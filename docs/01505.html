<html>
<head>
<title>Why It’s Time to Ditch the for…in Loop in JavaScript — The Best Ways to Iterate through Objects in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是时候抛弃JavaScript中的for…in循环了——这是在JS中迭代对象的最佳方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-its-time-to-ditch-the-for-in-loop-in-javascript-75327f74004d?source=collection_archive---------9-----------------------#2020-01-08">https://levelup.gitconnected.com/why-its-time-to-ditch-the-for-in-loop-in-javascript-75327f74004d?source=collection_archive---------9-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f560e87efb2e3b0aeb6b1e4c2c29154a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GuzhJOVcMVQV7sJ_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@juanpoe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">理查德·普莱斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5a52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从ES5.1开始，我们有了遍历对象属性的新特性。在过去，我们只有<code class="fe le lf lg lh b">for...in</code>循环来完成这个任务。</p><p id="a366" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看为什么遍历对象属性的新方法比<code class="fe le lf lg lh b">for...in</code>循环好得多。这包括从ES5.1开始提供的<code class="fe le lf lg lh b">Object.keys</code>方法，但在ES6中更新以支持符号，以及ES2017新增的<code class="fe le lf lg lh b">Object.entries</code>和<code class="fe le lf lg lh b">Object.values</code>方法。要循环符号键，我们有<code class="fe le lf lg lh b">Reflect.ownKeys</code>方法。</p><h1 id="9e63" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">for…in循环的特征</h1><p id="78b6" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">for...in</code>循环让我们遍历对象的非符号、可枚举属性。</p><p id="b9e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将以任意顺序迭代对象的属性。因此，我们不能依赖于对象的键被迭代的顺序。</p><p id="98d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe le lf lg lh b">delete</code>关键字删除的属性不会被迭代。如果在迭代过程中修改了一个属性，那么以后访问它时的值将是修改完成后的值。</p><p id="61ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在迭代过程中修改一个对象的属性是一个坏主意，因为上面提到的特征会造成混乱。</p><p id="249a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有些人也用它来遍历数组，因为<code class="fe le lf lg lh b">for...in</code>会像对象的键一样获取数组的索引。然而，这又是一个坏主意，因为订单没有保证。</p><p id="899d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它迭代自己的属性及其原型的属性。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3445" class="mt lj it lh b gy mu mv l mw mx">const person = {<br/>  name: 'Joe'<br/>};<br/>const employee = {<br/>  title: 'waiter'<br/>};</span><span id="96c7" class="mt lj it lh b gy my mv l mw mx">employee.__proto__ = person;<br/>for (let prop in employee) {<br/>  console.log(prop);</span><span id="b6a8" class="mt lj it lh b gy my mv l mw mx">}</span></pre><p id="bbe1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们看到<code class="fe le lf lg lh b">for...in</code>循环中的<code class="fe le lf lg lh b">console.log</code>记录了<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">title</code>。</p><p id="bace" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能不希望这样，所以我们必须从一个对象的原型使用<code class="fe le lf lg lh b">hasOwnProperty</code>方法来检查属性是否实际上是一个对象自己的属性，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7b5f" class="mt lj it lh b gy mu mv l mw mx">const person = {<br/>  name: 'Joe'<br/>};<br/>const employee = {<br/>  title: 'waiter'<br/>};</span><span id="993e" class="mt lj it lh b gy my mv l mw mx">employee.__proto__ = person;<br/>for (let prop in employee) {<br/>  if (employee.hasOwnProperty(prop)) {<br/>    console.log(prop);<br/>  }<br/>}</span></pre><p id="cf91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，没有<code class="fe le lf lg lh b">hasOwnProperty</code>,<code class="fe le lf lg lh b">for...in</code>循环遍历一个对象的所有自己的和继承的属性。</p><p id="3b7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不太方便，因为这通常不是我们想要的。</p><p id="ecbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，由于<code class="fe le lf lg lh b">for...in</code>循环是在ES6之前引入的，并且从未更新过，所以它不知道符号属性键，所以如果我们有以下对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8655" class="mt lj it lh b gy mu mv l mw mx">const foo = {<br/>  [Symbol('foo')]: 'Joe'<br/>};</span></pre><p id="c797" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们试图如下循环遍历<code class="fe le lf lg lh b">foo</code>对象时:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="83f2" class="mt lj it lh b gy mu mv l mw mx">for (let prop in foo) {<br/>  console.log(prop);<br/>}</span></pre><p id="755d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们什么也得不到。</p><h1 id="9d34" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">对于…在回路中的性能</h1><p id="4572" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">for...in</code>环路也很慢。这是因为循环必须检查每个属性在原型链上是否都是可枚举的，然后返回每个可枚举属性的名称。</p><p id="dbc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让它与任意对象一起工作是困难的，因为结构不是恒定的。它必须检查每个键及其原型的键，以便对每个属性进行检查。因此，这比一个简单的<code class="fe le lf lg lh b">for</code>循环包含了更多的计算。</p><p id="97fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，数组或对象越大，这个问题就越严重，但是在这些情况下，还是要记住这一点。</p><h1 id="3507" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">遍历对象属性的新方法</h1><h2 id="571e" class="mt lj it bd lk mz na dn lo nb nc dp ls kr nd ne lw kv nf ng ma kz nh ni me nj bi translated">对象.键</h2><p id="bcaf" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">从ES5.1开始，我们有了<code class="fe le lf lg lh b">Object.keys</code>方法来获取对象的键并将它们作为数组返回。</p><p id="48fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">密钥按以下顺序返回。首先是按数字升序排列的整数索引键。然后是所有其他的字符串键，按照它们被添加到对象的顺序。</p><p id="4a38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe le lf lg lh b">for...in</code>循环不同，返回键的顺序有一些推理。由于<code class="fe le lf lg lh b">Object.keys</code>返回一个数组，我们可以按照自己喜欢的方式对它进行排序。</p><p id="22f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<code class="fe le lf lg lh b">for...of</code>循环或<code class="fe le lf lg lh b">forEach</code>方法来编写一个更干净的循环。</p><p id="f1ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不必再使用<code class="fe le lf lg lh b">hasOwnProperty</code>来检查一个对象的属性是否是它自己的属性。</p><p id="2c72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe le lf lg lh b">Object.keys</code>随ES6一起发布，所以支持符号。</p><p id="1a71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设我们拥有与上述示例相同的继承对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="594f" class="mt lj it lh b gy mu mv l mw mx">const person = {<br/>  name: 'Joe'<br/>};<br/>const employee = {<br/>  title: 'waiter'<br/>};</span><span id="bc05" class="mt lj it lh b gy my mv l mw mx">employee.__proto__ = person;</span></pre><p id="73ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下循环:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4ca2" class="mt lj it lh b gy mu mv l mw mx">for (let prop of Object.keys(employee)) {<br/>  console.log(prop);<br/>}</span></pre><p id="ad98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只从上面的循环中返回<code class="fe le lf lg lh b">'title'</code>。</p><p id="df7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">排序如下所示。如果我们有以下对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3c36" class="mt lj it lh b gy mu mv l mw mx">const foo = {<br/>  a: 1,<br/>  b: 2,<br/>  1: 'a',<br/>  2: 'b',<br/>  3: 'c',<br/>};</span></pre><p id="57b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们用以下代码循环遍历这些键时:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="748a" class="mt lj it lh b gy mu mv l mw mx">for (let prop of Object.keys(foo)) {<br/>  console.log(prop);<br/>}</span></pre><p id="06d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0509" class="mt lj it lh b gy mu mv l mw mx">1<br/>2<br/>3<br/>a<br/>b</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/e86792427fc5021ca3f9792342a9204e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GdRvjI2c2Zu62cQn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@amitjain0106?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Amit Jain </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="c4af" class="mt lj it bd lk mz na dn lo nb nc dp ls kr nd ne lw kv nf ng ma kz nh ni me nj bi translated">对象.值</h2><p id="9984" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">要从没有继承属性的对象中获取值，我们可以使用<code class="fe le lf lg lh b">Object.values()</code>方法。</p><p id="a2ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代的顺序与<code class="fe le lf lg lh b">Object.keys</code>相同，但是我们得到的是值而不是键。</p><p id="076d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定以下对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="69ec" class="mt lj it lh b gy mu mv l mw mx">const person = {<br/>  name: 'Joe'<br/>};<br/>const employee = {<br/>  title: 'waiter'<br/>};<br/>employee.__proto__ = person;</span></pre><p id="bdfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在没有<code class="fe le lf lg lh b">person</code>属性值的情况下遍历<code class="fe le lf lg lh b">employee</code>自己的值，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ab3e" class="mt lj it lh b gy mu mv l mw mx">for (let val of Object.values(employee)) {<br/>  console.log(val);<br/>}</span></pre><p id="fa52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该只从<code class="fe le lf lg lh b">console.log</code>那里得到<code class="fe le lf lg lh b">'waiter'</code>。</p><p id="1601" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Object.values</code>方法是ES2017的新功能。</p><h2 id="090c" class="mt lj it bd lk mz na dn lo nb nc dp ls kr nd ne lw kv nf ng ma kz nh ni me nj bi translated">对象.条目</h2><p id="9602" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">为了在一个循环中获得键值对，我们可以使用<code class="fe le lf lg lh b">Object.entries</code>方法。像上面提到的其他方法一样，它接受一个对象作为参数。</p><p id="6e02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法返回一个数组，该数组在数组中具有其自身属性的键值对。</p><p id="54bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设我们有以下对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="853f" class="mt lj it lh b gy mu mv l mw mx">const person = {<br/>  name: 'Joe'<br/>};<br/>const employee = {<br/>  title: 'waiter'<br/>};<br/>employee.__proto__ = person;</span></pre><p id="5cfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用<code class="fe le lf lg lh b">Object.entries</code>方法:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6b9b" class="mt lj it lh b gy mu mv l mw mx">for (let entry of Object.entries(employee)) {<br/>  console.log(entry);<br/>}</span></pre><p id="274d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们回来了:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="72db" class="mt lj it lh b gy mu mv l mw mx">["title", "waiter"]</span></pre><p id="beb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那就是键和属性的值分别在<code class="fe le lf lg lh b">employee</code>中。</p><h2 id="885d" class="mt lj it bd lk mz na dn lo nb nc dp ls kr nd ne lw kv nf ng ma kz nh ni me nj bi translated">Reflect.ownKeys</h2><p id="ee3f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">没有一个<code class="fe le lf lg lh b">Object</code>方法支持符号。要循环遍历带有符号键的对象，我们可以使用<code class="fe le lf lg lh b">Reflect.ownKeys</code>方法。像<code class="fe le lf lg lh b">Object.keys</code>一样，它获取对象自身属性的键，但也支持符号键。它还返回一个键数组。像<code class="fe le lf lg lh b">Object.keys.</code>一样也支持字符串键</p><p id="ec23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设我们有以下对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a7eb" class="mt lj it lh b gy mu mv l mw mx">const foo = {<br/>  [Symbol('foo')]: 'Joe'<br/>};</span></pre><p id="a248" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">Reflect.ownKeys</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7cf6" class="mt lj it lh b gy mu mv l mw mx">for (let prop of Reflect.ownKeys(foo)) {<br/>  console.log(prop);<br/>}</span></pre><p id="6be6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们再回来<code class="fe le lf lg lh b">Symbol(foo)</code>。</p><p id="9683" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们编写以下循环，从符号键获取值也是可行的:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="587e" class="mt lj it lh b gy mu mv l mw mx">for (let prop of Reflect.ownKeys(foo)) {<br/>  console.log(foo[prop]);<br/>}</span></pre><p id="dfae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们再回来<code class="fe le lf lg lh b">'Joe’</code>。</p><p id="d1e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是ES6的新方法。</p><p id="fcc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，从ES5.1或更高版本开始，我们有很多替代方法来使用<code class="fe le lf lg lh b">for...in</code>循环遍历对象的属性。在<code class="fe le lf lg lh b">for...in</code>循环中唯一有用的特性是遍历对象的继承属性。</p><p id="33d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们应该使用<code class="fe le lf lg lh b">Object.keys</code>、<code class="fe le lf lg lh b">Object.entries</code>、<code class="fe le lf lg lh b">Object.values</code>，因为它们都返回键或值的数组，或者两者都返回。此外，顺序是可预测的，不像<code class="fe le lf lg lh b">for...in</code>循环。因为数组是返回的，所以我们可以对它们进行排序，并以我们喜欢的方式遍历属性或值。</p><p id="b191" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要循环符号键，我们可以使用<code class="fe le lf lg lh b">Reflect.ownKeys</code>方法。</p></div></div>    
</body>
</html>