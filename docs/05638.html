<html>
<head>
<title>Polymorphism in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本中的多态性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/polymorphism-in-typescript-59fad77f8cd7?source=collection_archive---------2-----------------------#2020-09-17">https://levelup.gitconnected.com/polymorphism-in-typescript-59fad77f8cd7?source=collection_archive---------2-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e59" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">FP和OOP联手对抗代码冗余</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2c366553dacd97dbe977eb9f28393211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNl3M3aPcCk0xaroZuRbXw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Robert Euro Djojoseputro 在<a class="ae ky" href="https://unsplash.com/s/photos/shapes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们常常认为面向对象编程<strong class="lb iu"> </strong>和函数式编程<strong class="lb iu"> </strong>是互斥的，这是可以理解的；任何涉及这两者的讨论往往会变成一场以竞争为中心主题的辩论。但事实证明，在某些情况下，我们可以利用这两种范式来获得两个世界的最佳效果。Typescript <strong class="lb iu"> </strong>中的<strong class="lb iu">特殊多态性</strong>就是这样一种情况。</p><h1 id="5198" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">场景</h1><p id="005a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">考虑我们开发内联样式库的情况。该库具有对应于不同CSS数据类型的不同类型，例如:</p><ul class=""><li id="8a68" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">RGB</li><li id="3085" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">RGBA</li><li id="7191" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">high-speedlaunch高速快艇</li><li id="74e3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">high-strength low-alloy 高力低合金</li><li id="498d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">十六进制</li><li id="d1d6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">长度</li><li id="5fbf" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">百分率</li><li id="f14e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">分贝</li><li id="c1ba" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">时间</li><li id="d995" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">转换</li></ul><p id="7829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，这些内联样式对象的接口将只支持一个属性:<code class="fe ng nh ni nj b">color</code>属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/357389e4eb72b6021b0f7d26cfa89679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJOk2LsQLI8b0a_jZSkIIw.png"/></div></div></figure><p id="d1c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的照片所示，我们的接口中的color属性的值有一个tagged-union类型，它由一个<code class="fe ng nh ni nj b">stringLiteral</code>类型和五个其他自定义类型组成，表示为Javascript对象，并模仿我的前一篇文章中的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/nominal-typing-in-typescript-c712e7116006">描述的名义类型模型。</a></p><p id="ad2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在库代码的范围内，这些类型已经被很好地理解了，它们的值可以被相应地操作，但是在这些范围之外，比如说在React中，它们没有任何意义。为了让React利用这些值进行样式化，我们需要将它们序列化为<code class="fe ng nh ni nj b">string</code>或<code class="fe ng nh ni nj b">number</code>值。</p><h1 id="2a2e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题是</h1><p id="a20a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">基于我们的场景，我们需要一个将颜色值序列化为<code class="fe ng nh ni nj b">string</code>值的函数。有一种方法可以这样做:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/128ee25854164e9f235cc61441d8cc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoyXx0BK1Din0RFEViegMw.png"/></div></div></figure><p id="765a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没什么特别的。我们创建一些小函数，每个函数负责序列化一个子类型(颜色的一个子类型)，然后创建一个函数来检查传递的参数的类型(使用类型保护)并调用与该类型相关联的函数。<strong class="lb iu">这种方法导致了多余的代码和增加的导入数量(在本例中，我们使用了五个导入)。</strong></p><p id="3f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Haskell中，您将使用临时多态性来处理这种情况。在相同的名称下，不同的实现与不同的类型相关联，Haskell会根据参数的类型自动为您选择合适的实现。如果Typescript拥有它，它将“有点”看起来像这样(当然，没有错误):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/3c204c75fbd9b9d1c8a85678680528b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5T5KwqMEFp5fZIKK70YGw.png"/></div></div></figure><p id="b732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，TS的编译器抱怨“重复的函数实现”。出现此错误是因为在同一名称下可以有多个签名，但只允许一个实现。这个实现负责找到合适的函数来调用。因此，要修复该错误，我们需要执行以下操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/ee9ee26e4551af1002452a2651495f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oa5DusT9wKQHT0LC-TeRGw.png"/></div></div></figure><p id="e2d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一文不值！我们的情况和以前相似，只是更糟，代码更多。Typescript调用这个<strong class="lb iu">函数重载</strong>。它在许多情况下都很方便，但在本例中不方便。</p><blockquote class="nn"><p id="545a" class="no np it bd nq nr ns nt nu nv nw lu dk translated">在Typescript中，同一名称下可以有多个签名，但只允许一个实现与该名称关联</p></blockquote><p id="402c" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">TS中的功能超载并没有如预期的那样起作用，你感到悲伤和被背叛，你脑袋里的声音在催促你去接触黑暗的一面，在那里所有可怜的物体都在因突变和方法绑定而痛苦地尖叫。但是，就在你迈出面向对象编程世界的第一步之前，我——你的守护天使——出现并阻止了你，为你提供了一个中间地带，一个安全的地方，在那里你的功能可以和你的对象一起在一个纯净的氛围中茁壮成长。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/6827e778719228de0738e41f2f40e11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRUkeuzwVLIroJ_qjIdZ1Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">面向对象程序世界一瞥</figcaption></figure><h1 id="b238" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决方案</h1><p id="9789" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我解决这个问题的方法是<strong class="lb iu">保留从OOP世界中窃取的“类型化”对象</strong>中的函数引用。不要惊慌，这种方法不涉及任何状态，并且该功能仍然是透明的。该参考只是为了方便和快速地访问适当的功能，并消除代码冗余。我们可以通过添加一个其值是函数引用的属性来实现，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6727efc36632612226a67527e958b4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMbiqP0WzLOh7vpKJPscSQ.png"/></div></div></figure><p id="3117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以忽略属性<code class="fe ng nh ni nj b">type</code>和<code class="fe ng nh ni nj b">data</code>。<code class="fe ng nh ni nj b">rgb</code>函数只是一个工厂函数，它创建类型为<code class="fe ng nh ni nj b">RGB</code>的值。生成的对象将具有指向函数<code class="fe ng nh ni nj b">serializeRGB</code>的属性<code class="fe ng nh ni nj b">serialize</code>。按照这种模式和我们的其他定制类型，我们现在可以将我们的<code class="fe ng nh ni nj b">serializeColor</code>函数重构为以下形式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/4f2e7b6a509b77e7d9259d898903ad61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4l5-S1HOaqBxTz6H5jWMdg.png"/></div></div></figure><p id="dd77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每种类型都负责指向自己的序列化行为实现，不需要导入或手动类型检查。</p><p id="6e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你同意我的观点，这比之前的版本更简洁。如果你没有，那也没关系。我们都有权有自己的观点，只要留下评论，我会让连姆·尼森找到你，让你相信我的观点。</p><blockquote class="nn"><p id="24b0" class="no np it bd nq nr ns nt nu nv nw lu dk translated">我们可以在对象内部保留对函数的引用，以便将特定类型与重载行为相关联，而不会破坏函数代码的纯洁性。</p></blockquote><h1 id="8aca" class="lv lw it bd lx ly lz ma mb mc md me mf jz of ka mh kc og kd mj kf oh kg ml mm bi translated">概述</h1><ul class=""><li id="fe95" class="ms mt it lb b lc mn lf mo li oi lm oj lq ok lu mx my mz na bi translated">在不破坏其纯粹性的情况下，将OOP的一些原则引入我们的功能代码是可能的。</li><li id="922f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">使用引用是在TS中实现类似ad-hoc的多态性的一个很好的方法。</li></ul><p id="68ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在本文中使用的场景实际上是我在项目中处理的一个场景的简化版本，<a class="ae ky" href="https://www.rosebox.dev/" rel="noopener ugc nofollow" target="_blank"> Rosebox </a>，这是我用Typescript编写的一个样式库。看看这个。</p></div></div>    
</body>
</html>