<html>
<head>
<title>Microservices with Node.js, Kubernetes, and RabbitMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js、Kubernetes和RabbitMQ的微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/microservices-with-node-js-kubernetes-and-rabbitmq-c52091464c5d?source=collection_archive---------2-----------------------#2022-07-27">https://levelup.gitconnected.com/microservices-with-node-js-kubernetes-and-rabbitmq-c52091464c5d?source=collection_archive---------2-----------------------#2022-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="deab" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="d16c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">微服务是一个独立的单元，它与许多其他单元一起构成了一个大型应用程序。通过将你的应用分成小单元，它的每一部分都可以独立部署和扩展，可以由不同的团队用不同的编程语言编写，并且可以单独测试。</p><p id="baea" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">微服务架构意味着您的应用程序由许多较小的独立应用程序组成，这些应用程序能够在自己的内存空间中运行，并且可以在潜在的许多单独的机器上相互独立地扩展。</p><h1 id="0f8d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Kubernetes概述</h1><p id="e263" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">kubernetes(“K8s”)是一个用于自动化和管理容器编排的开源系统，它源于谷歌的Borg，现在由T2云计算基金会维护。</p><p id="05be" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">凭借专注于开发人员和DevOps工程师的流畅用户体验，以及一套令人印象深刻的编排功能，包括自动推出和回滚、服务发现、负载平衡以及秘密和配置管理，Kubernetes在短时间内获得了大量支持。与所有主要云提供商的集成使Kubernetes可移植到一系列基础设施。</p><h1 id="c2b8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">库伯内特建筑</h1><p id="186b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Kubernetes基于主节点的架构有助于实现快速的水平扩展。网络功能有助于促进Kubernetes各种元素之间的快速通信。</p><p id="a1d3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">以下是Kubernetes架构的核心组件:</p><ul class=""><li id="f773" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated"><strong class="kn ir"> Pod: </strong>由Kubernetes创建和管理的最小可部署单元，Pod是一组一个或多个容器。Pod中的容器共享一个IP地址，可以通过本地主机相互访问，并共享对卷的访问。</li><li id="8b2e" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><strong class="kn ir">节点:</strong>Kubernetes中的一个工作机。可能是虚拟机或物理机，并附带运行<em class="md"> Pods </em>所需的服务。</li><li id="a863" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><strong class="kn ir">服务:</strong>一个抽象，它定义了一组逻辑pod和访问它们的策略。为Pod副本分配固定的IP地址，允许其他Pod或服务与其通信。</li><li id="bd90" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><strong class="kn ir"> ReplicaSet: </strong>确保指定数量的Pod副本在任何给定时间运行。K8s建议使用部署而不是直接操作ReplicaSet对象，除非您需要自定义更新编排或者根本不需要更新。</li><li id="36c3" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><strong class="kn ir">部署:</strong>为pod和副本集提供声明性更新的控制器。</li><li id="4521" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated"><strong class="kn ir">命名空间:</strong>由同一个物理集群支持的虚拟集群。在多个用户之间划分集群资源的方法，以及将授权和策略附加到给定集群的子部分的机制。</li></ul><h1 id="db25" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">应用架构</h1><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/dae30df658e2e964facfd52258f6c4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wP6XPHi9R6zOgLUSJbTDGg.png"/></div></div></figure><p id="ce38" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">该应用程序是一个迷你电子商务后端，能够购买和创建产品。可以一次购买多种产品，并生成相应的订单。</p><p id="1385" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">该应用程序将由三个独立的服务组成:验证用户的Auth服务，创建和购买产品的Products服务，以及用户可以通过其访问订单的Order服务。</p><h1 id="96ea" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">开始</h1><p id="4f15" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">products/index.js将由两条路径组成，一条从数据库获取所有产品，另一条购买产品。后者将触发order微服务创建一个新的order对象，并将其保存到数据库中，同时通过响应将其发送给客户端。</p><pre class="mf mg mh mi gt mq mr ms mt aw mu bi"><span id="daea" class="mv jo iq mr b gy mw mx l my mz">const express = require('express');<br/>require('express-async-errors');<br/>const sequelize = require('./database');<br/>const isAuthenticated = require('./isAuthenticated');<br/>const Product = require('./product.model');<br/>const amqp = require('amqplib');<br/>const Sequelize = require('sequelize');<br/><br/>let channel;<br/><br/>async function connect() {<br/>  const amqpServer = process.env.RABBITMQ_URL;<br/>  const connection = await amqp.connect(amqpServer);<br/>  channel = await connection.createChannel();<br/>  await channel.assertQueue('PRODUCT');<br/>}<br/><br/>connect().catch(error =&gt; {<br/>  console.error('Unable to connect to the Rabbit MQ:', error);<br/>  process.exit(1);<br/>});<br/><br/>const app = express();<br/><br/>app.use(express.json());<br/><br/>const port = +process.env.PORT ?? 3002;<br/><br/>app.listen(port, () =&gt; {<br/>  console.log(`Products Service at ${port}`);<br/>});<br/><br/>app.get('/products', async (req, res) =&gt; {<br/>  const results = await Product.findAll();<br/><br/>  res.status(200).json(results);<br/>});<br/><br/>app.post('/products', isAuthenticated, async (req, res) =&gt; {<br/>  const { name, price, description, imageURL } = req.body;<br/><br/>  const product = await Product.create({<br/>    name,<br/>    price,<br/>    description,<br/>    imageURL,<br/>    creator: req.user.email,<br/>  });<br/><br/>  res.status(200).json(product);<br/>});<br/><br/>app.post('/products/buy', isAuthenticated, async (req, res) =&gt; {<br/>  const { ids } = req.body;<br/>  const products = await Product.findAll({<br/>    where: {<br/>      id: {<br/>        [Sequelize.Op.in]: ids,<br/>      },<br/>    },<br/>  });<br/>  let order;<br/><br/>  channel.sendToQueue(<br/>    'ORDER',<br/>    Buffer.from(<br/>      JSON.stringify({<br/>        products,<br/>        userEmail: req.user.email,<br/>      })<br/>    )<br/>  );<br/>  await channel.consume('PRODUCT', data =&gt; {<br/>    order = JSON.parse(data.content);<br/>  });<br/>  res.json(order);<br/>});<br/><br/>sequelize.sync();</span></pre><p id="d555" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">orders/index.js将侦听“order”消息，一旦收到该消息，它将获取买方提供的电子邮件ID和所有产品ID，并使用该数据生成一个ORDER对象。然后，订单服务将通过RabbitMQ将这些数据发送回产品服务。</p><pre class="mf mg mh mi gt mq mr ms mt aw mu bi"><span id="09b4" class="mv jo iq mr b gy mw mx l my mz">const express = require('express');<br/>require('express-async-errors');<br/>const sequelize = require('./database');<br/>const isAuthenticated = require('./isAuthenticated');<br/>const Order = require('./order.model.js');<br/>const amqp = require('amqplib');<br/><br/>let channel;<br/><br/>async function createOrder(products, userEmail) {<br/>  let total = 0;<br/>  for (let t = 0; t &lt; products.length; ++t) {<br/>    total += +products[t].price;<br/>  }<br/><br/>  products = products.map(product =&gt; {<br/>    return product.id;<br/>  });<br/><br/>  const newOrder = await Order.create({<br/>    products,<br/>    creator: userEmail,<br/>    totalPrice: total,<br/>  });<br/><br/>  return newOrder;<br/>}<br/><br/>async function connect() {<br/>  const amqpServer = process.env.RABBITMQ_URL;<br/>  const connection = await amqp.connect(amqpServer);<br/>  channel = await connection.createChannel();<br/>  await channel.assertQueue('ORDER');<br/>}<br/><br/>connect()<br/>  .then(() =&gt; {<br/>    channel.consume('ORDER', data =&gt; {<br/>      console.log('Consuming ORDER service');<br/>      const { products, userEmail } = JSON.parse(data.content);<br/>      createOrder(products, userEmail)<br/>        .then(newOrder =&gt; {<br/>          channel.ack(data);<br/>          channel.sendToQueue(<br/>            'PRODUCT',<br/>            Buffer.from(JSON.stringify({ newOrder }))<br/>          );<br/>        })<br/>        .catch(err =&gt; {<br/>          console.log(err);<br/>        });<br/>    });<br/>  })<br/>  .catch(error =&gt; {<br/>    console.error('Unable to connect to the Rabbit MQ:', error);<br/>    process.exit(1);<br/>  });<br/><br/>const app = express();<br/><br/>app.use(express.json());<br/><br/>const port = +process.env.PORT ?? 3003;<br/><br/>app.listen(port, () =&gt; {<br/>  console.log(`Orders Service at ${port}`);<br/>});<br/><br/>app.get('/orders', async (req, res) =&gt; {<br/>  const results = await Order.findAll();<br/><br/>  res.status(200).json(results);<br/>});<br/><br/>sequelize.sync();</span></pre><p id="3a79" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如您所见，这些服务是完全相互独立的。微服务架构可能是一个有用的工具，但是，在较小的项目中，这种架构的应用可能会引入某些复杂性，如代码重复和不必要的复杂性。因此，这种架构经常被推荐给大型项目，在这些项目中有一个庞大的工程师团队在工作。您可以在下面查看上述代码的完整存储库。</p><div class="na nb gp gr nc nd"><a href="https://github.com/ArjanAswal/nodejs-kubernetes-microservices" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">GitHub-ArjanAswal/nodejs-kubernetes-micro services:Sample node . js项目展示了如何创建…</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">示例Node.js项目展示了如何使用Kubernetes的微服务架构创建节点应用程序。- GitHub …</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr mo nd"/></div></div></a></div></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="a0a3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="7ab5" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="43c7" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">📰更多内容请查看<a class="ae lo" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="1dc6" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">🔔关注我们:<a class="ae lo" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae lo" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae lo" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="f841" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">🚀👉<a class="ae lo" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>