<html>
<head>
<title>How to Rewrite your Code to Achieve More Flexible Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何重写代码以实现更灵活的设计</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-rewrite-your-code-to-achieve-more-flexible-design-3c86dad822e?source=collection_archive---------7-----------------------#2020-05-27">https://levelup.gitconnected.com/how-to-rewrite-your-code-to-achieve-more-flexible-design-3c86dad822e?source=collection_archive---------7-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ace3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">干净的代码和重构|固体系列</h2><div class=""/><div class=""><h2 id="68fe" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">终极指南，举例说明如何使用单一责任原则打破等级和分离问题</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/513461976a641b7c8c897d0e4145218b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Q4XZtEsINjeQPmjRxANoA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">干净代码 <em class="li">是一门软件开发学科，旨在通过引入实践、原则和模式来提高开发者的编程技能，从而提高IT公司的活力。遵循</em>干净代码<em class="li">的程序员成为他们领域的专业人士和领导者。</em></figcaption></figure><p id="56d4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">单一责任原则或SRP代表这样一种思想，即每个类或模块应该有且只有一个<em class="mf">责任</em>。换句话说，每个类或模块都要做一件事，并且做好。</p><h1 id="e5d0" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">软件工程中的责任是什么意思？</h1><p id="4b22" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">罗伯特·c·马丁把责任定义为改变的理由。不要把它和我之前在博客中提到的改变软件的四个主要原因相混淆。</p><div class="nd ne gp gr nf ng"><a href="https://medium.com/swlh/four-reason-to-change-your-software-bf535916152d" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd jd gy z fp nl fr fs nm fu fw jc bi translated">更换软件的四个理由</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">Michael Feathers在《有效使用遗留代码》一书中定义了更改代码的四个主要原因。我…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu lb ng"/></div></div></a></div><p id="0604" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个<em class="mf">改变</em>的原因更多的是和模块或者应用特性有关。在理想情况下，一个特性的行为改变意味着一个类或模块要修改。</p><h1 id="079f" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">Unix中的SRP</h1><p id="6ab2" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">SRP是软件设计中一个众所周知的原则，我们几十年前就知道它非常有效。</p><p id="8ade" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><em class="mf"> Unix </em>就是基于这种做一件事的原则，并且做得很好。<em class="mf"> Unix </em>基于命令行，所以每个命令都是一个小的可执行程序。它有办法将这些可执行文件组合成更大规模的程序。</p><p id="b23d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">Unix的成功延续了Linux的成功，所以我们知道有一些例子说明这个原则可以让系统变得非常稳定和长寿。</p><p id="34e6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果你更感兴趣的话，我找到了一个包含1970年以来历史提交的<a class="ae lh" href="https://github.com/dspinellis/unix-history-repo" rel="noopener ugc nofollow" target="_blank">库</a>。</p><h1 id="3e59" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">为什么SRP很难实现？</h1><p id="533e" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">在寻找答案的过程中，我看到了来自用户Pawan Bhadauria的一个很棒的Quora答案，我想引用其中的一段。</p><blockquote class="nv"><p id="d11b" class="nw nx it bd ny nz oa ob oc od oe me dk translated">考虑下面的句子:“Tihs snetnece是hrad到raed”。</p><p id="3c96" class="nw nx it bd ny nz oa ob oc od oe me dk translated">我敢打赌，你能读懂这个句子，因为你是把这个单词作为一个整体来理解的，而不是把每个字母连在一起，然后用它造一个句子。虽然它与原理没有直接关系，但让我们一瞥大脑是如何处理事物的。我们的大脑非常善于观察一系列行为，并把它们组合在一起，即使这些行为构成了不同的责任。</p></blockquote><p id="7b91" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated">我们倾向于根据我们的本性对行为进行分组。人脑的力量也是开发者在尝试应用SRP时的克星。</p><h1 id="a0d9" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">违规指标</h1><p id="2e71" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">最重要的指标是类或函数的大小。<em class="mf">代码的物理行数</em>测量函数大小。另一方面， <em class="mf">职责的<em class="mf">数量</em>衡量班级规模。</em></p><blockquote class="nv"><p id="f454" class="nw nx it bd ny nz oa ob oc od oe me dk translated"><em class="li">“班级的首要原则是规模要小。班级的第二条规则是他们应该比那个小。”—罗伯特·马丁</em></p></blockquote><p id="596d" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated">正确命名类的困难也是指标之一。该名称最长应为25个字符，不要使用“如果”、“和”、“或”或“但是”等词语。</p><p id="7b20" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有时，命名类的问题通过提出一个观点并使用程序员想到的最常见的名字来结束，如<code class="fe ok ol om on b">OrderService.</code></p><p id="67ec" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">订单从装筐到收货的处理过程，不能用这么简单的名字来定义。</p><h1 id="9143" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">辅导的</h1><h2 id="02f8" class="oo mh it bd mi op oq dn mm or os dp mq ls ot ou ms lw ov ow mu ma ox oy mw iz bi translated">先决条件</h2><p id="51d4" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">读者应该对<em class="mf">面向对象编程或</em> OOP有基本的了解。基本了解<em class="mf">单元测试</em>也是合适的，但不是必须的。我是用C#语言编程的，但Java或其他OOP语言开发人员理解这个概念应该没有问题。</p><h2 id="5d16" class="oo mh it bd mi op oq dn mm or os dp mq ls ot ou ms lw ov ow mu ma ox oy mw iz bi translated">项目介绍</h2><p id="5212" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">存储库由两个项目组成。第一个是名为<code class="fe ok ol om on b">BusinessLogic.</code>的类库，它包括两个文件夹；<code class="fe ok ol om on b">Before</code>和<code class="fe ok ol om on b">After.</code></p><p id="dbd2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">文件夹<code class="fe ok ol om on b">Before</code>包含类<code class="fe ok ol om on b">FileStore</code>，它负责将消息存储到文本文件中。</p><p id="8c66" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">文件夹<code class="fe ok ol om on b">After</code>包含由三个职责完全相同的类组成的模块，作为一个<code class="fe ok ol om on b">Before/FileStore</code>类。目录的内容是应用SRP过程的结果表示。</p><p id="675c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">第二个项目<code class="fe ok ol om on b">Tests</code>也有两个同名的文件夹。每个文件夹都有一个包含完全相同的单元测试的类。测试类<code class="fe ok ol om on b">Before/FileStoreUnitTests</code>几乎与测试类<code class="fe ok ol om on b">After/MessageStoreUnitTests,</code>相同，但是它的测试针对的是不同的被测系统<a class="ae lh" href="https://en.m.wikipedia.org/wiki/System_under_test" rel="noopener ugc nofollow" target="_blank">顾名思义。</a></p><h2 id="7bc2" class="oo mh it bd mi op oq dn mm or os dp mq ls ot ou ms lw ov ow mu ma ox oy mw iz bi translated">确定责任</h2><p id="753b" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">要点如下图展示了这个职业的样子。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://github.com/DannyRusnok/Single.Responsibility.Principle.Example/blob/master/Single.Responsibility.Principle.Example/Before/FileStore.cs" rel="noopener ugc nofollow" target="_blank"> FileStore.cs </a></figcaption></figure><p id="9886" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">你们中的大多数人都能识别出文件存储类的职责是什么。首先，你应该想到的是<em class="mf">储存信息</em>。</p><p id="ac54" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">另一个更明显的职责是<em class="mf">日志</em>。命令方法<code class="fe ok ol om on b">Read</code>和<code class="fe ok ol om on b">Save</code>都会调用<a class="ae lh" href="https://nlog-project.org/" rel="noopener ugc nofollow" target="_blank"> NLog </a>函数来记录当前发生的事情。</p><p id="0a34" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后一个不太清楚，所以我会告诉你。这就是我所说的<em class="mf">编排</em>。控制前面两个方面如何相互作用的方式也是责任。</p><p id="b5e8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">就是这样！我们确定了所有三个，让我们重复一遍。</p><ul class=""><li id="e0de" class="pb pc it ll b lm ln lp lq ls pd lw pe ma pf me pg ph pi pj bi translated">存储消息</li><li id="adac" class="pb pc it ll b lm pk lp pl ls pm lw pn ma po me pg ph pi pj bi translated">记录事件</li><li id="d5ea" class="pb pc it ll b lm pk lp pl ls pm lw pn ma po me pg ph pi pj bi translated">协调互动</li></ul><h2 id="74b6" class="oo mh it bd mi op oq dn mm or os dp mq ls ot ou ms lw ov ow mu ma ox oy mw iz bi translated">下课</h2><p id="a89f" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">打破类实际上是另一个众所周知的原则的应用，叫做<a class="ae lh" href="https://en.m.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"><em class="mf"/></a>关注点分离。</p><p id="9a15" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我喜欢架构导师维克多·凯恩对“什么是软件工程中的关注点分离？”这个问题的回答</p><p id="cfee" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我来引用一下答案的开头；</p><blockquote class="nv"><p id="16dd" class="nw nx it bd ny nz oa ob oc od oe me dk translated">IT中关注点分离的哲学旨在防止不同领域“关注”的代码之间的“病态”依赖，同时试图将所有与单个“关注”相关的代码隔离。</p></blockquote><p id="58d7" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated">"..隔离所有与<em class="mf">单一关注点</em>相关的代码。”听起来很熟悉吧？现在，让我们打破<code class="fe ok ol om on b">FileStore.</code></p><p id="cb84" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我从提取<em class="mf">日志</em>关注点开始。新的<code class="fe ok ol om on b">StoreLogger</code>类封装了关于将事件记录到其方法中的实现细节。<code class="fe ok ol om on b">StoreLogger</code>的初始化是在<code class="fe ok ol om on b">FileStore</code>构造函数中进行的，方法是从与NLog函数调用之前相同的地方调用的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">FileStore.cs之前和之后的州际</figcaption></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://github.com/DannyRusnok/Single.Responsibility.Principle.Example/blob/master/Single.Responsibility.Principle.Example/After/StoreLogger.cs" rel="noopener ugc nofollow" target="_blank"> StoreLogger.cs </a></figcaption></figure><p id="ead7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，我们需要分离<em class="mf">存储消息</em>和<em class="mf">编排</em>。让我们在头脑中逻辑地分开两个实现细节；<em class="mf">存储</em>和<em class="mf">数据</em>。在我们的例子中，存储是一个文件系统，数据是消息。</p><p id="946d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们考虑依赖性时，似乎消息应该依赖于它的存储，但是存储不需要知道任何关于数据形式的信息。我们可以通过提取围绕消息的编排来实现它，并将对存储的关注放在<code class="fe ok ol om on b">FileStore.</code>上</p><p id="4379" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我把原来的<code class="fe ok ol om on b">FileStore</code>班分成了两个新的班；<code class="fe ok ol om on b">FileStore</code>和<code class="fe ok ol om on b">MessageStore.</code></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://github.com/DannyRusnok/Single.Responsibility.Principle.Example/blob/master/Single.Responsibility.Principle.Example/After/FileStore.cs" rel="noopener ugc nofollow" target="_blank">在/FileStore.cs之后</a></figcaption></figure><p id="2a2a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe ok ol om on b">MessageStore</code>协调消息、日志和存储过程。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://github.com/DannyRusnok/Single.Responsibility.Principle.Example/blob/master/Single.Responsibility.Principle.Example/After/MessageStore.cs" rel="noopener ugc nofollow" target="_blank"> MessageStore.cs </a></figcaption></figure><p id="54d2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这一次，我坚持在名称中使用“store”这个词，因为它更精确。有时，我很难为负责编排的类选择正确的名称。所以我通常选择“处理器”这个词，并添加一个前缀来定义职责——例如，<code class="fe ok ol om on b">MessageStoringProcessor.</code>这个名字听起来更准确。</p><p id="dad7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我很想听听你是如何处理这个问题的。</p><h1 id="8b89" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated">摘要</h1><p id="8ba9" class="pw-post-body-paragraph lj lk it ll b lm my kd lo lp mz kg lr ls na lu lv lw nb ly lz ma nc mc md me im bi translated">我们查看了<code class="fe ok ol om on b">FileStore</code>类，并确定了它的三个职责。首先，我们提取了最简单的一个，即<em class="mf">日志</em>职责。因此，我们将剩余的关注点<em class="mf">存储消息</em>和<em class="mf">编排</em>分离到两个新的类中；<code class="fe ok ol om on b">MessageStore</code>和<code class="fe ok ol om on b">FileStore.</code></p><p id="76e5" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">存储库还包含带有单元测试的项目，您可以尝试运行这些单元测试，并查看是否有任何丢弃的行为或功能。绿色测试将证明我们做得恰到好处。</p></div><div class="ab cl pp pq hx pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt ng"><a href="https://www.danielrusnok.com/daniel-rusnoks-newsletter" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd jd gy z fp nl fr fs nm fu fw jc bi translated">丹尼尔·鲁斯诺克的时事通讯</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">每个月我都会给你发一封电子邮件，列出我的最新文章。这当然是友好的联系…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">www.danielrusnok.com</p></div></div><div class="np l"><div class="pw l nr ns nt np nu lb ng"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://www.buymeacoffee.com/danielrusnok"><div class="gh gi px"><img src="../Images/88f0e07ab6797fc4fcd13ed7410af039.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*yzOQeIJSJCaRDN_oP5OidA.png"/></div></a></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://itixo.com"><div class="gh gi py"><img src="../Images/f3d94d9b86b4ee7080bab6d72172b50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:180/format:webp/1*mLQH7u1-b2HPVcLURnQ9NQ.png"/></div></a></figure></div></div>    
</body>
</html>