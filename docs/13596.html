<html>
<head>
<title>How to Setup a Lightweight Local Version for Airflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为气流设置一个轻量级的本地版本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-setup-a-lightweight-local-version-for-airflow-96feaab2e835?source=collection_archive---------1-----------------------#2022-09-19">https://levelup.gitconnected.com/how-to-setup-a-lightweight-local-version-for-airflow-96feaab2e835?source=collection_archive---------1-----------------------#2022-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="4230" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">由Docker和Docker组成</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/6a3732530f765b1d49d2f6b1ba28b93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/0*eMdKubccD4pWpgPu"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">忘记运行Airflow时的“低内存”问题(徽标取自<a class="ae la" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Airflow </a>和<a class="ae la" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a></figcaption></figure><p id="de02" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">本文由<a class="ae la" href="https://datatalks.club/" rel="noopener ugc nofollow" target="_blank"> DataTalksClub </a>在<a class="ae la" href="https://github.com/DataTalksClub/data-engineering-zoomcamp" rel="noopener ugc nofollow" target="_blank">数据工程师Zoomcamp </a>第一版的范围下创作。我将介绍我对最初提出的开发所做的一个技术变更，以在本地运行<strong class="ld iu"> Apache Airflow </strong>(参见<a class="ae la" href="https://medium.com/@lgsoliveira/what-means-to-run-one-software-locally-a8b556d6f34c" rel="noopener"> <em class="lz">什么是“在本地运行一个软件”</em> </a>)，并使用<strong class="ld iu"> Docker </strong>和<strong class="ld iu"> Docker Compose </strong>。正如在这个<a class="ae la" href="https://www.youtube.com/watch?v=A1p5LQ0zzaQ&amp;list=PL3MmuxUbc_hJed7dXYoJw8DoCuVHhGEQb&amp;index=23" rel="noopener ugc nofollow" target="_blank">视频</a>中看到的那样，这个改编后来被并入了DE Zoomcamp。</p><p id="91fc" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将在本文中讨论的内容:</p><ul class=""><li id="ec93" class="ma mb it ld b le lf li lj lm mc lq md lu me ly mf mg mh mi bi translated">什么是阿帕奇气流和Docker</li><li id="bedd" class="ma mb it ld b le mj li mk lm ml lq mm lu mn ly mf mg mh mi bi translated">如何设置轻量级Docker版本来运行气流</li><li id="0fe6" class="ma mb it ld b le mj li mk lm ml lq mm lu mn ly mf mg mh mi bi translated">这种设置更轻的原因</li></ul><p id="9b9b" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这不是一个关于Airflow或Docker的教程，而是一个关于如何设置一个要求较低的Docker环境版本来本地运行Airflow的解释。</p><p id="c70a" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在Docker容器内运行气流的“完全”建议版本是高度资源密集型的，因此推动了许多计算机/笔记本电脑(我的笔记本电脑的冷却风扇总是开着)。关于完整版本的更多信息，我建议你去看看上面提到的数据工程Zoomcamp和这篇由Leandro Bueno写的<a class="ae la" href="https://www.linkedin.com/pulse/airflow-o-que-%C3%A9-o-faz-hands-on-leandro-bueno/" rel="noopener ugc nofollow" target="_blank">文章</a>(葡萄牙语)。</p><h1 id="8c3e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.气流和Docker简介</h1><h1 id="5309" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.1阿帕奇气流</h1><p id="566f" class="pw-post-body-paragraph lb lc it ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly im bi translated">Apache Airflow是数据工程领域最著名的工具之一，因此我不会花太多时间来解释它。</p><p id="67b5" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该软件是一个开源的数据编制工具，允许通过连接<strong class="ld iu">有向无环图</strong> ( <strong class="ld iu"> DAG </strong> s)中的几个进程来建立完整的端到端管道。它连接并组织管理数据的任务，并不是官方<a class="ae la" href="https://airflow.apache.org/docs/apache-airflow/stable/#" rel="noopener ugc nofollow" target="_blank"> Airflow网站</a>:<em class="lz">air flow所说的数据流工具，也不是数据流解决方案。任务不会将数据从一个移动到另一个(虽然任务可以交换元数据！)".</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/e81dc6bad2bced3108483fe8701ffaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*988jFBJhXLbd1ko7"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated"><a class="ae la" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇气流</a>的官方标志</figcaption></figure><p id="f799" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae la" href="http://airbnb.com" rel="noopener ugc nofollow" target="_blank"> Airbnb </a>于2014年开发了Airflow，2015年作为免费工具提供，次年捐赠给了<a class="ae la" href="https://www.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache基金会</a>。</p><p id="f402" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">除了开源之外，Airflow还有以下主要优势:</p><ul class=""><li id="fea1" class="ma mb it ld b le lf li lj lm mc lq md lu me ly mf mg mh mi bi translated">根据Airflow官方网站的说法，它更易于维护、版本化、可测试和协作，因为它都是用代码开发的；</li><li id="4f1a" class="ma mb it ld b le mj li mk lm ml lq mm lu mn ly mf mg mh mi bi translated">自始至终使用知名编程语言Python</li><li id="9a24" class="ma mb it ld b le mj li mk lm ml lq mm lu mn ly mf mg mh mi bi translated">它有几个内置的操作符，但是如果它们不能满足您的要求，您可以编写自己的自定义操作符；</li><li id="f02d" class="ma mb it ld b le mj li mk lm ml lq mm lu mn ly mf mg mh mi bi translated">即使全部都是用代码开发的，它也有一个奇妙的网络界面，允许正确的流程轻描淡写；</li><li id="644a" class="ma mb it ld b le mj li mk lm ml lq mm lu mn ly mf mg mh mi bi translated">它是高度可扩展的。</li></ul><h1 id="3ea2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">1.2.码头工人和码头工人组成</h1><p id="10f4" class="pw-post-body-paragraph lb lc it ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly im bi translated">一年前，我开始从事Docker的工作，这是一套奇妙的平台软件(PAAS)产品，我现在是它的超级粉丝。</p><p id="61ed" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该工具使用操作系统级虚拟化，允许对容器中的软件进行奇妙的定制，可以轻松地与您的同事或开发环境之间共享，“<em class="lz">并确保您共享的每个人都获得以相同方式工作的相同容器”</em>(由<a class="ae la" href="https://docs.docker.com/get-started/overview/#:~:text=Docker%20provides%20the%20ability%20to,simultaneously%20on%20a%20given%20host." rel="noopener ugc nofollow" target="_blank">官方Docker网站</a>)。</p><p id="21e1" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Docker的工作方式非常简单，因为它使用了客户机-服务器架构。"<em class="lz">Docker客户端与</em> <strong class="ld iu"> <em class="lz"> Docker守护进程</em> </strong> <em class="lz">对话，后者负责构建、运行和分发Docker容器。Docker客户机和守护进程可以在同一个系统上运行，或者您可以将Docker客户机连接到远程Docker守护进程。Docker客户机和守护程序使用REST API通过UNIX套接字或网络接口进行通信。另一个Docker客户端是Docker Compose，它让您可以使用由一组容器组成的应用程序。</em>(文字摘自Docker官方网站)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi my"><img src="../Images/43fb9ba86f6196874ef13032001b2ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HuJbkkFWnXJrVRp7"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Docker架构(来自Docker官方网站<a class="ae la" href="https://docs.docker.com/get-started/overview/#:~:text=Docker%20provides%20the%20ability%20to,simultaneously%20on%20a%20given%20host." rel="noopener ugc nofollow" target="_blank"/>)</figcaption></figure><p id="77c3" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用Docker最常见的方式是在一个名为<strong class="ld iu"> Dockerfile </strong>的文本文件中设置几个指令。该文件首先从公共Docker存储库中“调用”一个图像(例如Python图像、Airflow图像等)来设置基础图像，然后它将运行几个用户定义的命令来定制您的新图像。然后在运行“docker build”命令后，创建一个新的映像，并将整个上下文(递归地)发送到守护进程。</p><p id="8d75" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="ld iu"><em class="lz">“Docker Compose</em></strong><em class="lz">是一个定义和运行多容器Docker应用的工具。它使用YAML文件来配置应用程序的服务，并通过一个命令执行所有容器的创建和启动过程(……)</em><strong class="ld iu"><em class="lz">docker-compose . yml</em></strong><em class="lz">文件用于定义应用程序的服务，包括各种配置选项。”</em>(文字摘自<a class="ae la" href="https://en.wikipedia.org/wiki/Docker_(software)" rel="noopener ugc nofollow" target="_blank">维基百科</a> <em class="lz">)。</em></p><h1 id="86a1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.使用要求较低的Docker-compose版本(带附加信息)在本地设置和运行Airflow</h1><p id="f3eb" class="pw-post-body-paragraph lb lc it ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly im bi translated">我在本节中介绍的设置是在我上面提到的Zoomcamp的最终顶点的范围内构建并成功运行的。你可以在这里看到我的全部顶点<a class="ae la" href="https://github.com/guoliveira/data-engineer-zoomcamp-project" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1c67" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我把文章的这一部分分成两部分:</p><ol class=""><li id="bdeb" class="ma mb it ld b le lf li lj lm mc lq md lu me ly mz mg mh mi bi translated">主要设计，使气流运行在码头集装箱和</li><li id="70d1" class="ma mb it ld b le mj li mk lm ml lq mm lu mn ly mz mg mh mi bi translated">我创建的适应允许一个不太苛刻的配置。</li></ol><h1 id="a9ed" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.1.允许气流在Docker中流动的结构</h1><p id="8580" class="pw-post-body-paragraph lb lc it ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly im bi translated">为了在本地运行Airflow(在Docker容器中)，我使用了一个扩展映像，其中包含一些额外的依赖项。</p><p id="2f19" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，我首先创建了一个指向我需要的Airflow版本的Dockerfile，比如apache/airflow:2.2.3，作为基本映像。</p><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="7050" class="nf jr it nb b gy ng nh l ni nj">FROM apache/airflow:2.2.3</span></pre><p id="eed9" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后我通过添加一些要安装的定制包来定制这个Dockerfile。我最需要的是<em class="lz"> gcloud </em>来连接GCS bucket/Data Lake并集成“requirements.txt”来通过pip install安装库。</p><p id="bd2c" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是我承诺的<strong class="ld iu">奖励</strong>:我决定在我的DAG中运行spark(使用Pyspark ),所以我必须在docker文件中配置Spark。这可以通过添加bash命令来设置Java env，并插入命令来下载运行Spark所需的所有文件来实现。此外，有必要插入Pyspark作为一个需求。</p><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="9f1f" class="nf jr it nb b gy ng nh l ni nj">ENV JAVA_HOME=/home/jdk-11.0.2<br/></span><span id="00ac" class="nf jr it nb b gy nk nh l ni nj">ENV PATH="${JAVA_HOME}/bin/:${PATH}"<br/></span><span id="3fa2" class="nf jr it nb b gy nk nh l ni nj"><strong class="nb iu">RUN </strong>DOWNLOAD_URL="https://download.java.net/java/GA/jdk11/9/GPL/openjdk-11.0.2_linux-x64_bin.tar.gz" \ <br/>&amp;&amp; TMP_DIR="$(mktemp <strong class="nb iu">-d</strong>)" \<br/>&amp;&amp; curl <strong class="nb iu">-fL</strong> "<strong class="nb iu">${</strong>DOWNLOAD_URL<strong class="nb iu">}</strong>" <strong class="nb iu">--output</strong> "<strong class="nb iu">${</strong>TMP_DIR<strong class="nb iu">}</strong>/openjdk-11.0.2_linux-x64_bin.tar.gz" \<br/>&amp;&amp; mkdir <strong class="nb iu">-p</strong> "<strong class="nb iu">${</strong>JAVA_HOME<strong class="nb iu">}</strong>" \<br/>&amp;&amp; tar xzf "<strong class="nb iu">${</strong>TMP_DIR<strong class="nb iu">}</strong>/openjdk-11.0.2_linux-x64_bin.tar.gz" <strong class="nb iu">-C</strong> "<strong class="nb iu">${</strong>JAVA_HOME<strong class="nb iu">}</strong>" <strong class="nb iu">--strip-components</strong>=1 \<br/>&amp;&amp; rm <strong class="nb iu">-rf</strong> "<strong class="nb iu">${</strong>TMP_DIR<strong class="nb iu">}</strong>" \<br/>&amp;&amp; java <strong class="nb iu">--version</strong></span></pre><p id="e3df" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后我运行curl将官方的docker-compose安装文件(docker-compose.yml)从最新的Airflow版本导入到我的笔记本电脑中。</p><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="fbba" class="nf jr it nb b gy ng nh l ni nj">curl -LfO 'https://airflow.apache.org/docs/apache-airflow/stable/docker-compose.yaml'</span></pre><p id="c4c0" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后我修改了Yaml文件以运行docker-compose:</p><ul class=""><li id="29c0" class="ma mb it ld b le lf li lj lm mc lq md lu me ly mf mg mh mi bi translated">在x-airflow-common中，a)我删除了image标记，替换为我的Dockerfile，b)将我的google_credentials以只读方式安装在volumes部分，c)设置环境变量GOOGLE_APPLICATION_CREDENTIALS和air flow _ CONN _ GOOGLE _ CLOUD _ DEFAULT；</li><li id="b7b8" class="ma mb it ld b le mj li mk lm ml lq mm lu mn ly mf mg mh mi bi translated">而且我把AIRFLOW__CORE__LOAD_EXAMPLES改成了false</li></ul><p id="0d2d" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有了前面提到的所有步骤，我准备运行完整版，用Docker在本地运行Airflow。</p><h1 id="720b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">2.2.允许轻量级版本的修改</h1><p id="d6f3" class="pw-post-body-paragraph lb lc it ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly im bi translated">为了实现拥有一个轻量级版本的目标，我必须删除docker-compose.yml文件的几个部分。正如我将在下一节中解释的那样，所有这些进程都被删除了。</p><ol class=""><li id="a687" class="ma mb it ld b le lf li lj lm mc lq md lu me ly mz mg mh mi bi translated">我首先删除了<em class="lz"> redis </em>部分:</li></ol><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="2b43" class="nf jr it nb b gy ng nh l ni nj"><strong class="nb iu">redis</strong>:<br/>  <strong class="nb iu">image</strong>: redis:latest<br/>  <strong class="nb iu">expose</strong>:<br/>    - 6379<br/>  <strong class="nb iu">healthcheck</strong>:<br/>    <strong class="nb iu">test</strong>: ["CMD", "redis-cli", "ping"]<br/>    <strong class="nb iu">interval</strong>: 5s<br/>    <strong class="nb iu">timeout</strong>: 30s<br/>    <strong class="nb iu">retries</strong>: 50<br/>  <strong class="nb iu">restart</strong>: always</span></pre><p id="9f38" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">2.这是为了移除气流工作服务。这是一种有争议的方法，因为我们正在讨论工人，但在下一节中，您将理解这一点:</p><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="146d" class="nf jr it nb b gy ng nh l ni nj"><strong class="nb iu">airflow-worker</strong>:<br/>  &lt;&lt;: *airflow-common<br/>  <strong class="nb iu">command</strong>: celery worker<br/>  <strong class="nb iu">healthcheck</strong>:<br/>    <strong class="nb iu">test</strong>:<br/>      - "CMD-SHELL"<br/>      - 'celery --app airflow.executors.celery_executor.app inspect ping -d "celery@$${HOSTNAME}"'<br/>    <strong class="nb iu">interval</strong>: 10s<br/>    <strong class="nb iu">timeout</strong>: 10s<br/>    <strong class="nb iu">retries</strong>: 5<br/>  <strong class="nb iu">environment</strong>:<br/>    &lt;&lt;: *airflow-common-env<br/>    <em class="lz"># Required to handle warm shutdown of the celery workers properly</em><br/>    <em class="lz"># See https://airflow.apache.org/docs/docker-stack/entrypoint.html#signal-propagation</em><br/>    <strong class="nb iu">DUMB_INIT_SETSID</strong>: "0"<br/>  <strong class="nb iu">restart</strong>: always<br/>  <strong class="nb iu">depends_on</strong>:<br/>    &lt;&lt;: *airflow-common-depends-on<br/>    <strong class="nb iu">airflow-init</strong>:<br/>      <strong class="nb iu">condition</strong>: service_completed_successfully</span></pre><p id="a990" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">3.然后我去掉了<em class="lz">气流触发器</em>的部分:</p><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="6800" class="nf jr it nb b gy ng nh l ni nj"><strong class="nb iu">airflow-triggerer</strong>:<br/>  &lt;&lt;: *airflow-common<br/>  <strong class="nb iu">command</strong>: triggerer<br/>  <strong class="nb iu">healthcheck</strong>:<br/>    <strong class="nb iu">test</strong>: ["CMD-SHELL", 'airflow jobs check --job-type TriggererJob --hostname "$${HOSTNAME}"']<br/>    <strong class="nb iu">interval</strong>: 10s<br/>    <strong class="nb iu">timeout</strong>: 10s<br/>    <strong class="nb iu">retries</strong>: 5<br/>  <strong class="nb iu">restart</strong>: always<br/>  <strong class="nb iu">depends_on</strong>:<br/>    &lt;&lt;: *airflow-common-depends-on<br/>    <strong class="nb iu">airflow-init</strong>:<br/>      <strong class="nb iu">condition</strong>: service_completed_successfully</span></pre><p id="0700" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">4.最后，移除了<em class="lz">花</em>部分:</p><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="3821" class="nf jr it nb b gy ng nh l ni nj"><strong class="nb iu">flower</strong>:<br/>  &lt;&lt;: *airflow-common<br/>  <strong class="nb iu">command</strong>: celery flower<br/>  <strong class="nb iu">ports</strong>:<br/>    - 5555:5555<br/>  <strong class="nb iu">healthcheck</strong>:<br/>    <strong class="nb iu">test</strong>: ["CMD", "curl", "--fail", "http://localhost:5555/"]<br/>    <strong class="nb iu">interval</strong>: 10s<br/>    <strong class="nb iu">timeout</strong>: 10s<br/>    <strong class="nb iu">retries</strong>: 5<br/>  <strong class="nb iu">restart</strong>: always<br/>  <strong class="nb iu">depends_on</strong>:<br/>    &lt;&lt;: *airflow-common-depends-on<br/>    <strong class="nb iu">airflow-init</strong>:<br/>      <strong class="nb iu">condition</strong>: service_completed_successfully</span></pre><p id="15ae" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">删除这些部分后，需要纠正一些依赖关系:</p><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="184e" class="nf jr it nb b gy ng nh l ni nj"><strong class="nb iu">user</strong>: "${AIRFLOW_UID:-50000}:0"<br/>  <strong class="nb iu">depends_on</strong>:<br/>    &amp;airflow-common-depends-on<br/>    <strong class="nb iu">redis</strong>:<br/>      <strong class="nb iu">condition</strong>: service_healthy<br/>    <strong class="nb iu">postgres</strong>:<br/>      <strong class="nb iu">condition</strong>: service_healthy</span></pre><p id="9f1c" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最终我将执行程序从CoreExecutor设置为LocalExecutor。在下一部分，我将解释为什么我们改变了执行者，为什么这是<strong class="ld iu">最重要的部分</strong>。</p><pre class="kp kq kr ks gt na nb nc nd aw ne bi"><span id="6dac" class="nf jr it nb b gy ng nh l ni nj">AIRFLOW__CORE__EXECUTOR<!-- -->: LocalExecutor</span></pre><p id="1639" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">docker-compose.yml的原始和正式版本是<a class="ae la" href="https://airflow.apache.org/docs/apache-airflow/stable/docker-compose.yaml" rel="noopener ugc nofollow" target="_blank"> this </a>，我的最终版本在这里<a class="ae la" href="https://github.com/guoliveira/data-engineer-zoomcamp-project/blob/main/Airflow/docker-compose.yaml" rel="noopener ugc nofollow" target="_blank">呈现</a>。</p><h1 id="a0a5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">3.为什么这个装置更轻</h1><p id="fa5c" class="pw-post-body-paragraph lb lc it ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly im bi translated">这种设置比完整版轻的主要原因是由于选择将核心执行器设置为<strong class="ld iu"> LocalExecutor </strong>(单节点)。然后，在相关关系中，依赖于<strong class="ld iu"> CeleryExecutor </strong>(多节点)的一些特性可以被移除。</p><p id="7388" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在Airflow中，DAG将由于三个主要组件而被执行和完成，a)元数据 <strong class="ld iu">数据库</strong>，b)调度器和c)执行器(来自天文学家网站<a class="ae la" href="https://www.astronomer.io/guides/airflow-executors-explained/" rel="noopener ugc nofollow" target="_blank"/></p><p id="90eb" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">执行器的功能是与调度器一起工作，了解哪些资源将在它们排队时实际完成这些任务。</p><p id="4de6" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">CeleryExecutor(与<a class="ae la" href="https://docs.celeryq.dev/en/stable/" rel="noopener ugc nofollow" target="_blank"> Celery </a>分布式系统相关)是专门为水平扩展而制造的，因为CeleryExecutor与独立工作人员的“池”(在可靠的分布式系统中)一起工作，它可以通过消息(根据<a class="ae la" href="https://www.astronomer.io/guides/airflow-executors-explained/" rel="noopener ugc nofollow" target="_blank">astronomy . io</a>网站)在这些工作人员之间委派任务。然而，这个执行器是高度资源密集型的。LocalExecutor举例说明了单节点架构(因此它的资源很少)，但它仍然允许并行。</p><blockquote class="nl"><p id="94e5" class="nm nn it bd no np nq nr ns nt nu ly dk translated">因此，建议使用LocalExecutor进行本地测试(在本地运行),使用CeleryExecutor进行生产。</p></blockquote><p id="2c32" class="pw-post-body-paragraph lb lc it ld b le nv lg lh li nw lk ll lm nx lo lp lq ny ls lt lu nz lw lx ly im bi translated">因为我将Executor设置为LocalExecutor，所以我可以删除部件<em class="lz">air flow-work</em>r和<em class="lz"> flower </em>，因为它们只适用于芹菜架构。</p><p id="2b4a" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><em class="lz"> Redis </em>是一个简单的缓存服务器(见<a class="ae la" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis.io </a>)，需要设置为CeleryExecutor的芹菜后端(见<a class="ae la" href="https://airflow.apache.org/docs/apache-airflow/1.10.13/executor/celery.html#:~:text=For%20this%20to%20work%2C%20you%20need%20to%20setup%20a%20Celery%20backend%20(RabbitMQ%2C%20Redis%2C%20%E2%80%A6){:target=%22_blank%22}" rel="noopener ugc nofollow" target="_blank"> CeleryExecutor </a>)。因为我们不会使用这个执行程序，所以删除这个服务是安全的-</p><p id="1fef" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我决定移除<em class="lz">气流触发器</em>，因为它是一个专门为asyncio事件循环设计的新气流服务，我不打算使用它。</p><h1 id="1bf0" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="1a9f" class="pw-post-body-paragraph lb lc it ld b le mo lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly im bi translated">现在，我可以在局部运行气流，而不会对我的笔记本电脑造成太大损坏，也不用担心我的散热面的完整性(这感觉不像我在操作飞机😉)因为我们使用单节点执行器(但仍有并行性)运行它，并且运行的进程更少。</p><p id="415c" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我希望得到您对本文信息的反馈。</p><p id="9fc8" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你认为我在技术观点上是清楚还是不清楚？</p><p id="4eec" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我写了什么技术上的错误吗？</p><p id="5e77" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你喜欢这篇文章吗？关注我更多关于<a class="ae la" href="https://medium.com/@lgsoliveira" rel="noopener">媒介</a>的文章。</p></div></div>    
</body>
</html>