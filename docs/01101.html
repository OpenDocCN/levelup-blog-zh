<html>
<head>
<title>Ensuring healthy Node.js program using watchdog timer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用看门狗定时器确保Node.js程序正常运行</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ensuring-healthy-node-js-program-using-watchdog-timer-9170fa35cf68?source=collection_archive---------4-----------------------#2019-11-09">https://levelup.gitconnected.com/ensuring-healthy-node-js-program-using-watchdog-timer-9170fa35cf68?source=collection_archive---------4-----------------------#2019-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="634a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有一个Node.js程序，该程序被设计为异步提取任务并处理它们，那么您应该注意挂起的进程。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/b69315dcd7ed3fd91b97730ab829ac94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*R5fNxhyIY16xfBvi2tUghQ.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">监控Node.js程序运行状况。</figcaption></figure><p id="9192" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑这样一个程序的例子:</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="3b28" class="lf lg it lb b gy lh li l lj lk">import delay from 'delay';</span><span id="f82a" class="lf lg it lb b gy ll li l lj lk">const getNextJob = async () =&gt; { /* ... */ };<br/>const doJob = async () =&gt; { /* ... */ };</span><span id="4e18" class="lf lg it lb b gy ll li l lj lk">const main = async () =&gt; {<br/>  while (true) {<br/>    const maybeNextJob = await getNextJob();</span><span id="3cff" class="lf lg it lb b gy ll li l lj lk">    if (maybeNextJob) {<br/>      await doJob(maybeNextJob);<br/>    } else {<br/>      await delay(1000);<br/>    }<br/>  }<br/>};</span><span id="f47e" class="lf lg it lb b gy ll li l lj lk">main();</span></pre><p id="f927" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lb b">getNextJob</code>用于从任意数据库中提取任务指令，<code class="fe lm ln lo lb b">doJob</code>用于执行这些任务。</p><p id="7b0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的风险是任何异步任务都可能无限期挂起，例如，如果<code class="fe lm ln lo lb b">getNextJob</code>从远程数据库中提取数据，数据库套接字可能会无限期挂起。几乎可以肯定，这总是一个错误。</p><p id="6c61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的具体案例中，我遇到了一个<code class="fe lm ln lo lb b">node-postgres</code>中的<a class="ae lp" href="https://github.com/brianc/node-postgres/issues/1952" rel="noopener ugc nofollow" target="_blank">错误</a>，导致连接在<code class="fe lm ln lo lb b">ClientRead</code>状态下挂起。后者发生在服务器看到开始查询的协议消息，但它还没有返回到空闲状态时，这发生在服务器在查询结束时发送<code class="fe lm ln lo lb b">ReadyForQuery</code>响应时。PostgreSQL没有为<code class="fe lm ln lo lb b">ClientRead</code>设置超时，也就是说，这会导致我的<code class="fe lm ln lo lb b">getNextJob</code>无限期挂起。</p><p id="28c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">防范这种风险的最好方法是给用于拉取和执行任务的循环添加一个超时。每次迭代都应刷新超时值；当超时没有及时重置时，您应该终止进程并记录足够的详细信息，以确定导致进程挂起的原因。这种模式称为<a class="ae lp" href="https://en.wikipedia.org/wiki/Watchdog_timer" rel="noopener ugc nofollow" target="_blank">看门狗定时器</a>。</p><p id="c3d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是看门狗定时器的一个示例实现:</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="7b9d" class="lf lg it lb b gy lh li l lj lk">import delay from 'delay';</span><span id="b911" class="lf lg it lb b gy ll li l lj lk">const getNextJob = async () =&gt; { /* ... */ };<br/>const doJob = async () =&gt; { /* ... */ };</span><span id="df2d" class="lf lg it lb b gy ll li l lj lk">const main = async () =&gt; {<br/>  const timeoutId = setTimeout(() =&gt; {<br/>    console.error('watchdog timer timeout; forcing program termination');</span><span id="3622" class="lf lg it lb b gy ll li l lj lk">    process.exit(1);<br/>  }, 30 * 1000);</span><span id="416d" class="lf lg it lb b gy ll li l lj lk">  timeoutId.unref();</span><span id="35c9" class="lf lg it lb b gy ll li l lj lk">  while (true) {<br/>    timeoutId.refresh();</span><span id="7b22" class="lf lg it lb b gy ll li l lj lk">    const maybeNextJob = await getNextJob();</span><span id="1fe1" class="lf lg it lb b gy ll li l lj lk">    if (maybeNextJob) {<br/>      await doJob(maybeNextJob);<br/>    } else {<br/>      await delay(1000);<br/>    }<br/>  }<br/>};</span><span id="53ab" class="lf lg it lb b gy ll li l lj lk">main();</span></pre><p id="2bc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个计时器，它会在每次检查新任务的循环开始时刷新。30秒的超时适用于整个周期(即<code class="fe lm ln lo lb b">getNextJob</code>和<code class="fe lm ln lo lb b">doJob</code>),因为您正在强制突然终止，所以它应该远高于内部任务限制。</p><p id="b8c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我必须在我的多个应用程序中实现上述模式，以防止这些幽灵进程挂在使用Kubernetes编排的许多进程的大规模部署中。因此，我将上述逻辑+一些糖抽象成一个模块<a class="ae lp" href="https://github.com/gajus/watchdog-timer" rel="noopener ugc nofollow" target="_blank">看门狗定时器</a>。在很大程度上，它可以像前面使用<code class="fe lm ln lo lb b">setTimeout</code>的例子一样使用:</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="00cb" class="lf lg it lb b gy lh li l lj lk">import {<br/>  createWatchdogTimer,<br/>} from 'watchdog-timer';<br/>import delay from 'delay';</span><span id="29d1" class="lf lg it lb b gy ll li l lj lk">const getNextJob = async () =&gt; { /* ... */ };<br/>const doJob = async () =&gt; { /* ... */ };</span><span id="d53f" class="lf lg it lb b gy ll li l lj lk">const main = async () =&gt; {<br/>  const watchdogTimer = createWatchdogTimer({<br/>    onTimeout: () =&gt; {<br/>      console.error('watchdog timer timeout; forcing program termination');</span><span id="b03c" class="lf lg it lb b gy ll li l lj lk">      process.exit(1);<br/>    },<br/>    timeout: 1000,<br/>  });</span><span id="ea01" class="lf lg it lb b gy ll li l lj lk">  while (true) {<br/>    watchdogTimer.refresh();</span><span id="4fab" class="lf lg it lb b gy ll li l lj lk">    const maybeNextJob = await getNextJob();</span><span id="687b" class="lf lg it lb b gy ll li l lj lk">    if (maybeNextJob) {<br/>      await doJob(maybeNextJob);<br/>    } else {<br/>      await delay(1000);<br/>    }<br/>  }<br/>};</span><span id="817f" class="lf lg it lb b gy ll li l lj lk">main();</span></pre><p id="4f71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要强调的是，这是一个进程内保护，也就是说，如果有什么东西阻塞了事件循环，那么就不会调用超时。为了防止后者，您还需要一个外部服务来检查应用程序的活性。如果您正在使用Kubernetes，那么这个功能由<code class="fe lm ln lo lb b"><a class="ae lp" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank">livenessProbe</a></code>提供，并且可以使用<code class="fe lm ln lo lb b"><a class="ae lp" href="https://github.com/gajus/lightship" rel="noopener ugc nofollow" target="_blank">lightship</a></code> NPM模块来实现。</p><p id="4695" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lb b">watchdog-timer</code>与Lightship完美融合:</p><pre class="kp kq kr ks gt la lb lc ld aw le bi"><span id="2786" class="lf lg it lb b gy lh li l lj lk">import {<br/>  createWatchdogTimer,<br/>} from 'watchdog-timer';<br/>import {<br/>  createLightship,<br/>} from 'lightship';</span><span id="5e7d" class="lf lg it lb b gy ll li l lj lk">const main = async () =&gt; {<br/>  const lightship = createLightship({<br/>    timeout: 5 * 1000,<br/>  });</span><span id="c650" class="lf lg it lb b gy ll li l lj lk">  lightship.signalReady();</span><span id="ea8a" class="lf lg it lb b gy ll li l lj lk">  lightship.registerShutdownHandler(async () =&gt; {<br/>    console.log('shutting down');<br/>  });</span><span id="e710" class="lf lg it lb b gy ll li l lj lk">  const watchdogTimer = createWatchdogTimer({<br/>    onTimeout: () =&gt; {<br/>      // If you do not call `destroy()`, then<br/>      // `onTimeout` is going to be called again on the next timeout.<br/>      watchdogTimer.destroy();</span><span id="6770" class="lf lg it lb b gy ll li l lj lk">      lightship.shutdown();<br/>    },<br/>    timeout: 1000,<br/>  });</span><span id="dbe6" class="lf lg it lb b gy ll li l lj lk">  while (true) {<br/>    if (lightship.isServerShuttingDown()) {<br/>      console.log('detected that the service is shutting down; terminating the event loop');</span><span id="5688" class="lf lg it lb b gy ll li l lj lk">      break;<br/>    }</span><span id="33bc" class="lf lg it lb b gy ll li l lj lk">    // Reset watchdog-timer on each loop.<br/>    watchdogTimer.reset();</span><span id="a76c" class="lf lg it lb b gy ll li l lj lk">    // `foo` is an arbitrary routine that might hang indefinitely,<br/>    // e.g. due to a hanging database connection socket.<br/>    await foo();<br/>  }</span><span id="6ef9" class="lf lg it lb b gy ll li l lj lk">  watchdogTimer.destroy();<br/>};</span><span id="91b1" class="lf lg it lb b gy ll li l lj lk">main();</span></pre><p id="7ab4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">综上所述，为了避免挂起进程，你必须有一个进程内看门狗来发现你的应用什么时候处于空闲/没有执行预期的步骤；您必须使用一个进程外看门狗来确保应用程序不会陷入阻塞事件循环。</p></div></div>    
</body>
</html>