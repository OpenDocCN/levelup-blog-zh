<html>
<head>
<title>How to Get a Perfect Deep Equal in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中得到一个完美的深度相等？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-get-a-perfect-deep-equal-in-javascript-b849fe30e54f?source=collection_archive---------3-----------------------#2022-03-02">https://levelup.gitconnected.com/how-to-get-a-perfect-deep-equal-in-javascript-b849fe30e54f?source=collection_archive---------3-----------------------#2022-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="242f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在反应浅相等的基础上实现几乎完美的深相等。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9f0eac740e50c6b09aa3814854b5aeb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9ImMM0wcYxNniBqi"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">萨尔曼·侯赛因·赛义夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们可以使用<code class="fe lv lw lx ly b">==</code>、<code class="fe lv lw lx ly b">===</code>运算符和<code class="fe lv lw lx ly b">Object.is</code>方法来判断两个变量值相等。但是如果要深入比较两个变量值，它们能满足我们的需求吗？跟着我分析一下。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d2a9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi">==</h1><p id="a814" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">==</code>操作符是一个松散的等式操作符。当比较两个不同类型的值时，它将首先尝试将它们转换为相同的类型，然后再进行比较。具体使用的算法是<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" rel="noopener ugc nofollow" target="_blank">抽象等式比较算法</a>，它的规则复杂难记，你也可以在这里查看它的简短描述<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality#description" rel="noopener ugc nofollow" target="_blank">，还可以通过这个</a><a class="ae ky" href="https://felix-kling.de/js-loose-comparison/#[1%2C2]==%221%2C2%22" rel="noopener ugc nofollow" target="_blank">链接</a>互动体验它的转换过程。</p><p id="f50a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以说是最不严谨的等式运算符，很多结果可能会让你大吃一惊。</p><h1 id="986d" class="mg mh it bd mi mj nd ml mm mn ne mp mq jz nf ka ms kc ng kd mu kf nh kg mw mx bi">===</h1><p id="f1fe" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">===</code>运算符是一个严格的等式运算符。它总是认为不同类型的操作数是不同的。具体使用的算法是<a class="ae ky" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6" rel="noopener ugc nofollow" target="_blank">严格相等比较算法</a>，它的规则更容易记忆，你也可以在这里查看它的简短描述<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality#description" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="fca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是我们最常用的等式运算符。看起来很严格，但在以下情况下有瑕疵:</p><ul class=""><li id="f27d" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">数字必须有相同的数值。<code class="fe lv lw lx ly b">+0</code>和<code class="fe lv lw lx ly b">-0</code>被认为是相同的值。</li><li id="b9d6" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">如果任一操作数为<code class="fe lv lw lx ly b">NaN</code>，将返回false。</li><li id="a719" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">如果两个操作数都是对象，那么只会判断它们的引用地址是否相同。</li></ul><h1 id="a3fa" class="mg mh it bd mi mj nd ml mm mn ne mp mq jz nf ka ms kc ng kd mu kf nh kg mw mx bi translated">对象. is</h1><p id="0535" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在大多数情况下，<code class="fe lv lw lx ly b">Object.is</code>方法的行为与<code class="fe lv lw lx ly b">===</code>操作符相同，但在以下两种情况下，其结果与<code class="fe lv lw lx ly b">===</code>操作符相反:</p><ul class=""><li id="3f54" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe lv lw lx ly b">+0</code>和<code class="fe lv lw lx ly b">-0</code>被认为是不同的值，将返回false。</li><li id="623e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe lv lw lx ly b">NaN</code>和<code class="fe lv lw lx ly b">NaN</code>被认为是相同的值，将返回true。</li></ul><p id="2ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不代表<code class="fe lv lw lx ly b">Object.is</code>比<code class="fe lv lw lx ly b">===</code>运算符严格。我们要根据<code class="fe lv lw lx ly b">Object.is</code>的具体特点来处理相应的使用要求。</p><p id="bad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果两个操作数是对象，那么<code class="fe lv lw lx ly b">Object.is</code>的行为与<code class="fe lv lw lx ly b">===</code>操作符相同，或者只确定它们的引用地址是否相同。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9e04" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何获得深度平等？</h1><p id="0a84" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于操作数都是对象的情况，我们期望Deep Equal给出我们想要的答案。例如，对于任何非原始对象<code class="fe lv lw lx ly b">x</code>和<code class="fe lv lw lx ly b">y</code>，它们具有相同的结构，但是它们本身是不同的对象，我们期望Deep Equal返回true。</p><p id="ce2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/use-pure-javascript-to-get-a-perfect-deep-copy-5fdc2d9e3d42"> <em class="nw">中解释了JavaScript数据类型的特点如何在JavaScript中获得完美的深度拷贝？</em> </a>文章发表较早。正是因为这些特点，一个完美的深度相等需要考虑很多边缘情况，其性能注定很差。，所以在React中，我们不是用深相等来判断前后状态是否有变化，而是浅相等。</p><p id="92cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们来看看React中的Shallow Equal是如何实现的？</p><h1 id="5b55" class="mg mh it bd mi mj nd ml mm mn ne mp mq jz nf ka ms kc ng kd mu kf nh kg mw mx bi translated">反应迟钝</h1><p id="3e82" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我这里不改变原来的逻辑，只是去掉兼容性代码，提高可读性。它的原始文件是<a class="ae ky" href="https://github.com/facebook/react/blob/main/packages/shared/shallowEqual.js" rel="noopener ugc nofollow" target="_blank">这里的</a>，你可以查看一下进行对比。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意我在代码中以<code class="fe lv lw lx ly b">P</code>开头的注释，我将以它为单位进行解释:</p><p id="3ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> P1: </strong>通过<code class="fe lv lw lx ly b">Object.is</code>进行一级比较，如果相等则返回true，具有一级过滤的作用。</p><p id="492f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">P2: 确保两者都是对象，如果其中一个不是，则返回false。</p><p id="5e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> P3: </strong>此时两者都是对象，但是它们的引用地址不一样。所以下一步就是循环遍历其中一个对象的key数组，判断这个key是否是另一个对象的自身属性(相对于继承它)，判断这两个对象的key对应的值是否可以通过<code class="fe lv lw lx ly b">Object.is</code>，也就是说这里React并不选择递归判断性能，也就是说只比较一层。</p><p id="0fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看了React里的浅等，相信你有想法了。让我们在此基础上实现一个完美的深度平等。</p><h1 id="ecb6" class="mg mh it bd mi mj nd ml mm mn ne mp mq jz nf ka ms kc ng kd mu kf nh kg mw mx bi translated">在浅相等的基础上获得完美的深相等</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz ny l"/></div></figure><p id="ff59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的测试代码使用了在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/use-pure-javascript-to-get-a-perfect-deep-copy-5fdc2d9e3d42">上一篇文章</a>中实现的深度复制功能。当然，你也可以直接在StackBlitz上修改和测试结果，比如你可以删除代码末尾的注释来查看结果的变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意我在代码中以<code class="fe lv lw lx ly b">P</code>开头的注释，我将以它为单位进行解释:</p><p id="63e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> P1: </strong>像影相等，用<code class="fe lv lw lx ly b">Object.is</code>进行一级过滤。</p><p id="6d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> P2: </strong>需要对<code class="fe lv lw lx ly b">Date</code>和<code class="fe lv lw lx ly b">RegExp</code>进行特殊处理，因此使用<code class="fe lv lw lx ly b">Date.prototype.getTime()</code>表示日期以获取时间戳并进行比较，使用<code class="fe lv lw lx ly b">RegExp.prototype.toString()</code>表示RegExp以获取字符串并进行比较。</p><p id="9a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">P3: 像影子一样相等，确保两者都是对象，如果其中一个不是，则返回false。</p><p id="05f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> P4: </strong>使用WeakMap作为哈希表解决循环引用问题。如果之前已经比较过两者，那么会返回true，也就是说不会影响最终的结果。</p><p id="aee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> P5: </strong>相比于Shadow Equal，我们升级到<code class="fe lv lw lx ly b">Reflect.ownKeys</code>得到所有的键。然后我们也判断属性数组的长度，然后循环遍历<code class="fe lv lw lx ly b">objA</code>的所有属性键，用<code class="fe lv lw lx ly b">Reflect.has</code>判断<code class="fe lv lw lx ly b">objB</code>上是否有相同的属性。最后我们把<code class="fe lv lw lx ly b">Object.is</code>升级为递归处理，不断判断深度值是否相等。</p><p id="47ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看看之前实现的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/use-pure-javascript-to-get-a-perfect-deep-copy-5fdc2d9e3d42">深度复制函数</a>，你感觉到它们之间的相似之处了吗？是的，他们在一些逻辑判断上非常相似。可以通过对比来学习。相信可以加深你对JavaScript数据结构的理解。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="a916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw">今天就到这里。我是Zachary，我会继续输出与web开发相关的故事，如果你喜欢这样的故事并想支持我，请考虑成为</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nw">中级会员</em> </a> <em class="nw">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nw">我的链接</em> </a> <em class="nw">报名，我会得到一点佣金。</em></p><p id="eae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的支持对我来说非常重要——谢谢。</p></div></div>    
</body>
</html>