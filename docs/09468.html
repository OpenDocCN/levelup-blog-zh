<html>
<head>
<title>Build An API With A Database From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始用数据库构建API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-an-api-with-a-database-from-scratch-9b9a39d7739d?source=collection_archive---------0-----------------------#2021-08-13">https://levelup.gitconnected.com/build-an-api-with-a-database-from-scratch-9b9a39d7739d?source=collection_archive---------0-----------------------#2021-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="764f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用FastAPI和Sqlite的新项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5cb34c57f8d6093f37b04b311e13f18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*teDrCeZZ-uUDNaNm"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@sortino?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·索蒂诺</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="052c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">春季学期结束了，暑假开始了，总觉得每年的这个时候都想学点新东西。</p><p id="fefc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的“暑期学习”清单上的第一项是构建一个API，因为我以前从来没有机会构建一个，我认为在某个时候我会在工作中这样做，或者至少修改一个现有的API。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ec36" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">简而言之，什么是API？</h1><blockquote class="mu"><p id="e4a0" class="mv mw it bd mx my mz na nb nc nd lu dk translated">应用程序编程接口</p></blockquote><p id="d830" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">一个API基本上处理用户的<em class="nj">请求</em>并返回<em class="nj">响应</em>，就像餐馆的服务员处理你的<em class="nj">订单</em>并为你提供<em class="nj">食物</em>一样。</p><p id="4b94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像在餐馆里一样，API有一个预先定义的菜单，整个连接都基于它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6931" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概观</h1><p id="4a79" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了让这个项目更有趣，我决定使用数据库。<br/>我浏览了Kaggle，寻找能吸引我眼球的东西，毫无疑问，我们将使用口袋妖怪数据集——理想情况下，你会像我意识到有这样的数据集一样兴奋。</p><p id="3c2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以从<a class="ae ky" href="https://www.kaggle.com/abcsds/pokemon" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>获取数据集。</p><p id="d5a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的项目将由两个主要文件组成——一个用于处理数据库调用，另一个用于API。</p><p id="7a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">需求</strong> : FastAPI，uvicorn，熊猫</p><p id="438d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到本文结束时，您将已经创建了以下API</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/6790d43ab4fc8f1e8d9955677f96df48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYSGTFrU72DljY15LsBDKg.jpeg"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c907" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据库ˌ资料库</h1><p id="fd63" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">创建你的第一个文件，命名为<code class="fe nq nr ns nt b">database.py</code>，让我们开始编码。</p><p id="7f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从进口开始</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="be79" class="ny md it nt b gy nz oa l ob oc">from pathlib import Path<br/>import sqlite3<br/>import pandas as pd</span></pre><p id="3647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">sqlite3数据库是一个基于文件的数据库，这意味着首先，我们必须创建一个包含数据集的文件。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="97c4" class="ny md it nt b gy nz oa l ob oc">DB_FILENAME = "poke_db.db"</span><span id="64cb" class="ny md it nt b gy od oa l ob oc">def init_db():<br/>    if not Path(DB_FILENAME).is_file():<br/>        Path(DB_FILENAME).touch()</span></pre><p id="24dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将把下载的数据集加载到我们创建的数据库文件中。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="7bcf" class="ny md it nt b gy nz oa l ob oc">def load_csv_to_db():<br/>    init_db()<br/>    conn = sqlite3.connect(DB_FILENAME)<br/>    cursor = conn.cursor()<br/>    cursor.execute('''<br/>        CREATE TABLE IF NOT EXISTS Pokemons (idx int, name text,<br/>        type1 text,type2 text, sum_stats int, hp int, attack int,<br/>        special_attack int, defense int, special_defense int)''')</span><span id="1c57" class="ny md it nt b gy od oa l ob oc">    poke_data = pd.read_csv('Pokemon.csv')</span><span id="0629" class="ny md it nt b gy od oa l ob oc">    poke_data.drop(['Speed', 'Generation', 'Legendary'], axis=1,<br/>                    inplace=True)</span><span id="2eca" class="ny md it nt b gy od oa l ob oc">    poke_data.columns = ['idx', 'name', 'type1', 'type2', <br/>                          'sum_stats', 'hp', 'attack',<br/>                          'special_attack', 'defense',    <br/>                          'special_defense']</span><span id="7688" class="ny md it nt b gy od oa l ob oc">    poke_data.to_sql('Pokemons', conn, if_exists='append',<br/>                      index=False)</span></pre><p id="a98b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这个函数创建一个名为Pokemons的表，并将我们的数据集保存到数据库文件中。<br/>我还省略了一些列——您可以保留它们，并将匹配的列添加到您的表中。</p><p id="2fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续讨论数据库查询之前，我要定义一个函数，这个函数在以后会很有用，它会让我们知道我们的表是否存在。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="adb2" class="ny md it nt b gy nz oa l ob oc">def table_exists(cursor):<br/>    cursor.execute('''<br/>        SELECT count(name) FROM sqlite_master WHERE type='table' AND<br/>        name='Pokemons' ''')</span><span id="6471" class="ny md it nt b gy od oa l ob oc">    if not cursor.fetchone()[0]:<br/>        return False<br/>    return True</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将定义的每个API调用最终都会查询数据库，因此我们将预先为API准备所需的功能。</p><p id="cf87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一个API调用将允许我们通过名称检索pokemon的详细信息，因此我们将创建匹配的数据库查询</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="a7ed" class="ny md it nt b gy nz oa l ob oc">def get_poke_by_name(poke_name):<br/>    conn = sqlite3.connect(DB_FILENAME)<br/>    cursor = conn.cursor()</span><span id="2c19" class="ny md it nt b gy od oa l ob oc">     if not table_exists(cursor):<br/>        load_csv_to_db()</span><span id="0ba8" class="ny md it nt b gy od oa l ob oc">    cursor.execute('''SELECT * FROM Pokemons WHERE name = ?''', <br/>                    (poke_name,))</span><span id="2680" class="ny md it nt b gy od oa l ob oc">    return cursor.fetchone()</span></pre><p id="293e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个查询将根据口袋妖怪的类型检索它们的列表——每个口袋妖怪都有一个主要和次要类型，我们将能够查询这两种类型或只查询主要类型。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="8cf2" class="ny md it nt b gy nz oa l ob oc">def get_poke_by_type(type1, type2=None):<br/>    conn = sqlite3.connect(DB_FILENAME)<br/>    cursor = conn.cursor()</span><span id="70f5" class="ny md it nt b gy od oa l ob oc">    if not table_exists(cursor):<br/>        load_csv_to_db()</span><span id="fa36" class="ny md it nt b gy od oa l ob oc">    if type2:<br/>        cursor.execute('''<br/>        SELECT * FROM Pokemons WHERE type1 = ? AND type2 = ?''', <br/>        (type1, type2))</span><span id="98fc" class="ny md it nt b gy od oa l ob oc">    else:<br/>        cursor.execute('''<br/>        SELECT * FROM Pokemons WHERE type1 = ?''', (type1,))<br/> <br/>    return cursor.fetchall()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="cef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上两个查询的目标是基于一些参数检索口袋妖怪。<br/>接下来的三个查询将负责添加、更新和删除口袋妖怪。</p><h2 id="2f4c" class="ny md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">添加口袋妖怪</h2><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="f78b" class="ny md it nt b gy nz oa l ob oc">def add_poke_to_db(name, type1, type2, sum_stats, hp, attack, <br/>                   special_attack,defense, special_defense):  <br/>  <br/>    conn = sqlite3.connect(DB_FILENAME)<br/>    cursor = conn.cursor()</span><span id="fd5f" class="ny md it nt b gy od oa l ob oc">    if not table_exists(cursor):<br/>        load_csv_to_db()</span><span id="5306" class="ny md it nt b gy od oa l ob oc">    cursor.execute('''<br/>        INSERT INTO Pokemons ('name', 'type1', 'type2', 'sum_stats',  <br/>                          'hp', 'attack', 'special_attack', <br/>                          'defense', 'special_defense')<br/>                           VALUES (?,?,?,?,?,?,?,?,?)''', <br/>                           (name, type1, type2, sum_stats, hp, <br/>                           attack, special_attack, defense, <br/>                           special_defense))<br/>    conn.commit()</span></pre><p id="4bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数使用传递的参数向数据库添加了一个新行。为了确保写出数据库的新状态，我们必须提交我们的更改。<br/>如果我们不提交，在添加一个口袋妖怪后，我们将尝试按名称查询它，例如，我们可能会得到一个错误，说找不到口袋妖怪。</p><h2 id="7db2" class="ny md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">更新口袋妖怪</h2><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="b63a" class="ny md it nt b gy nz oa l ob oc">def update_poke(name, type1=None, type2=None, sum_stats=None,  <br/>                hp=None, attack=None, special_attack=None, <br/>                defense=None, special_defense=None):</span><span id="b005" class="ny md it nt b gy od oa l ob oc">     conn = sqlite3.connect(DB_FILENAME)<br/>     cursor = conn.cursor()</span><span id="97e9" class="ny md it nt b gy od oa l ob oc">     if not table_exists(cursor):<br/>        load_csv_to_db()</span><span id="8451" class="ny md it nt b gy od oa l ob oc">     params = [type1, type2, sum_stats, hp, attack, special_attack,<br/>              defense, special_defense]</span><span id="4214" class="ny md it nt b gy od oa l ob oc">     params_names = ['type1', 'type2', 'sum_stats', 'hp', 'attack',<br/>                    'special_attack', 'defense', 'special_defense']</span><span id="013d" class="ny md it nt b gy od oa l ob oc">     for param, param_name in zip(params, params_names):<br/>        if param:<br/>            query = '''<br/>                    UPDATE Pokemons SET ''' + param_name + '''    <br/>                    = ? WHERE name = ?''' </span><span id="b18b" class="ny md it nt b gy od oa l ob oc">            cursor.execute(query, (param, name))</span><span id="aaa7" class="ny md it nt b gy od oa l ob oc">     conn.commit()</span></pre><p id="22eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们希望只更新口袋妖怪的部分信息，我们将反复检查我们希望更新的参数，并在数据库中这样做。<br/>出于上面提到的同样原因，我们最后使用提交。</p><h2 id="f3d3" class="ny md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">删除口袋妖怪</h2><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="9db8" class="ny md it nt b gy nz oa l ob oc">def delete_poke(name):<br/>    conn = sqlite3.connect(DB_FILENAME)<br/>    cursor = conn.cursor()</span><span id="0991" class="ny md it nt b gy od oa l ob oc">     if not table_exists(cursor):<br/>        load_csv_to_db()</span><span id="fd3b" class="ny md it nt b gy od oa l ob oc">     cursor.execute('''DELETE FROM Pokemons WHERE name = ?''',  <br/>                       (name,))<br/>     conn.commit()</span></pre><p id="1d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据口袋妖怪的名字删除一行，这是不言自明的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="84e8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">应用程序接口</h1><p id="83a3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在准备好我们将要使用的所有数据库功能之后，最困难的部分已经过去了。我们现在要做的就是简单地包装我们的数据库函数并返回一些状态代码。</p><p id="025c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建第二个文件<code class="fe nq nr ns nt b">pokeapi.py</code>，并继续编码。</p><p id="5dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从进口开始</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="03e3" class="ny md it nt b gy nz oa l ob oc">from typing import Optional<br/>from fastapi import FastAPI, Path, HTTPException, status<br/>from pydantic import BaseModel<br/>from database import get_poke_by_name, get_poke_by_type, <br/>                     add_poke_to_db, update_poke, delete_poke</span></pre><p id="a0b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了快速了解我们的API，让我们为API的根路径添加一条欢迎消息。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="4bf2" class="ny md it nt b gy nz oa l ob oc">app = FastAPI()</span><span id="4b4c" class="ny md it nt b gy od oa l ob oc">@app.get("/")<br/>def root():<br/>    raise HTTPException(status_code=status.HTTP_200_OK,  <br/>                        detail="Welcome to PokeAPI")</span></pre><p id="7d09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是一个简短的片段，但我还是会回顾一些概念，因为它们也会在接下来的片段中重复。</p><p id="f966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，<code class="fe nq nr ns nt b">app.get("/")</code>是做什么的？<br/>它在我们的API的根路径中定义了一个GET请求—“/”。<br/>当我们访问该路径时，将调用后面定义的函数。</p><p id="70e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们将使用HTTPException类引发异常，而不是返回一些带有默认状态代码的定制JSON消息。<br/>作为一个参数，我们可以传递我们想要返回的状态代码和一些信息性的消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是我们第一次真正的API调用的时候了。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="aacb" class="ny md it nt b gy nz oa l ob oc">@app.get("/poke/{pokemon_name}")<br/>def get_pokemon_by_name(pokemon_name: str = Path(None,  <br/>                       description="Name of the pokemon you'd like <br/>                                   to retrieve")):</span><span id="648f" class="ny md it nt b gy od oa l ob oc">    pokemon = get_poke_by_name(pokemon_name)</span><span id="b0e0" class="ny md it nt b gy od oa l ob oc">    if not pokemon:<br/>        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, <br/>                           detail="Pokemon not found")</span><span id="20bb" class="ny md it nt b gy od oa l ob oc">    return {"Pokemon": pokemon[0],<br/>            "Types": [pokemon[1], pokemon[2]],<br/>            "HP": pokemon[4],<br/>            "Attack": pokemon[5],<br/>            "Special Attack": pokemon[6],<br/>            "Defense": pokemon[7],<br/>            "Special Defense": pokemon[8],<br/>            }</span></pre><p id="ce74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这个片段，让我们先介绍一下路径参数。</p><p id="de1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">路径参数是用户通过请求路径传递的参数。<br/>在我们的函数中，<code class="fe nq nr ns nt b">pokemon_name</code>是一个路径参数，这意味着如果用户键入<code class="fe nq nr ns nt b">&lt;server&gt;/poke/Pikachu</code>，我们将进入带有参数<code class="fe nq nr ns nt b">pokemon_name="Pikachu"</code>的函数<code class="fe nq nr ns nt b">get_pokemon_by_name</code>。</p><p id="8a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用path类来指定函数的参数是路径参数。将<code class="fe nq nr ns nt b">None</code>指定为第一个参数意味着如果没有pokemon名称被传递，默认值将是<code class="fe nq nr ns nt b">None</code>。</p><p id="b299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数体中，我们将首先检查所需的口袋妖怪是否存在，如果不存在，我们将引发一个异常，通知用户我们没有找到它。<br/>如果我们找到了它，我们将使用我们想要检索的信息创建一个定制的JSON。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/519a6ef1b0d10343fe4b152f51d3ce55.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*ga-aZ0iaHlnLec3yD-kfpg.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">口袋妖怪_name = "皮卡丘"</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个API请求将基于主要和次要类型检索多个口袋妖怪。<br/>我们将允许仅基于主要类型或两种类型进行查询，这意味着次要类型将是可选的。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="2b16" class="ny md it nt b gy nz oa l ob oc">@app.get("/poketype/{poke_type}")<br/>def get_pokemon_by_type(poke_type: str =  <br/>                        Path(None,description="Primary type of the <br/>                        pokemons you want to query),<br/>                        type2: Optional[str] = None):</span><span id="835f" class="ny md it nt b gy od oa l ob oc">    pokemons = get_poke_by_type(poke_type, type2)</span><span id="d92f" class="ny md it nt b gy od oa l ob oc">    if not pokemons:<br/>        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,<br/>                            detail="No pokemon with this type")<br/>    result = {}<br/>    for idx, pokemon in enumerate(pokemons):<br/>        result[idx] = {"Pokemon": pokemon[0],<br/>                       "Types": [pokemon[1], pokemon[2]],<br/>                       "HP": pokemon[4],<br/>                       "Attack": pokemon[5],<br/>                       "Special Attack": pokemon[6],<br/>                       "Defense": pokemon[7],<br/>                       "Special Defense": pokemon[8],<br/>                       }<br/>    return result</span></pre><p id="fcd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次<code class="fe nq nr ns nt b">poke_type</code>将是我们的路径参数，我们还有第二个可选参数——您不必像我一样用类<code class="fe nq nr ns nt b">Optional</code>来指定它，但是它将更具可读性。</p><p id="1820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像前面的API调用一样，如果我们没有找到任何指定类型的口袋妖怪，我们将返回一些错误异常。</p><p id="b9d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们确实找到了至少一个口袋妖怪，我们将检查我们得到的列表，并返回一个字典，其中的每一项都是包含口袋妖怪统计数据的字典。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/f246e1bd20725c8d2c63a0044ab210ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*Eb8m_Iww9pLuHfIDJpkpXw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">主要类型=“草”，次要类型=“毒”</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="9d81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们刚刚处理了两个GET请求，所以现在是时候发布、上传和删除请求了，这些请求将用于添加、更新和删除口袋妖怪。</p><p id="bbfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些类型的请求需要请求体——不像我们之前使用的查询和路径参数。请求体将是我们存储在数据库中的对象——一个口袋妖怪。<br/>我们将添加一个用属性和属性类型定义口袋妖怪的类。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="3ede" class="ny md it nt b gy nz oa l ob oc">class Pokemon(BaseModel):<br/>    name: str<br/>    primary_type: str<br/>    secondary_type: str<br/>    sum_stats: int<br/>    hit_points: int<br/>    attack_strength: int<br/>    defensive_strength: int<br/>    special_attack_strength: int<br/>    special_defensive_strength: int</span></pre><p id="e34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在请求中使用这个类</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="0df5" class="ny md it nt b gy nz oa l ob oc">@app.post("/newPoke/{pokemon_name}")<br/>def create_pokemon(pokemon_name: str, pokemon: Pokemon):<br/>    if get_poke_by_name(pokemon_name):<br/>        raise HTTPException(<br/>              status_code=status.HTTP_406_NOT_ACCEPTABLE, <br/>              detail="Pokemon already exists") </span><span id="63ed" class="ny md it nt b gy od oa l ob oc">   add_poke_to_db(pokemon.name, pokemon.primary_type, <br/>                   pokemon.secondary_type,<br/>                   pokemon.sum_stats, pokemon.hit_points,<br/>                   pokemon.attack_strength,<br/>                   pokemon.special_attack_strength,<br/>                   pokemon.defensive_strength,<br/>                   pokemon.special_defensive_strength)</span><span id="8bd1" class="ny md it nt b gy od oa l ob oc">   raise HTTPException(<br/>         status_code=status.HTTP_201_CREATED,  <br/>         detail="Pokemon created successfully")</span></pre><p id="ddab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，作为一个参数，这个函数将得到一个<code class="fe nq nr ns nt b">Pokemon</code>对象，它将包含在我们的数据库中创建一个新的口袋妖怪所必需的所有细节。</p><p id="f774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数体相当简单，首先，我们检查是否已经有一个口袋妖怪与我们传递的名字相同。<br/>如果我们没有这样的口袋妖怪，我们将使用我们在数据库部分编写的函数来创建它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/c0b4c83ea86d5595bea33be00fe979d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5bEHrgzC_mq4ewellF0Rw.jpeg"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="aecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续我们的更新方法</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="1e4d" class="ny md it nt b gy nz oa l ob oc">@app.put("/updatePoke/{pokemon_name}")<br/>def update_pokemon(pokemon_name: str, pokemon: Pokemon):<br/>    if not get_poke_by_name(pokemon_name):<br/>        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, <br/>                           detail="Pokemon not found")</span><span id="2288" class="ny md it nt b gy od oa l ob oc">     update_poke(pokemon.name, pokemon.primary_type,<br/>                pokemon.secondary_type,<br/>                pokemon.sum_stats, pokemon.hit_points,<br/>                pokemon.attack_strength,<br/>                pokemon.special_attack_strength,<br/>                pokemon.defensive_strength,<br/>                pokemon.special_defensive_strength)</span><span id="d4c2" class="ny md it nt b gy od oa l ob oc">     raise HTTPException(status_code=status.HTTP_200_OK,<br/>                        detail="Pokemon details updated")</span></pre><p id="b8b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看了前面的方法之后，这一个可能看起来相当不言自明。<br/> -通过<code class="fe nq nr ns nt b">Pokemon</code>参数获取请求体。<br/> -检查我们要更新的口袋妖怪是否存在。<br/> -如果口袋妖怪存在，发送口袋妖怪参数到匹配的数据库函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/79ef63bf36197eef6385d735aee6f70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*rMF9ZBAfrqyBYlmweWuTKA.jpeg"/></div></figure><p id="5fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有我们将更改的参数将被设置—其余的将保持与请求前相同(基于我们如何实现匹配的数据库功能)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜，我们已经达到了最后的要求。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="f821" class="ny md it nt b gy nz oa l ob oc">@app.delete("/deletePoke/{pokemon_name}")<br/>def delete_pokemon(pokemon_name: str):<br/>    if not get_poke_by_name(pokemon_name):<br/>        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,<br/>                            detail="Pokemon not found")<br/>     delete_poke(pokemon_name)</span><span id="f91b" class="ny md it nt b gy od oa l ob oc">     raise HTTPException(status_code=status.HTTP_200_OK,<br/>                        detail="Pokemon deleted successfully")</span></pre><p id="448b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这到现在看起来很简单。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7ec7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何执行</h1><p id="3779" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了运行我们的API并开始运行，只需进入你的项目文件夹并在终端中输入</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="863f" class="ny md it nt b gy nz oa l ob oc">uvicorn pokeapi:app --reload</span></pre><p id="6182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns nt b">pokeapi</code> —定义API的文件名。</p><p id="dbbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nq nr ns nt b">app</code> —保存对象的变量名称<code class="fe nq nr ns nt b">FastAPI</code>。</p><p id="14af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你做了，你应该能看到这个</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/ed76f529476960c6d984abda6293e449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*SMi4larL2YNLzdiE4SMzLA.jpeg"/></div></figure><p id="571b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在去<code class="fe nq nr ns nt b">http://127.0.0.1:8000/docs</code>开始到处玩。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8379" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="a277" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们学习了如何从零开始创建一个与数据库集成的API，并经历了所有主要使用的请求类型。</p><p id="c88e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的<a class="ae ky" href="https://github.com/DevEliran/PokeAPI" rel="noopener ugc nofollow" target="_blank"> GitHub </a>查看完整代码。</p><p id="13ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我想向你介绍我的<a class="ae ky" href="http://codingkaiser.blog" rel="noopener ugc nofollow" target="_blank">博客</a>，在那里你可以找到更多我的作品。</p><p id="f188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你考虑成为中级会员并希望支持我，你可以在我的<a class="ae ky" href="https://eliran9692.medium.com/membership" rel="noopener">推荐链接</a>注册。</p></div></div>    
</body>
</html>