<html>
<head>
<title>Why and How I Created Another Console Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我为什么以及如何创建另一个控制台框架</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dotnet-cosole-framework-3d5ebce96b8f?source=collection_archive---------12-----------------------#2020-05-11">https://levelup.gitconnected.com/dotnet-cosole-framework-3d5ebce96b8f?source=collection_archive---------12-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有时候，为了学习，我们需要找借口开始一个新项目</h2></div><p id="fe55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">控制台应用程序正在成为开发者的病毒工具。在将每一个非可视化工具转移到GUI以获得更好的控制的趋势之后，最近几年，我们看到了CLI的成功。提醒一下Docker和Kubernetes。在过去的几个月里，我开发了一个名为<a class="ae le" href="https://github.com/arduosoft/RawCMS/" rel="noopener ugc nofollow" target="_blank"> RawCMS </a>的开源无头CMS，并在上面放了一个CLI应用程序。我通过使用。Net market，最后体验不怎么样。我完成了任务，但是下一次我必须开发客户端应用程序时，我决定投入一些时间尝试做得更好。我开发了一个简单的控制台框架，可以自动执行命令并与用户交互。</p><p id="15da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将解释我是如何做到的——集中在我学到的令人兴奋的部分。像往常一样，代码可以在GitHub上获得，我发布了一个Nuget包用于测试(文章末尾有链接)。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/a0d2fbf1a3a150299867a020a0b26ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xz3fTs79X6Mp6O8r"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@halgatewood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈尔·盖特伍德</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="e170" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么是另一个控制台框架</h1><p id="0a1f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">诚实的回答是因为我需要找一个借口来测试Github的行为。我可以为此做一个虚拟项目，但我不喜欢太多的假东西。这就是为什么我接受了我最后一次可怜的经历。net RawCMS CLI可以尝试做一些有用的东西。现在我会试着找一个理性的理由。</p><p id="9213" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我到目前为止使用的框架Commandlineparser工作正常，并且结构良好。它有一个简单的方法:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1a58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这导致代码组织如下:</p><ul class=""><li id="752d" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated">您为映射输入每个命令创建一个类</li><li id="9715" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">在这个类中，您将在每个将从命令行输入解析的字段上定义注释</li><li id="f323" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">您将定义一段接收类输入的代码</li></ul><p id="6cdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现这种方法结构非常好，对模型和业务逻辑有很好的定义。无论如何，对于一个简单的项目，要求你产生许多类，保持它们同步，这对于非常简单的程序来说是一堆时间。此外，它不支持在交互模式下工作或自动化脚本。</p><p id="c0b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了克服这些限制，我决定使用一种不同的方法:</p><ol class=""><li id="cdf8" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld ni na nb nc bi translated">参数和命令定义将从方法注释中自动导出</li><li id="86e2" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">我将实现一个架构，允许用户直接调用一个命令，或者简单地定义一个脚本并运行它，利用其中的命令</li></ol><p id="1792" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我试图解释的不清楚，也许我们需要一个例子。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1607" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以像这样使用它:</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="1f4c" class="no lw it nk b gy np nq l nr ns">&gt; MyProgram.exec CommandName --arg value --arg2 value<br/>&gt; MyProgram.exec Exec MySettings.yaml # (settings from file input!)<br/>&gt; MyProgram.exec</span><span id="d7d8" class="no lw it nk b gy nt nq l nr ns">Welcome to MyProgram!<br/>This is the commands available, digit the number to get more info<br/>0 - info: Display this text<br/>1 - MyMethod: Execute a test method</span></pre><p id="f396" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望现在已经有点清楚了。</p><h1 id="accd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">它是如何工作的</h1><p id="5929" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这个工具非常简单。它可以从上到下分解成几个子部分:</p><ol class=""><li id="b9a9" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld ni na nb nc bi translated">流畅的注册课程</li><li id="5692" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">程序定义(要执行的命令序列)</li><li id="10a5" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">命令实现</li><li id="b47f" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">基本执行</li></ol><h2 id="fb46" class="no lw it bd lx nu nv dn mb nw nx dp mf kr ny nz mh kv oa ob mj kz oc od ml oe bi translated">流畅的注册课程</h2><p id="06b9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">该类旨在提供一种集成到控制台应用程序中的简单方法。你需要这样的东西:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="7e4b" class="no lw it bd lx nu nv dn mb nw nx dp mf kr ny nz mh kv oa ob mj kz oc od ml oe bi translated">程序定义(要执行的命令序列)</h2><p id="919d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">控制台解析以表示程序定义的类的水合结束。该类包含要执行的命令列表和它们需要工作的参数。所有将在运行时执行的东西都来自这些命令。例如，欢迎消息是每次执行的命令，或者有一个显示所有可用选项的“info”命令。</p><p id="5e17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是程序定义:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4b2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是从YAML脚本文件或通过命令行调用加载的。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h2 id="eb99" class="no lw it bd lx nu nv dn mb nw nx dp mf kr ny nz mh kv oa ob mj kz oc od ml oe bi translated">命令实现</h2><p id="2c5e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">命令实现表示可以调用的命令。我创建了两个注释，一个用于将常规方法提升为命令，另一个用于描述参数。</p><p id="0082" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用法大概是这样的:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ace7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ConsoleAuto扫描所有程序集以查找所有命令，并将其添加到内部可用命令集中。</p><h2 id="b96d" class="no lw it bd lx nu nv dn mb nw nx dp mf kr ny nz mh kv oa ob mj kz oc od ml oe bi translated">基本执行</h2><p id="ee2a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">当用户要求执行命令时，该类由。net core DI和使用反射执行的方法。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="092c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">DevOps设置</h1><p id="6e02" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在这个有趣的库中呆了几个小时后，我终于可以开始测试GitHub的动作了。</p><p id="3e17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想要建立的是一个简单的流程:</p><ol class=""><li id="b7c5" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld ni na nb nc bi translated">构建代码</li><li id="23df" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">测试代码</li><li id="5f95" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">将代码打包成一个Nuget包</li><li id="737e" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">将包推送到NuGet</li></ol><p id="d6c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">git hub的设置很简单，您只需要在。github/workflows文件夹。</p><p id="c44f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我用的文件是这个。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8561" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意基于渐进式版本号的自动版本控制。</p><p id="4470" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些步骤是:</p><ol class=""><li id="db7a" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld ni na nb nc bi translated">修补版本</li><li id="9c3d" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">建设</li><li id="a978" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">试验</li><li id="8924" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">发布到NuGet</li></ol><p id="6e82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">替换中的版本可以很容易地完成路径。csproj文件。这是第一步，以便所有后续编译都使用正确的内部版本号。</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="92ca" class="no lw it nk b gy np nq l nr ns">sed -i "s/1.0.0/1.0.$GITHUB_RUN_NUMBER.0/g" ConsoleAuto/ConsoleAuto.csproj</span></pre><p id="0621" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该脚本假设在csproj中总是有版本标签1.0.0。您可以使用regexp来改进这个解决方案。</p><p id="3e24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">build\test命令非常标准，相当于</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="136b" class="no lw it nk b gy np nq l nr ns">dotnet restore<br/>dotnet build --configuration Release --no-restore<br/>dotnet test --no-restore --verbosity normal</span></pre><p id="8956" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后的发布步骤是一个第三方插件，它在内部运行pack命令和push命令。如果你看看GitHub的历史，你会发现类似的东西:</p><pre class="lg lh li lj gt nj nk nl nm aw nn bi"><span id="90b5" class="no lw it nk b gy np nq l nr ns">dotnet pack  --no-build -c Release ConsoleAuto/ConsoleAuto.csproj <br/>dotnet nuget push *.nupkg </span></pre><h1 id="4232" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我从这次经历中学到了什么</h1><p id="4c43" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在我们的领域里，我们所需要的一切都已经被发现或完成了。完成一项任务的最快方法是用你找到的东西去做。永远不要重新发明轮子。无论如何，当你需要学习新的东西时，你可能会受到鼓励，尝试创造一些有用的东西。这样可以让你的学习更实际，让你和现实问题产生冲突。</p><p id="dcac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个图书馆度过了一个星期六之后，我学到了:</p><ul class=""><li id="3c64" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated">已经有一个库可以自动将表单方法映射到命令行参数。这个库做得非常好，它还有一个web界面，可以使用swagger UI可视化地运行命令。</li><li id="55e6" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">GitHub的动作非常酷，但是问题出在第三方插件上，这些插件没有很好的文档记录，也不能完全正常工作。给他们一些时间让他们成熟。但是对于这个话题，我需要另一篇文章😃</li></ul><h1 id="a54d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="a19e" class="mu mv it kk b kl mn ko mo kr of kv og kz oh ld mz na nb nc bi translated"><a class="ae le" href="https://github.com/zeppaman/ConsoleAuto" rel="noopener ugc nofollow" target="_blank">GitHub上的ConsoleAuto项目</a></li><li id="d39b" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><a class="ae le" href="https://github.com/arduosoft/RawCMS" rel="noopener ugc nofollow" target="_blank"> RAWCMS </a> —上面提到的无头CMS</li><li id="3c1f" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated">文中提到的库有<a class="ae le" href="https://github.com/commandlineparser/commandline" rel="noopener ugc nofollow" target="_blank"> Commandlineparser </a>和<a class="ae le" href="https://github.com/Cysharp/ConsoleAppFramework" rel="noopener ugc nofollow" target="_blank"> ConsoleAppFramework </a>，我建议测试一下作为首选。</li></ul></div></div>    
</body>
</html>