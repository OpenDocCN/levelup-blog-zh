<html>
<head>
<title>Deep Understanding of Golang Mutex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对Golang互斥体的深入理解</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deep-understanding-of-golang-mutex-9964b02c56e9?source=collection_archive---------2-----------------------#2022-09-22">https://levelup.gitconnected.com/deep-understanding-of-golang-mutex-9964b02c56e9?source=collection_archive---------2-----------------------#2022-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cc4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何实现Golang互斥体</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5a0342010aa738d80d2e756632fb0201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*BWLrf8Kh0LvhK9nuqnH9jg.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">丹尼尔·西兰特夫在<a class="ae ku" href="https://unsplash.com/s/photos/home?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8cb7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在开始之前，我们需要添加几种实现锁的方法。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="5f0e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> #旗语。</strong></p><p id="9461" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">操作系统中有P和V操作。P操作是将信号量改变-1，V操作是将信号量增加1，所以信号量的操作方式是:</p><ul class=""><li id="cf54" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">初始化，给它一个非负整数值。</li><li id="2b8f" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">程序试图进入临界块的进程需要先运行P。那么将会有两种情况。</li></ul><ol class=""><li id="9aca" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq mm me mf mg bi translated">当信号量S减少到负值时，进程将被阻塞，无法继续。此时，进程被阻塞。</li><li id="cf2e" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq mm me mf mg bi translated">当信号量S不为负时，该进程可以被允许进入临界块。</li></ol><ul class=""><li id="cd9f" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">为了结束离开临界块的进程，将运行V。当信号量S不为负时，先前被阻塞的其他进程将被允许进入临界块。</li></ul><p id="b54e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> #信号量和锁。</strong></p><p id="8d01" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">虽然信号量和锁看起来很像，比如信号量为1时，实现了互斥锁，但实际上，它们的含义是不同的。</p><p id="c017" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">锁用于保护关键资源，例如不能同时执行读和写。</p><p id="fc46" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">信号量是为了确保进程(或线程或goroutine)被调度。比如三个进程共同计算c=a+b，首先a+b的计算和赋值操作不能同时进行。其次，要保证先执行a+b。c是在赋值之后执行的，所以这个地方需要以信号量的形式来完成。</p><p id="a039" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此外，锁可以通过信号量来实现，然后goroutine可以根据规定被阻塞和唤醒，或者它可以通过旋转锁来实现，然后goroutine将占用CPU，直到它被解锁。</p><p id="e750" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这两种方法的区别在于是否需要goroutine调度，但本质上，锁的实现是为了保证关键资源不会被错误访问。</p><p id="7d8c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> #旋转锁。</strong></p><p id="70db" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">CAS理论是一种自旋锁。</p><p id="c70b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同一时间只能有一个线程获得锁，没有获得锁的线程通常有两种处理方法:</p><ul class=""><li id="da35" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">它一直在循环中等待确定资源是否已经释放了锁。这种锁称为旋转锁，它不会阻塞线程(非阻塞)。</li><li id="9fda" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">阻塞自己，等待重新调度请求，这是互斥的。</li></ul><p id="daf5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">自旋锁的原理相对简单。如果持有锁的线程可以在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要在内核态和用户态之间切换进入阻塞状态，它们只需要等待一分钟(spin)，等到持有锁的线程释放锁后再获取，这样就避免了用户进程和内核切换的消耗。</p><p id="7a29" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是如果长时间锁定，自旋锁的开销会非常大，它会阻止其他线程运行和调度。</p><p id="276c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">线程持有锁的时间越长，持有该锁的线程被OS调度程序中断的风险就越大。</p><p id="5b85" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果发生中断，其他线程将继续运行(反复尝试获取锁),而持有锁的线程不打算释放锁，这将导致无限延迟，直到持有锁的线程可以完成并释放锁。</p><p id="351f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">解决上述情况的一个好方法是为自旋锁设置一个自旋时间，时间一到就释放自旋锁。</p><p id="cea3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">旋转锁的目的是占用CPU资源而不释放它们，并在获得锁时立即处理它们。</p><p id="aa23" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> #悲观锁定和乐观锁定。</strong></p><p id="4c93" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">悲观锁定是一种悲观的思维。它总是认为最坏的情况可能会发生。它认为数据很可能被他人修改。无论是读还是写，悲观锁在执行操作之前都会被锁定。</p><p id="0d2b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">读写都需要锁，导致性能低，所以悲观锁的机会不多。但是，在多次写入的情况下，仍然有机会使用悲观锁，因为乐观锁会在写入不一致的情况下不断重试，这样会浪费更多的时间。</p><p id="8fbc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">乐观锁定的思想与悲观锁定的思想相反。它始终认为资源和数据不会被别人修改，所以读不会被锁，但是乐观锁会决定写操作时当前数据是否被修改过。。</p><p id="8dd4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">乐观锁的实现方案主要包括CAS和版本号机制。乐观锁定适用于多次读取的情况，可以提高吞吐量。</p><p id="50ee" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">CAS代表比较和交换，这是一种众所周知的无锁算法。</p><p id="09ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">即在不使用锁的情况下实现多个线程之间的变量同步，也就是在不阻塞线程的情况下实现变量同步，所以也叫非阻塞同步。</p><p id="703b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">CAS涉及三种关系:指向内存区域的指针V、旧值A和要写入的新值B。</p><p id="e720" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">CAS实现的乐观锁会带来ABA问题。同时，整个乐观锁会在数据不一致的情况下触发等待和重试机制，对性能影响很大。</p><p id="a61a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">版本号机制通过版本号版本实现版本控制。</p><p id="144e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">好了，有了以上的基础知识，我们就可以开始分析Golang是如何实现互斥的了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="1923" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Golang对互斥体的实现一直在改进，截至目前主要改进了4个版本:</p><ul class=""><li id="206a" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">V1:简单的实现。</li><li id="6615" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">V2:新的goroutine参加锁比赛。</li><li id="6efa" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">给新人更多的机会。</li><li id="1523" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">V4:解决老的goroutine饥饿问题。</li></ul><p id="f121" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每一次改进都是为了提高系统的整体性能。这种升级是渐进和持续的，所以有必要从V1版本开始慢慢看互斥体的演变。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="07dc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">V1:简单的实现。</p><p id="a2d8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在V1版本中，互斥体的完整源代码如下。</p><div class="mn mo gp gr mp mq"><a href="https://github.com/golang/go/blob/d90e7cbac65c5792ce312ee82fbe03a5dfc98c6f/src/pkg/sync/mutex.go" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">go/mutex . go at d 90 e 7 cbac 65 c 5792 ce 312 ee 82 FBE 03 a5 DFC 98 c 6 f golang/go</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ko mq"/></div></div></a></div><p id="3683" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">主要核心代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="209b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，<code class="fe nh ni nj nk b">Mutex</code>的结构非常简单，包括两个标志，<code class="fe nh ni nj nk b">key</code>和<code class="fe nh ni nj nk b">sema</code>。</p><p id="bf1f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj nk b">key</code>表示有几个goroutines正在使用或准备使用该锁。如果<code class="fe nh ni nj nk b">key==0</code>，表示当前互斥体解锁，否则<code class="fe nh ni nj nk b">key&gt;0</code>表示互斥体锁定。</p><p id="2f23" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj nk b">sema</code>是信号量，它实际上是导致<code class="fe nh ni nj nk b">goroutine</code>阻塞和唤醒的原因。</p><p id="6544" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj nk b">xadd</code>函数是基于CAS的加减函数。</p><p id="3e54" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj nk b">Lock</code>和<code class="fe nh ni nj nk b">Unlock</code>函数是锁定当前互斥体的核心，但逻辑很简单。</p><p id="de02" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj nk b">Lock</code>函数使用<code class="fe nh ni nj nk b">xadd</code>方法来<code class="fe nh ni nj nk b">key+1</code>。如果结果为<code class="fe nh ni nj nk b">1</code>，则说明原锁处于解锁状态，不需要关注信号量直接获取锁。如果没有，调用<code class="fe nh ni nj nk b">semacquire</code>方法来阻塞当前的goroutine。</p><p id="cc26" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj nk b">Unlock</code>函数使用<code class="fe nh ni nj nk b">xadd</code>方法来配对<code class="fe nh ni nj nk b">key-1</code>。如果结果不是<code class="fe nh ni nj nk b">0</code>，则意味着一个goroutine正在等待，需要调用<code class="fe nh ni nj nk b">semrelease</code>来唤醒一个goroutine。</p><p id="17c1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在当前的V1版本中，锁定和解锁完全基于FIFO方法。这种方法虽然很公平，但从效率的角度来看并不是最优的。</p><p id="38eb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">想象一个场景:被阻塞的goroutine(将当前goroutine命名为g1)一定不能占用CPU，所以需要在g1被唤醒后进行上下文切换。如果此时出现新的goroutine (g2 ),它将拥有CPU资源。</p><p id="a7d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果锁给了g2，那么它可以立即执行并返回结果(不用等待g1的上下文切换)，这样整体效率可以提高一个档次。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="d792" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> V2:新歌路汀参加锁比赛。</strong></p><p id="9da3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">完整的源代码地址位于:<a class="ae ku" href="https://github.com/golang/go/blob/weekly.2011-07-07/src/pkg/sync/mutex.go" rel="noopener ugc nofollow" target="_blank">https://github . com/golang/go/blob/weekly . 2011-07-07/src/pkg/sync/mutex . go</a></p><p id="15e4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在V2版本中，核心特征是一个goroutine在被唤醒后并不立即执行任务，而是仍然重复抢占锁的过程，以便新的go routine有机会获取锁，这就是所谓的新人机会。</p><p id="8a4d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">互斥结构和常量定义如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6207" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">虽然互斥结构的定义基本不变，但是从V1的<code class="fe nh ni nj nk b">key</code>到V2的<code class="fe nh ni nj nk b">state</code>，它们的内部结构却大不相同。</p><p id="b98f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第0位代表锁定状态(L)，即<code class="fe nh ni nj nk b">0</code>代表解锁，<code class="fe nh ni nj nk b">1</code>代表锁定，第1位代表唤醒状态(W)，第2位到第31位代表阻塞等待次数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ddd3d7c5f72f646c225bbf1d1ed76f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*_aGSxVA7YJpaUsb7fmQaMA.png"/></div></figure><p id="6f02" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nh ni nj nk b">mutexLocked</code>的值是<code class="fe nh ni nj nk b">0x1</code>,<code class="fe nh ni nj nk b">mutexWoken</code>的值是<code class="fe nh ni nj nk b">0x2</code>,<code class="fe nh ni nj nk b">mutexWaiterShift</code>的值是<code class="fe nh ni nj nk b">0x2</code>,<code class="fe nh ni nj nk b">mutexWaiterShift</code>表示任何代表阻塞等待数的数组都需要左移两位。</p><p id="1e4c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">V2版本的主要改进存在于锁方法中，代码如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b398" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第2–4行中的代码逻辑适用于解锁状态，通过将L位从<code class="fe nh ni nj nk b">0</code>设置到<code class="fe nh ni nj nk b">1</code>，goroutine通过CAS获取锁定。</p><p id="0f84" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这一点上没有争用，所以获得锁几乎不需要任何成本。</p><p id="65e0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来的代码被访问表示当前被锁定，即L位为<code class="fe nh ni nj nk b">1</code>。</p><p id="fa52" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，goroutine进入一个循环，在这个循环中，CAS方法确保新状态被正确叠加。</p><p id="3639" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从旧状态到新状态(新)的主要变化包括:</p><ul class=""><li id="4491" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">尝试获取锁。</li><li id="ed05" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">尝试将服务员的数量增加1。</li></ul><p id="6cfe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由于更改不是原子性的，因此可能会导致旧状态变得陈旧。</p><p id="5e35" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">比如当前处于解锁状态，两个goroutines同时获取旧状态，都处于解锁状态，但总有一个能得到锁，另一个不能。</p><p id="b6c7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同样，即使当前状态被锁定，旧状态也会由于等待者的数量而过时。</p><p id="137b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，您需要继续通过循环获得新的旧状态。</p><p id="b689" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在旧状态未过时并覆盖新状态后，进入真正的锁定步骤。</p><p id="141b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果旧状态解锁，则直接获得锁，否则通过信号量机制阻塞当前的goroutine。</p><p id="f307" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">被唤醒后，不像V1，当前进程还是会陷入for循环重新抢锁，这是给新人机会的体现:</p><ul class=""><li id="93f4" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">如果在上下文切换期间旧的goroutine有了新的goroutine，锁将被给予新的goroutine。</li><li id="8d6f" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">如果在上下文切换完成后，旧的goroutine仍然没有新的goroutine，那么锁将被给予旧的goroutine。</li></ul><p id="0d08" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">解锁方法相对简单。代码如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4e63" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">解锁逻辑主要有两个。</p><ul class=""><li id="d9fe" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">如果没有服务员或者当前系统未锁定并且有唤醒程序，则直接返回。</li><li id="85ab" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">如果不满足上述要求，等待的次数将减一，队列头的Goroutine将通过信号量被唤醒。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="c14d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> V3:多给新人一些机会。</strong></p><p id="15e8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个版本的优化，关键在于</p><p id="f04d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ku" href="https://github.com/golang/go/commit/edcad8639a902741dc49f77d000ed62b0cc6956f" rel="noopener ugc nofollow" target="_blank">https://github . com/golang/go/commit/edcad 8639 a 902741 DC 49 f 77d 000 ed 62 b 0 cc 6956 f</a></p><p id="aeed" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在V2的基础上，如何进一步提高性能？很多时候，协程独占锁期间对数据的操作其实是很低的，可能比唤醒+切换上下文的耗时还要低。</p><p id="804a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">想象一个场景:GoroutineA有CPU资源，GoroutineB在阻塞队列的最前面。然后当GoroutineA试图获取锁时，它发现当前锁已被占用。根据V2策略，GoroutineA会立即被阻塞，假设此时锁已被锁定。如果被释放，那么GoroutineB将按计划被唤醒，即整个运行时间包括GoroutineB的唤醒+上下文切换时间。</p><p id="a86c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在V3中，允许新的Goroutine (GoroutineA)通过旋转等待一段时间。如果在等待时间内释放了锁，新的Goroutine立即获得锁资源，避免了旧的Goroutine的唤醒+上下文切换的耗时，提高了整体工作效率。</p><p id="8cca" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同样，V3的改进主要集中在<code class="fe nh ni nj nk b">Lock</code>方法上，代码如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6b94" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">与V2的实现代码相比，主要集中在第14–25行，多了两个函数<code class="fe nh ni nj nk b">runtime_canSpin</code>和<code class="fe nh ni nj nk b">runtime_doSpin</code>，是自旋锁的核心。</p><p id="12df" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先是<code class="fe nh ni nj nk b">runtime_canSpin</code>功能。传入的参数是<code class="fe nh ni nj nk b">iter</code>(代表当前的旋转次数)。runtime_canSpin函数的实现功能是确定是否可以进入当前的自旋等待状态。</p><p id="f854" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如前所述，自旋锁等待不释放CPU资源，不存在上下文切换的消耗，但如果自旋时间过长，会导致无意义的CPU消耗，进而影响性能。</p><p id="60ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，在使用自旋锁时，必须严格控制自旋锁的进入过程。</p><p id="7e06" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后是<code class="fe nh ni nj nk b">runtime_doSpin</code>函数，可以简单理解为CPU空闲一段时间，也就是自旋过程。</p><p id="dc2b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">整个过程非常清楚。所有占用CPU的Goroutines都在runtime_canSpin函数通过检查后执行spin操作。如果在旋转操作完成后它们仍然没有持有锁，则Goroutine被阻塞。其他逻辑与V2相同。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="80d6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"> V4:解决老goroutine饥饿问题。</strong></p><p id="7bde" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">源地址位于:<a class="ae ku" href="https://github.com/golang/go/blob/go1.15.5/src/sync/mutex.go" rel="noopener ugc nofollow" target="_blank">https://github . com/golang/go/blob/go 1 . 15 . 5/src/sync/mutex . go</a></p><p id="22a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">V2到V3的改进是为了给新的goroutines更多的机会，导致老的goroutines可能抢不到新的goroutines的饥饿问题，所以这个问题在V4中重点改进。</p><p id="fdf2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先是互斥结构的State字段有了新的变化，增加了饥饿指示器。</p><p id="7cf9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其中<code class="fe nh ni nj nk b">0</code>表示没有发生饥饿，<code class="fe nh ni nj nk b">1</code>表示发生了饥饿。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/334bd84d393487fe9064f03ed1a82d43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJxfWDDhhfFv7sGFisDCQQ.png"/></div></div></figure><p id="0a84" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在新的定义中，常数的定义也有一些变化。</p><pre class="kj kk kl km gt nr nk ns nt aw nu bi"><span id="1e6e" class="nv nw it nk b gy nx ny l nz oa">const (<br/>    mutexLocked = 1 &lt;&lt; iota <em class="ob">// mutex is locked<br/></em>    mutexWoken<br/>    mutexStarving <em class="ob">// </em>separate out a starvation token from the state field<em class="ob"><br/></em>    mutexWaiterShift = iota<br/>    starvationThresholdNs = 1e6    <br/>)</span></pre><p id="308d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Lock方法的逻辑如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ef2b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们关注洛克斯洛方法。在深入研究代码之前，我们首先需要了解在什么情况下当前锁被认为是饥饿的:</p><ul class=""><li id="d359" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">(场景1)旧的Goroutine被唤醒，但是锁被新的Goroutine占用，因为旧的Goroutine“我被唤醒并且什么也没做，并且立即再次被阻塞”。</li><li id="fef0" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">(场景2)go routine被阻塞的总时间超过了阈值(默认值为1毫秒)。</li></ul><p id="42cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">所以核心是记录当前Goroutine开始等待的时间:对于最先进入锁的Goroutine，开始等待时间为0。对于场景1，判断标准是开始等待时间是否为0。如果不是0，说明之前已经被屏蔽了。通过(第45行)。</p><p id="9a71" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于场景2，判断标准是当前时间和开始等待时间之差是否超过阈值。如果是这样，这意味着Goroutine已经等待了太长时间，应该进入饥饿状态(第50行)。</p><p id="ca2c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">进一步，当我们知道饥饿状态是如何判断的，饥饿模式和非饥饿模式有什么区别？</p><p id="1175" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，如果当前锁是饥饿的，任何新的Goroutines都不会旋转(第15行)。</p><p id="e94a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第二，如果当前的Goroutine处于饥饿状态，当它被阻塞时，它将被添加到等待队列的头部(下一个唤醒操作肯定会唤醒当前饥饿的Goroutine，第45–49行)。</p><p id="dad6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，饥饿的goroutine被允许在被唤醒后立即持有锁，而无需与其他goro utine重新竞争锁(比较V2，第52–62行)。</p><p id="342d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对应于V4的解锁也根据饥饿状态进行了调整。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4d45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">与上锁操作相比，解锁操作要容易理解得多。</p><p id="dfce" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在正常模式下，解锁操作与以前的版本相同。在饥饿模式下，位于阻塞队列顶部的协同程序将被直接唤醒。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="de09" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢阅读。</p><p id="a528" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你喜欢这样的故事，想支持我，请给我鼓掌。</p><p id="fad8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你的支持对我来说非常重要，谢谢你。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a0ab" class="oc nw it bd od oe of og oh oi oj ok ol jz om ka on kc oo kd op kf oq kg or os bi translated">分级编码</h1><p id="d00a" class="pw-post-body-paragraph kv kw it kx b ky ot ju la lb ou jx ld le ov lg lh li ow lk ll lm ox lo lp lq im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="60f8" class="ly lz it kx b ky kz lb lc le ma li mb lm mc lq md me mf mg bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="3fe5" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">📰更多内容请查看<a class="ae ku" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="8f47" class="ly lz it kx b ky mh lb mi le mj li mk lm ml lq md me mf mg bi translated">🔔关注我们:<a class="ae ku" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ku" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ku" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="1baf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">🚀👉<a class="ae ku" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>