<html>
<head>
<title>Setting up mTLS and Kestrel (cont.)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置mTLS和Kestrel(续。)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/setting-up-mtls-and-kestrel-cont-3f4deb849e47?source=collection_archive---------15-----------------------#2020-07-22">https://levelup.gitconnected.com/setting-up-mtls-and-kestrel-cont-3f4deb849e47?source=collection_archive---------15-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bbe22612b28540ea9385d2992a08ebcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8YKAK0K2TPB5DsZ9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@christianw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·威迪格</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2f9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/setting-up-mtls-and-kestrel-a4f8b146a32e">上一篇文章</a>中，我们开始谈论mTLS。在帖子中我指出客户端证书的签名证书没有被验证，让我们来解决这个问题吧！</p><h1 id="02e8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">问题是</h1><p id="560f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/setting-up-mtls-and-kestrel-a4f8b146a32e">上一篇文章</a>中完成的主要事情是建立一个CA并使用该CA签署的客户端证书运行。我们更新了web api，要求客户端证书，并使用新的客户端证书成功连接到应用程序。</p><p id="117d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前一篇文章中的缺陷是，虽然我们验证了客户端证书的存在，但我们实际上并没有验证客户端证书是由我们创建的CA签名的。如果客户端证书由于其他原因有效(比如它是由系统中另一个受信任的根CA签署的，比如一个实际的internet CA)，它仍然会“进入”。</p><h1 id="82a6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">补救步骤</h1><ul class=""><li id="ecf4" class="mh mi it ki b kj mc kn md kr mj kv mk kz ml ld mm mn mo mp bi translated">为描述问题而设置</li><li id="73e4" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">演示问题</li><li id="7291" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">用代码解决问题</li></ul><h2 id="855b" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">为描述问题而设置</h2><p id="9e0d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">所以首先，我们需要证明这确实是一个问题。我已经描述了这个问题，但是我们如何着手证明它呢？</p><p id="c22d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，最简单的事情就是用新的CA创建另一个CA和客户端证书。web api应该接受原始的“client”证书，以及“badClient”证书。</p><p id="c3fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将按照上一篇文章中的所有步骤来设置CA，包括信任我们的“badCa”。这样做的原因已经在上面介绍过了，但只是重申一下，我们想显示任何有效的证书当前都在进入；其中我们希望<em class="nh">只有来自预期CA </em>的有效证书才能进入。</p><p id="8035" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以现在我们应该有以下内容:</p><ul class=""><li id="4db0" class="mh mi it ki b kj kk kn ko kr ni kv nj kz nk ld mm mn mo mp bi translated">一个“好”的CA——我们希望确保检查出的客户端证书</li><li id="f2ce" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">一个“好的”客户端证书——应该通过我们的应用程序接受的证书</li><li id="5d47" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">一个“坏”的CA——一个有效的CA，但不应该被允许签署可以进入我们的应用程序的证书</li><li id="0308" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">“不良”客户端证书——由“不良”ca签署，应该<em class="nh">不会</em>(但目前能够)进入我们的应用程序</li></ul><p id="5ed9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您正在检查证书，它看起来会像这样:</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/9ae0b5293f326e18aee19e0e404f4d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-PEDxgs3XI3DSpps.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这么多证书</figcaption></figure><h2 id="7325" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">演示问题</h2><p id="b133" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在要做的就是用“好”证书和“坏”证书点击我们的web api，并确认我们实际上能够从两者中获得输出。</p><p id="ab80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像前面一样，让我们确保web api使用来自“Kritner”的<code class="fe nq nr ns nt b">dotnet run</code>运行。Mtls”项目。</p><p id="9cdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在没有证书的情况下首先点击应用程序:</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="0cb6" class="mv lf it nt b gy ny nz l oa ob">curl --insecure -v https://localhost:5001/weatherForecast</span></pre><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/a90d47ee07e1ca3fb71d73975dc69149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bk-7wZhyn5z6vc2o.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">没有证书</figcaption></figure><p id="1b33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">具有“良好”证书:</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="0f33" class="mv lf it nt b gy ny nz l oa ob">curl --insecure -v --key client.key --cert client.crt https://localhost:5001/weatherForecast</span></pre><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/a81ac138470d78a688b35b486331a78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7-xiZGX_i6Ni3JB1.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">好证书</figcaption></figure><p id="3c69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用“坏”证书:</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="3bc6" class="mv lf it nt b gy ny nz l oa ob">curl --insecure -v --key badClient.key --cert badClient.crt https://localhost:5001/weatherForecast</span></pre><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/37c13b204a5d57f0e3a43d685e7228d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HVEHRrXfPkIoSbzo.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">错误证书</figcaption></figure><p id="8e53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如所料，您可以看到，没有客户端证书的请求被拒绝，而带有“好”和“坏”客户端证书的请求都通过了。现在，我们需要弄清楚如何将应用程序限制为只接受由我们“好的”CA签署的客户端证书</p><h2 id="edf5" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">用代码解决问题</h2><p id="0ce1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">所以首先，我们需要确定什么使得“好的”客户端证书“好”，什么使得“坏的”客户端证书“坏”。如果您检查系统上的证书，您会看到有一个“授权密钥标识符”作为属性。客户端证书上的“授权密钥标识符”与签署证书的CA上的<a class="ae kf" href="https://knowledge.digicert.com/solution/SO18140#AKI" rel="noopener ugc nofollow" target="_blank">“授权密钥标识符”</a>和/或<a class="ae kf" href="https://knowledge.digicert.com/solution/SO18140#SKI" rel="noopener ugc nofollow" target="_blank">“主题密钥标识符”</a>相匹配:</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/5e8d75cd29d28970633ca89723f08a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b2-qLfMFY7ttRH-A.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">授权密钥标识符</figcaption></figure><p id="63fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">抱歉，所有不同的CA标签等等，如果你在截图中注意到了，我像个疯子一样在电脑间切换！</p><p id="cbe8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的内容中，您将能够看到“好的”证书“属于”好的CA，而“坏的”证书“属于”坏的CA——这是我们需要的信息！现在我们只需要一种用代码获取信息的方法。</p><p id="597d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我正在处理的代码的起点是<a class="ae kf" href="https://github.com/Kritner-Blogs/Kritner.Mtls/releases/tag/v0.9.1" rel="noopener ugc nofollow" target="_blank">https://github.com/Kritner-Blogs/Kritner.Mtls/releases/tag/v0.9.1 </a></p><p id="123e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回顾一下当前的代码，在上一篇文章中，我甚至给自己和其他人留了一个小纸条:</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="fd9e" class="mv lf it nt b gy ny nz l oa ob">OnCertificateValidated = context =&gt;<br/>{<br/>    var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;Startup&gt;&gt;();</span><span id="b6a5" class="mv lf it nt b gy of nz l oa ob">// You should implement a service that confirms the certificate passed in<br/>    // was signed by the root CA.<br/>    <br/>    // Otherwise, a certificate that is valid to one of the other trusted CAs on the webserver,<br/>    // would be valid in this case as well.<br/>    <br/>    logger.LogInformation("You did it my dudes!");</span><span id="c1ec" class="mv lf it nt b gy of nz l oa ob">return Task.CompletedTask;<br/>}</span></pre><h2 id="bb64" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">实现存根</h2><p id="bc35" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们在这部分代码中引入一个服务，它的抽象如下所示:</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="9b98" class="mv lf it nt b gy ny nz l oa ob">public interface ICertificateAuthorityValidator<br/>{<br/>    bool IsValid(X509Certificate2 clientCert);<br/>}</span></pre><p id="f9ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的抽象中，我们接收一个客户端证书，并返回它是否有效(显然)。<code class="fe nq nr ns nt b">OnCertificateValidated</code>内的<code class="fe nq nr ns nt b">context</code>可以访问<code class="fe nq nr ns nt b">ClientCertificate</code>，并且已经是<code class="fe nq nr ns nt b">X509Certificate2</code>的形式。</p><p id="435d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看我们的实现:</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="5c3d" class="mv lf it nt b gy ny nz l oa ob">public class CertificateAuthorityValidator : ICertificateAuthorityValidator<br/>{<br/>    private readonly ILogger&lt;CertificateAuthorityValidator&gt; _logger;</span><span id="659d" class="mv lf it nt b gy of nz l oa ob">public CertificateAuthorityValidator(ILogger&lt;CertificateAuthorityValidator&gt; logger)<br/>    {<br/>        _logger = logger;<br/>    }</span><span id="8125" class="mv lf it nt b gy of nz l oa ob">public bool IsValid(X509Certificate2 clientCert)<br/>    {<br/>        _logger.LogInformation($"Validating certificate within the {nameof(CertificateAuthorityValidator)}");<br/>        return true;<br/>    }<br/>}</span></pre><p id="8c23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上显然只是一个“起点”，我们总是说它是有效的。我们将通过将它注册为服务，并将其插入我们的<code class="fe nq nr ns nt b">OnCertificateValidated</code>来连接它。我已经在其他帖子中多次提到过这些服务，但是如果你需要帮助，看看完成的代码(TODO在这里放一个链接...如果我在评论中漏掉了这个，底部可能会有一个链接)。</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="a70f" class="mv lf it nt b gy ny nz l oa ob">OnCertificateValidated = context =&gt;<br/>{<br/>    var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;Startup&gt;&gt;();<br/>    logger.LogInformation("Within the OnCertificateValidated portion of Startup");</span><span id="b24c" class="mv lf it nt b gy of nz l oa ob">var caValidator = context.HttpContext.RequestServices.GetService&lt;ICertificateAuthorityValidator&gt;();<br/>    if (!caValidator.IsValid(context.ClientCertificate))<br/>    {<br/>        const string failValidationMsg = "The client certificate failed to validate";<br/>        logger.LogWarning(failValidationMsg);<br/>        context.Fail(failValidationMsg);<br/>    }</span><span id="bdd5" class="mv lf it nt b gy of nz l oa ob">return Task.CompletedTask;<br/>}</span></pre><p id="668f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面，一旦客户端证书被验证(否则)，我们将得到我们的<code class="fe nq nr ns nt b">ICertificateAuthorityValidator</code>的一个实例，然后在它上面运行额外的验证过程。如果验证失败，它会将验证标记为失败，否则仍然会成功。</p><p id="479c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着我们的存根实现从<code class="fe nq nr ns nt b">IsValid</code>返回<code class="fe nq nr ns nt b">true</code>，让我们看看是什么样子:</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/28b41b52c51a76e35cbe8847ca7ab1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cSxgGdjFFp-pZFNq.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">实现存根总是返回真</figcaption></figure><p id="5c3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更改存根实现以从<code class="fe nq nr ns nt b">IsValid</code>返回<code class="fe nq nr ns nt b">false</code>:</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/4e13a2c1f61e9cf6bfe350bfa63079e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RvUEXj2ihQcO1p2I.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">实现存根总是返回假</figcaption></figure><h2 id="6878" class="mv lf it bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">实际实施</h2><p id="a13e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们可以开始实际实现<code class="fe nq nr ns nt b">CertificateAuthorityValidator</code>了。您还记得，我们可以(希望)依靠“授权密钥标识符”来确保只有我们预期的CA签署的证书才能通过验证。</p><p id="6579" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们做些调试好吗？</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/d2c20ba3549192916b1a261d7bdff43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JekXBTMD1diKGLff.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">调试以查找X509Certificate2中的信息</figcaption></figure><p id="d37f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的截图显示，我们需要的信息实际上存在于从<code class="fe nq nr ns nt b">X509Certificate2</code>呈现给我们的数据中。为了节省一点时间和文字，要知道这个扩展上的“原始数据”确实表示CA cert上的相同值，但是还有一些额外的信息字节，即“KeyID= ”(如前面的截图所示)。我实际上无法从要确认的字节中获取这些数据(尝试获取ascii、utf8和其他几种格式的字节字符串)，但看起来就是这样。这意味着对于我们的实现，我们需要来自这个扩展的“原始数据”，减去最初的几个字节，以说明我只能假设是“KeyID=”。</p><p id="896a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整的<code class="fe nq nr ns nt b">CertificateAuthorityValidator</code>:</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="9799" class="mv lf it nt b gy ny nz l oa ob">public class CertificateAuthorityValidator : ICertificateAuthorityValidator<br/>{<br/>    private readonly ILogger&lt;CertificateAuthorityValidator&gt; _logger;</span><span id="8a44" class="mv lf it nt b gy of nz l oa ob">// this should probably be injected via config or loaded from the cert<br/>    // Apparently the bytes are in the reverse order when using this BigInteger parse method,<br/>    // hence the reverse<br/>    private readonly byte[] _caCertSubjectKeyIdentifier = BigInteger.Parse(<br/>        "e9be86f64eb53bc12c1b5fe0f63df450274811da",<br/>        System.Globalization.NumberStyles.HexNumber<br/>    ).ToByteArray().Reverse().ToArray();</span><span id="6037" class="mv lf it nt b gy of nz l oa ob">private const string AuthorityKeyIdentifier = "Authority Key Identifier";<br/>    <br/>    public CertificateAuthorityValidator(ILogger&lt;CertificateAuthorityValidator&gt; logger)<br/>    {<br/>        _logger = logger;<br/>    }</span><span id="50f3" class="mv lf it nt b gy of nz l oa ob">public bool IsValid(X509Certificate2 clientCert)<br/>    {<br/>        _logger.LogInformation($"Validating certificate within the {nameof(CertificateAuthorityValidator)}");<br/>        <br/>        if (clientCert == null)<br/>            return false;<br/>        foreach (var extension in clientCert.Extensions)<br/>        {<br/>            if (extension.Oid.FriendlyName.Equals(AuthorityKeyIdentifier, StringComparison.OrdinalIgnoreCase))<br/>            {<br/>                try<br/>                {<br/>                    var authorityKeyIdentifier = new byte[_caCertSubjectKeyIdentifier.Length];<br/>                    // Copy from the extension raw data, starting at the index that should be after the "KeyID=" bytes<br/>                    Array.Copy(<br/>                        extension.RawData, extension.RawData.Length - _caCertSubjectKeyIdentifier.Length, <br/>                        authorityKeyIdentifier, 0, <br/>                        authorityKeyIdentifier.Length);</span><span id="fac0" class="mv lf it nt b gy of nz l oa ob">if (_caCertSubjectKeyIdentifier.SequenceEqual(authorityKeyIdentifier))<br/>                    {<br/>                        _logger.LogInformation("Successfully validated the certificate came from the intended CA.");<br/>                        return true;<br/>                    }<br/>                    else<br/>                    {<br/>                        _logger.LogError($"Client cert with subject '{clientCert.Subject}' not signed by our CA.");<br/>                        return false;<br/>                    }<br/>                }<br/>                catch (Exception e)<br/>                {<br/>                    _logger.LogError(e, string.Empty);<br/>                    return false;<br/>                }<br/>            }<br/>        }<br/>        <br/>        _logger.LogError($"'{clientCert.Subject}' did not contain the extension to check for CA validity.");<br/>        return false;<br/>    }<br/>}</span></pre><p id="470d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相对来说<em class="nh">应该是</em>在上面自我解释清楚了，但是这里有细目:</p><ul class=""><li id="6fb6" class="mh mi it ki b kj kk kn ko kr ni kv nj kz nk ld mm mn mo mp bi translated">设置一个变量作为CA证书的“主题密钥标识符”(SKI)，使用post开头附近图像中的十六进制字符串。(我在代码的注释中指出了这一点，但是请注意，字节数组与我们想要的是相反的，所以我们颠倒了字节以得到我们需要的)</li><li id="8b52" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">通过<code class="fe nq nr ns nt b">clientCert.Extensions</code>进行枚举，直到找到具有“授权密钥标识符”的“友好名称”的那个</li><li id="29bf" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">找到后，通过从完整的原始字节长度减去SKI的长度开始进行数组复制，删除" KeyID= "(假定的)字节</li><li id="dd2b" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">比较这两个序列</li><li id="de8d" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">如果匹配，返回真，否则返回假</li></ul><h1 id="7b11" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试它</h1><p id="bd00" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在是检查我们工作的时候了！如果应用程序尚未运行，请运行它，让我们检查一下是否可以使用我们的有效证书获取信息:</p><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="ceb6" class="mv lf it nt b gy ny nz l oa ob">curl --insecure -v --key client.key --cert client.crt https://localhost:5001/weatherForecast</span></pre><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/25a5d932348a20436ed7c35f26e06910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R0rwZgHSJQdKn8nF.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">好证书</figcaption></figure><pre class="nm nn no np gt nu nt nv nw aw nx bi"><span id="753f" class="mv lf it nt b gy ny nz l oa ob">curl --insecure -v --key badClient.key --cert badClient.crt https://localhost:5001/weatherForecast</span></pre><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/25705d7352d38370d909b5b9a6db99ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TukpkUozC1_nj6Vz.JPG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">错误证书</figcaption></figure><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/42304f84c1b3f72e61e224dc132d8775.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*nU3VYUDgwMcLwWdv.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">有用！</figcaption></figure><h1 id="879b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><ul class=""><li id="7af0" class="mh mi it ki b kj mc kn md kr mj kv mk kz ml ld mm mn mo mp bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/setting-up-mtls-and-kestrel-a4f8b146a32e">设置mTLS和Kestrel </a></li><li id="92b9" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">SSL证书包含哪些扩展和细节？</li><li id="75b2" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><a class="ae kf" href="https://github.com/Kritner-Blogs/Kritner.Mtls/releases/tag/v0.9.1" rel="noopener ugc nofollow" target="_blank">帖子开头的代码起点</a></li><li id="9ae4" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><a class="ae kf" href="https://github.com/Kritner-Blogs/Kritner.Mtls/releases/tag/v1.0" rel="noopener ugc nofollow" target="_blank">代码结束点</a></li></ul></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="f348" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nh">原载于2020年7月22日https://blog.kritner.com</em><em class="nh"/><a class="ae kf" href="https://blog.kritner.com/2020/07/22/setting-up-mtls-and-kestrel-cont/" rel="noopener ugc nofollow" target="_blank"><em class="nh">。</em></a></p></div></div>    
</body>
</html>