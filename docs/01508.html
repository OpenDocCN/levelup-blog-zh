<html>
<head>
<title>Great New Features Released in TypeScript 3.5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 3.5中发布的优秀新功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/great-new-features-released-with-typescript-3-5-575f7731b28b?source=collection_archive---------12-----------------------#2020-01-08">https://levelup.gitconnected.com/great-new-features-released-with-typescript-3-5-575f7731b28b?source=collection_archive---------12-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ad394b510c47a218b35438a35626c35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cy_x6z071cLEnSCZ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">斯科特·沃尔什在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7e00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript每天都在改进。我们在每个版本中都不断获得新的特性。在本文中，我们将看看TypeScript 3.5中发布的新内容。</p><p id="dca4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新特性包括对增量构建的速度改进、新的<code class="fe le lf lg lh b">Omit</code>助手类型、联合类型中更好的额外属性检查，以及构造函数组合的类型推断。</p><h1 id="faa5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">速度改进</h1><p id="8793" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用<code class="fe le lf lg lh b">--incremental</code>构建模式，后续构建会更快，因为缓存了引用、文件位置和其他与构建相关的数据。</p><h1 id="dd1e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">省略助手类型</h1><p id="4835" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">Omit</code>助手类型是在TypeScript 3.5中引入的，通过从原始类型中排除一些属性，我们可以从现有类型中创建一个新类型。</p><p id="b086" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定下面代码中定义的<code class="fe le lf lg lh b">Person</code>类型:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2c60" class="mt lj it lh b gy mu mv l mw mx">type Person = {<br/>    name: string;<br/>    age: number;<br/>    address: string;<br/>};</span></pre><p id="e9de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">Omit</code>创建一个没有<code class="fe le lf lg lh b">address</code>属性的新类型:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5593" class="mt lj it lh b gy mu mv l mw mx">type NewPerson = Omit&lt;Person, "address"&gt;;</span></pre><p id="e2b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与以下内容相同:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7d32" class="mt lj it lh b gy mu mv l mw mx">type NewPerson = {<br/>    name: string;<br/>    age: number;<br/>}</span></pre><h1 id="4f07" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">联合类型中更好的超额属性检查</h1><p id="6973" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在TypeScript 3.5之前，多余属性检查在某些情况下无法捕捉属性。如果我们有一个联合类型，那么3.5之前的TypeScript版本允许一个属性与联合类型的类型同名，但与类型定义中指定的类型不同。</p><p id="5a95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="754f" class="mt lj it lh b gy mu mv l mw mx">type Person = {<br/>    name: string;<br/>    age: number;    <br/>};</span><span id="a6b6" class="mt lj it lh b gy my mv l mw mx">type Address = {<br/>    address: string;<br/>}</span><span id="75dc" class="mt lj it lh b gy my mv l mw mx">const person: Person | Address = {<br/>    name: 'Joe',<br/>    age: 1,<br/>    address: true<br/>};</span></pre><p id="a759" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将<code class="fe le lf lg lh b">address</code>设置为非字符串，这是不允许的。</p><p id="e06b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这已在TypeScript 3.5中修复。现在<code class="fe le lf lg lh b">address</code>必须是一个字符串，因为它被指定为一个字符串。</p><h1 id="0717" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><code class="fe le lf lg lh b">--allowUmdGlobalAccess</code>旗</h1><p id="e338" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">现在可以使用新的<code class="fe le lf lg lh b">--allowUmdGlobalAccess</code>标志在TypeScript 3.5中引用UMD全局声明文件。</p><p id="b618" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它增加了混合和匹配第三方库的灵活性。现在，库声明的全局变量可以被使用，甚至可以从模块内部使用。</p><h1 id="51be" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">更智能的联合类型检查</h1><p id="faac" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在TypeScript 3.5之前，我们会得到以下联合类型定义和变量赋值的错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="66d7" class="mt lj it lh b gy mu mv l mw mx">type Foo = { done: boolean, value: string }<br/>type Bar =<br/>    | { done: false, value: string }<br/>    | { done: true, value: string };</span><span id="b277" class="mt lj it lh b gy my mv l mw mx">declare let source: Foo;<br/>declare let target: Bar;</span><span id="e0cf" class="mt lj it lh b gy my mv l mw mx">target = source;</span></pre><p id="6051" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在3.5之前，<code class="fe le lf lg lh b">done</code>将被识别为具有带值的文字类型，而不是布尔类型。</p><p id="9a00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在它将<code class="fe le lf lg lh b">done</code>字段的类型识别为布尔型。这个现在起作用的布尔只能是<code class="fe le lf lg lh b">true</code>或<code class="fe le lf lg lh b">false</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1608194c552d4ebba9d1c62e7084b512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8YG04nBUAsW78sdz"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@themaxsandelin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Sandelin </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="c7a3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">来自泛型构造函数的高阶类型推断</h1><p id="06dc" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当我们像在下面的函数中那样构造泛型构造函数时:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="65bf" class="mt lj it lh b gy mu mv l mw mx">function composeConstructors&lt;T, U, V&gt;(<br/>    F: new (x: T) =&gt; U, G: new (y: U) =&gt; V): (x: T) =&gt; V {    <br/>    return x =&gt; new G(new F(x))<br/>}</span></pre><p id="2346" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript 3.5可以通过推断由组合形成的类型链来推断类型<code class="fe le lf lg lh b">T</code>、<code class="fe le lf lg lh b">U</code>和<code class="fe le lf lg lh b">V</code>。</p><p id="7c16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9e01" class="mt lj it lh b gy mu mv l mw mx">class Foo&lt;T&gt; {    <br/>    value: T;<br/>    constructor(value: T) {<br/>        this.value = value;<br/>    }<br/>}</span><span id="a4a5" class="mt lj it lh b gy my mv l mw mx">class Bar&lt;U&gt; {    <br/>    value: U;<br/>    constructor(value: U) {<br/>        this.value = value;<br/>    }<br/>}</span><span id="bae6" class="mt lj it lh b gy my mv l mw mx">let f = composeConstructors(Foo, Bar);<br/>let a = f('foo');</span></pre><p id="4b08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将得到类型为<code class="fe le lf lg lh b">Bar&lt;Foo&lt;string&gt;&gt;</code>的<code class="fe le lf lg lh b">a</code>。3.5之前的版本有类型<code class="fe le lf lg lh b">Bar&lt;{}&gt;</code>用于<code class="fe le lf lg lh b">a</code>。</p><p id="9f1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript 3.5现在更智能了。它可以推断由构造函数的组合形成的类型。</p><p id="c2cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了TypeScript 3.5，更智能更快。它可以通过遍历组合链来推断由构造函数组合而成的类型。</p><p id="36fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对联合类型进行额外的属性检查，这在早期版本中是不会发生的。</p><p id="10c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们有<code class="fe le lf lg lh b">-- allowUmdGlobalAccess</code>标志来运行来自UMD模块的访问全局变量。</p><p id="6918" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们有<code class="fe le lf lg lh b">Omit</code>类型，用于从现有类型中创建一个新类型，并删除一些属性。</p></div></div>    
</body>
</html>