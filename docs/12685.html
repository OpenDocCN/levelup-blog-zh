<html>
<head>
<title>Getting Started with Web Components &amp; Lit | Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件入门&amp; Lit |第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-web-components-lit-part-1-911aa7058e9b?source=collection_archive---------4-----------------------#2022-06-30">https://levelup.gitconnected.com/getting-started-with-web-components-lit-part-1-911aa7058e9b?source=collection_archive---------4-----------------------#2022-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4cd724e2cd59be109974eb65040f230b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80s8kTfbx89dmbidCD_eHA.png"/></div></div></figure><h1 id="384a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">第1部分| HTML Web组件简介</h1><blockquote class="kw kx ky"><p id="4b27" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">来自谷歌的<a class="ae ly" href="https://lit.dev" rel="noopener ugc nofollow" target="_blank"> Lit </a>，是一个开始使用web组件的简单方法。这些是HTML的升级形式，解决了Angular、React和Vue等框架解决的许多问题。不同的是，Lit还解决了那些框架<em class="iq">制造的</em>的许多问题。继续读下去，看看为什么我称Lit为反框架，为什么我认为你应该在你的下一个项目中强烈考虑它。</p></blockquote><p id="043f" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated"><strong class="lc ir">快速索引</strong> <br/>第1部分:<a class="ae ly" href="https://medium.com/@mimixco/getting-started-with-web-components-lit-part-1-911aa7058e9b" rel="noopener">介绍Web组件</a> <br/>第2部分:<a class="ae ly" href="https://medium.com/@mimixco/getting-started-with-web-components-lit-part-2-3cd878aeca73" rel="noopener">设置Lit和Vite </a> <br/>第3部分:<a class="ae ly" href="https://medium.com/@mimixco/getting-started-with-web-components-lit-part-3-81ba933f0f56" rel="noopener">构建单页面App </a></p><h1 id="a816" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">互动的问题</h1><p id="e3f7" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">自从在网页中使用JavaScript的早期，许多框架就试图克服处理DOM的丑陋。第一批网页没有任何交互性，正是因为这太糟糕了。任何JS程序都必须检查像<code class="fe mh mi mj mk b">&lt;input&gt;</code>或<code class="fe mh mi mj mk b">&lt;button&gt;</code>这样的实际HTML元素，并动态地改变它们的内容或行为，这看起来马上就像意大利面条代码，因为这就是它。</p><p id="5e11" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">最早流行的解决方案，<a class="ae ly" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>，使得以编程方式处理页面的单个元素变得更加容易，但是仍然让用户编写大量原始的、一次性的代码。第一个真正的框架是AngularJS ，它给了程序员一种将网页视为应用的方法。它有一系列崇高的目标。它以沉重的代价实现了这些目标。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/43b4a4d9941f4dc6b4bcd16636330a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PmhJBwlDflCxclkr"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">微软Expression Studio是将设计和开发引入一个过于复杂的IDE的早期(也是可怕的，失败的)尝试。自那以后，许多其他封闭框架也进行了同样的尝试。</figcaption></figure><h1 id="3236" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">上去吗？</h1><p id="b54a" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">Angular不仅仅是与页面上的元素对话。它附带了一个数据绑定模型，更新一些幕后数据来反映页面上发生的事情。这个被称为<a class="ae ly" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC </a>或模型-视图-控制器的模型深深融入了Angular的设计。它允许模型(服务器或本地数据源)和视图(用户看到的页面外观)之间的双向数据流。</p><p id="85cf" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">理论上，让数据上升和下降一样容易是非常好的。一个程序员的梦想，对吧？Susan在日历上更改了她的可用性，后端的数据库立即有了新的日期。第一次迭代AngularJS就是这样工作的。</p><p id="2102" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">实际上，双向数据是站不住脚的。打破自己的东西太容易了，防止这种破坏需要太多的脚手架。就像以前一样，任何复杂程度的应用程序看起来都像意大利面条，而且速度很慢。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/dd7f4d23a56e225ad6c9aca8a1a21b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DzTFTnpJuKYdQQoePFBuQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我的一项发明的早期定制web界面有多个<a class="ae ly" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank"> websockets </a>是用Angular编写的，并使用了我为之前的项目开发的UI脚手架。</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/f292d40a2c8b599f72a9477905512b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCfG2FgmheIZzLtmqQk07A.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">在Lit中重新编写同样的工具产生了一个更有吸引力和功能更多的“笔记本风格”的应用程序，像<a class="ae ly" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupityr </a>可以管理与后端服务器的对话。</figcaption></figure><h1 id="4e8b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">棱角和朋友:系列</h1><p id="2dd3" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">在AngularJS变得过于流行之前，谷歌意识到了这些问题，并通过引入一个新版本，命名为<em class="lb"> Angular </em>，并在改变后的框架上构建所有后续版本，从而消除了这些问题。这两者是不兼容的，因为新的Angular不允许双向数据绑定。</p><p id="7185" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">大约在同一时间，脸书(实际上看不到他在使用谷歌框架)发布了他们自己的MVC框架，这是他们为内部使用而创建的。那就是<a class="ae ly" href="https://en.wikipedia.org/wiki/React_(JavaScript_library)" rel="noopener ugc nofollow" target="_blank">反应</a>。Vue由曾在Angular工作过的一名前谷歌员工创建。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/6a4a9d1e70906e57d8143463629a6812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jSntVMePiiReV1lGW0axYA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated"><a class="ae ly" href="https://ungallery-alpha.web.app/" rel="noopener ugc nofollow" target="_blank"> Ungallery </a>是我为自己的另一项发明写的AngularJS应用。像这些<strong class="bd ka"> <em class="mx">现在购买</em> </strong>艺术面板这样的定制web组件，在React这样的框架中根本不存在。</figcaption></figure><h1 id="b4f9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">输入Web组件</h1><p id="2df4" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">看到大量的框架都试图解决相同的问题(丑陋、不灵活的DOM无数据绑定)，W3C试图通过允许程序员以标准化的方式编写他们自己的所有元素来改进HTML标准本身。这些是<a class="ae ly" href="https://en.wikipedia.org/wiki/Web_Components" rel="noopener ugc nofollow" target="_blank">网络组件</a>。</p><p id="3feb" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">换句话说，我可以决定我的页面将由填充了<code class="fe mh mi mj mk b">&lt;dta-panel&gt;</code>内容的<code class="fe mh mi mj mk b">&lt;dta-page&gt;</code>元素组成，而不是由<code class="fe mh mi mj mk b">&lt;div&gt;</code>和<code class="fe mh mi mj mk b">&lt;p&gt;</code>元素组成。我的自定义元素将以我选择的任何方式布局。因为这些定制元素的属性和值也可以通过编程来设置(使用标准语法，不同的框架不会互相冲突)，所以这些HTML扩展可以支持任何类型的数据绑定。</p><p id="02bb" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">web组件的另一个目标是清除DOM中CSS样式继承的问题。CSS的级联部分(名字中的“C”)很难调试。有时候，你只是想要你自己的CSS在你想要的地方，没有任何来自上面的层叠。在糟糕的名称选择中，W3C选择了<em class="lb"> shadow DOM </em>作为非继承CSS的概念。事实上，顾名思义，它不仅扩展到样式，还扩展到整个DOM。远离DOM是很好的编程实践，但是我认为您应该知道。</p><p id="cd91" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">还需要一个标准来阻止巨型框架造成的围墙花园效应。React有数百种网络元素可供你选择，无数的应用程序都充满了这些组件。各种对话框、控件、滑块、日历等。React拥有所有这些。这很好，但是…你已经学会了他们做任何事情的方式。如果你想要一个行为不像React的输入框或下拉列表，那么，你就有麻烦了。无论你写什么，都必须至少符合React，因为你的应用程序的其余部分都在React中，对吗？</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/8b2e52012c44a81be9012a42dc1cc788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haxRXG1J0ISY0yYVS4Veyw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">所有流行的框架都不缺少组件。这个列表只是针对<a class="ae ly" href="https://mui.com/material-ui/" rel="noopener ugc nofollow" target="_blank"> React MDI </a>。但是如果这些都不是你想要的呢？或者……更有可能的是，如果你喜欢的东西<strong class="bd ka">行为</strong>像这些，但看起来不像它们中的任何一个呢？</figcaption></figure><h1 id="0ed7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">直到裸露的金属</h1><p id="ef91" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">框架的对立面是<strong class="lc ir">裸机</strong> HTML。也就是说，只有HTML、JS、CSS和SVG的<a class="ae ly" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank"> MDN标准文档</a>中的东西——没有任何东西是由单一供应商控制的。裸机web组件不需要任何导入语句，也没有任何依赖关系。从最小的手机到最大的电视，它在每种设备上的每种浏览器中都以同样的方式工作。将来它不需要仅仅因为一个平台这么说就升级。</p><p id="7dd3" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">在我忘记之前，关于web组件或Lit的任何内容都不能排除您使用任何其他框架或HTML规范的任何部分。你不能用定制组件来破坏任何东西，这是他们设计的一部分。这意味着你可以使用Lit来<strong class="lc ir">将一个应用从静态HTML演变为更动态的元素，而无需从头重写。你也可以使用Lit将不同框架中的单个组件升级到你在Lit中定制的组件，而不需要改变你的页面。您甚至可以将Lit行为添加到其他库中的现成组件中。</strong></p><p id="5bae" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">现在web组件是裸机的一部分，我们可以真正开始编写应用程序来修复我们一直以来存在的一些问题。它们可以是完全定制的，也可以是干净的和模块化的。它们可以有尽可能少的依赖，但是充满了我们编写的高度可重用的代码。我们可以鱼和熊掌兼得。所以让我们开始吧！</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/351a352f9062419c24952f20ac1017e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCh60Tnj4kPK7UEEQ0iICA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">这个架构图是一个真实的应用程序，我的<a class="ae ly" href="https://hexxedgame.com" rel="noopener ugc nofollow" target="_blank"> Hexxed </a>游戏。自定义web组件与我的Typescript模块交互，创建一个在<strong class="bd ka">index.html</strong>结束的UI。</figcaption></figure><h1 id="ebf5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Lit是反框架的</h1><p id="9e66" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">谷歌最新的HTML框架是你能得到的最接近裸机的东西。虽然它为您添加了数据绑定和事件绑定，但与React庞大的组件库相比，Lit没有提供任何组件可供选择。你将会写这些。路由怎么样？你需要那个吗？希望你能写出来。(可以。)您的应用程序需要任何类型的安全性、身份或存储吗？装上电线，我的朋友！</p><p id="2513" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">如果这听起来很可怕，显然你还没有使用过React或Angular。因为，实际上，编写自己的代码通常比学习这些大框架的工作方式要好5倍。你不需要弄清楚如何让你想要的东西在“框架”内工作，而是简单地按照你想要的方式来写！</p><p id="2988" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">实际上，这是非常崇高的。它还非常高效，因为它易于调试。就拿路由来说吧。谷歌周围的方式做路由在Vue，或角，或反应。去拿咖啡！</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/5a88382562d4b97c5023ec247e374021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*dxFcwJU2Nl4CnWyMjlN-Og.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">这个来自<a class="ae ly" href="https://lit.dev/playground/" rel="noopener ugc nofollow" target="_blank"> live playground </a>的小例子展示了一个正在定义的新web组件。在这种情况下，它是一个<strong class="bd ka"> &lt;简单问候&gt; </strong>，它接受一个属性，一个名称。自定义组件返回良好的旧HTML，这就是它在任何地方都能工作的原因。请注意，这是整个程序。不需要其他文件或设置。</figcaption></figure><p id="ee3c" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">现在裸机JS，<em class="lb">老skool </em>风格，什么叫路由？它意味着从URL中去掉一些东西，通过显示不同的内容来进入一个页面。好的，在JavaScript中大概有3行代码。真的。您解析URL，然后更改决定所显示页面内容的任何变量的值。这不是火箭科学。然而，学习使用别人的路由框架可能需要像学习火箭科学一样长的时间！</p><p id="77a5" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">如果Lit将为您进行数据绑定，这是它添加到您的裸机web组件的秘密酱，那么当“页面内容”变量发生变化时，您的应用程序将自动更新，以便所有HTML元素都包含正确的新内容。恭喜你！你刚刚写了一个没有框架的单页应用程序。</p><h1 id="2319" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">是的，在你的后院</h1><p id="0187" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">航空业有一个可怕的自动化问题。当飞行员变得过于依赖软件时，他们会在驾驶飞机的基础上犯错误。开发人员也是如此。Lit鼓励你对应用程序的所有部分负责，这意味着理解所有部分。</p><p id="e486" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">你不能回到谷歌说，“我在文学上有问题”，因为你不太可能有问题。你不能说，“我对文学的了解还不足以写我的应用，”因为你可以很快学会。在web组件和Lit中思考迫使你思考你的应用程序的真正架构，以及它是如何在页面上呈现的。当出现问题时，它还会给你深层的调试本能，因为问题总是存在的——因为问题在于你正在做的事情，而不是你正在做的事情。</p><p id="6806" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">这就是为什么我建议你从零开始的地方使用Lit。我还认为对于第一次学习JavaScript(或者，希望是Typescript)的新开发人员来说，这是一个极好的选择。不妨开始吧！</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/e29cc061587230b5e9c4e21336fb5b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nveoa639ZBW8bH-QMwtX5g.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">在上图的放大视图中，我们可以看到<strong class="bd ka"> &lt; dta-gateway &gt; </strong>是<strong class="bd ka">index.html</strong>的子节点。它还有其他几个子元素，可以通过“下推”数据和强制重绘数据来与它们通信。这些元素又有子元素。当<strong class="bd ka"> &lt; dta-board &gt; </strong>子节点需要与它的<strong class="bd ka"> &lt; dta-welcome &gt; </strong>父节点通信时(如双箭头所示)，它必须通过发送JS事件消息来完成。</figcaption></figure><h1 id="3b75" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在Web组件中思考</h1><p id="36aa" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">用web组件编写应用程序需要一种不同的思维方式，因为所有更新的数据必须自上而下地到达<em class="lb"/>，并且必须流经每个组件及其子组件，而不会“触及”来自任何其他地方的数据。当一个组件需要告诉另一个组件一些事情(不是它的直接子组件)时，第一个组件必须通过JS事件系统向第二个组件异步发送消息。</p><p id="9ef2" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">除了这些消息之外，组件不得以任何其他方式进行通信。当收到消息时，组件可以重画自己。当父组件重绘时，其子组件也会重绘。这种设计限制是试图编写和调试<em class="lb">不能用这种方式工作的应用程序的结果。它防止了许多在其他设计模式中常见的错误。当架构正确时，web组件应用程序是<strong class="lc ir">神奇的</strong>和美丽的，因为它们看起来会自动用所有正确的数据在屏幕上更新自己。</em></p><h1 id="112d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">接下来…设置Lit &amp; Vite</h1><p id="8cbd" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">在本系列的第二部分中，我们将设置Lit来使用VSCode。我们还需要一个开发服务器，这样我们就可以看到我们的应用程序在进展中，为此我推荐Vite。</p><p id="2db7" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">一如既往地感谢您的阅读，下次再见！</p><p id="d705" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated"><em class="lb"> — D </em></p></div></div>    
</body>
</html>