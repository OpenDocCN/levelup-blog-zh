<html>
<head>
<title>How to Integrate MongoDB Realm with React: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将MongoDB领域与React集成:第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-integrate-mongodb-realm-with-react-part-1-ca21dd99d996?source=collection_archive---------4-----------------------#2021-05-22">https://levelup.gitconnected.com/how-to-integrate-mongodb-realm-with-react-part-1-ca21dd99d996?source=collection_archive---------4-----------------------#2021-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6f3e8eba12dbdf8a2a56d3127c474293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9uXDp2BrqwNt_g62u-8ow.png"/></div></div></figure><p id="a39c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本文原载于</em> <a class="ae kx" href="https://blog.shahednasser.com/how-to-integrate-mongo-realm-with-react-part-1/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">我的个人博客</em> </a> <em class="kw">。</em></p><p id="1c9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MongoDB Realm是一个无服务器的后端，它不仅允许您轻松地写入和读取数据，而且还提供了简单的方法来验证用户，保持您的数据在多个设备之间同步，等等。</p><p id="477d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将学习如何创建一个MongoDB Realm应用程序，向其中添加示例数据，基于用户角色限制数据访问，然后如何将该应用程序与React集成。我们将创建一个网站，显示餐馆评论，并允许用户创建一个帐户，并添加他们自己的评论。</p><p id="9922" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里找到这个教程<a class="ae kx" href="https://github.com/shahednasser/mongodb-realm-tutorial" rel="noopener ugc nofollow" target="_blank">的代码</a>。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="ca73" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">创建一个MongoDB领域应用程序</h2><p id="900e" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><strong class="ka ir">创建一个MongoDB集群</strong></p><p id="c9e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在创建MongoDB Realm应用程序之前，我们需要创建一个MongoDB集群。为此，请访问<a class="ae kx" href="https://cloud.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> Atlas门户网站</a>。如果您没有帐户或尚未登录，您需要先登录。</p><p id="a11b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您没有被重定向到项目页面，请单击左上角的徽标。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi md"><img src="../Images/403a7e4934682aed31598dd60e959e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*eJMsDNBgsoNAbG77.png"/></div></figure><p id="0b9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">进入项目页面后，点击右边的新建项目按钮。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/714cff4a3f4dc01336e6b1c153628357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NGGoD7nF0NFwJdX-.png"/></div></div></figure><p id="1ec2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后会要求您输入项目名称。你想叫它什么都可以。之后，如果需要的话，会要求您添加成员。完成后，点击创建项目。</p><p id="1c0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建项目后，您将被重定向到Clusters页面。点击“构建集群”</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/c319217ab5e67838300ad2b0c43a52a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XOy2vJzwnSc0E5WO.png"/></div></div></figure><p id="d450" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将被要求选择一个集群计划。对于本教程，您可以选择免费计划。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/c2edfc9bc67a109f88c577fb9e0cec00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dVD9ycb6QOU6LTqE.png"/></div></div></figure><p id="8629" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您只需点击“创建集群”</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/8abc812ffc0a89a5f511c00c3e2dfd08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c3fjh71NMGZEESts.png"/></div></div></figure><p id="4b65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此后，您的集群将需要一些时间来部署。您需要等到它被创建和部署，这可能需要几分钟。</p><p id="6ec4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是向我们的集群添加一个样本数据集。如果已经有数据集，可以添加自己的数据。</p><p id="e19a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要开始添加数据，请单击您创建的集群中的集合。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/8f4d862ad99b818bdc588403196dd44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TRNPZbapESyifQcI.png"/></div></div></figure><p id="550e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，点击加载样本数据集。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/12cb6404c2b936219774a1d8b4abb8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xqK620CoxGsQ41LV.png"/></div></div></figure><p id="b412" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将打开一个弹出窗口要求确认。确认后，示例数据集将安装在您的集群中。这个数据集包含一堆有用的数据库和集合，用于不同的用例。</p><p id="e03a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成示例数据集的安装需要一两分钟的时间。完成后，您会看到现在您已经有了几个数据库。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e8c59838b1a1bac9c0e55e997dc1db42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/0*pdZCwVQHx0yg6PnF.png"/></div></figure><p id="7063" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将只使用<code class="fe ml mm mn mo b">sample_restaurants</code>数据库，所以您可以通过点击当您将鼠标悬停在一个数据库名称上时出现的垃圾桶图标来删除其余的。</p><p id="0a6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的MongoDB集群已经准备好了，让我们继续创建一个MongoDB Realm应用程序。</p><p id="cae5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">创建一个MongoDB领域应用</strong></p><p id="1c3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要进入MongoDB领域，点击“Atlas”旁边标签栏中的“领域”</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/c4d06413c1aa05b477cf1b42837d5149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F-MqnnSiyubk4ivs.png"/></div></div></figure><p id="1fbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个对话框将显示开始创建MongoDB领域应用程序。您需要为领域应用程序输入一个名称，可以是您想要的任何名称。然后，您需要选择一个集群来链接Realm应用程序。您需要选择我们刚刚创建的集群。完成后，单击创建领域应用程序。</p><p id="c827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要从集群中选择一个集合，以便从Realm应用程序添加访问权限。为此，请单击仪表板上“添加收藏”下的“开始”。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/87176311b91f8d13a150ddd563c1f320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iRSmLa-OVmunQzSU.png"/></div></div></figure><p id="cf82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您必须选择数据库，即<code class="fe ml mm mn mo b">sample_restaurants</code>。然后选一个集合，会是<code class="fe ml mm mn mo b">restaurants</code>。</p><p id="409b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要选择一个权限模板。权限模板允许根据需要轻松限制读写访问。</p><p id="5943" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们正在创建的网站中，所有用户都可以阅读关于餐馆的所有数据，他们可以在自己的账户中写评论。</p><p id="9286" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们只需从下拉列表中选择“用户只能读取所有数据”。完成后，点按“添加收藏”接下来，点击侧边栏中的<code class="fe ml mm mn mo b">neighborhoods</code>，选择相同的模板，然后添加收藏。</p><p id="59a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次您对Realm应用程序进行更改时，您都必须部署它以使更改生效。要部署我们刚刚做出的更改，请单击顶部蓝色横幅中的“审阅草稿和部署”。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/61bbc04be69a44e26d04ce21f373f601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ql45WedaCHdTjv_s.png"/></div></div></figure><p id="5a18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！我们创建了一个Realm应用程序，它链接到我们的集群和集群中的集合。这将提供一个无服务器的后端，使我们能够轻松地检索和写入数据到我们的集群。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="6bf2" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">生成模式</h2><p id="e52b" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">为了能够查询我们的集合和文档，并且能够应用某些角色、权限和限制，我们需要为每个集合生成模式定义。为此，单击侧边栏中的Schema。</p><p id="18d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，单击生成模式按钮。这将基于集合中已经存在的数据生成模式。</p><p id="612d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在“Generate schema(s) for:”下，选择“all unconfigured collections”并在“20”中选择“Sample type”，因为考虑到我们的数据很简单，我们不需要对这么多文档进行采样。然后，单击生成模式。</p><p id="3897" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，您将看到生成的模式包含所有字段及其各自的类型。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/74a3e38c3f7e0682f5e93e00df8be3ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*svSgbEer_Zb5_hfw.png"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="a1d6" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">在领域应用程序中设置验证</h2><p id="795a" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在我们的Realm应用程序中，我们将使用两个身份验证提供者:</p><ol class=""><li id="8f93" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">匿名登录:允许用户在不实际登录的情况下查看所有数据。</li><li id="e27b" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">电子邮件和密码登录:用户必须用电子邮件和密码登录才能写评论。</li></ol><p id="92a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着用户有权读取所有数据，但只能写入自己的数据。</p><p id="8ea5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Realm Portal中，单击侧栏中的Authentication。您将看到几个身份验证提供程序都被禁用了。</p><p id="d090" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将首先启用“允许用户匿名登录”点击这个的编辑按钮，然后打开它。</p><p id="71ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后返回到身份验证页面。我们现在将单击第二个选项“电子邮件/密码”的编辑</p><p id="0dce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，启用提供者。接下来，对于“用户确认方法”，选择“自动确认用户”MongoDB Realm为您的应用程序提供了用户确认工作流，但在我们的情况下，我们不需要它。</p><p id="b88d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是“密码重置方法”MongoDB领域还为您的用户提供了密码重置方法。我们不会实现它，但是因为我们需要输入配置，只需在“密码重置URL”中输入<code class="fe ml mm mn mo b">http://example.com/reset</code></p><p id="d5c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，单击保存。我们的用户现在可以使用电子邮件和密码登录。</p><p id="698a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置身份验证的最后一步是允许使用电子邮件和密码登录的用户撰写自己的评论。为此，转到侧边栏中的rules，然后选择<code class="fe ml mm mn mo b">restaurants</code>集合，然后单击表格中的“New Role”。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/eade75e39edf21119b7784a406949f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bjPfpmRf56RMA5gf.png"/></div></div></figure><p id="3b87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将会打开一个弹出窗口。您首先需要输入角色名称。我们将其命名为“用户”</p><p id="17f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要输入“Apply When”条件，这意味着何时应该将用户视为该角色的一部分。我们希望使用电子邮件和密码登录的用户能够撰写评论。输入以下内容:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="b536" class="lf lg iq mo b gy nk nl l nm nn">{<br/>  "%%user.data.email": {<br/>    "%exists": true<br/>  }<br/>}</span></pre><p id="9d14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，对于“文档级权限”，选择“插入文档”完成后，点按“完成编辑”</p><p id="712e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在表格中单击“添加字段”并键入“成绩”,然后单击复选标记。然后检查用户角色的读和写。这增加了双重限制，即用户只能写成绩，不能写其他。至于Read，您可以检查所有字段。然后，单击“用户”角色名称下的左箭头，在将登录用户与正确的角色匹配时，为用户角色赋予更高的优先级。完成后，点击保存。该表应该如下所示:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/164abeb81eb71f5fa498f82b0330b030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*amyo3ecdh_lrgF8F.png"/></div></div></figure><p id="5529" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，我们现在可以匿名，登录用户可以读取所有数据，但只有登录用户可以写自己的评论。</p><p id="3407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后要做的一件事是，确保单击“审阅草稿和部署”以使所有更改生效。</p><p id="d1e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的MongoDB Realm应用程序已经准备好与React集成。接下来，我们将讨论如何将其与React集成，并使用我们已经设置好的所有功能。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="71cd" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">反应设置</h2><p id="1f2f" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">如果您还没有准备好React项目，请运行以下命令来创建一个:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="8b88" class="lf lg iq mo b gy nk nl l nm nn">npx create-react-app restaurants-reviews<br/>cd restaurants-reviews</span></pre><p id="f34a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将安装MongoDB Realm Web SDK:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="b0a5" class="lf lg iq mo b gy nk nl l nm nn">npm install --save realm-web</span></pre><p id="6ab9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们开始使用React Realm所需的全部内容。我们还将安装<a class="ae kx" href="https://react-bootstrap.github.io/" rel="noopener ugc nofollow" target="_blank">反应引导</a>使造型更容易:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="c686" class="lf lg iq mo b gy nk nl l nm nn">npm install react-bootstrap bootstrap@4.6.0</span></pre><p id="de09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和<a class="ae kx" href="https://reactrouter.com/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React路由器</a>添加不同页面:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="d42f" class="lf lg iq mo b gy nk nl l nm nn">npm install react-router-dom</span></pre><p id="b30b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">首页</strong></p><p id="5447" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先修改创建将成为主页的<code class="fe ml mm mn mo b">Home</code>组件。主页将只显示餐馆及其评级的列表。</p><p id="bf7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建文件<code class="fe ml mm mn mo b">src/pages/Home.js</code>和以下基本组件:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="2e38" class="lf lg iq mo b gy nk nl l nm nn">function Home () {<br/>	return (<br/>    	&lt;div&gt;&lt;/div&gt;<br/>    )<br/>}<br/><br/>export default Home</span></pre><p id="86b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，它只是一个显示了<code class="fe ml mm mn mo b">&amp;lt;div&amp;gt;</code>元素的组件。我们需要让它显示一个餐馆列表。</p><p id="78f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们稍后将从MongoDB Realm应用程序中获取餐馆，所以我们将为餐馆使用一个州:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="ad04" class="lf lg iq mo b gy nk nl l nm nn">function Home () {<br/>	const [restaurants, setRestaurants] = useState([])<br/>    //...<br/>}</span></pre><p id="a6ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将遍历餐馆并显示它们:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="55ac" class="lf lg iq mo b gy nk nl l nm nn">&lt;div className="mt-3"&gt;<br/>    {restaurants.map((restaurant) =&gt; (<br/>        &lt;RestaurantCard key={restaurant._id} restaurant={restaurant} /&gt;<br/>        ))<br/>	}<br/>&lt;/div&gt;</span></pre><p id="6124" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用以下内容创建<code class="fe ml mm mn mo b">src/components/RestaurantCard.js</code>:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="a9e8" class="lf lg iq mo b gy nk nl l nm nn">import { Badge } from 'react-bootstrap'<br/>import Card from 'react-bootstrap/Card'<br/><br/>function RestaurantCard ({restaurant}) {<br/>    //get average of grades<br/>    let sum = 0;<br/>    restaurant.grades.forEach(element =&gt; {<br/>        sum += element.score<br/>    });<br/>    const avg = Math.round(sum / (restaurant.grades.length))<br/>    return (<br/>        &lt;Card className="m-3"&gt;<br/>            &lt;Card.Body&gt;<br/>                &lt;Card.Title&gt;{restaurant.name} &lt;Badge variant="warning"&gt;{avg}&lt;/Badge&gt;&lt;/Card.Title&gt;<br/>            &lt;/Card.Body&gt;<br/>        &lt;/Card&gt;<br/>    )<br/>}<br/><br/>export default RestaurantCard</span></pre><p id="4685" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先计算餐馆的平均分数，然后展示一张写有餐馆名称和平均分数的卡片。</p><p id="3ec7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们的主页应该显示一个带有餐馆名称和等级的卡片列表。剩下的就是将它实际链接到我们Realm应用程序中的数据。</p><p id="1791" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们先来看看如何连接到Realm应用程序。你首先需要一个应用ID。你可以在仪表盘上找到应用ID，也可以点击边栏中的复制图标。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/2fcf007fb1268319a5b00587c20c0c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/0*ulc2MUbZaQpKKD-L.png"/></div></figure><p id="1281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在根目录下创建一个<code class="fe ml mm mn mo b">.env</code>文件，内容如下:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="3455" class="lf lg iq mo b gy nk nl l nm nn">REACT_APP_REALM_APP_ID=&lt;YOUR_APP_ID&gt;</span></pre><p id="dc63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保将<code class="fe ml mm mn mo b">&amp;lt;YOUR_APP_ID&amp;gt;</code>替换为您复制的应用ID。这有助于轻松更改应用id，只需在<code class="fe ml mm mn mo b">.env</code>中更改即可。</p><p id="3681" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到<code class="fe ml mm mn mo b">src/pages/Home.js</code>，我们首先需要导入SDK:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="6efc" class="lf lg iq mo b gy nk nl l nm nn">import * as Realm from 'realm-web'</span></pre><p id="3826" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，初始化领域应用程序:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="81b4" class="lf lg iq mo b gy nk nl l nm nn">const app = new Realm.App({id: process.env.REACT_APP_REALM_APP_ID})</span></pre><p id="3e0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们使用了之前设置的环境变量。</p><p id="b3ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在<code class="fe ml mm mn mo b">Home</code>组件中，我们将使用<code class="fe ml mm mn mo b">useEffect</code>在第一次渲染时获取数据:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="9790" class="lf lg iq mo b gy nk nl l nm nn">useEffect(() =&gt; {<br/><br/>}, [])</span></pre><p id="a0a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在内部，我们将匿名登录用户，然后获取<code class="fe ml mm mn mo b">restaurants</code>数据。从以前开始，我们允许所有用户读取所有数据，甚至没有登录的用户也可以读取数据。</p><p id="7603" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要匿名登录用户:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="6e09" class="lf lg iq mo b gy nk nl l nm nn">useEffect(() =&gt; {<br/>	async function getData () {<br/>    	const user = await app.logIn(Realm.Credentials.anonymous())<br/>    }<br/>    <br/>    getData();<br/>}, [])</span></pre><p id="0b8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们将使用刚刚登录的用户为我们的集合获取MongoDB客户端:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="724d" class="lf lg iq mo b gy nk nl l nm nn">const client = app.currentUser.mongoClient('mongodb-atlas')</span></pre><p id="4ee4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，通过使用<code class="fe ml mm mn mo b">app.currentUser</code>，我们指的是当前登录的用户。然后，我们获得该用户的MongoDB客户端。这意味着对数据的访问是基于登录的用户来限制的，就像我们上面定义的那样。</p><p id="cc7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是从<code class="fe ml mm mn mo b">restaurants</code>集合中获取餐馆并设置餐馆状态:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="de96" class="lf lg iq mo b gy nk nl l nm nn">const rests = client.db('sample_restaurants').collection('restaurants')<br/>setRestaurants((await rests.find()).slice(0, 10))</span></pre><p id="d0cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，一旦我们从MongoDB Realm应用程序中检索到餐馆，我们的代码就会显示它们。我们还将添加一些负载，以确保我们可以看到负载:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="0f92" class="lf lg iq mo b gy nk nl l nm nn">const [restaurants, setRestaurants] = useState([])<br/>const [loading, setLoading] = useState(true)<br/><br/>useEffect(() =&gt; {<br/>	async function getData () {<br/>    	//...<br/>        const rests = client.db('sample_restaurants').collection('restaurants')<br/>        setRestaurants((await rests.find()).slice(0, 10))<br/>        setLoading(false)<br/>    }<br/>    <br/>    if (loading) {<br/>        getData();<br/>    }<br/>}, [loading])<br/><br/>return (<br/>    &lt;div className="mt-3"&gt;<br/>            {loading &amp;&amp; (<br/>                &lt;div className="text-center"&gt;<br/>                    &lt;Loading /&gt;<br/>                &lt;/div&gt;<br/>            )}<br/>            {restaurants.map((restaurant) =&gt; (<br/>                &lt;RestaurantCard key={restaurant._id} restaurant={restaurant} /&gt;<br/>            ))}<br/>        &lt;/div&gt;<br/>);</span></pre><p id="3b21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将创建<code class="fe ml mm mn mo b">src/components/Loading.js</code>:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="a8a0" class="lf lg iq mo b gy nk nl l nm nn">import { Spinner } from "react-bootstrap";<br/><br/>function Loading () {<br/>    return (<br/>        &lt;Spinner animation="border" variant="primary"&gt;<br/>            &lt;span className="sr-only"&gt;Loading...&lt;/span&gt;<br/>        &lt;/Spinner&gt;<br/>    )<br/>}<br/><br/>export default Loading</span></pre><p id="7347" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！主页现在已经准备好了。唯一剩下的就是在<code class="fe ml mm mn mo b">src/App.js</code>中使用<code class="fe ml mm mn mo b">react-router</code>来确保多页:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="6153" class="lf lg iq mo b gy nk nl l nm nn">import {<br/>  BrowserRouter as Router,<br/>  Switch,<br/>  Route,<br/>} from "react-router-dom"<br/>import Home from "./pages/Home"<br/>import 'bootstrap/dist/css/bootstrap.min.css'<br/>import { Container } from "react-bootstrap"<br/><br/>function App() {<br/><br/>  return (<br/>    &lt;Router&gt;<br/>        &lt;Container&gt;<br/>          &lt;Switch&gt;<br/>            &lt;Route path="/" component={Home} /&gt;<br/>          &lt;/Switch&gt;<br/>        &lt;/Container&gt;<br/>    &lt;/Router&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="14e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们运行服务器:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="34a1" class="lf lg iq mo b gy nk nl l nm nn">npm start</span></pre><p id="a1af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">加载后，您将看到餐馆的平均等级:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/238553b96a3f5f2be5fa9caa1d97b259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lhq6NUYBP0BFhXoQ.png"/></div></div></figure><p id="3643" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将创建身份验证表单，以允许用户创建帐户和登录。</p><p id="7845" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">认证页面</strong></p><p id="693f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于用户只需要输入电子邮件和密码来注册和登录，我们将只创建一个身份验证组件，它根据<code class="fe ml mm mn mo b">type</code>属性来改变行为，该属性确定表单是用于创建帐户还是用于登录。</p><p id="6027" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们开始之前，让我们安装<a class="ae kx" href="https://formik.org/" rel="noopener ugc nofollow" target="_blank"> Formik </a>和<a class="ae kx" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank"> Yup </a>以便更容易地创建表单:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="15d5" class="lf lg iq mo b gy nk nl l nm nn">npm i formik yup</span></pre><p id="e730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，用以下内容创建<code class="fe ml mm mn mo b">src/pages/Authentication.js</code>:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="253b" class="lf lg iq mo b gy nk nl l nm nn">import { Formik } from 'formik'<br/>import { Button, Form } from 'react-bootstrap'<br/>import * as yup from 'yup'<br/>import { useState } from 'react'<br/>import Loading from '../components/Loading'<br/><br/>const userSchema = yup.object().shape({<br/>    email: yup.string().email().required(),<br/>    password: yup.string().required().min(8)<br/>})<br/><br/>function Authentication ({type = 'login'}) {<br/>    const [loading, setLoading] = useState(false)<br/><br/>    async function submitHandler (values) {<br/>        setLoading(true)<br/>        //TODO handle login/create<br/>    }<br/><br/>    return (<br/>        &lt;Formik <br/>            initialValues={{<br/>                email: '',<br/>                password: ''<br/>            }}<br/><br/>            validationSchema={userSchema}<br/><br/>            onSubmit={submitHandler}<br/>        &gt;<br/>            {({errors, touched, handleSubmit, values, handleChange}) =&gt; (<br/>                &lt;Form noValidate onSubmit={handleSubmit}&gt;<br/>                    {loading &amp;&amp; &lt;Loading /&gt;}<br/>                    {!loading &amp;&amp; (&lt;div&gt;<br/>                        &lt;h1&gt;{type === 'login' ? 'Login' : 'Sign Up'}&lt;/h1&gt;<br/>                        &lt;Form.Row&gt;<br/>                            &lt;Form.Label&gt;Email&lt;/Form.Label&gt;<br/>                            &lt;Form.Control type="email" name="email" value={values.email} onChange={handleChange} <br/>                            isValid={touched.email &amp;&amp; !errors.email} /&gt;<br/>                            &lt;Form.Control.Feedback&gt;{errors.email}&lt;/Form.Control.Feedback&gt;<br/>                        &lt;/Form.Row&gt;<br/>                        &lt;Form.Row&gt;<br/>                            &lt;Form.Label&gt;Password&lt;/Form.Label&gt;<br/>                            &lt;Form.Control type="password" name="password" value={values.password} onChange={handleChange} <br/>                            isValid={touched.password &amp;&amp; !errors.password} /&gt;<br/>                            &lt;Form.Control.Feedback&gt;{errors.password}&lt;/Form.Control.Feedback&gt;<br/>                        &lt;/Form.Row&gt;<br/>                        &lt;div className="text-center mt-2"&gt;<br/>                            &lt;Button variant="primary" type="submit"&gt;Submit&lt;/Button&gt;<br/>                        &lt;/div&gt;<br/>                    &lt;/div&gt;)}<br/>                &lt;/Form&gt;<br/>            )}<br/>        &lt;/Formik&gt;<br/>    )<br/>}<br/><br/>export default Authentication</span></pre><p id="196c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用Formik创建一个包含两个字段的表单，电子邮件和密码。我们还使用<code class="fe ml mm mn mo b">yup</code> it来创建一个验证模式。在表单提交时，如果一切都有效，函数<code class="fe ml mm mn mo b">submitHandler</code>将运行并接受<code class="fe ml mm mn mo b">values</code>对象。</p><p id="e892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ml mm mn mo b">submitHandler</code>里面，我们需要检查<code class="fe ml mm mn mo b">type</code>道具。如果它等于<code class="fe ml mm mn mo b">create</code>，那么我们需要创建一个新用户，然后登录该用户。如果是<code class="fe ml mm mn mo b">login</code>，那么我们只需要登录用户。</p><p id="85f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在我们开始之前，因为使用<code class="fe ml mm mn mo b">user</code>对象、MongoDB <code class="fe ml mm mn mo b">client</code>和领域<code class="fe ml mm mn mo b">app</code>会很麻烦，所以让我们创建一个<a class="ae kx" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>，它允许我们轻松地在所有组件中使用相同的数据。</p><p id="88f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下内容创建<code class="fe ml mm mn mo b">src/MongoContext.js</code>:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="32c7" class="lf lg iq mo b gy nk nl l nm nn">import React from 'react'<br/><br/>const MongoContext = React.createContext({<br/>    app: null,<br/>    client: null,<br/>    user: null,<br/>    setApp: () =&gt; {},<br/>    setClient: () =&gt; {},<br/>    setUser: () =&gt; {}<br/>})<br/><br/>export default MongoContext</span></pre><p id="0f68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在创建一个包含对象<code class="fe ml mm mn mo b">app</code>、<code class="fe ml mm mn mo b">client</code>和<code class="fe ml mm mn mo b">user</code>及其设置函数<code class="fe ml mm mn mo b">setApp</code>、<code class="fe ml mm mn mo b">setClient</code>和<code class="fe ml mm mn mo b">setUser</code>的上下文。</p><p id="5b8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们将<code class="fe ml mm mn mo b">Home</code>中的<code class="fe ml mm mn mo b">user</code>、<code class="fe ml mm mn mo b">app</code>和<code class="fe ml mm mn mo b">client</code>的声明和初始化移到<code class="fe ml mm mn mo b">App</code>:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="122b" class="lf lg iq mo b gy nk nl l nm nn">const [client, setClient] = useState(null)<br/>  const [user, setUser] = useState(null)<br/>  const [app, setApp] = useState(new Realm.App({id: process.env.REACT_APP_REALM_APP_ID}))<br/><br/>  useEffect(() =&gt; {<br/>    async function init () {<br/>      if (!user) {<br/>        setUser(app.currentUser ? app.currentUser : await app.logIn(Realm.Credentials.anonymous()))<br/>      }<br/><br/>      if (!client) {<br/>        setClient(app.currentUser.mongoClient('mongodb-atlas'))<br/>      }<br/>    }<br/><br/>    init();<br/>  }, [app, client, user])</span></pre><p id="2404" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们正在为它们中的每一个创建状态，并将它们设置在<code class="fe ml mm mn mo b">App</code>中。然后，我们将使用<code class="fe ml mm mn mo b">MongoContext.Provider</code>结束我们的路线:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="1f78" class="lf lg iq mo b gy nk nl l nm nn">return (<br/>    &lt;Router&gt;<br/>      &lt;MongoContext.Provider value={{app, client, user, setClient, setUser, setApp}}&gt;<br/>      	&lt;Container&gt;<br/>          &lt;Switch&gt;<br/>            &lt;Route path="/" component={Home} /&gt;<br/>          &lt;/Switch&gt;<br/>        &lt;/Container&gt;<br/>      &lt;/MongoContext.Provider&gt;<br/>     &lt;/Router&gt;<br/>  );</span></pre><p id="e207" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要使用<code class="fe ml mm mn mo b">MongoContext.Consumer</code>将上下文传递给每个组件。为了避免重复，让我们在<code class="fe ml mm mn mo b">App</code>中创建一个函数来做这件事:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="69a2" class="lf lg iq mo b gy nk nl l nm nn">function renderComponent (Component, additionalProps = {}) {<br/>    return &lt;MongoContext.Consumer&gt;{(mongoContext) =&gt; &lt;Component mongoContext={mongoContext} {...additionalProps} /&gt;}&lt;/MongoContext.Consumer&gt;<br/>  }</span></pre><p id="af33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将用<code class="fe ml mm mn mo b">MongoContext.Consumer</code>包装一个组件，然后传递给它<code class="fe ml mm mn mo b">mongoContext</code> prop，它将保存我们存储在上下文中的所有对象及其设置器。</p><p id="b19b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到<code class="fe ml mm mn mo b">App</code>中的return语句，我们将传递一个渲染函数，而不是将<code class="fe ml mm mn mo b">component={Home}</code>传递给route:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="7906" class="lf lg iq mo b gy nk nl l nm nn">&lt;Route path="/" render={() =&gt; renderComponent(Home)} /&gt;</span></pre><p id="6175" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们有了一个包含所有对象及其setters的上下文，然后我们将它传递给route的组件。</p><p id="f7ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在<code class="fe ml mm mn mo b">src/pages/Home.js</code>中做些改变，不再使用<code class="fe ml mm mn mo b">app</code>、<code class="fe ml mm mn mo b">user</code>和<code class="fe ml mm mn mo b">client</code>的首字母，而是将它们作为道具接收:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="5954" class="lf lg iq mo b gy nk nl l nm nn">import { useEffect, useState } from 'react'<br/>import RestaurantCard from '../components/RestaurantCard'<br/>import Loading from '../components/Loading'<br/><br/>function Home ({mongoContext: {client, user}}) {<br/>    const [restaurants, setRestaurants] = useState([])<br/>    const [loading, setLoading] = useState(true)<br/><br/>    useEffect(() =&gt; {<br/>        async function getData () {<br/>            const rests = client.db('sample_restaurants').collection('restaurants')<br/>            setRestaurants((await rests.find()).slice(0, 10))<br/>            setLoading(false)<br/>        }<br/><br/>        if (loading &amp;&amp; user &amp;&amp; client) {<br/>            getData()<br/>        }<br/>    }, [client, loading, user])<br/><br/>    return (<br/>        &lt;div className="mt-3"&gt;<br/>            {loading &amp;&amp; (<br/>                &lt;div className="text-center"&gt;<br/>                    &lt;Loading /&gt;<br/>                &lt;/div&gt;<br/>            )}<br/>            {restaurants.map((restaurant) =&gt; (<br/>                &lt;RestaurantCard key={restaurant._id} restaurant={restaurant} /&gt;<br/>            ))}<br/>        &lt;/div&gt;<br/>    )<br/>}<br/><br/>export default Home</span></pre><p id="8d87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你试着运行服务器并访问网站，你会发现一切都和以前一样完美。</p><p id="2a46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到<code class="fe ml mm mn mo b">Authentication</code>组件，我们现在将把<code class="fe ml mm mn mo b">mongoContext</code>道具传递给它:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="35d4" class="lf lg iq mo b gy nk nl l nm nn">function Authentication ({mongoContext: {app, user, setUser}, type = 'login'})</span></pre><p id="92d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ml mm mn mo b">submitHandler</code>中，如果<code class="fe ml mm mn mo b">type</code>是create，我们将注册一个新用户，那么对于这两种类型，我们将使用用户的凭据登录用户:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="4eb5" class="lf lg iq mo b gy nk nl l nm nn">async function submitHandler (values) {<br/>        setLoading(true)<br/>        if (type === 'create') {<br/>            //create<br/>            await app.emailPasswordAuth.registerUser(values.email, values.password);<br/>        }<br/><br/>        //login user and redirect to home<br/>        const credentials = Realm.Credentials.emailPassword(values.email, values.password);<br/>        setUser(await app.logIn(credentials))<br/>        setLoading(false)<br/>    }</span></pre><p id="3605" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们在上下文中使用了<code class="fe ml mm mn mo b">app</code>和<code class="fe ml mm mn mo b">setUser</code>。当我们使用<code class="fe ml mm mn mo b">setUser</code>时，用户将使用上下文更新所有组件。</p><p id="e3e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要添加的最后一件事是，如果用户已经登录，就重定向用户。为此，首先创建<code class="fe ml mm mn mo b">src/utils.js</code>，它将保存函数<code class="fe ml mm mn mo b">isAnon</code>以确定用户是否登录:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="266f" class="lf lg iq mo b gy nk nl l nm nn">module.exports = {<br/>    isAnon: function (user) {<br/>        return !user || user.identities[0].providerType === 'anon-user'<br/>    }<br/>}</span></pre><p id="e12e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户没有登录，这里的<code class="fe ml mm mn mo b">providerType</code>将是<code class="fe ml mm mn mo b">anon-user</code>。</p><p id="5e7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在<code class="fe ml mm mn mo b">Authentication</code>中，我们将从<code class="fe ml mm mn mo b">react-router</code>中使用<code class="fe ml mm mn mo b">useHistory</code>得到一个<code class="fe ml mm mn mo b">history</code>实例:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="30f6" class="lf lg iq mo b gy nk nl l nm nn">const history = useHistory()</span></pre><p id="9c25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，每当上下文中的<code class="fe ml mm mn mo b">user</code>改变时，我们将检查用户是否登录，如果是，我们将重定向到home。</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="5d59" class="lf lg iq mo b gy nk nl l nm nn">useEffect(() =&gt; {	<br/>	if (!isAnon(user)) {<br/>		history.push('/')<br/>	}<br/>}, [history, user])</span></pre><p id="aef3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe ml mm mn mo b">Authentication</code>组件现在完成了！让我们在<code class="fe ml mm mn mo b">src/App.js</code>中添加<code class="fe ml mm mn mo b">signin</code>和<code class="fe ml mm mn mo b">signup</code>路线:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="0f25" class="lf lg iq mo b gy nk nl l nm nn">&lt;Route path="/signup" render={() =&gt; renderComponent(Authentication, {type: 'create'})} /&gt;<br/>&lt;Route path="/signin" render={() =&gt; renderComponent(Authentication)} /&gt;<br/>&lt;Route path="/" render={() =&gt; renderComponent(Home)} /&gt;</span></pre><p id="ee5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要一个<code class="fe ml mm mn mo b">LogOut</code>页面，因此创建包含以下内容的<code class="fe ml mm mn mo b">src/pages/Logout.js</code>:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="354a" class="lf lg iq mo b gy nk nl l nm nn">import { useEffect } from "react"<br/>import Loading from "../components/Loading"<br/>import * as Realm from 'realm-web'<br/>import { useHistory } from "react-router"<br/>import { isAnon } from "../utils"<br/><br/>function LogOut ({mongoContext: {app, setUser, setClient}}) {<br/>    const history = useHistory()<br/><br/>    if (isAnon()) {<br/>        history.push('/')<br/>    }<br/><br/>    useEffect(() =&gt; {<br/>        async function logout () {<br/>            await app.currentUser.logOut()<br/>            //login anon user<br/>            setUser(await app.logIn(Realm.Credentials.anonymous()))<br/>            //set new client<br/>            setClient(app.currentUser.mongoClient('mongodb-atlas'))<br/>        }<br/><br/>        logout()<br/>    }, [app, setClient, setUser])<br/><br/>    return (<br/>        &lt;Loading /&gt;<br/>    )<br/>}<br/><br/>export default LogOut</span></pre><p id="7010" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先检查用户是否还没有登录，如果是这样，我们会将他们重定向到主页。然后，我们显示加载组件，在<code class="fe ml mm mn mo b">useEffect</code>中，我们使用以下命令注销用户:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="a624" class="lf lg iq mo b gy nk nl l nm nn">await app.currentUser.logOut()</span></pre><p id="6e2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们再次将用户设置为匿名用户，并重新初始化MongoDB客户端:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="9dc5" class="lf lg iq mo b gy nk nl l nm nn">//login anon user<br/>setUser(await app.logIn(Realm.Credentials.anonymous()))<br/>//set new client<br/>setClient(app.currentUser.mongoClient('mongodb-atlas'))</span></pre><p id="ea6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们就有了注销页面。我们只需要将它添加到<code class="fe ml mm mn mo b">src/App.js</code>中的路线:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="e0ba" class="lf lg iq mo b gy nk nl l nm nn">&lt;Route path="/signup" render={() =&gt; renderComponent(Authentication, {type: 'create'})} /&gt;<br/>&lt;Route path="/signin" render={() =&gt; renderComponent(Authentication)} /&gt;<br/>&lt;Route path="/logout" render={() =&gt; renderComponent(LogOut)} /&gt;<br/>&lt;Route path="/" render={() =&gt; renderComponent(Home)} /&gt;</span></pre><p id="6a09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将创建一个<code class="fe ml mm mn mo b">src/components/Navigation.js</code>组件来显示带有链接的导航栏:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="bd53" class="lf lg iq mo b gy nk nl l nm nn">import { Nav, Navbar } from "react-bootstrap"<br/>import { Link } from "react-router-dom"<br/>import { isAnon } from "../utils"<br/><br/><br/>function Navigation ({user}) {<br/>    const loggedIn = !isAnon(user)<br/>    return (<br/>        &lt;Navbar bg="light" expand="lg"&gt;<br/>            &lt;Navbar.Brand href="#home"&gt;Restaurant Reviews&lt;/Navbar.Brand&gt;<br/>            &lt;Navbar.Toggle aria-controls="basic-navbar-nav" /&gt;<br/>            &lt;Navbar.Collapse id="basic-navbar-nav"&gt;<br/>                &lt;Nav className="mr-auto"&gt;<br/>                    &lt;Link to="/" className="mx-2"&gt;Home&lt;/Link&gt;<br/>                    {!loggedIn &amp;&amp; &lt;Link to="/signup" className="mx-2"&gt;Sign Up&lt;/Link&gt;}<br/>                    {!loggedIn &amp;&amp; &lt;Link to="/signin" className="mx-2"&gt;Sign In&lt;/Link&gt;}<br/>                    {loggedIn &amp;&amp; &lt;Link to="/logout" className="mx-2"&gt;Log out&lt;/Link&gt;}<br/>                &lt;/Nav&gt;<br/>            &lt;/Navbar.Collapse&gt;<br/>        &lt;/Navbar&gt;<br/>    )<br/>}<br/><br/>export default Navigation</span></pre><p id="48f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将用户属性传递给它，然后检查用户是否登录，我们将显示注销链接。如果没有，我们将显示登录和注册链接。</p><p id="a126" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ml mm mn mo b">src/App.js</code>中增加<code class="fe ml mm mn mo b">Navigation</code>组件:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="621d" class="lf lg iq mo b gy nk nl l nm nn">return (<br/>    &lt;Router&gt;<br/>      &lt;Navigation user={user} /&gt;<br/>      &lt;MongoContext.Provider value={{app, client, user, setClient, setUser, setApp}}&gt;<br/>      //...<br/>)</span></pre><p id="823e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们完了！如果尚未运行服务器，请运行服务器:</p><pre class="me mf mg mh gt ng mo nh ni aw nj bi"><span id="0cc0" class="lf lg iq mo b gy nk nl l nm nn">npm start</span></pre><p id="c7a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会看到我们有一个导航栏，在我们未登录时显示登录和注册链接。试着注册，注销，签名，做不同的事情。要检查用户是否真的被创建，在Realm平台上，点击侧边栏中的“应用用户”。您将看到用户类型为匿名或电子邮件/密码的用户列表。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="6847" class="np lg iq bd lh nq nr ns lk nt nu nv ln nw nx ny lq nz oa ob lt oc od oe lw of bi translated">结论</h1><p id="2e59" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在下一部分中，我们将为用户添加一个表单来创建他们自己的评论。我们将能够测试我们之前添加的权限，并了解如何根据我们创建的角色来限制用户。</p><p id="0c00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">如果您想联系并讨论更多关于本文或编程的内容，您可以在我的twitter帐户上找到我</em><a class="ae kx" href="https://twitter.com/shahednasserr" rel="noopener ugc nofollow" target="_blank"><em class="kw">@ shahednasserr</em></a></p></div></div>    
</body>
</html>