<html>
<head>
<title>4 Ways to Achieve Open-Closed Principle in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中实现开闭原则的4种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-ways-to-achieve-open-closed-principle-in-c-d2d0ebea4b86?source=collection_archive---------2-----------------------#2021-10-10">https://levelup.gitconnected.com/4-ways-to-achieve-open-closed-principle-in-c-d2d0ebea4b86?source=collection_archive---------2-----------------------#2021-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c316" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利弊分析。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80f0e9d65df6d79cd29521055367f3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DQlThp1S5TuJgOV9"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rangel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·兰格尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开闭原则表明，像方法、类或模块这样的软件组件应该对扩展开放，但对修改关闭。</p><p id="856d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员一般在以下四种情况下遵循开闭原则<strong class="lb iu"/>:</p><ul class=""><li id="5567" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">当添加到一个对象的行为不是它真正关心的时候。例如，域类不应该实现缓存、跟踪、日志和其他横切关注点。这些问题应该放在单独的类中。</li><li id="4f79" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当要添加的行为应该被系统中不同的类重用时。例如，如果开发人员将缓存逻辑直接放入<code class="fe mj mk ml mm b">ProductRepository</code>类，就不可能为其他类型的存储库重用缓存。</li><li id="2ac3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当现有组件的行为由于其脆弱性而难以扩展时。在重用现有组件功能的新组件中实现新需求会更合理。这通常发生在旧的遗留系统上。</li><li id="b65c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当根据一些用户设置、许可或其他条件应该可以启用/禁用新行为时。当然，开发人员可以将逻辑直接放在现有的组件中，并编写<code class="fe mj mk ml mm b">if-else</code>分支，但是代码将很难测试和维护。</li></ul><p id="3597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看最简单的带有接口的类:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="fe42" class="mr ms it mm b gy mt mu l mv mw">public interface IService<br/>{<br/>   void DoSomething(int input);<br/>}</span><span id="b9cd" class="mr ms it mm b gy mx mu l mv mw">public class Service : IService<br/>{<br/>    public void DoSomething(int input)<br/>    {<br/>        throw new NotImplementedException();<br/>    }<br/>}</span></pre><p id="35ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们需要用一个简单的功能来扩展<code class="fe mj mk ml mm b">DoSomething</code>方法的行为，以跟踪方法调用。当然，这要用开合的方式。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="10a9" class="nf ms it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">1.依赖注入</h1><p id="1fe5" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">也许遵循开闭原则最明显的选择是将额外的行为放入一个单独的包装类中，该包装类实现与我们需要扩展的对象相同的接口。然后注入对象以扩展到包装器中。这实际上是一种装饰设计模式。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="07c8" class="mr ms it mm b gy mt mu l mv mw">public class ServiceTracer : IService<br/>{<br/>    private readonly IService _service;</span><span id="4219" class="mr ms it mm b gy mx mu l mv mw">    public Tracer(IService service) =&gt; _service = service;</span><span id="1721" class="mr ms it mm b gy mx mu l mv mw">    public void DoSomething(int input)<br/>    {<br/>        WriteLine($"DoSomething method, input = {input}");<br/>        <br/>        _service.DoSomething(input);    <br/>    }<br/>}</span></pre><h2 id="8df5" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">优点:</h2><ul class=""><li id="6159" class="lv lw it lb b lc nw lf nx li om lm on lq oo lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">ServiceTracer</code>包装器可以和任何实现<code class="fe mj mk ml mm b">IService</code>接口的类型一起工作。</li><li id="f4ca" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">开发人员可以在依赖注入容器中动态启用或禁用包装器，而不必重新编译代码。</li></ul><h2 id="1682" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">缺点:</h2><ul class=""><li id="c779" class="lv lw it lb b lc nw lf nx li om lm on lq oo lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">ServiceTracer</code>只能用于实现<code class="fe mj mk ml mm b">IService</code>接口的类型，不能被其他接口重用。</li><li id="7a23" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">这种方法无法扩展受保护成员的行为。这只是为了装饰公众成员。</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="efc9" class="nf ms it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">2.扩展方法</h1><p id="2650" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">新的行为可以放在扩展方法中。扩展方法应该实现跟踪功能，然后调用<code class="fe mj mk ml mm b">IService</code>类型的原始方法。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="3c6d" class="mr ms it mm b gy mt mu l mv mw">public static class Tracer<br/>{<br/>  public static void DoSomethingWithTracing<br/>       (this IService service, int input)<br/>  {<br/>      WriteLine($"DoSomething method called, input = {input}");</span><span id="2bcd" class="mr ms it mm b gy mx mu l mv mw">      service.DoSomething(input);<br/>    }<br/>}</span></pre><h2 id="e8b9" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">优点:</h2><ul class=""><li id="965e" class="lv lw it lb b lc nw lf nx li om lm on lq oo lu ma mb mc md bi translated">以及在包装器的情况下，扩展方法将与实现<code class="fe mj mk ml mm b">IService</code>接口的任何类型一起工作。</li></ul><h2 id="071c" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">缺点:</h2><ul class=""><li id="af81" class="lv lw it lb b lc nw lf nx li om lm on lq oo lu ma mb mc md bi translated">如果你想停止使用跟踪扩展，你只需要用<code class="fe mj mk ml mm b">DoSomething</code>替换调用<code class="fe mj mk ml mm b">DoSomethingWithTracing</code>，然后重新编译代码。</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="03dc" class="nf ms it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">3.属性</h1><p id="014a" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">属性是将对象从它不应该关心的问题中分离出来的另一种方式。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="54cc" class="mr ms it mm b gy mt mu l mv mw">[PSerializable]<br/>public class TracingAspect : OnMethodBoundaryAspect<br/>{<br/>    public override void OnEntry(MethodExecutionArgs args)<br/>    {<br/>        WriteLine($"{args.Method.Name} method, {args.Arguments[0]} - args.Arguments.GetArgument(0)");<br/>    }<br/>}</span></pre><p id="2d18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">[TracingAspect]</code>只是一个. NET属性，可以应用于这样的方法:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="2883" class="mr ms it mm b gy mt mu l mv mw">public class Service <br/>{<br/>   <strong class="mm iu">[TracingAspect]</strong><br/>   <!-- -->public void DoSomething(int input)<br/>   {<br/>      WriteLine("Base");<br/>   }<br/>}</span></pre><p id="73c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是使用<a class="ae ky" href="https://www.postsharp.net/" rel="noopener ugc nofollow" target="_blank"> postsharp </a>库实现的。</p><h2 id="425f" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">优点:</h2><ul class=""><li id="decb" class="lv lw it lb b lc nw lf nx li om lm on lq oo lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">[TracingAspect]</code>属性可以应用于应用程序中的任何方法。</li><li id="ad46" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对于开发人员来说，应用属性是一个非常快速简单的操作。</li></ul><h2 id="6f02" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">缺点:</h2><ul class=""><li id="6193" class="lv lw it lb b lc nw lf nx li om lm on lq oo lu ma mb mc md bi translated">为方法应用<code class="fe mj mk ml mm b">[TracingAspect]</code>属性需要修改和重新编译代码。</li><li id="a23c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在方法调用之前或之后执行属性需要使用第三方库或编写大量样板代码。</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="1ce8" class="nf ms it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">4.遗产</h1><p id="e171" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">最后一种方法是使用继承。虽然继承有许多限制，但它仍然有一些优势。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="35dd" class="mr ms it mm b gy mt mu l mv mw">public class ServiceTracer : Service<br/>{<br/>  public new void DoSomething(int input)<br/>  { <br/>      WriteLine($"DoSomething method called, input = {input}");</span><span id="0088" class="mr ms it mm b gy mx mu l mv mw">      base.DoSomething(input);<br/>    }<br/>}</span></pre><h2 id="2f63" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">优点:</h2><ul class=""><li id="1d22" class="lv lw it lb b lc nw lf nx li om lm on lq oo lu ma mb mc md bi translated">基于继承的方法允许扩展受保护的方法的行为。</li></ul><h2 id="9d38" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">缺点:</h2><ul class=""><li id="2f1c" class="lv lw it lb b lc nw lf nx li om lm on lq oo lu ma mb mc md bi translated">继承不能用于扩展密封类的行为。</li><li id="1e96" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果需要多态行为，开发人员需要将<code class="fe mj mk ml mm b">Service</code>类中的方法虚拟化。然而，当要扩展的类驻留在单独的库中时，这并不总是可能的。</li><li id="543c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用继承，您只能扩展某些类，而不能扩展接口。</li></ul></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="70e3" class="nf ms it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">摘要</h1><p id="9d07" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">由于各种原因:可测试性、可重用性、可配置性或其他原因，现有的软件组件应该关闭以进行修改。</p><p id="b9eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员至少有四种方法来扩展现有软件组件的行为:包装器(装饰器)、扩展方法、属性、继承。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h2 id="1372" class="mr ms it bd ng ob oc dn nk od oe dp no li of og nq lm oh oi ns lq oj ok nu ol bi translated">我的其他文章</h2><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/7-tricky-questions-to-ask-net-developer-in-a-job-interview-9cdb3789db54"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">要问的7个棘手问题。NET开发人员在工作面试</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">带着答案。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/fast-database-fast-application-useful-db-performance-optimization-techniques-34b6926d1196"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">快速数据库—快速应用程序(有用的数据库性能优化技术)</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">了解加速关系数据库的最佳实践。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">如何专业地对Bug修复进行代码审查</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">审查bug修复时要问的几个重要问题。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>