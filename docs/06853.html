<html>
<head>
<title>Why you should use CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该使用CI</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-you-should-use-ci-df1adc0c5145?source=collection_archive---------17-----------------------#2021-01-07">https://levelup.gitconnected.com/why-you-should-use-ci-df1adc0c5145?source=collection_archive---------17-----------------------#2021-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="26d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何用GitHub动作做到这一点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/404c7e68ac4cb6d7dcf7f9e391afa30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*39mUyWUmQYHxCilf"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="5803" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我曾经参与了一个涉及几个开发人员的项目。所述项目包括为应用程序构建和设计前端页面。在项目开始时，一切都很顺利——每个人都知道他们的任务是什么，以及如何解决它们。</p><p id="ed1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">于是时间一分一秒过去，每个人都努力工作，按时交付项目。于是有一天我们不得不将所有的代码合并成一个单一的代码库。很少有开发人员将他们的更改提交到主分支，而其余的人决定最好在本地进行他们的更改，并在以后处理合并他们的结果代码。</p><p id="9006" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你无法想象合并所有代码是一种多么可怕的体验。这完全是一片混乱。到处都是同名的函数，威胁性的全局变量，合并代码时比我想处理的冲突还要多。</p><p id="47c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事后看来，如果我们只是定期向主分支提交我们的变更，这一切都是可以避免的。但是问题是，我们如何知道我们的提交没有破坏任何现有的代码？</p><h1 id="09aa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">输入CI</h1><p id="2253" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">CI代表“持续集成”,可以定义为一天几次将所有开发人员的工作代码副本合并到主分支的实践。不要每隔很长一段时间就进行大的修改，对代码库的修改应该是逐步的，一点一点的。当与<strong class="ky ir">测试驱动开发</strong><strong class="ky ir">【TDD】</strong>结合使用时，CI处于最佳状态。</p><p id="83b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">潜在的想法是:在项目的开始，人们应该编写适当的单元测试，可以验证当前的代码库是否如预期的那样工作。这样，每次对代码进行更改时，都可以运行单元测试来检查在此过程中是否出现了任何问题。</p><p id="c508" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过组合<strong class="ky ir"> CI </strong>和<strong class="ky ir"> TDD </strong>我们得到了一个工作流，在这个工作流中，开发人员频繁地提交对代码库的更改，并且可以通过运行单元测试过早地识别他们的任何更改是否破坏了现有的代码。如果对工作基础的更改不是小规模的和有规律的，那么识别代码的哪一部分导致了现有的bug将会变得更加困难。除了<strong class="ky ir">之外，<strong class="ky ir">CI</strong>TDD</strong>使得开发过程更加敏捷，对每个参与的人来说更加容易。</p><p id="e68a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是您可以开始想象，每次提交代码时都必须手动运行几次单元测试会变得重复和乏味。幸运的是，GitHub已经覆盖了我们！</p><h1 id="8a4b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">GitHub操作</h1><p id="04d3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.github.com/en/free-pro-team@latest/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>是GitHub提供给我们的工具，用于在GitHub存储库中创建工作流和运行命令。工作流可以在某些事件上触发，如推送或合并到给定的分支。</p><p id="11f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用GitHub actions，我们可以设置一个工作流，在每次有人提交或者合并到主分支时运行我们的单元测试！对开发人员来说，完全自动化的单元测试使CI变得真正独特和强大。不要担心，因为这样做很简单，但是请允许我指导您完成这个过程。</p><h1 id="7a45" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">实施CI </strong></h1><p id="04de" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，创建或导航到您希望在其中实现CI的GitHub存储库。在那里，搜索顶部菜单上的<em class="mp">动作</em>选项卡。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/dab7fabbbcf9fd754bdd59748d767766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w51uAUDs0i5rpDDEhfinzQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd lu"> <em class="mr">动作</em> </strong> <em class="mr">选项卡顶部菜单</em></figcaption></figure><p id="fbc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦到了那里，让自己舒服！GitHub已经为您提供了大量的工作流:从几乎每一种现代语言的CI到构建和部署，稍后还会有更多！您可以随意选择一个预先存在的工作流，但是对于本演练，我将继续从头创建一个工作流。点击<em class="mp">自己设置一个工作流程</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/4d6141bb54c2c9f0032087734516c925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*FPJZflzYxH7EY3GKAAOltw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd lu">自己设置一个工作流</strong>链接</figcaption></figure><p id="9835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦出现，GitHub将向您展示一个用于创建工作流的出色的文档化模板，它应该看起来像下面这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="897e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧。工作流是从<code class="fe mv mw mx my b">.yaml</code>文件创建的，如果你对它们更熟悉的话，它的工作方式有点像JSONs。首先，在<code class="fe mv mw mx my b">name</code>中，我们给正在创建的工作流命名。在标签<code class="fe mv mw mx my b">on</code>上，我们可以指定我们希望在什么条件下执行我们的工作流。</p><p id="de45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此示例在向主分支发送推或拉请求后触发。我们可以添加<code class="fe mv mw mx my b">workflow_dispatch</code>来允许我们手动运行这个动作，而不必等待我们刚刚定义的任何触发器。</p><p id="1516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GitHub动作是在它们的<strong class="ky ir">虚拟机(VM) </strong>中执行的，所以我们需要告诉GitHub我们希望将要执行我们工作流的VM使用什么操作系统。这是用<code class="fe mv mw mx my b">runs-on</code>用ubuntu完成的——latest指的是Ubuntu的最新稳定版本。</p><p id="2415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以告诉GitHubs我们想要执行什么操作。这是在<code class="fe mv mw mx my b">steps</code>中用<code class="fe mv mw mx my b">name</code>和<code class="fe mv mw mx my b">run</code>完成的，最后一个包含我们希望运行的实际命令。</p><h1 id="3175" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">CI示例</h1><p id="24e2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">既然我们已经知道了如何创建GitHub Actions，我们还等什么去尝试呢？我用以下python代码创建了一个小型GitHub存储库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f9bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个判断一个数是否是质数的简单函数。现在我们有了代码，我们需要运行单元测试。这可以用<code class="fe mv mw mx my b">unittest</code>库来完成，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="29d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在本地运行这些单元测试，请执行以下简单操作:</p><pre class="kg kh ki kj gt mz my na nb aw nc bi"><span id="e5e1" class="nd lt iq my b gy ne nf l ng nh">$ <strong class="my ir">python tests.py<br/></strong>......<br/>--------------------------------------------------------------------<br/>Ran 6 tests in 0.000s</span><span id="325e" class="nd lt iq my b gy ni nf l ng nh">OK</span></pre><p id="cbe0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe mv mw mx my b">tests.py</code>是包含单元测试的python文件。</p><p id="910d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有代码要测试，也有单元测试要做，让我们创建CI工作流。它最终应该看起来或多或少像下面这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ecb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我指示GitHub在每次有对资源库的推或拉请求时运行<code class="fe mv mw mx my b">python3 tests.py</code>。我也可以手动运行测试，因为我已经启用了<code class="fe mv mw mx my b">workflow_dispatch</code>。我们来试试吧！</p><p id="7d74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到存储库中的<em class="mp">操作</em>，如果您已经创建了工作流，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/56e69fa2a26642e26b8af9b1aa3796ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYcLQVGqfqmpNDCzdJ6OGQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd lu">仓库内的动作</strong></figcaption></figure><p id="b42c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以看到我们的行动了！要运行它，我们可以提交到主分支，或者通过单击<em class="mp">运行工作流</em>来手动运行工作流。如果操作失败(并非所有单元测试都成功)，您将会收到电子邮件通知。此外，GitHub可以与Slack或Discord集成，让您的开发人员了解代码库的最新状态！如果单元测试的最后一次运行成功与否，您的存储库也会出现在它的首页。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/aa3268bfb4355db481516cac4c71f840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G8kR2woYRRrcCNhhMCbE9A.png"/></div></div></figure><h1 id="33df" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的想法</h1><p id="f261" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">CI的用途绝不仅限于此！CI通常与<strong class="ky ir">连续交付(CD) </strong>一起使用，其中对成功通过单元测试的代码库的每个提交都被部署到生产中。多亏了GitHub Actions，这也可以完全自动化，值得拥有自己的文章，如果你想让我报道它，现在就让我来报道吧！</p><p id="dbd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一如既往，如果需要，请随时联系我。本教程中的所有代码都可以在GitHub上免费获得。</p><div class="nl nm gp gr nn no"><a href="https://github.com/PaburoTC/CI-CD" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">PaburoTC/CI-CD</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">在GitHub上创建一个帐户，为PaburoTC/CI-CD的开发做出贡献。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc kp no"/></div></div></a></div><p id="93d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐连续集成！</p><p id="1442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你</p></div></div>    
</body>
</html>