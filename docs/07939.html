<html>
<head>
<title>Using Terraform together with Azure, Azure Pipelines &amp; GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Terraform与Azure、Azure Pipelines和GitHub操作一起使用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-terraform-with-azure-azure-pipelines-github-actions-86e043bd0d9e?source=collection_archive---------5-----------------------#2021-03-23">https://levelup.gitconnected.com/using-terraform-with-azure-azure-pipelines-github-actions-86e043bd0d9e?source=collection_archive---------5-----------------------#2021-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="edfc" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Azure CLI和PowerShell是您的朋友</h2><div class=""/><p id="0bc4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">Terraform(基础设施供应)、Azure Pipelines (CI/CD)和GitHub Actions (CI)都非常受欢迎。所以它们经常一起使用也就不足为奇了。虽然我使用了一些Azure DevOps扩展和GitHub动作，但我发现自己主要依赖脚本进行集成。</p><p id="b9a4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这篇文章中，我分享了我用来将Terraform与Azure Pipeline或GitHub Action workflow集成的方法，我如何处理Terraform资源提供者不支持某个特定功能的情况，以及一些其他技巧。</p><p id="c749" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">因为我是一个Azure的家伙，我将专注于用Terraform创建<strong class="jy ja"> Azure </strong>资源。我将跳过地形基础知识，<a class="ae ku" href="https://learn.hashicorp.com/collections/terraform/azure-get-started" rel="noopener ugc nofollow" target="_blank">这里有很棒的(视频)学习内容作为介绍</a>。其他技术选择是PowerShell作为脚本外壳的选择，以及YAML Azure管道，即忽略经典(ClickOps)管道。下面的模式也适用于其他超大规模和工具。</p><p id="c89a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我将在下面介绍的主题是:</p><ul class=""><li id="413e" class="kv kw iq jy b jz ka kd ke kh kx kl ky kp kz kt la lb lc ld bi translated">Azure提供程序配置</li><li id="9778" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">提供者版本控制</li><li id="9b25" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">Azure后端配置</li><li id="8b33" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">地形版本化</li><li id="0c2b" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">输入变量</li><li id="b6df" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">功能回退到Azure CLI</li><li id="c186" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">输出变量</li><li id="8b39" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">拆卸</li><li id="6f16" class="kv kw iq jy b jz le kd lf kh lg kl lh kp li kt la lb lc ld bi translated">端到端示例</li></ul><p id="fd75" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">作为参考，使用的工具及其在DevOps工具分类中的位置:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/20b0d379806f874b423a36eb946b3780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQwSiQHWDtYcYZ2LASnL0A.png"/></div></div></figure><p id="3424" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">关于DevOps工具的完整参考模型，请参考<a class="ae ku" href="https://digital.ai/periodic-table-of-devops-tools" rel="noopener ugc nofollow" target="_blank">周期表</a>:</p><div class="lv lw gp gr lx ly"><a href="https://digital.ai/periodic-table-of-devops-tools" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ja gy z fp md fr fs me fu fw iz bi translated">DevOps周期表</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">DevOps工具周期表是行业内识别最佳工具的首选资源…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">数字. ai</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm lt ly"/></div></div></a></div></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="604f" class="mu mv iq bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated"><strong class="ak"> Azure提供者配置</strong></h1><p id="caf0" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">我从来没有为Terraform使用单独的凭证。交互使用Terraform，支持继承Azure CLI用户凭证，如这里的<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/guides/azure_cli" rel="noopener ugc nofollow" target="_blank">所述</a>。使用Azure CLI或Terraform时，基本上有两种类型的脚本可以确保订阅保持一致:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">使用Azure CLI以交互方式向Terraform进行身份验证，ARM_SUBSCRIPTION_ID优先</figcaption></figure><p id="265e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">或者</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">使用Azure CLI以交互方式向Terraform进行身份验证，订阅连接优先</figcaption></figure><p id="7292" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这是交互式的。那么，如何在自动化中共享凭证呢？Terraform仅支持在作为用户而非服务主体进行身份验证时使用Azure CLI会话。对于<strong class="jy ja"> Azure Pipelines </strong>，还有另一种方法，但是您需要为您的管道配置一个Azure服务连接。如果你还没有这样做，创建一个描述<a class="ae ku" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/library/service-endpoints?view=azure-devops&amp;tabs=yaml" rel="noopener ugc nofollow" target="_blank">在这里</a>。使用<a class="ae ku" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/deploy/azure-cli?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure CLI任务</a>，并将其配置为将服务主体凭证公开为环境变量(<code class="fe od oe of og b">addSpnToEnvironment: true</code>)。这允许您捕获服务主体凭证，并使用相同的凭证配置Terraform:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">Terraform身份验证继承Azure管道服务连接凭据</figcaption></figure><p id="267f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">注意零合并操作符<code class="fe od oe of og b">??=</code>的使用。环境变量只有在尚未定义时才会被设置，如果已经定义，则不会被覆盖。</p><p id="d5d1" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在<strong class="jy ja"> GitHub Actions </strong>中,(目前)没有与Azure的原生集成，即预先存在的连接可以被重用。相反，Azure登录操作需要配置一个密码，如这里的<a class="ae ku" href="https://github.com/marketplace/actions/azure-login" rel="noopener ugc nofollow" target="_blank">所述</a>。这将像下面这样存储一个json值作为秘密:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">GitHub Azure登录操作的Azure服务主体凭据</figcaption></figure><p id="aedc" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">一旦存储，相同的秘密可用于Terraform:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">Terraform身份验证重用GitHub Azure操作凭据</figcaption></figure><p id="1f37" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">由于其他平台提供者或者不需要配置(例如，<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/tls" rel="noopener ugc nofollow" target="_blank">证书</a>、<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/cloudinit" rel="noopener ugc nofollow" target="_blank">云初始化</a>、<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/random" rel="noopener ugc nofollow" target="_blank">随机</a>生成器)，或者基于另一个提供者(例如，<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/azurerm" rel="noopener ugc nofollow" target="_blank"> Azure </a>、<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/azuread" rel="noopener ugc nofollow" target="_blank"> AAD </a>)创建的资源的输出来动态配置(例如，<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/dns" rel="noopener ugc nofollow" target="_blank"> DNS </a>、<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/helm" rel="noopener ugc nofollow" target="_blank"> Helm </a>、<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>)，这覆盖了99%的</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="e886" class="mu mv iq bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">提供者版本控制</h1><p id="f948" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">这实际上是标准的Terraform，但我将在这里介绍它:提供者依赖关系(从版本0.14开始)在<a class="ae ku" href="https://www.terraform.io/docs/language/dependency-lock.html" rel="noopener ugc nofollow" target="_blank"> .terraform.lock.hcl依赖关系锁文件</a>中捕获。Hashicorp建议将该文件包含在源代码控制中，以便在自动化中使用。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="decc" class="mu mv iq bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">Azure后端配置</h1><p id="dbd2" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">Terraform可以在<a class="ae ku" href="https://www.terraform.io/docs/language/settings/backends/index.html" rel="noopener ugc nofollow" target="_blank">后端</a>中维护其状态，而不是在本地磁盘上。我使用的是<a class="ae ku" href="https://www.terraform.io/docs/language/settings/backends/azurerm.html" rel="noopener ugc nofollow" target="_blank"> azurerm后端</a>，它使用一个存储帐户，需要额外的配置。为了能够使用后端，而不将任何敏感信息检查到Git中，我使用了<a class="ae ku" href="https://www.terraform.io/docs/language/settings/backends/configuration.html#partial-configuration" rel="noopener ugc nofollow" target="_blank">部分配置</a>。也就是说，我有一个backend.tf模板，它被部分填充，然后在初始化Terraform时将其余部分作为参数传入:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">Azure Pipeline中的Terraform后端设置</figcaption></figure><p id="88f5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为了确保Terraform能够访问用于后端的存储帐户，可以定义<code class="fe od oe of og b">ARM_SAS_TOKEN</code>(我推荐使用容器级SAS令牌)<code class="fe od oe of og b">ARM_ACCESS_KEY</code>(存储帐户密钥，不推荐)，或者授予运行Terraform的服务主体<a class="ae ku" href="https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles#storage-blob-data-contributor" rel="noopener ugc nofollow" target="_blank">存储Blob数据贡献者</a>角色。</p><p id="1b78" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">Terraform后端支持的一件事是使用不同的工作空间，例如用于开发、测试等的不同配置。如果你使用的是Terraform后端，那么通过<code class="fe od oe of og b">TF_WORKSPACE</code>变量锁定要使用的工作空间是个好主意。这确保了Terraform不会接触到在其他工作空间中创建的资源。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="c4d9" class="mu mv iq bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">地形版本化</h1><p id="09bb" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">为了与所用的Terraform版本保持一致，我使用了一个<a class="ae ku" href="https://github.com/tfutils/tfenv#terraform-version-file" rel="noopener ugc nofollow" target="_blank">。本地带有<a class="ae ku" href="https://github.com/tfutils/tfenv" rel="noopener ugc nofollow" target="_blank"> tfenv </a>的terraform-version </a>文件(仅在Linux &amp; macOS上工作)。要在Azure管道中使用该文件中存储的版本:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">在Azure Pipeline中使用首选的Terraform版本</figcaption></figure><p id="fc53" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">或者在GitHub Actions中，类似的方法是:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">在GitHub操作中使用首选的Terraform版本</figcaption></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="d040" class="mu mv iq bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">输入变量</h1><p id="2370" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">在Azure管道中，输入变量需要特殊处理。环境变量总是被转换成大写，而输入变量(按照命名约定)是小写的。假设有一个输入变量<code class="fe od oe of og b">foo</code>:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">地形变量' foo '</figcaption></figure><p id="e69a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为了覆盖一个变量的值，定义了一个Azure Pipeline变量<code class="fe od oe of og b">TF_VAR_foo="bar"</code>，但是它将被转换成一个环境变量<code class="fe od oe of og b">TF_VAR_FOO="bar"</code>，因此Terraform将看不到它，并将使用“notbar”作为<code class="fe od oe of og b">var.foo</code>的值。</p><p id="dc04" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">为了解决这个问题，需要一些环境变量的巫术。以下代码涵盖了Linux和Windows两种版本(纯Linux版本可能更短):</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">修复Azure Pipeline中TF_VAR环境变量的情况</figcaption></figure><p id="eca8" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><code class="fe od oe of og b">TF_VAR_FOO</code>将被转换回<code class="fe od oe of og b">TF_VAR_foo</code>，Terraform将使用“bar”作为<code class="fe od oe of og b">var.foo</code>的值。</p><p id="4f8b" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">由于<strong class="jy ja"> GitHub Actions </strong>不修改环境变量(hurray)的情况，所以没有什么需要修复的。</p><p id="ed63" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">当我们讨论环境变量时，请确保也设置了<code class="fe od oe of og b">TF_IN_AUTOMATION=true</code>和<code class="fe od oe of og b">TF_INPUT=0</code>。这将防止Terraform在自动化过程中因用户输入而停止。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="62c1" class="mu mv iq bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">功能回退到Azure CLI</h1><p id="a86f" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">任何使用Terraform的人都知道，云服务提供商通常不会实现100%的底层服务。给定的资源完全不受支持，或者受支持的资源的某些功能无法通过提供程序进行配置。事实上，这(资源API覆盖率)是使用Terraform的主要缺点。</p><p id="9984" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">好吧，如果你能两全其美呢？terra form<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs" rel="noopener ugc nofollow" target="_blank">Azure RM</a>provider拥有<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/resource_group_template_deployment" rel="noopener ugc nofollow" target="_blank">Azure RM _ resource _ group _ template _ deployment</a>资源作为一种包罗万象的方法，但我个人更喜欢另一种技术:使用terra form<a class="ae ku" href="https://www.terraform.io/docs/language/resources/provisioners/local-exec.html" rel="noopener ugc nofollow" target="_blank">local-exec</a>provisioner和Azure CLI:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">使用Azure CLI扩展Terraform</figcaption></figure><p id="c388" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在这种特定情况下，<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/azurerm/2.51.0/docs/resources/application_insights" rel="noopener ugc nofollow" target="_blank">azure RM _ application _ insights</a>资源尚不支持与日志分析工作区的集成(在<a class="ae ku" href="https://registry.terraform.io/providers/hashicorp/azurerm/2.51.0/docs" rel="noopener ugc nofollow" target="_blank">azure RM provider 2.51版</a>)。Azure CLI在创建资源后调用，以执行Terraform无法提供的那部分配置。注意，没有指定shell，所以不管使用Bash还是PowerShell，都可以工作。由于我们将Terraform设置为使用与Azure CLI相同的安全凭证，订阅排队，并且Azure CLI是等幂的，这就可以工作了。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="757a" class="mu mv iq bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">输出变量</h1><p id="ad61" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">基础设施只是包括应用程序在内的整体解决方案的一部分。Terraform供应完成后，需要在已创建的资源上加载数据和部署应用程序。但是为了能够做到这一点，我们需要知道实际的资源id或名称是什么。这些通常作为Terraform输出变量提供。下面的代码片段将这些变量导出为<strong class="jy ja"> Azure Pipeline </strong>任务输出:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">将Terraform输出导出为Azure管道任务输出</figcaption></figure><p id="42d6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> GitHub Actions </strong>有多个模型在步骤之间传递数据。一个作为步骤输出，另一个作为环境变量。这个代码片段实现了这两个功能:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">将Terraform输出导出为GitHub操作步骤输出</figcaption></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="fc30" class="mu mv iq bd mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr bi translated">拆卸</h1><p id="12cb" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">如果您在CI中运行Terraform来测试资源调配，那么一旦验证通过，您也会破坏基础架构。如果这最后一步失败了，基础设施和相关的成本可能会堆积起来，尤其是在使用夜间构建时。因此，为了确保基础设施总是被破坏，即使在Terraform失败的情况下，我有以下方法。首先，我确保定义元数据，以便识别创建了哪些资源:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">能够拆卸的Terraform仪器</figcaption></figure><p id="b87e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">有了上面的标签，下面的任务就能够在<strong class="jy ja"> Azure Pipelines </strong>中执行拆卸:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">拆除Terraform在Azure Pipeline <strong class="ak">创造的资源(使用风险自担！)</strong></figcaption></figure><p id="42d5" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">同样针对<strong class="jy ja">的GitHub动作</strong>是:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">在GitHub actions <strong class="ak">中拆除Terraform创建的资源(使用风险自担！)</strong></figcaption></figure><h1 id="e039" class="mu mv iq bd mw mx oh mz na nb oi nd ne nf oj nh ni nj ok nl nm nn ol np nq nr bi translated">端到端示例</h1><p id="4444" class="pw-post-body-paragraph jw jx iq jy b jz ns kb kc kd nt kf kg kh nu kj kk kl nv kn ko kp nw kr ks kt ij bi translated">上面的例子都经过了修改，只解决了所描述的问题。它们可以在端到端场景中结合使用，我在这里不做介绍，只是简单地链接到:</p><p id="4edc" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><a class="ae ku" href="https://github.com/geekzter/azure-vdc/blob/master/pipelines/templates/vdc-terraform-apply.yml" rel="noopener ugc nofollow" target="_blank">示例azure管道(作为YAML模板):azure-vdc </a> <br/> <a class="ae ku" href="https://github.com/geekzter/synapse-performance/blob/main/pipelines/templates/synapse-terraform-apply.yml" rel="noopener ugc nofollow" target="_blank">示例Azure管道(作为YAML模板):synapse-performance</a><br/><a class="ae ku" href="https://github.com/geekzter/azure-minecraft-docker/blob/main/.github/workflows/ci-vanilla.yml" rel="noopener ugc nofollow" target="_blank">示例GitHub动作工作流程:azure-minecraft-docker </a></p></div></div>    
</body>
</html>