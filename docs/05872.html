<html>
<head>
<title>Functional Dynamic Programming With Haskell: Bottom Up Space Optimized</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Haskell函数式动态编程:自底向上空间优化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-dynamic-programming-with-haskell-bottom-up-space-optimized-ef7b5f73a849?source=collection_archive---------14-----------------------#2020-10-07">https://levelup.gitconnected.com/functional-dynamic-programming-with-haskell-bottom-up-space-optimized-ef7b5f73a849?source=collection_archive---------14-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1a49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用runST和StateT的纯功能单态突变</p><p id="7ab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是对<a class="ae kl" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-92e68efe808" rel="noopener">第一部分</a>和<a class="ae kl" href="https://medium.com/@SA_19/functional-dynamic-programming-with-haskell-top-down-and-bottom-up-7ccade222337" rel="noopener">第二部分</a>的跟进</p><p id="4c76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次访问圣莫纳德哈斯克尔维基。</p><p id="0aa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">引自</strong><a class="ae kl" href="https://wiki.haskell.org/Monad/ST" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://wiki.haskell.org/Monad/ST</strong></a></p><p id="07b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ST monad允许您使用就地更新，但它是可转义的(不像IO)。ST动作具有以下形式:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="19b8" class="kv kw iq kr b gy kx ky l kz la">ST s α</span></pre><p id="5b55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着它们返回α类型的值，并在“线程”中执行。</p><p id="347f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lb lc ld kr b">runST</code>函数是纯函数。</p><p id="12c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">状态单子</strong></p><ul class=""><li id="458c" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">可用于跟踪内部状态，作为参数传递是很麻烦的。</li><li id="5f7c" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">是具有从当前状态到包含值和更新状态的元组的函数的构造函数。</li></ul><p id="7d04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于突变，我们将在runST中使用ST单子</p><ul class=""><li id="90ac" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">ST是严格状态单子的可变变体</li><li id="2b68" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它解冻数据，使其变异，然后重新冻结，这样它就不能再变异了。因此，它设法变异，并仍然保持引用透明。-</li></ul><figure class="km kn ko kp gt lt gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/e1de57d37d9d046989efe80cb06a6275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*MkhJHLnnvNC18DL6mWMvNg.png"/></div></figure><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="79ba" class="kv kw iq kr b gy kx ky l kz la">:info ST<br/>newtype ST s a = GHC.ST.ST (GHC.ST.STRep s a) <br/>... <br/>instance Monad (ST s)</span><span id="2969" class="kv kw iq kr b gy lw ky l kz la">:info runST<br/>runST :: (forall s. ST s a) -&gt; a</span></pre><p id="e4e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> ST s a </strong>中的<strong class="jp ir"> s </strong>是从正在变异的事物中派生出来的类型。“s”不是我们变异的状态。</p><p id="1fcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，什么是“s”型呢？</p><p id="856b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了将一个可变的引用冻结成一个持久不变的数据结构作为最终结果，ST在编译时强制执行它，使得<strong class="jp ir">“s”永远不会与ST单子</strong>之外的任何东西统一。</p><p id="5ba6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们要讨论上面的问题？</p><p id="714b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们很好奇，希望确保我们的突变是安全的，并且在runST上下文中是透明的。</p><p id="1b20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个空间优化版本，使用了状态单子(或来自单子变形金刚的StateT)</p><p id="6c49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在runST内使用状态单子的自下而上空间优化版本</strong></p><ul class=""><li id="e2b0" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">countDerangementsBUSO使用execStateT给我们一个新的状态(StateT ),其中<code class="fe lb lc ld kr b">StateT s</code>是一个基于<code class="fe lb lc ld kr b">State s</code>的单子转换器，你可以注意到“m”中的值。</li></ul><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="1fba" class="kv kw iq kr b gy kx ky l kz la">:info StateT<br/>newtype StateT s (m :: * -&gt; *) a = StateT {runStateT :: s -&gt; m (a, s)}</span></pre><p id="7f09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">execState产生新状态的示例。</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="2bf8" class="kv kw iq kr b gy kx ky l kz la">:t execState (put 5) 1<br/>execState (put 5) 1 :: Num s =&gt; s</span><span id="7a4e" class="kv kw iq kr b gy lw ky l kz la">execState (put 5) 1<br/>5</span></pre><ul class=""><li id="5d56" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">cdWState接受一个Int并给出tuple (Int，(Int，Int))的StateT，其中tuple表示从1到n步进时计算的(currentValue，(currMinus1Value，currMinus2Value))</li></ul><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="c7f8" class="kv kw iq kr b gy kx ky l kz la">:t cdWState<br/>cdWState :: Monad m =&gt; Int -&gt; StateT (Integer, (Integer, Integer)) m ()</span></pre><ul class=""><li id="2166" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">shiftTuple实现了一个步骤，该步骤计算所有三个值(当前值、当前值减1、当前值减2 ),接受一个Int和一个Tuple，并返回一个tuple</li></ul><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="cd0c" class="kv kw iq kr b gy kx ky l kz la">:t shiftTuple<br/>shiftTuple :: Int -&gt; (Integer, (Integer, Integer)) -&gt; (Integer, (Integer, Integer))</span></pre><p id="bda8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个代码</p><figure class="km kn ko kp gt lt"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="2090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Scala Cats状态的类似代码如下所示</p><figure class="km kn ko kp gt lt"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="2ce7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再看一下上述Simple和TD/BU版本之间的时间/空间比较</p><figure class="km kn ko kp gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/3ada64ef71a5422afe971f12bf745678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oop3W6mDIeKZW9dAKH5UQA.png"/></div></div></figure><figure class="km kn ko kp gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi me"><img src="../Images/126326194c2eebbb7d66a9808a2afc1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViK3dWjme6rWucIPCzpZew.png"/></div></div></figure><p id="5877" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BUSO(自下而上空间优化)版本显示了n = 5到35时近乎恒定的空间利用率和运行时间。</p></div></div>    
</body>
</html>