<html>
<head>
<title>Continuous deployment using Docker, GitHub Actions, and Web-hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker、GitHub动作和Web挂钩进行持续部署</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/automated-deployment-using-docker-github-actions-and-webhooks-54018fc12e32?source=collection_archive---------0-----------------------#2020-03-01">https://levelup.gitconnected.com/automated-deployment-using-docker-github-actions-and-webhooks-54018fc12e32?source=collection_archive---------0-----------------------#2020-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2e45da80042efd511885c4fc805c1e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vZJeflsYT9xzBiFnqjPUw.jpeg"/></div></div></figure><h2 id="82bf" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">要求</h2><ul class=""><li id="29dd" class="ku kv iq kw b kx ky kz la kh lb kl lc kp ld le lf lg lh li bi translated">一个maven项目将被<a class="ae lj" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">停靠</a>进行部署。在本教程中，我将使用一个<a class="ae lj" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>应用程序</li><li id="b029" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated">GitHub知识库</li><li id="6bc9" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated">Docker Hub仓库</li><li id="2557" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated">将部署容器映像的Linux机器</li><li id="5291" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated">本教程基于基于<a class="ae lj" href="https://trunkbaseddevelopment.com/" rel="noopener ugc nofollow" target="_blank">主干的开发</a>策略，但是您可以塑造下面描述的技术来更好地适应您的分支策略</li></ul><h2 id="377f" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">我们要建造什么？</h2><p id="6bd4" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">我们将创建一个GitHub工作流，使用一个<a class="ae lj" href="https://medium.com/tanda-developers/a-beginners-guide-to-using-webhooks-3d95018fabbc" rel="noopener"> Webhook </a>作为触发器，测试、构建并自动触发远程服务器上自动生成的docker容器映像的重新部署。</p><h1 id="77b1" class="me jz iq bd ka mf mg mh kd mi mj mk kg ml mm mn kk mo mp mq ko mr ms mt ks mu bi translated">入门指南</h1><p id="a171" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">有许多工具可用于自动化部署。这种方法为运行在远程服务器上的简单应用程序提供了一种非常简单直接的实现方式。</p><h2 id="8851" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">GitHub存储库</h2><p id="1aad" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">我们有一个共享的主分支(主干),许多短命的特性分支从它开始生长，并在几天内合并(理想情况下)。我们也有几个发布分支，主分支的版本被挑选出来进行部署。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/c1f5419518e5a9799c8848b79262aafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*E5JB-r96AL1n40T3EYfyCg.jpeg"/></div></figure><h2 id="e7c5" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">Docker Hub知识库</h2><p id="c917" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">您还应该创建一个<a class="ae lj" href="https://hub.docker.com/repositories" rel="noopener ugc nofollow" target="_blank"> Docker Hub存储库</a>。我们生成的容器映像将被推送到那里，我们的服务器将总是从那里获取应用程序的最新版本，以便重新部署它。</p><h1 id="c741" class="me jz iq bd ka mf mg mh kd mi mj mk kg ml mm mn kk mo mp mq ko mr ms mt ks mu bi translated">GitHub工作流程</h1><p id="dfca" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">为我们的项目触发GitHub动作就像在正确的位置放置正确的配置文件一样简单。在<em class="na"> /中的项目根目录下创建两个新的YAML配置文件。github/workflows </em>文件夹。第一个文件将用于主分支，并将运行一些测试以确保每次推送都正常。第二个将仅应用于发布分支，不仅测试新版本，还为其创建docker映像并触发重新部署。</p><h2 id="a0f3" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">主工作流程</h2><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="1f5c" class="jy jz iq nc b gy ng nh l ni nj">name: Master - Testing<br/><br/>on:<br/>  push:<br/>    branches:<br/>      - 'master'<br/><br/>jobs:<br/><br/>  artifact:<br/><br/>    name: Test master branch - GitHub Packages<br/>    runs-on: ubuntu-18.04<br/><br/>    steps:<br/>      - uses: actions/checkout@v1<br/>      - name: Set up JDK 11<br/>        uses: actions/setup-java@v1<br/>        with:<br/>          java-version: 11.0.4<br/>      - name: Maven Package<br/>        run: mvn -B clean package -DskipTests<br/>      - name: Maven Verify<br/>        run: mvn -B clean verify</span></pre><p id="1763" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">这个简单的文件很容易阅读，它触发了Java 11环境中maven构建生命周期的打包和验证阶段。我强烈建议看一下<a class="ae lj" href="https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow#creating-a-workflow-file" rel="noopener ugc nofollow" target="_blank">关于工作流的官方文档</a>来理解这些配置文件的工作。现在，让我们一步一步地看看我们刚刚创建的那个:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="7e69" class="jy jz iq nc b gy ng nh l ni nj">name: Master - Testing<br/><br/>on:<br/>  push:<br/>    branches:<br/>      - 'master'</span></pre><p id="d62e" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">仅当主分支被推送时，才会触发此工作流。当您在GitHub页面上查看您的操作历史时，以及当您收到关于失败测试的电子邮件通知时，您为您的工作流指定的名称将是可见的，因此请始终选择一个有意义的名称。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="faa1" class="jy jz iq nc b gy ng nh l ni nj">jobs:<br/><br/>  test:<br/><br/>    name: Test master branch - GitHub Packages<br/>    runs-on: ubuntu-18.04<br/><br/>    steps:<br/>      - uses: actions/checkout@v1<br/>      - name: Set up JDK 11<br/>        uses: actions/setup-java@v1<br/>        with:<br/>          java-version: 11.0.4<br/>      - name: Maven Package<br/>        run: mvn -B clean package -DskipTests<br/>      - name: Maven Verify<br/>        run: mvn -B clean verify</span></pre><p id="8e51" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">在这个工作流程中，我们只有一个作业。我们定义作业将在其上运行的机器类型，您可以在这里找到可能值的列表<a class="ae lj" href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="c61c" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">一项工作总是由多个步骤组成。在这种情况下，我们用期望的版本建立一个java环境，一旦它准备好了，我们就可以运行我们想要的任何maven命令。在这种情况下，我们打包我们的应用程序，然后验证它。</p><p id="223d" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">如果你不熟悉Maven构建生命周期，我建议看一看<a class="ae lj" href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" rel="noopener ugc nofollow" target="_blank">在它的每个阶段</a>到底做了什么。</p><h2 id="65f7" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">试试吧！</h2><p id="19d7" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">推送主分支的新版本，并转到存储库的Actions部分。您将立即看到工作流被执行。我鼓励您现在对您的配置文件进行一些调整，并根据您的需要调整工作流的行为。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/1e27d078b6aeb785e63636ed96ade4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0nTe86ypMoU9rvg9_UEgw.png"/></div></div></figure><h2 id="8763" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">发布工作流程</h2><p id="17f3" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">现在我们已经准备好了主工作流，让我们把注意力转向节目的明星。我们的发布工作流应该构建一个docker映像并将其发布到Docker Hub存储库中，并通过调用Webhook端点来触发服务器上的重新部署。如果你不熟悉Webhooks，我建议看看<a class="ae lj" href="https://codeburst.io/what-are-webhooks-b04ec2bf9ca2" rel="noopener" target="_blank">这篇文章</a>。</p><p id="560d" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">在我们看一下发布分支的工作流文件应该是什么样子之前，让我们已经为自动重新部署准备好了服务器。</p><h1 id="87e4" class="me jz iq bd ka mf mg mh kd mi mj mk kg ml mm mn kk mo mp mq ko mr ms mt ks mu bi translated">准备服务器</h1><p id="e4c9" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">对于这个例子，我使用一个简单的运行Ubuntu 18.04的AWS EC2实例。在远程实例上使用它之前，您可以在本地机器上测试它。</p><h2 id="9a8f" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">安装docker</h2><p id="a5f4" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">由于我们的应用程序将被转换成一个容器映像，我们的服务器将需要安装docker，以便总是获取和运行最新版本。你可以在这里找到如何安装docker <a class="ae lj" href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" rel="noopener ugc nofollow" target="_blank">最新版本的详细信息，但是这个简单的命令列表在大多数情况下也能达到目的:</a></p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="7d88" class="jy jz iq nc b gy ng nh l ni nj">sudo apt-get update<br/>sudo apt-get remove docker docker-engine docker.io<br/>sudo apt install docker.io<br/>sudo systemctl start docker<br/>sudo systemctl enable docker</span></pre><p id="0fbc" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">然后，您可以检查安装是否成功:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="3eb0" class="jy jz iq nc b gy ng nh l ni nj">docker --version</span></pre><h2 id="721f" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">创建Dockerfile文件</h2><p id="271f" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">为了将我们的应用程序转换成容器映像，我们需要一个配置文件来描述创建它的必要步骤。在项目的根目录下，以<em class="na"> Dockerfile </em>的名称创建以下文件。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="2c80" class="jy jz iq nc b gy ng nh l ni nj">FROM maven:3.6.3-jdk-11-slim AS <em class="na">build<br/></em>RUN mkdir -p /workspace<br/>WORKDIR /workspace<br/>COPY pom.xml /workspace<br/>COPY src /workspace/src<br/>RUN mvn -B -f pom.xml clean package -DskipTests<br/><br/>FROM openjdk:11-jdk-slim<br/>COPY --from=<em class="na">build </em>/workspace/target/*.jar app.jar<br/>EXPOSE 8080<br/>ENTRYPOINT ["java","-jar","app.jar"]</span></pre><p id="0d99" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">这将创建一个包含pom文件和maven项目源代码的工作区。然后将它打包，并将生成的jar文件作为容器的入口点公开。(确保您的maven配置生成了一个JAR文件)</p><p id="7549" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">注意:确保公开应用程序使用的端口</p><h2 id="117f" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">打造码头工人形象</strong></h2><p id="51a5" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">你现在可以使用docker来建立你的形象。使用您的Docker Hub凭证登录，导航到您的项目的根目录，构建它并将其推送到您的存储库:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="c84c" class="jy jz iq nc b gy ng nh l ni nj">sudo docker login -u myusername -p mypassword<br/>cd /example/my-project-path<br/>sudo docker build -t example/my-repository .<br/>sudo docker push example/my-repository</span></pre><h2 id="51c2" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">运行应用程序</h2><p id="f52e" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">现在，您可以通过命令行获取并运行应用程序的最新可用映像:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="5644" class="jy jz iq nc b gy ng nh l ni nj">docker run -d --name=SAMPLE_APP example/repository:latest</span></pre><p id="b6d6" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">这将在后台启动应用程序。该名称在以后的重新部署中会很有用，所以请确保将其作为参数传递，并存储起来以备后用。然后，您可以获得当前加载的所有容器的列表，在那里您将有希望找到您的应用程序的当前状态:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="fdb4" class="jy jz iq nc b gy ng nh l ni nj">docker container ls -a </span></pre><h2 id="5b90" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">为Webhook创建一个端点</h2><p id="9d9f" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">我们的目标是使HTTP端点可用，以便我们可以在每次消息发送到该端点时重新部署应用程序。为了做到这一点，我们将安装这个<a class="ae lj" href="https://github.com/adnanh/webhook" rel="noopener ugc nofollow" target="_blank">简洁的轻量级工具</a>来为我们做这件事。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="2bf2" class="jy jz iq nc b gy ng nh l ni nj">sudo apt-get install webhook</span></pre><p id="4fab" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">您可以查看文档，了解如何进一步定制您的端点。对于本教程，我们将有一个名为“redeploy”的简单端点，每当有消息发送给它时，它都会运行一个bash脚本。在您选择的目录中创建一个名为<em class="na"> hooks.json </em>的文件。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="7efd" class="jy jz iq nc b gy ng nh l ni nj">[<br/>  {<br/>    "id": "redeploy",<br/>    "execute-command": "/my/scrips/path/redeploy.sh",<br/>    "command-working-directory": "/my/path/to/hooks",<br/>    "response-message": "Redeploying API server."<br/>  }<br/>]</span></pre><p id="aa7d" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">端点的“<em class="na">execute-command”</em>字段应该指向每次端点收到消息时您希望运行的脚本。因此，请确保该脚本确实存在:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="18c5" class="jy jz iq nc b gy ng nh l ni nj">#!bin/bash</span><span id="f248" class="jy jz iq nc b gy nq nh l ni nj">docker pull example/repository:latest<br/>docker stop SAMPLE_APP<br/>docker system prune -f<br/>docker run -d --name=SAMPLE_APP example/repository:latest</span></pre><p id="412d" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">这个小脚本将停止您的应用程序，删除它，然后使用我们之前看到的命令从您的docker hub存储库中获取并运行最新版本。</p><p id="6e02" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">一旦配置文件和脚本都准备好了，就可以通过运行webhook应用程序来激活端点:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="39b5" class="jy jz iq nc b gy ng nh l ni nj">webhook -hooks /my/path/to/hooks/hooks.json -verbose</span></pre><p id="3565" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">一旦运行，端点将在<a class="ae lj" href="http://your-ip-address:9000/hooks/redeploy." rel="noopener ugc nofollow" target="_blank">http://your-IP-address:9000/hooks/redeploy上可用。</a>通过<a class="ae lj" href="https://medium.com/aubergine-solutions/api-testing-using-postman-323670c89f6d" rel="noopener">使用邮递员</a>或您选择的任何其他工具发送请求来测试它。然后，您可以通过列出当前容器来检查您的应用程序是否成功重启:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="2f63" class="jy jz iq nc b gy ng nh l ni nj">sudo docker container ls -a</span></pre><p id="6617" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">端点可以被进一步配置来做一些事情，比如使用另一个端口、验证报头和有效负载，以及向您希望使用的脚本传递参数。我强烈建议您深入了解它的所有功能。</p><h2 id="94bf" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">…然后回到工作流程</h2><p id="3e04" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">让我们回到正题。我们的发布工作流需要自动完成我们刚刚做的那些事情，下面是如何完成的。</p><h2 id="572c" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">创造你的秘密</h2><p id="ab67" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">将以下变量作为秘密存储在GitHub中，以便工作流能够访问您的docker帐户。</p><ul class=""><li id="3943" class="ku kv iq kw b kx nk kz nl kh nr kl ns kp nt le lf lg lh li bi translated"><strong class="kw ir"> DOCKER_REPO - </strong>您在Docker Hub的存储库地址</li><li id="b533" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><strong class="kw ir"> DOCKER_USER - </strong>您的用户名</li><li id="0e7f" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><strong class="kw ir"> DOCKER_PASS - </strong>您的密码</li><li id="466f" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><strong class="kw ir"> DEPLOY_WEBHOOK_URL - </strong>将用于触发应用程序重新部署的端点地址</li></ul><h2 id="f397" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">创建您的工作流文件</h2><p id="db77" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">就像我们对主分支所做的那样，在“<em class="na"> /”处创建另一个<em class="na"> YAML </em>文件。发布分支的github/workflows " </em>。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="dedb" class="jy jz iq nc b gy ng nh l ni nj">name: Release - Test, Build &amp; Redeploy<br/><br/>on:<br/>  push:<br/>    branches:<br/>      - 'release-*'<br/><br/>jobs:<br/>  test:<br/>    name: Test - Unit &amp; Integration<br/>    runs-on: ubuntu-18.04<br/><br/>    steps:<br/>      - uses: actions/checkout@v1<br/>      - name: Set up JDK 11<br/>        uses: actions/setup-java@v1<br/>        with:<br/>          java-version: 11.0.4<br/>      - name: Maven Package<br/>        run: mvn -B clean package -DskipTests<br/>      - name: Maven Verify<br/>        run: mvn -B clean verify<br/><br/>  docker:<br/>    name: Publish - Docker Hub<br/>    runs-on: ubuntu-18.04<br/>    needs: [test]<br/>    env:<br/>      REPO: ${{ secrets.DOCKER_REPO }}<br/>    steps:<br/>      - uses: actions/checkout@v1<br/>      - name: Set up JDK 11<br/>        uses: actions/setup-java@v1<br/>        with:<br/>          java-version: 11.0.4<br/>      - name: Login to Docker Hub<br/>        run: docker login -u ${{ secrets.DOCKER_USER }} <br/>             -p ${{ secrets.DOCKER_PASS }}<br/>      - name: Build Docker image<br/>        run:docker build -t $REPO:latest -t $REPO:${GITHUB_SHA::8} .<br/>      - name: Publish Docker image<br/>        run: docker push $REPO<br/><br/>  redeploy:<br/>    name: Redeploy webhook call<br/>    runs-on: ubuntu-18.04<br/>    needs: [docker]<br/>    steps:<br/>      - name: Deploy docker container webhook<br/>        uses: joelwmale/webhook-action@master<br/>        env:<br/>          WEBHOOK_URL: ${{ secrets.DEPLOY_WEBHOOK_URL  }}<br/>          data: "{ 'myField': 'myFieldValue'}"</span></pre><p id="b0e0" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">让我们在这里分解一下最相关的部分。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="66ff" class="jy jz iq nc b gy ng nh l ni nj">on:<br/>  push:<br/>    branches:<br/>      - 'release-*'</span></pre><p id="07db" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">这一次，我们希望我们的工作流只在以“<em class="na"> release- </em>”开始的分支被推送时才被执行。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="56af" class="jy jz iq nc b gy ng nh l ni nj">docker:<br/>    name: Publish - Docker Hub<br/>    runs-on: ubuntu-18.04<br/>    needs: [test]<br/>    env:<br/>      REPO: ${{ secrets.DOCKER_REPO }}<br/>    steps:<br/>      - uses: actions/checkout@v1<br/>      - name: Set up JDK 11<br/>        uses: actions/setup-java@v1<br/>        with:<br/>          java-version: 11.0.4<br/>      - name: Login to Docker Hub<br/>        run: docker login -u ${{ secrets.DOCKER_USER }} <br/>             -p ${{ secrets.DOCKER_PASS }}<br/>      - name: Build Docker image<br/>        run:docker build -t $REPO:latest -t $REPO:${GITHUB_SHA::8} .<br/>      - name: Publish Docker image<br/>        run: docker push $REPO</span></pre><p id="906d" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">我们的应用程序使用我们作为机密存储的信息构建并推送到我们的docker存储库。build命令使用根目录中的docker文件。请注意,“需求”配置确保只有在测试成功执行之后，这个作业才会运行。</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="4cab" class="jy jz iq nc b gy ng nh l ni nj">redeploy:<br/>    name: Redeploy - Webhook call<br/>    runs-on: ubuntu-18.04<br/>    needs: [docker]<br/>    steps:<br/>      - name: Deploy docker container webhook<br/>        uses: joelwmale/webhook-action@master<br/>        env:<br/>          WEBHOOK_URL: ${{ secrets.DEPLOY_WEBHOOK_URL  }}<br/>          data: "{ 'myField': 'myFieldValue'}"</span></pre><p id="617e" class="pw-post-body-paragraph lp lq iq kw b kx nk lr ls kz nl lt lu kh nm lw lx kl nn lz ma kp no mc md le ij bi translated">最后，我们使用一个<a class="ae lj" href="https://github.com/marketplace/actions/webhook-action" rel="noopener ugc nofollow" target="_blank"> Webhook动作</a>向我们的端点URL发送一个请求。现在，我们只是发送一个没有任何有意义的数据的一般请求，但你可以检查文档，并考虑扩展它，以包括一个验证你的调用的聪明方法。</p><h1 id="076e" class="me jz iq bd ka mf mg mh kd mi mj mk kg ml mm mn kk mo mp mq ko mr ms mt ks mu bi translated">就是这样！</h1><p id="fb95" class="pw-post-body-paragraph lp lq iq kw b kx ky lr ls kz la lt lu kh lv lw lx kl ly lz ma kp mb mc md le ij bi translated">您现在可以创建一个发布分支并推动它。转到GitHub存储库的Actions部分，观察应用程序自动重新部署的过程。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/49b222217d8e9c5f06e5255dc573fd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pf4aMtU9UNb8A_hnh1fzFg.png"/></div></div></figure></div></div>    
</body>
</html>