<html>
<head>
<title>DNS requests in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的DNS请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dns-request-and-response-in-java-acbd51ad3467?source=collection_archive---------0-----------------------#2022-04-13">https://levelup.gitconnected.com/dns-request-and-response-in-java-acbd51ad3467?source=collection_archive---------0-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4d0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是集中讨论UDP上的DNS协议及其java实现的系列文章的第一篇。</p><p id="b9de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://medium.com/@junkypic/dns-response-in-java-a6298e3cc7d9" rel="noopener">下一篇文章关注DNS服务器的响应以及如何解析它。</a></p><p id="2420" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对没有全部解释的代码更感兴趣，请跳到文章末尾。</p><p id="e3de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近我想用Java写一个DNS解析器。很快我就知道这并不像你想象的那么容易(我想除了我自己没人会感到惊讶)。</p><p id="65b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，最让我困惑的是，没有任何好文章(我能找到的)是关于如何让你的脚趾弄湿的。我能找到的唯一一个最新的Java DNS服务器实现是<a class="ae km" href="https://github.com/dnsjava/dnsjava" rel="noopener ugc nofollow" target="_blank"> dnsjava </a>，它虽然非常好，但是功能非常丰富，很难理解。我只是想找点又快又脏的东西让我继续下去。</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="134f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将使用哪些工具:</p><ul class=""><li id="9ad1" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">IntelliJ IDEA Community Edition然而，任何可以编写代码的媒介都可以很好地工作。Eclipse，Notepad++，Vim等。</li><li id="d67a" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">Wireshark 这样我就可以拦截我将要发送的请求(以及相应的响应)。这并不是强制性的，但是我觉得我对发生的事情有了更好的理解。</li><li id="c298" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">Java 17。当然，其他版本的java也可以。</li></ul><p id="0456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个系列的最终目标是能够发送一个请求并接收一个对<a class="ae km" href="https://en.wikipedia.org/wiki/List_of_DNS_record_types" rel="noopener ugc nofollow" target="_blank"/>记录类型甚至是<a class="ae km" href="https://en.wikipedia.org/wiki/List_of_DNS_record_types" rel="noopener ugc nofollow" target="_blank"> AAAA </a>记录的响应。</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="87ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别东拉西扯了，让我们看看到底是怎么回事。</p><p id="7d52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们应该理解DNS请求/响应的结构。</p><p id="80a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有什么比阅读<a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc1035" rel="noopener ugc nofollow" target="_blank"> RFC1035 </a>更好的方法呢？不想读完整本吗？我给你简单介绍一下。</p><p id="a885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">免责声明时间:</strong> RFC1035，我认为是同类型中与DNS协议相关的最老的RFC。还有其他更新的RFC建立在这个RFC之上。虽然大部分内容仍然准确，但有些内容已经过时了。在我看来，将所有与DNS协议相关的RFC作为一个人来考虑是徒劳的，因为有很多方法。相反，我将只关注这个特定的RFC，因为它非常容易理解。</p><p id="c98e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将重点介绍UPD的DNS。有许多<a class="ae km" href="https://en.wikipedia.org/wiki/Domain_Name_System#DNS_transport_protocols" rel="noopener ugc nofollow" target="_blank"> DNS协议</a>，但是绝大多数呼叫都是通过UPD的。</p><p id="8921" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解析DNS请求</strong></p><p id="3576" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1" rel="noopener ugc nofollow" target="_blank">摘自RFC1035 <em class="kl"> : </em> </a> <em class="kl">域协议内部的所有通信都以一种称为消息的格式进行。</em></p><p id="1509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一条消息看起来像这样</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="ce18" class="lr ls iq ln b gy lt lu l lv lw">    +---------------------+<br/>    |        Header       |<br/>    +---------------------+<br/>    |       Question      | the question for the name server<br/>    +---------------------+<br/>    |        Answer       | RRs answering the question<br/>    +---------------------+<br/>    |      Authority      | RRs pointing toward an authority<br/>    +---------------------+<br/>    |      Additional     | RRs holding additional information<br/>    +---------------------+</span></pre><p id="4fed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从标题部分开始。</p><p id="7bd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.1" rel="noopener ugc nofollow" target="_blank">RFC 1035的第4.1.1节</a>详细说明了标题部分的外观。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="5b8f" class="lr ls iq ln b gy lt lu l lv lw">     0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                      ID                       |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    QDCOUNT                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    ANCOUNT                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    NSCOUNT                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    ARCOUNT                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span></pre><p id="0b8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们能够正确地阅读本节(或任何其他后续章节)之前，我们必须了解数据是如何传输的。</p><p id="f46d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc1035#section-2.3.2" rel="noopener ugc nofollow" target="_blank">第2.3.2节</a>告诉我们:<em class="kl">本文档中描述的报头和数据的传输顺序被解析为八位字节级别。每当图表显示一组二进制八位数时，这些二进制八位数的传输顺序就是它们在英语中的正常读取顺序。</em></p><p id="0772" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来分解一下:</p><ul class=""><li id="46ed" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">一个八位字节等于8位。特别是在Java中，这将是一个<em class="kl">字节。</em>这里有一些东西可以刷新你对java 中<a class="ae km" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="noopener ugc nofollow" target="_blank">基本类型的记忆。</a></li><li id="dc6a" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">位的顺序总是<a class="ae km" href="https://chortle.ccsu.edu/assemblytutorial/Chapter-15/ass15_3.html" rel="noopener ugc nofollow" target="_blank">大端</a>。这意味着请求和响应总是遵循这个约定。换句话说，正如上面的部分告诉我们的那样，我们像阅读普通英语一样阅读它。</li></ul><p id="db27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Java使用大端位顺序存储数据。</p><p id="08f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在回到标题部分。让我们选择第一个条目，特别是ID 。如果我们阅读上面的图表，我们可以知道ID有16位或2字节的数据。简单来说，它相当于Java中的一个short。所以是-32，768到32，767之间(含)的任何数字。</p><p id="2682" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ID的RFC定义是:<em class="kl">一个由程序分配的16位标识符，<br/>生成任何类型的查询。这个标识符被复制到相应的回复中，并且可以被请求者用来匹配对未完成查询的回复。</em></p><p id="00f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用更具体的Java术语来描述这一点</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="12b0" class="lr ls iq ln b gy lt lu l lv lw">Random random = new Random();<br/>short ID = (short)random.nextInt(32767);</span></pre><p id="4bec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ID也可以签名，所以不用担心负数。</p><p id="55d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，我们找到了一个简称。让我们进入下一部分。</p><p id="aa40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一部分有点棘手。事实上，它有一个特殊的名字，<a class="ae km" href="https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-12" rel="noopener ugc nofollow" target="_blank">标志</a>部分。</p><p id="f677" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经注意到它不是一个单一的字节(在java中我们可以很容易地用T2表示的最小单位)。事实上，第一个字节包括5个不同的标志(QR、OpCode、AA、TC和RD)。</p><p id="b6ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在测试了一些东西之后，我得出结论，在java中表示flags部分的最简单的方法是使用一个字符串。对，没错，一串。我本来可以使用一个<a class="ae km" href="https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html" rel="noopener ugc nofollow" target="_blank">位集</a>，但它不是立即明显是什么标志，所以我很快放弃了这个想法。</p><p id="9d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们代表标志部分。总的来说，标志的长度等于16位或短1位。</p><p id="d34b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">QR — <em class="kl">一个一位字段，指定该消息是一个<br/>查询(0)，还是一个响应(1)。</em></p><p id="a59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，因为我们正在做一个请求，QR是0。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="a806" class="lr ls iq ln b gy lt lu l lv lw">String flags = "0"; // QR</span></pre><p id="882e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OpCode — <em class="kl">四位字段，指定此<br/>消息中的查询类型。该值由查询<br/>的发起者设置，并复制到响应中。这些值是:</em></p><p id="ad86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> 0个标准查询(查询)</em></p><p id="5c4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> 1一个逆向查询(IQUERY) </em></p><p id="ed5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> 2 a服务器状态请求(STATUS) </em></p><p id="2b4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">3–15保留供将来使用</em></p><p id="3200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们做一个标准的查询，所以操作码是0。然而，我们需要将它表示为一个4位长的比特序列。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="e8ef" class="lr ls iq ln b gy lt lu l lv lw">flags += "0000"; // OpCode</span></pre><p id="3588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AA — <em class="kl">权威回答—该位在响应中有效，<br/>并指定响应的名称服务器是问题部分中域名的<br/>权威机构。</em></p><p id="4170" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AA应该是0，因为当我们发送请求时，我们需要一些东西。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="dae0" class="lr ls iq ln b gy lt lu l lv lw">flags += "0"; // AA</span></pre><p id="a9c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TC — <em class="kl">截断—指定该消息由于长度超过了<br/>传输通道允许的长度而被截断<br/>。</em></p><p id="5df2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这面旗帜的一个旁注。<a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc1035#section-2.3.4" rel="noopener ugc nofollow" target="_blank">第2.3.4节</a>说明UDP消息被限制为512字节或更少。<em class="kl">在大多数情况下</em>这不再适用，但是这个标志并不是完全多余的，因为一些服务器可能仍然受到UDP包大小的限制。</p><p id="7698" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，消息不会被截断。注意截断指定消息是否被截断(也称为布尔值),而不是消息被截断的绝对值。所以截断不是真就是假。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="8a2c" class="lr ls iq ln b gy lt lu l lv lw">flags += "0"; // TC</span></pre><p id="309a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RD — <em class="kl">期望递归—该位可以在查询中设置，并且<br/>被复制到响应中。如果RD被设置，它指示<br/>名称服务器递归地进行查询。<br/>递归查询支持是可选的。</em></p><p id="e9a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，这是该请求的整个标志部分中唯一设置为真的位。我还没有发现不需要递归的情况。关于DNS中递归的更多信息。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="6e62" class="lr ls iq ln b gy lt lu l lv lw">flags += "1"; // RD</span></pre><p id="5fdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RA — <em class="kl">递归可用—这是在<br/>响应中设置或清除的，表示递归查询支持在名称服务器中是否<br/>可用。</em></p><p id="4b20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将由响应服务器设置。在请求中将其设置为false。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="aea6" class="lr ls iq ln b gy lt lu l lv lw">flags += "0"; // RA</span></pre><p id="aae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Z- <em class="kl">保留供将来使用。在所有查询<br/>和响应中必须为零。</em></p><p id="3634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不言自明。</p><p id="e063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">flags+= " 000 "；// Z </strong></p><p id="5668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RDCODE — <em class="kl">响应代码—该4位字段设置为<br/>响应的一部分。</em></p><p id="8da2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的RDCODEs列表可以在找到。出于请求的目的，RDCODE是0。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="2934" class="lr ls iq ln b gy lt lu l lv lw">flags += "0000"; // RDCODE</span></pre><p id="a5bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在它的结尾，所有的Flags部分看起来都像这样</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="a4ae" class="lr ls iq ln b gy lt lu l lv lw">"0000000100000000"</span></pre><p id="feb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于快速直观地检查标志来说很好，但是在实际发送标志头时完全没有用。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="742f" class="lr ls iq ln b gy lt lu l lv lw">short requestFlags = Short.<em class="kl">parseShort</em>("0000000100000000", 2);<br/>ByteBuffer flagsByteBuffer = ByteBuffer.<em class="kl">allocate</em>(2).putShort(requestFlags);<br/>byte[] flagsByteArray= flagsByteBuffer.array();</span></pre><p id="aa5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将字符串表示解析为base 2中的short，并创建所述short的总长度为2(2字节= 1 short)的bytebuffer，最后将bytebuffer转换为字节数组。</p><p id="5f74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的部分由1个短节表示。总共有4个部分:</p><ul class=""><li id="b81c" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">QDCOUNT — <em class="kl">一个无符号的16位整数，指定问题部分中<br/>条目的数量。</em></li><li id="deab" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">ANCOUNT — <em class="kl">一个无符号的16位整数，指定答案部分中<br/>资源记录的数量。</em></li><li id="2f9d" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">NSCOUNT — <em class="kl">一个无符号的16位整数，指定授权记录<br/>部分中名称<br/>服务器资源记录的数量。</em></li><li id="afd5" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">ARCOUNT — <em class="kl">一个无符号的16位整数，指定附加记录部分中<br/>资源记录的数量。</em></li></ul><p id="da9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一感兴趣的是QDCOUNT部分，因为其他部分将由响应服务器设置。请注意，我们仍然需要在请求中将它们表示为0。</p><p id="bc45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种特殊情况下，我们只有一个问题。</p><p id="9eb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这里有一个很小但非常重要的旁注</strong>。从技术上来说，没有人会阻止任何人在每个查询中提出一个以上的问题，但是，我还没有看到这种情况发生。坦白地说，我甚至不知道如果每个查询有一个以上的问题会发生什么。我怀疑一个服务器能够回答每个查询1个以上的问题。<a class="ae km" href="https://stackoverflow.com/questions/55092830/how-to-perform-dns-lookup-with-multiple-questions" rel="noopener ugc nofollow" target="_blank">请看这个stackoverflow问题，获取更详细的答案</a>。</p><p id="3868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说…</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="75bd" class="lr ls iq ln b gy lt lu l lv lw">short QDCOUNT = 1;<br/>short ANCOUNT = 0;<br/>short NSCOUNT = 0;<br/>short ARCOUNT = 0;</span></pre><p id="91b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将所有这些放在一起:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="04fc" class="lr ls iq ln b gy lt lu l lv lw">Random random = new Random();<br/>short ID = (short)random.nextInt(32767);<br/>ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();<br/>DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);<br/><br/>short requestFlags = Short.<em class="kl">parseShort</em>("0000000100000000", 2);<br/>ByteBuffer flagsByteBuffer = ByteBuffer.<em class="kl">allocate</em>(2).putShort(requestFlags);<br/>byte[] flagsByteArray = flagsByteBuffer.array();<br/><br/>short QDCOUNT = 1;<br/>short ANCOUNT = 0;<br/>short NSCOUNT = 0;<br/>short ARCOUNT = 0;<br/><br/>dataOutputStream.writeShort(ID);<br/>dataOutputStream.write(flagsByteArray);<br/>dataOutputStream.writeShort(QDCOUNT);<br/>dataOutputStream.writeShort(ANCOUNT);<br/>dataOutputStream.writeShort(NSCOUNT);<br/>dataOutputStream.writeShort(ARCOUNT);</span></pre><p id="db97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们有了请求的完整报头部分。</p><p id="2944" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们进入问题部分。</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="7853" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题部分实际上是最直接的部分之一。</p><p id="d294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.2" rel="noopener ugc nofollow" target="_blank">第4.1.2节。</a>状态:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="36de" class="lr ls iq ln b gy lt lu l lv lw">The question section is used to carry the "question" in most queries,<br/>i.e., the parameters that define what is being asked.  The section<br/>contains QDCOUNT (usually 1) entries, each of the following format:<br/><br/>                                    1  1  1  1  1  1<br/>      0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                                               |<br/>    /                     QNAME                     /<br/>    /                                               /<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                     QTYPE                     |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                     QCLASS                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span></pre><p id="9cfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">QNAME — <em class="kl">用一系列标签表示的域名，其中<br/>每个标签由一个长度八位字节和其后的<br/>个八位字节组成。域名以根的空标签的零长度八位字节<br/>结束。注意<br/>该字段可以是奇数个八位字节；不使用<br/>填充。</em></p><p id="76f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个小注释。通常我们可以(并且应该)对这个部分使用<a class="ae km" href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.4" rel="noopener ugc nofollow" target="_blank">消息压缩</a>，但是，因为它不是对请求的强制<strong class="jp ir">，所以我不会这样做。当服务器响应时，域将被压缩。所以很快它将不得不被处理。</strong></p><p id="e576" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一部分非常简单。取一个域名(不带scheme(http或https)或www之类的前缀)，把它分成几部分，放入一个字节数组中。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="5d80" class="lr ls iq ln b gy lt lu l lv lw">String domain = "medium.com";<br/>String[] domainParts = domain.split("\\.");<br/><br/>for (int i = 0; i &lt; domainParts.length; i++) {<br/>    byte[] domainBytes = domainParts[i].getBytes(StandardCharsets.<em class="kl">UTF_8</em>);<br/>    dataOutputStream.writeByte(domainBytes.length);<br/>    dataOutputStream.write(domainBytes);<br/>}</span><span id="da17" class="lr ls iq ln b gy lx lu l lv lw">dataOutputStream.writeByte(0);// no more parts</span></pre><p id="1329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">QTYPE — <em class="kl">两个八位字节的代码，指定查询的类型。<br/>该字段的值包括对<br/>类型字段有效的所有代码，以及一些更通用的代码，这些代码<br/>可以匹配多种类型的RR。</em></p><p id="51d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如AAAA就是一种记录。每个查询可以请求多条记录，但是，在这个例子中，我将只请求一条记录。特别是一项记录。</p><p id="a091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是所有可用记录的列表。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="8096" class="lr ls iq ln b gy lt lu l lv lw">// Type 1 = A (Host Request)<br/>dataOutputStream.writeShort(1);</span></pre><p id="f2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">QCLASS — <em class="kl">两个八位字节的代码，指定查询的类别。<br/>例如，QCLASS字段在互联网中。</em></p><p id="4f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里可以找到完整的课程列表。</p><p id="d578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，我将在课堂上使用。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="45cf" class="lr ls iq ln b gy lt lu l lv lw">// Class 1 = IN<br/>dataOutputStream.writeShort(1);</span></pre><p id="d788" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题部分到此为止。简单。</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="00ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的3个部分(答案、权限和附加)将不会在请求中设置。响应服务器将设置它们，因此在本例中我们可以忽略它们。</p><p id="0367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Java使用<a class="ae km" href="https://docs.oracle.com/javase/7/docs/api/java/net/DatagramSocket.html" rel="noopener ugc nofollow" target="_blank"> DatagramSockets和DatagramPackets </a>通过UDP发送/接收数据。</p><p id="e76f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是发送这样一个请求的完整代码(包括上面的所有代码)。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="b253" class="lr ls iq ln b gy lt lu l lv lw">InetAddress ipAddress = InetAddress.<em class="kl">getByName</em>("1.1.1.1");// cloudflare<br/><br/>Random random = new Random();<br/>short ID = (short)random.nextInt(32767);<br/>ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();<br/>DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);<br/><br/>short requestFlags = Short.<em class="kl">parseShort</em>("0000000100000000", 2);<br/>ByteBuffer flagsByteBuffer = ByteBuffer.<em class="kl">allocate</em>(2).putShort(requestFlags);<br/>byte[] flagsByteArray = flagsByteBuffer.array();<br/><br/>short QDCOUNT = 1;<br/>short ANCOUNT = 0;<br/>short NSCOUNT = 0;<br/>short ARCOUNT = 0;<br/><br/>dataOutputStream.writeShort(ID);<br/>dataOutputStream.write(flagsByteArray);<br/>dataOutputStream.writeShort(QDCOUNT);<br/>dataOutputStream.writeShort(ANCOUNT);<br/>dataOutputStream.writeShort(NSCOUNT);<br/>dataOutputStream.writeShort(ARCOUNT);<br/>String domain = "medium.com";<br/>String[] domainParts = domain.split("\\.");<br/><br/>for (int i = 0; i &lt; domainParts.length; i++) {<br/>    byte[] domainBytes = domainParts[i].getBytes(StandardCharsets.<em class="kl">UTF_8</em>);<br/>    dataOutputStream.writeByte(domainBytes.length);<br/>    dataOutputStream.write(domainBytes);<br/>}<br/>// No more parts<br/>dataOutputStream.writeByte(0);<br/>// Type 1 = A (Host Request)<br/>dataOutputStream.writeShort(1);<br/>// Class 1 = IN<br/>dataOutputStream.writeShort(1);<br/><br/>byte[] dnsFrame = byteArrayOutputStream.toByteArray();<br/><br/>System.<em class="kl">out</em>.println("Sending: " + dnsFrame.length + " bytes");<br/>for (int i = 0; i &lt; dnsFrame.length; i++) {<br/>    System.<em class="kl">out</em>.print(String.<em class="kl">format</em>("%s", dnsFrame[i]) + " ");<br/>}<br/><br/>DatagramSocket socket = new DatagramSocket();<br/>DatagramPacket dnsReqPacket = new DatagramPacket(dnsFrame, dnsFrame.length, ipAddress, <em class="kl">DNS_SERVER_PORT</em>);<br/>socket.send(dnsReqPacket);</span></pre><p id="f6a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们实际发送一个请求，看看会发生什么。</p><p id="76c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要捕获请求，请在端口53(默认UDP端口)上使用Wireshark。</p><figure class="li lj lk ll gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi ly"><img src="../Images/64635b29f79062c158757917d11d025c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeTOLGUw2NwbLM2T4Lx7ew.jpeg"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">wireshark端口53</figcaption></figure><p id="189d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始监听所述端口，然后使用您喜欢的方式发送请求。</p><p id="ee56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用默认的IntelliJ编译器来发送请求。</p><p id="aa2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发送请求后，Wireshark中应该会出现响应</p><figure class="li lj lk ll gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mk"><img src="../Images/d5028205a028749e27656feba4760090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFhMaaRCQ6KLPQZ60DChxw.jpeg"/></div></div></figure><p id="ee4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们可以看到上面设置的标志(RD —需要递归)。以及包括所选域的2 A记录的响应。</p><p id="2167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一篇文章将重点讨论如何回应。</p></div></div>    
</body>
</html>