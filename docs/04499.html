<html>
<head>
<title>Too many parameters in Java might indicate subtle duplication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中太多的参数可能意味着细微的重复</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/too-many-parameters-in-java-might-indicate-subtle-duplication-ac1ab5af78ca?source=collection_archive---------25-----------------------#2020-06-29">https://levelup.gitconnected.com/too-many-parameters-in-java-might-indicate-subtle-duplication-ac1ab5af78ca?source=collection_archive---------25-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c0804183ba22a0b2594bfcf347d43b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pjc5IxRO9y_M48nK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">斯科特·布雷克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c8db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java以冗长著称，程序员不用编写带有九个或十个参数的构造函数。从技术上讲，构造函数或其他单元可以接受超过200个参数，但是对于日常使用来说，这显然太多了。</p><p id="20c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拥有这么多参数显然是不好的，尤其是如果它们中的大多数都是同一类型，因为很容易混淆参数的顺序。当然，如果它们都是同一类型的<em class="le"/>，你可能应该使用一个数组或集合来传递它们。</p><p id="d6b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，比严格必要的多一个参数也可能是不好的，并且可能表明您无意中不必要地重复了项目中的一些重要行。</p><p id="e0f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在NetBeans这样的集成开发环境(IDE)中，您可以进行检查，用八个或更多参数标记项目中的单元。这可能应该重新配置为更低的数字，比如5。</p><p id="99d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Java版的<em class="le">构建可维护软件</em>中，Joost Visser建议将参数数量保持在不超过四个。</p><p id="3c5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样的指导方针可能适用于几乎所有其他编程语言，比如C#、Scala甚至FORTRAN和COBOL。在Malbolge这样的语言中，这个问题可能没有实际意义。</p><p id="2216" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我读完Visser书中的那一章后不久，我查看了我的一个项目，并做了一些重构来遵守这个指导方针。</p><p id="d731" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我有一个带五个参数的异常构造函数，我想了一些方法把它减少到四个。我还提出了一个辅助构造函数，它只接受三个参数，并填充第四个参数。</p><p id="a42e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于本文来说，这将是一个很好的例子，只不过该项目的领域是一个简单但不熟悉的主题。问题域需要是简单的<em class="le">和</em>熟悉的东西。</p><p id="6ef8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上周，在进行另一个简单但更熟悉的主题的编程练习时，我发现了一个不太引人注目的例子，在这个例子中，我将一个3参数构造函数减少到只有两个参数。</p><p id="2207" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个练习是一个简单的工资处理程序。即使你从未有过需要“打卡”的工作，你理解这个练习应该没有问题。</p><p id="e295" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个员工都有一个“时间卡”，他们把它放在一个特殊的钟里，笨拙地称为“时间钟”，以标记他们上班和下班的时间，从而描绘出他们期望获得报酬的时间段。</p><p id="948a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，在星期一，一名员工在早上7:59打卡开始一天的工作，在下午12:01打卡去吃午饭。员工吃完午饭回来晚了一点，下午1:04打卡，等等。</p><p id="a99f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">典型的时间卡是为每个持续一周的支付期准备的。一周结束后，已填写的考勤卡将被收集并发送至工资单处理部门，新的考勤卡将在新的一周发放。</p><p id="c3f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在软件中实现这一点，我们可能需要一个<code class="fe lf lg lh li b">Employee</code>类。当然还有一个<code class="fe lf lg lh li b">TimeCard</code>类。可能还需要一个类来表示时间段，例如星期一上午7:59到下午12:01的时间间隔。</p><p id="f9af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的第一份<code class="fe lf lg lh li b">TimeCard</code>构造函数草案看起来像这样:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="39df" class="lr ls it li b gy lt lu l lv lw">    public TimeCard(Employee employee, LocalDateTime start,<br/>                    LocalDateTime end) {<br/>        this.cardOwner = employee;<br/>        this.startDateTime = start;<br/>        this.endDateTime = end;<br/>    }</span></pre><p id="ff6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">start</code>参数可能是周一上午12:00，<code class="fe lf lg lh li b">end</code>参数可能是周日晚上11:59</p><p id="3bd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">TimeCard</code>的一个实例将保存一个时间块列表，这些时间块落在卡片的开始和结束位置。如果员工忘记在工资期结束时最后一次打卡，如果他们不打电话询问，工资部门可能会推断出打卡时间。</p><p id="b214" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，是的，我正在使用<code class="fe lf lg lh li b">java.time</code>包中的<code class="fe lf lg lh li b">LocalDateTime</code>类。我可能会收到评论说Java time API很糟糕，不应该使用它。一个更有成效的评论会解释为什么某些特定的第三方库要好得多。</p><p id="45d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管<code class="fe lf lg lh li b">java.time</code>有一个明显的缺陷:我找不到任何东西来表示一段时间，比如前面例子中的上午7:59到下午12:01。当然，第三方时间图书馆对此有所帮助。</p><p id="62ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过我准备为此做一个自己的时间段类，也许我会叫它<code class="fe lf lg lh li b">TimeBlock</code>。我提醒你，我这么做是在练习。如果我是为一个付费客户做这件事，我会认为客户不是付钱让我重新发明免费的现有第三方库。</p><p id="0820" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个工资处理的例子也符合Joost Visser的另一个准则:“编写一次代码”他给出了一个指导原则，即在一个程序中重复的连续行不能超过六行。</p><p id="70e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我觉得门槛可以降到三四线。一两行太低了，因为像IntelliJ IDEA这样的IDE会捕捉很多花括号。那将是一件无益的麻烦事。</p><p id="8550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我相信你已经明白为什么“代码复制”是不好的。但是对于程序员和我们用来编辑程序的ide来说，重复有时是微妙而难以识别的。</p><p id="6c6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我从这个工资处理例子中得到的。我的第一份<code class="fe lf lg lh li b">TimeBlock</code>构造函数草案看起来像这样:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="1383" class="lr ls it li b gy lt lu l lv lw">    public TimeBlock(LocalDateTime start, LocalDateTime end) {<br/>        this.startTime = start;<br/>        this.finishTime = end;<br/>    }</span></pre><p id="11ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单，对吧？它只需要两个参数，从技术上来说，我们只是复制了右花括号。技术上来说。</p><p id="3ff6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果<code class="fe lf lg lh li b">end</code>在<code class="fe lf lg lh li b">start</code>之前呢？你典型的物理时间卡时钟就是为了避免这种问题而建立的。员工不可能在打卡上班前打卡下班。目前的<code class="fe lf lg lh li b">TimeBlock</code>构造者没有办法阻止这种事情的发生。</p><p id="5dd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe lf lg lh li b">end</code>在<code class="fe lf lg lh li b">start</code>之前，构造函数应该抛出某种异常，比如可能是<code class="fe lf lg lh li b">InvalidTimeSpanException</code>，或者最好是一个带有适当错误消息的老式<code class="fe lf lg lh li b">IllegalArgumentException</code>。</p><p id="6387" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我喜欢做测试驱动的开发，即使是像这样的练习，我在改变构造函数之前写一个测试。测试第一次就失败了，这是应该的。然后我改变构造函数，让它通过测试。</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="a385" class="lr ls it li b gy lt lu l lv lw">    public TimeBlock(LocalDateTime start, LocalDateTime end) {<br/>        <strong class="li iu">if (end.isBefore(start)) {<br/>            String excMsg = "Block can't start (" + start.toString() <br/>                    + ") before it ends (" + end.toString() + ")";<br/>            throw new IllegalArgumentException(excMsg);<br/>        }</strong><br/>        this.startTime = start;<br/>        this.finishTime = end;<br/>    }</span></pre><p id="6e77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我继续为我认为<code class="fe lf lg lh li b">TimeBlock</code>需要具备的其他特性编写测试，比如布尔函数<code class="fe lf lg lh li b">contains()</code>和<code class="fe lf lg lh li b">overlaps()</code>。另外，<code class="fe lf lg lh li b">TimeBlock</code>可能应该实现<code class="fe lf lg lh li b">Comparable</code>接口。</p><p id="78c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要<code class="fe lf lg lh li b">contains()</code>来确保某人不能在卡的范围之外的一段时间内打卡上下班，例如上一个支付期的周日下午6:00到晚上10:00。</p><p id="7aa4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至于<code class="fe lf lg lh li b">overlaps()</code>，我认为它将有助于提供一种使用图形用户界面编辑时间段的方法。我还没有充实项目的这一部分，现在都在命令行上。</p><p id="6c27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我继续工作<code class="fe lf lg lh li b">TimeCard</code>，最终整个项目通过了所有的测试，看起来一切正常。但是第二天，我注意到<code class="fe lf lg lh li b">TimeCardTest</code>和<code class="fe lf lg lh li b">TimeBlockTest</code>都包含了当<code class="fe lf lg lh li b">end</code>参数在<code class="fe lf lg lh li b">start</code>参数之前时的测试。</p><p id="16bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢使用Try-Catch-Fail测试异常，但是为了使本文简短，我将使用JUnit 4预期异常属性。因此，从<code class="fe lf lg lh li b">TimeCardTest</code>开始，我有:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="b98d" class="lr ls it li b gy lt lu l lv lw">    @Test(expected = IllegalArgumentException.class)<br/>    public void testBadConstructorParams() {<br/>        TimeCard <strong class="li iu">badCard</strong> = new TimeCard(TEST_PERIOD_END, <br/>                    TEST_PERIOD_START);<br/>    }</span></pre><p id="e0c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自<code class="fe lf lg lh li b">TimeBlockTest</code>:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="e859" class="lr ls it li b gy lt lu l lv lw">    @Test(expected = IllegalArgumentException.class)<br/>    public void testBadConstructorParams() {<br/>        TimeBlock <strong class="li iu">badBlock</strong> = new TimeBlock(TEST_PERIOD_END, <br/>                    TEST_PERIOD_START);<br/>    }</span></pre><p id="b632" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个测试都通过了，当然，我让它们在测试中以完全相同的方式通过了相应的类。</p><p id="1919" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很明显，这是重复，无论是在构造函数中还是在测试中，静态检查工具应该足够聪明来捕捉它…除了它低于六行的阈值。</p><p id="b695" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我终于意识到:如果<code class="fe lf lg lh li b">TimeCard</code>构造函数只接受一个<code class="fe lf lg lh li b">TimeBlock</code>类型的参数，而不是接受一个<code class="fe lf lg lh li b">start</code>参数和一个<code class="fe lf lg lh li b">end</code>类型的<code class="fe lf lg lh li b">LocalDateTime</code>参数，会怎么样？</p><p id="2d62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不再是三个参数，<code class="fe lf lg lh li b">TimeCard</code>构造函数现在只接受两个参数:类型为<code class="fe lf lg lh li b">Employee</code>的参数和时间段参数。</p><p id="99e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将需要一些重构，但是，感谢您的IDE，它应该只需要您几分钟的时间来更改需要更改的内容。</p><p id="171e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以现在<code class="fe lf lg lh li b">TimeCardTest</code>中的坏参数测试变得完全没有必要了。如果试图用无效的开始和结束时间构造一个<code class="fe lf lg lh li b">TimeBlock</code>实例导致异常，那么就不可能用无效的开始和结束时间构造一个<code class="fe lf lg lh li b">TimeCard</code>实例。</p><p id="184d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，注意到在构造函数和它们相应的测试中有一个微妙的重复情况，这使我们减少了一个构造函数参数列表，在这个微妙的情况下，有一个以上的参数是绝对必要的。</p><p id="c638" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我认为它显示了面向对象编程(OOP)范式的价值。有时感觉OOP范例迫使我们毫无意义地创建几十或几百个类。</p><p id="92d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">治疗这种感觉的方法是试着想象一个简单的练习，比如工资处理程序只使用原语。您可能实际上接近构造函数和其他单元的255个参数的技术限制。</p></div></div>    
</body>
</html>