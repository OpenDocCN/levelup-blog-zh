<html>
<head>
<title>Full-text search with Gatsby and Netlify CMS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gatsby和Netlify CMS进行全文搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/full-text-search-with-gatsby-and-netlify-cms-5a2a77d730de?source=collection_archive---------8-----------------------#2021-04-03">https://levelup.gitconnected.com/full-text-search-with-gatsby-and-netlify-cms-5a2a77d730de?source=collection_archive---------8-----------------------#2021-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/9f5d0970541967dd24a33d21d89520ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9aBA0WkjI0tFLFcSK_zDpQ.jpeg"/></div></div></figure><div class=""/><p id="88b8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">全文搜索是指在全文数据库中搜索单个文档或集合的技术。全文搜索不同于基于元数据或数据库中表示的部分原始文本(如标题、摘要、选定部分或参考书目)的搜索。</p><p id="7c2d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与使用其他方法相比，全文搜索允许用户检索更高质量的结果。在全文搜索过程中，搜索引擎在尝试匹配搜索条件时会检查每个存储文档中的所有单词。</p><p id="2036" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现对Gatsby的全文搜索很容易设置。我尝试过不同的插件，但决定使用Flexsearch(最容易实现和设置)。</p><h1 id="f79e" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">先决条件</h1><p id="d842" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这个例子中，我展示了一个Gatsby网站的实现，它使用Netlify CMS来管理内容。使用其他CMS时，实现可能会有所不同。</p><p id="f5f3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要安装<code class="fe lz ma mb mc b">gatsby-plugin-flexsearch</code></p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="a3c7" class="ml kx jb mc b gy mm mn l mo mp">$ yarn add gatsby-plugin-flexsearch</span></pre><p id="395c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们必须初始化<code class="fe lz ma mb mc b">gatsby-config</code>中的插件，并配置我们想要包含的属性。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="49f9" class="ml kx jb mc b gy mm mn l mo mp">{<br/>      resolve: 'gatsby-plugin-flexsearch',<br/>      options: {<br/>        languages: ['en'],<br/>        type: 'MarkdownRemark',<br/>        fields: [<br/>          {<br/>            name: 'id',<br/>            indexed: false,<br/>            resolver: 'id',<br/>            store: true,<br/>          },<br/>          {<br/>            name: 'html',<br/>            indexed: true,<br/>            resolver: 'internal.content',<br/>            attributes: {<br/>              encode: 'balance',<br/>              tokenize: 'strict',<br/>              threshold: 0,<br/>              resolution: 3,<br/>              depth: 3,<br/>            },<br/>            store: true,<br/>          },<br/>          {<br/>            name: 'title',<br/>            indexed: true,<br/>            resolver: 'frontmatter.title',<br/>            attributes: {<br/>              encode: 'extra',<br/>              tokenize: 'full',<br/>              threshold: 1,<br/>              resolution: 3,<br/>            },<br/>            store: true,<br/>          },<br/>          {<br/>            name: 'description',<br/>            indexed: true,<br/>            resolver: 'frontmatter.description',<br/>            attributes: {<br/>              encode: 'icase',<br/>              tokenize: 'forward',<br/>              threshold: 2,<br/>              depth: 3,<br/>            },<br/>            store: true,<br/>          },<br/>          {<br/>            name: 'type',<br/>            indexed: false,<br/>            resolver: 'frontmatter.type',<br/>            store: true,<br/>          },<br/>          {<br/>            name: 'slug',<br/>            indexed: false,<br/>            resolver: 'fields.slug',<br/>            store: true,<br/>          },<br/>          {<br/>            name: 'layout',<br/>            indexed: false,<br/>            resolver: 'frontmatter.layout',<br/>            store: true,<br/>          },<br/>        ],<br/>      },<br/>    },</span></pre><p id="acb2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的示例中，我声明了要由flex search索引的自定义属性(id、布局和slug ),这些属性对于显示结果片段非常重要，并且必须可以从搜索组件中获得。</p><p id="2c81" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重新启动开发服务器后，flex搜索索引和商店将附加到浏览器的窗口对象。</p><h1 id="edd2" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">带代码片段的搜索组件</h1><p id="9db0" class="pw-post-body-paragraph jy jz jb ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在，我们的盖茨比网站将启用灵活搜索。到目前为止，一切顺利！现在，我们必须让用户能够对我们的内容进行搜索。</p><p id="f2b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们需要一个搜索组件！最重要的部分是搜索功能本身。如果你想查看完整的组件<a class="ae mq" href="https://gist.github.com/mrkaluzny/f53a0323621a670e86a51dad7c78b804" rel="noopener ugc nofollow" target="_blank">，看看这个要点</a></p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1983" class="ml kx jb mc b gy mm mn l mo mp">getSearchResults(query) {<br/>    <em class="mr">var</em> index = window.__FLEXSEARCH__.en.index<br/>    <em class="mr">var</em> store = window.__FLEXSEARCH__.en.store<br/>    <em class="mr">if</em> (!query || !index) {<br/>      <em class="mr">return</em> []<br/>    } <em class="mr">else</em> {<br/>      <em class="mr">var</em> results = []<br/>      Object.keys(index).forEach((idx) =&gt; {<br/>        results.push(...index[idx].values.search(query))<br/>      })</span><span id="b0a7" class="ml kx jb mc b gy ms mn l mo mp">      results = Array.from(<em class="mr">new</em> Set(results))</span><span id="aaa3" class="ml kx jb mc b gy ms mn l mo mp">      <em class="mr">var</em> nodes = store<br/>        .filter((node) =&gt; (results.includes(node.id) ? node : <em class="mr">null</em>))<br/>        .map((node) =&gt; node.node)</span><span id="eb5d" class="ml kx jb mc b gy ms mn l mo mp">      <em class="mr">return</em> nodes<br/>    }<br/>  }</span></pre><p id="ba41" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了搜索我们的文档，我们可以创建一个简单的函数，它接受用户的输入，并使用Flexsearch索引和存储来执行搜索。</p><p id="4a17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们为结果创建一个数组。然后，我们可以检查查询用户搜索的每个索引，并返回匹配的值。然后，我们使用结果数组来过滤Flexsearch商店，并返回与我们的查询匹配的对象。该函数返回包含与查询匹配的文档信息的节点。</p><p id="7082" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，这些节点可用于呈现每个搜索结果的片段。你可以在<a class="ae mq" href="https://dionysus.events/" rel="noopener ugc nofollow" target="_blank">我们上个月做的酒神网站</a>上查看完整的实现</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="e8ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嘶！如果你正在寻找一个有顺风和Netlify CMS的了不起的盖茨比，你必须看看<a class="ae mq" href="https://henlo.netlify.app/" rel="noopener ugc nofollow" target="_blank"> Henlo </a></p></div></div>    
</body>
</html>