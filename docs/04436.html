<html>
<head>
<title>How to Build a Chat Room App in 20 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在20分钟内搭建一个聊天室App</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-chat-room-app-in-20-minutes-82411791a36c?source=collection_archive---------9-----------------------#2020-06-26">https://levelup.gitconnected.com/how-to-build-a-chat-room-app-in-20-minutes-82411791a36c?source=collection_archive---------9-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df47" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用GraphQL、VueJS和现代软件开发工具的力量构建一个聊天室应用程序。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a2211c39182d7800ba49d79533caab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5TAbQdofgryuWqj1.jpg"/></div></div></figure><p id="802a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我父亲喜欢提醒我，作为20世纪70年代的一名计算机工程师，“在编码变得很酷之前，他是一名程序员。”有一两次，他甚至拿出了老式的Fortran和COBOL脚本。读完那段代码后，我很自信地说今天的编码绝对是<strong class="kw iu">更酷的</strong>！</p><p id="4722" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现代计算机语言和开发框架的一个显著特点是它们允许开发人员编写的代码要少得多。通过利用高级语言以及许多可用的API、开源包和付费服务，应用程序——甚至是具有复杂需求的应用程序——可以以令人难以置信的速度构建。</p><p id="4bf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在软件开发的进化中概念化这一点的一个有用的比较是看一下构造。从前，建造任何房子都是从砍倒自己的树开始的。然而，标准材料、工具和最佳实践的发展使项目完成得更快，结构更容易，并减轻工人的低级任务。‍</p><blockquote class="lr"><p id="e82b" class="ls lt it bd lu lv lw lx ly lz ma lp dk translated">如果要建造一座摩天大楼，你必须自己开采钢铁，那将会有多少座摩天大楼？</p></blockquote><p id="3258" class="pw-post-body-paragraph ku kv it kw b kx mb ju kz la mc jx lc ld md lf lg lh me lj lk ll mf ln lo lp im bi translated">仍然年轻和工作的工程师不得不砍树来开始他们的职业生涯。也就是说，过去十年前所未有的创新已经导致软件业像建筑业一样走向成熟。‍</p><p id="6b76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简而言之，今天的开发人员现在拥有标准的工具、材料和最佳实践，可以更快地完成项目，稳定地运行应用程序，并将开发人员从较低级别的任务中解放出来。</p><h1 id="5e5a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">聊天室教程概述</h1><p id="2e32" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">让我们在几分钟内完成一些传统上需要几天或几周的事情；好消息，这不是一个待办事项的应用程序！我们将构建一个公共聊天室应用程序，它使用WebSockets来实现实时消息传递。</p><p id="79e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WebSockets】在所有现代浏览器中都得到了本地支持。然而，<em class="lq">我们的目标是强调我们能为这项工作带来哪些工具，而不是在这项工作的基础上构建工具</em>。本着这种精神，我们将使用以下技术。‍</p><ul class=""><li id="0e00" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated"><a class="ae nd" href="https://www.8base.com/platform" rel="noopener ugc nofollow" target="_blank"> 8base </a> —一个托管的GraphQL API</li><li id="bc3f" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated"><a class="ae nd" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> VueJS </a> —一个前端的JavaScript framework‍</li></ul><p id="73c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">starter项目和完整的自述文件可以在<a class="ae nd" href="https://github.com/8base/Chat-application-using-GraphQL-Subscriptions-and-Vue" rel="noopener ugc nofollow" target="_blank"> this GitHub repo </a>中找到。如果你只想查看完成的应用程序，检查<code class="fe ns nt nu nv b">public-chat-room</code>分支。</p><p id="9bbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，下面的视频遍历教程，并解释了更大的背景下的每一步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">使用GraphQL和VueJS构建一个公共聊天室教程</figcaption></figure><p id="b318" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，让我们开始吧！</p><h1 id="3e9b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.项目设置</h1><p id="9f86" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">克隆starter项目并移动到群聊目录中。您是使用<code class="fe ns nt nu nv b">yarn</code>还是<code class="fe ns nt nu nv b">npm</code>来安装项目依赖项取决于您自己。无论哪种方式，我们都需要安装在<code class="fe ns nt nu nv b">package.json</code>文件中声明的所有NPM软件包。</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="8518" class="og mh it nv b gy oh oi l oj ok"># Clone project<br/>git clone <a class="ae nd" href="https://github.com/8base/Chat-application-using-GraphQL-Subscriptions-and-Vue.git" rel="noopener ugc nofollow" target="_blank">https://github.com/8base/Chat-application-using-GraphQL-Subscriptions-and-Vue.git</a> group-chat</span><span id="7122" class="og mh it nv b gy ol oi l oj ok"># Move into directory<br/>cd group-chat</span><span id="b3af" class="og mh it nv b gy ol oi l oj ok"># Install dependencies<br/>yarn</span></pre><p id="402c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了与GraphQL API通信，我们必须设置3个环境变量。用下面的命令在项目的根目录下创建一个<code class="fe ns nt nu nv b">.env.local</code>文件。初始化后，Vue应用程序将自动设置我们添加到该文件中的环境变量。‍</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="7dc0" class="og mh it nv b gy oh oi l oj ok">echo ‘VUE_APP_8BASE_WORKSPACE_ID=&lt;YOUR_8BASE_WORKSPACE_ID&gt;<br/>VUE_APP_8BASE_API_ENDPOINT=https://api.8base.com<br/>VUE_APP_8BASE_WS_ENDPOINT=wss://ws.8base.com’ \<br/>&gt; .env.local</span></pre><p id="ce3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ns nt nu nv b">VUE_APP_8BASE_API_ENDPOINT</code>和<code class="fe ns nt nu nv b">VUE_APP_8BASE_WS_ENDPOINT</code>值总是相同的。我们需要更新的值是<code class="fe ns nt nu nv b">VUE_APP_8BASE_WORKSPACE_ID</code>。</p><p id="291e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">‍If:您有一个8base工作空间，您想在本教程中使用它，继续使用工作空间ID更新您的<code class="fe ns nt nu nv b">.env.local</code>文件。否则，通过完成<a class="ae nd" href="https://docs.8base.com/docs/getting-started/quick-start" rel="noopener ugc nofollow" target="_blank"> 8base快速入门</a>的步骤1 &amp; 2检索工作区ID。</p><h1 id="8b0f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.导入数据库模式</h1><p id="2311" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们现在需要调配后端。在这个回购的根目录下，你应该可以找到一个<code class="fe ns nt nu nv b">chat-schema.json</code>文件。要将其导入工作区，我们只需安装并验证8base命令行，然后导入模式文件。</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="7cb2" class="og mh it nv b gy oh oi l oj ok"># Install 8base CLI<br/>yarn global add 8base-cli</span><span id="24b8" class="og mh it nv b gy ol oi l oj ok"># Authenticate CLI<br/>8base login</span><span id="21a5" class="og mh it nv b gy ol oi l oj ok"># Configure project and select workspace<br/>8base configure</span><span id="4b67" class="og mh it nv b gy ol oi l oj ok"># Import the schema to our workspace<br/>8base import -f chat-schema.json -w &lt;YOUR_8BASE_WORKSPACE_ID&gt;</span></pre><h1 id="23c8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.设置API权限</h1><p id="c372" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">最后一个后端任务是启用对GraphQL API的公共访问。</p><p id="254c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在8base控制台中，导航至<code class="fe ns nt nu nv b">App Services &gt; Roles &gt; Guest</code>。将为<em class="lq">消息</em>和<em class="lq">用户</em>设置的权限更新为<strong class="kw iu">选中</strong>或<em class="lq">所有记录</em>(如下图所示)。</p><p id="8ac2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Guest角色定义了向API发出未经身份验证的请求的用户可以做什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/f027752275a87f693f3193c2bc928a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfmCK20KXSbSie69FKrxNg.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">8控制台中的基本权限编辑器</figcaption></figure><h1 id="d270" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.编写GraphQL查询</h1><p id="63a1" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">此时，我们将定义并写出我们的聊天组件所需的所有GraphQL查询。这将帮助我们理解我们将通过API读取、创建和监听(通过WebSockets)什么数据。</p><p id="58c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的代码应该放在<code class="fe ns nt nu nv b">src/utils/graphql.js</code>文件中。阅读每个导出常量上面的注释，了解每个查询正在完成什么。</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="15d6" class="og mh it nv b gy oh oi l oj ok">/* gql converts the query strings into graphQL documents */<br/>import gql from "graphql-tag";</span><span id="ef10" class="og mh it nv b gy ol oi l oj ok">/* 1. Fetch all online chat Users and last 10 messages */<br/>export const InitialChatData = gql`<br/>  {<br/>    usersList {<br/>      items {<br/>        id<br/>        email<br/>      }<br/>    }<br/>    messagesList(last: 10) {<br/>      items {<br/>        content<br/>        createdAt<br/>        author {<br/>          id<br/>          email<br/>        }<br/>      }<br/>    }<br/>  }<br/>`;</span><span id="f2aa" class="og mh it nv b gy ol oi l oj ok">/* 2. Create new chat users and assign them the Guest role */<br/>export const CreateUser = gql`<br/>  mutation($email: String!) {<br/>    userCreate(data: { <br/>      email: $email,<br/>      roles: { <br/>        connect: { name: "Guest" } <br/>      } <br/>    }) {<br/>      id<br/>    }<br/>  }<br/>`;</span><span id="dfcf" class="og mh it nv b gy ol oi l oj ok">/* 3. Delete a chat user */<br/>export const DeleteUser = gql`<br/>  mutation($id: ID!) {<br/>    userDelete(data: { id: $id, force: true }) {<br/>      success<br/>    }<br/>  }<br/>`;</span><span id="079f" class="og mh it nv b gy ol oi l oj ok">/* 4. Listen for when chat users are created or deleted */<br/>export const UsersSubscription = gql`<br/>  subscription {<br/>    Users(filter: { mutation_in: [create, delete] }) {<br/>      mutation<br/>      node {<br/>        id<br/>        email<br/>      }<br/>    }<br/>  }<br/>`;</span><span id="4848" class="og mh it nv b gy ol oi l oj ok">/* 5. Create new chat messages and connect it to it's author */<br/>export const CreateMessage = gql`<br/>  mutation($id: ID!, $content: String!) {<br/>    messageCreate(<br/>      data: { content: $content, author: { connect: { id: $id } } }<br/>    ) {<br/>      id<br/>    }<br/>  }<br/>`;</span><span id="e05e" class="og mh it nv b gy ol oi l oj ok">/* 6. Listen for when chat messages are created. */<br/>export const MessagesSubscription = gql`<br/>  subscription {<br/>    Messages(filter: { mutation_in: create }) {<br/>      node {<br/>        content<br/>        createdAt<br/>        author {<br/>          id<br/>          email<br/>        }<br/>      }<br/>    }<br/>  }<br/>`;</span></pre><h1 id="a1e3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.创建阿波罗和订阅客户端</h1><p id="642f" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">随着GraphQL查询的编写，是时候设置我们的API模块了。</p><p id="c514" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们使用<code class="fe ns nt nu nv b">ApolloClient</code>及其所需的缺省值来处理API客户机。对于<code class="fe ns nt nu nv b">createHttpLink</code>,我们提供完全成形的工作空间端点。这个代码属于<code class="fe ns nt nu nv b">src/utils/api.js</code>。</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="86c5" class="og mh it nv b gy oh oi l oj ok">import { ApolloClient } from "apollo-boost";<br/>import { createHttpLink } from "apollo-link-http";<br/>import { InMemoryCache } from "apollo-cache-inmemory";</span><span id="b2f0" class="og mh it nv b gy ol oi l oj ok">const { VUE_APP_8BASE_API_ENDPOINT, VUE_APP_8BASE_WORKSPACE_ID } = process.env;</span><span id="6a2b" class="og mh it nv b gy ol oi l oj ok">export default new ApolloClient({<br/>  link: createHttpLink({<br/>    uri: `${VUE_APP_8BASE_API_ENDPOINT}/${VUE_APP_8BASE_WORKSPACE_ID}`,<br/>  }),<br/>  cache: new InMemoryCache(),<br/>});</span><span id="5d4e" class="og mh it nv b gy ol oi l oj ok">/**<br/> * Note: To learn more about the options available when configuring<br/> * ApolloClient, please reference their documentation.<br/> */</span></pre><p id="7f34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们使用<code class="fe ns nt nu nv b">subscriptions-transport-ws</code>和<code class="fe ns nt nu nv b">isomorphic-ws</code>来处理订阅客户端。这个脚本比上一个稍长，所以请花点时间通读代码注释！‍</p><p id="5aa9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们正在使用我们的WebSockets端点和<code class="fe ns nt nu nv b">connectionParams</code>中的<code class="fe ns nt nu nv b">workspaceId</code>初始化<code class="fe ns nt nu nv b">SubscriptionClient</code>。然后我们在默认导出上定义的两个方法中使用那个<code class="fe ns nt nu nv b">subscriptionClient</code>;<code class="fe ns nt nu nv b">subscribe()</code>和<code class="fe ns nt nu nv b">close()</code>。</p><p id="1389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ns nt nu nv b">subscribe</code>允许我们创建带有数据和错误回调的新订阅。关闭方法是我们在离开聊天室时可以用来关闭连接的方法。</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="0dbc" class="og mh it nv b gy oh oi l oj ok">import WebSocket from "isomorphic-ws";<br/>import { SubscriptionClient } from "subscriptions-transport-ws";</span><span id="7714" class="og mh it nv b gy ol oi l oj ok">const { VUE_APP_8BASE_WS_ENDPOINT, VUE_APP_8BASE_WORKSPACE_ID } = process.env;</span><span id="a0d3" class="og mh it nv b gy ol oi l oj ok">/**<br/> * Create the subscription client using the relevant environment<br/> * variables and default options<br/> */<br/>const subscriptionClient = new SubscriptionClient(<br/>  VUE_APP_8BASE_WS_ENDPOINT,<br/>  {<br/>    reconnect: true,<br/>    connectionParams: {<br/>      /**<br/>       * WorkspaceID MUST be set or the Websocket Endpoint <br/>       * wont be able to map the request to the appropriate<br/>       * workspace<br/>       */<br/>      workspaceId: VUE_APP_8BASE_WORKSPACE_ID<br/>    }<br/>  },<br/>  /**<br/>   * Constructor for W3C compliant WebSocket implementation. <br/>   * Use this when your environment does not have a built-in <br/>   * native WebSocket (for example, with NodeJS client)<br/>   */<br/>  WebSocket<br/>);</span><span id="bb8a" class="og mh it nv b gy ol oi l oj ok">export default {<br/>  /**<br/>   * Accepts the subscription query, any variables and the<br/>   * callback handlers 'data' and 'error'<br/>   */<br/>  subscribe: (query, options) =&gt; {<br/>    const { variables, data, error } = options;</span><span id="b99d" class="og mh it nv b gy ol oi l oj ok">    /**<br/>     * Runs the new subscription request.<br/>     */<br/>    const result = subscriptionClient.request({<br/>      query,<br/>      variables<br/>    });</span><span id="7173" class="og mh it nv b gy ol oi l oj ok">    /**<br/>     * The unsubscribe function can be used to close a specific<br/>     * subscription as opposed to ALL subscriptions be maintained<br/>     * by the subscriptionClient<br/>     */<br/>    const { unsubscribe } = result.subscribe({<br/>      /**<br/>       * Whenever an event is received, the result is passed<br/>       * to the developer specified data callback.<br/>       */<br/>      next(result) {<br/>        if (typeof data === "function") {<br/>          data(result);<br/>        }<br/>      },</span><span id="6100" class="og mh it nv b gy ol oi l oj ok">      /**<br/>       * Whenever an error is received, the error is passed<br/>       * to the developer specified error callback.<br/>       */<br/>      error(e) {<br/>        if (typeof error === "function") {<br/>          error(e);<br/>        }<br/>      }<br/>    });</span><span id="3033" class="og mh it nv b gy ol oi l oj ok">    return unsubscribe;<br/>  },</span><span id="da10" class="og mh it nv b gy ol oi l oj ok">  /**<br/>   * Closes subscriptionClient's connection.<br/>   */<br/>  close: () =&gt; {<br/>    subscriptionClient.close();<br/>  }<br/>};</span><span id="29dd" class="og mh it nv b gy ol oi l oj ok">/** <br/> * Note: To learn more about the SubscriptionClient and <br/> * its options, please reference their documentation <br/> */</span></pre><h1 id="618c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.编写Vue组件</h1><p id="7e2c" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">至此，我们已经拥有了构建公共聊天室所需的一切！剩下的就是写出一个单独的<code class="fe ns nt nu nv b">GroupChat.vue</code>组件。</p><p id="03c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用<code class="fe ns nt nu nv b">yarn serve</code>启动组件，让我们继续。</p><p id="357f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="lq">警告:情人眼里出西施……正因为如此，只添加了使组件实用所需的最少样式。</em> </strong></p><h2 id="6568" class="og mh it bd mi on oo dn mm op oq dp mq ld or os ms lh ot ou mu ll ov ow mw ox bi translated">Vue组件脚本</h2><p id="351b" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">首先，我们需要导入我们的模块、简单样式和GraphQL查询。所有这些工件都存在于我们的<code class="fe ns nt nu nv b">src/utils</code>目录中。</p><p id="8316" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ns nt nu nv b">GroupChat.vue</code>中的开始<code class="fe ns nt nu nv b">\&lt;script\&gt;</code>标签后插入以下导入语句。‍</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="0c69" class="og mh it nv b gy oh oi l oj ok"><em class="lq">/* API modules */</em><br/>import Api from "./utils/api";<br/>import Wss from "./utils/wss";<br/><br/><em class="lq">/* graphQL operations */</em><br/>import {<br/> InitialChatData,<br/> CreateUser,<br/> DeleteUser,<br/> UsersSubscription,<br/> CreateMessage,<br/> MessagesSubscription,<br/>} from "./utils/graphql";<br/>‍<br/><em class="lq">/* Styles */</em><br/>import "../assets/styles.css";</span></pre><h2 id="0d86" class="og mh it bd mi on oo dn mm op oq dp mq ld or os ms lh ot ou mu ll ov ow mw ox bi translated">Vue组件数据</h2><p id="bb51" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们可以在组件的数据函数中定义我们想要的数据属性。我们需要的只是一种存储聊天用户、消息、“当前”用户是谁以及任何尚未发送的消息的方法。这些属性可以像这样添加:</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="fe94" class="og mh it nv b gy oh oi l oj ok"><em class="lq">/* imports ... */</em><br/><br/>export default {<br/> name: "GroupChat",<br/>‍<br/> data: () =&gt; ({<br/>   messages: [],<br/>   newMessage: "",<br/>   me: { email: "" },<br/>   users: [],<br/> }),<br/>};</span></pre><h2 id="a0d9" class="og mh it bd mi on oo dn mm op oq dp mq ld or os ms lh ot ou mu ll ov ow mw ox bi translated">Vue生命周期挂钩</h2><p id="dbc9" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们的生命周期钩子在Vue组件“生命”的不同时刻执行。例如，当它被装载或更新时。在我们的例子中，我们只关心组件何时被创建以及<code class="fe ns nt nu nv b">beforeDestroy</code>。在这些时候，我们想要打开聊天订阅或关闭聊天订阅。</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="9a2d" class="og mh it nv b gy oh oi l oj ok">/* imports ... */</span><span id="b42b" class="og mh it nv b gy ol oi l oj ok">export default {<br/>  /* other properties ... */</span><span id="e793" class="og mh it nv b gy ol oi l oj ok">  /**<br/>   * Lifecycle hook executed when the component is created.<br/>   */<br/>  created() {<br/>    /**<br/>     * Create Subscription that triggers event when user is <br/>     * created or deleted<br/>     */<br/>    Wss.subscribe(UsersSubscription, {<br/>      data: this.handleUser<br/>    });</span><span id="22bd" class="og mh it nv b gy ol oi l oj ok">    /**<br/>     * Create Subscription that triggers event when <br/>     * message is created<br/>     */<br/>    Wss.subscribe(MessagesSubscription, {<br/>      data: this.addMessage<br/>    });</span><span id="3514" class="og mh it nv b gy ol oi l oj ok">    /**<br/>     * Fetch initial chat data (Users and last 10 Messages)<br/>     */<br/>    Api.query({<br/>      query: InitialChatData<br/>    }).then(({ data }) =&gt; {<br/>      this.users = data.usersList.items;<br/>      this.messages = data.messagesList.items;<br/>    });</span><span id="7459" class="og mh it nv b gy ol oi l oj ok">    /**<br/>     * Callback executed on page refresh to close chat<br/>     */<br/>    window.onbeforeunload = this.closeChat;<br/>  },</span><span id="2586" class="og mh it nv b gy ol oi l oj ok">  /**<br/>   * Lifecycle hook executed before the component is destroyed.<br/>   */<br/>  beforeDestroy() {<br/>    this.closeChat();<br/>  }<br/>};</span></pre><h2 id="83a9" class="og mh it bd mi on oo dn mm op oq dp mq ld or os ms lh ot ou mu ll ov ow mw ox bi translated">Vue组件方法</h2><p id="2e41" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们必须添加特定的方法来处理每个API调用/响应(<code class="fe ns nt nu nv b">createMessage</code>、<code class="fe ns nt nu nv b">addMessage</code>、<code class="fe ns nt nu nv b">closeChat</code>等)。).这些都将存储在组件的方法对象中。</p><p id="e2e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的一点是，大多数突变不会等待或处理响应。这是因为我们有订阅运行，监听那些突变。成功运行后，由订阅处理事件数据。</p><p id="d304" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些方法中的大多数都是不言自明的。无论如何，请阅读下面代码中的注释。</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="3e1e" class="og mh it nv b gy oh oi l oj ok"><em class="lq">/* imports ... */</em><br/><br/>export default {<br/> <em class="lq">/* other properties ... */</em><br/>‍<br/> methods: {<br/>   <em class="lq">/**</em><br/><em class="lq">    * Create the new user using a submitted email address.</em><br/><em class="lq">    */</em><br/>   createUser() {<br/>     Api.mutate({<br/>       mutation: CreateUser,<br/>       variables: {<br/>         email: this.me.email,<br/>       },<br/>     });<br/>   },</span><span id="b18b" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">/**</em><br/><em class="lq">    * Delete a user by their ID.</em><br/><em class="lq">    */</em><br/>   deleteUser() {<br/>     Api.mutate({<br/>       mutation: DeleteUser,<br/>       variables: { id: this.me.id },<br/>     });<br/>   },</span><span id="3d05" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">/**</em><br/><em class="lq">    * Our users subscription listing to both the create <br/>    * and update events, and therefore we need to choose <br/>    * the appropriate method to handle the response based <br/>    * on the mutation type.</em><br/><em class="lq">    *</em><br/><em class="lq">    * Here, we have an object that looks up the mutation <br/>    * type by name, returns it and executes the function <br/>    * while passing the event node.</em><br/><em class="lq">    */</em><br/>   handleUser({<br/>     data: {<br/>       Users: { mutation, node },<br/>     },<br/>   }) {<br/>     ({<br/>       create: this.addUser,<br/>       delete: this.removeUser,<br/>     }[mutation](node));<br/>   },</span><span id="b725" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">/**</em><br/><em class="lq">    * Adds a new user to users array, first checking <br/>    * whether the user being added is the current user.</em><br/><em class="lq">    */</em><br/>   addUser(user) {<br/>     if (this.me.email === user.email) {<br/>       this.me = user;<br/>     }<br/>     this.users.push(user);<br/>   },</span><span id="2c07" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">/**</em><br/><em class="lq">    * Removes user from the users array by ID.</em><br/><em class="lq">    */</em><br/>   removeUser(user) {<br/>     this.users = this.users.filter(<br/>       (p) =&gt; p.id != user.id<br/>     );<br/>   },</span><span id="5e2e" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">/* Create a new message */</em><br/>   createMessage() {<br/>     Api.mutate({<br/>       mutation: CreateMessage,<br/>       variables: {<br/>         id: this.me.id,<br/>         content: this.newMessage,<br/>       },<br/>     }).then(() =&gt; (this.newMessage = ""));<br/>   },</span><span id="7746" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">/**</em><br/><em class="lq">    * Our messages subscription only listens to the <br/>    * create event. Therefore, all we need to do is <br/>    * push it into our messages array.</em><br/><em class="lq">    */</em><br/>   addMessage({<br/>     data: {<br/>       Messages: { node },<br/>     },<br/>   }) {<br/>     this.messages.push(node);<br/>   },</span><span id="eafd" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">/**</em><br/><em class="lq">    * We'll want to close our subscriptions and <br/>    * delete the user. This method can be</em><br/><em class="lq">    * called in our beforeDestroy lifecycle hook and <br/>    * any other relevantly placed callback.</em><br/><em class="lq">    */</em><br/>   closeChat () {<br/>     <em class="lq">/* Close subscriptions before exit */</em><br/>     Wss.close()<br/>     <br/>     <em class="lq">/* Delete participant */</em><br/>     this.deleteUser();<br/>     <br/>     <em class="lq">/* Set me to default */</em><br/>     this.me = { me: { email: '' } }<br/>   }<br/> },<br/>‍<br/> <em class="lq">/* lifecycle hooks ... */</em><br/>}</span></pre><h2 id="d804" class="og mh it bd mi on oo dn mm op oq dp mq ld or os ms lh ot ou mu ll ov ow mw ox bi translated">Vue组件模板</h2><p id="6c2d" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">最后但同样重要的是，我们有我们的组件<code class="fe ns nt nu nv b">\&lt;template\&gt;</code>。</p><p id="ab21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">‍There有数以千计的关于如何构建漂亮ui的教程。这不是那些教程中的一个。</p><p id="bc71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下模板符合群聊应用的最低要求。真的要靠你进去把它做漂亮。也就是说，让我们快速浏览一下我们在这里实现的关键标记。‍</p><p id="d1e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一如既往，请阅读内联代码注释。</p><pre class="kj kk kl km gt oc nv od oe aw of bi"><span id="da8f" class="og mh it nv b gy oh oi l oj ok">&lt;template&gt;<br/> &lt;div id="app"&gt;</span><span id="78f4" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">&lt;!--</em><br/><em class="lq">     Only if the current user has an ID (has been created) <br/>     should the chat view be rendered. Otherwise, a sign <br/>     up for is shown.</em><br/><em class="lq">    --&gt;</em><br/>   &lt;div v-if="me.id" class="chat"&gt;<br/>     &lt;div class="header"&gt;</span><span id="318f" class="og mh it nv b gy ol oi l oj ok">       <em class="lq">&lt;!--</em><br/><em class="lq">         Since we're using subscriptions that run in real-time, <br/>         our number of user currently online will <br/>         dynamically adjust.</em><br/><em class="lq">        --&gt;</em><br/>       {{ users.length }} Online Users<br/>       <em class="lq">&lt;!--</em><br/><em class="lq">         A user can leave the chat by executing the</em><br/><em class="lq">         closeChat function.</em><br/><em class="lq">        --&gt;</em><br/>       &lt;button @click="closeChat"&gt;Leave Chat&lt;/button&gt;<br/>     &lt;/div&gt;</span><span id="ef21" class="og mh it nv b gy ol oi l oj ok">     <em class="lq">&lt;!--</em><br/><em class="lq">       For every message that we're storing in the messages array,</em><br/><em class="lq">       we'll render out in a div. Additionally, if the <br/>       messages participant id matches the current user <br/>       id, we'll assign it the me class.</em><br/><em class="lq">      --&gt;</em><br/>     &lt;div<br/>       :key="index"<br/>       v-for="(msg, index) in messages"<br/>       :class="['msg', { me: msg.participant.id === me.id }]"<br/>     &gt;<br/>       &lt;p&gt;{{ msg.content }}&lt;/p&gt;<br/>       &lt;small&gt;<br/>          &lt;strong&gt;{{ msg.participant.email }}&lt;/strong&gt;<br/>          {{ msg.createdAt}}<br/>       &lt;/small&gt;<br/>     &lt;/div&gt;</span><span id="bcb6" class="og mh it nv b gy ol oi l oj ok">     <em class="lq">&lt;!--</em><br/><em class="lq">       Our message input is bound to the newMessage data property.</em><br/><em class="lq">      --&gt;</em><br/>     &lt;div class="input"&gt;<br/>       &lt;input<br/>         type="text"<br/>         placeholder="Say something..."<br/>         v-model="newMessage"<br/>       /&gt;</span><span id="e4ec" class="og mh it nv b gy ol oi l oj ok">       <em class="lq">&lt;!--</em><br/><em class="lq">         When the user clicks the send button, we run <br/>         the createMessage function.</em><br/><em class="lq">        --&gt;</em><br/>       &lt;button @click="createMessage"&gt;Send&lt;/button&gt;<br/>     &lt;/div&gt;<br/>   &lt;/div&gt;</span><span id="5008" class="og mh it nv b gy ol oi l oj ok">   <em class="lq">&lt;!--</em><br/><em class="lq">     The sign up flow simply asks the user to enter an email <br/>     address. Once the input is blurred, the createUser <br/>     method is executed.</em><br/><em class="lq">    --&gt;</em><br/>   &lt;div v-else class="signup"&gt;<br/>     &lt;label for="email"&gt;Sign up to chat!&lt;/label&gt;<br/>     &lt;br /&gt;<br/>     &lt;input<br/>       type="text"<br/>       v-model="me.email"<br/>       placeholder="What's your email?"<br/>       @blur="createUser"<br/>       required<br/>     /&gt;<br/>   &lt;/div&gt;<br/> &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="ea65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">信不信由你，现在整个公共聊天室都建好了。如果您在本地主机网络(<code class="fe ns nt nu nv b">yarn serve</code>)上打开它，您将能够开始发送和接收信息。但是，要证明是真的群聊，打开几个窗口，看对话流程！</p><h1 id="444e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">7.总结和测试</h1><p id="d282" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">在本教程中，我们探索了如何利用现代开发工具让我们在几分钟内构建真实世界的应用程序。</p><p id="8cf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望您还学习了如何初始化<code class="fe ns nt nu nv b">ApolloClient</code>和<code class="fe ns nt nu nv b">SubscriptionClient</code>以有效地执行GraphQL查询、变异和对8base工作空间的订阅，以及一些关于VueJS的知识。‍</p><p id="ae74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论您是在开发网页/手机游戏、消息和通知应用程序，还是有实时数据需求的其他项目，订阅都是一个非常好的工具。我们在这里仅仅触及了表面！</p></div><div class="ab cl oy oz hx pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="im in io ip iq"><p id="4825" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">8base平台允许开发人员使用JavaScript和GraphQL构建令人惊叹的云应用。了解更多关于<a class="ae nd" href="https://www.8base.com/platform" rel="noopener ugc nofollow" target="_blank"><em class="lq">8基础平台</em> </a> <em class="lq">。</em></p><p id="6e06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">原载于</em> <a class="ae nd" href="https://www.8base.com/blog" rel="noopener ugc nofollow" target="_blank"> <em class="lq"> 8base的博客</em> </a> <em class="lq">。</em></p></div></div>    
</body>
</html>