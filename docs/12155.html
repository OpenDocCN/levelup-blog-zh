<html>
<head>
<title>Graceful shutdown of Pulsar queue consumers in Java and Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java和Spring Boot中Pulsar队列消费者的正常关闭</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graceful-shutdown-of-pulsar-queue-consumers-in-java-and-spring-boot-f93645a92b2b?source=collection_archive---------5-----------------------#2022-05-19">https://levelup.gitconnected.com/graceful-shutdown-of-pulsar-queue-consumers-in-java-and-spring-boot-f93645a92b2b?source=collection_archive---------5-----------------------#2022-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在软件工程中，系统的边缘/边界通常是有趣问题发生的地方，不仅是在<em class="kl">系统间</em>的通信中——这里有所有经典的分布式系统问题——而且在单个系统中也有<em class="kl">。许多困扰系统的问题与该服务与另一个服务的通信无关，这些问题不是在正常运行期间发生的<em class="kl">，而是在应用程序启动和关闭期间发生的</em>。</em></p><p id="d557" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正确的应用程序关闭程序是文档中一个非常容易被忽视的领域，并且，通过扩展，也是许多应用程序问题容易出现的领域。你上一次阅读应用程序或框架的教程，提到如何正确关闭应用程序是什么时候？当然，这不是启动和运行的必要条件，但也许正因为如此，正确的关闭处理常常是一个被忽视的领域，直到生产问题开始出现，开发人员不得不试图找出可能出错的地方。</p><p id="259a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多web框架至少会有一些内置功能来启动web流量的正常关闭——允许正在进行的请求完成，但拒绝任何新的请求——但其他过程，如队列消费者或生产者，通常不会在文档中提及(对Quarkus的大喊<a class="ae km" href="https://quarkus.io/guides/lifecycle" rel="noopener ugc nofollow" target="_blank">就是一个很好的反例</a>)。</p><h1 id="7027" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">那么，什么是正常关机呢？</h1><p id="6f28" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">有很多优秀的资源可以帮助理解优雅关机——为了理解Kubernetes中的优雅关机，我推荐<a class="ae km" href="https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-terminating-with-grace" rel="noopener ugc nofollow" target="_blank">这个简单的教程</a>和<a class="ae km" href="https://learnk8s.io/graceful-shutdown" rel="noopener ugc nofollow" target="_blank">这个深入的教程</a>——所以我在这里不会涉及太多。</p><p id="3f7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是作为一个快速的总结——交通灯的类比对我很有帮助。假设您的应用程序是一组快乐行驶的汽车(容器的部署)——灯是绿色的。现在，您需要停止您的应用程序，以便您可以部署一个新版本。你可以告诉应用程序它需要立即停止<em class="kl"/>(立即红灯)———但是，就像汽车接近十字路口一样，这可能会导致事故。</p><p id="55e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们该怎么做才能给汽车一个安全通过十字路口的机会呢？</p><p id="d92a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">我们有黄灯— —它给汽车一个</em> <strong class="jp ir"> <em class="kl">宽限期</em> </strong> <em class="kl">，让它们有足够的时间减速，在到达十字路口之前停下来(或者完成穿过十字路口——这是这个类比失效的地方:)</em></p><p id="387e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的应用程序容器/服务器，我们希望做同样的事情——如果它们当前正在工作(正在写入数据库，发出出站API请求，等等)。)，无论是处理API请求还是使用队列消息，<em class="kl">通常希望让这些正在进行的工作完成，但不要再做新的工作。</em></p><p id="79dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，要做到这一点，我们需要一种方法向计算机进程发送两种不同的<em class="kl">信号</em>，它们相当于黄灯和红灯。幸运的是，这些信号是存在的，并且是标准化的— <em class="kl">然而，实现业务逻辑，以对应用程序正在做的工作有意义的方式适当地处理这些信号，这取决于应用程序。</em></p><p id="a8ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标准信号是:</p><ul class=""><li id="23b9" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">SIGTERM(黄灯)—指示应用程序启动正常关机</li><li id="d5cf" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk lv lw lx ly bi translated">SIGINT / SIGKILL(红灯)—强制中断/终止进程</li></ul><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/c184cc1b2e108c0834ff6cd2a283ad41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtQWaGEyN9dkWuh5wosMRg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">理想化的优雅关机流程</figcaption></figure><p id="6c47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在容器世界中，像Kubernetes这样的编排者利用这些信号作为应用程序新部署的一部分。在新的应用程序单元启动并运行之后(在负载平衡器开始将请求路由到新的单元之后)，Kubernetes开始清理旧的单元。上图描述了这一过程的简化版本。首先，一个SIGTERM被发送到所有旧的pod(黄灯信号)，这启动了“终止宽限期”。您可以在笔记本电脑上通过按Ctrl + C(如果通过命令行运行您的应用程序)来模拟这种行为，或者如果您使用IntelliJ之类的IDE，则通过停止您的应用程序来模拟这种行为。</p><p id="ba5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">理解这个信号实际上并不<em class="kl">做任何事情</em>是很重要的，这取决于应用<em class="kl">处理</em>SIGTERM信号。</strong></p><p id="29b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多web框架将有一些SIGTERM的内置处理，其中它们将拒绝任何带有503的全新传入的<em class="kl"> web </em>请求，但允许进行中的请求完成。在Java中，Spring Boot 2.3+会通过在你的application.properties文件中设置<code class="fe mu mv mw mx b">server.shutdown=graceful</code>属性(默认为<code class="fe mu mv mw mx b">immediate</code>)来自动做到这一点，类似的属性也存在于Quarkus ( <code class="fe mu mv mw mx b">quarkus.shutdown.timeout</code>)等框架中。</p><p id="f7e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">但是，如果您的应用程序正在做<em class="kl">非web </em>工作，比如使用队列消息——则由应用程序决定以下事项:</strong></p><ol class=""><li id="34b5" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk my lw lx ly bi translated"><strong class="jp ir">我们是立即停止处理正在进行的队列消息，还是等待它们完成？</strong></li><li id="e2e7" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">我们停止接受新的队列消息了吗？</li><li id="95f5" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">我们如何处理本地排队的消息？</li></ol><p id="d798" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将介绍在Spring Boot环境中使用Java客户端时如何为<a class="ae km" href="https://pulsar.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Pulsar </a>处理这个问题——但是这里讨论的原则和模式适用于任何框架中的任何队列消费者。</p><h1 id="9428" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">如何优雅地关闭Spring Boot的Pulsar消费者</h1><p id="5386" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我创建了一个示例应用程序来帮助演示我将要介绍的原则，因此如果您想继续学习，请<a class="ae km" href="https://github.com/zachelrath/pulsar-graceful-shutdown-java" rel="noopener ugc nofollow" target="_blank">查看这个repo </a>,并按照自述文件中的步骤执行以下操作:</p><ol class=""><li id="71f8" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk my lw lx ly bi translated">用Docker Compose启动一个本地脉冲星簇</li><li id="1cd6" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">在生产者模式下运行应用程序，以产生Pulsar主题的消息</li><li id="5038" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">在消费者模式下运行应用程序，以消费来自主题的消息</li></ol><div class="mz na gp gr nb nc"><a href="https://github.com/zachelrath/pulsar-graceful-shutdown-java" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">GitHub-zachelrath/Pulsar-Graceful-shut down-Java:Apache Pulsar Java的优雅关机…</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">Spring中Apache Pulsar Java消费者的优雅关闭-GitHub-zachelrath/Pulsar-优雅关闭-java…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq mo nc"/></div></div></a></div><p id="7192" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦运行了生成器，您应该会在控制台中看到如下所示的日志:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nr"><img src="../Images/a215fc7f97693bad70ede964a31246e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8MT9r3ayWPwH0Q-4r097Iw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">针对该主题生成一些消息</figcaption></figure><p id="2734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您启动消费者，您应该会看到如下消息:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ns"><img src="../Images/3288c4ed2477fe56aafa721f51b61ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aImUPWZfh1hu69K-2N6AGA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">使用队列中的消息</figcaption></figure><p id="402e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本队列使用者配置如下所示:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8fa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理队列消息的实际逻辑委托给MessageListener实现，如下所示:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="83d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了模拟真实的队列工作，我们只是让消息监听器休眠0-2秒的随机间隔，然后确认消息，告诉Pulsar工作已经完成，此时它记录“成功处理！”</p><p id="c546" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么——当我们试图关闭应用程序时会发生什么？</p><p id="a6cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来按Ctrl + C，一探究竟！</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nv"><img src="../Images/29aa8d88abf2b45d8381a71fabb320f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Pot6E9c8xNhpugxiBw42A.png"/></div></div></figure><p id="5057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这真的很简单——应用程序在运行中停止，不允许现有的请求完成。请注意，最后一个日志是“已收到，开始处理…”。在现实世界中，您的队列消费者可能会发出API请求，写入数据库，谁知道呢。</p><p id="6fb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会问，那又怎样？Pulsar不会重新传递这条消息吗，因为队列消费者从未确认过它？</p><p id="3cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，这是真的——Pulsar将等待消费者特定的<code class="fe mu mv mw mx b">ackTimeout</code>(在我们的配置中设置为10秒)之后，再尝试重新发送从未被确认的消息。这很好，只要请求处理是等幂的——如果您正在做的工作可以一遍又一遍地重做，那么让消息处理失败也没什么坏处。</p><p id="2041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在现实世界的应用程序中，并不是所有的请求都是幂等的——仅仅允许请求在运行中失败也不是有效的。</p><p id="add6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想确保我们的消息被允许完成，我们需要实现对正常关闭的支持。</p><h1 id="0a26" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">如何在Spring应用程序中监听SIGTERM</h1><p id="78ea" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们需要做的第一件事是挂钩Spring的应用程序生命周期事件，这样当SIGTERM信号发送到应用程序时，我们就会得到通知。</p><p id="fb92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是通过添加一个<code class="fe mu mv mw mx b">@EventListener</code>注释来实现的，该注释与<code class="fe mu mv mw mx b">ContextClosedEvent</code>挂钩:</p><pre class="mf mg mh mi gt nw mx nx ny aw nz bi"><span id="95a5" class="oa ko iq mx b gy ob oc l od oe">@EventListener(ContextClosedEvent.class)<br/>public void onContextClosed() {<br/>    <em class="kl">log</em>.info("(CONSUMER) CONTEXT CLOSED received, initiating graceful shutdown...");</span></pre><p id="d59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了——现在我们该怎么办？</p><p id="1dd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从我们必须回答的三个问题中的第一个开始:</p><p id="9015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(1) <em class="kl">我们是立即停止处理进行中的请求，还是让它们完成？</em></p><p id="f3ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们知道我们的请求最多需要2秒钟才能完成，所以我们可以轻松地休眠2秒钟以上，并确保我们现有的请求已经成功完成:</p><pre class="mf mg mh mi gt nw mx nx ny aw nz bi"><span id="62ad" class="oa ko iq mx b gy ob oc l od oe"><em class="kl">// Wait for a time to allow messages to finish being processed<br/></em>try {<br/>    TimeUnit.<em class="kl">SECONDS</em>.sleep(shutdownGracePeriodSeconds);<br/>} catch (InterruptedException e) {<br/>    <em class="kl">log</em>.error("THREAD INTERRUPTED");<br/>}</span></pre><p id="672c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很简单！但是，如果我们运行消费者，我们会看到我们继续看到消息被处理。那是因为我们<em class="kl">仍在接受来自脉冲星经纪人的新消息。</em></p><p id="2105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来回答问题<em class="kl"> (2)我们是否停止接受新的队列消息？</em></p><p id="21f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pulsar提供了一种简单的方法来停止接受新消息:<a class="ae km" href="https://pulsar.apache.org/api/client/org/apache/pulsar/client/api/Consumer.html#pause" rel="noopener ugc nofollow" target="_blank">简单地调用</a> <code class="fe mu mv mw mx b"><a class="ae km" href="https://pulsar.apache.org/api/client/org/apache/pulsar/client/api/Consumer.html#pause" rel="noopener ugc nofollow" target="_blank">consumer.pause()</a></code>:</p><pre class="mf mg mh mi gt nw mx nx ny aw nz bi"><span id="4a04" class="oa ko iq mx b gy ob oc l od oe"><em class="kl">// Stop accepting new messages from Broker by pausing all consumers<br/>log</em>.info("Pausing all consumers...");<br/>consumers.forEach(Consumer::pause);</span></pre><p id="dec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从逻辑上来说，我们应该在为<code class="fe mu mv mw mx b">shutdownGracePeriodSeconds</code>睡觉之前先做这个<em class="kl"/>。</p><p id="9aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">休眠之后，我们可以更进一步，明确关闭Pulsar <code class="fe mu mv mw mx b">Consumer</code>实例，最后关闭<code class="fe mu mv mw mx b">Client</code>:</p><pre class="mf mg mh mi gt nw mx nx ny aw nz bi"><span id="9cd5" class="oa ko iq mx b gy ob oc l od oe"><em class="kl">log</em>.info("Closing all consumers...");<br/>consumers.forEach(consumer -&gt; {<br/>    try {<br/>        consumer.close();<br/>    } catch (PulsarClientException e) {<br/>        <em class="kl">log</em>.error("UNABLE TO close consumer", e);<br/>    }<br/>});<br/><em class="kl">log</em>.info("Successfully closed consumers!");<br/><em class="kl">log</em>.info("Closing client...");<br/>try {<br/>    client.close();<br/>} catch (PulsarClientException e) {<br/>    <em class="kl">log</em>.error("UNABLE to close client...", e);<br/>}<br/><br/><em class="kl">log</em>.info("Graceful shutdown complete!");</span></pre><p id="cda4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该能解决所有问题，对吧？让我们来看看:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi of"><img src="../Images/7bec866be5619cdf33e0406c819193df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0Ocx_O-iqGFmtyZO0tKQg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">优雅关机不太顺利:(</figcaption></figure><p id="55a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">呀…真是一团糟，哪里出错了？</p><p id="6e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来分解一下:</p><ol class=""><li id="9bcf" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk my lw lx ly bi translated">我们开始处理消息7:527(“收到，开始处理…”)</li><li id="1564" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">我们点击Ctrl + C，启动正常关机(“收到上下文关闭”)</li><li id="5a51" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated"><strong class="jp ir">我们暂停消费者。</strong></li><li id="7e08" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">消息7:527完成处理。</li><li id="4e68" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">我们在7:528收到一条新消息，并开始处理它。这也成功了。</li><li id="5cd7" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated"><strong class="jp ir">我们在7:529收到一条新消息，并开始处理它。</strong></li><li id="5af6" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">3秒钟的正常关机睡眠结束。</li><li id="18af" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">我们关闭了所有的消费者和Pulsar客户端。</li><li id="98b1" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">线程processing 7:529试图向Pulsar发送一个确认，告知它的工作已经完成——但是客户端已经关闭，所以失败了，并出现了一个令人讨厌的异常。</li></ol><p id="9767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最大的问题是--为什么会出现(5)和(6)？？为什么我们调用<code class="fe mu mv mw mx b">consumer.pause()</code>后Pulsar会给我们发新消息？</p><h1 id="cd86" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">接收者队列</h1><p id="599b" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">答:Pulsar broker <em class="kl">没有</em>向我们发送任何新消息——消费者已经将消息在本地的“接收者队列”中排队。</p><p id="1509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">接收方队列</strong>是一种在高容量队列中特别有用的机制，在这种情况下，为了最大化吞吐量，我们希望确保消费者在完成一条消息的处理后，总是有一些消息准备好开始工作——这样就不会浪费任何时间返回给代理说“嘿，我准备好了，给我更多的工作！”如果消息处理时间与消费者从代理请求和接收新消息的时间相当，这将大大降低吞吐量。</p><p id="443f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在我们的示例配置中，我们将接收方队列大小设置为5:</p><pre class="mf mg mh mi gt nw mx nx ny aw nz bi"><span id="2c39" class="oa ko iq mx b gy ob oc l od oe">Consumer&lt;byte[]&gt; consumer = client.newConsumer()<br/>        .subscriptionName(subscriptionName)<br/>        .subscriptionType(SubscriptionType.<em class="kl">Key_Shared</em>)<br/>        .topic(topicName)<br/><strong class="mx ir">        .receiverQueueSize(5)<br/></strong></span></pre><p id="b5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着，即使在我们暂停消费者接收来自代理的新消息之后，<em class="kl">其本地接收者队列中仍有多达5条消息需要处理</em>。如果任其自生自灭，消费者将继续尝试处理这些信息。不幸的是，我们已经关闭了客户端，因此消费者无法确认这些消息。</p><p id="ec7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对此我们应该做些什么？</p><p id="3abe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们有几个选择:</p><ol class=""><li id="97ef" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk my lw lx ly bi translated">增加正常关机睡眠持续时间，不仅允许<em class="kl">进行中的</em>消息完成处理<em class="kl">，还允许处理接收器队列中的所有消息</em>。</li><li id="e594" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">通过否定确认来防止消费者处理其接收者队列中的更多消息。</li><li id="936d" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated">将接收方队列大小设置为0。</li></ol><p id="ad78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们这样做(1 ),这将需要额外等待5 * 2秒。如果我们在Kubernetes，这应该没问题，那里的终止宽限期是30秒——我们将在下面的方式。但是如果这里有更多的可变性呢？如果我们的接收方队列大小为10，并且每条消息可能需要3秒钟才能处理完，该怎么办？同样，所有这些都取决于现实世界中队列的实际动态，但是作为最佳实践，最好遵循以下规则:</p><ul class=""><li id="4d57" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk lv lw lx ly bi translated">如果一个应用程序被赋予了一个SIGTERM，它应该<em class="kl">尽可能快地停止做更多的工作。</em></li></ul><p id="8f4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循这个原则，(1)就out了。(3)如果我们想确保对我们的消费者有更高的吞吐量，也是不可能的。这给我们留下了(2)。</p><p id="22a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现(2)，我们基本上只需要设置一个标志，该标志将指示<code class="fe mu mv mw mx b">MessageListener</code>否定确认它接收到的任何全新消息——其中<em class="kl">应该只是留在接收者队列中的消息。</em></p><p id="e00a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在监听器中，我们将添加一个名为<code class="fe mu mv mw mx b">initiateGracefulShutdown</code>的新钩子(这可能是所有<code class="fe mu mv mw mx b">MessageListener</code>实现所需的接口方法)，它只是将一个布尔值转换为假，然后我们在我们的<code class="fe mu mv mw mx b">received</code>方法中添加一个分支，该分支否定确认所有net-new消息:</p><pre class="mf mg mh mi gt nw mx nx ny aw nz bi"><span id="9cb2" class="oa ko iq mx b gy ob oc l od oe">public void initiateGracefulShutdown() {<br/>    this.isAcceptingNewMessages = false;<br/>}<br/><br/>@Override<br/>public void received(Consumer&lt;byte[]&gt; consumer, Message&lt;byte[]&gt; msg) {<br/>    <em class="kl">log</em>.info(<em class="kl">CONSUMER_PREFIX </em>+ "Received, beginning to process ...", msg.getMessageId());<br/><br/>    if (!isAcceptingNewMessages) {<br/>        <em class="kl">log</em>.info(<em class="kl">CONSUMER_PREFIX </em>+ "&gt;&gt;&gt; NOT accepting new messages! Negative acking.", msg.getMessageId());<br/>        consumer.negativeAcknowledge(msg);<br/>        return;<br/>    }</span></pre><p id="9dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到消费者配置，我们只需要在暂停消费者后立即调用<code class="fe mu mv mw mx b">initiateGracefulShutdown</code>:</p><pre class="mf mg mh mi gt nw mx nx ny aw nz bi"><span id="7186" class="oa ko iq mx b gy ob oc l od oe">consumers.forEach(Consumer::pause);<br/><strong class="mx ir">msgListener.initiateGracefulShutdown();</strong><em class="kl"><br/></em>try {<br/>    TimeUnit.<em class="kl">SECONDS</em>.sleep(shutdownGracePeriodSeconds);<br/>} catch (InterruptedException e) { ... }</span></pre><p id="0968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看会怎样…</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi og"><img src="../Images/c96f90df843a1f13ed556e6bf62027d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAEhuTRKRTNZo02zlBecVw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">接收方队列否定确认的正常关机</figcaption></figure><p id="1243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完美！</p><p id="1cc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到传输中的消息得到了处理，但是接收者队列中的所有剩余消息都得到了否定确认，将它们发送回代理。现在，如果我们重新启动消费者，我们可以看到这些消息(533–537)都被成功处理:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oh"><img src="../Images/4fb42270f831622a8329963525561dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ecrGZo8wFZVvYLpEO8c8g.png"/></div></div></figure><h1 id="d1b4" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="7ea4" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">在其他排队系统中，细节当然会稍有不同，但是作为为队列使用者实现健壮的正常关闭策略的一部分，您将始终需要回答以下问题:</p><ol class=""><li id="0f27" class="lq lr iq jp b jq jr ju jv jy ls kc lt kg lu kk my lw lx ly bi translated"><strong class="jp ir">我们是立即停止处理正在处理的队列消息，还是等待它们完成？</strong></li><li id="53da" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated"><strong class="jp ir">我们是否停止接受新的队列消息？</strong></li><li id="713a" class="lq lr iq jp b jq lz ju ma jy mb kc mc kg md kk my lw lx ly bi translated"><strong class="jp ir">我们如何处理本地排队的消息？</strong></li></ol><p id="3d90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你只是想自己通读代码，这里是回购的链接:</p><p id="2846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://github.com/zachelrath/pulsar-graceful-shutdown-java" rel="noopener ugc nofollow" target="_blank">https://github.com/zachelrath/pulsar-graceful-shutdown-java</a></p></div></div>    
</body>
</html>