<html>
<head>
<title>Build your own AutoML Text Classification using spaCy &amp; Firebase. (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用spaCy &amp; Firebase建立你自己的自动文本分类。(第二部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-your-own-automl-text-classification-using-spacy-firebase-part-2-3cd08e4298da?source=collection_archive---------28-----------------------#2020-06-08">https://levelup.gitconnected.com/build-your-own-automl-text-classification-using-spacy-firebase-part-2-3cd08e4298da?source=collection_archive---------28-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6fee14b1340969573e9b7fddf1b2eec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z2i966AdNLbp6ET6NNpfLQ.jpeg"/></div></div></figure><p id="9d10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是使用spaCy和Firebase等现成组件创建自己的AutoML文本分类器指南的第2部分。在第一部分、<a class="ae kz" href="https://www.linkedin.com/in/andrew-hayes-belfast/" rel="noopener ugc nofollow" target="_blank">和</a>中，我谈到了项目的架构以及如何设置运行项目所需的各种组件。在本文中，我将讨论将各部分粘合在一起所需的关键代码，然后讨论如何部署代码。该项目的完整代码可以在<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/tree/v1.0.0" rel="noopener ugc nofollow" target="_blank">回购</a>中找到，具体分支为“v1.0.0”。我不会检查每一段代码，只检查需要的关键部分。如果您只想部署它，请跳到底部的部署步骤。</p><h1 id="02a1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">关键零件</h1><p id="05d7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">概括地说，要得到一个类似AutoML的文本分类器，需要解决的5个主要问题是:</p><ol class=""><li id="d295" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">上传数据集的能力</li><li id="188e" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">分析数据集注释并将它们显示给用户</li><li id="e6cd" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">在数据集上训练文本分类机器学习模型</li><li id="8720" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">部署模型</li><li id="e2d1" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">告知用户如何使用该模型</li></ol><p id="338d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第1部分中，我提到了可以用来解决这些问题的工具。Firebase(带云存储和云功能)可以解决1、3、5。SpaCy可用于训练模型，从而求解3。最后云构建和云运行相结合解决4。因此，现在我将逐一介绍，向您展示如何使用这些工具来解决这些问题。</p><h1 id="f240" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.上传数据集</h1><p id="b0f8" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Firebase附带了“<a class="ae kz" href="https://firebase.google.com/docs/storage" rel="noopener ugc nofollow" target="_blank"> Firebase Storage </a>”，这是一个谷歌云存储集成。这意味着您可以使用Firebase库来上传数据集。Firebase将处理身份验证、存储桶配置和文件检查。在这个项目中，我设置了规则，只有登录的用户才能上传文件，并且文件必须小于50mb。代码本身取自<a class="ae kz" href="https://firebase.google.com/docs/storage/web/upload-files" rel="noopener ugc nofollow" target="_blank"> Firebase存储上传文档</a>。当用户点击“上传”时，该功能在UI中:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e531" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，它几乎是直接从文档中复制的。它获取用户选择的文件，并要求Firebase存储库上传它。然后，它会要求定期更新上传进度。关键区别在于，它为数据集创建了一个新的Firestore条目，并对“状态”管理做出了一些反应。该文件的完整代码可以在<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/src/components/upload/Upload.js#L58-L122" rel="noopener ugc nofollow" target="_blank">这里</a>找到。需要的另一部分是上传的规则。这就是Firebase如何知道什么是允许的，什么是拒绝的。这是通过更改“storage.rules”文件来实现的。这些规则基于<a class="ae kz" href="https://firebase.google.com/docs/storage/security/start" rel="noopener ugc nofollow" target="_blank"> Firebase安全规则文档</a>。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9494" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">规则相当简单，用户必须登录，文件大小必须小于50mb，文件类型必须是CSV，元数据必须包含所有者的电子邮件地址。有了这些规则，Firebase可以确保上传正确类型的数据，数据不会太大，并且可以将其链接回所有者。这些规则可以在回购<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/storage.rules" rel="noopener ugc nofollow" target="_blank">这里</a>找到。有了这些关键代码片段，你可以允许用户上传他们想要分析的数据集。</p><h1 id="6d5d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.分析数据集注释并显示它们</h1><p id="af55" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在，用户可以上传数据集，你会想用它们做一些有用的事情。在AutoML中，它提取文本上使用的注释和每个注释的统计信息。在回购的<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/sample-data/spam_dataset.csv" rel="noopener ugc nofollow" target="_blank">样本数据</a>中，短信上有‘垃圾’和‘火腿’标注。因此，当用户上传数据集时，您希望显示这些注释的明细。示例:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/e450d26324db58e2c7ca97cad7cc3a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PtyuzrOMIvBW57tiFxkxHw.png"/></div></div></figure><p id="3a66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，您可以看到样本数据注释统计信息已经从数据集中提取出来。为此，您可以利用Firebase云函数触发器，更具体地说，就是Firebase存储<a class="ae kz" href="https://firebase.google.com/docs/functions/gcp-storage-events" rel="noopener ugc nofollow" target="_blank">云函数触发器</a>。为此，需要一个监听最终文件事件的函数。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="02cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦数据集上传完成，这个函数将被自动调用。然后，它会将文件下载到内存中(50mb的大小规则确保它不会使功能崩溃)。一旦下载，它将解析CSV并检查其格式是否正确。然后，它收集注释统计信息，并将它们保存到数据库中。然后可以在UI中向用户显示它们。完整的代码可以在这里找到<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/functions/index.js#L452-L536" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="092f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.在数据集上训练文本分类机器学习模型</h1><p id="ceee" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在是最难的部分，创建文本分类机器学习模型。此时，用户可以上传他们的数据集并查看注释统计，但是他们还不能对数据集做任何有用的事情。幸运的是，spaCy使得创建文本分类模型变得相对容易。<a class="ae kz" href="https://spacy.io/usage/training#textcat" rel="noopener ugc nofollow" target="_blank"> spaCy docs </a>给出了一个很棒的例子来创建一个可以适应我们需求的文本分类器。它利用一个spaCy预训练模型来实现迁移学习，因此我们的新模型只需调整参数即可工作。它还被设计为在CPU上运行，因此可以在云构建环境中运行。两者结合起来将节省大量的时间和精力。<a class="ae kz" href="https://spacy.io/usage/training#textcat" rel="noopener ugc nofollow" target="_blank"> spaCy docs </a>中的例子是将IMDB评论分为“正面”或“负面”，然而，只需稍作调整，它就可以变得更加通用。只需稍作修改，它就可以加载数据并基于数据集动态生成标签，而不是硬编码。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0b1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码将读入数据集，解析出标签和文本数据。然后将它们分成训练集和测试集。然后这些可以被传递到spaCy文本分类管道来训练它。一旦完成训练，它会将新的空间模型保存到磁盘，以便在其他地方重用。其代码与spaCy示例中的代码几乎相同:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8e35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">训练模型的完整代码可以在<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/containers/classifier/create_model.py" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="2e7d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.部署模型</h1><p id="8f96" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">创建机器学习模型只是成功的一半，实际机器学习中经常被忽略的一部分是部署该模型以便可以使用。使用修改后的空间代码能够创建模型，那么可以用什么来部署它呢？</p><p id="04f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是您将利用云构建和云运行的地方。Cloud Run是一个以无服务器方式运行容器的工具。这意味着您可以给云运行一个容器，它将为您部署该容器并负责确认管理。所以你需要做的就是把spaCy代码创建的文本分类模型放到一个容器中，交给Cloud Run，剩下的事情就交给它了。这样做的方法相当简单，您创建一个运行模型训练代码的Docker文件，代码输出模型，Docker将模型打包到一个容器中供云运行。docker文件如下所示:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="64c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个文档分为两部分。第一部分接受数据集的URL并下载它。然后它调用模型训练空间代码。该代码使用数据集对模型进行定型并保存它。第二部分采用经过训练的模型，并将其包装在一个简单的HTTP web服务器中。这允许Cloud Run部署和调用容器。可以在报告<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/containers/classifier/Dockerfile" rel="noopener ugc nofollow" target="_blank">这里</a>找到Dockerfile文件。</p><p id="0ce6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然可以将模型构建到容器中，那么就可以使用Cloud Build将其部署到Cloud Run。为了让云构建工作，需要一个构建配置来告诉it从哪里获取代码以及构建它需要哪些步骤。在这种情况下，它将从链接到GitHub存储库的源存储库中获取代码。那么构建代码的步骤如下:</p><ol class=""><li id="f2f9" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">接受数据集的URL，并将其传递给Dockerfile。然后使用docker文件创建一个包含文本分类模型的容器。</li><li id="c7b0" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">将容器上传到容器注册表，以便Cloud Run可以部署它。</li><li id="7729" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">告诉Cloud Run使用新创建的容器部署服务。</li></ol><p id="87fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用于此目的的云构建配置JSON如下所示:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="281d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一个问题是如何让这个配置进入云构建，因为它通常是通过静态构建触发器来完成的。最简单的方法是使用云构建API。恼人的是，以这种方式触发构建的文档很少。然而，它可以使用谷歌API客户端完成，只需将上面的配置发布到API，完整的代码可以在回购<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/functions/index.js#L313-L451" rel="noopener ugc nofollow" target="_blank">这里</a>找到。为了使用户能够利用这一点，对API的调用被放在一个<a class="ae kz" href="https://firebase.google.com/docs/functions/callable" rel="noopener ugc nofollow" target="_blank"> Firebase可调用函数</a>中。这意味着Firebase将代码部署为云函数，但允许在UI中调用它，就像它是本地函数一样。在UI中，事情就像这样简单:</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="55b0" class="nd lb it mz b gy ne nf l ng nh">var train_model = functions.httpsCallable('train_model');<br/>train_model({ datasetID: this.state.datasetID })<br/>.then(() =&gt; {...</span></pre><p id="3ce7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">UI中的完整代码可以在<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/src/components/datasetView/DatasetView.js#L104-L115" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="3933" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，当用户单击“训练模型”按钮时，它将执行以下操作:</p><ol class=""><li id="634b" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">该按钮将调用本地“train_model”函数，该函数又调用“train_model”云函数。</li><li id="3ba5" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">云函数获取数据集，生成一个URL并将其传递给云构建API。</li><li id="0546" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">Cloud Build创建一个容器，从URL下载数据集并训练文本分类模型。</li><li id="7458" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">然后，模型被包装在容器中的web服务器中，容器被存储。</li><li id="3d4f" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">然后，Cloud Build告诉Cloud Run部署新创建的容器。</li><li id="ad51" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">模型部署完毕！</li></ol><h1 id="198e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.告知用户如何使用该模型</h1><p id="f330" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">所有这一切的最后一步是通知用户如何利用部署的模型。谢天谢地，GCP让这变得相当容易。每当云构建完成时，它都会向“云构建”<a class="ae kz" href="https://cloud.google.com/pubsub/docs/" rel="noopener ugc nofollow" target="_blank">发布/订阅</a>主题发送一条消息。因此，您所要做的就是创建一个云函数，该函数监听有关“云构建”主题的消息，并在部署完成时将详细信息记录到Firestore DB中。例如:</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="265e" class="nd lb it mz b gy ne nf l ng nh">exports.build_updated = functions.pubsub.topic('cloud-builds').onPublish((message) =&gt; {<br/>   const buildMessage = message.json ? message.json : undefined;<br/>   console.log(buildMessage);</span></pre><p id="ff15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当云构建完成时，这个云函数将被自动调用。在其中，您可以解析已经完成的构建的详细信息。使用这些细节，您可以获得新部署模型的云运行URL，并将其保存到DB。然后，用户可以使用该URL来利用他们的模型。做所有这些的完整代码可以在回购<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/functions/index.js#L32-L117" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="2b5c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">部署</h1><p id="754c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在是有趣的部分！部署代码以便您可以使用它！幸运的是，Firebase让这变得简单，我知道这很令人震惊。如果您已经完成了第1部分中的所有配置步骤，那么只需要再部署几个步骤。</p><p id="c46a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一部分是将Firebase项目的API键复制到代码中。可以通过进入<a class="ae kz" href="https://console.firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase控制台</a>并导航到项目设置来访问密钥。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/9b21407b2f280eed4a3ece56a5ec69a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PY_xXocVydVkRYSclLsyXA.png"/></div></div></figure><p id="3704" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">向下滚动并选择“配置”单选按钮:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/23342c8fca49add046842128551c1d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_4EoiklhptHggA3btIdUg.png"/></div></div></figure><p id="bb9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将显示一段带有Firebase API配置的代码，复制它并替换代码<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/src/components/fire.js#L4-L13" rel="noopener ugc nofollow" target="_blank">中的配置。之后，你需要在</a><a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/functions/index.js#L13-L15" rel="noopener ugc nofollow" target="_blank">这里</a>找到的云函数文件中用你自己的项目ID、库名和区域替换项目ID、库名和区域。(如果地区不同，您还需要在这里更新<a class="ae kz" href="https://github.com/Andrew-Hayes/diy-auto-ml-with-spacy-and-gcp/blob/v1.0.0/diy-auto-ml-ui/src/components/fire.js#L28" rel="noopener ugc nofollow" target="_blank">。)</a></p><p id="ffdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">文件更新后，导航至repo目录</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="a9bd" class="nd lb it mz b gy ne nf l ng nh">diy-auto-ml-with-spacy-and-gcp/diy-auto-ml-ui</span></pre><p id="0da0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦有你将需要建立所需的UI文件。您可以通过拨打以下电话来完成此操作:</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="8bef" class="nd lb it mz b gy ne nf l ng nh">npm install<br/>npm run-script build</span></pre><p id="06ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦完成，你可以告诉Firebase部署，它会处理剩下的。</p><pre class="mr ms mt mu gt my mz na nb aw nc bi"><span id="f9bc" class="nd lb it mz b gy ne nf l ng nh">firebase deploy</span></pre><p id="742d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成后，它会告诉您新web UI的URL，您可以导航到那里并开始训练模型！</p><p id="209b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nk">注意:有时部署会失败，但是，如果您再次运行“firebase deploy ”,通常会解决问题。</em></p><h1 id="45e7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">看看它的实际效果</h1><p id="8347" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面是一些展示DIY AutoML运行的截图:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/72483c83b189f7fe2d424ea4b0bb596b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3IBtNIWzH5TmfDsNQNVDQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">数据集表</figcaption></figure><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/6bafe331fe269090255fa0750b231f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ao1HNjNetkEPuJFaG8EwMA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">模型定型时的数据集详细信息页</figcaption></figure><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/7fedb00491912c3db1057fb11bcab6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H37s6riQQ_sEpYjvXM8OJA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">数据集模型评估页面</figcaption></figure><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/2c04c36546750f51a8153b127892afd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ir-rxzyakVrI_GXAPhCMQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">模型测试页面</figcaption></figure><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/bdc56f34c1c7693b1cd049a347525211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oR_yAgVMmXF3tol7tY0HVQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">模型详细信息页面</figcaption></figure></div></div>    
</body>
</html>