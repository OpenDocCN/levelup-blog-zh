<html>
<head>
<title>Is 10 million times 7 equal to 70 million?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">1000万乘以7等于7000万吗？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/is-10-million-times-7-equal-to-70-million-1fac941af828?source=collection_archive---------21-----------------------#2020-11-02">https://levelup.gitconnected.com/is-10-million-times-7-equal-to-70-million-1fac941af828?source=collection_archive---------21-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a57" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数值计算会导致细微的舍入误差。优秀的程序员必须知道如何避免它们。</h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="0b69" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">考虑以下用C编写的程序:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="1a37" class="lu lv it lq b gy lw lx l ly lz">#include &lt;stdio.h&gt;</span><span id="f22a" class="lu lv it lq b gy ma lx l ly lz">int main() {<br/> float x = 7;<br/> float S = 0;<br/> int i;<br/> for (i = 0; i &lt; 10000000; i++) {<br/>   S += x;<br/> }<br/> printf(“%f\n”, S);<br/>}</span></pre><p id="1109" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">程序将变量S加7一千万次。因此，预期结果是7000万。事实上，编译(没有优化)和运行程序给出了</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="695b" class="lu lv it lq b gy lw lx l ly lz">77603248.000000</span></pre><p id="fff1" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这比以前大了10%以上。惊讶吗？嗯，这是舍入误差的影响，它是由计算机中的数字只能用有限的位数来表示这一事实引起的。事实上，700万和1000万在计算机内存中都是完全可以表示的。那么，为什么结果会如此糟糕呢？</p><h1 id="844c" class="mb lv it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">代表计算机内存中的数字</h1><p id="6475" class="pw-post-body-paragraph kp kq it kr b ks ms ju ku kv mt jx kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">计算机中的数字是用二进制表示的。</p><p id="069c" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这个系统中，任何数都以2为基数表示在位置系统中，因此由<em class="mx"> m </em>位数字(0和1)组成的任何整数都表示数<em class="mx"> x </em>为</p><figure class="ll lm ln lo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi my"><img src="../Images/abcd9a36afd2fdf76614a9a7424d6e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDKF-LCQCcfMbDU-iRxkpA@2x.png"/></div></div></figure><p id="1300" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">其中<em class="mx"> d </em> ᵢ是第<em class="mx"> i </em>位的值(0或1)。例如，在8位计算机中，整数5表示为00000101，即1⨉2 +0⨉2 +1⨉2⁰=4+0+1=5.当然，前导零并不重要。</p><p id="6cb5" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了表示非整数，例如3.14，原则上可以使用相同的符号，唯一的区别是<em class="mx"> i </em>的起始值是负的，并且等于小数点后的位数。比如3.14对应二进制的11.00100011110101110001。事实上，</p><figure class="ll lm ln lo gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ng"><img src="../Images/12b901267f1f1b62d4232a2c0d3a2338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G1NhbntLJRr19Xl72oztLA@2x.png"/></div></div></figure><p id="adc4" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">值得注意的是，上述计算得出的精确数字实际上是3.1400003433。一个基数中的有理数不一定是另一个基数中的有理数(例如，1/10在基数2中是无理数)。这种表示法对计算机来说是不切实际的，因为它需要大量的数字来以足够的精度表示在十进制记数法中只有有限位数的数字。相反，计算机使用IEEE754标准符号。在这个符号中，<em class="mx">浮点数</em>，如他们所称，占用32位。然后用一种以2为基数的<strong class="kr iu">科学符号</strong>来表示数字。在科学记数法中，一个数<em class="mx"> x </em>被写成<em class="mx"> x </em> =y×10ⁿ，其中，通常<em class="mx">y</em>∈【1，10】和<em class="mx"> n </em>被相应地选择。例如，地球到太阳的平均距离是149 597 870 700米，可以写成标准形式的1.49 597 870 700⨉10米。同理，3.1400003433，以2为基数，可以写成1.100100011110101110001⨉2，即写成y×2ⁿ，<em class="mx">y</em>∈【1，2】，<em class="mx"> n </em> =1。使用这种约定，小数点前面的数字总是1，可以去掉。乘以二的幂的数(1.100100011110101110001)称为<strong class="kr iu">尾数</strong>，可以表示为100100011110101110001，省略了前导1。后者被称为<strong class="kr iu">范式</strong>。</p><p id="bd2f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在IEEEE754记数法中，使用第一个比特来表示数字的符号(0表示正)，使用8个比特来表示2的指数(在示例中为<em class="mx"> n= </em> 1 )(即，作为整数，使得<em class="mx">n = m127；m= </em>在我们的例子中是128)和23位来表示其标准形式的尾数。因此，表示我们的数字所需的比特序列如下:0 10000000<strong class="kr iu"/>10010001 11101011 1000100。</p><h1 id="6a76" class="mb lv it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">对问题的剖析</h1><p id="8706" class="pw-post-body-paragraph kp kq it kr b ks ms ju ku kv mt jx kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">将<em class="mx"> x </em>声明为浮点数(float)，编译器将其表示为0 100000001 11000000 00000000000，即(1+1×2⁻ +1×2⁻ )×2 =7。事实上，前导0代表+号。接下来的8位组代表129，而129又对应于2的指数129–127 = 2。其余23位中，只有前两位不为空，对应于功率<em class="mx"/>1和<em class="mx"/>2。加到这些能力上的1隐含在范式中，没有明确表示出来。</p><p id="c6db" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">问题出现在程序做加法的时候。要做到这一点，CPU必须考虑用2的相同幂来表示和中的两项，因为这样，它可以利用乘法的分配特性。</p><p id="c56a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">当S=16 777 222时，它在计算机内存中的表示是0 10010111 000000000 000000000000011。指数是10010111，对应整数151。因此，科学记数法中2的指数是151–127 = 24。那么，s被表示为y×2 ⁴.为了对其求和<em class="mx"> x </em> =7，我们需要将<em class="mx"> x </em>表示为<em class="mx"> z </em> ×2 ⁴，这样CPU就可以对<em class="mx"> y </em>和<em class="mx"> z </em>求和，以获得s的新值。<em class="mx"> x </em>的原始表示为1.11后跟21个零乘以2。为了将其表示为<em class="mx"> z </em> ×2 ⁴，我们需要将尾数的位向右平移22位。结果是一个由21个零后跟数字111组成的数字。在一个32位的数中，没有最后一个1的位置，这就丢失了，事实上，<em class="mx"> x </em> =6，S=16 777 228。</p><p id="2d22" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为了减轻舍入的影响，求和在FPU(浮点单元)中执行，FPU使用80位来表示浮点。16 777 228加7等于16 777 235。不幸的是，当将这个数复制回内存时，FPU会在尾数上加1，以恢复之前的错误，结果是S=16 777 236，即16 777 228 + 8。事实上，加到实际总和上的值是8而不是7。每次连续迭代都会发生同样的情况，并且会多次添加8而不是7。在一种情况下，加到实际总和S上的值确实是11！</p><h1 id="03c8" class="mb lv it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">教训</h1><p id="8a63" class="pw-post-body-paragraph kp kq it kr b ks ms ju ku kv mt jx kx ky mu la lb lc mv le lf lg mw li lj lk im bi translated">用计算机对两个值<em class="mx"> S </em>和<em class="mx"> x </em>求和时，必须注意它们的相对值。如果log₂(S)−log₂(x) ≪ p，其中<em class="mx"> p </em>是用于尾数的位数，那么你不会有任何麻烦。另一方面，如果log₂(S)−log₂(x) ≃ p或更大，那么，很有可能，你会遇到舍入误差，事实上，这可能是严重的。不要盲目地将相差太多的数字相加。同样的，你要时刻注意非常相似的数字的区别。如果这两个数字太接近，它们的差值可能很难表示，甚至可能是零，即使这两个数字是不同的。</p></div></div>    
</body>
</html>