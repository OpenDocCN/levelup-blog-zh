<html>
<head>
<title>Performance Tuning Of Node.js Application With Parallel Execution Step By Step</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逐步并行执行Node.js应用程序的性能调优</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/performance-tuning-of-node-js-application-with-parallel-execution-step-by-step-5954a64ec1ad?source=collection_archive---------2-----------------------#2020-01-20">https://levelup.gitconnected.com/performance-tuning-of-node-js-application-with-parallel-execution-step-by-step-5954a64ec1ad?source=collection_archive---------2-----------------------#2020-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b385" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Javascript技巧</h2><div class=""/><div class=""><h2 id="f10e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用承诺的快速指南。All()和P-Map来提高javascript中多循环异步调用的性能</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/0e9c7ca24ffd43ba5eeb4254e173d6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XtdU6-7TPW_PqO4r"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@willianjusten?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威利安·贾斯登·德·瓦斯康塞洛斯</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="db3b" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated"><strong class="ak">背景</strong></h1><p id="4c6f" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">async/await表达式通常用于处理JavaScript中的异步操作，因为它比callback和then()模式有许多优势。await表达式是以最简单的方式处理异步函数的理想选择。然而，如果处理不当，这种简单性有时也会导致问题。在这里，我想分享我最近从我的一个项目中学到的一个有趣的经验，并展示我们可以从中得出什么样的最佳实践。</p><p id="288e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">故事从一个缓慢但必不可少的过程开始，该过程每30分钟运行一次，从不同的服务收集必要的数据并将其同步到前端客户页面。但是，随着时间的推移，同步过程本身大约需要一个小时才能完成。因此，我们迫切需要解决性能问题。</p><p id="f33e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">经过一些调查和检查日志，找到了如下有问题的代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="59cd" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们可以看到，最有可能的原因是这里有两个循环，外部循环调用API getDeparturePorts来获取端口信息，内部循环使用端口来获取与端口和区域相关的所有航班数据。每个API调用都将通过HTTP请求传递给第三方服务，这肯定会导致网络出现一定的延迟。然而，由于这里典型的await用法，每次我们调用<code class="fe na nb nc nd b">getDeparturePorts()</code>时，我们都必须暂停以遍历<code class="fe na nb nc nd b">queryFlight</code>调用，并按顺序等待它们一个接一个地完成。</p><p id="8367" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，不难想到，如果所有await/async调用都不是当场调用/创建的，而是存储在一个列表中，以后再调用/创建并立即等待，那么所有承诺逐一解决所需的时间将会最小化，只需要最耗时的承诺。为了验证假设，我做了以下实验。</p><h1 id="708d" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">重现问题:用本地代码和更通用的模式模拟问题</h1><h2 id="8cb9" class="ne lg iq bd lh nf ng dn ll nh ni dp lp mg nj nk lr mk nl nm lt mo nn no lv iw bi translated"><strong class="ak">使用Promise和SetTimeout()模拟具有网络延迟的APIs】</strong></h2><p id="fce8" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">大多数人都是已经做出的承诺的消费者。然而，在这里我们必须创建我们自己的承诺，在这种情况下，模拟通常需要一些延迟的API调用。(<code class="fe na nb nc nd b"><strong class="lz ja">you can skip this part if you are familiar with Promise/SetTimeout() already,but as a step-by-step tutorial, I'd like to include this.</strong></code>)</p><p id="fea9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们检查一下语法，从头开始创建一个简单的承诺:</p><pre class="kp kq kr ks gt np nd nq nr aw ns bi"><span id="64ea" class="ne lg iq nd b gy nt nu l nv nw">return new Promise(function(resolve, reject) {</span><span id="70a7" class="ne lg iq nd b gy nx nu l nv nw">      // do something about intervalInnerAPICall</span><span id="4e50" class="ne lg iq nd b gy nx nu l nv nw">      resolve(intervalInnerAPICall)</span><span id="35ba" class="ne lg iq nd b gy nx nu l nv nw">});</span></pre><p id="5c42" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在我们需要模拟我们承诺中的网络延迟。在javascript中创建延迟的一个非常典型的方法是使用setTimeout()，但是它不是异步调用。</p><p id="c4fe" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">SetTimeout()接受以下3个参数:</p><ol class=""><li id="a41d" class="ny nz iq lz b ma mt md mu mg oa mk ob mo oc ms od oe of og bi translated">要运行的函数或对别处定义的函数的引用。</li><li id="b356" class="ny nz iq lz b ma oh md oi mg oj mk ok mo ol ms od oe of og bi translated">一个数字，表示在执行代码之前等待的时间间隔，以毫秒为单位(1000毫秒等于1秒)。</li><li id="0b81" class="ny nz iq lz b ma oh md oi mg oj mk ok mo ol ms od oe of og bi translated">值，表示运行时要传递给函数的任何参数。</li></ol><p id="dc29" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">所以现在代码修改为:</p><pre class="kp kq kr ks gt np nd nq nr aw ns bi"><span id="d53e" class="ne lg iq nd b gy nt nu l nv nw">return new Promise(function(resolve, reject) {</span><span id="b528" class="ne lg iq nd b gy nx nu l nv nw">     // after intervalOuterAPICAll seconds, will resolve the value of intervalInnerAPICall and return it as a new promise</span><span id="6f26" class="ne lg iq nd b gy nx nu l nv nw">     setTimeout(resolve, intervalOuterAPICall * 1000, intervalInnerAPICall);</span><span id="ecee" class="ne lg iq nd b gy nx nu l nv nw">});</span></pre><p id="e520" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们添加一些描述作为输出</p><pre class="kp kq kr ks gt np nd nq nr aw ns bi"><span id="b1b1" class="ne lg iq nd b gy nt nu l nv nw">return new Promise(function(resolve, reject) {</span><span id="1f7c" class="ne lg iq nd b gy nx nu l nv nw">    console.log("Func outerAPICall will, after " +  intervalOuterAPICall + "s, send : " + intervalInnerAPICall)</span><span id="f7b3" class="ne lg iq nd b gy nx nu l nv nw">    setTimeout(resolve, intervalOuterAPICall * 1000, intervalInnerAPICall);</span><span id="70c5" class="ne lg iq nd b gy nx nu l nv nw">});</span></pre><p id="fb3e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在，将它放入我们的API调用函数中，并将API调用命名为outerAPICall，这意味着API调用位于第一个/外部循环中。所以现在已经创建了一个名为outerAPICAll的函数来模拟外部循环中远程服务的API调用！</p><p id="530f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">该函数将打印出每个API调用的描述，并在将其特定值传递给内部API调用模拟之前等待特定的时间。完整的代码如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">外部API调用</figcaption></figure><p id="48ae" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">同样，内部API调用如下所示</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">内部API调用</figcaption></figure><h2 id="d518" class="ne lg iq bd lh nf ng dn ll nh ni dp lp mg nj nk lr mk nl nm lt mo nn no lv iw bi translated"><strong class="ak">用我们刚刚嘲笑过的API调用复制这个问题</strong></h2><p id="090b" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">现在我们把它们放在一起，用更高的抽象来模拟我们的问题。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">模拟我们问题的主要代码</figcaption></figure><p id="18f8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">根据我们的代码，我们可以计算出所有的调用，包括内部调用和外部调用，都是按顺序执行的，理论上花费的时间应该是(1+2+3) <em class="om"> *2+2* </em> (1+2+3)=24s</p><p id="3439" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们运行测试，看看我们是否重现了这个问题。</p><pre class="kp kq kr ks gt np nd nq nr aw ns bi"><span id="7ceb" class="ne lg iq nd b gy nt nu l nv nw">node test_sequential.js</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi on"><img src="../Images/570e19e62d0163f9c6ad726685d8bcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ng7nVfrh31xfFFDHBXeaw.jpeg"/></div></div></figure><p id="b96b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">正好24秒，记住数字以后对比。因此，我们为顺序异步调用创建了模拟。现在来看看怎么改进吧。</p><h1 id="505c" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated"><strong class="ak">第一种解决方案:带承诺并行执行。All() </strong></h1><p id="26e7" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><strong class="lz ja">要知道await函数是在用await关键字声明时被当场调用的，这一点很重要，</strong>因此，要延迟函数的运行，一个简单的方法是将带有正确参数的函数存储到一个列表中，并在存储了所有带参数的函数之后使用await函数。</p><pre class="kp kq kr ks gt np nd nq nr aw ns bi"><span id="af82" class="ne lg iq nd b gy nt nu l nv nw">let output = await innerAPICall(j, valueReturnedByOuterAPICall)</span></pre><p id="a420" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">会变成</p><pre class="kp kq kr ks gt np nd nq nr aw ns bi"><span id="4644" class="ne lg iq nd b gy nt nu l nv nw">let innerAPICalls = []<br/>innerAPICalls.push(innerAPICall(j, valueReturnedByOuterAPICall))</span><span id="6ca3" class="ne lg iq nd b gy nx nu l nv nw">// later<br/>await Promise.all(innerAPICalls)</span></pre><p id="8203" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">因此，我们可以对innerAPICalls使用一个片/列表，并将调用放入列表中，但不要对它们使用await。</p><p id="349d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">所以代码变成了</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">with promise.all()</figcaption></figure><p id="0bae" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在，我们终于有了一个innerAPICalls的列表，所以我们可以同时触发它们<strong class="lz ja"/>并等待所有调用返回，完成这个操作所需的时间将等于最耗时的时间——假设在我们的实验案例中，内部调用是3s，加上不可避免的花费在3次外部调用上的时间，总时间预计为3+ 2*(1+2+3) = 15s。</p><p id="c720" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们看看结果</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/2e0e863d83bf7a08ea6a4cea7569d4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TRcLaQ5QP8pGtTbDGJSCw.jpeg"/></div></div></figure><p id="3b6a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">维奥拉。时间从24秒缩短到15秒，这正是我们所期待的！我们很容易知道，实际上，<strong class="lz ja">内环的元素越多，性能的提高就越显著</strong>。</p><h1 id="4286" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated"><strong class="ak">最终解决方案:p-map </strong></h1><p id="9b58" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">然而，我们的解决方案存在一些缺陷。</p><p id="5e46" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">首先，原始行为是继续内部API调用，不管内部循环中单个API调用的任何失败，但是承诺。All()将在第一次失败时返回，并完全放弃所有剩下的调用，因此看起来至少是有希望的。AllSettled()是比承诺更好的选择。全部()在此。</p><p id="bb0c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">第二，在现实世界中，上述解决方案的真正致命问题是服务资源总是有限的。如果列表最终变得如此之长，假设总共有数千个内部API调用，如果所有调用都被同时触发，那么并行API调用的沉重负载将会破坏网络资源和远程服务。显然，我们需要并行运行我们的API调用，但是我们需要将并发的数量控制在我们的服务能够承受的水平。换句话说，我们必须限制并行执行的数量。</p><p id="b906" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">那么怎么做呢？我的答案是<a class="ae le" href="https://www.npmjs.com/package/p-map" rel="noopener ugc nofollow" target="_blank"> p-map </a>，一个用作承诺的npm包。AllSelttled()，但是有一个可配置的并发线程限制。</p><p id="e9ba" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">要使用它，只需运行以下命令来安装它:</p><pre class="kp kq kr ks gt np nd nq nr aw ns bi"><span id="d06e" class="ne lg iq nd b gy nt nu l nv nw">npm install -g p-map</span></pre><p id="1c65" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">P-map需要4个参数，第一个是参数列表，包含用于异步函数的参数，第二个是我们想要运行的函数(在映射器中)，第三个是并发数，第四个是不管任何拒绝是否继续执行，因此在我们的例子中，它被设置为false以确保它将运行所有调用。</p><p id="1f32" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">所以我们必须创建一个列表来存储要传递给innerAPICall函数的参数，并将参数列表作为实函数innerAPICall()的映射器的参数进行传递。完整的代码如下(并发设置为5):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">用p-map重构的代码</figcaption></figure><p id="cff4" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们再来看看结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/242095fc9bdfa346b2f7f333c9d2c182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxEOSFOqMWpCC6CHEYe6Lw.jpeg"/></div></div></figure><p id="a650" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们可以看到它比承诺的要慢。All()方法，但它仍然比我们正常的旧代码快得多。事实上，如果我们将并发设置为1或大于10，我们可以得到与旧代码或承诺完全一样的结果。所有()代码。</p><h1 id="13b2" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated"><strong class="ak">现实世界中的结果</strong></h1><p id="a30f" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我在我们的代码中实现了这个想法，时间从50分钟显著减少到16分钟，在我们的产品系统中并发度为10。多么大的进步啊！</p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><h1 id="393a" class="lf lg iq bd lh li ox lk ll lm oy lo lp kf oz kg lr ki pa kj lt kl pb km lv lw bi translated"><strong class="ak">我们应该学习什么</strong></h1><p id="8067" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">1.在javascript中看到一些多循环操作，内循环等待外循环的输出是很正常的。第一眼看到时，很自然地直接使用await，然后像一段同步代码那样按顺序执行它们。然而，<strong class="lz ja">现在我们应该记住，如果可能的话，所有这种情况实际上都应该转换成并行执行代码。</strong></p><p id="9c20" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">2.保证。所有()在理论上都是好的，但在实践中却很成问题，因为服务的资源是有限的。因此，为了不破坏所有的套接字，我们必须设置并行执行的限制，在这个意义上，p-map是promise.all()的一个非常有效的替代解决方案。</p><p id="bdfa" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">3.为了获得最佳的性能结果、安全性和稳定性，请始终尝试收集函数或收集函数的参数，并在稍后的时间点用await一起声明它们。</p><p id="d823" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">4.这里无法下载<a class="ae le" href="https://github.com/thyxkris/test" rel="noopener ugc nofollow" target="_blank">的源代码。</a></p></div></div>    
</body>
</html>