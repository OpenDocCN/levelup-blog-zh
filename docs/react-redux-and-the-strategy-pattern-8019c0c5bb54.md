# 反应冗余与策略模式

> 原文：<https://levelup.gitconnected.com/react-redux-and-the-strategy-pattern-8019c0c5bb54>

![](img/df7d0ec231ae0a77ea177342322469f0.png)

当我们在大多数 Redux 教程中看到构建 Redux 的例子时，通常我们会看到它们使用`switch`语句，每个动作类型一个`case`语句，就像这样:

典型教程减压器

虽然这相当简单，但也可能有点多，这取决于案例的数量和复杂性。

当然，我们可以通过将逻辑提取到它自己的一组函数中来使它更具可读性，但是我们仍然从下面的案例列表开始:

教程减压器，增强

# 从切换到策略

这种变化可能会使每个案例的逻辑有一个相似的接口:

```
(state, action) => state
```

在这种情况下，我们会根据我们需要做的事情，从众多算法中选择一种来处理状态。我们选择的任何算法都有相同的签名，所以我们可以调用它，而不必知道它实际上做什么。这就是所谓的[战略模式](https://en.wikipedia.org/wiki/Strategy_pattern)。

在开创性的著作*设计模式:可重用面向对象软件的元素中定义，*策略模式让我们以两种方式简化我们的 reducers。首先，它让我们将变形金刚拉入地图，知道地图中的每个元素都以相同的方式调用。这张图向我们展示了我们的行动和它们的算法之间的一一对应关系:

定义为策略的动作算法

我们没有用 case 语句玩缩进反弹游戏，而是有一个简单的键值对映射，在末尾有一个“默认”case，以防我们收到一个这个 reducer 不能处理的动作。(由于我们不关心默认情况下的动作，所以我懒得把它包含在签名里。对于更强类型的语言，如 TypeScript，即使不使用，也可能需要它。)

第二种简化更加明显。减速器本身现在变成这样:

我们的减速器

就是这样。两条线。没有控制逻辑。一个快捷操作符，如果没有与动作类型相关联的转换器，它将为我们提供默认值。如果我们想牺牲可读性，我们可以把它变成一行，但是可读的代码是值得的。

一个地方的所有代码如下所示:

瞧啊。

在 Redux reducer 中使用策略模式可以清晰地分离关注点:

*   动作类型显然与它们请求的状态改变相关联。
*   缩减器代码变得琐碎而容易被遗忘。
*   各个特定于类型的更改被封装在它们自己的函数中，这些函数可以在任何地方定义，包括在复杂情况下从其他文件导入。

# 使用策略创建减速器工厂

我们可以更进一步。如果我们创建多个 reducer 来处理不同的状态片段，我们可以使用一个 reducer 工厂:

我用实际的默认函数替换了 __default__ 键，使它成为一行程序，不需要在提供的映射中定义默认值。可读性到此为止。称之为傲慢吧。

我们的减速器代码变成了:

棒极了。

我们的样板文件现在只有一行。五个字。

其他的一切要么是将我们的动作类型映射到我们的变形金刚，要么是变形金刚本身。我们的 reducers 现在有一个一致的、可读的模式:一个映射、一行样板文件和算法本身。

# 最后的话

这就结束了我们从`switch`到战略的转换。希望这说明了使用一些老派设计模式使我们的代码更具可读性和可插入性的价值。

说到“老派”，你可能已经注意到我比箭头符号更经常使用`function`符号。这在可读性方面有明显的优势，因为函数可以在它的作用域内随时被调用，*甚至在它被定义之前。*箭头函数是表达式，在定义时计算，在定义前不能调用。

通过使用`function`符号，我可以用自顶向下的方式编写代码。首先出现的行为后面出现的行提供了上下文。如果我使用`const`来代替我的函数，我必须在我所有的变形金刚之后定义策略地图。它会被遗忘在页面的底部。相反，在被所有的变形金刚淹没之前，读者会看到给定的动作需要哪个变形金刚。

感谢阅读！