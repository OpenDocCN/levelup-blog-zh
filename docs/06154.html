<html>
<head>
<title>How to Calculate the Fibonacci Sequence in Logarithmic Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何计算对数时间内的斐波那契数列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-calculate-the-fibonacci-sequence-in-logarithmic-time-abde842f5a39?source=collection_archive---------10-----------------------#2020-10-30">https://levelup.gitconnected.com/how-to-calculate-the-fibonacci-sequence-in-logarithmic-time-abde842f5a39?source=collection_archive---------10-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2bff19a6d320849a92ff75726d5c11a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g4xVgskbfXf8Ogd_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">朱莉安娜·马尔他在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="37d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">著名的斐波那契问题的天真解是指数型的，大多数人可以在线性时间内解决它。但是我们能做得更好吗？绝对的。</p><h1 id="a981" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是斐波那契问题？</h1><p id="9a92" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是一个经典的问题，第n项是前两项之和。前两项是1和1。第三个是2，第四个是3，然后是5，8等等。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/0f2ab58c8eac053958a026dfeea1ae7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9Uile1KuElDAZt0uk-KDA.png"/></div></div></figure><h1 id="5086" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一般是怎么解决的？</h1><p id="583f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">最常见的是，人们倾向于使用一个简单的递归解决方案来调用前两项的函数。显然，这是非常低效的，并且以指数时间运行(每个函数调用分支成两个大小为n-1或n-2的独立函数调用)。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="83f9" class="mo lc iq mk b gy mp mq l mr ms">// calculates nth term of fibonacci, 1 indexed<br/>Procedure Fib_Naive(<strong class="mk ir">int</strong> n):<br/>    <strong class="mk ir">if</strong>(n &lt; 3):<br/>        <strong class="mk ir">return</strong> 1;<br/>        end_if<br/>    <strong class="mk ir">return</strong> Fib_Naive(n-1) + Fib_Naive(n-2)<br/>end_Fib_Naive</span></pre><h1 id="73a9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">斐波那契，改进</h1><p id="9020" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个更好的方法是要么用一个递归函数来记忆，要么用一个临时变量来保存前两项。</p><p id="4390" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，我们可以只保留一个<em class="mt"> temp </em>变量，并对其进行迭代编程，这是更可取的，因为递归通常比迭代解决方案耗时更长(这是因为被推送到调用堆栈的调用需要额外的汇编代码指令)。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c4a4" class="mo lc iq mk b gy mp mq l mr ms">// calculates nth term of fibonacci, 1 indexed<br/>Procedure Fib(<strong class="mk ir">int</strong> n):<br/>        <strong class="mk ir">if</strong>(n &lt; 3): <strong class="mk ir">return</strong> 1;</span><span id="e907" class="mo lc iq mk b gy mu mq l mr ms">        <strong class="mk ir">int</strong> prev = 1;<br/>        <strong class="mk ir">int</strong> cur = 1;<br/>        <strong class="mk ir">for</strong> i = 3...n:<br/>            <strong class="mk ir">int</strong> temp = cur;<br/>            cur += prev;<br/>            prev = temp;<br/>        end_for</span><span id="a706" class="mo lc iq mk b gy mu mq l mr ms"><strong class="mk ir">return</strong> cur;<br/>end_Fib</span></pre><h1 id="9db5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一种新方法</h1><p id="0f58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在我们开始之前，让我们考虑一下基本的线性代数，好吗？</p><p id="44a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回想一下单位矩阵，它的对角线设置为1，每隔一个条目设置为0:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b7226309cc99a35e76b87e52c832edf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*LoAro-J_ts9EcoUedDLz5A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一个矩阵乘以一个单位矩阵就是它本身，反过来也是如此如上图。</figcaption></figure><p id="7f98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们交换单位矩阵的两行，并将其乘以另一个矩阵，这相当于交换另一个矩阵的相同两行:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1eff053deeee47580424a2f5a8686a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*q6BBNl7Kp_x3j-LlK04iHQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这个矩阵称为置换矩阵(中间)</figcaption></figure><p id="25d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在假设我们在上面的置换矩阵的右下角条目上加一个1，然后乘以一个2x1向量(a，b)。会发生什么？根据矩阵乘法的规则，这将交换前两行，并将结果矩阵的最底部条目设置为(a+b)。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/983a073233dd1f80f69bdc3a98e5dfad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*rF1zsThWkQ01bxVnHYPRcA.png"/></div></figure><p id="eff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以回到手头的问题上来。还记得我们对斐波那契问题的迭代解法吗？在这个等式中，<em class="mt"> a </em>表示前一个元素(第<em class="mt"> (n-1)个</em>元素)，而<em class="mt"> b </em>表示当前元素。</p><p id="71f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的矩阵乘法方程做的完全一样。</p><p id="8288" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实证明，如果我们将左边的矩阵提升到n次方，并乘以(0，1)，我们将获得斐波那契数列的第n个元素。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/e8fad63f0150b7f4479360deccb01d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*xRU1oezChnIwpzcLyUK0pQ.png"/></div></figure><h1 id="96f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这怎么是对数？</h1><p id="1aac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">两个字:<a class="ae kc" href="https://algorithmist.com/wiki/Repeated_squaring" rel="noopener ugc nofollow" target="_blank">反复平方</a>。而不是把左矩阵乘以n次，我们可以用矩阵乘法的前几个乘积来更快的达到我们的答案。</p><p id="d004" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">矩阵的8次幂可以通过对原始矩阵求平方来计算，然后求平方以获得4次幂，然后再求平方。这比将同一个矩阵相乘8次要快。</p><p id="e0c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们获得以下性能分析:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/00d8beda2e1bff470f42f79f8306d4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*1Zeaj6J9C4qjoLJRVhwFRw.png"/></div></figure><p id="4b7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了减少混乱(因为用代码实现这个可能很棘手)，这里是一个实际的Java实现(不像前面的例子那样是伪代码)。</p><p id="8fd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有任何矩阵，但它仍然利用前面讨论的重复平方来实现我们的对数性能:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c748" class="mo lc iq mk b gy mp mq l mr ms">public int fib(int N) {<br/>        if(N == 0) return 0;<br/>        int[] sol = fibHelp(N);<br/>        <br/>        return sol[1];<br/>    }<br/>    <br/>    public int[] fibHelp(int n) {<br/>        if(n == 1) {<br/>            return new int[] {0,1};<br/>        }<br/>        int m = n/2;<br/>        <br/>        int[] temp = fibHelp(m);<br/>        <br/>        int fPrev = temp[0];<br/>        int fCur = temp[1];<br/>        <br/>        int prev = (fPrev * fPrev) + (fCur * fCur);<br/>        int cur = fCur * (2 * fPrev + fCur);<br/>        int next = prev + cur;<br/>        <br/>        if(n % 2 == 0) { <br/>            return new int[] {prev, cur};<br/>        }<br/>        else {<br/>            return new int[] {cur, next};<br/>        }<br/>    }</span></pre><p id="51d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">*注意:</strong>虽然说我们已经大大减少了计算时间，并且这种实现被广泛接受为对数实现，但我们必须考虑一个问题:算术的时间复杂性。</p><p id="7610" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://hal.archives-ouvertes.fr/hal-02070778" rel="noopener ugc nofollow" target="_blank">已知最快的乘法算法</a>执行速度为O(n log(n))。所以，算术运算的次数在技术上是<em class="mt">而不是承诺的</em>。然而，我们的递归深度是对数的，如下面的代码示例所示。</p></div></div>    
</body>
</html>