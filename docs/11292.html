<html>
<head>
<title>Faster than Pandas : Polars (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比熊猫还快:极地(第一部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deeper-dive-alternatives-to-our-beloved-pandas-polars-part-1-e34d31398006?source=collection_archive---------0-----------------------#2022-03-06">https://levelup.gitconnected.com/deeper-dive-alternatives-to-our-beloved-pandas-polars-part-1-e34d31398006?source=collection_archive---------0-----------------------#2022-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/350fd73c842e5c7404f9bc339849c74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iLsK9wFquf4RZAEe-ZvOw.jpeg"/></div></div></figure><p id="3564" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">熊猫几乎不需要它自己的介绍。它是最常用的数据操作库之一。Pandas是一个快速、强大、灵活且易于使用的开源数据分析和操作工具，构建于Python编程语言之上。</p><p id="0c08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着Pandas在多个方面的不断发展，如可扩展性、字符串类型处理、丢失值的一致处理等，人们仍在努力使它变得更快。人们可以看到<strong class="kd iu"> Numba </strong>加速操作和<strong class="kd iu">火花箭头</strong>兼容性在^1的路线图上</p><p id="67f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，有一种新的包装已经显示出前景。本系列将介绍许多这样的软件包，它们有可能变得更有用、更快、更用户友好。那么，让我们开始吧</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="c385" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的第一个候选人是Polars。<a class="ae lg" href="https://github.com/pola-rs/polars" rel="noopener ugc nofollow" target="_blank">https://github.com/pola-rs/polars</a></p><p id="dc86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Polars是一个非常快速的数据帧库，在Rust中实现，使用Apache Arrow Columnar格式作为内存模型。Polars标榜懒惰/渴望执行，多线程，SIMD，查询优化，强大的表达式API。根据用户指南，^2 <code class="fe lh li lj lk b">Polars</code>完全由<code class="fe lh li lj lk b"><a class="ae lg" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank">Rust</a></code>编写(没有运行时开销！)并使用<code class="fe lh li lj lk b"><a class="ae lg" href="https://arrow.apache.org/" rel="noopener ugc nofollow" target="_blank">Arrow</a></code>—<a class="ae lg" href="https://github.com/jorgecarleitao/arrow2" rel="noopener ugc nofollow" target="_blank">本机arrow2 </a> <code class="fe lh li lj lk b"><a class="ae lg" href="https://github.com/jorgecarleitao/arrow2" rel="noopener ugc nofollow" target="_blank">Rust</a></code> <a class="ae lg" href="https://github.com/jorgecarleitao/arrow2" rel="noopener ugc nofollow" target="_blank">实现</a>——作为其基础，本指南中的示例将主要使用其高级语言绑定。后者仅仅是一个薄薄的包装器，不会提供比核心库更多的功能。</p><p id="a3d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将浏览Polar提供的全套功能，并检查它是否准备好替代真正快速的熊猫！我们将假设我们的分析将在木星环境中进行。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="e360" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">!</strong> python <strong class="lk iu">--</strong>version<br/>Python 3.9.4</span></pre><h1 id="5e94" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">安装和导入polars</h1><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="37ce" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">!</strong> pip install polars<br/><strong class="lk iu">import</strong> polars <strong class="lk iu">as</strong> pl</span></pre><h1 id="f197" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">获取数据</h1><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="97f2" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">!</strong> wget "https://s3.amazonaws.com/nyc-tlc/trip+data/yellow_tripdata_2021-01.csv"</span><span id="d8c3" class="lt lu it lk b gy mw lw l lx ly">--2022-03-06 11:55:29--  <a class="ae lg" href="https://s3.amazonaws.com/nyc-tlc/trip+data/yellow_tripdata_2021-01.csv" rel="noopener ugc nofollow" target="_blank">https://s3.amazonaws.com/nyc-tlc/trip+data/yellow_tripdata_2021-01.csv</a><br/>Resolving s3.amazonaws.com (s3.amazonaws.com)... 52.216.251.190<br/>Connecting to s3.amazonaws.com (s3.amazonaws.com)|52.216.251.190|:443... connected.<br/>HTTP request sent, awaiting response... 200 OK<br/>Length: 125981363 (120M) [text/csv]<br/>Saving to: ‘yellow_tripdata_2021-01.csv.1’</span><span id="bfb6" class="lt lu it lk b gy mw lw l lx ly">yellow_tripdata_202 100%[===================&gt;] 120.14M  24.9MB/s    in 4.9s</span><span id="bc04" class="lt lu it lk b gy mw lw l lx ly">2022-03-06 11:55:34 (24.4 MB/s) - ‘yellow_tripdata_2021-01.csv.1’ saved [125981363/125981363]</span><span id="80d2" class="lt lu it lk b gy mw lw l lx ly"><strong class="lk iu">!</strong> wc <strong class="lk iu">-</strong>l yellow_tripdata_2021<strong class="lk iu">-</strong>01.csv<br/>1369766 yellow_tripdata_2021-01.csv</span></pre><h1 id="39aa" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">让我们用熊猫的方式做事情</h1><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/9188fbbae2d035c081ddbd734fa8e7dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMHA1XmY1yW0VQ_B22h4yQ.jpeg"/></div></div></figure><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="49ac" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">import</strong> pandas <strong class="lk iu">as</strong> pd<br/><strong class="lk iu">import</strong> polars <strong class="lk iu">as</strong> pl<br/><strong class="lk iu">import</strong> datetime</span></pre><p id="724f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将用熊猫作为我们的基准。熊猫read_csv()函数的默认设置可以在<a class="ae lg" href="https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="362d" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">%%</strong>time<br/>data <strong class="lk iu">=</strong> pd.read_csv("yellow_tripdata_2021-01.csv", infer_datetime_format<strong class="lk iu">=True</strong>)</span><span id="7cfd" class="lt lu it lk b gy mw lw l lx ly">CPU times: user 1.26 s, sys: 131 ms, total: 1.39 s<br/>Wall time: 1.41 s</span><span id="8023" class="lt lu it lk b gy mw lw l lx ly">data.dtypes</span><span id="99df" class="lt lu it lk b gy mw lw l lx ly">VendorID                 float64<br/>tpep_pickup_datetime      object<br/>tpep_dropoff_datetime     object<br/>passenger_count          float64<br/>trip_distance            float64<br/>RatecodeID               float64<br/>store_and_fwd_flag        object<br/>PULocationID               int64<br/>DOLocationID               int64<br/>payment_type             float64<br/>fare_amount              float64<br/>extra                    float64<br/>mta_tax                  float64<br/>tip_amount               float64<br/>tolls_amount             float64<br/>improvement_surcharge    float64<br/>total_amount             float64<br/>congestion_surcharge     float64<br/>dtype: object</span></pre><p id="9e75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">熊猫无法推断日期和时间字符串。熊猫将这些领域转化为物体。<strong class="kd iu"> tpep_pickup_datetime </strong>和<strong class="kd iu"> tpep_dropoff_datetime </strong>都应该是日期或者某种形式的日期+时间推断<strong class="kd iu">。</strong>为什么重要？提示:任何对象都将占用更多的内存，并成为未来处理的一大难题。</p><p id="1edb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试着解析日期并实现<em class="my"> strptime。</em>成功了。现在的特征实际上是日期时间64秒，但是一个大但是..</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="63a6" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">%%</strong>time</span><span id="b5fd" class="lt lu it lk b gy mw lw l lx ly">mydateparser <strong class="lk iu">=</strong> <strong class="lk iu">lambda</strong> x: datetime.datetime.strptime(x, '%Y-%m-%d %H:%M:%S')<br/>data <strong class="lk iu">=</strong> pd.read_csv("yellow_tripdata_2021-01.csv", parse_dates<strong class="lk iu">=</strong>['tpep_pickup_datetime','tpep_dropoff_datetime'], date_parser<strong class="lk iu">=</strong>mydateparser)</span><span id="65d6" class="lt lu it lk b gy mw lw l lx ly">display(data.dtypes)<br/>VendorID                        float64<br/>tpep_pickup_datetime     datetime64[ns]<br/>tpep_dropoff_datetime    datetime64[ns]<br/>passenger_count                 float64<br/>trip_distance                   float64<br/>RatecodeID                      float64<br/>store_and_fwd_flag               object<br/>PULocationID                      int64<br/>DOLocationID                      int64<br/>payment_type                    float64<br/>fare_amount                     float64<br/>extra                           float64<br/>mta_tax                         float64<br/>tip_amount                      float64<br/>tolls_amount                    float64<br/>improvement_surcharge           float64<br/>total_amount                    float64<br/>congestion_surcharge            float64<br/>dtype: object</span><span id="3189" class="lt lu it lk b gy mw lw l lx ly">CPU times: user 15.4 s, sys: 212 ms, total: 15.6 s<br/>Wall time: 15.6 s</span></pre><p id="936b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在没有指定数据类型或日期解析器的情况下，读取时间为1.4秒，通过添加对日期列的解析，读取时间缩短到了15.6秒。对于行数为1，369，766的文件来说，这是很长的时间。乌曼..这不是很好..哦，亲爱的熊猫..！</p><h1 id="18d7" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">使用极坐标读取数据</h1><p id="8980" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">有两种主要方法可以将数据读入Polar。</p><ol class=""><li id="5135" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated">Polars.scan_ <format/></li><li id="0078" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">Polars.read_ <format/></li></ol><p id="baf0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Polars可以处理<strong class="kd iu"> csv </strong>、<strong class="kd iu"> ipc </strong>、<strong class="kd iu"> parquet </strong>、<strong class="kd iu"> sql </strong>、<strong class="kd iu"> json </strong>和<strong class="kd iu"> avro </strong>，因此我们覆盖了99%的基础。所以，事不宜迟，让我们读入2021年1月纽约出租车数据的csv文件。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="f8ae" class="lt lu it lk b gy lv lw l lx ly">df <strong class="lk iu">=</strong> pl.scan_csv("yellow_tripdata_2021-01.csv")<br/>display("trying head on the LazyFrame")<br/>display(df.head(n<strong class="lk iu">=</strong>5))</span><span id="7aa3" class="lt lu it lk b gy mw lw l lx ly"><em class="my">naive plan: (run </em><strong class="lk iu"><em class="my">LazyFrame.describe_optimized_plan()</em></strong><em class="my"> to see the optimized plan)</em></span><span id="187c" class="lt lu it lk b gy mw lw l lx ly">CSV SCAN yellow_tripdata_2021–01.csv; PROJECT */18 COLUMNS; SELECTION: NoneSLICE[offset: 0, len: 5]</span></pre><p id="a18d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要记住的一点是，LazyExecution就像一个蓝图。印刷在那里，但并不意味着房屋已经建成。计划不允许实际查看数据，因此我们调用方法<em class="my"> collect()。</em> Naive plan不允许直接使用head()，所以让collect()方法之后再做。</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/a9f88fa0b27e1fc68bfd689947e01c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wydXcf3OWPDnUjCOw_zqWQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">df.collect()。头部(n <strong class="bd ma"> = </strong> 5)</figcaption></figure><p id="1f1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们扫描_csv文件时，该对象是一个懒惰对象。惰性执行允许Polars在执行之前优化工作流。它允许链接操作，而无需将更改提交给内存。但是，懒惰对象没有dtypes！！有人会认为地图应该有理想的数据类型，对吗？好吧，让我们继续。让我们看看什么是允许偷懒的！:)</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/9b340957b95cae4908dffb7673ae2297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xz0izhE0lHtXSza5eRXs5w.jpeg"/></div></div></figure><p id="3b42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以比较懒惰对象和急切执行对象/数据帧的所有方法。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="2e71" class="lt lu it lk b gy lv lw l lx ly"><em class="my"># Following methods are available to the LazyFrame but not to DataFrame</em></span><span id="7812" class="lt lu it lk b gy mw lw l lx ly">set_difference <strong class="lk iu">=</strong> set(dir(df)) <strong class="lk iu">-</strong> set(dir(df.collect()))<br/>list_difference <strong class="lk iu">=</strong> list(set_difference)<br/>list_difference</span><span id="09fd" class="lt lu it lk b gy mw lw l lx ly">['_from_pyldf',<br/> 'cache',<br/> 'map',<br/> 'describe_optimized_plan',<br/> 'describe_plan',<br/> 'scan_parquet',<br/> 'last',<br/> 'collect',<br/> 'reverse',<br/> 'show_graph',<br/> 'inspect',<br/> '_ldf',<br/> 'scan_csv',<br/> 'first',<br/> 'scan_ipc',<br/> 'fetch']</span></pre><p id="4a35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，以下方法适用于Polars数据帧，但不适用于lazy帧</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="98c8" class="lt lu it lk b gy lv lw l lx ly">set_difference <strong class="lk iu">=</strong> set(dir(df.collect())) <strong class="lk iu">-</strong> set(dir(df))<br/>list_difference <strong class="lk iu">=</strong> list(set_difference)<br/>list_difference</span><span id="8d81" class="lt lu it lk b gy mw lw l lx ly">['__getattr__',<br/> '_read_json',<br/> 'width',<br/> '__add__',<br/> 'transpose',<br/> 'is_empty',<br/> 'height',<br/> 'replace',<br/> '__len__',<br/> 'to_csv',<br/> 'to_dummies',<br/> 'to_dicts',<br/> '_read_parquet',<br/> 'to_parquet',<br/> '__copy__',<br/> 'lazy',<br/> '_from_dict',<br/> '__iter__',<br/> 'n_chunks',<br/> '_pos_idx',<br/> 'to_avro',<br/> 'schema',<br/> 'describe',<br/> 'frame_equal',<br/> 'sample',<br/> '_from_records',<br/> 'replace_at_idx',<br/> '__mod__',<br/> 'upsample',<br/> 'fold',<br/> 'to_dict',<br/> 'apply',<br/> 'get_column',<br/> 'hstack',<br/> '__setstate__',<br/> 'to_ipc',<br/> 'shrink_to_fit',<br/> '__setitem__',<br/> 'to_series',<br/> 'row',<br/> 'to_arrow',<br/> '__getstate__',<br/> 'to_json',<br/> '_read_avro',<br/> '_from_dicts',<br/> 'find_idx_by_name',<br/> 'rechunk',<br/> '__getitem__',<br/> '_df',<br/> '__sub__',<br/> 'select_at_idx',<br/> 'insert_at_idx',<br/> 'extend',<br/> '_from_pydf',<br/> '_read_ipc',<br/> 'hash_rows',<br/> '__truediv__',<br/> 'null_count',<br/> 'rows',<br/> '__mul__',<br/> 'to_pandas',<br/> 'shape',<br/> '_from_pandas',<br/> '_from_arrow',<br/> 'vstack',<br/> 'is_duplicated',<br/> 'is_unique',<br/> 'product',<br/> 'pivot',<br/> 'clone',<br/> '__deepcopy__',<br/> 'to_numpy',<br/> 'dtypes',<br/> 'get_columns',<br/> 'drop_in_place',<br/> '_read_csv']</span></pre><p id="9d0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重要的是<strong class="kd iu">模式</strong>和<strong class="kd iu"> dtypes </strong>在LazyFrame中不可用。其他重要的方法还有<strong class="kd iu"> lazyexecute </strong>、<strong class="kd iu"> chunk </strong>，以及一些有帮助的<strong class="kd iu">哈希</strong>、<strong class="kd iu">分组</strong>、<strong class="kd iu">折叠</strong>函数。但是，没有模式和数据类型可能会导致问题。</p><p id="edf1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">人们可以期望能够将LazyFrame转换成DataFrame。如果有错误，那么<strong class="kd iu">模式</strong>或<strong class="kd iu"> dtypes </strong>不可用，因此没有LazyFrames的方法是有意义的，已经被扫描的模式仍然是可用的..让我们进一步挖掘</p><p id="ed67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以让我们来看看这个模式。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="0789" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">%%</strong>time<br/>df <strong class="lk iu">=</strong> pl.scan_csv("yellow_tripdata_2021-01.csv")<br/>df.collect().schema</span><span id="ff7b" class="lt lu it lk b gy mw lw l lx ly">CPU times: user 586 ms, sys: 243 ms, total: 829 ms<br/>Wall time: 348 ms</span><span id="7c00" class="lt lu it lk b gy mw lw l lx ly">{'VendorID': polars.datatypes.Int64,<br/> 'tpep_pickup_datetime': polars.datatypes.Utf8,<br/> 'tpep_dropoff_datetime': polars.datatypes.Utf8,<br/> 'passenger_count': polars.datatypes.Int64,<br/> 'trip_distance': polars.datatypes.Float64,<br/> 'RatecodeID': polars.datatypes.Int64,<br/> 'store_and_fwd_flag': polars.datatypes.Utf8,<br/> 'PULocationID': polars.datatypes.Int64,<br/> 'DOLocationID': polars.datatypes.Int64,<br/> 'payment_type': polars.datatypes.Int64,<br/> 'fare_amount': polars.datatypes.Float64,<br/> 'extra': polars.datatypes.Float64,<br/> 'mta_tax': polars.datatypes.Float64,<br/> 'tip_amount': polars.datatypes.Float64,<br/> 'tolls_amount': polars.datatypes.Float64,<br/> 'improvement_surcharge': polars.datatypes.Float64,<br/> 'total_amount': polars.datatypes.Float64,<br/> 'congestion_surcharge': polars.datatypes.Float64}</span></pre><p id="6ee8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不幸的是，日期字段<strong class="kd iu"> tpep_pickup_datetime </strong>和<strong class="kd iu"> tpep_dropoff_datetime </strong>被读作<strong class="kd iu"> Utf8 </strong>。我们需要解决这个问题。其他地方看起来不错。还有一些其他的方法来减少内存占用，但是我们将在后面检查这些方法。</p><p id="4f4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有，scan_csv用<strong class="kd iu"> collect </strong>在0.35秒内完成了操作！相比之下为1.4秒。</p><h1 id="bfbf" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">让我们再次读取该文件，并尝试修复模式</h1><p id="eb22" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">另一种方法是让Polars做尽可能多的工作来推断数据类型，并显式地确认其余的数据类型。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="3f60" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">%%</strong>time<br/>df <strong class="lk iu">=</strong> pl.scan_csv("yellow_tripdata_2021-01.csv")</span><span id="160d" class="lt lu it lk b gy mw lw l lx ly">df <strong class="lk iu">=</strong> df.with_columns([ pl.col("tpep_pickup_datetime").str.strptime(pl.Datetime, '%Y-%m-%d %H:%M:%S'),<br/>pl.col("tpep_dropoff_datetime").str.strptime(pl.Datetime, '%Y-%m-%d %H:%M:%S')</span><span id="3eaa" class="lt lu it lk b gy mw lw l lx ly">]).collect()</span><span id="34ab" class="lt lu it lk b gy mw lw l lx ly">display(df.schema)</span><span id="2ee9" class="lt lu it lk b gy mw lw l lx ly">{'VendorID': polars.datatypes.Int64,<br/> 'tpep_pickup_datetime': polars.datatypes.Datetime,<br/> 'tpep_dropoff_datetime': polars.datatypes.Datetime,<br/> 'passenger_count': polars.datatypes.Int64,<br/> 'trip_distance': polars.datatypes.Float64,<br/> 'RatecodeID': polars.datatypes.Int64,<br/> 'store_and_fwd_flag': polars.datatypes.Utf8,<br/> 'PULocationID': polars.datatypes.Int64,<br/> 'DOLocationID': polars.datatypes.Int64,<br/> 'payment_type': polars.datatypes.Int64,<br/> 'fare_amount': polars.datatypes.Float64,<br/> 'extra': polars.datatypes.Float64,<br/> 'mta_tax': polars.datatypes.Float64,<br/> 'tip_amount': polars.datatypes.Float64,<br/> 'tolls_amount': polars.datatypes.Float64,<br/> 'improvement_surcharge': polars.datatypes.Float64,<br/> 'total_amount': polars.datatypes.Float64,<br/> 'congestion_surcharge': polars.datatypes.Float64}</span><span id="b4fb" class="lt lu it lk b gy mw lw l lx ly">CPU times: user 1.06 s, sys: 106 ms, total: 1.16 s<br/>Wall time: 452 ms</span></pre><p id="008e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，假设日期是非标准时间戳，我们将无法使用现成的日期解释器。(<strong class="kd iu"> parse_dates() </strong>和<strong class="kd iu">polars . data types . datetime</strong>使用的是由64位有符号整数编码的<strong class="kd iu"> UNIX纪元)</strong></p><h1 id="4b54" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">懒惰的对象会发现一个故意的错误吗？</h1><p id="0009" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">我尝试在读取csv /扫描csv时显式指定dtypes。有趣的事情发生了。scan_csv作为一个懒惰调用执行时没有错误，在我看来这是不应该允许的。扫描应该捕获不兼容的数据类型规范。</p><pre class="ll lm ln lo gt lp lk lq lr aw ls bi"><span id="f138" class="lt lu it lk b gy lv lw l lx ly"><strong class="lk iu">%%</strong>time</span><span id="3c8b" class="lt lu it lk b gy mw lw l lx ly">types<strong class="lk iu">=</strong> {'VendorID': pl.Int64,<br/>'tpep_pickup_datetime': pl.Datetime,<br/>'tpep_dropoff_datetime': pl.Datetime,<br/>'passenger_count': pl.Int64,<br/>'trip_distance': pl.Float64,<br/>'RatecodeID': pl.Int64,<br/>'store_and_fwd_flag': pl.Utf8,<br/>'PULocationID': pl.Int64,<br/>'DOLocationID': pl.Int64,<br/>'payment_type': pl.Int64,<br/>'fare_amount': pl.Float64,<br/>'extra': pl.Float64,<br/>'mta_tax': pl.Float64,<br/>'tip_amount': pl.Float64,<br/>'tolls_amount': pl.Float64,<br/>'improvement_surcharge': pl.Float64,<br/>'total_amount': pl.Float64,<br/>'congestion_surcharge': pl.Float64}</span><span id="b1bd" class="lt lu it lk b gy mw lw l lx ly">df <strong class="lk iu">=</strong> pl.scan_csv("yellow_tripdata_2021-01.csv", dtypes<strong class="lk iu">=</strong>types)<br/>display(df.head(n<strong class="lk iu">=</strong>10))<br/>display(df.collect().dtypes)</span></pre><p id="99cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有在调用执行方法(head()、collect()等)时，才会显示该错误。</p><figure class="ll lm ln lo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/84ac653afff11efe9864a0c8103acc6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2TzZzO1m6jQ4EUNlyuAbw.png"/></div></div></figure><p id="ffbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">旁注:我注意到有些head()调用需要指定df.head(n=10)的行数，而有些时候则不需要。但是除此之外，这个过程像预期的那样工作。</p><h1 id="2fb2" class="lz lu it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">真实使用案例的结论</h1><p id="f825" class="pw-post-body-paragraph kb kc it kd b ke mz kg kh ki na kk kl km nb ko kp kq nc ks kt ku nd kw kx ky im bi translated">最好用<strong class="kd iu"> infer_schema_length=0读入数据。</strong>下一步自然是以可接受的模式dtype()格式操作数据。接下来可以显式指定dtypes()。的确，这是一种普遍接受的方法，适用于所有数据源，但不同之处在于，Polars允许在一个步骤中完成这些操作，而无需在内存中创建对象。</p><p id="958e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不管选择什么选项，阅读速度对Polars来说都是令人印象深刻的。记住Polars。DataFrame与Pandas.DataFrame不同。对于所有的熊猫爱好者来说，总是可以使用<strong class="kd iu"> to_pandas </strong>功能将Polars帧转换成熊猫。提前了解你所拥有的数据并使用适当的方法将会节省大量的时间和可能的内存。</p><p id="7de6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一篇文章中，我将用数据更详细地介绍内存占用，以及如何提高资源消耗。</p><p id="61cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在那之前，继续编码吧！</p><p id="a811" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这篇文章对你有帮助</p><p id="3db9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请通过按下喜欢按钮来分享一些爱。</p><p id="12b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请<a class="ae lg" href="https://ithinkbot.com/membership" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="my">成为会员</em></strong></a><em class="my"/><a class="ae lg" href="https://ithinkbot.com/subscribe" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="my">订阅</em> </strong> </a>获取更多简明教程。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><ol class=""><li id="bc35" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><a class="ae lg" href="https://pandas.pydata.org/docs/development/roadmap.html" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/docs/development/roadmap.html</a></li><li id="7821" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><a class="ae lg" href="https://pola-rs.github.io/polars-book/user-guide/index.html" rel="noopener ugc nofollow" target="_blank">https://pola-rs.github.io/polars-book/user-guide/index.html</a></li></ol></div></div>    
</body>
</html>