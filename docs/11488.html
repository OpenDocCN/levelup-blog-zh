<html>
<head>
<title>Decorator Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">装饰设计模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/decorator-design-pattern-18676c5741a?source=collection_archive---------21-----------------------#2022-03-20">https://levelup.gitconnected.com/decorator-design-pattern-18676c5741a?source=collection_archive---------21-----------------------#2022-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f6d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">装饰器是一种结构设计模式，它允许在现有对象上添加新功能，而不改变其底层结构。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/c114c7fd40795e49fe16e6a24284dbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*xpD08vPjq55XNaC5D6wEmQ.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated"><a class="ae kx" href="https://www.flaticon.com/free-icons/brush" rel="noopener ugc nofollow" target="_blank">由Freepik-flat icon创建的画笔图标</a></figcaption></figure><h1 id="62b3" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">优势</h1><ul class=""><li id="d0e3" class="lw lx iq jp b jq ly ju lz jy ma kc mb kg mc kk md me mf mg bi translated">一个对象的行为可以在没有大的继承树的情况下被扩展。</li><li id="f5dd" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">附加功能可以很容易地添加或删除。这种功能也可以组合。</li><li id="f7ad" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">避免了创造一个<em class="mm">神的对象</em>。额外的功能和责任(想想SRP)可以从具体的对象中分离出来。</li></ul><h1 id="d037" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python实现</h1><p id="51e5" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">下面的例子展示了装饰者如何从一个假想的菜单中添加额外的食物。</p><h2 id="5563" class="mq kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">首先是一些进口</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">__future__的注释允许在类的定义中对类进行类型提示。</figcaption></figure><h2 id="4fb0" class="mq kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">连接</h2><p id="0908" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">定义需要由具体对象、基本装饰者和装饰者实现的共享功能。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="2828" class="mq kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">具体对象</h2><p id="288d" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">实现基本行为，可以使用decorators扩展。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="2970" class="mq kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">基础装饰工</h2><p id="2890" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">将所有操作委托给包装的组件(可以是具体的对象或另一个装饰器)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="cb84" class="mq kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">装修工</h2><p id="b96a" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">实现附加功能。在被包装的组件之前执行它们的行为。包装组件的行为由基本装饰器执行。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">并非所有的功能都需要扩展。</figcaption></figure><h2 id="9e61" class="mq kz iq bd la mr ms dn le mt mu dp li jy mv mw lm kc mx my lq kg mz na lu nb bi translated">添加附加功能</h2><p id="121b" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">装饰设计模式的好处在这里可以真正看到。基本装饰器可以与具体对象和其他装饰器一起使用，因为它们都是从IFood接口派生的。这使得生菜和培根装饰，很容易结合，或删除任何顺序，在任何时候。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="c12d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">何时使用</h1><ul class=""><li id="5368" class="lw lx iq jp b jq ly ju lz jy ma kc mb kg mc kk md me mf mg bi translated">需要向现有对象添加额外的功能，而不改变基本实现。</li><li id="7193" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">您希望避免给现有对象增加额外的责任。</li><li id="351b" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">当需要添加许多不同的附加功能，并且您希望避免创建一个大的继承树时。</li></ul><h1 id="998e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么不只是…</h1><p id="e137" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">…从具体的burger对象继承，然后覆盖并调用那里的父对象？您将无法轻松灵活地组合附加功能。您最终会将所有功能紧密耦合在一起，创建一个大的继承树。</p><p id="3847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…从装饰器调用被装饰的对象，而不使用基本装饰器？这给所有装饰者增加了额外的重复责任。这应该被提取(连同任何其他共享功能)到基本装饰器中。</p><h1 id="0afa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">不足之处</h1><ul class=""><li id="eaab" class="lw lx iq jp b jq ly ju lz jy ma kc mb kg mc kk md me mf mg bi translated">需要为每个单独的附加功能创建一个单独的对象。</li><li id="f925" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">更难调试，因为decorators可以以任何顺序组合。</li></ul></div></div>    
</body>
</html>