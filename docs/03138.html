<html>
<head>
<title>When Shouldn’t we Use Async/Await to Run Multiple Promises?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候不应该使用Async/Await运行多个承诺？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-shouldnt-we-use-async-await-to-run-multiple-promises-a2de85ddb925?source=collection_archive---------12-----------------------#2020-04-21">https://levelup.gitconnected.com/when-shouldnt-we-use-async-await-to-run-multiple-promises-a2de85ddb925?source=collection_archive---------12-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ed550edf5006b411e5bc08ece7bcf8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g8YsQj6PqEX-sJ2J"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@matthewhenry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马太·亨利</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="39ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>语法非常适合运行多个承诺。</p><p id="5aa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们看看什么时候我们不应该使用它们，我们应该用什么来代替。</p><h1 id="6825" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么时候应该使用异步和等待？</h1><p id="dc96" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>应该只在我们需要运行连续运行的承诺时使用。</p><p id="4363" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们不应该使用它们。例如，下面是第二个承诺依赖于第一个承诺的结果的情况，因此它们应该按顺序运行:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2e39" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const breedsRes = await fetch('https://dog.ceo/api/breeds/list/all');<br/>  const {<br/>    message<br/>  } = await breedsRes.json();<br/>  const breed = Object.keys(message)[0];</span><span id="d53f" class="mt lj it lh b gy my mv l mw mx">  const imgRes = await fetch(`https://dog.ceo/api/breed/${breed}/images/random`)<br/>  const img = await imgRes.json();<br/>  console.log(img.message);<br/>})();</span></pre><p id="3805" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，第一个请求从Dog API返回品种，然后将结果用于对Dog API的第二个承诺以获取图像。</p><p id="0981" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，使用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>是有意义的，因为我们确实需要等待第一个承诺完成后再继续第二个承诺。</p><p id="442d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">for...await...of</code>循环只是循环形式的<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>。因此，它也在iterable对象中顺序运行承诺。</p><p id="d62a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们做同样的事情，但是<code class="fe le lf lg lh b">for..await...of</code>循环允许我们在循环中连续运行承诺，这在没有外部库的情况下是无法实现的。</p><p id="9c47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们是按顺序运行它们的，所以我们必须等待第一个任务完成，然后第二个任务才开始。因此，等待他们两个完成需要更长的时间。</p><h1 id="2973" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">不相关的承诺不应该使用异步和顺序等待</h1><p id="fcc1" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">另一方面，如果我们正在运行不相关的承诺，我们不应该使用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>，因为我们没有必要在运行下一个之前等待上一个承诺完成。</p><p id="cca6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下代码在一个<code class="fe le lf lg lh b">async</code>函数中运行两个不相关的承诺:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2ea6" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const res = await fetch('https://dog.ceo/api/breeds/image/random')<br/>  const {<br/>    message<br/>  } = await res.json()<br/>  console.log(message);</span><span id="cdb5" class="mt lj it lh b gy my mv l mw mx">const useRes = await fetch('https://randomuser.me/api/')<br/>  const {<br/>    results<br/>  } = await useRes.json()<br/>  console.log(results);<br/>})();</span></pre><p id="3793" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个从Dog API获取一些数据，第二个获取一些随机生成的用户数据。</p><p id="d225" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们互不依赖，因此它们不必依次使用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>。</p><p id="c8c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个请求在普通宽带连接上总共需要510毫秒，在慢速3G连接上需要4秒钟才能完成。</p><p id="c79b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这肯定比应该的要慢，因为我们可以通过并行运行它们来优化，因为它们是不相关的。</p><p id="5fe4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe le lf lg lh b">Promise.all</code>来做，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="29dc" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const [res, userRes] = await Promise.all([<br/>    fetch('https://dog.ceo/api/breeds/image/random'),<br/>    fetch('https://randomuser.me/api/')<br/>  ])<br/>  const [{<br/>    message<br/>  }, results] = await Promise.all([res.json(), userRes.json()]);<br/>  console.log(message, results);<br/>})();</span></pre><p id="3b07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码在正常的宽带连接上运行需要360毫秒，而在使用慢速3G连接时，运行需要3秒钟。</p><p id="c41c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，差异是显著的，并且我们得到了与上一个例子相同的数据，因为这两个承诺不相关。</p><p id="c62c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们决不能把<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>与不相关的承诺连用。</p><p id="35b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该将<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>与<code class="fe le lf lg lh b">Promise.all</code>一起使用，然后将我们的承诺放入传入的数组中。</p><p id="36d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe le lf lg lh b">fetch</code>承诺分组到一个数组中，并将其传递到<code class="fe le lf lg lh b">Promise.all</code>，然后在<code class="fe le lf lg lh b">fetch</code>承诺完成后，我们对<code class="fe le lf lg lh b">json</code>调用做同样的事情。</p><p id="d57c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为<code class="fe le lf lg lh b">json</code>承诺依赖于<code class="fe le lf lg lh b">fetch</code>承诺，而<code class="fe le lf lg lh b">fetch</code>承诺并不相互依赖，<code class="fe le lf lg lh b">json</code>承诺也是独立的。</p><p id="e260" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们使用了<code class="fe le lf lg lh b">Promise.all</code>，我们的代码运行得更快了，同时从使用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>中获得了同样的好处。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/dcc820e7291e8854a6f879e93aa5e1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BBIC97bB7zhOs0vL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@christianbuehner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> christian buehner </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4849" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="8f02" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>来链接依赖于另一个的承诺。</p><p id="c128" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，<code class="fe le lf lg lh b">for...await...of</code>循环也在一个iterable对象中顺序运行承诺。因此，它的行为与<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>相同。</p><p id="08d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在履行不相关的承诺，我们应该同时履行</p><p id="58fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们应该使用<code class="fe le lf lg lh b">Promise.all</code>与<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>并行运行不相关的承诺。</p><p id="8e9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不必等待一个又一个不相关的承诺，造成不必要的等待。</p></div></div>    
</body>
</html>