# 操作系统—调度

> 原文：<https://levelup.gitconnected.com/operating-system-scheduling-fb7dc14b8c0a>

## 仅用 5 分钟了解日程安排

![](img/24c8f80b78e5f909378f43eeaa6066c0.png)

卢卡斯·布拉塞克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

您的计算机每天同时执行成百上千个任务。你有没有想过它是如何稳定有序地处理这么多事情的？

# 什么是排班？

**调度**是决定下一个运行哪个进程并分配资源给它执行任务的过程。我们在讨论调度的时候经常会提到“**上下文切换**”。它是从一个过程到另一个过程的实际切换过程。

## 上下文切换什么时候发生？

下图显示了流程的生命周期。如果你想了解更多关于过程管理的知识，可以看看我以前的文章。

[](/operating-system-process-management-26c73901166) [## 操作系统—流程管理

### 关于过程的基础、中级和高级知识

levelup.gitconnected.com](/operating-system-process-management-26c73901166) ![](img/a2826f71f7734ee9e6e900d64357b30e.png)

流程生命周期

有许多方法可以实现上下文切换:

1.  每当进程进入阻塞/等待状态(wait()/sleep())时
2.  当 POSIX 信号到达时(SIGCHLD)
3.  当中断到达时(击键)
4.  当操作系统调度程序中断并停止进程时(循环调度，优先级循环调度)

## 深入了解上下文切换

你可能想知道**上下文切换**实际上在做什么。

假设一个进程放弃在 CPU 上运行。比如调用 sleep()。

然后，调度程序将选择下一个要运行的进程。

![](img/883f0b13fefc175fdffffd9587823252.png)

备份所有当前上下文

但是，在调度程序能够获得 CPU 的控制权之前，CPU 必须将该进程的所有当前上下文备份到内核空间内存中:

*   当前寄存器值
*   程序计数器(当前程序在代码的哪一行)

![](img/9c1bd0595ebe7ba88e85718eaa838166.png)

从主存储器加载进程上下文

如果调度程序决定调度就绪队列中的另一个进程，该调度程序必须将该进程的上下文从主内存加载到 CPU。

这整个操作被称为“**上下文切换**”。

## 上下文切换开销很大

内核中的直接成本:

*   保存和恢复寄存器等。
*   交换地址空间(昂贵的指令)

间接成本:

*   隐藏物
*   缓冲缓存
*   TLB 失手了

# 什么是进程调度？

调度是必需的，因为计算资源(CPU)的数量是有限的。

当调度程序选择一个进程时，该进程将拥有 CPU，直到:

*   该进程主动等待 I/O
*   进程主动释放 CPU(例如 exit())
*   该过程检测特定类型的中断(例如周期性时钟中断)

古时候叫“**分时**”。现在，所有的系统都是分时的。

对于进程调度，有不同的调度算法。

# 调度算法

## 最短作业优先(SJF)

每当一个新的进程到达系统时，调度程序就会介入并根据剩余的 CPU 需求选择下一个任务。

![](img/70ad77009b6e326d99529458ee5c995b.png)

由于只有一个进程，调度程序将首先处理进程 A

![](img/989c91834071031bdbae11d0bbe68802.png)

调度程序将首先分配 CPU 来处理新进程(进程 B ),因为它需要的资源最少

![](img/f93502f64bf1b71e0d663398e7b67033.png)

在运行进程 B 之后，CPU 将继续处理进程 A

![](img/dcc4a66eabc979a966778a75c72bff02.png)

如果有资源需求较低的新进程(进程 C)出现，CPU 将首先切换到处理它

![](img/20485d2d208fe972cabe3e736c9312a6.png)

运行进程 C 后，CPU 将继续处理进程 A

![](img/b4c8aa7b37f162e04f6ebd2f1b18b27c.png)

现在将忽略进程 D，因为进程 A 需要的资源较少

![](img/c13e58b5fc457049b2770491e2ffd8f0.png)

流程 D 将在流程 A 完成后处理

![](img/17abf7f55620844ecb860c84a4d9b492.png)

完成的

该算法的缺点是上下文切换的次数可能很高，因为**上下文切换是昂贵的**。

## 循环赛

循环调度是抢占式的。

进程作为一个循环队列一个接一个地运行，没有优先级。

*   新进程被添加到就绪队列的尾部
*   新流程的到来不会触发新的选择决策

![](img/c318f4e68a77e2bb641a522c3b32dd5a.png)

每个进程被赋予一个量程 2，即允许执行的时间量

![](img/066e0de27b3d6761cc83bebb4cb645b0.png)

CPU 将首先处理进程 A，并且只处理给定的 quantun

![](img/2831694af7d1dd7e2e02b0ae81328416.png)

在进程 A 用完量程后，调度程序将分配 CPU 来处理下一个进程，即进程 B

每当一个进程的量用完时，该进程就释放 CPU，这就是抢占。

![](img/1f1d4026f3bed2fc1fefa20f8d4efe99.png)

进程 B 将消耗量程

然后，调度程序介入并选择下一个具有非零量程的进程来运行。

![](img/a1e141780a578241638b3912eaf4073f.png)

在进程 BHA 用完量程后，调度程序将分配 CPU 来处理下一个进程，即进程 C

![](img/e91d599b0615e406377d9ae27d51dc2d.png)

在完成进程 C 之后，CPU 将处理进程 D

![](img/1a35060b615373d8acc609fa0eaa73a9.png)

一轮之后，进程的数量被重置

如果系统中的所有进程都用完了量程，它们将被重新充电到初始值。

![](img/3c9b03c867abbefbc4892a442e6b3714.png)

CPU 将处理进程 A

![](img/59cfb3922df500a96a90d0ac79c93525.png)

CPU 已经完成处理进程 B

![](img/11a1bed7313a086a1c01addfba9393a1.png)

同时，进程 A 的数量被重置

![](img/f9f9a061c99a210ea8e3fff24f830d23.png)

完成的

## 优先级调度

一个任务有一个优先级，通常是一个整数。

*   调度程序根据优先级选择下一个进程
*   更高优先级的进程+循环=优先级队列+新进程到达触发新的选择

**静态优先级调度**

![](img/e235683b14fe7679250fd117b3201254.png)

静态优先级调度

当进程被提交到系统时，它们被分配一个固定的优先级。将选择最高优先级的类别。这些任务通常是短暂的，但是重要的

为了防止高优先级任务无限期运行，只有当高优先级类没有任务时，才会调度低优先级类。

**多队列优先级调度**

![](img/228902b40923aa304f16c377a9d0b3cc.png)

多队列优先级调度

它仍然是一个优先级调度程序。但是，在每个优先级，可以部署不同的调度器。优先级可以是静态和动态的混合。

## 后续步骤

如果你正在读这一行，恭喜你！！！你做到了。您已经学习了调度的基础知识和最常见的调度算法。

请随意查看下面关于操作系统的其他文章:

[](https://mattchw.medium.com/overview-of-operating-system-cc3f6f6bb062) [## 操作系统概述

### 操作系统一般是如何工作的？

mattchw.medium.com](https://mattchw.medium.com/overview-of-operating-system-cc3f6f6bb062) 

要了解更多关于我的后端学习路径，请点击这里查看我的旅程:

[](https://mattchw.medium.com/my-backend-developer-learning-journey-%E6%88%91%E7%9A%84%E5%BE%8C%E7%AB%AF%E5%AD%B8%E7%BF%92%E4%B9%8B%E6%97%85-5315fe2fefc2) [## My Backend Developer Learning Journey 我的後端學習之旅

### 毕业一年多了。拥有 2 年以上的前端和后端工作经验…

mattchw.medium.com](https://mattchw.medium.com/my-backend-developer-learning-journey-%E6%88%91%E7%9A%84%E5%BE%8C%E7%AB%AF%E5%AD%B8%E7%BF%92%E4%B9%8B%E6%97%85-5315fe2fefc2)