<html>
<head>
<title>JavaScript Best Practices — Comparison and Old Constructs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—比较和旧结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-comparison-and-old-constructs-dbf68348fa9?source=collection_archive---------14-----------------------#2020-05-11">https://levelup.gitconnected.com/javascript-best-practices-comparison-and-old-constructs-dbf68348fa9?source=collection_archive---------14-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fee5952a2167881146de6385da7238a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xwz3dvhJqxzcN_qS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Gabrielle Costa 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7f33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="1aac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究编写JavaScript代码时的一些最佳实践，包括比较、访问器、对象和循环。</p><h1 id="b99f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">===而且！==都比==和好！=</h1><p id="e670" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">===</code>和<code class="fe mh mi mj mk b">!==</code>省去了我们很多JavaScript类型强制的麻烦。因为使用了<code class="fe mh mi mj mk b">==</code>和<code class="fe mh mi mj mk b">!=</code>进行比较的算法。</p><p id="892c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">==</code>,我们会得到这样的结果:</p><ul class=""><li id="9ee8" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe mh mi mj mk b">[] == false</code></li><li id="d7e0" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe mh mi mj mk b">[] == ![]</code></li><li id="3db3" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe mh mi mj mk b">2 == "02"</code></li></ul><p id="d3ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">全部返回<code class="fe mh mi mj mk b">true</code>。</p><p id="87fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" rel="noopener ugc nofollow" target="_blank">https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3</a>为<code class="fe mh mi mj mk b">==</code>和<code class="fe mh mi mj mk b">!=</code>列出了很多我们必须知道的规则。</p><p id="0496" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，为了避免记住所有这些并避免上面列出的奇怪结果，我们应该使用<code class="fe mh mi mj mk b">===</code>和<code class="fe mh mi mj mk b">!==</code>进行比较。</p><p id="4b92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我们应该避免编写下面的代码:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="bd19" class="nh lf it mk b gy ni nj l nk nl">if (x == 1) {</span><span id="54b3" class="nh lf it mk b gy nm nj l nk nl">}</span></pre><p id="ae23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，写下:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="3567" class="nh lf it mk b gy ni nj l nk nl">if (x === 1) {</span><span id="0a22" class="nh lf it mk b gy nm nj l nk nl">}</span></pre><p id="0b79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他好代码的例子包括:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="b66b" class="nh lf it mk b gy ni nj l nk nl">a === b<br/>foo === true<br/>apple !== 1<br/>value === undefined<br/>typeof foo === 'undefined'<br/>'foo' !== 'bar'</span></pre><h1 id="79b6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将对象文字和类中的访问器对分组</h1><p id="1eec" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">将同一个字段的getters和setters分组在一起是有意义的。它更容易阅读，我们不必在整个代码中寻找它们。</p><p id="2241" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="e6cb" class="nh lf it mk b gy ni nj l nk nl">const obj = {<br/>  get a() {<br/>    return this.val;<br/>  },</span><span id="57c4" class="nh lf it mk b gy nm nj l nk nl">  b: 1,</span><span id="96c9" class="nh lf it mk b gy nm nj l nk nl">  set a(val) {<br/>    this.val = val;<br/>  }<br/>}</span></pre><p id="02e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="e5fd" class="nh lf it mk b gy ni nj l nk nl">class Foo {<br/>  get a() {<br/>    return this.val;<br/>  }</span><span id="c6c3" class="nh lf it mk b gy nm nj l nk nl">  b() {<br/>    return 1;<br/>  }</span><span id="6f2c" class="nh lf it mk b gy nm nj l nk nl">  set a(val) {<br/>    this.val = val;<br/>  }<br/>}</span></pre><p id="b996" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该改为写:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="3494" class="nh lf it mk b gy ni nj l nk nl">const obj = {<br/>  get a() {<br/>    return this.val;<br/>  },</span><span id="afcb" class="nh lf it mk b gy nm nj l nk nl">  set a(val) {<br/>    this.val = val;<br/>  },</span><span id="5561" class="nh lf it mk b gy nm nj l nk nl">  b: 1,<br/>}</span></pre><p id="381f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="0712" class="nh lf it mk b gy ni nj l nk nl">class Foo {<br/>  get a() {<br/>    return this.val;<br/>  }</span><span id="cf94" class="nh lf it mk b gy nm nj l nk nl">  set a(val) {<br/>    this.val = val;<br/>  }</span><span id="814a" class="nh lf it mk b gy nm nj l nk nl">  b() {<br/>    return 1;<br/>  }<br/>}</span></pre><h1 id="97a8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在for…in循环中检查自己的属性</h1><p id="5946" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">for...in</code> loop循环通过对象自身的属性以及原型链上的属性。</p><p id="60b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将导致意外的项目在循环中循环。</p><p id="0895" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了避免这种情况，我们应该添加一个检查来查看我们是否在遍历一个对象自己的属性，这样我们就不会意外地遍历一个对象原型的属性。</p><p id="461d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，与其写:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="3c42" class="nh lf it mk b gy ni nj l nk nl">for (const key in foo) {<br/>  console.log(foo[key]);<br/>}</span></pre><p id="bb75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该改为编写以下代码:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="b965" class="nh lf it mk b gy ni nj l nk nl">for (const key in foo) {<br/>  if (Object.prototype.hasOwnProperty.call(foo, key)) {<br/>    console.log(foo[key]);<br/>  }<br/>}</span></pre><p id="395f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码也不错:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="e604" class="nh lf it mk b gy ni nj l nk nl">for (const key in foo) {<br/>  if ({}.hasOwnProperty.call(foo, key)) {<br/>    console.log(foo[key]);<br/>  }<br/>}</span></pre><p id="4747" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这两个例子中，我们用<code class="fe mh mi mj mk b">call</code>方法调用<code class="fe mh mi mj mk b">hasOwnPropterty</code>,将<code class="fe mh mi mj mk b">hasOwnProperty</code>中的<code class="fe mh mi mj mk b">this</code>值更改为<code class="fe mh mi mj mk b">foo</code>,并将<code class="fe mh mi mj mk b">key</code>作为第一个参数传递给<code class="fe mh mi mj mk b">hasOwnProperty</code>,这样我们可以检查<code class="fe mh mi mj mk b">key</code>是否在<code class="fe mh mi mj mk b">foo</code>本身中。</p><h1 id="ecd0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">每个文件不要有太多的类</h1><p id="d30c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">每个文件有太多的类会增加阅读和导航的难度。结构也更差。</p><p id="6f11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最好将每个代码文件限制为一个责任。例如，不是写入一个文件:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="caf4" class="nh lf it mk b gy ni nj l nk nl">class Foo {}<br/>class Bar {}</span></pre><p id="7359" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该将它们分成两个文件:</p><p id="ea74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">foo.js</code>:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="5a63" class="nh lf it mk b gy ni nj l nk nl">class Foo {}</span></pre><p id="4d41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">bar.js</code>:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="e266" class="nh lf it mk b gy ni nj l nk nl">class Bar {}</span></pre><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/df027afa68e62542e6cb9d614d89434d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dcWC7RA-hbR2PMN9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@syedabsarahmad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">赛义德·艾哈迈德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2c15" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不允许使用警报</h1><p id="34bc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript的<code class="fe mh mi mj mk b">alert</code>、<code class="fe mh mi mj mk b">confirm</code>和<code class="fe mh mi mj mk b">prompt</code>函数作为UI元素很显眼，应该用模态、对话框或其他不那么显眼的东西来代替。</p><p id="fb83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还经常用于调试代码。因此，我们应该避免使用它们，除非我们真的用它们来提醒用户和询问问题。</p><p id="220e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即便如此，也应该谨慎使用。</p><h1 id="7ab9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mh mi mj mk b">Stop Using arguments.caller</code>和<code class="fe mh mi mj mk b">arguments.callee</code></h1><p id="4458" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">arguments.caller</code>和<code class="fe mh mi mj mk b">arguments.callee</code>使得一些代码优化变得不可能。它们在严格模式下也是被禁止的。</p><p id="afc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们在箭头函数中也不起作用，因为它们没有绑定到<code class="fe mh mi mj mk b">arguments</code>。</p><p id="e094" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果不需要绑定到<code class="fe mh mi mj mk b">this</code>，我们应该使用箭头函数。如果我们需要使用传统的函数，那么我们不应该在函数中引用这两个属性。</p><p id="a986" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="d269" class="nh lf it mk b gy ni nj l nk nl">function foo() {<br/>  var callee = arguments.callee;<br/>}</span></pre><p id="e3f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="1be4" class="nh lf it mk b gy ni nj l nk nl">function foo() {<br/>  var caller = arguments.caller;  <br/>}</span></pre><p id="0a94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会是我们想要避免的坏代码。</p><p id="1bd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种方法是直接引用调用者和被调用者函数。所以<code class="fe mh mi mj mk b">arguments.callee</code>就是<code class="fe mh mi mj mk b">foo</code>。</p><h1 id="55a7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b5e7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该使用<code class="fe mh mi mj mk b">===</code>和<code class="fe mh mi mj mk b">!==</code>进行比较，以避免<code class="fe mh mi mj mk b">==</code>和<code class="fe mh mi mj mk b">!=</code>比较运算符的混淆结果。</p><p id="dd5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用访问器，那么我们应该将相同的值访问器组合在一起。</p><p id="74b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，每个文件的最大类应该是有限的。越少越好。这将任何代码文件限制为一个责任。</p><p id="2ad3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应该尽可能少用警告、确认和弹出提示。</p><p id="fd87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们不应该在传统函数中使用<code class="fe mh mi mj mk b">arguments.caller</code>和<code class="fe mh mi mj mk b">arguments.callee</code>。</p></div></div>    
</body>
</html>