<html>
<head>
<title>Optimization in Python — the Interning Technique for Improved Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的优化——提高性能的内部技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimization-in-python-the-interning-technique-for-improved-performance-3ff14d376176?source=collection_archive---------4-----------------------#2019-12-18">https://levelup.gitconnected.com/optimization-in-python-the-interning-technique-for-improved-performance-3ff14d376176?source=collection_archive---------4-----------------------#2019-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="af67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文探讨了Python的标准实现(CPython)如何使用interning来优化变量赋值和执行内存管理。</p><p id="adb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编程中的实习意味着使用引用来代替相同对象的副本的实践。</p><h2 id="8ea8" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">整数实习</strong></h2><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/60d100a0f0b2b18c8bd69f26573e28c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*UR3HkSN-3UzwqKUqbFnUgA.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated"><strong class="bd kq">图1: Python实习</strong></figcaption></figure><p id="1cae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">启动时，Python会缓存一个范围在[-5，256]内的整数全局列表。每当在该范围内引用一个整数时，Python将使用该对象的缓存版本。因此，如果我们创建两个或更多的变量，并给它们赋一个介于-5和256(包括-5和256)之间的值，Python只在内存中存储该数字一次，并将该内存位置的引用赋给这些变量。Python会自动为我们创建一个共享引用。</p><p id="5a60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们给任意一个整数赋值，而不是范围[-5，256]内的整数，Python会给每个变量分配不同的内存地址，即使被赋值的值是相同的。</p><p id="e3ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，范围[-5，256]内的整数是一个单例对象，这意味着它只被创建一次。</p><p id="b630" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一种优化策略。小整数在代码中出现得更频繁，Python决定缓存一定范围的整数，以便更快地访问最常见的值。显然，它不会缓存太多的值，因为这会产生内存开销。</p><p id="9499" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将通过定义和比较变量来观察这种行为。</p><p id="6fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码导致True，因为我们在循环的每次迭代中用范围[-5，256]内的相同值定义了两个变量<code class="fe lx ly lz ma b">i</code>和<code class="fe lx ly lz ma b">j</code>。它们将有相同的内存地址，表达式<code class="fe lx ly lz ma b">i is j</code>将为真。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/331bb570842a1a4b9963671ea0bfd1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*geabDPa9l07t8I6hdxzjkQ.png"/></div></figure><p id="b576" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的代码导致False，因为我们在循环的每次迭代中定义了两个变量<code class="fe lx ly lz ma b">i</code>和<code class="fe lx ly lz ma b">j</code>，它们的值在范围【257，1000】内相同。它们将具有不同的存储器地址，并且表达式<code class="fe lx ly lz ma b">i is j</code>将导致全部为假。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi mc"><img src="../Images/957c0dc72d2d0a217dd9b61a751806ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxHePUDcGsVYz1-5iF_CRw.png"/></div></div></figure><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi md"><img src="../Images/856930187e462f72dcd3e0632ef9a9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6_4zBs-R7MFCQVJ3J682Q.png"/></div></div></figure><p id="9490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如下面的代码所示，我们如何定义一个值并不重要，最终结果将是一个整数，并使用相同的缓存项。当我们使用四种不同的策略定义<code class="fe lx ly lz ma b">10</code>时，Python仍然为所有变量<code class="fe lx ly lz ma b">a</code>、<code class="fe lx ly lz ma b">b</code>、<code class="fe lx ly lz ma b">c</code>和<code class="fe lx ly lz ma b">d</code>分配相同的内存地址。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi me"><img src="../Images/99175267e020b199d11995270c467cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*DQLaqzp9d1W2tEw_XRPTWg.png"/></div></figure><h2 id="88a4" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">串实习</strong></h2><p id="8de8" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">和整数一样，有些字符串也是Python所固有的，但不是全部！<br/>在编译python代码时，会保留标识符，例如— <br/> ◘变量名<br/> ◘函数名<br/> ◘类名</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi mk"><img src="../Images/818edafba4fee88f4b49dd5fd9d5287a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*FFS-DaVJxmiH_uQeq_ZP3w.png"/></div></div></figure><p id="8d17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些字符串也可以被自动保留，例如，一个看起来像标识符的字符串，例如<code class="fe lx ly lz ma b">‘python_interning’</code>。但是我们不应该指望它，因为python做出这个决定是出于优化的原因，对于不同的Python代码可能是不同的。</p><h2 id="e229" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">Python为什么要用实习？</strong></h2><p id="3967" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">这一切都是为了优化速度和内存。例如，我们想检查两个很长的字符串是否相等。Python可以先对它们进行整型，然后比较它们的内存地址，而不是使用<code class="fe lx ly lz ma b">==</code>操作符逐个字符地比较它们。如果它们被分配到相同的内存地址，这意味着两个字符串是相同的。这样肯定会加快比较的速度。</p><p id="ebaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是并不是所有的字符串都会被Python自动保留。Python提供了一些功能，通过这些功能，我们可以使用<code class="fe lx ly lz ma b">sys.intern()</code>方法来强制保留字符串。</p><h2 id="be06" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated"><strong class="ak">什么时候应该用实习？</strong></h2><p id="1a49" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">我们应该非常合理地使用实习。例如，我们可以在NLP中使用它，在NLP中，我们必须处理大量文本数据，这些文本数据包含大量重复率很高的字符串。当我们对一大组文本数据进行标记时，我们会得到大量出现的单词，如“a”、“the”、“is”。</p><p id="3a9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们假设单词“the”重复了10000次。我们不用为10000次重复中的每一次创建10000个对象，我们可以使用interning来创建一个singleton对象，然后每次出现“the”都指向同一个内存位置。在这种情况下，我们可以使用实习来优化代码性能。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/38787d31a3209eff6d68e56a5e843b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*qPiSWX26eL538j1783gD6Q.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated"><strong class="bd kq">图2:有实习和无实习的执行时间</strong></figcaption></figure><p id="166d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在图2中，我们用等式运算符<code class="fe lx ly lz ma b">==</code>进行比较，它将逐个字符地比较两个字符串，另一方面，我们用等式运算符<code class="fe lx ly lz ma b">is</code>比较它们的内存地址。我们在<code class="fe lx ly lz ma b">compare_with_identity()</code>函数中保留了这两个字符串。如果我们将这种比较运行一百万次，我们可以观察到执行时间的显著差异。</p><p id="4cde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们必须多次执行字符串比较，那么这是使用实习的好要求，但是对于一些比较，实习不会帮助提高性能。因此，除非需要，否则我们应该遵循Python的默认行为。</p></div></div>    
</body>
</html>