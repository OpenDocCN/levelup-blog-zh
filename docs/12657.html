<html>
<head>
<title>Build a Metacritic Web Scraper using NodeJS and Puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NodeJS和Puppeteer构建一个元代码Web Scraper</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-metacritic-web-scraper-using-nodejs-and-puppeteer-a10d8c3630b2?source=collection_archive---------7-----------------------#2022-06-27">https://levelup.gitconnected.com/build-a-metacritic-web-scraper-using-nodejs-and-puppeteer-a10d8c3630b2?source=collection_archive---------7-----------------------#2022-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2fe926422d02f10c0266ce91eb32f2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUgIF5M42cCAARHHL_D8ng.png"/></div></div></figure><h2 id="7506" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h2><p id="45e6" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">这篇文章将是一个交互式教程，我们将使用NodeJS和Puppeteer构建一个web scraper。这个工具将收集关于塞尔达传说系列中视频游戏的关键信息。我们将把收集到的所有信息写入一个CSV文件，因此在本练习结束时，我们将生成一个包含多个网页中所有信息的报告。我们将从Metacritic收集数据，这是一个收集视频游戏、电影、电视节目和音乐评论的网站。</p><h2 id="036d" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是网络抓取，它有什么好处</h2><p id="22c9" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">Web抓取是自动从网站收集数据的过程。数据收集是通过脚本自动完成的，通常来自多个页面，有时来自多个网站，收集的数据随后被导出为对用户最有利的格式。这可以是单个报告或API调用的形式。在我们的示例中，我们将创建一个报告。</p><p id="e5c8" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">Web抓取非常有用，因为自动化数据收集的过程要比人工从一个网页到另一个网页并手动提取和检索他们需要的信息快得多。通常，他们需要持续地(每天、每周、每月)执行这样的任务，在这种情况下，需要做的就是安排脚本运行来收集数据，而不是一次又一次地执行相同的任务。除了我们收集有关视频游戏特许经营权的信息之外，还有其他流行的web抓取用例，包括但不限于:收集股票价格、房地产数据、产品详情、体育统计数据等信息。现在让我们看看我们将如何建立我们的网页抓取器。</p><h2 id="113f" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">构建我们的Web Scraper</h2><p id="c7f3" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">既然我们已经简要介绍了什么是web抓取，为什么您可能想要使用它，以及它的好处是什么，现在让我们来构建我们的Metacritic web scraper。以下项目的Github库可以在这里找到<a class="ae lx" href="https://github.com/mwiginton/metacritic-zelda-webscraper" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="dcdd" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">我们的web scraper的逻辑可以在我们的<code class="fe ly lz ma mb b">index.js</code>文件中找到。让我们从文件的最顶端开始，在这里我们将导入本例中使用的所有包:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">布袋戏网刮刀的进口</figcaption></figure><p id="64fa" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">我们列出的第一个进口产品是<code class="fe ly lz ma mb b">puppeteer</code>包。这是我们用来做网络抓取的包。</p><p id="a098" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">你看到的下一个进口将是<code class="fe ly lz ma mb b">fs</code>包。这是我们将用来将我们的网络抓取结果写入我们的csv报告的包。</p><p id="3c1f" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">您看到的最后一个导入将是<code class="fe ly lz ma mb b">fast-csv</code>包。这个包将与我们的<code class="fe ly lz ma mb b">fs</code>包一起工作，帮助我们将csv数据写入报告。</p><p id="2eb8" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">既然我们已经介绍了使这个工具工作所需的所有包，让我们进入这个脚本的逻辑。</p><p id="a8fc" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">让我们跳到我们的<code class="fe ly lz ma mb b">index.js</code>文件的第73行，在那里我们看到有一个对我们的<code class="fe ly lz ma mb b">scrapeMetacritic()</code>函数的函数调用。这是我们脚本的入口点。让我们进入我们的<code class="fe ly lz ma mb b">scrapeMetacritic()</code>函数。在我们函数的最开始，您会看到下面几行:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="523c" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在这段代码的第一行，我们使用Puppeteer来初始化我们的<code class="fe ly lz ma mb b">browser</code>对象，我们将从web上抓取数据。Chromium浏览器捆绑在Puppeteer包中，这是我们将用于网络抓取的浏览器。你会注意到我们在初始化浏览器时设置的一些参数。参数<code class="fe ly lz ma mb b">headless: false</code>表示我们不希望在运行脚本时隐藏浏览器。通过将这个值设置为<code class="fe ly lz ma mb b">false</code>，当我们运行我们的脚本时，您将实际上能够在浏览器中看到所有正在执行的活动。看到所有的浏览器活动都被自动化是非常酷的！默认情况下，Chromium中的浏览器窗口非常小，很难看到所有内容，所以我们可以用下面的参数<code class="fe ly lz ma mb b">defaultViewport: false</code>来覆盖它。</p><p id="7d43" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在初始化我们的<code class="fe ly lz ma mb b">browser</code>之后，我们使用新初始化的<code class="fe ly lz ma mb b">browser</code>对象来初始化我们的<code class="fe ly lz ma mb b">page</code>对象，代码为<code class="fe ly lz ma mb b">await browser.newPage()</code>。在我们的page对象下面，我们初始化一个空数组<code class="fe ly lz ma mb b">listPageData</code>。这是我们将用于存储关键信息的集合，我们希望从搜索结果页面中提取这些信息，并最终填充我们的最终csv报告。</p><p id="8a0b" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在本例中，您将看到的最后一行是我们导航到想要访问的页面的位置。在我们的例子中，我们希望导航到用户从Metacritic搜索栏中搜索“塞尔达传说”并通过游戏过滤后的页面。<code class="fe ly lz ma mb b">waitUntil: “load”</code>参数表示我们希望在进一步执行任何代码之前等待页面完全加载完毕。</p><pre class="mc md me mf gt mm mb mn mo aw mp bi"><span id="09e7" class="kb kc it mb b gy mq mr l ms mt">await       page.goto('https://www.metacritic.com/search/game/the%20legend%20of%20zelda/results', {waitUntil: "load"});</span></pre><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/831c231fe728ff8db03c59db80f3a985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WkPXt_Hk6IWzVaDluMg9w.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">导航到Metacritic.com，搜索塞尔达传说，并确保你在左侧导航过滤游戏。这样做之后，这将是我们在示例中导航到的URL。</figcaption></figure><p id="f9ba" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在我们的脚本中导航到元符号搜索结果页面后，您会注意到下面一行:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ff7c" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">我们正在初始化的这个<code class="fe ly lz ma mb b">nextButtonVisible</code>变量是我们将用来进入下一页搜索结果的变量。我们可以看到搜索结果包含多个页面。只要“Next”按钮存在并可点击，我们就想继续导航到搜索结果的下一页，继续获取我们的数据。我们通过在木偶师的内置<code class="fe ly lz ma mb b">page.$()</code>函数中搜索下面的选择器并传递查询选择器<code class="fe ly lz ma mb b">span.flipper.next &gt; a &gt; span</code>来搜索可点击的“下一步”按钮的存在。只要这个元素不为空，我们就知道可以继续分页和获取数据。</p><p id="8f8b" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">要找到本例中“Next”按钮的选择器(以及任何其他选择器)，您可以在web浏览器中右键单击该元素并选择“Inspect”选项。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/377453010208596e9fec40e8827f9a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hw1bIfOkCsk-2_SwVZ64CQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">右键单击“下一步”按钮，然后单击“检查”。您将看到生成next按钮的HTML代码。</figcaption></figure><p id="8130" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">右键单击并检查元素后，您需要右键单击下一步按钮的HTML源代码，将鼠标悬停在“复制”上，然后选择“复制选择器”选项。这将为您提供选择器，我们可以使用它在您的木偶脚本中搜索HTML元素。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/6a3ba267cf610918f08eafd7fb4a35bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*sVQWghPpXIGkezVe5w1T3Q.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">右键单击下一步按钮的HTML源代码，选择复制，然后选择复制选择器</figcaption></figure><p id="a8d9" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在声明了检查可点击的“Next”按钮是否存在的<code class="fe ly lz ma mb b">nextButtonVisible</code>变量之后，我们可以进入while循环的逻辑，只要我们能够点击“Next”按钮，这个循环就会继续执行。</p><pre class="mc md me mf gt mm mb mn mo aw mp bi"><span id="3502" class="kb kc it mb b gy mq mr l ms mt">while (nextButtonVisible)</span></pre><p id="c89c" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">我们在while循环体中做的第一件事是等待搜索结果完全加载到页面上。<code class="fe ly lz ma mb b">page.waitForSelector()</code>函数接受一个字符串参数作为查询选择器，我们希望在继续之前等待它。在我们知道结果已经加载之前，我们不想继续尝试收集任何数据。我们在下面一行中执行这个逻辑，等待搜索结果的选择器出现在网页上。您可以像检索“下一步”按钮的选择器一样检索搜索结果的选择器:</p><pre class="mc md me mf gt mm mb mn mo aw mp bi"><span id="ca7a" class="kb kc it mb b gy mq mr l ms mt">await page.waitForSelector('.search_results.module &gt; .result.first_result');</span></pre><p id="62e0" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在等待搜索结果加载完毕后，我们希望捕获所有搜索结果的内容。我们可以通过使用<code class="fe ly lz ma mb b">page.$$()</code>函数来做到这一点，该函数接受一个字符串参数，该参数表示我们所针对的选择器。在我们的例子中，选择器是<code class="fe ly lz ma mb b">‘.search_results.module &gt; .result’</code>，它获取当前页面上的所有搜索结果。我们可以将这些搜索结果存储在我们的<code class="fe ly lz ma mb b">gameResults</code>数组中</p><pre class="mc md me mf gt mm mb mn mo aw mp bi"><span id="4169" class="kb kc it mb b gy mq mr l ms mt">const gameResults = await page.$$('.search_results.module &gt; .result');</span></pre><p id="756b" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">将当前页面的所有结果存储在array中后，我们希望遍历数组中的每个结果。对于数组中的每个元素，我们希望捕获关键信息，用这个关键信息创建一个JSON对象，然后将该对象推送到我们在脚本开始时初始化的<code class="fe ly lz ma mb b">listPageData</code>数组中。<code class="fe ly lz ma mb b">listPageData</code>数组是我们将用来填充最终csv报告的。代码如下所示:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">对于每个列表，捕获关键信息并推送到我们的listPageData数组</figcaption></figure><p id="b0ff" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在上面的循环体中，我们使用<code class="fe ly lz ma mb b">page.evaluate()</code>函数捕获关键信息，该函数接受元素el，然后调用<code class="fe ly lz ma mb b">el.querySelector()</code>函数，该函数接受web元素的查询选择器作为参数。我们希望从这个页面获得的关键信息是<code class="fe ly lz ma mb b">title</code>，它是游戏的标题、<code class="fe ly lz ma mb b">metacriticScore</code>，它是评论家给出的分数，以及<code class="fe ly lz ma mb b">url</code>，它是我们将导航到当前游戏的详细信息页面的url。在<code class="fe ly lz ma mb b">title</code>和<code class="fe ly lz ma mb b">metacriticScore</code>的情况下，我们提取这些元素的<code class="fe ly lz ma mb b">textContent</code>属性。在<code class="fe ly lz ma mb b">url</code>的例子中，因为它是一个链接，所以我们将查询选择器中的<code class="fe ly lz ma mb b">href</code>属性作为目标。在我们提取了这些关键点之后，我们可以将包含这些信息的JSON对象推送到我们的<code class="fe ly lz ma mb b">listPageData</code>数组中。</p><p id="c488" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在我们循环完当前页面上的搜索结果后，我们需要检查是否可以单击导航到下一个页面，或者是否已经到达了搜索结果的末尾。执行此逻辑的代码如下:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">检查是否存在可点击的“下一步”按钮。如果存在，请单击该按钮。如果不存在，将nextButton可见变量设置为false，这样我们就可以结束while循环。</figcaption></figure><p id="3b6f" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在上面的代码片段中，我们首先通过搜索选择器<code class="fe ly lz ma mb b">‘span.flipper.next &gt; a &gt; span’</code>来检查可点击的Next按钮是否存在。如果这样的元素存在并且不是<code class="fe ly lz ma mb b">null</code>，我们知道我们能够继续在搜索结果中分页。我们可以使用<code class="fe ly lz ma mb b">page.click()</code>方法点击下一个按钮，并传递代表下一个按钮的<code class="fe ly lz ma mb b">‘span.flipper.next &gt; a &gt; span’</code>选择器。如果我们在页面上找不到这个元素，我们知道我们已经到达了搜索结果的末尾，我们可以通过将我们的<code class="fe ly lz ma mb b">nextButtonVisible</code>变量设置为<code class="fe ly lz ma mb b">false</code>来退出while循环。</p><p id="c433" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">当我们浏览完搜索结果后，我们希望导航到每个游戏的详细信息页面，以提取关键信息，包括游戏类型以及用户分数。注意，在我写作和从事这个项目的时候，我努力弄清楚如何在我们最初的循环中导航到细节页面和返回到上一页。一个理想的解决方案，会采用这种方法，这是我真正想要完成的。但是我下面的解决方案是我所面临的这个问题的变通方法。随时欢迎任何建议！导航到每个搜索结果的详细信息页面的代码如下:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="52c5" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">这里你可以看到我们在第一个循环中创建的<code class="fe ly lz ma mb b">listPageData</code>数组上循环，它包含了我们当前抓取的信息。对于数组中的每个元素，我们首先获取当前条目的URL:<code class="fe ly lz ma mb b">let url = entry.pageUrl</code>。这将用于导航到当前列表的详细信息页面，我们正在下一行:<code class="fe ly lz ma mb b">await page.evaluate((url)=&gt;{window.location = url}, url)</code>。一旦我们导航到细节页面，我们就等待页面加载，然后尝试进行交互:<code class="fe ly lz ma mb b">await page.waitForSelector(‘body &gt; iframe’)</code>。一旦页面加载完毕，我们初始化一个变量<code class="fe ly lz ma mb b">userScore</code>，来存储用户评分的平均等级。</p><p id="bdb0" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">然后，我们将继续从详细信息页面中捕获我们想要的两个数据点:<code class="fe ly lz ma mb b">userScore</code>和<code class="fe ly lz ma mb b">genre</code>。我们使用常用的<code class="fe ly lz ma mb b">page.evaluate()</code>和<code class="fe ly lz ma mb b">querySelector()</code>函数，并传递这些元素的查询选择器字符串。</p><p id="294f" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">一旦我们有了当前列表的两个关键数据点，我们就想返回并更新我们的<code class="fe ly lz ma mb b">listPageData</code>数组中的适当列表，以包含这些信息。我们通过使用Javascript的内置<code class="fe ly lz ma mb b">Array.filter()</code>函数并返回具有与当前页面的url相匹配的<code class="fe ly lz ma mb b">pageUrl</code>属性的条目来实现。我们找到的元素存储在一个<code class="fe ly lz ma mb b">matchingEntry</code>变量中，返回的类型是一个数组，在本例中只包含一个匹配元素<code class="fe ly lz ma mb b">var matchingEntry = listPageData.filter(function(item) { return item.pageUrl === url; })</code>。</p><p id="5d24" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">一旦我们有了匹配的变量，我们就可以将包含<code class="fe ly lz ma mb b">genre</code>和<code class="fe ly lz ma mb b">userScore</code>的这两个新数据点添加到我们列表中的那个元素。该逻辑的代码如下:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8473" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">一旦我们最终完成了包含我们想要的所有数据的JSON对象列表的构建，我们就可以将这些信息写入最终的CSV报告。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8098" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">在上面的例子中，我们使用<code class="fe ly lz ma mb b">fs</code>包来创建我们的写流<code class="fe ly lz ma mb b">ws</code>以写入我们的csv文件<code class="fe ly lz ma mb b">out.csv</code>。一旦我们打开了写流对象，我们就可以使用我们的<code class="fe ly lz ma mb b">fastcsv</code>库来帮助我们写csv数据。我们使用我们的<code class="fe ly lz ma mb b">listPageData</code>数组来填充我们的报告，并使用数组中键的名称来设置报告中的标题名称，方法是传递下面的参数header:在我们的<code class="fe ly lz ma mb b">fastcsv.write()</code>函数中为true。此操作完成后，您将得到一份最终报告，类似于这样，其中包含我们收集的所有数据:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/3b4242f0d5c3682415d1e0cf28c6fb10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLxkL6t4L0kjnoRo_Y5DPg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">我们收集的所有数据的最终报告。</figcaption></figure><p id="9bf7" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated">最后一步是使用<code class="fe ly lz ma mb b">browser.close()</code>功能关闭我们的浏览器。</p><h2 id="b0a2" class="kb kc it bd kd ke kf dn kg kh ki dp kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h2><p id="5d45" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">感谢您花时间阅读本教程。如果您对需要改进的地方有任何反馈，或者在测试这个实现时遇到任何障碍。请随时联系我，让我知道。我总是乐于接受建设性的反馈，并在过程中帮助解决问题。网络抓取有时也很挑剔，会导致一些不一致的行为。所以，如果你看到任何给你带来麻烦的事情，我很乐意听到，并尽力帮助你。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="2fcc" class="pw-post-body-paragraph kx ky it kz b la ls lc ld le lt lg lh kk lu lj lk ko lv lm ln ks lw lp lq lr im bi translated"><em class="nf">如果你喜欢阅读这篇文章，请考虑使用</em> <a class="ae lx" href="https://medium.com/@michelle.wiginton00/membership" rel="noopener"> <em class="nf">我的推荐链接</em> </a> <em class="nf">注册Medium。这种订阅保证了可以无限制地访问我的文章以及其他许多学科的数千名天才作家的文章。</em></p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="5709" class="ng kc it bd kd nh ni nj kg nk nl nm kj nn no np kn nq nr ns kr nt nu nv kv nw bi translated">分级编码</h1><p id="c7fb" class="pw-post-body-paragraph kx ky it kz b la lb lc ld le lf lg lh kk li lj lk ko ll lm ln ks lo lp lq lr im bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae lx" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae lx" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae lx" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae lx" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="kz iu">升一级正在改造理工大招聘➡️ </strong> <a class="ae lx" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kz iu">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>