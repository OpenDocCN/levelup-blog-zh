<html>
<head>
<title>Secrets and Serverless — managing and deploying secrets with KMS and Secret Manager in Google Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">秘密和无服务器——使用谷歌云中的KMS和秘密管理器管理和部署秘密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/secrets-and-serverless-managing-and-deploying-secrets-with-kms-and-secret-manager-in-google-cloud-8ec3bad0f800?source=collection_archive---------4-----------------------#2020-03-03">https://levelup.gitconnected.com/secrets-and-serverless-managing-and-deploying-secrets-with-kms-and-secret-manager-in-google-cloud-8ec3bad0f800?source=collection_archive---------4-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c09708e39ae6a47ace0560acd0a37002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfDqfepkBRc-BqiQTsf6ww.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">秘密？Shhhhhhhh —原图，来源:<a class="ae kf" href="https://pixabay.com/photos/california-road-highway-hills-210913/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>，作者:<a class="ae kf" href="https://pixabay.com/users/philm1310-752382/" rel="noopener ugc nofollow" target="_blank"> tphilm1310 </a></figcaption></figure><blockquote class="kg kh ki"><p id="d71d" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">我们使用Google App Engine和Cloud Run等无服务器工具来加速当今云饱和世界中web应用程序的开发。</p><p id="9e84" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">然而，从谷歌云平台(GCP)的“安全”方面来看，如何才能将秘密安全地注入到我们的应用程序中呢？我们能在GCP轻松解决这些问题吗？</p></blockquote></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="45b6" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated"><strong class="km iu">“无服务器”</strong>web服务的托管和维护方式发生了巨大的变化。无需担心底层基础设施(如物理服务器、操作系统、网络)，就可以轻松创建web服务。</p><p id="0a70" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">然而，抽象底层基础设施并非没有成本。</p><p id="794b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">以前，当我们在没有服务器的情况下自己管理基础架构时，我们能够直接访问我们的服务器。这使我们能够执行一些壮举，比如将我们自己的过程应用于将配置和机密直接注入到我们的应用程序中(一个简单的例子是在将机密与应用程序代码捆绑在一起以便从部署机器进行部署之前，编写机密检索的脚本)。</p><p id="982e" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">随着“无服务器”的出现，使用相同的工作流向应用程序注入秘密不再有效。首先，您的秘密应该只能从私有机器上访问，并且只能在部署web应用程序时应用到它。这在无服务器的情况下是不可能的，在无服务器的情况下，我们无法在无法访问“服务器”的情况下注入秘密。</p><p id="b0e2" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">有了谷歌云平台(GCP)，上述问题可以用许多不同的方式解决。让我们探索这些方法来解决在无服务器环境中注入秘密的问题。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="89ac" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">迎接“无服务器”</h1><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/abd4387e9aa2f5b94ed36e2e812c444e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkXUV64UcUj93Zmo435Raw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">“嗨，我是无服务器”——修改图片，来源:<a class="ae kf" href="https://pixabay.com/photos/business-card-business-card-man-2056020/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>，作者:<a class="ae kf" href="https://pixabay.com/users/TeroVesalainen-809550/" rel="noopener ugc nofollow" target="_blank"> TeroVersalainen </a></figcaption></figure><p id="f797" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">在我开始与GCP讨论访问秘密之前，我想谈一下无服务器工具和其他相关技术。</p><p id="6a0e" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">对于无服务器工具，我同时使用了<a class="ae kf" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank"> <strong class="km iu">云运行</strong> </a>和<a class="ae kf" href="https://cloud.google.com/appengine/docs/flexible/custom-runtimes/about-custom-runtimes" rel="noopener ugc nofollow" target="_blank"> <strong class="km iu">带自定义运行时的Google App Engine Flex</strong></a>。</p><p id="811a" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">与传统的无服务器工具相比，云运行是一个有趣的工具，在传统的无服务器工具上运行的应用程序可以从Dockerfile文件进行配置。这使得它成为开发人员高度灵活的工具，这种配置可以部署到Cloud Run、Kubernetes甚至直接部署到虚拟机。</p><p id="4548" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">对于谷歌应用引擎来说，它可以在标准的T2版本和灵活的T4版本之间变化，前者的配置选项与平台紧密相关，后者的选项更宽松，与平台的关联更小。在Google App Engine Flex下，有一个使用自定义运行时的选项。与Go、Python或Node等其他运行时选项相比，自定义运行时提供了Dockerfile配置的使用。这允许应用程序开发人员决定与GCP耦合度非常低的运行时，提供了与上面看到的云运行类似的灵活性。</p><p id="676f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">正如我在之前的<a class="ae kf" href="https://medium.com/@weiyuan.liu/keep-your-hands-off-the-servers-going-serverless-with-google-cloud-platform-gcp-and-g-suite-86f5fac0bbc9" rel="noopener">中所描述的，这两种工具之间存在一定的差异。然而，使用多种无服务器工具的目的是探索我们早期问题的某些解决方案是否可以全面应用。</a></p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="c98c" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">那么，我们如何安全地将秘密注入到我们在GCP的无服务器工具中呢</h1><p id="e183" class="pw-post-body-paragraph kj kk it km b kn mu kp kq kr mv kt ku lp mw kx ky lq mx lb lc lr my lf lg lh im bi translated">当使用无服务器工具时，需要注意的一件重要事情是我们不能直接访问我们的服务器！这意味着使用SSH的传统部署方式是不可能的。事实上，有了GCP，你会希望使用<code class="fe mz na nb nc b">gcloud</code> CLI而不是直接访问服务器。</p><p id="88e6" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">例如，我们可以从CLI使用以下命令部署应用程序:</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="b240" class="nh lt it nc b gy ni nj l nk nl"><strong class="nc iu"># Cloud Run</strong></span><span id="1a6a" class="nh lt it nc b gy nm nj l nk nl">gcloud builds submit --tag gcr.io/$PROJECT_ID/$APP:$APP_VER</span><span id="688e" class="nh lt it nc b gy nm nj l nk nl">gcloud run deploy --image gcr.io/$PROJECT_ID/$APP:$APP_VER --allow-unauthenticated --platform="managed" --region="$REGION" $APP</span></pre><p id="818b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi">—</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="6eed" class="nh lt it nc b gy ni nj l nk nl"><strong class="nc iu"># Google App Engine</strong></span><span id="262c" class="nh lt it nc b gy nm nj l nk nl">gcloud app deploy --project $PROJECT_ID</span></pre><p id="da5b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">但是，这些命令没有任何选项允许机密与部署的应用程序一起传递。让我们研究一下如何解决这个问题。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="1b89" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">方法一:将秘密“烘焙”到应用程序中</h1><p id="896a" class="pw-post-body-paragraph kj kk it km b kn mu kp kq kr mv kt ku lp mw kx ky lq mx lb lc lr my lf lg lh im bi translated">我最初探索的方法之一是将秘密直接“烘焙”到应用程序中。对于Google App Engine来说，这是一个简单的方法，在这里，与<a class="ae kf" href="https://cloud.google.com/appengine/docs/flexible/custom-runtimes/configuring-your-app-with-app-yaml" rel="noopener ugc nofollow" target="_blank"> app.yaml </a>在同一个目录中的秘密文件与源代码一起部署。部署应用程序后，可以通过读取这些文件来访问秘密。</p><p id="5d63" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">对于云运行，等同于将秘密文件作为Docker文件指令的一部分复制到Docker映像中。当从映像部署容器时，文件也将存在于环境中。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a5a13e841b3f297473ad8b8487f93212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*BXSitU7E5R35-nSkIN2Xiw.jpeg"/></div></figure><p id="a2ad" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">然而，我觉得这种方法并不是一个好的选择，原因如下:</p><p id="5af6" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">首先，应用程序代码应该没有任何秘密的上下文。这对于回滚尤其重要。假设您最近更新了一个应用程序秘密，随后一个不相关的部署导致了故障率的增加。然而，我们不能在这里执行回滚，因为以前的版本中的秘密已经过时了。</p><p id="bb1b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">这种方法的另一个问题是秘密不再集中在一个位置。如果你使用Cloud Run，你必须意识到你的docker映像注册表在每个版本中都包含这些秘密，并对这些映像应用适当的访问控制。否则，用户仍然可以通过映像访问这些秘密，即使他们无权从您的私人环境中访问这些秘密。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="b76e" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用密钥管理存储增强最后一种方法(KMS)</h1><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/234a0023927df03b1844e1d68891ab41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*UOk2rtDCGU214JUv"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">KMS——原图，来源:<a class="ae kf" href="https://cloud.google.com/kms" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a></figcaption></figure><p id="646b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">我们可以在GCP使用的一个工具是<a class="ae kf" href="https://cloud.google.com/kms/docs" rel="noopener ugc nofollow" target="_blank"> KMS </a>，用来限制对秘密文件的读写操作。KMS允许在本地环境和远程服务器环境中对文件进行加密和解密。如果我们将其与以前的方法进行比较，这种方法将是一种改进。我们可以选择在将文件传递给应用程序构建之前加密文件，然后仅在应用程序启动时在无服务器环境中解密这些文件，而不是将原始机密文件“烘焙”到应用程序中。</p><p id="6434" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">让我们看看如何在我们的GCP项目中使用KMS。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/6e743c9e833c78882c76b9b794f432eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdR5jRHWM9vaY6TUId_zGA.png"/></div></div></figure><p id="a4c9" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">要启用KMS，你必须从GCP的控制台的侧边栏中选择<code class="fe mz na nb nc b">IAM &amp; Admin &gt; Cryptographic keys</code>。然后，选择<code class="fe mz na nb nc b">+ Create Key Ring</code>按钮。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/819a780aad84640936d713bd3c54673f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLMTFG3w5BuoAq1h9nWxag.png"/></div></div></figure><p id="1157" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">从上面，选择戒指的名字以及地区。该名称应与要加密的内容的一般用途一致(注意，您还需要选择“密钥”的名称，并且多个密钥可以与密钥环相关联)。对于区域，如果环的区域与您的无服务器环境不同，这并不重要，但是选择相同的区域应该有助于部署期间的性能。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/d4047226ba60931f9b337c75b71ec446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvAIbDoU6ZU4_fBlZrUfnQ.png"/></div></div></figure><p id="e353" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">一旦你的戒指被创建，点击进入戒指，然后选择<code class="fe mz na nb nc b">+ Create Key</code>选项。设置您的密钥名称，并从上面看到的任何可用选项中进行选择(如果您打算使用Google的管理密钥，上面的默认选项应该足够了)。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/0bfceb8b69d2c30a0c210f67c3321b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZR6Jtbk5MdODde6XRhhqw.png"/></div></div></figure><p id="0621" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">一旦你完成了这个过程，你应该以上面的视图结束。</p><p id="e971" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">我们需要做的下一件事是允许用户和系统使用的服务帐户能够加密和解密秘密文件。</p><p id="0ff5" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">虽然有可能(而且可能更简单！)要通过IAM菜单分配项目范围的授权来加密和解密文件，我想使用不同的方法来限制分配的权限。这是为了确保用户或服务帐户不会被滥用于读取或更改超出其原始目的的其他机密。</p><p id="8de1" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">对于用户帐户，我们希望允许用户能够读写机密。我们可以运行下面的命令(替换下面的所有变量)并分配角色<strong class="km iu">roles/cloudkms . cryptokeyencrpterdecrypter</strong>，以允许用户加密和解密机密文件。</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="8bc0" class="nh lt it nc b gy ni nj l nk nl">gcloud kms keys add-iam-policy-binding ${KEY} --location=${LOCATION} --keyring=${KEY_RING} --member=user:${USER_ACCOUNT} --role=<strong class="nc iu">roles/cloudkms.cryptoKeyEncrypterDecrypter</strong> --project=${PROJECT}</span></pre><p id="d1c0" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">对于系统使用的服务帐户，我们可能希望限制他们只能解密秘密文件，因为他们不应该改变秘密的内容。我们可以通过在启用了<strong class="km iu">角色/cloud kms . cryptokey decrypter</strong>角色的情况下运行以下命令来实现这一点。</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="8054" class="nh lt it nc b gy ni nj l nk nl">gcloud kms keys add-iam-policy-binding ${KEY} --location=${LOCATION} --keyring=${KEY_RING} --member=serviceAccount:${SERVICE_ACCOUNT} --role=<strong class="nc iu">roles/cloudkms.cryptoKeyDecrypter</strong> --project=${PROJECT}</span></pre><p id="1098" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">如上所述，服务帐户可以在您使用的不同无服务器工具之间有所不同。如果您的项目名称为<code class="fe mz na nb nc b">fine-project</code>，id为<code class="fe mz na nb nc b">12345678</code>，则云运行的默认服务帐户为<code class="fe mz na nb nc b">12345678-compute@developer.gserviceaccount.com</code>，App Engine的服务帐户为<code class="fe mz na nb nc b">fine-project@appspot.gserviceaccount.com</code>。如果你不确定你的项目名称和ID，点击查看你的资源经理<a class="ae kf" href="https://console.cloud.google.com/cloud-resource-manager" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2490" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">将权限授予适当的帐户后，我们可以使用以下命令加密和解密我们的秘密文件(同样，在更改项目上下文的变量名之后)</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="8127" class="nh lt it nc b gy ni nj l nk nl"><strong class="nc iu"># Decrypt from ${ENCRYPTED_FILE_NAME} to ${DECRYPTED_FILE_NAME}</strong><br/>gcloud kms decrypt --ciphertext-file=${ENCRYPTED_FILE_NAME} --plaintext-file=${DECRYPTED_FILE_NAME} --key=${KEY} --location=${LOCATION} --keyring=${KEY_RING} --project=${PROJECT}</span><span id="1ad8" class="nh lt it nc b gy nm nj l nk nl"><strong class="nc iu"># Encrypt from ${DECRYPTED_FILE_NAME} to ${ENCRYPTED_FILE_NAME}</strong><br/>gcloud kms encrypt --ciphertext-file=${ENCRYPTED_FILE_NAME} --plaintext-file=${DECRYPTED_FILE_NAME} --key=${KEY} --location=${LOCATION} --keyring=${KEY_RING} --project=${PROJECT}</span></pre><p id="1c9c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">就是这样！我们只需要确保加密我们的秘密文件，然后在启动我们的应用程序之前用上面的命令解密我们的文件，以确保我们的应用程序可以访问秘密。</p><p id="c322" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">KMS是“烘焙”秘密的答案吗？</p><p id="4cd0" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">使用KMS的一个直接好处是随之而来的访问控制。只有某些用户和系统帐户被允许读取和写入加密的秘密文件的内容。这降低了秘密通过docker图像注册表被泄露的可能性。</p><p id="f292" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">然而，我们发现我们无法完全克服与KMS的中央机密问题。加密只帮助保护秘密文件的内容，但对同步文件的内容没有什么帮助。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="8e7b" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用另一种工具保护机密——Secret Manager</h1><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6eaa06b6c15674ad41af0acb60f8b733.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*UiB-XB1GoaefzuwJ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">秘密管理—原图，来源:<a class="ae kf" href="https://cloud.google.com/solutions/secrets-management" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a></figcaption></figure><p id="5b5d" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">“烘焙”秘密方法的另一种选择是仅在部署时提取秘密。要在GCP做到这一点，我们可以求助于它的托管解决方案<a class="ae kf" href="https://cloud.google.com/secret-manager/docs" rel="noopener ugc nofollow" target="_blank"> Secret Manager </a>。</p><p id="46df" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">顾名思义，我们可以使用秘密管理器来管理秘密。这里的管理是指我们可以创建、读取和销毁不同秘密的不同版本。通过使用Secret Manager，我们还可以利用<a class="ae kf" href="https://cloud.google.com/secret-manager/docs/accessing-the-api" rel="noopener ugc nofollow" target="_blank"> API </a>在构建时、部署时，甚至在应用程序运行时提取秘密。这给了我们当我们想要利用我们的应用程序的秘密时的灵活性，避免了将秘密烘焙到应用程序中的需要。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/fffb84769d04875375f36b6974be80ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IOAiB3AtBcJUdrAr94mkw.png"/></div></div></figure><p id="7746" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">要开始使用“Secret Manager ”,从侧边栏中选择<code class="fe mz na nb nc b">Security &gt; Secret Manager</code>,并启用使用它所需的API。选择<code class="fe mz na nb nc b">+ Create Secret</code>选项创建您的第一个秘密！</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/81610a7d7706c44f07606d2b91d8ebd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0joYxOHvlZnh13MgVf9K_g.png"/></div></div></figure><p id="9256" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">为你的秘密选择名字(这很重要！你需要用这个来引用你的秘密。).您也可以直接输入您的秘密值，或上传包含秘密值的文本文件。</p><p id="7648" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">一旦我们创建了我们的秘密，我们需要继续授权我们的系统使用的服务帐户来访问和读取秘密。这种情况与之前KMS的方法非常相似，我们可以应用项目范围的权限，但如果我们想限制不同服务帐户对不同机密的访问，我们就不应该这样做。</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="4e7b" class="nh lt it nc b gy ni nj l nk nl">gcloud secrets add-iam-policy-binding $SECRET_NAME --member=serviceAccount:${SERVICE_ACCOUNT} --role=roles/secretmanager.secretReader --project=${PROJECT}</span></pre><p id="515e" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">为了授权服务帐户访问我们创建的秘密，我们需要运行上面的命令(在用实际值替换变量之后)。</p><p id="4f67" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">请注意，对于服务帐户，它与KMS相同。从上面复制—如果您的项目名称为<code class="fe mz na nb nc b">fine-project</code>，id为<code class="fe mz na nb nc b">12345678</code>，那么云运行的默认服务帐户将为<code class="fe mz na nb nc b">12345678-compute@developer.gserviceaccount.com</code>，App Engine的服务帐户将为<code class="fe mz na nb nc b">fine-project@appspot.gserviceaccount.com</code>。如果你不确定你的项目名称和ID，在这里检查你的资源管理器<a class="ae kf" href="https://console.cloud.google.com/cloud-resource-manager" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a681" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">有了我们的秘密，并且我们的服务帐户能够从无服务器环境中访问我们的秘密，让我们来探索如何检索这些秘密。请注意，我们使用Node.js库来实现上述功能，但对于各种语言也可以这样做，如Go、Ruby和Python，如这里的<a class="ae kf" href="https://cloud.google.com/secret-manager/docs/creating-and-accessing-secrets" rel="noopener ugc nofollow" target="_blank">所示</a>。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="fc10" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">从上面的脚本中，我们观察到使用了两个库，<a class="ae kf" href="https://github.com/googleapis/nodejs-secret-manager" rel="noopener ugc nofollow" target="_blank"> nodejs-secret-manager </a>和<a class="ae kf" href="https://github.com/googleapis/googleapis" rel="noopener ugc nofollow" target="_blank"> googleapis </a>。对于其他语言的模块，请点击查看官方的Github维护者<a class="ae kf" href="https://github.com/googleapis" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="f625" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">这两个库在获取秘密方面有不同的目的。<strong class="km iu"> nodejs-secret-manager </strong>用于检索带有秘密名称的秘密。</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="bc97" class="nh lt it nc b gy ni nj l nk nl">const client = new SecretManagerServiceClient();<br/>const name = await getSecretName('MY SECRET NAME');</span></pre><p id="ea7d" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">请注意，这里的“秘密名称”不仅包括您之前选择的名称，还包括保存您的秘密的<strong class="km iu">项目id </strong>，以及秘密的<strong class="km iu">版本号</strong>。完整的机密名称应该显示为以下格式:</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="5ea5" class="nh lt it nc b gy ni nj l nk nl">projects/<strong class="nc iu">${project-id}</strong>/secrets/<strong class="nc iu">${secret-name}</strong>/versions/<strong class="nc iu">${version}</strong></span></pre><p id="60a3" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">我们可以在应用程序代码中硬编码<strong class="km iu"> secret-name </strong>值，以显示应用程序中使用的秘密的关系。如果我们想将使用的秘密与应用程序构建结合起来，版本<strong class="km iu">也可以硬编码，但更好的方法是将其设置为字符串值<strong class="km iu"> latest </strong>而不是任何版本号，以便尽可能使用最新的秘密版本。</strong></p><p id="655d" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">对于<strong class="km iu">项目id </strong>，我们也可以在我们的应用程序代码中硬编码这个值，但是这是不可取的，因为应用程序不应该与GCP项目耦合(通过扩展，我们应该能够在任何GCP项目中部署相同的应用程序，而不需要更新代码中的任何配置)。我们可以通过以下代码行使用<strong class="km iu"> googleapis </strong>库来避免项目id的硬编码。</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="e019" class="nh lt it nc b gy ni nj l nk nl">const auth = new google.auth.GoogleAuth({});<br/>const projectId = await auth.getProjectId();</span></pre><p id="e924" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">这就是我们使用Secret Manager检索机密所需做的全部工作。通过调用之前的脚本，我们可以在应用程序运行时获得我们需要的秘密。我们还可以独立于应用程序来调用这个脚本，这显示了它的用途是多么广泛。</p><p id="7eeb" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">否则，为了在应用程序代码之外使用，我们也可以求助于gcloud CLI</p><pre class="mq mr ms mt gt nd nc ne nf aw ng bi"><span id="bbf4" class="nh lt it nc b gy ni nj l nk nl">gcloud beta secrets versions access <strong class="nc iu">${version}</strong> --secret <strong class="nc iu">${secret-key}</strong></span></pre><p id="3203" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">请注意，截至本文发布之日(2020年3月2日),该托管工具仍处于测试阶段。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="5bba" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="1685" class="pw-post-body-paragraph kj kk it km b kn mu kp kq kr mv kt ku lp mw kx ky lq mx lb lc lr my lf lg lh im bi translated">最后，我们看了两种不同的方式来管理和部署我们的无服务器工具的秘密(云运行和谷歌应用引擎)。</p><p id="f552" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated"><strong class="km iu">第一种方法包括将加密的秘密“烘焙”到应用程序中，并在部署时用KMS </strong>解密这些秘密。我们还研究了向用户和服务帐户分配适当的权限。这样做是为了限制不同加密密钥和环之间的访问控制，充分利用使用KMS的好处——GCP的IAM controls带来了访问控制的便利性，而不必从头开始实施访问控制。</p><p id="a7dd" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">然后我们继续探索一种不同的方法，使用Secret Manager。<strong class="km iu">我们使用Secret Manager的方法允许我们在需要时随时检索秘密，而不是将秘密烘焙到应用程序中并在部署时解密</strong>。这提供了一个额外的好处，即没有将秘密“烘焙”到应用程序中，允许秘密和配置在更新时“向后兼容”。</p><p id="9bc7" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">我发现这两种方法对于在无服务器工具中部署我的秘密非常有用——Cloud Run和Customruntime中的Google App Engine Flex。我希望你喜欢读这篇文章，并让我知道你是否有其他方法来实现同样的目标。</p><p id="d295" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">Ciao~</p></div></div>    
</body>
</html>