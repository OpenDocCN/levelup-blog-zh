# 如何通过合同设计软件来降低风险

> 原文：<https://levelup.gitconnected.com/how-to-design-software-by-contract-to-reduce-risk-1c1c439c573f>

![](img/0156f5829764f8448babb51332e3d38f.png)

由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的[路博宣礼塔](https://unsplash.com/@bubo?utm_source=medium&utm_medium=referral)拍摄的照片

对代码进行任何更改都会带来风险。我们应该思考这些问题，以便在问题出现时能够应对。

通过联系来设计软件是记录我们的代码并降低变更风险的一种方式。

在本文中，我们将看看如何通过文档或软件的契约来设计软件。

# 前提

这是函数被调用时必须满足的条件。如果违反了前提条件，就不应该调用函数。

# 后置条件

这是该函数保证要做的事情。它是程序完成时软件的状态。

# 类别不变量

从调用者的角度来看，类确保条件总是真的。

当函数退出并且控制返回到调用者时，不变量必须为真。

# 常数参数

传递到函数中的参数不应该被更改，以便遵循约定。

这样，函数的代码就不会破坏契约。

# 合同设计

我们应该遵守 Liskov 替换原则，该原则声明“子类必须可以通过基类接口使用，而不需要用户知道区别”

这意味着，如果我们用实现相同契约的另一个子类替换一个子类，那么它们应该表现相同。

这样，我们不必知道这些类的实现是什么。

我们只需要确保两个类都有返回相同内容的方法。

这也意味着我们必须确保我们创建的新子类型是一个“独一无二”的基本类型。

我们可以通过合同做到这一点。我们只需要指定它一次，然后我们离开它。

这意味着我们可以确保所有的子类都符合特定的方法签名。

但是如果我们有一个基类契约，我们可以确定未来的子类不能改变方法的含义。

# 通过合同实施设计

我们可以通过枚举每个功能的输入、边界条件和输出来通过契约实现设计。

对于不使用像 JavaScript 这样的代码进行契约式设计的语言来说，这可能是我们所能做到的最大限度了。

另一方面，像 TypeScript 这样的语言确实支持通过接口的契约来设计，我们可以使用接口和抽象类来为我们的类指定契约。

# 断言

我们可以通过使用断言来确保我们的函数和类遵循契约。

然而，如果我们有子类，那么它们将不会正确运行，除非我们在子类的方法中复制断言功能。

我们还必须保存任何旧值，以便在必要时用来检查后置条件。

运行时库不是为支持契约而设计的，所以不检查它们。如果需要，我们必须自己检查这些函数的返回值。

# 循环不变量

循环不变量是循环最终目标的陈述。然而，它是一般化的，因此在循环执行之前和循环的每次迭代中它也是有效的。

例如，如果我们想找到一个循环的最小数，那么我们可以写如下:

```
const arr = [4, 5, 6, 2, 1];
let [m] = arr;
i = 1;while (i < arr.length) {
  m = Math.min(m, arr[i]);
  i = i + 1;
}
```

在上面的代码中，我们的循环不变量是:

```
m = Math.min(m, arr[i]);
```

它总是设置当前找到的从`arr`数组到`m`的最小数。

因此，只要循环正在运行，它总是来自数组的最小值。

所以它是一个循环不变量，因为`m`是数组的最小值，到目前为止从未改变。

![](img/4132666542b42dd319c5f8a669a46098.png)

照片由[湄木](https://unsplash.com/@picoftasty?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

# 语义不变量

语义不变量是由需求直接驱动的法则，只在管理体制改变时才会改变。

我们不应该混淆语义不变量和固定的需求。新政策可能会改变这一要求。

无论当时的需求是什么，我们都应该清楚地记录下来，这样每个人都知道它的存在。

加强语义不变量的最好方法是站在用户的角度出错。我们必须向用户保证我们系统的行为。

# 结论

契约式设计通过强制执行契约来降低变更破坏事物的风险，也可以作为我们所写内容的文档。

它遵循一些不变的条件，这些条件减少了变化给我们的系统带来的风险。