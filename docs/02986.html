<html>
<head>
<title>What happens where you type ls -l in a Linux Shell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Linux Shell中键入ls -l会发生什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-happens-where-you-type-ls-l-in-a-linux-shell-98ad95430cbf?source=collection_archive---------2-----------------------#2020-04-14">https://levelup.gitconnected.com/what-happens-where-you-type-ls-l-in-a-linux-shell-98ad95430cbf?source=collection_archive---------2-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="90b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">shell是一个程序，它从键盘上获取你的命令，然后交给操作系统去执行。外壳隐藏了底层操作系统的细节，并管理操作系统内核接口的技术细节。</p><p id="606e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提示符$，称为命令提示符，是由shell发出的。当提示符显示时，您可以键入命令。在您按Enter键后，shell会读取您的输入。它通过查看您输入的第一个单词来确定您想要执行的命令。单词是一组完整的字符。空格和制表符分隔单词。Shell脚本是一个命令列表，按照执行顺序排列。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/edb5fddd5202a9381c180fcb61aee9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*6NstewKEDpCcNBLAYxfGjg.gif"/></div></figure><p id="5859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ls 是一个shell命令，列出一个目录中的文件和目录。使用<strong class="jp ir"> -l </strong>选项，ls将以长列表格式列出文件和目录。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi kt"><img src="../Images/4a344a417905cae9113bb6f852a76feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U22EhQXyezK4EihI_XmZdw.png"/></div></div></figure><h1 id="9164" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">那么…到底发生了什么？</h1><p id="6e8e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">首先，在您键入任何内容之前，shell会打印一个提示，通常以一个<strong class="jp ir"> $ </strong>符号结尾。提示符或命令行是您键入命令的地方。</p><h1 id="16ac" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1.将显示shell提示符</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mb"><img src="../Images/2bec6fd55c3fe372406736253ea461da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FA_17SfBZWtW8UpANYsJIg.png"/></div></div></figure><h1 id="f3ff" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2.shell从用户输入的标准输入中读取命令</h1><p id="833a" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">其次，在您键入命令后，shell会读取您使用getline函数键入的内容。</p><p id="933e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">getline函数将输入的行作为一个字符串从标准输入中读取，并将其存储在缓冲区中。</p><h1 id="c6e8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">getline()函数</h1><p id="d4a1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">最新最流行的读取一串文本的函数是<em class="mc"> getline() </em>。这是一个新的C库函数，出现在2010年左右。</p><p id="1adc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能没有听说过<em class="mc"> getline() </em>函数，一些C程序员避免使用它，因为它使用了——振作起来— <em class="mc">指针</em>！尽管如此，这是一个很好的行输入函数，即使您不打算使用它，您也应该熟悉它。</p><p id="1a48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个典型的<em class="mc"> getline() </em>语句:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="2c23" class="mi kz iq me b gy mj mk l ml mm">getline(&amp;buffer,&amp;size,stdin);</span></pre><p id="f382" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mc"> getline() </em>函数的原型在<code class="fe mn mo mp me b">stdio.h</code>头文件中。这里有三个论点:</p><p id="1220" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mn mo mp me b">&amp;buffer</code>是存储输入字符串的第一个字符位置的地址。是<em class="mc">不是</em>缓冲区的基址，而是缓冲区中第一个<em class="mc">字符</em>的基址。这种指针类型(指针-指针或<code class="fe mn mo mp me b">**</code>之类的东西)导致了巨大的混乱。</p><p id="17fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mn mo mp me b">&amp;size</code>是保存输入缓冲区大小的变量的地址，另一个指针。</p><p id="506c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mn mo mp me b">stdin</code>是输入文件的句柄。因此，您可以使用<em class="mc"> getline() </em>从文件中读取一行文本，但是当指定了<code class="fe mn mo mp me b">stdin</code>时，将读取标准输入。</p><p id="eda2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在读取该行并将其存储在缓冲区中之后，getline返回一个int/ssize_t，它等于:</p><ol class=""><li id="f2d8" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">成功时读取的字符数，不包括字符串的终止空字节。</li></ol><p id="5525" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运筹学</p><p id="2f01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.-1，表示未能读取一行(包括文件结束条件)。</p><p id="d31c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">名词（noun的缩写）程序员必须在程序结束时释放分配给缓冲区的内存。</p><h1 id="b003" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.解析用户输入</h1><p id="3dc7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">调用字符串标记化函数，将命令行拆分为标记。在我们的shell中，我们使用了一个名为<code class="fe mn mo mp me b">strtok()</code>的函数，该函数用行来标记，用分隔符来定义标记边界</p><p id="f26e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以该命令为例:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="bf58" class="mi kz iq me b gy mj mk l ml mm">ls -la /</span></pre><p id="2a9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有二进制文件的名字(ls)和它的参数。</p><p id="14d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该命令也可以是:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="0d5a" class="mi kz iq me b gy mj mk l ml mm">$  ls       -la      /</span></pre><p id="1505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将编写一个函数，将我们的命令(不带空格)存储在char **中，它将给出:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="66fe" class="mi kz iq me b gy mj mk l ml mm">[ls][-la][/]</span></pre><h1 id="19e2" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">4.shell检查第一个标记(主命令本身)是否是别名，如果是，就用实际的命令替换别名</h1><p id="16e5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">shell通常会在其系统文件中查找已定义的别名。如果<code class="fe mn mo mp me b">ls</code>命令是其他命令的别名，那么shell将用<code class="fe mn mo mp me b">ls</code>代表的命令字符串替换<code class="fe mn mo mp me b">ls</code>标记，以便在后续步骤中进行正确的操作。</p><h1 id="c8fd" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">5.执行</h1><p id="9718" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为了执行我们的订单，我们将使用syscall <code class="fe mn mo mp me b">execve</code>。</p><p id="f035" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须使用syscall <code class="fe mn mo mp me b">fork</code>来创建一个新的进程，并在其中启动我们的命令。</p><p id="0bed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> fork() </strong>系统调用用于在C程序中创建子进程。fork()用于应用程序中需要并行处理的地方。fork()系统函数在头文件<strong class="jp ir"> sys/types.h </strong>和<strong class="jp ir"> unistd.h </strong>中定义。在使用fork的程序中，还必须使用wait()系统调用。wait()系统调用用于在父进程中等待子进程完成。为了完成子进程，在子进程中使用exit()系统调用。wait()函数在头文件<strong class="jp ir"> sys/wait.h </strong>中定义，exit()函数在头文件<strong class="jp ir"> stdlib.h </strong>中定义。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/9d4a91673d6e71528dd7ba56aa318039.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*Qdn6uayFB-sEIA02IuOdIg.png"/></div></figure><p id="f2ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下系统调用用于基本流程管理。</p><p id="7536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> fork : </strong>父流程使用fork创建新的子流程。子进程是父进程的副本。fork之后，父进程和子进程执行相同的程序，但是在不同的进程中。</p><p id="72ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">exec : 替换进程执行的程序。子进程可以在fork之后使用exec来用新的可执行程序替换进程的内存空间，使子进程执行与父进程不同的程序。</p><p id="a493" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">退出:</strong>以退出状态终止进程。</p><p id="d71c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">等待:</strong>父进程可以使用等待来暂停执行，直到子进程终止。使用wait，父进程可以获得被终止的子进程的退出状态。</p><h1 id="fa46" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Fork成功返回两次</h1><p id="e200" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">成功时<code class="fe mn mo mp me b">fork</code>返回两次:一次在父节点，一次在子节点。在调用<code class="fe mn mo mp me b">fork</code>之后，程序可以使用fork返回值来判断是在父进程中执行还是在子进程中执行。</p><ul class=""><li id="102b" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk na mw mx my bi translated">如果返回值是<code class="fe mn mo mp me b">0</code>，程序在新的子进程中执行。</li><li id="8ad6" class="mq mr iq jp b jq nb ju nc jy nd kc ne kg nf kk na mw mx my bi translated">如果返回值大于零，程序在父进程中执行，返回值是创建的子进程的进程ID (PID)。</li><li id="15b8" class="mq mr iq jp b jq nb ju nc jy nd kc ne kg nf kk na mw mx my bi translated">失败时<code class="fe mn mo mp me b">fork</code>返回<code class="fe mn mo mp me b">-1</code>。</li></ul><p id="171b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:通过向我们的shell发送一个像holberton这样的简单命令，<code class="fe mn mo mp me b"><strong class="jp ir">execve</strong></code>我们返回-1，<code class="fe mn mo mp me b"><strong class="jp ir">perror </strong></code>显示<strong class="jp ir">。/hsh: 3:霍尔伯顿:找不到。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/23429468e8bd8cb0205ea6334a5558e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-wSx_bmf39xO21fNsVG_Q.png"/></div></div></figure><p id="1b42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个参数<code class="fe mn mo mp me b">d'execve</code>必须是要执行的二进制文件的绝对路径。</p><p id="0a2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了找到程序在哪里，我们需要使用环境变量<code class="fe mn mo mp me b">PATH</code>。</p><p id="b5ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们执行命令:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="3e0d" class="mi kz iq me b gy mj mk l ml mm">$&gt; echo $PATH</span></pre><p id="e949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将得到如下所示的输出:</p><pre class="km kn ko kp gt md me mf mg aw mh bi"><span id="5257" class="mi kz iq me b gy mj mk l ml mm">/bin:/usr/bin:/usr/local/bin</span></pre><p id="9eb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些是文件(用':'分隔)，否则我们的Shell将查找要执行的二进制文件。</p><p id="29f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在需要编写连接路径和二进制文件的函数。</p><p id="1d79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您必须用函数<code class="fe mn mo mp me b">getenv</code>检索$ PATH变量的内容。它接受一个我们正在寻找的变量的参数，并返回一个指向作为参数传递的变量内容的指针。</p><p id="c6be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的二进制文件不在任何文件夹中，我们可以通过一个<code class="fe mn mo mp me b">Command not found</code>来警告用户，否则我们可以执行execve: D。</p><p id="e4b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检索＄PATH变量的内容并返回绝对路径:D的函数</p><p id="9243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们的shell执行一个命令，但是没有内置或环境。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nh"><img src="../Images/111870ba94d78840cd83a32b76f4fba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYMXAXzncLlMf3p9MemnPQ.png"/></div></div></figure><p id="b3f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在将添加一些内置到我们的外壳。</p><p id="a843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">内置</strong>是我们shell中的一个编码器命令。也就是说，该命令不会与execve一起执行。</p><p id="89a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们启动bash并删除环境变量<code class="fe mn mo mp me b">PATH</code>，我们的shell必须仍然能够执行基本的命令。</p><p id="da77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令<code class="fe mn mo mp me b">cd, pwd, exit ...</code>必须是可执行的。</p><p id="1d42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用命令<code class="fe mn mo mp me b">help</code>列出bash下的所有内置代码</p><p id="7265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们会看到内置的<code class="fe mn mo mp me b">cd, pwd</code>。还有很多其他的，但是目标只是让你理解什么是内置以及如何实现它。</p><p id="8a6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于内置的<code class="fe mn mo mp me b">cd</code>，我们将使用函数<code class="fe mn mo mp me b">chdir</code></p><p id="86d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mn mo mp me b">chdir</code>将成为当前文件夹的路径作为参数</p><p id="0851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内置实现的一个例子<code class="fe mn mo mp me b">cd</code>:</p><h1 id="b4d8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">是时候退出外壳了</h1><p id="ea4b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">退出shell有三种方式:</p><p id="d31f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1-键入命令“exit”或“exit n”(n是整数)</p><p id="37ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2-按下Ctrl + D(这标志着EOF，标准输入文件的结尾)</p><p id="cc00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3-按下Ctrl + C(这被定义为退出的信号)</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><div class="km kn ko kp gt np"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">编写面试问题</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">技术开发</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kr np"/></div></div></a></div></div></div>    
</body>
</html>