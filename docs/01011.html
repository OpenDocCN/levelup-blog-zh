<html>
<head>
<title>My Top 4 Patterns for Writing Simple Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我编写简单代码的四大模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-top-4-patterns-for-writing-simple-code-466705ac0b97?source=collection_archive---------0-----------------------#2019-10-18">https://levelup.gitconnected.com/my-top-4-patterns-for-writing-simple-code-466705ac0b97?source=collection_archive---------0-----------------------#2019-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d73ce67126426829be9879cd55bff642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sMR49RfFJ0KIbFsZ98fA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">凯利·西克玛在<a class="ae kf" href="https://unsplash.com/s/photos/building-blocks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ba19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到写代码，我的目标是写简单的代码。鲍伯·马丁所说的干净代码。其他人所说的可读性或可维护性。在许多方面，它们都指同一件事。</p><p id="96b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是很难<strong class="ki iu"/>！</p><p id="e03a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写简单的代码需要深思熟虑。它需要几轮重构，直到代码恰到好处。它通常涉及同行评审或结对编程。</p><p id="b293" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我在职业生涯中发现的一些模式帮助我编写了简单的代码。不一定更快或更容易，但更简单。当我面前有新问题时，我会求助于这些模式，它们几乎总能让复杂的事情变得简单一点。</p><h2 id="7640" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">关于模式</h2><p id="9646" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">作为一个简短的介绍，当我谈到模式时，我通常指的是您可能听说过的一组<a class="ae kf" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank"> OOP模式</a>。我知道OOP在很多方面已经过时了——但是不管你喜欢哪种模式，其中一些模式仍然适用。他们每个人都更喜欢简单的组合而不是继承，这正是大多数人讨厌OOP的地方。</p><p id="eb47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在这里提到的大多数模式都来自于四人组的开创性著作:<a class="ae kf" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">设计模式</a>。我将只对每种模式做一个简单的介绍，所以我强烈建议您通过提供的链接来更详细地阅读它们。</p><h2 id="e89f" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">模式1:抽象工厂</h2><p id="5615" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">工厂</a>本质上是一个对象，它唯一的工作就是生成其他对象。工厂可以以不同的方式出现，但是在我看来抽象工厂模式是最强大的。</p><p id="cd90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Abstract_factory_pattern" rel="noopener ugc nofollow" target="_blank">抽象工厂</a>不仅允许你在运行时改变生成或构建的对象，还可以在运行时改变工厂。虽然这听起来有些不可思议，但对于像Spring或Unity这样的控制框架的反转来说，这确实很有效。</p><p id="5b3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从代码的角度来看，通常看起来有点像:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ddba" class="le lf it mh b gy ml mm l mn mo">interface Factory&lt;T&gt; {</span><span id="2c33" class="le lf it mh b gy mp mm l mn mo">T build(Metadata d)</span><span id="64fd" class="le lf it mh b gy mp mm l mn mo">}</span><span id="a369" class="le lf it mh b gy mp mm l mn mo">class ClientFactory implements Factory&lt;Client&gt; {</span><span id="010e" class="le lf it mh b gy mp mm l mn mo">Client build(Metadata d) {<br/>        // Build actual object and return      <br/>    }</span><span id="cf69" class="le lf it mh b gy mp mm l mn mo">}</span></pre><p id="dd3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我需要构建一个与基于配置的简单接口相匹配的具体对象时，我都会尝试使用抽象工厂，并且我不希望使用该对象的每个其他类知道发生了什么变化。是的，那是一个很长的句子。核心思想与其他软件工程原则是相同的经典思想:信息隐藏、做一件事的类和小接口。更直接地说，抽象工厂有助于隐藏构建对象的乏味。</p><h2 id="e285" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">模式2:委托人</h2><p id="a221" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我敢肯定，我们都在从事某个项目(代码或非代码)，在这个项目中，我们决定将工作委托给其他人，而不是自己做某个方面的工作。这通常发生在你在项目中处于更高的位置——例如，一个项目协调员可能会将工作委托给一组助理协调员，这些助理协调员将工作委托给志愿者领导，等等。等等。</p><p id="15a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码中的<a class="ae kf" href="https://en.wikipedia.org/wiki/Delegation_pattern" rel="noopener ugc nofollow" target="_blank">委托者</a>模式完全相同:高阶类要求低阶类为它们完成工作。这有助于高阶类保持简单，并且对其下面的结构知道得更少。</p><p id="ab57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从代码的角度来看，它看起来有点像:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ff63" class="le lf it mh b gy ml mm l mn mo">interface Validator {<br/>    <br/>    bool validate(Object o)</span><span id="d087" class="le lf it mh b gy mp mm l mn mo">}</span><span id="b930" class="le lf it mh b gy mp mm l mn mo">class ValidatorHelper implements Validator {</span><span id="7dd3" class="le lf it mh b gy mp mm l mn mo">Set&lt;Validator&gt; delegates;<br/>    <br/>    bool validate(Object o) { <br/>        for (Validator v : delegates) { <br/>            if (!v.validate(o)) return false<br/>        }<br/>        return true<br/>    }</span><span id="756f" class="le lf it mh b gy mp mm l mn mo">}</span><span id="da0b" class="le lf it mh b gy mp mm l mn mo">class RestController {</span><span id="adfe" class="le lf it mh b gy mp mm l mn mo">ValidationHelper helper;</span><span id="be25" class="le lf it mh b gy mp mm l mn mo">Response addObject(Object o) {<br/>        if (helper.validate(o)) return ErrorResponse</span><span id="4240" class="le lf it mh b gy mp mm l mn mo">// Normal processing<br/>    }</span><span id="611c" class="le lf it mh b gy mp mm l mn mo">}</span></pre><p id="1fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现委托器的使用对于验证、排序、规范化等非常有用。可能特定于特定数据形式的常见事物，但是对该数据做出决策的类可能不需要知道委托工作的全部复杂性。它只需要知道工作已经完成。</p><h2 id="1873" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">模式3:构建器/命名参数</h2><p id="e23c" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在所有改变我写代码方式的模式中，<a class="ae kf" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">构建器模式</a>是我最喜欢的一个。我从一开始就用构建器编写我的每一个DTO(数据传输对象)。实际上，构建器不需要太多的工作就能生成灵活且可扩展的代码，而且如果你需要的话，它们还具有不变性的优势！</p><p id="8431" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他语言可能没有(甚至不需要)builder模式，因为它们在构造函数中使用相同的默认值命名参数。本质上，这是一样的:只声明你希望被设置为特定值的东西，不要担心其他的。</p><p id="cfe7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在代码中，它看起来像这样:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="12f1" class="le lf it mh b gy ml mm l mn mo">class Dto {</span><span id="73a4" class="le lf it mh b gy mp mm l mn mo">String s<br/>    int i</span><span id="f460" class="le lf it mh b gy mp mm l mn mo">private Dto(String s, int i) {<br/>        this.s = s<br/>        this.i = i<br/>    }</span><span id="685c" class="le lf it mh b gy mp mm l mn mo">public DtoBuilder builder() {<br/>        return new DtoBuilder()<br/>    }</span><span id="9ba3" class="le lf it mh b gy mp mm l mn mo">public static class DtoBuilder {<br/>        <br/>        private String s = "some string"<br/>        private int i = 0</span><span id="c343" class="le lf it mh b gy mp mm l mn mo">public DtoBuilder withString(String s) {<br/>            this.s = s<br/>            return this<br/>        }</span><span id="0c41" class="le lf it mh b gy mp mm l mn mo">public DtoBuilder withInt(int it) {<br/>            this.i = i<br/>            return this<br/>        }</span><span id="67c5" class="le lf it mh b gy mp mm l mn mo">public Dto build() {<br/>            return new Dto(s, i)<br/>        }<br/>    }</span><span id="106c" class="le lf it mh b gy mp mm l mn mo">}</span></pre><p id="61a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mq">注意:在java中，我们使用</em> <a class="ae kf" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> <em class="mq"> Lombok </em> </a> <em class="mq">来完成所有繁琐的编码工作。</em></p><p id="77a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式让我的代码如此简单的原因是，当所有的<strong class="ki iu">对象都使用构建器时，创建一个新的是自动的。在我们的代码库中，我们总是在我们想要构建的类中添加一个静态工厂方法来返回构建器。从那里，我们简单地遵循fluent API的链，传入您的变量，然后键入<code class="fe mr ms mt mh b">.build()</code>。完成了。你不会花时间去看构造函数。你甚至不用花时间去看构建器代码。它就在那里，你在写作的时候用它。在现代的ide中，自动补全功能告诉你可以设置什么样的变量。简单。</strong></p><h2 id="4a6a" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">模式4:浓缩器</h2><p id="bde3" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">这种模式在G-o-4的书中没有，但它与责任链和模板方法关系最密切。在这种模式中，每个“链”丰富或扩充一个对象，并将丰富的对象返回给调用者。它可以为链中的每个富集器这样做，或者如果需要，链可以决定跳过链的其余部分。</p><p id="9610" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会认为您违反了干净代码中关于函数副作用的规则。我的理由是<em class="mq">没有</em>违反这些原则，因为充实器<strong class="ki iu">必须</strong>将充实后的对象返回给调用者，所以在很多方面，它声明对象可能会改变。对于调用者所知道的，它可能是一个新对象(特别是在不可变约束的情况下)。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="f6b7" class="le lf it mh b gy ml mm l mn mo">interface Enricher&lt;T&gt; {</span><span id="fba7" class="le lf it mh b gy mp mm l mn mo">T enrich(T thing);</span><span id="3b37" class="le lf it mh b gy mp mm l mn mo">}</span><span id="6aee" class="le lf it mh b gy mp mm l mn mo">class HeadersEnricher implements Enricher&lt;Headers&gt; {<br/> <br/>    Headers enrich(Headers headers) {<br/>        headers.add("x-header", "something")<br/>        return headers<br/>    }</span><span id="9e07" class="le lf it mh b gy mp mm l mn mo">}</span></pre><p id="3fb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现这个特别有用的地方是当你需要用新的状态来丰富一个对象的时候。例如，如果您有一个来自Kafka流的对象，需要在将它存储到数据仓库之前添加一些数据，那么enricher模式可以很好地工作。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="babf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些只是我编写简单代码时最喜欢的一些模式。无论如何，这不是一个详尽的列表，但是我每天都使用这些模式来解决编码问题。只不过是将更多的工具添加到您的编码工具带上。</p><p id="6c53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！</p></div></div>    
</body>
</html>