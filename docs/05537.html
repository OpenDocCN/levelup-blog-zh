<html>
<head>
<title>Async Processing in Python: Make Data Pipelines Scream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异步处理:让数据管道尖叫</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/async-processing-in-python-make-data-pipelines-scream-ceea74a537ad?source=collection_archive---------14-----------------------#2020-09-07">https://levelup.gitconnected.com/async-processing-in-python-make-data-pipelines-scream-ceea74a537ad?source=collection_archive---------14-----------------------#2020-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84836c7b37c15c7849bcd1a37522d1c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gx4MPTHnfGAdyLKfCNFMFg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a href="’&lt;a" class="ae kc" rel="noopener ugc nofollow" target="_blank">https://www.freepik.com/photos/background'</a>&gt;kjpargeter制作的背景照片—<a class="ae kc" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">www.freepik.com</a>&lt;/a&gt;</figcaption></figure><p id="0a66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何在python中启用并行处理？线程化是一种方式，但是构建一个完全有弹性的多线程进程是困难的。在python中引入异步处理是在应用程序中引入并行处理的一种更加简单和实用的方式。在这篇非常短的博文中，您将了解如何启用简单的异步功能。</p><h1 id="eb5b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">“正常”的方式</h1><p id="83be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们来看看编写程序的标准方式。考虑一个在名为<code class="fe me mf mg mh b">myproc()</code>的函数中定义的流程，它做了一件需要5秒钟的事情。我们将通过设置5秒钟的睡眠来模拟它。当进行函数调用时，我们打印一行“myproc started …”。同样，当函数完成执行时，我们打印“myproc finished …”。使用时间模块，我们将记录经过的时间。这是代码。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="99fd" class="mq lc iq mh b gy mr ms l mt mu">import time</span><span id="6ca1" class="mq lc iq mh b gy mv ms l mt mu">def myproc():<br/>    print("myProc started ...")<br/>    t1 = time.perf_counter()<br/>    time.sleep(5)<br/>    t = time.perf_counter() - t1<br/>    print(f"   myProc finished in {t:0.5f} seconds.")<br/>    <br/>def main():<br/>    for _ in range(5):<br/>        myproc()<br/>      <br/>if __name__ == "__main__":<br/>    start_sec = time.perf_counter()<br/>    main()<br/>    elapsed_secs = time.perf_counter() - start_sec<br/>    print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="56ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把这个文件叫做sync.py。当我们用python执行这个脚本时:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f066" class="mq lc iq mh b gy mr ms l mt mu">myProc started ...<br/>   myProc finished in 5.00262 seconds.<br/>myProc started ...<br/>   myProc finished in 5.00281 seconds.<br/>myProc started ...<br/>   myProc finished in 5.00011 seconds.<br/>myProc started ...<br/>   myProc finished in 5.00042 seconds.<br/>myProc started ...<br/>   myProc finished in 5.00504 seconds.<br/>Job finished in 25.01145 seconds.</span></pre><p id="d892" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如预期的那样，这项工作总共花费了25秒，因为函数<code class="fe me mf mg mh b">myproc()</code>的每次运行花费了5秒。连续运行5次，我们在25秒内完成了任务。</p><h1 id="c940" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步方式</h1><p id="6747" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在，让我们以异步方式重写它。下面是修改后的代码。修改后的部分以粗体显示。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8b42" class="mq lc iq mh b gy mr ms l mt mu">import asyncio<br/>import time</span><span id="85e4" class="mq lc iq mh b gy mv ms l mt mu">async def myproc():<br/>    print("myProc started ...")<br/>    t1 = time.perf_counter()<br/>    <strong class="mh ir">await asyncio.</strong>sleep(5)<br/>    t = time.perf_counter() - t1<br/>    print(f"   myProc finished in {t:0.5f} seconds.")</span><span id="937d" class="mq lc iq mh b gy mv ms l mt mu">async def main():<br/>    <strong class="mh ir">await asyncio.gather</strong>(<br/>      myproc(),<br/>      myproc(), <br/>      myproc(), <br/>      myproc(),<br/>      myproc()<br/>    )</span><span id="4d36" class="mq lc iq mh b gy mv ms l mt mu">if __name__ == "__main__":<br/>    start_sec = time.perf_counter()<br/>    <strong class="mh ir">asyncio.run</strong>(main())<br/>    elapsed_secs = time.perf_counter() - start_sec<br/>    print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="e6b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是输出:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ecbd" class="mq lc iq mh b gy mr ms l mt mu">myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>   myProc finished in 5.00337 seconds.<br/>   myProc finished in 5.00347 seconds.<br/>   myProc finished in 5.00349 seconds.<br/>   myProc finished in 5.00351 seconds.<br/>   myProc finished in 5.00353 seconds.<br/>Job finished in 5.00495 seconds.</span></pre><p id="104c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">哇哦。整个工作只用了5秒钟就完成了(每次运行<code class="fe me mf mg mh b">myproc()</code>函数所花的时间)。怎么会这样</p><h1 id="0b55" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步/等待组合</h1><p id="bd2c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">诀窍是在上面的代码中包含async和await关键字。这些关键字确保函数以异步方式运行。请注意下面一行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="53f5" class="mq lc iq mh b gy mr ms l mt mu"><strong class="mh ir">await </strong>sleep(5)</span></pre><p id="4644" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">await关键字告诉python不要等待它的完成，而是将控制权暂时交还给调用者。让我重复一遍，因为这是一个非常强大的概念。关键字告诉python解释器将控制权交还给被调用的程序(在本例中是程序<code class="fe me mf mg mh b">main()</code>)，但只是暂时的。一旦执行结束，它就取回控制权。请注意下面一行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cfb5" class="mq lc iq mh b gy mr ms l mt mu"><strong class="mh ir">asyncio.run</strong>(main())</span></pre><p id="9ce0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这告诉<code class="fe me mf mg mh b">main()</code>函数以异步方式执行该函数，即不要等待<code class="fe me mf mg mh b">myproc()</code>的完成。但是然后主程序里就没别的了；因此，它调用<code class="fe me mf mg mh b">myproc()</code>的下一次迭代，再次像以前一样异步，并且一旦遇到await关键字，它就传递控制。</p><p id="e08c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，回到<code class="fe me mf mg mh b">main()</code>的控制权是不是一去不复返了？一点也不。当<code class="fe me mf mg mh b">myproc()</code>完成时(按照设计，大约5秒钟)，控制权返回给该函数。该函数执行下一行，打印结束行以及经过的时间。</p><p id="bebf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数调用仍然花了5秒钟(正如预期的那样)，但是程序以一种并行的方式执行了所有的函数调用。因此总时间也只有5秒。</p><p id="7f56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我用的是“某种平行”。执行实际上不是并行的。我们将条件放在函数的逻辑中，以告知何时将控制权交还给调用者。它模仿了平行，但实际上不是平行的。事实仅仅是被调用的函数是一个<strong class="kf ir">非阻塞</strong>调用。迷茫？</p><h1 id="47a9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们控制异步部分</h1><p id="b26b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了说明我们如何控制调用的异步性质的微妙概念，让我们修改脚本async1.py如下。我们称之为async2.py，变化用粗体表示。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6de4" class="mq lc iq mh b gy mr ms l mt mu">import asyncio<br/>import time</span><span id="b178" class="mq lc iq mh b gy mv ms l mt mu">async def myproc():<br/>    print("myProc started ...")<br/>    t1 = time.perf_counter()<br/>    await asyncio.sleep(<strong class="mh ir">2.5)</strong><br/>    <strong class="mh ir">time.sleep(2.5)</strong><br/>    t = time.perf_counter() - t1<br/>    print(f"   myProc finished in {t:0.5f} seconds.")</span><span id="d954" class="mq lc iq mh b gy mv ms l mt mu">async def main():<br/>    await asyncio.gather(<br/>      myproc(),<br/>      myproc(),<br/>      myproc(),<br/>      myproc(),<br/>      myproc()<br/>    )</span><span id="ce7c" class="mq lc iq mh b gy mv ms l mt mu">if __name__ == "__main__":<br/>    start_sec = time.perf_counter()<br/>    asyncio.run(main())<br/>    elapsed_secs = time.perf_counter() - start_sec<br/>    print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="d1de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个简单但重要的变化。我没有让函数异步地花费所有的5秒，而是将它分成2.5秒，分别用在asyncio.sleep和time.sleep上(这是同步的)。以下是我们运行脚本时的结果:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f964" class="mq lc iq mh b gy mr ms l mt mu">myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>   myProc finished in 5.00751 seconds.<br/>   myProc finished in 7.50905 seconds.<br/>   myProc finished in 10.01197 seconds.<br/>   myProc finished in 12.51726 seconds.<br/>   myProc finished in 15.02254 seconds.<br/>Job finished in 15.02414 seconds.</span></pre><p id="8b65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出很有启发性。注意所有的函数调用是如何像预期的那样立即开始的。然而，现在每次通话花费的时间越来越多，比上一次多了2.5秒。为什么？</p><p id="a39f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是因为只有2.5秒的通话是异步的。一旦达到这一点，调用返回到函数。第二次睡眠不是异步的；因此，在调用完成之前，函数不会将控制权返回给调用者，在本例中是main()。因此，这是一个阻塞呼叫。这就是为什么第二个函数必须等待睡眠函数的执行。所以，这不是并行执行。我们控制的是异步执行。</p><h1 id="e70b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通话顺序很重要</h1><p id="0377" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">来说明这种控制是如何有用和重要的。让我们对程序再做一个小小的改动。在这里，我们将简单地改变调用async和sync sleep命令的顺序，如粗体所示。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6a03" class="mq lc iq mh b gy mr ms l mt mu">import asyncio<br/>import time</span><span id="5fd0" class="mq lc iq mh b gy mv ms l mt mu">async def myproc():<br/>    print("myProc started ...")<br/>    t1 = time.perf_counter()<br/><strong class="mh ir">    time.sleep(2.5)<br/>    await asyncio.sleep(2.5)</strong><br/>    t = time.perf_counter() - t1<br/>    print(f"   myProc finished in {t:0.5f} seconds.")</span><span id="a770" class="mq lc iq mh b gy mv ms l mt mu">async def main():<br/>    await asyncio.gather(<br/>      myproc(),<br/>      myproc(),<br/>      myproc(),<br/>      myproc(),<br/>      myproc()<br/>    )</span><span id="9c72" class="mq lc iq mh b gy mv ms l mt mu">if __name__ == "__main__":<br/>    start_sec = time.perf_counter()<br/>    asyncio.run(main())<br/>    elapsed_secs = time.perf_counter() - start_sec<br/>    print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="ca65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:和async2.py完全一样；只是调用睡眠的顺序变了。之前我们先称之为异步睡眠，然后称之为同步睡眠。这里我们先调用同步睡眠。当您运行它时，您将得到以下输出:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0de2" class="mq lc iq mh b gy mr ms l mt mu">myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>   myProc finished in 12.51053 seconds.<br/>   myProc finished in 10.00526 seconds.<br/>   myProc finished in 7.50407 seconds.<br/>   myProc finished in 5.00093 seconds.<br/>   myProc finished in 5.00068 seconds.<br/>Job finished in 15.01211 seconds.</span></pre><p id="2380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意函数调用“myProc started …”的第一行现在是如何交错出现的。事实上，它每隔2.5秒就出现一次。为什么？简单；该函数有一个睡眠2.5秒的阻塞调用；因此，在将控制发送回主程序之前，它必须等待那么长时间。main()程序不能再次调用<code class="fe me mf mg mh b">myProc()</code>,直到这段时间过去。</p><p id="8d2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.5秒后，该函数遇到异步睡眠调用。此时，它将控制权返回给main()。然而，当<code class="fe me mf mg mh b">main()</code>返回到<code class="fe me mf mg mh b">myproc()</code>的第一个调用时，已经是所有其他调用完成之后了。因此，这里有一个有趣的模式:第一个对<code class="fe me mf mg mh b">myproc()</code>的调用耗时最长，而前一个调用耗时最长。不过，总的时间保持不变。</p><p id="d83d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么<strong class="kf ir">调用函数的同步和异步部分的顺序会影响</strong>程序如何从子组件返回值。总时间不会变化。</p><p id="7b6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么重要？好吧，让我们考虑这个程序中的另一个小任务。我们需要计算函数调用中某个数字的总数。为了简单起见，我们将在每次调用函数时将变量sum加1。此外，让我们也展示一下函数是如何依次被调用的。我们将修改函数来接受一个名为<code class="fe me mf mg mh b">callid</code>的参数，这个参数仅仅是一个数字，用来清楚地表示每个函数调用。然后我们将创建一个调用id链来显示被调用的函数。首先，我们将按以下顺序进行:异步，然后同步。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="16d3" class="mq lc iq mh b gy mr ms l mt mu">import asyncio<br/>import time</span><span id="47dd" class="mq lc iq mh b gy mv ms l mt mu">chain = ""<br/>sum = 0<br/>async def myproc(callid):<br/><strong class="mh ir">    global chain<br/>    global sum</strong><br/>    print(f"myProc {callid} started ...")<br/>    t1 = time.perf_counter()<br/>    await asyncio.sleep(2.5)<br/><strong class="mh ir">    chain = chain + "-&gt;" + str(callid)<br/>    sum = sum + 1</strong><br/>    time.sleep(2.5)<br/>    t = time.perf_counter() - t1<br/>    print(f"   myProc {callid} finished in {t:0.5f} seconds. sum = {sum} chain {chain}")</span><span id="9869" class="mq lc iq mh b gy mv ms l mt mu">async def main():<br/>    await asyncio.gather(<br/>      myproc(1),<br/>      myproc(2),<br/>      myproc(3),<br/>      myproc(4),<br/>      myproc(5)<br/>    )</span><span id="a9fb" class="mq lc iq mh b gy mv ms l mt mu">if __name__ == "__main__":<br/>    start_sec = time.perf_counter()<br/>    asyncio.run(main())<br/>    elapsed_secs = time.perf_counter() - start_sec<br/>    print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="9033" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是输出:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7b1c" class="mq lc iq mh b gy mr ms l mt mu">myProc 1 started ...<br/>myProc 2 started ...<br/>myProc 3 started ...<br/>myProc 4 started ...<br/>myProc 5 started ...<br/>   myProc 1 finished in 5.00606 seconds. sum = 1 chain -&gt;1<br/>   myProc 2 finished in 7.51137 seconds. sum = 2 chain -&gt;1-&gt;2<br/>   myProc 3 finished in 10.01224 seconds. sum = 3 chain -&gt;1-&gt;2-&gt;3<br/>   myProc 4 finished in 12.51499 seconds. sum = 4 chain -&gt;1-&gt;2-&gt;3-&gt;4<br/>   myProc 5 finished in 15.01671 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>Job finished in 15.01861 seconds.</span></pre><p id="85c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些函数是按照我们传递的顺序调用的，如链中所示；但是请注意<code class="fe me mf mg mh b">sum</code>这个变量。它在每个函数调用中都有所不同。为什么？</p><p id="62cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单。当第一次调用该函数时，它返回控制，然后控制转到第二次函数调用。然而，当第二个函数调用(callid=2)开始执行同步部分时，第一个函数调用(callid=1)已经开始计算并完成了它的工作。当时sum为0；所以它加了1得出1。当第二个函数调用到达代码的计算部分时，总和已经是1；于是就想出了1 + 1 = 2。接下来的电话也是如此。</p><p id="b79a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么重要？</p><p id="7869" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要的只是最终的总数，也就是工作结束时的总数，那就没问题了。数字会是正确的。但是，如果您在函数中使用sum，例如，您正在检查sum是否大于3，那么显然调用1、2和3会失败，但调用4和5会成功。这可能会引入一个错误。</p><p id="037b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与之形成对比的是一个小小的变化，您颠倒了同步和异步调用的顺序</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="543c" class="mq lc iq mh b gy mr ms l mt mu">import asyncio<br/>import time</span><span id="c90b" class="mq lc iq mh b gy mv ms l mt mu">chain = ""<br/>sum = 0<br/>async def myproc(callid):<br/>    global chain<br/>    global sum<br/>    print(f"myProc {callid} started ...")<br/>    t1 = time.perf_counter()<br/>    time.sleep(2.5)<br/>    chain = chain + "-&gt;" + str(callid)<br/>    sum = sum + 1<br/>    await asyncio.sleep(2.5)<br/>    t = time.perf_counter() - t1<br/>    print(f"   myProc {callid} finished in {t:0.5f} seconds. sum = {sum} chain {chain}")</span><span id="3f0f" class="mq lc iq mh b gy mv ms l mt mu">async def main():<br/>    await asyncio.gather(<br/>      myproc(1),<br/>      myproc(2),<br/>      myproc(3),<br/>      myproc(4),<br/>      myproc(5)<br/>    )</span><span id="99de" class="mq lc iq mh b gy mv ms l mt mu">if __name__ == "__main__":<br/>    start_sec = time.perf_counter()<br/>    asyncio.run(main())<br/>    elapsed_secs = time.perf_counter() - start_sec<br/>    print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="4b34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是输出:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="51c8" class="mq lc iq mh b gy mr ms l mt mu">myProc 1 started ...<br/>myProc 2 started ...<br/>myProc 3 started ...<br/>myProc 4 started ...<br/>myProc 5 started ...<br/>   myProc 1 finished in 12.51241 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>   myProc 2 finished in 10.01062 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>   myProc 3 finished in 7.51010 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>   myProc 4 finished in 5.00613 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>   myProc 5 finished in 5.00680 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>Job finished in 15.01523 seconds.</span></pre><p id="13e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">行为就不一样了。注意和的值是一样的，链也是一样的。这是为什么呢？这是因为当函数完成时，所有的值都已经被恰当地赋值了。</p><p id="25c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">底线:注意函数调用的哪些部分是同步或异步的，以及在哪里使用变量。它可能会在你不知道的情况下产生不同的结果。</p><h1 id="4c3c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">概括起来</h1><ul class=""><li id="a942" class="mw mx iq kf b kg lz kk ma ko my ks mz kw na la nb nc nd ne bi translated">您可以在python中使用异步处理来模拟并行处理。</li><li id="3538" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">但它不是多线程的。您可以控制哪些部分是异步的，哪些不是。</li><li id="b3f9" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">两个关键词的组合使之成为可能。async应用于函数定义，告诉python该函数是一个异步调用。await告诉命令将控制权暂时传递回调用者。</li><li id="f045" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">注意函数调用内部的逻辑对于同步和异步事件的行为。如果没有在正确的位置访问变量值，可能会导致错误的结果。</li></ul></div></div>    
</body>
</html>