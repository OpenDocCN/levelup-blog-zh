<html>
<head>
<title>JavaScript: Arrays vs Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:数组与对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-arrays-vs-objects-6551efddfa03?source=collection_archive---------2-----------------------#2019-08-04">https://levelup.gitconnected.com/javascript-arrays-vs-objects-6551efddfa03?source=collection_archive---------2-----------------------#2019-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/12a438957bddb53b6b64fc9de78f836b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DWdOVqmpCrgjt3Yz.jpg"/></div></div></figure><p id="07a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在学习JavaScript的时候，我们都会偶然发现“数组只是JavaScript中的对象”这句话。今天，我们将把这句话放在显微镜下观察。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="870f" class="li lj it le b gy lk ll l lm ln">let groceries = ["apples"]<br/>console.log(typeof groceries) // Logs "object"</span></pre><p id="5572" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看一下代码，很明显数组的类型是<code class="fe lo lp lq le b">object</code>。但是，这意味着什么呢？</p><blockquote class="lr ls lt"><p id="9e1a" class="kb kc lu kd b ke kf kg kh ki kj kk kl lv kn ko kp lw kr ks kt lx kv kw kx ky im bi translated">如果你不熟悉<code class="fe lo lp lq le b"><em class="it">typeof</em></code>操作符，请点击链接<a class="ae ly" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/typeof" rel="noopener ugc nofollow" target="_blank">阅读关于<code class="fe lo lp lq le b"><em class="it">typeof</em></code>操作符的</a>。</p></blockquote><h1 id="4962" class="lz lj it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">遗产</h1><p id="da78" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">为了理解对象和数组之间的区别，让我们快速浏览一下JavaScript中的继承。原型继承本身就是一个很大的话题，值得单独发表一篇博文。然而，为了这篇文章的目的，我将保持事情非常基本。</p><p id="236c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript中的每个对象都有一个对其父(原型)对象的引用。当一个方法被调用时，JavaScript会在你正在使用的对象上寻找它。如果没有找到，它会查看原型。它将继续沿着原型链向下，直到找到属性，或者到达根对象。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="47d0" class="li lj it le b gy lk ll l lm ln">var person = {<br/>  name: "Mr. Frontend Mayhem",<br/>}</span><span id="2d33" class="li lj it le b gy nb ll l lm ln">//toString method comes from the prototype because it's not defined on the person object.<br/>console.log(person.toString()) // Logs "[object Object]"</span><span id="0e7b" class="li lj it le b gy nb ll l lm ln">person.toString = function() {<br/>  return this.name<br/>}</span><span id="1547" class="li lj it le b gy nb ll l lm ln">//person object has a toString method of it's own now, which will be used.<br/>console.log(person.toString()) // Logs "Mr. Frontend Mayhem"</span></pre><p id="afea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，创建了一个person对象，它拥有一个名为<code class="fe lo lp lq le b">name</code>的属性。当调用<code class="fe lo lp lq le b">toString</code>方法时，首先检查person对象，然后查找其原型，即<code class="fe lo lp lq le b">Object.prototype</code>。使用原型提供的实现，它具有返回<code class="fe lo lp lq le b">[object Object]</code>的默认行为。</p><p id="0c84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，在person对象本身上创建了<code class="fe lo lp lq le b">toString</code>方法，当从该点开始调用<code class="fe lo lp lq le b">toString</code>时，将使用该方法。</p><h1 id="cd49" class="lz lj it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">对象和数组之间的区别</h1><p id="05ef" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">尽管只是幕后的对象，数组的行为与常规对象非常不同。原因是<code class="fe lo lp lq le b">Array.prototype</code>对象，它拥有所有的<code class="fe lo lp lq le b">Array</code>具体方法。每个新数组都从<code class="fe lo lp lq le b">Array.prototype</code>继承了这些额外的方法。</p><p id="b404" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要注意的一个关键点是<code class="fe lo lp lq le b">Array.prototype</code>的<code class="fe lo lp lq le b">prototype</code>属性的值是<code class="fe lo lp lq le b">Object.prototype</code>。这意味着两件事:</p><ol class=""><li id="460a" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">数组只是对象，但是有一些额外的方法。</li><li id="ae85" class="nc nd it kd b ke nl ki nm km nn kq no ku np ky nh ni nj nk bi translated">没有一个对象能做的事情是数组做不到的。</li></ol><p id="b950" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看实际情况。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="eed4" class="li lj it le b gy lk ll l lm ln">let grocery = ["apple"]<br/>// Prototype of an array is "[]"<br/>console.log(grocery.__proto__) // Logs []<br/>// Looking down the chain, prototype is "{}"<br/>console.log(grocery.__proto__.__proto__) // Logs {}</span><span id="cc90" class="li lj it le b gy nb ll l lm ln">// Arrays are instance of both Array &amp; Object'<br/>console.log(grocery instanceof Array) // Logs true<br/>console.log(grocery instanceof Object) // Logs true<br/>// Objects aren't instance of array<br/>console.log({} instanceof Array) // Logs false</span><span id="7d23" class="li lj it le b gy nb ll l lm ln">// Array.prototype contains Array specific methods such as .push<br/>console.log(typeof Array.prototype.push) // Logs function</span><span id="ac36" class="li lj it le b gy nb ll l lm ln">// Returns undefined because Object<br/>// prototype doesn't have the push method<br/>console.log(typeof Object.prototype.push) // Logs undefined</span></pre><h1 id="502c" class="lz lj it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">古怪</h1><p id="f1c3" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">像JavaScript中的所有东西一样，数组也有自己的特点。</p><p id="7efe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">非索引属性</strong> <br/>由于数组只是伪装的对象，所以可以在数组上设置非索引属性。这通常是第一件让人措手不及的事情。在下面的例子中，我在<code class="fe lo lp lq le b">groceries</code>数组上设置了两个名为<code class="fe lo lp lq le b">sorted</code> &amp; <code class="fe lo lp lq le b">authored by</code>的非索引属性。注意:两个点&amp;括号符号都被支持，就像对象一样。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="9984" class="li lj it le b gy lk ll l lm ln">var groceries = ["banana", "apple"]</span><span id="4442" class="li lj it le b gy nb ll l lm ln">groceries.sorted = false<br/>groceries["authored by"] = "frontendmayhem"</span><span id="66a6" class="li lj it le b gy nb ll l lm ln">//Non-indexed properties won't get logged<br/>console.log(groceries) // Logs ["banana","apple"]</span><span id="7f40" class="li lj it le b gy nb ll l lm ln">//But looking at the keys that exist on the groceries array<br/>// it is clear that both of those properties were added<br/>// to the array.<br/>console.log(Object.keys(groceries))<br/>// Logs ["0","1","sorted","authored by"]</span><span id="e281" class="li lj it le b gy nb ll l lm ln">//non-indexed properties don't affect the length of the array<br/>console.log(groceries.length) // Logs 2</span><span id="247b" class="li lj it le b gy nb ll l lm ln">//length is not "count" of items<br/>groceries[9] = "chicken"<br/>console.log(groceries.length) // Logs 10</span></pre><p id="85b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">长度</strong> <br/> <code class="fe lo lp lq le b">length</code>数组的属性是另一个经常引起混淆的属性。它经常被误解为数组中的项数。然而，事实并非如此。值<code class="fe lo lp lq le b">length</code>在数值上大于最大数组索引。由于这种行为，非索引属性不会影响数组的<code class="fe lo lp lq le b">length</code>，如上面的代码示例所示。</p><p id="a0a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个<code class="fe lo lp lq le b">length</code>可能导致混乱的场景是当一个条目被添加到一个比当前数组长度更高的索引时。请注意，在上面的代码示例中，在我向数组的索引9处添加了第三项之后，数组的长度从2跳到了10。</p><p id="f8ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每当<code class="fe lo lp lq le b">length</code>属性的值改变时，索引大于新的<code class="fe lo lp lq le b">length</code>的每个元素都被删除。</p><blockquote class="lr ls lt"><p id="3ded" class="kb kc lu kd b ke kf kg kh ki kj kk kl lv kn ko kp lw kr ks kt lx kv kw kx ky im bi translated">为了获得正确的长度值，您可以使用<code class="fe lo lp lq le b"><em class="it">Object.keys(groceries).length</em></code>。请记住，这也包括非索引属性，除非您将它们定义为不可枚举的。<code class="fe lo lp lq le b"><em class="it">Object.defineProperty(groceries, "sorted", { value: false, enumerable: false, configurable: true, writable: true });</em></code></p></blockquote><h1 id="1f0d" class="lz lj it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">我应该用什么？</h1><p id="0f29" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">我试图遵循的一条一般经验法则是，如果需要存储不同类型的属性集合，请使用对象。否则，使用数组。</p></div></div>    
</body>
</html>