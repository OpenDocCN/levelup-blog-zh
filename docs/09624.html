<html>
<head>
<title>Creating Security Cameras in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Unity中创建安全摄像头</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-security-cameras-in-unity-e2eafe1b1439?source=collection_archive---------1-----------------------#2021-08-27">https://levelup.gitconnected.com/creating-security-cameras-in-unity-e2eafe1b1439?source=collection_archive---------1-----------------------#2021-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b66311bb2b0330e73b34deaeb01b9e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2C3CAFZ1MOf3tgvMhfxcDg.gif"/></div></div></figure><p id="7911" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们通过巡逻警卫后，我们面对着两个安全摄像头。这些物体由一个静态的支架臂、我们希望以摇摄方式旋转的摄像机本身以及一个将作为其检测方法的可视摄像机圆锥体组成。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/d512dc3f65e6bdd12751001fecf42023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pT12PcxPWX7ziT3UKzojeQ.png"/></div></div></figure><p id="30e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们先来看看动画的旋转。我们只需要在从最小Y值到最大值的所需时间内插入关键帧。然后在我们的<strong class="ka ir"> Animator窗口</strong>中，我们可以在Animator状态的两个实例之间创建一个无限循环，其中一个的速度设置为-1，因此它反向运行。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/379ae70aba9f4d7f9c1adde548885467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVk8PEe4cCu6Pu0EG7udBg.png"/></div></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/66ba2aeef4d4557189bde1dcddd2783b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QIhnwGQMCcGQbD1sbDzVGw.gif"/></div></div></figure><p id="e896" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着相机的动画，让我们看看创造检测。我们的相机视锥装有一个<strong class="ka ir">网格碰撞器</strong>，它允许我们将碰撞器设置为<strong class="ka ir">网格渲染器的形状，</strong>以达到最大的精确度。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/d43430e4ebdb60f5a91fdfb2a16734c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*PYBGf7n0mJiIugxPeirr8w.png"/></div></figure><p id="c474" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用<strong class="ka ir">碰撞器</strong>，我们需要为我们的安全摄像头创建一个新的<strong class="ka ir">脚本</strong>。每个摄像机都有自己的脚本实例，但是如果一个摄像机检测到玩家，我希望两个摄像机都启用捕捉行为。为此，我们可以创建一个<strong class="ka ir">列表</strong>来存储这个脚本的所有实例。使用<strong class="ka ir">标签</strong>我们可以找到场景中的所有摄像机镜头，将它们存储在一个数组中，然后<strong class="ka ir">对每个镜头，</strong>访问它们的脚本以存储在我们的<strong class="ka ir">列表中。</strong></p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/710e759b95d7a989899d2347cbbc04f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ClMKj0sKyofdx4sb188wMQ.png"/></div></div></figure><p id="f1b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<strong class="ka ir">触发回车，</strong>如果<strong class="ka ir">玩家</strong>被检测到，我们可以在所有安全摄像机脚本上调用<strong class="ka ir">玩家调用方法</strong>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/bd87487b3e8cf9913416a48769ba6449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lwxejipWjZO2HF6FmREMnQ.png"/></div></div></figure><p id="9ea6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">player caugh方法</strong>是<strong class="ka ir"> public </strong>，作为一种简单地将bool设置为true的方法。</p><p id="4b62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在我们的<strong class="ka ir">更新方法</strong>中，如果上述bool为真，我们可以启动一个<strong class="ka ir">协程</strong>来运行我们的相机行为。</p><p id="1381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<strong class="ka ir">协程</strong>立即将bool设置为false，以防止调用多个实例。然后，我们运行两个方法，一个停止动画相机旋转，一个改变颜色。接下来，我们在激活过场动画游戏对象之前等待半秒钟。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/8b4e7e883c2b279bbb3b487089ae3dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89tHx5PSFsDuYzp5_Qe2Pg.png"/></div></div></figure><p id="402a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个方法需要捕获它们所需组件的<strong class="ka ir">列表</strong>。</p><p id="ee88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，<strong class="ka ir">动画师</strong>包含在不同的<strong class="ka ir">游戏对象</strong>上，所以我们需要运行另一个<strong class="ka ir"> FindGameObjectsWithTag </strong>函数。然后<strong class="ka ir">对于这些对象中的每一个</strong>，我们可以得到<strong class="ka ir">动画师</strong>并将其添加到<strong class="ka ir">列表中。</strong></p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/e26062c237c18a6dfefcfa2b9843a6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNwrs67OCnz9xDM0MS7UOw.png"/></div></div></figure><p id="4a34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，我们可以简单地禁用<strong class="ka ir">列表中的每个<strong class="ka ir">动画制作人</strong>。</strong></p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/d422a4456a97a9acaad9f449d161db11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1gENRV3-qP-sAM_RNK1Ug.png"/></div></div></figure><p id="eb43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的<strong class="ka ir">网格渲染器，</strong>我们已经捕获了每个<strong class="ka ir">相机圆锥体对象的<strong class="ka ir">数组</strong>，</strong>，所以我们可以简单地追加获取<strong class="ka ir">网格渲染器</strong>并将其添加到<strong class="ka ir">列表</strong>中，旁边是我们获取<strong class="ka ir">脚本的地方。</strong></p><p id="ded8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要改变摄像机镜头的<strong class="ka ir">颜色</strong>，我们必须比标准的<strong class="ka ir">颜色变化更深一点。这是因为我们的对象正在使用粒子着色器来创建适当的外观。在这个<strong class="ka ir">着色器</strong>中，我们想要改变的是<strong class="ka ir">淡色，</strong>因此，在设置颜色之前，我们需要传入这个<strong class="ka ir">字符串值</strong>。</strong></p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/7dba4d4d319802d0350f51c9ebc568ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1Kk5SWAN9irrQ60l-lNWQ.png"/></div></div></figure><p id="8520" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当<strong class="ka ir">玩家</strong>被抓住时，使用静态红色摄像机，我们的过场动画不一定发生在正确的地方。为了解决这个问题，我在<strong class="ka ir">检查器</strong>中存储了一个<strong class="ka ir"> Vector3 </strong>可赋值，为我们的摄像机设置一个最终的旋转来处理过场动画。在我们的<strong class="ka ir">更新方法中，这个方法将与<strong class="ka ir">协程</strong>一起被调用。</strong></p><p id="66e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以简单地抓取脚本所在的摄像机圆锥体的父变换。然后我们可以将<strong class="ka ir">欧拉角</strong>设置为我们的<strong class="ka ir">矢量3变量。</strong></p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/6213246622a1936394578daa8b307e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbHqaeLk525Ndf8loN8aqQ.png"/></div></div></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lc"><img src="../Images/5936e5dfff74458ef762b39371e95a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XqOcqnSOuuCs6C7eflqGhQ.gif"/></div></div></figure></div></div>    
</body>
</html>