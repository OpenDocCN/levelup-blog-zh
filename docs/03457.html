<html>
<head>
<title>Kotlin has 4 ways to access the collection element!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin有4种方法来访问集合元素！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kotlin-has-4-ways-to-access-the-collection-element-1cf20cfdd0ed?source=collection_archive---------9-----------------------#2020-05-10">https://levelup.gitconnected.com/kotlin-has-4-ways-to-access-the-collection-element-1cf20cfdd0ed?source=collection_archive---------9-----------------------#2020-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2034" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">学习Kotlin编程</h2><div class=""/><div class=""><h2 id="c76d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">你有<code class="fe kr ks kt ku b">[ ]</code>、<code class="fe kr ks kt ku b">get</code>、<code class="fe kr ks kt ku b">elementAt</code>和<code class="fe kr ks kt ku b">componentN</code>。用哪个？</h2></div><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/988e1eec84a8e5f41efe301ccf5264c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7xq6iNQXKCy9AyCz"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">图片由<a class="ae ll" href="https://unsplash.com/@danidums" rel="noopener ugc nofollow" target="_blank">丹妮卡坦尤科</a>在<a class="ae ll" href="https://unsplash.com/photos/53rr-FWu2P8" rel="noopener ugc nofollow" target="_blank">喷溅</a></figcaption></figure><p id="7665" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果您必须使用Kotlin集合，您可能以前就访问过它的元素。你是怎么做到的？下面用哪个？</p><ol class=""><li id="05b1" class="mi mj it lo b lp lq ls lt lv mk lz ml md mm mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">val value = myCollection[0]</code></li><li id="d8a3" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">val value = myCollection.get(0)</code></li><li id="1069" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">val value = myCollection.elementAt(0)</code></li><li id="8335" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">val value = myCollection.component1()</code></li></ol><blockquote class="mw"><p id="6847" class="mx my it bd mz na nb nc nd ne nf mh dk translated">有4种方法？！他们有什么不同？</p></blockquote><h1 id="6c53" class="ng nh it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">1.方括号[ ]方法</h1><p id="6782" class="pw-post-body-paragraph lm ln it lo b lp ny kd lr ls nz kg lu lv oa lx ly lz ob mb mc md oc mf mg mh im bi translated">这是默认的推荐方法。它可用于列表、数组和映射。即</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="de44" class="oh nh it ku b gy oi oj l ok ol">val listFirstItem = list[0]    // list = listOf(1)<br/>val arrayFirstItem = array[0]  // array = arrayOf(1)<br/>val mapWithKey0 = map[0]     // map = mapOf(0 to 1)</span></pre><p id="d40f" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">但是，它不能用于序列</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="4e9f" class="oh nh it ku b gy oi oj l ok ol">// Compile Error!<br/>val sequenceFirstElement = sequence[0]  // sequence = sequenceOf(1)</span></pre><p id="9e2e" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此外，它不能用于可空列表、数组或映射</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="a624" class="oh nh it ku b gy oi oj l ok ol">// Compile error, as all of them are nullable.</span><span id="60d7" class="oh nh it ku b gy om oj l ok ol">val listFirstItem = list[0]    // list: List&lt;Int&gt;? = listOf(1)<br/>val arrayFirstItem = array[0]  // array: Array&lt;Int&gt;? = arrayOf(1)<br/>val mapWithKey0 = map[0]  // map: Map&lt;Int, Int&gt;? = mapOf(0 to 1)</span><span id="70b8" class="oh nh it ku b gy om oj l ok ol">// Neither can we do below. It also compile error</span><span id="a6de" class="oh nh it ku b gy om oj l ok ol">val listFirstItem = list?[0]    // list: List&lt;Int&gt;? = listOf(1)<br/>val arrayFirstItem = array?[0]  // array: Array&lt;Int&gt;? = arrayOf(1)<br/>val mapWithKey0 = map?[0]  // map: Map&lt;Int, Int&gt;? = mapOf(0 to 1)</span></pre><h1 id="44fa" class="ng nh it bd ni nj nk nl nm nn no np nq ki on kj ns kl oo km nu ko op kp nw nx bi translated">2.get方法</h1><p id="2fd0" class="pw-post-body-paragraph lm ln it lo b lp ny kd lr ls nz kg lu lv oa lx ly lz ob mb mc md oc mf mg mh im bi translated">括号方法虽然简洁，但它不处理可空集合。</p><p id="bc4d" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">所以与其这样做</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="94ac" class="oh nh it ku b gy oi oj l ok ol">list?.let { val listFirstItem = it[0] }</span></pre><p id="edc3" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="25d8" class="oh nh it ku b gy oi oj l ok ol">val listFirstItem = list?.get(0)</span></pre><p id="5848" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">所以，下面的一切都会起作用。</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="ff53" class="oh nh it ku b gy oi oj l ok ol">val listFirstItem = list?.get(0)    // list: List&lt;Int&gt;?<br/>val arrayFirstItem = array?.get(0)  // array: Array&lt;Int&gt;?<br/>val mapWithKey0 = map?.get(0)       // map: Map&lt;Int, Int&gt;?</span></pre><p id="c457" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">然而，这对于Sequence仍然不起作用</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="9eec" class="oh nh it ku b gy oi oj l ok ol">val sequence = sequenceOf(1)</span><span id="08a4" class="oh nh it ku b gy om oj l ok ol">// Compile Error!<br/>val sequenceFirstElement = sequence.get(0)</span></pre><h1 id="9ca9" class="ng nh it bd ni nj nk nl nm nn no np nq ki on kj ns kl oo km nu ko op kp nw nx bi translated">3.基本方法</h1><p id="0c7e" class="pw-post-body-paragraph lm ln it lo b lp ny kd lr ls nz kg lu lv oa lx ly lz ob mb mc md oc mf mg mh im bi translated">序列有什么特别的？它类似于List，但处理方式不同。详情请看下面。</p><div class="oq or gp gr os ot"><a href="https://medium.com/@elye.project/kotlin-slow-list-and-lazy-sequence-61691fc974c5" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd jd gy z fp oy fr fs oz fu fw jc bi translated">科特林:慢列表和懒惰序列</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">从Java 7到Kotlin，我们很高兴我们可以轻松地在列表中包含集合操作符并链接它们…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph lf ot"/></div></div></a></div><p id="9371" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了得到序列的一个元素，我们将使用<code class="fe kr ks kt ku b">elementAt</code></p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="1832" class="oh nh it ku b gy oi oj l ok ol">val sequence = sequenceOf(1)<br/>val sequenceFirstElement = sequence.elementAt(0)</span></pre><p id="1780" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">类似地，我们也可以对列表和数组使用<code class="fe kr ks kt ku b">elementAt</code>。</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="b7ff" class="oh nh it ku b gy oi oj l ok ol">val listFirstItem = list.elementAt(0)    // list = listOf(1)<br/>val arrayFirstItem = array.elementAt(0)  // array = arrayOf(1)</span></pre><blockquote class="pi pj pk"><p id="ddcf" class="lm ln pl lo b lp lq kd lr ls lt kg lu pm lw lx ly pn ma mb mc po me mf mg mh im bi translated">虽然他们不是首选，因为本质上在引擎盖下，它是<code class="fe kr ks kt ku b">get</code>。并且使用<code class="fe kr ks kt ku b">[]</code>更加简洁。</p></blockquote><p id="2ca5" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">然而，这对于map是不允许的，因为<code class="fe kr ks kt ku b">elementAt</code>在语义上不是描述访问键值元素的正确方式。</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="cba5" class="oh nh it ku b gy oi oj l ok ol">// Compile error<br/>val mapWithKey0 = map.elementAt[0]     // map = mapOf(0 to 1)</span></pre><h1 id="077d" class="ng nh it bd ni nj nk nl nm nn no np nq ki on kj ns kl oo km nu ko op kp nw nx bi translated">4.组件方法</h1><p id="4224" class="pw-post-body-paragraph lm ln it lo b lp ny kd lr ls nz kg lu lv oa lx ly lz ob mb mc md oc mf mg mh im bi translated">如果你阅读Kotlin <a class="ae ll" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/component1.html" rel="noopener ugc nofollow" target="_blank">集合</a>文档，你会发现有<code class="fe kr ks kt ku b">collection1()</code>、<code class="fe kr ks kt ku b">collection2()</code>、<code class="fe kr ks kt ku b">collection3()</code>、<code class="fe kr ks kt ku b">collection3()</code>和<code class="fe kr ks kt ku b">collection5()</code>。</p><p id="9377" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">似乎适用于列表和数组。</p><p id="b626" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你看到引擎盖下的代码，本质上它只是<code class="fe kr ks kt ku b">get(0)</code>、<code class="fe kr ks kt ku b">get(1)</code>、<code class="fe kr ks kt ku b">get(2)</code>、<code class="fe kr ks kt ku b">get(3)</code>和<code class="fe kr ks kt ku b">get(4)</code>。那是为了什么？</p><p id="3a3e" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">嗯，它不是用于正常的使用，而是用于列表/数组的析构。例如</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="d952" class="oh nh it ku b gy oi oj l ok ol">val list = listOf(1, 2, 3, 4, 5)<br/>val (a, b, c, d, e) = list</span><span id="151e" class="oh nh it ku b gy om oj l ok ol">// a=1, b=2, c=3, d=4, e=5</span></pre><p id="d59e" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你尝试</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="4627" class="oh nh it ku b gy oi oj l ok ol">// Error<br/>val list = listOf(1, 2, 3, 4, 5, 6)<br/>val (a, b, c, d, e, f) = list</span></pre><p id="58e2" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">它将错误说明<code class="fe kr ks kt ku b">Destructuring declaration initializer of type List&lt;Int&gt; must have a 'component6()' function</code></p><p id="5e51" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">要修复它，只需创建如下的扩展函数<code class="fe kr ks kt ku b">component6()</code></p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="0597" class="oh nh it ku b gy oi oj l ok ol">private operator fun &lt;E&gt; List&lt;E&gt;.<strong class="ku jd">component6</strong>(): E {<br/>    return get(5)<br/>}</span></pre><p id="ca09" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">嗯，它似乎很有限，我们不太可能用它来析构一个列表或数组。</p><p id="2042" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们几乎没有意识到，实际上这种方法也被用来析构映射条目的键值。</p><div class="oq or gp gr os ot"><a href="https://kotlinlang.org/docs/reference/multi-declarations.html#example-destructuring-declarations-and-maps" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd jd gy z fp oy fr fs oz fu fw jc bi translated">析构声明</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">有时，将一个对象析构成若干个变量是很方便的，例如:这种语法称为…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">kotlinlang.org</p></div></div><div class="pc l"><div class="pp l pe pf pg pc ph lf ot"/></div></div></a></div><p id="9422" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当我们做的时候</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="b38d" class="oh nh it ku b gy oi oj l ok ol">for ((key, value) in map) {<br/> // do something with the key and the value<br/>}</span></pre><p id="b84e" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们实际上使用了下面的底层扩展函数来进行析构。</p><pre class="kw kx ky kz gt od ku oe of aw og bi"><span id="f9f6" class="oh nh it ku b gy oi oj l ok ol">operator fun &lt;K, V&gt; Map&lt;K, V&gt;.iterator(): Iterator&lt;Map.Entry&lt;K, V&gt;&gt; <br/>    = entrySet().iterator()<br/>operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.<strong class="ku jd">component1</strong>() = getKey()<br/>operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.<strong class="ku jd">component2</strong>() = getValue()</span></pre><p id="d911" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们不太可能在日常生活中使用它，但很高兴知道这是什么。</p><blockquote class="pi pj pk"><p id="c467" class="lm ln pl lo b lp lq kd lr ls lt kg lu pm lw lx ly pn ma mb mc po me mf mg mh im bi translated">感谢在这部分学习中提供的答案。</p></blockquote><div class="oq or gp gr os ot"><a href="https://stackoverflow.com/a/61708884/3286489" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd jd gy z fp oy fr fs oz fu fw jc bi translated">Kotlin系列的“组件1”到“组件5”有什么用？</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">这些允许析构声明。在问题链接的页面下方，它解释说…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">stackoverflow.com</p></div></div><div class="pc l"><div class="pq l pe pf pg pc ph lf ot"/></div></div></a></div></div><div class="ab cl pr ps hx pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="im in io ip iq"><p id="19d6" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">总之，我提供一个简单的参考表。</p><p id="4e58" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><strong class="lo jd">更新:添加</strong> <code class="fe kr ks kt ku b"><strong class="lo jd">set</strong></code> <strong class="lo jd">，因为</strong> <code class="fe kr ks kt ku b"><strong class="lo jd">set</strong></code> <strong class="lo jd">对元素的访问与</strong> <code class="fe kr ks kt ku b"><strong class="lo jd">sequence</strong></code>相同</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi py"><img src="../Images/ab99ce47948eae840ea565844b6ecd49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EAWyczvj-8MakhTrMoyaTw.png"/></div></div></figure></div><div class="ab cl pr ps hx pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="im in io ip iq"><p id="221f" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">感谢阅读。你可以在这里查看我的其他话题<a class="ae ll" href="https://medium.com/@elye.project/" rel="noopener">。</a></p><p id="2609" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">关注我关于<a class="ae ll" href="https://medium.com/@elye.project" rel="noopener"> <em class="pl">中</em></a><em class="pl"/><a class="ae ll" href="https://twitter.com/elye_project" rel="noopener ugc nofollow" target="_blank"><em class="pl">推特</em></a><em class="pl"/><a class="ae ll" href="https://www.facebook.com/elye.project/" rel="noopener ugc nofollow" target="_blank"><em class="pl">脸书</em></a><em class="pl"/>或<a class="ae ll" href="https://www.reddit.com/user/elyeproj/" rel="noopener ugc nofollow" target="_blank"> <em class="pl"> Reddit </em> </a>关于移动开发等相关话题的小技巧和学习。~Elye~</p><figure class="kw kx ky kz gt la"><div class="bz fp l di"><div class="pz qa l"/></div></figure></div></div>    
</body>
</html>