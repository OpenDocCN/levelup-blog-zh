<html>
<head>
<title>How to use Java Callable and Future</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Java可调用和未来</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-java-callable-and-future-5d79ecb47c8b?source=collection_archive---------6-----------------------#2020-07-02">https://levelup.gitconnected.com/how-to-use-java-callable-and-future-5d79ecb47c8b?source=collection_archive---------6-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="78f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Java Executor线程管理完全指南—第2部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c7d3e45fa92f8e9fc1696ce72b24b5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ocRH2Rb7JAsKgOJp"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Joshua Sortino 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bb0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-the-executor-framework-in-java-58a610d20b87">文章</a>中，我讨论了如何将Runnable对象用于Executor服务。在本文中，您可以学习如何使用可调用对象和未来对象进行线程管理。</p><p id="a73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Runnable对象定义的任务不能返回结果。那么，如果您想从提交给线程池的任务中返回一个结果，该怎么做呢？解决方案是使用可调用对象，而不是可运行对象。可调用对象返回的结果称为未来对象。使用这个Future对象，我们可以了解可调用任务的状态。Java中的Callable和Future接口都提供了线程管理的方法。所以让我们看看如何在我们的代码中使用这些方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d7bf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">请求即付的</h1><p id="3c8e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">Callable</code>接口有一个名为<code class="fe mz na nb nc b">call()</code>的方法，它应该包含由线程执行的代码。它类似于<code class="fe mz na nb nc b">Runnable</code>接口中的<code class="fe mz na nb nc b">run()</code>方法，但与<code class="fe mz na nb nc b">run()</code>方法不同的是<code class="fe mz na nb nc b">call()</code>方法抛出一个检查过的异常。让我们看一个使用<code class="fe mz na nb nc b">call()</code>方法的简单例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="e473" class="mc md it bd me mf nf mh mi mj ng ml mm jz nh ka mo kc ni kd mq kf nj kg ms mt bi translated">将来的</h1><p id="37b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<code class="fe mz na nb nc b">submit()</code>方法，您可以提交一个<code class="fe mz na nb nc b">Callable</code>对象给executor服务来执行。但是，该方法不知道提交任务的结果何时可用。因此，它返回一个<code class="fe mz na nb nc b">Future</code>对象，当任务结果可用时，该对象可用于检索任务结果。如果你熟悉JavaScript <code class="fe mz na nb nc b">Promises</code>，你会发现<code class="fe mz na nb nc b">Futures</code>和<code class="fe mz na nb nc b">Promises</code>非常相似。<code class="fe mz na nb nc b">Future</code>接口提供了一个<code class="fe mz na nb nc b">get()</code> <strong class="lb iu"> </strong>方法，可以等待<code class="fe mz na nb nc b">Callable</code>完成然后返回结果。有一个重载版本的<code class="fe mz na nb nc b">get()</code>方法，您可以在其中指定等待结果的时间。</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="8f17" class="no md it nc b gy np nq l nr ns">Future.get(long timeout, TimeUnit unit)</span></pre><p id="9c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有助于避免当前线程被长时间阻塞。还可以使用<code class="fe mz na nb nc b">isDone()</code>方法来检查任务是否完成。如果任务完成，则返回true，否则返回false。</p><p id="5b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个使用<code class="fe mz na nb nc b">ExecutorService</code>执行<code class="fe mz na nb nc b">Callable</code>任务并使用未来接口的<code class="fe mz na nb nc b">get()</code>方法获得结果的例子。如果你在理解下面例子中的执行器服务和线程池时有任何困难，请参考我以前的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-the-executor-framework-in-java-58a610d20b87">文章</a>，我在其中讨论了这些概念。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bd41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java Future还提供了一个<code class="fe mz na nb nc b">cancel()</code>方法，该方法接受一个布尔参数来取消相关的可调用任务。它尝试取消任务的执行，如果成功取消则返回true，否则返回false。如果你运行<code class="fe mz na nb nc b">cancel(true)</code>，那么当前正在执行任务的线程将被中断。您可以使用<code class="fe mz na nb nc b">isCancelled()</code>方法来检查任务是否被取消。还有，取消任务后，<code class="fe mz na nb nc b">isDone()</code>总会返回true。</p><p id="6a73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过将一组<code class="fe mz na nb nc b">Callable</code>对象传递给<code class="fe mz na nb nc b">ExecutorService</code>接口中的<code class="fe mz na nb nc b">invokeAll()</code>方法来执行多个任务，该方法返回未来对象的列表。</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="0368" class="no md it nc b gy np nq l nr ns">List&lt;Callable&lt;String&gt;&gt; taskList = Arrays.asList(task1,task2,task3);<br/>List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(taskList);</span></pre><p id="8b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">invokeAny()</code>方法也接受<code class="fe mz na nb nc b">Callables</code>的集合，执行它们，并返回单个任务第一次成功执行的结果(如果已经成功执行过)<em class="nt">。</em></p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="f1d3" class="no md it nc b gy np nq l nr ns">List&lt;Callable&lt;String&gt;&gt; taskList = Arrays.asList(task1,task2,task3);<br/>String result = executorService.invokeAny(<!-- -->taskList<!-- -->);</span></pre><p id="9671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java还有一个名为<code class="fe mz na nb nc b">FutureTask</code>的具体类，它实现了Runnable和Future，方便地结合了两种功能。下面是创建一个<code class="fe mz na nb nc b">FutureTask</code>对象的例子。可以通过向其构造函数提供一个<code class="fe mz na nb nc b">Callable</code>来创建该对象。</p><pre class="kj kk kl km gt nk nc nl nm aw nn bi"><span id="d4b4" class="no md it nc b gy np nq l nr ns">FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable);</span></pre><p id="efc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">execute()</code>方法可以执行<code class="fe mz na nb nc b">FutureTask</code>对象。大多数情况下，您不需要在应用程序代码中使用<code class="fe mz na nb nc b">FutureTask</code>，因为您可以通过提交一个<code class="fe mz na nb nc b">Callable</code>任务，然后使用返回的<code class="fe mz na nb nc b">Future</code>对象来完成同样的事情。您可以根据自己的需求选择使用哪种方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是对Java中Callable和Future工作原理的理解。好了，希望你学到了新的东西，希望以后能给你带来更多有趣的文章。</p><p id="ed9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读和快乐编码！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f733" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ul class=""><li id="714c" class="nu nv it lb b lc mu lf mv li nw lm nx lq ny lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.baeldung.com/java-executor-service-tutorial" rel="noopener ugc nofollow" target="_blank">Java ExecutorService指南</a></li><li id="a825" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html" rel="noopener ugc nofollow" target="_blank"> Java Oracle docs接口未来</a></li><li id="c861" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html" rel="noopener ugc nofollow" target="_blank"> Java Oracle docs接口可调用</a></li></ul></div></div>    
</body>
</html>