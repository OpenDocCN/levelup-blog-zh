# 像我五岁一样解释自由单子(第一部分)

> 原文：<https://levelup.gitconnected.com/explain-free-monad-like-i-am-five-part-1-5bee794074bd>

![](img/e969974e873c29204528ed073dbf7a22.png)

照片由 Meagan Carsience 拍摄

在 Cats 文档中:

> 自由单子是一种允许你从任何函子中构建单子的结构。

另一个定义说，从效果函数(可能不纯)转换到表示我们的领域逻辑的普通数据结构是一个想法。

简单地说，它就像一个包装器，将任何 ADT 包装到一元结构 DSL 中，您可以用它来创建程序。它把你的程序 DSL 和它的解释器分开，这样你可以挑选不同的解释器。

本文将从一个简单的 Todo 应用程序(没有并发性等等)开始，从命令的角度出发，慢慢地将它转换成自由的 monad 风格。

# 创造代数

上面，我们用一个简单的 CRUD 创建了`Todo` case 类。

将 DSL 嵌入到其他编程语言中的最初方法是使用 ADT 将编程语言中的每个句子编码成 ADT 的一种形式。

# 命令式程序

我们会想做一系列的操作，如`Create`一`Todo`。然后，我们可以`Find`这个 id 属于待办事项列表。`Read`待办事项列表，显示我们所有待办事项的结果，并标记我们已经完成的待办事项。

做这些事情的必要方法可以是像这样构造这些 ADT 的列表:

所以上面的程序只是一个*描述*。为了执行这个计划，我们需要一些执行解释器来运行它。

让我们创建一个“执行”解释器:

当我们运行上面描述的程序时，我们使用模式匹配来做各种各样的动作。这是我们所有副作用和所有变异发生的地方。因此，我们将循环通过程序，并对每个描述运行`execute`:

到目前为止，一切顺利。然而，我们上面描述的 ADT 不是很有用。例如，我们不能`Find`一个 id，并根据那个 id 标记待办事项。理想情况下，我们希望进行顺序操作，比如创建一个 to do 列表，读取所有 Todo 列表，并标记完成的列表。

我们需要找到一种方法来获得前一个操作的值，并根据前一个操作的评估值进行一些其他的顺序处理。听起来像单子，对吧？

理想情况下，我们希望这样做:

```
val program = for {
  todo <- Create("Do Laundry")
  listTodos <- Read
  idZero <- Find(0L)
  _ <- Mark(todo.id)
} yield ()
```

现在的问题是，既然程序不再是一个列表，我们如何创建解释器？

因为我们在程序上创建一个通用的数据结构，所以我们希望有某种“包装器”用一个单子绑定来包装这些数据结构，以构造一个单子类型的程序。

# 大改写

我们需要返回我们的代数来“返回”一些值，以便在一元绑定中捕获它:

让我们写一个程序的包装器，这样它就可以有一元绑定函数。一元运算可以翻译成这样:

我们引入`FlatMap`和`Pure`将我们最初的代数类型绑定到单子:

想象一下`F[_]`像`Todo`，但是它可以是任何类型的`F[_]`。它没有任何约束，`FlatMap`和`Pure`类似于 Monad 中的`flatMap`和`pure`，它将上下文绑定到一个顺序操作中。

Free 是一种递归数据结构，其中每个后续计算都可以访问前一个计算。这就是我们使用一个简单的数据结构来构建程序所需要的，这个数据结构对它的解释是自由的。

根据以上理解，我们如何使上述`Free` ADT 起作用？

理想情况下，我们希望得出这样的结论:

为此:

1.  自由必须是单子。它需要一些`flatMap`和`map`以便 scala 可以检测和执行“理解”。
2.  我们希望程序在*空闲时*执行`flatMap`，而不是我们定义的“动作”ADT。这使得动作只是一个数据结构，我们可以稍后连接到我们的解释器。

# 以单子的形式创造自由

让我们构造一个自由函数，它需要有一个`map`和一个`flatMap`方法。

上面的代码`flatMap`递归地执行 flatMap，直到遇到`Pure`，并将`func`应用到`a`。`f andThen (a => a.flatMap(func))`表示首先将输入应用到`f`来构成函数。`f(a)`的返回值是一个`Free[F[_], B]`。然后，返回值被应用于后续函数`a => flatMap(func)`。如果还是不明白，就把上面的代码拍进 IntelliJ，自己试着解一下类型。你对输入类型和返回类型看得越多，你就越知道如何创建上面的函数。

一旦我们准备好了`map`和`flatMap`函数，我们就可以开始构建我们的程序了。

然而，我们如何建构自由呢？

# 举起免费的东西

我们想把`Action`的`lift`变成`Free[F[_],A]`。

让我们创建一个`lift`函数来完成这个任务:

然后，我们可以创建这样的程序:

我们也可以创建一个 DSL，通过创建一个隐式转换使它更可读:

# 解释者

既然我们已经创建了自己的程序，我们还需要以某种方式将程序与解释器绑定起来。

让我们回头看看我们定义的第一个解释器:

上面的代码看起来不错，但是我们如何将上面的解释器与我们的自由单子连接起来呢？

我们想这样做——给定下面的`Free[F,A]`数据结构，我们想遍历`Free`结构，评估每一步，并将结果线程化到下一个后续计算。我们要折叠程序描述的`List`。

最终，我们将免费做同样的事情，为`FlatMap`和`Return`创建一个模式匹配:

我在上面放了一个`???`,因为我们无法访问自己创建的常规解释器。如果我们也提供解释器作为另一个参数来评估`Action`:

我们可以像这样用现有的解释器运行我们的程序:

```
runProgram(program)
```

# 结论

通过首先介绍创建程序描述的传统命令式方法，我们已经走了很长的路。我们意识到，我们无法在一个常规的描述“列表”中访问先前计算的值，也无法进行我们想要的顺序计算。

然后，我们创建了一个 *Free* 结构，使我们能够将现有的 ADT 包装成更为单一的东西。我们通过让*平面图*和*纯*引入*自由* ADT，这类似于*平面图*和*纯*的一元绑定。除此之外，我们还创造了一种将`lift`类型转化为`Free`类型的方法来理解它们。

最后，我们使用我们创建的现有解释器`execute`，并执行`Free`程序。

在本系列的第 2 部分中，我想深入探讨我们如何能够一般化`Free` ADT 并创建一个 *free* 结构，以便最终在任何程序中创建 DSL。敬请期待！

完整的源代码在这里是。

**感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的**[](https://edward-huang.com/subscribe/)****来获取关于科技职业的文章、有趣的链接和内容！****

**你可以关注我，也可以在[媒体](https://medium.com/@edwardgunawan880)上关注我，以获得更多类似的帖子。**

***原载于*[*https://edward-huang.com*](https://edward-huang.com/functional-programming/scala/programming/monad/2020/09/06/explain-free-monad-like-i-am-five-part-1/)*。***