<html>
<head>
<title>Advanced Code Organization Patterns: The Case For One Function Per File</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级代码组织模式:每个文件一个函数的情况</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-code-organization-patterns-the-case-for-one-function-per-file-da68c15826e8?source=collection_archive---------3-----------------------#2022-03-16">https://levelup.gitconnected.com/advanced-code-organization-patterns-the-case-for-one-function-per-file-da68c15826e8?source=collection_archive---------3-----------------------#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3bce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">回到这个模式的基础。</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1d1a1e5199f1042f579effe27de8001b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uo41mNLAO2ZjPaLT6tMH2Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@afgprogrammer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">穆罕默德·拉赫马尼</a>在<a class="ae kv" href="https://unsplash.com/s/photos/software?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2b06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">免责声明:这篇文章是在考虑前端项目的情况下写的，比如网站、React本地移动应用和电子应用。尽管后端编程有一些可移植的技能，正如我下面提到的。还有，标题有点开玩笑。😄这个没那么高级，但是经常被忽略。</em></p><p id="9848" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将谈论一种在前端项目中组织功能代码的模式，这是非常基本的，但经常被完全忽视…它被称为… <em class="ls">一个文件一个功能！</em></p><p id="3458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“你一定是在开玩笑，对吗？文件组织？这样一个基本的概念，我不能相信这个家伙会发这样的帖子……”好吧，我会反驳说，它被认为是<em class="ls">如此简单，以至于经常被忽视和遗忘，从长远来看，可能会导致巨大的“上帝”文件，其中充满了数十个函数。所以考虑看看这个帖子吧！并且尊重基本！</em></p><h1 id="7255" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">两种代码组织模式</h1><p id="1146" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">考虑两种组织代码功能的方法:</p><ol class=""><li id="0de2" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">将几个相关的函数组合成一个文件。例如:<code class="fe mz na nb nc b"><strong class="ky ir">utils/</strong></code>文件夹下一个名为<code class="fe mz na nb nc b"><strong class="ky ir">math.js</strong></code>的文件，里面有<code class="fe mz na nb nc b"><strong class="ky ir">add</strong></code>、<code class="fe mz na nb nc b"><strong class="ky ir">subtract</strong></code>、<code class="fe mz na nb nc b"><strong class="ky ir">multiply</strong></code>和<code class="fe mz na nb nc b"><strong class="ky ir">divide</strong></code>的函数:</li></ol><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="06b2" class="nh lu iq nc b gy ni nj l nk nl"><strong class="nc ir">utils</strong></span><span id="f49a" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">└── math.js</strong></span><span id="9681" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">^ contains functions add, subtract, multiply, and divide</strong></span></pre><ol class=""><li id="4897" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">将每个函数放在自己的文件中。例如:<code class="fe mz na nb nc b"><strong class="ky ir">utils/math/</strong></code>文件夹下的<code class="fe mz na nb nc b"><strong class="ky ir">add.js</strong></code>、<code class="fe mz na nb nc b"><strong class="ky ir">subtract.js</strong></code>、<code class="fe mz na nb nc b"><strong class="ky ir">multiply.js</strong></code>、<code class="fe mz na nb nc b"><strong class="ky ir">divide.js</strong></code>文件:</li></ol><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="6ff7" class="nh lu iq nc b gy ni nj l nk nl"><strong class="nc ir">utils</strong></span><span id="4e67" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">└── math</strong></span><span id="d37d" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">    ├── add.js</strong></span><span id="ceb2" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">    ├── divide.js</strong></span><span id="d75b" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">    ├── multiply.js</strong></span><span id="9bca" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">    └── subtract.js</strong></span></pre><p id="dedc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在相当长的一段时间里，我习惯于选择1。更好。将相关函数组织到同一个文件中！想不到！好像很有道理吧？更少的文件，更低的复杂性？</p><p id="2da5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着时间的推移，处理越来越大的项目，处理小的、可管理的代码构建块就越令人耳目一新。无论如何，我们可以通过使用各种文件夹来命名分组，从而抽象出“相似”或“相关”功能的概念。</p><p id="aa3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看我在十多年的软件工程师职业生涯中了解到的单函数文件更好的三个原因。</p><h1 id="4173" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用单一功能文件的三个原因</h1><h1 id="5366" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">1.试验</h1><p id="c8cb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当你想对你的函数进行单元测试时，在阅读测试代码时，很清楚你要导入的是哪一个函数——不多也不少。对于集成测试来说，这也很清楚——我们希望看到集成测试所需的每个功能的导入。</p><h1 id="69fd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">2.代码合并</h1><p id="7694" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果您有一个包含特性和热修复分支的复杂git树，将许多函数放在一个大的“utils”文件或类似文件中只会在您希望保留每个函数的功能性(没有双关语)时导致麻烦。当你的每一个函数都被隔离到一个单独的文件中时，浏览每个文件的git历史并查看给定函数(并且只<em class="ls">那个函数)做了什么更改就容易多了。</em></p><h1 id="35e9" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">3.组织</h1><p id="c0ea" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">仅仅根据<code class="fe mz na nb nc b"><strong class="ky ir">import</strong></code>语句就能立即理解函数的位置，这就更容易找到代码库的组织。选择1。，函数<code class="fe mz na nb nc b"><strong class="ky ir">add</strong></code>在它自己命名的文件中，<code class="fe mz na nb nc b"><strong class="ky ir">subtract</strong></code>也是如此，等等。采用备选方案2。，从思考“好吧...<code class="fe mz na nb nc b"><strong class="ky ir">utils/</strong></code>，<code class="fe mz na nb nc b"><strong class="ky ir">math.js</strong></code>...啊哈！<code class="fe mz na nb nc b"><strong class="ky ir">add</strong></code>在<code class="fe mz na nb nc b"><strong class="ky ir">math.js</strong></code>以内！”</p><p id="f02a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在编写任何复杂的现代应用程序，相信我:你将会有<em class="ls">许多</em>实用函数，都是围绕各种动作、任务和活动收集的——如果你正确划分代码，很容易超过50甚至100个函数。</p><h1 id="655f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">缺点</h1><p id="72b5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这种模式没有太多缺点——我能想到的只有一个缺点，那就是如果你将你的每一个函数划分到一个单独的文件中，你的<code class="fe mz na nb nc b"><strong class="ky ir">import</strong></code>语句(或者<code class="fe mz na nb nc b"><strong class="ky ir">require</strong></code>语句)将会更多。<em class="ls">然而</em>，如果您选择选项1，大多数linters和formatters无论如何都会生成<code class="fe mz na nb nc b"><strong class="ky ir">import</strong></code>多行。以上，即格式如下:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="9942" class="nh lu iq nc b gy ni nj l nk nl"><strong class="nc ir"><em class="ls">import</em> {</strong></span><span id="def9" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">add,</strong></span><span id="7d63" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">subtract,</strong></span><span id="57e1" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">multiple,</strong></span><span id="bd6a" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">divide</strong></span><span id="ff7c" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir">} <em class="ls">from</em> "./utils/math"</strong></span></pre><p id="2da3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而不是组织模式(选项2。)那我建议:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="46e0" class="nh lu iq nc b gy ni nj l nk nl"><strong class="nc ir"><em class="ls">import</em> { add } <em class="ls">from</em> "./utils/math/add"</strong></span><span id="62a2" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir"><em class="ls">import</em> { subtract } <em class="ls">from</em> "./utils/math/subtract"</strong></span><span id="3795" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir"><em class="ls">import</em> { multiply } <em class="ls">from</em> "./utils/math/multiply"</strong></span><span id="6a28" class="nh lu iq nc b gy nm nj l nk nl"><strong class="nc ir"><em class="ls">import</em> { divide } <em class="ls">from</em> "./utils/math/divide"</strong></span></pre><p id="cd4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，对你们这些线猎犬来说，这是一条更短的线😉</p><h1 id="efa8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">其他考虑</h1><p id="1918" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">请注意，这种模式是针对您自己的内部代码的。如果你要发布一个库或者包，从同一个文件中导出所有的文件是有意义的，比如and <code class="fe mz na nb nc b"><strong class="ky ir">index.js</strong></code>或者<code class="fe mz na nb nc b"><strong class="ky ir">index.ts</strong></code>。即使这样，这也只是为了导出接口，库本身的源代码可以(而且在我看来，应该)使用这种模式。</p><p id="db15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，这篇文章的整体看起来非常明显。但是我已经看到代码组织的缺乏在许多不同的项目中一次又一次地出现，所以我认为我应该重申这种模式的重要性。</p><p id="3fd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式也可以移植到面向对象的编程中。如果您发现您在一个类中编写了太多的私有(甚至公共)方法，这表明您应该将一些逻辑分解到另一个类中，最终得到更小、更易读、更易于理解的代码。</p><h1 id="1b4d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">谢谢！</h1><p id="9458" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">你喜欢如何在面向客户端的应用程序中组织你的功能？你会选择选项1吗？或者2。，为什么？</p><p id="1950" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干杯，</p><p id="65a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">克里斯🍺</p></div></div>    
</body>
</html>