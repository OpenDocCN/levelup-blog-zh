<html>
<head>
<title>Buggy Memoized Components and React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">错误的内存组件和反应挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/buggy-memoized-components-and-react-hooks-6d83ccbd50a5?source=collection_archive---------17-----------------------#2020-03-28">https://levelup.gitconnected.com/buggy-memoized-components-and-react-hooks-6d83ccbd50a5?source=collection_archive---------17-----------------------#2020-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84c43e6ba9c93524a70c0e22007d49e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qqlUP529fm3cagIz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">蔬菜</figcaption></figure><p id="d2b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">本条</em> <a class="ae lb" href="https://github.com/MarkGeeRomano/stale-functions" rel="noopener ugc nofollow" target="_blank"> <em class="la">的配套回购可以在这里找到</em> </a></p><p id="f7f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文概述了使用从父代传下来的状态改变方法的记忆化功能组件可能遇到的一个错误。起初，我不理解我所看到的行为——在我意识到这是什么之后，它有助于巩固我对钩子本质的理解。希望这篇文章也能帮助你理解钩子。</p><p id="9461" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在工作中，我试图记忆一个列表项类型的组件，以避免不必要的重新呈现，并向它传递一个将该项切换为收藏夹的函数。因为不是每个人都喜欢遵守广告技术隐私立法的例子——我的工作领域——让我们假设这个列表呈现了一些更普遍的东西——口袋妖怪。准确的说是最初的151个。</p><p id="d587" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">代码非常简单。一个<code class="fe lc ld le lf b">App</code>组件，在这里我们的状态被初始化，还有一个<code class="fe lc ld le lf b">Tile</code>组件，一个列表项组件，它呈现口袋妖怪的图像、名称和❤️(如果它是最喜欢的)。</p><p id="9f19" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">状态是由151个对象组成的数组。每个对象包含一个<code class="fe lc ld le lf b">url</code>属性和一个<code class="fe lc ld le lf b">isFavorite</code>属性，前者包含我们将放入<code class="fe lc ld le lf b">&lt;img/&gt;</code>标签的口袋妖怪图像的url，后者初始化为<code class="fe lc ld le lf b">false</code>。有一个<code class="fe lc ld le lf b">toggleFavorite</code>函数接受一个索引，并返回一个总是有用的高阶函数，该函数翻转给定pokemon的<code class="fe lc ld le lf b">isFavorite</code>布尔值，并将更新后的数组传递给从<code class="fe lc ld le lf b">useState</code>返回的<code class="fe lc ld le lf b">setPokemon</code>函数。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="d881" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe lc ld le lf b">Tile</code>拿一个口袋妖怪物体当道具，还有<code class="fe lc ld le lf b">toggleFavorite</code>功能。它会呈现口袋妖怪的图像、名字，如果它是最喜欢的，还会呈现一颗心。点击它最父级的<code class="fe lc ld le lf b">div</code>可以将它标记为收藏或不收藏。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/54d58b87ba5c6d92ac4943d6b34b6a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*ZdfpzeFaeaWTGvvrlc0bHg.gif"/></div></figure><p id="0b5a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">很管用。让我们记住<code class="fe lc ld le lf b">Tile</code>这样就不会每次都刷新了。为了记忆功能组件，我们将其包装在<code class="fe lc ld le lf b">React.memo</code>中。它工作于浅层比较道具，如果有任何不同，它将使用给定的更新道具重新渲染组件。在我们的例子中，浅渲染是不够的，因为我们传递的是一个对象和一个函数。所以我们可以传入第二个参数，回调，到<code class="fe lc ld le lf b">memo</code>。在这个回调中，我们可以访问旧属性和新属性，因为我们知道如果<code class="fe lc ld le lf b">isFavorite</code>的值已经改变，我们只需要重新呈现组件，我们可以比较这些值并返回一个布尔值。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="3df1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们试着点击一下。应该没有明显的区别，除了可能稍微快一点，对吗？</p><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/e5cea7270166208d76e12e99bf109b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9EwKPBR3LXhT206kvkO9ZA.gif"/></div></figure><p id="46cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">似乎当你点击后面的口袋妖怪时，红心正在消失。然后如果你点击前面的，心就会回来。再点击什么，一切又会变得疯狂。这确实是一些奇怪的行为。经过一番挠头和大量的控制台日志记录后，我意识到:</p><p id="204f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">内存化组件的</em> <code class="fe lc ld le lf b"><em class="la">toggleFavorite</em></code> <em class="la">函数内部是对</em> <code class="fe lc ld le lf b"><em class="la">pokemon</em></code> <em class="la">状态数组的陈旧引用。在定义的时候，每个对象都有一个</em><code class="fe lc ld le lf b"><em class="la">isFavorite</em></code><em class="la"/><code class="fe lc ld le lf b"><em class="la">false</em></code><em class="la">的值。当你喜欢一个口袋妖怪时，你看到的是每次更新的原始数组，而不是预期的数组。</em></p><p id="9bcb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个问题突出了基于类的组件和基于钩子的组件之间的主要区别——状态在呈现之间是不可变的。类没有我们刚刚看到的问题，因为每个函数调用都会发生变异<code class="fe lc ld le lf b">this.state</code>。我们可以在setter函数中传递一个回调来解决这个问题。传入的参数是真实的先前状态，因此我们可以确保我们永远不会处理对状态值的过时引用。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><figure class="lg lh li lj gt jr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/58cc4d73f14ba0b53760c60c4ec4e9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*V0erKUlt9xUVUB62Zy_9mA.gif"/></div></figure><p id="74ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读！本文的配套回购<a class="ae lb" href="https://github.com/MarkGeeRomano/stale-functions" rel="noopener ugc nofollow" target="_blank">可以在这里找到</a></p></div></div>    
</body>
</html>