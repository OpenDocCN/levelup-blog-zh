<html>
<head>
<title>Unit Test and Integration Test for AWS Lambda/NodeJS in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中AWS Lambda/NodeJS的单元测试和集成测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-test-and-integration-test-for-aws-lambda-nodejs-in-typescript-2235a0f69f5?source=collection_archive---------4-----------------------#2020-10-05">https://levelup.gitconnected.com/unit-test-and-integration-test-for-aws-lambda-nodejs-in-typescript-2235a0f69f5?source=collection_archive---------4-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8aafb0c2870149a7f669ca80b847ee27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IvwiqcYq0n1uTgBZVYcDLg.png"/></div></div></figure><div class=""/><h1 id="a728" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">AWS Lambda/NodeJS(类型脚本)系列</h1><ol class=""><li id="6d24" class="kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><a class="ae lo" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-typescript-for-aws-lambda-in-3-steps-1996243547eb">如何在3个步骤中为AWS Lambda使用TypeScript</a></li><li id="647b" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj lk ll lm ln bi translated"><a class="ae lo" href="https://medium.com/@zijing/unit-test-and-integration-test-for-aws-lambda-nodejs-in-typescript-2235a0f69f5" rel="noopener">TypeScript中AWS Lambda/NodeJS的单元测试和集成测试</a></li></ol><h1 id="5b3d" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">准备</h1><p id="6646" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">我们将使用<code class="fe mj mk ml mm b">jest</code>来管理所有的测试。为了在TypeScript中使用<code class="fe mj mk ml mm b">jest</code>，我们必须安装一些<code class="fe mj mk ml mm b">babel</code>依赖项。请检查下面的安装命令:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="03eb" class="mv jz jb mm b gy mw mx l my mz"><em class="na">// install jest and types<br/></em><strong class="mm jc">$ npm i -D jest @types/jest</strong></span><span id="4407" class="mv jz jb mm b gy nb mx l my mz"><em class="na">// install babel support to use jest with typescript<br/></em><strong class="mm jc">$ npm i -D babel-jest @babel/core @babel/preset-env @babel/preset-typescript</strong></span></pre><p id="50f8" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">我们将它们安装在<code class="fe mj mk ml mm b">dev-dependencies</code>中，因为它们只在测试期间使用，而不在最终构建的包中使用。安装之后，我们需要在中创建<code class="fe mj mk ml mm b">babel.config.js</code>来让babel工作。文件内容:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="5545" class="mv jz jb mm b gy mw mx l my mz"><strong class="mm jc">module</strong>.<strong class="mm jc">exports</strong> = {<br/>    <strong class="mm jc">presets</strong>: [<br/>        ['@babel/preset-env', {targets: {node: 'current'}}],<br/>        '@babel/preset-typescript',<br/>    ],<br/>};</span></pre><p id="3261" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">文件结构现在看起来像这样:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="3f6d" class="mv jz jb mm b gy mw mx l my mz">.<br/>├── README.md<br/>├── hello-world<br/>│   ├── <strong class="mm jc">babel.config.js</strong><br/>│   ├── package-lock.json<br/>│   ├── package.json<br/>│   ├── src-ts<br/>│   └── tsconfig.json<br/>├── samconfig.toml<br/>└── template.yaml</span></pre></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="b87e" class="jy jz jb bd ka kb no kd ke kf np kh ki kj nq kl km kn nr kp kq kr ns kt ku kv bi translated">单元测试</h1><p id="f645" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">要使用<code class="fe mj mk ml mm b">jest</code>，最好有一个配置文件，我们可以用<code class="fe mj mk ml mm b">jest cli</code>生成文件:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="85e4" class="mv jz jb mm b gy mw mx l my mz"><em class="na">// pwd: $ROOT/hello-world</em><strong class="mm jc"><em class="na"><br/></em>$</strong> <strong class="mm jc">./node_modules/.bin/jest</strong> <strong class="mm jc">init</strong> <em class="na">// generate jest.config.js</em><br/><strong class="mm jc">$</strong> <strong class="mm jc">mv</strong> <strong class="mm jc">jest.config.js jest.config.test.js</strong> <em class="na">// rename</em></span></pre><p id="2614" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">在生成的<code class="fe mj mk ml mm b">jest.config.test.js</code>中，我们需要以下选项:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="cc2c" class="mv jz jb mm b gy mw mx l my mz">module.exports = {<br/><em class="na">  </em>clearMocks: false,<br/><em class="na">  </em>collectCoverage: true,<br/><em class="na">  </em>coverageDirectory: "coverage",<br/><em class="na">  </em>coverageProvider: "v8",<br/><br/><em class="na">  </em>testEnvironment: "node",<br/><em class="na">  </em>testMatch: [<br/><strong class="mm jc">    "**/unit/**/*.test.ts"<br/></strong>  ],<br/>};</span></pre><p id="97f1" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">然后让我们创建我们的第一个单元测试文件<code class="fe mj mk ml mm b">hello-world/tests/unit/test-handler.test.ts</code>。接下来，我们可以用在上一篇文章中创建的app handler的单元测试来填充文件。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="d014" class="mv jz jb mm b gy mw mx l my mz"><strong class="mm jc">import</strong> { <strong class="mm jc">APIGatewayProxyEvent</strong> } from "aws-lambda";<br/><strong class="mm jc">import</strong> { <strong class="mm jc">lambdaHandler</strong> } from "../../src-ts/app";<br/><br/><strong class="mm jc">describe</strong>('Unit test for app handler', function () {<br/>    <strong class="mm jc">it</strong>('verifies successful response', <strong class="mm jc">async</strong> () =&gt; {<br/>        <strong class="mm jc">const</strong> event: <strong class="mm jc">APIGatewayProxyEvent</strong> = {<br/>            queryStringParameters: {<br/>                a: "1"<br/>            }<br/>        } as any<br/>        <strong class="mm jc">const</strong> result = <strong class="mm jc">await</strong> lambdaHandler(event)<br/><br/>        <strong class="mm jc">expect</strong>(result.statusCode).<strong class="mm jc">toEqual</strong>(200);<br/>        <strong class="mm jc">expect</strong>(result.body).<strong class="mm jc">toEqual</strong>(`Queries: ${<strong class="mm jc">JSON</strong>.<strong class="mm jc">stringify</strong>(event.queryStringParameters)}`);<br/>    });<br/>});</span></pre><p id="7ead" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">在<code class="fe mj mk ml mm b">package.json</code>中添加一个新的命令，这样我们可以很容易地运行单元测试:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="6ea8" class="mv jz jb mm b gy mw mx l my mz">"scripts": {<br/>  <strong class="mm jc">"test": "jest --config=jest.config.test.js",</strong><br/>  "compile": "tsc"<br/>}</span></pre><p id="9cba" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">现在，我们应该能够运行单元测试并查看覆盖率报告了:</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/0f656f04829e17ca571f568b071c63a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qercZvKGBdRFFDdlxSNyA.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">单元测试运行结果</figcaption></figure><p id="2a7c" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">看起来棒极了！文件结构现在看起来像这样:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="f8fe" class="mv jz jb mm b gy mw mx l my mz">.<br/>├── README.md<br/>├── hello-world<br/>│   ├── babel.config.js<br/><strong class="mm jc">│   ├── jest.config.test.js</strong><br/>│   ├── package-lock.json<br/>│   ├── package.json<br/>│   ├── src-ts<br/><strong class="mm jc">│   ├── tests<br/>│   │   └── unit<br/>│   │       └── test-handler.test.ts</strong><br/>├── samconfig.toml<br/>└── template.yaml</span></pre></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><blockquote class="ny nz oa"><p id="fc53" class="lu lv na ky b kz nc lw lx lb nd ly lz ob ne mb mc oc nf me mf od ng mh mi lj ij bi translated">如果你觉得这篇文章有用，请关注这个帐户，以便将来更新。感谢支持！</p></blockquote><h1 id="1d9e" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">整合测试</h1><p id="72a7" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">为了区分集成测试和单元测试，我们需要一个不同的jest配置文件，即带有内容的<code class="fe mj mk ml mm b">jest.confg.integ.test.js</code>:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="eb08" class="mv jz jb mm b gy mw mx l my mz"><em class="na">// no need for coverage here</em><br/>module.exports = {<em class="na"><br/>  </em>testEnvironment: "node",<em class="na"><br/>  </em>testMatch: [<br/><strong class="mm jc">    "**/integ/**/*.integ.test.ts"<br/></strong>  ],<em class="na"><br/></em>};</span></pre><p id="5866" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">要运行集成测试，我们还需要以下两样东西:</p><ul class=""><li id="ae56" class="kw kx jb ky b kz nc lb nd ld oe lf of lh og lj oh ll lm ln bi translated">运行我们lambda的本地服务器</li><li id="7a08" class="kw kx jb ky b kz lp lb lq ld lr lf ls lh lt lj oh ll lm ln bi translated">向本地服务器发送请求的HTTP SDK包</li></ul><h2 id="08a6" class="mv jz jb bd ka oi oj dn ke ok ol dp ki ld om on km lf oo op kq lh oq or ku os bi translated">在本地服务器上运行lambda</h2><p id="2895" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">幸运的是，AWS SAM CLI提供了使用以下命令在本地运行堆栈的能力:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="6454" class="mv jz jb mm b gy mw mx l my mz"><em class="na">// pwd: $ROOT/hello-world<br/></em><strong class="mm jc">$ sam local start-api -t ../template.yaml</strong></span></pre><p id="dc8e" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">该命令需要安装<code class="fe mj mk ml mm b">Docker</code>，更多信息可以参考<a class="ae lo" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-cli-command-reference-sam-local-start-api.html" rel="noopener ugc nofollow" target="_blank">本文档</a>。在执行之后，它将在<code class="fe mj mk ml mm b">127.0.0.1:3000</code>打开一个服务器监听。</p><p id="ad00" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">最好也将上面的命令添加到NPM脚本中:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="dcab" class="mv jz jb mm b gy mw mx l my mz">"scripts": {<br/>  "test": "jest --config=jest.config.test.js",<br/>  <strong class="mm jc">"start-local": "sam local start-api -t ../template.yaml",</strong><br/>  "compile": "tsc"<br/>},</span></pre><h2 id="81fa" class="mv jz jb bd ka oi oj dn ke ok ol dp ki ld om on km lf oo op kq lh oq or ku os bi translated">将HTTP SDK添加到项目中</h2><p id="c33b" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">我们将选择<code class="fe mj mk ml mm b">Axios</code>向上面启动的服务器发送请求:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="2cca" class="mv jz jb mm b gy mw mx l my mz"><strong class="mm jc">$ npm i -D axios @types/axios</strong></span></pre><p id="37ef" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">创建一个集成测试文件<code class="fe mj mk ml mm b">hello-world/tests/integ/handler.integ.test.ts</code>，内容为:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="e822" class="mv jz jb mm b gy mw mx l my mz"><strong class="mm jc">import</strong> <strong class="mm jc">axios</strong> from "axios";<br/><br/><strong class="mm jc">describe</strong>("Integration Test", () =&gt; {<br/>    <strong class="mm jc">it</strong>("hello world integration test", <strong class="mm jc">async</strong> () =&gt; {<br/>        <strong class="mm jc">const</strong> query = { a: "hi" };<br/>        <strong class="mm jc">const</strong> response = <strong class="mm jc">await</strong> axios.get("http://localhost:3000/hello", {<br/>            params: query<br/>        });<br/><br/>        <strong class="mm jc">expect</strong>(response.status).<strong class="mm jc"><em class="na">toEqual</em></strong>(200);<br/>        <strong class="mm jc">expect</strong>(response.data).<strong class="mm jc"><em class="na">toEqual</em></strong>(`Queries: ${<strong class="mm jc">JSON</strong>.<strong class="mm jc">stringify</strong>(query)}`);<br/>    });<br/>});</span></pre><p id="c93e" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">在这个集成测试中，我们使用<code class="fe mj mk ml mm b">axios</code>向上面启动的服务器发送一个<code class="fe mj mk ml mm b">GET</code>消息。更重要的是，我们使用<code class="fe mj mk ml mm b">async</code>和<code class="fe mj mk ml mm b">await</code>来保持测试代码的简单性和可读性。</p><p id="78ff" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">同样，在<code class="fe mj mk ml mm b">package.json</code>中为集成测试添加一个执行命令:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="84c9" class="mv jz jb mm b gy mw mx l my mz">"scripts": {<br/>  "test": "jest --config=jest.config.test.js",<br/>  "integ-test": "jest --config=jest.config.integ.test.js",<br/><strong class="mm jc">  "start-local": "sam local start-api -t ../template.yaml",<br/></strong>  "compile": "tsc"<br/>}</span></pre><h2 id="05ce" class="mv jz jb bd ka oi oj dn ke ok ol dp ki ld om on km lf oo op kq lh oq or ku os bi translated">运行集成测试</h2><p id="574a" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">我们需要两个控制台进行集成测试，一个用于服务器，另一个用于运行集成测试。看一下运行结果:</p><figure class="mn mo mp mq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ot"><img src="../Images/68bede740ac68cf162d0a5938ecdd9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFWI3DORTG-oAqa3q0CcOw.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">集成测试执行</figcaption></figure><p id="8192" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">最终文件结构:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="2254" class="mv jz jb mm b gy mw mx l my mz">.<br/>├── README.md<br/>├── hello-world<br/>│   ├── babel.config.js<br/><strong class="mm jc">│   ├── jest.config.integ.test.js</strong><br/>│   ├── jest.config.test.js<br/>│   ├── package-lock.json<br/>│   ├── package.json<br/>│   ├── src-ts<br/>│   │   └── app.ts<br/>│   ├── tests<br/><strong class="mm jc">│   │   ├── integ<br/>│   │   │   └── handler.integ.test.ts</strong><br/>│   │   └── unit<br/>│   │       └── test-handler.test.ts<br/>│   └── tsconfig.json<br/>├── samconfig.toml<br/>└── template.yaml</span></pre><h1 id="499f" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="6fef" class="pw-post-body-paragraph lu lv jb ky b kz la lw lx lb lc ly lz ld ma mb mc lf md me mf lh mg mh mi lj ij bi translated">厉害！我们现在不仅可以用TypeScript编写lambda处理程序，还可以用TypeScript编写单元/集成测试。完整的代码可以在<a class="ae lo" href="https://github.com/zijing07/aws-lambda-nodejs-ts" rel="noopener ugc nofollow" target="_blank">https://github.com/zijing07/aws-lambda-nodejs-ts</a>找到。</p><p id="d856" class="pw-post-body-paragraph lu lv jb ky b kz nc lw lx lb nd ly lz ld ne mb mc lf nf me mf lh ng mh mi lj ij bi translated">在下一篇文章中，我将分享如何在AWS Lambda中用DDB创建单元/集成测试。</p><blockquote class="ny nz oa"><p id="975f" class="lu lv na ky b kz nc lw lx lb nd ly lz ob ne mb mc oc nf me mf od ng mh mi lj ij bi translated">如果你觉得这篇文章有用，请关注这个帐户，以便将来更新。感谢支持！</p></blockquote></div></div>    
</body>
</html>