<html>
<head>
<title>HowTo: Developing a full-stack production simulation with Python and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HowTo:使用Python和React开发全栈生产模拟</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/howto-developing-a-full-stack-production-simulation-with-python-and-react-c8daaf464556?source=collection_archive---------8-----------------------#2022-03-28">https://levelup.gitconnected.com/howto-developing-a-full-stack-production-simulation-with-python-and-react-c8daaf464556?source=collection_archive---------8-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="b57a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">基于React、Flask和本体论的生产仿真</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d1dcd4f0e8b732cf89cafa9e0e380309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnzR5x7NQv6pv7aABtrnOw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:作者图片</figcaption></figure><h1 id="23c2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">想法</h1><p id="a57c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">使用Python等构建的制造模拟的一个挑战是缺乏图形可视化。当开发出新的策略、方法和算法时，这一点尤其重要。对决策的理解对于快速开发算法(如调度、分派、生产控制)至关重要。到目前为止，与大型商业模拟(如AnyLogic、PlantSim)相比，用Python编写的开源模拟缺乏生成漂亮、流畅和可用的图形可视化的能力。</p><h1 id="6f9e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">内容</h1><ul class=""><li id="54cb" class="lz ma iq ld b le lf li lj lm mb lq mc lu md ly me mf mg mh bi translated">在基于Python的制造模拟中显示和比较图形可视化选项</li><li id="6c8f" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">将图形模拟用于OntolgySim的示例</li></ul><h1 id="9334" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">选项1:使用Tkinter的离线应用程序</h1><p id="2b56" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Tkinter是一个2D绘图表面库，因此可以显示简单的形状。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1534" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">所有相关的数据，应该是可视化的，像机器，产品，必须在每个时间步创建，以产生一个静态图片。由于静态表示，有几个缺点，特别限制了用户友好性:</p><ul class=""><li id="1078" class="lz ma iq ld b le mp li mq lm mu lq mv lu mw ly me mf mg mh bi translated">拖放元素:例如，如果创建了模拟</li><li id="1224" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">选择元素:显示更多信息，例如产品</li><li id="2fe6" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">像缩放窗格这样的选项:对于大型模拟，可见表面的动态调整<br/>此外，在没有图形界面的服务器上运行程序是不可能的。</li></ul><h1 id="42ee" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">选项2:使用JavaScript进行可视化</h1><p id="e286" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个想法是利用JavaScript的强大功能来实现图形化。要连接Python和JavaScript，需要一个web服务器。Python和Flask包支持通过API进行数据传输。作为一个JavaScirpt框架，使用React。</p><p id="535b" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">概念过程如下:</p><ul class=""><li id="fd7d" class="lz ma iq ld b le mp li mq lm mu lq mv lu mw ly me mf mg mh bi translated">React用于图形化实现，向Python发送API请求以获取最新的模拟状态</li><li id="66c3" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">下一步，提取、处理所有相关数据，并通过AJAX调用发送回React。</li><li id="e1a7" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">随后，可以基于当前模拟数据构建可视化。例如，对于可视化，React Konva是合适的。对象的创建类似于Python，最大的优势是通过动态渲染的机会，如缩放、拖放，元素点击变得很容易。</li><li id="0d34" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">动态可视化允许通过回调对模拟进行更改，也允许通过单击显示附加数据。</li></ul><p id="ae55" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">然而，由于web服务器的设置，在开始时需要更多的编程工作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mx"><img src="../Images/86b8c0186a5584e29a5c8a56906b7fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aO9DzDRlzsfwO90_OrSPQQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用JavaScript进行可视化的概念，来源:作者图片</figcaption></figure><p id="b9fa" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">作为全栈应用实现的另一大优势是可以为仿真建立一个完整的仪表板。因此，在这种情况下，事件数据、KPI可以快速可视化，并增加进一步的图形建模。</p><h1 id="1d14" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">带有本体论的全栈应用示例</h1><p id="1c38" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">以开源仿真包OntologySim和React的扩展实现为例，展示了具体的实现。模拟和图形可视化的安装如下所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi my"><img src="../Images/e764e748374a78d431ee0e1c30360988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbcrCASWr3QmXWbR1L7YEA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:作者图片</figcaption></figure><h1 id="948d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">履行</h1><p id="a35d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">仿真的实现基于React和Flask的全栈应用。仿真的基础是一个本体，它存储所有的状态并允许很大的灵活性。为了通过图形用户界面访问本体，所有访问操作符都被包装在Python中独立的包装器方法中，并作为API接口提供。通过AJAX调用，前端应用程序链接到后端。应该注意的是，Ajax调用不是无状态API，因为模拟状态存储在服务器上。该图显示了使用的库和自定义编程的库。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/d518dd9bf5af0667e27584d199432d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5R1QOr832chSLYo6Zp3aA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">本体论结构，来源:作者图片[1]</figcaption></figure><h1 id="cff8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">可能性</h1><p id="f0da" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">总之，React、Flask和OntologySim的组合实现了以下功能:</p><ul class=""><li id="081b" class="lz ma iq ld b le mp li mq lm mu lq mv lu mw ly me mf mg mh bi translated">生产布局的图形可视化，KPI</li><li id="174f" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">通过图形界面启动和导出模拟</li><li id="0a43" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">查看模拟步骤，包括返回的可能性</li><li id="210c" class="lz ma iq ld b le mi li mj lm mk lq ml lu mm ly me mf mg mh bi translated">事件的过滤、分类和显示</li></ul><h1 id="14eb" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">装置</h1><p id="4553" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了设置模拟，必须安装前端和后端。对于安装，您需要node -v 16.13.1和python&gt;3.6。</p><p id="ea97" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated"><strong class="ld ir"> 1)安装前端<br/> </strong>仿真可通过GitHub获得</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="b976" class="nf jo iq nb b gy ng nh l ni nj">git clone <a class="ae nk" href="https://github.com/larsKiefer/ontologysim_react" rel="noopener ugc nofollow" target="_blank">https://github.com/larsKiefer/ontologysim_react</a><br/>cd ontologysim_react</span></pre><p id="1391" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">有两种安装方式。第一种选择是通过Docker和Docker compose进行安装</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="3582" class="nf jo iq nb b gy ng nh l ni nj">docker-compose up — build</span></pre><p id="af7f" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">第二种选择是通过npm进行安装。</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="4490" class="nf jo iq nb b gy ng nh l ni nj">npm install<br/>npm start</span></pre><p id="1f59" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">安装成功后，应该可以从<strong class="ld ir"> localhost:3000 </strong>调用。</p><p id="737b" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated"><strong class="ld ir"> 2)安装后端</strong></p><p id="92c9" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">对于后端的安装，可以通过pip下载</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="2ce6" class="nf jo iq nb b gy ng nh l ni nj">pip install ontologysim</span></pre><p id="cf24" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">然后请用下面两行创建一个python文件。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8930" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">下一步，您需要在命令中运行新创建的文件。之后，可以在浏览器中输入以下内容来测试安装</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="bfd4" class="nf jo iq nb b gy ng nh l ni nj">localhost:5000/test</span></pre><h1 id="7645" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">模拟分析</h1><p id="a3dc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">模拟的图形显示允许对模拟进行具体分析。事件日志和KPI都可用于此目的。由于本体在后台，所以可以来回遍历事件步骤。这意味着单个步骤可以重复几次。</p><p id="db14" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated"><strong class="ld ir"> 1)上传仿真配置<br/> </strong>第一步是在“上传”选项卡下加载配置。配置类型可以在这里找到:<a class="ae nk" href="https://ontologysim.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://ontologysim.readthedocs.io/en/latest/</a>，但也有可能使用一个样本模拟。加载模拟后，以下分析选项可用:</p><p id="fc71" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated"><strong class="ld ir"> 2)事件日志<br/> </strong>该软件允许您跟踪所有事件，并有可能对数据进行排序和过滤。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/bd96181b69b7c41434e7de125a01c6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Md8eRwObBAF3ZDyFPeQ7bw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">模拟的事件记录器，来源:作者提供的图片[1]</figcaption></figure><p id="5493" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated"><strong class="ld ir"> 3)仿真可视化<br/> </strong>在视图选项卡下，控制器的决策以图形方式可视化。有可能倒退到更好地分析决策。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/ff9af17c30115f80e43ec7ebb37fc4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00h7WnPVAZp5DmrXZ4waIA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">更多信息，来源:作者图片[1]</figcaption></figure><p id="0542" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated"><strong class="ld ir"> 4 ) KPI存储</strong> <br/>在模拟进行之后，KPI可以显示在图表中。此外，还可以导出KPI结果。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/3498082fd984bee7ac7f14df1ddd6cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMK5sOre642Kcz3wPWnOTQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">模拟运行的KPI仪表板，来源:作者图片[1]</figcaption></figure><h1 id="979a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">结论</strong></h1><p id="1898" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">感谢阅读。如果你有什么要补充的，欢迎随时留言评论！</p><p id="f859" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">关于本体论的技术解释、基础知识和文献综述，可以在这里找到:<a class="ae nk" href="https://doi.org/10.3390/app12031608" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/app12031608</a></p><p id="7d8c" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated"><strong class="ld ir">参考:</strong></p><div class="nm nn gp gr no np"><a href="https://github.com/larsKiefer/ontologysim_react" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">GitHub-larsKiefer/ontology sim _ react</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">Ontologysim React用于可视化用Ontologysim创建的模拟运行。本体论反应仅用作…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kv np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://github.com/larsKiefer/ontologysim" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">GitHub-larsKiefer/本体论</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">Ontologysim是一个开源的深度生产模拟框架，重点是模块化的灵活库…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od kv np"/></div></div></a></div><p id="1fe2" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">感谢这项工作的支持者:马文·卡尔·梅、安德烈亚斯·库恩勒和吉塞拉·兰扎</p><p id="356a" class="pw-post-body-paragraph lb lc iq ld b le mp lg lh li mq lk ll lm mr lo lp lq ms ls lt lu mt lw lx ly ij bi translated">这项研究工作是在DIGIMAN4.0项目的背景下进行的(“DIG- 565零缺陷工业4.0生产的数字化制造技术”，<a class="ae nk" href="http://www.digiman4-" rel="noopener ugc nofollow" target="_blank">http://www . digi man 4-</a>566 0 . MEK . dtu . dk/)。DIGIMAN4.0是一个由Horizon 2020支持的欧洲培训网络，Horizon 2020是欧盟567研究和创新框架计划(项目ID: 814225)</p><h1 id="96d7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">来源</strong></h1><p id="a52c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">[1]: May MC，Kiefer L，Kuhnle A，Lanza G .基于本体的生产模拟与本体主义。<em class="of">应用科学</em>。2022;12(3):1608.<a class="ae nk" href="https://doi.org/10.3390/app12031608" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/app12031608</a></p></div></div>    
</body>
</html>