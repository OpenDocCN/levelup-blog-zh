<html>
<head>
<title>Load balancing in Golang Cloud-Native microservice with Consul and Fabio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang Cloud中的负载平衡Consul和Fabio的原生微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/load-balancing-in-golang-cloud-native-microservice-with-consul-and-fabio-f3026493982b?source=collection_archive---------5-----------------------#2022-04-18">https://levelup.gitconnected.com/load-balancing-in-golang-cloud-native-microservice-with-consul-and-fabio-f3026493982b?source=collection_archive---------5-----------------------#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d64f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://medium.com/p/731a01c648b4" rel="noopener">上一篇文章</a>中，我用一个真实的演示向你展示了如何在基于Consul和Docker的Golang云原生微服务应用中进行服务发现。在演示中，简单<code class="fe km kn ko kp b">helloworld-server</code>服务在consult中注册，<code class="fe km kn ko kp b">helloworld-client</code>可以通过consult发现服务的动态地址。但是前面的演示有一个限制，正如我在上一篇文章中提到的，在真实的微服务应用程序中，每个服务可能有多个实例来处理网络请求。</p><p id="333a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将展开演示，向您展示当一个服务的多个实例在Consul中注册时，如何做<code class="fe km kn ko kp b">load balancing</code>。</p><p id="f9b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续上一个帖子，新的演示将继续使用云原生方式与<code class="fe km kn ko kp b">Docker</code>和<code class="fe km kn ko kp b">Docker-compose</code>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/14273ee08978b64ca730be618458eacf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VXmsQ0iWmLgad68c"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">由<a class="ae kl" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="55ec" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Fabio负责负载平衡</h1><p id="e73e" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">为了实现Consul的负载平衡，Consul官方文档推荐了几种策略。在这篇文章中，我选择使用<a class="ae kl" href="https://github.com/fabiolb/fabio" rel="noopener ugc nofollow" target="_blank">法比奥</a>。</p><blockquote class="mj mk ml"><p id="c814" class="jn jo mm jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated"><em class="iq"> Fabio是一款开源工具，为Consul管理的服务提供快速、现代、零配置的负载平衡HTTP(S)和TCP路由器。用户通过健康检查在Consul中注册服务，fabio会自动将流量发送给他们。不需要额外的配置。</em></p></blockquote><p id="7475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Fabio是一个有趣的项目，它基于Consul中服务注册的<code class="fe km kn ko kp b">tag</code>信息实现负载均衡。</p><p id="d93f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户使用以<code class="fe km kn ko kp b">urlprefix-</code>开头的标签注册服务，比如:</p><pre class="kr ks kt ku gt mq kp mr ms aw mt bi"><span id="38bd" class="mu lh iq kp b gy mv mw l mx my">urlprefix-/my-service</span></pre><p id="e161" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，当在<code class="fe km kn ko kp b">/my-service</code>向fabio发出请求时，fabio会自动将流量路由到集群中的健康服务。我将在下面的演示中告诉你如何做。我还将通过查看源代码对Fabio如何实现这一负载平衡策略进行简单的研究，并在下一篇文章中分享研究结果。</p><h1 id="3bc0" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Fabio负载平衡演示</h1><p id="8f72" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">首先，这篇文章中显示的所有代码和配置文件都可以在这个<a class="ae kl" href="https://github.com/baoqger/service-discovery-demo" rel="noopener ugc nofollow" target="_blank"> github repo </a>中找到，请<code class="fe km kn ko kp b">git checkout</code>到<code class="fe km kn ko kp b">load-balancing</code>分支查看这篇文章的演示。</p><h2 id="e80c" class="mu lh iq bd li mz na dn lm nb nc dp lq jy nd ne lu kc nf ng ly kg nh ni mc nj bi translated">服务器端</h2><p id="c3d9" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">对于<code class="fe km kn ko kp b">helloworld-server</code>，有两个变化:</p><ul class=""><li id="240a" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">首先，每个服务实例应该有一个惟一的<code class="fe km kn ko kp b">ID</code>；</li><li id="3fee" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">第二，添加<code class="fe km kn ko kp b">Tags</code>进行服务注册，标签遵循<code class="fe km kn ko kp b">Fabio</code>的规则。</li></ul><p id="863c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们来检查一下新版本代码。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="cefa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些更改位于第30、32和40行，并在那里添加了注释来解释更改的目的。简单地说，现在每个服务实例都用一个惟一的ID注册自己，这个ID由基本服务名(本例中是helloworld-server)和动态地址组成。另外，我们为每个注册添加了<code class="fe km kn ko kp b">urlprefix-/helloworld</code> <strong class="jp ir">标签</strong>。<code class="fe km kn ko kp b">urlprefix-</code>是Fabio的默认配置，您可以根据需要设置自定义前缀。基于这个<strong class="jp ir">标签</strong>，Fabio可以对<code class="fe km kn ko kp b">/helloworld</code>端点进行自动负载均衡。</p><p id="68fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是服务器端的代码更改。让我们回顾一下客户的变化。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9e6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以前，我们需要运行<code class="fe km kn ko kp b">serviceDiscoveryWithConsul</code>来发现要调用的服务地址。现在，由于我们有<code class="fe km kn ko kp b">Fabio</code>作为负载均衡器，所以我们将请求发送到<code class="fe km kn ko kp b">Fabio</code>，我们的请求将由<code class="fe km kn ko kp b">Fabio</code>分发到服务实例。</p><p id="676c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这部分逻辑在以下方法中实现:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0d8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了获得Fabio服务的地址，我们需要将其配置为一个环境变量，该变量将在Docker-compose的<code class="fe km kn ko kp b">yml</code>文件中设置。现在让我们来看看新的<code class="fe km kn ko kp b">yml</code>文件。</p><h2 id="3a3a" class="mu lh iq bd li mz na dn lm nb nc dp lq jy nd ne lu kc nf ng ly kg nh ni mc nj bi translated">docker-撰写配置</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0ed9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个<code class="fe km kn ko kp b">yml</code>配置文件中有几个变化:</p><ul class=""><li id="4096" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">添加新服务<code class="fe km kn ko kp b">Fabio</code>。如上所述，Fabio是一个zero-conf负载均衡，可以简单地作为docker容器运行。这是如此方便，完全符合云原生风格。两个环境变量:<code class="fe km kn ko kp b">registry_consul_addr</code>和<code class="fe km kn ko kp b">proxy_strategy</code>，用于定义领事的地址和循环策略。</li><li id="6eb0" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">为客户端设置<code class="fe km kn ko kp b">FABIO_HTTP_ADDR</code>环境变量。这就是我们在上一节提到的，它允许<code class="fe km kn ko kp b">client.go</code>获取Fabio服务地址并发送请求。</li><li id="134c" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">将两个docker镜像升级到<strong class="jp ir"> v1.0.2 </strong>。</li></ul><h2 id="396e" class="mu lh iq bd li mz na dn lm nb nc dp lq jy nd ne lu kc nf ng ly kg nh ni mc nj bi translated">演示</h2><p id="1557" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">是时候运行演示了！假设您在本地机器上构建了所有docker映像，然后运行以下命令:</p><pre class="kr ks kt ku gt mq kp mr ms aw mt bi"><span id="a1ab" class="mu lh iq kp b gy mv mw l mx my">docker-compose up --scale helloworld-server=3</span></pre><p id="0f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个命令有一个关于Docker-compose的重要提示:如何运行某些服务的多个实例。在我们的例子中，我们需要多个<code class="fe km kn ko kp b">helloworld-server</code>实例来实现负载平衡。Docker-compose通过<code class="fe km kn ko kp b">--scale</code>选项支持这一功能。对于上面的命令，将启动helloworld-server的3个实例。</p><p id="b609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在下图中看到演示的结果:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi oa"><img src="../Images/028e070f86573a88684a9922fcdf1b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XWMyq9Z_6c2QXMO_.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">负载平衡</figcaption></figure><p id="c233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端重复并定期发送请求，Fabio以循环方式将每个请求分配给三个实例中的一个。正是我们所期望的！</p></div></div>    
</body>
</html>