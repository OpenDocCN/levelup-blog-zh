# 一堆 Go 泛型

> 原文：<https://levelup.gitconnected.com/a-heap-of-go-generics-cd20f362a76>

![](img/2c9469ae3bb7e6cdccb0e2497c01e2d5.png)

我来自使用[泛型](https://en.wikipedia.org/wiki/Generic_programming)的语言，此外，我在 Go 中编写的样板代码的数量也有问题。所以，我一直带着希望期待着去仿制药。我已经记住了特定类型的泛型用例，当我发现我可以在[的 Go2 Go 游乐场](https://go2goplay.golang.org/)玩 Go 的泛型时。我决定试试看能不能解决一个。对于那些想要 T4 TLDR 的人来说，答案是:是的！

## 我的使用案例

如果你用过 Go 的[容器/堆](https://golang.org/pkg/container/heap/)，你可能也会觉得它很笨拙。如果给定一个像切片这样的东西，只需要缺少一个类型化的比较函数就可以拥有一个堆，为什么还要有那么多样板代码呢？

例如，从头实现一个通用的 Kotlin 堆可能如下所示:

泛型确保我们包含、比较、推送和弹出一个类型(T)。给定这些已知的约束，您可以轻松地实现一个泛型堆。你可以用你希望的任何类型来实例化它，提供一个适合类型的比较函数:

## 使用 Go 泛型

用 Go 泛型我能实现什么？事实上我想要的一切。看看下面这个使用我的 Go 泛型堆的例子:

它正确地产生了:

```
1
1
2
{70}
{42}
{30}
{23}
```

那就是一堆**应该**的样子。一些数据和一个比较器。谁在乎是什么类型。

## 怎么做到的？

下面是整个 Go 泛型堆的实现。它干净、简单、实用:

我现在真的很期待去仿制药。