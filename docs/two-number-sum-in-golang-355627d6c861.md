# 戈兰的两个数和

> 原文：<https://levelup.gitconnected.com/two-number-sum-in-golang-355627d6c861>

学习如何在 Go 中编程，同时还要学习编码面试问题！

![](img/6e61f201b690756c16d98f056c4f2663.png)

来自 [Chinquada](https://deepdreamgenerator.com/ddream/pubfgohk0vb)

这里有许多学习新编程语言的方法，我最喜欢的一种是完成编码面试问题！你不仅要提高批判性思维技能，编码问题通常会迫使你利用编程语言中最重要的部分，比如数据结构、分支和循环方法。

不仅如此，我们都知道准备编码面试的阻力。我更喜欢每天提高一点我的编码技能，而不是在工作申请的压力下临时抱佛脚几个月。通过这种方式，我可以保持对我选择的编程语言、我的问题解决技巧的敏锐，同时避免将来不必要的压力。

好吧，那么，让我们来看看常见的两个数和问题，我们将使用我目前最喜欢的编程语言来解决，开始！作为参考，我将在这里解决 LeetCode 上的问题:

[](https://leetcode.com/problems/two-sum/) [## 两个总和代码

### 给定一个整数 num 数组和一个整数 target，返回这两个数字的索引，使它们加起来等于…

leetcode.com](https://leetcode.com/problems/two-sum/) 

**注:**本文假设了解大 O 符号。

# 理解问题

两个数和问题是这样的——给你一个名为`nums`的整数数组。也给你一个整数`target`，你的任务是看数组中是否有两个数加起来是`target`。如果有，那么返回两个数的索引*和`target`的数组。否则，只返回一个空数组。*

以下基本假设适用于此问题:

*   每个解只有一个解。
*   不能两次使用同一个元素。
*   可以任意顺序返回答案。

编写问题的第一步是拿出**个例子**来确认你的理解。如果给你一个数组`[2,7,11,15]`和目标值 9，你将返回数组`[0,1]`。这个问题很简单，所以举几个例子就够了——但是随着问题变得越来越复杂，写出你的理解并说出来，让你的大脑为更困难的代码解决过程做好准备变得非常重要。

# 一个强力解决方案——O(N)时间，O(1)空间

让我们想一个最简单的方法来检查数组中是否有两个数加起来是`target`。我们可以很容易地一次检查数组的一个元素，然后检查数组的其余元素，看这两个元素是否匹配。

所以我们将有两个参数，一个整数的`array`和一个`target`值。我们还将通过在函数参数后添加`[]int`来返回一个整数数组。然后，我们将得到第一个 for 循环的当前值的值`start`，以及第二个 for 循环的值`end`。设置`j=i+1`很重要，这样我们就不会重复计算数组中的单个值。

总而言之，强力解决方案可能是这样的:

如果我们有一个通过数组递归的双 for 循环，我们将有 O(N)的时间复杂度。除了变量`start`和`end`之外，我们也不存储任何数据，所以我们有常数空间 O(1)。如果你想知道为什么双 for 循环有二次运行时间，这里有一个很好的关于 N 个自然数之和的视频例子:

# 使用散列映射— O(N)时间，O(N)空间

好吧，让我们再仔细想想。双 for 循环解决方案的主要低效之处是什么？好吧，我们实际上在几个元素上循环了很多次，绝对超过了必要的次数。如果我们可以跟踪我们已经看到的东西，这样我们就不必重复检查数组的元素了，会怎么样？

我们可以用一个散列图做到这一点！Go 使得实现这种数据结构变得轻而易举，它如此有用的部分原因是它具有恒定的 O(1)访问时间。让我们将它添加到我们的新函数尝试中。

在我们新的`twoSum()`函数中，我们首先初始化一个名为`seenNums`的空散列映射。我们将把我们已经看到的数字存储为一个散列映射键，并将这些数字的*索引*存储为一个散列映射值。

我们可以使用`range`关键字从`array`中获取当前索引`i`和对应的编号`num`。对于数组的每个值，我们创建一个变量`potentialMatch`，这个变量*可能是我们需要的*值。我们从`target`中减去当前值`num`来得到我们*需要的*数，并且希望在我们的`seenNums`散列图中。因此，如果我们的目标是 9，并且我们当前有值 3，我们需要查看 9–3 = 6 是否在我们的哈希表中。

为了验证这一点，我们用散列图做了一个很好的 Go 一行程序。记住，我们的 hash map `seenNums`将看到的数字存储为一个键，并将该数字的索引存储为一个值。在第 5 行，我们得到了值(index) j 和一个布尔值`found`，它告诉我们键`potentialMatch`是否存在于`seenNums`中。如果`found`为真，我们可以通过在哈希映射操作的末尾添加`;`后直接放置它来立即检查。

因此，如果所有这些都检查过了，那么我们的哈希表实际上就有了当前值`num`的`potentialMatch`!然后我们可以返回当前的索引`i`和我们的索引`potentialMatch`、`j`。

**不要忘记:**在检查完 for 循环中的每个元素后，我们必须将键`num`和值`i`添加到我们的散列图`seenNums`中，以跟踪我们看到了哪些数字以及它们的索引是什么。

因为我们只遍历数组一次，所以时间复杂度是 O(N)。此外，我们可以在哈希映射中存储数组的每个元素，所以空间复杂度也是 O(N)。

# 排序和计算— O(NlogN)时间，O(1)空间

是时候变得大胆了。我们使用了一个散列映射来避免过多地查看数组元素。但是，如果我们对空间要求严格，但是又想比二次时间更快呢？让我们想一想。

在我们希望值等于`target`而不是索引的情况下，我们可以跟踪当前的两个和值。如果我们对数组进行排序，那么我们可以有两个索引来表示数组开头和结尾的补码对。然后，我们将“压缩”它们，以缩小与`target`相等的可能称赞对的范围。

例如，我们的补码对可以是 4 和 15，而`target`值为 10。我们知道 4+15=19，大于 10。由于数组已经排序，我们希望*减少*我们的两个和补码对，因此我们将减少最终值的索引以更接近值 10。

Go 使得数组排序变得很容易，我们可以只导入包`"sort"`然后调用`sort.Ints(array)`。然后，我们可以将变量`start`和`end`指定为从`array`的起始和结束索引开始。

从那里开始，如果`start`变得大于`end`，我们的循环将终止，因为如果发生这种情况，我们将知道我们已经查看了排序数组中的每个值，但找不到有效的两个和对。在每个循环迭代的开始，我们从当前索引的数组值中找到`currentSum`值。

如果`currentSum`的值等于`target`，我们找到正确的索引并相应地返回它们。如果总和小于`target`，那么我们想要一个更大的值，因此*增加*我们计算窗口的`start`值。最后一个`else`条件是当当前总和大于`target`时，我们*减少*我们的计算窗口的`end`值。

我们的 for 循环是 O(N)，但是它需要 O(NlogN)时间来排序我们的数组—所以我们的时间复杂度将是[O(N) + O(NlogN)]=O(NlogN)。虽然它比我们的 hash map 解决方案要慢一点，但是我们有一个额外的好处，那就是不存储任何数据结构来获得恒定的空间复杂度 O(1)。

虽然这个问题相当简单，但它很好地介绍了 Go 中的排序、数组、函数和散列映射。不仅如此，我们还找到了三种不同时间和空间复杂度的解决方案。由你和面试官来决定哪种解决方案最适合你的情况，但是最重要的是，除了你的问题解决技巧之外，你还能适应你所选择的编程语言，以便灵活地实现。

如果你喜欢这篇文章或者想看其他编程问题教程，请在下面留下评论！感谢阅读。