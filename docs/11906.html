<html>
<head>
<title>What (and Why) is Event Sourcing?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是活动采购(为什么)?</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basics-of-event-sourcing-12ebe0b86788?source=collection_archive---------1-----------------------#2022-04-27">https://levelup.gitconnected.com/basics-of-event-sourcing-12ebe0b86788?source=collection_archive---------1-----------------------#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解活动采购</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b3ba8e30f79e1ce82164ed318ccec6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHlLSLzXBPEyOo4v6RY8Jg.png"/></div></div></figure><p id="0d5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事件源是领域驱动设计(DDD)和CQRS中经常提到的一种数据持久性策略。这些概念是独立的，但是<strong class="kw iu">完美地互补</strong>。但是事件采购是如何工作的呢？</p><p id="06df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">存储数据通常遵循<strong class="kw iu"> CRUD </strong>原则。然而，其中包含的<strong class="kw iu">四个数据库操作</strong>(“创建”、“读取”、“更新”和“删除”)并不都是相同的类型，因为更新和删除与其他操作不同，是破坏性操作。因此，通常使用带有“isDeleted”标志的更新来代替删除。但是更新也是破坏性的，因为之前保存的数据通常会丢失。</p><p id="9d0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，事件源的基本思想是放弃更新和删除，而<strong class="kw iu">只使用非破坏性的创建和读取操作</strong>。借助事件源，每个技术变更或技术流程都作为一个<strong class="kw iu">新条目</strong>输入到一个不断增长的列表中，该列表通过CREATE创建，即所谓的<strong class="kw iu">仅附加日志</strong>。这些条目将<strong class="kw iu">永远不会被更改</strong>甚至删除！</p><p id="0708" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事件源随着时间的推移收集越来越多的数据，给你一个<strong class="kw iu">历史</strong>和<strong class="kw iu">审计日志</strong>，这对报告和<strong class="kw iu">数据分析</strong>非常有用。它们还能让<strong class="kw iu">重新诠释过去</strong>获得洞见，为未来学习。由于关注于记录业务流程，<strong class="kw iu">事件源远比CRUD </strong>更受业务驱动，CRUD通常被视为反模式，因为它更面向技术。</p><p id="1507" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，事件源不存储当前状态，而是存储随着时间的推移导致当前状态的各个步骤。以这种方式工作的数据库被称为“<strong class="kw iu">事件存储库</strong>”。</p><p id="8964" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">读取当前状态可在事件源中启用所谓的“<strong class="kw iu">重放</strong>”。为一个对象保存的所有条目被<strong class="kw iu">重新加载，并以原始顺序聚集</strong>。然而，这不仅对于当前状态是可能的，对于昨天、前天或过去的任何其他时间点也是可能的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lq"><img src="../Images/3c3bcd59613bd27d1d55a62426fe5c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RrePjBWddq7GlRXi"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@itfeelslikefilm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Janko ferli</a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="30ba" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">事件来源的缺点</h1><p id="2726" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">因此，事件源提供了一种更具技术性的方法来收集历史数据，提供审计日志，为报告和数据分析提供良好的基础，并适合作为重新解释过去的起点。与CRUD相比，这是几个优势。但是缺点是什么呢？</p><p id="1114" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">说到事件采购，有三个基本挑战，但每个都有解决方案。第一个挑战是与重放相关的线性增加的工作量:必须加载和聚集的条目越多，重放花费的时间就越长。所谓的“<strong class="kw iu">快照</strong>在这里提供了一种补救措施，它显示定期额外保存的中间结果。</p><h2 id="2bbc" class="mt lx it bd ly mu mv dn mc mw mx dp mg ld my mz mi lh na nb mk ll nc nd mm ne bi translated">增加执行时间</h2><p id="1a16" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">其基础是认识到<strong class="kw iu">重放总是确定性地运行</strong>，因为存储在事件存储器<strong class="kw iu">中的条目将不再改变。</strong>对于时间X的快照来说，随后是否有更多条目也是无关紧要的。一路走来，重播并不总是要从头开始。相反，读出并聚集自上次快照以来添加的条目<strong class="kw iu">就足够了。</strong></p><h2 id="3258" class="mt lx it bd ly mu mv dn mc mw mx dp mg ld my mz mi lh na nb mk ll nc nd mm ne bi translated">增加容量存储</h2><p id="fffd" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">第二个挑战是<strong class="kw iu">活动商店不断增长的存储需求</strong>，同时，应该注意的是，如今存储空间几乎不需要任何成本。此外，如果需要的话，也可以删除不再需要的旧条目<strong class="kw iu"/>，前提是存在可以基于其进行重放的<strong class="kw iu">快照</strong>。</p><h2 id="e1a5" class="mt lx it bd ly mu mv dn mc mw mx dp mg ld my mz mi lh na nb mk ll nc nd mm ne bi translated">事件记录太多</h2><p id="8e55" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">第三个挑战是加载不是一个而是所有记录的当前状态。在这种情况下，<strong class="kw iu">必须为每个数据集</strong>执行单独的重放，这很快变得过于<strong class="kw iu">耗时</strong>。这个问题也可以通过<strong class="kw iu">快照</strong>来解决，即每次添加最新条目时都必须写入一个新的快照。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/006c64d9083bbd044a7bec363874137d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CkhiEmZy3oRlczlH"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">由<a class="ae lv" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Towfiqu barbhuiya </a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5866" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">CRUD与事件来源</h1><p id="608e" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">当<strong class="kw iu">需要变更的可追溯性</strong>时，事件源尤其适用。对历史数据的需求，特别是对审计日志的需求，也是<strong class="kw iu">事件外包何时是一个好选择的良好指标</strong>。</p><p id="4b81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当对数据进行改变时，事件源还导致<strong class="kw iu">较低的潜在冲突</strong>,因为增量被写入仅包含部分数据:事件存储中的两个条目仅在它们同时出现并且关于各自的数据重叠不同时才彼此冲突。这是实践中不太常见的情况，也可以通过使用版本控制的<strong class="kw iu">乐观并发</strong>来避免。</p><p id="c31c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，CRUD也有优势:如果既没有语义也没有主题，事件源就不能充分利用它的优势。这些相位从无到有，但肯定已经像事物一样被锚定。所以说，如果你选择<strong class="kw iu">领域驱动的设计</strong>，那么事件采购通常是一个不错的选择。如果不是这样，CRUD通常是更合适的选择。原始数据的高性能存储不需要任何专业逻辑，也很适合CRUD。</p><p id="c121" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CRUD还展示了它在d <strong class="kw iu">检测重复</strong>和<strong class="kw iu">保证唯一性</strong>方面的优越性。事件采购需要为此付出更大的努力。因此，将CRUD和事件源结合起来是有意义的，CRUD用于更技术性的方面，而事件源用于专家方面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/c6213bb93ebc9328c605b623d9f873cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6-lovCQVuTQDqcYK"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@xps?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> XPS </a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="ab41" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">哪个数据库用于事件采购？</h1><p id="f51f" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">一旦你决定做事件源，你需要一个合适的数据库。乍一看，<strong class="kw iu">要求很低</strong>，因为只需要“插入”和“选择”的支持。不需要复杂的连接、公共表表达式(CTE)或其他SQL高级结构。在最好的情况下，对事务的支持仍然与在保存条目时能够映射全有或全无语义相关。</p><p id="41c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，乍一看，SQL数据库似乎不是事件源的好选择，因为事件存储中的所有条目都具有典型的结构。尽管如此，专家数据的结构<strong class="kw iu">因应用而异</strong>。事件存储从来不需要评估这个结构，所以BLOB或JSON类型的字段完全可以存储技术数据。因此，SQL数据库几乎是理想的。</p><p id="af8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> NoSQL数据库</strong>(文档数据库，如<strong class="kw iu"> MongoDB </strong>在这种情况下特别有意义)有一个<strong class="kw iu">优势</strong>，因为它们在没有模式的情况下工作，并且被设计为处理不同的<strong class="kw iu"> JSON格式</strong>。</p><p id="cd1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后但并非最不重要的是，存在误用其他系统的选择:一个典型的例子是消息代理<strong class="kw iu"> Apache Kafka </strong>，它可以用作一种事件存储。使用卡夫卡作为一个事件商店是两极化的:支持者反对一群至少同样重要的开发者，并从根本上拒绝这一想法。因此，只有在特殊情况下才应该这样做。</p><p id="1cc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总而言之，<strong class="kw iu">推荐使用MongoDB之类的NoSQL数据库</strong>解决方案，因为事件数据不一定需要结构化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/4ebe774d18479dd0dd59c386f972a389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JGLkEQHYwd2UgoRz"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">潘卡杰·帕特尔</a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="90ef" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">领域驱动的设计和事件源</h1><p id="0a5f" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">正如开头提到的，事件源经常在<strong class="kw iu">与领域驱动设计</strong> (DDD)的联系中被提及。“事件”一词在这两个概念中都是一个常用术语。在事件采购中，它已经是概念名称的一部分。与DDD，它被发现与所谓的“<strong class="kw iu">域事件</strong>”有关。</p><p id="8751" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这两种情况下，事件(或域事件)描述过去的<strong class="kw iu">域相关事件</strong>。因此，它们不能再被撤销，但其影响最多只能通过反交易来补偿。所以这是两个世界中相同的概念。由于DDD对于<strong class="kw iu">微服务</strong>来说是一个很好的概念，所以对于活动采购来说也是如此。</p><p id="1471" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为域事件通常是命令的结果，所以<strong class="kw iu">将这些域事件</strong>作为条目存储在<strong class="kw iu">事件存储</strong>中是有意义的。然后使用重放来恢复所需单元的状态，这是处理进一步命令的基础。</p><p id="0267" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种想法也非常适合事件源，因为通常不是单个条目流，而是许多小条目组合成组——从DDD到聚合。</p><h1 id="f54d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="dbc8" class="pw-post-body-paragraph ku kv it kw b kx mo ju kz la mp jx lc ld mq lf lg lh mr lj lk ll ms ln lo lp im bi translated">事件源对于持久化数据来说是一个令人兴奋和有趣的概念。这种方法在所有涉及对现在和过去的数据进行领域评估的场景中展示了它的优势。</p><p id="c687" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事件源不太适合纯粹的技术数据存储，如数据上的表单，或者当涉及到确定数据的技术方面时，如重复或唯一性。</p><p id="21f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，事件源不能替代CRUD，正如CRUD不能替代事件源一样。相反，这两个概念通常可以很好地相互补充，以便您可以根据具体情况决定使用哪种方法。不管你最终使用的是什么，了解活动采购总是有益的，即使只是为了拓宽你的视野。</p><p id="9bba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您阅读我关于事件源的文章。我希望你能从中吸取一些东西。关注更多。</p><p id="17f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干杯！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="89b8" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">接下来阅读</h1><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/what-is-cqrs-8ddd74ca05bb"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">深入CQRS —一个伟大的微服务模式</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">什么是CQRS，为什么它越来越受欢迎？</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/domain-driven-design-in-software-development-f92c3f58d012"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">微服务:深入领域驱动的设计</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">软件开发背景下的领域驱动设计</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener  ugc nofollow" target="_blank" href="/why-did-i-move-from-typescript-to-go-1d9f92ef882a"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">为什么我从打字稿转向Go</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">以及为什么我不会放弃使用TypeScript</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>