<html>
<head>
<title>Combine Blazor WebAssembly Client and Server Logs: Two-way log streaming with NLog and SignalR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">结合Blazor WebAssembly客户端和服务器日志:使用NLog和SignalR的双向日志流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/combine-blazor-webassembly-client-and-server-logs-two-way-log-streaming-with-nlog-and-signalr-cf45ced27082?source=collection_archive---------2-----------------------#2022-04-13">https://levelup.gitconnected.com/combine-blazor-webassembly-client-and-server-logs-two-way-log-streaming-with-nlog-and-signalr-cf45ced27082?source=collection_archive---------2-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7274" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上次，在使用自定义NLog目标和SignalR 将Blazor(ASP.Net核心)日志流式传输到浏览器的<a class="ae kl" href="https://medium.com/@adored_coral_armadillo_894/streaming-blazor-asp-net-core-logs-to-the-browser-with-a-custom-nlog-target-and-signalr-82d900c0e3" rel="noopener">中，我们设置了一个新的Blazor WebAssembly项目，将服务器日志流式传输到浏览器:</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/1d22b00d44822c7b0409ede8594807ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EGnv3kP-WKsSUpZ6gANC-w.gif"/></div></div></figure><p id="e4b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在那篇文章的最后，我总结道“<em class="ky">这对Blazor服务器项目更有用，因为一切都已经在服务器上发生了”</em>。在接下来的几天里，它继续困扰着我，因为我在想，如果能像在Blazor Server中一样，在Blazor WASM中将客户端和服务器日志结合起来该有多好。</p><p id="2171" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想要的确切设置是作为开发环境工具:</p><ul class=""><li id="9fc8" class="kz la iq jp b jq jr ju jv jy lb kc lc kg ld kk le lf lg lh bi translated">服务器项目将日志流式传输到浏览器JavaScript控制台</li><li id="27ae" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk le lf lg lh bi translated">客户端项目将日志流式传输到服务器项目控制台</li></ul><p id="e982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在服务器上，这将提供与Blazor服务器项目相同的体验，前端和后端日志被合并，同时还增加了从浏览器JavaScript控制台访问相同日志的能力。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="6cfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个步骤都有提交的存储库可以在这里找到。</p><div class="lu lv gp gr lw lx"><a href="https://github.com/stewartcelani/WasmTwoWayLogging" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">GitHub-stewartcelani/WasmTwoWayLogging</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml kw lx"/></div></div></a></div><p id="de13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请随意跳到文章的末尾，看一张GIF图片。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="b86f" class="mm mn iq bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated"><strong class="ak">第七步:修复服务器项目以直接访问LoggingHub，而不是通过微软。AspNetCore.SignalR.Client </strong></h1><p id="e206" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">通过Server \ Logging \ hub connection . cs使用SignalR从服务器向自身发送SignalR消息感觉有点笨拙，所以幸运的是<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/signalr/hubcontext?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">有一种方法可以通过SignalR HubContext </a>从hub外部发送消息。不过，并没有浪费所有的资源，我们将需要稍后从客户端项目中使用LoggingHubConnection.cs来将客户端日志发送到服务器。</p><p id="98f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不包括删除Server \ Logging \ Logging hub connection . cs我们有<a class="ae kl" href="https://github.com/stewartcelani/WasmTwoWayLogging/commit/b6992a6833e7df003abecb54abc64061446cab5c#diff-fa6370bf83a253635896bf21e7fff5c1b1fb7c0972fa3e6e93df22bdad3e005c" rel="noopener ugc nofollow" target="_blank"> 4个更改的文件</a>。</p><ol class=""><li id="4529" class="kz la iq jp b jq jr ju jv jy lb kc lc kg ld kk np lf lg lh bi translated"><strong class="jp ir">Server \ Services \ debug service . cs</strong>是我们将通过LoggingHub上下文直接向浏览器发送日志消息的地方，该上下文通过构造函数中的ASP.NET核心依赖注入提供。</li><li id="96f5" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk np lf lg lh bi translated">我们需要一种方法将对调试服务的引用放入Server \ Logging \ Logging hub target . cs中。为此，在<strong class="jp ir"> Server\Program.cs </strong>、<strong class="jp ir">、</strong>中，我们可以<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-6.0" rel="noopener ugc nofollow" target="_blank">在应用启动时获取对服务的引用</a>，然后将该引用传入Server \ Logging \ logger . cs::Configure。</li><li id="36a5" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk np lf lg lh bi translated"><strong class="jp ir"> Server\Logging\Logger.cs </strong>将引用传递给LoggingHubTarget。</li><li id="4dfe" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk np lf lg lh bi translated">一个非常精简的<strong class="jp ir">Server \ Logging \ Logging hub target . cs</strong>只是将logEvent呈现为一个字符串，并将其传递给DebugService::LogToBrowser。</li></ol><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="03f1" class="mm mn iq bd mo mp ns mr ms mt nt mv mw mx nu mz na nb nv nd ne nf nw nh ni nj bi translated">步骤8:在客户端项目中设置NLog</h1><p id="d4c0" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">是时候将NLog添加到我们的客户端项目中了。</p><pre class="kn ko kp kq gt nx ny nz oa aw ob bi"><span id="4617" class="oc mn iq ny b gy od oe l of og">cd .\Client<br/>dotnet add package NLog</span></pre><p id="1cc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们快速启动和运行NLog并登录到控制台。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f87d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经通过JavaScript控制台组合了服务器/客户端日志记录:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oh"><img src="../Images/dffc8f82508f7508b86e7696513a4143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tZK34RPPJNPdf-KZNnfM5w.gif"/></div></div></figure><h1 id="feea" class="mm mn iq bd mo mp ns mr ms mt nt mv mw mx nu mz na nb nv nd ne nf nw nh ni nj bi translated">步骤9:清理客户端代码</h1><p id="33f9" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">首先让我们重构Client \ Services \ debug service . cs，以便只将服务器输出记录到控制台。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="20ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更新MainLayout.razor，以便仅在我们的环境为“开发”时挂载ServerConsole.razor组件。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="80a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们告诉我们的信号连接总是重试，如果它掉线。我们将通过实施IRetryPolicy来实现这一点。默认情况下，AutomaticReconnect将在四次尝试失败后停止尝试。默认行为和如何实现自定义重试策略可以在这里阅读<a class="ae kl" href="https://docs.microsoft.com/en-us/aspnet/core/signalr/dotnet-client?view=aspnetcore-6.0&amp;tabs=visual-studio" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="1129" class="mm mn iq bd mo mp ns mr ms mt nt mv mw mx nu mz na nb nv nd ne nf nw nh ni nj bi translated">步骤10/10:使用自定义NLog目标将客户端连接到服务器并完成</h1><p id="e8a4" class="pw-post-body-paragraph jn jo iq jp b jq nk js jt ju nl jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">这里，我们将重新实现上一篇文章中使用的基本相同的LoggingHubTarget和LoggingHubConnection，只是这次是在客户端项目中。</p><p id="735b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会覆盖一个嵌入中的每一个变化，因为有太多，但你可以<a class="ae kl" href="https://github.com/stewartcelani/WasmTwoWayLogging/commit/f928c8e2d74e140c5d3a6cea32e4307fb9265547" rel="noopener ugc nofollow" target="_blank">在这里直接浏览变化</a>。</p><p id="fbb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变更摘要:</p><ul class=""><li id="20d9" class="kz la iq jp b jq jr ju jv jy lb kc lc kg ld kk le lf lg lh bi translated">将Client \ Library \ infiniteretry policy . cs移动到Shared\InfiniteRetryPolicy.cs，因为我们将在客户端和服务器上使用</li><li id="64b9" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk le lf lg lh bi translated">将日志配置为通过Client\Logging\Logger.cs、\ Logging \ LoggingHubConnection.cs和Client \ Logging hub target . cs流向服务器</li><li id="c2e4" class="kz la iq jp b jq li ju lj jy lk kc ll kg lm kk le lf lg lh bi translated">我们需要某种方法来连接Server \ Services \ debug service . cs来监听“logto Server”logging hub事件，并将它们打印到控制台。不幸的是，这不可能直接从HubContext中实现，所以我使用了微软。AspNetCore.SignalR.Client在DebugService中设置HubConnection。总之:DebugService用它的HubContext将日志从服务器广播到客户机，并用HubConnection.On监听来自客户机的广播。</li></ul><p id="424b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终结果如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oi"><img src="../Images/ed2b727f4cb0e05cdab9d3858623f904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8U_hZJqYpKrmPM3rmh6Dkw.gif"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">服务器上和浏览器控制台中的统一客户端和服务器日志</figcaption></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="1d8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我很高兴在Blazor中获得并运行这种日志功能是如此容易。我可以想象自己在未来的项目中使用它。</p></div></div>    
</body>
</html>