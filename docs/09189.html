<html>
<head>
<title>How to create like button animation in Android — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android中创建like按钮动画——第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-like-button-animation-in-android-part-1-f99e2792143d?source=collection_archive---------16-----------------------#2021-07-14">https://levelup.gitconnected.com/how-to-create-like-button-animation-in-android-part-1-f99e2792143d?source=collection_archive---------16-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="48cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从Dribbble设计到真正的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5c5ec6c2970c7d5b319be3f9375b7340.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/1*xTb0L1xZ8FX7GDXkZn9dtw.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://dribbble.com/shots/12234916--Like-Button-for-Figma-Cool" rel="noopener ugc nofollow" target="_blank">https://dribbble.com/shots/12234916式的纽扣很酷</a></figcaption></figure><h1 id="7293" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">介绍</h1><p id="88b2" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">当你被告知在家工作而别无选择时，很容易感到孤独。我也是！🥱</p><p id="fbdc" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">越来越无聊后，我开始在Dribbble上浏览以获得一些灵感。我发现自己盯着这个设计，突然意识到自己有多喜欢它。</p><p id="7e5e" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">相信我，这比你想象的容易。我将拍摄一张我最近拍摄的照片，带你走过这些步骤，并给你一些如何实现它的想法。</p><h1 id="8b63" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">必需的知识</h1><p id="3056" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">自定义视图的一些基本概念。有关自定义视图组件的更多信息，请参考:</p><p id="03c5" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><a class="ae ku" href="https://developer.android.com/guide/topics/ui/custom-components" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/guide/topics/ui/custom-components</a></p><h1 id="0561" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">分析动画</h1><p id="d673" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在第1部分中，我们将实现心形图标和背景的动画。所以请继续关注第2部分。🥰</p><p id="d970" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">动画是以下步骤的组合:</p><ul class=""><li id="9fae" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated">背景从1缩放到0.9，然后回到1。</li><li id="e351" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">心形图标的刻度从1到0.6，然后回到1。</li><li id="ce3c" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">背景会更新起始值和结束值之间的颜色。</li><li id="1482" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">心形图标更新开始值和结束值之间的颜色。</li></ul><h1 id="65f3" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">编码部分</h1><p id="775b" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我将编码部分分为3个步骤，如下所示。</p><ul class=""><li id="76cd" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated"><a class="ae ku" href="#2aed" rel="noopener ugc nofollow">创建自定义视图。</a></li><li id="6201" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><a class="ae ku" href="#6a35" rel="noopener ugc nofollow">处理OnDraw()方法。</a></li><li id="a71d" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><a class="ae ku" href="#a340" rel="noopener ugc nofollow">处理动画。</a></li></ul><h1 id="2aed" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">步骤1:创建自定义视图</h1><h2 id="4781" class="nc kw it bd kx nd ne dn lb nf ng dp lf lw nh ni lh ma nj nk lj me nl nm ll nn bi translated">a.创建视图类</h2><p id="0e43" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">您可以通过扩展<code class="fe no np nq nr b">View</code>类来创建您的自定义视图。虽然<code class="fe no np nq nr b">View</code>有许多方法来处理度量，但是我们的视图不需要对它的大小进行特殊控制，为了简单起见，它们不需要被覆盖。</p><p id="61e5" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">自定义视图最重要的部分是它的外观。第一步是覆盖<code class="fe no np nq nr b">onDraw()</code>方法。<code class="fe no np nq nr b">onDraw()</code>的参数是一个<code class="fe no np nq nr b">Canvas</code>对象，视图可以用它来绘制自己。以下是展示框架结构的一个片段:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="cf67" class="nc kw it nr b gy nw nx l ny nz">class LikeAnimButton @JvmOverloads constructor(<br/>    context: Context,<br/>    attrs: AttributeSet? = null,<br/>    defStyle: Int = 0<br/>) : View(context, attrs, defStyle) {<br/><br/>    override fun onDraw(canvas: Canvas) {<br/>        super.onDraw(canvas)<br/>    }<br/>}</span></pre><p id="982f" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在Kotlin中，记得使用<code class="fe no np nq nr b">@JvmOverloads</code>注释来定义一个构造函数，而不是像Java中那样定义多个构造函数。</p><h2 id="ea02" class="nc kw it bd kx nd ne dn lb nf ng dp lf lw nh ni lh ma nj nk lj me nl nm ll nn bi translated">b.定义用户界面状态</h2><p id="76f4" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">首先，我们定义状态。我们还使用密封类来确保状态都在一个地方。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e510" class="nc kw it nr b gy nw nx l ny nz">sealed class UIState {<br/>    object UnLike : UIState()<br/>    class Like(val number: Int) : UIState()<br/>    object Animating : UIState()<br/>}</span></pre><p id="16d2" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">此视图中有3种状态:</p><ul class=""><li id="0f82" class="mo mp it lp b lq mj lt mk lw mq ma mr me ms mi mt mu mv mw bi translated"><code class="fe no np nq nr b">Like</code>:显示带有粉色心形的like按钮，并有一个指示like编号的有效载荷。</li><li id="f909" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><code class="fe no np nq nr b">Unlike</code>:用灰色心形显示喜欢按钮。</li><li id="30d2" class="mo mp it lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><code class="fe no np nq nr b">Animating</code>:表示动画正在运行。这是用来防止快速点击。</li></ul><h2 id="92b3" class="nc kw it bd kx nd ne dn lb nf ng dp lf lw nh ni lh ma nj nk lj me nl nm ll nn bi translated">c.将其添加到XML文件中</h2><p id="2dc8" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">接下来，用XML实例化我们的自定义<code class="fe no np nq nr b">LikeAnimButton</code>:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e281" class="nc kw it nr b gy nw nx l ny nz">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"&gt;<br/><br/>    &lt;com.umbrella.likeanimbutton.widget.LikeAnimButton<br/>        android:id="@+id/btn"<br/>        android:layout_width="112dp"<br/>        android:layout_height="112dp"<br/>        android:layout_gravity="center" /&gt;<br/>&lt;/FrameLayout&gt;</span></pre><h1 id="6a35" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">步骤2:处理OnDraw()方法</h1><h2 id="2f6e" class="nc kw it bd kx nd ne dn lb nf ng dp lf lw nh ni lh ma nj nk lj me nl nm ll nn bi translated">a.在OnDraw()方法中创建骨架结构</h2><p id="44ff" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">这就是<code class="fe no np nq nr b">onDraw()</code>方法的工作原理。它一个接一个地绘制所有的视图层。这里有一个片段显示了框架结构:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e5c1" class="nc kw it nr b gy nw nx l ny nz">override fun onDraw(canvas: Canvas) {<br/>    super.onDraw(canvas)</span><span id="7866" class="nc kw it nr b gy oa nx l ny nz">    // draw background<br/>    getRoundRectPaint().also {<br/>    }</span><span id="f573" class="nc kw it nr b gy oa nx l ny nz">    // draw heart icon<br/>    getBitmapPaint().also { paint -&gt;<br/>    }<br/>}</span></pre><p id="73ea" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">所以，在我们画任何东西之前，我们需要创建一个或多个<code class="fe no np nq nr b">Paint</code>对象。在这个例子中，我们只创建一个画图，并使用<code class="fe no np nq nr b">getRoundRectPaint()</code>方法和<code class="fe no np nq nr b">getBitmapPaint()</code>方法来更新颜色。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="3825" class="nc kw it nr b gy nw nx l ny nz">private val paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><span id="bef7" class="nc kw it nr b gy oa nx l ny nz">private fun getRoundRectPaint() = paint.apply {<br/>}</span><span id="2780" class="nc kw it nr b gy oa nx l ny nz">private fun getBitmapPaint() = paint.apply {<br/>}</span></pre><p id="6362" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">接下来，定义一个<code class="fe no np nq nr b">fraction</code>，它表示动画步骤中使用的0到1之间的当前数量，我们将在后面讨论。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1a7e" class="nc kw it nr b gy nw nx l ny nz">private var fraction: Float = 0f</span></pre><h2 id="aa7d" class="nc kw it bd kx nd ne dn lb nf ng dp lf lw nh ni lh ma nj nk lj me nl nm ll nn bi translated">b.绘制背景</h2><p id="595b" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">首先，我们创建一个<code class="fe no np nq nr b">ArgbEvaluator</code>对象来在两种颜色之间制作动画:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1c46" class="nc kw it nr b gy nw nx l ny nz">private val argbEvaluator = ArgbEvaluator()</span></pre><p id="d919" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">根据<code class="fe no np nq nr b">fraction</code>，我们计算出相应的背景颜色。在这里，我希望更新速度比平时快两倍:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a7e2" class="nc kw it nr b gy nw nx l ny nz">private fun getRoundRectPaint() = paint.apply {<br/>    val bgFraction = (fraction * 2).coerceAtMost(1f)<br/>    color = argbEvaluator.evaluate(bgFraction, fromBgColor, toBgColor) as Int<br/>}</span></pre><p id="a531" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们需要用从1到0.9的缩放比例来画它，然后回到1。下面是在<code class="fe no np nq nr b">leap()</code>函数帮助下的代码片段:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="c4ab" class="nc kw it nr b gy nw nx l ny nz">val scaleX = lerp(1f, 0.9f, 1f, fraction)</span><span id="aa11" class="nc kw it nr b gy oa nx l ny nz">private fun lerp(a: Float, b: Float, c: Float, fraction: Float): Float {<br/>    return if (fraction &lt;= 0.5f) {<br/>        lerp(a, b, fraction * 2)<br/>    } else {<br/>        val tempFraction = fraction - 0.5f<br/>        lerp(b, c, tempFraction * 2)<br/>    }<br/>}</span></pre><p id="293f" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在上面的代码中，我创建了一个自定义的<code class="fe no np nq nr b">lerp()</code>，它返回<code class="fe no np nq nr b">a</code>、<code class="fe no np nq nr b">b</code>和<code class="fe no np nq nr b">c</code>之间的<code class="fe no np nq nr b">fraction</code>的线性插值。</p><p id="8d71" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这就是我们绘制背景所需的全部内容。让我们直接进入主题:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6111" class="nc kw it nr b gy nw nx l ny nz">getRoundRectPaint().also {<br/>    // bound<br/>    val left = 0f<br/>    val top = 0f<br/>    val right = width.toFloat()<br/>    val bottom = height.toFloat()<br/>    // scale<br/>    val scaleX = lerp(1f, 0.9f, 1f, fraction)<br/>    val scaleY = scaleX<br/>    val pivotX = width / 2f<br/>    val pivotY = height / 2f<br/>    canvas.withScale(scaleX, scaleY, pivotX, pivotY) {<br/>        canvas.drawRoundRect(left, top, right, bottom, radius, radius, it)<br/>    }<br/>}</span></pre><p id="d886" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">构建项目并检查结果。酷！🥰</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5265b1fb4e9515b8998591bb52b0ddba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/1*UPB9AnxtknXLWin2u84F4A.gif"/></div></figure><h2 id="3315" class="nc kw it bd kx nd ne dn lb nf ng dp lf lw nh ni lh ma nj nk lj me nl nm ll nn bi translated">c.绘制心形图标</h2><p id="a215" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">首先，让我们从vector中获取心形位图:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2dfe" class="nc kw it nr b gy nw nx l ny nz">private val iconBitmap = getBitmap(R.drawable.ic_baseline_favorite)</span></pre><p id="aeec" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">根据<code class="fe no np nq nr b">fraction</code>，我们计算相应的位图颜色。在这里，我希望更新速度比平时快两倍:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6062" class="nc kw it nr b gy nw nx l ny nz">private fun getBitmapPaint() = paint.apply {<br/>    val bgFraction = (fraction * 2).coerceAtMost(1f)<br/>    color = argbEvaluator.evaluate(bgFraction, fromBmColor, toBmColor) as Int<br/>}</span></pre><p id="8a0a" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">接下来，我们在<code class="fe no np nq nr b">PorterDuffXfermode</code>的帮助下给位图着色:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="19a2" class="nc kw it nr b gy nw nx l ny nz">private val srcInMode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)<br/>private val drawableCanvas = Canvas(this.iconBitmap)</span><span id="2599" class="nc kw it nr b gy oa nx l ny nz">private fun tintBitmap() {<br/>    // change to src in<br/>    paint.xfermode = srcInMode<br/>    drawableCanvas.drawRect(0f, 0f, this.iconBitmap.width.toFloat(), this.iconBitmap.height.toFloat(), getBitmapPaint())<br/>    paint.xfermode = null<br/>}</span></pre><p id="caf5" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">然后，我们需要用从1到0.6的缩放比例来画它，然后回到1:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="5556" class="nc kw it nr b gy nw nx l ny nz">getBitmapPaint().also { paint -&gt;<br/>    val scaleX = lerp(1f, 0.6f, 1f, fraction)<br/>    val scaleY = scaleX<br/>    val pivotX = width / 2f<br/>    val pivotY = height / 2f<br/>    canvas.withScale(scaleX, scaleY, pivotX, pivotY) {<br/>        val left = width / 2f - iconBitmap.width / 2f<br/>        val top = height / 2f - iconBitmap.height / 2f<br/>        tintBitmap()<br/>        canvas.drawBitmap(iconBitmap, left, top, paint)<br/>    }<br/>}</span></pre><p id="4a0f" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">构建项目并再次检查结果。😉</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b75d91c9bf068534164f7a5ee40e9634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/1*Euu29UDC8Pgmanpvbp9W1A.gif"/></div></figure><h1 id="a340" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">步骤3:处理动画</h1><p id="ca42" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">下面是名为<code class="fe no np nq nr b">setUIState()</code>的方法()，我们用它来改变like按钮的外观:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="134f" class="nc kw it nr b gy nw nx l ny nz">fun setUIState(uiState: UIState, isAnim: Boolean) {<br/>    updateBgColor(uiState)<br/>    if (this.uiState == UIState.Animating) {<br/>        return<br/>    }<br/>    if (isAnim) {<br/>        runAnimation().apply {<br/>            doOnEnd {<br/>                this@LikeAnimButton.uiState = uiState<br/>            }<br/>        }<br/>    } else {<br/>        this.uiState = uiState<br/>        fraction = 0f<br/>        invalidate()<br/>    }<br/>}</span></pre><p id="13a1" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">最后，<code class="fe no np nq nr b">runAnimation()</code>方法用于更新<code class="fe no np nq nr b">fraction</code>并调用<code class="fe no np nq nr b">invalidate()</code>，后者通过<code class="fe no np nq nr b">onDraw()</code>方法重绘UI:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4521" class="nc kw it nr b gy nw nx l ny nz">private fun runAnimation(): ValueAnimator {<br/>    return ValueAnimator.ofFloat(0f, 1f).apply {<br/>        addUpdateListener {<br/>            fraction = it.animatedValue as Float<br/>            invalidate()<br/>        }<br/>        interpolator = FastOutSlowInInterpolator()<br/>        doOnStart {<br/>            this@LikeAnimButton.uiState = UIState.Animating<br/>        }<br/>        duration = 500L<br/>        start()<br/>    }<br/>}</span></pre><p id="29e4" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">让我们重建一下，看看最后的结果！🥰</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2cf5d0f1b239ba2a3f20bc3ee9d0f5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/1*FrqoqgAUVEDPpK_rS93AlA.gif"/></div></figure><h1 id="fb26" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">这是一个总结！</h1><p id="ece0" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">下面是<code class="fe no np nq nr b">LikeAnimButton</code>类的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="b0b8" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">如果您在执行代码片段时发现问题，请查看GitHub repo获取帮助:</p><div class="og oh gp gr oi oj"><a href="https://github.com/PhongHuynh93/LikeButtonAnimation" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">phonghuynh 93/like button animation</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">在GitHub上创建一个帐户，为phonghuynh 93/LikeButtonAnimation开发做贡献。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ko oj"/></div></div></a></div></div><div class="ab cl oy oz hx pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="im in io ip iq"><p id="cf68" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">现在你已经学会了如何绘制喜欢的图标，并制作一个很酷的动画。在下一部分，我们将学习如何绘制涟漪效应和类似的数字。</p><p id="6bc8" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">非常感谢你阅读我的文章。<em class="pf">如果你喜欢这个故事，请</em> <strong class="lp iu"> <em class="pf">点击</em> </strong>👏<strong class="lp iu"> <em class="pf">按钮，分享</em> </strong> <em class="pf">它来帮助别人！</em>关注我的<a class="ae ku" href="https://mr-umbrella.medium.com/" rel="noopener"> Medium </a> <em class="pf">获取更多牛逼安卓小技巧</em>。也可以在<a class="ae ku" href="https://www.linkedin.com/in/huynh-phong-3649a7131/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。祝您愉快！😄</p><h1 id="24f6" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">继续读Android的东西</h1><p id="c3cd" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/shared-element-using-materialcontainertransform-in-android-6d420e74b122">Android中使用MaterialContainerTransform的共享元素</a></p><p id="e584" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/android-button-morphing-animation-bc3bed740501">安卓按钮变形动画</a></p><p id="cccd" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/motionlayout-collapsing-toolbar-d0ce8dd874b6">运动布局——折叠工具栏</a></p><h1 id="5c8a" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">Jetpack撰写</h1><p id="200a" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/implement-android-snackbar-in-jetpack-compose-d83df5ff5b47">在Jetpack Compose中实现snack bar</a></p><p id="7842" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/implement-android-tablayout-in-jetpack-compose-e61c113add79">在Jetpack Compose中实现tab layout</a></p><p id="1dbb" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/implement-tablayout-with-viewpager-in-android-jetpack-compose-d509fc6e2d8e">在Jetpack Compose中用ViewPager实现talayout</a></p><p id="4826" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated"><a class="ae ku" rel="noopener ugc nofollow" target="_blank" href="/create-an-auto-scroll-viewpager-with-transformation-and-ken-burns-effect-in-android-jetpack-compose-efdf46f2e8ed">在Jetpack Compose中创建一个带有变形和ken burns效果的自动滚动浏览器</a></p></div></div>    
</body>
</html>