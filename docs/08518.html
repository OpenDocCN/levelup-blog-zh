<html>
<head>
<title>Refactoring Code to Pass Sonar Qube’s Cognitive Complexity Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构代码以通过Sonar Qube的认知复杂性检查</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/refactoring-code-to-pass-sonar-qubes-cognitive-complexity-checks-8433433d83a1?source=collection_archive---------0-----------------------#2021-05-09">https://levelup.gitconnected.com/refactoring-code-to-pass-sonar-qubes-cognitive-complexity-checks-8433433d83a1?source=collection_archive---------0-----------------------#2021-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a8e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SonarQube和类似的代码质量和安全工具真是太好了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e0f5e28b1d028918d346ccef9b5ada52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkfK8IG7C3NWS66A_0FOtQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/code-microscope?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></figcaption></figure><p id="61ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank">sonar cube</a>等质检软件是福。</p><p id="6753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有它们，我们最终部署的代码会有很多错误、死代码、不可达代码、代码味道、安全漏洞等等。</p><p id="4c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多开发人员对代码质量工具的最初印象和体验是，它们给开发和部署过程带来了不必要的摩擦和瓶颈。</p><p id="65a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们认为引入到开发和集成工作流中的摩擦和瓶颈会降低开发人员的生产力。</p><p id="9055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在你体验到这些工具带来的丰厚回报之前，你有理由坚持这种强烈的不成熟的想法。</p><p id="4e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将SonarQube之类的代码质量工具集成到您的开发过程中，从一开始就看起来令人沮丧，而且事与愿违，因为您突然要负责修复该工具标记的所有问题。通过CI/CD管道检查必须解决的问题。</p><p id="e012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题中的许多会进入生产环境，并在以后产生运行时问题、代码理解和维护开销。有了SonarQube这样的工具，你可以提前解决这些问题，甚至不用尝试就知道它们。</p><p id="626f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SonarQube和其他类似的工具运行代码质量检查，并确保您的代码库的质量和安全性是可靠的。</p><h1 id="11d2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关注认知复杂性</h1><p id="434b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">SonarQube执行的质量检查之一是分析您的代码库，找出具有高认知开销的代码。</p><p id="9265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SonarQube的认知复杂性度量对代码构造的复杂性进行检查和评分。较高的分数表明，当你试图理解应用程序的控制流时，你会有更大的障碍。</p><p id="6c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">认知复杂性增加了开发人员理解代码并进一步维护或扩展代码的工作量。</p><p id="46be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sonar有一套衡量代码复杂性的详细规则。看看这份<a class="ae ky" href="https://www.sonarsource.com/docs/CognitiveComplexity.pdf" rel="noopener ugc nofollow" target="_blank">白皮书</a>。任何打破应用程序线性流程的结构都会增加认知复杂性得分。</p><p id="545c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">增加SonarQube认知复杂性的常见结构有</p><ol class=""><li id="ba84" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">嵌套条件和迭代</li><li id="55e6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">迭代次数</li><li id="799c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">具有多个不同逻辑运算符的条件句</li></ol><p id="2096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有具有认知复杂性的函数和代码块都被SonarQube标记出来，报告如下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/a9e579e2fa4a423e54fb29cff67db72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCiv2CWBx_w1ffm3oJ8nYQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片:声纳截图提高了声纳立方体的认知复杂性</figcaption></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="77e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍如何降低上面截图中的<code class="fe no np nq nr b">create(...)</code>方法的认知复杂性。</p><p id="5edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将一起重构这个方法，将认知复杂度从28降低到至少可接受的最小值，即15。</p><p id="41eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将采用马丁·福勒的书<a class="ae ky" href="https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599/ref=pd_lpo_14_t_0/136-1119044-0910438?_encoding=UTF8&amp;pd_rd_i=0134757599&amp;pd_rd_r=d58e3ba7-8f83-4fea-a8e1-24a4a1e1a4fd&amp;pd_rd_w=YMTyK&amp;pd_rd_wg=fzwKe&amp;pf_rd_p=337be819-13af-4fb9-8b3e-a5291c097ebb&amp;pf_rd_r=B9YK5S2MB0DD9FBA2ZKE&amp;psc=1&amp;refRID=B9YK5S2MB0DD9FBA2ZKE" rel="noopener ugc nofollow" target="_blank">重构:改进现有代码的设计</a>中的一些重构。</p><p id="de9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一重构的最后，我们将无一例外地获得以下好处:</p><ol class=""><li id="f20c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">一个干净，可读和全面的功能</li><li id="afaf" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">一个不太复杂的代码，几乎没有认知开销</li><li id="53f0" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">代码行更少的方法</li><li id="5c46" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">高度可维护和可扩展的方法</li></ol></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="3f71" class="lv lw it bd lx ly ns ma mb mc nt me mf jz nu ka mh kc nv kd mj kf nw kg ml mm bi translated">遇到认知复杂性问题的方法</h1><p id="518a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面的代码的SonarQube认知复杂性得分为<strong class="lb iu"> 25 </strong>，如前面的报告所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">代码片段#1 —需要重构以通过SonarQube的代码认知</strong></figcaption></figure><h2 id="f4be" class="nz lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">这个方法在做什么</h2><p id="bd6f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe no np nq nr b">create(...)</code>方法属于自定义Odoo ERP模块的<code class="fe no np nq nr b">Cheque</code>类，用于处理支票清算。</p><p id="3839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果银行分行代码<code class="fe no np nq nr b">branch_code</code>出现在传递给方法的<code class="fe no np nq nr b">vals</code>参数中，方法<code class="fe no np nq nr b">create(...)</code>覆盖并创建一个<strong class="lb iu">合作伙伴支票账户</strong>。当账号<code class="fe no np nq nr b">acc_no</code>和银行分支<code class="fe no np nq nr b">branch</code>的<strong class="lb iu">伙伴支票账户</strong>不存在时，它检查并创建该账户</p><p id="d8d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终使用现有的<strong class="lb iu">合伙人支票账户</strong>或新创建的<strong class="lb iu">合伙人支票账户</strong>创建支票。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="427e" class="lv lw it bd lx ly ns ma mb mc nt me mf jz nu ka mh kc nv kd mj kf nw kg ml mm bi translated">让我们从分析和重构开始</h1><p id="51f0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将通过首先分析功能并指出与认知相关的问题来开始这个重构练习，然后讨论它们的解决方案。</p><h2 id="973d" class="nz lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">条件守卫</h2><p id="d04f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">第3行到第7行[<strong class="lb iu">到</strong>代码片段#1 <strong class="lb iu"> ] </strong>实施条件保护，这是在不满足某些条件和应用程序状态时终止程序执行的理想方法。</strong></p><p id="ce7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">行# 3</strong><strong class="lb iu"/>from<strong class="lb iu"/>代码片段# 1<strong class="lb iu"/>在<code class="fe no np nq nr b">vals</code>字典中检查关键字<code class="fe no np nq nr b">amount</code>。在缺少这两个键的情况下，<code class="fe no np nq nr b">create(...)</code>方法的主要操作无法执行，因此该函数终止，并引发一个适当的“验证错误”异常。</p><p id="9a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到两个条件守卫都评估<code class="fe no np nq nr b">amount</code>的存在，并且还检查金额值是否大于零，如果反馈中的粒度重要到已经达到，我们可以将这两个条件守卫作为两个独立的条件。</p><p id="86ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有，我们可以考虑将两者合并成一个，并将异常消息一般化。</p><p id="c8b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将两个条件守卫合并为一个，<strong class="lb iu">行#3到# 7[<strong class="lb iu"/>代码片段#1 <strong class="lb iu"> ] </strong>中的</strong>导致下面的条件更加简短易读。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">代码片段#2 </strong></figcaption></figure><h2 id="4a02" class="nz lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">简化和合并条件句</h2><p id="e999" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">第12行到第17行</strong><strong class="lb iu"/>from<strong class="lb iu"/>代码片段# 1<strong class="lb iu"/>是我们可以简化以增加可读性的条件句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">第12行到第17行【来自代码片段# 1】</strong></figcaption></figure><p id="2b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您注意到有一个对键<code class="fe no np nq nr b">internal_hold</code>的存在及其值<code class="fe no np nq nr b">vals['internal_hold']</code>的真实性的评估。</p><p id="fefa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe no np nq nr b">internal_hold</code>存在并且是<code class="fe no np nq nr b">True</code>，则<code class="fe no np nq nr b">vals</code>字典用具有值<code class="fe no np nq nr b">internally_held</code>的新密钥<code class="fe no np nq nr b">state</code>更新</p><p id="74a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还注意到<code class="fe no np nq nr b">elif</code>和<code class="fe no np nq nr b">else</code>块将相同的状态<code class="fe no np nq nr b">draft</code>分配给<code class="fe no np nq nr b">vals['state']</code>，而不管它们的条件逻辑有何不同。</p><p id="b7ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在这里，我们将合并这两个条件句。</p><p id="9ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重构<strong class="lb iu">第12行到第17行</strong>从<strong class="lb iu"> </strong>代码片段# 1<strong class="lb iu"/>用我们当前的基本原理将条件语句简化到下面</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">第12行到第17行[来自代码片段#1]被重构</strong></figcaption></figure><p id="b731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用Python的三元运算符，用一条语句来实现上面的重构，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">第12行到第17行[来自代码片段#1]使用三元运算符</strong>进一步简化</figcaption></figure><h2 id="0b57" class="nz lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">合并和删除重复的逻辑</h2><p id="370c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">敏锐的观察力会让我们注意到在<strong class="lb iu">第19行到第63行</strong>到<strong class="lb iu"> [ 【T19来自代码片段#1 <strong class="lb iu"> ] </strong>中嵌套的<code class="fe no np nq nr b">if-else</code>语句中用于取回支票的代码的重复</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">第19行到第63行【来自代码片段# 1】</strong></figcaption></figure><p id="b062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然从代码片段# 1<strong class="lb iu"/>到代码片段# 63<strong class="lb iu"/>的第<strong class="lb iu">行#19到第<strong class="lb iu">行的第<strong class="lb iu">行#3和第#34 </strong>行检索支票的域过滤器不同，但是机制是相同的，因此可以通过对ORM <code class="fe no np nq nr b">self.search(...)</code>方法的一次调用来实现。</strong></strong></p><pre class="kj kk kl km gt ol nr om on aw oo bi"><span id="e623" class="nz lw it nr b gy op oq l or os">cheques = self.search([&lt;domain-filters&gt;])</span></pre><p id="7451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码在<code class="fe no np nq nr b">if</code>和<code class="fe no np nq nr b">else</code>子句中都存在；这种重复是因为每个都必须用不同的域过滤器列表调用<code class="fe no np nq nr b">self.search(...)</code>。</p><p id="aa68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过向上移动<code class="fe no np nq nr b">self.search(...)</code>并传入一个基于<code class="fe no np nq nr b">vals</code>中是否存在键<code class="fe no np nq nr b">branch_code</code>而准备的域过滤器列表来简化这段代码</p><p id="367b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">董这才端起本改版:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">第19行到第63行[来自代码片段#1 ]被重构</strong></figcaption></figure><p id="9841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个版本中，我们创建了通用域过滤器<code class="fe no np nq nr b">cheque_exists_domain_filters</code>，并根据满足哪些条件来动态扩展过滤器。</p><p id="a8b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个版本现在显示了对<code class="fe no np nq nr b">self.search(cheque_exists_domain_filter)</code>的单个调用</p><p id="10ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做使我们的控制流变得平坦，并从原始的<code class="fe no np nq nr b">create(...)</code>方法<strong class="lb iu"/><strong class="lb iu"/>代码片段# 1<strong class="lb iu"/>中移除了两层嵌套的<code class="fe no np nq nr b">if</code>语句</p><p id="399c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经将<code class="fe no np nq nr b">self.search(cheque_exist_domain_filter</code>上移，我们也可以实现条件保护，如我们修改后的代码中的第9行所示，当<code class="fe no np nq nr b">self.search(cheque_exist_domain_filter)</code>返回一些支票时引发<code class="fe no np nq nr b">ValidationError</code>异常，这是我们不继续创建合作伙伴支票账户的前提条件。</p><h1 id="2797" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最终重构方法</h1><p id="dc61" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个<code class="fe no np nq nr b">create(...)</code>方法的最终修订版可以通过应用其他的重构来进一步重构，比如“方法提取”。</p><p id="8172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是本文的目标是考虑我们可以进行的最小重构，以使该方法通过SonarQube的认知复杂性检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">代码片段#5 —最终重构的方法</strong></figcaption></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="b18d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个重构练习。</p><p id="b7f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝您的软件开发之旅一切顺利。</p><h2 id="b78c" class="nz lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">你可能也想看看我的其他文章</h2><div class="ot ou gp gr ov ow"><a rel="noopener  ugc nofollow" target="_blank" href="/please-refactor-these-blocks-of-code-c7d2b6f2e4ce"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">请重构这些代码块</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">我知道它们有用，但是请让我们去掉这些代码的味道</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a rel="noopener  ugc nofollow" target="_blank" href="/the-6-things-every-good-software-developer-i-know-religiously-does-fd6dd9c2c8f7"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">我所知道的每一个优秀的软件开发人员都会认真做的6件事</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">我认识的每个优秀的软件开发人员都会做这些事情</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk ks ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a href="https://javascript.plainenglish.io/angular-top-4-front-end-developer-opinions-ef864876af59" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">angular:4大前端开发者观点</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">前端开发人员对Angular(重写)的主要看法。</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pf l"><div class="pm l ph pi pj pf pk ks ow"/></div></div></a></div></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="c48c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘿，谢谢你花时间阅读这篇文章。在你走之前，我想让你知道一些事情。你可以用我的 <a class="ae ky" href="https://ofelix03.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="pn">推荐链接</em> </strong> </a> <em class="pn">通过</em> <a class="ae ky" href="https://ofelix03.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="pn">加盟中</em> </strong> </a> <em class="pn">作为付费会员支持我的写作。只需5美元</em> <strong class="lb iu"> <em class="pn"> </em> </strong> <em class="pn">您就可以拥有</em> <strong class="lb iu"> <em class="pn">完整访问内容</em> </strong> <em class="pn">像您刚刚阅读的内容以及更多内容。如果你今天加入，我会从你的5美元会员费中收取一小笔佣金，而不会给你增加任何额外费用。</em></p><div class="ot ou gp gr ov ow"><a href="https://ofelix03.medium.com/membership" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">通过我的推荐链接加入媒体-费利克斯·奥托</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">ofelix03.medium.com</p></div></div><div class="pf l"><div class="po l ph pi pj pf pk ks ow"/></div></div></a></div></div></div>    
</body>
</html>