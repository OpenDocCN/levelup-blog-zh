<html>
<head>
<title>Julia Artifacts for Dummies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉亚假人艺术品</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/julia-artifacts-for-dummies-f2eef4fc193a?source=collection_archive---------5-----------------------#2021-01-28">https://levelup.gitconnected.com/julia-artifacts-for-dummies-f2eef4fc193a?source=collection_archive---------5-----------------------#2021-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="037d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个聪明的系统，使图像，二进制文件，训练集和其他数据可以在你的软件包中匹配你的架构。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3062a434e4245f792b834a60f9f6add5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pa0WxaKeVw2YPCI9DH4kZw.png"/></div></div></figure><p id="8988" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated"><span class="l lr ls lt bm lu lv lw lx ly di"> O </span>凯我承认，当我阅读<a class="ae lz" href="https://julialang.github.io/Pkg.jl/v1/artifacts/" rel="noopener ugc nofollow" target="_blank">茱莉亚神器文档</a>的时候，我对很多事情都很困惑。如果你是一个聪明的人，谁能想出它，那么恭喜你，你不需要进一步阅读。</p><p id="2760" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们其余的人需要更多关于工件的介绍和背景，以及更详细的API和用法的演练。这就是我希望在这里提供的。我也将涵盖我最初的误解，希望你可能有同样的想法，我可以向你澄清其中的一些。</p><p id="4ead" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始之前，让我快速提示一下我们正在谈论的内容。工件在Julia中以一个模块的形式存在于名为<code class="fe ma mb mc md b">Pkg.Artifacts</code>的<code class="fe ma mb mc md b">Pkg</code>模块中。您可以通过以下方式访问REPL中的功能:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="bdc3" class="mi mj it md b gy mk ml l mm mn">julia&gt; using Pkg.Artifacts</span></pre><p id="e0e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提供<code class="fe ma mb mc md b">artifact_toml</code>、<code class="fe ma mb mc md b">artifact_path</code>、<code class="fe ma mb mc md b">artifact_exists</code>等功能。我们稍后会详细讨论这些内容。</p><p id="ec11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与此相结合，工件还向您的源代码仓库添加了另一个文件:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="c62f" class="mi mj it md b gy mk ml l mm mn">Foobar<br/>├── Artifacts.toml        # Stores info about artifacts<br/>├── Manifest.toml<br/>├── Project.toml          # Direct package dependencies<br/>├── src<br/>│   └── Foobar.jl         # Defines Foobar module<br/>└── test<br/>    ├── Manifest.toml<br/>    ├── Project.toml       # Package dependencies for tests<br/>    ├── runtests.jl        # Contains your tests</span></pre><p id="221b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除此之外，工件不会给你的实际源代码包增加太多，这就是问题的关键。但是，要理解为什么，让我们退一步，看看大局。</p><h1 id="a920" class="mo mj it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">我们不能把所有数据都放在Git Repo中吗？</h1><p id="6378" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">如果将图像、二进制文件、数据集和类似的数据放入git仓库是没有痛苦和问题的，我们可能根本不需要工件。</p><p id="c78a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，git不是为二进制数据而设计的。因此，将这种数据放入源代码存储库很容易使其膨胀。第二个问题是，对于二进制文件来说，空间需求会变得非常快。想象一下，你依赖于Qt库、OpenCV、VTK或任何其他C++怪物项目。为每一个平台编译一个版本，32位、64位和许多其他版本，并把它放在你的源代码库中会带来灾难。它会占用太多的空间。</p><h1 id="19bf" class="mo mj it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">工件解决的问题</h1><p id="aad5" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">有了工件，原则上多个包可以使用相同的数据，你不需要下载两次。说包A和包B，都依赖于Qt库。这个问题的虚拟解决方案是让两个库都存储一个Qt:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="7fa1" class="mi mj it md b gy mk ml l mm mn">A<br/>└─ libs<br/>    └── Qt <br/><br/>B<br/>└─ libs<br/>    └── Qt</span></pre><p id="e7b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是现在我们不得不两次下载一个巨大的库，我们在硬盘上吸收了两倍的空间。所以不是一个好的解决方案。现在其他人可能认为他们很聪明，将Qt存储在一个共享目录中，供两个包使用。各种操作系统很早就这样做了，并创造了我们称之为“DLL地狱”的有趣的东西。当所需的Qt版本不完全相同时，就会出现这种情况。下载的Qt版本可能适用于A，但不适用于b。</p><h2 id="6b72" class="mi mj it bd mp nl nm dn mt nn no dp mx ld np nq mz lh nr ns nb ll nt nu nd nv bi translated">内容可寻址数据</h2><p id="5471" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Git推广了一种解决这个难题的方法，叫做<em class="nk">内容寻址</em>数据。这意味着不要通过给出名称路径如<code class="fe ma mb mc md b">A/libs/Qt</code>来定位数据，而是使用有趣的路径如:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="87ef" class="mi mj it md b gy mk ml l mm mn">7c9ef733699a1d86b8a6073ed08a4457e3e790f7/Qt</span></pre><p id="a211" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">什么鬼东西？那些难看的数字是干什么用的？这些是存储在。哈希是通过对组成某些数据的所有字节运行算法而产生的固定长度的字符串。在这种情况下，Qt库二进制文件的每一个字节都被输入到一个散列算法中，它产生一个惟一的数字，即散列。从理论上讲，你当然不能保证两个数据集产生不同的散列。这个真的是基于概率的。不同的数据集产生相同散列的机会类似于地球上随机位置的两个人捡起相同的一粒沙子。这可能发生，但可能性不大。</p><p id="f29d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个系统的美妙之处在于你可以避免下载两次完全相同的数据。Julia跟踪您的主目录中的所有软件包信息。看起来是这样的:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="ab1f" class="mi mj it md b gy mk ml l mm mn">$ cd ~/.julia<br/>$ ls<br/>artifacts/    compiled/     config/       environments/ packages/     registries/<br/>clones/       conda/        dev/          logs/         prefs/</span></pre><p id="4b08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里要注意的是，工件不是存储在它们所属的包下，而是存储在<code class="fe ma mb mc md b">artifacts</code>目录中:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="b64c" class="mi mj it md b gy mk ml l mm mn">&gt; ls ~/.julia/artifacts/<br/>0c063b1aef124b99659e1604675f2dce871e7e97<br/>0eb6ffcbe0cde10007a2678013611da80643b728<br/>6b04ad7f71b1a29adad801f4fdd0d34b3535c638</span></pre><p id="d942" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以打开其中一些看看里面有什么:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="728a" class="mi mj it md b gy mk ml l mm mn">$ ls ~/.julia/artifacts/6b04ad7f71b1a29adad801f4fdd0d34b3535c638<br/>bin include lib logs    share<br/><br/>$ ls ~/.julia/artifacts/6b04ad7f71b1a29adad801f4fdd0d34b3535c638/lib/<br/>engines-1.1     libcrypto.a     libssl.1.1.dylib    libssl.dylib<br/>libcrypto.1.1.dylib libcrypto.dylib     libssl.a        pkgconfig</span></pre><p id="c52e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，这恰好是某个包所依赖的加密库。每个依赖于这个加密库的包都会有一个<code class="fe ma mb mc md b">Artifacts.toml</code>文件，说明加密库有hash <code class="fe ma mb mc md b">6b04ad7f71b1a29adad801f4fdd0d34b3535c638</code>。然后，Julia包系统可以通过检查具有该散列的目录是否已经存在来检查它是否已经安装了这个库，并且避免第二次下载同一个库。</p><p id="c502" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，这不只是针对二进制文件。这也可能是一个大图像，或者大规模的机器学习训练数据集。你不想下载这些超过一次。</p><h2 id="3d10" class="mi mj it bd mp nl nm dn mt nn no dp mx ld np nq mz lh nr ns nb ll nt nu nd nv bi translated">避免Git Repo膨胀</h2><p id="be6c" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">工件的第二个问题是，它们避免了用二进制文件膨胀您的repo。假设你有一个<code class="fe ma mb mc md b">Comics</code>包，里面有展示漫画的代码。不是在你的包repo中放一个目录<code class="fe ma mb mc md b">super-heroes</code>和每个超级英雄的图像，而是创建一个<code class="fe ma mb mc md b">Artifacts.toml</code>文件。在里面你描述了超级英雄的照片是在哪里找到的:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="f31a" class="mi mj it md b gy mk ml l mm mn"># Comics/Artifacts.toml <br/>[super-heroes]<br/>git-tree-sha1 = "c5f4d31e5c9c5d6fba2469ceff3d9916050d92d2"<br/>lazy = true<br/><br/>    [[super-heroes.download]]<br/>    sha256 = "2aea399ab3c6b6e3a4285ec6ae31b858803442bf1b3e3e4889a2e3e8287d56c6"<br/>    url = "https://github.com/jimmy/Comics.jl/releases/download/super-heroes.tar.gz"</span></pre><p id="ec39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设你有一个朱莉娅的项目。通常你会像这样加载超级英雄图像文件:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="e19e" class="mi mj it md b gy mk ml l mm mn">path = joinpath("super-heroes", "batman.png")<br/># equivalent to: path = "super-heroes/batman.png"<br/>batman_img = load(path)</span></pre><p id="cd55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是使用伪像，你不能假设图像是局部的。相反，你应该写:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="1b54" class="mi mj it md b gy mk ml l mm mn">using Pkg.Artifacts<br/><br/>path = joinpath(artifact"super-heroes", "batman.png")<br/>batman_img = load(path)</span></pre><p id="b552" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">artifact"super-heroes"</code>部分是一个宏。这导致Julia在解析时运行代码，下载工件。如果<code class="fe ma mb mc md b">Artifacts.toml</code>文件中有<code class="fe ma mb mc md b">lazy = true</code>，那么这个工件只有在这样访问的时候才会被下载。这避免了下载超过用户实际使用的量。</p><p id="4fc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在运行时,<code class="fe ma mb mc md b">artifact"super-heroes"</code>表达式返回工件的本地路径，因此您可以加载它。</p><p id="0f89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以用更多的手动方式来完成这项工作。下面是一些朱莉娅·REPL的代码来证明这一点:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="9ba9" class="mi mj it md b gy mk ml l mm mn">julia&gt; super_hash = artifact_hash("super-heroes", "Artifacts.toml")<br/>SHA1("c5f4d31e5c9c5d6fba2469ceff3d9916050d92d2")<br/><br/>julia&gt; basepath = artifact_path(super_hash)<br/>"~/.julia/artifacts/c5f4d31e5c9c5d6fba2469ceff3d9916050d92d2"<br/><br/>julia&gt; path = joinpath(basepath, "batman.png")<br/>"~.julia/artifacts/c5f4d31e5c9c5d6fba2469ceff3d9916050d92d2/batman.png"</span></pre><p id="3146" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，这里没有太多的魔法。你可以做一个看起来像这样的“包”来让它工作:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="adf1" class="mi mj it md b gy mk ml l mm mn">$ tree Comics<br/>Comics/<br/>└── Artifacts.toml</span></pre><p id="14c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">各种工件函数实际上只是在读取<code class="fe ma mb mc md b">Artifacts.toml</code>文件。当然，由于我们没有在给定的URL中放入任何<code class="fe ma mb mc md b">.tar.gz</code>文件，也没有在<code class="fe ma mb mc md b">~/.julia/artifacts</code>目录中放入任何东西，我们当然不能加载任何东西。</p><h1 id="4710" class="mo mj it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">创建Artifacts.toml文件</h1><p id="4770" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">创建一个<code class="fe ma mb mc md b">Artifacts.toml</code>文件最初让我很困惑。我不明白:</p><ol class=""><li id="81e4" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated"><code class="fe ma mb mc md b">git-tree-sha1</code>中的SHA1哈希来自哪里？我需要运行一些命令来创建它吗？</li><li id="5c16" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated"><code class="fe ma mb mc md b">sha256</code>散列来自哪里，为什么有两个散列？</li></ol><p id="a2d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初我认为<code class="fe ma mb mc md b">git-tree-sha1</code>与我的存储库上的提交散列有某种关系。我太纠结于git这个名字了。但是放弃这个想法。工件不是git仓库。藏物只是一个文件。通常它是一个<code class="fe ma mb mc md b">.tar.gz</code>文件。这样你就可以收集一些资源，比如超级英雄的图片目录，然后打包。</p><p id="b7a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，<code class="fe ma mb mc md b">Pkg.Artifacts</code>模块的目的不仅仅是在设置好一切后访问工件。这也意味着您可以使用它来创建<code class="fe ma mb mc md b">Artifacts.toml</code>文件。许多包包含Julia脚本，这些脚本在<code class="fe ma mb mc md b">Artifacts.toml</code>文件中填充正确的信息，并负责将工件在线上传到正确的位置。</p><p id="ccd3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我最初对这些脚本的误解是，我以为它们是在软件包安装期间运行的。但是，这些脚本是由包的创建者运行的。他们甚至不需要成为包装的一部分。这是你的选择。这样做只是方便。</p><h2 id="10a0" class="mi mj it bd mp nl nm dn mt nn no dp mx ld np nq mz lh nr ns nb ll nt nu nd nv bi translated">git-tree-sha1</h2><p id="edf7" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">在<code class="fe ma mb mc md b">Pkg.Artifacts</code>模块中，我们使用<code class="fe ma mb mc md b">create_artifact</code>函数为包含要放入工件的所有文件的目录实际生成一个SHA1散列。</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="7430" class="mi mj it md b gy mk ml l mm mn">julia&gt; create_artifact() do dir<br/>           @info "storage dir: " dir<br/>       end<br/>┌ Info: storage dir:<br/>└   dir = "~/.julia/artifacts/jl_l4XQEX"<br/>SHA1("4b825dc642cb6eb9a060e54bf8d69288fbee4904")</span></pre><p id="4f41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以看到，它创建了一个名为<code class="fe ma mb mc md b">jl_l4XQEX</code>的临时目录，用于放置要哈希的文件。如果目录是空的，你可以看到我们得到了<code class="fe ma mb mc md b">"4b825dc642cb6eb9a060e54bf8d69288fbee4904"</code>散列。这当然毫无意义。我们想把一些真实的文件放进去。让我们制作一些文件。</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="c61c" class="mi mj it md b gy mk ml l mm mn">$ mkdir data<br/>$ echo "hello world" &gt; data/hello.txt<br/>$ echo "how do you do?" &gt; data/howdy.txt</span></pre><p id="3c56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些原则上可以放在任何地方。接下来我们使用<code class="fe ma mb mc md b">create_artifact()</code>为包含这两个文件的目录生成一个散列:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="da82" class="mi mj it md b gy mk ml l mm mn">julia&gt; hash = create_artifact() do dir<br/>           cp("data/hello.txt", joinpath(dir, "hello.txt"))<br/>           cp("data/howdy.txt", joinpath(dir, "howdy.txt"))<br/>       end<br/>SHA1("604c1a4760bd32fbb9758a84c1507a117252e688")</span></pre><p id="9465" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，您可以看到文件已存储在正确的工件哈希下:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="d814" class="mi mj it md b gy mk ml l mm mn">julia&gt; artifact_path(hash)<br/>"~/.julia/artifacts/604c1a4760bd32fbb9758a84c1507a117252e688"<br/><br/>julia&gt; readdir(artifact_path(hash))<br/>2-element Array{String,1}:<br/> "hello.txt"<br/> "howdy.txt"</span></pre><h2 id="71d7" class="mi mj it bd mp nl nm dn mt nn no dp mx ld np nq mz lh nr ns nb ll nt nu nd nv bi translated">Tarball SHA256哈希</h2><p id="e422" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">接下来，我们想以某种方式上传这些文件。原则上，这些文件可以以任何方式打包，我们希望确保下载的<code class="fe ma mb mc md b">.zip</code>、<code class="fe ma mb mc md b">.tar</code>或<code class="fe ma mb mc md b">.tar.gz</code>文件没有被篡改。因此，我们获取了压缩tarball的散列，因为原则上这可能与git树SHA1完全不同，后者涉及未打包文件的散列。</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="29e7" class="mi mj it md b gy mk ml l mm mn">julia&gt; tarball_hash = archive_artifact(hash, "data.tar.gz")<br/>"7bd1483bc31fd3cd885a6b3c8f953af5815ac7729593bde29c6cdec9ca16268e"</span></pre><p id="10bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ma mb mc md b">archive_artifact</code>函数获取与给定散列相关联的工件目录中的内容，并以给定的文件名路径创建压缩存档。它会对结果tarball执行常规的SHA256散列。可以在shell中验证:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="6352" class="mi mj it md b gy mk ml l mm mn">shell&gt; ls<br/>Artifacts.toml  data        data.tar.gz<br/><br/>shell&gt; shasum -a 256 data.tar.gz<br/>7bd1483bc31fd3cd885a6b3c8f953af5815ac7729593bde29c6cdec9ca16268e  data.tar.gz</span></pre><p id="3243" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以列出tarball的内容，看看它是否确实包含存储在工件目录中的两个文件。</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="9da5" class="mi mj it md b gy mk ml l mm mn">shell&gt; tar -tf data.tar.gz<br/>./<br/>./howdy.txt<br/>./hello.txt</span></pre><h2 id="d045" class="mi mj it bd mp nl nm dn mt nn no dp mx ld np nq mz lh nr ns nb ll nt nu nd nv bi translated">将详细信息写入工件. toml</h2><p id="cfa7" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在我们已经得到了所有的散列，我们原则上可以将相关信息填入<code class="fe ma mb mc md b">Artifacts.toml</code>文件。您还需要一个URL，用于存储<code class="fe ma mb mc md b">data.tar.gz</code>文件。</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="b034" class="mi mj it md b gy mk ml l mm mn">julia&gt; bind_artifact!("Artifacts.toml", "hi", hash,<br/>          download_info=[("http://howdy.com/data.tar.gz", <br/>                          tarball_hash)])</span></pre><p id="8c94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将一个名为<code class="fe ma mb mc md b">hi</code>的人工产物放入<code class="fe ma mb mc md b">Artifacts.toml</code>文件，其中包含唯一标识该人工产物的SHA1散列<code class="fe ma mb mc md b">hash</code>。此外，它还规定该软件包的用户将从<code class="fe ma mb mc md b">http://howdy.com/data.tar.gz</code> URL下载这个<code class="fe ma mb mc md b">hi</code>工件。它还将此上传文件的SHA256哈希记录为<code class="fe ma mb mc md b">tarball_hash</code>。因此，当用户下载该文件时，系统可以验证其具有相同的散列。</p><p id="7321" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看<code class="fe ma mb mc md b">Artifacts.toml</code>现在的样子:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="3925" class="mi mj it md b gy mk ml l mm mn">shell&gt; cat Artifacts.toml<br/>[hi]<br/>git-tree-sha1 = "604c1a4760bd32fbb9758a84c1507a117252e688"<br/><br/>    [[hi.download]]<br/>    sha256 = "7bd1483bc31fd3cd885a6b3c8f953af5815ac7729593bde29c6cdec9ca16268e"<br/>    url = "http://howdy.com/data.tar.gz"<br/><br/>[super-heroes]<br/>git-tree-sha1 = "c5f4d31e5c9c5d6fba2469ceff3d9916050d92d2"<br/>lazy = true<br/><br/>    [[super-heroes.download]]<br/>    sha256 = "2aea399ab3c6b6e3a4285ec6ae31b858803442bf1b3e3e4889a2e3e8287d56c6"<br/>    url = "https://github.com/jimmy/Comics.jl/releases/download/super-heroes.tar.gz"</span></pre><p id="d212" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想要掌握这些数据的人现在可以使用:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="a7fd" class="mi mj it md b gy mk ml l mm mn">julia&gt; hi_hash = artifact_hash("hi", "Artifacts.toml")<br/>SHA1("604c1a4760bd32fbb9758a84c1507a117252e688")<br/><br/>julia&gt; artifact_path(hi_hash)<br/>"~/.julia/artifacts/604c1a4760bd32fbb9758a84c1507a117252e688"</span></pre><p id="98d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，使用的快捷方式是<code class="fe ma mb mc md b">artifact"hi"</code>，但这将尝试从<code class="fe ma mb mc md b">http://howdy.com/data.tar.gz</code>下载，我没有在那里存储任何东西。</p><p id="07c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想测试这个下载是如何工作的，你可以简单地把URL指向一个本地文件位置。因为您正在更改记录在<code class="fe ma mb mc md b">Artifacts.toml</code>文件中的内容，所以您需要指定<code class="fe ma mb mc md b">force=true</code>。</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="88bc" class="mi mj it md b gy mk ml l mm mn">julia&gt; bind_artifact!("Artifacts.toml", "hi", hash, download_info=[("file:/home/steve/dev/Comics/data.tar.gz", tarball_hash)], force=true)</span><span id="00a7" class="mi mj it md b gy ok ml l mm mn">shell&gt; cat Artifacts.toml<br/>[hi]<br/>git-tree-sha1 = "604c1a4760bd32fbb9758a84c1507a117252e688"</span><span id="a7e7" class="mi mj it md b gy ok ml l mm mn">[[hi.download]]<br/>    sha256 = "7bd1483bc31fd3cd885a6b3c8f953af5815ac7729593bde29c6cdec9ca16268e"<br/>    url = "file:/home/steve/dev/Comics/data.tar.gz"</span></pre><p id="0f62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，我们假设你的漫画包存储在<code class="fe ma mb mc md b">/home/steve/dev</code>下。将其替换为硬盘上的有效路径，然后<code class="fe ma mb mc md b">artifact"hi"</code>将在第一次访问时从该位置“下载”。</p><h1 id="c5d7" class="mo mj it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">工件示例</h1><p id="e862" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">如果您想了解所有这些是如何组合在一起形成实际的工件脚本的，您可以查看一下<a class="ae lz" href="https://github.com/r3tex/ObjectDetector.jl/blob/master/dev/artifacts/generate_artifacts.jl" rel="noopener ugc nofollow" target="_blank"> ObjectDetector.jl </a>包中工件的使用。</p><p id="0e0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还在官方文档中，有<a class="ae lz" href="https://julialang.github.io/Pkg.jl/v1/artifacts/" rel="noopener ugc nofollow" target="_blank">这个例子</a>:</p><pre class="kj kk kl km gt me md mf mg aw mh bi"><span id="c756" class="mi mj it md b gy mk ml l mm mn">using Pkg.Artifacts<br/><br/>artifact_toml = joinpath(@__DIR__, "Artifacts.toml")<br/>iris_hash = artifact_hash("iris", artifact_toml)<br/><br/>if iris_hash == nothing || !artifact_exists(iris_hash)<br/>     iris_hash = create_artifact() do artifact_dir<br/>        iris_url_base = "https://archive.ics.uci.edu/ml/machine-learning-databases/iris"<br/>        download("$(iris_url_base)/iris.data",<br/>                 joinpath(artifact_dir, "iris.csv"))<br/>        download("$(iris_url_base)/bezdekIris.data", <br/>                 joinpath(artifact_dir, "bezdekIris.csv"))<br/>        download("$(iris_url_base)/iris.names", <br/>                 joinpath(artifact_dir, "iris.names"))<br/>    end<br/><br/>    bind_artifact!(artifact_toml, "iris", iris_hash)<br/>end<br/><br/>iris_dataset_path = artifact_path(iris_hash)</span></pre><p id="e517" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个脚本可以多次运行，因为它检查工件是否已经存在。这是一个将iris数据集作为工件提供的例子。</p><h1 id="04a8" class="mo mj it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">处理二进制文件</h1><p id="eb0f" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">当处理二进制文件时，我们需要一种不同的方法，因为与在不同类型的计算机上运行不同操作系统的人相比，您的机器的架构和您运行的操作系统需要不同的二进制文件。</p><p id="7787" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将在我的下一个故事中讲述:<a class="ae lz" href="https://erik-engheim.medium.com/julia-binary-artifacts-for-dummies-7c80955604ea" rel="noopener">Julia Binary Artifacts for Dummies。</a></p><p id="8867" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，每个工件都有多个散列。每个操作系统和架构组合一个。理解这一点有助于理解朱莉娅JLL包如何工作。</p></div></div>    
</body>
</html>