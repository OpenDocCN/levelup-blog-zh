# K 个元素的最大偶数和

> 原文：<https://levelup.gitconnected.com/maximum-even-sum-of-k-elements-ca060ab3a9fd>

![](img/4e1ee1a2fa1ff8ea0920dba2b7eb3d04.png)

在 [Unsplash](https://unsplash.com/s/photos/numbers?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上由 [Carlos Irineu da Costa](https://unsplash.com/@carlosirineu?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

这是一个流行的算法问题，可以用[贪婪算法](https://en.wikipedia.org/wiki/Greedy_algorithm)方法解决。这是一个学习如何以贪婪的方式思考的极好例子。

通俗地说，贪心方式就是利用局部最优解的优势，向外扩展到全局最优解。

现在，我们来看看问题陈述。

# 问题陈述:

我们得到了一个列表(坚持使用蟒蛇舌头，因为我无法停止爱它！)的正**整数，我们必须从列表中找出*最大值* ***偶数*** *总和*为 **K** 的元素。如果找不到，我们返回 *-1。***

**注意单词 **even 的重音。****

## ****样本输入/输出:****

***输入*:**

```
[4, 2, 6, 7, 8], k = 3
```

***输出:***

```
18
```

***说明:***

**由于 **k = 3** ，我们必须从这个列表中取出 3 个元素。别忘了我们必须使它成为一个偶数。因此，即使[8，7，6] = 21 的和是我们能得到的最大和，但我们不能接受它，因为它是奇数。因此，最大偶数和将是[8，6，4] = 18 的和，这是我们可以得到的最大偶数和。**

**让我们再尝试几个:**

***输入:***

```
[5,5,1,1,3], k = 3
```

***输出:***

```
-1
```

***解释:***

**看这里，我们需要 3 个元素来得到最大的偶数和。但是请注意，我们根本没有偶数。同样，3 个奇数加起来也不可能是偶数。考虑:1 + 3 + 5 = 9，所以永远是奇数和。所以，我们只返回 **-1** 。**

# ****图案:****

**一开始理解这种模式可能有点棘手。让我们把它分成几块:**

*   **首先，让我们从最基本的角度考虑一下:我们什么时候能得到一个偶数？实际上，我们只有两种方法可以得到**甚至**和。注意:**偶数+偶数=偶数(如 2 + 4 = 6)或奇数+奇数=偶数(如 1 + 3 = 4)。除了这两种方法，我们永远也得不到偶数。(例如偶数+奇数！=偶数，例如 10 + 1 = 11，反之亦然)****
*   ****其次，**注意，在给定的列表中，我们混合了偶数和奇数整数。但是，为了创造上述条件，如果我们能够在一个单独的列表中把事件和概率分开，我们的生活就会容易得多。**

****最后**，观察如果我们部署贪婪方法——在非常局部的级别我们会有:k = 1，即只有 1 个元素——那么我们会做什么？—我们必须取偶数(如果有的话)。**

**类似地，注意如果我们有 k = 2，需要 2 个偶数或 2 个奇数，因为我们已经知道:**

*   ****偶数+偶数=偶数****
*   ****奇数+奇数=偶数****
*   ****偶数+奇数！=偶数****

**在前两种情况下，我们必须取最大值以使最大值为偶数。**

# ****算法:****

**实际上，解决这个问题的方法不止一种，我将选择我认为最容易理解和说明的一种。让我们用简单的英语来解释一下:**

1.  **我们按照 desc 顺序对列表进行排序(降序在接下来的步骤中会很方便)。**
2.  **接下来，我们**分离出**偶数**和**奇数元素。在这一步之后，我们将有两个列表，一个是偶数**元素，另一个是奇数**元素，按降序排列。**

**现在，我们初始化一个 **max_sum** 来跟踪当前的最大值，然后我们部署我们的贪婪方法:**

1.  **循环，直到我们获得了 K 个元素，同时循环偶数和奇数列表，在每一步中，我们执行以下操作:**

*   **如果 **K** 是**奇数，**我们从偶数列表中取最大的数。**
*   **如果 **K** 是**偶数**，我们取两个最大偶数和两个最大赔率之和的最大值。**

**在这两种情况下，我们都必须更新 **max_sum 的运行值。****

**请注意，我们只是利用了贪婪算法方法，即获取局部最优解(即 k=1，k=2)并将其扩展到全局最优解。**

# ****代码:****

**从正整数列表中寻找最大值的代码。**

**通过取消对打印行的注释，尝试给定输入的输出。**

## ****代码演练:****

*   **首先，我们检查边缘案例并相应地返回 **-1** 。**
*   **直到 **line: 8，**我们初始化一个奇偶列表，我们将使用它来存储从主输入列表中分离出来的偶数和奇数。**
*   **Net 中，我们以相反的顺序对输入列表进行排序。**
*   **从第**11–15 行:**我们循环遍历输入列表，分离出偶数和奇数，并将它们放入各自的列表中。**
*   **接下来在**第 18–19 行**:我们初始化偶数和奇数索引，这些索引将用于跟踪我们当前在奇偶列表中循环的位置。**

**从第 **32:52 —** 行开始，我们循环执行，直到满足 k 个元素的要求。**

**注意现在有两种情况:**

1.  **如果 **k%2 == 1，即当 k 为奇数时。**我们检查偶数列表的长度是否大于 0，即偶数项目列表中至少有 1 个项目。然后我们归还那个项目。对于贪婪方法，我们可以考虑 **k = 1** 的情况**
2.  ****else: k 是偶数。**根据贪心法，我们可以认为这是当 **k = 2，**从上面我们知道:当**偶数+偶数**或**奇数+奇数时，我们只能从 2 个数中得到偶数。**所以，很自然地，我们采取了**

**请注意，当我们进入第二种情况时，我们将偶数和奇数索引增加 2。并且也将 k 减 2。这是因为我们一次取两个数字。**

**最后我们返还最大金额，终于可以睡个好觉了！**