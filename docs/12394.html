<html>
<head>
<title>Angular server side pagination and filtering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度服务器端分页和过滤</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-server-side-pagination-and-filtering-2206ce8279d1?source=collection_archive---------3-----------------------#2022-06-07">https://levelup.gitconnected.com/angular-server-side-pagination-and-filtering-2206ce8279d1?source=collection_archive---------3-----------------------#2022-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="58be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为大型数据集提高数据表的性能</h2></div><p id="fc8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将学习如何使用RxJS在Angular应用程序中实现数据表的服务器端分页和过滤。首先，让我们看看数据表的一般情况，以及为什么我们应该考虑使用服务器端分页。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/6ecbd8171ff15fdf64a804df5ca09cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*RCDk64UPAOrYb7bPvjMugw.jpeg"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">由<a class="ae lq" href="https://unsplash.com/@otutunaru?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Olga Tutunaru </a>在<a class="ae lq" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="cad7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">为什么是服务器端分页？</h1><p id="399b" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当我们使用表时，我们通常有一个端点来检索数据，然后在表组件中使用这些数据。分页和过滤是在客户端完成的。但是，如果我们需要检索大型数据集，这会显著降低我们的性能和用户体验，该怎么办呢？这就是服务器端分页的用武之地。我们可以用它来只获取当前显示页面的数据。因此，我们必须为要检索的页面添加一个参数，并为页面大小值添加另一个参数。</p><h1 id="494a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">还有过滤？</h1><p id="2407" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">因为我们只检索数据的一个子集，所以我们还需要将过滤移到服务器端，否则过滤器将只应用于可见的数据。为此，我们需要通过一个额外的搜索字符串来扩展我们的参数，服务器可以用它来查询正确的数据。</p><p id="2b2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将创建一个简单的函数从后端服务器获取一些数据。对于当前页面和尺寸参数，我们利用<code class="fe mo mp mq mr b">HttpParams</code>来设置这两个值。结果将是这样的:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2339" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于大小为10的第1页，我们将得到以下请求:</p><pre class="lf lg lh li gt mu mr mv mw aw mx bi"><span id="a9c2" class="my ls it mr b gy mz na l nb nc"><a class="ae lq" href="http://localhost:8080/paged" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/paged</a>?page=1&amp;size=10</span></pre><p id="f8e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务器可以使用这些参数来返回我们所请求的页面数据。由于这仍然是非常基本的，让我们移动到过滤。为此，我们可以简单地在请求中添加另一个参数:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b86e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的请求现在看起来像这样:</p><pre class="lf lg lh li gt mu mr mv mw aw mx bi"><span id="6e95" class="my ls it mr b gy mz na l nb nc"><a class="ae lq" href="http://localhost:8080/paged" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/paged</a>?page=1&amp;size=10&amp;search=my-search-string</span></pre><p id="c477" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，假设我们有一个小表，用户可以通过输入文本进行过滤。如果我们现在用用户的每个输入来调用我们的函数，我们可能会有很多请求。那么，我们能做些什么呢？我们可以用更多的RxJS操作符来增强我们的功能。</p><p id="7583" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们向我们的服务添加一个RxJS-Subject，它将保存用户的搜索输入以及页面和大小信息。然后，我们添加了另一个函数，我们订阅了这个主题，并使用一些RxJS操作符来触发我们现有的函数</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="373c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看不同的运算符。使用<code class="fe mo mp mq mr b">debounceTime</code>,我们可以防止请求被每个键盘事件触发，因为只有当用户在给定的时间内(在本例中为400毫秒)没有输入时，请求才会被触发。然后，我们使用<code class="fe mo mp mq mr b">distinctUntilChanged</code>操作符，如果输入改变，它将只触发我们的请求。此外，如果另一个请求被触发，<code class="fe mo mp mq mr b">switchMap</code>用于取消之前的请求。</p><p id="d8e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以将我们的主题链接到过滤器输入，就这样。但是…</p><h1 id="f2d5" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">错误处理呢？</h1><p id="f7d0" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">考虑发送一个带有第4页和一些搜索值作为参数的请求。在服务器应用我们的搜索值后，过滤后的数据可能没有第4页，我们将得到一条错误消息，例如“404-未找到页面”(取决于我们的服务器)。为了处理这种情况，我们可能希望发送另一个请求，其中包含页面参数的更新值。因此，我们可以在fetch函数中添加一些重试机制:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="910d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的职能有两个重要的变化。首先，如果响应的状态为404，我们添加<code class="fe mo mp mq mr b">retryWhen </code>操作符来触发新的请求。第二，当我们想要请求另一个页面时，我们使用<code class="fe mo mp mq mr b">tap</code>来更新我们的参数，与<code class="fe mo mp mq mr b">defer</code>-操作符一起，这将发送一个新的请求，将0作为页面参数的值。</p><p id="1284" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以将服务用于我们的表格组件。</p><h1 id="7c12" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">下一步是什么？</h1><p id="19fe" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这是一个简单的演示，展示了我们如何通过服务器端分页和过滤来获取表数据。当然，在服务器上也有一些工作要做，但是本文主要关注前端部分。</p></div></div>    
</body>
</html>