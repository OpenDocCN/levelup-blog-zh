<html>
<head>
<title>Hershey Fonts in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">好时字体在去</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hershey-fonts-in-go-b3c3e373171c?source=collection_archive---------17-----------------------#2021-09-20">https://levelup.gitconnected.com/hershey-fonts-in-go-b3c3e373171c?source=collection_archive---------17-----------------------#2021-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/26e4364efba0b95c91a16fbadaa29274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QClJ8x0Nq-Qmol82kBF7w.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">吉祥物归功于golang.org</figcaption></figure><div class=""/><p id="51f8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在Golang中解码和使用Hershey矢量字体</p><p id="a335" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为什么你会需要好时矢量字体呢？不是有很多现代字体吗？是的，然而，好时的角色是为一个非常特殊的场景而创造的:用在天生画线而不是画像素的设备上。此外，它们可以免费使用。因此，来自机械笔式绘图仪和激光切割机用户以及更多用户的兴趣重新燃起。另外，从历史和编程的角度来看，它们都非常简洁。</p><p id="f047" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好时字体编码为两个文本文件，一个用于一组<a class="ae ld" href="http://Latin alphabet" rel="noopener ugc nofollow" target="_blank">罗马字符</a>，另一个用于一组日语字符。本文主要关注罗马字符和字体，但也可以很容易地应用于日语。</p><p id="280d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Hershey Roman文本文件是一组1597个矢量字符，可以松散地组织成18种字体以及一些分类符号。我说“不严格”,因为它们已经存在了很长时间，已经被处理和重新分组了很多次。所有这些最初都是在20世纪60年代中期由Allen Vincent Hershey博士为光学绘图仪开发的，你可以在Chris Lott的<a class="ae ld" href="https://hackaday.com/2021/03/30/hershey-fonts-not-chocolate-the-origin-of-vector-lettering/" rel="noopener ugc nofollow" target="_blank">这篇优秀文章</a>中读到所有相关信息。</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi le"><img src="../Images/28571617560b502970bacd3cf11370a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWlWCqapg9CmK54nlUn8ug.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">所有好时罗马字符</figcaption></figure><p id="ac77" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我找不到原始数据集的任何来源，我能找到的最早的数据集是1997年Paul Bourke的数据集。Paul将罗马字符和日本字符作为两个独立的集合，编码到一个普通的ascii文本文件中。这种编码被证明非常耐用。许多模糊的二进制文件格式来了又去，然而几十年后我们仍然可以很容易地解码这个简单的文本格式。</p><ul class=""><li id="ed9f" class="lj lk ji kh b ki kj km kn kq ll ku lm ky ln lc lo lp lq lr bi translated">4个字符(id)表示纯文本中的字符Id(不是连续的数字)</li><li id="8924" class="lj lk ji kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">3个字符(n)表示纯文本中字符的顶点数</li><li id="72e6" class="lj lk ji kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">1个字符(lt)表示X轴左偏移，int由ASCII(lt)- ASCII('R ')导出</li><li id="415c" class="lj lk ji kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">1个字符(rt)表示X轴左偏移，int由ASCII(rt)- ASCII('R ')导出</li><li id="ac27" class="lj lk ji kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">(x，y)坐标的n * 2个字符，其中x和y由ASCII(x)- ASCII('R ')和ASCII(y)- ASCII('R ')导出</li><li id="14ea" class="lj lk ji kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">特殊情况是，如果任何坐标是一个空格，那么下一个字符将是一个“R”——这个组合被认为是一个新路径的开始(不是坐标)。</li><li id="d57e" class="lj lk ji kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">忽略遇到的任何虚假换行</li></ul><p id="f0dd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">左偏移和右偏移告诉我们字符在x轴的开始和结束位置(相对原点是字符的中心)。以这种方式，通过迭代一组路径来绘制Hershey字符，其中移动到路径中的第一个坐标，然后在该路径中的每一个其他坐标处绘制一条连续的线。</p><p id="12b8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Paul还提供了将罗马字符映射成18种字体的id集。我决定坚持使用这些名字，而不是一些看似随机的字体名称和重叠的字体集合。《未来》？..实际上？)</p><p id="f3b8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Paul的罗马字体集没有覆盖符号，但是我们可以将它们分成四种不同的符号字体，以覆盖罗马文件中的所有字符。</p><p id="03cb" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">查看Hershey文本文件(hershey.dat)的前几行，您可以看到上面提到的编码示例。</p><p id="e9e4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好时. dat</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="b26e" class="mc md ji ly b gy me mf l mg mh">1  9MWRMNV RRMVV RPSTS<br/>2 16MWOMOV ROMSMUNUPSQ ROQSQURUUSVOV<br/>3 11MXVNTMRMPNOPOSPURVTVVU<br/>4 12MWOMOV ROMRMTNUPUSTURVOV<br/>5 12MWOMOV ROMUM ROQSQ ROVUV<br/>6  9MVOMOV ROMUM ROQSQ</span><span id="4bb9" class="mc md ji ly b gy mi mf l mg mh">...</span></pre><p id="95be" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一行是</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="6964" class="mc md ji ly b gy me mf l mg mh">&lt;s&gt;&lt;s&gt;&lt;s&gt;1&lt;s&gt;&lt;s&gt;9MWRMNV&lt;s&gt;RRMVV&lt;s&gt;RPSTS</span></pre><p id="cee9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它解码成</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="87f1" class="mc md ji ly b gy me mf l mg mh">Id: 1<br/>Vertices: 9<br/>Left offset: ASCII(M) — ASCII(R) = -5<br/>Right offset: ASCII(W) — ASCII(R) = 5<br/>Path[0]Coord[0].X =  ASCII(R) — ASCII(R) = 0<br/>Path[0]Coord[0].Y = ASCII(M) — ASCII(R) = -5<br/>Path[0]Coord[1].X = ASCII(N) — ASCII(R) = -4<br/>Path[0]Coord[1].Y = ASCII(V) — ASCII(R) =4</span><span id="4ef0" class="mc md ji ly b gy mi mf l mg mh">&lt;Path Break&gt;</span><span id="3a95" class="mc md ji ly b gy mi mf l mg mh">Path[1]Coord[0].X = ASCII(R) — ASCII(R) = 0<br/>Path[1]Coord[0].Y = ASCII(M) — ASCII(R) =-5</span><span id="22f4" class="mc md ji ly b gy mi mf l mg mh">…and so on</span></pre><p id="6a38" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们从保存我们解码的数据的结构开始:</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="40c5" class="mc md ji ly b gy me mf l mg mh">type FontPath struct {<br/>   Lt     int<br/>   Rt     int<br/>   Coords [][][]int<br/>}</span></pre><p id="651a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">多维数组坐标引用为:</p><p id="7d91" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">坐标[p] =路径</p><p id="e3d2" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">路径内的坐标</p><p id="f554" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Coords[p][c][0] =坐标的X分量</p><p id="18c5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Coords[p][c][1] =坐标的Y分量</p><p id="446d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么我们的整套Hershey字符将只是这些结构的数组:</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="85ff" class="mc md ji ly b gy me mf l mg mh">var hershey = []FontPath</span></pre><p id="d8af" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的计划是编写一个小生成器，它将解码Hershey文本文件并创建一个新的。go文件保存我们的角色数据。</p><p id="8105" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">generate.go:</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="fa56" class="mc md ji ly b gy me mf l mg mh">func GenerateHershey() (out string, idToIndex map[int]int, err error) {<br/>    idToIndex = make(map[int]int)<br/>    name := "hershey"<br/>    data, err := ioutil.ReadFile(name + ".dat")<br/>    if err != nil {<br/>        return<br/>    }<br/>    fmt.Println("Decoding: ", name)<br/>    s := strings.ReplaceAll(string(data), "\n", "")<br/>    out = "//Coordinates: \n\nvar " + name + " = []FontPath{\n"<br/>    i := 0<br/>    for {<br/>        if len(s) &lt; 5 {<br/>            break<br/>        }<br/>        // hershey character id<br/>        id := s[0:5]<br/>        nid, err := strconv.Atoi(strings.Trim(id, " "))<br/>        if err != nil {<br/>            return "", map[int]int{}, err<br/>        }<br/>        idToIndex[nid] = i<br/>        //number of coordinate pairs<br/>        n, err := strconv.Atoi(strings.Trim(s[5:8], " "))<br/>        if err != nil {<br/>            return "", map[int]int{}, err<br/>        }<br/>        s = s[8:]<br/>        //number of characters<br/>        cn := 2 * n<br/>        ss := s[:cn]<br/>        //left position<br/>        lt := int(ss[0]) - int('R')<br/>        //right position<br/>        rt := int(ss[1]) - int('R')<br/>        out += fmt.Sprintf("// %d: %s\n", i, id)<br/>        out += fmt.Sprintf("{%d, %d, [][][]int{", lt, rt)<br/>        i++<br/>        //paths &amp; coordinates<br/>        if n &gt; 1 {<br/>            out += "{"<br/>        }<br/>        for i := 2; i &lt; len(ss); i++ {<br/>            if ss[i] == ' ' { //new path<br/>                out += fmt.Sprintf("},{")<br/>                i += 2<br/>            }<br/>            //coords<br/>            dx := int(ss[i]) - int('R')<br/>            dy := int(ss[i+1]) - int('R')<br/>            i++<br/>            out += fmt.Sprintf("{%d, %d},", dx, dy)<br/>        }<br/>        out = strings.TrimRight(out, ",")<br/>        if n &gt; 1 {<br/>            out += "}"<br/>        }<br/>        out += fmt.Sprintf("}},\n")<br/>        s = s[cn:]<br/>    }<br/>    out = strings.TrimRight(out, ",\n")<br/>    out += "}\n\n"<br/>    return<br/>}</span></pre><p id="7b09" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，我们沿途创建了一个地图(idToIndex) —我们这样做是为下一步生成字体集做准备。它们是Paul作为Id引用给出的，但是我们想把它们改成数组索引引用。</p><p id="ad5e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们要转换的原始数据在fontids中。go:</p><p id="dbcb" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">fontids.go</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="7709" class="mc md ji ly b gy me mf l mg mh">package hershey<br/>var Id_Fonts = map[string][]int{"Simplex": Id_Simplex,<br/>"Script_Simplex":         Id_Script_Simplex,<br/>"Gothic_English_Triplex": Id_Gothic_English_Triplex,<br/>"Gothic_German_Triplex":  Id_Gothic_German_Triplex,<br/>"Gothic_Italian_Triplex": Id_Gothic_Italian_Triplex,<br/>"Greek_Complex":          Id_Greek_Complex,<br/>"Greek_Complex_Small":    Id_Greek_Complex_Small,<br/>"Greek_Plain":            Id_Greek_Plain,<br/>"Greek_Simplex":          Id_Greek_Simplex,<br/>"Cyrillic_Complex":       Id_Cyrillic_Complex,<br/>"Italic_Complex":         Id_Italic_Complex,<br/>"Italic_Complex_Small":   Id_Italic_Complex_Small,<br/>"Italic_Triplex":         Id_Italic_Triplex,<br/>"Script_Complex":         Id_Script_Complex,<br/>"Complex":                Id_Complex,<br/>"Complex_Small":          Id_Complex_Small,<br/>"Duplex":                 Id_Duplex,<br/>"Plain":                  Id_Plain,<br/>"Triplex":                Id_Triplex,</span><span id="f613" class="mc md ji ly b gy mi mf l mg mh">//unmapped chars:</span><span id="8cad" class="mc md ji ly b gy mi mf l mg mh">"Symbols1": Id_Symbols1,<br/>"Symbols2": Id_Symbols2,<br/>"Symbols3": Id_Symbols3,<br/>"Symbols4": Id_Symbols4,<br/>}</span><span id="694c" class="mc md ji ly b gy mi mf l mg mh">var Id_Simplex = []int{<br/>699, 714, 717, 733, 719, 2271, 734, 731, 721, 722,<br/>2219, 725, 711, 724, 710, 720, 700, 701, 702, 703,<br/>704, 705, 706, 707, 708, 709, 712, 713, 2241, 726,<br/>2242, 715, 2273, 501, 502, 503, 504, 505, 506, 507,<br/>508, 509, 510, 511, 512, 513, 514, 515, 516, 517,<br/>518, 519, 520, 521, 522, 523, 524, 525, 526, 2223,<br/>804, 2224, 2262, 999, 730, 601, 602, 603, 604, 605,<br/>606, 607, 608, 609, 610, 611, 612, 613, 614, 615,<br/>616, 617, 618, 619, 620, 621, 622, 623, 624, 625,<br/>626, 2225, 723, 2226, 2246, 718,}</span><span id="4295" class="mc md ji ly b gy mi mf l mg mh">var Id_Script_Simplex = []int{<br/>699, 2764, 2778, 733, 2769, 2271, 2768, 2767, 2771, 2772,<br/>2773, 725, 2761, 724, 710, 2770, 2750, 2751, 2752, 2753,<br/>2754, 2755, 2756, 2757, 2758, 2759, 2762, 2763, 2241, 726,<br/>2242, 2765, 2273, 551, 552, 553, 554, 555, 556, 557,<br/>558, 559, 560, 561, 562, 563, 564, 565, 566, 567,<br/>568, 569, 570, 571, 572, 573, 574, 575, 576, 2223,<br/>804, 2224, 2262, 999, 2766, 651, 652, 653, 654, 655,<br/>656, 657, 658, 659, 660, 661, 662, 663, 664, 665,<br/>666, 667, 668, 669, 670, 671, 672, 673, 674, 675,<br/>676, 2225, 723, 2226, 2246, 718,}</span><span id="ed27" class="mc md ji ly b gy mi mf l mg mh">var Id_Gothic_English_Triplex = []int{<br/>3699, 3714, 3728, 2275, 3719, 2271, 3718, 3717, 3721, 3722,<br/>3723, 3725, 3711, 3724, 3710, 3720, 3700, 3701, 3702, 3703,<br/>3704, 3705, 3706, 3707, 3708, 3709, 3712, 3713, 2241, 3726,<br/>2242, 3715, 2273, 3501, 3502, 3503, 3504, 3505, 3506, 3507,<br/>3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517,<br/>3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 2223,<br/>804, 2224, 2262, 999, 3716, 3601, 3602, 3603, 3604, 3605,<br/>3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615,<br/>3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625,<br/>3626, 2225, 2229, 2226, 2246, 3729,}</span><span id="d874" class="mc md ji ly b gy mi mf l mg mh">... and much more</span></pre><p id="0ee6" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将基本上镜像原始数据的结构，并使用idToIndex将Id引用转换为数组索引引用。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="144c" class="mc md ji ly b gy me mf l mg mh">func GenerateFonts(idToIndex map[int]int) (out string) {<br/>    out = "//Fonts: \n\nvar Fonts = map[string][]int{"<br/>    for name, _ := range Id_Fonts {<br/>        out += "\"" + name + "\": " + name + ",\n"<br/>    }<br/>    out += "}\n\n"<br/>    for name, font := range Id_Fonts {<br/>        out += "var " + name + " = []int{\n"<br/>        for i, v := range font {<br/>            out += fmt.Sprintf("%d, ", idToIndex[v])<br/>            if (i+1)%10 == 0 {<br/>                out += "\n"<br/>            }<br/>        }<br/>        out += "}\n\n"<br/>    }<br/>    return<br/>}</span></pre><p id="1966" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们将添加几个map[int]int结构，这将允许我们轻松地在Id和数组索引或数组索引和Id之间来回转换——以防我们希望通过字符的原始Hershey Id来访问它。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="a02f" class="mc md ji ly b gy me mf l mg mh">func GenerateTranslators(idToIndex map[int]int) (out string) {<br/>    out1 := "//Id translation\n\nvar IdToIndex = map[int]int {\n"<br/>    out2 := "\n\nvar IndexToId = map[int]int {\n"<br/>    i := 1<br/>    for k, v := range IdToIndex {<br/>        out1 += fmt.Sprintf("%d: %d,", k, v)<br/>        out2 += fmt.Sprintf("%d: %d,", v, k)<br/>        if i%10 == 0 {<br/>            out1 += "\n"<br/>            out2 += "\n"<br/>        }<br/>        i++<br/>    }<br/>    out1 += "}\n\n"<br/>    out2 += "}\n\n"<br/>    out = out1 + out2<br/>    return<br/>}</span></pre><p id="3aae" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将在一个主生成函数中调用所有这些函数，并将它包装成一个go测试，这样我们不仅可以轻松地生成它，还可以将所有代码编写成一个Go包。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="e5fc" class="mc md ji ly b gy me mf l mg mh">func Generate() (err error) {<br/>    packageName := "hershey"<br/>    out0 := "// generated file, do not edit - see generate.go\n"<br/>    out0 += "package " + packageName + "\n\n" + "type FontPath struct {\n   Lt     int\n   Rt     int\n   Coords [][][]int\n}\n\n"</span><span id="e9d1" class="mc md ji ly b gy mi mf l mg mh">out1, idToIndex, err := GenerateHershey()<br/>    if err != nil {<br/>        return<br/>    }<br/>    out2 := GenerateFonts(idToIndex)<br/>    out3 := GenerateTranslators(idToIndex)</span><span id="e3c1" class="mc md ji ly b gy mi mf l mg mh">err = ioutil.WriteFile(packageName+".go", []byte(out0+out1+out2+out3), 0644)<br/>    // SymbolTables(IdToIndex)<br/>    return<br/>}</span></pre><p id="712a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，当我们运行Go Test时，我们生成一个名为hershey.go的新文件。完成后，我们刚刚生成了近4000行Go代码，这些代码将构成hershey字体包的基础。</p><p id="0ddd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好时去吧</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="ca3a" class="mc md ji ly b gy me mf l mg mh">// generated file, do not edit - see generate.go<br/>package hershey</span><span id="1187" class="mc md ji ly b gy mi mf l mg mh">type FontPath struct {<br/>   Lt     int<br/>   Rt     int<br/>   Coords [][][]int<br/>}</span><span id="b467" class="mc md ji ly b gy mi mf l mg mh">//Coordinates:</span><span id="2fc0" class="mc md ji ly b gy mi mf l mg mh">var hershey = []FontPath{<br/>// 0:     1<br/>{-5, 5, [][][]int{{{0, -5},{-4, 4},},{{0, -5},{4, 4},},{{-2, 1},{2, 1}}}},<br/>// 1:     2<br/>{-5, 5, [][][]int{{{-3, -5},{-3, 4},},{{-3, -5},{1, -5},{3, -4},{3, -2},{1, -1},},{{-3, -1},{1, -1},{3, 0},{3, 3},{1, 4},{-3, 4}}}},<br/>// 2:     3<br/>{-5, 6, [][][]int{{{4, -4},{2, -5},{0, -5},{-2, -4},{-3, -2},{-3, 1},{-2, 3},{0, 4},{2, 4},{4, 3}}}},<br/>// 3:     4<br/>{-5, 5, [][][]int{{{-3, -5},{-3, 4},},{{-3, -5},{0, -5},{2, -4},{3, -2},{3, 1},{2, 3},{0, 4},{-3, 4}}}},<br/>// 4:     5<br/>{-5, 5, [][][]int{{{-3, -5},{-3, 4},},{{-3, -5},{3, -5},},{{-3, -1},{1, -1},},{{-3, 4},{3, 4}}}},<br/>// 5:     6<br/>{-5, 4, [][][]int{{{-3, -5},{-3, 4},},{{-3, -5},{3, -5},},{{-3, -1},{1, -1}}}},</span><span id="cc35" class="mc md ji ly b gy mi mf l mg mh">... and much more</span></pre><p id="b46b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们将使用新的字体包编写一个绘制字符的函数。我们希望能够将它用于许多独立于任何特定渲染的应用程序，因此我们将传入一对函数来进行实际渲染，一个用于MoveTo (fmv ),一个用于LineTo(fln ),以及一个变量接口来保存我们的渲染函数可能需要的任何数据。稍后当我们展示如何使用它时，这一切会变得更有意义。</p><p id="a949" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">开始吧</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="8ea6" class="mc md ji ly b gy me mf l mg mh">type Fn func(s ...interface{})</span><span id="fbd3" class="mc md ji ly b gy mi mf l mg mh">func DrawChar(c rune, font string, scale int, x, y *int, fmv, fln Fn, s ...interface{}) (err error) {<br/>    index := int(c) - 32<br/>    f, ok := Fonts[font]<br/>    if !ok {<br/>        err = errors.New("Unknown Font: " + font)<br/>        return<br/>    }<br/>    if index &lt; 0 || index &gt;= len(f) {<br/>        err = errors.New(fmt.Sprintf("Font: %s, Length: %d, Unprintable character: %d", font, len(f), index))<br/>        return<br/>    }<br/>    if scale &lt; 0 {<br/>        err = errors.New(fmt.Sprintf("Negative scale: %d", scale))<br/>        return<br/>    }<br/>    for _, path := range hershey[f[index]].Coords {<br/>        dx := *x + (path[0][0]-hershey[f[index]].Lt)*scale<br/>        dy := *y - (path[0][1])*scale //chars assume Y inversion<br/>        //prepend dx, dy<br/>        sm := append([]interface{}{&amp;dy}, s...)<br/>        sm = append([]interface{}{&amp;dx}, sm...)<br/>        // fmv(dx, dy, s...)<br/>        if fmv != nil {<br/>            fmv(sm...)<br/>        }<br/>        for coord := 1; coord &lt; len(path); coord++ {<br/>            dx = *x + (path[coord][0]-hershey[f[index]].Lt)*scale<br/>            dy = *y - (path[coord][1])*scale<br/>            //prepend dx, dy<br/>            sl := append([]interface{}{&amp;dy}, s...)<br/>            sl = append([]interface{}{&amp;dx}, sl...)<br/>            // fln(dx, dy, s...)<br/>            if fln != nil {<br/>                fln(sl...)<br/>            }<br/>        }<br/>    }<br/>    //update x for char width<br/>    *x += (hershey[f[index]].Rt - hershey[f[index]].Lt) * scale<br/>    return<br/>}</span></pre><p id="0377" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以在函数的内部看到，我们只是迭代了角色的所有路径，将MoveTo函数(fmv)应用于路径中的第一个坐标。然后，我们迭代路径中的所有其他坐标，并对每个坐标应用LineTo函数(fln)。请注意，我们将坐标添加到变量s的前面，并将其传递给函数，这样函数就可以访问变量s中的坐标和其他任何内容。注意，x和y是字符的本地原点，我们将它们作为指针传递，这样它们就可以被更新到一个新的位置。因为字符是从中心开始绘制的，所以我们从x坐标中减去左边的偏移量。因为它是上下颠倒的，所以我们从本地y原点减去y坐标。我们的目标是考虑一个普通的二维笛卡尔坐标系，然后渲染到任何设备或格式坐标系，比如PNG，垂直轴是翻转的。</p><p id="82f0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了使用这个新函数，我们需要做的就是传递两个函数来进行实际的渲染。在我们的例子中，我们将通过渲染到image.RGBA来测试它。因此，我们需要一些东西来将线条转换为像素(如果我们渲染到笔式绘图仪，就不需要)。我们将使用Bresenham软件包来绘制直线。</p><p id="0236" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm" rel="noopener ugc nofollow" target="_blank"> Bresenham算法是一种经典的计算机科学</a>算法，用于在两点之间绘制一条完整的像素线。夏羽·布内尔写了一个<a class="ae ld" href="https://github.com/StephaneBunel/bresenham/blob/master/drawline.go" rel="noopener ugc nofollow" target="_blank">的不错的Go版本</a>，虽然他声称这不是生产，但我认为它没有问题，而且它工作得很好。</p><p id="83c4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">由于Bresenham函数需要to和from点，我们将把ImageMoveTo坐标保存回变量列表，以便ImageLineTo可以访问它。ImageLineTo函数然后解包保存的ImageMoveTo坐标、它自己的坐标、目标图像和颜色，然后调用Bresenham函数在图像上呈现线条。最后，它将其坐标推回到移动槽中，用作下一行中的x1，y1。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="f9cd" class="mc md ji ly b gy me mf l mg mh">// s = (x2, y2, x1, y1, img, color)<br/>func ImageMoveTo(s ...interface{}) {<br/>   x := *(s[0].(*int))<br/>   y := *(s[1].(*int))<br/>   *(s[2].(*int)) = x //save x and y in s for line<br/>   *(s[3].(*int)) = y<br/>}</span><span id="11e2" class="mc md ji ly b gy mi mf l mg mh">// s = (x2, y2, x1, y1, img, color)<br/>func ImageLineTo(s ...interface{}) {<br/>   x1 := *(s[2].(*int)) //saved from ImageMoveTo<br/>   y1 := *(s[3].(*int))<br/>   x2 := *(s[0].(*int))<br/>   y2 := *(s[1].(*int))<br/>   img := (s[4].(*image.RGBA))<br/>   dimg := convertIf(img) //bresenham needs draw.Image<br/>   color := (s[5].(*color.RGBA))<br/>   bresenham.Bresenham(dimg, x1, y1, x2, y2, color)<br/>   *(s[2].(*int)) = x2 //save x and y in s for next line<br/>   *(s[3].(*int)) = y2<br/>}</span></pre><p id="882d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们测试一下DrawChar，在本文开头创建所有Hershey罗马字符的图像。</p><p id="89f4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">examples.go</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="4854" class="mc md ji ly b gy me mf l mg mh">var ColorBLACK = color.RGBA{0, 0, 0, 255}<br/>var ColorGREEN = color.RGBA{0, 255, 0, 255}</span><span id="1acf" class="mc md ji ly b gy mi mf l mg mh">//Test function for DrawChar<br/>func DrawAllFontImage() (err error) {<br/>    var imgRect = image.Rect(0, 0, 2000, 2000)<br/>    img := image.NewRGBA(imgRect)<br/>    var mx, my int //reserve space for move coords<br/>    x := 50<br/>    y := 1900<br/>    lineHt := 50<br/>    scale := 1<br/>    for fontname, f := range Fonts {<br/>        fmt.Println("  Drawing Font: ", fontname)<br/>        err = DrawString(fontname+":", "Plain", scale, &amp;x, &amp;y, ImageMoveTo, ImageLineTo, &amp;mx, &amp;my, img, &amp;ColorBLACK)<br/>        x = 50<br/>        y -= Height["Plain"][1] - Height["Plain"][0] + 5<br/>        for i, _ := range f {<br/>            err = DrawChar(rune(i+32), fontname, scale, &amp;x, &amp;y, ImageMoveTo, ImageLineTo, &amp;mx, &amp;my, img, &amp;ColorBLACK)<br/>            if err != nil {<br/>                return<br/>            }<br/>        }<br/>        y -= lineHt<br/>        x = 50<br/>    }<br/>    toimg, err := os.Create("allfonts.png")<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer toimg.Close()<br/>    flipImg := FlipV(img)<br/>    png.Encode(toimg, flipImg)<br/>    return<br/>}</span><span id="7ccf" class="mc md ji ly b gy mi mf l mg mh">func FlipV(img image.Image) *image.RGBA {<br/>    bnds := img.Bounds()<br/>    var newImg = image.NewRGBA(bnds)<br/>    for j := bnds.Min.Y; j &lt; bnds.Max.Y; j++ {<br/>        for i := bnds.Min.X; i &lt; bnds.Max.X; i++ {<br/>            c := img.At(i, j)<br/>            newImg.Set(i, bnds.Max.Y-j-1, c)<br/>        }<br/>    }<br/>    return newImg<br/>}</span></pre><p id="3af1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请记住，我们是在正常的2d笛卡尔坐标中思考和绘制，因此我们必须垂直翻转以使PNG看起来向右，因为PNG Y轴随着它的下降而增加。</p><p id="643e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，假设你想画一个完整的字符串，而不是一次画一个字符？我们将添加一个DrawString函数来实现这一点，并且仍然对渲染进行抽象。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="9b15" class="mc md ji ly b gy me mf l mg mh">func DrawString(str string, font string, scale int, x, y *int, fmv, fln Fn, s ...interface{}) (err error) {<br/>    for _, c := range str {<br/>        err = DrawChar(c, font, scale, x, y, fmv, fln, s...)<br/>        if err != nil {<br/>            return<br/>        }<br/>    }<br/>    return<br/>}</span></pre><p id="950a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，我们的DrawChar函数会随着X位置的变化而更新，这样我们就可以从停止的地方绘制另一个字符。</p><p id="b966" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们在一个新的例子中测试抽绳。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="b691" class="mc md ji ly b gy me mf l mg mh">func DrawAllFontStringImage() (err error) {<br/>    var imgRect = image.Rect(0, 0, 2000, 2000)<br/>    img := image.NewRGBA(imgRect)<br/>    var mx, my int //reserve space for move coords<br/>    x := 0<br/>    y := 1990<br/>    scale := 2<br/>    str := "Hello World!"<br/>    for fontname, _ := range Fonts {<br/>        fmt.Println("  Drawing Font String: ", fontname)<br/>        //miny, maxy<br/>        height := Height[fontname]<br/>        y -= (height[1] * scale)<br/>        x = 0<br/>        err = DrawString(fontname+": "+str, fontname, scale, &amp;x, &amp;y, ImageMoveTo, ImageLineTo, &amp;mx, &amp;my, img, &amp;ColorBLACK)<br/>        if err != nil {<br/>            return err<br/>        }<br/>        y += (height[0] * scale)<br/>    }<br/>    toimg, err := os.Create("allstringfonts.png")<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer toimg.Close()<br/>    flipImg := FlipV(img)<br/>    png.Encode(toimg, flipImg)<br/>    return<br/>}</span></pre><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi le"><img src="../Images/e095cfd5f61a2584915460e0eca50a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKgI6lGd0RQNcUwHLZ42Ng.png"/></div></div></figure><p id="679b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以就此打住，但是我们可以通过将长字符串分解成多行来轻松地呈现它们，从而使它变得更加有用。</p><p id="1dc5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样，我们将通过传递渲染函数来使它呈现不可知。这里我们将采用一种简单的方法，只在空格或换行符上断开一个字符串。我们需要一个依赖于语言的断字词典来拆分单词。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="1f99" class="mc md ji ly b gy me mf l mg mh">func DrawStringLines(str string, font string, scale int, x, y *int, lineSpace, width int, fmv, fln Fn, s ...interface{}) (err error) {<br/>    re := regexp.MustCompile(`[\n| +]`)<br/>    id := re.FindAllIndex([]byte(str), -1)<br/>    if id == nil {<br/>        return<br/>    }<br/>    height := Height[font]<br/>    lastIndex := 0<br/>    x0 := *x<br/>    for strId := 0; strId &lt; len(id); strId++ {<br/>        *x = x0<br/>        _, _, xx, _, err := StringBounds(font, scale, *x, *y, str[lastIndex:id[strId][0]])<br/>        if err != nil {<br/>            return err<br/>        }<br/>        if (xx &gt; (x0 + width)) || (str[id[strId][0]] == '\n') { //exceeded width or , print to last good break<br/>            if xx &gt; (x0 + width) {<br/>                strId--<br/>                if strId &lt; 0 {<br/>                    return errors.New("No breaks and too long") //does not fit??<br/>                }<br/>            }<br/>            *x = x0<br/>            *y -= (height[1] * scale)<br/>            err = DrawString(str[lastIndex:id[strId][0]], font, scale, x, y, fmv, fln, s...)<br/>            *y += (height[0] * scale) - lineSpace<br/>            lastIndex = id[strId][0] + 1<br/>        }<br/>    }<br/>    *x = x0<br/>    if lastIndex &lt; len(str) {<br/>        *y -= (height[1] * scale)<br/>        err = DrawString(str[lastIndex:], font, scale, x, y, fmv, fln, s...)<br/>    }<br/>    return<br/>}</span><span id="4fa2" class="mc md ji ly b gy mi mf l mg mh">//get the bounds of a string to be drawn (do not draw)<br/>func StringBounds(font string, scale int, x, y int, str string) (minX, minY, maxX, maxY int, err error) {<br/>    haveFirst := false //to seed max/min<br/>    tx := x<br/>    ty := y<br/>    for _, c := range str {<br/>        err = DrawChar(c, font, scale, &amp;tx, &amp;ty, Bounds, Bounds, &amp;haveFirst, &amp;minX, &amp;minY, &amp;maxX, &amp;maxY)<br/>        if err != nil {<br/>            return<br/>        }<br/>    }<br/>    return<br/>}</span><span id="a858" class="mc md ji ly b gy mi mf l mg mh">// s = (haveFirst, minX, minY, maxX, maxY)<br/>func Bounds(s ...interface{}) {<br/>    x := *(s[0].(*int))<br/>    y := *(s[1].(*int))<br/>    b := *(s[2].(*bool))<br/>    if !b {<br/>        *(s[2].(*bool)) = true<br/>        *(s[3].(*int)) = x<br/>        *(s[4].(*int)) = y<br/>        *(s[5].(*int)) = x<br/>        *(s[6].(*int)) = y<br/>    } else {<br/>        *(s[3].(*int)) = int(math.Min(float64(x), float64(*(s[3].(*int)))))<br/>        *(s[4].(*int)) = int(math.Min(float64(y), float64(*(s[4].(*int)))))<br/>        *(s[5].(*int)) = int(math.Max(float64(x), float64(*(s[5].(*int)))))<br/>        *(s[6].(*int)) = int(math.Max(float64(y), float64(*(s[6].(*int)))))<br/>    }<br/>}</span></pre><p id="1ccb" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">注意，我们传入了两个新的参数，lineSpace来添加除了行高之外的任何额外的行间距。宽度，它决定了在寻找换行符之前我们想要绘制的最大宽度。这个函数使用高度来移动到下一行，这就是为什么我们在generate.go中预先计算字体字符高度参数。</p><p id="b864" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要一个新的函数StringBounds来告诉我们候选子串的边界，看看我们是否超出了宽度。请注意，我们利用现有的DrawChar函数来完成这项工作。因为我们用渲染函数和变量实现了它，所以我们现在可以用一个新的边界渲染函数来查找和保存min和max。尽管DrawChar以整数工作，因为原生Hershey数据是整数，但如果需要，我们可以很容易地在渲染函数中将它转换为浮点数。</p><p id="06a5" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好吧，让我们测试拉绳，看看我们得到了什么。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="1749" class="mc md ji ly b gy me mf l mg mh">//Test function for DrawStringLinesImage<br/>func DrawAStringLines() (err error) {<br/>    var imgRect = image.Rect(0, 0, 3000, 3000)<br/>    img := image.NewRGBA(imgRect)<br/>    var mx, my int //reserve space for move coords<br/>    x := 100<br/>    y := 2900<br/>    scale := 3<br/>    lineSpace := 50<br/>    width := 2800<br/>    font := "Script_Complex"<br/>    str := "Dearest Bianca,\n\nHello favorite cousin, how are you doing? I am writing to you from sunny Seattle where the trains and ferries are always running and the seagulls are always calling. We are having loads of fun. I have decided that I really want to be submarine captain for my career, so I am now studying Ocean Navigation. Perhaps you would like to travel with me when I get my submarine?\nLove,\n Gopher"<br/>    err = DrawStringLines(str, font, scale, &amp;x, &amp;y, lineSpace, width, ImageMoveTo, ImageLineTo, &amp;mx, &amp;my, img, &amp;ColorBLACK)<br/>    if err != nil {<br/>        return err<br/>    }<br/>    toimg, err := os.Create("stringlines.png")<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer toimg.Close()<br/>    flipImg := FlipV(img)<br/>    png.Encode(toimg, flipImg)<br/>    return<br/>}</span></pre><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/e87c0ec1f4a69bfd91126df993607302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awUErMrMayJdD8g56eLAeQ.png"/></div></div></figure><p id="4872" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的好时矢量字体包已经完成了。要在您自己的代码中使用它，只需:</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="403b" class="mc md ji ly b gy me mf l mg mh">go get github.com/exyzzy/hershey</span></pre><p id="71c2" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">并将其导入到您的代码中:</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="cb87" class="mc md ji ly b gy me mf l mg mh">import "github.com/exyzzy/hershey"</span></pre><p id="a633" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，您可以轻松地使用任何绘制函数，并向其传递您自己的渲染函数，或者使用示例中的图像版本。</p><pre class="lf lg lh li gt lx ly lz ma aw mb bi"><span id="f752" class="mc md ji ly b gy me mf l mg mh">func DrawChar(c rune, font string, scale int, x, y *int, fmv, fln Fn, s …interface{}) (err error)</span><span id="31dd" class="mc md ji ly b gy mi mf l mg mh">func DrawString(str string, font string, scale int, x, y *int, fmv, fln Fn, s …interface{}) (err error)</span><span id="adbc" class="mc md ji ly b gy mi mf l mg mh">func DrawStringLines(str string, font string, scale int, x, y *int, lineSpace, width int, fmv, fln Fn, s …interface{}) (err error)</span></pre><p id="0546" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有代码都可以在这里找到，玩得开心！</p><p id="6f26" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://github.com/exyzzy/hershey" rel="noopener ugc nofollow" target="_blank">github.com/exyzzy/hershey</a></p></div></div>    
</body>
</html>