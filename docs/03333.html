<html>
<head>
<title>JavaScript Function Construction (Part 7)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript函数构造(第7部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-function-construction-part-7-17c5661e6ea7?source=collection_archive---------17-----------------------#2020-05-03">https://levelup.gitconnected.com/javascript-function-construction-part-7-17c5661e6ea7?source=collection_archive---------17-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c29" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ES6 IIFC用React获取请求</h2></div><p id="9f22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a>|<strong class="kk iu">|</strong><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a>||<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <strong class="kk iu">第7部分</strong></p><p id="7b16" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的JavaScript函数构造器之旅中，我想介绍的最后一件事(至少目前是这样)是编写一个IIFC，它使用ES6 <code class="fe lf lg lh li b">Class</code>处理获取请求。我还想将这些获取请求发送到Ruby on Rails后端，该后端为HTTP端点提供JSON API。</p><p id="396d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个约束是，我想使用一个基本的React应用程序作为我们的前端，并将我们的IIFC导入到<code class="fe lf lg lh li b">App.js</code>中。这样我们就可以在使用React时测试IIFC的功能。</p><p id="9cce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单的东西。</p><p id="c6ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在两个博客前首次写了一个非常相似的IIFC，但是我们没有在ES6中写任何东西，也没有利用ES6为类提供的所有语法糖。</p><p id="6a63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一次，事情会有所不同。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="9c1d" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">德佳·VU。我以前写过这样的代码</h2><p id="ea01" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我将快速跳过Ruby On Rails的设置，因为我们将使用与本系列第5部分<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369"><strong class="kk iu"/></a>相同的后端来构建JavaScript函数，并且不会对它的工作方式做任何改变。</p><p id="26af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你只需要知道我们在<code class="fe lf lg lh li b">localhost:3001</code>有一个JSON API设置。这个API是使用Fast JSON API构建的，由两个PostgreSQL表组成:一个是来自美国的人的表，另一个是来自欧洲的人的表。</p><p id="a111" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些表需要作为JSON对象在<code class="fe lf lg lh li b">localhost:3001/usas</code>和<code class="fe lf lg lh li b">localhost:3001/europes</code>可用，如下所示:</p><p id="a027" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在</em>处<code class="fe lf lg lh li b"><em class="mo">localhost:3001/usas</em></code></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/9f475300b849d2aad3be5bfac1cd4a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*TOAZpYlJBezRfsWRo4UkYQ.jpeg"/></div></div></figure><p id="3611" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在</em>在<code class="fe lf lg lh li b"><em class="mo">localhost:3001/europes</em></code></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/cb23cb762024c954e006d7ddd9d328b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*dWB-im71c1fgH9IoSBpGjg.jpeg"/></div></figure><p id="ea4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想更详细地了解我们是如何设置的，我建议你通读一下本系列关于JavaScript函数构造的第5部分</p><p id="1663" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过我们设置Rails的方式，我们可以轻而易举地向<code class="fe lf lg lh li b">localhost:3001</code>发出获取请求，让我们可以随心所欲地使用我们的IIFC。</p><p id="3ef2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的React前端也将是我们在第5部分 中构建的相同设置，并没有什么不同寻常。我们需要做的就是在终端中运行最基本的<code class="fe lf lg lh li b">create-react-app</code>命令，我们应该准备好了。</p><p id="86ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要做的就是移动(或删除)我们当前在<code class="fe lf lg lh li b">./src/utility</code>文件夹中的<code class="fe lf lg lh li b">fetchFunctions.js</code>文件，并将其重命名(或替换)为<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>。</p><p id="c2a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与我们在将<code class="fe lf lg lh li b">getTime.js</code>转换为<code class="fe lf lg lh li b">getTimeES6.js</code>时开始上一篇博客的方式相同。下面是我们前端的文件结构应该是什么样子:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0d4e88ebca1f635bf7d579064cc30fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*4LS0SdNuawqsaMttjl3irQ.jpeg"/></div></figure><p id="39bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没什么我们以前没见过的，但我只是想确保我们都在同一页上。或者在同一个文件夹中。你明白我的意思。</p><p id="84b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们今天要做的所有工作都在<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>内，之前是<code class="fe lf lg lh li b">fetchFunctions.js</code>。</p><p id="c84c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为参考，下面是最初的<code class="fe lf lg lh li b">fetchFunctions.js</code> IIFC的样子:</p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c4dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">fetchFunctions.js</code>允许我们做的是抽象出许多枯燥的代码，我们每次想要向<code class="fe lf lg lh li b">localhost:3001</code>发出请求时都需要编写这些代码。不用写出整个请求，我们可以将<code class="fe lf lg lh li b">fetchFunctions.js</code>导入到<code class="fe lf lg lh li b">App.js</code>中，然后用几个参数调用<code class="fe lf lg lh li b">fetchFunctions.js</code>中的一个方法。</p><p id="cece" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个是我们要发送的RESTful方法，第二个是我们要向其发送请求的URL，根据方法的不同，第三个是包含我们要用来更新数据库的数据的对象。</p><p id="fc73" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们从<code class="fe lf lg lh li b">App.js</code>的<code class="fe lf lg lh li b">componentDidMount()</code>中调用<code class="fe lf lg lh li b">fetchFunctions('get', <a class="ae le" href="http://localhost:3001/usas)" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/usas)</a></code>，我们将获得<code class="fe lf lg lh li b">usas</code>表中的所有行:</p><p id="5e9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在App.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="acef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在chrome中查看控制台，我们应该会看到我们的<code class="fe lf lg lh li b">usas</code>表:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nf"><img src="../Images/f220336a6fc4a0a6cf2c10f60ab873fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0MgOLFLhr1l_beNRSrlzVw.jpeg"/></div></div></figure><p id="2bbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那里只有9个人，因为在写这篇博客之前，我删除了一个用于测试。</p><p id="54a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论哪种方式，这些都是我们正在处理的主要事情，对于任何关注这个系列的人来说都不应该是什么新东西。</p><p id="5473" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望如此。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="05d6" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">完全（或彻底）地</h2><p id="253d" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">随着React和Rails分别在<code class="fe lf lg lh li b">localhost:3000</code>和<code class="fe lf lg lh li b">localhost:3001</code>正确设置，我们可以将注意力转向更新<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>。</p><p id="7952" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要重构的很多东西与我们重构<code class="fe lf lg lh li b">getTime.js</code>的方式是并行的，但是有一些变化，这样我们的方法可以接受多个参数。</p><p id="cf8b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要做的第一件事是把<code class="fe lf lg lh li b">fetchFunctions.js</code>剥离到它的生命骨架。<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>将会使用和<code class="fe lf lg lh li b">getTimeES6.js</code>一样的框架，所以我们将会遵循一些熟悉的步骤。</p><p id="22da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在fetchFunctionsES6.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f54f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里开始，我们想给一个匿名函数添加一个非常熟悉的<code class="fe lf lg lh li b">init</code>变量集。这个函数将返回我们传递给<code class="fe lf lg lh li b">fetchFunctions</code> <code class="fe lf lg lh li b">Class</code>(我们还没有写)的方法名的调用。被调用的方法<code class="fe lf lg lh li b">init</code>从我们发送到后端的获取请求中返回承诺。</p><p id="2397" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有我们以前没做过的，也没有我们以前博客里没见过的。主要增加的是<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>如何处理我们传递给即将编写的<code class="fe lf lg lh li b">fetchFunctions</code> <code class="fe lf lg lh li b">Class</code>的两个额外参数:</p><p id="212e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在fetchFunctionsES6.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9e4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想对这里发生的事情有更详细的解释，请查看本系列的<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af"> <strong class="kk iu">第4部分</strong> </a>、<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369"> <strong class="kk iu">第5部分</strong> </a>和<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c"> <strong class="kk iu">第6部分</strong> </a>。</p><p id="ff0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们将<code class="fe lf lg lh li b">init</code>作为<code class="fe lf lg lh li b">fetchFunctions</code>附加到全局执行上下文，并在<code class="fe lf lg lh li b">module</code>中导出它，我们将能够在任何其他需要它的JavaScript文件中使用<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>，以及在React的内部和外部:</p><p id="4626" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">in fetchFunctionsES6.js:</code></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c014" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以把<code class="fe lf lg lh li b">fetchFunctions</code> <code class="fe lf lg lh li b">Class</code>加到<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>上。这里的技巧是确保我们的<code class="fe lf lg lh li b">constructor()</code>方法正确地接受和传递参数给方法:</p><p id="8c6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在fetchFunctionsES6.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d726" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您遵循本博客系列的<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369"> <strong class="kk iu">第5部分</strong> </a>，唯一的主要区别是我去掉了检查方法是否被传入<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>的<code class="fe lf lg lh li b">error</code>方法。</p><p id="b065" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为有了添加的参数，它不能像使用<code class="fe lf lg lh li b">getTime.js</code>那样工作，并且需要大量的重构，这超出了本文的范围。</p><p id="25a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，我觉得移除<code class="fe lf lg lh li b">error</code>方法有助于将博客的重点放在设置获取请求上。</p><p id="45e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论如何，让我们确保一切都设置正确，并向<code class="fe lf lg lh li b">fetchFunctions</code> <code class="fe lf lg lh li b">Class</code>添加一个测试方法，并尝试从<code class="fe lf lg lh li b">App.js</code>中的<code class="fe lf lg lh li b">componentDidMount()</code>调用它。</p><p id="6a13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在fetchFunctionsES6.js中:</em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="db0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在App.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="073a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在Chrome: </em></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/68acf79e605c69f476152ccb9ca66b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tk0V5Sb3kUMQigs7aTyiNQ.jpeg"/></div></div></figure><p id="53ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很好。</p><p id="f402" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里我们可以开始从<code class="fe lf lg lh li b">fetchFunctions</code> <code class="fe lf lg lh li b">Class</code>内部构建我们的RESTful方法。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="85cd" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">安于现状</h2><p id="c856" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们添加到我们的<code class="fe lf lg lh li b">fetchFunctions</code>类中的方法与我们之前在<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369"> <strong class="kk iu">第5部分</strong> </a>中写的方法相同。</p><p id="b858" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们最初编写<code class="fe lf lg lh li b">fetchFunctions.js</code>和<code class="fe lf lg lh li b">getTime.js</code>的美妙之处在于，我们不需要用后端重构任何东西，也不需要重构<code class="fe lf lg lh li b">App.js</code>中的任何东西。所有的重构都将与<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>一起进行，因为我们的计划是返回与<code class="fe lf lg lh li b">fetchFunctions.js</code>完全相同的承诺。</p><p id="efad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从一个<code class="fe lf lg lh li b">GET</code>请求开始:</p><p id="7689" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">in</em>T7<em class="mo">in fetchfunctionses 6 . js:</em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2a87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过将<code class="fe lf lg lh li b">get</code>作为<code class="fe lf lg lh li b">fetchFunctions</code>调用中的第一个参数，将URL作为第二个参数，从<code class="fe lf lg lh li b">App.js</code>调用这个方法。我们还可以使用相同的方法来获取表中的所有行，或者表中的单个行:</p><p id="55ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在App.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0660" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在Chrome中:</em></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nh"><img src="../Images/1504c2d130dfc13d362acd4864fc88ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4L02crG7--TQqyKybLthuw.jpeg"/></div></div></figure><p id="065f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户登录或点击按钮时，您更有可能得到<code class="fe lf lg lh li b">userID</code>,就像您通常在反应中一样。出于演示目的，我们对变量<code class="fe lf lg lh li b">userID</code>使用静态值，而<code class="fe lf lg lh li b">fetchFunctions</code>将像没有区别一样工作。</p><p id="2180" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们来设置我们的<code class="fe lf lg lh li b">POST</code>方法:</p><p id="e3ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在</em> <code class="fe lf lg lh li b"><em class="mo">class</em></code> <em class="mo"> </em> <code class="fe lf lg lh li b"><em class="mo">fetchFunctions</em></code> <em class="mo">在fetchFunctionsES6.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5545" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在应该能够像以前一样通过将<code class="fe lf lg lh li b">post</code>方法和URL从<code class="fe lf lg lh li b">App.js</code>传递到<code class="fe lf lg lh li b">fetchFunctions</code>来创建一个新的人员表，而且还可以使用一个包含我们想要创建该人员的信息的对象:</p><p id="510d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在App.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="41eb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在Chrome: </em></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ni"><img src="../Images/a5d4eb2af513aa6485dea4f0d3eca3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKB7zZu2sjuEg9OCe-MfxQ.jpeg"/></div></div></figure><p id="71f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了。</p><p id="91f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以继续使用<code class="fe lf lg lh li b">PATCH</code>方法，至少在这个例子中，它与我们的<code class="fe lf lg lh li b">POST</code>方法是相同的。我认为将这两种方法分开是很好的做法，但是我并没有忽视将这两种方法结合起来的可能性。</p><p id="85be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">in</em><code class="fe lf lg lh li b"><em class="mo">class</em></code><em class="mo"/><code class="fe lf lg lh li b"><em class="mo">fetchFunctions</em></code><em class="mo">in fetchfunctionses 6 . js:</em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ce36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们从<code class="fe lf lg lh li b">App.js</code>调用<code class="fe lf lg lh li b">PATCH</code>方法，并传入一个有效的<code class="fe lf lg lh li b">userID</code>以及一个包含我们想要更新的数据的对象，我们应该能够在Chrome中看到结果。</p><p id="f7c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我注释掉了<code class="fe lf lg lh li b">POST</code>请求，这样我们就不会不断地在<code class="fe lf lg lh li b">usas</code>表中创建新行:</p><p id="ba97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在App.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7578" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在Chrome中:</em></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nj"><img src="../Images/6c3d7b80828bae9030900b3cf42a0043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRZrEGDjO9YTuifwfJdB6A.jpeg"/></div></div></figure><p id="c818" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太棒了。</p><p id="9233" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们有<code class="fe lf lg lh li b">DELETE</code>方法，它和<code class="fe lf lg lh li b">GET </code>方法一样简单:</p><p id="969a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在</em> <code class="fe lf lg lh li b"><em class="mo">class</em></code> <em class="mo"> </em> <code class="fe lf lg lh li b"><em class="mo">fetchFunctions</em></code> <em class="mo">在fetchFunctionsES6.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9eed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所要做的就是像我们的<code class="fe lf lg lh li b">PATCH</code>或<code class="fe lf lg lh li b">GET</code>方法一样传递一个单一的URL，具有相应ID的人将从表中删除:</p><p id="e448" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在App.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4f45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在Chrome中:</em></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nk"><img src="../Images/6608ea23d071a76ba8c3684bddcbae2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blOyXXiDLkro8ie7V5PIIQ.jpeg"/></div></div></figure><p id="646c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太棒了。</p><p id="eba6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所有的RESTful方法在尽可能少的重构(减去额外的错误处理)下再次正常工作，同时使用一些新的ES6语法。</p><p id="989e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们最后看一下<code class="fe lf lg lh li b">App.js</code>和<code class="fe lf lg lh li b">fetchFunctionsES6.js</code>，称这个博客任务完成:</p><p id="b21a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在fetchFunctionsES6.js中:</em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cf82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mo">在App.js: </em></p><figure class="mq mr ms mt gt mu"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="ca7f" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">任务完成</h2><p id="5bba" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">自从关于JavaScript函数构造的本系列文章的第1部分以来，我们已经走过了很长的路，涵盖了很多内容。我们已经构建了一些很酷的库，想出了如何抽象出我们正在处理的代码JavaScript文件，减少了我们的枯燥程度，深入了JavaScript的一些更深层次的部分，讨论了关于学习新编程语言的具体细节的概念和想法，甚至用React和Ruby On Rails之类的东西进行了一些创新。</p><p id="957c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在可预见的将来，我关于JavaScript函数构造器的博客系列到此结束。我觉得我已经尽我所能地谈论这个话题，而没有陷入全新的话题或开始全新的项目，所以我觉得这是“正式”这个系列的一个很好的结束点。</p><p id="d7c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要再次感谢您踏上这漫长的2个月JavaScript之旅，并希望本系列能帮助您理解JavaScript的强大。不只是作为HTML和CSS的伴侣，而是作为一种编程语言，它能做的不仅仅是操纵DOM上的元素。</p><p id="e76f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使没有，嗯…我试过了。</p><p id="e202" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保持安全…保持健康…继续为正义而战。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="4502" class="nl lr it bd ls nm nn no lv np nq nr ly jz ns ka mb kc nt kd me kf nu kg mh nv bi translated">JavaScript函数构造</h1><p id="44d8" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <strong class="kk iu"> </strong> <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> <strong class="kk iu"> </strong> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <strong class="kk iu">第7部分</strong></p></div></div>    
</body>
</html>