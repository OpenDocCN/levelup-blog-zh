<html>
<head>
<title>React Custom Hooks — useAutoScroll</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应自定义挂钩—使用自动滚动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-custom-hooks-useautoscroll-d63f17037a2d?source=collection_archive---------6-----------------------#2020-03-26">https://levelup.gitconnected.com/react-custom-hooks-useautoscroll-d63f17037a2d?source=collection_archive---------6-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3e669a0ea033db06ea9e7d8abbefcbb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HT9bblarto9_XbQFQQ9fNA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">草莓</figcaption></figure><p id="c081" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">与本文相关的回购可以在</em> <a class="ae le" href="https://github.com/MarkGeeRomano/useAutoScroll" rel="noopener ugc nofollow" target="_blank"> <em class="ld">这里找到</em> </a></p><p id="c903" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最近在工作中，我开发了一个具有固定高度的React组件，但是它的内容<em class="ld">可以比父div具有更高的高度。div保存可变数量的输入，其数量由用户决定，用户可以通过单击按钮来添加输入。我应用了一个<code class="fe lf lg lh li b">overflow: scroll</code> css属性，这样用户可以向下滚动并使用他们添加的输入。下面是组件的简化:</em></p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/96ec388b6150e1a184eee8adcc34f147.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*3G-N39Tq1bbTwTg7AbckYw.gif"/></div></figure><p id="89b7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是我还希望每次添加输入时，输入容器滚动到底部，这样用户就可以看到输入。这可以通过组合使用<code class="fe lf lg lh li b">useRef</code>和<code class="fe lf lg lh li b">useEffect</code>挂钩来实现。</p><p id="1a33" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先实例化两个引用。让我们调用第一个<code class="fe lf lg lh li b">prevLengthRef</code>，我们将它设置为我们的<code class="fe lf lg lh li b">inputs</code>数组的初始长度。接下来，我们将实例化另一个ref，称为<code class="fe lf lg lh li b">containerRef</code>，我们将用<code class="fe lf lg lh li b">null</code>初始化它。最后，我们将创建另一个名为<code class="fe lf lg lh li b">prevLength</code>的变量，并将其设置为<code class="fe lf lg lh li b">prevLengthRef.current</code>。这在目前看来是多余的，但过一会儿就有意义了。</p><pre class="lj lk ll lm gt lq li lr ls aw lt bi"><span id="6b79" class="lu lv it li b gy lw lx l ly lz">function View() {<br/>  const [inputs, setInputs] = useState([])<br/>  const prevLengthRef = useRef(inputs.length)<br/>  const containerRef = useRef(null)<br/>  const prevLength = prevLengthRef.current<br/>  ...<br/>}</span></pre><p id="c451" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来我们将利用<code class="fe lf lg lh li b">useEffect</code>来比较<code class="fe lf lg lh li b">prevLengthRef</code>和<code class="fe lf lg lh li b">inputs.length</code>的值，以确定我们是否应该在渲染后执行自动滚动。我们希望在<code class="fe lf lg lh li b">inputs</code>数组的长度改变时进行比较。因此，让我们将该值放入deps数组中。</p><pre class="lj lk ll lm gt lq li lr ls aw lt bi"><span id="cbb3" class="lu lv it li b gy lw lx l ly lz">function View() {<br/>  ...<br/>  useEffect(() =&gt; {<br/>    //some logic to perform autoscroll<br/>  }, [inputs.length])<br/>  ...<br/>}</span></pre><p id="77a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们声明我们希望在<code class="fe lf lg lh li b">inputs</code>的<code class="fe lf lg lh li b">.length</code>属性改变时触发回调，并可能触发自动滚动。实际上，我们只希望自动滚动在长度<em class="ld">增加时发生。我们不能在dep数组中进行这种检查，所以我们将把这个逻辑放在回调函数中。这就是我们要利用上面声明的看似多余的变量— <code class="fe lf lg lh li b">prevLength</code>的地方。这个变量保存了对先前渲染的<code class="fe lf lg lh li b">inputs.length</code>值的引用。在<code class="fe lf lg lh li b">useEffect</code>回调中，我们将该值与<code class="fe lf lg lh li b">inputs.length</code>的当前值进行比较，如果它较小，我们知道我们添加了一个输入元素，并执行自动滚动。在回调结束时，我们将ref的<code class="fe lf lg lh li b">.current</code>属性设置为<code class="fe lf lg lh li b">inputs.length</code>的值，以期待下一次的渲染和比较。</em></p><pre class="lj lk ll lm gt lq li lr ls aw lt bi"><span id="ac8c" class="lu lv it li b gy lw lx l ly lz">function View() {<br/>  ...<br/>  const prevLength = prevLengthRef.current<br/>  useEffect(() =&gt; {<br/>    if (prevLength &gt; length) {<br/>      //some logic to perform autoscroll   <br/>    }<br/>    prevLengthRef.current = length<br/>  }, [inputs.length])<br/>  ...<br/>}</span></pre><p id="43ba" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">大部分碎片都在那里。现在我们需要编写逻辑来改变我们的DOM并滚动到我们的div的底部。首先要做的是将<code class="fe lf lg lh li b">containerRef</code>作为<code class="fe lf lg lh li b">ref</code>道具传递到我们的输入容器中。</p><pre class="lj lk ll lm gt lq li lr ls aw lt bi"><span id="91c6" class="lu lv it li b gy lw lx l ly lz">function View() {<br/>  ...<br/>  return (<br/>    &lt;div className="view-container"&gt;<br/>      &lt;div ref={containerRef} className="inputs-container"&gt;<br/>  ...<br/>}</span></pre><p id="8a0c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们的<code class="fe lf lg lh li b">useEffect</code>内部，我们将在<code class="fe lf lg lh li b">ref</code>上执行我们的操作。这很简单。我们的<code class="fe lf lg lh li b">containerRef</code>的<code class="fe lf lg lh li b">.current</code>属性指向div节点，因此包含了<code class="fe lf lg lh li b">.scrollHeight</code>和<code class="fe lf lg lh li b">.scrollTop</code>属性。<code class="fe lf lg lh li b">scrollTop</code>是从元素顶部到其最顶端的<em class="ld">可见</em>内容的距离。<code class="fe lf lg lh li b">scrollHeight</code>是代表元素高度的值，包括不可见的像素。如果我们将<code class="fe lf lg lh li b">scrollTop</code>设置为<code class="fe lf lg lh li b">scrollHeight</code>，就会产生自动滚动✨.的效果</p><pre class="lj lk ll lm gt lq li lr ls aw lt bi"><span id="cf65" class="lu lv it li b gy lw lx l ly lz">function View() {<br/>  ...<br/>  const prevLength = prevLengthRef.current<br/>  useEffect(() =&gt; {<br/>    if (prevLength &gt; length) {<br/>     const container = containerRef.current<br/>     container.scrollTop = container.scrollHeight<br/>    }<br/>    prevLengthRef.current = length<br/>  }, [inputs.length])<br/>  ...<br/>}</span></pre><p id="238c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，每当我们用按钮添加输入时，我们的<code class="fe lf lg lh li b">useEffect</code>回调就会触发，并且会滚动到底部。这是实际操作和组件的完整代码。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/0b4915966ff423b752ed40e062b931e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/1*iTT4r3rn9gWHN_hEZSCrtw.gif"/></div></figure><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="450f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">几个星期后，我发现自己需要再次自动滚动以获得类似的视图。我的第一反应是再次实现这组钩子——毕竟，这相当简单。但事实证明，这是一个创建自定义挂钩的好机会，并为我自己节省了十几行组件代码。</p><p id="1747" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">把它抽象成一个广义的函数需要你问自己:</p><p id="ebbd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">哪些特定于组件的信息需要与钩子共享？</em></p><p id="d347" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">钩子生成了什么信息，组件需要利用这些信息来达到预期的效果？</em></p><p id="bffc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">什么逻辑是真正通用的，并且可以留在钩子内？</em></p><p id="a718" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在查看组成自动滚动的组件内钩子集时，我们可以看到触发事件集的值是<code class="fe lf lg lh li b">inputs.length</code>。这是我们将<code class="fe lf lg lh li b">prevLength</code>设置为的值，这是<code class="fe lf lg lh li b">useEffect</code> dep数组中的值，这是我们的条件中的值，它决定是否应该发生自动滚动——该值是基于给定组件中的元素数量生成的。因此，这个值是需要传递到我们的定制钩子中的信息——函数的参数。</p><pre class="lj lk ll lm gt lq li lr ls aw lt bi"><span id="ff5a" class="lu lv it li b gy lw lx l ly lz">function useAutoscroll(length) {<br/>  // ???<br/>}</span></pre><p id="8151" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">很好——我们已经确定了钩子的输入应该是什么。让我们跟进一下输出应该是多少。输出是专门为使用它的组件创建的值。在查看我们的<code class="fe lf lg lh li b">&lt;View/&gt;</code>组件时，我们可以看到jsx使用的钩子产生的实际值是<code class="fe lf lg lh li b">containerRef</code>。这是我们传递给div的一个<code class="fe lf lg lh li b">ref</code>，允许自动滚动。这是我们自定义钩子函数的输出。让我们给它一个更通用的名字。</p><pre class="lj lk ll lm gt lq li lr ls aw lt bi"><span id="b5f2" class="lu lv it li b gy lw lx l ly lz">function useAutoscroll(length) {<br/>  const elementRef = useRef(null)<br/>  // ???<br/>  return elementRef<br/>}</span></pre><p id="59af" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们已经弄清楚了输入、输出，接下来是确定钩子中的逻辑，使用它的组件不关心的逻辑。这段代码自己编写—它只是剩下的逻辑。剩下的逻辑是这组钩子本身的绝大部分逻辑，这意味着我们从组件中取出了一堆代码。这就是为什么它是定制钩子的一个很好的用例。这是所有的一切:</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="35c7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在让我们利用我们的<code class="fe lf lg lh li b">&lt;View2/&gt;</code>组件——一个与<code class="fe lf lg lh li b">&lt;View/&gt;</code>几乎相同的组件，但是它使用下拉菜单而不是输入。</p><figure class="lj lk ll lm gt ju"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="df95" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们已经将几乎所有的钩子逻辑提取到一个定制钩子中。它缩短了我们组件的代码行，使用起来非常简单，现在它可以跨任何组件使用。在这里，它和<code class="fe lf lg lh li b">&lt;View/&gt;</code>一起工作——每个人都在使用自己的定制钩子，并且彼此完全独立。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/2ee8a77e8d318379bcb9ddcb70cc04e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*dHv6N7ibvWzzTZU8IDuRdQ.gif"/></div></figure><p id="e00a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">感谢阅读！</p><p id="c333" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">与本文相关的回购可以在</em> <a class="ae le" href="https://github.com/MarkGeeRomano/useAutoScroll" rel="noopener ugc nofollow" target="_blank"> <em class="ld">这里找到</em> </a></p></div></div>    
</body>
</html>