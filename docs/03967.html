<html>
<head>
<title>Kickoff Angular Full-Stack Development and Stop Using “ng serve”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启动角度全栈开发，停止使用“ng发球”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kickoff-angular-full-stack-development-b42a41ded696?source=collection_archive---------19-----------------------#2020-06-03">https://levelup.gitconnected.com/kickoff-angular-full-stack-development-b42a41ded696?source=collection_archive---------19-----------------------#2020-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e2fb47da410fb97378f4919199eff25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ff-vqfCjnm1vohOo.jpg"/></div></div></figure><h1 id="2fa5" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">TL；博士</h1><p id="3ab1" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在Angular全栈开发中，这里有一些从开发到生产构建高效环境的技巧:</p><ul class=""><li id="568d" class="lu lv iq ky b kz lw ld lx lh ly ll lz lp ma lt mb mc md me bi translated">停止使用<code class="fe mf mg mh mi b">ng serve</code>运行应用程序。</li><li id="81ba" class="lu lv iq ky b kz mj ld mk lh ml ll mm lp mn lt mb mc md me bi translated"><strong class="ky ir">将</strong>前端和后端与<code class="fe mf mg mh mi b">ng build --watch <strong class="ky ir">--output-path</strong></code>集成，将编译好的角页输出到后端的静态内容文件夹。</li><li id="112e" class="lu lv iq ky b kz mj ld mk lh ml ll mm lp mn lt mb mc md me bi translated">在你的后端服务器中启用<strong class="ky ir">实时重载</strong>。以<strong class="ky ir">跳靴</strong>为例，添加<code class="fe mf mg mh mi b">spring-boot-devtools</code>依赖。</li><li id="93f0" class="lu lv iq ky b kz mj ld mk lh ml ll mm lp mn lt mb mc md me bi translated">使用<a class="ae mo" href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" rel="noopener ugc nofollow" target="_blank">扩展</a>在Chrome中启用LiveReload。</li><li id="45b1" class="lu lv iq ky b kz mj ld mk lh ml ll mm lp mn lt mb mc md me bi translated">设置<code class="fe mf mg mh mi b">.gitignore</code>防止编译后的Angular代码被提交给源代码管理。</li><li id="8946" class="lu lv iq ky b kz mj ld mk lh ml ll mm lp mn lt mb mc md me bi translated">如果你使用<strong class="ky ir">路由器</strong>，当用户登陆一个有路由的URL时，处理404错误。</li><li id="e260" class="lu lv iq ky b kz mj ld mk lh ml ll mm lp mn lt mb mc md me bi translated">设置CI/CD以在构建期间执行集成。</li></ul><h1 id="185a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="637a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你是一个说<strong class="ky ir"> Angular </strong>的全栈开发人员，你希望有一个结合前端和后端的本地HTTP服务器。然而，所有这些教程都要求你去做<code class="fe mf mg mh mi b"><strong class="ky ir">ng serve</strong></code>。这是前端专用的，并且<strong class="ky ir">不是</strong>设计来让你从Angular调用API的。在Angular中做模拟数据或伪造数据也很耗时，因为你可以自己完成所有真正的后端工作。让我们尽量避免这些废话。</p><p id="6f62" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">本系列文章以JAVA ( <strong class="ky ir"> SpringBoot </strong>)为例，指导您如何建立整个全栈开发工具链。你可以将类似的想法应用到你的NodeJS (express，koa)，Python (flask，django)，Go (beego，gin，revel)，PHP (laravel，codeigniter)，ASP.NET，或者任何你喜欢的后端语言/方法。</p><h1 id="0343" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">主要思想</h1><p id="5413" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将简单地用<code class="fe mf mg mh mi b">ng build</code>代替<code class="fe mf mg mh mi b">ng serve</code>。</p><p id="e5dc" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">为了使<strong class="ky ir">自动检测</strong>角度源代码变化并自动触发重新编译，我们添加了<code class="fe mf mg mh mi b">--watch</code>选项。</p><p id="be77" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">为了使编译后的Angular代码位于我们的<strong class="ky ir">后端的静态页面文件夹</strong>中，而不是默认的<code class="fe mf mg mh mi b">/dist</code>文件夹中，我们添加了<code class="fe mf mg mh mi b">--output-path</code>选项，并指定了目标文件夹。</p><p id="dfa0" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">下面是我们正在使用的命令:</p><pre class="ms mt mu mv gt mw mi mx my aw mz bi"><span id="fcb9" class="na jz iq mi b gy nb nc l nd ne">ng build <strong class="mi ir">--watch</strong> <strong class="mi ir">--output-path=</strong>/d/my-backend/src/main/resources/static</span></pre><p id="f477" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">我们的后端静态文件夹将如下所示:(以JAVA/SpringBoot为例)</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/235bc956e27a9038e96c5f78642e135b.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/0*N_V8lYXXGfUIhhXH.jpg"/></div></figure><p id="8561" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">简单，嗯？</p><h1 id="8fbb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">提高效率</h1><p id="305b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe mf mg mh mi b">ng serve</code>快速高效，因为它在内存中，内置的<strong class="ky ir">实时重新加载</strong>功能(在NodeJS中)可以在代码发生变化时自动刷新浏览器页面。(有了<a class="ae mo" href="https://angular.io/guide/ivy" rel="noopener ugc nofollow" target="_blank"> Ivy </a>的帮助，现在瞬间的构建甚至更快了。)</p><p id="09ce" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">要实现我们自己的live-reload，我们需要一个具有这种能力的服务器，并且客户端(前端)要有相应的websocket服务。</p><p id="a85c" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated"><strong class="ky ir">服务器端:</strong>以<strong class="ky ir"> SpringBoot </strong>为例，将<code class="fe mf mg mh mi b">spring-boot-devtools</code>添加到你的开发依赖中。</p><pre class="ms mt mu mv gt mw mi mx my aw mz bi"><span id="15ab" class="na jz iq mi b gy nb nc l nd ne">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;<strong class="mi ir">spring-boot-devtools</strong>&lt;/artifactId&gt;<br/>  &lt;optional&gt;true&lt;/optional&gt;<br/>&lt;/dependency&gt;</span></pre><p id="0002" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated"><strong class="ky ir">客户端:</strong>在Chrome中安装<a class="ae mo" href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" rel="noopener ugc nofollow" target="_blank"> LiveReload扩展</a>。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/def60f133a867cd9ea2a9ebd82c21479.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/0*sbvZOwVlU9JDvZVO.jpg"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated"><a class="ae mo" href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" rel="noopener ugc nofollow" target="_blank">镀铬的LiveReload extension </a></figcaption></figure><p id="dfab" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">如果您使用IDE来启动服务器，那么实时重新加载可能会变慢，因为它可能有自己的更改检测机制。你必须调整设置，使其更好地响应文件的变化。以Eclipse为例，您可以启用本机挂钩。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/1e0008a4dd912cc4e25b79d0f037dbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ykiyx7rHRPZxOLWa.jpg"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">在Eclipse中启用本机挂钩</figcaption></figure><h1 id="68a3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">具体细节</h1><p id="14b8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们考虑一下我们现在将面临的一些缺点。</p><h2 id="1b60" class="na jz iq bd ka nm nn dn ke no np dp ki lh nq nr km ll ns nt kq lp nu nv ku nw bi translated">404未找到</h2><p id="bf71" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">假设您使用Angular的路由。URL“http://localhost:4200/user/jen”将在浏览器中打开Jen的联系信息。然而，这个魔法只对<code class="fe mf mg mh mi b">ng serve</code>有效。在你自己的后端服务器中，它不会识别出这是你的SPA中的一条路线。它只是试图定位静态文件<code class="fe mf mg mh mi b">/user/jen</code>，但失败了，并返回一个404错误。</p><p id="66d7" class="pw-post-body-paragraph kw kx iq ky b kz lw lb lc ld lx lf lg lh mp lj lk ll mq ln lo lp mr lr ls lt ij bi translated">在SpringBoot中，你可以<a class="ae mo" href="https://stackoverflow.com/a/46854105/1118626" rel="noopener ugc nofollow" target="_blank">配置资源处理器规则</a>，或者简单地让你的后端<a class="ae mo" href="https://stackoverflow.com/a/40281409/1118626" rel="noopener ugc nofollow" target="_blank">将所有404错误转发给index.html</a>。</p><h2 id="445a" class="na jz iq bd ka nm nn dn ke no np dp ki lh nq nr km ll ns nt kq lp nu nv ku nw bi translated">停止提交编译的角度代码</h2><p id="4717" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们只是让编译好的前端代码自动复制到后端项目中。我们不希望那些重复的代码每次都被提交，所以将静态内容文件夹添加到<code class="fe mf mg mh mi b">.gitignore</code>是个好主意。</p><h2 id="15bf" class="na jz iq bd ka nm nn dn ke no np dp ki lh nq nr km ll ns nt kq lp nu nv ku nw bi translated">在CI/CD中构建webapp</h2><p id="573f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后但同样重要的是，我们将需要在构建期间做同样的复制到静态文件夹的事情。(我们刚刚<code class="fe mf mg mh mi b">.gitignore</code>了静态文件夹中的所有代码，因此当CI/CD刚刚<code class="fe mf mg mh mi b">git clone</code>了它时，该文件夹将是空的)以good-o-Jenkins为例，我们可以添加这些预构建脚本:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/e056ad46ac506c2dae75aa6ab48f30ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7FM3bfQI58vsZT-w.jpg"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">Jenkins预构建脚本示例(该Jenkins从机是一台Windows机器)</figcaption></figure><h1 id="7e02" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结果</h1><p id="1281" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我们只讨论这个想法。现实中事情可能会变得更加困难。接下来的文章将给出更多的教程和示例代码，并揭示更多的细节。</p></div></div>    
</body>
</html>