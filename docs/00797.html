<html>
<head>
<title>What is the Event Loop in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的事件循环是什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-an-event-loop-69e1581ecdcc?source=collection_archive---------1-----------------------#2019-08-02">https://levelup.gitconnected.com/what-is-an-event-loop-69e1581ecdcc?source=collection_archive---------1-----------------------#2019-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/bcaeca25a8fce6ffed43a7aaf7445dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*QQE8gwh0QvP9-Ij0xablAA.gif"/></div></figure><p id="29e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Javascript是一种单线程语言。被各种引擎解读，最著名的是Chrome和Node用的V8。</p><p id="7c04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然而，引擎实际上只做了几件事。它逐行运行代码，并将函数添加到调用堆栈中。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ks"><img src="../Images/a359e4a29660a066c08852b8dd1e648b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLbK8nM3pfLWPu4qIUaWww.png"/></div></div></figure><p id="a2f7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么如果你发送一个这样的递归函数会发生什么呢？</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/c14c4e3380b408a5cd3cde9bd0eadcb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*7-hqPbh3tEWELMWIlbPOxQ.png"/></div></figure><p id="2364" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">引擎会将每个调用添加到堆栈中，直到堆栈过载。您可能见过一两次“最大调用堆栈超出错误”，对吗？</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ks"><img src="../Images/b81da78c6d8614d18b851b7b43293a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SsUMEKtyEcfyj67N6cWhzQ.png"/></div></div></figure><p id="c54e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">非常明确地说，事件循环不会修复您的错误递归。</p><p id="d7f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是，如果你想在一个app上使用一个执行极其复杂的图像变换的拉票库呢？您肯定不希望用户在页面呈现之前等待这种情况发生。否则，他们可能会离开你的应用程序。多亏了Javascript中处理异步函数的一些特性，我们能够在调用每个先前的函数之前看到事情。这些函数由事件循环管理。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lc"><img src="../Images/5cc9e04718e07569b0ecb1dc0d4ca5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvbUhFpMUeN9xoaazrp_gQ.jpeg"/></div></div></figure><p id="f9d7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事件循环具体做什么:</p><ul class=""><li id="de94" class="ld le iq jw b jx jy kb kc kf lf kj lg kn lh kr li lj lk ll bi translated">等待和调度事件的代码</li><li id="1ac4" class="ld le iq jw b jx lm kb ln kf lo kj lp kn lq kr li lj lk ll bi translated">处理其环境的事件</li><li id="863a" class="ld le iq jw b jx lm kb ln kf lo kj lp kn lq kr li lj lk ll bi translated">监控调用堆栈和回调队列</li><li id="579b" class="ld le iq jw b jx lm kb ln kf lo kj lp kn lq kr li lj lk ll bi translated">将异步代码分解成节拍</li></ul><p id="c2af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">什么是滴答——滴答是事件循环的一次迭代，由处理非常具体的事情的阶段组成。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/e17ef9f42b925a8a1052a8db242fb627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*YkyXaNiIixCaRkkpjAywkQ.png"/></div></figure><h2 id="9d78" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kf mb mc md kj me mf mg kn mh mi mj mk bi translated">事件循环阶段</h2><p id="1c2a" class="pw-post-body-paragraph ju jv iq jw b jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr ij bi translated">计时器—指定执行回调之前的阈值</p><p id="3903" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">待定回调—执行系统操作回调</p><p id="39ea" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">空闲/准备—仅供内部使用</p><p id="0513" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">轮询—检索新事件，执行I/O回调和计时器</p><p id="ce70" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">检查— <code class="fe mq mr ms mt b">setImmediate()</code>调用的回调</p><p id="d847" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">结束回访—任何特定的“结束”回访</p><p id="9376" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事件循环代码是用C编写的，由几家公司管理。Libuv (Node)和Libevent (Google Chrome，Tor)是目前使用的两个主要工具。下面是一个应用于特定环境的Libuv事件循环源代码的例子，比如Node.js，它就是为这个环境开发的。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mu"><img src="../Images/50ff832acfbc6e834c2322933d481505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtNILGhqsjzoekld5PgisA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">传入的上下文是环境，传入的循环是libuv事件循环。</figcaption></figure><p id="2451" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么上面的代码实际上在做什么呢？让我们来看看伪代码。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mz"><img src="../Images/a2b1abcc4dbee4639f1cc54f459fc3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6f72a76phc_kAKdvOSQOQ.png"/></div></div></figure><p id="78b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这实际上是一个由一些出色的代码处理的简单过程，这些代码改变了我们编写应用程序的方式。如果没有事件循环，应用程序要么非常慢，要么非常无聊。</p><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c7ebb7f6a184a27044ef02df8d8a2e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*7E8nrGSkD9UuCbmd5uLgqA.jpeg"/></div></figure><p id="bc07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么Libuv又是什么呢？</p><ul class=""><li id="ab89" class="ld le iq jw b jx jy kb kc kf lf kj lg kn lh kr li lj lk ll bi translated">Libuv是利用Libev和微软IOCP的想法为Node.js开发的，因为Libev不支持微软，而Node希望所有机器的循环处理都有一个单一的依赖</li></ul><figure class="kt ku kv kw gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f05bd66377f98bb680d18d9344fee044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*5H0t7xXzy8rKhK14RxjsUg.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">独角兽迅猛龙库—又名Libuv</figcaption></figure></div></div>    
</body>
</html>