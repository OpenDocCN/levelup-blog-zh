<html>
<head>
<title>Solving N-Queens/Rooks bit by bit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一点一点地解决N皇后/车</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solving-n-queens-rooks-bit-by-bit-1f3f3a08fda8?source=collection_archive---------6-----------------------#2019-01-16">https://levelup.gitconnected.com/solving-n-queens-rooks-bit-by-bit-1f3f3a08fda8?source=collection_archive---------6-----------------------#2019-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4dc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大家最喜欢的递归问题对吧？当我还是老师的时候，我喜欢把这个问题分配给我聪明的学生，因为我知道这会让他们慢下来，这样我就可以把注意力集中到别的地方。几个月前，在研究一些LeetCode问题时，我又一次碰到了这个问题，并且很享受回忆之旅。上周，作为<a class="ae kl" href="https://www.hackreactor.com/" rel="noopener ugc nofollow" target="_blank"> HackReactor </a>的一部分，我再次遇到了这个问题，但这次我的任务是使用按位运算符来解决它，以减少一些计算时间。谷歌搜索让我看到了一位前人力资源毕业生发的这条<a class="ae kl" href="https://twitter.com/spellrp/status/332992908565295104" rel="noopener ugc nofollow" target="_blank">推文</a>。这是一个非常厚颜无耻的实现，但是作为一个教过不同编程技能的学生的人，我认为最好让它更具可读性。</p><h1 id="70d2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">代码</strong></h1><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/08a8eaad036fa9a46eda6367bb0ce67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*iRipUgUyBYt4S0AnmMuAwg.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">谁不喜欢递归呢？</figcaption></figure><h1 id="3669" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">哗</strong></h1><p id="faa1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这个算法是从马丁·理查德的<a class="ae kl" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.51.7113&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">论文</a>中推导出来的，他比我聪明得多。这张图片应该可以直观地展示这个算法。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="ab gu cl mb"><img src="../Images/0f0ec41f681a5b5d060abf9cc170abc0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*-0c9R2bNXNcQqL7lO1Ht0Q.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">简单对吗？</figcaption></figure><p id="ae86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这就是你所需要的，请随意继续，也许可以看看他论文的其余部分…否则，请留下来听听更多的细节。</p><p id="2de6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">入门</strong></p><p id="ee51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数接受一个数字n，它决定了我们要搜索有效解的板子的大小。我们首先声明一个结果数组来存储我们在算法中遇到的所有解。然后我们声明一个变量done等于2^n -1。例如，对于大小为4的棋盘，2⁴-1产生15，在二进制中是1111。这将用于我们递归中的基本情况。然后，我们通过传递几个0和一个空数组来开始我们的递归之旅。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/de0fe055609de504cf29e6a3931cfb51.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*XjlZoYXS37mo0zilbfNDdQ.png"/></div></figure><p id="c531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">寻找我们的解决方案</strong></p><p id="1718" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的是要记住，我们将以自下而上的方式解决这个问题，如上图所示。通过一次尝试一行的解决方案，我们可以跳过检查来查看该行是否已经被另一个Queen占用。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4ca95ad8077cbca14242aad7eb353d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*ZcM30XVddmApJs3ZKdOPjw.png"/></div></figure><p id="b05d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ld是左对角线的缩写，我们将使用它来跟踪当前行中被当前行下一行的皇后阻挡的位置。不出所料，rd将被用于跟踪右对角线上被前女王阻挡的位置。col将用于跟踪当前由下面一行中的皇后占据的所有列。这些值都从0开始，因为我们还没有放置皇后。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi me"><img src="../Images/66162e97cec9c69f104192e214cd9d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*j3Xgu3NYOUzw9NN6B3sQhw.png"/></div></figure><p id="0580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">openColumns将用于跟踪当前行中我们可以安全放置皇后的位置。它是使用按位“或”(|)和按位“翻转”(~)计算的。我们首先或我们的三个跟踪变量在一起，看看所有的位置，目前是不安全的一个新的女王。然后，我们使用~翻转所有的位，将所有的空位设置为1，以备将来使用。我们第一次遇到这种情况时，没有设置皇后，因此所有位置都是安全的，OR返回0，然后我们对其求反，得到全1，表示我们可以将皇后放在任何位置。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/569469f440086e7c50e7e6b54def3067.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*yEm4Ee0fVnkpvxGjWV5prw.png"/></div></figure><p id="5a74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个while循环允许我们在新行中放置皇后时检查所有可能的位置。只要openColumns中至少还有一个位置，按位AND(&amp;)将返回true，因为done被设置为全1，即。0b1100 &amp; 0b1111将返回第一位，并为0b0100返回true。这是一个真值，所以循环继续。当我们一次删除一列时，openColumns将被更新，直到没有位置需要检查，它将为0。0b0000 &amp; 0b1111将返回0，一个falsy值，我们将退出while循环。开始0b1111 &amp; 0b1111返回true，我们开始搜索。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/4282dad5f30ae739e148819475553e3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*oPx6wNhkJJgzAzaSzTYCUw.png"/></div></figure><p id="a0ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的线用于选择要检查的位置。在openColumns上使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="noopener ugc nofollow" target="_blank">二进制补码</a>运算符(-)，将其转换为0b1111到0b0001。当我们把这些值加在一起，我们得到0b0001。因此，我们将尽可能在第一列中放置一个女王。pos更新为1。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/162814446422af1363aab4220c3298a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*5iB2z7TWNglRoXKguAwUng.png"/></div></figure><p id="a924" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们更新openColumns，告诉它我们将尝试这个位置。0b 1111–0b 0001产生0b1110。这个值不是0，所以我们知道在while循环中有更多的列要检查。但是下一行是大的。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/4c1c96affc76a571692f2efbc9b7dc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*wAE2KhcW4CfBoYFlUJ1GOA.png"/></div></figure><p id="493f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个让我停下来的问题，所以我会试着一点一点地分解它。让我们看看传递给solve的第一个参数。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/d62524aa698c1f12ed9fb5170f73e40e.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/1*ibP35quP-xFntjgzRgDnJQ.png"/></div></figure><p id="0eb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将ld中的当前值与我们想要检查的位置进行比较。0b0000 | 0b0001 = 0b0001。&gt;&gt;是按位移位运算符，它将一个数字中的所有位向右移位该运算符后面的数字。0b0001&gt;&gt;1 = 0b0000。1已被移出，因此，ld在下一次调用solve时将保持为0。这应该是有意义的，因为如果一个皇后在棋盘的左下角，那么左边就没有什么了。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ae96456d7ce6f8be352661077b56bf75.png" data-original-src="https://miro.medium.com/v2/resize:fit:162/format:webp/1*E-w54WKZf4ZY_mNxtq0c9Q.png"/></div></figure><p id="4bcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将col的当前值与我们想要检查的位置进行比较。0b0000 | 0b0001 = 0b0001。这将防止我们在以后的递归中在该列中放置另一个皇后。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/d32d38b07e922ecda3bc22a53b7f131d.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*7Fw8YOOzEV5Lsyvlc6mg_Q.png"/></div></figure><p id="ac9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将rd中的当前值与我们想要检查的位置进行比较。0b0000 | 0b0001 = 0b0001。&lt;</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/db9efb20152ce6473f160267ae3a8b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:254/format:webp/1*bQn-VQpzHamThT1-w2LUvA.png"/></div></figure><p id="5b2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将当前位置连接到我们的工作解决方案数组中，并将所有更新的值传递给solver，以便进行下一次递归调用。</p><p id="d4b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二轮</strong></p><p id="0724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的下一次solve迭代中，在第10行之后，我们在openColumns中剩下0b1100。通过执行按位“或”然后求反，我们可以看到只有两个可能的列，我们需要尝试放置一个新的皇后。这是对我以前实现的NQueens问题的巨大改进。通常，我会尝试在第1列放置一个皇后，检查它是否有效，移除它，尝试在第2列放置一个皇后，等等。</p><p id="52d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">基地案例</strong></p><p id="0c04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的col变量一次只更新一位。因此，如果我们对col进行了4次“或”运算，这意味着已经成功放置了4个皇后。我们可以通过比较col和设置为0b1111的变量done来检查这一点。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/c04f47be064ce915eed4d0b1e155b8a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*YfqDf6b9E0Su7P9vUOQcTQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">成功！！</figcaption></figure><p id="40d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们已经找到了一个有效的解决方案，并可以将其推送到我们的结果数组中供以后使用。原谅我跳过了一些中间的回合，但是如果你在跟随算法的步骤上有困难，我会推荐我所做的。在第14行后放置一个degugger语句，并单步执行代码，查看变量是如何更新的。</p><h1 id="8b23" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">白车</strong></h1><p id="7685" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我在标题中加入了车，但是一次都没有提到它们。这是因为如果你了解事情是如何进行的，那么修改代码来求解N-Rooks是很容易的。在第5、10和15行删除rd和ld，然后在第18行从第一个调用中删除相应的0…嘭！你刚刚解决了N-Rooks。</p><h1 id="6523" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">不浪费时间</strong></h1><p id="5a10" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我从这个算法中得到的最大收获是，它是解决这个问题的一个更好的方法。当我用n=8运行我的原始实现时，计算N-Rooks的所有解花了将近2秒，计算N-ques的所有解花了大约100毫秒。上述解决方案都没有打破10ms。这个故事的寓意是位运算速度很快。</p><h1 id="aa23" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">输出</strong></h1><p id="f66c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果你运行上面的代码，你会发现结果看起来很有趣。最初的实现只是用来计算解决方案的数量，而不是跟踪解决方案实际是什么。我想把它提高一个档次，并跟踪它们，所以我把它们存储在一个数组中，而不是仅仅增加一个计数器。解决方案是一个长度为n的数组，如下所示(n=4)</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1280e8211213cae54e758b15f2598b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*mGf9nNYOdGYTqZKYA-DFeA.png"/></div></figure><p id="071a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想很好地打印它，你可以使用下面的代码。解决方案中的索引按位值存储(0=&gt;1，1=&gt;2，2=&gt;4，3=&gt;8等)。2^index =价值。在我们使用它们来索引数组之前，必须对它们进行转换。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/42eeca6081b0dc84be08a27dcb9d1655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*IDLDlQjZvVE5yoKFynQACg.png"/></div></figure><p id="df7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将产生以下结果。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/98537a0b9322ca317757ad6626780aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*n8NdTMmGJrCTXkO2mNXXaQ.png"/></div></figure></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><figure class="ll lm ln lo gt lp gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi mx"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="my mz gp gr na nb"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">前65名JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">gitconnected.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np lq nb"/></div></div></a></div></div></div>    
</body>
</html>