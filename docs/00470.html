<html>
<head>
<title>Handling NodeJS CPU Intensive Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理节点的CPU密集型任务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-nodejs-c-p-u-extensive-task-aa559452eca8?source=collection_archive---------2-----------------------#2019-03-19">https://levelup.gitconnected.com/handling-nodejs-c-p-u-extensive-task-aa559452eca8?source=collection_archive---------2-----------------------#2019-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NodeJS通常被称为单线程。这是真的——但是有一个问题。</p><p id="c53e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Node有一个“<strong class="jp ir"> main </strong>”线程来处理来自脚本的所有同步代码执行，对于Node API，还有所有客户端请求。当阻塞请求进来时，它实际上将I/O任务委托给线程池中的一个工作线程。所以我们可以得出结论，节点是<strong class="jp ir">而不是</strong>完全端到端的单线程。</p><blockquote class="kl km kn"><p id="46bd" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:工作线程不是主线程。</p></blockquote><p id="2d06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，没关系。但是如果我们这样说NodeJS:</p><blockquote class="kl km kn"><p id="9a41" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">在Node.js中，除了代码之外，所有东西都是并行运行的。这意味着您在Node.js中编写的所有I/O代码都是非阻塞的，而(相反)您在Node.js中编写的所有非I/O代码都是阻塞的。</p></blockquote><p id="60c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果上面的陈述是真的(确实如此)，那么如果一个非常非常重的CPU任务作为一个客户端请求出现，会发生什么呢？你可能会认为你什么都不会，但会想你是否可以使用另一种语言。</p><p id="29e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是不，我亲爱的朋友，我们甚至可以将这个CPU密集型任务委派给一个线程。</p><p id="a32f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何做到这一点？</p><p id="7502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在这里用一个适当的例子来解释这一点</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/01768f033547061735d98dc158aebde8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txhASJgrRDraqBB6-f2HsA.png"/></div></div></figure><p id="4589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我创建了一个名为heavyTask的函数，它运行for循环5000000000000次。主线程将长时间处于忙碌状态，并且它将拒绝为任何其他客户端请求提供服务。</p><p id="81b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何将这个CPU任务委派给线程池中的一个工作线程。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi le"><img src="../Images/c1f6efc1198d06ed09694c9a94abe9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOCSZaySkGuTZgO8BwCz6g.png"/></div></div></figure><p id="65e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> workerpool </strong>提供了一种简单的方法来创建一个工人池，用于动态卸载计算以及管理一个专用工人池。它基本上实现了一个线程池模式。有一群工作人员来执行任务。新任务被放入队列中。一个工作者一次执行一个任务，一旦完成，就从队列中挑选一个新任务。</p><blockquote class="kl km kn"><p id="c708" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">在上面的例子中，有一个函数<code class="fe lf lg lh li b">heavyTask</code>，它被动态地卸载到一个worker上，为一组给定的参数执行。</p></blockquote><p id="59bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是通过将工作卸载到工作线程来处理CPU密集型任务的方式。</p><p id="3321" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Github链接参考:<a class="ae lj" href="https://github.com/yogain123/Workers-Pool" rel="noopener ugc nofollow" target="_blank">https://github.com/yogain123/Workers-Pool</a></p><p id="8452" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读</p><p id="02e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐学习:)</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><div class="kt ku kv kw gt lr"><a href="https://gitconnected.com/learn/node-js" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">学习Node.js -最佳Node.js教程(2019) | gitconnected</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">排名前45的Node.js教程-免费学习Node.js。课程由开发人员提交和投票，使您能够…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">gitconnected.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf lc lr"/></div></div></a></div></div></div>    
</body>
</html>