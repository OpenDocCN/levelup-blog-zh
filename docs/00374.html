<html>
<head>
<title>JavaScript: The Weird Parts (Part I: Data Types, Type Coercion, PBR)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:奇怪的部分(第一部分:数据类型、类型强制、PBR)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-the-weird-parts-part-i-data-types-type-coercion-pbr-3ecc751ad62?source=collection_archive---------4-----------------------#2019-01-28">https://levelup.gitconnected.com/javascript-the-weird-parts-part-i-data-types-type-coercion-pbr-3ecc751ad62?source=collection_archive---------4-----------------------#2019-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="81b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在今天的博客中，我们将讨论JavaScript与Ruby有何不同，它的用途是什么，并通过介绍该语言最基本但也是最重要的方面之一:数据类型，轻松了解JavaScript的怪异之处。我们将涵盖关于数据类型的一切，从类型强制到真值和假值，从原始数据类型到复杂数据类型，从传递我的值到传递我的引用。让我们开始吧！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0ba5cd0c2c42f3cad996734fd99e94fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZN5EaJJug-d_rRFm"/></div></div></figure><p id="07a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在熨斗学校，从Ruby到JavaScript的过渡是这个项目中最残酷的部分之一。在为期三周的JavaScript模块培训中，我们的学生:</p><ol class=""><li id="8fef" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">从能够用Ruby on Rails构建全功能的web应用程序到突然不得不重新学习JavaScript的基础知识</li><li id="e49e" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">几乎立即投入到操纵DOM，这是一个完全不同的宇宙</li><li id="0e1a" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">学习如何使用fetch api在JavaScript中获取JSON数据，这会给JavaScript语言带来一些令人讨厌的惊喜，比如它的异步特性</li><li id="054e" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">为了处理上述问题，我必须迅速对JavaScript的奇怪部分有一个深刻的理解，许多经验丰富的开发人员仍然没有完全理解这些部分(比如承诺、范围、闭包和this关键字)</li><li id="d64a" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">必须学习两种不同语法的JavaScript(旧的ES5和新的ES6)</li><li id="6def" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">在仅仅两个星期后，接受一个代码挑战，在上面的所有测试中测试它们</li><li id="550d" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">使用纯JavaScript和DOM操作，仅用两周时间就构建了一个项目</li></ol><p id="7283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来绝对不可能。在去熨斗学校之前，我从来不会相信有人能熬过这种只有三周的紧张的过山车。但是，我在这里让你知道，你<em class="ll">可以</em>做到。我看到学生们在JavaScript模块中不仅生存下来，而且<em class="ll">茁壮成长</em>。只有当你被推到极限时，你才知道你能真正完成多少，深度学习才真正发生，你才开始真正茁壮成长。</p><p id="3cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript是一头野兽，这是不可否认的。JavaScript只用了10天就完成了，没有人预见到对它的需求会有多大，所以现在开发人员被迫在它的基础上进行开发。这里或那里有一些奇怪的部分是很自然的(比如typeof null = 'object '，类似数组的对象，以及不可预测的类型强制)。在我看来，Javascript只是有点被误解，一旦你驯服了这头美丽的野兽，你就离不开它了。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lm"><img src="../Images/2e89c88cabeedaa2b07df2dd53381a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A3TPcm91VJei_uva"/></div></div></figure><p id="4df0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事不宜迟，让我们进入JavaScript的一些奇怪但重要的部分，其中大部分我已经在过去的“JS简介”讲座中介绍过，以便尽可能平稳地过渡。</p><h1 id="4bd4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">JavaScript和浏览器</h1><p id="a457" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">JavaScript如此强大的原因之一是它实际上是在浏览器中运行的。当我们构建Rails应用程序时，我们的代码实际上是在接触浏览器之前编译的——我们知道这一点，因为当我们打开chrome控制台时，我们看不到任何ERB，即使我们在ERB编写视图。相反，我们看到HTML是因为所有的东西在接触浏览器之前都被预编译成HTML。</p><p id="e66f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript不再是这种情况了！当您访问任何web应用程序并在chrome控制台中打开“网络”选项卡时，您将实际看到JavaScript资源正被加载到浏览器中，以使该web应用程序与图像、css等资源一起工作。花点时间在任何web应用程序上尝试一下吧！在你的网络标签中任何标有“脚本”类型的东西实际上都是JavaScript！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/a91296d70453dfbdd08706bcafef8c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pta0SEjLo9TtvOHnjII6DA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Netflix.com上chrome控制台的网络标签显示了加载的JavaScript</figcaption></figure><p id="d6bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在浏览器中运行JavaScript的事实实际上非常强大！这意味着我们可以通过将JavaScript文件连接到HTML来编写程序中的交互行为。这也意味着我们可以做一些很酷的事情，比如“黑”任何网站:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">这里我在chrome控制台中添加了一个document . body . content editable = true语句，现在我可以编辑网飞的主页了！</figcaption></figure><h1 id="70b3" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak"> JS数据类型</strong></h1><p id="d8c5" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">JavaScript有七种不同的数据类型，其中一些是原始数据类型，其他的被认为是复杂数据类型。除了符号，我们将每天使用所有的数据类型。七种数据类型如下:</p><ol class=""><li id="7b2a" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">线</li><li id="60d2" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">数字</li><li id="6e29" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">布尔代数学体系的</li><li id="9aeb" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">空</li><li id="97fc" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">不明确的</li><li id="7ba5" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">标志</li><li id="c64f" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">目标</li></ol><h1 id="e0b1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">原始数据类型</strong></h1><p id="e155" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">在JavaScript中，我们可以使用<code class="fe mx my mz na b">typeof</code>来检查一段数据的类型(有一些例外)。上面定义的所有数据类型都被认为是原始的，除了对象(被认为是复杂的)。原始数据类型<em class="ll">不能</em>变异。这意味着一旦一个变量被赋予一个原始数据，它就不能被变异，只能被重新分配。除了字符串之外，我们不会注意到Ruby和JavaScript之间有太大的区别。</p><h2 id="6ea8" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">用线串</h2><p id="687a" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">在JavaScript中，字符串是不可变的，但在Ruby中肯定不是这样！让我们看一个例子:</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="5bee" class="nb lo iq na b gy nr ns l nt nu">#Ruby<br/>test_string = "ruby"<br/>test_string[0] = "x"<br/>#test_string -&gt; "xuby"</span><span id="638a" class="nb lo iq na b gy nv ns l nt nu">//JavaScript<br/>let testString = "javascript"<br/>testString[0] = "x"<br/>testString -&gt; "javascript"</span></pre><p id="c440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Ruby和JavaScript中，我们通过提供索引来读取字符串中的字符。然而，正如你在上面的例子中看到的，Ruby也给了我们写访问权——它允许我们通过提供索引和重新分配它来覆盖字符串中的字符。JavaScript不允许这样做，因为字符串被认为是不可变的。</p><p id="bf5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，在JavaScript中实际上有三种不同的方法来声明字符串:使用双引号、单引号和反勾号。虽然双引号和单引号可以互换，但是使用反勾号可以进行字符串插值。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="9460" class="nb lo iq na b gy nr ns l nt nu">const string1 = "Hello"<br/>const string2 = 'World'<br/>const string3 = `JavaScript is cool!`</span><span id="135e" class="nb lo iq na b gy nv ns l nt nu">const stringConcatenation = string1 + " " + string2<br/>//-&gt; "Hello World"</span><span id="b565" class="nb lo iq na b gy nv ns l nt nu">const stringInterpolation = `${string1} ${string2}`<br/>//-&gt; "Hello World"</span></pre><p id="0925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们用三种不同的方式声明了三个字符串。stringConcatenation示例显示如何使用串联生成“Hello World ”, string interpolation示例显示如何使用反勾号和字符串插值生成“Hello World”。</p><h2 id="1757" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">数字</h2><p id="bc31" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">JavaScript中的数字相当简单。与Ruby不同，JavaScript没有将数字分成FixNum、BigNum、Float等类别。事实上，<code class="fe mx my mz na b">'number'</code>是各种数字的伞式数据类型，包括<code class="fe mx my mz na b">Infinity</code>。甚至代表“不是一个数”的值<code class="fe mx my mz na b">NaN</code>也是被赋予类型<code class="fe mx my mz na b">'number'</code>，这个值可以通过怪异的数学运算产生，比如除以零。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="26f3" class="nb lo iq na b gy nr ns l nt nu">typeof 5 -&gt; 'number'<br/>typeof 5.567 -&gt; 'number'<br/>typeof Infinity -&gt; 'number'<br/>typeof NaN -&gt; 'number'</span></pre><p id="d1e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我在野外遇到的最喜欢的一段JavaScript:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nw"><img src="../Images/3d3b364f766b4b8be6173ec52d52e01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1y0G6AAG9b9oqmqgl51B-w.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">L号列车默特尔-怀科夫站-下一趟开往曼哈顿的列车将在10分钟内到达！努夫说。</figcaption></figure><h1 id="60a4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">类型强制</h1><p id="29ee" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">既然我们已经知道了JavaScript中几种不同的数据类型，那么注意到类型强制会发生是很重要的。信不信由你，JavaScript是一种友好的语言。在JavaScript中，当用户试图强制两种不同的数据类型进行交互时，JavaScript会对用户的意图做出假设，并将其中一种数据类型强制转换为另一种。这是需要注意并尽量避免的事情，因为有时会出现意想不到的结果。让我们看一些类型强制的例子:</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="054d" class="nb lo iq na b gy nr ns l nt nu">1 + "hello world"<br/>//-&gt; "1hello world"</span><span id="0bba" class="nb lo iq na b gy nv ns l nt nu">"hello world" + 1<br/>//-&gt; "hello world1"</span><span id="0ff6" class="nb lo iq na b gy nv ns l nt nu">1 + true<br/>//-&gt; 2</span><span id="8741" class="nb lo iq na b gy nv ns l nt nu">"hello" + true<br/>//-&gt; "hellotrue</span></pre><p id="076e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，发生的大多数类型强制是可预测的。当字符串和数字组合在一起时，数字被强制转换成字符串，字符串被连接起来。当数字加到布尔值上时，这些布尔值被强制转换成数字(<code class="fe mx my mz na b">true</code>变成1，<code class="fe mx my mz na b">false</code>变成0)。当字符串被添加到布尔值时，布尔值被强制为intro字符串。</p><h2 id="3c16" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">严格相等与宽松相等(===与==)</h2><p id="f77e" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">然而，有时类型强制的结果可能是完全出乎意料的，甚至是滑稽的，例如下面的结果。因此，尽可能避免类型强制非常重要。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="d917" class="nb lo iq na b gy nr ns l nt nu">{} + {}<br/>//-&gt; '[object Object][object Object]'</span><span id="84a6" class="nb lo iq na b gy nv ns l nt nu">[] + []<br/>//-&gt; ''</span></pre><p id="3d71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">避免类型强制的一种方法是在JavaScript中进行比较时使用严格相等(===)。在JavaScript中，检查相等性实际上有两种不同的方法:严格相等(===)和松散相等(==)。严格相等将检查两个数据是否相同<em class="ll">和</em>是否具有相同的类型。松散相等只检查一部分数据是否可以被强制转换成另一部分。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="f0c2" class="nb lo iq na b gy nr ns l nt nu">1 == true <br/>//-&gt; true</span><span id="0478" class="nb lo iq na b gy nv ns l nt nu">1 === true<br/>//-&gt; false</span><span id="7fa8" class="nb lo iq na b gy nv ns l nt nu">1 == '1'<br/>//-&gt; true</span><span id="0dc1" class="nb lo iq na b gy nv ns l nt nu">1 ==='1'<br/>//-&gt; false</span></pre><p id="8509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，双等号只检查宽松的等式。它为<code class="fe mx my mz na b">1 == true</code>返回<code class="fe mx my mz na b">true</code>，因为1可以被类型强制转换为<code class="fe mx my mz na b">true</code>，它为<code class="fe mx my mz na b">1 == '1'</code>返回<code class="fe mx my mz na b">true</code>，因为数字1可以被强制转换为字符串<code class="fe mx my mz na b">"1"</code>。但是，对于任何数据类型不同的情况，不管类型强制与否，它都返回false。使用triple equals来检查相等性是最好的方法，对于来自Ruby的人来说，这绝对是值得注意的！</p><h2 id="acf6" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">当类型强制有用时</h2><p id="51bb" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">有一种类型强制实际上非常有用not(！)算符，又称“霹雳”。使用一个bang操作符允许我们将任何值强制转换为布尔值，并返回它的相反值；使用两个bang运算符，我们可以将它强制转换成相反的布尔值。例如，如果我们想知道0是真值还是假值，我们可以运行<code class="fe mx my mz na b">!!0</code>。如果我们想在某个数字为假时运行一些逻辑，我们可以运行<code class="fe mx my mz na b">if (!number)</code>。省略bang操作符并依赖隐式类型强制在条件中也很有用，比如仅当某个变量为真时才运行一些逻辑。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="ed87" class="nb lo iq na b gy nr ns l nt nu">let number = 0;<br/>let string = "hello"</span><span id="409a" class="nb lo iq na b gy nv ns l nt nu">!!number<br/>//-&gt; false</span><span id="8d22" class="nb lo iq na b gy nv ns l nt nu">if (!number) return `The number ${number} is falsy.`<br/>if (string) return `The string ${string} is truthy.`</span></pre><p id="c251" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写这种隐式条件在JavaScript中是常见的做法，但是它确实需要理解JavaScript中哪些值是真的哪些值是假的。让我们跳进来吧！</p><h1 id="5946" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">虚伪的价值观</h1><p id="89ed" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">JavaScript中的falsy值是可以强制为false的值。有六种虚假的价值观，其他的都是真实的。falsy值为:</p><ol class=""><li id="922a" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">错误的</li><li id="871d" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">0(零)</li><li id="8a2f" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">''或" "(空字符串)</li><li id="d5fe" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">空</li><li id="ebba" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">不明确的</li><li id="204d" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">圆盘烤饼</li></ol><p id="04cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Ruby中，只有两个falsy值(nil和false ),所以要记住的更多。当有疑问时，记住在任何值前运行<code class="fe mx my mz na b">!!</code>将帮助您确定它是真还是假。</p><h2 id="32f1" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">空且未定义</h2><p id="fd08" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">您可能想知道为什么JavaScript既有null又有undefined，这两者之间有什么区别。通常，未定义是指用户尚未定义某个值。当访问一个数组中的索引或者一个不存在的对象中的键时，你可能会得到<code class="fe mx my mz na b">undefined</code>。类似地，如果您定义了一个变量或函数，但是在尝试使用它时拼写错误，您可能会得到一个错误，比如<code class="fe mx my mz na b">variable is not defined</code>。然而，Null并不意味着一个值被忘记声明或者不存在。通常，一个人已经<em class="ll">有意</em>给<code class="fe mx my mz na b">null</code>赋值，暗示该值应该从<code class="fe mx my mz na b">null</code>开始，但可能会改变。</p><h1 id="f587" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">复杂数据类型</h1><p id="7853" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">如前所述，JavaScript中的复杂数据类型是对象。事实上，使用<code class="fe mx my mz na b">typeof</code>会显示很多值可能被归类为对象。事实上——有趣的事实——即使运行<code class="fe mx my mz na b">typeof null</code>也会导致<code class="fe mx my mz na b">'object'</code>，但是<code class="fe mx my mz na b">null</code>实际上是<em class="ll">而不是</em>一个<code class="fe mx my mz na b">'object'</code>。这实际上是一个不幸的错误，无法修复，因为它会破坏互联网！以下是一些在JavaScript中被归类为对象的东西:</p><ul class=""><li id="59b4" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk nx ld le lf bi translated">数组</li><li id="0787" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk nx ld le lf bi translated">POJOS(普通旧JavaScript对象)</li><li id="f967" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk nx ld le lf bi translated">类似数组的对象</li><li id="2819" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk nx ld le lf bi translated">承诺</li><li id="2809" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk nx ld le lf bi translated">功能</li></ul><h2 id="be13" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">数组</h2><p id="d003" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">因为数组是对象，所以需要注意的是<code class="fe mx my mz na b">typeof []</code>不会帮助我们确定一个特定的变量是否是数组。确定这一点的更好方法是尝试<code class="fe mx my mz na b">Array.isArray([])</code>。</p><h2 id="a706" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">波霍斯</h2><p id="524b" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">POJOS只是普通的旧JavaScript对象，类似于Ruby哈希。它们有逗号分隔的键值对，可以用括号符号或点符号来访问这些键。但是，请注意，我们不能对Javascript对象使用rocket语法。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="c15c" class="nb lo iq na b gy nr ns l nt nu">let pojo = {"hello": "world", "javascriptIsFun": true}</span></pre><h2 id="0fe2" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">类似数组的对象</h2><p id="ef0c" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">在JavaScript中，类似数组的对象是一个欺骗性的集合，<em class="ll">看起来</em>像<em class="ll"> </em>一个数组，并且通常会有方括号，但<em class="ll">不是</em>一个数组。偶尔，我们在操作DOM和抓取诸如<code class="fe mx my mz na b">&lt;li&gt;</code>元素之类的元素组时会遇到这样的害虫。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/0a4569a1e13b647fbccf13cb3134e13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MzCwaZhB1qkYgbth32Kz7Q.png"/></div></div></figure><p id="249f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我从这篇博文中获取了<code class="fe mx my mz na b">li</code>元素，我看到了一个看起来像数组的东西。通过<code class="fe mx my mz na b">typeof</code>测试它的类型是没有帮助的，但是当我尝试<code class="fe mx my mz na b">Array.isArray</code>时，我看到了真相——这个对象是<em class="ll">而不是</em>一个数组。类似数组的对象可能很难处理，因为它们允许对它们执行某些数组方法，但不允许对其他方法执行。<em class="ll">提示</em>:一个好的技巧是在一个类似数组的对象上尝试<code class="fe mx my mz na b">.__proto__</code>，看看有什么方法可以在上面执行。</p><p id="8963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果你遇到这样的害虫，不要害怕。只要你知道你在处理什么，把一个类似数组的对象变成一个真正的数组是相当简单的！尤其是使用ES6的新<code class="fe mx my mz na b">Array.from</code>方法，我们能够将这样一个对象强制放入一个数组。请看下面，我将这个<code class="fe mx my mz na b">domElements</code>数组转换成一个真正的数组，并用<code class="fe mx my mz na b">Array.isArray</code>测试它。现在它是一个真正的数组，我也可以在这个对象上执行所有普通的数组方法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/dccec68dd19ab7f1cfa0975762b9dd96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djeLDUaPEzwN9b7Ry-hqzg.png"/></div></div></figure><p id="18cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然承诺和功能也被归类为对象，但我们将改天再讨论这些主题！</p><h1 id="6739" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">按引用传递，按值传递</h1><p id="2520" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">既然我们已经介绍了一些复杂的数据类型，那么理解它们与原始数据类型的不同行为是很重要的。如前所述，原始数据类型不能变异。然而，复杂的数据类型是可以变异的。这意味着我们可以拼接一个数组，将新元素放入其中，删除元素，或者进行任何数量的其他破坏性操作。类似地，我们可以给一个对象分配新的键和值，或者重新分配旧的键和值。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="49b6" class="nb lo iq na b gy nr ns l nt nu">const obj = {<br/>    name: "Jane", <br/>    hobby: "Languages", <br/>    isHungry: true<br/>  }</span><span id="d2c7" class="nb lo iq na b gy nv ns l nt nu">obj.isHungry = false<br/>//-&gt; obj = {name: "Jane", hobby: "Languages", isHungry: false}</span></pre><p id="9d6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们可以使用<code class="fe mx my mz na b">const</code>关键字给一个对象或数组赋值的原因。只要我们不是真正地<em class="ll">重新分配</em>变量，而仅仅是<em class="ll">改变</em>变量，使用<code class="fe mx my mz na b">const</code>对对象和数组来说是完全没问题的！</p><p id="5b03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，对于对象和数组来说，有一件事非常棘手。让我们观察下面的代码片段，在这里我将一个对象实例化为<code class="fe mx my mz na b">obj1</code>，然后创建了一个变量<code class="fe mx my mz na b">obj2</code>，并将这个相同的对象保存在那里。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="ada9" class="nb lo iq na b gy nr ns l nt nu">let obj1 = {name: "Jane", hobby: "Languages"}<br/>let obj2 = obj1<br/>obj1.name = "JaneyWaney"</span></pre><p id="5c03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我改变<code class="fe mx my mz na b">obj1</code>的一个属性时会发生什么？大多数人正确地认为<code class="fe mx my mz na b">obj1</code>会改变。但是<code class="fe mx my mz na b">obj2</code>会怎么样呢？大多数人认为<code class="fe mx my mz na b">obj2</code>会保持不变。然而，这是错误的。让我们观察一下<code class="fe mx my mz na b">obj1</code>和<code class="fe mx my mz na b">obj2</code>会发生什么。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="3f18" class="nb lo iq na b gy nr ns l nt nu">//obj1 -&gt; {name: "JaneyWaney", hobby: "Languages"}<br/>//obj2 -&gt; {name: "JaneyWaney", hobby: "Languages"}</span></pre><p id="7c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原来<em class="ll"/><code class="fe mx my mz na b">obj1</code>和<code class="fe mx my mz na b">obj2</code>都变了。这是因为当我们设置<code class="fe mx my mz na b">obj2 = obj1</code>时，我们实际上是保存一个<em class="ll">引用</em>到<code class="fe mx my mz na b">obj1</code>，而不是制作一个新的不相关的副本！因此，当我们对<code class="fe mx my mz na b">obj1</code>进行更改时，<code class="fe mx my mz na b">obj2</code>也会受到影响。与原始数据类型不同，JavaScript不会将对象的实际值保存到变量中。相反，JavaScript将<em class="ll">引用</em>保存到对象，或者它在内存中的位置。这称为按引用传递(与按值传递相对)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oa mw l"/></div></figure><p id="6b25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript中的复杂数据类型是通过引用传递的，而基本数据类型是通过值传递的。这意味着数组也是通过引用传递的！</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="73c1" class="nb lo iq na b gy nr ns l nt nu">let array1 = [1,2,3,4,5]<br/>let array2 = array<br/>array.push(6)</span><span id="45ed" class="nb lo iq na b gy nv ns l nt nu">//array1 -&gt; [1,2,3,4,5,6]<br/>//array2 -&gt; [1,2,3,4,5,6]</span></pre><p id="cecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码片段中，当我们试图将某些东西推入<code class="fe mx my mz na b">array1</code>时，我们也在对<code class="fe mx my mz na b">array2</code>进行变异，因为<code class="fe mx my mz na b">array2</code>实际上持有对<code class="fe mx my mz na b">array1</code>本身的引用，而不是副本。</p><h2 id="de32" class="nb lo iq bd lp nc nd dn lt ne nf dp lx jy ng nh mb kc ni nj mf kg nk nl mj nm bi translated">复制数组和对象</h2><p id="6f5e" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">但是我们如何解决这个问题呢？如果我们真的想保存一个副本而不是一个对象的引用呢？有几种不同的方法可以做到这一点:</p><ol class=""><li id="4afc" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">对于数组，我们可以使用<code class="fe mx my mz na b">.slice()</code>来复制数组。当没有给定参数时，<code class="fe mx my mz na b">.slice()</code>方法将复制一个数组，当给定参数时，将根据传入的索引复制该数组的特定部分。</li><li id="c21a" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">对于对象，我们可以使用<code class="fe mx my mz na b">Object.assign</code>来复制一个对象。<code class="fe mx my mz na b">Object.assign</code>方法需要几个参数。第一个参数是我们要将另一个对象复制到其中的对象。通常，我们传递一个空的对象(<code class="fe mx my mz na b">{}</code>)作为空白的石板。第二个参数代表我们试图复制的对象。以下任何参数都是可选的，它们是我们试图在该对象中写入或覆盖的附加属性。</li></ol><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="c689" class="nb lo iq na b gy nr ns l nt nu">let jane = {name: "Jane", cat: "Poseidon", dog: "Atlas"}<br/>let janeCopy = Object.assign({}, jane)<br/>//jane === janeCopy -&gt; false</span></pre><p id="150c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们使用<code class="fe mx my mz na b">Object.assign</code>成功地复制了<code class="fe mx my mz na b">jane</code>对象，并可以通过运行<code class="fe mx my mz na b">jane === janeCopy</code>来测试它。当存在真实副本时，对象彼此不相等并返回false。然而，当对象指向同一个引用时，<code class="fe mx my mz na b">===</code>返回true。</p><p id="9e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.我最喜欢的复制方式是使用ES6扩展运算符(…)。这种方式超级简单方便，而且对数组和对象都有效！spread操作符允许我们将数组和对象中的所有值展开，就好像它们不再包含在括号中一样。然后，我们将这些元素放回括号中，将它们聚集回一个全新的数组或对象中。</p><pre class="km kn ko kp gt nn na no np aw nq bi"><span id="e680" class="nb lo iq na b gy nr ns l nt nu">let array1 = ["hello", "world"]<br/>let copy = [...array1]</span><span id="1b39" class="nb lo iq na b gy nv ns l nt nu">let obj = {name: "Jane", cat: "Poseidon", dog: "Atlas"}<br/>let objCopy = {...obj}</span></pre></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="0984" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道了通过引用传递和通过值传递，让我们总是小心我们的数组和对象！如果我们想将一个数组或对象保存到另一个变量中，我们需要创建一个新的副本，这样我们就不会改变原来的数组或对象。让我们记住我们今天讨论的所有数据类型，真值和假值，以及如何避免不必要的类型强制。在下一部分中，我们将介绍诸如提升、函数表达式与声明、范围等概念！敬请期待！</p><blockquote class="oi oj ok"><p id="a979" class="jn jo ll jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">你应该把变量想象成触手，而不是盒子。它们不包含值；他们掌握它们——两个变量可以指同一个值。</p><p id="b6f5" class="jn jo ll jp b jq jr js jt ju jv jw jx ol jz ka kb om kd ke kf on kh ki kj kk ij bi translated">— Marijn Haverbeke，<a class="ae oo" href="https://www.goodreads.com/work/quotes/13787033" rel="noopener ugc nofollow" target="_blank">雄辩的JavaScript:编程的现代介绍</a></p></blockquote></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi op"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="oq or gp gr os ot"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">前65名JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">gitconnected.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kv ot"/></div></div></a></div></div></div>    
</body>
</html>