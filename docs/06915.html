<html>
<head>
<title>Deploying .NET Core application on local Kubernetes cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正在部署。NET Core在本地Kubernetes集群上的应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-net-core-application-on-local-kubernetes-cluster-d4a0473d1543?source=collection_archive---------2-----------------------#2021-01-12">https://levelup.gitconnected.com/deploying-net-core-application-on-local-kubernetes-cluster-d4a0473d1543?source=collection_archive---------2-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b904" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从Docker -&gt; Docker撰写-&gt; Kubernetes</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c4dbffdcb3a58b2171ee5edee1c1b404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3vBkY5MJMNLjZ4xNykAHw.png"/></div></div></figure><p id="630a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">ubernetes，也缩写为K8s，是一个用于自动化部署、扩展和管理容器化应用程序的开源系统。在当今的容器化微服务应用世界中，K8s有助于更轻松地跨各种pod、节点和集群管理、部署和扩展我们的容器。Kubernetes已被组织广泛采用来管理、部署和扩展容器。</p><div class="lz ma gp gr mb mc"><a href="https://kubernetes.io/" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">生产级容器编排</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">Kubernetes，也称为K8s，是一个开源系统，用于自动部署、扩展和管理…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">kubernetes.io</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ks mc"/></div></div></a></div><p id="1eb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几个月前，我正在开发一个dotnet核心应用程序，它带有几个带有Swagger集成的API端点。使用API，我们可以注册一个用户，然后登录获得JWT。我们还可以获得注册用户的列表。该项目使用实体框架核心作为数据库层，使用<a class="ae mr" href="https://www.nuget.org/packages/Npgsql.EntityFrameworkCore.PostgreSQL" rel="noopener ugc nofollow" target="_blank"> Npgsql。EntityFrameworkCore . PostgreSQL</a>作为数据库提供者。该项目的完整代码可在我的GitHub账户上获得。</p><div class="lz ma gp gr mb mc"><a href="https://github.com/Chandankkrr/identity-core" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">chandankkrr/身份-核心</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">dot net core identity-core Permalink无法加载最新提交信息。点网核心身份-核心你不能…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">github.com</p></div></div><div class="ml l"><div class="ms l mn mo mp ml mq ks mc"/></div></div></a></div><h1 id="1721" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">TLDR；🤷‍♂️</h1><blockquote class="nl nm nn"><p id="2908" class="ku kv no kw b kx ky ju kz la lb jx lc np le lf lg nq li lj lk nr lm ln lo lp im bi translated">将带有Postgres数据库的dotnet核心应用程序部署到本地K8s集群。创建部署、服务、入口和卷。还使水平pod自动缩放器能够在负载增加和减少时分别查看正在创建和删除的pod。</p></blockquote></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="8d16" class="mt mu it bd mv mw nz my mz na oa nc nd jz ob ka nf kc oc kd nh kf od kg nj nk bi translated">为什么部署到本地K8s集群？🤔</h1><ul class=""><li id="6512" class="oe of it kw b kx og la oh ld oi lh oj ll ok lp ol om on oo bi translated">体验可用的K8s功能</li><li id="c53b" class="oe of it kw b kx op la oq ld or lh os ll ot lp ol om on oo bi translated">运行K8s实验</li><li id="efea" class="oe of it kw b kx op la oq ld or lh os ll ot lp ol om on oo bi translated">在将K8s配置部署到云☁之前测试它们</li><li id="75f6" class="oe of it kw b kx op la oq ld or lh os ll ot lp ol om on oo bi translated">它是免费的</li><li id="9465" class="oe of it kw b kx op la oq ld or lh os ll ot lp ol om on oo bi translated">如果你搞砸了也没关系</li></ul></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="d384" class="mt mu it bd mv mw nz my mz na oa nc nd jz ob ka nf kc oc kd nh kf od kg nj nk bi translated">我们开始吧</h1><p id="f1de" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">下面是在端口<code class="fe ox oy oz pa b">5001.</code>上本地运行的<a class="ae mr" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Swagger UI </strong> </a>该项目包含两个端点，<code class="fe ox oy oz pa b">/account</code>用于注册用户，<code class="fe ox oy oz pa b">/login</code>用于认证用户并获得一个JSON Web令牌(JWT)。用户详细信息保存在Postgres数据库中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/93a4d70221f8c5d3ca270f8cf4dce2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0Q6K_geF2DJk1JebTTw9g.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">运行应用程序的Swagger UI</figcaption></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="07c8" class="mt mu it bd mv mw nz my mz na oa nc nd jz ob ka nf kc oc kd nh kf od kg nj nk bi translated">Dockerfile文件</h1><p id="87a1" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">让我们快速浏览一下文档。它正在提取dotnet 5 SDK和运行时，使用SDK来恢复项目和运行时，以将应用程序及其依赖项发布到一个文件夹，以便部署到托管系统。最后，我们通过指定<code class="fe ox oy oz pa b">Identity.dll</code>作为入口点来启动应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="7fef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从Dockerfile文件构建一个映像，最后使用以下命令将该映像作为容器运行</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="33db" class="pm mu it pa b gy pn po l pp pq">// build an image using Dockerfile<br/>docker build -t identity-core-api .</span><span id="94e0" class="pm mu it pa b gy pr po l pp pq">// run the image as a container<br/>docker run -p 80:80 identity-core-api:latest</span></pre><p id="d878" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行docker运行命令我们得到<code class="fe ox oy oz pa b">Application startup exception.</code>🤦</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/d11633850245eeea121cc13df86ed0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mp5HiG34WsomoZQ_yjO9tg.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">应用程序启动异常</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/dac83975a62ccd0d4a256869a16a6213.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*dlMqySvqGoSEQgtCUGfWsw.jpeg"/></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">urlme.me</figcaption></figure><p id="ab24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为应用程序试图连接到本地主机端口<code class="fe ox oy oz pa b">5432.</code>上的Postgres DB。连接字符串存储在<code class="fe ox oy oz pa b">appSettings.json.</code>中</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="ef35" class="pm mu it pa b gy pn po l pp pq">"ConnectionStrings": {<br/>  "IdentityCoreDBConnection":"Host=localhost;Port=5432;<br/>     Database=identitycore;Username=postgres;Password=postgres"<br/>},</span></pre><p id="6235" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们构建一个运行Postgres docker映像的容器。</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="7992" class="pm mu it pa b gy pn po l pp pq">docker run --env POSTGRES_USER=postgres --env POSTGRES_PASSWORD=postgres -p 5432:5432 postgres:latest</span></pre><p id="8bc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这次我将使用<code class="fe ox oy oz pa b">dotnet run</code>命令直接运行应用程序，而不使用docker。这是为了避免此时必须创建网络。我们将处理这个问题，并在docker容器上运行应用程序和数据库。我们可以成功启动应用程序并访问swagger端点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pu"><img src="../Images/1d86988129cd52e362ffb6ceb607abb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZK1-8WQxpvfS0g0uu7Xwg.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">注册用户并获取所有注册用户</figcaption></figure><p id="3bd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们注册几个用户，然后通过调用<code class="fe ox oy oz pa b">/account/getAllUsers</code>端点检索所有注册的用户。</p><div class="kj kk kl km gt ab cb"><figure class="pv kn pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/f0907b3724af491068fccaababe1fa5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*SBupEqHzLRkVxrT9yiPzIw.png"/></div></figure><figure class="pv kn qb px py pz qa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/981a8d756ebb627b8d1d66dfe090e605.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*ipFgxjxbL63YdK1Iqym2ow.png"/></div></figure><figure class="pv kn qc px py pz qa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/6c3281a816c65d626a50aabd88ee4666.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*HDgrXw3rhVFJP2IXXf7PBw.png"/></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk qd di qe qf translated">注册、登录和<code class="fe ox oy oz pa b">getAllUsers</code> API响应的Swagger UI</figcaption></figure></div><p id="b363" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，这种方法很有效，但是有一个问题。在我们停止Postgres容器后，我们将丢失所有的用户注册数据。这是因为Docker容器的设计是短暂的。</p><blockquote class="nl nm nn"><p id="16d6" class="ku kv no kw b kx ky ju kz la lb jx lc np le lf lg nq li lj lk nr lm ln lo lp im bi translated">所谓“短暂的”，我们的意思是容器可以被停止和销毁，新的容器可以从相同的Docker映像构建，并以绝对最小的设置和配置放在适当的位置。</p></blockquote><div class="lz ma gp gr mb mc"><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#create-ephemeral-containers" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">编写docker文件的最佳实践</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">本文档涵盖了构建高效映像的推荐最佳实践和方法。Docker构建图像…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">docs.docker.com</p></div></div><div class="ml l"><div class="qg l mn mo mp ml mq ks mc"/></div></div></a></div><p id="fb02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以利用体积来解决这个问题。卷是保存Docker容器生成和使用的数据的首选机制。卷存储在主机上，与容器生命周期无关。这允许用户轻松地备份数据和在容器之间共享文件系统。我将再次运行Postgres映像，为卷指定<code class="fe ox oy oz pa b">-v</code>标志。</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="dc50" class="pm mu it pa b gy pn po l pp pq">docker run --env POSTGRES_USER=postgres --env POSTGRES_PASSWORD=postgres -p 5432:5432 -v identitycore:/var/lib/postgresql/data postgres:latest postgres:latest</span></pre><p id="acaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，每次我们启动API和Postgres容器时，我们以前注册的用户数据仍然可用。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="2093" class="mt mu it bd mv mw nz my mz na oa nc nd jz ob ka nf kc oc kd nh kf od kg nj nk bi translated">码头工人🐳构成</h1><p id="82cd" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">到目前为止，我们已经使用<code class="fe ox oy oz pa b">dotnet run</code>命令运行了我们的应用程序，并连接到本地运行的<code class="fe ox oy oz pa b">postgres</code> docker容器。到目前为止，这是可以的，但是我们必须每次使用单独的命令手动启动API和Postgres DB容器，并且必须确保DB容器在应用程序之前启动。我们可以解决这个问题，并使用<code class="fe ox oy oz pa b">docker-compose.</code>启动应用程序运行所需的所有容器</p><blockquote class="nl nm nn"><p id="e43b" class="ku kv no kw b kx ky ju kz la lb jx lc np le lf lg nq li lj lk nr lm ln lo lp im bi translated">Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。通过Compose，我们可以使用YAML文件来配置应用程序的服务。然后，只需一个命令，我们就可以从您的配置中创建和启动所有服务</p></blockquote><div class="lz ma gp gr mb mc"><a href="https://docs.docker.com/compose/" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">Docker编写概述</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">寻找撰写文件参考？在此处找到最新版本。Compose是一个定义和运行…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">docs.docker.com</p></div></div><div class="ml l"><div class="qh l mn mo mp ml mq ks mc"/></div></div></a></div><p id="cbf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们的<code class="fe ox oy oz pa b">identity-core</code>应用程序的<code class="fe ox oy oz pa b">docker-compose.yml</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="8f4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们稍微分解一下docker-compose文件。我们有<code class="fe ox oy oz pa b">networks,</code>T3和<code class="fe ox oy oz pa b">volumes.</code></p><h2 id="66d8" class="pm mu it bd mv qi qj dn mz qk ql dp nd ld qm qn nf lh qo qp nh ll qq qr nj qs bi translated">网络🌐</h2><p id="a452" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">默认情况下，Compose为应用程序设置一个网络。服务的每个容器都加入默认网络，并且可以被该网络上的其他容器访问。在我们的docker-compose文件中，我们正在创建一个名为<code class="fe ox oy oz pa b">identity-network.</code>的定制网络</p><h2 id="dad7" class="pm mu it bd mv qi qj dn mz qk ql dp nd ld qm qn nf lh qo qp nh ll qq qr nj qs bi translated">服务📡</h2><p id="2b2c" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">我们定义了两个服务，<code class="fe ox oy oz pa b">identity-core-api</code>和<code class="fe ox oy oz pa b">identity-core-db.</code>。<code class="fe ox oy oz pa b">identity-core-api</code>服务使用从<code class="fe ox oy oz pa b">Identity</code>目录中定义的<code class="fe ox oy oz pa b">Dockerfile</code>构建的映像。它使用先前定义的<code class="fe ox oy oz pa b">identity-network</code>。已经指定了一个端口映射，将容器和主机绑定到暴露的端口<code class="fe ox oy oz pa b">80</code>。<code class="fe ox oy oz pa b">depends_on</code>选项有助于控制服务启动的顺序。这确保了<code class="fe ox oy oz pa b">identity-core-db</code>服务在<code class="fe ox oy oz pa b">identity-core-api</code>启动之前启动并运行。</p><p id="6dd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ox oy oz pa b">identity-core-db</code>服务使用从Docker Hub注册中心提取的公共<a class="ae mr" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank"> Postgres </a>映像，该注册中心为代码构建映像并启动定义的服务。这个服务也使用<code class="fe ox oy oz pa b">identity-network</code>，并且在主机和容器之间定义了一个端口映射<code class="fe ox oy oz pa b">5432</code>。已经指定了使用Postgres映像所需的环境变量。<code class="fe ox oy oz pa b">POSTGRES_DB</code>环境变量用于为镜像首次启动时创建的默认数据库定义一个自定义名称。</p><h2 id="afc9" class="pm mu it bd mv qi qj dn mz qk ql dp nd ld qm qn nf lh qo qp nh ll qq qr nj qs bi translated">卷💽</h2><p id="76af" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">卷提供了将容器的特定文件系统路径连接回主机的能力。如果装载了容器中的目录，主机上也会看到该目录中的更改。如果您在容器重启时挂载相同的目录，您会看到相同的文件。我创建了一个命名卷<code class="fe ox oy oz pa b">identity-postgres-data.</code> Docker维护磁盘上的物理位置，我们只需要记住卷的名称。每次我们使用该卷时，Docker都会确保提供正确的数据。通过提供带有<code class="fe ox oy oz pa b">/var/lib/postgres/data</code>的<code class="fe ox oy oz pa b">-v</code>标志作为挂载路径来运行Postgres映像，我们每次启动一个新容器时，实际上都在使用同一个数据库。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qt"><img src="../Images/aa0822cc8c9cee24007701b7a05de107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8-95E9q7A1tT5hjCREpNg.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">使用卷运行docker Postgres映像</figcaption></figure><p id="cdc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们使用<code class="fe ox oy oz pa b">docker-compose build</code>命令构建docker-compose文件，并使用<code class="fe ox oy oz pa b">docker-compose up.</code>运行我们的应用程序。这将把Postgres映像作为一个容器运行，并为我们启动API。</p><div class="kj kk kl km gt ab cb"><figure class="pv kn qu px py pz qa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/d45153113b7042dccb82c2bc4b251a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*vLZVrkLkXH80POHpkTkRNA.png"/></div></figure><figure class="pv kn qv px py pz qa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a656fecf8baed1ea12d13527601b11ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*DSd6w1wc8GmDZqzoCEnwxQ.png"/></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk qw di qx qf translated">docker-撰写构建和运行</figcaption></figure></div></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="2474" class="mt mu it bd mv mw nz my mz na oa nc nd jz ob ka nf kc oc kd nh kf od kg nj nk bi translated">库伯内特☸</h1><p id="a598" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">我们已经通过<code class="fe ox oy oz pa b">dock-compose.</code>成功运行了我们的应用程序，现在让我们尝试将它部署到本地K8s集群。Docker桌面包括独立的K8s服务器和客户端，以及Docker CLI集成。K8s服务器在Docker实例中本地运行，是一个单节点集群。K8s服务器在本地系统上的Docker容器中运行，并且仅用于本地测试。我们可以通过Docker桌面设置启用Kubernetes。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qy"><img src="../Images/948e9c3b7cb499ee4dc0e8a028374fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMNWGygnGFXX2PHsRqRcZw.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">Docker桌面设置</figcaption></figure><p id="fa67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是YAML文件，它将用于为我们的<code class="fe ox oy oz pa b">Identity Core API</code>和<code class="fe ox oy oz pa b">Postgres DB</code>创建K8s资源。我们已经定义了<code class="fe ox oy oz pa b">Deployment,</code> <code class="fe ox oy oz pa b">Service</code>和<code class="fe ox oy oz pa b">Ingress</code>，它们定义了我们想要创建什么样的资源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pg ph l"/></div></figure><p id="15a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我们的<code class="fe ox oy oz pa b">identity-core-api</code>和<code class="fe ox oy oz pa b">identity-core-posgres</code>部署，我们已经声明我们需要pod的一个副本，以便在任何给定的时间始终运行。如果由于任何原因，pod出现故障，<code class="fe ox oy oz pa b">ReplicaSet</code>将创建一个新的pod来替换故障的pod。通过<code class="fe ox oy oz pa b">spec</code>属性，我们声明了容器的名称和构建容器的图像。此外，指定要公开的端口和资源限制。</p><p id="6ecc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似于我们的<code class="fe ox oy oz pa b">docker-compose.yml</code>文件，我们将环境变量传递给Postgres映像，并通过<code class="fe ox oy oz pa b">PersistentVolume</code>和<code class="fe ox oy oz pa b">PersistenVolumeClaim.</code>设置<code class="fe ox oy oz pa b">volumeMounts</code></p><div class="lz ma gp gr mb mc"><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">将Pod配置为使用持久卷进行存储</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">本页说明如何配置Pod以使用PersistentVolumeClaim进行存储。以下是对…的总结</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">kubernetes.io</p></div></div><div class="ml l"><div class="qz l mn mo mp ml mq ks mc"/></div></div></a></div><p id="947e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为API和DB都指定了<code class="fe ox oy oz pa b">Service</code>,并且为API添加了一个<code class="fe ox oy oz pa b">Ingress</code>,以便能够与集群中的服务进行通信。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="9ab3" class="mt mu it bd mv mw nz my mz na oa nc nd jz ob ka nf kc oc kd nh kf od kg nj nk bi translated">库贝特尔</h1><p id="a798" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">准备好文件后，让我们使用<code class="fe ox oy oz pa b">kubectl</code>来创建我们想要的资源。kubectl命令行工具让我们可以控制Kubernetes集群。我将首先在<code class="fe ox oy oz pa b">postgres.yaml</code>文件中创建资源，以确保DB准备好接受连接，并且Identity Core API应用程序可以成功连接到它。</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="5eff" class="pm mu it pa b gy pn po l pp pq">kubectl apply -f k8s/postgres.yaml</span><span id="c16c" class="pm mu it pa b gy pr po l pp pq">kubectl apply -f k8s/api.yaml</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ra"><img src="../Images/8da0d68fe4924f0921b077575e53c0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*titSE8qC1bVKTeiSLAIYMg.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">kubectl应用<code class="fe ox oy oz pa b">postgres.yaml </code> &amp; <code class="fe ox oy oz pa b">api.yaml</code>文件的输出</figcaption></figure><p id="f55d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用以下后续命令检查资源是否已创建</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="670f" class="pm mu it pa b gy pn po l pp pq">kubectl get deployment</span><span id="60b5" class="pm mu it pa b gy pr po l pp pq">kubectl get pods</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rb"><img src="../Images/062dc885c87e776a57b3a83e32e449b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chihsJ6l54sCHHb3hrxGDg.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">kubectl get部署和pods的输出</figcaption></figure><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="63cf" class="pm mu it pa b gy pn po l pp pq">kubectl get service</span><span id="ab17" class="pm mu it pa b gy pr po l pp pq">kubectl get ingress</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rc"><img src="../Images/74ab18aafacddee8bca5a26e7f8da53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fucRH84earFKVggaCUfLQw.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">kubectl get服务和入口的输出</figcaption></figure><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="6a93" class="pm mu it pa b gy pn po l pp pq">kubectl get pv</span><span id="5f6f" class="pm mu it pa b gy pr po l pp pq">kubectl get pvc</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rd"><img src="../Images/74e1e40073b80fed11f48cad54465e7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vd7BqqFn2RzRHjQcv3vVdg.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">kubectl get的输出<code class="fe ox oy oz pa b">pv</code> &amp; <code class="fe ox oy oz pa b">pvc</code></figcaption></figure><p id="083f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以通过Docker桌面仪表板看到我们的容器在运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi re"><img src="../Images/c78b30e854f436a32fef8bf2252e5edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvgtxJAAlETUtc255TJbmQ.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">docker桌面运行容器</figcaption></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="744d" class="mt mu it bd mv mw nz my mz na oa nc nd jz ob ka nf kc oc kd nh kf od kg nj nk bi translated">横向扩展⬆️ Scale-in⬇️</h1><p id="66b5" class="pw-post-body-paragraph ku kv it kw b kx og ju kz la oh jx lc ld ou lf lg lh ov lj lk ll ow ln lo lp im bi translated">我们可以使用水平机架自动缩放器(HPA)横向扩展我们的<code class="fe ox oy oz pa b">identity-core-api</code>机架。水平单元自动缩放器根据CPU利用率自动缩放单元的数量。</p><p id="311c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要创建HPA，我们首先需要启用K8s指标服务器。HPA根据从资源指标API检索的pod资源指标来扩展pod。度量API由度量服务器提供。我们可以使用以下命令部署度量服务器。</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="f20b" class="pm mu it pa b gy pn po l pp pq">kubectl apply -f <a class="ae mr" href="https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.4.1/components.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.4.1/components.yaml</a></span></pre><p id="1a12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了让它在本地工作，我们还需要将<code class="fe ox oy oz pa b">--kubelet-insecure-tls</code>添加到容器规范的<code class="fe ox oy oz pa b">args</code>中。最后，让我们为<code class="fe ox oy oz pa b">identity-core-api</code>部署创建一个HPA资源。</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="9f4a" class="pm mu it pa b gy pn po l pp pq">kubectl autoscale deployment identity-core-api <br/>--cpu-percent=10 --min=1 --max=10</span></pre><p id="df74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的命令创建了一个自动缩放器，目标是部署10%的CPU利用率，最少1个单元，最多10个单元。当平均CPU负载为<code class="fe ox oy oz pa b">&lt;10%,</code>时，自动缩放器会尝试将部署中的单元数量减少到最少1个。当负载为<code class="fe ox oy oz pa b">&gt;10%,</code>时，自动缩放器会尝试增加部署中的吊舱数量，最多可达10个吊舱。</p><p id="f014" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个HPA运行的短片。当API上的负载增加时，HPA旋转新的pod。我通过使用Chrome DevTools中的一个<code class="fe ox oy oz pa b">for</code>循环发出一堆请求，在API上创建了load。</p><pre class="kj kk kl km gt pi pa pj pk aw pl bi"><span id="cce4" class="pm mu it pa b gy pn po l pp pq">for(var i = 0; i &lt; 1000; i++){<br/>    fetch("<a class="ae mr" href="http://localhost/Account/getAllUsers" rel="noopener ugc nofollow" target="_blank">http://localhost/Account/getAllUsers</a>");<br/>}</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="rf ph l"/></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">HPA在运行</figcaption></figure><p id="2d38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终，HPA达到最大10个吊舱，当负载不再存在时，最终下降到1个吊舱。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rg"><img src="../Images/cb9be301dc05effd9f342cb0a4ecbcb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abmw-P10IHekp54kyBuJfg.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">HPA最大化了豆荚</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rg"><img src="../Images/75951bbe8b341d418b062f4483a523a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCfqzzB5kpFqfLo4u9aA1w.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">HPA返回到最小复制副本</figcaption></figure><p id="99a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以在K8s dashboard上看到一些使用指标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rh"><img src="../Images/7cd9fcfd5f5346db8da20191dc935421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBKS9atWNeMPtBBuPCpPEg.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">K8s豆荚详情</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi rh"><img src="../Images/fa3d95f93eec6ea67fc304c9ecc7f41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WBpOfvMbYXAIds9QmJBkRA.png"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">K8s使用指标</figcaption></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="10ff" class="mt mu it bd mv mw nz my mz na oa nc nd jz ob ka nf kc oc kd nh kf od kg nj nk bi translated">结论📍</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ri"><img src="../Images/73abf5c963a9f8fd5b4b94c7c9e41e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZaAjqiOl1L_PhBiPL8DRw.jpeg"/></div></div><figcaption class="pc pd gj gh gi pe pf bd b be z dk translated">urlme.me</figcaption></figure><p id="8dc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">能够与本地K8s集群进行交互是很有帮助的，尤其是在了解K8s或者尝试创建各种资源的时候。🙏</p></div></div>    
</body>
</html>