<html>
<head>
<title>Extending or simplifying TypeScript decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展或简化TypeScript装饰器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/extending-or-simplifying-typescript-decorators-5e3cff556b96?source=collection_archive---------4-----------------------#2020-02-14">https://levelup.gitconnected.com/extending-or-simplifying-typescript-decorators-5e3cff556b96?source=collection_archive---------4-----------------------#2020-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="094c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你有没有使用过图书馆里的打字稿装饰器</p><blockquote class="kl km kn"><p id="a967" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">如果这东西能再多做一件事，那就完美了！</p></blockquote><p id="efdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者也许</p><blockquote class="kl km kn"><p id="7fc0" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">这4个参数中的3个总是相同的，一遍又一遍地写同样的东西真是浪费时间！</p></blockquote><p id="6c9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对自己？如果不是，你在撒谎或者只是非常谦虚😉。如果是，请继续阅读。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/18ddb315cc359701bc4a4f6182feebc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fsFM8HhDgiebdhcV"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Roman Synkevych </a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="dcd1" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">装饰者是函数</h2><p id="240d" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">关于TypeScript decorators，要知道的主要事情是:它们看起来很花哨，但在它们的核心中，它们只不过是一个函数，当被修饰的方法、属性或类被加载时，它将被执行。当你定义一个装饰器时，你可以直接定义一个函数，或者实现一个工厂，让<strong class="jp ir">返回</strong>一个参数化的函数。</p><p id="da88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个函数，无论是由工厂定义的还是返回的，都将其<code class="fe mh mi mj mk b">target</code>作为一个最小参数。根据装饰者的类型(即你把它放在什么前面)，这个<code class="fe mh mi mj mk b">target</code>可能是:</p><ul class=""><li id="258a" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">一个类的方法</li><li id="d343" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">一个类的属性</li><li id="a6c6" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">一个类本身</li></ul><p id="4daf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在官方的<a class="ae li" href="http://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener ugc nofollow" target="_blank"> TypeScript文档</a>中阅读更多关于不同类型装饰器的信息。</p><h2 id="34e7" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">装饰示例</h2><p id="c59e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">让我们看看类装饰器的以下用法:</p><pre class="kt ku kv kw gt mz mk na nb aw nc bi"><span id="2151" class="lj lk iq mk b gy nd ne l nf ng">import {Table} from "imaginary-decorator-library";</span><span id="5f5f" class="lj lk iq mk b gy nh ne l nf ng">@Table({<br/>    name: "example",<br/>    createAutoAttributes: true,<br/>})<br/>export class MyEntity {}</span></pre><blockquote class="kl km kn"><p id="6c04" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">这是一个基于<strong class="jp ir">工厂</strong>的装饰器，因为您可以放入参数来指定细节。</p></blockquote><p id="7960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，您在无数的实体文件中使用这个装饰器，并且您总是必须提供一个对象作为参数，给出表的名称和<code class="fe mh mi mj mk b">createAutoAttribute</code>标志，它总是<code class="fe mh mi mj mk b">true</code>。但是另一方面，如果这里给出的名字可以放在一个名字的全局数组中，那就太好了，这样我们就可以在允许装饰器之前检查数组是否有重复。</p><p id="6050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，让我们实现我们自己的装饰工厂:</p><pre class="kt ku kv kw gt mz mk na nb aw nc bi"><span id="eebd" class="lj lk iq mk b gy nd ne l nf ng">import {Table} from "imaginary-decorator-library";<br/>import {TABLE_NAME} from "somewhere-else";</span><span id="5803" class="lj lk iq mk b gy nh ne l nf ng">export function CoolerTable(name: string): Function {  <br/>  // Factory returns the actual decoration function.  <br/>  return function(target: Function): void {<br/>    <br/>    // Check our duplication stuff.   <br/>    if(TABLE_NAMES.includes(name)) {<br/>      throw new Exception(`Duplicate table name "${name}"!`);<br/>    }<br/>    TABLE_NAMES.push(name);</span><span id="72c0" class="lj lk iq mk b gy nh ne l nf ng">    // Execute the uncool decorator.<br/>    Table({<br/>      name: name,<br/>      createAutoAttributes: true,<br/>    })(target);<br/>  }<br/>}</span></pre><p id="800d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工厂得到一个<code class="fe mh mi mj mk b">name</code>作为参数，并返回一个新的类装饰器，这个函数现在是空的。现在让我们插入我们自己的实现细节:</p><pre class="kt ku kv kw gt mz mk na nb aw nc bi"><span id="f7c7" class="lj lk iq mk b gy nd ne l nf ng">import {Table} from "imaginary-decorator-library";<br/>import {TABLE_NAME} from "somewhere-else";</span><span id="a5b6" class="lj lk iq mk b gy nh ne l nf ng">export function CoolerTable(name: string): Function {  <br/>  // Factory returns the actual decoration function.  <br/>  return function(target: Function): void {<br/>    <br/>    // Check our duplication stuff.   <br/>    if(TABLE_NAMES.includes(name)) {<br/>      throw new Exception(`Duplicate table name "${name}"!`);<br/>    }<br/>    TABLE_NAMES.push(name);<br/>  }<br/>}</span></pre><p id="84c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，你已经可以在你的代码中使用装饰器了。它将检查给定的表名是否已经在另一个装饰器中使用，否则抛出一个异常。但是您仍然需要为实际的功能应用最初的<code class="fe mh mi mj mk b">@Table</code>装饰器。让我们来完成这个:</p><pre class="kt ku kv kw gt mz mk na nb aw nc bi"><span id="5b2e" class="lj lk iq mk b gy nd ne l nf ng">import {Table} from "imaginary-decorator-library";<br/>import {TABLE_NAME} from "somewhere-else";</span><span id="f680" class="lj lk iq mk b gy nh ne l nf ng">export function CoolerTable(name: string): Function {  <br/>  // Factory returns the actual decoration function.  <br/>  return function(target: Function): void {<br/>    <br/>    // Check our duplication stuff.   <br/>    if(TABLE_NAMES.includes(name)) {<br/>      throw new Exception(`Duplicate table name "${name}"!`);<br/>    }<br/>    TABLE_NAMES.push(name);</span><span id="52d4" class="lj lk iq mk b gy nh ne l nf ng">    // Execute the uncool decorator.<br/>    Table({<br/>      name: name,<br/>      createAutoAttributes: true,<br/>    })(target);<br/>  }<br/>}</span></pre><p id="4ad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看到我做了什么吗？因为装饰器是函数——你可以在目标上自己调用它们。在我们的自定义装饰器的最后几行中，我们首先调用工厂来获得一个装饰器函数，然后调用函数本身，将原始目标作为参数。这样，您可以在应用装饰器之前和之后做任何您想做的事情，并定制它的输入。</p><h2 id="f893" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">额外小费</h2><p id="3711" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">当你总是不得不使用两个或更多的装饰者来得到你想要的行为时，你不讨厌吗？只需创建一个新的装饰器，并在其实现中调用它们！</p></div></div>    
</body>
</html>