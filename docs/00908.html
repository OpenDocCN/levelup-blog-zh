<html>
<head>
<title>Comparing Golang’s built-in HTTP server implementation with the most popular community package gorilla/mux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Golang的内置HTTP服务器实现与最流行的社区包gorilla/mux进行比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/experiment-golang-http-builtin-and-related-popular-packages-1d9a6dcb80d?source=collection_archive---------0-----------------------#2019-09-12">https://levelup.gitconnected.com/experiment-golang-http-builtin-and-related-popular-packages-1d9a6dcb80d?source=collection_archive---------0-----------------------#2019-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1d9792df9d3931d902438619b4a9aa20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06A5r9G6LQApjya2LCo2JA.png"/></div></div></figure><h2 id="5cb8" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener ugc nofollow" target="_blank" href="/go-restful-series-a7addbfef5b1">安息吧</a> — #6</h2><div class=""/><p id="52bb" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">本文总结了我使用Golang HTTP进行的实验，使用内置功能和最流行的社区开发包来找出声明HTTP视图和处理HTTP请求的有效方法。</p><figure class="lg lh li lj gt is gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/602e3e240e7500d5af09feaed01512ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*jGTqQo_dUA28d3GhuHYO8g.gif"/></div></figure></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="dd27" class="lr ls jb bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">内置网络/http包</h1><h2 id="0685" class="mp ls jb bd lt mq mr dn lx ms mt dp mb ks mu mv mf kw mw mx mj la my mz mn jh bi translated">声明处理程序</h2><p id="0a4f" class="pw-post-body-paragraph kh ki jb kj b kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ne lc ld le ij bi translated"><code class="fe nf ng nh ni b">net/http</code>包包含接受请求和动态处理请求所需的所有实用程序。我们可以用<code class="fe nf ng nh ni b">http.HandleFunc</code>注册处理程序。该处理程序的第一个参数采用一个字符串路径进行匹配，第二个参数是一个在该路径匹配时执行的函数。</p><pre class="lg lh li lj gt nj ni nk nl aw nm bi"><span id="8219" class="mp ls jb ni b gy nn no l np nq">http.HandleFunc("/", <strong class="ni jl">func</strong> (w http.ResponseWriter, r *http.Request) {<br/>    fmt.Fprintf(w, "Go RESTful Series")<br/>}</span></pre><p id="02b2" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">匹配算法是前缀匹配，所以上面的声明将把每个请求路由到内联匿名函数。也就是说，因为只有<code class="fe nf ng nh ni b">/</code>，所以所有的路线都会匹配它。</p><h2 id="a40c" class="mp ls jb bd lt mq mr dn lx ms mt dp mb ks mu mv mf kw mw mx mj la my mz mn jh bi translated">读取请求</h2><p id="562c" class="pw-post-body-paragraph kh ki jb kj b kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ne lc ld le ij bi translated">每个处理函数接收一个<code class="fe nf ng nh ni b">*http.Request</code>作为第二个参数<strong class="kj jl">，这是一个包含与请求相关的所有信息的结构实例指针。</strong></p><pre class="lg lh li lj gt nj ni nk nl aw nm bi"><span id="664b" class="mp ls jb ni b gy nn no l np nq">r.Method  <em class="nr">// request method</em><br/>r.URL     <em class="nr">// request URL</em><br/>r.Header  <em class="nr">// request headers</em><br/>r.Body    <em class="nr">// request body</em></span></pre><p id="97d1" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">参考<a class="ae ns" href="https://golang.org/pkg/net/http/#Request" rel="noopener ugc nofollow" target="_blank">这里的</a>获取完整的<code class="fe nf ng nh ni b">http.Request</code> API参考。</p><h2 id="f8bd" class="mp ls jb bd lt mq mr dn lx ms mt dp mb ks mu mv mf kw mw mx mj la my mz mn jh bi translated">写下回应</h2><p id="5c4a" class="pw-post-body-paragraph kh ki jb kj b kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ne lc ld le ij bi translated">每个处理函数都接收一个<code class="fe nf ng nh ni b">http.ResponseWriter</code>作为第一个<strong class="kj jl">参数，它公开了用于编写响应的头和体的API。它实现了<code class="fe nf ng nh ni b">io.Writer</code>接口，这样我们就可以编写类似于写入文件/stdout等的响应。</strong></p><pre class="lg lh li lj gt nj ni nk nl aw nm bi"><span id="5ab7" class="mp ls jb ni b gy nn no l np nq"><em class="nr">// Set header</em><br/>w.Header().Set("Some-Header", "value")</span><span id="ec79" class="mp ls jb ni b gy nt no l np nq"><em class="nr">// Write using standard write method in fmt package.<br/></em>fmt.Fprintf(w, "Body content")</span><span id="bd8a" class="mp ls jb ni b gy nt no l np nq"><em class="nr">// Write body will automatically write all previous-set header fields.</em></span></pre><h2 id="a62c" class="mp ls jb bd lt mq mr dn lx ms mt dp mb ks mu mv mf kw mw mx mj la my mz mn jh bi translated">启动服务器</h2><p id="5d77" class="pw-post-body-paragraph kh ki jb kj b kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ne lc ld le ij bi translated">为了运行上面的代码，我们需要启动服务器。</p><pre class="lg lh li lj gt nj ni nk nl aw nm bi"><span id="b220" class="mp ls jb ni b gy nn no l np nq">http.ListenAndServe(":80", <strong class="ni jl">nil</strong>)</span></pre><p id="7405" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这将使用我们使用<code class="fe nf ng nh ni b">http.HandleFunc</code>设置的默认路由启动默认HTTP服务器。如果你想创建一个新的服务器并在你自己的服务器中管理它，请参考<a class="ae ns" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank">这里的</a>，为了这篇文章，默认的服务器就足够了。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="6405" class="lr ls jb bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">社区开发的包</h1><p id="9318" class="pw-post-body-paragraph kh ki jb kj b kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ne lc ld le ij bi translated">Go的<code class="fe nf ng nh ni b">net/http</code>包已经为编写HTTP应用程序提供了相当数量的API。然而，有一点它做得不是很好，那就是复杂的请求路由，比如将请求URL分割成单个参数。幸运的是，有一个非常流行的由社区开发的名为<code class="fe nf ng nh ni b">gorilla/mux</code>的包来处理这些责任。</p><h2 id="9411" class="mp ls jb bd lt mq mr dn lx ms mt dp mb ks mu mv mf kw mw mx mj la my mz mn jh bi translated">导入</h2><pre class="lg lh li lj gt nj ni nk nl aw nm bi"><span id="5c30" class="mp ls jb ni b gy nn no l np nq">import "github.com/gorilla/mux"</span></pre><h2 id="3ed4" class="mp ls jb bd lt mq mr dn lx ms mt dp mb ks mu mv mf kw mw mx mj la my mz mn jh bi translated">重构代码以使用gorilla/mux</h2><p id="b36b" class="pw-post-body-paragraph kh ki jb kj b kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ne lc ld le ij bi translated">为了应用<code class="fe nf ng nh ni b">gorilla/mux</code>，我们需要对之前的实现做一些更新。</p><pre class="lg lh li lj gt nj ni nk nl aw nm bi"><span id="8b48" class="mp ls jb ni b gy nn no l np nq"><em class="nr">// Create a new mux router.</em><br/>r := mux.NewRouter()</span><span id="e625" class="mp ls jb ni b gy nt no l np nq"><em class="nr">// Replace http.HandleFunc by router.HandleFunc.<br/></em>r.HandleFunc("/", handler)</span><span id="32b6" class="mp ls jb ni b gy nt no l np nq"><em class="nr">// Replace 2nd parameter by the configured mux router.<br/></em>http.ListenAndServe(":80", r)</span></pre><h2 id="ab14" class="mp ls jb bd lt mq mr dn lx ms mt dp mb ks mu mv mf kw mw mx mj la my mz mn jh bi translated">声明复杂路线</h2><p id="c04b" class="pw-post-body-paragraph kh ki jb kj b kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ne lc ld le ij bi translated">有了<code class="fe nf ng nh ni b">gorilla/mux</code>，我们可以用变量声明复杂的路线，用方法约束路线等等。</p><pre class="lg lh li lj gt nj ni nk nl aw nm bi"><span id="c0ac" class="mp ls jb ni b gy nn no l np nq">r.HandleFunc("/users/", listUsers).Methods(http.MethodGet)<br/>r.HandleFunc("/users/", createUser).Methods(http.MethodPost)<br/>r.HandleFunc("/users/{userId}/", getUser).Methods(http.MethodGet)<br/>r.HandleFunc("/users/{userId}/", updateUser).Methods(http.MethodPut)<br/>r.HandleFunc("/users/{userId}/", deleteUser).Methods(Http.MethodDelete)</span></pre><p id="e7d1" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">参考<a class="ae ns" href="http://www.gorillatoolkit.org/pkg/mux" rel="noopener ugc nofollow" target="_blank">这里的</a>获取完整的<code class="fe nf ng nh ni b">gorilla/mux</code> API参考。</p><h2 id="5242" class="mp ls jb bd lt mq mr dn lx ms mt dp mb ks mu mv mf kw mw mx mj la my mz mn jh bi translated">获取捕获的变量</h2><p id="d146" class="pw-post-body-paragraph kh ki jb kj b kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ne lc ld le ij bi translated">我们用变量声明了路由，我们应该能够在处理程序中捕获这些变量的值。</p><pre class="lg lh li lj gt nj ni nk nl aw nm bi"><span id="5cb6" class="mp ls jb ni b gy nn no l np nq"><strong class="ni jl">func</strong> handler(w http.ResponseWriter, r *http.Request) {<br/>     <em class="nr">// mux.Vars(r) returns all values captured in the request URL.<br/>     </em>vars := mux.Vars(r)</span><span id="6d03" class="mp ls jb ni b gy nt no l np nq">     <em class="nr">// vars is a dictionary whose key-value pairs are variables' name-value pairs.</em><br/>     fmt.Fprintf(w, "User %s\n", vars["userId"])<br/>}</span></pre></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="5150" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如您所见，Go中的标准HTTP服务器实现已经很强大了。通过使用<code class="fe nf ng nh ni b">gorilla/mux</code>,我们能够获得一个更简单的接口来处理复杂的路由和管理请求。</p></div></div>    
</body>
</html>