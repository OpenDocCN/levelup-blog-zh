<html>
<head>
<title>Flutter for Single-Page Scrollable Websites with Navigator 2.0 — Part 2: Scroll To Position</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Navigator 2.0下单页可滚动网站的抖动——第二部分:滚动到位置</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-for-single-page-scrollable-websites-with-navigator-2-0-part-2-scroll-to-position-4c09cbc9d975?source=collection_archive---------0-----------------------#2021-07-18">https://levelup.gitconnected.com/flutter-for-single-page-scrollable-websites-with-navigator-2-0-part-2-scroll-to-position-4c09cbc9d975?source=collection_archive---------0-----------------------#2021-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/961f79306e87ae98e3ed9399f31aa52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9WLVOmziSPSK9Xj_W5v5Tw.png"/></div></div></figure><p id="e003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的<a class="ae kw" href="https://ulusoyca.medium.com/flutter-navigator-2-0-for-authentication-and-bootstrapping-part-1-introduction-d7b6dfdd0849" rel="noopener">第一部分中，</a>我们讨论了在<strong class="ka ir">单页可滚动网站</strong> (SPSW)中构建可滚动小部件时的选项，并解释了我们将构建的示例应用程序。在本文中，我们将探索使用一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ListView/ListView.builder.html" rel="noopener ugc nofollow" target="_blank">ListView</a></code>来构建一个SPSW，它的各个部分是延迟构建的(按需)，并且具有相同的高度。</p><ul class=""><li id="302a" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv lg lh li lj bi translated"><a class="ae kw" href="https://ulusoyca.medium.com/flutter-for-single-page-scrollable-websites-with-navigator-2-0-part-1-introduction-c219b471bbec" rel="noopener">第1部分:简介</a></li><li id="b9d5" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated"><strong class="ka ir">第2部分:滚动到位置</strong></li><li id="58c7" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated"><a class="ae kw" href="https://ulusoyca.medium.com/flutter-for-single-page-scrollable-websites-with-navigator-2-0-part-3-scroll-to-page-30b6c43bd41" rel="noopener">第3部分:滚动到第</a>页</li><li id="b181" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated"><a class="ae kw" href="https://ulusoyca.medium.com/flutter-for-single-page-scrollable-websites-with-navigator-2-0-part-4-ensure-visible-145eba88d742" rel="noopener">第4部分:确保可见</a></li><li id="a78e" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated"><a class="ae kw" href="https://ulusoyca.medium.com/flutter-for-single-page-scrollable-websites-with-navigator-2-0-part-5-scroll-to-index-c38ed06ddf08" rel="noopener">第5部分:滚动至索引</a></li><li id="e089" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated"><a class="ae kw" href="https://ulusoyca.medium.com/flutter-for-single-page-scrollable-websites-with-navigator-2-0-part-6-navigation-16b4f5a1981f" rel="noopener">第六部分:导航</a></li><li id="431f" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated">第7部分:查询参数</li></ul><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/713bff51d2c4643fce5f1596a3b4615d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3C9ApMj0dExwZe57PSbdQ.png"/></div></div></figure><h1 id="2bd5" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">主屏幕</h1><p id="f610" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated"><code class="fe kx ky kz la b">HomeScreen</code>有一个由两个主要部分组成的<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/Column-class.html" rel="noopener ugc nofollow" target="_blank">Column</a></code>:一个<em class="mx">粘性顶部导航菜单</em>和一个扩展的<em class="mx">可滚动列表</em>。我们提供<code class="fe kx ky kz la b">colors</code>、<code class="fe kx ky kz la b">colorCodeNotifier</code>和<code class="fe kx ky kz la b">shapeBorderTypeNotifier</code>到<code class="fe kx ky kz la b">HomeScreen</code>作为构造器参数。</p><p id="ec18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，虽然<code class="fe kx ky kz la b">shapeBorderTypeNotifier</code>和<code class="fe kx ky kz la b">colorCodeNotifier</code>是<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/foundation/ValueNotifier-class.html" rel="noopener ugc nofollow" target="_blank">ValueNotifier</a></code>的实例，但是我们将它们作为<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/foundation/ValueNotifier-class.html" rel="noopener ugc nofollow" target="_blank">ValueNotifier</a></code>的父类<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/foundation/ValueListenable-class.html" rel="noopener ugc nofollow" target="_blank">ValueListenable</a></code>传递。这是一个很好的实践，因为虽然<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/foundation/ValueNotifier-class.html" rel="noopener ugc nofollow" target="_blank">ValueNotifier</a></code>实例可以通知它们的侦听器，但是<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/foundation/ValueListenable-class.html" rel="noopener ugc nofollow" target="_blank">ValueListenable</a></code>实例不能。在<code class="fe kx ky kz la b">HomeScreen</code>小部件中，我们不会通知监听器，但是它的子部件会通知监听器。因此，在<code class="fe kx ky kz la b">HomeScreen</code>中包含它们的类型<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/foundation/ValueListenable-class.html" rel="noopener ugc nofollow" target="_blank">ValueListenable</a></code>更安全。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="1c32" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">顶部导航菜单</h1><p id="dfbd" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated"><code class="fe kx ky kz la b">TopNavigationMenu</code>小部件以水平方式包装所有的<code class="fe kx ky kz la b"><a class="ae kw" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/003-single-page-scrollable-web/widgets/navigation_menu_button.dart" rel="noopener ugc nofollow" target="_blank">NavigationMenuButton</a></code>小部件。运行次数因屏幕宽度而异。</p><p id="929c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个小部件监听并通知<code class="fe kx ky kz la b">colorCodeNotifier</code>:</p><ul class=""><li id="4b88" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv lg lh li lj bi translated">它<em class="mx">监听</em>来自不同来源的颜色代码值，如果当前颜色代码与按钮文本相同，则填充按钮的背景。</li></ul><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/46b4e2eac2a52c6f06b172779a372469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qaNIAjeEpkD3LZU1skqhKQ.gif"/></div></div></figure><ul class=""><li id="ef15" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv lg lh li lj bi translated">它<em class="mx">通知</em>用户按钮按下时的颜色代码监听器。当用户点击一个颜色按钮时，按钮的<code class="fe kx ky kz la b">Color</code>被转换成一个<code class="fe kx ky kz la b">String</code>十六进制颜色代码，并通知<code class="fe kx ky kz la b">colorCodeNotifier</code>的监听器。</li></ul><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/c4040a0eaaed5596a241266f8776f4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NZ2tghSwTNU9wwjc85XoWA.gif"/></div></div></figure><p id="72b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们先来分析一下<code class="fe kx ky kz la b"><a class="ae kw" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow/blob/develop/lib/003-single-page-scrollable-web/widgets/navigation_menu_button.dart" rel="noopener ugc nofollow" target="_blank">NavigationMenuButton</a></code>。它是一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html" rel="noopener ugc nofollow" target="_blank">StatelessWidget</a></code>，包括一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/material/TextButton-class.html" rel="noopener ugc nofollow" target="_blank">TextButton</a></code>或一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/material/ElevatedButton-class.html" rel="noopener ugc nofollow" target="_blank">ElevatedButton</a></code>，这取决于<code class="fe kx ky kz la b">selected</code>参数。</p><ul class=""><li id="9705" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv lg lh li lj bi translated">如果<code class="fe kx ky kz la b">selected</code>是<code class="fe kx ky kz la b">false</code>，那么它就是一个文本颜色与<code class="fe kx ky kz la b">color</code>参数相同的<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/material/TextButton-class.html" rel="noopener ugc nofollow" target="_blank">TextButton</a></code>。</li><li id="5e40" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated">如果<code class="fe kx ky kz la b">selected</code>是<code class="fe kx ky kz la b">true</code>，那么它就是一个背景颜色与<code class="fe kx ky kz la b">color</code>参数相同的<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/material/ElevatedButton-class.html" rel="noopener ugc nofollow" target="_blank">ElevatedButton</a></code>。我们根据颜色的估计亮度将文本颜色设置为黑色或白色。</li></ul><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="aa3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">TopNavigationMenu</code>是一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html" rel="noopener ugc nofollow" target="_blank">StatefulWidget</a></code>。它监听<code class="fe kx ky kz la b">colorCodeNotifier</code>，每当它的值被更新时，就调用<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/State/setState.html" rel="noopener ugc nofollow" target="_blank">setState</a></code>方法，以便根据新的<code class="fe kx ky kz la b">selected</code>状态重建<code class="fe kx ky kz la b">NavigationMenuButton</code>小部件。文本值等于<code class="fe kx ky kz la b">colorCodeNotifier</code>中十六进制色码值的按钮为<code class="fe kx ky kz la b">selected</code>按钮。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f902" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">转念一想，<code class="fe kx ky kz la b">TopNavigationMenu</code> widget可以是一个无状态的widget，因为Flutter的<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ValueListenableBuilder-class.html" rel="noopener ugc nofollow" target="_blank">ValueListenableBuilder</a></code> widget可以帮助内容与<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/foundation/ValueListenable-class.html" rel="noopener ugc nofollow" target="_blank">ValueListenable</a></code>保持同步。在我们的例子中，我们将用一个代表<code class="fe kx ky kz la b">colorCodeNotifier</code>的<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ValueListenableBuilder-class.html" rel="noopener ugc nofollow" target="_blank">ValueListenableBuilder</a></code>来包装内容。每当<code class="fe kx ky kz la b">colorCodeNotifier</code>保存的值被更新时，提供给<code class="fe kx ky kz la b">builder</code>字段的小部件被重建。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="1763" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">颜色部分</h1><p id="6c4c" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated"><code class="fe kx ky kz la b">ColorSections</code>是一个可滚动的小部件，列出了所有的颜色部分。这个小部件监听颜色代码的变化，并通知颜色代码监听器:</p><ul class=""><li id="a515" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv lg lh li lj bi translated">它<em class="mx">监听</em>来自不同来源的颜色代码值，如果值更新的来源是<strong class="ka ir">而不是</strong>滚动，则滚动到相应的颜色部分。</li><li id="15e3" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv lg lh li lj bi translated">当第一个可见部分(<code class="fe kx ky kz la b">trailingIndex</code>)改变时，以及当一个成形按钮被按下时，它<em class="mx">通知</em>色码监听器。</li></ul><p id="f00c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的录音中，当点击一个异形按钮时，所有的<code class="fe kx ky kz la b">ColorCode</code>听众都会得到通知。<code class="fe kx ky kz la b">ColorSections</code>小部件中的监听器将触发滚动到具有异形按钮的部分。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/435be25978d43d13c3a901eb826b8d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*n1kQn90a4SXMnzvhYCM_pQ.gif"/></div></div></figure><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8351" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ListView/ListView.builder.html" rel="noopener ugc nofollow" target="_blank">ListView.builder</a></code>构造函数来构建<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ListView/ListView.html" rel="noopener ugc nofollow" target="_blank">ListView</a></code>。不是一次构建所有的列表项(颜色部分)，而是当它们在屏幕上可见时构建。显然，从性能的角度来看，这是有帮助的，但是正如在本系列的介绍部分中提到的那样，这是有代价的。</p><p id="9c3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于所有的项目都不是一次放出来的(懒人建造)，所以我们无法知道所有项目的偏移量，除非我们在建造之前就有了它们的大小信息。因此，当从<code class="fe kx ky kz la b">TopNavigationMenu</code>中选择一个颜色代码时，如果各部分具有不可预测的高度，我们无法跳转到相应的颜色部分。</p><p id="c08b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们根据这个公式假设所有的列表项具有相同的高度:如果可用高度(可见的listview区域，viewport高度)小于<code class="fe kx ky kz la b">_minItemHeight</code> (700 px)，则等于<code class="fe kx ky kz la b">_minItemHeight</code>，否则为可用高度。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="5b03" class="nb lv iq bd lw nc nd dn ma ne nf dp me kj ng nh mi kn ni nj mm kr nk nl mq nm bi translated">收听颜色代码更新</h2><p id="ccda" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">在<code class="fe kx ky kz la b">ColorSections</code>中，我们听<code class="fe kx ky kz la b">colorCodeNotifier</code>滚动到一个颜色段。请注意，<code class="fe kx ky kz la b">colorCodeNotier</code>值可以从不同的源进行设置。如果颜色因滚动事件而更新，我们将<strong class="ka ir">而不是</strong>以编程方式滚动到某个部分。</p><p id="9a1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<code class="fe kx ky kz la b">colorCodeNotifier</code>保存的值发生变化并且变化的来源是<strong class="ka ir">而不是</strong> <em class="mx">滚动</em>时，我们执行以下操作:</p><ol class=""><li id="e173" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv nn lh li lj bi translated">从<code class="fe kx ky kz la b">colors</code>列表中找到颜色代码的索引</li><li id="7149" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv nn lh li lj bi translated">通过将索引乘以项目高度来计算滚动偏移量。我们可以通过点击按钮从<code class="fe kx ky kz la b">ColorSections</code> ' <code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html" rel="noopener ugc nofollow" target="_blank">context</a></code>的<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/BuildContext/size.html" rel="noopener ugc nofollow" target="_blank">size</a></code>属性中获取可用的高度信息，因为<code class="fe kx ky kz la b">ColorSections</code>小部件已经布局好了。因此，框架可以决定它的大小。</li><li id="5508" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv nn lh li lj bi translated">调用<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollController/animateTo.html" rel="noopener ugc nofollow" target="_blank">ScrollController.animateTo</a></code>方法以编程方式滚动到该节。</li></ol><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="461c" class="nb lv iq bd lw nc nd dn ma ne nf dp me kj ng nh mi kn ni nj mm kr nk nl mq nm bi translated">通知颜色代码更新</h2><p id="8adc" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">当用户滚动时，我们希望随着第一个可见的颜色代码部分(<code class="fe kx ky kz la b">trailingIndex</code>)的改变来更新<code class="fe kx ky kz la b">colorCodeNotifier</code>监听器。请注意，当我们设置<code class="fe kx ky kz la b">colorCodeNotifier</code>通知程序值时，我们将其源字段设置为<code class="fe kx ky kz la b">fromScroll</code>。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/cbda7e8250950f1aeed88b4e8c18998b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFHdFZkpwTGg_btHfnU1iA.png"/></div></div></figure><p id="e015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/Scrollable-class.html" rel="noopener ugc nofollow" target="_blank">Scrollable</a></code>小部件用<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">ScrollNotificaton</a></code>通知它们的祖先滚动事件。一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">ScrollNotificaton</a></code>将在树中向上遍历，直到一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">NotificationListener</a></code>处理它。<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">NotificationListener</a></code>小部件不必是源<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/Scrollable-class.html" rel="noopener ugc nofollow" target="_blank">Scrollable</a></code>小部件的父部件，但它必须是将<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/Notification-class.html" rel="noopener ugc nofollow" target="_blank">Notification</a></code>类型指定为<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">ScrollNotificaton</a></code>的祖先小部件。</p><p id="b927" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们用一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">NotificationListener</a></code>小部件包装了<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ListView/ListView.html" rel="noopener ugc nofollow" target="_blank">ListView</a></code>小部件，它的<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/NotificationListener/onNotification.html" rel="noopener ugc nofollow" target="_blank">onNotification</a></code>回调属性将由两个滚动事件源调用:</p><ol class=""><li id="72cf" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv nn lh li lj bi translated">按下<code class="fe kx ky kz la b">TopNavigationMenu</code>中的一个彩色按钮导致程序滚动</li><li id="c5ce" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv nn lh li lj bi translated">用户通过触摸、触控板或鼠标事件生成的滚动。</li></ol><p id="06b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要区分滚动事件源，并只为用户生成的<em class="mx">事件通知<code class="fe kx ky kz la b">colorCodeNotier</code>监听器。因此，我们使用<code class="fe kx ky kz la b">is</code>操作符检查<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/dart-core/Object/runtimeType.html" rel="noopener ugc nofollow" target="_blank">runtimeType</a></code>，如果<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/dart-core/Type-class.html" rel="noopener ugc nofollow" target="_blank">Type</a></code>是<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/UserScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">UserScrollNotification</a></code>，就处理通知。</em></p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="69ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们接收到<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/UserScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">UserScrollNotification</a></code>时，我们从通知中获得偏移量(<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollMetrics/pixels.html" rel="noopener ugc nofollow" target="_blank">pixels</a></code>)，并通过将偏移量除以列表项高度来计算第一个可见索引(尾部索引)。我们可以从<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html" rel="noopener ugc nofollow" target="_blank">context</a></code>中获得可用的高度信息，因为<code class="fe kx ky kz la b">ColorSections</code>小部件已经在用户滚动时布局好了。</p><blockquote class="no np nq"><p id="a643" class="jy jz mx ka b kb kc kd ke kf kg kh ki nr kk kl km ns ko kp kq nt ks kt ku kv ij bi translated"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollPosition/pixels.html" rel="noopener ugc nofollow" target="_blank"> pixels </a>是在轴的相反方向上偏移子节点的像素数。例如，如果轴方向是向下的，那么像素值代表将子<em class="iq">在屏幕上向上</em>移动的逻辑像素的数量…</p></blockquote><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9dd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/NotificationListener/onNotification.html" rel="noopener ugc nofollow" target="_blank">onNotification</a></code>方法中返回<code class="fe kx ky kz la b">true</code>，我们停止了小部件树中<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/UserScrollNotification-class.html" rel="noopener ugc nofollow" target="_blank">UserScrollNotification</a></code>的冒泡。</p><p id="a3cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，在构建过程中，我们无法从<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html" rel="noopener ugc nofollow" target="_blank">BuildContext</a></code>中获取物品高度。如果我们这样做，我们将得到以下错误:</p><blockquote class="no np nq"><p id="5685" class="jy jz mx ka b kb kc kd ke kf kg kh ki nr kk kl km ns ko kp kq nt ks kt ku kv ij bi translated">这个渲染对象的大小还没有确定，因为框架还在构建小部件的过程中，这意味着这个帧的渲染树还没有确定。size getter只能从paint回调或交互事件处理程序(如手势回调)中调用。</p><p id="41eb" class="jy jz mx ka b kb kc kd ke kf kg kh ki nr kk kl km ns ko kp kq nt ks kt ku kv ij bi translated">如果您在构建期间需要一些大小信息来决定构建哪些小部件，可以考虑使用LayoutBuilder小部件，它可以告诉您树中给定位置的布局约束。</p></blockquote><p id="4a2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们在<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/LayoutBuilder-class.html" rel="noopener ugc nofollow" target="_blank">LayoutBuilder</a></code>小部件的帮助下确定截面高度并计算<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollController-class.html" rel="noopener ugc nofollow" target="_blank">ScrollController</a></code>的初始偏移。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="b9d9" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">部分</h1><p id="5799" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">在<code class="fe kx ky kz la b">ShapedBorderListView</code>中，我们列出了具有以下<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/painting/ShapeBorder-class.html" rel="noopener ugc nofollow" target="_blank">ShapeBorder</a></code>类别的5个按钮:<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/painting/BeveledRectangleBorder-class.html" rel="noopener ugc nofollow" target="_blank">BeveledRectangleBorder</a></code>、<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/painting/RoundedRectangleBorder-class.html" rel="noopener ugc nofollow" target="_blank">RoundedReactangleBorder</a></code>、<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/painting/ContinuousRectangleBorder-class.html" rel="noopener ugc nofollow" target="_blank">ContinousRectangleBorder</a></code>、<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/painting/StadiumBorder-class.html" rel="noopener ugc nofollow" target="_blank">StadiumBorder</a></code>和<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/painting/CircleBorder-class.html" rel="noopener ugc nofollow" target="_blank">CircleBorder</a></code>。</p><p id="cfdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollView/physics.html" rel="noopener ugc nofollow" target="_blank">physics</a></code>属性设置为<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/NeverScrollableScrollPhysics-class.html" rel="noopener ugc nofollow" target="_blank">NeverScrollableScrollPhyscis</a></code>，这样<code class="fe kx ky kz la b">ShapedBorderListView</code>就不允许滚动了。相反，用户滚动事件会被父<code class="fe kx ky kz la b">ColorSections</code>拦截。</p><p id="8fb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户点击列表中的按钮时，我们相应地设置<code class="fe kx ky kz la b">colorCodeNotifier</code>和<code class="fe kx ky kz la b">shapeBorderTypeNotifier</code>中的值，并通知它们的监听器。</p><p id="0224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能想知道为什么没有与点击手势时显示对话框相关的代码。这是因为显示对话框页面是由<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/Router-class.html" rel="noopener ugc nofollow" target="_blank">Router</a></code>小部件以声明方式处理的。我们将在本系列的导航部分详细讨论它。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="da2c" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">调整浏览器窗口的大小</h1><p id="e289" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">当我在这个系列工作时，我面临的最具挑战性的问题之一是浏览器窗口调整大小时<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollController-class.html" rel="noopener ugc nofollow" target="_blank">ScrollController</a></code>的不一致行为。这就是这个系列在草稿模式下等待很久的原因。</p><p id="52de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了提高性能，我避免了重新构建和重新创建<code class="fe kx ky kz la b">ColorSections</code>小部件以及在build方法中实例化<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollController-class.html" rel="noopener ugc nofollow" target="_blank">ScrollController</a></code>。然而，当浏览器窗口大小改变时，滚动控制器不能跳到正确的偏移量，除非当前偏移量再次设置为0。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/824de6ddf625449985e3069d772d6ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kewgFyZEyaMGFvbWbFkCIQ.gif"/></div></div></figure><p id="3eb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我意识到在Flutter库中有两个打开的PRs(<a class="ae kw" href="https://github.com/flutter/flutter/pull/85221" rel="noopener ugc nofollow" target="_blank"># 85221</a>和<a class="ae kw" href="https://github.com/flutter/flutter/pull/82687" rel="noopener ugc nofollow" target="_blank"> #82687 </a>)来解决这个问题。<code class="fe kx ky kz la b"><a class="ae kw" href="https://github.com/flutter/flutter/pull/85221/files#diff-a4c79fceeb99d44f8b40468a40157b0db9d92c97a0bfe25b088dc8a9a12b160dR974" rel="noopener ugc nofollow" target="_blank">ScrollMetricsNotification</a></code>在<code class="fe kx ky kz la b"><a class="ae kw" href="https://github.com/flutter/flutter/pull/82687/files#diff-7ea53e627d4729db3a54ab440e8f6d2610cbfc44ac4f9718daef49b2b4645f2dR1494" rel="noopener ugc nofollow" target="_blank">Scrollbar</a></code>中引入并整合。希望这是解决这个问题的正确方向。</p><pre class="lq lr ls lt gt nv la nw nx aw ny bi"><span id="9d2d" class="nb lv iq la b gy nz oa l ob oc">[<a class="ae kw" href="https://github.com/flutter/flutter/pull/85221/files#diff-a4c79fceeb99d44f8b40468a40157b0db9d92c97a0bfe25b088dc8a9a12b160dR974" rel="noopener ugc nofollow" target="_blank">ScrollMetricsNotification</a>] A notification that a scrollable widget's [ScrollMetrics] has changed.<br/><br/>For example, when the content of a scrollable is altered, making it larger or smaller, this notification will be dispatched. Similarly, if the size of the window or parent changes, the scrollable can notify of these changes in dimensions.<br/><br/>The above behaviors usually do not trigger [ScrollNotification] events, so this is useful for listening to [ScrollMetrics] changes that are not caused by the user scrolling.</span></pre><p id="76a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个功能登陆之前，我找到了两种解决这个问题的方法:</p><ol class=""><li id="39fa" class="lb lc iq ka b kb kc kf kg kj ld kn le kr lf kv nn lh li lj bi translated">第一个是有性能成本的。每次窗口大小改变时，我都会重新创建<code class="fe kx ky kz la b">_ColorSectionsState</code>状态和<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollController-class.html" rel="noopener ugc nofollow" target="_blank">ScrollController</a> </code>。然后还有另一个问题:当浏览器窗口高度改变时，小部件不会调用<code class="fe kx ky kz la b">ColorSections</code>的<code class="fe kx ky kz la b">build</code>方法，因为Flutter故意这样做是为了提高性能。为了强制重新创建状态，我向<code class="fe kx ky kz la b">_ColorSections</code>小部件添加了一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/foundation/ValueKey-class.html" rel="noopener ugc nofollow" target="_blank">ValueKey</a></code>，这样每当窗口高度改变时，框架都会创建一个新的<code class="fe kx ky kz la b">_ColorSectionsState</code>。</li><li id="22d4" class="lb lc iq ka b kb lk kf ll kj lm kn ln kr lo kv nn lh li lj bi translated">第二个解决方案是使用一个<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/PageView-class.html" rel="noopener ugc nofollow" target="_blank">PageView</a></code>。这个小部件有一个扩展了<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ScrollController-class.html" rel="noopener ugc nofollow" target="_blank">ScrollController</a></code>的<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/PageController-class.html" rel="noopener ugc nofollow" target="_blank">PageController</a></code>。显然，<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/PageController-class.html" rel="noopener ugc nofollow" target="_blank">PageController</a></code>更好地适应了视窗大小的变化，并且在调整浏览器窗口大小时没有任何问题。</li></ol><h1 id="418b" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="6495" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">在本文中，我们探索了使用<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/ListView/ListView.builder.html" rel="noopener ugc nofollow" target="_blank">ListView</a></code>小部件构建单页可滚动网站的各个部分。在本系列的第三部分中，我们将使用<code class="fe kx ky kz la b"><a class="ae kw" href="https://api.flutter.dev/flutter/widgets/PageView-class.html" rel="noopener ugc nofollow" target="_blank">PageView</a></code>小部件构建一个类似的UI。</p><p id="c272" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过右键单击项目源代码中的<code class="fe kx ky kz la b">main_003.01.dart</code>文件来运行示例应用程序。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/59b3f84e5ff96f583ce20aabff7d72b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*Z7JIZ6Ms28fDjzE7F3Xabw.png"/></div></figure><p id="f387" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这篇文章，请按下拍手按钮，并<strong class="ka ir">星</strong>的<a class="ae kw" href="https://github.com/ulusoyca/Flutter-ShareWhatYouKnow" rel="noopener ugc nofollow" target="_blank"> Github库</a>的样本应用。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/7ed12a2da035c2f3a7a04c632b7c65eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xq9FuQ7QWrflJMq1rcswCA.png"/></div></div></figure></div></div>    
</body>
</html>