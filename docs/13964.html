<html>
<head>
<title>Top K Frequent Elements Blind 75 LeetCode Question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">前K个常见元素盲75 LeetCode问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/top-k-frequent-elements-blind-75-leetcode-question-ebe5a29ceb7?source=collection_archive---------2-----------------------#2022-10-20">https://levelup.gitconnected.com/top-k-frequent-elements-blind-75-leetcode-question-ebe5a29ceb7?source=collection_archive---------2-----------------------#2022-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0bc0b0978ba9e6563deb2d403bde3b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o5kKke7kSn7H51ha"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/photos/eofm5R5f9Kw" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kd">照片由Bekir Dö nmez在Unsplash </strong> </a>上拍摄</figcaption></figure><h2 id="f767" class="ke kf iq bd kd kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">任务描述:</h2><p id="a978" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">给定一个整数数组<code class="fe lu lv lw lx b">nums</code>和一个整数<code class="fe lu lv lw lx b">k</code>，返回<em class="ly"/><code class="fe lu lv lw lx b">k</code><em class="ly">最频繁出现的元素</em>。你可以按<strong class="lb ir">任何顺序</strong>返回答案。</p><p id="679d" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated"><strong class="lb ir">例1: </strong></p><pre class="me mf mg mh gt mi lx mj mk aw ml bi"><span id="87e4" class="ke kf iq lx b gy mm mn l mo mp"><strong class="lx ir">Input:</strong> nums = [1,1,1,2,2,3], k = 2<br/><strong class="lx ir">Output:</strong> [1,2]</span></pre><p id="4a52" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated"><strong class="lb ir">例二:</strong></p><pre class="me mf mg mh gt mi lx mj mk aw ml bi"><span id="17a6" class="ke kf iq lx b gy mm mn l mo mp"><strong class="lx ir">Input:</strong> nums = [1], k = 1<br/><strong class="lx ir">Output:</strong> [1]</span></pre><p id="e1ff" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated"><strong class="lb ir">约束:</strong></p><ul class=""><li id="c3a4" class="mq mr iq lb b lc lz lg ma km ms kq mt ku mu lt mv mw mx my bi translated"><code class="fe lu lv lw lx b">1 &lt;= nums.length &lt;= 10^5</code></li><li id="ad00" class="mq mr iq lb b lc mz lg na km nb kq nc ku nd lt mv mw mx my bi translated"><code class="fe lu lv lw lx b">-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li id="1920" class="mq mr iq lb b lc mz lg na km nb kq nc ku nd lt mv mw mx my bi translated"><code class="fe lu lv lw lx b">k</code>在<code class="fe lu lv lw lx b">[1, the number of unique elements in the array]</code>范围内。</li><li id="43be" class="mq mr iq lb b lc mz lg na km nb kq nc ku nd lt mv mw mx my bi translated"><strong class="lb ir">保证</strong>答案<strong class="lb ir">唯一</strong>。</li></ul><p id="8e9d" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated"><strong class="lb ir">跟进:</strong>你的算法的时间复杂度一定要比<code class="fe lu lv lw lx b">O(n log n)</code>好，这里n是数组的大小。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="a727" class="ke kf iq bd kd kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">推理:</h2><p id="2417" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">所以task要求我们计算前K个频繁元素，我们应该做的第一步是计算每个元素在给定数组中出现的次数。下面的代码解决了这个子问题:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">计算每个元素的出现次数</figcaption></figure><p id="5294" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">收集了这些信息后，我们现在可以使用它来按照降序对元素进行计数排序，并返回前K个元素。首先，我们需要创建一个优先级队列，并为它提供逆序比较器，该比较器使用我们刚刚创建的Map中的信息</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">具有提供的比较器的优先级队列</figcaption></figure><p id="05c2" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">接下来，我们将valueToCount映射中的所有键推送到我们的优先级队列中，这将强制它们根据计数按降序排序。之后，我们进行K次迭代，在每次迭代中，我们从优先级队列中移除顶部元素，并将其放入我们的答案中。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">排序和挑选前K个元素逻辑</figcaption></figure><p id="655b" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">所以我们的解决方案应该是这样的:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">第一种解决方案</figcaption></figure><p id="4072" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">它起作用并给我们以下结果:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5bd236aac3b4ccd044206ad2a5bd132d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*1HBemBAxHBsXDeaZC2o8jQ.png"/></div></figure><p id="30eb" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">虽然它有效，但结果看起来并不令人印象深刻，我们可以而且应该做得更好。此外，如果您仔细查看问题陈述，会发现它还有后续问题</p><pre class="me mf mg mh gt mi lx mj mk aw ml bi"><span id="4b76" class="ke kf iq lx b gy mm mn l mo mp">Your algorithm's time complexity must be better than <!-- -->O(n log n)<!-- -->, where n is the array's size.</span></pre><p id="af6b" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">现在是时候优化和加速我们的算法了。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="8669" class="ke kf iq bd kd kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">解决方案:</h2><p id="6d12" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">为了获得更好的性能，让我们从引入一个额外的变量开始，这个变量将保存所提供的数组中所有元素的最大出现次数。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更新了计算每个元素出现次数的逻辑</figcaption></figure><p id="008b" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">我们不能再使用我们的优先级队列，因为当我们添加valueToCount映射中的所有键时，它给了我们<strong class="lb ir"> n log n </strong>时间复杂度。相反，我们希望做得更快。让我们引入整数列表的列表，称之为桶。不要害怕，我稍后会解释这个逻辑。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">介绍存储桶</figcaption></figure><p id="66be" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">如您所见，我们做了一些小的优化—我们将存储桶的大小限制为计数阶段看到的最大值。</p><p id="352b" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">第一次尝试可能很难理解下一步，请给自己一些时间再读一遍。</p><p id="0ae5" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">让我们回顾一下我们的valueToCount映射，它保存代表给定数组中元素的键，值代表每个键出现的次数。记住这些信息，我们将遍历valueToCount映射的值，并将来自同一映射的键放入特定的位置。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="150d" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">让我们看看这个例子，试着想象一下我们所做的步骤。让我们来看看这个数组</p><pre class="me mf mg mh gt mi lx mj mk aw ml bi"><span id="be16" class="ke kf iq lx b gy mm mn l mo mp"><strong class="lx ir">[4,1,-1,2,-1,2,3,5,5,5]</strong></span></pre><p id="8d2d" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">数字4、1、3在每个数字中出现1次。数字-1，2在每个数字中出现2次。数字5出现了3次。我们的地图应该包含以下信息</p><pre class="me mf mg mh gt mi lx mj mk aw ml bi"><span id="1af5" class="ke kf iq lx b gy mm mn l mo mp">{-1=2, 1=1, 2=2, 3=1, 4=1, 5=3}</span></pre><p id="6c99" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">现在让我们想象一下桶</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d99c4bb74fb7ef12500e11d2f00decd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*ahgkr1oGClcLNlWOWTo3DA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">桶可视化</figcaption></figure><p id="1022" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">顶行反映出现的次数。只剩下一步了——我们需要收集并返回结果数组</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">收集结果逻辑</figcaption></figure><p id="86e7" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">完整的解决方案应该是这样的</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="nl nm l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">第二种解决方案</figcaption></figure><p id="7244" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">现在结果看起来好多了</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4709c5cd3022ce80eac0bc6a981afd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*tFonnO1eSGUy15kAC45uXQ.png"/></div></figure></div></div>    
</body>
</html>