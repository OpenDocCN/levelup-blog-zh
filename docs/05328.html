<html>
<head>
<title>Practical Guide to Data Analysis and Machine Learning using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的数据分析和机器学习实用指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-guide-into-data-analysis-and-machine-learning-using-python-7e8ce4081dfc?source=collection_archive---------9-----------------------#2020-08-19">https://levelup.gitconnected.com/practical-guide-into-data-analysis-and-machine-learning-using-python-7e8ce4081dfc?source=collection_archive---------9-----------------------#2020-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5ff3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">掌握构建机器学习应用的第一步实践指南。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/acafd59bdb5193dd5f0f32059548b3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CA54DxgOb5l7geun0A0OOw.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">来源:<a class="ae lf" href="https://pixabay.com/photos/abacus-count-mathematics-learn-4167869/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="e3af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">机器学习在不断进化。伴随着这种演变而来的是需求和重要性的激增。企业和初创公司现在比以往任何时候都更需要数据科学家和机器学习工程师，将这些数据转化为有用的智慧。可能没有比现在(除了5年前)更好的时间来钻研机器学习了。当然，没有比Python更好的工具来开发这些应用程序了。Python有一个充满活力和活跃的社区。它的许多开发者来自科学界，因此为Python提供了大量用于科学计算的库。</p><p id="cbd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将讨论Python关键科学库的一些特性，并在适当的数据分析和机器学习工作流中使用它们。</p><p id="d781" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你将学到什么；</p><ul class=""><li id="0fa1" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">了解熊猫是什么，为什么它是你工作流程中不可或缺的一部分。</li><li id="ee60" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">如何使用Pandas检查数据集</li><li id="53f0" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">如何准备熊猫的数据和特征工程</li><li id="233e" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">理解为什么数据可视化很重要。</li><li id="ca56" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">如何用Matplotlib和Seaborn实现数据可视化？</li><li id="5045" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">如何用Statsmodel建立统计模型？</li><li id="a010" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">如何用Scikit-Learn的算法建立一个ML模型？</li><li id="a97d" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">如何对模型的特征重要性进行排序并执行特征选择。</li></ul><p id="107f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想直接看代码，可以在GitHub 上找到<a class="ae lf" href="https://github.com/SteveKola/Python-ML-Blueprints/blob/master/1.-Baby-Steps-into-Data-Analysis-and-Machine-Learning/Baby%20steps%20into%20ML.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4a87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">免责声明:</strong>本文假设</p><ul class=""><li id="b7b2" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">您至少掌握了Python和</li><li id="0957" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">你已经熟悉<a class="ae lf" href="https://steventure.hashnode.dev/the-data-sciencemachine-learning-workflow-ckdslw7ps00egb6s1gla942wv" rel="noopener ugc nofollow" target="_blank">数据科学/机器学习工作流程</a>。</li></ul><h2 id="8084" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">熊猫</h2><p id="dcf2" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">Pandas是一个非凡的数据分析工具，旨在成为任何语言中最强大、最灵活的开源数据分析/操作工具。让我们来看看熊猫的能力:</p><h2 id="1f42" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">数据采集</h2><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="2541" class="lu lv it mt b gy mx my l mz na">import numpy as np<br/>import pandas as pd<br/>from sklearn import datasets</span><span id="a397" class="lu lv it mt b gy nb my l mz na">iris_data = datasets.load_iris()</span><span id="d0bf" class="lu lv it mt b gy nb my l mz na">iris_data.keys()</span><span id="53f7" class="lu lv it mt b gy nb my l mz na"># THIS IS THE OUTPUT FOR 'iris_data.keys()'<br/>dict_keys(['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names', 'filename'])</span><span id="9b18" class="lu lv it mt b gy nb my l mz na">iris_data['target_names']</span><span id="208e" class="lu lv it mt b gy nb my l mz na"># THIS IS THE OUTPUT FOR 'iris_data['target_names']'<br/>array(['setosa', 'versicolor', 'virginica'], dtype='&lt;U10')</span><span id="d88a" class="lu lv it mt b gy nb my l mz na">df_data = pd.DataFrame(iris_data['data'], columns=iris_data['feature_names'])</span><span id="f0f4" class="lu lv it mt b gy nb my l mz na">df_target = pd.DataFrame(iris_data['target'], columns=['species'])</span><span id="d985" class="lu lv it mt b gy nb my l mz na">df = pd.concat([df_data, df_target], axis=1)</span><span id="96aa" class="lu lv it mt b gy nb my l mz na">df</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/86ee429e9a9110ae3f71e21d63b94e32.png" data-original-src="https://miro.medium.com/v2/format:webp/1*PYH5CGrTdRfCokgoy3VNYQ.png"/></div></figure><p id="4d6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的单元格中，您会注意到我已经使用Scikit-learn 导入了经典数据集<a class="ae lf" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_iris.html" rel="noopener ugc nofollow" target="_blank">Iris数据集(我们稍后将探讨Scikit-learn)。然后，我将数据传递到Pandas DataFrame中，同时还包括列标题。我还创建了另一个数据帧来包含鸢尾物种，它们的代码分别为<code class="fe nd ne nf mt b">0</code>代表<code class="fe nd ne nf mt b">setosa</code>、<code class="fe nd ne nf mt b">1</code>代表<code class="fe nd ne nf mt b">versicolor</code>、<code class="fe nd ne nf mt b">2</code>代表<code class="fe nd ne nf mt b">virginica</code>。最后一步是将两个数据帧连接成一个数据帧。</a></p><p id="15bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当处理可以放在一台机器上的数据时，Pandas是终极工具。它更像Excel，但却是类固醇。就像Excel一样，操作的基本单位是行和列，其中数据列是系列，系列的集合是数据帧。</p><h2 id="a30e" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">探索性数据分析</h2><p id="c07f" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">让我们执行一些常见的操作；</p><h2 id="0774" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">数据切片</h2><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="268b" class="lu lv it mt b gy mx my l mz na">df.head()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/c451d7a932c29309715c67dc892fa242.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mmv7qb3GHLAqBOwQLEXEjw.png"/></div></figure><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="fbef" class="lu lv it mt b gy mx my l mz na">df['sepal length (cm)']</span><span id="5387" class="lu lv it mt b gy nb my l mz na"># OUTPUT<br/>0      5.1<br/>1      4.9<br/>2      4.7<br/>3      4.6<br/>4      5.0<br/>      ... <br/>145    6.7<br/>146    6.3<br/>147    6.5<br/>148    6.2<br/>149    5.9<br/>Name: sepal length (cm), Length: 150, dtype: float64</span></pre><p id="6279" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf mt b">.head()</code>命令将返回前5行。第二个命令是通过引用列名从数据帧中选择一个列。</p><p id="7f1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行<a class="ae lf" href="https://whatis.techtarget.com/definition/slice-and-dice" rel="noopener ugc nofollow" target="_blank">数据切片</a>的另一种方式是使用<code class="fe nd ne nf mt b">loc</code>和<code class="fe nd ne nf mt b">iloc</code>方法。</p><p id="5f8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使用<code class="fe nd ne nf mt b">iloc</code>，我们必须指定我们想要通过它们的整数索引进行切片的行和列，而对于<code class="fe nd ne nf mt b">loc</code>，我们必须指定我们想要过滤掉的列的名称。</p><p id="fed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf mt b">loc</code>从索引中获取带有特定标签的行(或列)<strong class="js iu">，而<code class="fe nd ne nf mt b">iloc</code>获取索引中特定位置</strong>的行(或列)位置<strong class="js iu">(因此它只接受整数)</strong></p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="659c" class="lu lv it mt b gy mx my l mz na">df.iloc[:3, :2]</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/9851569c822c4e6025e6dd1e9fa88562.png" data-original-src="https://miro.medium.com/v2/format:webp/1*rcbznerDzepxjts2M8AFsw.png"/></div></figure><p id="6726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe nd ne nf mt b">.iloc</code>，我们只选择了数据帧的前3行和前2列。让我们试试更难的；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="92b2" class="lu lv it mt b gy mx my l mz na">df.loc[:3, [x for x in df.columns if 'width' in x]]</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/722818b077ba41b567904009e5a18801.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Ju9QqOPrZiDCw7JKfvWpeg.png"/></div></figure><p id="ad0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们遍历<code class="fe nd ne nf mt b">df.columns</code>，它将返回一个列列表，并且只选择名称中带有“width”的列。这个看似很小的函数在用于大得多的数据集时是一个非常强大的工具。</p><p id="48e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们使用另一种方法，通过指定要满足的条件来选择一部分数据。我们将查看<code class="fe nd ne nf mt b">species</code>的唯一列表，然后从中选择一个。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="c594" class="lu lv it mt b gy mx my l mz na"># Listing all the available unique classes</span><span id="8f97" class="lu lv it mt b gy nb my l mz na">df['species'].unique()</span><span id="2322" class="lu lv it mt b gy nb my l mz na"># OUTPUT FOR 'df['species'].unique()'<br/>array([0, 1, 2])</span><span id="7093" class="lu lv it mt b gy nb my l mz na">df[df['species'] == 2]</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/653b9a48a01103625884a9e20194dc0c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CyFoa_Qh0CHLz_g9sLgw8g.png"/></div></figure><p id="48fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们的数据帧只包含了几行<code class="fe nd ne nf mt b">Iris-virginica</code>物种(用2表示)。事实上，大小是50，而不是原来的150行。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="3781" class="lu lv it mt b gy mx my l mz na">df.count()</span><span id="fb33" class="lu lv it mt b gy nb my l mz na"># OUTPUT<br/>sepal length (cm)    150<br/>sepal width (cm)     150<br/>petal length (cm)    150<br/>petal width (cm)     150<br/>species              150<br/>dtype: int64</span><span id="305d" class="lu lv it mt b gy nb my l mz na">df[df['species'] == 2].count()</span><span id="2f5b" class="lu lv it mt b gy nb my l mz na"># OUTPUT<br/>sepal length (cm)    50<br/>sepal width (cm)     50<br/>petal length (cm)    50<br/>petal width (cm)     50<br/>species              50<br/>dtype: int64</span></pre><p id="d1a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还会注意到左边的索引保留了原始的行号，这可能会在以后引起问题。因此，我们可以将它保存为一个新的数据帧，并重置索引。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="85fb" class="lu lv it mt b gy mx my l mz na">virginica = df[df['species'] == 2].reset_index(drop=True)<br/>virginica</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/def3766d2e03a703a7bb9e6d0bb847a1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0bB21ky9aIxhYXA2Q7iT5Q.png"/></div></figure><p id="cb76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过指定一个条件来选择这个新的数据帧。现在让我们添加更多的条件。我们将在原始数据帧上指定两个条件。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="381f" class="lu lv it mt b gy mx my l mz na">df[(df['species'] == 2) &amp; (df['petal width (cm)'] &gt; 2.2)]</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/e55bae79fe7cc230e357bea9618f22c1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*3ciMvSR5nqUTFC1BXF0jDQ.png"/></div></figure><p id="9177" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为练习，您可以自己重置这个新数据帧的索引。</p><h2 id="a2b6" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">描述统计学</h2><p id="d8b6" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">现在让我们试着从我们的数据集中获取一些描述性统计数据；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="ff9b" class="lu lv it mt b gy mx my l mz na">df.describe()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/e84c209b9d25794be086b5d16b1e6f46.png" data-original-src="https://miro.medium.com/v2/format:webp/1*y6rATRzE5sgCRzaZu0bhTg.png"/></div></figure><p id="5d34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe nd ne nf mt b">.describe()</code>方法，我得到了每一列的描述性统计的细目分类。我可以发现所有列的计数，并且很容易注意到是否有丢失的值。我可以看到平均值、标准差、中值、众数，还可以注意到数据是否有偏差。如果我想要更详细的信息，我也可以传递我自己的百分位数；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="4a5b" class="lu lv it mt b gy mx my l mz na"># Passing in custom percentiles</span><span id="8206" class="lu lv it mt b gy nb my l mz na">df.describe(percentiles=[.2, .4, .8, .9, .95])</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/7efdc0413380eef49e36dd802d229683.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fzjLexzXgT2DvVbb3DXx-A.png"/></div></figure><p id="cb6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们通过调用DataFrame上的<code class="fe nd ne nf mt b">.corr()</code>方法来检查特性之间是否有任何相关性；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="288f" class="lu lv it mt b gy mx my l mz na"># Checking for correlations between the features</span><span id="4edf" class="lu lv it mt b gy nb my l mz na">df.corr()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/a05c00bcc887e93410f5c3aae8bc7a22.png" data-original-src="https://miro.medium.com/v2/format:webp/1*lxSRxGH7G9w91CxrqZ22Ew.png"/></div></figure><p id="ebbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现令人惊讶的是<code class="fe nd ne nf mt b">sepal length</code>和<code class="fe nd ne nf mt b">sepal width</code>的相关性最低，得分为<strong class="js iu"> -0.117570 </strong>。</p><p id="db50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经了解了如何选择数据帧的子集以及如何汇总其统计数据，让我们尝试并直观地检查我们的数据。</p><h2 id="ed54" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">数据可视化</h2><p id="5a4e" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">你可能想知道为什么我们还要为可视化而烦恼。事实是，数据可视化使数据更容易被人脑理解，我们可以通过执行视觉检查来轻松检测数据中的趋势、模式和异常值。</p><p id="4a9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经理解了可视化的重要性，让我们来看看在这方面做得最好的两个Python库。</p><h2 id="3154" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">Matplotlib库</h2><p id="7b9e" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">Matplotlib是所有Python绘图库的始祖。它最初是为了模仿MATLAB的绘图功能而创建的，后来它凭借自己的力量成长为一个巨人。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="fe2d" class="lu lv it mt b gy mx my l mz na">import matplotlib.pyplot as plt<br/>plt.style.use('ggplot')</span></pre><p id="8fb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一行导入Matplotlib，而第二行将我们的绘图风格设置为类似于<a class="ae lf" href="https://ggplot2.tidyverse.org/reference/ggplot.html" rel="noopener ugc nofollow" target="_blank"> R的ggplot库</a>。</p><p id="e3ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们在常规数据集上使用以下代码生成第一个图表；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="a0d5" class="lu lv it mt b gy mx my l mz na"># Plotting an histogram of the petal width feature</span><span id="b7c8" class="lu lv it mt b gy nb my l mz na">plt.figure(figsize=(6,4))<br/>plt.hist(df['petal width (cm)'], color='black')<br/>plt.xlabel('Width', fontsize=12)<br/>plt.ylabel('Count', fontsize=12)<br/>plt.title('Iris Petal Width', fontsize=14,)</span><span id="9bf0" class="lu lv it mt b gy nb my l mz na">Text(0.5, 1.0, 'Iris Petal Width')</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/e58b10531d8f2fa2dfba1db9b579954e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0JchhQ5tl5rGdJyNiZG9rw.png"/></div></figure><p id="5274" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们一行一行地检查代码:</p><ul class=""><li id="61e8" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">第一行创建一个宽6英寸、高4英寸的绘图空间。</li><li id="852a" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">第二行创建了花瓣宽度列的直方图，我们还将条形颜色设置为黑色。</li><li id="a1fe" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">我们分别用“宽度”和“数量”标记x和y轴，同时将字体大小设置为12。</li><li id="b473" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">最后一行创建标题“鸢尾花瓣宽度”，字体大小为14。</li></ul><p id="75bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有这些给了我们一个很好的花瓣宽度数据直方图！</p><p id="010e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们对此进行扩展，并为Iris数据集的每一列生成直方图；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="31af" class="lu lv it mt b gy mx my l mz na"># Plotting subplots of the 4 features (NOTE: THIS IS NOT IDEAL!)</span><span id="e398" class="lu lv it mt b gy nb my l mz na">fig, ax = plt.subplots(2, 2, figsize=(6,4))</span><span id="5f16" class="lu lv it mt b gy nb my l mz na">ax[0][0].hist(df['petal width (cm)'], color='black')<br/>ax[0][0].set_xlabel('Width', fontsize=12)<br/>ax[0][0].set_ylabel('Count', fontsize=12)<br/>ax[0][0].set_title("Iris Petal Width", fontsize=14)</span><span id="8e03" class="lu lv it mt b gy nb my l mz na">ax[0][1].hist(df['petal length (cm)'], color='black')<br/>ax[0][1].set_xlabel('Length', fontsize=12)<br/>ax[0][1].set_ylabel('Count', fontsize=12)<br/>ax[0][1].set_title("Iris Petal Length", fontsize=14)</span><span id="5af7" class="lu lv it mt b gy nb my l mz na">ax[1][0].hist(df['sepal width (cm)'], color='black')<br/>ax[1][0].set_xlabel('Width', fontsize=12)<br/>ax[1][0].set_ylabel('Count', fontsize=12)<br/>ax[1][0].set_title("Iris Sepal Width", fontsize=14)</span><span id="f543" class="lu lv it mt b gy nb my l mz na">ax[1][1].hist(df['sepal length (cm)'], color='black')<br/>ax[1][1].set_xlabel('Length', fontsize=12)<br/>ax[1][1].set_ylabel('Count', fontsize=12)<br/>ax[1][1].set_title("Iris Sepal Length", fontsize=14)</span><span id="8869" class="lu lv it mt b gy nb my l mz na">plt.tight_layout()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/f1f9b57ff9e163ac146bca324073c886.png" data-original-src="https://miro.medium.com/v2/format:webp/1*evN11fg874jXtmP9hnIV2A.png"/></div></figure><p id="9982" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很明显，这不是最有效的方法，但是演示Matplotlib的工作方式非常有用。在前面的例子中，这几乎是不言自明的，除了我们现在有四个可以通过ax数组访问的子情节。另一个附加功能是<code class="fe nd ne nf mt b">plt.tight_layout()</code>调用，我们很好地自动分隔了我们的支线剧情以避免拥挤。</p><p id="228f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们来看看Matplotlib中可用的其他类型的绘图。一个是<strong class="js iu">散点图</strong>。这里我们绘制了花瓣宽度与花瓣长度的关系；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="e14c" class="lu lv it mt b gy mx my l mz na"># A scatterplot of the Petal Width against the Petal Length</span><span id="1a42" class="lu lv it mt b gy nb my l mz na">plt.scatter(df['petal width (cm)'], df['petal length (cm)'], color='green')<br/>plt.xlabel('Petal Width')<br/>plt.ylabel('Petal Length')<br/>plt.title('Petal Scatterplot')</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/6613bf59544b01f1602bb0504a23d0b1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*aD5nh26lpeBQDXrOAT3sAg.png"/></div></figure><p id="3b50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个图是简单的线形图。这是花瓣长度的线图；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="ffc6" class="lu lv it mt b gy mx my l mz na"># A simple line plot of the Petal Length</span><span id="4095" class="lu lv it mt b gy nb my l mz na">plt.figure(figsize=(6,6))<br/>plt.plot(df['petal length (cm)'], color='blue')<br/>plt.xlabel('Specimen Number')<br/>plt.ylabel('Petal Length')<br/>plt.title('Petal Length Plot')</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/40e337cadc35fc8a18b72d3a1c5fc802.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pVxhQIB_hO9lv1RI8u2KEA.png"/></div></figure><p id="b1e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在这里看到，在这个图中有三个不同的集群，大概是每一种物种。这告诉我们，如果我们建立分类器模型，花瓣长度很可能是表示物种的有用特征。</p><p id="1971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们来看条形图。在这里，我们将为三种鸢尾的每个特征的平均值绘制一个条形图。此外，我们将使它成为一个堆叠的条形图，以增加趣味。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="dd1e" class="lu lv it mt b gy mx my l mz na"># A Bar-chart of the mean of each feature for the 3 classes of irises</span><span id="bd25" class="lu lv it mt b gy nb my l mz na">fig, ax = plt.subplots(figsize=(6,6))<br/>labels = [x for x in df.columns if 'length' in x or 'width' in x]</span><span id="35e6" class="lu lv it mt b gy nb my l mz na">ver_y = [df[df['species'] == 0][x].mean() for x in labels]<br/>vir_y = [df[df['species'] == 1][x].mean() for x in labels]<br/>set_y = [df[df['species'] == 2][x].mean() for x in labels]<br/>x = np.arange(len(labels))</span><span id="82a9" class="lu lv it mt b gy nb my l mz na">plt.bar(x, vir_y, bottom=set_y, color='darkgrey')<br/>plt.bar(x, set_y, bottom=ver_y, color='white')<br/>plt.bar(x, ver_y, color='black')</span><span id="ca0a" class="lu lv it mt b gy nb my l mz na">plt.xticks(x)<br/>ax.set_xticklabels(labels, rotation=-70, fontsize=12);<br/>plt.title('Mean Measurement by Class')<br/>plt.legend(['Setosa', 'Versicolor', 'Virginica'])</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/66a2f57c4c3171cb86528596a236f76b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*P3nLaefPmc7mUudE2GPjWg.png"/></div></figure><p id="98e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了生成条形图，我们需要将x和y值传入<code class="fe nd ne nf mt b">.bar()</code>。这里，x值是我们感兴趣的特征长度的数组。我们还调用了，并传入了要显示的首选列名。</p><p id="bea9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了正确排列x标签，我们还调整了标签的间距。这就是为什么我们将xticks设置为x加上bar_width大小的一半。</p><p id="4051" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">y值来自每个物种的每个特征的平均值，我们通过调用<code class="fe nd ne nf mt b">.bar()</code>来调用每个特征。我们还为每个系列传入一个底部参数，以设置其下系列的最小y点和最大y点。这就是产生堆叠棒线的原因。</p><p id="2b29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们添加了一个描述每个系列的图例。这些名称按照条形从上到下的排列顺序插入到图例列表中。</p><h2 id="0097" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">锡伯恩图书馆</h2><p id="6852" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">我们要看的下一个可视化库是Seaborn。Seaborn构建于Matplotlib之上，它是为统计可视化而构建的。这意味着它是为结构化数据(行和列中的数据)量身定制的。</p><p id="444c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们领略一下Seaborn的力量。只用两行代码，我们会得到如下结果:</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="9def" class="lu lv it mt b gy mx my l mz na">import seaborn as sns</span><span id="dea9" class="lu lv it mt b gy nb my l mz na">sns.pairplot(df, hue='species')</span><span id="2dfb" class="lu lv it mt b gy nb my l mz na">&lt;seaborn.axisgrid.PairGrid at 0x28fe2953430&gt;</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/6d5f8190e72f0244bb8e3f91df2dedb8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*p8QBxKlO8g9S4GujdVI6fA.png"/></div></figure><p id="bd90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">刚刚经历了(我希望不是)理解Matplotlib的复杂性的艰难时期，你会欣赏我们生成这个图的简单和容易。我们所有的功能都是用两行代码创建并正确标记的。</p><p id="3629" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会想，当Seaborn如此容易使用时，为什么还要使用Matplotlib。正如我前面说过的，Seaborn是建立在Matplotlib之上的，为了修改，有时你必须将Seaborn的功能与Matplotlib的功能结合起来。让我们尝试下一个可视化；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="63c1" class="lu lv it mt b gy mx my l mz na">sns.set(style='white', palette='muted')<br/>features = [col for col in df.columns if '(cm)' in col]</span><span id="20ba" class="lu lv it mt b gy nb my l mz na">plt.figure(figsize=(7, 7))<br/>for n in range(len(features)):<br/>    plt.subplot(2, 2, n+1)<br/>    sns.violinplot(x='species', y=features[n], data=df)<br/>    <br/>plt.suptitle('Violin Plots', fontsize=16)<br/>plt.tight_layout()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/0eece70c1569f784e1bb3e3ce8fca99a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*mUoevtCFtqwss-QudlRLOg.png"/></div></figure><p id="417a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经为四个特征中的每一个生成了一个小提琴图。小提琴图显示了特征的分布。比如你很容易看到<code class="fe nd ne nf mt b">setosa</code> <strong class="js iu"> (0) </strong>的花瓣长度在1厘米到2厘米之间高度聚集，而<code class="fe nd ne nf mt b">virginica</code> <strong class="js iu"> (2) </strong>则分散得多，从近4厘米到超过7厘米。</p><p id="008c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还会注意到，我们使用了许多与构建matplotlib图时相同的代码。主要区别是增加了<code class="fe nd ne nf mt b">sns.plot()</code>呼叫，取代了之前的<code class="fe nd ne nf mt b">plt.plot()</code>和<code class="fe nd ne nf mt b">ax.plot()</code>呼叫。</p><p id="c396" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以用<a class="ae lf" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>和<a class="ae lf" href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.html" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>创建各种各样的图形，我强烈推荐你深入研究这两个库的文档。</p><p id="5c55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里讨论的方法应该对帮助您可视化和理解后续数据大有帮助。</p><h2 id="f60a" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">数据准备</h2><p id="88b8" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">了解了如何检查和可视化我们的数据，下一步是学习如何处理和操作我们的数据。在这里，我们将使用熊猫的<code class="fe nd ne nf mt b">map()</code>、<code class="fe nd ne nf mt b">apply()</code>、<code class="fe nd ne nf mt b">applymap()</code>和<code class="fe nd ne nf mt b">groupby()</code>功能。它们在处理数据方面非常有用，对于要素工程(创建新要素的艺术)也非常有用。</p><h2 id="128a" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">地图</h2><p id="bfc5" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated"><code class="fe nd ne nf mt b">map</code>函数只对series有效，所以我们将使用它来转换DataFrame的一列，这是一个熊猫系列。假设我们已经厌倦了使用物种代码？我们可以使用带有Python字典的<code class="fe nd ne nf mt b">map</code>来实现这一点。键将是代码数字，而值将是替换</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="0c66" class="lu lv it mt b gy mx my l mz na"># Replacing each of the unique Iris types</span><span id="5dc5" class="lu lv it mt b gy nb my l mz na">dict_map = {0: 'SET', <br/>            1: 'VIR', <br/>            2: 'VER'}<br/>df['species'] = df['species'].map(dict_map)<br/>df</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/4222f06177da5a1233c747d0defc57c1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*G6C8V74jke7LFRkqKia-fA.png"/></div></figure><p id="f033" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们已经传入了字典，<code class="fe nd ne nf mt b">map</code>函数遍历了我们的整个数据，在遇到代码编号时，将它们替换为代码编号。</p><p id="fd81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们为我们的列选择了另一个名称，比如说<code class="fe nd ne nf mt b">better names</code>，我们将有一个名为<code class="fe nd ne nf mt b">better names</code>的新列追加到我们的数据帧中，并且我们仍然有带有新<code class="fe nd ne nf mt b">better names</code>列的<code class="fe nd ne nf mt b">species</code>列。</p><p id="b368" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以将一个序列或一个函数传递给我们的<code class="fe nd ne nf mt b">map</code>函数，但是我们也可以使用<code class="fe nd ne nf mt b">apply</code>函数来完成这个任务(我们很快就会看到)。使<code class="fe nd ne nf mt b">map</code>函数与众不同的是能够传入字典，因此<code class="fe nd ne nf mt b">map</code>成为大多数单列转换的首选函数。</p><h2 id="058b" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">应用</h2><p id="895c" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">与<code class="fe nd ne nf mt b">map</code>不同，<code class="fe nd ne nf mt b">apply</code>既适用于系列(单列)，也适用于数据框架(系列的集合)。现在，让我们使用花瓣宽度的平均值(1.3)作为决定因素，创建一个基于花瓣宽度的新列。</p><p id="31ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe nd ne nf mt b">petal width</code>大于平均值，我们将<code class="fe nd ne nf mt b">wide petal</code>设置为1，而如果它小于平均值，我们将<code class="fe nd ne nf mt b">wide petal</code>设置为0。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="c754" class="lu lv it mt b gy mx my l mz na"># Creating a new feature via petal width</span><span id="81d1" class="lu lv it mt b gy nb my l mz na">df['wide petal'] = df['petal width (cm)'].apply(lambda x: 1 if x&gt;=1.3 else 0)<br/>df</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/5d6f479e464ea54ea571b7982e2b2dc2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9YQyS7RF4wfFTP_u05bcGg.png"/></div></figure><p id="671c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们对<code class="fe nd ne nf mt b">petal width</code>列运行了<code class="fe nd ne nf mt b">apply</code>，返回了<code class="fe nd ne nf mt b">wide petal</code>列中的相应值。<code class="fe nd ne nf mt b">apply</code>函数通过遍历<code class="fe nd ne nf mt b">petal width</code>列的每个值来工作。如果该值大于或等于1.3，则该函数返回1，否则返回0。</p><p id="c434" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种类型的转换是机器学习中相当常见的特征工程技术，因此熟悉如何执行它是很好的。</p><p id="05b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看如何在整个数据框架中使用apply，而不仅仅是在单个系列上。我们将基于花瓣区域创建一个新列。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="8039" class="lu lv it mt b gy mx my l mz na"># creating a new column via petal length &amp; petal width</span><span id="2033" class="lu lv it mt b gy nb my l mz na">df['petal area'] = df.apply(lambda row: row['petal width (cm)'] * row['petal length (cm)'], axis=1)<br/>df</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/80bc7cb19e799b4ec27a501892002e0e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*XjQq9igSQFq7KttLWmAzYA.png"/></div></figure><p id="a401" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们在这里对整个数据帧调用了<code class="fe nd ne nf mt b">apply</code>，我们还传入了一个新的参数<code class="fe nd ne nf mt b">axis=1</code>，以便按顺序选择列并按行应用函数。如果我们将<code class="fe nd ne nf mt b">axis</code>设置为0，那么函数将按列操作并抛出一个错误。</p><p id="770e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，对于数据帧中的每一行，我们将它的<code class="fe nd ne nf mt b">petal width</code>乘以它的<code class="fe nd ne nf mt b">petal length</code>，从而创建一个结果序列<code class="fe nd ne nf mt b">wide petal</code>。</p><p id="d151" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种能力和灵活性使得Pandas成为数据操作不可或缺的工具。</p><h2 id="e073" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">应用地图</h2><p id="72bf" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">当我们想要操作数据帧中的所有数据单元格时，可以使用<code class="fe nd ne nf mt b">applymap</code>函数。让我们来看看这个。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="2111" class="lu lv it mt b gy mx my l mz na"># Getting the log values of all the data cells</span><span id="de4e" class="lu lv it mt b gy nb my l mz na">df.applymap(lambda x: np.log(x) if isinstance(x, float) else x)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/b056b144c4d14aa0c31f8b351816723f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*_CYCHRAdu7Vq4e5Z0pzJ7g.png"/></div></figure><p id="0893" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们对整个数据执行了一次对数转换(使用Numpy ),规定的条件是数据单元必须属于一个<strong class="js iu"> float </strong>实例。</p><p id="9f39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf mt b">applymap</code>的常见应用包括基于满足多个条件来转换或格式化每个单元格。</p><h2 id="6a09" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">分组依据</h2><p id="e509" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">现在，让我们来看看一个非常有用的工具，但是一个熊猫新用户难以理解的工具。为了说明它的通用功能，我们将研究一些例子。</p><p id="792b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf mt b">groupby</code>函数确实如其名:它根据您选择的一个或几个类对数据进行分组。让我们试试第一个例子；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="372e" class="lu lv it mt b gy mx my l mz na">df.groupby('species').mean()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/8c1f24df8594663f4aa1cb4221df494b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zlzKVK3LtbiS-4yfMmQLUg.png"/></div></figure><p id="07e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，每个物种的数据被划分，并提供了每个特征的平均值。现在让我们迈出更大的一步，获得每个物种的描述性统计数据；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="6792" class="lu lv it mt b gy mx my l mz na"># T for transpose</span><span id="6ba0" class="lu lv it mt b gy nb my l mz na">df.groupby('species').describe().T</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/29556637cfaa90df3a7fd0200e5ab136.png" data-original-src="https://miro.medium.com/v2/format:webp/1*tjIk5clQpzZy_PiPEApPUA.png"/></div></figure><p id="bc4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了总的统计细目。当视觉化时，我们注意到有一些界限将每个物种的<code class="fe nd ne nf mt b">petal width</code>和<code class="fe nd ne nf mt b">petal length</code>分开。因此，让我们探索如何使用<code class="fe nd ne nf mt b">groupby</code>来看到这一点；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="2954" class="lu lv it mt b gy mx my l mz na"># Group the classes by the petal width they are associated with</span><span id="6552" class="lu lv it mt b gy nb my l mz na">df.groupby('petal width (cm)')['species'].unique().to_frame()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/2c83d40afac155cf96f21bea7c6bd7fa.png" data-original-src="https://miro.medium.com/v2/format:webp/1*S4bjG_BC666Nrkf7TnMzkw.png"/></div></figure><p id="c1f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以在这里，我们通过<code class="fe nd ne nf mt b">petal width</code>将<code class="fe nd ne nf mt b">species</code>分组，我们可以尝试的另一个步骤(作为练习)是使用<code class="fe nd ne nf mt b">apply</code>将数据划分到括号中。</p><p id="07ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们来看看一个自定义的聚合函数。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="11ba" class="lu lv it mt b gy mx my l mz na">df.groupby('species')['petal width (cm)'].agg(lambda x: x.max() - x.min())</span><span id="16d1" class="lu lv it mt b gy nb my l mz na"># OUTPUT<br/>species<br/>SET    0.5<br/>VER    1.1<br/>VIR    0.8<br/>Name: petal width (cm), dtype: float64</span></pre><p id="b080" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们将<code class="fe nd ne nf mt b">petal width</code>按<code class="fe nd ne nf mt b">species</code>分组，并使用一个<code class="fe nd ne nf mt b">lambda</code>函数来获得最大值<code class="fe nd ne nf mt b">petal width</code>和最小值<code class="fe nd ne nf mt b">petal width</code>之间的差值。</p><p id="add1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们已经触及了<code class="fe nd ne nf mt b">groupby</code>和其他熊猫函数的表面。我非常鼓励你去查阅文献资料，了解更多关于熊猫的工作原理。</p><h2 id="c529" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">建模和评估</h2><p id="cd26" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">既然您已经对如何操作和准备数据有了坚实的理解，我们将进入下一步，即建模。</p><p id="9b86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们将讨论用于机器学习的主要Python库。</p><h2 id="2313" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">统计模型</h2><p id="38b7" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">Statsmodels是一个Python包，用于探索数据、估计模型和运行统计测试。在这里，我们将使用它来建立一个简单的线性回归模型，用于描述物种<code class="fe nd ne nf mt b">setosa</code>的<code class="fe nd ne nf mt b">sepal length</code>和<code class="fe nd ne nf mt b">sepal width</code>之间的关系。</p><p id="6510" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们创建一个散点图来直观地观察这种关系；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="dc91" class="lu lv it mt b gy mx my l mz na">plt.figure(figsize=(7,7))<br/>plt.scatter(df['sepal width (cm)'][:50], df['sepal length (cm)'][:50])<br/>plt.xlabel('Sepal Width')<br/>plt.ylabel('Sepal Length')<br/>plt.title('Setosa Sepal Width vs. Length', fontsize=14, y=1.02)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/ff7d98fd148208906cb2622a650c5c9b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*IblJQRzR8CKA-LHNnH5x-A.png"/></div></figure><p id="e267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到这两个特征之间存在正线性关系。萼片宽度随着萼片长度的增加而增加。下一步是使用<code class="fe nd ne nf mt b">statsmodels</code>对数据进行线性回归，以估计关系的强度。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="94fc" class="lu lv it mt b gy mx my l mz na">import statsmodels.api as sm</span><span id="2a16" class="lu lv it mt b gy nb my l mz na">y = df['sepal length (cm)'][:50]<br/>x = df['sepal width (cm)'][:50]<br/>X = sm.add_constant(x)</span><span id="f6dd" class="lu lv it mt b gy nb my l mz na">results = sm.OLS(y, X).fit()<br/>results.summary()</span></pre><p id="6884" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">OLS回归结果部。变量:萼片长度(cm) R平方:0.551模型:OLS调整R平方:0.542方法:最小二乘F统计:58.99日期:2020年8月18日星期二概率(F统计):6.71e-10时间:18:57:12对数似然:1.7341数量观察:50 AIC: 0.5319 Df残差:48 BIC: 4.356 Df模型:1协方差类型:非稳健协№34.3</p><p id="f05f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">警告:<br/> [1]标准误差假设误差的协方差矩阵是正确指定的。</p><p id="405d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们简单回归模型的结果。由于这是一个线性回归，模型采用<code class="fe nd ne nf mt b">Y = B0+ B1X</code>的格式，其中<code class="fe nd ne nf mt b">B0</code>是常数(或截距)，而<code class="fe nd ne nf mt b">B1</code>是回归系数。在这里，公式应该是<code class="fe nd ne nf mt b">Sepal Length = 2.6447 + 0.6909 * Sepal Width</code>。我们还可以看到，该模型的<code class="fe nd ne nf mt b">R2</code>是相当可观的0.558，而<code class="fe nd ne nf mt b">p-value</code>(Prob)非常显著。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="e55b" class="lu lv it mt b gy mx my l mz na">plt.figure(figsize=(7,7))<br/>plt.plot(x, results.fittedvalues, label='regression line', color='r')<br/>plt.scatter(x, y, label='data point')<br/>plt.ylabel('Sepal Length (cm)')<br/>plt.xlabel('Sepal Width (cm)')<br/>plt.title('Setosa Sepal Width vs. Sepal Length', fontsize=14,)<br/>plt.legend(loc=0)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/394c5ce05a0e90293c4ab732e48ff4b7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Z7kxCGVVVbkDCTmH_j_aMw.png"/></div></figure><p id="ed6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">绘制结果。fittedvalues从我们的回归中获得结果回归线。</p><p id="676a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">statsmodels包中还有其他几个统计函数和测试，但这是目前最常用的测试。</p><p id="7b9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们转到Python机器学习包的核心部分；所有欢呼sci kit-学习！</p><h2 id="2681" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">sci kit-学习</h2><p id="bbbd" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">Scikit-learn是一个非常棒的Python库，拥有出色的文档，旨在为数十种算法提供一致的API。它建立在Python科学堆栈的核心组件之上，本身也是，Python科学堆栈包括NumPy、SciPy、Pandas和Matplotlib。以下是scikit-learn涵盖的一些领域:分类、回归、聚类、降维、模型选择和预处理。</p><p id="e2b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们用虹膜数据构建一个分类器，然后我们看看如何使用scikit-learn的工具来评估我们的模型:</p><ol class=""><li id="2852" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ng lm ln lo bi translated">数据应分为预测值和目标值；预测值(独立变量)应该是一个数字<code class="fe nd ne nf mt b">n * m</code>矩阵X，目标值(因变量)y，一个<code class="fe nd ne nf mt b">n * 1</code>向量。</li><li id="df7b" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ng lm ln lo bi translated">然后这些被传递到所选分类器的<code class="fe nd ne nf mt b">.fit()</code>方法中。</li><li id="45fb" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ng lm ln lo bi translated">然后我们可以使用<code class="fe nd ne nf mt b">.predict()</code>方法对新数据进行预测。</li></ol><p id="291e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是使用scikit-learn的最大好处:每个分类器尽可能利用相同的方法。这使得它们的进出交换变得轻而易举。我们将很快看到这一点。</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="d916" class="lu lv it mt b gy mx my l mz na">from sklearn.model_selection import train_test_split as tts</span><span id="4fef" class="lu lv it mt b gy nb my l mz na">y = df.pop('species')<br/>X_train, X_test, y_train, y_test = tts(df, y, test_size=.3)</span><span id="5802" class="lu lv it mt b gy nb my l mz na">from sklearn.ensemble import RandomForestClassifier</span><span id="ce89" class="lu lv it mt b gy nb my l mz na">clf = RandomForestClassifier(max_depth=5, n_estimators=10)</span><span id="f295" class="lu lv it mt b gy nb my l mz na">clf.fit(X_train, y_train)<br/>y_pred = clf.predict(X_test)</span><span id="954e" class="lu lv it mt b gy nb my l mz na">rf = pd.DataFrame(list(zip(y_pred, y_test)), columns=['predicted', 'actual'])<br/>rf['correct'] = rf.apply(lambda x: 1 if x.predicted == x.actual else 0, axis=1)<br/>rf</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/667f8248b9dbf7236a2792876768d7a5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EN0sUb1BVIM3F66zW54EBw.png"/></div></figure><p id="b82a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们运行这行代码；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="63c3" class="lu lv it mt b gy mx my l mz na"># accuracy percentage</span><span id="24fb" class="lu lv it mt b gy nb my l mz na">rf['correct'].sum() / rf['correct'].count()</span><span id="392c" class="lu lv it mt b gy nb my l mz na"># OUTPUT<br/>0.9333333333333333</span></pre><p id="d5b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前面的代码行中，我们在iris数据集上构建、训练和测试了一个准确率为93%的分类器。现在让我们一个接一个地经历每一个步骤；</p><ul class=""><li id="d232" class="lg lh it js b jt ju jx jy kb li kf lj kj lk kn ll lm ln lo bi translated">我们从scikit-learn导入了<code class="fe nd ne nf mt b">train_test_split</code>，它被简化为<code class="fe nd ne nf mt b">sklearn</code>import语句。<code class="fe nd ne nf mt b">train_test_split</code>是一个将数据分成训练集和测试集的模块。这是一个非常重要的建模实践。我们用训练集训练我们的模型，并用测试集验证我们的模型的性能。</li><li id="8c1a" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">在第二行中，我们将目标变量<code class="fe nd ne nf mt b">species</code>与预测变量分开。(在数学语言中，我们创建了X矩阵和y向量)</li><li id="b359" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">然后我们使用<code class="fe nd ne nf mt b">train_test_split</code>来分割数据。正如您所注意到的，我们将<code class="fe nd ne nf mt b">test_size</code>设置为0.3，这意味着测试集应该是整个数据的30%。<code class="fe nd ne nf mt b">train_test_split</code>模块也打乱了我们的数据，因为订单可能包含我们不想让模型知道的偏差。</li><li id="1afb" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">移动到下一个单元格，我们从<code class="fe nd ne nf mt b">sklearn</code>模块导入了一个随机森林分类器。我们在下一行中使用10棵决策树实例化了我们的森林分类器，每棵树的最大分裂深度为5，以避免过度拟合。</li><li id="bf4f" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">接下来，使用训练数据来拟合我们的模型。在训练了我们的分类器之后，我们在分类器上调用了predict方法，并传入了我们的测试数据。请记住，测试数据是分类器尚未看到的数据。</li><li id="6c36" class="lg lh it js b jt lp jx lq kb lr kf ls kj lt kn ll lm ln lo bi translated">然后，我们创建了实际标签与预测标签的数据框架。之后，我们合计了正确的预测，并将其除以实例的总数，这给了我们一个非常高的准确度。</li></ul><p id="18ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们来看看给我们最高预测能力的特征；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="1819" class="lu lv it mt b gy mx my l mz na"># Feature Selection</span><span id="b65e" class="lu lv it mt b gy nb my l mz na">f_names = df.columns<br/>f_importances = clf.feature_importances_<br/>f_std = np.std([tree.feature_importances_ for tree in clf.estimators_], axis=0)</span><span id="ada3" class="lu lv it mt b gy nb my l mz na">zz = zip(f_names, f_importances, f_std)<br/>zzs = sorted(zz, key=lambda x: x[1], reverse=True)</span><span id="e72f" class="lu lv it mt b gy nb my l mz na">labels = [x[0] for x in zzs]<br/>imps = [x[1] for x in zzs]<br/>errs = [x[2] for x in zzs]</span><span id="7391" class="lu lv it mt b gy nb my l mz na">plt.figure(figsize=(10,4))<br/>plt.bar(range(df.shape[1]), imps, color='r', yerr=errs, align='center')<br/>plt.xticks(range(len(f_importances)), labels)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/655ccca7cb414912341e90add1f5b732.png" data-original-src="https://miro.medium.com/v2/format:webp/1*7TlLFBbj_4pzBctmZ5embw.png"/></div></figure><p id="ca4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所预期的，基于我们早期的视觉分析，当区分虹膜类别时，花瓣长度和宽度具有更强的辨别能力。</p><p id="d721" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我提到的，当我们检查我们特征之间的相关性时，萼片长度和萼片宽度似乎对我们模型的准确性贡献很小。</p><p id="ad89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们是怎么得到这个的？随机森林有一个名为<code class="fe nd ne nf mt b">.feature_importances_</code>的方法，该方法返回在树叶处进行分割的特性的相对性能。如果一个特性能够一致且清晰地将一个组划分为不同的类，那么它将具有很高的特性重要性。</p><p id="3ed9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到我们包括了标准差，这有助于说明每个特性的一致性。这是通过对十棵树中的每一棵树的每个特征取特征重要性，并计算标准偏差而生成的。</p><p id="c0c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们看看另一个使用Scikit-learn的例子。我们现在将切换我们的分类器，并使用<strong class="js iu">支持向量机(SVM) </strong>:</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="6e52" class="lu lv it mt b gy mx my l mz na">from sklearn.multiclass import OneVsRestClassifier<br/>from sklearn.svm import SVC</span><span id="7863" class="lu lv it mt b gy nb my l mz na">clf = OneVsRestClassifier(SVC(kernel='linear'))</span><span id="b191" class="lu lv it mt b gy nb my l mz na">clf.fit(X_train, y_train)<br/>y_pred = clf.predict(X_test)</span><span id="d82d" class="lu lv it mt b gy nb my l mz na">svc = pd.DataFrame(list(zip(y_pred, y_test)), columns=['predicted', 'actual'])<br/>svc['correct'] = svc.apply(lambda x: 1 if x.predicted == x.actual else 0, axis=1)<br/>svc</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/667f8248b9dbf7236a2792876768d7a5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EN0sUb1BVIM3F66zW54EBw.png"/></div></figure><p id="157d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们执行下面一行代码；</p><pre class="kq kr ks kt gt ms mt mu mv aw mw bi"><span id="7dec" class="lu lv it mt b gy mx my l mz na">svc['correct'].sum() / svc['correct'].count()</span><span id="73ab" class="lu lv it mt b gy nb my l mz na"># OUTPUT<br/>0.9333333333333333</span></pre><p id="11b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们使用SVM代替随机森林分类器，除了导入支持向量分类器和实例化模型的部分，没有改变任何代码。这只是对Scikit-learn所提供的无与伦比的能力的一个尝试。</p><p id="626e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我强烈建议你去<a class="ae lf" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> Scikit-learn文档</a>看看Scikit-learn提供的其他一些ML算法。</p><h2 id="2f87" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">最终注释</h2><p id="cba8" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">这样，我们就完成了数据分析和机器学习的入门指南。</p><p id="fa28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们学习了如何通过数据分析和机器学习的每个阶段逐步获取数据。我们还学习了Python科学堆栈中每个主要库的关键特性。</p><p id="c137" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里是GitHub上代码和解释的<a class="ae lf" href="https://github.com/SteveKola/Python-ML-Blueprints/blob/master/1.-Baby-Steps-into-Data-Analysis-and-Machine-Learning/Baby%20steps%20into%20ML.ipynb" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="6788" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在后续文章中，我们将利用这些知识，并开始应用它们来创建独特而有用的机器学习应用程序。敬请期待！</p><p id="dfd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，如果你觉得这篇文章很有见地，请喜欢并分享它。也可以在<a class="ae lf" href="https://twitter.com/steveddev" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae lf" href="https://www.linkedin.com/in/steven-kolawole-80/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上跟我打招呼。玩得开心！</p><p id="aa6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:这篇文章的灵感主要来自Alexander T. Combs的Python机器学习蓝图。</p></div></div>    
</body>
</html>