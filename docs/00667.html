<html>
<head>
<title>CSS at Scale: Cosmetic vs Layout Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缩放比例的CSS:外观与布局属性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/css-at-scale-cosmetic-vs-layout-properties-a1c8acc875d7?source=collection_archive---------1-----------------------#2019-06-23">https://levelup.gitconnected.com/css-at-scale-cosmetic-vs-layout-properties-a1c8acc875d7?source=collection_archive---------1-----------------------#2019-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/11054cc36564c2adfbaa06c537071614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RveSs9E-9tkPTgkBMtxucw.png"/></div></div></figure><h1 id="cd90" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="53a2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">CSS属性基本上有两种类型:控制布局/结构/功能的属性和控制外观的属性。知道如何、何时以及为什么识别差异可以提高产品的可维护性和团队的生产力。通常，业务需求可以通过仅仅修改被认为是<em class="lu">装饰性的</em>(想想品牌化)的属性来满足；考虑到这个问题的性质，将其分开是有意义的。</p><p id="5d25" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">CSS属性经常在没有适当考虑的情况下被投入生产，这就是为什么很难实现可维护和可伸缩的CSS代码库。注释/记录UI模块中的每一个CSS属性来解释它的用途是不切实际的(但是每一个属性都应该有一个已知的用途和副作用，对吗？)，但是通过合理的属性分离，它们可以更容易地被管理和维护，允许一个更加“自文档化”的CSS代码库。</p><p id="ba24" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">考虑一个只有两个CSS属性的UI元素:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d617" class="mj jz iq mf b gy mk ml l mm mn">.element {<br/>  display: flex;<br/>  color: red;<br/>}</span></pre><p id="3850" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这两个属性之间的区别似乎微不足道(它们都是CSS，对吗？)，但更改其中一个可能会导致您的应用程序不可用，而更改另一个则不会。这种顿悟如何帮助我们构建更好的产品？一旦你意识到大部分考虑布局和结构的CSS属性具有<em class="lu">离散的</em>值，并且大部分考虑外观和感觉的CSS属性具有<em class="lu">连续的</em>值，就很清楚外观属性更倾向于变化(这实际上<em class="lu">有意义</em>)。</p><p id="2926" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">当某样东西可以分成两个不同的类别，一个包含<em class="lu">安全</em>和<em class="lu">易变</em>属性，另一个包含<em class="lu">危险</em>和<em class="lu">抗变</em>属性时，将它们分开<em class="lu">才有意义。这种对布局和外观属性的担忧只会阻碍大规模生产——就像把你的苏打水和漂白剂放在同一个橱柜里，只是因为它们都是“瓶子里的液体”。</em></p><h1 id="ec75" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解决方案</h1><p id="3496" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们假设您的项目有某种UI模块文件夹，每个模块都有一个<code class="fe mo mp mq mf b">styles.scss</code>文件:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="cfd1" class="mj jz iq mf b gy mk ml l mm mn">modules/<br/>|    |-- accordion/<br/>|    |    |-- styles.scss</span></pre><p id="61f8" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">像这样的建议太不切实际(也太容易)了:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="ae42" class="mj jz iq mf b gy mk ml l mm mn">modules/<br/>|    |-- accordion/<br/>|    |    |-- layout.scss<br/>|    |    |-- cosmetic.scss</span></pre><p id="522c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">…(虽然这实际上不是一个坏主意…)，但是解决这个问题的更好的方法引入了一种新的思维方式，那就是将UI模块的表面CSS属性视为<em class="lu">配置</em>，而不是逻辑/实际代码(CSS)。毕竟，对于传达含义的外观属性，您实际上不需要对CSS有固有的理解(不像布局属性)；"颜色:红色；"对任何说英语的人都有意义；"显示器:flex"不会。同样，这可能看起来是一个无关紧要的细微差别，但在实践中，它最终会导致需要一个新版本和不需要一个新版本之间的差异，因为外观属性可以直接与业务需求相关联(您可以想象企业要求某些东西是红色的，但从来没有要求某些东西是“display:flex；”)并且可以放心地应用，而不需要任何回归测试。</p><p id="062e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">因此，现在我们将外观CSS属性视为配置而非代码，我们的项目结构可能类似于:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2b44" class="mj jz iq mf b gy mk ml l mm mn">modules/<br/>|    |-- accordion/<br/>|    |    |-- config.json<br/>|    |    |-- layout.scss</span></pre><p id="969e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">JSON是数据/配置的标准格式。从理论的角度来看，这很好，但是从实践的角度来看，这没有多大用处，因为Sass不能开箱即用地解释JSON，JSON也不能写入样式表。实现本文提出的目标的技术“如何做”有些超出了本文的范围(尽管它将被简单地触及)；从技术上来说，有一百万种不同的方法来实现它，所以重点将继续放在理论上。但是，只是把它扔在那里，所有这些理论在实践中使用One-Nexus的<a class="ae mr" href="https://github.com/One-Nexus/Synergy-Front-End-Guides/wiki/CSS-at-Scale:-Cosmetic-vs-Layout-Properties#TODO" rel="noopener ugc nofollow" target="_blank">协同框架</a>(特别是<a class="ae mr" href="https://www.npmjs.com/package/@onenexus/synergy-sass-importer" rel="noopener ugc nofollow" target="_blank"> synergy-sass-importer </a>和<a class="ae mr" href="https://github.com/One-Nexus/Cell" rel="noopener ugc nofollow" target="_blank"> Cell </a>)是可能的。</p><h1 id="7b27" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">分离</h1><p id="46b6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">到目前为止，我们只看了两个CSS属性(<code class="fe mo mp mq mf b">display</code>和<code class="fe mo mp mq mf b">color</code>)，但是将任何CSS属性放入“布局”或“装饰”类别应该很容易，没有太多争议(...<em class="lu">多了</em>...)，根据经验法则，具有连续值的属性=外观，具有离散值的属性=布局。</p><p id="0ca3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">实际上有大约500个有效的CSS属性<a class="ae mr" href="https://github.com/known-css/known-css-properties/blob/master/source/w3c.json" rel="noopener ugc nofollow" target="_blank">和属性是否应该被认为是“装饰”或“布局”相关的确切性质取决于它被使用的上下文。</a></p><p id="2494" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">主要目标实际上是通过将潜在的可配置属性移动到配置中，并将它们与不太可能频繁更改或从不更改的属性完全分离，从而提高生产率——因此真正的问题是“这个属性可能会被更改不止一次吗？”或者甚至是“这个属性可以在任何时候改变以直接满足某些业务需求吗？”。考虑是否可以让一个“非技术”人员负责更改相关属性的值，以及更改值是否会破坏产品(之前我可能暗示过,<code class="fe mo mp mq mf b">display</code>属性不应该是可配置的，因为它会破坏应用程序；然而，仍然有一些例子说明配置这个属性是有意义的，比如控制促销标语的可见性。</p><p id="3e58" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">作为一个粗略的想法，下面是一些共同的属性可能经常被分开:</p><h2 id="27bd" class="mj jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">化妆品特性</h2><ul class=""><li id="693d" class="nd ne iq ky b kz la ld le lh nf ll ng lp nh lt ni nj nk nl bi translated">颜色</li><li id="713e" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">背景颜色</li><li id="1969" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">背景图像</li><li id="3a3f" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">边框半径</li><li id="5b09" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">充满</li><li id="a249" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">字体系列</li><li id="ac66" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">字体大小</li><li id="1f48" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">字体样式</li><li id="2a16" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">字体粗细</li></ul><h2 id="b70f" class="mj jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">布局属性</h2><ul class=""><li id="7365" class="nd ne iq ky b kz la ld le lh nf ll ng lp nh lt ni nj nk nl bi translated">盒子尺寸</li><li id="cbe3" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">清楚的</li><li id="3674" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">显示</li><li id="91ec" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">弯曲</li><li id="04a4" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">浮动</li><li id="5700" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">泛滥</li><li id="fd7e" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">位置</li><li id="c250" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">垂直对齐</li></ul><h2 id="9031" class="mj jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">有争议的财产</h2><p id="250a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir">高/宽<br/> </strong>使用<code class="fe mo mp mq mf b">height</code>或<code class="fe mo mp mq mf b">width</code>可以被认为是<code class="fe mo mp mq mf b">layout</code>属性或<code class="fe mo mp mq mf b">cosmetic</code>属性的可能性是50/50；这完全取决于上下文。毕竟，企业肯定会说“让徽标更大”，而不是修改代码，而是修改一些配置来增加徽标的大小。但是你必须考虑这样的问题:“增加标志的尺寸会不会破坏布局?”？在哪种情况下，我们首先应该允许大小是可配置的？”-这些问题的答案取决于每个项目特有的因素。</p><p id="6c12" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">填充/边距<br/> </strong> <code class="fe mo mp mq mf b">padding</code>和<code class="fe mo mp mq mf b">margin</code>是很难分类的属性；虽然它们的值是连续的，但它们的用途通常与布局相关，在其他情况下，它们的值可能在您的设计系统中是标准化的，因此不太可能在模块级别进行配置。也就是说，你可以在两个不同的主题中使用同一个模块，除了一个主题需要稍微大一点的填充；在这种情况下，将<code class="fe mo mp mq mf b">padding</code>属性作为模块的可配置值是有意义的。</p><p id="5305" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">上/下/左/右<br/></strong><code class="fe mo mp mq mf b">top</code>、<code class="fe mo mp mq mf b">bottom</code>、<code class="fe mo mp mq mf b">left</code>和<code class="fe mo mp mq mf b">right</code>属性通常用于布局目的，例如将您可以做的事情垂直居中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="96c2" class="mj jz iq mf b gy mk ml l mm mn">.vertical-center {<br/>  position: relative;<br/>  top: 50%;<br/>  transform: translateY(-50%);<br/>}</span></pre><p id="10ec" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">…在这里，改变<code class="fe mo mp mq mf b">top</code>的值是没有意义的，尽管这个值是连续的。通常情况下，考虑到这些属性的使用性质，它们应该被认为是<code class="fe mo mp mq mf b">layout</code>属性，而不是<code class="fe mo mp mq mf b">cosmetic</code>属性。</p><h1 id="31e3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">前/后示例</h1><p id="16e3" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们以一个<code class="fe mo mp mq mf b">accordion</code>模块为例，看看采用这种哲学前后的一些源代码。</p><blockquote class="nr ns nt"><p id="8eb9" class="kw kx lu ky b kz lv lb lc ld lw lf lg nu lx lj lk nv ly ln lo nw lz lr ls lt ij bi translated">本例使用<a class="ae mr" href="https://github.com/One-Nexus/Cell/wiki" rel="noopener ugc nofollow" target="_blank">单元库</a></p></blockquote><p id="c074" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">对于上下文，我们将要设计的accordion模块的标记是:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">这个例子使用了BEM命名约定</figcaption></figure><h2 id="d0ff" class="mj jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">以前</h2><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5a0b" class="mj jz iq mf b gy mk ml l mm mn">modules/<br/>|    |-- accordion/<br/>|    |    |-- styles.scss</span></pre><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">本例中使用的mixins来自<a class="ae mr" href="https://github.com/One-Nexus/Cell" rel="noopener ugc nofollow" target="_blank">单元库</a></figcaption></figure><h2 id="2bd2" class="mj jz iq bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">在...之后</h2><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="56a7" class="mj jz iq mf b gy mk ml l mm mn">modules/<br/>|    |-- accordion/<br/>|    |    |-- config.json<br/>|    |    |-- layout.scss</span></pre><p id="2844" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在已经将可配置属性移动到它们自己的文件中，现在看起来可能类似于:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">JSON可以通过<a class="ae mr" href="https://www.npmjs.com/package/@onenexus/synergy-sass-importer" rel="noopener ugc nofollow" target="_blank"> synergy-sass-importer </a>导入到Sass中</figcaption></figure><p id="7742" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在，如果没有某种神奇的工具从这个JSON文件写入CSS，您仍然需要手动将上述值映射到Sass文件中的CSS属性。使用<a class="ae mr" href="https://www.npmjs.com/package/@onenexus/synergy-sass-importer" rel="noopener ugc nofollow" target="_blank"> synergy-sass-importer </a>，导入<code class="fe mo mp mq mf b">config.json</code>文件会将<code class="fe mo mp mq mf b">$config</code>变量下的值作为sass映射暴露给Sass，因此可以使用<code class="fe mo mp mq mf b"><a class="ae mr" href="https://esr360.github.io/Sass-Boost/#undefined-function-map-get-deep" rel="noopener ugc nofollow" target="_blank">map-get-deep</a></code>函数访问它们:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2656" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在，我相信你会同意在这一点上，我们可以说是后退了一步，而不是前进；我们仍然将修饰属性与源代码紧密耦合，我们只是允许从一个单独的JSON文件中配置它们的值。在这个过程中，我们让源代码看起来更不和谐。</p><p id="c756" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">幸运的是，由于有了<a class="ae mr" href="https://github.com/One-Nexus/Cell" rel="noopener ugc nofollow" target="_blank">细胞库</a>，我们可以实现之前所要求的<em class="lu">魔法</em>。Cell可以智能地确定模块配置中的哪些属性应该被视为CSS，以及它们应该应用于哪些元素。这意味着我们可以从源代码中删除它们，留给我们的是:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">JSON由<a class="ae mr" href="https://www.npmjs.com/package/@onenexus/synergy-sass-importer" rel="noopener ugc nofollow" target="_blank"> synergy-sass-importer </a>导入</figcaption></figure><p id="12ca" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">没有了污染文件的修饰属性，现在需要担心的属性减少了大约85%,剩下的属性更容易破译。这很重要，因为剩下的15%有可能会破坏应用程序。</p><p id="b679" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">要明确一点:这不是“CSS-in-JSON”。即使你能从技术上证明这是事实，得出这个结论的思维方式也没有抓住我们的目标。我们拥有的是其属性恰好对应于有效CSS属性的配置；我们使用的工具利用了这一事实来为相应的属性自动生成CSS。将它想象成“CSS-in-JSON”意味着您可以随意添加任何属性，这是公约所不允许的。重要的是，你只需要给JSON添加属性，这些属性可以转化为不会破坏应用程序的修饰性属性。</p><p id="a9d7" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如果这个概念仍然没有意义(或者看起来仍然是CSS-in-JSON ),那么可以考虑同样的概念，只是稍微修改了一下配置键，并且没有创建CSS的JSON属性的神奇之处。这可能会给你留下这样的东西:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4cd5" class="mj jz iq mf b gy mk ml l mm mn">{<br/>  "accordion": {<br/>    "panel-color": "red",<br/>    ...<br/>  }<br/>}</span></pre><p id="8a72" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在在<code class="fe mo mp mq mf b">accordion.scss</code>中，你可能会看到这样的内容:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="44bc" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这满足了使价值可配置的目标(对业务有益！)，但仍然会使源代码受到外观属性的污染(不利于可读性！).对于所有意图和目的(从配置的角度来看)，这:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5966" class="mj jz iq mf b gy mk ml l mm mn">{<br/> "accordion": {<br/>    "panel-color": "red",<br/>    ...<br/> }<br/>}</span></pre><p id="e774" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">…实际上与此没有什么不同:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="22d3" class="mj jz iq mf b gy mk ml l mm mn">{<br/>  "accordion": {<br/>    "panel": {<br/>        "color": "red",<br/>        ...<br/>    },<br/>    ...<br/>  }<br/>}</span></pre><p id="a3b3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">…除了后者，某些东西可以更安全地推断出来，然后可以在API中加以利用。因此，这种理念在理论上允许的是一种产品，其源代码可以保持更小、更干净和更简洁，其配置可以用于生成装饰性的CSS。</p><h1 id="d897" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="ba86" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">通过将CSS属性视为两个不同的类别(外观和功能/布局)，您可以利用某些好处，最终导致生产力的提高，如本文所述。只有当你有合适的工具来处理杠杆化的利益时，这样做才有意义(否则这个过程会适得其反)。</p><p id="7357" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">总之，这一理论的主要实际好处包括:</p><ul class=""><li id="436b" class="nd ne iq ky b kz lv ld lw lh od ll oe lp of lt ni nj nk nl bi translated">减少源代码的大小</li><li id="02bb" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">提高源代码的清晰度</li><li id="d657" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">允许更有效地处理修饰更新</li><li id="466c" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">在更改CSS属性时，对可能受影响的内容更有信心(关注点分离的好处)</li><li id="5383" class="nd ne iq ky b kz nm ld nn lh no ll np lp nq lt ni nj nk nl bi translated">通过将更多的注意力吸引到单个的属性上来改善CSS在产品中的整体使用方式</li></ul><p id="b8c2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">…这些都有助于软件开发的共同目标，如可伸缩性和可维护性。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0f4eaa82f76695a20f09ba4fa9fd37ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbifSkjSDCs7zGgIwXMiwg.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated"><a class="ae mr" href="https://twitter.com/esr360" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae mr" href="https://github.com/esr360" rel="noopener ugc nofollow" target="_blank"> Github </a></figcaption></figure></div></div>    
</body>
</html>