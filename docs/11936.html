<html>
<head>
<title>Theme management with datastore in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jetpack Compose中的数据存储进行主题管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/theme-management-with-datastore-in-jetpack-compose-c10c043ab276?source=collection_archive---------3-----------------------#2022-05-01">https://levelup.gitconnected.com/theme-management-with-datastore-in-jetpack-compose-c10c043ab276?source=collection_archive---------3-----------------------#2022-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5597" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在你的应用程序上使用暗/亮模式可能会有点混乱，但通过一些工具，我们将能够匹配所需的外观和感觉。</p><h2 id="342c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">包装纸</h2><p id="f58d" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">为了能够轻松切换，我们将使用自定义主题管理器来包装我们的应用程序，这将允许我们处理主题的状态。</p><p id="2eda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包装器将有一个对数据存储的引用，以检查它何时发生变化，并让整个应用程序知道正在发生变化。当数据改变时，应用程序也会改变。</p><p id="ae6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了方便起见，我们将使用Twitter在其应用程序上使用的方法，基本上，您可以选择使用您的配置，或者使用系统的配置。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/b891e1bf93b465d7648f42745b406c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*4OUGeJcXwlxJ1X95CZAa0A.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">设置演示应用程序。</figcaption></figure><p id="178c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将依赖于材料设计主题组件，它有所有的工具来使这个变得简单一点。</p><pre class="lk ll lm ln gt lv lw lx ly aw lz bi"><span id="3174" class="kl km iq lw b gy ma mb l mc md">@Composable<br/>fun AppTheme(<br/>    content: @Composable () -&gt; Unit,<br/>) {<br/>    val context = <em class="me">LocalContext</em>.current<br/>    val viewModel = <em class="me">remember </em><strong class="lw ir">{ </strong>ThemeViewModel(context.<em class="me">dataStore</em>) <strong class="lw ir">}<br/>    </strong>val state = viewModel.state.<em class="me">observeAsState</em>()<br/>    val value = state.value ?: <em class="me">isSystemInDarkTheme</em>()<br/><br/>    <em class="me">LaunchedEffect</em>(viewModel) <strong class="lw ir">{ </strong>viewModel.request() <strong class="lw ir">}<br/><br/>    </strong><em class="me">DarkThemeValue</em>.current.value = value<br/>    <em class="me">MaterialTheme</em>(<br/>        colors = if (value) <em class="me">AppDarkColors </em>else <em class="me">AppLightColors</em>,<br/>        typography = <em class="me">AppTypography</em>,<br/>        shapes = <em class="me">AppShapes</em>,<br/>        content = content<br/>    )<br/>}<br/><br/>@Composable<br/>@ReadOnlyComposable<br/>fun isDarkTheme() = <em class="me">DarkThemeValue</em>.current.value<br/><br/>@SuppressLint("CompositionLocalNaming")<br/>private val <em class="me">DarkThemeValue </em>= <em class="me">compositionLocalOf </em><strong class="lw ir">{ </strong><em class="me">mutableStateOf</em>(false) <strong class="lw ir">}</strong></span></pre><h2 id="035c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">数据存储/视图模型</h2><p id="db1e" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">我将减少这一串只是为了得到的想法，基本上，对于这个例子，我们将只保存一个值真/假，根据这个值的变化，用户界面将重新呈现。这种基本的视图模型使用实时数据与用户界面交流并保持最新。</p><pre class="lk ll lm ln gt lv lw lx ly aw lz bi"><span id="32cc" class="kl km iq lw b gy ma mb l mc md">class ThemeViewModel(<br/>    private val dataStore: DataStore&lt;Preferences&gt;<br/>) : ViewModel() {<br/>    private val forceDarkModeKey = <em class="me">booleanPreferencesKey</em>("theme")<br/><br/>    val state = MutableLiveData&lt;Boolean?&gt;(null)<br/>    fun request() {<br/>        <em class="me">viewModelScope</em>.<em class="me">launch </em><strong class="lw ir">{<br/>            </strong>dataStore.data.collectLatest <strong class="lw ir">{<br/>                </strong>state.<em class="me">value </em>= <strong class="lw ir">it</strong>[forceDarkModeKey]<br/>            <strong class="lw ir">}<br/>        }<br/>    </strong>}<br/><br/>    fun switchToUseSystemSettings(isSystemSettings: Boolean) {<br/>        <em class="me">viewModelScope</em>.<em class="me">launch </em><strong class="lw ir">{<br/>            </strong>if (isSystemSettings) {<br/>                dataStore.edit <strong class="lw ir">{<br/>                    it</strong>.remove(forceDarkModeKey)<br/>                <strong class="lw ir">}<br/>            </strong>}<br/>        <strong class="lw ir">}<br/>    </strong>}<br/><br/>    fun switchToUseDarkMode(isDarkTheme: Boolean) {<br/>        <em class="me">viewModelScope</em>.<em class="me">launch </em><strong class="lw ir">{<br/>            </strong>dataStore.edit <strong class="lw ir">{<br/>                it</strong>[forceDarkModeKey] = isDarkTheme<br/>            <strong class="lw ir">}<br/>        }<br/>    </strong>}<br/>}</span></pre><p id="4127" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于某些特殊原因，这里有三个函数，其思想是监听数据存储上的更改，这些更改将传播到UI。</p><h2 id="98fe" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">调色板/用户界面</h2><p id="a442" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">现在我们有了工具，我们可以开始在我们的屏幕上使用它，首先我们可以创建一些颜色和一个根据主题状态设置颜色的工具。</p><pre class="lk ll lm ln gt lv lw lx ly aw lz bi"><span id="88f1" class="kl km iq lw b gy ma mb l mc md">val <em class="me">DarkBlue </em>= Color.<em class="me">fromRGB</em>("#0B1729")<br/>val <em class="me">Silver20 </em>= Color.<em class="me">fromRGB</em>("#E5E5E5")<br/>val <em class="me">SilverLight </em>= Color.<em class="me">fromRGB</em>("#F8F7F8")<br/><br/>@Composable<br/>fun backgroundColor() = <em class="me">DarkBlue orInLightTheme SilverLight<br/><br/></em>@Composable<br/>fun captionColor() = <em class="me">Silver20 orInLightTheme DarkBlue</em></span><span id="6ab4" class="kl km iq lw b gy mf mb l mc md">@Composable<br/>@ReadOnlyComposable<br/>infix fun &lt;T&gt; T.orInLightTheme(other: T): T = if (<em class="me">isDarkTheme</em>()) this else other</span></pre><p id="ff62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi lw b">orInLightTheme</code>只是一个不在app周围写if/else的花哨功能。</p><p id="6874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以对所有组件进行主题化:</p><pre class="lk ll lm ln gt lv lw lx ly aw lz bi"><span id="461f" class="kl km iq lw b gy ma mb l mc md"><em class="me">CustomText</em>(<br/>    text = "\uD83C\uDF19  Dark mode",<br/>    color = <em class="me">captionColor</em>(),<br/>)</span></pre><h2 id="d61c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">设置屏幕/示例</h2><p id="c583" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">要查看完整示例，请访问https://github.com/go-cristian/compose_theme。</p><p id="a184" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个你如何处理它的快速例子，当然在生产中，你需要改变这里的一些东西。</p></div></div>    
</body>
</html>