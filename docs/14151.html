<html>
<head>
<title>Introduction To Rx.NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rx简介。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-rx-net-87e4a6c6e71b?source=collection_archive---------1-----------------------#2022-11-06">https://levelup.gitconnected.com/introduction-to-rx-net-87e4a6c6e71b?source=collection_archive---------1-----------------------#2022-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1727" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">反应式编程。网</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e988137f362322d508571878be5f6726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tjRS5sNIVmkJDSrz"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</figcaption></figure><p id="8d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在首次发现<a class="ae ky" href="https://github.com/dotnet/reactive" rel="noopener ugc nofollow" target="_blank">反应性延伸</a>后。NET，我发现学习它非常困难，因为几乎没有任何例子或文档真正涵盖所有情况，或者它们太复杂，乍一看难以理解。网上有一些教程，大部分可以在这里找到。</p><p id="4ad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还没有使用过。NET，我可以推荐<a class="ae ky" href="http://introtorx.com/" rel="noopener ugc nofollow" target="_blank"> IntroToRx </a>。这是一个很好的开始。然而，在我的项目中，我很快遇到了用例，这些用例在任何文档或教程中都没有被完全覆盖。我尤其难以实现多播和稳定的可观察流，除非我真的打算这样做，否则无法完成。</p><p id="bd34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将向您介绍。NET以及如何处理一些一开始不太明显的用例。</p><h1 id="e5a7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍</h1><p id="d704" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/dotnet/reactive" rel="noopener ugc nofollow" target="_blank"> Reactive Extensions </a>是一个库，通过它你可以使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>用类似LINQ的操作符处理异步数据流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/c567ca0cf10833d60df76e1fd5fe322d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2JGv_DK5wf9DhwKrSdoVAA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">示例可观察管道的抽象(来自<a class="ae ky" href="https://fontawesome.com/license" rel="noopener ugc nofollow" target="_blank"> FontAwesome </a>的图标)</figcaption></figure><p id="712b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图显示了可观察管道的<strong class="lb iu">示例</strong>实现。你有发出事件的可观察物。这些事件然后由管道异步处理。在这种情况下，它首先被记录，然后检查错误，然后我们触发一个侧面逻辑，最后观察器接收事件并可以用它做自己的逻辑，例如改变一个状态。</p><p id="a3af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可观察不一定会产生事件，你也可以创造一个数据流或任何你能想象的东西。你也可以让可观察管道完全空着，只直接观察可观察物。</p><h1 id="b8d8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">要求</strong></h1><p id="cfea" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要开始使用Rx.NET，您需要安装以下软件包:</p><ul class=""><li id="11d0" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><a class="ae ky" href="https://www.nuget.org/packages/System.Reactive/" rel="noopener ugc nofollow" target="_blank">系统。无功</a></li></ul><h1 id="e075" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基础:可观察对象/观察者创建</h1><p id="b43d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从创建可观察对象和观察者开始。初始化观察器(<em class="nc">，即处理管道末端的事件或数据流</em>)的昂贵方式是手动实现所需的方法或事件处理程序，名为:<code class="fe nd ne nf ng b">OnNext()</code>、<code class="fe nd ne nf ng b">OnError()</code>和<code class="fe nd ne nf ng b">OnCompleted()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="97db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以想象，如果你需要很多观察者，这需要太多的代码。</p><p id="9f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也展示如何创建一个可观察的。一个可观察对象正在观察器或管道处理程序上调用方法<code class="fe nd ne nf ng b">OnNext()</code>、<code class="fe nd ne nf ng b">OnError()</code>、<code class="fe nd ne nf ng b">OnCompleted()</code>(如果可用的话)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="dc3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是一个有点多的代码开始，可能不是很可读，如果它变得更多。这就是为什么<strong class="lb iu">反应式扩展</strong>包具有许多扩展，这将简化可观测量和观察者的创建。</p><p id="bcd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不用像observer_creation.cs那样创建一个类，您可以只使用lambda函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nd ne nf ng b">Subscribe()</code>方法中，您可以在lambda函数上实现观察者功能。您甚至可以选择忽略<code class="fe nd ne nf ng b">OnError()</code>或<code class="fe nd ne nf ng b">OnCompleted()</code>处理程序。请记住，只有当您导入了<code class="fe nd ne nf ng b">System;</code>名称空间时，这个扩展方法才可用！</p><h1 id="510a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">错误处理</h1><p id="75ea" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我对反应式扩展的第一个困惑是在错误处理和重试期间，这也是为什么我想在一开始就更详细地讨论这个话题。</p><p id="3394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你像我一样，你可能会想到传统的try-catch子句，在这种情况下，执行只是在一个异常之后跳转到catch子句，并且你可以继续你的逻辑。然而，在这种情况下，你向观察者返回了一个全新的<strong class="lb iu">可观察值，而观察者并不知道这个可观察值是在哪里被截断的。输出如下所示:</strong></p><pre class="kj kk kl km gt nj ng nk nl aw nm bi"><span id="0580" class="nn lw it ng b gy no np l nq nr">//  0<br/>//  1<br/>//  Exception: i is 2<br/>//  *Whatever you define as result of the errorHandler*</span></pre><p id="ff13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新的可观察物通常会完成并触发观察者不再观察可观察物。这完全停止了你的可观察性，你打算不断地产生新的事件，在某一点上，你可能想知道发生了什么。为了应对这种行为，我们必须实现一个重试逻辑。</p><p id="0f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用的反应式扩展中的两个选项是<code class="fe nd ne nf ng b">Retry()</code>和<code class="fe nd ne nf ng b">RetryWhen()</code>。</p><p id="660e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重试</strong></p><p id="5db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，最有希望的似乎是。你可能会遇到一个例外，可观察的只是从头开始。<code class="fe nd ne nf ng b">Retry()</code>的大问题是，我们无法处理发生的异常。您可能想要区分几个异常，当它是轻微异常时重试，当它是严重异常时快速失败。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是这个问题的一个可能的解决方案。我们只需添加一个<code class="fe nd ne nf ng b">Catch()</code>方法并指定一个错误处理程序，它可以区分不同类型的错误。之后，我们添加了<code class="fe nd ne nf ng b">Retry()</code>方法，它将重试n次或永远重试。</p><p id="f430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近我有一个用例，其中源可观察对象不断地从消息队列中发出新事件。如果我不使用Catch &amp; Retry组合，我的应用程序将会崩溃，不再处理重要的事件。</p><p id="34dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">返回时间</strong></p><p id="9d63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf ng b">RetryWhen</code>几乎和<code class="fe nd ne nf ng b">Retry</code>一样，除了你还需要一个可观察到的触发信号，这是再次重试的信号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生的是，可观测的源正在发射<code class="fe nd ne nf ng b">0, 1, error</code>。<code class="fe nd ne nf ng b">RetryWhen()</code>捕捉异常并等待，直到<code class="fe nd ne nf ng b">signal</code>发出任何值，这将在1秒后发生。当检测到该信号时，源可观测信号将被重新订阅并再次发射<code class="fe nd ne nf ng b">0, 1, error</code>。</p><h1 id="636c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">可连接的可观测量</strong></h1><p id="809a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">第二个也是更令人困惑的话题，我遇到了所谓的<code class="fe nd ne nf ng b">Connectable Observables</code>。可连接观察物，更好地称为<strong class="lb iu">热观察物</strong>，能够为零到任意数量的订户产生通知。这意味着，他们可以发射事件，即使还没有人订阅它们。</p><p id="8aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您有一个外部源发出事件，并且您希望只将它们发送给任何感兴趣的观察者，或者甚至保留这些事件的历史，以备新的观察者订阅时，它们就派上了用场。</p><p id="ebca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的代码，我起初认为它是正确的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我简单地将<code class="fe nd ne nf ng b">Replay()</code>添加到我的source observable中，希望它能为每个新订户重放我最近的3个事件。如果我是正确的，这就是在Rx中可行的方法。Js，但是在这里，我们没有得到任何结果在我们的控制台。</p><p id="f5a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因很简单。<code class="fe nd ne nf ng b">Replay()</code>函数返回一个<code class="fe nd ne nf ng b">IConnectableObservable</code>，它本身就像一个观察者。这个观察器还没有初始化，所以它订阅了它的底层可观察对象。这可以通过使用<code class="fe nd ne nf ng b">Connect()</code>方法来实现，正如你在这里看到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以将任意数量的观察者连接到这个源，每个观察者都将收到最近发出的3个通知。</p><p id="be99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完整起见，IConnectableObservables由:<code class="fe nd ne nf ng b">Publish()</code>、<code class="fe nd ne nf ng b">PublishLast()</code>和<code class="fe nd ne nf ng b">Multicast()</code>产生。处理这些问题时，请特别注意。还有一点，您调用<code class="fe nd ne nf ng b">Connect()</code>方法的地方是相关的，因为这将已经开始订阅，您可能会丢失通知，直到第一个观察者订阅。</p><h1 id="fdeb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">添加</h1><p id="0198" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">可观察模式与反应式扩展相结合也使得以一种非常干净的方式实现<a class="ae ky" href="https://learn.microsoft.com/en-us/azure/architecture/patterns/pipes-and-filters" rel="noopener ugc nofollow" target="_blank">管道和过滤器模式</a>变得非常容易。为了使它更加干净和直观，同时也支持依赖注入，我创建了一个名为<strong class="lb iu"> ObservablePipelines </strong>的Nuget包。您可以查看它的工作原理，并从本文下载:</p><div class="ns nt gp gr nu nv"><a href="https://betterprogramming.pub/the-best-approach-for-a-pipeline-architecture-in-net-d0ad0332ea24" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">中管道体系结构的最佳方法。网</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">用最少的代码创建一个干净的管道</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">better编程. pub</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="0f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这两个例子可以消除一些困惑，帮助你掌握反应式扩展。</p><p id="167f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对源代码感兴趣，可以看看我为本文准备的知识库:</p><div class="ns nt gp gr nu nv"><a href="https://github.com/TobiStr/Understanding-Reactive.NET" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">GitHub-TobiStr/Understanding-Reactive。NET:这个库展示了如何正确使用…</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">这个库展示了如何在. NET中正确使用反应式扩展。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="or l og oh oi oe oj ks nv"/></div></div></a></div></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="bf35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。</p><p id="2403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。</p><p id="5f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你有美好的一天！</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/429378e6a7aee01df92851fb0e90e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK4zVN8TtnIM37dhEhE54g.png"/></div></div></figure><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@tobias.streng/membership" rel="noopener"> <em class="nc">加入中现</em> </a></p><p id="cb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。</p></div></div>    
</body>
</html>