<html>
<head>
<title>Testing Essentials In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的测试要点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-essentials-in-go-3bf588fef76e?source=collection_archive---------5-----------------------#2020-12-16">https://levelup.gitconnected.com/testing-essentials-in-go-3bf588fef76e?source=collection_archive---------5-----------------------#2020-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7700" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从强大的测试标志到代码覆盖率和基准测试！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/f438465d6f0fbf0dbad10e53ef043ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/0*OuPmdfHpDgL6YXbQ.jpg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">来自<a class="ae la" href="https://deepdreamgenerator.com/u/danielwar" rel="noopener ugc nofollow" target="_blank">丹妮尔</a></figcaption></figure><p id="1207" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi lb translated">每个软件工程师都需要知道如何用他们选择的语言进行测试。即使是一个简单的单元测试层也可以极大地提高程序的弹性，并确保它按照工程师的期望运行。Go有一个很棒的内置测试支持系统，带有全面的标志选项，可以帮助工程师高效地创建测试程序。</p><p id="6b14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将详细介绍以下内容:</p><ul class=""><li id="21d4" class="lk ll it js b jt ju jx jy kb lm kf ln kj lo kn lp lq lr ls bi translated">在Go中运行基本测试</li><li id="c0f5" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated">使用测试标志</li><li id="ee46" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated">基准和绩效</li><li id="4c9f" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated">生成代码覆盖率</li></ul><p id="0734" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们学一些围棋吧！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f2a9" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">基本测试套件</h1><p id="158b" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">让我们从头开始。为了运行我们的测试，我们需要移动到我们的Go source文件夹。从那里我们可以创建一个新的文件夹，我们将使用它作为我们测试的沙箱。让我们也创建两个目录<code class="fe ni nj nk nl b">parent</code>和一个子目录<code class="fe ni nj nk nl b">child</code>。最后，我们将添加两个测试文件<code class="fe ni nj nk nl b">parent_test.go</code>和<code class="fe ni nj nk nl b">child_test.go</code>。在Go文件的末尾添加“_test”向编译器发出信号，表明我们想要从这个源代码运行单元测试。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="2d81" class="nq mg it nl b gy nr ns l nt nu">$ go env GOPATH<br/>/Users/israelmiles/go<br/>$ cd /Users/israelmiles/go/src<br/>$ mkdir testing-go<br/>$ cd testing-go<br/>$ mkdir parent<br/>$ mkdir parent/child<br/>$ touch parent/parent_test.go<br/>$ touch parent/child/child_test.go</span></pre><p id="bb5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你需要帮助设置你的<code class="fe ni nj nk nl b">GOPATH</code>，请看这里:</p><div class="nv nw gp gr nx ny"><a href="https://stackoverflow.com/questions/21001387/how-do-i-set-the-gopath-environment-variable-on-ubuntu-what-file-must-i-edit/53026674#53026674" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">如何在Ubuntu上设置GOPATH环境变量？我必须编辑什么文件？</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">你可以像其他人建议的那样使用“导出”解决方案。我想给你提供另一个…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">stackoverflow.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ku ny"/></div></div></a></div><p id="6b49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将有<code class="fe ni nj nk nl b">parent</code>和<code class="fe ni nj nk nl b">child</code>目录来展示不同的测试方法。首先让我们将下面的代码添加到我们的<code class="fe ni nj nk nl b">parent_test.go</code>文件中。</p><h2 id="9fb0" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">parent_test.go</h2><p id="8e43" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在我们的<code class="fe ni nj nk nl b">parent</code>包中，我们的第一步是导入<code class="fe ni nj nk nl b">testing</code>包，它让我们可以访问不同的测试方法。如您所见，我们为测试函数<code class="fe ni nj nk nl b">TestMath()</code>引用了对象<code class="fe ni nj nk nl b">testing.T</code>。然后，这个函数针对go中的加法和减法运行两个不同的测试。<code class="fe ni nj nk nl b">t.Run()</code>的结构包括一个名字(在go中增加)和一个匿名函数，该函数接受对<code class="fe ni nj nk nl b">testing.T</code>的相同引用。如果我们没有通过我们设置的一些条件，我们调用<code class="fe ni nj nk nl b">t.Fail()</code>作为选项来显示我们的测试结果。</p><p id="c8d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">方法<code class="fe ni nj nk nl b">t.Run()</code>可以从多个goroutines中同时调用，但是所有这样的调用必须在测试对象<code class="fe ni nj nk nl b">t</code>的外部测试函数返回之前返回。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7e25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要的是要大写第一个字母，并使用camel case让Go编译器识别我们的测试。使用测试函数和分层的单独测试是组织测试套件的一种基本但有效的方法。</p><h2 id="3d08" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">去测试</h2><p id="0049" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">如果我们进入<code class="fe ni nj nk nl b">parent</code>目录并运行<code class="fe ni nj nk nl b">go test</code>，编译器将自动运行任何以_test.go结尾的文件。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="472e" class="nq mg it nl b gy nr ns l nt nu">$ pwd<br/>/Users/israelmiles/go/src/testing-go/parent<br/>$ go test<br/>PASS<br/>ok   testing-go/parent 0.220s</span></pre><p id="9010" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">酷，我们的测试通过了！但是如果我们想要更多的信息呢？我们可以在verbose中包含<code class="fe ni nj nk nl b">-v</code>标志，以进一步了解我们的测试是如何运行的。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="4dbb" class="nq mg it nl b gy nr ns l nt nu">$ go test -v<br/>=== RUN   TestMath<br/>=== RUN   TestMath/Addition_in_Go<br/>=== RUN   TestMath/Subtraction_in_Go<br/>--- PASS: TestMath (0.00s)<br/>    --- PASS: TestMath/Addition_in_Go (0.00s)<br/>    --- PASS: TestMath/Subtraction_in_Go (0.00s)<br/>=== RUN   TestStrings<br/>=== RUN   TestStrings/Concatenation_in_Go<br/>--- PASS: TestStrings (0.00s)<br/>    --- PASS: TestStrings/Concatenation_in_Go (0.00s)<br/>PASS<br/>ok   testing-go/parent 0.085s</span></pre><p id="8e6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以看到每个单独的测试层中运行了哪些函数。如果我们有一个分层的目录结构，我们也可以运行一个递归测试套件。</p><p id="c9c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想<strong class="js iu">运行单个测试</strong>，您可以使用<code class="fe ni nj nk nl b">-run</code>标志。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="3e86" class="nq mg it nl b gy nr ns l nt nu">$ pwd<br/>/Users/israelmiles/go/src/testing-go/parent<br/>$ go test -v -run TestMath<br/>=== RUN   TestMath<br/>=== RUN   TestMath/Addition_in_Go<br/>=== RUN   TestMath/Subtraction_in_Go<br/>--- PASS: TestMath (0.00s)<br/>    --- PASS: TestMath/Addition_in_Go (0.00s)<br/>    --- PASS: TestMath/Subtraction_in_Go (0.00s)<br/>PASS<br/>ok   testing-go/parent 0.243s</span></pre><p id="64c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还可以指定包来搜索要运行的测试。这个结构便是<code class="fe ni nj nk nl b">go test -run &lt;Test expression&gt; &lt;packages to search&gt;</code>。</p><p id="c55e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想要<strong class="js iu">多次运行测试</strong>，您可以使用<code class="fe ni nj nk nl b">-count</code>标志。例如，如果您正在执行耐力测试，这可能会很有用。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="f57c" class="nq mg it nl b gy nr ns l nt nu">$ go test -count 1 testing-go/parent<br/>ok   testing-go/parent 0.079s<br/>$ go test -count 10 testing-go/parent<br/>ok   testing-go/parent 0.310s<br/>Israels-MacBook-Pro:parent israelmiles$</span></pre><h2 id="af79" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">儿童_测试. go</h2><p id="797d" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在我们的<code class="fe ni nj nk nl b">parent</code>目录中是<code class="fe ni nj nk nl b">child</code>目录，包括<code class="fe ni nj nk nl b">child_test.go</code>。下面是我们可以添加到文件中的一个示例测试:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="ce8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们有一个更简单的设置，我们只需要检查一个条件，如果它是假的，我们就从我们的测试对象调用<code class="fe ni nj nk nl b">Error()</code>方法。</p><h2 id="ead3" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">递归测试</h2><p id="63dd" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">我们可以用<code class="fe ni nj nk nl b">go test</code>运行一个<strong class="js iu">递归测试</strong>，方法是在测试包的末尾添加<code class="fe ni nj nk nl b">/...</code>。例如:</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="f015" class="nq mg it nl b gy nr ns l nt nu">$ pwd<br/>/Users/israelmiles/go/src/testing-go<br/>$ go test -v testing-go/parent/...<br/>=== RUN   TestMath<br/>=== RUN   TestMath/Addition_in_Go<br/>=== RUN   TestMath/Subtraction_in_Go<br/>--- PASS: TestMath (0.00s)<br/>    --- PASS: TestMath/Addition_in_Go (0.00s)<br/>    --- PASS: TestMath/Subtraction_in_Go (0.00s)<br/>=== RUN   TestStrings<br/>=== RUN   TestStrings/Concatenation_in_Go<br/>--- PASS: TestStrings (0.00s)<br/>    --- PASS: TestStrings/Concatenation_in_Go (0.00s)<br/>PASS<br/>ok   testing-go/parent (cached)<br/>=== RUN   TestMultiplication<br/>--- PASS: TestMultiplication (0.00s)<br/>PASS<br/>ok   testing-go/parent/child 0.295s</span></pre><p id="0e1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您知道如何:</p><ul class=""><li id="f45d" class="lk ll it js b jt ju jx jy kb lm kf ln kj lo kn lp lq lr ls bi translated">用<code class="fe ni nj nk nl b">go test</code>运行测试</li><li id="a541" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated">使用<code class="fe ni nj nk nl b">-count</code>标志多次运行测试</li><li id="47b6" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated">使用<code class="fe ni nj nk nl b">testing.T.Run()</code>创建测试</li><li id="e1f9" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated">打印带有<code class="fe ni nj nk nl b">-v</code>标志的测试信息</li><li id="c23e" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated">使用<code class="fe ni nj nk nl b">-run</code>标志执行单个测试</li><li id="359e" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated">通过将<code class="fe ni nj nk nl b">/...</code>添加到您的包中来执行递归测试套件</li></ul></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="323b" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">测试基准</h1><p id="b6db" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">让我们加强我们的项目结构。我们将向项目根文件夹添加三个文件，使用循环结构和递归格式来计算和测试斐波那契数列。</p><h2 id="51af" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">斐波那契，开始</h2><p id="9702" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">使用切片和递归找到斐波那契数列的两种方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="3272" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">fibonacci_test.go</h2><p id="af1b" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">这里我们有fibonacci序列的前12个值来测试。然后我们调用两个测试反循环和递归方法计算序列。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oy oz l"/></div></figure><h2 id="7566" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">main.go</h2><p id="ece1" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">驱动文件<code class="fe ni nj nk nl b">main.go</code> simple调用fibonacci方法10次，使用<code class="fe ni nj nk nl b">strconv.Itoa()</code>从int转换为string。您可以运行它来查看每个斐波那契函数的输出。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="217a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用<code class="fe ni nj nk nl b">go test -v</code>运行我们的测试将会给出:</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="e155" class="nq mg it nl b gy nr ns l nt nu">=== RUN   TestFib<br/>=== RUN   TestFib/Fibonnaci_Loop<br/>=== RUN   TestFib/Fibonnaci_Recursion<br/>--- PASS: TestFib (0.00s)<br/>    --- PASS: TestFib/Fibonnaci_Loop (0.00s)<br/>    --- PASS: TestFib/Fibonnaci_Recursion (0.00s)<br/>PASS<br/>ok   testing-go 0.092s</span></pre><h2 id="ba53" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">标杆管理</h2><p id="8b1f" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">如果您想很好地了解您的测试有多高效，除了创建一个基准方法之外，您还可以使用<code class="fe ni nj nk nl b">-bench</code>标志。首先，将下面的代码添加到<code class="fe ni nj nk nl b">fibonacci_test.go</code>中。要创建一个基准方法，只需以<code class="fe ni nj nk nl b">Benchmark</code>作为函数名的开头，并将对<code class="fe ni nj nk nl b">testing.B</code>的引用作为参数。值<code class="fe ni nj nk nl b">b.N</code>由编译器分配，是我们将运行<code class="fe ni nj nk nl b">FibonacciLoop</code>的次数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="7d2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面，我们的第一个基准测试是用第一个序列值的<code class="fe ni nj nk nl b">FibonacciLoop()</code>方法运行的。第7行的第二个基准方法是针对第100个斐波那契数列值的。如果我们针对测试运行基准测试，我们可以看到计算斐波那契数列是如何变得越来越困难的。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="e950" class="nq mg it nl b gy nr ns l nt nu">$ go test -v -bench Fib<br/>=== RUN   TestFib<br/>=== RUN   TestFib/Fibonnaci_Loop<br/>=== RUN   TestFib/Fibonnaci_Recursion<br/>--- PASS: TestFib (0.01s)<br/>    --- PASS: TestFib/Fibonnaci_Loop (0.00s)<br/>    --- PASS: TestFib/Fibonnaci_Recursion (0.01s)<br/>goos: darwin<br/>goarch: amd64<br/>pkg: testing-go<br/>BenchmarkFibonacciLoop1<br/>BenchmarkFibonacciLoop1-8      43454248         25.2 ns/op<br/>BenchmarkFibonacciLoop100<br/>BenchmarkFibonacciLoop100-8     4285092        277 ns/op<br/>PASS<br/>ok   testing-go 2.694s</span></pre><p id="0fa5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看我们的正则表达式<code class="fe ni nj nk nl b">Fib</code>是如何执行两个<code class="fe ni nj nk nl b">FibonacciLoop</code>方法的？不仅如此，我们还可以看到，计算第1个斐波那契数列值每次调用大约需要25.2纳秒，而第100个斐波那契数列值每次调用大约需要277纳秒！</p><p id="c6d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，通过包含<code class="fe ni nj nk nl b">-benchmem</code>标志，我们可以看到我们的函数使用了多少内存。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="a9e1" class="nq mg it nl b gy nr ns l nt nu">$ go test -v -bench . -benchmem<br/>=== RUN   TestFib<br/>=== RUN   TestFib/Fibonnaci_Loop<br/>=== RUN   TestFib/Fibonnaci_Recursion<br/>--- PASS: TestFib (0.01s)<br/>    --- PASS: TestFib/Fibonnaci_Loop (0.00s)<br/>    --- PASS: TestFib/Fibonnaci_Recursion (0.01s)<br/>goos: darwin<br/>goarch: amd64<br/>pkg: testing-go<br/>BenchmarkFibonacciLoop1<br/>BenchmarkFibonacciLoop1-8   42072594 24.9 ns/op 32 B/op  1 allocs/op<br/>BenchmarkFibonacciLoop100<br/>BenchmarkFibonacciLoop100-8 4268587  280 ns/op  896 B/op 1 allocs/op<br/>PASS<br/>ok   testing-go 2.780s</span></pre><p id="ae93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以看到，第1个序列值每次调用需要32个字节，第100个值需要896个字节。你认为递归方法需要多少时间？</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="45a4" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">生成代码覆盖率</h1><p id="f068" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">好了，到目前为止你已经学到了很多！让我们用最后一个有用的工具来测试Go。如果我们想知道测试用例覆盖了多少代码，我们可以使用<code class="fe ni nj nk nl b">-cover</code>标志。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="e2be" class="nq mg it nl b gy nr ns l nt nu">$ go test -v -cover testing-go<br/>=== RUN   TestFib<br/>=== RUN   TestFib/Fibonnaci_Loop<br/>=== RUN   TestFib/Fibonnaci_Recursion<br/>--- PASS: TestFib (0.01s)<br/>    --- PASS: TestFib/Fibonnaci_Loop (0.00s)<br/>    --- PASS: TestFib/Fibonnaci_Recursion (0.01s)<br/>PASS<br/>coverage: 64.7% of statements<br/>ok   testing-go 0.112s</span></pre><p id="f62a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们覆盖了<code class="fe ni nj nk nl b">fibonacci.go</code>和<code class="fe ni nj nk nl b">main.go</code>中所有代码的64.7%。如果您取消<code class="fe ni nj nk nl b">main.go</code>中的打印报表，您可以将覆盖率提高到73.3%。针对斐波那契方法的进一步的目标测试案例将会增加你的覆盖率。</p><p id="3de0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>如果你测试失败了，<code class="fe ni nj nk nl b">-cover</code>标志实际上会在编译之前重写你的源代码(别问我怎么重写)。因此，<em class="pa">不要</em>在任何基准测试中使用<code class="fe ni nj nk nl b">-cover</code>标志。</p><h2 id="7dac" class="nq mg it bd mh on oo dn ml op oq dp mp kb or os mt kf ot ou mx kj ov ow nb ox bi translated">但是我的代码的哪些部分被覆盖了呢？</h2><p id="57f4" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">如果您想查看哪些代码语句被测试覆盖，您可以包含<code class="fe ni nj nk nl b">-coverprofile</code>标志。这需要一个附加信息的文件，我们称之为<code class="fe ni nj nk nl b">cover.out</code>。如果你试图立即阅读<code class="fe ni nj nk nl b">cover.out</code>的作品，你不会得到太多有用的信息。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="d9aa" class="nq mg it nl b gy nr ns l nt nu">$ go test -coverprofile cover.out<br/>$ cat cover.out<br/>mode: set<br/>testing-go/fibonnaci.go:4.31,6.14 2 1<br/>testing-go/fibonnaci.go:9.5,11.29 3 1<br/>testing-go/fibonnaci.go:14.5,14.16 1 1<br/>testing-go/fibonnaci.go:6.14,8.6 1 1<br/>testing-go/fibonnaci.go:11.29,13.6 1 1<br/>testing-go/fibonnaci.go:18.36,19.15 1 1<br/>testing-go/fibonnaci.go:22.5,22.61 1 1<br/>testing-go/fibonnaci.go:19.15,21.6 1 1<br/>testing-go/main.go:3.13,4.29 1 0<br/>testing-go/main.go:7.5,7.29 1 0<br/>testing-go/main.go:4.29,6.6 1 0<br/>testing-go/main.go:7.29,9.6 1 0</span></pre><p id="7fcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了以更有用的格式查看我们的覆盖范围，使用<code class="fe ni nj nk nl b">go tool cover</code>命令。如果您调用<code class="fe ni nj nk nl b">-html</code>标志，您可以将它分配给我们新的输出文件<code class="fe ni nj nk nl b">cover.out</code>，以便生成一个综合报告。</p><pre class="kp kq kr ks gt nm nl nn no aw np bi"><span id="6bb0" class="nq mg it nl b gy nr ns l nt nu">$ go tool cover -html=cover.out</span></pre><p id="9bb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在您的默认web浏览器中打开一个覆盖范围摘要:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pc pd di pe bf pf"><div class="gh gi pb"><img src="../Images/0bcd2bab9bcc908eb9b429403c29322a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbXmbdkmm3uF1Mu3BLFHFw.png"/></div></div></figure><p id="5e28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，斐波那契方法实际上已经完全涵盖了！但是如果我们看看主要的Go文件…</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="pc pd di pe bf pf"><div class="gh gi pg"><img src="../Images/74b297da974b7ee00faa9d6c920509fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eXKo-0bbPewiuHYhBUfR0g.png"/></div></div></figure><p id="1cc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到这实际上是我们缺乏覆盖面的根源。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="7bf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢这篇文章，并学到一些新的东西。关于在Go中进行测试，还有很多信息需要学习，但是本文涵盖了启动和运行所需的主要基础知识。如果你看到了任何值得注意的东西，或者想听到更多关于这篇文章的部分，我鼓励你在下面留下评论！非常感谢你的阅读。</p></div></div>    
</body>
</html>