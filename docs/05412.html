<html>
<head>
<title>Typescript: Type signatures for any function.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript:任何函数的类型签名。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-type-signatures-for-any-function-c21a22596d1c?source=collection_archive---------1-----------------------#2020-08-26">https://levelup.gitconnected.com/typescript-type-signatures-for-any-function-c21a22596d1c?source=collection_archive---------1-----------------------#2020-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2127ca91794b43a3f12718642afdcb5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P5X2Z3VsDXN8EmhjoA7bQ.jpeg"/></div></div></figure><p id="67e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天我将描述如何为各种javascript函数编写类型签名。这将有助于读者缩小类型，增加可靠性，类型依赖性，等等。</p><p id="e4c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类型签名就像任何给定代码段的蓝图。它告诉编译器事物是什么。类型良好的程序更可靠，运行速度更快。它们还为编译器提供了许多额外的信息，帮助我们更快地识别错误。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e748" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">函数类型签名的“hello world”。</h1><p id="0c5f" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">对函数进行类型化的最基本方法是声明参数和返回。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c976" class="ms lh it mo b gy mt mu l mv mw">const returnArg = (arg:number):number =&gt; {<br/>return arg<br/>}</span></pre><p id="259a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，参数是数字类型的，括号与函数体的返回语句具有相同的类型声明。</p><p id="e99d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们改变返回，我们可以改变类型签名。这是完全相同的函数，除了它返回一个字符串而不是一个数字。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b0fc" class="ms lh it mo b gy mt mu l mv mw">const returnArg = (arg:number):string =&gt; {<br/>return "yow"<br/>}</span></pre><p id="0934" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数体内部的任何内容都与typescript中的其他内容类型相同。函数体可以被视为它自己的独立程序。</p><p id="fd62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于Typescript的推断，如果不总是键入return语句，效果几乎一样。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="fcd9" class="ms lh it mo b gy mt mu l mv mw">const returnArg = (first:number, second:number) =&gt; {<br/>return first + second<br/>}</span></pre><p id="c858" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们没有显式地输入函数return，但是因为两个参数都是显式的数字，所以编译器足够聪明，知道它们不能是其他任何数字。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b3b6" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">类型级别和值级别</h1><p id="330d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我们也可以将类型签名从函数语法中提取出来，单独编写。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="629d" class="ms lh it mo b gy mt mu l mv mw">//type level<br/>type add = (a:number, b:number) =&gt; number</span><span id="1f3d" class="ms lh it mo b gy mx mu l mv mw">//value level<br/>let addNow:add = (a, b) =&gt; {</span><span id="5122" class="ms lh it mo b gy mx mu l mv mw">return a+b</span><span id="56f1" class="ms lh it mo b gy mx mu l mv mw">}</span></pre><p id="0a47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们已经严格地分离了类型级和值级代码，但是这个函数的工作方式是一样的，并且和其他函数一样类型化。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b7fc" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">同样的游戏，不同的名字</h1><p id="3343" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">这两个的编译方式是一样的。一个是速记语法，另一个是完整签名。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="86c7" class="ms lh it mo b gy mt mu l mv mw">//shorthand<br/>type add = (a:number, b:number) =&gt; number</span><span id="ee8a" class="ms lh it mo b gy mx mu l mv mw">//full signature</span><span id="3a65" class="ms lh it mo b gy mx mu l mv mw">type add = {</span><span id="3f7f" class="ms lh it mo b gy mx mu l mv mw">(a:number, b:number):number<br/>}</span></pre><h1 id="359f" class="lg lh it bd li lj my ll lm ln mz lp lq lr na lt lu lv nb lx ly lz nc mb mc md bi translated">上下文类型</h1><p id="4882" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">我们从编译器得到的推论比更清晰的语法给我们提供了更多的能力。我们可以为函数编写类型签名，然后在声明它们之前调用它们。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/dee34aeb1cdcd109ef1986cb03716a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*OEwtBB4gheucxx1g4znHMw.jpeg"/></div></figure><p id="3d57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们已经告诉编译器，有一个带有特定类型签名的函数“c ”,我们想调用它n次。这可能看起来很奇怪，因为我们只提供了一个签名，而不是我们通常会提供的声明体。</p><p id="fb77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，“c”实际上不会被调用，直到父函数“timesTwo”被调用。当我们准备好的时候，我们可以内联声明“c”。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="dc0a" class="ms lh it mo b gy mt mu l mv mw">timesTwo(n =&gt; console.log(n), 8)</span></pre><p id="3723" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们调用“timesTwo”时，它足够聪明地将我们的内联函数识别为“c ”,并采用我们声明的类型签名。</p><p id="7e6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，它从0开始将每次迭代乘以2。</p><p id="fd4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">理解这一点的一个好方法是，我们将为变量“c”传递一个函数，我们知道它将以这种特殊的方式运行，但我们不知道“c”看起来是什么样的，直到调用“timesTwo”。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0943" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">重载函数</h1><p id="7904" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">在大多数静态类型语言中，我们希望我们的函数尽可能的隔离和调整。换句话说…理想情况下，我们的函数将只接受一个东西并输出一个东西，我们可以尽可能地保持我们的类型。然而，由于Javascript是一种动态语言，我们无法避免重载函数。尽管它们的结构很脆弱，但它们已经融入了我们日常使用的大多数公共库和约定中。</p><blockquote class="ne"><p id="8a0a" class="nf ng it bd nh ni nj nk nl nm nn ky dk translated">重载函数是具有多个调用签名的函数</p></blockquote><p id="0238" class="pw-post-body-paragraph kb kc it kd b ke no kg kh ki np kk kl km nq ko kp kq nr ks kt ku ns kw kx ky im bi translated">动态语言打开了重载函数的大门。它们随处可见。</p><p id="8cf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，假设我们想要一个多用途函数，用数字来做事情。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/9a6e19828c7b07bcafb1f2b9a3294a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lf0uFr6O5DXQ1miCxowiRw.jpeg"/></div></div></figure><p id="30c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它像其他函数一样工作，除了我们必须在函数体中提供逻辑，告诉编译器我们在做不同的事情。</p><p id="d0cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以在类型上使用OR运算符来处理重载函数。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/2eb0a9a577d4e99960c3a06af5acb384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFNpp47t2Mk_satEimx2uw.jpeg"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="abec" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">无商标消费品</h1><p id="b2c3" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">假设我们想输入一些东西，尽管我们不知道它看起来像什么。作为一个比喻。我们不知道外星人访问地球时会是什么样子或行为，但我们知道当他们来的时候，我们会试着和他们交流。</p><p id="0c52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样的逻辑也适用于我们的编程。我们可以创建一个函数，说它将接收一些值，忽略细节，然后尝试用它做一个特定的任务。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/7a5151a73984fe25862459ea744ec33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*NqAgXtwQ00XJZeFZo3vqXg.jpeg"/></div></div></figure><p id="25d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">泛型的语法是通过将别名放在函数名后面的箭头括号中来实现的。</p><p id="f865" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们说某样东西是某种类型，这个函数的返回语句也是同一种类型，不管是什么类型。</p><p id="e327" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">泛型最常用于动态语言的内置函数中。</p><p id="69d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，在Javascript中，我们有map函数。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="d8b0" class="ms lh it bd li nw nx dn lm ny nz dp lq km oa ob lu kq oc od ly ku oe of mc og bi translated">地图</h2><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/1cac13a20260bd117661faf9f488b5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqxL1qO9HO7GgEzeKUv_-g.jpeg"/></div></div></figure><p id="f74e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过告诉编译器我们将传入某个泛型数组来键入这个函数，输出将是一个不同的泛型数组。关于这些类型，我们唯一能确定的是返回的数组和输入数组的类型不同。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/deff967f572c297a50d623944674b05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aEttvDA2t4zhAQIc1ITGQ.jpeg"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="7f47" class="ms lh it bd li nw nx dn lm ny nz dp lq km oa ob lu kq oc od ly ku oe of mc og bi translated">过滤器</h2><p id="6c5d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">过滤器也是一样。我们传入一个通用数组，在返回一个数组之前，删除所有不符合标准的值。filter的一个关键区别是，我们实际上并没有改变输入数组中的元素，因此输出数组具有相同的类型。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/3537e6e4619417a7928a06c95a6d793a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayGh2f5F4hCOqebk_i95ow.jpeg"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="ed73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时我们需要通用，但是我们仍然希望缩小我们的类型。例如，假设我们想要一个通用函数，它将专门处理字符串数组。</p><p id="9677" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这叫做给我们的泛型加上一个上限。</p><h2 id="ba6b" class="ms lh it bd li nw nx dn lm ny nz dp lq km oa ob lu kq oc od ly ku oe of mc og bi translated">加入</h2><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/76594a7270cafb115cedd4163fe3c845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OpgC_q-7Nz0ItjT81YRIw.jpeg"/></div></div></figure><p id="683f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们创建了通用的Join函数，只是它只对字符串数组有效。</p><p id="d5e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们想要构造特定领域的泛型函数时，上限泛型变得更加有用。假设我们有一个程序，它对球进行了分级，我们想创建一个通用函数，这个函数只适用于我们在健身房里找到的项目。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/9609a3ceeb8ce998a463acd6682616ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*8IHNoAt_cdiAWSExdf-Sww.jpeg"/></div></figure><p id="bf18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们就是这么做的。使用“球映射器”,我们可以映射到任何子分类上，但它只对球层次内的对象有效。</p><h1 id="74bf" class="lg lh it bd li lj my ll lm ln mz lp lq lr na lt lu lv nb lx ly lz nc mb mc md bi translated">结论</h1><p id="0fd4" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">这就是我目前要讲的全部内容。</p><p id="caf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，还有其他约定可以使用。其中一个主要的是生成器函数，但是我跳过了它们，因为它们在最近的版本中没有得到很好的支持。</p><p id="8988" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下次见。</p></div></div>    
</body>
</html>