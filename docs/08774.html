<html>
<head>
<title>Why Cognitive and Cyclomatic Complexity Matters in Software Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么认知和圈复杂度在软件开发中很重要</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-cognitive-and-cyclomatic-complexity-matters-in-software-development-5fce1efb56ab?source=collection_archive---------0-----------------------#2021-06-03">https://levelup.gitconnected.com/why-cognitive-and-cyclomatic-complexity-matters-in-software-development-5fce1efb56ab?source=collection_archive---------0-----------------------#2021-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d5c4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">固执己见的</h2><div class=""/><div class=""><h2 id="605d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">决定代码可理解性和可维护性的两个基本概念。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/63466b01e46c13dc93f919ebbc15f1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ioeid6P_x_KAgvgkq6-Vg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="lh li ep" href="https://medium.com/u/7c7a43b3d9de?source=post_page-----5fce1efb56ab--------------------------------" rel="noopener" target="_blank">尼克拉斯·米勒德</a>提供</figcaption></figure><p id="662d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我经常抨击花括号应用程序的编码人员，对<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/remove-your-if-else-and-switch-cases-1ed2b625b4cf">降低复杂性</a>不以为然，认为任何没有副作用的问题都可以通过添加已经无法理解的<code class="fe mg mh mi mj b">if-elseif-else</code>或<code class="fe mg mh mi mj b">switch</code>语句来解决。</p><p id="f6f4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是，我从来没有真正解释过我的基本推理和指导原则——除此之外，传统的分支相当于硬编码，看起来很糟糕。</p><blockquote class="mk ml mm"><p id="56a4" class="lj lk mn ll b lm ln kd lo lp lq kg lr mo lt lu lv mp lx ly lz mq mb mc md me im bi translated">侧边栏:我想保持这种实用性。我不会对你做任何学术研究。如果你更感兴趣，我在最后提供了链接。</p></blockquote></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="3d05" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果易于理解、可扩展、可维护和可工作的代码是软件开发的巅峰，那么为什么大量的代码完全不可读、更改起来很痛苦，并且会因为最轻微的错误输入而中断呢？</p><blockquote class="my"><p id="cfc0" class="mz na it bd nb nc nd ne nf ng nh me dk translated">软件开发是一门手艺。你的代码中充斥着你解决问题的固执己见的方法——老实说，这很好。</p></blockquote><p id="a0fd" class="pw-post-body-paragraph lj lk it ll b lm ni kd lo lp nj kg lr ls nk lu lv lw nl ly lz ma nm mc md me im bi translated">阅读自己的代码很容易。阅读他人，并不总是那么容易。</p><p id="2ea8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">使用经过试验和测试的、无处不在的模式和方法使你的代码更容易阅读、理解甚至改变。</p><p id="9492" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，任何不理解你所应用的模式的人都会说你的代码是反模式的混乱——仅仅是因为他们甚至没有尝试去学习一些新的东西，或者花一点时间去理解为什么你以某种方式解决了一个问题。</p><p id="9b73" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">了解什么是圈复杂度和认知复杂度将有助于你编写更好、更容易理解的代码，即使你所使用的设计模式并不被你团队中的每个人(或者网络上的随机人群)所理解。</p><p id="b540" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">🔔想要更多这样的文章吗？在这里签名。</p><h1 id="a667" class="nn no it bd np nq nr ns nt nu nv nw nx ki ny kj nz kl oa km ob ko oc kp od oe bi translated">低圈复杂度使得你的代码易于维护和测试。</h1><p id="bce3" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated">因此，在这里稍微倒退一下，圈复杂度实际上是一种“古老的”代码复杂度的客观度量。圈复杂度是在1976年被创造出来的，所以不用说，它并不是用来描述当今编程语言的复杂性的。</p><p id="441f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，它在告诉你的if-else或switch有多糟糕方面做得很好。在使用传统分支时，通常会看到圈复杂度飙升。<a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/remove-your-if-else-and-switch-cases-1ed2b625b4cf">因此，完全移除分支通常是有意义的。</a></p><p id="0732" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">看看下面的开关表达式。</p><p id="8cfb" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我告诉你这个方法很难维护，你可能会调用bullsh*t，而你最初的想法是这个代码完全合理。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/13f426a6aaa18e15c3a8bca19f80c2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_SVmp_WZofPK0ILWTIzHQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">圈复杂度高的开关表达式。</figcaption></figure><p id="523d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我不想打断你，但是它的圈复杂度是11。通常，推荐的阈值是10。</p><p id="f4fd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">那么这意味着什么呢？当然，这段代码不可能都是坏的。很容易读，对吧？</p><p id="5c40" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">你说得对。这段特殊的代码很容易阅读。我认为即使是最初级的开发人员也可以阅读这段相当琐碎的代码片段。(顺便问一句，我们真的要根据学弟学妹的能力来评判自己的代码吗？)</p><p id="a649" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我们纯粹谈论圈复杂度时，可读性不是我们主要关心的。</p><p id="eb9b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这些问题主要与可维护性和可测试性有关。</p><p id="33ff" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这种情况下，每次需要新功能时，不仅要进一步增加相同方法的复杂性，而且还要修改现有代码以允许新的行为——如果你非常重视坚实的原则，你就知道这是行不通的。</p><p id="f7a3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">其次，高圈复杂度也会导致高测试工作量。必须覆盖通过方法或模块的所有路径。复杂性越高，需要覆盖的路径就越多，这并不总是一项简单明了的任务——导致单个方法或模块的测试工作量更大。</p><p id="441d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">还发现高圈复杂度与大量缺陷密切相关。所以ISO 26262要求软件开发人员保持较低的圈复杂度是有原因的。</p><h1 id="87a2" class="nn no it bd np nq nr ns nt nu nv nw nx ki ny kj nz kl oa km ob ko oc kp od oe bi translated">可理解的代码是低认知复杂性的结果。</h1><p id="27ee" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated">圈复杂度并不总是你想要遵循的度量。例如，一个看起来很糟糕的嵌套了<code class="fe mg mh mi mj b">if</code>的循环和一个结构良好的开关可能具有相同的圈复杂度，尽管其中一个看起来一塌糊涂。</p><p id="d752" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有很多方法可以增加复杂性。基本上，下面的任何结构都会影响我们理解和推理代码的能力。</p><p id="78b3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><code class="fe mg mh mi mj b">if</code>、<code class="fe mg mh mi mj b">else if</code>、<code class="fe mg mh mi mj b">else</code>、三元、<code class="fe mg mh mi mj b">switch</code>、<code class="fe mg mh mi mj b">for</code>、<code class="fe mg mh mi mj b">foreach</code>、<code class="fe mg mh mi mj b">while/do-while</code>、<code class="fe mg mh mi mj b">try-catch</code>、嵌套、断流。</p><p id="4ef7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每当你打破自然的“阅读流程”，你就增加了认知的复杂性。</p><p id="52d6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果我们以前面的代码为例，将每个分支分解成自己的方法或对象，那么测试工作就落到了地上，对代码的推理现在变得完全无关紧要了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/c6ddb83196a64b8a93a27891efb04abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U46KmrvMdSwcpO9MKk8xZA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">没有应用格式。</figcaption></figure><p id="97b8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以毫不费力地分析每个“分支”。没有一个“WTF”时刻。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/6a82c85a916bbcf2c0fd68c5048564e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YShZJtezscw3EKHeN-PAqg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">日期格式为yyyy-MM-dd。</figcaption></figure><p id="798e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当然——相反的观点是，我们没有将所有东西都放在一个(不断扩展的)地方，而是将逻辑分割到多个类和方法中。</p><p id="3435" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有些人会认为这是一件坏事。</p><p id="a13a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但其实真的不是。</p><ol class=""><li id="d49b" class="om on it ll b lm ln lp lq ls oo lw op ma oq me or os ot ou bi translated">现在，您可以单独检查每一段代码。</li><li id="d661" class="om on it ll b lm ov lp ow ls ox lw oy ma oz me or os ot ou bi translated">您可以通过添加新的类而不是修改现有的类来轻松扩展功能。</li><li id="f926" class="om on it ll b lm ov lp ow ls ox lw oy ma oz me or os ot ou bi translated">每段代码都有一个明确的职责。</li><li id="a0d5" class="om on it ll b lm ov lp ow ls ox lw oy ma oz me or os ot ou bi translated">查明bug非常容易。</li><li id="8495" class="om on it ll b lm ov lp ow ls ox lw oy ma oz me or os ot ou bi translated">测试是琐碎的。</li><li id="21cb" class="om on it ll b lm ov lp ow ls ox lw oy ma oz me or os ot ou bi translated">由于您只需要理解接口，因此系统理解能力得到了提高。此外，底层实现是从客户端代码中抽象出来的。</li></ol><h1 id="7200" class="nn no it bd np nq nr ns nt nu nv nw nx ki ny kj nz kl oa km ob ko oc kp od oe bi translated">你的主要收获。</h1><p id="985b" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated">有意识地应用久经考验的设计模式极大地提高了代码的可读性、可理解性和系统理解性。</p><p id="45f1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，有些人可能会盲目地将您的代码作为“垃圾”丢弃，因为他们缺乏对所应用的设计模式及其效用的理解。</p><p id="0d58" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">不管读者的体验如何，编写具有低圈复杂度和认知复杂度的代码将增加可维护性、可测试性和可理解性。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="61d5" class="nn no it bd np nq pa ns nt nu pb nw nx ki pc kj nz kl pd km ob ko pe kp od oe bi translated">让我们保持联系！</h1><p id="c086" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated"><a class="ae mf" href="https://nmillard.medium.com/subscribe" rel="noopener">点击这里</a>订阅时事通讯，获取类似文章的通知，并查看YouTube新频道<a class="ae mf" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank"><em class="mn">(@尼可拉斯·米勒德)</em> </a></p><p id="fdcf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><em class="mn">连接上</em> <a class="ae mf" href="https://www.linkedin.com/in/nicklasmillard/" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> LinkedIn </em> </a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="b2bb" class="nn no it bd np nq pa ns nt nu pb nw nx ki pc kj nz kl pd km ob ko pe kp od oe bi translated">好奇者的资源。</h1><p id="2c3d" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated"><a class="ae mf" href="https://www.sonarsource.com/docs/CognitiveComplexity.pdf" rel="noopener ugc nofollow" target="_blank">认知复杂性</a>作者G. Ann Campbell来自SonarSource</p><p id="e958" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">软件度量(ISO 26262) 作者乔纳森·摩尔</p><p id="161f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><a class="ae mf" href="https://docs.codeclimate.com/docs/maintainability#section-checks" rel="noopener ugc nofollow" target="_blank">代码气候的可维护性</a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="3e41" class="nn no it bd np nq pa ns nt nu pb nw nx ki pc kj nz kl pd km ob ko pe kp od oe bi translated">分级编码</h1><p id="ef52" class="pw-post-body-paragraph lj lk it ll b lm of kd lo lp og kg lr ls oh lu lv lw oi ly lz ma oj mc md me im bi translated">感谢您成为我们社区的一员！<a class="ae mf" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅我们的YouTube频道</a>或者加入<a class="ae mf" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> Skilled.dev编码面试课程</strong> </a>。</p></div></div>    
</body>
</html>