<html>
<head>
<title>Serverless Lambda Destinations 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器Lambda目的地🚀</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/serverless-lambda-destinations-146f8b3c3456?source=collection_archive---------1-----------------------#2021-07-13">https://levelup.gitconnected.com/serverless-lambda-destinations-146f8b3c3456?source=collection_archive---------1-----------------------#2021-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ab06855049b6030b0e4a77cab520db33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmF2NNXW7oKN5swSRV4lfA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@beastydesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> beasty拍摄。</a> on <a class="ae jd" href="https://unsplash.com/collections/9249086/geometric-architecture?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><div class=""/><h1 id="df5a" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="1b6b" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这篇文章将涵盖<a class="ae jd" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>的一个功能，该功能自2019年冬季以来一直存在，但许多开发人员和架构师并不知道它，或者以我的经验来看并不典型地利用它— <a class="ae jd" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations" rel="noopener ugc nofollow" target="_blank"> Lambda destinations </a>。知道这个特性是可用的，并在设计新的解决方案时把它放在心里，这可能是值得的。🛠</p><p id="7c25" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我添加了下面的基本代码repo，在这里显示了一个小的示例应用程序<a class="ae jd" href="https://github.com/leegilmorecode/serverless-lambda-destinations" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="813d" class="kd ke jg bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">目的地是如何工作的？</h1><p id="b822" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Lambda目的地允许您自动将来自异步lambda调用的<strong class="ld jh">成功</strong>或<strong class="ld jh">失败</strong>场景路由到四个AWS服务目的地，而无需编写粘合代码！</p><p id="5e0e" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">想象一个非常小的<a class="ae jd" href="https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html" rel="noopener ugc nofollow" target="_blank">步骤功能或快速工作流</a>，当它与一些基本的成功/失败路由过度时，不需要创建状态机。</p><p id="b1a7" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这基本上意味着在lambda函数中，您不需要引入相关的AWS SDK并编写和测试代码来将成功和失败的有效载荷发送给每个不同的消费者！🥳</p><blockquote class="mq mr ms"><p id="0004" class="lb lc mt ld b le lz lg lh li ma lk ll mu mb lo lp mv mc ls lt mw md lw lx ly ij bi translated">一种常见的事件驱动微服务架构模式是使用队列或消息总线进行通信。这有助于弹性和可伸缩性。Lambda异步调用可以将事件或消息放到<a class="ae jd" href="https://aws.amazon.com/sns/" rel="noopener ugc nofollow" target="_blank">亚马逊简单通知服务</a> (SNS)、<a class="ae jd" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank">亚马逊简单队列服务</a> (SQS)或<a class="ae jd" href="https://aws.amazon.com/eventbridge/" rel="noopener ugc nofollow" target="_blank">亚马逊事件桥</a>上进行进一步处理。以前，您需要在Lambda函数中编写SQS/SNS/EventBridge处理代码，并自己管理重试和失败。</p><p id="f3d3" class="lb lc mt ld b le lz lg lh li ma lk ll mu mb lo lp mv mc ls lt mw md lw lx ly ij bi translated">使用目标，您可以将异步函数结果作为执行记录路由到目标资源，而无需编写额外的代码。执行记录包含JSON格式的请求和响应的详细信息，包括版本、时间戳、请求上下文、请求有效负载、响应上下文和响应有效负载。对于每个执行状态，比如<em class="jg">成功</em>或<em class="jg">失败</em>，你可以选择四个目的地之一:另一个Lambda函数、SNS、SQS或EventBridge。Lambda还可以被配置为将不同的执行结果路由到不同的目的地。朱利安·伍德。亚马逊网络服务，无服务器开发者倡导者。</p></blockquote><p id="6226" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下图很好地概述了Lambda目的地的工作方式以及通常涉及的服务:</p><figure class="my mz na nb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mx"><img src="../Images/f73ef0c9eb96eb7ea36d5721a55d2fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QygEXfU9LzpVBgKV4vFdIg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://aws.amazon.com/blogs/compute/introducing-aws-lambda-destinations/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/compute/introducing-AWS-lambda-destinations/</a></figcaption></figure><p id="0621" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果您登录AWS控制台并选择一个新的或现有的lambda，您将看到以下目标类型，如上图所示:</p><figure class="my mz na nb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/a50de5a24b3bd7d5ad8e26f4683350e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1puOHqeqOskxuO8hpY_sg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">lambda异步调用一次失败和成功的可用目标</figcaption></figure></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="b62a" class="kd ke jg bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">我何时使用目的地？</h1><p id="6d02" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果您在无服务器架构中构建一个流，需要将成功或失败记录路由到两个独立的AWS服务，那么lambda destinations可能是您的好朋友！</p><p id="7bfb" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这意味着您不需要使用AWS SDK在处理lambda中编写粘合代码来将有效负载推送到给定的服务。下面是一个虚构的例子:</p><figure class="my mz na nb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/f4ae9da4d7a86c88cdf7272015b32585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOCceFCGx1n5KR8txAyNPw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">显示目的地何时有用的基本示例</figcaption></figure><p id="1de8" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在本例中，流程是:</p><ol class=""><li id="d6b3" class="ne nf jg ld b le lz li ma lm ng lq nh lu ni ly nj nk nl nm bi translated">一个API网关端点接受一个基本的支付负载，看起来像这样:<code class="fe nn no np nq b">{ “paymentId” : “123” }</code></li><li id="5f93" class="ne nf jg ld b le nr li ns lm nt lq nu lu nv ly nj nk nl nm bi translated">有效负载被直接路由到<a class="ae jd" href="https://aws.amazon.com/sns/?whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;whats-new-cards.sort-order=desc" rel="noopener ugc nofollow" target="_blank"> AWS SNS </a>，无需计算层。</li><li id="4b20" class="ne nf jg ld b le nr li ns lm nt lq nu lu nv ly nj nk nl nm bi translated">A ' <em class="mt">处理付款</em> ' lambda尝试处理付款，并且:</li></ol><p id="b71b" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在<strong class="ld jh">成功时</strong>使用lambda目的地将有效负载路由到一个“<em class="mt">支付通知</em>”<a class="ae jd" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank">SQS队列</a> <strong class="ld jh">，该有效负载由一个“<em class="mt">通知客户</em>”lambda提取，以向他们发送电子邮件或SMS。<br/>在<strong class="ld jh">失败</strong>时，有效载荷被路由到一个“<em class="mt">失败的支付</em>”SQS排队等待一个“<em class="mt">通知支付团队</em>”λ来取货，以通过电子邮件通知相关团队(<strong class="ld jh">再次使用λ目的地</strong>)。</strong></p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="b7e4" class="kd ke jg bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">如何使用无服务器框架进行配置？</h1><p id="cf56" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">无服务器框架使得Lambda目的地的配置非常简单，这里显示为<code class="fe nn no np nq b">serverless.yml</code>文件中Lambda的基本示例集:</p><pre class="my mz na nb gt nw nq nx ny aw nz bi"><span id="8e11" class="oa ke jg nq b gy ob oc l od oe">functions:<br/>  helloStarting:<br/>    handler: handler.starting<br/>    destinations:<br/>      onSuccess: helloSuccess<br/>      onFailure: helloFailure<br/>  helloSuccess:<br/>    handler: success.handler<br/>  helloFailure:<br/>    handler: failure.handler</span></pre><p id="674d" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">上面的例子显示了一个非常基本的<code class="fe nn no np nq b">helloStarting</code>λ，它通向成功时的<code class="fe nn no np nq b">helloSuccess</code>λ和失败时的<code class="fe nn no np nq b">helloFailure</code>λ。</p><blockquote class="mq mr ms"><p id="c22f" class="lb lc mt ld b le lz lg lh li ma lk ll mu mb lo lp mv mc ls lt mw md lw lx ly ij bi translated">使用async lambdas时，值得注意的是maximumRetryAttempts属性，该属性默认为2，可以取值0、1或2。如果不这样做，异步失败将重试多次，并且您将在队列中收到多条消息。</p></blockquote><p id="cb7a" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这个来自无服务器框架团队的视频展示了一个使用Python的简短实践演示:</p><figure class="my mz na nb gt is"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://youtu.be/8KBLzRi76Tc" rel="noopener ugc nofollow" target="_blank">https://youtu.be/8KBLzRi76Tc</a></figcaption></figure></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h2 id="aee4" class="oa ke jg bd kf oh oi dn kj oj ok dp kn lm ol om kr lq on oo kv lu op oq kz or bi translated">好的，给我看一些无服务器代码！</h2><p id="cfd1" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于我们上面的虚拟支付架构图，您的<code class="fe nn no np nq b">serverless.yml</code>将如下所示:</p><figure class="my mz na nb gt is"><div class="bz fp l di"><div class="os og l"/></div></figure><p id="8c22" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">以下报告显示了<a class="ae jd" href="https://github.com/leegilmorecode/serverless-lambda-destinations" rel="noopener ugc nofollow" target="_blank">完整示例</a>。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><p id="c17f" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在我看来，有几个权衡值得了解:</p><ol class=""><li id="7b8b" class="ne nf jg ld b le lz li ma lm ng lq nh lu ni ly nj nk nl nm bi translated">查看您的lambda代码的开发人员可能不知道lambda的输出将去往何处(<em class="mt">成功和失败</em>)，因为它已经在您的无服务器代码中完全配置好了。当胶水代码写在lambda本身(<em class="mt">中时，这一点显然更明显，但是和任何东西一样，总会有权衡！</em>)。自述文件中的好的架构图和代码中的注释可能就足够了。</li><li id="3682" class="ne nf jg ld b le nr li ns lm nt lq nu lu nv ly nj nk nl nm bi translated">在控制台中调用是同步的，所以如果您在单击测试按钮时没有看到结果，不要感到困惑！</li><li id="9c20" class="ne nf jg ld b le nr li ns lm nt lq nu lu nv ly nj nk nl nm bi translated">无服务器框架有一个当前的错误，您必须规定非lambda资源的ARN字符串，即您不能使用引用，例如引用您刚刚在资源部分创建的队列或主题。你需要自己积累，这很容易。</li><li id="bf9c" class="ne nf jg ld b le nr li ns lm nt lq nu lu nv ly nj nk nl nm bi translated">在使用异步lambdas/SQS/SNS时，请记住始终要考虑“<a class="ae jd" href="https://aws.amazon.com/premiumsupport/knowledge-center/lambda-function-idempotent/" rel="noopener ugc nofollow" target="_blank">幂等性</a>！</li></ol><h1 id="c649" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">包扎</h1><p id="6b4e" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果您认为本文有趣，那么让我们从以下任何一个方面进行连接:</p><p id="6642" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/lee-james-gilmore/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/lee-james-gilmore/</a><br/><a class="ae jd" href="https://twitter.com/LeeJamesGilmore" rel="noopener ugc nofollow" target="_blank">https://twitter.com/LeeJamesGilmore</a></p><p id="08ff" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果你觉得这些文章鼓舞人心或有用，请随时用虚拟咖啡<a class="ae jd" href="https://www.buymeacoffee.com/leegilmore" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/leegilmore</a>来支持我，不管怎样，让我们联系和聊天吧！☕️</p><p id="df0c" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果你喜欢这些帖子，请关注我的简介<a class="ae jd" href="https://medium.com/u/2906c6def240?source=post_page-----39c4f4ae5aff----------------------" rel="noopener">李·詹姆斯·吉尔摩</a>以获取更多的帖子/系列，不要忘记联系并说<strong class="ld jh">嗨</strong>👋</p><p id="6259" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld jh">本文由</strong> <a class="ae jd" href="https://www.sedai.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ld jh"> Sedai.io </strong> </a>赞助</p><figure class="my mz na nb gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ot"><img src="../Images/4c77bc2d275bd557dda90aa2fe842d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJqkQYFI-KAGHOI3cHWxJQ.png"/></div></div></figure><h1 id="ff0c" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">关于我</h1><p id="fbfc" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld jh"> " </strong> <em class="mt">大家好，我是Lee，英国的AWS认证技术架构师和首席软件工程师，目前是技术云架构师和首席无服务器开发人员，过去5年主要从事AWS上的全栈JavaScript工作。</em></p><p id="33ad" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mt">我认为自己是一个热爱AWS、创新、软件架构和技术的无服务器布道者。</em><strong class="ld jh"/></p><p id="bd73" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld jh"> **所提供的信息是我个人的观点，我对这些信息的使用不承担任何责任。*** </strong></p></div></div>    
</body>
</html>