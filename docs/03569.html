<html>
<head>
<title>Injecting Environment Variables into JSON Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将环境变量注入JSON文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/injecting-environment-variables-into-static-files-ea21c2d4bdbd?source=collection_archive---------0-----------------------#2020-05-17">https://levelup.gitconnected.com/injecting-environment-variables-into-static-files-ea21c2d4bdbd?source=collection_archive---------0-----------------------#2020-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8911e4e342524be0514914fc6e7ec962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pZKUWHW63GHSiiYN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@juon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">巨摄</a>上<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">下</a></figcaption></figure><p id="6155" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我目前从事的项目中，我们有多个托管在docker容器中的环境，通常很难跟踪它们是否正确更新以及环境中运行的是哪个版本。</p><p id="8caf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些容器是使用我们的Gitlab CI/CD管道构建的，该管道提供了大量的<a class="ae kc" href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html" rel="noopener ugc nofollow" target="_blank">环境变量</a>，可用于将上下文信息注入到构建中。例如，通过组合像提交散列或标记、构建号和repo名称这样的东西，可以唯一地标识每个构建，然后可以在启动时打印到控制台中。</p><p id="58fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常我们会简单地将环境变量放到一个<code class="fe lb lc ld le b">env</code>文件中，或者通过著名的<code class="fe lb lc ld le b">$FOO_BAR</code>语法在其他文件中引用它们。我们希望我们的语言、框架或工具在运行时获取语法，并通过<code class="fe lb lc ld le b">process.env</code>向我们展示。</p><p id="0f3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是唉，事情没那么简单。这可能就是你在这里的原因。</p><p id="cfb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如Angular，作为客户端，不能访问任何环境变量。通常，环境变量是运行该进程的机器(也称为环境)的一种表示。然而，对于一个web应用程序来说，运行它的机器是用户的个人电脑，但我们通常对托管它的服务器更感兴趣。更糟糕的是，也许我们需要了解一些早已过去的构建环境。我们需要找到一种方法来注入可以保存和提供的静态文件，以便我们始终可以访问一些服务器信息的快照。</p><p id="2f05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目标是轻松地生成一个文件，最好是JSON，并在其中注入一些变量。我发现最简单的方法是创建一个文件(<code class="fe lb lc ld le b">environmentVariables.json</code>)，然后在构建期间将变量注入其中。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lm"><img src="../Images/4205a911fb18827b6170626500dfed16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VSD2B9xITEx3gurQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Paul Esch-Laurent 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="ed8e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">方法一:NPM</h1><p id="d6ef" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">通过CLI轻松编辑JSON文件的一种方法是使用<a class="ae kc" href="https://www.npmjs.com/package/json" rel="noopener ugc nofollow" target="_blank"> json </a> NPM包。这是一个非常简单的库，基本上允许您通过JSON Path esque语法从命令行处理JSON文件。</p><p id="9f4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我有以下对象:</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">空环境信息文件</figcaption></figure><p id="6b5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次改变时都填充分支和提交散列会让我发疯。因此，您可以将该命令作为构建脚本的一部分来运行。</p><pre class="ln lo lp lq gt mw le mx my aw mz bi"><span id="2989" class="na ls iq le b gy nb nc l nd ne">export BRANCH=$(<!-- -->git rev-parse --abbrev-ref HEAD)<br/>export COMMIT_SHA=$(git rev-parse --short HEAD)</span><span id="8b3d" class="na ls iq le b gy nf nc l nd ne">json -I -f environmentVariables.json \<br/>      -e “this.branch=’$BRANCH’” \<br/>      -e "this.commit='$COMMIT_SHA'</span></pre><p id="845d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者跳过整个环境变量:</p><pre class="ln lo lp lq gt mw le mx my aw mz bi"><span id="901b" class="na ls iq le b gy nb nc l nd ne">json -I -f environmentVariables.json \<br/>      -e "this.branch='$(git rev-parse --abbrev-ref HEAD)'" \<br/>      -e "this.commit='$(git rev-parse --short HEAD)'"</span></pre><h1 id="d179" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">注</strong></h1><blockquote class="ng nh ni"><p id="94c1" class="kd ke nj kf b kg kh ki kj kk kl km kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated">为了使它成为有效的JSON，您必须将选择的环境变量包含在另一组引号中。</p></blockquote><h1 id="4070" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">命令行参数分解:</strong></h1><blockquote class="ng nh ni"><p id="47c0" class="kd ke nj kf b kg kh ki kj kk kl km kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated"><code class="fe lb lc ld le b">-I -f</code>激活将更新写入输入文件的<a class="ae kc" href="http://trentm.com/json/#FEATURE-In-place-editing" rel="noopener ugc nofollow" target="_blank">就地编辑</a></p><p id="a9e1" class="kd ke nj kf b kg kh ki kj kk kl km kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated"><code class="fe lb lc ld le b">-e</code> <a class="ae kc" href="http://trentm.com/json/#FEATURE-Execution" rel="noopener ugc nofollow" target="_blank">对输入JSON对象执行</a>提供的表达式</p></blockquote><h1 id="fd1b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">方法2:外壳</h1><blockquote class="ng nh ni"><p id="ca50" class="kd ke nj kf b kg kh ki kj kk kl km kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated">让我们继续上面的示例文件。</p></blockquote><p id="b6ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您希望保持较小的NPM依赖性，或者不使用Node.js，那么您也可以选择使用CLI工具。例如，我发现<a class="ae kc" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>是一个优秀的小命令行工具，可以用来交互和操作JSON。</p><p id="01d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将它应用到这个问题看起来会像这样:</p><pre class="ln lo lp lq gt mw le mx my aw mz bi"><span id="4c36" class="na ls iq le b gy nb nc l nd ne">jq ‘.build=env.CI_PIPELINE_ID’ environment.json &gt;&gt; tmp.json &amp;&amp; mv tmp.json environment.json</span></pre><p id="82b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是将对象的<code class="fe lb lc ld le b">build</code>属性设置为<code class="fe lb lc ld le b">CI_PIPELINE_ID</code>变量。JQs内置了对通过<code class="fe lb lc ld le b">env</code>对象访问OS环境变量的支持。</p><p id="d2e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">jq</code>的一个缺点是它似乎还不提供就地编辑，所以你不得不创建一个临时文件。然而，这是一个很小的代价，可以很容易地自动化。</p><h1 id="9f0f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">方法3:更多外壳</h1><p id="875e" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">您可以随时使用您选择的字符替换工具(例如awk、sed)来查找和替换配置文件中的属性。这可能被认为是不引入依赖性的最纯粹的方法，但是它也会增加复杂性和可维护性开销。</p><p id="9d35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现最好的方法是给你的文件添加一种“标签”,这种标签是独一无二的，足以引起搜索的关注。例如，在我的一个Kubernetes配置文件中，我在我要编辑的行(图片)上方添加了一个注释。</p><pre class="ln lo lp lq gt mw le mx my aw mz bi"><span id="f370" class="na ls iq le b gy nb nc l nd ne">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: myApp-deploy-v1<br/>  labels:<br/>    app: myApp<br/>    version: v1<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: myApp<br/>      version: v1<br/>  template:<br/>    metadata:<br/>      name: myApp-pod<br/>      labels:<br/>        app: myApp<br/>        version: v1<br/>    spec:<br/>      serviceAccountName: myApp-sa<br/>      containers:<br/>        - name: myApp<br/>          livenessProbe:<br/>            httpGet:<br/>              port: 80<br/>              path: /health<br/>          readinessProbe:<br/>            httpGet:<br/>              port: 80<br/>              path: /myApp/<br/>          #-&gt;CI-IMAGE-NAME<br/>          image: myApp:1<br/>          ports:<br/>            - containerPort: 80</span></pre><p id="fa43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您可以像这样使用类似<code class="fe lb lc ld le b">sed</code>的CLI工具:</p><pre class="ln lo lp lq gt mw le mx my aw mz bi"><span id="414e" class="na ls iq le b gy nb nc l nd ne">sed '/#-&gt;CI-IMAGE-NAME.*/!b;n;s/:.*\s*$/:1.0.2/' deploy.yaml</span></pre><blockquote class="ng nh ni"><p id="516b" class="kd ke nj kf b kg kh ki kj kk kl km kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated">这用1.0.2替换了<code class="fe lb lc ld le b">myApp:1</code>图像标签，因此它使用了<code class="fe lb lc ld le b">myApp:1.0.2</code></p></blockquote><h1 id="9cc5" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">注意</h1><blockquote class="ng nh ni"><p id="c84f" class="kd ke nj kf b kg kh ki kj kk kl km kn nk kp kq kr nl kt ku kv nm kx ky kz la ij bi translated">自从第一次写这篇文章以来，我发现了<a class="ae kc" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank"> Kustomize </a>和<a class="ae kc" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>的乐趣，这使得外壳替换的应用变得多余。</p></blockquote></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="e798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我确信有更多的选择可以实现这一点。此外，根据您正在使用的框架、语言和/或工具，可能已经有可用的变量替换解决方案(参见K8文件的<a class="ae kc" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank"> Kustomize </a>和<a class="ae kc" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>)。</p><p id="4c0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在没有合适的工具的情况下，我希望这些方法中的一个能帮到你。</p><p id="ef6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你好运！:)</p></div></div>    
</body>
</html>