<html>
<head>
<title>Build an On-hover Custom Scrollbar in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中构建悬停自定义滚动条</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-on-hover-custom-scrollbar-in-react-d846194a7ea4?source=collection_archive---------1-----------------------#2020-04-27">https://levelup.gitconnected.com/build-on-hover-custom-scrollbar-in-react-d846194a7ea4?source=collection_archive---------1-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/de428ac5fe1dc59d0d6aeb5cbd2ce645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eL42Gt7K-YeKWSWc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">沙加尔·赛义德在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="21f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都知道滚动条是一个UI组件，通常位于窗口的最右侧或底部，它允许你上下左右移动窗口查看区域。今天大多数人都熟悉<strong class="kf ir">滚动条</strong>，因为几乎每个网页和应用程序都需要上下滚动。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a361" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">web应用程序中滚动条的问题</h1><ul class=""><li id="ff30" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">所有操作系统都有不同类型的原生滚动条，并且大多数浏览器继承了特定于操作系统的滚动条，这使得你的web应用程序滚动条在不同的操作系统上有不同的外观和感觉。基于Web-kit的浏览器通过CSS支持<a class="ae kc" href="https://css-tricks.com/custom-scrollbars-in-webkit/" rel="noopener ugc nofollow" target="_blank">滚动条UI定制</a>，但是其他的呢？</li><li id="1eb9" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">它们在水平或垂直方向上占用了一些额外的空间，这减少了您的网页内容或内容容器(如表格)的可用空间(基于WebKit的浏览器提供了一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/CSS/overflow" rel="noopener ugc nofollow" target="_blank"> overlay </a> value，使scrollbar绘制在内容的顶部，以消除这些额外的空间，但是其他浏览器呢？)</li></ul><h1 id="4385" class="li lj iq bd lk ll mw ln lo lp mx lr ls lt my lv lw lx mz lz ma mb na md me mf bi translated"><strong class="ak">动机</strong></h1><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b3760b231282276eafa0ccc159fcfbd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/1*eu5fGYBev9EUZV4hKvFB_w.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Facebook Messenger自定义滚动条</figcaption></figure><ul class=""><li id="025b" class="mg mh iq kf b kg kh kk kl ko ng ks nh kw ni la mn mo mp mq bi translated"><strong class="kf ir">脸书</strong>:我在脸书信使弹出窗口中发现了一个自定义滚动条，它会在鼠标悬停时出现。</li><li id="f2c6" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><strong class="kf ir"> Gmail: </strong>你也可以在Gmail中看到类似的滚动条，位于悬停时的电子邮件撰写按钮下方</li><li id="1eb2" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">你可能已经注意到其他应用程序中类似的滚动条，甚至在“代码沙箱”项目中你也能注意到类似的滚动条</li></ul></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="6989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个故事中，我将带你经历如何在React中创建自定义滚动条的步骤，我们可以在其他前端框架中使用相同的技术，如Angular，但在深入研究之前，让我们可视化滚动条的不同组件</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/4531c906ef5ce7fb5c8a9964a5c37dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCRRPEIw8_UjvscGz_vPHQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">滚动条组件</figcaption></figure><div class="nk nl gp gr nm nn"><a href="https://github.com/hkurra/react-on-hover-scrollbar" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">hkurra/悬停滚动条时反应</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">这是一个基本但有用的例子，演示了如何在react中创建一个自定义滚动条，鼠标悬停时可以看到它…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob jw nn"/></div></div></a></div><p id="9ea1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成代码沙盒项目<a class="ae kc" href="https://codesandbox.io/s/github/hkurra/react-on-hover-scrollbar/tree/master/" rel="noopener ugc nofollow" target="_blank">链接</a></p><h2 id="01e9" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">我们需要执行的步骤</h2><ol class=""><li id="5a4b" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la oo mo mp mq bi translated">隐藏浏览器的原生滚动条</li><li id="3274" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la oo mo mp mq bi translated">添加自定义滚动条用户界面，鼠标悬停时可见</li><li id="7bbd" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la oo mo mp mq bi translated">在滚动条中添加自定义的<strong class="kf ir">滚动块</strong></li><li id="19b3" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la oo mo mp mq bi translated">基于可滚动内容计算<strong class="kf ir">滚动块</strong> <strong class="kf ir"> <em class="op">高度</em> </strong></li><li id="7071" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la oo mo mp mq bi translated">在滚动主机中改变鼠标滚动上的<strong class="kf ir">滚动块<em class="op">位置</em>和</strong></li><li id="32cc" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la oo mo mp mq bi translated">鼠标拖动时改变<strong class="kf ir">滚动-拇指</strong> <strong class="kf ir"> <em class="op">位置</em> </strong></li></ol><p id="2f5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些步骤在下面都有深入的解释</p><h1 id="ea58" class="li lj iq bd lk ll mw ln lo lp mx lr ls lt my lv lw lx mz lz ma mb na md me mf bi translated">隐藏本机滚动条</h1><p id="6099" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated">首先我们需要做的是在scroll-host元素上隐藏浏览器的原生滚动条，不要禁用通过<strong class="kf ir"> <em class="op">溢出:隐藏</em> </strong>的滚动</p><blockquote class="ot ou ov"><p id="77a1" class="kd ke op kf b kg kh ki kj kk kl km kn ow kp kq kr ox kt ku kv oy kx ky kz la ij bi translated">为什么？我们很快就会看到原因。</p></blockquote><p id="060a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是在不同浏览器上隐藏滚动条的CSS。这里的是代码沙盒项目的链接，我已经用下面的CSS隐藏了我的滚动主机容器上的滚动条</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">隐藏浏览器原生滚动条的CSS</figcaption></figure><p id="7ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们通过上面的步骤摆脱了浏览器自带的滚动条。在进入下一步之前，我已经创建了一个<a class="ae kc" href="https://codesandbox.io/s/hide-scroll-bar-ps471?file=/src/onHover.js" rel="noopener ugc nofollow" target="_blank">代码沙盒项目</a>，它有一个完整的实现。具有中级或更高级经验的用户可以直接转到那里，直接从代码中理解逻辑。虽然，我会推荐通读文章，详细了解一切。</p><h1 id="352d" class="li lj iq bd lk ll mw ln lo lp mx lr ls lt my lv lw lx mz lz ma mb na md me mf bi translated">让我们创建我们的自定义滚动条</h1><p id="7786" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated">下一步是在我们的滚动主机上呈现一个<strong class="kf ir">滚动条</strong>和<strong class="kf ir">滚动框滑块</strong>，这将帮助我们通过鼠标拖动来滚动内容。首先，我们将添加一个滚动条，将出现在悬停。下面是代码片段及其CSS。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基于React的CustomScrollDiv组件</figcaption></figure><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基于React的CustomScrollDiv组件CSS</figcaption></figure><p id="79cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，现在我们有了单独的可重用组件名<strong class="kf ir"> CustomScrollDiv </strong>，它将你的内容和<strong class="kf ir">滚动条</strong>一起呈现在组件中，并且这个滚动条只有当用户将鼠标悬停在你的<strong class="kf ir"> CustomScrollDiv </strong>组件上时才可见。</p><h2 id="032a" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">提供；给予</h2><ul class=""><li id="e48a" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated"><strong class="kf ir"> Scroll-host </strong>:它代表你的自定义<strong class="kf ir"> div </strong>容器，它将在悬停时呈现自定义滚动条，它将保存可滚动的内容(在第<strong class="kf ir"> 25行</strong>它正在呈现<strong class="kf ir">子</strong>道具)，你提供给<strong class="kf ir"> CustomScrollDiv </strong>的任何道具都将在这个div上得到应用。参见<strong class="kf ir">第23行</strong></li><li id="ef5f" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><strong class="kf ir">滚动条</strong>:这将容纳滚动块，并为滚动块提供一个跟踪区域。在后面的部分中，我们将在这个组件中添加scroll-thumb。这里，我们利用<strong class="kf ir">绝对</strong>定位CSS属性在固定位置将滚动条容器呈现在我们的<strong class="kf ir">滚动主机</strong>上，保持其高度等于<strong class="kf ir">滚动主机容器的100%。</strong></li><li id="08b1" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><strong class="kf ir"> Scroll-host-container </strong>:它是你实际组件aka <strong class="kf ir"> scroll-host </strong>的容器/包装器。作为一个容器，它正在监听<strong class="kf ir">鼠标经过</strong>和<strong class="kf ir">鼠标离开</strong>事件(<strong class="kf ir">第17行，18 </strong>)，而不是<strong class="kf ir">滚动主机</strong>。</li></ul><blockquote class="ot ou ov"><p id="f32d" class="kd ke op kf b kg kh ki kj kk kl km kn ow kp kq kr ox kt ku kv oy kx ky kz la ij bi translated">我们为什么需要这个？</p><p id="3cf2" class="kd ke op kf b kg kh ki kj kk kl km kn ow kp kq kr ox kt ku kv oy kx ky kz la ij bi translated">这将有助于我们保持滚动条高度等于<strong class="kf ir">滚动主机</strong>的客户端高度，否则你必须保持<strong class="kf ir">滚动条</strong>的高度等于<strong class="kf ir">滚动主机</strong>的<strong class="kf ir"> scrollHeight </strong>的高度，当你的scrollHeight非常大时，这将导致闪烁问题(我将在最后一节解释)</p></blockquote><h2 id="c294" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated"><strong class="ak">状态</strong></h2><p id="2279" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated">目前，我们只保持一种状态，即<strong class="kf ir">悬停</strong>，</p><p id="d7bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在更改<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> mouseout </strong> </a>和<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseover_event" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> mouseover </strong> </a>事件处理程序下的值，该事件处理程序注册在<strong class="kf ir"> Scroll-host-container上。随着我们的前进，我们将增加更多的州</strong></p><p id="5edc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在有了上面的组件和CSS，你会注意到<strong class="kf ir">滚动条</strong>在悬停时可见，你的内容仍然可以滚动</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/8ef343ccce7e8b7361487c80a97c3035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*HeiVhdkTTG3ZBcsTRJzh9Q.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">自定义滚动条在鼠标悬停滚动主机上可见</figcaption></figure><blockquote class="ot ou ov"><p id="7aea" class="kd ke op kf b kg kh ki kj kk kl km kn ow kp kq kr ox kt ku kv oy kx ky kz la ij bi translated">你知道为什么你的内容仍然可以滚动吗？</p></blockquote><p id="fdbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了隐藏滚动条，我们<strong class="kf ir">没有</strong>使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/CSS/overflow" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">溢出:隐藏</strong> </a> <strong class="kf ir">，它对滚动</strong>做了两件事</p><ol class=""><li id="1342" class="mg mh iq kf b kg kh kk kl ko ng ks nh kw ni la oo mo mp mq bi translated"><strong class="kf ir">隐藏</strong>滚动条</li><li id="01e8" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la oo mo mp mq bi translated">不允许用户滚动内容</li></ol><p id="c998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个，你也就有了上述问题的答案。</p><h1 id="6f4c" class="li lj iq bd lk ll mw ln lo lp mx lr ls lt my lv lw lx mz lz ma mb na md me mf bi translated">让我们拿着滚动条，滚动拇指</h1><p id="eebf" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated">我们的下一步是呈现<strong class="kf ir">滚动块(框)</strong>或<strong class="kf ir">滚动块</strong>，通过它们，用户不仅可以通过鼠标拖动来滚动内容，还可以帮助用户根据其相对于<strong class="kf ir">滚动条</strong>的位置来确定可滚动内容的长度。这是该实现中最关键/最复杂的部分。所以，先喝一杯咖啡/茶🍮 😉。</p><h2 id="c985" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">滚动缩略图呈现</h2><p id="3b7a" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated">首先，我们将在代表<strong class="kf ir">滚动块</strong>的<strong class="kf ir">滚动条</strong>中添加一个新的<strong class="kf ir"> div </strong>元素</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><h2 id="39aa" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated"><strong class="ak">滚动块高度计算</strong></h2><ul class=""><li id="456d" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">接下来，我们必须根据可滚动的内容找到这个滚动块的高度，这是刷新基本数学百分比公式的时候了。</li><li id="a7e6" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">不要太紧张，这是简单的数学。在使用公式之前，让我们先理解下面的术语</li></ul><blockquote class="ot ou ov"><p id="5c54" class="kd ke op kf b kg kh ki kj kk kl km kn ow kp kq kr ox kt ku kv oy kx ky kz la ij bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> clientHeight </strong> </a>:元素的内部高度</p><p id="6e69" class="kd ke op kf b kg kh ki kj kk kl km kn ow kp kq kr ox kt ku kv oy kx ky kz la ij bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">scroll height</strong></a><strong class="kf ir">:</strong>是一个元素的<strong class="kf ir"> </strong>高度的<strong class="kf ir">内容</strong></p></blockquote><ul class=""><li id="72a6" class="mg mh iq kf b kg kh kk kl ko ng ks nh kw ni la mn mo mp mq bi translated">现在，这里是公式，其中滚动主机或可滚动区域的RHV的高度</li></ul><blockquote class="pc"><p id="1b5a" class="pd pe iq bd pf pg ph pi pj pk pl la dk translated"><strong class="ak"><em class="pm">scroll thumbheight =(client height/scroll height)* client height</em></strong></p></blockquote><figure class="pn po pp pq pr jr"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">滚动块高度计算</figcaption></figure><ul class=""><li id="18ae" class="mg mh iq kf b kg kh kk kl ko ng ks nh kw ni la mn mo mp mq bi translated">设置滚动框的最小高度为20 px，以避免在滚动内容非常大的情况下滚动框的高度为负。</li><li id="8b6e" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">在React中，我们将在我们的<strong class="kf ir"> CustomScrollDiv </strong>元素在DOM中挂载之后计算这个高度，如果是基于类的组件，您可以使用<strong class="kf ir"> componentDidMount </strong>生命周期方法，如果是功能组件，您可以使用<strong class="kf ir"> useEffect </strong>钩子。</li></ul><h2 id="bf89" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">滚动缩略图定位</h2><ul class=""><li id="ba9b" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">为了改变鼠标滚动时上面的<strong class="kf ir">滚动块</strong>的位置，我们需要<strong class="kf ir">按照下面的步骤<br/> 1。</strong>处理<strong class="kf ir">滚动主机<br/> 2上的<strong class="kf ir"> <em class="op">滚动</em> </strong>事件。</strong>根据以下公式，在步骤1中注册的处理器中，每次滚动移动时，改变<strong class="kf ir">滚动块</strong>的<em class="op">顶部</em>位置</li></ul><blockquote class="pc"><p id="df0f" class="pd pe iq bd pf pg ph pi pj pk pl la dk translated">scroll thumb top =(scroll top/scroll height)* client height</p></blockquote><figure class="pn po pp pq pr jr gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/6ff460bd50fb60ee939303c5f9a3ca26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*GmoJ8KReZQNK7t3wphKRSA.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">滚动-拇指在鼠标滚动上移动</figcaption></figure><ul class=""><li id="9b5b" class="mg mh iq kf b kg kh kk kl ko ng ks nh kw ni la mn mo mp mq bi translated">更改后，<strong class="kf ir"> CustomScrollDiv </strong>组件将如下所示</li></ul><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">鼠标滚动时滚动拇指位置计算</figcaption></figure><h2 id="7226" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">滚动拇指拖动</h2><ul class=""><li id="68b6" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">现在，我们有了正确大小的<strong class="kf ir">滚动条和滚动块</strong>,它们也可以在滚动主机区域的鼠标滚动中正确移动。尽管如此，鼠标在<strong class="kf ir">滚动拇指</strong>上拖动还是不起作用，让我们看看如何处理:</li><li id="ba9d" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">为了处理滚动块上的拖动，我们需要处理<br/> 1。<strong class="kf ir"> <em class="op"> mouseDown </em> </strong>事件发生在<strong class="kf ir">滚动块</strong>元素和<br/> 2上。<strong class="kf ir"> <em class="op">鼠标移动</em> </strong>，<strong class="kf ir"> <em class="op">鼠标移动&amp;鼠标离开</em> </strong>文档</li></ul><blockquote class="ot ou ov"><p id="9df3" class="kd ke op kf b kg kh ki kj kk kl km kn ow kp kq kr ox kt ku kv oy kx ky kz la ij bi translated">为什么记录？</p><p id="1a80" class="kd ke op kf b kg kh ki kj kk kl km kn ow kp kq kr ox kt ku kv oy kx ky kz la ij bi translated">因为当拖动时，你可以在文档中的任何地方移动你的鼠标，这是所有滚动条的默认行为，你可以在阅读这篇文章时通过滚动来验证这个行为</p></blockquote><ul class=""><li id="a884" class="mg mh iq kf b kg kh kk kl ko ng ks nh kw ni la mn mo mp mq bi translated">为了识别用户是否在拖动滚动块，我们将在组件中保留状态<strong class="kf ir">正在拖动</strong>,还需要存储用户开始拖动时<strong class="kf ir">滚动块</strong>元素的Y坐标</li><li id="787f" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">现在，让我们看一下在每个事件处理程序中我们需要做什么</li></ul><h2 id="55e7" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">先将<strong class="ak"> <em class="pm">鼠标按下</em> </strong>处理程序<strong class="ak"> <em class="pm">放在</em>滚动条上</strong></h2><p id="10f4" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated">鼠标按下滚动块意味着，用户将开始拖动<strong class="kf ir">滚动块</strong>，因此，我们保持<strong class="kf ir">滚动块</strong>的当前Y坐标位置，并将<strong class="kf ir">正在拖动</strong>状态更改为真</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><h2 id="d759" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">文档<strong class="ak"> <em class="pm">鼠标离开和鼠标抬起事件</em> </strong></h2><p id="208c" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated"><strong class="kf ir">文档上的mouseLeave </strong>和<strong class="kf ir"> mouseUp </strong>事件表示如果当前正在拖动鼠标拇指，用户将停止拖动，所以我们将<strong class="kf ir">正在拖动</strong>状态改为false</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><h2 id="2bc1" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">文档<strong class="ak">鼠标移动处理</strong></h2><p id="0c49" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated">为了在拖动时产生滚动效果，我们需要改变下面组件的滚动顶部:</p><ul class=""><li id="58d8" class="mg mh iq kf b kg kh kk kl ko ng ks nh kw ni la mn mo mp mq bi translated"><strong class="kf ir">Scroll-Thumb:</strong>Scroll-Thumb的滚动顶部的变化是拖动过程中鼠标位置的垂直变化。为了计算该值，我们需要最后一个<strong class="kf ir">滚动拇指</strong>位置，该位置已保存在l<strong class="kf ir">astscrollhumbposition</strong>状态中。在<strong class="kf ir">第9行(</strong>见下文<strong class="kf ir"> ) </strong>我们正在改变<strong class="kf ir">滚动块</strong>的位置，在<strong class="kf ir">第15行</strong>我们正在将<strong class="kf ir">滚动块</strong>的顶部增加该值。</li><li id="8eb9" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><strong class="kf ir"> Scroll-Host: </strong>如果你注意到新的scroll-top是拖动过程中鼠标位置变化的百分比，那么Scroll-Host的滚动顶部的变化使用下面的公式计算。</li></ul><blockquote class="pc"><p id="9921" class="pd pe iq bd pf pg ph pi pj pk pl la dk translated">newScrollHostTop =(scroll height/offset height)* deltaY；</p></blockquote><p id="13ad" class="pw-post-body-paragraph kd ke iq kf b kg ps ki kj kk pt km kn ko pu kq kr ks pv ku kv kw pw ky kz la ij bi translated">我们在<strong class="kf ir">第10行</strong>计算scrollTop的变化，并将其应用于<strong class="kf ir">第20行</strong></p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="4c3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们已经实现了我们的目标，我们定制的悬停滚动条已经准备好了，它也可以在<strong class="kf ir">滚动拇指</strong>上拖动鼠标，这就是它现在的工作方式。</p><figure class="nc nd ne nf gt jr gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/490097ae360835c72b2ee1f8a1fde47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*jkiQri7Xc7f5vMPCgLyN4A.gif"/></div></figure><h1 id="6454" class="li lj iq bd lk ll mw ln lo lp mx lr ls lt my lv lw lx mz lz ma mb na md me mf bi translated">结论</h1><p id="32a2" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko oq kq kr ks or ku kv kw os ky kz la ij bi translated">虽然我已经尽力让这个故事容易理解，但它需要先决条件，如<a class="ae kc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> React </strong> </a>，<a class="ae kc" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> React-Hooks </strong> </a>，<strong class="kf ir"> DOM </strong>布局，<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model#HTML_DOM" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> JS DoM API </strong> </a>等。有些部分可能需要额外的阐述，但是为了保持故事的简洁和便于所有类型的用户理解，我只提到了重要的几点。欢迎在下面的评论区提出你的疑问和建议。</p><p id="0f51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在你的代码中自由使用<a class="ae kc" href="https://codesandbox.io/s/custom-scrollbar-on-hover-ps471?file=/src/CustomScrollDiv.js:162-177" rel="noopener ugc nofollow" target="_blank"> CustomScrollDiv </a>组件，但是对于产品来说，你可能需要处理额外的东西，比如，目前，我只是在组件挂载之后计算<strong class="kf ir"> scroll-thumb </strong>的高度，但是如果用户调整窗口大小，或者如果你的scroll-host延迟加载数据并延迟改变scrollHeight，它就会改变。</p><p id="5d4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧啊。！现在，我们有了自己的自定义滚动条:)</p><p id="f317" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意安全，继续编码！！</p></div></div>    
</body>
</html>