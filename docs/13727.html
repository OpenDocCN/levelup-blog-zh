<html>
<head>
<title>Solving Maximum Flow Problems with Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Neo4j解决最大流问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solving-maximum-flow-problems-with-neo4j-ea227f8b798?source=collection_archive---------12-----------------------#2022-09-30">https://levelup.gitconnected.com/solving-maximum-flow-problems-with-neo4j-ea227f8b798?source=collection_archive---------12-----------------------#2022-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/1e2e303e95ce194801f0ec70e118d6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*SdfoeYoYkGTyDlbPQBPSng.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated"><strong class="bd kb">图1 </strong>在Neo4j中创建的由源节点(绿色)、汇聚节点(红色)、附加节点(蓝色)和边容量(浅蓝色)组成的简单流网络:<em class="kc">图片作者</em></figcaption></figure><p id="af61" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">流网络可用于许多现实世界的应用中。从制造材料移动到运输路线到二部图匹配，最大流问题非常普遍，我期望在Neo4j中找到它的实现，但是没有。</p><p id="19bb" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">Neo4j是一个图形数据库，它将信息存储为节点和关系，而不是像传统的表格数据库那样存储为表格中的行和列。这对于用有向图表示的流网络问题(如最大流)非常有益。</p><p id="54c5" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">流网络是以起始节点(“源”)开始，以终止节点(“汇”)结束的图。其他几个节点用边(也称为关系)连接，但都是“流”(在生产线的情况下可以指材料，在管道的情况下可以指水，在电路的情况下可以指电，等等。)最终从源头转移到了汇点。每条边都有一个容量，决定了有多少流量可以从一个节点移动到另一个节点(见图1)。</p><p id="2e80" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">最大流问题的思想是确定流可以采取的适当路径，同时最大化从源头到汇点的流量。在图1中，可以推断出最大流量是20，所采用的路径应该是外围(s-&gt;1-&gt;3-&gt;t和s-&gt;0-&gt;2-&gt;t)。然而，在包含更多节点和更多连接这些节点的边的更复杂的流网络中，这可能很快变得太复杂而难以推理。</p><p id="dce9" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">幸运的是，有许多已知的算法可以解决最大流问题。下面在Neo4j中实现的是Ford-Fulkerson算法。但是在开始之前，您需要设置您的环境。</p><h1 id="72a2" class="lb lc it bd kb ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在Neo4j中实施</h1><p id="2563" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">如果你是Neo4j的新手，你可以在网上创建一个账户，并在你的浏览器中建立一个沙盒环境。这样做只需要几分钟，不需要任何下载。一个空白的沙盒就可以了。从这里开始:<a class="ae md" href="https://neo4j.com/sandbox/" rel="noopener ugc nofollow" target="_blank"> Neo4j沙盒</a></p><h2 id="a36a" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">设置环境</h2><p id="fce0" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">要找到一个网络的最大流量，你首先需要一个可以玩的网络。首先创建初始流网络的节点，包括一个源、一个汇和四个附加节点。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c992" class="me lc it mv b gy mz na l nb nc">UNWIND ['Source', 'Zero', 'One', 'Two', 'Three', 'Sink'] AS nodeName<br/>CREATE (s:point {name:nodeName});</span></pre><p id="df94" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">接下来，为源节点和接收节点添加一些标签，使将来的查询更容易。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="558b" class="me lc it mv b gy mz na l nb nc">MATCH(ns:point{name:'Source'})<br/>SET ns:Source<br/>RETURN ns;</span><span id="a644" class="me lc it mv b gy nd na l nb nc">MATCH(nt:point{name:'Sink'})<br/>SET nt:Sink<br/>RETURN nt;</span></pre><p id="f18e" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">创建每个节点之间的关系，并为<code class="fe ne nf ng mv b">MaxCapacity</code>、<code class="fe ne nf ng mv b">Flow</code>和<code class="fe ne nf ng mv b">AvailableFlow</code>设置初始值。这些关系被称为<code class="fe ne nf ng mv b">[:CAPACITY]</code>，因为它们的流量小于它们的最大容量。</p><p id="4ea4" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><code class="fe ne nf ng mv b">MaxCapacity</code>是您正在建模的流动网络所固有的。如果您将流动网络想象为不同直径的管道，水流通过这些管道，则最大容量就像最大流速，即在任何给定时间内可能有多少水通过每个管道。该值不会改变。</p><p id="a05e" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><code class="fe ne nf ng mv b">Flow</code>是当前通过每根管道的水量。在问题开始时，没有水流过网络，因此所有值都从0开始。该值将不断变化，直到问题得到解决。</p><p id="4516" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><code class="fe ne nf ng mv b">AvailableFlow</code>就是<code class="fe ne nf ng mv b">MaxCapacity</code>和<code class="fe ne nf ng mv b">Flow</code>的区别。给定流过其中一条管道的电流，在管道达到其最大容量之前，还有多少水可以被推过该管道。该值将不断变化，直到问题得到解决。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5a23" class="me lc it mv b gy mz na l nb nc">MATCH(ns:point{name:'Source'})<br/>MATCH(n0:point{name:'Zero'})<br/>MATCH(n1:point{name:'One'})<br/>MATCH(n2:point{name:'Two'})<br/>MATCH(n3:point{name:'Three'})<br/>MATCH(nt:point{name:'Sink'})</span><span id="83cf" class="me lc it mv b gy nd na l nb nc">MERGE(ns)-[c1:CAPACITY]-&gt;(n0)<br/>SET c1.MaxCapacity = 10,<br/>c1.Flow = 0,<br/>c1.AvailableFlow = 10</span><span id="9f40" class="me lc it mv b gy nd na l nb nc">MERGE(ns)-[c2:CAPACITY]-&gt;(n1)<br/>SET c2.MaxCapacity = 10,<br/>c2.Flow = 0,<br/>c2.AvailableFlow = 10</span><span id="7b89" class="me lc it mv b gy nd na l nb nc">MERGE(n0)-[c3:CAPACITY]-&gt;(n2)<br/>SET c3.MaxCapacity = 25,<br/>c3.Flow = 0,<br/>c3.AvailableFlow = 25</span><span id="587d" class="me lc it mv b gy nd na l nb nc">MERGE(n1)-[c4:CAPACITY]-&gt;(n3)<br/>SET c4.MaxCapacity = 15,<br/>c4.Flow = 0,<br/>c4.AvailableFlow = 15</span><span id="d5f0" class="me lc it mv b gy nd na l nb nc">MERGE(n2)-[c5:CAPACITY]-&gt;(nt)<br/>SET c5.MaxCapacity = 10,<br/>c5.Flow = 0,<br/>c5.AvailableFlow = 10</span><span id="a15e" class="me lc it mv b gy nd na l nb nc">merge(n3)-[c6:CAPACITY]-&gt;(n0)<br/>SET c6.MaxCapacity = 6,<br/>c6.Flow = 0,<br/>c6.AvailableFlow = 6</span><span id="f245" class="me lc it mv b gy nd na l nb nc">merge(n3)-[c7:CAPACITY]-&gt;(nt)<br/>SET c7.MaxCapacity = 10,<br/>c7.Flow = 0,<br/>c7.AvailableFlow = 10;</span></pre><p id="573c" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">此时，您已经建立了流网络。事实上，稍微重新排列一下，它看起来应该和图1中的流网络一模一样。</p><h2 id="635e" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated"><strong class="ak">设置初始残留边缘和属性</strong></h2><p id="6164" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">有了新的流量网络，您需要找到最大流量。第一步是在每个现有关系的相反方向上创建边。这有点不直观，但是允许使用残留边缘。</p><p id="4abd" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">残留边存在于不良扩充路径选择的全部或部分撤销中(稍后将详细介绍扩充路径)。在流动网络中，它们是来自所选扩充路径的方向相反的边。在该算法的第一次迭代中，从源到接收器选择的路径将或多或少是随机的，并且很可能该第一路径不会导致最大流量。剩余边为算法创建了一种在节点之间向后移动并撤消或放回流程的方式。每当扩充路径被更新时，相应的剩余边也将被更新。</p><p id="da4a" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">所有这些值最初将被设置为0，直到选择了第一个扩充路径。这些关系被称为<code class="fe ne nf ng mv b">[:SATURATED]</code>，因为它们的流量值等于它们的最大容量值。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="b29f" class="me lc it mv b gy mz na l nb nc">MATCH(ns:point{name:'Source'})<br/>MATCH(n0:point{name:'Zero'})<br/>MATCH(n1:point{name:'One'})<br/>MATCH(n2:point{name:'Two'})<br/>MATCH(n3:point{name:'Three'})<br/>MATCH(nt:point{name:'Sink'})</span><span id="38a8" class="me lc it mv b gy nd na l nb nc">MERGE(ns)&lt;-[c1:SATURATED]-(n0)<br/>SET c1.MaxCapacity = 0,<br/>c1.Flow = 0,<br/>c1.AvailableFlow = 0</span><span id="7df8" class="me lc it mv b gy nd na l nb nc">MERGE(ns)&lt;-[c2:SATURATED]-(n1)<br/>SET c2.MaxCapacity = 0,<br/>c2.Flow = 0,<br/>c2.AvailableFlow = 0</span><span id="048d" class="me lc it mv b gy nd na l nb nc">MERGE(n0)&lt;-[c3:SATURATED]-(n2)<br/>SET c3.MaxCapacity = 0,<br/>c3.Flow = 0,<br/>c3.AvailableFlow = 0</span><span id="cc09" class="me lc it mv b gy nd na l nb nc">MERGE(n1)&lt;-[c4:SATURATED]-(n3)<br/>SET c4.MaxCapacity = 0,<br/>c4.Flow = 0,<br/>c4.AvailableFlow = 0</span><span id="378d" class="me lc it mv b gy nd na l nb nc">MERGE(n2)&lt;-[c5:SATURATED]-(nt)<br/>SET c5.MaxCapacity = 0,<br/>c5.Flow = 0,<br/>c5.AvailableFlow = 0</span><span id="1648" class="me lc it mv b gy nd na l nb nc">MERGE(n3)&lt;-[c6:SATURATED]-(n0)<br/>SET c6.MaxCapacity = 0,<br/>c6.Flow = 0,<br/>c6.AvailableFlow = 0</span><span id="9cad" class="me lc it mv b gy nd na l nb nc">MERGE(n3)&lt;-[c7:SATURATED]-(nt)<br/>SET c7.MaxCapacity = 0,<br/>c7.Flow = 0,<br/>c7.AvailableFlow = 0;</span></pre><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/582335f7ca9ea3e2e1b10fabb96c829c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fhu14ybt3feDAvTF2sLa6Q.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated"><strong class="bd kb">图2 f </strong>低网络显示容量(浅蓝色)和饱和(橙色)边缘:<em class="kc">图片作者</em></figcaption></figure><h2 id="a8e6" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">实现福特-富尔克森算法</h2><p id="906c" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">下面是你将在最近创建的流网络上实现的福特-富尔克森算法的概要。</p><p id="a177" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf iu">循环开始——重复直到找不到新的扩充路径:</strong> <br/> 1。找到一个增加的路径<br/> 2。在增补路径内，找到瓶颈值，<code class="fe ne nf ng mv b">Bottleneck</code> <br/> 3。增加<code class="fe ne nf ng mv b">Flow</code>作为当前流量加上<code class="fe ne nf ng mv b">Bottleneck</code>T22】4。将<code class="fe ne nf ng mv b">AvailableFlow</code>增加为<code class="fe ne nf ng mv b">MaxCapacity</code>减去<code class="fe ne nf ng mv b">Flow</code> <br/> 5。设置一个临时标志，指示该边缘不是残留边缘<br/> 6。找到残留边缘<br/> 7。将剩余边的<code class="fe ne nf ng mv b">Flow</code>增加为<code class="fe ne nf ng mv b">Flow</code>减去<code class="fe ne nf ng mv b">Bottleneck</code>T26】8。将剩余边缘的<code class="fe ne nf ng mv b">AvailableFlow</code>增大为<code class="fe ne nf ng mv b">MaxCapacity</code>减去<code class="fe ne nf ng mv b">Flow</code>T27】9。移除所有残留的标记<br/> 10。基于以下内容重构关系类型:<br/> 10.1如果<code class="fe ne nf ng mv b">AvailableFlow</code>为0，则将关系类型更改为<code class="fe ne nf ng mv b">[:SATURATED]</code>10.2如果<code class="fe ne nf ng mv b">AvailableFlow</code>为&gt; 0，则将关系类型更改为<code class="fe ne nf ng mv b">[:CAPACITY]</code></p><p id="83be" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">如果你没有按照总结做，不要担心。每一步都将被分解和解释。</p><p id="2148" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">注意:下面的密码都是一个查询。我将它分成不同的部分来描述查询的每个部分在做什么，但是如果您试图单独运行每个部分，您将会收到错误。在文章的最底部，你会找到完整的代码。</p><h2 id="5b64" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">1.找到一条增强的道路</h2><p id="f6b2" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">扩充路径是仅使用<code class="fe ne nf ng mv b">[:CAPACITY]</code>关系从源节点到汇聚节点的路径。之所以称之为增加路径，是因为你将改变，或增加路径中每个边的流动。使用Neo4j解决最大流问题的一个巨大好处是路径查找变得很简单。Ford-Fulkerson算法的一半复杂性是实现深度优先或呼吸优先搜索，以找到从源节点到汇聚节点的路径。在Neo4j中，非常简单:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1035" class="me lc it mv b gy mz na l nb nc">MATCH AugmentingPath = (source:Source)-[:CAPACITY*]-&gt;(sink:Sink)<br/>WITH AugmentingPath LIMIT 1<br/>...</span></pre><h2 id="0a86" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">2.在增加的路径中，找到瓶颈</h2><p id="2ff9" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">瓶颈值是扩充路径中任何边上最小的<code class="fe ne nf ng mv b">AvailableFlow</code>。例如，在下面的图3中，这个扩充路径的瓶颈是10，因为源和接收器之间最小的蓝色(<code class="fe ne nf ng mv b">[:CAPACITY]</code>)边是10。这意味着即使连接节点“0”和“2”的边可以处理25个(水、材料、电流等)，因为另一条边只能处理10个，所以整个路径必须限制为10个。两条边并列成为瓶颈只是巧合。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/a6bd55d3dd4bf1a990f6a7b2777819dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P42pDJDDPaMbsFl9JDpF5Q.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated"><strong class="bd kb">图3 </strong>从信源到信宿的增补路径:<em class="kc">作者图片</em></figcaption></figure><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1a2f" class="me lc it mv b gy mz na l nb nc">...<br/>WITH relationships(AugmentingPath) AS rels<br/>UNWIND rels as r<br/>WITH apoc.coll.sort(collect(r.AvailableFlow)) AS AvailableFlows, rels<br/>WITH AvailableFlows[0] AS Bottleneck, rels<br/>...</span></pre><h2 id="aa0d" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">3.增加流量</h2><p id="c7b6" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">现在<code class="fe ne nf ng mv b">Bottleneck</code>已知，通过为每个<code class="fe ne nf ng mv b">[:CAPACITY]</code>边沿添加<code class="fe ne nf ng mv b">Flow</code>到<code class="fe ne nf ng mv b">Bottleneck</code>来使用它增加电流。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2380" class="me lc it mv b gy mz na l nb nc">...<br/>UNWIND rels AS r<br/>SET r.Flow = r.Flow + Bottleneck<br/>...</span></pre><h2 id="7f74" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">4.增加可用流量</h2><p id="b735" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">您已经使用了沿着这些边中的每一条边的一些可用流，因此您需要调整<code class="fe ne nf ng mv b">AvailableFlow</code>,方法是为扩充路径中的每一个<code class="fe ne nf ng mv b">[:CAPACITY]</code>关系从<code class="fe ne nf ng mv b">MaxCapacity</code>中减去<code class="fe ne nf ng mv b">Flow</code>。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e439" class="me lc it mv b gy mz na l nb nc">...<br/>WITH r, Bottleneck<br/>SET r.AvailableFlow = r.MaxCapacity - r.Flow,<br/>...</span></pre><h2 id="5cb4" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">5.设置临时残留边缘标志</h2><p id="a0d0" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">您需要找到这个扩充路径的剩余边，虽然它们在图3中显示为橙色关系，但它们实际上并不出现在查询结果中——Neo4j只是在可视化中自动连接节点。要找到剩余边，首先要做的是将增加的路径关系标记为非剩余。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c969" class="me lc it mv b gy mz na l nb nc">...<br/>r.Residual = 'No'<br/>...</span></pre><h2 id="7999" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">6.找到残留的边缘</h2><p id="0f9e" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">要找到剩余边，首先要匹配构成当前扩充路径的节点，然后再次匹配，寻找没有设置“剩余=否”标志的关系。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e339" class="me lc it mv b gy mz na l nb nc">...<br/>WITH r, Bottleneck<br/>MATCH (n1)-[r]-(n2)<br/>WITH n1,n2,Bottleneck<br/>MATCH(n1)-[res]-&gt;(n2) WHERE res.Residual IS NULL<br/>...</span></pre><h2 id="5e56" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">7.增加剩余边的流量</h2><p id="d59a" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">现在你可以对剩余边的<code class="fe ne nf ng mv b">Flow</code>进行类似的更新，就像对扩充路径所做的那样。请注意，在这种情况下，瓶颈被从流程中减去，导致流程为负。这是因为残留边的最大流量为0(请记住，残留边的存在是为了撤销流量)。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1c34" class="me lc it mv b gy mz na l nb nc">...<br/>WITH res, Bottleneck<br/>SET res.Flow = res.Flow - Bottleneck<br/>...</span></pre><h2 id="c6fd" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">8.增加剩余边缘的可用流量</h2><p id="64de" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">要设置剩余边缘的<code class="fe ne nf ng mv b">AvailableFlow</code>，取<code class="fe ne nf ng mv b">MaxCapacity</code>和<code class="fe ne nf ng mv b">Flow</code>的差值。请注意，在这种情况下<code class="fe ne nf ng mv b">AvailableFlow</code>将为正，因为您正在减去一个负数，并且该边现在将有流可用于下一次循环迭代的路径查找。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ae9a" class="me lc it mv b gy mz na l nb nc">...<br/>WITH res<br/>SET res.AvailableFlow = res.MaxCapacity - res.Flow<br/>...</span></pre><h2 id="972d" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">9.移除所有残留的边缘标志</h2><p id="47af" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">残留边缘标志是临时的，并且需要在该循环的下一次迭代之前被移除。匹配所有关系并将所有残差值设置为<code class="fe ne nf ng mv b">NULL</code>。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c9ce" class="me lc it mv b gy mz na l nb nc">...<br/>WITH res<br/>MATCH(n)-[rel]-(n2)<br/>SET rel.Residual = NULL<br/>...</span></pre><h2 id="95a5" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">10.重构关系类型</h2><p id="e5a7" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">最后要做的最后一件事是检查关系，如果必要的话，将它们从<code class="fe ne nf ng mv b">[:CAPACITY]</code>改为<code class="fe ne nf ng mv b">[:SATURATED]</code>，反之亦然。</p><p id="874a" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">您不希望遍历一条容量已达到最大值(或饱和值)的路径，因此，如果在增加流的过程中，您达到了边的最大容量，那么关系类型应该更改为<code class="fe ne nf ng mv b">[:SATURATED]</code>。</p><p id="5080" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">类似地，如果你从一个已经饱和的边上释放了容量，那么该边类型应该翻转到<code class="fe ne nf ng mv b">[:CAPACITY]</code>。</p><p id="4d4c" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">您可以通过查看每个关系的可用流来做到这一点。如果<code class="fe ne nf ng mv b">AvailableFlow</code>为0，则将关系类型改为<code class="fe ne nf ng mv b">[:SATURATED]</code>。如果<code class="fe ne nf ng mv b">AvailableFlow</code>为&gt; 0，则将关系类型改为<code class="fe ne nf ng mv b">[:CAPACITY]</code>。不应该是负的。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a122" class="me lc it mv b gy mz na l nb nc">...<br/>CALL apoc.refactor.setType(rel,<br/>CASE WHEN rel.AvailableFlow = 0 THEN 'SATURATED'<br/>WHEN rel.AvailableFlow &gt; 0 THEN 'CAPACITY' END)<br/>YIELD output<br/>...</span></pre><h2 id="d6bc" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">将它们循环在一起</h2><p id="8992" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">执行上面的所有操作将只找到一条扩充路径，并进行一组更新。但是你会想一遍又一遍地做这件事，直到再也找不到增加的路径。一旦发生这种情况，你就会知道你已经达到了最大流量！为此，您可以将所有内容包装在一个<code class="fe ne nf ng mv b">apoc.periodic.commit()</code>函数中，该函数将继续迭代代码，直到没有返回任何内容。仅此而已。最大流量问题解决了。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a92d" class="me lc it mv b gy mz na l nb nc">CALL apoc.periodic.commit(<br/>"MATCH AugmentingPath = (source:point{name:'Source'})-[:CAPACITY*]-&gt;(sink:point{name:'Sink'})<br/>WITH AugmentingPath LIMIT 1<br/>WITH relationships(AugmentingPath) AS rels<br/>unwind rels AS r<br/>WITH apoc.coll.sort(collect(r.AvailableFlow)) AS AvailableFlows, rels<br/>WITH AvailableFlows[0] AS Bottleneck, rels<br/>UNWIND rels AS r<br/>SET r.Flow = r.Flow + Bottleneck<br/>WITH r, Bottleneck<br/>SET r.AvailableFlow = r.MaxCapacity - r.Flow,<br/>r.Residual = 'No'<br/>WITH r, Bottleneck<br/>MATCH (n1)-[r]-(n2)<br/>WITH n1,n2,Bottleneck<br/>MATCH(n1)-[res]-&gt;(n2) WHERE res.Residual IS NULL<br/>WITH res, Bottleneck<br/>SET res.Flow = res.Flow - Bottleneck<br/>WITH res<br/>SET res.AvailableFlow = res.MaxCapacity - res.Flow<br/>WITH res<br/>match(n)-[rel]-(n2)<br/>SET rel.Residual = NULL<br/>WITH rel<br/>CALL apoc.refactor.setType(rel,<br/>CASE WHEN rel.AvailableFlow = 0 THEN 'SATURATED'<br/>WHEN rel.AvailableFlow &gt; 0 THEN 'CAPACITY' END)<br/>YIELD output<br/>RETURN count(*)");</span></pre><h1 id="5139" class="lb lc it bd kb ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">评价</h1><p id="642a" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">既然你已经解决了这个问题，你会怎么做呢？上面的循环实际上没有返回任何东西。</p><h2 id="51e2" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">显示最大流动路径</h2><p id="b024" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">以下查询将返回网络中的最大流路径。但是，请确保在Neo4j设置中关闭“连接结果节点”,否则会显示不相关的关系。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="dd7c" class="me lc it mv b gy mz na l nb nc">MATCH path = (s:Source)-[rels*]-(t:Sink)<br/>WHERE ALL(r in relationships(path) WHERE r.Flow &gt; 0)<br/>RETURN path;</span></pre><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nn"><img src="../Images/6793ed56cb1bcfb7184cf73fa8790a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8jGZcQCHRzQH8FxWr7-8A.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated"><strong class="bd kb">图4 </strong>解决了显示饱和边(橙色)和容量边(浅蓝色)的最大流量问题:<em class="kc">作者图片</em></figcaption></figure><h2 id="8c33" class="me lc it bd kb mf mg dn lg mh mi dp lk ko mj mk lo ks ml mm ls kw mn mo lw mp bi translated">获取最大流量值</h2><p id="5c46" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">以下查询将返回网络的最终最大流量值。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8802" class="me lc it mv b gy mz na l nb nc">MATCH ()-[r]-&gt;(t:Sink)<br/>RETURN sum(r.Flow) as MaxFlow</span></pre><h1 id="c0bf" class="lb lc it bd kb ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="3931" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">我花了很多时间在谷歌上搜索，试图找到Neo4j中最大流量问题的解决方案，但没有成功，所以我决定自己开发自己的实现。我希望这篇文章可以帮助指导其他发现自己处于类似境地的人。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="b7d5" class="lb lc it bd kb ld nv lf lg lh nw lj lk ll nx ln lo lp ny lr ls lt nz lv lw lx bi translated">分级编码</h1><p id="8d94" class="pw-post-body-paragraph kd ke it kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="d1e7" class="oa ob it kf b kg kh kk kl ko oc ks od kw oe la of og oh oi bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="744e" class="oa ob it kf b kg oj kk ok ko ol ks om kw on la of og oh oi bi translated">📰查看<a class="ae md" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="ec36" class="oa ob it kf b kg oj kk ok ko ol ks om kw on la of og oh oi bi translated">🔔关注我们:<a class="ae md" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae md" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae md" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="78b9" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">🚀👉<a class="ae md" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf iu">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>