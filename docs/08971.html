<html>
<head>
<title>Fast Database—Fast Application (Useful DB Performance Optimization Techniques)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速数据库—快速应用程序(有用的数据库性能优化技术)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fast-database-fast-application-useful-db-performance-optimization-techniques-34b6926d1196?source=collection_archive---------1-----------------------#2021-06-23">https://levelup.gitconnected.com/fast-database-fast-application-useful-db-performance-optimization-techniques-34b6926d1196?source=collection_archive---------1-----------------------#2021-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b755" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解加速关系数据库的最佳实践。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66a135f1e896e932b3867fc4202b3e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a_MuZMk41dt0pwwE"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">奥斯卡·萨顿在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web应用程序由几个相互连接的层组成:客户端、web框架、ORM，以及最底层的数据库。</p><p id="249c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当应用程序运行缓慢时，性能瓶颈可能隐藏在以下几个级别之一:</p><ul class=""><li id="2099" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">该表可能在数据库中缺少索引<strong class="lb iu">。</strong></li><li id="4252" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">实体框架中可能存在N+1问题<strong class="lb iu">。</strong></li><li id="0e58" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">应用</strong>逻辑主动“变异”不可变的数据类型，导致大量分配到堆中。</li><li id="cade" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> web框架</strong>在将大型响应发送给客户端之前不会对其进行压缩。</li></ul><p id="d115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与任何其他复杂的应用程序组件一样，该数据库有许多加快速度的实践和建议。让我们来看看一些对提高性能最有用的实践。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8502" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">根据您的领域选择数据类型</h1><p id="aacf" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">通过在设计表时为列选择尽可能小的数据类型，可以大大节省SQL Server使用的内存。</p><p id="fa0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在为任何列选择数据类型之前，仅仅了解它将存储字符串、数字还是其他东西是不够的。您应该更好地理解您的域，并考虑存储在列中的值的范围。</p><p id="a189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如用<code class="fe nn no np nq b">int</code>类型来存储一个人的年龄是没有意义的，因为这个类型的范围是-2到2。一个人的年龄不能是负数，而且一个人的最大可能年龄从2⁷到2⁸不等。这一知识允许我们使用<code class="fe nn no np nq b">tinyint</code>类型(从0到255)来节省内存并提高处理较少数据的查询的性能。</p><h2 id="20de" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">估计内存节省</h2><p id="1bfb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们做一个简单的数学计算，估计一下选择<code class="fe nn no np nq b">tinyint</code>而不是<code class="fe nn no np nq b">int</code>类型可以节省多少内存。</p><p id="1d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您的<code class="fe nn no np nq b">dbo.Users</code>表有250，000个注册用户。<code class="fe nn no np nq b">int</code>类型大小为4字节，因此分配用于存储用户年龄的总内存为250000 * 4 = 1000000字节或1兆字节。</p><p id="ed4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后你把<code class="fe nn no np nq b">int</code>换成<code class="fe nn no np nq b">tinyint.</code>一个<code class="fe nn no np nq b">tinyint</code>的大小是1字节，比<code class="fe nn no np nq b">int</code>类型小4倍。通过做一个简单的改变，你将节省<strong class="lb iu"> 0.75 </strong> <strong class="lb iu">兆字节</strong>的内存。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a705" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">创建和维护索引</h1><p id="0588" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">聚集和非聚集索引可以显著加快对表的选择查询，因为索引有助于避免对整个表的线性扫描。</p><p id="2664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当表有聚集索引时，表中的行按键(通常是主键)排序。一个表可以有一个聚集索引，因为数据不能同时按不同的键进行物理排序。</p><p id="9970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非聚集索引是一种单独的B树数据结构，它包含索引中包含的数据和指向表中实际行的指针。一个表上可以有许多非聚集索引，因为与聚集索引不同，表中的实际数据保持不变。</p><p id="3fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引有一个缺点——它们增加了在表上执行<strong class="lb iu"> INSERT、UPDATE或DELETE </strong>语句的时间，因为当表中的数据发生变化时，需要一些时间来重建索引。一个表的索引越多，需要重建的索引就越多。因此，索引许多列会大大降低写操作的速度。</p><p id="b927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，因为非聚集索引是作为单独的数据结构实现的，所以它们<strong class="lb iu">需要额外的内存</strong>。这是将索引数量限制在合理数量的第二个原因——优化内存消耗。</p><p id="c1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用索引来实现更好的应用程序性能时，需要记住以下几点:</p><ul class=""><li id="f733" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">为外键创建索引。</li><li id="6e74" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过基于实际工作负载创建索引来优化性能。仅根据假设创建索引是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Program_optimization#:~:text=%22Premature%20optimization%22%20is%20a%20phrase,of%20a%20piece%20of%20code." rel="noopener ugc nofollow" target="_blank">不成熟的优化</a>。</li><li id="0c22" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">考虑在频繁读取但很少用于写入的表上创建索引。</li><li id="d09b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">定期检查数据库中以前需要但现在不再需要的索引，并删除它们以避免不必要的写性能下降。</li><li id="a0ac" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">了解如何分析数据库中的<a class="ae ky" href="https://www.mssqltips.com/sqlservertip/1634/find-sql-server-missing-indexes-with-dmvs/" rel="noopener ugc nofollow" target="_blank">缺失索引</a>。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="de20" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">对数据进行反规范化以加快查询速度</h1><p id="ec37" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">数据规范化意味着数据是根据<a class="ae ky" href="https://en.wikipedia.org/wiki/Database_normalization" rel="noopener ugc nofollow" target="_blank">范式</a>构建的。</p><p id="df97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规范化提高了插入、更新和删除操作的性能，使它们更加简单，因为规范化的数据不会重复，因此只需要在一个地方访问。</p><p id="1d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规范化表的缺点是选择查询速度慢，这主要是因为两点:</p><ul class=""><li id="c8e7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">规范化的数据分布在许多表中，因此选择查询必须使用连接操作符来获得最终的数据集。</li><li id="f040" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">定期调用包含COUNT()、SUM()、AVG()等聚合函数的SELECT查询会降低大表上的执行速度。</li></ul><p id="270a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库反规范化旨在提高SELECT语句的性能，因为数据存储在更少的表中，所以需要执行更少的JOIN语句。此外，如果SELECT语句只是从表中检索预先计算的值，而不是在每次执行时计算值，那么它的执行速度会快得多。</p><p id="0f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反规范化的缺点是它会使写语句变得非常复杂和缓慢，因为必须在多个列/表中更新相同的重复数据。</p><p id="0355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是数据库中非规范化数据的示例:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="c608" class="nr mr it nq b gy oh oi l oj ok">Orders table:</span><span id="a0bd" class="nr mr it nq b gy ol oi l oj ok"><strong class="nq iu">    ID  Title    Price</strong><br/>    1   Order 1  545.35<br/>    2   Order 2  766.25<br/>    3   Order 3  1943.12</span><span id="98bf" class="nr mr it nq b gy ol oi l oj ok">PrecalculatedOrderInfo table:</span><span id="f541" class="nr mr it nq b gy ol oi l oj ok"><strong class="nq iu">    ID Type         Value</strong><br/>    1  total_price  3,254.72<br/>    2  max_price    1943.12<br/>    3  min_price    545.35</span></pre><p id="2ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不需要定期运行像<code class="fe nn no np nq b">SELECT SUM(Price) FROM Orders</code>这样的查询，因为记录数量太多，可能需要很长时间，只需运行一次查询，然后将值存储到<code class="fe nn no np nq b">PrecalculatedOrderInfo</code>表中。然后，可以通过运行一个简单的不进行计算的查询来获得总价格。</p><p id="a6de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次添加或删除新订单时，<code class="fe nn no np nq b">PrecalculatedOrderInfo</code>中的数据也必须更新，这使得维护非规范化数据变得困难。</p><h2 id="fe84" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">报告数据库</h2><p id="3178" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在规范化和反规范化之间找到平衡，就是在数据一致性、优化的内存消耗和良好的选择查询性能之间找到平衡。</p><p id="75e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，通过创建两个单独的数据库，其中规范化数据用于写入，非规范化数据用于读取，并实现在两个数据库之间同步数据的机制，应用程序可以同时获得规范化和非规范化的好处。</p><p id="7611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在Martin Fowler的这篇文章中读到更多关于这种方法的内容。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="7b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管应用程序由许多层组成，但通常数据库仍然是基础，需要特别的关注和投资来保持整个应用程序快速运行。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="1ffa" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">我的其他文章</h2><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">5种免费提高C#代码性能的方法</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">慢速代码是可选的。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/5-github-repositories-for-net-developers-to-take-tech-skills-to-the-next-level-84f244f6257b"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">5 GitHub。净回购，让你的技术技能更上一层楼</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">亲身体验GitHub资源库。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener  ugc nofollow" target="_blank" href="/why-is-list-struct-is-15-times-faster-to-allocate-than-list-class-17f5f79889ae"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">为什么C#中List <struct>的分配速度比List <class>快15倍</class></struct></h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">在上一篇文章《免费提高C#代码性能的5种方法》中，在其中一个例子中，我测量了…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oy l"><div class="pf l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>