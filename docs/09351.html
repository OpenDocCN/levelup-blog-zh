<html>
<head>
<title>Seventeen Methods For Changing Linux Environment Variables and Docker Containers Environment Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改变Linux环境变量和Docker容器环境变量的十七种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-tutorial-on-the-behavior-of-linux-environment-variables-and-docker-containers-environment-29218a982220?source=collection_archive---------5-----------------------#2021-07-30">https://levelup.gitconnected.com/a-tutorial-on-the-behavior-of-linux-environment-variables-and-docker-containers-environment-29218a982220?source=collection_archive---------5-----------------------#2021-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fc07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker容器从它们的主机继承环境变量，在启动时在外部设置，或者在docker文件中内部设置。还展示了如何修补正在运行的Docker容器。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7ce5fd4182a5813b9f2b604c54334068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bDqtpQmGHmM3YFnxnSfCQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">虚拟环境托管在父环境中。约瑟夫·阿克布鲁德在<a class="ae le" href="https://unsplash.com/s/photos/virtual-world?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5698" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个软件工程师需要知道大量的Linux命令。为什么？</p><ul class=""><li id="d2cd" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">Linux变种是免费和开源的。</li><li id="aa2b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">Linux变体实际上是所有云中虚拟机(节点)的裸机操作系统基础。</li><li id="2caa" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">Linux变种实际上是企业服务器的标准。</li><li id="b0b3" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">Linux变种是Docker和其他虚拟环境创建工具事实上的操作系统基础。</li><li id="b9c7" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">值得重申的是，Linux的变体，如Redhat、Ubuntu、Alpine等都是免费和开源的。</li></ul><p id="7ee6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇博客文章:</p><ol class=""><li id="2e78" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lt ll lm ln bi translated">简要讨论启动<em class="lu">终端会话；</em></li><li id="559f" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lt ll lm ln bi translated">显示和改变<em class="lu">终端会话的<em class="lu">外壳</em>；</em></li><li id="6a59" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lt ll lm ln bi translated">讨论用于显示、定义、设置环境变量的值以及更改环境变量的值的Linux命令；</li><li id="ea18" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lt ll lm ln bi translated">如何修补正在运行的Docker容器；</li><li id="287b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lt ll lm ln bi translated">如何显示、定义、设置和改变<em class="lu"> Docker容器</em>的环境变量的值。</li></ol><p id="4a50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想温习Linux和/或Docker，请阅读以下博客:</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/linuxforeveryone/the-real-reason-linux-users-love-the-command-line-e8043f583028" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Linux用户喜欢命令行的真正原因</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">当我开始我的Linux之旅时，我坚决不碰终端窗口。然后我意识到了真正的吸引力…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ky ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://medium.com/100-days-of-linux/20-basic-linux-commands-for-beginners-78516ab936d6" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">初学者的20个基本Linux命令！</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">对初学者有帮助的基本Linux命令示例！</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm ky ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://medium.com/codingthesmartway-com-blog/docker-beginners-guide-part-1-images-containers-6f3507fffc98" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Docker —初学者指南—第1部分:图像和容器</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">这篇文章首先在CodingTheSmartWay.com上发表。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mo l mj mk ml mh mm ky ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener  ugc nofollow" target="_blank" href="/our-enterprise-docker-solution-for-migration-to-the-cloud-d7bb9d1a796b"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">我们面向云迁移的企业Docker解决方案</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">这是一个关于我们第一次推出Docker的故事，它发生在我以前作为承包商工作过的一家公司。代码，作为…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mh l"><div class="mp l mj mk ml mh mm ky ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://towardsdatascience.com/twenty-one-techniques-and-five-concepts-for-better-docker-usage-9ee135dccdc9" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">更好地使用Docker的21个技巧和5个概念</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">Docker是为你的非智能手机电脑设计的应用软件。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mq l mj mk ml mh mm ky ly"/></div></div></a></div><p id="2bbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在过去的五年里，我一直使用码头集装箱。它使我能够处于Ubuntu 20.04-Python 3.8环境中，无论是由我的MacOS还是我的Ubuntu 18.0-Python 3.6-Nivida机器托管。</p><p id="0979" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以自由使用这篇博客文章中展示的Linux和Docker命令。</p><p id="4912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备好了吗？让我们开始吧！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="32d7" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">1.启动终端会话</h1><p id="f41d" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">每个Linux操作系统都有一个不活动的图形用户界面(GUI)。顶层窗格通常称为桌面。由施乐公司命名，由苹果公司和微软公司商业化。</p><p id="10ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几乎所有的Linux变种都有一个GUI终端会话应用程序。示例桌面GUI终端会话有:<code class="fe ob oc od oe b"><strong class="js iu">gnome-terminal</strong></code>、<code class="fe ob oc od oe b"><strong class="js iu">konsole</strong></code>、<code class="fe ob oc od oe b"><strong class="js iu">xterm</strong></code>、<code class="fe ob oc od oe b"><strong class="js iu">rxvt</strong></code>、<code class="fe ob oc od oe b"><strong class="js iu">kvt</strong></code>、<code class="fe ob oc od oe b"><strong class="js iu">nxterm</strong></code>和<code class="fe ob oc od oe b"><strong class="js iu">eterm</strong></code>。</p><p id="bde5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，以前，终端应用程序被称为“终端仿真器”大约四十年前，回到过去的美好时光，一个“真正的”终端有80个字符宽，在黑屏上以白色(或绿色)字符的线性流显示数据。</p><p id="9b36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu"> IMHO </em> </strong> <em class="lu">:“终端仿真器”应该有不同的名称。作为一个例子，“鱼模拟器”被称为蜥蜴。“终端会话”怎么样</em></p><p id="44ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在MacOS Big Sur(版本11.x)上，GUI终端会话启动图标显示为:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d56c2ef038bf5ac62f49798c19dcc8c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*SWEB_WhfDtf7XKp8YApLwQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图一。来源:作者桌面快照。</figcaption></figure><p id="d738" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在“启动栏”上通过双击图标启动终端会话。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="a74f" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">2.确定终端会话启动哪个Shell</h1><p id="3689" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">当您启动终端会话时，您通过“命令行”进行交互在终端会话中执行的“命令行”解析器应用程序被称为“shell”</p><p id="4bdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有不同的shell可以使用，比如:<code class="fe ob oc od oe b"><strong class="js iu">sh</strong></code>(通天shell)<strong class="js iu"/><code class="fe ob oc od oe b"><strong class="js iu">bash</strong></code>(bash或者再次通天shell)<code class="fe ob oc od oe b"><strong class="js iu">ksh</strong></code>(Korn shell)<code class="fe ob oc od oe b"><strong class="js iu">tcsh</strong></code>(TC shell)<code class="fe ob oc od oe b"><strong class="js iu">zsh</strong></code>。</p><p id="2cc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个shell都有细微的语法差异，这种语法差异足以让一个shell脚本在不同的shell中以非常不酷的方式失败。</p><p id="67ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注</em> </strong> <em class="lu">:可能存在语义差异，附加功能。</em></p><p id="5550" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我推荐你挑个壳，比如<code class="fe ob oc od oe b"><strong class="js iu">bash.</strong></code>至少五年不变？五年给你的智力投资带来了足够的回报。</p><p id="239c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">浅见</em> </strong> <em class="lu">:大家都用</em> <code class="fe ob oc od oe b"><strong class="js iu"><em class="lu">bash</em></strong></code> <em class="lu">。为什么苹果改用</em> <code class="fe ob oc od oe b"><strong class="js iu"><em class="lu">zsh</em></strong></code> <em class="lu">大苏尔发布？我确信他们有充分的理由——不是。</em></p><p id="b2e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注</em> </strong> <em class="lu">:如果一个苹果开发者对于MacOS或者iX设备，那么，唉，把</em> <code class="fe ob oc od oe b"><strong class="js iu"><em class="lu">tcsh</em></strong></code>换成<em class="lu">。Xcode要求您切换。</em></p><p id="116c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以看到正在使用的shell:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="3b6e" class="ok mz it oe b gy ol om l on oo">echo "$SHELL"<br/># or<br/>echo $0"<br/># or my favorite<br/># ps -p "$$"</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/f98fd8f9cb0580da80d2c8cbc6eedd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*AVX9aYRphlYdHR0kjm4FEw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><code class="fe ob oc od oe b">ps -p "$$" output,. </code>来源:作者桌面快照。</figcaption></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="e0fe" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">3.更改在终端会话中启动的Shell</h1><p id="59e5" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">在终端会话中，使用命令<code class="fe ob oc od oe b">$ chsh -s &lt;path&gt;</code>切换到不同的shell，其中的路径是/etc/shell中列出的shell路径之一。</p><p id="a465" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在MacOS Big Sur上，炮弹的清单是:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="19dc" class="ok mz it oe b gy ol om l on oo">$ <!-- -->/bin/zsh, /bin/bash, /bin/csh, /bin/dash, /bin/ksh, /bin/sh, or /bin/tcsh</span></pre><p id="f073" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，改为bash。</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="4018" class="ok mz it oe b gy ol om l on oo">$ chsh -s <!-- -->/bin/bash</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="683f" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">4.指定获取脚本时要使用的Shell</h1><p id="e6ae" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">下面是我的<code class="fe ob oc od oe b">.bash_profile</code>文件的前15行:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="ef1a" class="ok mz it oe b gy ol om l on oo">#!/bin/bash<br/>#<br/># v 1.5.1 # I always version to make sure I am not overwriting files.<br/># 2015-09-12 # This is the last date I edited a file.<br/>export PATH="/usr/local/sbin:$PATH"<br/>#<br/>#export PYTHONSTARTUP=/Users/brucecottman/Documents/DB/Programming/PYSPARK/InitPySpark.py</span><span id="c56a" class="ok mz it oe b gy oq om l on oo"># edit 5-14-2017<br/>export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/test.in<br/>export SPARK_HOME=/usr/local/Cellar/apache-spark/2.4.3/libexec<br/>export PYTHONPATH=/usr/local/Cellar/apache-spark/2.0.1/libexec/python/:$PYTHONP$</span><span id="9e37" class="ok mz it oe b gy oq om l on oo">export PATH=$JAVA_HOME/bin:$SBT_HOME/bin:$SBT_HOME/lib:$SCALA_HOME/bin:$SCALA_HOME/lib:$PATH<br/>export PATH=$JAVA_HOME/bin:$SPARK_HOME:$SPARK_HOME/bin:$SPARK_HOME/sbin:$PATH<br/>export PYSPARK_PYTHON=python3</span><span id="5f88" class="ok mz it oe b gy oq om l on oo">#</span></pre><p id="f256" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关键的一点是，这个脚本有指令<code class="fe ob oc od oe b">#!/bin/bash</code>来用bash shell执行脚本<code class="fe ob oc od oe b">.bash_profile</code>。您用Linux命令<code class="fe ob oc od oe b">source:</code>执行一个shell脚本</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="0225" class="ok mz it oe b gy ol om l on oo">$ source &lt;shell-path&gt;<br/># example<br/>$ source .bash_profile</span></pre><p id="dbae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Github存储库中有丰富的开源登录配置文件。</p><p id="391f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注</em> </strong> <em class="lu">:你从这些脚本中学习shell编程。</em></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="97b7" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">5.Shell脚本是在您启动终端会话时获得的</h1><p id="3c43" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">当您启动一个新的终端会话时，找出自动运行的shell脚本是非常困难的。</p><p id="5357" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注意</em> </strong> <em class="lu">:记住，我在MacOS上使用的是终端会话。MacOS拥有大多数Linux shell命令。但是，如果您使用的是Linux版本，那么在可用的shell命令方面会有一些小的不同。</em></p><p id="8e93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用的方法是在我的<code class="fe ob oc od oe b">$HOME</code> l目录中列出<code class="fe ob oc od oe b">.&lt;files&gt;</code>:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="aede" class="ok mz it oe b gy ol om l on oo">$ cd $HOME;ls -al .*</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/a3218de86d1bbe2347a6cb3110989de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11z3Pfw0ZG7gTs8NUgOIEg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><code class="fe ob oc od oe b">The command cd $HOME;ls -al .* output. </code>来源:作者桌面快照。</figcaption></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="865c" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">6.常见的Linux环境变量</h1><p id="3e02" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">在顶级环境(父环境)中创建的默认变量通常是:</p><ul class=""><li id="8b61" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">SHELL</code> : Value是终端会话的外壳；</li><li id="670a" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">TERM</code> : Value指定运行shell时要模拟的终端类型；</li><li id="4be2" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">USER</code>:值指定登录用户。</li><li id="d4f0" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">PWD</code>:指定工作目录的值。</li><li id="70d9" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">OLDPWD</code>:值指定上一个工作目录。您可以通过运行以下命令切换回之前的目录。<code class="fe ob oc od oe b">cd -</code>。</li><li id="00c1" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">MAIL</code> : Value指定登录用户邮箱的路径。</li><li id="62c3" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">PATH</code> : Value指定一个目录列表，系统将按降序检查任何命令的二进制文件。</li><li id="3202" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">LANG</code> : Value指定计算机语言和本地化设置，包括字符编码。</li><li id="34ee" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">HOME</code> : Value指定登录用户主目录的路径。</li><li id="1bbf" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><code class="fe ob oc od oe b">_</code> : Value指定之前执行的命令。</li></ul><h1 id="d927" class="my mz it bd na nb os nd ne nf ot nh ni nj ou nl nm nn ov np nq nr ow nt nu nv bi translated">7.环境变量可以有多个值</h1><p id="7256" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">如果您深入研究系统核心代码，您会遇到创建和销毁多值环境变量的情况。作为一个用户，就没那么多了。但是，有一个多值环境变量您会遇到并更改— <code class="fe ob oc od oe b">PATH:</code></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ox"><img src="../Images/b328bc5eb8edfda94868dc1a55c38c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDahVKB0FPOI7SX_VdIPkA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">echo $PATH输出。<code class="fe ob oc od oe b"> </code>来源:作者桌面快照。</figcaption></figure><p id="cc55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常要设置一个新的<code class="fe ob oc od oe b">PATH,</code>通常要添加到<code class="fe ob oc od oe b">PATH:</code></p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="aeb7" class="ok mz it oe b gy ol om l on oo">PATH=$PATH:&lt;path-1&gt;:&lt;path-2&gt;:&lt;path-3&gt;...</span></pre><p id="b768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">按照Python的说法，它被附加到一个列表中。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="474a" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">8.在终端会话中显示环境变量</h1><p id="c499" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">您在shell中显示所有环境变量:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="8dfc" class="ok mz it oe b gy ol om l on oo">echo "$&lt;environment variable&gt;"<br/># for example<br/>echo "$SHELL"</span></pre><p id="7f55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者更好的是，用命令<code class="fe ob oc od oe b">printenv</code>打印出所有的环境变量:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="c44a" class="ok mz it oe b gy ol om l on oo">&gt; printenv</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/288e2c1184cf7f2b449b170e4df69972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DoOTWgy80ggqLrSuULjlw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><code class="fe ob oc od oe b">printenv output. </code>来源:作者桌面快照。</figcaption></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="955b" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">9.在终端会话中创建环境变量</h1><p id="eabe" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">在几乎所有的shells中创建新的环境变量都很简单。在<code class="fe ob oc od oe b">bash:</code></p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="b707" class="ok mz it oe b gy ol om l on oo">$ NEW_VAR=123456789<br/>$ export NEW_VAR<br/>$ printenv; grep NEW_VAR</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/d5bf67ef3561f200b87126a7a6cccc30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B20fCTx8gJAYROL-eNXWXw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><code class="fe ob oc od oe b">printenv|grep NEW_VAR output. </code>来源:作者桌面快照。</figcaption></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="6f3a" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">10.显示Docker容器中的环境变量</h1><p id="24de" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">我所有的Docker映像都有一个Linux基础层。当您运行Docker容器时，您可以附加和运行大多数shell命令。</p><p id="3915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，您显示所有环境变量，并在Docker容器外壳中分配一个值:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="a18a" class="ok mz it oe b gy ol om l on oo">$ docker run -d --name  &lt;container name/ID&gt; &lt;image name/ID&gt;<br/>$ docker exec -it &lt;container name/ID&gt; bash -c "printenv"</span></pre><p id="2f1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哪些输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/c5bec93dabc84eb84504746e447eb66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IyX_w5kMHLHpQslj0pck-A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><code class="fe ob oc od oe b">printenv output of Docker container lp. </code>来源:作者桌面快照。</figcaption></figure><p id="2aa5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个命令启动Docker映像，<code class="fe ob oc od oe b">&lt;image-name&gt;,</code>作为Docker容器运行，<code class="fe ob oc od oe b">&lt;container-name&gt;.</code>第二个命令，<code class="fe ob oc od oe b">&lt;docker exec..&gt;,</code>在Docker容器内运行，<code class="fe ob oc od oe b">&lt;container-name&gt;.</code></p><p id="d02a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以作为一个分离的进程运行，在后台Docker容器中，<code class="fe ob oc od oe b">&lt;container-name&gt;.</code>:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="f99c" class="ok mz it oe b gy ol om l on oo">$ docker run -d --name  &lt;container name/ID&gt; &lt;image name/ID&gt;<br/>$ docker exec -t -d &lt;container name/ID&gt; bash -c "printenv"</span></pre><p id="289f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了调试<strong class="js iu">容器</strong>，我们启动了一个交互式会话:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="878d" class="ok mz it oe b gy ol om l on oo">$ docker run -d --name  &lt;container name/ID&gt; &lt;image name/ID&gt;<br/>$ docker exec -it &lt;container name/ID&gt; bash<br/># ps -p "$$"<br/># exit<br/>$</span></pre><p id="47f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pa"><img src="../Images/8bb7f0ae824088845162e5498a7954c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aa7l0LkdWQQNEAJgml5ANw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Shell命令ps -p "$$" <code class="fe ob oc od oe b"> output of Docker container lp. </code>来源:作者桌面快照。</figcaption></figure><p id="117d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注意</em> </strong> <em class="lu">:您可以通过输入</em> <code class="fe ob oc od oe b"><em class="lu">exit</em></code> <em class="lu">来结束或终止您的会话。</em></p><p id="ed84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注意</em> </strong> <em class="lu">:以上命令对于监控和您可能想要在运行的</em> <strong class="js iu"> <em class="lu">容器</em> </strong> <em class="lu">上执行的其他任务非常有用。</em></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="0062" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">11.确定哪个Shell是Docker容器中的默认Shell</h1><p id="2ee8" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">在上一个例子中，我们确定了Docker容器中的默认shell。</p><p id="c4ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下内容也适用:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="644e" class="ok mz it oe b gy ol om l on oo">$ docker run -d --name  &lt;container name/ID&gt; &lt;image name/ID&gt;<br/>$ docker exec -it &lt;container name/ID&gt; bash<br/># <!-- -->echo "$SHELL"<br/># exit<br/>$</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/08dae7538af6b2ecc548090b594d375c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKNN4H5NeUVmQ9-R38xdvA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Shell命令e <code class="fe ob oc od oe b">cho "$SHELL" output of Docker container lp. </code>来源:作者桌面快照。</figcaption></figure><p id="87d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在Docker容器中交互式运行任何shell。您可以在Docker容器的虚拟环境中执行shell命令。</p><p id="adf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我觉得太棒了！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="bb5d" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">12.更改Docker容器中的外壳</h1><p id="7c08" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">对前面的命令稍加修改，我们使用以下命令切换到Docker容器中的<code class="fe ob oc od oe b">sh</code>:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="1255" class="ok mz it oe b gy ol om l on oo">$ $ docker run -d --name  &lt;container name/ID&gt; &lt;image name/ID&gt;<br/>$ docker exec -it &lt;container name/ID&gt; bash# <!-- -->sh<br/># exit<br/>$</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pc"><img src="../Images/a04d29affaba588e998ee76bdf8612a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNt1aVh8Q7EDerWRuLLZzg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在Docker容器中改变外壳<code class="fe ob oc od oe b"> lp. </code>来源:作者桌面快照。</figcaption></figure><p id="a165" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注意</em> </strong> <em class="lu">:一退出外壳开关就消失了。记得你在Docker容器里面运行</em><code class="fe ob oc od oe b"><em class="lu">bash</em></code><em class="lu"/><code class="fe ob oc od oe b"><em class="lu">&lt;docker exec..&gt;,</em></code><em class="lu">，</em> <code class="fe ob oc od oe b"><em class="lu">lp.</em></code></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="f6f9" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">13.不要在Docker映像中使用root</h1><p id="38d8" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">创建映像并赋予其root权限被认为是一种不好的做法。我通过对我的docker文件进行以下更改来解决这个问题:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="d597" class="ok mz it oe b gy ol om l on oo">USER root</span><span id="c547" class="ok mz it oe b gy oq om l on oo">.<br/>.<br/>bunch of dockerfile commands that need root<br/>like apt-get<br/>.<br/>.</span><span id="a05e" class="ok mz it oe b gy oq om l on oo">USER $USER  # After commands that need root priveledges.</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="4746" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">14.创建群组“docker”</h1><h2 id="1357" class="ok mz it bd na pd pe dn ne pf pg dp ni kb ph pi nm kf pj pk nq kj pl pm nu pn bi translated">马科斯</h2><p id="d45c" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">MacOS使用的命令不同于Linus变体。</p><p id="28ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我托管的是MacOS终端会话，而不是Docker容器，所以我输入了将$USER放入组<code class="fe ob oc od oe b">docker</code>的命令:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="f75b" class="ok mz it oe b gy ol om l on oo"># add "docker"as a group<br/>$ sudo dseditgroup -o create docker # create a group named "docker"<br/># add current user to group docker<br/>$ sudo dseditgroup -o edit -a $USER -t user docker <br/># List what groups $USER is in  <br/>$ id -Gn $USER</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi po"><img src="../Images/69862e4548f8f53e7a6dc502986e236e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3EmQvfztdIorvc8eacjdA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">用户在组docker中。<code class="fe ob oc od oe b"> </code>来源:作者桌面快照。</figcaption></figure><p id="8524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注</em> </strong> <em class="lu">:以上魔法圣咏我就不解释了。通常，你使用MacOS的“系统偏好设置&gt;用户组&amp;”但是，我想保持一致，从终端会话执行所有命令。</em></p><h2 id="1934" class="ok mz it bd na pd pe dn ne pf pg dp ni kb ph pi nm kf pj pk nq kj pl pm nu pn bi translated">Linux变体</h2><p id="d18c" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">需要有<code class="fe ob oc od oe b">root</code>密码才能在任何Linux变体中执行以下命令:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="25d4" class="ok mz it oe b gy ol om l on oo">$ sudo groupadd mygroupgroupadd docker<br/>$ sudo usermod -a -G docker $USER</span></pre><p id="2b37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:<code class="fe ob oc od oe b">busybox</code>在我看来，是作为一个基本的Linux来创建的，以支持创建最小的Docker容器。我不认为<code class="fe ob oc od oe b">busybox</code>是我的Linux变种列表的一部分。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="45c2" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">15.在启动时为Docker容器设置环境变量</h1><p id="d33a" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">你使用<code class="fe ob oc od oe b">--env</code>、<code class="fe ob oc od oe b">-e</code>选项，以<code class="fe ob oc od oe b">docker run.</code>为例:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="8cb4" class="ok mz it oe b gy ol om l on oo">$ $ docker run -e \ "SSL_CERT_FILE=/Users/brucecottman/github_cert.ca.txt" -d --name \&lt;container name/ID&gt; &lt;image name/ID&gt;</span></pre><p id="581d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您忘记在Docker容器启动时指定环境变量，那么您可以执行以下操作:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="e99d" class="ok mz it oe b gy ol om l on oo">$ docker run -d --name  &lt;container name/ID&gt; &lt;image name/ID&gt;<br/>$ docker exec -it &lt;container name/ID&gt; bash<br/>#SSL_CERT_FILE="/Users/brucecottman/github_cert.ca.txt"<br/>#export SSL_CERT_FILE</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="0d00" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">16.在Docker文件中为Docker容器设置环境变量</h1><p id="991c" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">Dockerfile有一个独特的用于设置Docker镜像中的环境变量，<code class="fe ob oc od oe b">ENV.</code>例如:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="9a4b" class="ok mz it oe b gy ol om l on oo"><strong class="oe iu">FROM </strong>python:3.7<br/><strong class="oe iu">FROM </strong>jupyter<strong class="oe iu">/</strong>minimal-notebook<br/><strong class="oe iu">ENV &lt;new_var&gt;="&lt;value"&gt;</strong></span><span id="d78c" class="ok mz it oe b gy oq om l on oo"><strong class="oe iu">.<br/>.<br/>.</strong></span></pre><p id="b4cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:Docker环境变量不应该是<code class="fe ob oc od oe b">EXPORTed.</code></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="78b4" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">17.修补正在运行的Docker容器</h1><p id="0cf1" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">以下对数据科学家来说很棒。然而，它可能会让你被“系统”或任何在你之后收拾残局的组织“烧死”。</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="79fc" class="ok mz it oe b gy ol om l on oo">$ docker run -d --name  &lt;container name/ID&gt; &lt;image name/ID&gt;<br/>$ docker exec -it &lt;container name/ID&gt; bash<br/>## look for diagrams in the Docker container</span><span id="5967" class="ok mz it oe b gy oq om l on oo"># pip list | grep diagrams</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pp"><img src="../Images/20e11d4692626a7321a58c9c723e3d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ferkk_ZNEnGe-QsPbUBa3g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我在已安装软件包的列表中找不到图表。<code class="fe ob oc od oe b"> </code>来源:作者桌面快照。</figcaption></figure><p id="73e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Docker容器中安装图表:</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="803b" class="ok mz it oe b gy ol om l on oo">#  pip install diagrams</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pq"><img src="../Images/3db3784b5bbe32c0e874b317c3cbb3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C0oaY8i32EHZnwHZjdPu8A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">已安装图表。<code class="fe ob oc od oe b"> </code>来源:作者桌面快照。</figcaption></figure><p id="ca3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">退出docker容器<code class="fe ob oc od oe b">bash</code>终端会话。创建一个新的docker容器<code class="fe ob oc od oe b">bash</code>终端会话。运行docker容器中安装了图吗？</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="5075" class="ok mz it oe b gy ol om l on oo">$ docker exec -it &lt;container name/ID&gt; bash<br/>## look for diagrams in the Docker container<br/># pip list | grep diagrams</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pr"><img src="../Images/a4dc96a79265263e673533fd7cac853b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69V7ikfR2XO8fGfgWU-MqQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">修补到正在运行的Docker容器中的图。<code class="fe ob oc od oe b"> </code>来源:作者桌面快照。</figcaption></figure><p id="d924" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">快点，现在，把这个放进你的档案里。</p><pre class="kp kq kr ks gt og oe oh oi aw oj bi"><span id="adad" class="ok mz it oe b gy ol om l on oo"># Dockerfile commands<br/>.<br/>. <br/>.<br/><strong class="oe iu">RUN pip install diagrams</strong><br/>.<br/>. <br/># Dockerfile commands</span></pre><p id="eb81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="lu">注意</em> </strong> <em class="lu"> : Docker容器必须有Python 3.5+。</em></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="f8bf" class="my mz it bd na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv bi translated">摘要</h1><p id="2ab4" class="pw-post-body-paragraph jq jr it js b jt nw jv jw jx nx jz ka kb ny kd ke kf nz kh ki kj oa kl km kn im bi translated">在十七步中，我展示了:</p><ol class=""><li id="7675" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lt ll lm ln bi translated">发起<em class="lu">终端会话；</em></li><li id="f94b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lt ll lm ln bi translated">显示和改变<em class="lu">终端会话的<em class="lu">外壳</em>；</em></li><li id="7ed7" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lt ll lm ln bi translated">用于显示、定义、设置环境变量的值以及更改环境变量的值的Linux命令；</li><li id="940b" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lt ll lm ln bi translated">如何显示、定义、设置和更改<em class="lu"> Docker容器的环境变量的值；</em></li><li id="1653" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lt ll lm ln bi translated">如何修补正在运行的Docker容器？</li></ol><p id="0b85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Docker是一个丰富的工具。</p><p id="bafe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将在下一篇博客文章中展示如何从Docker容器创建微服务，并将它们放在一起创建不同的服务。</p><p id="c86a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编码快乐！</p></div></div>    
</body>
</html>