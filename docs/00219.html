<html>
<head>
<title>Static code analysis in Javascript: verifying correctness of pattern matching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的静态代码分析:验证模式匹配的正确性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/static-code-analysis-in-javascript-verifying-correctness-of-pattern-matching-4bd16d42ec27?source=collection_archive---------1-----------------------#2018-09-30">https://levelup.gitconnected.com/static-code-analysis-in-javascript-verifying-correctness-of-pattern-matching-4bd16d42ec27?source=collection_archive---------1-----------------------#2018-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/cbcb293cbab65f5f338e10f7071b7d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKRDrOyxOlNowgbEI8oFSQ.png"/></div></figure><div class=""/><h1 id="6de2" class="ju jv ix bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">目录</h1><ul class=""><li id="20b1" class="ks kt ix ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">函数式语言中的求和类型</li><li id="cb18" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">tagmeme:Javascript中Sum类型的实现</li><li id="4b78" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">使用标签模因的问题</li><li id="7d75" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">标签词分析器:标签词的静态类型检查器和分析器</li><li id="82e2" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">分析仪的工作原理</li><li id="5e39" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">关于令人敬畏的Javascript生态系统</li></ul><h2 id="ca47" class="lp jv ix bd jw lq lr dn ka ls lt dp ke kz lu lv ki lb lw lx km ld ly lz kq ma bi translated">函数式语言中的求和类型</h2><p id="05e2" class="pw-post-body-paragraph mb mc ix ku b kv kw md me kx ky mf mg kz mh mi mj lb mk ml mm ld mn mo mp lf ij bi translated">许多函数式编程语言，尤其是静态类型的语言，如F#、Elm、Haskell等。有联合的概念，也称为和类型:这些是用于建模值的类型定义，这些值可以是一组不相交的事物中的一个。例如，您可以将<code class="fe mq mr ms mt b">Shape</code>建模为圆形、三角形或矩形，或者您可以定义一个只能是红色、绿色或蓝色的<code class="fe mq mr ms mt b">Color</code>。</p><p id="0eb0" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">在某种意义上，它们类似于C风格语言中的枚举(enum ),但有一个很大的区别:它们可以用数据参数化。圆形有半径，而矩形既有高度又有宽度。确切的数据类型可以在定义中进行编码，这是它在F#中的样子:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5357" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">本例中的不同形状(圆形、矩形和三角形)被称为<code class="fe mq mr ms mt b">Shape</code>类型的“联合案例”。每个联合用例被认为是一个<code class="fe mq mr ms mt b">Shape</code>的构造器:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2774" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">一旦构造了一个并集的值，就可以匹配该值的不同模式。例如，要确定某个值是否为圆形，需要匹配该值的所有情况:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a6f1" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">函数式语言的现代编译器的一个最好的特性是它们可以检测出详尽的模式匹配。你的代码是否真的考虑到了所有可能的情况，如果没有，它会给你警告，这是非常令人惊讶的。</p><h2 id="9594" class="lp jv ix bd jw lq lr dn ka ls lt dp ke kz lu lv ki lb lw lx km ld ly lz kq ma bi translated">tagmeme:Javascript中Sum类型的实现</h2><p id="58c2" class="pw-post-body-paragraph mb mc ix ku b kv kw md me kx ky mf mg kz mh mi mj lb mk ml mm ld mn mo mp lf ij bi translated">当然，在我的工作场所，我不能奢侈地使用F#或Elm，因为我们主要使用Javascript进行前端开发。不要误解我，我认为Javascript是可以的，我也有点喜欢它，但我仍然怀念使用表达类型系统进行领域建模的能力，或者至少是使用sum类型。</p><p id="6669" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">幸运的是，Javascript中有一些库可以弥补这种情况，其中一个我最近发现的被称为<a class="ae nf" href="https://github.com/andrejewski/tagmeme" rel="noopener ugc nofollow" target="_blank"> tagmeme </a>的隐藏瑰宝:一个由<a class="ae nf" href="https://github.com/andrejewski" rel="noopener ugc nofollow" target="_blank"> Chris Andrejewski </a>编写的用于简单标记联合的库。我非常喜欢这个库，因为它非常简单，让我们看看前面展示的例子是如何用Javascript和tagmeme编写的:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a88f" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">如您所见，我们将形状的联合“类型”定义为联合案例列表。然后每个case都变成了<code class="fe mq mr ms mt b">Shape</code>的构造函数，之后我们就可以根据<code class="fe mq mr ms mt b">Shape</code>的某些值进行模式匹配。</p><p id="99d0" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">对我来说，这看起来很漂亮，非常类似于用实现联合用例的语言(如F#或Elm)编写的代码。</p><h2 id="074a" class="lp jv ix bd jw lq lr dn ka ls lt dp ke kz lu lv ki lb lw lx km ld ly lz kq ma bi translated">使用标签模因的问题</h2><p id="4467" class="pw-post-body-paragraph mb mc ix ku b kv kw md me kx ky mf mg kz mh mi mj lb mk ml mm ld mn mo mp lf ij bi translated">因为这是我们正在讨论的Javascript，它可能非常容易出错，因为我们肯定会犯以下错误之一，这将导致tagmeme在运行时出现异常:</p><ul class=""><li id="df17" class="ks kt ix ku b kv mu kx mv kz ng lb nh ld ni lf lg lh li lj bi translated">当忘记处理一个案例(或拼错案例名称)时</li><li id="21cb" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">处理未申报的案件时(处理太多案件)</li><li id="a089" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">当处理所有情况时，仍然提供永远不会匹配的冗余通配符参数(参见文档)</li><li id="50fb" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">当使用单词“match”作为联合用例时</li><li id="903b" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">复制union case声明时</li><li id="ca7b" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">在值构造函数中拼错联合事例名称时</li></ul><p id="52cc" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">即使我们有一个linter来检查编写的Javascript代码的语法是否正确，如果我们没有正确地编写针对sum类型的详尽模式匹配，我们仍然会遇到运行时错误。静态分析到救援！</p><h2 id="070c" class="lp jv ix bd jw lq lr dn ka ls lt dp ke kz lu lv ki lb lw lx km ld ly lz kq ma bi translated">标签词分析器:标签词的静态类型检查器和分析器</h2><p id="1c17" class="pw-post-body-paragraph mb mc ix ku b kv kw md me kx ky mf mg kz mh mi mj lb mk ml mm ld mn mo mp lf ij bi translated">因为这些是在“编译”时可能出错的已知变量，所以我问自己是否有可能编写一个程序，在实际运行应用程序之前检查我们是否犯了一个愚蠢的错误？这是我上周的一个小实验，当我深入巴别塔解析器的未知领域，以检测哪里可能会发生错误，同时提供有意义的替代方案，如果是这样的话:介绍<a class="ae nf" href="https://github.com/Zaid-Ajaj/tagmeme-analyzer" rel="noopener ugc nofollow" target="_blank"> tagmeme-analyzer </a>！</p><div class="ip iq gp gr ir nj"><a href="https://github.com/Zaid-Ajaj/tagmeme-analyzer" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iy gy z fp no fr fs np fu fw iw bi translated">Zaid-Ajaj/tagmeme分析器</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">静态代码分析器，检查详尽的模式匹配，联合大小写错别字和标签中的冗余参数…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx it nj"/></div></div></a></div><p id="d56a" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">作为一个CLI工具实现，这个分析器针对一个javascript文件运行，解析AST并检测库在哪里被错误地使用！让我们通过编写一些在运行时会失败的代码来看看这一点，首先我们将在一个单独的文件中定义联合“类型”:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d5b2" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated"><code class="fe mq mr ms mt b">Option</code>和<code class="fe mq mr ms mt b">Result</code>声明正确，但是<code class="fe mq mr ms mt b">Numbers</code>和<code class="fe mq mr ms mt b">Duplicates</code>声明不正确，前者有“匹配”作为联合案例，后者有重复的联合案例。下面是消费代码:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="eec1" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">在评论中你可以看到什么是不正确的，现在我们需要运行<code class="fe mq mr ms mt b">tagmeme-analyzer</code>来对抗<code class="fe mq mr ms mt b">app.js</code>，让我们先安装它(现在作为一个全局工具)</p><pre class="mz na nb nc gt ny mt nz oa aw ob bi"><span id="cf9c" class="lp jv ix mt b gy oc od l oe of">npm install -g tagmeme-analyzer</span></pre><p id="d5c7" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">然后运行分析器并使用该文件作为参数，您将得到:</p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/31fdd34de6af901184b815772bd774e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXu3MoJnWUTAk68hgq3vFQ.png"/></div></div></figure><p id="3e1e" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">正如您所看到的，分析器检测到了我们之前讨论过的所有问题，如果您从visual studio代码内部运行它，您可以导航到出现问题的行。</p><h2 id="1946" class="lp jv ix bd jw lq lr dn ka ls lt dp ke kz lu lv ki lb lw lx km ld ly lz kq ma bi translated">分析仪的工作原理</h2><p id="53ff" class="pw-post-body-paragraph mb mc ix ku b kv kw md me kx ky mf mg kz mh mi mj lb mk ml mm ld mn mo mp lf ij bi translated">粗略地说，分析器经历以下步骤</p><ul class=""><li id="46a7" class="ks kt ix ku b kv mu kx mv kz ng lb nh ld ni lf lg lh li lj bi translated">解析代码并获得代码的抽象语法树表示</li><li id="0ce1" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">从当前和导入的文件中查找联合类型声明</li><li id="362a" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">遍历树，找到使用了一个声明的联合类型的<code class="fe mq mr ms mt b">match</code>函数的地方</li><li id="acbb" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">开始将声明的联合事例与在<code class="fe mq mr ms mt b">match</code>函数中使用的事例进行匹配</li><li id="a45b" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">创建一个错误列表，并从声明中模糊搜索可能的替代项</li><li id="437a" class="ks kt ix ku b kv lk kx ll kz lm lb ln ld lo lf lg lh li lj bi translated">将错误记录到控制台</li></ul><p id="0ebd" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">使用了Babel的两个组件，生成AST的<a class="ae nf" href="https://babeljs.io/docs/en/babel-parser" rel="noopener ugc nofollow" target="_blank">解析器</a>和通过AST寻找<code class="fe mq mr ms mt b">match</code>函数用法的<a class="ae nf" href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#babel-traverse" rel="noopener ugc nofollow" target="_blank">树访问者</a>(又名babel/traverse)。</p><p id="4755" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">解析器接收需要分析的代码，并返回带有标记节点的代码树结构，例如:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6a56" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">零件<code class="fe mq mr ms mt b">Option.Some('value')</code>被转换为</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ab83" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">注意，代码变成了数据，分析器遍历这个JSON树。例如，这是分析器的一个片段，它检测到了在哪里使用了<code class="fe mq mr ms mt b">match</code>函数:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="959c" class="pw-post-body-paragraph mb mc ix ku b kv mu md me kx mv mf mg kz mw mi mj lb mx ml mm ld my mo mp lf ij bi translated">这段代码寻找“调用表达式”,其属性作为对象的成员(成员表达式)被调用，其中属性的名称是“match ”,并具有两个或三个参数，等等。对于程序的其余部分，请参见此处的所有代码。</p><h2 id="d10d" class="lp jv ix bd jw lq lr dn ka ls lt dp ke kz lu lv ki lb lw lx km ld ly lz kq ma bi translated">关于令人敬畏的Javascript生态系统</h2><p id="08e7" class="pw-post-body-paragraph mb mc ix ku b kv kw md me kx ky mf mg kz mh mi mj lb mk ml mm ld mn mo mp lf ij bi translated">尽管我不是Javascript这种语言的最大粉丝，但当谈到生态系统中可用的工具时，没有什么能打败它！构建分析器是一种愉快的体验，在编写、测试和发布作为CLI工具的代码时，摩擦非常小。添加代码覆盖就像在测试脚本前添加<code class="fe mq mr ms mt b">nyc</code>一样简单。不要忘记从VS代码中调试是多么容易。</p><h2 id="fcc2" class="lp jv ix bd jw lq lr dn ka ls lt dp ke kz lu lv ki lb lw lx km ld ly lz kq ma bi translated">结束了</h2><p id="a761" class="pw-post-body-paragraph mb mc ix ku b kv kw md me kx ky mf mg kz mh mi mj lb mk ml mm ld mn mo mp lf ij bi translated">我可能暂时不会构建更多的分析器，但这是一个很好的体验，很高兴当谈到Javascript和生态系统时，它都是可接近的。</p></div></div>    
</body>
</html>