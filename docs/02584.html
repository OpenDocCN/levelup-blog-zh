<html>
<head>
<title>Learning Go: Structs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋:结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-structs-ca4074dff40d?source=collection_archive---------16-----------------------#2020-03-23">https://levelup.gitconnected.com/learning-go-structs-ca4074dff40d?source=collection_archive---------16-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8c332df7e98a25564e909731a64d994e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iA45E9M3BU7jxxB0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@williamdaigneault?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> William Daigneault </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="dcb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构(也称为结构)是一种聚合数据类型，允许您构建包含描述该类型的多个变量(字段)的用户定义类型。一个结构可以被复制到另一个结构，用作函数的参数和自变量，存储在数组中，并像使用内置类型一样使用。</p><h1 id="c923" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建和使用结构</h1><p id="650e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">定义结构的语法模板是:</p><p id="9173" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mh">类型结构名称结构{ <br/>字段列表<br/> } </em></p><p id="1662" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个例子。我们可以使用以下声明将几何点定义为结构:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a269" class="mr lf it mn b gy ms mt l mu mv">type Point struct {<br/>  x, y int<br/>}</span></pre><p id="3a56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我定义了一个<code class="fe mw mx my mn b">Point</code>结构来包含两个<code class="fe mw mx my mn b">int</code>字段，<code class="fe mw mx my mn b">x</code>和<code class="fe mw mx my mn b">y</code>。</p><p id="c1c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦定义了一个结构，就可以像这样声明<code class="fe mw mx my mn b">struct</code>类型的实体:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7883" class="mr lf it mn b gy ms mt l mu mv">var p1 Point</span></pre><p id="8c95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用点运算符访问结构的字段:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="51b5" class="mr lf it mn b gy ms mt l mu mv">p1.x = 1<br/>p1.y = 2<br/>fmt.Printf("x: %d, y: %d\n", p1.x, p1.y)</span></pre><p id="836b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以直接打印结构，而不必像我上面所做的那样访问它的字段:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="730c" class="mr lf it mn b gy ms mt l mu mv">fmt.Println(p1)</span></pre><p id="e2db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建结构的另一种方法是使用结构文本:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2e38" class="mr lf it mn b gy ms mt l mu mv">p1 := Point{1,2}<br/>p2 := Point{2,3}</span></pre><p id="174c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果结构的所有字段都是可比较的，则可以直接比较两个结构对象。例如:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="333a" class="mr lf it mn b gy ms mt l mu mv">type Point struct {<br/>  x, y int<br/>}</span><span id="6afd" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  p1 := Point{1,2}<br/>  p2 := Point{2,3}<br/>  if p1 == p2 {<br/>    fmt.Println("p1 and p2 are equal.")<br/>  } else {<br/>    fmt.Println("p1 and p2 are not equal.")<br/>  }<br/>}</span></pre><p id="6ffa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以将一个结构复制到另一个结构，生成的副本是深度副本，如下面的程序所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2d4d" class="mr lf it mn b gy ms mt l mu mv">type Point struct {<br/>  x, y int<br/>}</span><span id="9593" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  p1 := Point{1,2}<br/>  p2 := p1<br/>  fmt.Println(p1) // {1 2}<br/>  fmt.Println(p2) // {1 2}<br/>  p1.x = 3<br/>  fmt.Println(p1) // {3 2}<br/>  fmt.Println(p2) // {1 2}<br/>}</span></pre><h1 id="d0dc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结构和复合类型字段</h1><p id="324e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">结构可以包含复合数据类型作为字段。下面是一个<code class="fe mw mx my mn b">Student </code>结构，它有一个存储测试成绩的片:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a77b" class="mr lf it mn b gy ms mt l mu mv">type Student struct {<br/>  name string<br/>  major string<br/>  grades []int<br/>}</span><span id="b147" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  var st1 Student<br/>  st1.name = "Jane Doe"<br/>  st1.major = "History"<br/>  st1.grades = append(st1.grades, 81)<br/>  st1.grades = append(st1.grades, 93)<br/>  st1.grades = append(st1.grades, 88)<br/>  fmt.Println(st1)<br/>}</span></pre><p id="17c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以使用struct文本创建一个Student对象，甚至可以使用slice，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8c99" class="mr lf it mn b gy ms mt l mu mv">st1 := Student{"Jane Doe", "History", []int {81, 90, 88}}</span></pre><p id="06a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了拥有像字段这样的复合类型之外，结构还可以拥有其他结构作为其字段的一部分。下面是一个有两个<code class="fe mw mx my mn b">Point </code>结构作为其字段的<code class="fe mw mx my mn b">Line</code>结构的例子:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="cf9b" class="mr lf it mn b gy ms mt l mu mv">type Point struct {<br/>  x, y int<br/>}</span><span id="d41a" class="mr lf it mn b gy mz mt l mu mv">type Line struct {<br/>  p1 Point<br/>  p2 Point<br/>}</span><span id="f571" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  var line1 Line<br/>  line1.p1.x = 3<br/>  line1.p1.y = 4<br/>  line1.p2.x = 5<br/>  line1.p2.y = 8<br/>  fmt.Println(line1)<br/>}</span></pre><h1 id="6e43" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结构和函数</h1><p id="e5df" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">结构可以作为参数传递给函数，也可以是函数的返回值。让我们先看看作为返回值的结构。</p><p id="91a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个函数，它通过接受点的x和y坐标作为参数来生成一个<code class="fe mw mx my mn b">Point</code>:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6199" class="mr lf it mn b gy ms mt l mu mv">type Point struct {<br/>  x, y int<br/>}</span><span id="0bdc" class="mr lf it mn b gy mz mt l mu mv">func makePoint(x, y int) Point {<br/>  var p Point<br/>  p.x = x<br/>  p.y = y<br/>  return p<br/>}</span><span id="c584" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  p1 := makePoint(1,2)<br/>  fmt.Println(p1)<br/>}</span></pre><p id="5594" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构也可以是函数参数。在下面的示例中，<code class="fe mw mx my mn b">computeAvg</code>函数将一个<code class="fe mw mx my mn b">Student</code>结构作为参数，并返回学生的平均测试分数:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6bd9" class="mr lf it mn b gy ms mt l mu mv">type Student struct {<br/>  name string<br/>  major string<br/>  grades []int<br/>}</span><span id="1aac" class="mr lf it mn b gy mz mt l mu mv">func computeAvg(st Student) float64 {<br/>  total := 0<br/>  for _, grade := range st.grades {<br/>    total += grade<br/>  }<br/>  return float64(total) / float64(len(st.grades))<br/>}</span><span id="90be" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  var st1 Student<br/>  st1.name = "Jane Doe"<br/>  st1.major = "History"<br/>  st1.grades = append(st1.grades, 81)<br/>  st1.grades = append(st1.grades, 93)<br/>  st1.grades = append(st1.grades, 88)<br/>  average := computeAvg(st1)<br/>  fmt.Printf("%s's grade average is %.2f.\n", st1.name, average)<br/>}</span></pre><p id="9c50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，为了使程序更高效，指向结构的指针被传递给函数。我们只需要对上面的程序做两个改变。首先，我们需要创建一个指向<code class="fe mw mx my mn b">Student</code>结构的指针，然后我们需要在函数定义中引用该指针。</p><p id="6d07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是新程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="087b" class="mr lf it mn b gy ms mt l mu mv">func computeAvg(st *Student) float64 {<br/>  total := 0<br/>  for _, grade := range (*st).grades {<br/>    total += grade<br/>  }<br/>  return float64(total) / float64(len(st.grades))<br/>}</span><span id="56f7" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  var st1 Student<br/>  st1.name = "Jane Doe"<br/>  st1.major = "History"<br/>  st1.grades = append(st1.grades, 81)<br/>  st1.grades = append(st1.grades, 93)<br/>  st1.grades = append(st1.grades, 88)<br/>  pst1 := &amp;st1<br/>  average := computeAvg(pst1)<br/>  fmt.Printf("%s's grade average is %.2f.\n", st1.name, average)<br/>}</span></pre><p id="c79c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我也可以从一开始就使<code class="fe mw mx my mn b">st1</code>成为一个<code class="fe mw mx my mn b">Student</code>指针变量，而不是从<code class="fe mw mx my mn b">st1</code>创建一个指针。</p><p id="d294" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意函数定义中的<code class="fe mw mx my mn b"> range for</code>。在使用点运算符获取<code class="fe mw mx my mn b">grades</code>字段之前，必须对<code class="fe mw mx my mn b">Student</code>结构取消引用，这是通过将取消引用放在括号中来实现的，以便在访问该字段之前执行该操作。如果你不这样做，你会引起恐慌。</p><h1 id="0429" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么使用结构</h1><p id="84de" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用结构的最明显原因是当数据类型包含多个字段时。尽管如此，有三个原因可以解释为什么使用结构会帮助你的代码。我从史蒂夫·麦康奈尔(Steve McConnell)的优秀著作《代码完成(T7)》中汲取了这些原因。</p><p id="3476" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个原因是结构提供了数据关系的清晰性。当您跟踪几何点时，有一个具有x和y域的实体是有意义的，而不是单独的x和y点，它们不能相互关联。</p><p id="078e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个原因是结构简化了对数据块的操作。如果您的程序涉及员工数据，将所有员工数据保存在一个实体中比每条数据都有单独的变量更有意义。</p><p id="cc88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个原因是结构通过使函数参数列表更短来简化它们。如果您将有关学生的数据(从本文前面定义的学生结构)传递给一个函数，那么将数据作为一个实体而不是作为单独的数据传递要简单得多。使用结构时，参数列表可以从三个或更多个参数减少到一个。</p><p id="0679" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于所有这些原因，当您在解决编程问题时可以将数据包装到结构中时，您应该考虑这样做。</p><p id="3bec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读，并请通过电子邮件发送您的评论和建议。</p></div></div>    
</body>
</html>