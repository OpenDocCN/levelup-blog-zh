<html>
<head>
<title>Efficient Bulk Updates with Django Rest Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Django Rest框架进行高效的批量更新</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/really-fast-bulk-updates-with-django-rest-framework-43594b18bd75?source=collection_archive---------0-----------------------#2020-06-03">https://levelup.gitconnected.com/really-fast-bulk-updates-with-django-rest-framework-43594b18bd75?source=collection_archive---------0-----------------------#2020-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="40d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用ListSerializer和bulk_update通过Django Rest框架构建高效的PUT API端点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f1be91e5aa8fad9d395c49c5b609c585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zb-ewMc4-OkEaiRTvNuRoA.png"/></div></div></figure><p id="4464" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一般的rest框架端点通常被设计成一次修改一个对象。然而，当您需要修改数千个对象时，您会经常发现这可能会成为一个巨大的性能瓶颈。在这种情况下，与其对您的端点进行成千上万次调用，不如进行一次批量操作的调用。本教程向您展示了如何为PUT API端点创建高效的批量更新。</p><p id="b20b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae ln" href="https://medium.com/p/f73da6af7ddc/edit" rel="noopener"> <strong class="kt ir">第1部分:使用Django Rest框架高效批量创建</strong> </a> <strong class="kt ir"> </strong>中，我们回顾了如何使用Django Rest框架优化<strong class="kt ir"> POST </strong> API。在本文中，我将向您展示如何通过bulk_update方法使用ListSerializers来提高您的<strong class="kt ir"> PUT </strong> API调用的性能。可以在GitHub <a class="ae ln" href="https://github.com/cdknorow/django_bulk_tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">这里</strong> </a>找到一个包含代码和单元测试的完整的Django应用程序。</p><h2 id="40db" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">目标</h2><p id="2e0e" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">学完本教程后，您应该能够</p><ol class=""><li id="2de8" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">使用标准Django Rest框架工作流实现一个PUT API来更新数据库模型。</li><li id="b4e0" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">使用<strong class="kt ir"> ListSerializer </strong>修改API以执行批量更新。</li><li id="89e9" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">剖析并优化ListSerializer，通过使用<strong class="kt ir"> bulk_update </strong>并减少对数据库的调用次数，实现<strong class="kt ir">10倍的性能提升</strong>。</li></ol><p id="e972" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本教程中的toy应用程序由一个可以有许多任务的项目组成。每次添加或更新新任务时，我们还希望更新项目的上次修改日期。让我们开始吧。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="d8c4" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak"> Django API概述</strong></h2><p id="0fab" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">您可能会觉得Django Rest框架的高度抽象使得理解正在发生的事情变得很困难。我也发现它们在开始时有一个非常陡峭的学习曲线，但是一旦你熟悉了它的结构，使用它们来管理一个有许多API的大型项目可以大大提高生产率。您还会发现，如果团队中的每个人都遵循相同的模式，协作会变得更加容易。通常，创建Django Rest框架API有5个主要部分。它们如下:</p><ol class=""><li id="a7d3" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated"><strong class="kt ir">模型</strong>管理数据库表和python之间的关系。</li><li id="ac9c" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated"><strong class="kt ir">串行化器</strong>验证并串行化输入和输出数据</li><li id="d29f" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated"><strong class="kt ir"> Querysets </strong>哪些查询将数据库查询的结果构造、查询和存储为模型实例。</li><li id="74e5" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated"><strong class="kt ir">视图</strong>是为每个端点包装模型、序列化器和查询集的类。</li><li id="3d98" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated"><strong class="kt ir">URL</strong>指定何时调用<strong class="kt ir">视图。</strong></li></ol><p id="078c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在将检查这些代码以创建我们的REST API。</p><h2 id="56db" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">模型</h2><p id="e30e" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">Django ORM使用模型来管理与后端数据库的交互。对于本教程，我们将创建两个模型，一个项目模型具有与之相关联的任务模型。模型在<a class="ae ln" href="https://github.com/cdknorow/django_bulk_tutorial/blob/master/datamanager/models.py" rel="noopener ugc nofollow" target="_blank"> models.py </a>中定义为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="06e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，每当更新一个新任务时，业务逻辑要求应该更新最后修改的项目。为了处理业务逻辑，我们在任务上使用带有<strong class="kt ir"> post_save </strong>和<strong class="kt ir"> post_delete </strong>的信号API。这样，在调用保存后，还将调用信号来更新项目<strong class="kt ir"> last_modified </strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="e922" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">视图</h2><p id="8f9c" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">通用视图类是来自Django Rest框架的抽象方法，用于实现HTML方法POST/PUT/GET/DELETE。对于更新端点，我们将使用通用的<strong class="kt ir"> UpdateAPIView </strong>，它提供了一个PUT方法处理程序。为了更好地理解Django更新视图的基本控制流，我整理了下面的流程图作为参考。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/8553aa373438b07ee2b10048461e5089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRKVufKXHx9sB3YPeXZa7A.png"/></div></div></figure><p id="e242" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于PUT API，我们使用<a class="ae ln" href="https://www.django-rest-framework.org/api-guide/generic-views/#updateapiview" rel="noopener ugc nofollow" target="_blank"> UpdateAPIView </a>在任务模型上执行更新。为此，我们需要定义调用该函数的API的<strong class="kt ir">序列化器</strong>、<strong class="kt ir"> get_queryset </strong>方法和<strong class="kt ir"> URL </strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="798b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你不熟悉Django Rest框架，你可能会注意到上面的TaskUpdateView代码中没有很多代码。对于基本API来说，完成这项工作的几乎所有管道都被完全抽象掉了。为了优化这个API，我们最终需要覆盖许多继承的方法。关于视图的更深入的文档，查看官方教程<a class="ae ln" href="https://www.django-rest-framework.org/tutorial/3-class-based-views/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="d37c" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">查询集</h2><p id="cf76" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated"><a class="ae ln" href="https://docs.djangoproject.com/en/3.0/ref/models/querysets/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> queryset </strong> </a>是Django ORM的一部分，它促进了模型和数据库之间的交互。Querysets是强大的抽象，允许您以编程方式构建复杂的数据库查询。在我们的<strong class="kt ir"> get_queryset </strong>函数中，我们在任务对象上使用了一个过滤器，只返回具有用户指定项目作为外键和任务id的任务。queryset包含一个实例列表，我们可以更新这些实例，然后将用户传入的数据保存回数据库。</p><h2 id="f954" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">序列化程序</h2><p id="c2f6" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">序列化程序负责获取用户输入，验证它，并将其转换为数据库可消费的对象。它们还处理将数据库中的对象转换成可以返回给用户的东西。此外，序列化程序指定哪些字段是必需的，以及它们具有哪些属性。为了更好地演示序列化程序的基本控制流，我创建了下图以供参考。要深入了解序列化器，请点击这里查看官方教程<a class="ae ln" href="https://www.django-rest-framework.org/tutorial/1-serialization/" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/5f73c8f9b32ba2762e08120bf5150827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ds0x3L7AAAzXDF5pVEqf4w.png"/></div></div></figure><p id="8edf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这个项目，我们创建了TaskSerializer，它可以更新一个对象的名称<strong class="kt ir">和描述<strong class="kt ir"/>。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7ee9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为项目的<strong class="kt ir"> id </strong>是在URL中指定的，所以我们使用带有CurrentProjectDefault类的隐藏字段来指定如何从请求中提取<strong class="kt ir">项目id </strong>并从数据库中检索项目对象。<strong class="kt ir"> CurrentProjectDefault </strong>类定义如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bb4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了所有这些东西，我们就完成了API的基本实现。让我们继续分析性能。为此，我们将使用<a class="ae ln" href="https://docs.pytest.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> pytest </strong> </a>来创建一个单元测试，其中我们通过调用API一次来更新10，000个任务对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8af1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了获得测试的运行时间，我们将在调用pytest时设置duration标志。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="684f" class="lo lp iq nl b gy np nq l nr ns">&gt;&gt; py.test --durations=1<br/>    <br/>==================<br/>101.21s call test_update_task</span></pre><p id="c9b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到它是如此缓慢！执行10，000次更新大约需要100秒。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="755c" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">列表序列化程序</h2><p id="0036" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">让我们看看如何提高代码的性能。我们要做的第一个优化是切换到使用一个<strong class="kt ir"> ListSerializer </strong>。列表序列化程序将允许您提交一个请求进行多次更新。首先，我们将创建<strong class="kt ir"> UpdateListSerializer </strong>类，它扩展了<strong class="kt ir"> ListSerializer </strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ad40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过计算<strong class="kt ir"> instance_hash </strong>，我们避免了需要索引到实例中，这是非常低效的。然后，我们将修改TaskSerializer的<strong class="kt ir"> Meta </strong>属性，以使用新的list serializer类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d676" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要修改我们的url，现在它将只把<strong class="kt ir"> project_id </strong>作为路径的一部分，而<strong class="kt ir"> task_id </strong>将作为发送到PUT API的数据对象的一部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5e6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将创建一个新的视图；<strong class="kt ir">任务更新列表视图。</strong>这里我们将覆盖基本的<strong class="kt ir"> get_serializer </strong>方法来检查输入数据是否是列表。当我们检测到用户已经传递了一个列表的输入时，我们将设置属性<strong class="kt ir"> kwargs["many"] = True </strong>。这告诉序列化程序在调用每个任务的单独更新之前应该使用<strong class="kt ir"> list_serializer_class </strong>。</p><p id="357b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还覆盖了视图的基本<strong class="kt ir">更新</strong>方法。现在，它将在调用修改后的<strong class="kt ir"> get_queryset </strong>方法之前对<strong class="kt ir">id</strong>执行简单的验证，该方法将<strong class="kt ir">id</strong>作为输入。queryset将返回用户请求更新的所有任务对象的实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="04e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了所有这些优化，我们现在使用ListSerializer对任务模型进行批量更新。我们将创建另一个单元测试来分析性能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a957" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们继续检查这一变化的性能。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="bc16" class="lo lp iq nl b gy np nq l nr ns">&gt;&gt; py.test --durations=2<br/>    <br/>==================<br/>101.21s call test_update_task<br/>55.98s call test_update_list_serializer</span></pre><p id="6aa0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，通过添加ListSerializer方法，我们可以看到2倍的性能提升。尽管如此，10，000次更新用55秒还是很慢。进一步优化该API性能的关键是减少对数据库的调用次数。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="a049" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">巩固逻辑</h2><p id="6231" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">目前，我们的序列化程序正在调用CurrentProjectDefault来获取与它正在创建的每个任务实例对象相关联的项目。相反，我们将修改视图的put函数来拉取项目，并将其插入到<strong class="kt ir"> request.data </strong>对象中。这样，我们只需要点击一次数据库就可以获得所有任务的项目。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="df2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要用自定义字段替换序列化程序中的<strong class="kt ir"> CurrentProjectDefault </strong>字段。我们创建一个名为<strong class="kt ir"> ModelObjectidField </strong>的自定义字段，它只返回传递给它的数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="1891" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">批量更新</h2><p id="c173" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">接下来，我们将创建一个<strong class="kt ir">BulkUpdateListSerializer</strong>，它将使用Django 2.2中引入的Django的<strong class="kt ir"> bulk_update </strong>。该函数允许您通过传递要更新的实例列表来在数据库中执行批量更新。以下代码描述了<strong class="kt ir">BulkUpdateListSerializer</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="08bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要修改序列化程序，使它不再保存更新方法，而只返回新的实例。然后，在我们更新了所有实例的值之后，我们的BulkUpdateListSerializer将调用<strong class="kt ir"> bulk_update </strong>方法，该方法将发出一个数据库调用来执行更新。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="5977" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">至表示法</h2><p id="8798" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated"><strong class="kt ir"> to_representation </strong>函数是序列化程序的一部分，它处理如何将实例转换成可以返回给用户的序列化对象。ListSerializer的默认<strong class="kt ir"> to_representation </strong>方法在获取要返回的<strong class="kt ir"> instance.project id </strong>值时效率非常低。在下面的to_representation代码中，我们利用了所有项目id都相同的事实，因此我们只需要获取该属性一次。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="a425" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">我们的信号呢？</h2><p id="1bb4" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">进行批量更新时，不再触发模型的信号。这实际上是一件好事，因为<strong class="kt ir">信号虽然方便，但效率却低得令人难以置信</strong>。相反，我们创建一个<strong class="kt ir">update _ Project _ last _ modified</strong>函数，它在执行更新之后更新项目的最后修改日期。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f804" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要注意的一点是，<strong class="kt ir"> bulk_update </strong>函数不会修改数据库中的<strong class="kt ir"> auto_add_now </strong>字段。为了克服这个问题，我们为所有实例显式地设置了<strong class="kt ir"> last_modified </strong>字段，以便更新可以执行它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8d9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，让我们使用<strong class="kt ir"> bulk_update </strong>测试新函数的性能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="dae0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果是:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3b7c" class="lo lp iq nl b gy np nq l nr ns">&gt;&gt; py.test --durations=3<br/>    <br/>==================<br/>101.21s call test_update_task<br/>55.98s call test_update_list_serializer<br/>12.06s call test_bulk_update_list_serializer</span></pre><p id="4b84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，现在测试只需20秒左右。这大约是10倍的速度提升。 nt没有太多额外的代码复杂性。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="d1ec" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">摘要</h2><p id="ba17" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">至此，我们已经了解了如何使用Django 2.2中引入的<strong class="kt ir"> ListSerializer </strong>和<strong class="kt ir"> bulk_update </strong>功能来提高Django应用的性能。这两种方法，再加上仔细注意<strong class="kt ir">尽量减少对数据库</strong>的调用次数，可以让你在不做很多额外工作的情况下获得超过<strong class="kt ir">10倍的性能提升。</strong></p><p id="2f58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，包含所有代码和单元测试的完整Django项目可以在GitHub的<strong class="kt ir">d</strong><a class="ae ln" href="https://github.com/cdknorow/django_bulk_tutorial" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">ango _ Bulk _ tutorial</strong></a>资源库和之前的文章<a class="ae ln" href="https://medium.com/me/stats/post/f73da6af7ddc" rel="noopener"> <strong class="kt ir">第1部分:使用Django Rest框架</strong> </a>高效批量创建中找到。我希望你喜欢这篇文章，一定要关注我的更多关于Django、Python、DevOps、机器学习和Tinyml的文章。你有喜欢用的优化Django的小技巧吗？留下评论让我现在或提供对文章的反馈。</p></div></div>    
</body>
</html>