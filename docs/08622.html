<html>
<head>
<title>How to Build a Simple CLI Using TypeScript and Factory Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用TypeScript和工厂设计模式构建简单的CLI</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-simple-cli-using-typescript-and-factory-design-pattern-d9c335778f14?source=collection_archive---------4-----------------------#2021-05-18">https://levelup.gitconnected.com/how-to-build-a-simple-cli-using-typescript-and-factory-design-pattern-d9c335778f14?source=collection_archive---------4-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bbd8e694efd1a28f1e1855afb6c0f975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQTBn-uvcHJ8pYHPAodbkQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">罗伯特·柯林斯在<a class="ae kf" href="https://unsplash.com/s/photos/happy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1e4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用高级过程开发复杂的CLI应用程序并利用其他包和库/工具之前，首先，我们需要理解制作CLI应用程序的核心概念。</p><p id="d1bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">阅读完本文后，您将理解制作CLI、工厂设计模式的概念，并将能够使用任何语言创建CLI应用程序。</p><p id="31a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看到如何创建一个简单的TypeScript CLI，它可以使用Node.js 运行<a class="ae kf" href="https://nodejs.dev/learn/nodejs-with-typescript" rel="noopener ugc nofollow" target="_blank">。😃</a></p><h1 id="978b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">应用概述</h1><p id="adf5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在开始实现之前，我们先来看看如何构建我们的应用程序。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/ddba2640e9633e1576b441313d76c9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oKpWXyW8GCxh1TyxXUrYHQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图1:这个CLI的类图</figcaption></figure><p id="4c09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在主应用程序中，我们将使用来自命令工厂的命令名来获取每个命令。这就是所谓的工厂设计模式。</p><h2 id="58c3" class="mm lf it bd lg mn mo dn lk mp mq dp lo kr mr ms ls kv mt mu lw kz mv mw ma mx bi translated">工厂设计模式</h2><p id="d7ad" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这种模式下，我们将有一个工厂。那个工厂会给我们不同类型的对象，它们都属于一个共同的类型。我们将通过提供一些唯一的标识符从工厂获得这些不同类型的对象。通常，这些唯一标识符是字符串。</p><p id="6378" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，作为客户，我们不知道这些对象是如何在工厂内部构造的。我们将按照承诺从工厂获得这些可用的对象，它们可以在应用程序中使用。</p><p id="9b16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为工厂可以根据我们的请求构造并给我们所有不同类型的对象，所以我们通过公共类型指向这些对象。</p><p id="720f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式提供了创建对象的最佳方式之一:</p><ol class=""><li id="bcd2" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated">客户端不知道对象创建逻辑。</li><li id="5c50" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">我们不必在主应用程序中创建对象。</li></ol></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="784f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的CLI中，我们将通过向命令工厂提供命令名来调用每个命令。</p><p id="ff5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们开始创建CLI。</p><h1 id="fac3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1.初始设置</h1><p id="0c0a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">转到应用程序目录，使用<code class="fe nt nu nv nw b">npm init --y</code>创建一个新的NPM包。</p><p id="020c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">典型的CLI应用程序有一个或多个可执行文件，当我们键入特定于应用程序的命令时，这些文件就会被执行。</p><p id="8f13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的应用程序中，我们将有一个可执行文件，当我们键入命令<code class="fe nt nu nv nw b">we</code>时，该文件将被执行。</p><p id="cf3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如何进入<code class="fe nt nu nv nw b">we</code>执行可执行文件？我们将命令<code class="fe nt nu nv nw b">we</code>映射到可执行文件。所以每当我们输入命令<code class="fe nt nu nv nw b">we</code>时，就会执行映射的可执行文件。这就是我们的想法。</p><p id="a848" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">命令名与可执行文件的映射是通过在package.json中指定<code class="fe nt nu nv nw b">bin</code>字段来实现的。</p><p id="4580" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们创建应用程序的入口点(它实际上获取用户参数)。创建一个目录<code class="fe nt nu nv nw b">bin</code>并创建一个名为<code class="fe nt nu nv nw b">we</code>的文件。将以下属性添加到<code class="fe nt nu nv nw b">package.json</code>文件中。</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="5ffa" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu">"bin"</strong>: {<br/>  "we": "./bin/we"<br/>},<br/><strong class="nw iu">"main"</strong>: "./bin/we"</span></pre><p id="90f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，<code class="fe nt nu nv nw b">“we”: “./bin/we”</code>将命令<code class="fe nt nu nv nw b">we</code>映射到<code class="fe nt nu nv nw b">./bin/we</code>。在全局安装时，npm会将<code class="fe nt nu nv nw b">./bin/we</code>符号链接到<code class="fe nt nu nv nw b">prefix/bin</code>中，并将<code class="fe nt nu nv nw b">./node_modules/.bin/</code>符号链接到本地安装。</p><p id="1ab6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字段<code class="fe nt nu nv nw b">“main”</code>告诉<code class="fe nt nu nv nw b">“./bin/we”</code>是我们程序的主要入口点。</p><p id="c0ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nt nu nv nw b">we</code>是命令，我们用来执行可执行文件<code class="fe nt nu nv nw b">“./bin/we”</code>。</p><p id="aa47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使<code class="fe nt nu nv nw b">./bin/we</code>成为可执行文件，在文件开头添加以下行:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="dab9" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu">#!/usr/bin/env node</strong></span></pre><p id="cf1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面一行告诉系统这个文件是一个节点可执行文件。现在我们的可执行文件准备好了。</p><p id="99a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能用Node.js直接运行TypeScript文件，我们需要把TypeScript文件向下编译成JavaScript文件。这可以使用TypeScript配置文件轻松配置。</p><p id="c5d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用<code class="fe nt nu nv nw b">tsc --init</code>创建一个TypeScript配置文件。这里，我们需要指定包含类型脚本文件的输入文件的根目录:<code class="fe nt nu nv nw b">“rootDir”: “./src”</code>和包含编译后的JavaScript文件的输出目录:<code class="fe nt nu nv nw b">“outDir”: “./lib”</code>。您可以根据需要添加/删除<code class="fe nt nu nv nw b">tsconfig.json</code>中的其他属性。</p><p id="f77a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据TypeScript配置，<code class="fe nt nu nv nw b">src</code>目录下的TypeScript文件将作为JavaScript文件编译到<code class="fe nt nu nv nw b">lib</code>目录下。</p><p id="8565" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的入口文件<code class="fe nt nu nv nw b">./bin/we</code>应该执行<code class="fe nt nu nv nw b">lib</code>目录中编译好的JavaScript文件。指定在<code class="fe nt nu nv nw b">we</code>文件中添加以下行:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="cc43" class="mm lf it nw b gy ob oc l od oe"><em class="of">#!/usr/bin/env node<br/></em><strong class="nw iu"><em class="of">// require the compiled js files from ts<br/></em>require("../lib/we.js");</strong></span></pre><h1 id="1616" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2.基本CLI</h1><p id="489a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们安装依赖项:</p><ol class=""><li id="720a" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated">节点的类型定义:<code class="fe nt nu nv nw b">npm i — save-dev @types/node</code></li><li id="8997" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">项目中的打字稿:<code class="fe nt nu nv nw b">npm install typescript — save-dev</code></li></ol><p id="d3f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe nt nu nv nw b">npm link</code>创建一个全局符号链接。</p><p id="7268" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在根目录下创建一个新目录<code class="fe nt nu nv nw b">src</code>。这个<code class="fe nt nu nv nw b">src</code>目录将包含我们所有的类型脚本文件。</p><p id="710d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe nt nu nv nw b">src</code>里面创造<code class="fe nt nu nv nw b">we.ts</code>。</p><p id="815b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将通过向<code class="fe nt nu nv nw b">we.ts</code>添加以下代码来获取Node.js进程启动时的所有CLI参数:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="c824" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu">const args = process.argv;</strong><br/><em class="of">// log all CLI arguments<br/></em>console.log(args);</span></pre><p id="6aa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nt nu nv nw b"><a class="ae kf" href="https://nodejs.org/docs/latest/api/process.html#process_process_argv" rel="noopener ugc nofollow" target="_blank">process.argv</a></code>返回包含所有CLI参数的数组。</p><p id="fd48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了检查这一点，我们应该将TypeScript编译成JavaScript，这样我们的可执行文件就可以执行<code class="fe nt nu nv nw b">lib</code>目录中的JavaScript代码。</p><p id="2961" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们定义一个脚本，用于<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">编译<code class="fe nt nu nv nw b">package.json</code>中的项目</a>:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="53f6" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu">"build":  "tsc"</strong></span></pre><p id="b741" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们已经配置了<code class="fe nt nu nv nw b">tsconfig.json</code>，所以我们不需要提供像<code class="fe nt nu nv nw b">tsc src/*.ts</code>这样的命令。有关更多详细信息，请查看此<a class="ae kf" href="https://stackoverflow.com/questions/50738687/typescript-ts-not-working" rel="noopener ugc nofollow" target="_blank">堆栈溢出讨论</a>。</p><p id="119d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们使用<code class="fe nt nu nv nw b">npm run build</code>来编译这个项目。它将在<code class="fe nt nu nv nw b">lib</code>目录中创建编译后的JavaScript文件，如<code class="fe nt nu nv nw b">tsconfig</code>文件中所指定的。</p><p id="b3d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输入<code class="fe nt nu nv nw b">we</code>检查CLI参数:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d5b07f5e1e59ff07292e8c541fcd1c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*0MrR0ZacJQoXzftyfEmulw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图2: CLI参数</figcaption></figure><p id="bd51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回两个参数。首先是启动Node.js进程的可执行文件的绝对路径名。第二个是正在执行的JavaScript文件的路径。</p><p id="7f25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不需要这些争论。我们只需要用户输入一个参数。</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="1cad" class="mm lf it nw b gy ob oc l od oe">console.log(args.slice(2));</span></pre><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/60fea6b9098832ddbfc7ffb8017747f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*1WUhgzzHBXJpunFKg3DvXg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图3:用户输入的关键字</figcaption></figure><p id="25a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们能够从CLI获取用户输入。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="a464" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如类图中所指定的，我们的应用程序将有三个主要命令:<code class="fe nt nu nv nw b">we hi</code>、<code class="fe nt nu nv nw b">we status</code>和<code class="fe nt nu nv nw b">we help</code>。</p><p id="c6ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果用户只是输入<code class="fe nt nu nv nw b">we</code>，我们将向他显示一个很好的帮助指南。</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="de93" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu"><em class="of">// the help guide</em></strong><em class="of"><br/></em>const helpGuide = function () {<br/> const helpText = `<br/>   we is a friendly CLI!</span><span id="fb6b" class="mm lf it nw b gy oi oc l od oe">   usage:<br/>    we &lt;command&gt;<br/>    commands can be:<br/>    hi:       used to welcome to the user<br/>    help:     used to print the usage guide<br/> `;<br/> console.log(helpText);<br/>};</span><span id="8b54" class="mm lf it nw b gy oi oc l od oe"><strong class="nw iu"><em class="of">// if user doesn't enter any words (just types 'we')</em></strong><em class="of"><br/></em>if (userArgs.length == 0) {<br/> helpGuide();<br/>}</span></pre><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6aa5bf50419b8a859bbd124731fd33a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*I9Z-3gGSO8GdYffAxg6mOg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图4:帮助指南的输出</figcaption></figure><p id="e6da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，我们会处理的。</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="316b" class="mm lf it nw b gy ob oc l od oe">else {<br/>  console.log('call the command factory and get appropriate command');<br/>}</span></pre><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/0689f08c1d230cfa691babfb2b2a4b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfo3Jm_0U0DyZMFpMh-HGw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图5:处理else部分</figcaption></figure><p id="ea06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们的应用程序可以调用命令工厂了😃</p><h1 id="1c14" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.构建命令工厂和命令</h1><p id="8b5d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们在<code class="fe nt nu nv nw b">src</code>文件夹中创建<code class="fe nt nu nv nw b">commands</code>目录。这个目录将包含与我们的应用程序相关的所有命令。</p><p id="0e42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个通用的命令接口<code class="fe nt nu nv nw b">Command.ts</code>:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="623e" class="mm lf it nw b gy ob oc l od oe">export interface Command { run(): void; }</span></pre><p id="df47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建具体的命令。</p><p id="4a57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nt nu nv nw b">HelpCommand.ts</code>:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="ffa4" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu">export class HelpCommand implements Command </strong>{<br/>  run(): void {<br/>   const helpText = `<br/>    we is a friendly CLI!</span><span id="d446" class="mm lf it nw b gy oi oc l od oe">    usage:<br/>     we &lt;command&gt;<br/>     commands can be:<br/>     hi:       used to welcome to the user<br/>     help:     used to print the usage guide<br/>   `;<br/>   console.log(helpText);<br/>  }<br/>}</span></pre><p id="0892" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nt nu nv nw b">HiCommand.ts</code>:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="7f19" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu">export class HiCommand implements Command </strong>{<br/>  run(): void {<br/>   console.log(`Welcome to we CLI!`);<br/>  }<br/>}</span></pre><p id="97ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nt nu nv nw b">StatusCommand.ts</code>:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="21ee" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu">export class StatusCommand implements Command </strong>{<br/>  run(): void {<br/>   console.log(`Checkout the status`);<br/>  }<br/>}</span></pre><p id="7bcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nt nu nv nw b">ErrorCommand.ts</code>:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="9ebb" class="mm lf it nw b gy ob oc l od oe"><strong class="nw iu">export class ErrorCommand implements Command </strong>{<br/>  run(): void {<br/>   console.log(`Sorry! No keywords found. Please type 'Help' to see what I can help you with :)`);<br/>  }<br/>}</span></pre><p id="0dae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在<code class="fe nt nu nv nw b">src</code>目录中创建命令工厂:</p><p id="1d11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nt nu nv nw b">CommandFactory.ts</code>:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="7636" class="mm lf it nw b gy ob oc l od oe">export class CommandFactory {<br/>  getCommand(commandName: string): Command {<br/>   switch(commandName) {<br/>    <strong class="nw iu">case "hi":</strong><br/>     return new HiCommand();<br/>    <strong class="nw iu">case "status":</strong><br/>     return new StatusCommand();<br/>    <strong class="nw iu">case "help":</strong><br/>     return new HelpCommand();<br/>    <strong class="nw iu">default:</strong><br/>     return new ErrorCommand();<br/>   }<br/>  }<br/>}</span></pre><p id="eec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的司令部和司令部工厂已经准备好了。</p><p id="ea47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从<code class="fe nt nu nv nw b">we.ts</code>打电话给我们的指挥工厂:</p><pre class="mi mj mk ml gt nx nw ny nz aw oa bi"><span id="e555" class="mm lf it nw b gy ob oc l od oe">else {  <br/> <strong class="nw iu">// call the command factory and get appropriate command</strong><br/> const factoryObject = new CommandFactory();<br/> const commandObject = factoryObject.getCommand(userArgs[0]);<br/> <strong class="nw iu">commandObject.run();</strong><br/>}</span></pre><p id="f274" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，一切都准备好了。让我们构建项目并测试命令！</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/d2a40bf2482be5978fc9ef3061f10da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Unioz-4-KMypICQnBsguQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图6:构建并测试命令</figcaption></figure><p id="c1a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！我们有一个使用TypeScript实现的完整的工作CLI！😄现在，我们可以根据自己的意愿进一步扩展这个CLI应用程序。</p><p id="97a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" href="https://github.com/ThanoshanMV/we" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看这个CLI应用程序的源代码。</p><h1 id="6d9c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="00ea" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">感谢您的阅读！希望这篇文章对你有帮助。</p><p id="a299" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我感谢Shalitha Suranga 对我的帮助！🙌</p><p id="0567" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">快乐编码❤️ </strong></p></div></div>    
</body>
</html>