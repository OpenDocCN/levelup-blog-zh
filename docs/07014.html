<html>
<head>
<title>Infinite Scroll in React with GraphQL Pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的无限滚动与GraphQL分页</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/infinite-scroll-in-react-with-graphql-pagination-40bfc2294430?source=collection_archive---------5-----------------------#2021-01-19">https://levelup.gitconnected.com/infinite-scroll-in-react-with-graphql-pagination-40bfc2294430?source=collection_archive---------5-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9bad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建React前端和我们自己的GraphQL服务器的分步指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f1913998fbfe249ea7fda16c8d493bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K84uugVJpyV_Cr09jBTmZQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们今天将创造什么！</figcaption></figure><blockquote class="ky kz la"><p id="6f3f" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">注:所有文件(服务器和前端)都可以在<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-graphql-pagination" rel="noopener ugc nofollow" target="_blank"> GitLab </a>找到。</p></blockquote><h2 id="4cca" class="lz ma it bd mb mc md dn me mf mg dp mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">介绍</h2><p id="e9a3" class="pw-post-body-paragraph lb lc it le b lf mv ju lh li mw jx lk mi mx ln lo mm my lr ls mq mz lv lw lx im bi translated">在本文中，我们将:</p><ul class=""><li id="9ca5" class="na nb it le b lf lg li lj mi nc mm nd mq ne lx nf ng nh ni bi translated">创建我们自己的带有分页的定制GraphQL服务器</li><li id="995f" class="na nb it le b lf nj li nk mi nl mm nm mq nn lx nf ng nh ni bi translated">用一个<strong class="le iu">无限滚动组件</strong>创建一个React前端</li></ul><p id="7fee" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">我在React中看过几篇关于无限滚动的文章，<strong class="le iu">，但是很少有人深入细节</strong>，也没有解释如何创建GraphQL服务器(<em class="ld">他们大多数使用现有的服务器，比如GitHub GraphQL API </em>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8d8819b2e7763e1be1b7253c02df2c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/1*VgPxW6mT3bIFGTFJCqu9Uw.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">动画:无限滚动运行中(带有<strong class="bd mb">人工网络延迟</strong>)。</figcaption></figure><p id="458b" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">让我们深入研究一下。我们从后端开始，然后在下半部分继续讨论前端。</p><h1 id="88fa" class="np ma it bd mb nq nr ns me nt nu nv mh jz nw ka ml kc nx kd mp kf ny kg mt nz bi translated">创建GraphQL服务器</h1><p id="ed5e" class="pw-post-body-paragraph lb lc it le b lf mv ju lh li mw jx lk mi mx ln lo mm my lr ls mq mz lv lw lx im bi translated">我们将创建一个<code class="fe oa ob oc od b">apollo-server-express</code> GraphQL服务器，并用以下四个文件对其进行配置:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/44f49c1230ba22966e12770af32d008f.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*vuJHr1sY6iHKCFXwKeV8xA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们的后端文件。</figcaption></figure><p id="7b11" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">这个文件包含了我们的服务器将要返回的数据。我创建了一些虚拟数据(100个街道名称)。前几行如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/94c9f160d637ebb729e1c022a8d5ff33.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*hNDKn2F7tH__8wfoF-K2Nw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们的JSON包含100个街道名称。</figcaption></figure><p id="2bba" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">每个条目都有一个索引、一个名称和一个<em class="ld">散列</em>。哈希是通过将索引和名称连接成一个字符串形成的，然后我们对这个字符串进行base64编码。稍后，我们将把这些散列称为<strong class="le iu">游标</strong>。记住这一点。</p><p id="23e7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">该文件将引导我们的Apollo (GraphQL)服务器。配置非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="b3c3" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">第六行最有趣。我们必须将<code class="fe oa ob oc od b">typeDefs</code>(我们的GraphQL模式)和<code class="fe oa ob oc od b">resolvers</code>传递给ApolloServer构造函数。我们接下来会看那些文件。</p><blockquote class="ky kz la"><p id="7218" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">注意:我们用<a class="ae ly" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank"><strong class="le iu">nodemon</strong></a>(<em class="it">每周下载超过300万次)启动我们的服务器！这是一个工具，当检测到文件改变时，它会自动重启我们的服务器。这在开发过程中非常实用。<br/>启动我们服务器的完整命令:</em></p></blockquote><pre class="kj kk kl km gt oi od oj ok aw ol bi"><span id="86f0" class="lz ma it od b gy om on l oo op">nodemon -e js,graphql,json --exec babel-node server.js</span></pre><p id="cb94" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">参见库中的脚本<code class="fe oa ob oc od b">graphql:start</code> (inside package.json) <a class="ae ly" href="https://gitlab.com/gvanderput/gerard-graphql-pagination/-/blob/master/package.json" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3af4" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated"><strong class="le iu"> schema.graphql </strong> <br/>在我们看这个文件中的schema之前，稍微讲一下用GraphQL 分页的<strong class="le iu">。有几种方法可以创建支持分页的模式。但是正如GraphQL开发者(<em class="ld">脸书和开源社区</em>)所说:</strong></p><blockquote class="oq"><p id="0042" class="or os it bd ot ou ov ow ox oy oz lx dk translated">总的来说，我们发现基于光标的分页是最强大的。</p></blockquote><p id="67ef" class="pw-post-body-paragraph lb lc it le b lf pa ju lh li pb jx lk mi pc ln lo mm pd lr ls mq pe lv lw lx im bi translated">让我们不要固执，继续使用<strong class="le iu">基于光标的分页</strong>。这本身也可以通过多种方式实现。一个流行的规范是<em class="ld"> GraphQL游标连接规范</em>，由Relay提供。我们会用这个。脸书是提供该规范的<strong class="le iu"> Relay </strong>开源项目的主要贡献者。Relay是React的一个GraphQL客户端，由Facebook.com使用。</p><p id="15af" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">如果你已经研究过这个主题，你可能已经读过关于<strong class="le iu">节点、边和光标</strong>的内容。这些术语也出现在我们的模式中，该模式部分实现了中继规范。让我们打开它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="faa7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">如果我们对我们的服务器运行一个查询，并请求完整模式格式的数据，则响应如下所示:</p><blockquote class="ky kz la"><p id="df49" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">注意，我们提供了参数，或者如GraphQL世界中所说的“变量”，只返回<strong class="le iu">的前两条记录</strong>。稍后当我们在前端执行这个查询时，会有更多的细节)。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="84ef" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">第8行的<strong class="le iu">边</strong>基本上是我们街道名称的列表，周围有一些“元数据”。每个记录都包含一个游标(正如我们前面提到的，它是记录的哈希值)。它包含我们感兴趣的实际数据，在来自<code class="fe oa ob oc od b">streetNames.json</code>的<strong class="le iu">节点</strong>属性中。</p><p id="be69" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">请注意，该响应也表明<em class="ld">还有更多数据要获取</em>。你可以在<strong class="le iu"> pageInfo </strong>里面看到。它显示了返回的最后一条记录的光标(当我们发出下一个请求时，我们可以将它作为一个参数使用)，并且它明确表示可以获取更多的数据(<code class="fe oa ob oc od b">"hasNextPage": true</code>)。</p><p id="6167" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">在创建我们的前端之前，让我们看看这个数据是如何被我们的服务器用它的<em class="ld">解析器、</em>返回的。</p><p id="fc39" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated"><strong class="le iu"> resolvers.js </strong> <br/>当我们的服务器接收到一个<code class="fe oa ob oc od b">streetNames</code>查询时，它必须<em class="ld">解析</em>这个查询(它必须找到正确的数据)。在我们的模式定义中，我们可以看到该查询可以接收两个(可选)参数:</p><pre class="kj kk kl km gt oi od oj ok aw ol bi"><span id="abcd" class="lz ma it od b gy om on l oo op">type Query {<br/>  streetNames(first: Int, after: String): Response<br/>}</span></pre><p id="31a8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">通过这种方式，我们可以配置需要获取多少条记录，使用<code class="fe oa ob oc od b">first</code>和<code class="fe oa ob oc od b">after</code>选择数据时应该从哪条记录开始。<code class="fe oa ob oc od b">after</code>的值应该是一个<em class="ld">光标</em>。在我们的例子中，它是JSON文件中的一个<em class="ld">散列</em>。</p><p id="f227" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">我们的<strong class="le iu">解析器</strong> ( <em class="ld">有些简化，以使其更具可读性——完整版</em> <a class="ae ly" href="https://gitlab.com/gvanderput/gerard-graphql-pagination/-/blob/master/server/resolvers.js" rel="noopener ugc nofollow" target="_blank"> <em class="ld">中的回购</em> </a>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="ffc7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">在围绕这一点的所有解释和理论之后，代码应该自己说话。好好看看它，然后我们将继续前进到前端。</p><h1 id="5cbf" class="np ma it bd mb nq nr ns me nt nu nv mh jz nw ka ml kc nx kd mp kf ny kg mt nz bi translated">使用无限滚动对组件进行反应</h1><p id="cf4a" class="pw-post-body-paragraph lb lc it le b lf mv ju lh li mw jx lk mi mx ln lo mm my lr ls mq mz lv lw lx im bi translated">在继续之前，请确保您的本地GraphQL服务器正在运行。如果您已经克隆了<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-graphql-pagination" rel="noopener ugc nofollow" target="_blank">存储库</a>，您可以运行:</p><pre class="kj kk kl km gt oi od oj ok aw ol bi"><span id="6004" class="lz ma it od b gy om on l oo op">$ yarn run graphql:start</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/aa0977619cdf1cda7054514dc0157e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/1*P7r7pIm_2XeBeUryXiM3_Q.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">动画:行动中的无限滚动(<strong class="bd mb">无</strong>人工网络延迟)。</figcaption></figure><p id="aa42" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">我用CRA创建了一个新项目，并添加了一些依赖项。我们将使用流行的<a class="ae ly" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> <strong class="le iu"> Apollo客户端</strong> </a>与我们的GraphQL服务器对话:</p><pre class="kj kk kl km gt oi od oj ok aw ol bi"><span id="ab6e" class="lz ma it od b gy om on l oo op">$ npx create-react-app myApp<br/>$ cd myApp<br/>$ yarn add @apollo/client graphql</span></pre><h2 id="3b59" class="lz ma it bd mb mc md dn me mf mg dp mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">Apollo客户端实例</h2><p id="e8ab" class="pw-post-body-paragraph lb lc it le b lf mv ju lh li mw jx lk mi mx ln lo mm my lr ls mq mz lv lw lx im bi translated">首先，我们在<code class="fe oa ob oc od b">src/client.js</code>中创建和导出一个客户端实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="129a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">在第7–13行上，我们为街道名称查询配置了<code class="fe oa ob oc od b">typePolicies</code>。Apollo-Client从版本3(2020年7月发布)开始就支持这个。我们在这里所做的是定义<strong class="le iu">如何将对包含列表<strong class="le iu">的GraphQL模式</strong>的连续调用的数据合并</strong>(并存储在缓存中)。</p><p id="fec8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">换句话说，如果我们对服务器进行两次调用:</p><ul class=""><li id="f0e6" class="na nb it le b lf lg li lj mi nc mm nd mq ne lx nf ng nh ni bi translated">呼叫1:获取记录0到9</li><li id="6925" class="na nb it le b lf nj li nk mi nl mm nm mq nn lx nf ng nh ni bi translated">通话2:获取记录10至19</li></ul><p id="ad22" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">…这将决定两个响应如何组合(合并)并存储在缓存中。您还可以覆盖或定制由预定义的<code class="fe oa ob oc od b">relayStylePagination</code>函数返回的值，但这超出了本文的范围。<a class="ae ly" href="https://www.apollographql.com/docs/react/pagination/cursor-based/" rel="noopener ugc nofollow" target="_blank">在文档</a>中了解更多信息。至少我们现在看到了使用中继分页规范的一个好处:其他库也经常实现对它的支持。</p><p id="66f2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">在继续下一步之前，确保您的主组件被包装在一个引用实例化客户端的Apollo ProviderHOC(高阶组件)中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="3d86" class="lz ma it bd mb mc md dn me mf mg dp mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">无限涡旋组件</h2><p id="1ba1" class="pw-post-body-paragraph lb lc it le b lf mv ju lh li mw jx lk mi mx ln lo mm my lr ls mq mz lv lw lx im bi translated">最后但同样重要的是，无限卷轴组件本身。您可以在库中查看完整的文件<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-graphql-pagination/-/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank">，但是我将在下面描述一些<strong class="le iu">关键部分</strong>(马上查看整个文件可能会有点让人不知所措)。</a></p><p id="3a73" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">首先，我们在<code class="fe oa ob oc od b">queries.js</code>中定义我们的查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="46ae" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">然后，在我们的功能组件中，我们用来自Apollo-Client的<code class="fe oa ob oc od b">useQuery</code>钩子执行这个查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d53e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated"><code class="fe oa ob oc od b">first</code> (10)配置我们希望每个请求获取多少“行”。除此之外，每当<code class="fe oa ob oc od b">networkStatus</code>的值改变时，设置<code class="fe oa ob oc od b">notifyOnNetworkStatusChange</code>将重新呈现我们的组件。默认情况下，这是<em class="ld"> false </em>，但是我们希望能够在我们的组件中显示“正在发生一些事情”。例如，当我们的用户向下滚动并开始获取更多数据时，我们可以显示一个微调器。</p><p id="d370" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">重要提示:注意<code class="fe oa ob oc od b">useQuery</code>是如何导出一个名为<code class="fe oa ob oc od b">fetchMore</code>的变量(函数)的。这就是我们可以用来<em class="ld">获取更多数据</em>的函数！</p><p id="c33c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">所以当我们渲染我们的<strong class="le iu">数据</strong>(也由<code class="fe oa ob oc od b">useQuery</code>返回；这包含我们的街道名称)作为DOM中的行，我们将在它们下面呈现一个“<strong class="le iu"> load more </strong>按钮:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/2016922438a8387c103802ddabde9db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*Z4Cq0dwgQava0SLPanuH7g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">数据行下方的<strong class="bd mb">加载更多的</strong>按钮。</figcaption></figure><p id="cbbd" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">看看我们的按钮，以及它的<em class="ld">点击处理程序</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="bef8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">点击处理程序调用<code class="fe oa ob oc od b"><strong class="le iu">fetchMore</strong></code>函数。看看我们如何传递变量<code class="fe oa ob oc od b">after</code>、<em class="ld">和来自前一个请求</em>的、<code class="fe oa ob oc od b"><em class="ld">endCursor</em></code>、<em class="ld">值。</em></p><p id="24d2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">现在应该说得通了。</p><p id="3c7c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">现在，您可以打开浏览器进行测试。它的工作:我们可以通过点击“加载更多”按钮加载更多的数据！</p><p id="13a2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated"><em class="ld">感谢您的时间，我们将在我的下一个</em>再见……等待。我们不喜欢手工劳动，是吗？</p><p id="3f21" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">向<a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank"> <strong class="le iu">路口观察者API </strong> </a>问好。</p><p id="2c37" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">每当DOM元素在视窗中可见时，交叉点观察器<strong class="le iu">可以触发一个事件。</strong></p><p id="6ab3" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">我不会描述细节，因为否则这篇文章会变得太长，但它并不难使用。本质上，您必须:</p><ul class=""><li id="e67a" class="na nb it le b lf lg li lj mi nc mm nd mq ne lx nf ng nh ni bi translated">创建新的IntersectionObserver实例</li><li id="184a" class="na nb it le b lf nj li nk mi nl mm nm mq nn lx nf ng nh ni bi translated">让<em class="ld">观察</em>的“加载更多”按钮</li><li id="8290" class="na nb it le b lf nj li nk mi nl mm nm mq nn lx nf ng nh ni bi translated">每当“加载更多”按钮变得可见时(在屏幕上)，在其上触发一个点击事件。</li></ul><p id="07d0" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">你可以在库的<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-graphql-pagination/-/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank"> App.js中查找细节，在<strong class="le iu">第20–37行</strong>的两个useEffect钩子中。</a></p><p id="ba18" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated"><strong class="le iu">现在</strong>我们有了一个无限(自动)滚动组件和一个定制的GraphQL服务器！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/aa0977619cdf1cda7054514dc0157e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/1*P7r7pIm_2XeBeUryXiM3_Q.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">动画:行动中的无限滚动(<strong class="bd mb">无</strong>人为网络延迟)。</figcaption></figure><p id="0753" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">感谢您的时间:)</p><p id="300f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk mi lm ln lo mm lq lr ls mq lu lv lw lx im bi translated">杰拉德·范德普特</p></div></div>    
</body>
</html>