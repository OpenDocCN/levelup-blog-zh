<html>
<head>
<title>Introducing the Full Stack Typing Boilerplate: Once You ORM, You Can’t Go Back!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍全栈类型样板文件:一旦使用了ORM，就再也回不去了！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introducing-the-full-stack-typing-boilerplate-once-you-orm-you-cant-go-back-e97b53a36f?source=collection_archive---------6-----------------------#2020-05-13">https://levelup.gitconnected.com/introducing-the-full-stack-typing-boilerplate-once-you-orm-you-cant-go-back-e97b53a36f?source=collection_archive---------6-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b2c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以Typescript和Sequelize为特色:在前端和后端之间共享类型，以获得最高的开发效率。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b5cb704fa2773b59e06cc685c6a5f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZd_qi7oa3vqOzVznBK9Bw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://www.pexels.com/photo/computer-screen-programming-software-225250/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kv" href="https://www.pexels.com/@markusspiske?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>的照片</figcaption></figure><p id="9914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://chrisfrew.in/blog/sequelize-and-typescript-rest-once-you-orm-you-never-go-back/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">本帖镜像在我的博客上。</em> </a></p><p id="d9d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在软件世界中，99%的时候你都需要一个API。</p><p id="8ab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经常(也许总是🤔)API需要能够在数据库级别执行一些CRUD操作(创建、读取、更新和删除)。</p><p id="63c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几年来，在Node.js中获得易于使用的数据库连接的“前沿”看起来是这样的:</p><ul class=""><li id="f7bf" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">您将拥有一个包含连接设置的<code class="fe mc md me mf b"><strong class="ky ir">db/index.js</strong></code>文件</li><li id="0f3d" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">您的连接器看起来像这样(在这个例子中，我使用PostgreSQL的包<code class="fe mc md me mf b"><strong class="ky ir">pg</strong></code>):</li></ul><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="53c9" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">const { Pool } = require("pg")</strong></span><span id="38f0" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const pool = new Pool({<br/>    user: process.env.YOUR_DB_USER,<br/>    host: process.env.YOUR_DB_HOST,<br/>    database: process.env.YOUR_DB_NAME,<br/>    password: process.env.YOUR_DB_PASSWORD,<br/>    port: process.env.YOUR_DB_PORT,<br/>})</strong></span><span id="1ff5" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">/**<br/> * DB Query<br/> * @param {object} req<br/> * @param {object} res<br/> * @returns {object} object<br/> */<br/>function query(text, params) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        pool.query(text, params)<br/>            .then(res =&gt; {<br/>                resolve(res)<br/>            })<br/>            .catch(err =&gt; {<br/>                reject(err)<br/>            })<br/>    })<br/>}</strong></span><span id="71fe" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">exports.query = query</strong></span></pre><p id="8bf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后使用<code class="fe mc md me mf b"><strong class="ky ir">db</strong></code>模块，像这样传入(几乎)原始的SQL语句:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="b839" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">const db = require("../db")<br/>const email = "test@test.com"<br/>const userSelectPromise = db.query("SELECT * FROM users WHERE email = $1", [<br/>    email,<br/>])<br/>Promise.resolve(userSelectPromise).then(userSelect =&gt; {<br/>    if (userSelect &amp;&amp; parseInt(userSelect[0].rowCount) &gt; 0) {<br/>        const username = userSelect.rows[0].username<br/>        // etc...<br/>    }<br/>})</strong></span></pre><p id="d31a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，请随意复制并粘贴该代码，它将为您工作…</p><p id="6824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">⚠:但是我不建议你使用它！⚠</p><p id="ae6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这当然不再是最先进的做事方式了。从这种方法中可以清楚地看出一些事情:</p><ul class=""><li id="8d71" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">为了最终得到您想要的值，需要进行大量的非空和大小检查</li><li id="e702" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">笨拙的承诺语法</li><li id="fb63" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">也许最令人发指的是:原始SQL查询😱</li></ul><p id="fb61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在隔离/封锁/就地避难期间的某个时候，我问自己，</p><blockquote class="mw mx my"><p id="e334" class="kw kx ls ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">肯定有人已经抽象出了所有这些检查和承诺/异步的东西，对不对？</p></blockquote><p id="406c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且，</p><blockquote class="mw mx my"><p id="b7af" class="kw kx ls ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">现在是2020年…一定有一种不用写原始SQL就能查询数据库的方法，对吗？</p></blockquote><p id="0cf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然有！</p><h1 id="8302" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">介绍Sequelize</h1><p id="2bef" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">随着时间的推移，在软件世界中，样板代码往往被仔细地组织和抽象，经常成为一个包。对于在JavaScript中连接和执行SQL，这个包是<a class="ae kv" href="https://github.com/sequelize/sequelize" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>。开箱即用，Sequelize可以为您节省大量时间，为您解决可能需要完成的任何与SQL相关的任务。干杯🍻尊重那个包的作者、维护者和贡献者！</p><p id="a239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您将TypeScript的静态类型添加到这个组合中时，您就有了一个更加强大的工作流，能够将一个类——也就是一个模型——映射到一个表！事实上，这正是ORM的本质:对象关系映射。我记得当时我意识到所有的表都可以通过一个类1:1地表示出来:</p><p id="fe88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名软件工程师，我的生活永远改变了。</p><p id="a73d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如题，一旦你形成了，你就不能回头了。一旦你设置好了，事情就简单多了。我也会证明这一点——在本指南的最后，我会给出一个额外的指南，说明您可以在<em class="ls">分钟内</em>添加API端点！您甚至可以确信您没有犯任何愚蠢的SQL语法错误或键入错误——它们都是由Sequelize或Typescript处理的！再也不用为SQL错误挠头了，再也不用去寻找查询返回的究竟是什么类型了！</p><p id="596d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，在这篇文章中，当我提到“模型”这个词时，它可以和“桌子”这个词互换。</p><h1 id="2f10" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">入门指南</h1><p id="5bf4" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">在我为我的一个项目升级REST API的最初研究中，我发现了Loren Stewart的这篇文章。这篇文章采用了一种很好的组织模式，将众多的API模型组合成一个类。不过由于是2016年发的，现在有点过时了。(我知道，当我听到自己说一篇只有4年历史的文章已经“过时”时，我感到很不舒服，但那是软件🤷‍♂️).在Sequelize 最新版本的Typescript文档的帮助下，我已经将他的组织模式从JavaScript转换成了TypeScript。</p><p id="f311" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🎺 👼听啊！我现在给你带来了一个面向2020年的现代API后端框架！</p><h1 id="d819" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">创建我们的第一个模型</h1><p id="6350" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">让我们从为我们的<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>表创建一个模型开始，因为在我们旧的JavaScript做事方式中，我们甚至没有<em class="ls">这样的定义。下面是我们如何定义一个模型(<em class="ls">思考表</em>)的打字稿方式:</em></p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="0f73" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import { Model, DataTypes, Sequelize, BuildOptions } from "sequelize"<br/>import IUser from "../../shared/interfaces/IUser"</strong></span><span id="7f98" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">type UsersStatic = typeof Model &amp; {<br/>    new (values?: object, options?: BuildOptions): IUser<br/>}</strong></span><span id="fbd9" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const sequelize = new Sequelize(<br/>    process.env.YOUR_DB_NAME,<br/>    process.env.YOUR_DB_USER,<br/>    process.env.YOUR_DB_PASSWORD,<br/>    {<br/>        host: "localhost",<br/>        dialect: "postgres",<br/>    }<br/>)</strong></span><span id="ec96" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const users = &lt;UsersStatic&gt;sequelize.define("users", {<br/>    id: {<br/>        type: DataTypes.INTEGER,<br/>        autoIncrement: true,<br/>        primaryKey: true,<br/>    },<br/>    email: {<br/>        type: DataTypes.STRING(255),<br/>        allowNull: false,<br/>        unique: true,<br/>    },<br/>    username: {<br/>        type: DataTypes.STRING(30),<br/>        allowNull: false,<br/>        unique: true,<br/>    },<br/>})</strong></span></pre><p id="a0fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能需要在<code class="fe mc md me mf b"><strong class="ky ir">&lt;UserStatic&gt;</strong></code>铸造线上方提供<code class="fe mc md me mf b"><strong class="ky ir">// eslint-disable-next-line @typescript-eslint/consistent-type-assertions</strong></code>，这取决于您的格式器和/或棉绒规则。这些复杂的打字遵循<code class="fe mc md me mf b"><strong class="ky ir">sequelize</strong></code>自己的<a class="ae kv" href="https://sequelize.org/master/manual/typescript.html" rel="noopener ugc nofollow" target="_blank">打字文档</a>的指导。<code class="fe mc md me mf b"><strong class="ky ir">IUser</strong></code>只是一个定义我们的<code class="fe mc md me mf b"><strong class="ky ir">user</strong></code>表中的列的接口。现在请注意它——虽然它是一个简单的界面，但它将非常<em class="ls">😉对我们以后有用:</em></p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="cfae" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">export default interface IUser {<br/>    id: number<br/>    email: string<br/>    username: string</strong></span><span id="c1dc" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    createdAt: Date<br/>    updatedAt: Date<br/>}</strong></span></pre><p id="467a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe mc md me mf b"><strong class="ky ir">createdAt</strong></code>和<code class="fe mc md me mf b"><strong class="ky ir">updatedAt</strong></code>默认带有Sequelize <code class="fe mc md me mf b"><strong class="ky ir">define()</strong></code>函数，所以我们不必在模型定义中定义它们。让我们继续使用我们的用户选择示例，看看如何使用我们的新<code class="fe mc md me mf b"><strong class="ky ir">User</strong></code>模型创建select语句。在这种情况下，我们可以在声明<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>之后直接编写一个查询:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="8ff9" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import { Model, DataTypes, Sequelize, BuildOptions } from "sequelize"<br/>import IUser from "../../shared/interfaces/IUser"</strong></span><span id="b7bd" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">type UsersStatic = typeof Model &amp; {<br/>    new (values?: object, options?: BuildOptions): IUser<br/>}</strong></span><span id="5d47" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const sequelize = new Sequelize(<br/>    process.env.YOUR_DB_NAME,<br/>    process.env.YOUR_DB_USER,<br/>    process.env.YOUR_DB_PASSWORD,<br/>    {<br/>        host: "localhost",<br/>        dialect: "postgres",<br/>    }<br/>)</strong></span><span id="07e3" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const users = &lt;UsersStatic&gt;sequelize.define("users", {<br/>    id: {<br/>        type: DataTypes.INTEGER,<br/>        autoIncrement: true,<br/>        primaryKey: true,<br/>    },<br/>    email: {<br/>        type: DataTypes.STRING(255),<br/>        allowNull: false,<br/>        unique: true,<br/>    },<br/>    username: {<br/>        type: DataTypes.STRING(30),<br/>        allowNull: false,<br/>        unique: true,<br/>    },<br/>})</strong></span><span id="60f5" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">// --&gt; new code: query example<br/>const user = users.findOne({<br/>    where: {<br/>        email: {<br/>            [Op.eq]: email,<br/>        },<br/>    },<br/>})</strong></span><span id="ced7" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">if (!user) {<br/>    console.log("entry not found!")<br/>}</strong></span><span id="a009" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">if (user) {<br/>    const username = user.username<br/>}<br/>// &lt;-- end new code</strong></span></pre><p id="9825" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。我们刚刚在软件技术领域跨越了4年多！</p><p id="1e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意这里的<code class="fe mc md me mf b"><strong class="ky ir">[Op.eq]:</strong></code>不是必须的。另一种方法是使用冒号。在<code class="fe mc md me mf b"><strong class="ky ir">sequelize</strong></code>中，这意味着<code class="fe mc md me mf b"><strong class="ky ir">=</strong></code>，也就是说，如果我们希望email列等于<code class="fe mc md me mf b"><strong class="ky ir">email</strong></code>变量，我们可以写:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="a96d" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">where: {<br/>    email: email<br/>}</strong></span></pre><p id="e28c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于速记语法，我们甚至可以将其简化为:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="25bf" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">where: {<br/>    email<br/>}</strong></span></pre><p id="74df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这是一个滑坡。我经常在查询中使用各种操作，所以我通常已经导入了<code class="fe mc md me mf b"><strong class="ky ir">Op</strong></code>对象。</p><p id="68c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现<code class="fe mc md me mf b"><strong class="ky ir">[Op.eq]</strong></code>表示在准确描述正在发生的事情方面更加明确。</p><h1 id="1b66" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">集中模型！</h1><p id="be7a" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">所以我们有了很好的类型化模型，但是很少有API只有一个表结构。很容易想象，每当我们需要连接到一个表时，总是声明<code class="fe mc md me mf b"><strong class="ky ir">sequelize</strong></code>对象<em class="ls">和</em>重复提供模型定义会有多痛苦。</p><p id="1a32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们一次性完成所有的初始化步骤，并且可以将所有的模型组织到一个集中的类中，那就太好了，对吗？那么我们将只访问所有其他API类中的<em class="ls">和</em>类。(为这个组织理念向<a class="ae kv" href="https://lorenstewart.me/2016/09/12/sequelize-table-associations-joins" rel="noopener ugc nofollow" target="_blank"> Loren Stewart的职位</a>脱帽致敬)。</p><p id="9f11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们以后需要更复杂的<code class="fe mc md me mf b"><strong class="ky ir">JOIN</strong></code>查询，这个组织步骤也将非常有帮助——我们将立即获得所有的表以便于使用！</p><p id="8914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要稍微重构一下我们的<code class="fe mc md me mf b"><strong class="ky ir">user</strong></code>模型定义——我们想取出查询，并将声明包装在一个接受<code class="fe mc md me mf b"><strong class="ky ir">sequelize</strong></code>对象并返回<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>模型的函数中。<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>模型文件现在看起来是这样的:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="ddf5" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import { Model, DataTypes, Sequelize, BuildOptions } from "sequelize"<br/>import IUser from "../../shared/interfaces/IUser"</strong></span><span id="f7c3" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">type UsersStatic = typeof Model &amp; {<br/>    new (values?: object, options?: BuildOptions): IUser<br/>}</strong></span><span id="b01e" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">export default function Users(sequelize: Sequelize) {<br/>    const users = &lt;UsersStatic&gt;sequelize.define("users", {<br/>        id: {<br/>            type: DataTypes.INTEGER,<br/>            autoIncrement: true,<br/>            primaryKey: true,<br/>        },<br/>        email: {<br/>            type: DataTypes.STRING(255),<br/>            allowNull: false,<br/>            unique: true,<br/>        },<br/>        username: {<br/>            type: DataTypes.STRING(30),<br/>            allowNull: false,<br/>            unique: true,<br/>        },<br/>    })<br/>    return users<br/>}</strong></span></pre><p id="0b50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们假设我们已经创建了一个额外的模型，叫做<code class="fe mc md me mf b"><strong class="ky ir">posts</strong></code>。我们将经历与对<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>相同的模型定义和接口声明过程——将<code class="fe mc md me mf b"><strong class="ky ir">posts</strong></code>模型包装在一个接受<code class="fe mc md me mf b"><strong class="ky ir">sequelize</strong></code>对象的函数中，并同样导出它。</p><p id="a586" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们想将我们的两个模型<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>和<code class="fe mc md me mf b"><strong class="ky ir">posts</strong></code>导入到一个我们可以在任何地方使用的集中类中。我们只想初始化<code class="fe mc md me mf b"><strong class="ky ir">sequelize</strong></code>对象一次，并把它传递给我们所有的模型。我们可以创建一个这样的类，<code class="fe mc md me mf b"><strong class="ky ir">DB</strong></code>:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="7d60" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import { Sequelize } from "sequelize"<br/>import Users from "../models/Users"<br/>import Posts from "../models/Posts"</strong></span><span id="6e7e" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">class DB {<br/>    // create sequelize connection<br/>    public static readonly sequelize = new Sequelize(<br/>        process.env.YOUR_DB_NAME,<br/>        process.env.YOUR_DB_USER,<br/>        process.env.YOUR_DB_PASSWORD,<br/>        {<br/>            host: "localhost",<br/>            dialect: "postgres",<br/>        }<br/>    )</strong></span><span id="f89b" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    // initialize models by passing sequelize into our model definition functions<br/>    public static readonly users = Users(DB.sequelize)<br/>    public static readonly posts = Posts(DB.sequelize)<br/>}</strong></span><span id="356e" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">export default DB</strong></span></pre><p id="c593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，对于热衷于关系数据库的用户来说，您可能会注意到这里缺少了一条重要的信息。型号<code class="fe mc md me mf b"><strong class="ky ir">posts</strong></code>大概和型号<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>有关系吧？这可能就是我们所说的<em class="ls">一对多</em>或<em class="ls"> 1:n </em>关系。我们也应该想办法给这种关系下一次定义。为此，我们可以在定义<code class="fe mc md me mf b"><strong class="ky ir">DB</strong></code>类之前创建一个<code class="fe mc md me mf b"><strong class="ky ir">setRelations()</strong></code>函数来定义这些关系。现在完整的<code class="fe mc md me mf b"><strong class="ky ir">DB.ts</strong></code>文件变成了:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="17bf" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">class DB {<br/>    // create sequelize connection<br/>    public static readonly sequelize = new Sequelize(<br/>        process.env.YOUR_DB_NAME,<br/>        process.env.YOUR_DB_USER,<br/>        process.env.YOUR_DB_PASSWORD,<br/>        {<br/>            host: "localhost",<br/>            dialect: "postgres",<br/>        }<br/>    )</strong></span><span id="8a53" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    // initialize models by passing sequelize into our model definition functions<br/>    public static readonly users = Users(DB.sequelize)<br/>    public static readonly posts = Posts(DB.sequelize)<br/>}</strong></span><span id="8555" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">// --&gt; new code: setRelations() function<br/>function setRelations(): void {<br/>    /////////////////<br/>    // One-To-Many //<br/>    /////////////////</strong></span><span id="f8d0" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    // Users and Posts One-To-Many Relationship<br/>    DB.users.hasMany(DB.posts, { foreignKey: "userId" })<br/>    DB.posts.belongsTo(DB.users, { foreignKey: "userId" })<br/>}</strong></span><span id="9a94" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">setRelations()<br/>// &lt;-- end new code</strong></span><span id="62f1" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">export default DB</strong></span></pre><p id="5538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，表<code class="fe mc md me mf b"><strong class="ky ir">posts</strong></code>需要有列<code class="fe mc md me mf b"><strong class="ky ir">userId</strong></code>(如您在<a class="ae kv" href="https://github.com/princefishthrower/full-stack-typing-boilerplate" rel="noopener ugc nofollow" target="_blank">示例代码库</a>中所见)。现在Sequelize将知道表用户和帖子有一对多的关系，我们可以很容易地用这两者创建<code class="fe mc md me mf b"><strong class="ky ir">JOIN</strong></code>语句。</p><h1 id="43d5" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">利用它！(后端)</h1><p id="07a2" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">很好，我们基本上完成了！使用我们的<code class="fe mc md me mf b"><strong class="ky ir">DB</strong></code>类的新方法如下(仍然坚持用户对<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>表的查询):</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="ce21" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import DB from "../DB"<br/>import { Op } from "sequelize"</strong></span><span id="c536" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const email = "test@test.com"<br/>const user = await DB.users.findOne({<br/>    where: {<br/>        email: {<br/>            [Op.eq]: email,<br/>        },<br/>    },<br/>})</strong></span><span id="1423" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">if (!user) {<br/>    // TODO: real error logging and handling<br/>    console.log("error")<br/>}</strong></span><span id="4d89" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const username = user.username<br/>// more logic...</strong></span></pre><p id="0507" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了展示一个<code class="fe mc md me mf b"><strong class="ky ir">JOIN</strong></code>示例，让我们通过Sequelize <code class="fe mc md me mf b"><strong class="ky ir">include</strong></code>指令获取给定用户的所有帖子。因为我们已经定义了一对多的关系，这个<code class="fe mc md me mf b"><strong class="ky ir">JOIN</strong></code>变成了一行代码(是的，技术上是一个5行代码——但是如果你愿意，你可以把它放在一行代码中😉 😂):</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="0f7d" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import DB from "../DB"<br/>import { Op } from "sequelize"</strong></span><span id="baa6" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const email = "test@test.com"<br/>const userWithPosts = await DB.users.findOne({<br/>    where: {<br/>        email: {<br/>            [Op.eq]: email,<br/>        },<br/>    },<br/>    include: [<br/>        {<br/>            model: DB.posts, // That's all it takes to JOIN on table posts! Sequelize knows the JOIN should be on column userId!<br/>        },<br/>    ],<br/>})</strong></span><span id="843d" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">if (!userWithPosts) {<br/>    // TODO: real error logging and handling<br/>    console.log("error")<br/>}</strong></span><span id="853a" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">const posts = userWithPosts.posts</strong></span></pre><p id="4c28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由此产生的<code class="fe mc md me mf b"><strong class="ky ir">userWithPosts</strong></code>对象将有一个嵌套的结构，完整的<code class="fe mc md me mf b"><strong class="ky ir">user</strong></code>对象在最高层，但是有一个额外的键<code class="fe mc md me mf b"><strong class="ky ir">posts</strong></code>，包含用户的文章，类型为<code class="fe mc md me mf b"><strong class="ky ir">Array&lt;IPosts&gt;</strong></code>。在这种情况下，用确切的类型定义一个新的接口是有用的(记住，我们假设已经写了一个<code class="fe mc md me mf b"><strong class="ky ir">IPosts</strong></code>):</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="4258" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import IUser from "./IUser"<br/>import IPost from "./IPost"</strong></span><span id="e47c" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">export default interface IUserWithPosts extends IUser {<br/>    posts: Array&lt;IPost&gt;<br/>}</strong></span></pre><p id="043e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显式键入来自<code class="fe mc md me mf b"><strong class="ky ir">findOne()</strong></code>调用的响应是一个好习惯:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="5616" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">...<br/>import IUserWithPosts '../../shared/interfaces/IUserWithPosts';<br/>...<br/>const userWithPosts: IUserWithPosts = await DB.users.findOne({ ... });</strong></span></pre><p id="2e01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是一个<code class="fe mc md me mf b"><strong class="ky ir">findAll()</strong></code>调用，例如查找来自所有用户的所有帖子(一个玩具示例——谁知道你是否真的需要它，也许你会有所需要🤔)，返回类型成为该类型的数组版本:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="96dd" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">...<br/>import IUserWithPosts '../../shared/interfaces/IUserWithPosts';<br/>...<br/>const usersWithPosts: Array&lt;IUserWithPosts&gt; = await DB.users.findAll({ ... });</strong></span></pre><p id="c3b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种设置，您可以在定义端点时轻松地将其插入路由器。基本上，如果没有找到记录，您将返回HTTP 404，如果找到了，则返回HTTP 200 success！更多信息请参见<a class="ae kv" href="https://github.com/princefishthrower/full-stack-typing-boilerplate" rel="noopener ugc nofollow" target="_blank">示例代码库</a>。</p><h1 id="aa05" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">利用它！(前端)</h1><p id="d45d" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">记得我说过要注意那个界面<code class="fe mc md me mf b"><strong class="ky ir">IUser</strong></code>吗？当我们进行前端开发时，我们可以可靠地输入所有的API请求！这意味着:</p><p id="cd39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前端和后端共享他们输入的真实的单一来源！</p><p id="dc63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我第一次意识到使用TypeScript可以做到这一点时，我惊讶地发现这极大地减少了语法和运行时错误，从而提高了生产率。</p><p id="2c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当单个模型和界面定义您的数据时，跟踪数据流是如此容易——无论您是在后端还是前端。</p><p id="dc10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的不在乎那些<code class="fe mc md me mf b"><strong class="ky ir">vim</strong></code>家伙说什么；如果您有这样的设置，并且正在使用具有Intellisense的现代编辑器，那么您只需点击几下鼠标就可以深入了解API的完整类型定义——同样，无论您是从后端还是前端开始。</p><p id="33b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个前端例子，这里有一个<code class="fe mc md me mf b"><strong class="ky ir">fetch()</strong></code>调用，我们可以使用我们的接口键入它:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="1de3" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">...<br/>import IUser '../../shared/interfaces/IUser';<br/>...<br/>// IUser typed result<br/>try {<br/>    const response = await fetch('https://your-api-url.com/get-user?email=test@test.com');<br/>    if (response.status === 200) {<br/>        const json = await response.json();<br/>        const user: IUser = json.user;<br/>        // user has all properties IUser has<br/>    }<br/>} catch (err) {<br/>    console.log(err)<br/>}</strong></span><span id="fd5b" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">// IUserWithPosts typed result<br/>...<br/>import IUserWithPosts '../../shared/interfaces/IUserWithPosts';<br/>...</strong></span><span id="b720" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">try {<br/>    const response = await fetch('https://your-api-url.com/get-user-with-posts?email=test@test.com');<br/>    if (response.status === 200) {<br/>        const json = await response.json();<br/>        const userWithPosts: IUserWithPosts = json.userWithPosts;<br/>        // userWithPosts has all properties IUserWithPosts has<br/>    }<br/>} catch (err) {<br/>    console.log(err)<br/>}</strong></span></pre><p id="40cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，在响应对象中，你必须在第一个例子中传递一个键为<code class="fe mc md me mf b"><strong class="ky ir">user</strong></code>的对象，在第二个例子中传递一个键为<code class="fe mc md me mf b"><strong class="ky ir">userWithPosts</strong></code>的对象——参见<a class="ae kv" href="https://github.com/princefishthrower/full-stack-typing-boilerplate" rel="noopener ugc nofollow" target="_blank">示例代码库</a>。</p><h1 id="b6d3" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">全栈组织</h1><p id="ad20" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">您可能已经注意到，这种全堆栈类型的模式提出了三个一般领域，也许最好收集到文件夹中:</p><ul class=""><li id="ce07" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><code class="fe mc md me mf b"><strong class="ky ir">backend/</strong></code> -路由、数据库查询等。</li><li id="645e" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated"><code class="fe mc md me mf b"><strong class="ky ir">shared/</strong></code> -接口、枚举、类型等。</li><li id="42c9" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated"><code class="fe mc md me mf b"><strong class="ky ir">frontend/</strong></code> -视图、组件、样式等。</li></ul><p id="fd19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据许多因素，包括项目的规模和范围，您可能希望为每个“区域”建立一个存储库，或者将所有三个“区域”作为文件夹放在同一个存储库中。我将把它收集在一个库中，就像<a class="ae kv" href="https://github.com/princefishthrower/full-stack-typing-boilerplate" rel="noopener ugc nofollow" target="_blank">示例代码库</a>一样。</p><h1 id="a7b4" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">代码库</h1><p id="6df7" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">这里有一个<a class="ae kv" href="https://github.com/princefishthrower/full-stack-typing-boilerplate" rel="noopener ugc nofollow" target="_blank">示例存储库</a>，它包括前端、后端和共享区域。请在到达后阅读自述文件！</p><p id="a68b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能还想看看<a class="ae kv" href="https://github.com/vrudikov/typescript-rest-boilerplate" rel="noopener ugc nofollow" target="_blank">typescript-rest-boilerplate</a>以了解更多的后端实现思想和组织——尽管注意，boilerplate不包括前端部分。</p><p id="de79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你知道任何其他样板文件或框架使用了像我这样的模式吗？我很想知道。下面留言评论！</p><h1 id="ca6a" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">🥳BONUS！🥳</h1><p id="f300" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated"><em class="ls">本节是本帖的延伸，不再包含基本信息和概念。由于在后端引入了一个快速路由器，在前端引入了一个react应用程序，这需要一个跳跃。当然，非常欢迎感兴趣的读者继续阅读！</em></p><p id="be14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我提到过，我将演练如何在这种类型的框架中添加API端点，我引用如下:</p><blockquote class="mw mx my"><p id="d26a" class="kw kx ls ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">文字分钟</p></blockquote><p id="4dd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看我是否能履行我的承诺。我将使用<a class="ae kv" href="https://github.com/princefishthrower/full-stack-typing-boilerplate" rel="noopener ugc nofollow" target="_blank">示例代码库的</a>布局作为起点——随意使用并跟随，或者更好的是，克隆它并跟随编码！👩‍💻👨‍💻</p><p id="d90d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准备好了吗？！</p><p id="211c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🕰，各就各位，准备🤨，去吧🚀！</p><h1 id="6e24" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">第1分钟:场景/规格</h1><p id="1593" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">让我们构建一个简单的用户搜索，可在<code class="fe mc md me mf b"><strong class="ky ir">/user-search</strong></code>访问，并期望查询参数<code class="fe mc md me mf b"><strong class="ky ir">username</strong></code>带有用户名(注意，我们将允许部分名称并利用<code class="fe mc md me mf b"><strong class="ky ir">LIKE</strong></code> SQL操作符)。如果没有提供<code class="fe mc md me mf b"><strong class="ky ir">username</strong></code>参数，它应该返回一个HTTP 400代码，如果没有找到用户，返回404，否则返回200(当找到结果时)。</p><h1 id="242d" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">第2分钟:向路由器添加路由</h1><p id="06d9" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">首先，我们将我们的路线添加到<code class="fe mc md me mf b"><strong class="ky ir">Router/Router.ts</strong></code>，并将其传递给一个函数，比如说<code class="fe mc md me mf b"><strong class="ky ir">userSearch</strong></code>:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="040f" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">Router.get("/user-search", GetRoutes.userSearch)</strong></span></pre><h1 id="f808" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">第三分钟:编写用户搜索功能</h1><p id="8afd" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">然后我们实际编写函数<code class="fe mc md me mf b"><strong class="ky ir">userSearch</strong></code>。我们将它添加到<code class="fe mc md me mf b"><strong class="ky ir">Router/get/Users.ts</strong></code>文件中，因为我们需要访问的表是<code class="fe mc md me mf b"><strong class="ky ir">users</strong></code>:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="e241" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">export async function userSearch(req: express.Request, res: express.Response) {<br/>    // return 400 if username parameter not provided<br/>    if (req.query.username === null) {<br/>        return res.status(400).send("Username parameter not provided");<br/>    }</strong></span><span id="3225" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    const users: Array&lt;IUser&gt; = await DB.users.findAll({<br/>        where: {<br/>                username: {<br/>                    [Op.like]: '%' . req.query.username '%',<br/>                },<br/>            },<br/>        }<br/>    );</strong></span><span id="ea5f" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    if (users.length === 0) {<br/>        return res.status(404).send("No users found! :(");<br/>    }</strong></span><span id="3457" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    // send a 200 response with user data keyed as 'users'<br/>    return res.status(200).send({ users });<br/>}</strong></span></pre><h1 id="3c65" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">第4分钟:使用Route编写前端组件</h1><p id="4c0e" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">在前端，在<code class="fe mc md me mf b"><strong class="ky ir">components/SearchUsers.tsx</strong></code>下，你可以用<code class="fe mc md me mf b"><strong class="ky ir">fetch</strong></code>构建这样一个react功能组件。注意<code class="fe mc md me mf b"><strong class="ky ir">fetch</strong></code>调用是硬编码的，因为这是最简单的例子:</p><pre class="kg kh ki kj gt ml mf mm mn aw mo bi"><span id="2cae" class="mp mq iq mf b gy mr ms l mt mu"><strong class="mf ir">import React, { useState, useEffect } from "react"<br/>import IUser from "../../../shared/interfaces/IUser"<br/>import Constants from "../../../shared/Constants/Constants"</strong></span><span id="a4e5" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">export default function GetUser() {<br/>    const [users, setUsers] = useState&lt;Array&lt;IUser&gt; | undefined&gt;(undefined)</strong></span><span id="1b5b" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    useEffect(() =&gt; {<br/>        if (!users) {<br/>            searchUsers()<br/>        }<br/>    })</strong></span><span id="6f80" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    const searchUsers = async () =&gt; {<br/>        try {<br/>            const response = await fetch(<br/>                Constants.API_URL + "/search-users?username=tes"<br/>            )<br/>            if (response.status === 200) {<br/>                const json = await response.json()<br/>                setUsers(json.users)<br/>            }<br/>        } catch (err) {<br/>            console.log(err)<br/>        }<br/>    }</strong></span><span id="e5e3" class="mp mq iq mf b gy mv ms l mt mu"><strong class="mf ir">    return (<br/>        &lt;&gt;<br/>            {users ? (<br/>                &lt;ul&gt;<br/>                    {users.map(user =&gt; {<br/>                        return &lt;li&gt;{user.username}&lt;/li&gt;<br/>                    })}<br/>                &lt;/ul&gt;<br/>            ) : (<br/>                "Searching..."<br/>            )}<br/>        &lt;/&gt;<br/>    )<br/>}</strong></span></pre><p id="495d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">咻，真快！不到5分钟！🥵，我在流汗！</p><p id="1aca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道，我知道，你当然会构建一个交互式输入并呈现一个列表，但是我的<em class="ls">文字分钟</em>声明是关于构建一个API端点。这不包括前端组件😉。</p><p id="6888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，那是<em class="ls">字面上的分钟</em>？我也这么想😄</p><h1 id="e50a" class="nc mq iq bd nd ne nf ng nh ni nj nk nl jw nm jx nn jz no ka np kc nq kd nr ns bi translated">谢谢！</h1><p id="ad26" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">我希望这篇文章有助于让你的全栈应用程序开发更加愉快！</p><p id="99d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道我一直对这个装置很感兴趣！🚀 🚀 🚀</p><p id="0a9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干杯！🍺</p><p id="395f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">克里斯</p></div></div>    
</body>
</html>