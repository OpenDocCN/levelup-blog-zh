<html>
<head>
<title>My Top 5 JavaScript Tips and Tricks for Writing Cleaner Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的5大JavaScript技巧和窍门来编写更干净的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-top-5-javascript-tips-tricks-for-writing-cleaner-code-4ee60fef4b8?source=collection_archive---------4-----------------------#2021-08-08">https://levelup.gitconnected.com/my-top-5-javascript-tips-tricks-for-writing-cleaner-code-4ee60fef4b8?source=collection_archive---------4-----------------------#2021-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/00f6eef8b8219e4ecd5d5044b796dc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EB9byu_l-y_8AYtY"/></div></div></figure><h1 id="542c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.解构分配</h1><p id="b6d4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">析构赋值允许将一个或多个对象属性赋给单个表达式中的变量。创建的变量将与属性同名。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ee60" class="md jz iq lz b gy me mf l mg mh">let myObj = {<br/>  id: 1,<br/>  name: 'My Object'<br/>};</span><span id="eb41" class="md jz iq lz b gy mi mf l mg mh">// without destructuring assignment<br/>let id = myObj.id;<br/>let name = myObj.name; <br/>// id = 1, name = 'My Object'</span><span id="267d" class="md jz iq lz b gy mi mf l mg mh">// with destructuring assignment<br/>let { id, name } = myObj;<br/>// id = 1, name = 'My Object'</span></pre><p id="a9a7" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">当您知道您需要使用一个对象的多个属性，您需要多次使用同一个属性，或者您希望使用的属性深深地嵌套在该对象中时，这是非常有用的。在所有这些情况下，使用析构赋值可以使你从通过链接获取对象属性的混乱中解脱出来，并使你的代码更加简洁易读。</p><p id="7d8a" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">例如，我最近一直在做<a class="ae mo" href="https://leafletjs.com/" rel="noopener ugc nofollow" target="_blank">传单</a>的工作，这是一个用于构建交互式地图的Javascript框架。它是高度可定制的，允许你在地图上给不同的标记分配你自己的属性。然而，访问这些属性会变得有些混乱——我们可以用析构赋值来解决这个问题。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="957d" class="md jz iq lz b gy me mf l mg mh">// without destructuring assignment<br/>function onEachFeature (feature, layer) {<br/>  if (feature.properties.hasPopup) {<br/>    let popupContent = `&lt;a href="/feature/${feature.properties.id}"&gt;${feature.properties.name}&lt;/a&gt;`;<br/>    layer.bindPopup(popupContent);<br/>  }<br/>}</span><span id="84fd" class="md jz iq lz b gy mi mf l mg mh">// with destructuring assignment<br/>function onEachFeature (feature, layer) {<br/>  let { hasPopup, id, name } = feature.properties;</span><span id="9bc6" class="md jz iq lz b gy mi mf l mg mh">if (hasPopup) {<br/>    let popupContent = `&lt;a href="/feature/${id}"&gt;${name}&lt;/a&gt;`;<br/>    layer.bindPopup(popupContent);<br/>  }<br/>}</span></pre><p id="dd1c" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们可能添加了一行额外的代码，但是我相信这会让我们更清楚、更容易理解这个函数的意图。</p><p id="6e29" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">还可以析构数组，这允许您将数组中的一个或多个元素赋给变量。然而，我个人并不经常使用这种语法，所以我不会在这里进一步讨论它。如果您希望了解更多信息，请参见<a class="ae mo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> MDN参考</a>。</p><p id="5824" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">最后，如果你使用的函数有一个对象作为参数，那么在参数列表中析构这个对象是可能的。这使您不必亲自显式声明变量，并清楚地知道函数需要哪些属性。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5a28" class="md jz iq lz b gy me mf l mg mh">function logPerson(person) {<br/>  let { name, age } = options;<br/>  <br/>  console.log(`${name} is ${age} years old`);<br/>}</span><span id="48fd" class="md jz iq lz b gy mi mf l mg mh">function logPerson({ name, age }) {<br/>  console.log(`${name} is ${age} years old`);<br/>}</span></pre><h1 id="f49f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.短路评估和分配</h1><p id="8f7b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">JavaScript逻辑运算符AND (&amp;&amp;)和OR (||)被称为短路运算符，因为它们只在必要时计算表达式，以确定布尔表达式的结果。</p><p id="da6c" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">例如，和要求表达式的两端都计算为true。因此，如果表达式的左侧计算结果为false，它就不会检查右侧，因为这是浪费时间。</p><p id="d421" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">同样，OR要求表达式中只有一边的计算结果为true。因此，如果左手边的计算结果为true，它就不会检查右手边。</p><p id="cd04" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这种短路对于给涉及对象的表达式增加一些安全性是有用的。例如，考虑以下函数:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f896" class="md jz iq lz b gy me mf l mg mh">function logIfAdult(person) {<br/>  if(person.age &gt;= 18) {<br/>    console.log("Person is an adult");<br/>  }<br/>}</span></pre><p id="ed2d" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这种实现的问题是您不能保证person对象不为空。如果使用null person运行这个函数，将会得到下面的错误:<code class="fe mp mq mr lz b">Uncaught TypeError: Cannot read property 'age' of null</code>。</p><p id="ca1b" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">由于短路评估，我们可以像这样增加一些安全性:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9cbb" class="md jz iq lz b gy me mf l mg mh">function logIfAdult(person) {<br/>  if(person &amp;&amp; person.age &gt;= 18) {<br/>    console.log("Person is an adult");<br/>  }<br/>}</span></pre><p id="fff2" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这是因为，如果person为null，它将计算为false(这是因为null是一个“false”值，如果这个概念对您来说是新的，<a class="ae mo" href="https://samwalpole.com/javascript-short-circuit-assignment" rel="noopener ugc nofollow" target="_blank">也请阅读这篇文章</a>)，整个表达式将短路。只有当person不为null时，表达式才会继续检查表达式的右边，这时我们知道检查是安全的，不会出现任何错误。</p><p id="5308" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们也可以在分配变量时利用这种短路。例如，考虑以下函数:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3246" class="md jz iq lz b gy me mf l mg mh">function logName(person) {<br/>  let name = person &amp;&amp; person.name;<br/>  console.log(name);<br/>}</span><span id="bcea" class="md jz iq lz b gy mi mf l mg mh">logName({ name: 'Sam' });<br/>// logs 'Sam'</span><span id="de47" class="md jz iq lz b gy mi mf l mg mh">logName(null)<br/>// logs 'null'</span></pre><p id="4305" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">这里发生了什么事？在第一个例子中，我们向函数传递了一个有效的person对象。因为person对象不为空，所以AND操作符移到表达式的右边，并将<a class="ae mo" href="http://person.name" rel="noopener ugc nofollow" target="_blank"> person.name </a>的值赋给name变量。在第二个示例中，person为null，因此表达式短路并向name变量返回null。</p><p id="eedf" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们可以进一步扩展它，记录一个默认名称，而不仅仅是null。这次我们使用OR操作符，所以如果person对象为空，我们将只使用默认值。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="805d" class="md jz iq lz b gy me mf l mg mh">function logName(person) {<br/>  let name = person &amp;&amp; person.name || 'Default Name';<br/>  console.log(name);<br/>}</span><span id="bf39" class="md jz iq lz b gy mi mf l mg mh">logName({ name: 'Sam' });<br/>// logs 'Sam'</span><span id="6ba3" class="md jz iq lz b gy mi mf l mg mh">logName(null)<br/>// logs 'Default Name'</span></pre><h1 id="62f1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.可选的链接和无效合并运算符</h1><p id="170c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">短路计算和赋值是如此普遍，以至于JavaScript中加入了新的更简洁的语法来达到同样的目的。这些是可选的链接和无效合并操作符。我已经决定包括短路和可选的链接/空合并，因为在撰写本文时，后者是较新的特性，可能不完全兼容旧的浏览器。</p><p id="8588" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">可选的链接运算符(？。)允许您深入到对象中，而不必显式地检查对象是否为空。如果对象为空，那么表达式将返回undefined，而不是抛出一个错误。例如，使用可选链接，上面的logIfAdult函数可以重写为:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f7ce" class="md jz iq lz b gy me mf l mg mh">function logIfAdult(person) {<br/>  if(person?.age &gt;= 18) {<br/>    console.log("Person is an adult");<br/>  }<br/>}</span></pre><p id="24f3" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">零化合并算子(？？)用于在表达式左侧的值为空时返回默认值。这样，它取代了上面logName函数中OR运算符的功能:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3f9b" class="md jz iq lz b gy me mf l mg mh">function logName(person) {<br/>  let name = person?.name ?? 'Default Name';<br/>  console.log(name);<br/>}</span></pre><h1 id="bdbb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.命名回调函数</h1><p id="5b3e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">匿名函数真的很有用——你可以在任何时候任何地方声明它们，如果你只需要一次性的函数，那就太好了。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e59f" class="md jz iq lz b gy me mf l mg mh">let people = [<br/>  {<br/>    id: 1,<br/>    firstName: 'Sam',<br/>    lastName: 'Walpole',<br/>  },<br/>  ...<br/>];</span><span id="71d6" class="md jz iq lz b gy mi mf l mg mh">let viewModels = people.map(p =&gt; ({<br/>  id: p.id,<br/>  name: `${p.firstName} ${p.lastName}`,<br/>}));<br/>// viewModels = [{ id: 1, name: 'Sam Walpole' }]</span></pre><p id="6b19" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">但是，因为函数没有名字，所以您将它留给未来的开发人员来解决回调函数中的代码做什么——这在这里是可以的，但是在更长、更复杂的函数中，这可能会浪费不必要的时间。通过首先将函数声明为命名函数，您可以立即使代码更具可读性，并为未来的开发人员提供一些关于函数意图的线索。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f578" class="md jz iq lz b gy me mf l mg mh">let people = [<br/>  {<br/>    id: 1,<br/>    firstName: 'Sam',<br/>    lastName: 'Walpole',<br/>  },<br/>  ...<br/>];</span><span id="a3a3" class="md jz iq lz b gy mi mf l mg mh">let toViewModel = p =&gt; ({<br/>  id: p.id,<br/>  name: `${p.firstName} ${p.lastName}`,<br/>});</span><span id="05d3" class="md jz iq lz b gy mi mf l mg mh">let viewModels = people.map(toViewModel);<br/>// viewModels = [{ id: 1, name: 'Sam Walpole' }]</span></pre><h1 id="75d2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.枚举/词典</h1><p id="f662" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">枚举是将一组常数值存储为类型的一种方式。大多数语言都有对枚举的内置支持，但是在JavaScript中，我们必须使用对象自己构建它们。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0e1e" class="md jz iq lz b gy me mf l mg mh">const Color = {<br/>  RED: 'RED',<br/>  GREEN: 'GREEN',<br/>  BLUE: 'BLUE',<br/>};</span><span id="31c3" class="md jz iq lz b gy mi mf l mg mh">let redCar = {<br/>  make: 'Ferrari',<br/>  model: '812',<br/>  color: Color.RED,<br/>};</span><span id="41a6" class="md jz iq lz b gy mi mf l mg mh">let greenCar = {<br/>  make: 'Aston Martin',<br/>  model: 'Vantage',<br/>  color: Color.GREEN, <br/>};</span></pre><p id="07cb" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">枚举与用于流控制的switch语句很好地配对:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ec6f" class="md jz iq lz b gy me mf l mg mh">function getHexColor(car) {<br/>  switch (car.color) {<br/>    case Color.RED:<br/>      return '#ff0000';<br/>    case Color.GREEN:<br/>      return '#00ff00';<br/>    case Color.BLUE:<br/>      return '#0000ff';<br/>  }<br/>}</span></pre><p id="9099" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">然而，有时这可能有点冗长。我们可以使用字典来代替switch语句。JavaScript中的字典的声明方式与枚举非常相似，但是从概念上讲，它们有不同的用途。枚举是一组常量值，字典是键/值对的集合。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2501" class="md jz iq lz b gy me mf l mg mh">function getHexColor(car) {<br/>  let hexColors= {<br/>    [Color.RED]: '#ff0000',<br/>    [Color.GREEN]: '#00ff00',<br/>    [Color.BLUE]: '#0000ff',<br/>  };</span><span id="9ce6" class="md jz iq lz b gy mi mf l mg mh">return hexColors[car.color];<br/>}</span></pre><p id="2afa" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">在上面的例子中，我们已经不需要switch语句了，因为我们已经创建了一个字典，用enum值作为键，用十六进制颜色作为值。通过去除switch语句中的所有混乱，我相信这会使代码更容易阅读。</p><h1 id="a7f4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="1067" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我提供了5个我经常在JavaScript中使用的技巧，让我的代码更加简洁易读。我希望您已经发现它们是有帮助的，并将找到机会在您自己的代码中使用它们。</p><p id="f3c3" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我发布的大部分内容都是关于全栈的。NET和Vue web开发。为了确保你不会错过任何帖子，请关注这个博客并<a class="ae mo" href="https://samwalpole.com" rel="noopener ugc nofollow" target="_blank">订阅我的简讯</a>。如果你觉得这篇文章有帮助，请喜欢它并分享它。你也可以在<a class="ae mo" href="https://twitter.com/dr_sam_walpole" rel="noopener ugc nofollow" target="_blank">推特</a>上找到我。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="5541" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">【https://samwalpole.com】最初发表于<a class="ae mo" href="https://samwalpole.com/my-top-5-javascript-tips-and-tricks-for-writing-cleaner-code" rel="noopener ugc nofollow" target="_blank"><em class="mz"/></a><em class="mz">。</em></p></div></div>    
</body>
</html>