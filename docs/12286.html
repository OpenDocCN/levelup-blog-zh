<html>
<head>
<title>Javascript and Working With Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript和使用对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-and-working-with-objects-4f90838eaabb?source=collection_archive---------10-----------------------#2022-05-29">https://levelup.gitconnected.com/javascript-and-working-with-objects-4f90838eaabb?source=collection_archive---------10-----------------------#2022-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="79c6" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Javascript工程:背后的科学</h2><div class=""/><div class=""><h2 id="6d29" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">每个程序员都应该知道的JavaScript概念</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4a7a914196d97adddbdbcd314b65e00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLVS5ODB_6x0BLXeUKz8mQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@chuttersnap" rel="noopener ugc nofollow" target="_blank"> Chuttersnap </a>拍摄</figcaption></figure><p id="d552" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">除了我之前的两篇关于Javascript的文章，我还想谈谈对象和使用对象的问题，这不仅是Javascript开发人员，也是大多数语言开发人员都必须处理的问题。</p><div class="mb mc gp gr md me"><a href="https://blog.devgenius.io/javascript-concepts-every-programmer-should-know-v1-0-2-cc87f541e05" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ja gy z fp mj fr fs mk fu fw iz bi translated">Javascript工程:背后的科学</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">每个程序员和工程师都应该知道的Javascript概念背后的科学故事</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">blog.devgenius.io</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms ky me"/></div></div></a></div><div class="mb mc gp gr md me"><a href="https://javascript.plainenglish.io/javascript-concepts-every-programmer-should-know-d04731fe7a7c" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ja gy z fp mj fr fs mk fu fw iz bi translated">每个程序员都应该知道的JavaScript概念</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">了解这些JavaScript概念可以让你的程序员生活更轻松。</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mn l"><div class="mt l mp mq mr mn ms ky me"/></div></div></a></div></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="aa33" class="nb nc iq bd nd ne nf ng nh ni nj nk nl kf nm kg nn ki no kj np kl nq km nr ns bi translated">目标</h1><p id="a415" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">Javascript围绕着一个简单的基于对象的范例。我们都知道对象和类，我们可能整个职业生涯都在使用它们。</p><p id="5020" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对象是一组属性，属性是该对象的属性。和<em class="ny">美国人类</em>很有可比性。我们有自己的属性，无论是名、姓、出生日期，还是身高和体重。</p><p id="4cc6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对象和面向对象编程实际上是受到现实生活中对象的启发。</p><p id="4ccb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">以下示例介绍了如何处理对象，从简单到更高级的情况。</p><h1 id="a44f" class="nb nc iq bd nd ne nz ng nh ni oa nk nl kf ob kg nn ki oc kj np kl od km nr ns bi translated">实例化对象的方法</h1><p id="346f" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">实例化对象的常用方法如下</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="4ff3" class="oj nc iq of b gy ok ol l om on"># Create new object<br/>const site = {<br/>    name: "Medium",<br/>    domain: "medium.com",<br/>    type: "Writing Platform"<br/>}</span></pre><p id="8426" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但上面是一个对象初始化器，用花括号<code class="fe oo op oq of b">{}</code>括起来的逗号分隔的属性列表，也是较短的语法。更严格的方法如下。</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="e25b" class="oj nc iq of b gy ok ol l om on"># Create new object<br/>const site = new Object();<br/>site.name = "Medium";<br/>site.domain = "medium.com";<br/>site.type = "Writing Platform";</span></pre><p id="df90" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了设置属性本身，您可以使用该属性的键名，或者使用括号<code class="fe oo op oq of b">[]</code>来分配它</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="8234" class="oj nc iq of b gy ok ol l om on">site['name'] = "Medium";</span></pre><p id="c42c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用这种方法的好处是可以使用变量设置属性值。</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="4dbb" class="oj nc iq of b gy ok ol l om on">const propertyName = "name";<br/>const propertyValue = "Medium";<br/>site[propertyName] = propertyValue;</span></pre><p id="9ba7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当我们使用集合、映射列表、对象、类型等时，知道并记住这一点可能非常有用。</p><h1 id="5a2b" class="nb nc iq bd nd ne nz ng nh ni oa nk nl kf ob kg nn ki oc kj np kl od km nr ns bi translated">班级</h1><p id="f0cb" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">处理对象离不开处理类。</p><p id="a5f3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">你很可能知道类是如何工作的，所以简而言之——它是对象的模板，定义了实例的属性和功能。一个对象将拥有。</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="dcbc" class="oj nc iq of b gy ok ol l om on"># Classes<br/>class Website {<br/>    constructor(name, domain, type){<br/>        this.name = name;<br/>        this.domain = domain;<br/>        this.type = type;<br/>    }</span><span id="62b4" class="oj nc iq of b gy or ol l om on">    // Getter<br/>    get url() {<br/>        return `https://www.${this.domain}`;<br/>    }</span><span id="19d2" class="oj nc iq of b gy or ol l om on">    // Method<br/>    sayHello() {<br/>        return `Hello from ${this.name}!`;<br/>    }<br/>}</span><span id="796a" class="oj nc iq of b gy or ol l om on">const medium = new Website("Medium",<br/>    "medium.com",<br/>    "Writing Platform");</span><span id="7d2d" class="oj nc iq of b gy or ol l om on">const url = medium.url;<br/>const greeting = medium.sayHello();</span></pre><p id="3f31" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上面的例子中，<code class="fe oo op oq of b">constructor</code>本身定义了三个字段。这与事先自行定义字段是一样的。</p><p id="cace" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然而，有趣的是使用了被定义为<code class="fe oo op oq of b">get</code>函数的<code class="fe oo op oq of b">getters</code>。它不像常规函数那样可调用，但行为像一个属性。</p><h1 id="b5f3" class="nb nc iq bd nd ne nz ng nh ni oa nk nl kf ob kg nn ki oc kj np kl od km nr ns bi translated">菲尔茨</h1><p id="58c9" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">字段或属性实际上可以在构造函数之前声明。</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="a5f4" class="oj nc iq of b gy ok ol l om on"># Fields and Private Fields<br/>class Website {<br/>    name;<br/>    domain;<br/>    #type;<br/>    <br/>    constructor(name, domain, type){<br/>        this.name = name;<br/>        this.domain = domain;<br/>        this.#type = type;<br/>    }<br/>}</span><span id="3fb8" class="oj nc iq of b gy or ol l om on">const medium = new Website("Medium",<br/>    "medium.com",<br/>    "Writing Platform");</span></pre><p id="8b5d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意如何使用符号<code class="fe oo op oq of b">#</code>来声明私有字段。该字段不能在类外公开访问。</p><h1 id="abf0" class="nb nc iq bd nd ne nz ng nh ni oa nk nl kf ob kg nn ki oc kj np kl od km nr ns bi translated">生成器和产出结果</h1><p id="2917" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">生成器和关键字<code class="fe oo op oq of b">yield</code>是Javascript中相对较新的东西。<code class="fe oo op oq of b">yield</code>关键字让我们聚合，<em class="ny">从一个循环中产生</em>结果——这在其他语言中并不常见，但在C#中已经存在很长时间了。</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="603a" class="oj nc iq of b gy ok ol l om on"># Generator and Yielding results<br/>class Website {<br/>    constructor(tabs) {<br/>        this.tabs = tabs;<br/>    }</span><span id="9adb" class="oj nc iq of b gy or ol l om on">*getTabs() {<br/>        for(const tab of this.tabs){<br/>            yield tab;<br/>    }<br/>}<br/><br/>const medium = new Website(["Home",<br/>    "Recent","About Us",<br/>    "Register"]);</span><span id="fd13" class="oj nc iq of b gy or ol l om on">const generator = medium.getTabs();<br/>const tabs = [...generator];</span></pre><p id="b3d0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了从生成器中获取值，我们实际上需要<em class="ny">扩展</em>它，因为函数本身返回类型，而不是值。</p><h1 id="ca9c" class="nb nc iq bd nd ne nz ng nh ni oa nk nl kf ob kg nn ki oc kj np kl od km nr ns bi translated">扩展类</h1><p id="228f" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">类也可以用Javascript扩展。</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="c365" class="oj nc iq of b gy ok ol l om on"># Extending Classes<br/>class BaseWebsite {<br/>    constructor(name, domain, type){<br/>        this.name = name;<br/>        this.domain = domain;<br/>        this.type = type;<br/>    }<br/> <br/>    sayHello() {<br/>        return "Hello!";<br/>    }<br/>}</span><span id="6690" class="oj nc iq of b gy or ol l om on">class HttpsWebsite extends BaseWebsite {<br/>    constructor(name, domain, type){<br/>        super(name, domain, type);<br/>        this.scheme = 'https';<br/>    }<br/>    <br/>    sayHello() {<br/>        let superHello = super.sayHello();<br/>        return `${superHello} from ${this.name}`;<br/>    }<br/>}</span><span id="66ae" class="oj nc iq of b gy or ol l om on">const medium = new HttpsWebsite("Medium",<br/>    "medium.com",<br/>    "Writing Platform");<br/>    <br/>const hello = medium.sayHello();</span></pre><p id="2195" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">利用<code class="fe oo op oq of b">extend</code>和<code class="fe oo op oq of b">super</code>关键字，我们能够扩展现有类的属性和方法。</p><h1 id="4dd4" class="nb nc iq bd nd ne nz ng nh ni oa nk nl kf ob kg nn ki oc kj np kl od km nr ns bi translated">基类方法调用</h1><p id="e3f5" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">在前面提到的例子中，注意我们如何声明基本函数<code class="fe oo op oq of b">sayHello</code>，覆盖它，但是仍然使用关键字<code class="fe oo op oq of b">super</code>来使用它。在<code class="fe oo op oq of b">constructor</code>中也是如此。</p><h1 id="b2d3" class="nb nc iq bd nd ne nz ng nh ni oa nk nl kf ob kg nn ki oc kj np kl od km nr ns bi translated">混合食品</h1><p id="6623" class="pw-post-body-paragraph lf lg iq lh b li nt ka lk ll nu kd ln lo nv lq lr ls nw lu lv lw nx ly lz ma ij bi translated">多重继承在Javascript中是不可能的，即。类最多只能扩展一个超类。继承本身发生在运行时，Javascript搜索对象的原型链，以便找到它声明的属性和值。</p><p id="93da" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然而，我们可以利用和使用Mix-in来实现这一点。考虑下面的例子</p><pre class="kp kq kr ks gt oe of og oh aw oi bi"><span id="cd9c" class="oj nc iq of b gy ok ol l om on"># Mixins<br/>let WalkMixin = superclass =&gt; class extends superclass {<br/>  walk() {<br/>      return "I'm walking!";<br/>  }<br/>};</span><span id="f023" class="oj nc iq of b gy or ol l om on">let FlyMixin = superclass =&gt; class extends superclass {<br/>  fly() {<br/>      return "I'm flying!";<br/>  }<br/>};</span><span id="5c78" class="oj nc iq of b gy or ol l om on">class BaseClass {}<br/>class SampleClass extends WalkMixin(FlyMixin(BaseClass)) {};<br/>const sample = new SampleClass();</span><span id="2cde" class="oj nc iq of b gy or ol l om on">console.log(sample.walk());<br/>console.log(sample.fly());</span></pre><p id="1001" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您检查实例<code class="fe oo op oq of b">sample</code>，您会注意到它的原型链包含了上述混合中定义的两种方法。</p><p id="c025" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">注意，这不是Javascript特性，而更像是一种变通方法。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="81b5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我希望这篇文章对你有用，让你愉快。这是我最近开始写的关于Javascript概念的系列文章的一部分，所以请收听！如果你喜欢它的内容，点击follow，和我一起踏上研究和撰写更多关于Javascript背后的科学和工程的旅程。</p><p id="5139" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">感谢您的阅读！🎉</p></div></div>    
</body>
</html>