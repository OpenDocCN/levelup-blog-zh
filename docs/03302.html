<html>
<head>
<title>Node.js Best Practices — Production and Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—生产和安全</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-best-practices-production-and-security-bef27571cc97?source=collection_archive---------3-----------------------#2020-05-01">https://levelup.gitconnected.com/node-js-best-practices-production-and-security-bef27571cc97?source=collection_archive---------3-----------------------#2020-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8b743a27073ef2673950a372b010187d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_-LQa1eoAogzJtFF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">国际国王教会在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1a02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是编写应用程序的流行运行时。这些应用程序通常是许多人使用的生产质量应用程序。为了使维护它们变得更容易，我们必须为人们设定一些准则来遵循。</p><p id="2798" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究节点应用程序的部署和安全相关的最佳实践。</p><h1 id="be53" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置NODE _ ENV =生产</h1><p id="c5aa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该为生产环境设置<code class="fe mh mi mj mk b">NODE_ENV</code>到<code class="fe mh mi mj mk b">production</code>，为开发设置<code class="fe mh mi mj mk b">development</code>。将<code class="fe mh mi mj mk b">NODE_ENV</code>设置为<code class="fe mh mi mj mk b">production</code>会激活与生产相关的优化。</p><p id="5d73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">忽略这一属性可能会显著降低性能。例如，在没有将<code class="fe mh mi mj mk b">NODE_ENV</code>设置为<code class="fe mh mi mj mk b">production</code>的情况下使用Express会使其变慢3倍。</p><p id="2da9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Express中，如果<code class="fe mh mi mj mk b">NODE_ENV</code>是<code class="fe mh mi mj mk b">production</code>，它将缓存视图模板和从CSS扩展生成的CSS，并且它还将生成不太详细的错误消息，以防止它们被公开。</p><h1 id="9c54" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设计自动化、原子化和零停机部署</h1><p id="d456" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">部署需要自动化，这样一旦自动化部署管道建立起来，我们就不必担心它了。这样，我们就不必担心遇到人为错误导致的问题。手动部署也比自动部署慢得多。</p><p id="cb4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的是，我们可以用Docker创建自动化的沙盒环境，这样每个应用程序都可以在自己的环境中运行。这解决了许多运行时、包和环境变量冲突的问题。</p><p id="346e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们每次都必须手动部署，这可能会导致问题。此外，我们必须观察它，以确保它已经完成，所以人们不太可能部署应用程序，因为这是一个如此痛苦和容易出错的过程。</p><h1 id="666e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Node.js的LTS版本</h1><p id="1fc2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Node的长期服务(LTS)版本比非LTS Node版本受支持的时间更长。他们不断收到重要的错误修复、安全更新和性能改进。非LTS版本仅在其更新版本发布后的几个月内受支持。</p><p id="f893" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，为了避免一直升级Node，我们应该使用LTS版本。</p><h1 id="fe81" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">拥抱Linter安全规则</h1><p id="b937" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">像<code class="fe mh mi mj mk b">eslint-plugin-security</code>这样的ESLint插件会检查我们代码中的安全问题，这样我们就可以尽早修复它们。这有助于捕捉安全弱点，如<code class="fe mh mi mj mk b">eval</code>、调用子进程或导入带有用户输入字符串的模块。</p><p id="cc06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了它，我们可以在提交或推送代码之前进行检查。这样，我们团队中的每个人都会始终遵循安全最佳实践。</p><h1 id="e3db" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用中间件限制并发请求</h1><p id="6ca1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">拒绝服务(DOS)攻击非常流行，也很容易实施。因此，我们应该使用负载平衡、云防火墙、反向代理或应用程序包等服务来实现速率限制。</p><p id="9e71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在我们的应用端点实现速率限制，我们可以使用像<code class="fe mh mi mj mk b">rate-limiter-flexible</code>或<code class="fe mh mi mj mk b">express-rate-limit</code>这样的包。</p><p id="8208" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用下面的<code class="fe mh mi mj mk b">express-rate-limit</code>为我们的Express应用程序中的所有端点添加速率限制:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a6e5" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const rateLimit = require("express-rate-limit");</span><span id="79a0" class="mt lf it mk b gy my mv l mw mx">const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>const limiter = rateLimit({<br/>  windowMs: 15 * 60 * 1000,<br/>  max: 100<br/>});</span><span id="8fe2" class="mt lf it mk b gy my mv l mw mx">app.use(limiter);</span><span id="3fd8" class="mt lf it mk b gy my mv l mw mx">app.get('/', (req, res, next) =&gt; {<br/>  res.send('hello');<br/>});</span><span id="73f4" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));<br/>module.exports = app;</span></pre><p id="7cea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们只需添加一个简单的中间件来防止对我们的应用程序的拒绝服务攻击。因此，对于任何规模的应用程序，我们都应该从一开始就这样做。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/82160d77cff27717f1146154868eacc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b7Db5tQ7XtSfxB_a"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@marliesebrandsma?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">mar liese stree land</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="5988" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从配置文件中提取机密或使用包对其进行加密</h1><p id="e3ce" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">配置文件通常包含大多数人不应该看到的秘密数据。因此，我们不应该将它们存储在源代码中。相反，我们必须确保像Vault、Docker secrets这样的秘密管理系统，或者使用环境变量。</p><p id="f5f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该有预提交或推送挂钩来防止意外地将秘密提交给代码。源代码管理可能会被错误地公开，这将秘密暴露给其他不应该看到它们的人。</p><p id="00bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用<code class="fe mh mi mj mk b">dotenv</code>包来存储节点应用程序的环境变量。为了使用它，我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a7fd" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>require('dotenv').config();</span><span id="73ba" class="mt lf it mk b gy my mv l mw mx">const app = express();</span><span id="a55b" class="mt lf it mk b gy my mv l mw mx">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="6c7d" class="mt lf it mk b gy my mv l mw mx">app.get('/', (req, res) =&gt; {<br/>  res.send(process.env.DB_HOST);<br/>});</span><span id="ac8b" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="1af7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鉴于我们的<code class="fe mh mi mj mk b">.env</code>文件具有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="155b" class="mt lf it mk b gy mu mv l mw mx">DB_HOST=foo</span></pre><p id="9702" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一次我们跑了:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c326" class="mt lf it mk b gy mu mv l mw mx">require('dotenv').config();</span></pre><p id="da7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mh mi mj mk b">process.env.DB_HOST</code>返回<code class="fe mh mi mj mk b">'foo'</code>，所以如果我们转到<code class="fe mh mi mj mk b">/</code>，我们会看到<code class="fe mh mi mj mk b">foo</code>显示在屏幕上。</p><h1 id="ddfd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="bc9b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该确保<code class="fe mh mi mj mk b">NODE_ENV</code>被设置为<code class="fe mh mi mj mk b">production</code>，这样优化就可以应用于像Express这样的包。</p><p id="db68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何部署都应该是自动化的。另外，Node.js应该是LTS版本。此外，我们应该检查代码中的安全漏洞，并对API端点进行速率限制，以防止拒绝服务攻击。</p><p id="b5d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们应该在代码中保留秘密。</p></div></div>    
</body>
</html>