<html>
<head>
<title>Learning Robot Operative System [ROS] on the fly.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态学习机器人操作系统。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-robotics-operative-system-ffee4366a813?source=collection_archive---------4-----------------------#2020-01-03">https://levelup.gitconnected.com/learning-robotics-operative-system-ffee4366a813?source=collection_archive---------4-----------------------#2020-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8d9052a5d5be1594a1e2e2ef08789dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fsx-_zzA3Qs_G6CWXUkMTw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由来自<a class="ae kc" href="https://www.pexels.com/photo/grey-quadcopter-drone-724921/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kc" href="https://www.pexels.com/@pok-rie-33563?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pok Rie </a>拍摄</figcaption></figure><p id="3569" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几个月前，给了我一个具体的任务:学习ROS，5天内完成一个挑战。这是一个简短的解释，说明了我让代码工作的过程，以及我在这个过程中对ROS的了解。<br/>如果你正在寻找一种能够亲自动手编写ROS代码的方法，你来对地方了。让我们开始吃吧。</p><blockquote class="lb lc ld"><p id="15af" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">文末gitlab repo链接。要了解我是如何做到这一点的，请阅读下面的内容。</p></blockquote><h1 id="43bf" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">目录</h1><ul class=""><li id="819f" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">挑战</li><li id="a48b" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">一点理论</li><li id="27d1" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">关键概念</li><li id="4805" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">第一步</li><li id="558e" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">挑战:开始行动</li><li id="97ac" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">臭名昭著的“目标”方法</li><li id="9a8a" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">服务</li><li id="83b9" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">用户界面</li><li id="fa5e" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">结论和链接</li></ul><h1 id="4bef" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">挑战</h1><ul class=""><li id="8ea0" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated">C++中使<em class="le"> turtlesim </em>移动到目标[x，y]的ROS节点。</li><li id="7b98" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">目标将以geometry_msgs/Pose2D格式发布到主题中。</li><li id="52af" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">必须使用相同的Pose2D格式提供海龟姿势的定期反馈。</li><li id="81c5" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">可以使用服务暂停、恢复或重置运动。</li><li id="f1b8" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">创建一个RQT Python UI插件来读取一个JSON文件，该文件包含机器人必须遵循的点的列表。</li></ul><blockquote class="lb lc ld"><p id="3cec" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">必须使用装有Ubuntu 16.04的ROS Kinetic。</p></blockquote><p id="a7b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么首先我们从<a class="ae kc" href="http://wiki.ros.org/ROS/Tutorials" rel="noopener ugc nofollow" target="_blank">文档</a>说起。这里的是一个关于如何在Ubuntu 16.04中安装ROS的链接，但是<strong class="kf ir">要注意:它对Anaconda并不友好。因此，如果你像我一样安装了Anaconda，我建议你创建一个新用户来安装ROS。</strong></p><p id="7f5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果安装成功，您应该能够在一个新的终端中运行<em class="le"> roscore </em>，并打印出以<em class="le">started core service[/rosout]</em>结尾的内容。从现在开始，我假设ROS已经安装好并准备好了。</p><p id="1885" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装后，你需要创建一个<a class="ae kc" href="http://wiki.ros.org/ROS/Tutorials/InstallingandConfiguringROSEnvironment" rel="noopener ugc nofollow" target="_blank"> ROS工作空间</a>，以及一个<a class="ae kc" href="http://wiki.ros.org/ROS/Tutorials/CreatingPackage" rel="noopener ugc nofollow" target="_blank"> ROS包</a>。这些教程非常容易理解，并且包含了你需要的所有信息，所以我不会过多地讨论它是如何完成的。我将推荐您使用柳絮工作空间，因为本教程中的所有内容都是用它完成的。</p><h1 id="8ccd" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">一点理论</h1><p id="c672" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">好了，现在怎么办？你装的没错，但是什么<em class="le"> </em> <strong class="kf ir"> <em class="le">是</em> </strong> <em class="le"> </em> ROS？你可能已经知道，ROS是机器人操作系统的缩写；基本上是什么在操纵机器人。如果你熟悉实时操作系统[RTOS](一个为嵌入式设备设计的轻量级实时操作系统)的概念，那么你可能会认为ROS(目前)是类似的东西，但运行在PC上。实际上，这要复杂一点，但这是一个相似的概念。对于那些不熟悉RTOS的人来说，您的ROS应用程序将有一个或多个节点，它们可以与其他节点通信。这可以通过发布或订阅主题或者通过使用或提供服务来实现。这些节点将运行我们应用程序的不同任务。</p><h1 id="b56d" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">关键概念</h1><ul class=""><li id="441f" class="mg mh iq kf b kg mi kk mj ko mk ks ml kw mm la mn mo mp mq bi translated"><a class="ae kc" href="http://wiki.ros.org/ROS/Tutorials/UnderstandingNodes" rel="noopener ugc nofollow" target="_blank">节点</a>:节点是使用ROS与其他节点通信的可执行文件。</li><li id="a391" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="http://wiki.ros.org/Topics" rel="noopener ugc nofollow" target="_blank">主题</a>:节点可以<em class="le">向主题发布</em>消息，也可以<em class="le">向主题订阅</em>接收消息。</li><li id="2f0e" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">Messages:订阅或发布主题时使用的ROS数据类型。</li><li id="faca" class="mg mh iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><a class="ae kc" href="http://wiki.ros.org/ROS/Tutorials/UnderstandingServicesParams" rel="noopener ugc nofollow" target="_blank">服务</a>:节点可以相互通信的另一种方式。服务允许节点发送<em class="le">请求</em>并接收<em class="le">响应</em>。</li></ul><h1 id="2655" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第一步</h1><p id="5823" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">为了让turtlesim <em class="le"> </em>移动到某个目标，我需要运行它。在上面<em class="le">关键概念</em>下链接的节点教程中，它向您展示了如何运行一个节点，它使用的例子正是默认情况下应该安装的turtlesim节点。所以如果你跑:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3410" class="ni lj iq ne b gy nj nk l nl nm">rosrun turtlesim turtlesim_node</span></pre><p id="127d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">turtlesim模拟应该出现在屏幕上。非常好。对我来说，下一步是复制C++发布者和订阅者代码。我建议你也这样做，让它工作，并了解节点如何通信。</p><p id="39fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，我创建了自己的代码来完成这两项任务，它会说话，也会听。我把它命名为Controller，并使用OOP来开发它。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="15f0" class="ni lj iq ne b gy nj nk l nl nm">#include "ros/ros.h"<br/>#include "std_msgs/String.h"<br/>#include &lt;sstream&gt;</span><span id="909d" class="ni lj iq ne b gy nn nk l nl nm">class Controller {<br/> private:<br/>  ros::NodeHandle n;<br/>  ros::Publisher pub;<br/>  ros::Subscriber sub;<br/> <br/> public:<br/>  Controller() {<br/>   sub = n.subscribe("chatter", 1000, &amp;Controller::callback, this);<br/>   pub = n.advertise&lt;std_msgs::String&gt;("feedback", 1000);<br/>  }</span><span id="4dc3" class="ni lj iq ne b gy nn nk l nl nm">void callback(const std_msgs::String::ConstPtr &amp;msg) {<br/>   std_msgs::String pub_str;<br/>   std::stringstream ss;<br/>   ROS_INFO("Controller heard: [%s]", msg-&gt;data.c_str());   <br/>   ss &lt;&lt; "position set to: " &lt;&lt; msg-&gt;data.c_str();<br/>   pub_str.data = ss.str();</span><span id="1e28" class="ni lj iq ne b gy nn nk l nl nm">   std::cout &lt;&lt; pub_str.data.c_str() &lt;&lt; std::endl;</span><span id="78b1" class="ni lj iq ne b gy nn nk l nl nm">   pub.publish(pub_str);<br/>   ros::spinOnce();<br/>  }</span><span id="b8c3" class="ni lj iq ne b gy nn nk l nl nm">};<br/>int main(int argc, char **argv)<br/>{<br/> ros::init(argc, argv, "Controller");<br/> Controller ctrl;<br/> ros::spin();</span><span id="5592" class="ni lj iq ne b gy nn nk l nl nm">return 0;<br/>}</span></pre><p id="2085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它基本上监听一个<em class="le"> chatter </em>主题，并将它收到的所有内容复制到一个<em class="le">反馈</em>主题。如果您修改原始教程，使其与<em class="le"> chatter </em>对话，并听取<em class="le">的反馈</em>，那么您可以轻松测试此代码。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="8747" class="li lj iq bd lk ll nv ln lo lp nw lr ls lt nx lv lw lx ny lz ma mb nz md me mf bi translated">挑战:开始行动</h1><p id="90af" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">既然你已经了解了ROS的基础知识，并且知道了如何编写一些代码，那么让我们从挑战开始吧。或者至少是它的第一部分。您需要能够与turtlesim通信，所以让我们来看看如何实现。</p><blockquote class="lb lc ld"><p id="d689" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">提示:您需要使用多个终端。</p></blockquote><p id="dab8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="586c" class="ni lj iq ne b gy nj nk l nl nm">rosrun turtlesim turtlesim_node</span></pre><p id="0d03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦它启动并运行，您就可以知道它在听哪些主题:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="d71e" class="ni lj iq ne b gy nj nk l nl nm">rostopic list</span></pre><p id="246e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将列出当前可用的所有主题。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="fff1" class="ni lj iq ne b gy nj nk l nl nm">/rosout<br/>/rosout_agg<br/>/turtle1/cmd_vel<br/>/turtle1/color_sensor<br/>/turtle1/pose</span></pre><p id="bc19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似这样的东西应该打印出来。你要找的是以/turtle1开头的。要获得关于每台机器的更多信息，请运行:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="2e15" class="ni lj iq ne b gy nj nk l nl nm">rostopic info /topic</span></pre><p id="eaab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果您对turtlesim的每个主题运行上面的命令，您将会看到/cmd_vel实际上监听了<em class="le"> geometry_msgs:Twist </em>消息。从您的节点您需要做的就是<em class="le">使用特定类型的<em class="le">消息</em>发布</em>到那个<em class="le">主题</em>。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="7844" class="ni lj iq ne b gy nj nk l nl nm">#include "ros/ros.h"<br/>#include "geometry_msgs/Twist.h"<br/>#include "geometry_msgs/Pose2D.h"</span><span id="d70a" class="ni lj iq ne b gy nn nk l nl nm">class Robot {<br/> private:<br/>  ros::NodeHandle n;<br/>  ros::Publisher vel_pub;<br/>  ros::Subscriber pose_sub;<br/>  ros::Publisher feedback_pub;<br/>  ros::Subscriber messages_sub;</span><span id="3785" class="ni lj iq ne b gy nn nk l nl nm"> public:<br/>  turtlesim::Pose goal_pose;<br/>  turtlesim::Pose aux_pose;<br/>  geometry_msgs::Pose2D feedback_msg;<br/>  geometry_msgs::Twist vel_msg;</span><span id="2cb5" class="ni lj iq ne b gy nn nk l nl nm">Robot() {<br/>   // Advertise to turtlesim<br/>   vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;("/turtle1/cmd_vel", 10);<br/>   // Subscribe to new directions<br/>   messages_sub = n.subscribe("directions", 10, &amp;Robot::dirCallback, this);</span><span id="5cb6" class="ni lj iq ne b gy nn nk l nl nm">   // Get turtlesim position<br/>   pose_sub = n.subscribe("/turtle1/pose", 10, &amp;Robot::poseCallback, this);<br/>   // Send feedback position<br/>   feedback_pub = n.advertise&lt;geometry_msgs::Pose2D&gt;("feedback", 10);<br/>}</span></pre><blockquote class="lb lc ld"><p id="814a" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">注意，以上只是部分代码，强调的是我提到的改动。</p></blockquote><p id="c48b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我最初采取的方法。所以现在，每次通过“<em class="le">方向”</em>到达一个新的目标，你都需要告诉机器人移动。<br/>这是您需要实现“<em class="le">to goal”</em>方法的部分。为此，你需要了解一些基本的数学知识，以及一些控制系统的背景知识。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/acca4487ea6f6f2b691a39ff1045fb3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w39ziyQ9Ogw9Q7nD69Wr4g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">当所有节点都在运行时，它应该是什么样子</figcaption></figure><h1 id="fb27" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">臭名昭著的“目标”方法</h1><p id="d54b" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">事不宜迟:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3e1e" class="ni lj iq ne b gy nj nk l nl nm">void toGoal(turtlesim::Pose goal_pose, double tolerance) {<br/>   const double Kv = 1.5;<br/>   const double Kh = 3.5;</span><span id="8423" class="ni lj iq ne b gy nn nk l nl nm">ros::Rate loop_rate(10);</span><span id="9996" class="ni lj iq ne b gy nn nk l nl nm">while(getDistance(turtlesim_pose.x, turtlesim_pose.y, goal_pose.x, goal_pose.y) &gt; tolerance) {<br/>   <br/>     vel_msg.linear.x = Kv * getDistance(turtlesim_pose.x, turtlesim_pose.y, goal_pose.x, goal_pose.y);<br/>     vel_msg.linear.y = 0;<br/>     vel_msg.linear.z = 0;<br/>     vel_msg.angular.x = 0;<br/>     vel_msg.angular.y = 0;<br/>     vel_msg.angular.z = Kh * (atan2(goal_pose.y - turtlesim_pose.y, goal_pose.x - turtlesim_pose.x) - turtlesim_pose.theta);</span><span id="60c1" class="ni lj iq ne b gy nn nk l nl nm">    vel_pub.publish(vel_msg);<br/>    ros::spinOnce();<br/>    loop_rate.sleep();<br/>   }<br/>   <br/>   vel_msg.linear.x = 0;<br/>   vel_msg.angular.z = 0;<br/>   vel_pub.publish(vel_msg);<br/>   ros::spinOnce();<br/>  }</span></pre><p id="de5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了做到这一点，你需要将[x，y]笛卡尔坐标转换为极坐标形式。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/dce2ea32ef3879ac957d041854551082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*K7fBzj9mpR3eZpsWp8j9Tw.jpeg"/></div></figure><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="52db" class="ni lj iq ne b gy nj nk l nl nm">double getDistance(double x1, double y1, double x2, double y2) {<br/> return sqrt(pow((x1-x2),2)+pow((y1-y2),2));<br/>}</span></pre><p id="9ccf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，您可以通过一些基本的高中三角学和“math.h”标准库的帮助来完成。<br/>但是你的问题是，你不能把距离发给turtlesim的题目<em class="le"> cmd_vel </em>，你要发一个速度。线速度和角速度。</p><p id="7c55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好地理解这应该是如何工作的，我开始在网上搜索，直到我发现有人有一个关于如何做这件事的教程，移动乌龟！不幸的是，这是一个付费课程，只有几个免费视频。但有几个正是我需要的，让我走上正确的方向。</p><p id="7dad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了到达某一点，我所做的是将速度设置为与我们当前位置和目标之间的距离成比例的值。</p><p id="0bda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先说一点控制器。如果你翻阅一本控制系统的书，你可能会发现<a class="ae kc" href="https://en.wikipedia.org/wiki/PID_controller" rel="noopener ugc nofollow" target="_blank">提到了</a>三种基本类型的控制器。p、PI和PID。比例控制器、比例积分控制器和比例积分微分控制器。我提到这一点的原因是，我实际上实现了一个比例控制器，设置速度与常数<em class="le"> Kv </em>和要走的距离成比例。选择<em class="le"> Kv </em>和<em class="le"> Kh </em>的值有些随意。虽然我熟悉连续控制系统的理论，但我从未设计过数字控制器。所以我用每个常数的几个值进行迭代，直到我找到一个合理的行为。</p><blockquote class="lb lc ld"><p id="598b" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">有趣的是，在连续控制器中，这些常数与系统的稳定性有关，增加太多会使系统不稳定。</p></blockquote><p id="a7d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，你已经奠定了代码基础。应该发生的是，新的目标点通过“方向”主题到达您的节点。这些被存储起来，然后由“toGoal”方法处理，发布到turtlesim的主题“cmd_vel”。</p><h1 id="7d43" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">服务</h1><p id="f4ed" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">您几乎已经完成了这个挑战，但是就C++而言，您还需要实现一些东西。<br/>我已经谈了一些主题，以及如何使用它们与其他节点进行通信，所以您可能想知道，为什么要学习什么是“服务”呢？事实上，当你需要不断地发送数据时，主题是非常有用的。例如，反馈位置必须一直更新，以便订阅该主题的任何人都能实时了解该位置。同样的情况也适用于你的“方向”主题。新的目标点无论如何都会到来，你需要做好处理它们的准备。然而，在某些情况下，这可能是不必要的。这就是服务发挥作用的地方。这样，一个节点将提供一个或多个服务，其他节点(客户端)将使用它们。</p><p id="acae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用服务“停止、恢复和重置”turtlesim的动作，我建议您阅读并遵循<a class="ae kc" href="http://wiki.ros.org/ROS/Tutorials/CreatingMsgAndSrv" rel="noopener ugc nofollow" target="_blank">本</a>和<a class="ae kc" href="http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29" rel="noopener ugc nofollow" target="_blank">本</a>教程，其中涵盖了服务消息以及如何创建它们。每个服务消息由两部分组成:请求和响应。您需要为您的请求和响应创建一个描述消息类型的文件。</p><p id="b502" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您浏览存储库，您会发现一个“srv”文件夹，其中有一个类似如下的<em class="le"> ManualCommands.srv </em>文件:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="a823" class="ni lj iq ne b gy nj nk l nl nm">string name<br/>string order<br/>---<br/>string response</span></pre><p id="4c72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成这些后，您可以实现如下内容:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="ca2b" class="ni lj iq ne b gy nj nk l nl nm">// Server method<br/>  bool process(robot_tutorial::ManualCommands::Request  &amp;req, robot_tutorial::ManualCommands::Response &amp;res) {<br/>   if(req.name == "turtle1") {<br/>    if(req.order == "stop") {<br/>     order = req.order;<br/>    }<br/>    if(req.order == "resume") {<br/>     order = req.order;<br/>    }<br/>   }<br/>   return true;<br/>  }</span></pre><p id="af35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于“重置”，您将在代码实现中看到我调用了另一个服务，一个来自turtlesim的服务，以便将绝对位置设置为起始点。后来我注意到turtlesim已经有了一个<em class="le"> reset </em>服务，所以你可能想实现它。我怀疑代码会干净得多。</p><h1 id="84d6" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用户界面</h1><p id="5897" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">这是我最纠结的。我发现很少有关于RQT Python插件的文档。我找到了<a class="ae kc" href="http://wiki.ros.org/rqt/Tutorials/Create%20your%20new%20rqt%20plugin" rel="noopener ugc nofollow" target="_blank">这个</a>教程，但是从先决条件开始，第二个我已经失败了。首先，我没有基于QWidget的GUI。这正是我实际上想要完成的…所以在完成了那个教程之后，我开始尝试一些东西。我意识到<em class="le"> my_module.py </em>是应用的入口点，所以在googling了Qt代码后，我找到了一种方法，通过resources文件夹中的<em class="le"> MyPlugin.ui </em>文件来定义UI。我需要做的就是使用Qt钩子来触发ROS服务和主题。如果你通读代码，你会发现它非常简单，通过导入Qt和ROS库，你可以将UI按钮连接到链接到ROS主题/服务的回调。除此之外，我还导入了tkFileDialog来给用户一个显示本地文件的弹出窗口，让用户选择一个<em class="le"> points.js </em>文件让海龟跟随。</p><h1 id="5304" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论和链接</h1><p id="0bf9" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">整个库可以在<a class="ae kc" href="https://gitlab.com/tomi.ambro/catkin_ws" rel="noopener ugc nofollow" target="_blank">这里</a>找到。在那里你会发现几个ROS节点。本文讨论的是“robot_tutorial”和“rqt_mypkg ”,它们分别是C++节点和python UI插件。在自述文件中，您将找到如何运行这些程序的说明。我希望这篇文章能帮助你比我更好地浏览ROS代码的第一行。</p><p id="cd58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我可能会考虑将这篇文章变成一个系列，解释我在完成这篇文章后为自己设定的几个挑战，这篇文章让我开始在存储库中的其他节点上工作，这包括摆弄导航包。</p></div></div>    
</body>
</html>