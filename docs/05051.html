<html>
<head>
<title>Understanding Generics in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解TypeScript中的泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-generics-in-typescript-5c0828e2cfd5?source=collection_archive---------15-----------------------#2020-07-31">https://levelup.gitconnected.com/understanding-generics-in-typescript-5c0828e2cfd5?source=collection_archive---------15-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/191e3fbae52807c61b62604e98cc2105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qALT4gTaQL5qINfEy4c-A.jpeg"/></div></div></figure><p id="a7ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TypeScript是“JS的超集”，由于类型检查的强大功能，它使构建可维护、可理解和可伸缩的应用程序变得更加容易。</p><p id="c9ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">泛型在TypeScript中扮演着重要的角色，因为它允许我们编写可重用的代码，接受值和类型作为参数。</p><h1 id="b735" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">函数中的泛型</h1><p id="6714" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">泛型帮助我们提高代码的可重用性。让我们借助下面的例子来理解什么是泛型以及我们为什么需要它们:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ede2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，在上面的代码片段中，我们有三个函数做着几乎相同的事情。这是重复的代码，并呼吁使其可重用。</p><p id="3c9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以做的一件事是放入一个类型的<code class="fe mi mj mk ml b">any</code>,这样String、Number和Person类型的值可以在同一个函数中用作参数。不幸的是，这带来的问题比解决的问题还多。</p><p id="5426" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用泛型解决“可重用性问题”——一个例子:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="28e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mi mj mk ml b">converToValueArray</code>函数接收所选类型<code class="fe mi mj mk ml b">&lt;T&gt;</code>的值，并返回该类型的数组:<code class="fe mi mj mk ml b">Array&lt;T&gt;</code>。例如，如果值是字符串类型，那么返回类型是<code class="fe mi mj mk ml b">Array&lt;String&gt;</code></p><p id="bd78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看当我们定义泛型类型时，TypeScript是如何显示错误的。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/7bd6d544254187bb7ec8a2622d49f2dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KlCd0lkRa34OeleTibyc9w.png"/></div></div></figure><p id="abf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，在第18行，在使用了泛型之后，如果我们想要访问age，它会显示正确的错误，这是我们想要得到的关于任何类型错误的早期反馈。</p><h1 id="4cb9" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">推断类型</h1><p id="7223" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们定义一个接受泛型类型的函数。</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="4841" class="mr la it ml b gy ms mt l mu mv">function convertToArray&lt;T&gt;(args: T): Array&lt;T&gt; {<br/>  return [args];<br/>}</span></pre><p id="ea18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以用两种方式调用这个函数</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="e01e" class="mr la it ml b gy ms mt l mu mv">convertToArray("someString");</span><span id="eeed" class="mr la it ml b gy mw mt l mu mv">convertToArray&lt;String&gt;("someString");</span></pre><p id="22dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们所看到的，如果类型没有在<code class="fe mi mj mk ml b">&lt;&gt;</code>中传递，那么类型将被自动推断出来。类型推断使代码更短，但是在复杂的定义中，我们可能需要显式地传递类型。</p><h1 id="98f1" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">不止一个泛型类型</h1><p id="8992" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">就像函数参数一样，我们可以传递不止一种类型，这与函数参数的数量无关。例如</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="6c65" class="mr la it ml b gy ms mt l mu mv">function doStuff&lt;T, U&gt;(name: T): T {<br/>  // ...some process<br/>  return name;<br/>}</span></pre><p id="4ea5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述函数可以按如下方式调用:</p><pre class="mc md me mf gt mn ml mo mp aw mq bi"><span id="176e" class="mr la it ml b gy ms mt l mu mv">doStuff&lt;String, Number&gt;("someString");</span></pre><h1 id="f837" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通用类</h1><p id="b20b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">很多时候，我们需要创建一个泛型类，例如基本抽象类。在这里我们可以在创建类的实例时传递类型。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2dab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们所看到的，在第6行中，我们创建了一个基本的本地数据库类，我们可以用它为一个特定的表创建一个实例，并对数据库实例执行操作。让我们编写一个contact类来扩展这个基类，这样它就可以从parent继承一些属性。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><ul class=""><li id="2881" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">第14行，当我们扩展泛型类时，我们必须传递两种类型，在这个数据库中。在我们的例子中是ContactTable和ContactModel。</li><li id="dffc" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">第17行:<code class="fe mi mj mk ml b">ContactLocalDatabase</code>将从父类中获取函数，并且必须覆盖<code class="fe mi mj mk ml b">getFormattedData</code>，因为这在父基类中被定义为抽象函数。</li><li id="1c74" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">第17行:这是一个具有泛型类型的函数，我们在第一部分已经讨论过了。</li></ul><p id="11f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们创建一个ContactLocalDataBase实例来看看类泛型的运行情况。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><ul class=""><li id="efb1" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">第1行:因为我们已经在使用<code class="fe mi mj mk ml b">new</code>关键字时定义了ContactLocalDatabase类的类型，所以不需要将类型传递给基类。</li><li id="981f" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">第3、11、13行:我们可以注意到这些函数来自抽象类。这些行为符合一般的类定义。</li></ul><h1 id="910a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通用约束</h1><p id="5636" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">到目前为止，很清楚泛型是一种编写代码的方式，这样我们的代码可以支持多种类型，并且类型可以作为参数传递。</p><p id="5106" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这些知识，传递的类型可以是任何预定义类型或复杂的用户定义类型。</p><p id="3410" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时，如果我们想从泛型类型变量中访问任何函数，它会抛出一个错误。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/4721ab75d999a4732422c1aab6e6a770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPCYDkGeLmXgXZyN_JdhDg.png"/></div></div></figure><ul class=""><li id="41fc" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">第6行:这是一个完全有效的错误，因为数据有一个通用类型，它可以是字符串、数字、浮点或任何其他类型，传递的数据可以有也可以没有长度。</li></ul><p id="bb8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们可以向任何泛型添加一些约束，ts将确保只有那些值可以传递给满足约束的函数或类。让我们给通用函数定义添加一些约束。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/eab8a65856d0b76c16ffb4136f9ba098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K2b6RJZP_Gzp6FcUOAnA.png"/></div></div></figure><ul class=""><li id="948a" class="mx my it kd b ke kf ki kj km mz kq na ku nb ky nc nd ne nf bi translated">第4行:我们扩展了类型<code class="fe mi mj mk ml b">T</code>,使其具有长度属性</li><li id="9802" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">第5行:错误消失，这表示类型“T”上不存在属性长度</li><li id="6a96" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">第10行:当我们用一个数字调用函数时，它抛出一个错误，解释它不满足约束</li><li id="4d9b" class="mx my it kd b ke ng ki nh km ni kq nj ku nk ky nc nd ne nf bi translated">第12行和第13行:当我们传递有效数据如字符串或数组时，TS不会抛出错误。</li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="09c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是这篇文章的全部内容，我希望你已经了解了泛型的基础知识和它所产生的价值。</p><p id="dd1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你不了解泛型的基础，它看起来非常复杂。</p><p id="a9a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望你的时间值得阅读这篇文章。</p></div></div>    
</body>
</html>