<html>
<head>
<title>GoLang App build Version via Azure DevOps Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Azure DevOps管道的GoLang应用构建版本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-app-build-version-via-azure-devops-pipelines-fd4d800bf465?source=collection_archive---------7-----------------------#2020-11-15">https://levelup.gitconnected.com/golang-app-build-version-via-azure-devops-pipelines-fd4d800bf465?source=collection_archive---------7-----------------------#2020-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过Azure管道在GoLang容器日志中注入构建版本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cb518632277cc8c80809f5ae1a7e0b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yp2jpoYPOkwwOX1-0KErkw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有内部版本的GoLang容器日志</figcaption></figure><p id="4763" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我上一篇关于容器中的GoLang应用构建版本的文章中，我们已经讨论了构建版本在日志中的重要性。我们还讨论了在构建期间使用GitHub动作和GitLab CI注入版本。</p><p id="0ceb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将看到在Azure DevOps中构建GoLang容器时如何实现同样的目标。先决条件是</p><ul class=""><li id="8a0f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">有效的Azure DevOps订阅</li><li id="b9c3" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">活跃的Azure DevOps组织</li><li id="9a4e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">具有docker功能的Azure DevOps代理</li><li id="a4de" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">docker注册表的活动服务连接</li></ul><p id="3585" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">项目结构如下所示。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0890" class="mo mp it mk b gy mq mr l ms mt">golang-server<br/>|_main.go<br/>|_go.mod<br/>|_go.sum<br/>|_Dockerfile<br/>|_Makefile</span></pre><p id="348d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mu mv mw mk b">main.go</code>文件内容类似于前一篇文章中的内容。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="b811" class="mo mp it mk b gy mq mr l ms mt">package main<br/><br/>import "github.com/sirupsen/logrus"<br/><br/>var BuildVersion = "development"<br/><br/>func main() {<br/><br/>   logrus.Infof("The version of the app built with 'go build' : %s\n", BuildVersion)<br/><br/>}</span></pre><p id="4d83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像往常一样，为了保持轻量级图像，让我们使用多阶段docker构建。至此，Dockerfile文件的内容如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有BUILD_VERSION参数的Dockerfile</figcaption></figure><p id="f362" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于alpine:3.12构建的简单GoLang服务器。当您仔细查看docker文件时，您会发现<code class="fe mu mv mw mk b">go build</code>并不是在docker文件中本地发生的。这里使用<code class="fe mu mv mw mk b">Makefile</code>来做<code class="fe mu mv mw mk b">go build.</code>，这仅仅是因为它提供的动态性。</p><p id="68e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mu mv mw mk b">Makefile</code>的内容如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有BUILD_VERSION_ARG参数的Makefile</figcaption></figure><p id="883d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了上面的<code class="fe mu mv mw mk b">Dockerfile</code>和<code class="fe mu mv mw mk b">Makefile</code>，人们可以很容易地从本地创建Mac兼容的二进制文件和linux/amd64兼容的二进制文件。还可以通过设置本地环境变量来注入构建版本。</p><p id="3d30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在Azure管道中运行并为构建版本传递<strong class="la iu"> <em class="mz"> git标签</em> </strong>是我们想要的技巧。在Azure管道中这样做；首先，创建一个<code class="fe mu mv mw mk b">azure-pipelines.yml</code>文件。这是azure搜索管道定义的默认文件。你可以在这里阅读更多关于Azure管道的信息。</p><p id="c35b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要在分支上放置标签时触发管道，需要进行配置。所有的配置都发生在<code class="fe mu mv mw mk b">azure-pipelines.yml</code>文件中。<code class="fe mu mv mw mk b">tag</code>的触发器如下。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e2d7" class="mo mp it mk b gy mq mr l ms mt">trigger:<br/>  batch: true<br/>  branches:<br/>    include:<br/>      - "*"<br/>  tags:<br/>    include:<br/>      - "*"</span></pre><p id="564f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们已经指定在任何分支和任何标记丢弃中触发提交管道。“*”指定通配符any。</p><p id="59dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要为运行作业的代理指定一个配置。这允许您选择安装了<code class="fe mu mv mw mk b">docker</code>的代理。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="4541" class="mo mp it mk b gy mq mr l ms mt">pool:<br/>  name: default<br/>  demands:<br/>    - docker-builder</span></pre><p id="99ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码片段定义了<code class="fe mu mv mw mk b">default</code>池中任何具有<code class="fe mu mv mw mk b">docker-builder</code>标签功能的代理。点击查看更多关于代理功能<a class="ae lu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/agents?view=azure-devops&amp;tabs=browser#capabilities" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="a3fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在编写了定义作业的<strong class="la iu"> <em class="mz">阶段</em> </strong>的主要部分。这里，我们必须传递在<em class="mz"> Makefile中定义的变量<code class="fe mu mv mw mk b">BUILD_VERSION_ARG</code>的值。</em>这样构建版本将被注入到容器中。我们想满足几个要求。如果有标签丢失，需要进行设置，否则必须设置<em class="mz"> BuildNumber </em>。因此，通过Azure Pipelines的内部版本号，我们可以追溯到代码提交。内部版本号在美学上看起来比提交-sha更清晰。</p><p id="343d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Azure Pipelines还允许开发人员创建一个集中的存储库来创建模板，然后在任何管道中直接引用这些模板。为此，在同一个Azure Repos中创建一个git repo。在我们的场景中，我们已经创建了一个名为<code class="fe mu mv mw mk b">ci_templates.</code>的回购，以在当前管道中引用它，下面的代码片段必须添加到<code class="fe mu mv mw mk b">azure-pipelines.yml</code>文件中。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="1c76" class="mo mp it mk b gy mq mr l ms mt">resources:<br/>  repositories:<br/>    - repository: templates<br/>      name: MyOrgProject/ci_templates<br/>      type: git<br/>      ref: main</span></pre><p id="96cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Azure Pipelines提供了许多内置的环境变量。查看<a class="ae lu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&amp;tabs=yaml" rel="noopener ugc nofollow" target="_blank">这里的</a>以了解更多可用的预定义变量。在这些预定义变量和用户定义变量的帮助下，我们可以实现如下目标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ci_templates repo下的映像构建模板</figcaption></figure><p id="0a2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的构建模板定义中，我们使用docker命令的内置任务。请参考<a class="ae lu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/?view=azure-devops" rel="noopener ugc nofollow" target="_blank">这里的</a>获取可用的内置任务列表。</p><p id="1f95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在撰写本文时，<code class="fe mu mv mw mk b">Docker@2</code>是使用docker命令的最新内置任务。在这里，我们执行两个独立的任务:构建和推送映像。这是因为内置任务的命令<code class="fe mu mv mw mk b">buildAndPush</code>忽略了build参数。容器注册由已经注册的<code class="fe mu mv mw mk b">service connection</code>提供。<code class="fe mu mv mw mk b">repository</code>是指docker hub中的<em class="mz"> uname </em>的容器库。</p><p id="8277" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键概念是我们传递的<code class="fe mu mv mw mk b">arguments</code>输入。使用预定义变量<code class="fe mu mv mw mk b">Build.SourceBranch</code>我们可以得到分支名称。如果有一个标签被丢弃，上面变量的值将类似于<code class="fe mu mv mw mk b">refs/tag/&lt;tag-name&gt;.</code>如果在任何分支上有任何提交，那么上面变量的值将是<code class="fe mu mv mw mk b">refs/heads/&lt;branch-name&gt;.</code>有了上面的区别，我们几乎可以将<code class="fe mu mv mw mk b">arguments</code>和<code class="fe mu mv mw mk b">tags</code>的值指定为标签值或编译号。管道作业的构建号可以从预定义变量<code class="fe mu mv mw mk b">Build.BuildNumber</code>中获得。</p><p id="6ec9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mu mv mw mk b">tag</code>或<code class="fe mu mv mw mk b">buildNumber</code>的控制流程如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/07e3bc62e307eea3490baff09a4ddf58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1uqqP0AnN3Mmf7k5qy6-bg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将构建版本注入Azure DevOps管道中的GoLang容器映像</figcaption></figure><p id="b057" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上图所示，<code class="fe mu mv mw mk b">Build.BuildNumber</code>或<code class="fe mu mv mw mk b">Build.SourceBranchName</code>将作为构建参数传递给docker构建命令。这将把另一个环境变量中该变量的值作为参数传递给Makefile。Makefile会将它传递给<code class="fe mu mv mw mk b">golang linker flags</code>以将其注入到已经构建好的代码中。</p><p id="567d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了推送上面构建的docker映像，我们使用来自同一个<em class="mz"> Docker@2 </em>任务的命令<code class="fe mu mv mw mk b">push</code>，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ci_templates repo下的映像推送模板</figcaption></figure><p id="f368" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">部署后，容器将开始记录内部版本号</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="28db" class="mo mp it mk b gy mq mr l ms mt">INFO[0000] The version of the app built with makefile : 0.1.0</span></pre><p id="123c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，请通过鼓掌帮助其他人找到，并在这里和<a class="ae lu" href="https://twitter.com/gkarthics" rel="noopener ugc nofollow" target="_blank"> twitter </a>上关注我以获取更多更新。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="ae3a" class="ni mp it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">参考:</h1><ul class=""><li id="6131" class="lv lw it la b lb nz le oa lh ob ll oc lp od lt ma mb mc md bi translated"><a class="ae lu" href="https://medium.com/@github.gkarthiks/golang-app-build-version-in-containers-3d4833a55094" rel="noopener"> GoLang应用在容器中构建版本</a></li><li id="46d2" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/get-started/what-is-azure-pipelines?view=azure-devops" rel="noopener ugc nofollow" target="_blank">天蓝色管道</a></li><li id="3138" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/agents?view=azure-devops&amp;tabs=browser#capabilities" rel="noopener ugc nofollow" target="_blank"> Azure DevOps代理功能</a></li><li id="fd7e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&amp;tabs=yaml" rel="noopener ugc nofollow" target="_blank"> Azure DevOps代理内置变量</a></li><li id="8822" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure管道内置任务</a></li></ul></div></div>    
</body>
</html>