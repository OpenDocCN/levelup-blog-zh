<html>
<head>
<title>10 tips for optimizing your Firestore database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Firestore数据库的10个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/part-1-10-tips-for-optimizing-your-firestore-database-f32bd0c90d26?source=collection_archive---------5-----------------------#2022-12-29">https://levelup.gitconnected.com/part-1-10-tips-for-optimizing-your-firestore-database-f32bd0c90d26?source=collection_archive---------5-----------------------#2022-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7f79312038e59e31b52e712b8ced4db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFFbo8lkNxVQcmLrLDVRNw.png"/></div></div></figure><h1 id="beb3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">技巧#1为您的用例选择正确的数据库模式</h1><p id="1149" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用Firestore时，为您的用例选择正确的数据库模式非常重要。Firestore提供两种模式:本地模式和数据存储模式。以下是每种模式的简要概述，以及您可能需要使用它的时间:</p><h2 id="46a2" class="lu jz iq bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">本地模式</h2><p id="72c0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是Firestore更新、更强大的版本，提供实时更新和高级查询功能。它使用NoSQL数据模型，非常适合需要处理大量读写操作的应用程序。如果您需要实时更新或者希望能够对数据执行更高级的查询，您应该考虑使用纯模式。</p><h2 id="2411" class="lu jz iq bd ka lv lw dn ke lx ly dp ki lh lz ma km ll mb mc kq lp md me ku mf bi translated">数据存储模式</h2><p id="190d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是Firestore的遗留版本，基于Google Cloud Datastore产品。它提供了强大的一致性和事务支持，这使它成为某些类型工作负载的良好选择，例如那些需要强大一致性或需要与其他Google云服务交互的工作负载。如果你需要强一致性或者想要使用其他Google云服务，你可以考虑使用Datastore模式。</p><p id="2ee9" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">下表总结了本机模式和数据存储模式之间的主要差异:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/1bf305a7409908f16c80c5c4434ccd81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*FfwL6cBdtykv5A1cLf1zGg.png"/></div></figure><p id="a6fa" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">如果您不确定使用哪种数据库模式，您可以尝试两种模式，看看哪种模式更适合您的特定用例。通过迁移数据和索引定义以及更新客户端库和安全规则，您可以随时在本机模式和数据存储模式之间切换。</p><p id="e55d" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在选择正确的数据库模式时，评估应用程序的特定需求和要求非常重要。考虑您将存储的数据类型、您期望处理的读写操作量以及您的任何其他特定要求。您可能还想测试每种模式的性能和可伸缩性，看看哪种模式更适合您的用例。请记住，每种模式都有自己的权衡，由您来决定哪种模式最适合您的应用。</p><h1 id="5882" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">技巧#2设计一个高效且可伸缩的数据结构</h1><p id="956b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">设计高效且可扩展的数据结构对于优化Firestore数据库至关重要。设计良好的数据结构可以提高性能，减少需要存储和检索的数据量，并使数据处理更加容易。以下是设计高效且可伸缩的数据结构的一些技巧:</p><ul class=""><li id="3016" class="mq mr iq ky b kz mg ld mh lh ms ll mt lp mu lt mv mw mx my bi translated">尽可能使用嵌套数据结构:Firestore支持嵌套数据结构，这使得组织和检索相关数据更加容易。例如，如果您有一个用户集合，并且每个用户都有一个喜爱的产品列表，您可以将喜爱的产品作为一个数组存储在用户文档中，如下所示:</li></ul><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="3419" class="ne jz iq na b be nf ng l nh ni">{<br/>  "name": "John Smith",<br/>  "favorites": [<br/>    { "product_id": "p1", "name": "Product 1" },<br/>    { "product_id": "p2", "name": "Product 2" },<br/>    { "product_id": "p3", "name": "Product 3" }<br/>  ]<br/>}</span></pre><ul class=""><li id="0858" class="mq mr iq ky b kz mg ld mh lh ms ll mt lp mu lt mv mw mx my bi translated">非规范化数据:在传统的关系数据库中，通常通过将数据分解成更小的相关表并使用连接来检索数据来规范化数据。然而，在像Firestore这样的NoSQL数据库中，这可能是低效的，因为它需要多次读取操作，并且会增加需要存储的数据量。相反，您可以通过在多个文档和集合中复制数据来反规范化数据。例如，如果您有一个用户集合和一个产品集合，您可以将用户喜爱的产品作为一个数组存储在用户文档中，并将产品详细信息存储在产品集合中，如下所示:</li></ul><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="11b7" class="ne jz iq na b be nf ng l nh ni">// User document<br/>{<br/>  "name": "John Smith",<br/>  "favorites": ["p1", "p2", "p3"]<br/>}<br/><br/>// Product documents<br/>{ "product_id": "p1", "name": "Product 1" }<br/>{ "product_id": "p2", "name": "Product 2" }<br/>{ "product_id": "p3", "name": "Product 3" }</span></pre><ul class=""><li id="8286" class="mq mr iq ky b kz mg ld mh lh ms ll mt lp mu lt mv mw mx my bi translated">谨慎使用数组:数组对于存储项目列表很有用，但是在Firestore中使用时效率也很低。因为Firestore必须读取整个数组来检索单个元素，所以查询包含大量元素的数组会比较慢。此外，存储大型数组会增加文档的大小以及需要存储和检索的数据量。为了优化数据结构，应该尽量少用数组，只在必要的时候使用。</li><li id="ef52" class="mq mr iq ky b kz nj ld nk lh nl ll nm lp nn lt mv mw mx my bi translated">使用引用而不是嵌入数据:如果需要在文档中存储大量数据，使用引用比直接嵌入数据更有效。引用是一种特殊类型的字段，它存储数据库中另一个文档的ID，而不是整个文档本身。当需要访问数据时，可以使用查询单独检索引用的文档。这可以减小文档的大小并提高性能，尤其是对于不常访问或实时不需要的数据。</li><li id="8acf" class="mq mr iq ky b kz nj ld nk lh nl ll nm lp nn lt mv mw mx my bi translated">考虑使用子集合:如果有大量相关的文档被一起访问，可以考虑使用子集合来组织它们。子集合是文档中的一个集合，它对于存储与父文档密切相关的数据非常有用。例如，如果您有一个用户集合，并且每个用户都有大量的帖子，您可以使用一个子集合来存储每个用户文档中的帖子，如下所示:</li></ul><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="f130" class="ne jz iq na b be nf ng l nh ni">{<br/>  "name": "John Smith",<br/>  "posts": [<br/>    { "title": "Post 1", "body": "..." },<br/>    { "title": "Post 2", "body": "..." },<br/>    { "title": "Post 3", "body": "..." }<br/>  ]<br/>}</span></pre><p id="21a0" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">通过遵循这些提示，并花时间设计一个高效且可伸缩的数据结构，您可以显著提高Firestore数据库的性能和可伸缩性。</p><h1 id="abf7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">技巧#3使用复合索引来支持高级查询</h1><p id="fb93" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Firestore提供了高级查询功能，但是为了有效地使用它们，您需要建立复合索引。复合索引是包括多个字段的索引，而不仅仅是单个字段。它允许您执行复杂的查询，同时基于多个字段对数据进行筛选和排序。</p><p id="77e2" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">下面是一个基于单个字段筛选数据的简单查询示例:</p><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="070e" class="ne jz iq na b be nf ng l nh ni">db.collection("users").where("age", "&gt;", 30).get()</span></pre><p id="2536" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">该查询从“users”集合中检索“age”字段大于30的所有文档。</p><p id="1624" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">若要执行基于多个字段筛选数据的查询，您需要设置一个复合索引。例如，要按年龄和位置筛选用户，可以使用以下查询:</p><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="72f4" class="ne jz iq na b be nf ng l nh ni">db.collection("users").where("age", "&gt;", 30).where("location", "==", "San Francisco").get()</span></pre><p id="1cf2" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">要设置复合索引，您需要指定要包含的字段以及它们的索引顺序。例如，要为“年龄”和“位置”字段设置索引，可以使用以下索引定义:</p><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="4aec" class="ne jz iq na b be nf ng l nh ni">{<br/>  "fields": [<br/>    { "fieldPath": "age", "order": "ASCENDING" },<br/>    { "fieldPath": "location", "order": "ASCENDING" }<br/>  ]<br/>}</span></pre><p id="7a16" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">该索引定义告诉Firestore创建一个包括“年龄”和“位置”字段的索引，并对这两个字段的索引条目进行升序排序。</p><p id="f346" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">一旦建立了复合索引，就可以使用它来执行基于多个字段对数据进行筛选和排序的高级查询。如果您有一个大型数据集，并且需要执行复杂的查询来检索特定的数据，这可能特别有用。</p><p id="ee9b" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">值得注意的是，复合索引会占用额外的空间，并可能影响性能</p><h1 id="d974" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">技巧4:对数据进行非规范化处理，以减少对连接的需求</h1><p id="76b9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在传统的关系数据库中，通常通过将数据分解成更小的相关表并使用连接来检索数据来规范化数据。然而，在像Firestore这样的NoSQL数据库中，这可能是低效的，因为它需要多次读取操作，并且会增加您需要存储和检索的数据量。</p><p id="004c" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">为了优化Firestore中的数据结构，您可以通过在多个文档和集合中复制数据来取消数据的规范化。反规范化可以减少对连接的需求并提高性能，特别是对于频繁访问或需要实时检索的数据。</p><p id="3168" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">下面是一个规范化数据结构的示例，它使用两个集合“users”和“posts”来存储用户和帖子数据:</p><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="78dd" class="ne jz iq na b be nf ng l nh ni">// Users collection<br/>{ "user_id": "u1", "name": "John Smith" }<br/>{ "user_id": "u2", "name": "Jane Doe" }<br/><br/>// Posts collection<br/>{ "post_id": "p1", "user_id": "u1", "title": "Post 1", "body": "..." }<br/>{ "post_id": "p2", "user_id": "u1", "title": "Post 2", "body": "..." }<br/>{ "post_id": "p3", "user_id": "u2", "title": "Post 3", "body": "..." }</span></pre><p id="7754" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">要检索特定用户的帖子，您需要使用一个连接来组合来自“users”和“posts”集合的数据。</p><p id="16f1" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">要反规范化这个数据结构，您可以将用户的帖子存储为用户文档中的一个数组，如下所示:</p><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="c24f" class="ne jz iq na b be nf ng l nh ni">// Users collection<br/>{ <br/>  "user_id": "u1", <br/>  "name": "John Smith",<br/>  "posts": [<br/>    { "post_id": "p1", "title": "Post 1", "body": "..." },<br/>    { "post_id": "p2", "title": "Post 2", "body": "..." }<br/>  ]<br/>}<br/>{ <br/>  "user_id": "u2", <br/>  "name": "Jane Doe",<br/>  "posts": [<br/>    { "post_id": "p3", "title": "Post 3", "body": "..." }<br/>  ]<br/>}</span></pre><p id="56bc" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这种非规范化的数据结构允许您通过简单地读取用户文档中的“posts”数组来检索用户的帖子，而不是执行连接。这可以提高性能并减少需要存储和检索的数据量。</p><p id="2ed0" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">请记住，反规范化是有代价的，并不适合所有的数据结构。在决定是否对数据进行反规范化之前，您应该仔细考虑您的特定需求和要求。</p><h1 id="5483" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">技巧#5使用批处理操作来提高性能</h1><p id="3217" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Firestore允许您执行批处理操作，以提高性能并减少需要执行的读写操作的数量。批处理操作是作为一个单元一起执行的一组写或更新操作。通过使用批处理操作，您可以一次执行多个操作，这可以减少完成这些操作所需的时间和资源。</p><p id="9119" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">以下是如何使用批处理操作一次更新多个文档的示例:</p><pre class="mm mn mo mp gt mz na nb bn nc nd bi"><span id="d650" class="ne jz iq na b be nf ng l nh ni">let batch = db.batch();<br/>let doc1 = db.collection("users").doc("u1");<br/>let doc2 = db.collection("users").doc("u2");<br/>batch.update(doc1, { name: "John Smith" });<br/>batch.update(doc2, { name: "Jane Doe" });<br/>batch.commit().then(() =&gt; {<br/>  console.log("Batch update complete");<br/>});</span></pre><p id="f0bd" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">这段代码创建了一个批处理对象，并向其中添加了两个更新操作，每个用户文档一个。然后，它使用<code class="fe no np nq na b">commit()</code>方法执行批处理操作，同时更新两个文档。</p><p id="984d" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">您还可以使用批处理操作来执行多个写入或删除操作。例如，您可以使用批处理操作一次删除多个文档，或者在一次操作中写入大量文档。</p><p id="2798" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">批处理操作可以显著提高Firestore数据库的性能，尤其是对于需要大量读写操作的工作负载。但是，需要注意的是，批处理操作有一定的限制，例如每批的最大规模为500个操作，最大速率为每秒一批。要优化批处理操作的使用，您应该考虑应用程序的特定需求和要求，并测试不同批处理大小和频率的性能，以找到最佳平衡。</p><p id="d16d" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">还值得注意的是，批处理操作是原子性的，这意味着它们要么全部完成，要么根本没有完成。如果在批处理操作过程中出现错误，将不会应用任何操作，这对于保持数据的一致性非常有用。</p><p id="ee46" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">总之，批处理操作是优化Firestore数据库性能的强大工具。通过将多个读写操作组合在一起，可以减少需要执行的操作数量，并提高应用程序的整体性能。</p><div class="nr ns gp gr nt nu"><a href="https://medium.com/@nicchong/part-2-10-tips-for-optimizing-your-firestore-database-67c0394b1117" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">第2部分:优化Firestore数据库的10个技巧</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">在这篇博文中，我们介绍了一些优化Firestore数据库和提高性能的技巧</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi jw nu"/></div></div></a></div></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><p id="a21b" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><strong class="ky ir">不要错过我即将推出的内容和案例指南:</strong></p><p id="1027" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><a class="ae oq" href="https://medium.com/@nicchong/subscribe" rel="noopener">【https://medium.com/@nicchong/subscribe】T4</a></p><p id="9a02" class="pw-post-body-paragraph kw kx iq ky b kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">如果你有什么问题，我在这里帮忙，在评论区等你:)</p></div></div>    
</body>
</html>