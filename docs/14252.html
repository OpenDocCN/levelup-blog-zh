<html>
<head>
<title>Python Data Pipeline Data Validation with pydantic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用pydantic进行Python数据管道数据验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-data-pipeline-first-and-foremost-step-data-validation-e15017b7ef8d?source=collection_archive---------7-----------------------#2022-11-11">https://levelup.gitconnected.com/python-data-pipeline-first-and-foremost-step-data-validation-e15017b7ef8d?source=collection_archive---------7-----------------------#2022-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5086" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文旨在展示和分享关于如何使用<strong class="js iu"> pydantic </strong>来验证和保护您的数据管道的代码片段。让我们开始吧…</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/767dee1d49ea4ef1abf83be9acc16abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nJB5kUUEPAJ4SNcWpR2xQ.png"/></div></div></figure><h1 id="20c5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用镇静剂</h1><p id="ce5a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><code class="fe md me mf mg b">Pydantic</code>是一个流行的库，它将我们的数据解析成期望的数据类型。我们可以使用<code class="fe md me mf mg b">dataclass</code>定义我们的数据类型，让<code class="fe md me mf mg b">Pydantic</code>处理数据类型解析。让我们看看如何处理我们的营销数据。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="86ec" class="ml lb it mg b gy mm mn l mo mp">pip install pydantic</span></pre><h1 id="8e89" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">简单的例子</h1><p id="4905" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们将从导入<a class="ae mq" href="https://github.com/samuelcolvin/pydantic/blob/abea8232eef0eeeb728824cdec9b445dfbd3192e/pydantic/main.py#L310" rel="noopener ugc nofollow" target="_blank"> BaseModel </a>类开始，这是我们所有数据<a class="ae mq" href="https://pydantic-docs.helpmanual.io/usage/models/" rel="noopener ugc nofollow" target="_blank">模型</a>应该继承的类。我们还将导入<a class="ae mq" href="https://github.com/samuelcolvin/pydantic/blob/master/pydantic/error_wrappers.py#L50" rel="noopener ugc nofollow" target="_blank"> ValidationError </a>异常，如果模型中的数据解析和验证失败，我们将使用该异常进行错误处理。</p><p id="ff6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b"><strong class="js iu">from </strong>pydantic <strong class="js iu">import </strong>BaseModel, ValidationError</code></p><p id="1874" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这之后，我们将定义我们的模型类。为了便于说明，我们将定义一个示例Person类，它有几个字段:</p><ul class=""><li id="05ee" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated"><strong class="js iu">年龄</strong>:表示人的年龄的整数。类型提示应该是<strong class="js iu"> int </strong>。</li><li id="5ec6" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><strong class="js iu">姓名</strong>:带有人名的字符串。类型提示应该是<strong class="js iu"> str </strong>。</li><li id="4e3c" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated"><strong class="js iu"> is_married </strong>:布尔值，表示此人是否结婚。类型提示应该是<strong class="js iu"> bool </strong>。</li></ul><p id="179e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如已经提到的，我们的<strong class="js iu"> Person </strong>类应该继承我们已经导入的<strong class="js iu"> BaseModel </strong>类。</p><pre class="kp kq kr ks gt mh mg nf bn ng nh bi"><span id="1284" class="ni lb it mg b be nj nk l nl mp">class Person(BaseModel):<br/>    age: int<br/>    name: str<br/>    is_married: bool</span></pre><p id="b0c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经为我们的<strong class="js iu">人</strong>定义了模型，我们将定义一个字典，其中包含我们想要根据模型解析和验证的数据。在这个例子中，我们将定义一个包含有效数据的字典。</p><pre class="kp kq kr ks gt mh mg nf bn ng nh bi"><span id="7f6d" class="ni lb it mg b be nj nk l nl mp">data = {<br/>    'name': 'John',<br/>    'age': 20,<br/>    'is_married': False<br/>}</span></pre><p id="be76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们将创建一个<strong class="js iu"> Person </strong>类的对象。我们将传递数据字典的字段作为构造函数的输入。为了使我们的代码更加简洁，我们将使用字典解包操作符(双星号)。</p><p id="e552" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b">person <strong class="js iu">= </strong>Person(<strong class="js iu">**</strong>data)</code></p><p id="5a75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管我们传递的是符合模型规范的数据字典，但是我们需要考虑到，当接收外部数据时，这可能不是真的。因此，如果数据无效，将会引发一个<strong class="js iu">验证错误</strong>。因此，我们将在try except块中包含我们的<strong class="js iu"> Person </strong>对象的实例化。</p><p id="5360" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在except块中，我们将简单地打印异常。</p><pre class="kp kq kr ks gt mh mg nf bn ng nh bi"><span id="9024" class="ni lb it mg b be nj nk l nl mp">try:<br/>    person = Person(**data)<br/>    # use the data<br/> <br/>except ValidationError as e:<br/>    print(e)</span></pre><p id="1db2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于举例的目的，我们现在将通过调用<a class="ae mq" href="https://pydantic-docs.helpmanual.io/usage/exporting_models/#modeldict" rel="noopener ugc nofollow" target="_blank"> dict </a>方法将模型对象转换回字典。虽然这个方法可以接收一些可选的输入来定制模型到字典的转换，但是对于这个测试，我们不会传递任何参数，所以我们得到默认的行为。我们将打印生成的词典。</p><p id="ba2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b">print(person.dict())</code></p><p id="da79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是完整的代码。</p><pre class="kp kq kr ks gt mh mg nf bn ng nh bi"><span id="da6f" class="ni lb it mg b be nj nk l nl mp">from pydantic import BaseModel, ValidationError<br/> <br/>class Person(BaseModel):<br/>    age: int<br/>    name: str<br/>    is_married: bool<br/> <br/>data = {<br/>    'name': 'John',<br/>    'age': 20,<br/>    'is_married': False<br/>}<br/> <br/>try:<br/>    person = Person(**data)<br/>    print(person.dict())<br/> <br/>except ValidationError as e:<br/>    print(e)</span></pre><p id="8725" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要测试代码，只需在您选择的工具中运行它。在我的例子中，我使用的是VS代码。</p><p id="afce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该会得到类似于图1的结果。可以看到，我们没有得到任何异常，这意味着模型解析和验证没有出现任何问题。正如所料，我们还获得了模型的字典表示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/c9fc9cd1fc4989cd09acb48c2176441a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s37JJqlKfq0f4ajiVw2JYQ.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">图1从Person模型对象获得的字典</figcaption></figure><p id="59bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将做一些小的更改，使数据根据我们的模型定义无效:</p><ul class=""><li id="a643" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">我们将从字典中删除<strong class="js iu"> name </strong>属性</li><li id="6f1c" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn mw mx my mz bi translated">我们将把<strong class="js iu">年龄</strong>属性设置为任意字符串</li></ul><pre class="kp kq kr ks gt mh mg nf bn ng nh bi"><span id="1f37" class="ni lb it mg b be nj nk l nl mp">data = {<br/>    'age': "test",<br/>    'is_married': False<br/>}</span></pre><p id="3090" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们在更改了上面字典的数据变量后再次运行代码，我们应该得到如图2所示的输出。可以看出，该异常表明<strong class="js iu">年龄</strong>不是整数，并且<strong class="js iu">姓名</strong>缺失。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/b9ace87606a29b36149fded475c63e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMXvDZ_fW06B2fXAfwoPOg.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">图2 Pydantic抛出的验证错误</figcaption></figure><p id="4ffe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们展示了一个非常简单的例子，我们刚刚打印了我们的<strong class="js iu"> Person </strong>对象的字典表示。然而，在真实的场景中，我们可能会将该对象用于其他操作。从开发体验的角度来看，如果我们正在使用IDE(在我的例子中是VS代码)，这些模型的使用也给了我们一些好的特性，比如自动完成。这可能看起来是一个小细节，但是当处理大而复杂的代码库时，这种类型的特性比必须找出哪些字段可能存在于dictionary对象上要容易得多。</p><h1 id="de2f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="6092" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><code class="fe md me mf mg b">Pydantic</code>让您轻松</p><ol class=""><li id="6900" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn ns mx my mz bi translated">定义数据集的数据类型</li><li id="6f23" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn ns mx my mz bi translated">解析数据以匹配定义的数据类型</li><li id="c1c4" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn ns mx my mz bi translated">用<code class="fe md me mf mg b">ValidationError</code>捕捉数据类型错误</li><li id="592c" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn ns mx my mz bi translated">定义自定义数据类型</li><li id="0bd3" class="mr ms it js b jt na jx nb kb nc kf nd kj ne kn ns mx my mz bi translated">使用<code class="fe md me mf mg b"><a class="ae mq" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank">mypy</a></code>捕捉类型错误。</li></ol><p id="aa6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b">Pydantic</code>提供了很多功能。你可以参考它的完整文档<a class="ae mq" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="eefb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mq" href="https://medium.com/@caopengau/data-engineering-made-easy-attached-python-scripts-to-head-startyour-etl-tasks-960e766f3ae3" rel="noopener">使用python进行数据工程和ETL可能会容易得多，只需几个方便的脚本就可以了！</a></p><p id="d974" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您对数据可视化感兴趣，请随意查看<a class="ae mq" href="https://medium.com/@caopengau/data-visualisation-with-apache-superset-a-step-by-step-guide-e5b0c150f358" rel="noopener">这篇分步指南，了解如何使用Apache超集</a>创建您的第一个图表。</p><p id="371d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">行动呼吁</strong></p><p id="cb0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae mq" href="https://medium.com/@caopengau/membership" rel="noopener">链接</a>加入medium，获取我和所有其他优秀作家在medium上发表的所有优质文章。</p></div></div>    
</body>
</html>