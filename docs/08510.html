<html>
<head>
<title>Nesting GitHub’s API in your GraphQL Schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在GraphQL模式中嵌套GitHub的API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nesting-githubs-api-in-your-graphql-schema-bf87b96177c9?source=collection_archive---------7-----------------------#2021-05-07">https://levelup.gitconnected.com/nesting-githubs-api-in-your-graphql-schema-bf87b96177c9?source=collection_archive---------7-----------------------#2021-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a623cc45221cb8405a59ecb5865425db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIYUiIzjRw-nHXqrCiV2YA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片作者:Aaron Ortbals</figcaption></figure><p id="b4fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GraphQL很棒。每个GraphQL端点都同意使用相同的语言<code class="fe la lb lc ld b">{data, errors}</code>,这使得服务器之间的通信变得容易。现在假设两个公共API都使用GraphQL我们可以利用哪些优势？像<a class="ae le" href="https://www.graphql-tools.com/" rel="noopener ugc nofollow" target="_blank"> graphql-tools </a>这样的包使得合并和缝合模式变得容易，这允许团队通过连接和联合功能构建他们的子模式的独立部分。但是有自己的认证、速率限制和错误的第三方模式呢？比如看一下<a class="ae le" href="https://docs.github.com/en/graphql/overview/explorer" rel="noopener ugc nofollow" target="_blank"> GitHub的GraphQL API </a>。如果能把GitHub的端点嵌套在自己的模式中岂不是很棒？在一个简单的GraphQL查询中，您可以从您的应用程序中获得用户的姓名，也可以从GitHub中获得他们的简历:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="6790" class="ln lo iq ld b gy lp lq l lr ls"># Application schema<br/>query {<br/>  viewer {<br/>    name<br/>    githubApi {<br/>      # GitHub's schema<br/>      query {<br/>        viewer {<br/>          bio<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="01e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然这只是开始。客户端可以更新你的应用和GitHub，而不需要任何额外的后端逻辑。很好的图表:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="75bd" class="ln lo iq ld b gy lp lq l lr ls">mutation ($userId: String!) {<br/>  addFriend(userId: $userId) {<br/>    user {<br/>      name<br/>      githubApi {<br/>        mutation {<br/>          followUser(input: {userId: $userId}) {<br/>            user {<br/>              bio<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="81d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了<a class="ae le" href="https://github.com/ParabolInc/nest-graphql-endpoint" rel="noopener ugc nofollow" target="_blank"> nest-graphql-endpoint </a>，这终于成为可能🎉。</p><h1 id="9f5a" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">商业案例</h1><p id="d672" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">今天，建设一个成功的SaaS意味着在客户所在的地方与他们见面——集成他们已经使用的工具。我已经为Slack和Atlassian构建了集成，但是在构建GitHub集成时，我注意到我在重新创建GitHub的API已经内置的许多逻辑。</p><p id="3811" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，我们的<a class="ae le" href="https://www.parabol.co/solutions/sprint-poker" rel="noopener ugc nofollow" target="_blank">规划扑克会议</a>从GitHub获取团队的所有故事，提供一种有趣的、身临其境的方式给每个故事打分，并将分数导出到GitHub。没有嵌套GitHub的模式，我创建了自己的有一个<code class="fe la lb lc ld b">repos</code>字段的<code class="fe la lb lc ld b">GitHubIntegration</code>对象。该字段有一个定制的<code class="fe la lb lc ld b">resolve</code>函数，通过使用手写的GraphQL字符串从GitHub获取repos。这不是很好，有几个原因:</p><ul class=""><li id="2710" class="mv mw iq ke b kf kg kj kk kn mx kr my kv mz kz na nb nc nd bi translated">这是我必须维护的额外代码</li><li id="3ef3" class="mv mw iq ke b kf ne kj nf kn ng kr nh kv ni kz na nb nc nd bi translated">该查询没有明确显示前端开发人员哪些部件来自GitHub</li><li id="65f7" class="mv mw iq ke b kf ne kj nf kn ng kr nh kv ni kz na nb nc nd bi translated">如果没有数据加载器，多个查询会导致对GitHub的多次提取</li><li id="b50c" class="mv mw iq ke b kf ne kj nf kn ng kr nh kv ni kz na nb nc nd bi translated">即使有了数据加载器，对GitHub的多次提取也是不可避免的，除非每个查询都是相同的(因此会导致过度提取)</li></ul><p id="83d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我需要的是一种方法，将所有发送到GitHub的片段进行批处理，将它们合并成一个网络请求，然后再将响应解析成相应的片段。为什么要批处理？因为在现实世界中，查询会变得很大&amp;经常重复:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="b0c5" class="ln lo iq ld b gy lp lq l lr ls">query {<br/>  viewer {<br/>    githubApi {<br/>      query {<br/>        ...Bio<br/>      }<br/>    }<br/>    myTasks {<br/>      user {<br/>        githubApi {<br/>          query {<br/>            ...Bio<br/>            viewer {<br/>              bio<br/>              id<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span><span id="6759" class="ln lo iq ld b gy nj lq l lr ls">fragment Bio on _extGitHubQuery {<br/>  viewer {<br/>    bio<br/>  }<br/>}</span></pre><h1 id="432e" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">工作原理:nest-graphql-endpoint</h1><p id="8702" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">考虑到所有这些复杂性，我需要一种方法，只用一行代码就能在我的模式中嵌套端点:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="e95d" class="ln lo iq ld b gy lp lq l lr ls">const mergedSchema = nestGitHubEndpoint({<br/>  parentSchema,<br/>  fieldName: 'githubApi',<br/>  parentType: 'User',<br/>  resolveEndpointContext: (source) =&gt; ({accessToken: source.accessToken})<br/>})</span></pre><p id="08ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样！您的<code class="fe la lb lc ld b">User</code>对象现在有了一个包含查询、突变和错误的<code class="fe la lb lc ld b">githubApi</code>对象。<code class="fe la lb lc ld b">resolveEndpointContext</code>允许您获取并提供访问端点所需的密钥。</p><p id="a8f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在幕后，它是这样工作的:</p><ol class=""><li id="7a09" class="mv mw iq ke b kf kg kj kk kn mx kr my kv mz kz nk nb nc nd bi translated">它获取GitHub模式并为所有的<code class="fe la lb lc ld b">__typename</code>字段添加前缀，这样您就可以编写查询，而不用担心命名冲突</li><li id="2c23" class="mv mw iq ke b kf ne kj nf kn ng kr nh kv ni kz nk nb nc nd bi translated">它收集了<code class="fe la lb lc ld b">gitHubApi</code>对象中的所有片段&amp;并将它们合并成一个查询</li><li id="8440" class="mv mw iq ke b kf ne kj nf kn ng kr nh kv ni kz nk nb nc nd bi translated">它删除了未使用的变量、变量定义和片段</li><li id="c075" class="mv mw iq ke b kf ne kj nf kn ng kr nh kv ni kz nk nb nc nd bi translated">它取消了<code class="fe la lb lc ld b">__typename</code>字段的前缀，这样GitHub就能理解这个查询</li><li id="9ee1" class="mv mw iq ke b kf ne kj nf kn ng kr nh kv ni kz nk nb nc nd bi translated">在名称冲突的情况下，它会在获取请求之前给字段起别名</li><li id="d661" class="mv mw iq ke b kf ne kj nf kn ng kr nh kv ni kz nk nb nc nd bi translated">它取消响应的别名，重新应用<code class="fe la lb lc ld b">__typename</code>前缀，并通过路径过滤错误</li></ol><p id="ec52" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看它是如何建造的。</p><h1 id="8f34" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">构建GitHub模式</h1><p id="cadc" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">GitHub提供了一个很棒的包叫做<a class="ae le" href="https://github.com/octokit/graphql-schema" rel="noopener ugc nofollow" target="_blank">@ octo kit/graph QL-schema</a>。它提供了一个GitHub模式，保证是最新的，所以我不需要异步获取自省模式。然后，我使用<a class="ae le" href="https://www.graphql-tools.com/" rel="noopener ugc nofollow" target="_blank"> graphql-tools </a> ' <code class="fe la lb lc ld b">wrapSchema</code>到<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/nestGraphQLEndpoint.ts#L44" rel="noopener ugc nofollow" target="_blank">用我的前缀</a>重命名类型。<code class="fe la lb lc ld b">wrapSchema</code>内部增加一个代理解析器，调用他们的<code class="fe la lb lc ld b">delegateToSchema</code>函数。由于我们自己处理所有的获取，我们可以用默认的GraphQL解析器覆盖这个解析器:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="fb81" class="ln lo iq ld b gy lp lq l lr ls">(source, _, _, info) =&gt; source[info.fieldName]</span></pre><p id="8887" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们使用graph QL-tools<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/nestGraphQLEndpoint.ts#L77" rel="noopener ugc nofollow" target="_blank">将包装的模式</a>合并到父模式中。这给了我们一个如下所示的对象扩展:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="ac73" class="ln lo iq ld b gy lp lq l lr ls">user {<br/>  githubApi {<br/>    errors {...}<br/>    query {...}<br/>    mutation {...}<br/>  }<br/>}</span></pre><p id="bbc3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，<code class="fe la lb lc ld b">errors</code>是它自己的字段，尽管它将由<code class="fe la lb lc ld b">query</code>或<code class="fe la lb lc ld b">mutation</code>的响应填充。通过设计，GraphQL使得一个字段似乎不可能填充另一个字段的响应。为了解决这个问题，<code class="fe la lb lc ld b">errors</code>字段返回一个承诺&amp;通过改变<code class="fe la lb lc ld b">source</code>将<code class="fe la lb lc ld b">resolve</code>回调暴露给其他操作。你可以称它为hacky，但我认为它非常干净😎。</p><h1 id="03bc" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">分批处理碎片</h1><p id="4b9b" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">在Urql、Apollo和Relay Modern出现之前，我写了一个糟糕的GraphQL客户端缓存，叫做<a class="ae le" href="https://github.com/mattkrick/cashay" rel="noopener ugc nofollow" target="_blank"> Cashay </a>。虽然这个项目没有取得任何进展，但它教会了我很多关于GraphQL AST的知识。例如，遍历AST很痛苦，但是GraphQL内置了一个节点访问者函数！</p><p id="7ed5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们的查询有一堆变量，但其中只有一部分需要发送到GitHub。我们如何确定哪些变量需要删减？这很简单，因为:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="c6ff" class="ln lo iq ld b gy lp lq l lr ls">const usedVariables = new Set&lt;string&gt;()<br/>graphql.visit(selectionSet, {<br/>  Variable(node) {<br/>    usedVariables.add(node.name.value)<br/>  },<br/>})</span></pre><p id="e0a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样的模式可以重复用于片段、变量定义(看起来像<code class="fe la lb lc ld b">$foo: String!, $bar: ID</code>的块)，甚至是我们加前缀的<code class="fe la lb lc ld b">__typename</code>字段。一旦每个片段都被重构为一个独立的查询，就应该将尽可能多的片段组合在一起并进行合并。</p><p id="fd5a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了完成批处理，我们使用关闭了缓存功能的<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/getDataLoader.ts#L9-L11" rel="noopener ugc nofollow" target="_blank">数据加载器</a>。为什么没有缓存？每个请求都有一个与其他请求稍有不同的查询。例如，一个片段可能要求<code class="fe la lb lc ld b">viewer {id}</code>，而另一个片段要求<code class="fe la lb lc ld b">viewer {id, bio}</code>。我们<em class="nl">希望</em>将它们合并在一起，如果我们基于键进行缓存，那么它们将被分开保存。</p><p id="3595" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也就是说，我们希望<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/getDataLoader.ts#L5" rel="noopener ugc nofollow" target="_blank">在整个执行过程中重用同一个数据加载器</a>，所以我们将所有的数据加载器保存在一个<code class="fe la lb lc ld b">WeakMap</code>中，其中键是<code class="fe la lb lc ld b">context</code>，因为每次调用<code class="fe la lb lc ld b">GraphQL.execute</code>都会创建一个新的<code class="fe la lb lc ld b">context</code>。通过使用<code class="fe la lb lc ld b">WeakMap</code>，我们防止了内存泄漏，因为一旦<code class="fe la lb lc ld b">GraphQL.execute</code>不再引用<code class="fe la lb lc ld b">context</code>，它也将从<code class="fe la lb lc ld b">WeakMap</code>被垃圾收集。</p><p id="562b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦一个滴答过去，dataloader用一个查询数组<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/batchFn.ts#L25" rel="noopener ugc nofollow" target="_blank">调用它的批处理函数&amp;变量，我们可以将这些变量合并在一起</a>。首先，<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/mergeGQLDocuments.ts#L108" rel="noopener ugc nofollow" target="_blank">我们合并所有具有唯一名称的字段</a>。然后，如果两个字段共享一个名称，<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/mergeGQLDocuments.ts#L124" rel="noopener ugc nofollow" target="_blank">我们比较它们的所有子字段</a>。如果两个字段不同，我们<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/mergeGQLDocuments.ts#L59-L67" rel="noopener ugc nofollow" target="_blank">将其中一个字段命名为</a>:</p><pre class="lf lg lh li gt lj ld lk ll aw lm bi"><span id="8b9a" class="ln lo iq ld b gy lp lq l lr ls"><strong class="ld ir"># Before</strong><br/>query {<br/>  repository(name: "parabol", owner: "parabolinc") {<br/>    id<br/>  }<br/>}<br/>query {<br/>  repository(name: "nest", owner: "mattkrick") {<br/>    id<br/>  }<br/>}</span><span id="b07c" class="ln lo iq ld b gy nj lq l lr ls"><strong class="ld ir"># After</strong><br/>query {<br/>  repository(name: "parabol", owner: "parabolinc") {<br/>    id<br/>  }<br/>  repository_2: repository(name: "nest", owner: "mattkrick") {<br/>    id<br/>  }<br/>}</span></pre><p id="71dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种策略允许我们将无限数量的片段一起批处理到一个网络请求中。我们只需要保存我们添加的别名列表，这样最终的响应看起来就像是<code class="fe la lb lc ld b"><strong class="ke ir">#Before</strong></code>请求。</p><h1 id="f92f" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">处理响应</h1><p id="fdcb" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">当GitHub响应时，它可能不是GraphQL对象。GitHub <a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/nestGitHubEndpoint.ts#L48" rel="noopener ugc nofollow" target="_blank">可能关闭了</a>，或者<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/nestGitHubEndpoint.ts#L37" rel="noopener ugc nofollow" target="_blank">网关可能需要太长时间来响应</a>，或者如果auth令牌无效，它可能只是发送<code class="fe la lb lc ld b">{message}</code>。为了处理这些情况，执行程序用一个超时&amp;来包装获取。如果响应看起来不像一个<code class="fe la lb lc ld b">GraphQLExecutionResult</code>，它将强制它成为一个。</p><p id="9304" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦我们有了形状为<code class="fe la lb lc ld b">{data, errors}</code>的东西，剩下要做的就是<a class="ae le" href="https://github.com/mattkrick/nest-graphql-endpoint/blob/main/src/batchFn.ts#L54-L57" rel="noopener ugc nofollow" target="_blank">为每个片段</a>创建一个响应对象。这意味着取消我们重命名的字段的别名，给<code class="fe la lb lc ld b">__typename</code>字段重新加前缀，并且<a class="ae le" href="https://github.com/ParabolInc/nest-graphql-endpoint/blob/main/src/filterErrorsForDocument.ts#L4-L23" rel="noopener ugc nofollow" target="_blank">通过片段</a>过滤错误。过滤错误很容易，因为大多数错误都有一个显示错误发生位置的<code class="fe la lb lc ld b">path</code>。例如，如果路径是<code class="fe la lb lc ld b">['viewer', 'repository_2']</code>，那么我们知道错误应该只出现在第二个片段中。</p><h1 id="29d8" class="lt lo iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="4282" class="pw-post-body-paragraph kc kd iq ke b kf mq kh ki kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz ij bi translated">嵌套GraphQL端点是GraphQL统治世界的下一步。在未来，每个服务都使用GraphQL模式，集成将轻而易举地实现，并且需要更少的代码。听起来很有趣？我们正在招聘。让我们一起做些酷的东西。</p></div></div>    
</body>
</html>