# 了解用于数据分析和报告的列存储格式与行存储格式

> 原文：<https://levelup.gitconnected.com/data-storage-and-reporting-understanding-columna-vs-row-storage-formats-8cae46347fa3>

![](img/499f90e4aca35242e9c2b9784151c926.png)

如果你曾经从事数据、报告或分析工作，你可能已经听说过 Big Query、Amplitude、Google Analytics、Snowflake、Redshift 和其他一些数据产品。此外，在开发应用程序时，您可能听说过 Postgres、MySQL 和 Oracle。

所有这些产品的核心都擅长管理数据，并提供大量数据的报告。您是否想过这些技术如何在几秒钟甚至更短的时间内有效地回答复杂的业务报告？从表面上看，每个数据集都可以表示为一个表。但是底层存储可能完全不同。这篇文章旨在简要概述这些数据库系统使用的两种主要数据存储格式——面向行和面向列的存储。

# 面向行的存储

这个名字听起来很有趣，但是面向行的存储是大多数关系数据库中的存储。MySQL、PostgreSQL 和其他数据库系统。它们将表的记录存储为行。每一行都是由模式定义的列的连续集合。这些行是您在访问和操作底层数据时可以查询的内容。

让我们举一个例子来快速理解面向行的系统中的存储和查询是什么样子的。

![](img/abdb88a76f968c1a2e2762137840c4e3.png)

上图显示了一个简单的雇员表。

1.  它有 3 列`employee_id, salary and title.`
2.  所有三列都有不同的数据类型。
3.  在这篇文章中，假设没有主键或索引。

**行存储布局将整行作为字节存储在磁盘上。一行中的所有列都是相邻存储的。若要读取行中的特定列，数据库必须加载整行，转到特定列，然后查找列值。**

考虑到这一点，你能想出一个数据库如何查找一个职位为'**行政管理员**'的员工吗？

由于我们没有索引，**我们的数据库必须从第一行开始执行全扫描。它将在内存中加载整行，获取最后一列的值，并查看文本是否与我们的查询匹配。然后重复搜索，直到找到具有给定职位的雇员。因为这个雇员不在我们的表中，所以我们不会在结果中得到任何行。**

如果我们量化数据库在这个查询中读取的数据量，它将是**每行 32 字节* 3 = 66 字节**。想象一下一个真实的数据库，我们正在扫描一个没有索引的列。对于跨越数千行的每个查询，可能需要数百兆字节。

现在考虑另一个场景— **找出职位为“总监”或“经理”的员工的平均工资。**在这种情况下，我们也从第一行开始搜索。我们可以先看看这个头衔是否与“经理”或“主管”相匹配。如果匹配，我们可以收集薪水，并将其与匹配的行数一起存储在一个临时变量中。同样，我们可以用同样的操作重复第二行和第三行。如果我们找到一个匹配的标题，我们对临时变量求和，最后，通过将和与计数相除来计算平均值。我们有平均值。

这里需要注意的一件重要事情是，每当我们发现一个匹配时，我们已经在内存中加载了 salary 列的值。这是面向行存储的好处之一。**一旦加载了一行，我们就可以访问和修改该行中的任何列。**这意味着通过读取 32 个字节，可以针对每一行访问所有列。无论是**选择*** 还是选择单列，读盘成本都是一样的。(当然，我不考虑内存、网络和带宽成本。)

出于本文的目的，从逻辑上讲，**无论查询中有多少列，行存储布局总是必须访问和扫描磁盘上的整行。这就是基于行的存储非常擅长事务处理的原因之一。可以锁定整行，并且可以对事务提供某些保证。**

*请注意，在现代数据库中可能会有查询优化，我没有涉及到。当我说扫描时，我指的是允许数据库物理读取和过滤数据的磁盘访问部分。磁盘访问模式与内存访问略有不同。*

# 基于行的存储分析

让事情变得更复杂的是，让我们看看另一个数据集和查询。假设下面的数据集有 100，000 行。对于下面显示的 12 列，还假设每行平均约为 250 字节。

![](img/6b89cdaabd41960b321ef3a332be432e.png)

埃及房价(从 Kaggle 借来)

下面是我们想回答的问题。

1.  这是埃及所有房价的总和。所有房屋的总价值。
2.  在埃及的任何房子里，最多有多少间卧室？

让我们独立完成这些查询。对于第一个，由于它是一个没有任何过滤器的求和操作，我们的数据库将尝试遍历每一行，获得价格列，并继续求和。就磁盘成本而言，它将遍历 100k 行，每行 250 字节。**总计约 25 Mb 的扫描数据，用于计算总和。**

第二个查询将进行类似的计算。我们的数据库将扫描所有行，并选择卧室的最大值。又扫描了另一个 **25 MB 的磁盘数据。**

如果我们想一次得到两个查询的结果，它仍然是 25 MB。

## **但是在这种情况下，如果我们只想要一些聚合，我们能做得更好吗？**

绝对的！这就是柱状存储发挥作用的地方。通过改变底层数据的存储方式，列存储旨在大幅提高查询速度。让我们举同样的例子，看看列数据存储是如何表示和查询的。

# 柱状数据存储

想象一下，您可以组织住房表，使每一列完全是一个单独的文件。因此，在磁盘上，不是将所有列都存储在一行中，而是将表拆分开来，将每一列存储为自己独立的文件。

以埃及房价为例，这意味着我们现在在磁盘上有 12 个文件。而每个文件的内容只是列值(如下所示)。

![](img/d50e139adf51bd02e760e96070ca09b6.png)

现在，让我们试着得到所有价格的总和。我们知道我们有 100K 行。并且每个价格列可以是 **4 字节长(整数假设)**。因此，如果我们要计算所有行的总和，我们将只读取整个文件并对数据求和。这反过来意味着**我们只扫描 800KB 的数据。比我们以前拥有的少得多。想象一下，如果我们像这样组织我们的列，并且我们的数据大小增长了 20 倍，那么查询的速度会有多快。与第一种情况相比，这仍然需要扫描更少的字节。当我们的分析查询一次只涉及一列或几列时，这种设置和存储布局特别有用。分析数据本质上可以跨越数 Pb 的数据点。从本质上讲，这就是列存储的意义所在。让我们再来看看我们最初的例子，看看组织。**

![](img/d28ff9e3b28273c829491a738bcf1f4f.png)

如果我们要比较的话，这张图只是把前面的表格调换了一下。

列存储格式将一列的所有值存储为一条记录。这意味着数据集的所有列都存储在一个连续的行中。因此，列存储中的一行表示该列的所有值。

**使用面向列的存储的优势主要在于分析和聚合查询。**这些通常涉及过滤、计算和在某组列上的单个列上的聚集。在列数据存储中，扫描单个列的所有记录速度极快。

列存储中查询和聚合运行速度更快的另一个原因是，一列中所有条目的数据类型都是相同的。因此，对它们执行操作是非常高效的。在列数据存储系统中，有一些特定的优化和计算(如 SIMD)可以大大加快查询速度。

列存储帮助的不仅仅是计算和聚合。柱状存储也能带来更好的压缩效果。原因是一样的。在列存储中，列值将是相同的数据类型。一列中的值可能是重复的，或者与类型更加一致，从而为我们更好地压缩数据提供了优势。当处理 100 千兆字节的数据时，性能提升可能是巨大的。

## 缺点

使用列存储进行分析似乎很简单，但是列存储也有一定的限制。因为我们现在以一种新的格式存储数据，并且每一列都是独立存储的，所以与行存储相比，我们没有行的事务性的好处。

此外，扫描列数据库的成本与列数成正比。想象一下，如果您的数据库有 200 多列，那么与面向行的存储相比，为 select *重建一整行 200 列的成本非常高。必须始终避免在列数据库上执行 select *。除非数据的列数很少。

# 结论

这篇文章试图让读者了解在行和列数据库中数据是如何组织的。考虑到这两种数据存储技术可以为不同的用例带来性能提升，考虑和建模数据以尽可能接近预期的查询是很重要的。无论是面向行还是面向列的数据库，理解并确定查询模式有助于我们更好地对数据建模。

例如，在面向行的存储中，如果给我的任务是在不使用列数据库的情况下创建报告摘要(以及其他一些考虑)，我甚至可以选择一个单独的表，其中只包含所需的维度，并聚合它们，而不是在基表上做所有的事情。如果我们操作一个有数百列的基表，而不是一个只有几个维度的临时表，这可能会节省大量的资源。

另一方面，列数据存储的美妙之处在于，无论我们查看多大规模的数据，报告的优化和收益都是非常显著的。因此，它是很多大数据系统的首选。每个提供商都可以宣传他们自己的特色。但几乎所有大数据分析仓库和系统的核心都是列存储。

现在您已经知道了什么是列存储，我的下一组文章将关注对 Apache Parquet 的理解——一种流行的列存储格式，以及它的实现。

> **敬请关注，请不要忘记关注我的更多内容！**