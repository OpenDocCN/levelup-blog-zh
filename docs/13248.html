<html>
<head>
<title>A Case Study on the Yocto Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Yocto项目案例研究</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-case-study-on-the-yocto-project-947bfe58eb0c?source=collection_archive---------5-----------------------#2022-08-19">https://levelup.gitconnected.com/a-case-study-on-the-yocto-project-947bfe58eb0c?source=collection_archive---------5-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ea8be94e63737a363084b463e86502c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*avF6XoD8ktOL8oEz.jpeg"/></div></div></figure><p id="35ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我们将通过构建一个真实的例子来解释什么是Yocto项目——条形码阅读器。所以我们开始吧！</p><h1 id="4137" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">介绍</h1><p id="0879" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">以下摘录摘自维基百科关于Yocto项目的文章。</p><blockquote class="lz ma mb"><p id="b4db" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated">Yocto项目是一个Linux基金会合作开源项目，其目标是开发工具和流程，为独立于嵌入式硬件底层架构的嵌入式和物联网软件创建Linux发行版。该项目由Linux基金会在2010年宣布，并于2011年3月与包括OpenEmbedded在内的22个组织合作启动。</p></blockquote><p id="4bad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这直接将我们引向OpenEmbedded构建系统。那么什么是OpenEmbedded和OpenEmbedded build system呢？以下摘录摘自OpenEmbedded上的维基百科文章。</p><blockquote class="lz ma mb"><p id="64d6" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated"><em class="iq"> OpenEmbedded是一个构建自动化框架和交叉编译环境，用于为嵌入式设备创建Linux发行版。OpenEmbedded框架由OpenEmbedded社区开发，该社区于2003年正式成立。OpenEmbedded是Yocto项目的推荐构建系统，yo CTO项目是一个Linux基金会工作组，帮助商业公司为嵌入式产品开发基于Linux的系统。</em></p><p id="3065" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated"><em class="iq">构建系统是基于BitBake“食谱”的，它指定了如何构建一个特定的包，但也包括依赖项和源代码位置的列表，以及如何安装和删除编译后的包的说明。OpenEmbedded工具使用这些方法来获取和修补源代码、编译和链接二进制文件、生成二进制文件包(ipk、deb、rpm)以及创建可引导映像。</em></p></blockquote><p id="0f29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面关于Yocto项目和OpenEmbedded的引用可以看出，两者是有区别的。然而，它们经常互换使用。简而言之；</p><blockquote class="lz ma mb"><p id="168e" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated">Yocto是一个伞式项目，用于构建你自己的Linux嵌入式发行版</p><p id="565b" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq"> OpenEmbedded是Yocto </em> </strong>的构建系统</p></blockquote><p id="d445" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OpenEmbedded利用工具<strong class="ka ir"> BitBake </strong>来做任何事情，从上面的摘录中可以看出。在下一节中，将尝试解释如何获得open embedded build system<strong class="ka ir">bit bake</strong>。</p><h1 id="e6b5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何准备主机系统</h1><p id="5b56" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">由于目标系统是Linux操作系统，<strong class="ka ir"> BitBake </strong>需要一个Linux操作系统作为主机，尤其是Debian/Ubuntu。Windows或MacOS上的Linux VM或Windows上的WSL可以用作构建机器，但由于性能问题和对磁盘空间的高需求，不推荐使用。在任何情况下，都需要一台Linux机器，即使是虚拟的或本地的。从现在开始，我们有两个选项来在宿主Linux机器上安装构建系统。</p><ul class=""><li id="aada" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">直接在主机上安装工具。</li><li id="5211" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">使用Docker获取整个构建系统。</li></ul><p id="91ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本教程中使用了后一种方法，因为第一种方法扰乱了主机系统，而第二种方法提供了一个隔离的系统。在Linux上，这两种方法的工作性能相同，因为Docker没有添加额外的工作层。但是在Window和MacOS上，Docker需要额外的Linux虚拟机，因此性能会降低。</p><p id="d142" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从现在开始，我们假设我们有一台Debian/Ubuntu Linux机器(本地的或虚拟的),并且我们可以通过SSH控制台访问这台机器。如果你对控制台感到不舒服，你可以使用teh VS Code远程SSH插件。</p><p id="18a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于第一种方法，您可以遵循文档Yocto项目快速构建。</p><p id="78f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于第二种方法，首先需要安装Docker引擎。为此，你可以按照Debian上的文档安装Docker引擎。我们还需要<strong class="ka ir"> git </strong>版本控制工具。它可以按如下方式安装</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a4b3" class="nd kx iq mz b gy ne nf l ng nh">$ sudo apt-get update $ sudo apt-get install git</span></pre><h1 id="be23" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何获得OpenEmbedded构建系统</h1><p id="cd4a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在我们在主机上已经有了所有需要的基础工具，我们可以从<strong class="ka ir"> Poky </strong>项目中获得<strong class="ka ir"> BitBake </strong>如下</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="ed1d" class="nd kx iq mz b gy ne nf l ng nh"># Create a working directory<br/>$ mkdir -p /mnt/Work/PROJs/rpi/yocto/src<br/>$ cd /mnt/Work/PROJs/rpi/yocto/src<br/><br/># getting latest stable build system branch kirkstone from yocto project repos<br/>$ git clone https://git.yoctoproject.org/poky -b kirkstone<br/><br/># return to yocto directory and run docker<br/>$ cd ..<br/>$ docker run --rm -it -v $(pwd):/workspace --workdir /workspace crops/poky:latest<br/><br/># exit to return host command prompt<br/>$ exit</span></pre><p id="3f06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发出最后一个命令后，如果在本地找不到容器映像，它将自动从<strong class="ka ir"> Docker Hub </strong>下载并运行容器，然后进入容器命令行提示符。现在我们有了一个完整的构建系统，但是没有要构建的源代码。我们将在下一节中获取资源。</p><h1 id="251d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何获得BitBake图层</h1><p id="535b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在<strong class="ka ir"> BitBake </strong>概念中，每组提供相同功能的源称为<strong class="ka ir">层</strong>或<strong class="ka ir">元层</strong>。事实上，它们不是一个可以构建的常规源代码。它们是用<strong class="ka ir"> BitBake </strong>语言编写的脚本，定义了如何获取源代码、修补源代码、构建源代码、依赖源代码以及集成到最终的目标映像中。我们需要为我们的项目以下几层。</p><ul class=""><li id="5723" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">meta-extra</strong>——添加一个普通sudo用户的自定义层</li><li id="ef46" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">meta-raspberrypi</strong>—RPI板支持包</li><li id="7690" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir"> meta-openembedded </strong> —附加的Linux工具</li><li id="0ef0" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">元虚拟化</strong>—Docker支持包</li></ul><p id="8313" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些源代码可以从以下相关位置下载</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a5fb" class="nd kx iq mz b gy ne nf l ng nh"># goto source folder<br/>$ cd /mnt/Work/PROJs/rpi/yocto/src<br/><br/># meta-extra<br/>$ git clone https://github.com/ierturk/yocto-meta-extra.git -b kirkstone meta-extra<br/><br/># meta-raspberrypi<br/>$ git clone https://git.yoctoproject.org/meta-raspberrypi -b kirkstone<br/><br/># meta-openembedded<br/>$ git clone https://git.openembedded.org/meta-openembedded -b kirkstone<br/><br/># meta-virtualization<br/>$ git clone https://git.yoctoproject.org/meta-virtualization -b kirkstone<!-- -->Now we have all the source to build the target image.</span></pre><h1 id="c402" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">配置和构建目标映像</h1><p id="3a5e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们的目标图像将用于开发，它将有很多工具，不会有生产图像，因此它会比生产图像大。然而，我们将遵循不同的方法来开发应用程序。我们将为应用程序使用Docker，所有未包含在基本映像中的必需包都将包含在Docker容器中。</p><p id="a4a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以开始配置和构建映像了</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="43a9" class="nd kx iq mz b gy ne nf l ng nh"># goto yocto directory and run Docker<br/>$ cd /mnt/Work/PROJs/rpi/yocto/src<br/>$ docker run --rm -it -v $(pwd):/workspace --workdir /workspace crops/poky:latest<br/><br/># We will drop into container command promt.<br/># Now the directory /mnt/Work/PROJs/rpi/yocto/src will be mounted<br/># as /workspace within the container, and we are in this directory.<br/><br/># Following command start a new build directory,<br/># and automatically drop into build directory<br/>$ . src/poky/oe-init-build-env<br/>### Shell environment set up for builds. ###<br/><br/>You can now run 'bitbake &lt;target&gt;'<br/><br/>Common targets are:<br/>    core-image-minimal<br/>    core-image-full-cmdline<br/>    core-image-sato<br/>    core-image-weston<br/>    meta-toolchain<br/>    meta-ide-support<br/><br/>You can also run generated qemu images with a command like 'runqemu qemux86'<br/><br/>Other commonly useful commands are:<br/> - 'devtool' and 'recipetool' handle common recipe tasks<br/> - 'bitbake-layers' handles common layer tasks<br/> - 'oe-pkgdata-util' handles common target package tasks</span></pre><p id="f374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么在目录<strong class="ka ir"> yocto </strong>下应该有一个如下的目录树。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="b022" class="nd kx iq mz b gy ne nf l ng nh">|-- build<br/>|   |-- conf<br/>|   |   |-- bblayers.conf<br/>|   |   |-- local.conf<br/>|   |   `-- templateconf.cfg<br/>`-- src<br/>    |-- meta-extra<br/>    |-- meta-openembedded<br/>    |-- meta-raspberrypi<br/>    |-- meta-virtualization<br/>    `-- poky</span></pre><p id="8d9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要编辑文件<strong class="ka ir"> bblayers.conf </strong>和<strong class="ka ir"> local.conf </strong>。它们是用内容创建的，需要在修补后应用。</p><p id="bbfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> bblayers.conf </strong>的补丁</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="472b" class="nd kx iq mz b gy ne nf l ng nh">diff initial/bblayers.conf final/bblayers.conf <br/>11a12,19<br/>&gt;   ${TOPDIR}/../src/meta-raspberrypi \<br/>&gt;   ${TOPDIR}/../src/meta-openembedded/meta-oe \<br/>&gt;   ${TOPDIR}/../src/meta-openembedded/meta-multimedia \<br/>&gt;   ${TOPDIR}/../src/meta-openembedded/meta-networking \<br/>&gt;   ${TOPDIR}/../src/meta-openembedded/meta-python \<br/>&gt;   ${TOPDIR}/../src/meta-openembedded/meta-filesystems \<br/>&gt;   ${TOPDIR}/../src/meta-virtualization \<br/>&gt;   ${TOPDIR}/../src/meta-extra \</span></pre><p id="b14f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> local.conf </strong>的补丁</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="efbb" class="nd kx iq mz b gy ne nf l ng nh">diff initial/local.conf final/local.conf <br/>36a37,38<br/>&gt; MACHINE ?= "raspberrypi3-64"<br/>&gt; #<br/>108c110<br/>&lt; PACKAGE_CLASSES ?= "package_rpm"<br/>---<br/>&gt; PACKAGE_CLASSES ?= "package_ipk"<br/>276a279,344<br/>&gt; <br/>&gt; # IMAGE_ROOTFS_EXTRA_SPACE = "16777216"<br/>&gt; <br/>&gt; # Systemd enable<br/>&gt; DISTRO_FEATURES:append = " systemd"<br/>&gt; VIRTUAL-RUNTIME_init_manager = "systemd"<br/>&gt; DISTRO_FEATURES_BACKFILL_CONSIDERED = "sysvinit"<br/>&gt; VIRTUAL-RUNTIME_initscripts = ""<br/>&gt; <br/>&gt; # Extra Users<br/>&gt; DISTRO_FEATURES:append = " pam"<br/>&gt; IMAGE_INSTALL:append = " extra-sudo"<br/>&gt; IMAGE_INSTALL:append = " extra-user"<br/>&gt; <br/>&gt; # Image features<br/>&gt; IMAGE_FEATURES:append = " hwcodecs bash-completion-pkgs"<br/>&gt; <br/>&gt; # Kernel Modules All<br/>&gt; # IMAGE_INSTALL:append = " kernel-modules"<br/>&gt; # IMAGE_INSTALL:append = " linux-firmware"<br/>&gt; <br/>&gt; # OpenGL<br/>&gt; DISTRO_FEATURES:append = " opengl"<br/>&gt; <br/>&gt; # Dev Tools<br/>&gt; IMAGE_FEATURES:append = " tools-debug"<br/>&gt; EXTRA_IMAGE_FEATURES:append = " ssh-server-openssh"<br/>&gt; <br/>&gt; # Virtualization<br/>&gt; DISTRO_FEATURES:append = " virtualization"<br/>&gt; IMAGE_INSTALL:append = " docker-ce"<br/>&gt; IMAGE_INSTALL:append = " python3-docker-compose"<br/>&gt; IMAGE_INSTALL:append = " python3-distutils"<br/>&gt; <br/>&gt; # Network manager<br/>&gt; IMAGE_INSTALL:append = " wpa-supplicant"<br/>&gt; IMAGE_INSTALL:append = " networkmanager" <br/>&gt; IMAGE_INSTALL:append = " modemmanager"<br/>&gt; IMAGE_INSTALL:append = " networkmanager-nmcli"<br/>&gt; IMAGE_INSTALL:append = " networkmanager-nmtui"<br/>&gt; <br/>&gt; # USB Camera<br/>&gt; IMAGE_INSTALL:append = " kernel-module-uvcvideo"<br/>&gt; IMAGE_INSTALL:append = " v4l-utils"<br/>&gt; <br/>&gt; # RPi<br/>&gt; ENABLE_UART = "1"<br/>&gt; <br/>&gt; # Date Time Daemon<br/>&gt; # IMAGE_INSTALL:append = " ntpdate"<br/>&gt; <br/>&gt; # Tools<br/>&gt; IMAGE_INSTALL:append = " git"<br/>&gt; IMAGE_INSTALL:append = " curl"<br/>&gt; IMAGE_INSTALL:append = " wget"<br/>&gt; IMAGE_INSTALL:append = " rsync"<br/>&gt; IMAGE_INSTALL:append = " sudo"<br/>&gt; IMAGE_INSTALL:append = " nano"<br/>&gt; IMAGE_INSTALL:append = " socat"<br/>&gt; IMAGE_INSTALL:append = " tzdata"<br/>&gt; IMAGE_INSTALL:append = " e2fsprogs-resize2fs gptfdisk parted util-linux udev"<br/>&gt; <br/>&gt; # VS Code reqs<br/>&gt; IMAGE_INSTALL:append = " ldd"<br/>&gt; IMAGE_INSTALL:append = " glibc"<br/>&gt; IMAGE_INSTALL:append = " libstdc++"</span></pre><p id="51fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在只需键入以下命令，然后你需要等待相当长的时间来获得目标图像。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="82c6" class="nd kx iq mz b gy ne nf l ng nh">$ bitbake core-image-base</span></pre><h1 id="c46a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">闪烁图像</h1><p id="8f16" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">您会发现该映像的名称为<strong class="ka ir">build/tmp/deploy/images/raspberrypi 3–64/core-image-base-raspberrypi 3–64 . wic . bz2</strong>。在<strong class="ka ir"> Unix </strong>系统中，镜像可以按如下方式刷新。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="08f4" class="nd kx iq mz b gy ne nf l ng nh"># Unzip image<br/>$ bzip2 -d -f ./core-image-base-raspberrypi3-64.wic.bz2<br/><br/># Flash to SD Card<br/># Here you need to change sdX with your SD Card reader device.<br/>$ sudo dd if=./core-image-base-raspberrypi3.wic of=/dev/sdX bs=1m</span></pre><h1 id="bf61" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第一轮</h1><p id="4268" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">最后，你有一个SD卡有<strong class="ka ir">rpi 3–64位操作系统</strong>图像。只需插入您的<strong class="ka ir"> RPI3 </strong>，然后通电。如果您已经知道您的RPI IP地址，您可以通过SSH控制台以root用户身份登录，无需密码，或者使用默认密码<strong class="ka ir"> 1200 </strong>与用户<strong class="ka ir"> ierturk </strong>登录。首次登录时，系统请求更改用户<strong class="ka ir">伊尔图尔克</strong>的密码。这个用户也是一个sudo用户。</p><h1 id="c364" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">额外调整</h1><p id="648a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了保持图像尺寸更小并适合任何SD卡，根文件系统被保持得尽可能小。现在它需要扩展如下。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a4a0" class="nd kx iq mz b gy ne nf l ng nh"># login as root user over SSH<br/>$ ssh root@ip_address_of_the_rpi<br/><br/># following command list your memory blocks<br/>$ lsblk<br/>NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS<br/>mmcblk0     179:0    0  XXXG  0 disk <br/>|-mmcblk0p1 179:1    0 69.1M  0 part /boot<br/>`-mmcblk0p2 179:2    0   XXG  0 part /<br/><br/># here mmcblk0p2 needs to be expanded to its max<br/>$ parted /dev/mmcblk0 resizepart 2 100%<br/>$ resize2fs /dev/mmcblk0p2<br/><br/># then it looks like as follow<br/>$ lsblk<br/>NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS<br/>mmcblk0     179:0    0 29.1G  0 disk <br/>|-mmcblk0p1 179:1    0 69.1M  0 part /boot<br/>`-mmcblk0p2 179:2    0   29G  0 part /</span></pre><p id="a572" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一切都好了。现在输入下面的命令来测试你的Docker安装</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="5e1d" class="nd kx iq mz b gy ne nf l ng nh">$ docker info<br/>Client:<br/> Context:    default<br/> Debug Mode: false<br/><br/>Server:<br/> Containers: 0<br/>  Running: 0<br/>  Paused: 0<br/>  Stopped: 0<br/> Images: 2<br/> Server Version: 20.10.12-ce<br/> Storage Driver: overlay2<br/>  Backing Filesystem: extfs<br/>  Supports d_type: true<br/>  Native Overlay Diff: true<br/>  userxattr: false<br/> Logging Driver: json-file<br/> Cgroup Driver: cgroupfs<br/> Cgroup Version: 1<br/> Plugins:<br/>  Volume: local<br/>  Network: bridge host ipvlan macvlan null overlay<br/>  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog<br/> Swarm: inactive<br/> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc<br/> Default Runtime: runc<br/> Init Binary: docker-init<br/> containerd version: d12516713c315ea9e651eb1df89cf32ff7c8137c.m<br/> runc version: v1.1.2-9-gb507e2da-dirty<br/> init version: b9f42a0-dirty<br/> Kernel Version: 5.15.34-v8<br/> Operating System: Poky (Yocto Project Reference Distro) 4.0.2 (kirkstone)<br/> OSType: linux<br/> Architecture: aarch64<br/> CPUs: 4<br/> Total Memory: 909MiB<br/> Name: raspberrypi3-64<br/> ID: SKCZ:5JOV:CLCE:ECSC:UJ46:VGCH:YAFW:TNOF:J3FN:WO26:FHIO:BHRR<br/> Docker Root Dir: /var/lib/docker<br/> Debug Mode: false<br/> Registry: https://index.docker.io/v1/<br/> Labels:<br/> Experimental: false<br/> Insecure Registries:<br/>  127.0.0.0/8<br/> Live Restore Enabled: false<br/><br/>WARNING: No memory limit support<br/>WARNING: No swap limit support<br/>WARNING: No kernel memory TCP limit support<br/>WARNING: No oom kill disable support<br/>WARNING: No blkio throttle.read_bps_device support<br/>WARNING: No blkio throttle.write_bps_device support<br/>WARNING: No blkio throttle.read_iops_device support<br/>WARNING: No blkio throttle.write_iops_device support</span></pre><p id="2ac9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一个没有任何<strong class="ka ir">桌面</strong>的基础系统来使用<strong class="ka ir"> Docker </strong>开发应用。</p><h1 id="6403" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用Docker容器和Docker Compose开发一个简单的条形码阅读器应用程序，无需修改基础系统</h1><p id="4a68" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们将使用两个Docker容器，如下所示</p><ul class=""><li id="62de" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">VNC支持的窗口管理器作为wayland服务器</li><li id="403b" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">作为wayland客户端的应用服务器</li></ul><p id="7058" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要建造它们。为此，可以使用<strong class="ka ir"> Docker build </strong>在本地构建容器映像，或者使用<strong class="ka ir">Docker buildx</strong>构建多个架构。</p><p id="004c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将遵循另一种构建容器的方法。我们将使用<strong class="ka ir"> GitHub </strong>动作来构建容器并将它们作为CI/CD自动推送到HubDocker。我们需要一个名为<strong class="ka ir"> Dockerfile </strong>的配方文件来构建容器映像。这里的<strong class="ka ir"> Alpine Linux </strong>用于容器以获得更小的容器映像。下面的docker文件用于包含支持VNC的windows manager SwayWm(一个wayland合成器)的容器。它看起来就像一个bash脚本。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="8979" class="nd kx iq mz b gy ne nf l ng nh"># Dockerfile SwayWM<br/>ARG ALPINE_VERSION=3.16<br/>FROM alpine:${ALPINE_VERSION}<br/><br/>ENV USER="vnc-user" \<br/>    APK_ADD="mesa-dri-swrast openssl socat sway xkeyboard-config" \<br/>    APK_DEL="bash curl" \<br/>    VNC_LISTEN_ADDRESS="0.0.0.0" \<br/>    VNC_AUTH_ENABLE="false" \<br/>    VNC_KEYFILE="key.pem" \<br/>    VNC_CERT="cert.pem" \<br/>    VNC_PASS="$(pwgen -yns 8 1)"<br/><br/>RUN apk update \<br/>    &amp;&amp; apk upgrade<br/><br/># Add packages<br/>RUN apk add --no-cache $APK_ADD<br/><br/># Add fonts<br/>RUN apk add --no-cache msttcorefonts-installer fontconfig \<br/>    &amp;&amp; update-ms-fonts<br/><br/># Add application user<br/>RUN addgroup -g 1000 $USER &amp;&amp; adduser -u 1000 -G $USER -h /home/$USER -D $USER<br/><br/># Iinstall vnc packages<br/>RUN apk add --no-cache wayvnc neatvnc<br/><br/># Copy sway config<br/>COPY assets/swayvnc/config /etc/sway/config<br/>COPY assets/swayvnc/kms.conf /etc/kms.conf<br/><br/># Add wayvnc to compositor startup and put IPC on the network<br/>RUN mkdir /etc/sway/config.d \<br/>    &amp;&amp; echo "exec wayvnc 0.0.0.0 5900" &gt;&gt; /etc/sway/config.d/exec \<br/>    &amp;&amp; echo "exec \"socat TCP-LISTEN:7023,fork UNIX-CONNECT:/run/user/1000/sway-ipc.sock\"" &gt;&gt; /etc/sway/config.d/exec \<br/>    &amp;&amp; mkdir -p /home/$USER/.config/wayvnc/ \<br/>    &amp;&amp; printf "\<br/>address=$VNC_LISTEN_ADDRESS\n\<br/>enable_auth=$VNC_AUTH_ENABLE\n\<br/>username=$USER\n\<br/>password=$VNC_PASS\n\<br/>private_key_file=/home/$USER/$VNC_KEYFILE\n\<br/>certificate_file=/home/$USER/$VNC_CERT" &gt; /home/$USER/.config/wayvnc/config<br/><br/># Generate certificates vor VNC<br/>RUN openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 -nodes \<br/>	-keyout key.pem -out cert.pem -subj /CN=localhost \<br/>	-addext subjectAltName=DNS:localhost,DNS:localhost,IP:127.0.0.1<br/><br/># Add entrypoint<br/>USER $USER<br/>COPY assets/swayvnc/entrypoint.sh /<br/>ENTRYPOINT ["/entrypoint.sh"]</span></pre><p id="451b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下YML文件用于Github操作。有了这些文件，你就可以在DockerHub上得到三种架构(linux/amd64，linux/arm64，linux/arm/v7)的Dockar容器镜像。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="27d1" class="nd kx iq mz b gy ne nf l ng nh">name: Alpine SwayVnc<br/><br/>on:<br/>  push:<br/>    branches:<br/>      - master<br/><br/>jobs:<br/>  docker:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      -<br/>        name: Checkout<br/>        uses: actions/checkout@v3<br/>      -<br/>        name: Docker meta<br/>        id: meta<br/>        uses: docker/metadata-action@v4<br/>        with:<br/>          images: |<br/>            ierturk/alpine-swayvnc<br/>          tags: |<br/>            type=raw,value={{date 'YYYYMMDD-hhmm'}}<br/>      -<br/>        name: Set up QEMU<br/>        uses: docker/setup-qemu-action@v2<br/>      -<br/>        name: Set up Docker Buildx<br/>        uses: docker/setup-buildx-action@v2<br/>      -<br/>        name: Login to DockerHub<br/>        uses: docker/login-action@v2<br/>        with:<br/>          username: ${{ secrets.DOCKER_HUB_USERNAME }}<br/>          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}<br/>      -<br/>        name: Build and push<br/>        uses: docker/build-push-action@v3<br/>        with:<br/>          context: ./Alpine<br/>          file: ./Alpine/swayvnc.Dockerfile<br/>          platforms: linux/amd64, linux/arm64, linux/arm/v7<br/>          push: true<br/>          tags: ${{ steps.meta.outputs.tags }}, ierturk/alpine-swayvnc:latest<br/>          labels: ${{ steps.meta.outputs.labels }}<br/>          cache-from: type=registry,ref=ierturk/alpine-swayvnc:latest<br/>          cache-to: type=inline<br/>      -<br/>        name: Image digest<br/>        run: echo ${{ steps.docker_build.outputs.digest }}</span></pre><p id="16ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有资料都可以在相关的GitHub repo上找到。所有需要的容器也将被构建，然后由这个repo使用GitHub动作来推送。现在，集装箱已准备好在<strong class="ka ir">码头</strong>上使用。现在可以输入下面的代码来运行容器，并且可以通过一个<strong class="ka ir"> VNC浏览器</strong>连接到<strong class="ka ir">桌面SwayWM </strong>。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a81c" class="nd kx iq mz b gy ne nf l ng nh">$ export LISTEN_ADDRESS="0.0.0.0"; docker run -e XDG_RUNTIME_DIR=/tmp \<br/>             -e WLR_BACKENDS=headless \<br/>             -e WLR_LIBINPUT_NO_DEVICES=1 \<br/>             -e SWAYSOCK=/tmp/sway-ipc.sock<br/>             -p${LISTEN_ADDRESS}:5900:5900 \<br/>             -p${LISTEN_ADDRESS}:7023:7023 ierturk/alpine-swayvnc</span></pre><p id="1a3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后你会第一次看到你的桌面。这不是一个普通的桌面，而是一个轻量级的。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/b89559a616b56b7ab1f827eb54f5965a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*59s-bxiNB_KU0NdU.png"/></div></div></figure><p id="e5a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，通过键入一个长命令行来启动容器并不是一种正确的方式。幸运的是，有另一个工具可以更方便地做到这一点。我们将通过使用工具<strong class="ka ir"> Docker-Compose </strong>来运行容器。Docker-Compose使用一个YML文件来运行容器。这是一次运行多个容器的另一个方法。它看起来像如下</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="df20" class="nd kx iq mz b gy ne nf l ng nh">version: '2.4'<br/><br/>services:<br/>  swayvnc:<br/>    image: ierturk/alpine-swayvnc:latest<br/>    volumes:<br/>      - type: bind<br/>        source: /tmp<br/>        target: /tmp<br/>      - type: bind<br/>        source: /run/user/1000<br/>        target: /run/user/1000<br/>      - type: bind<br/>        source: /dev<br/>        target: /dev<br/>      - type: bind<br/>        source: /run/udev<br/>        target: /run/udev<br/>      - type: bind<br/>        source: ../..<br/>        target: /workspace<br/>    cap_add:<br/>      - CAP_SYS_TTY_CONFIG<br/>    # Add device access rights through cgroup...<br/>    device_cgroup_rules:<br/>      # ... for tty0<br/>      - 'c 4:0 rmw'<br/>      # ... for tty7<br/>      - 'c 4:7 rmw'<br/>      # ... for /dev/input devices<br/>      - 'c 13:* rmw'<br/>      - 'c 199:* rmw'<br/>      # ... for /dev/dri devices<br/>      - 'c 226:* rmw'<br/>      - 'c 81:* rmw'<br/>    entrypoint: /entrypoint.sh<br/>    network_mode: host<br/>    privileged: true<br/>    environment:<br/>      - XDG_RUNTIME_DIR=/run/user/1000<br/>      - WLR_BACKENDS=headless<br/>      - WLR_LIBINPUT_NO_DEVICES=1<br/>      - SWAYSOCK=/run/user/1000/sway-ipc.sock<br/><br/>  app:<br/>    image: ierturk/alpine-dev-qt:latest<br/>    security_opt:<br/>      - seccomp:unconfined<br/>    shm_size: '256mb'<br/>    volumes:<br/>      - type: bind<br/>        source: /tmp<br/>        target: /tmp<br/>      - type: bind<br/>        source: /run/user/1000<br/>        target: /run/user/1000<br/>      - type: bind<br/>        source: /dev<br/>        target: /dev<br/>      - type: bind<br/>        source: /run/udev<br/>        target: /run/udev<br/>      - type: bind<br/>        source: ../..<br/>        target: /workspace<br/>      # - type: bind<br/>      #   source: ~/.ssh<br/>      #   target: /home/ierturk/.ssh<br/>      #   read_only: true<br/>    cap_add:<br/>      - CAP_SYS_TTY_CONFIG<br/>      - SYS_PTRACE<br/>    # Add device access rights through cgroup...<br/>    device_cgroup_rules:<br/>      # ... for tty0<br/>      - 'c 4:0 rmw'<br/>      # ... for tty7<br/>      - 'c 4:7 rmw'<br/>      # ... for /dev/input devices<br/>      - 'c 13:* rmw'<br/>      - 'c 199:* rmw'<br/>      # ... for /dev/dri devices<br/>      - 'c 226:* rmw'<br/>      - 'c 81:* rmw'<br/>    stdin_open: true<br/>    tty: true<br/>    network_mode: host<br/>    privileged: true<br/>    environment:<br/>      - WAYLAND_USER=ierturk<br/>      - XDG_RUNTIME_DIR=/run/user/1000<br/>      - WAYLAND_DISPLAY=wayland-1<br/>      - DISPLAY=:0<br/>      - QT_QPA_PLATFORM=wayland<br/>      - QT_QPA_EGLFS_INTEGRATION="eglfs_kms"<br/>      - QT_QPA_EGLFS_KMS_ATOMIC="1"<br/>      - QT_QPA_EGLFS_KMS_CONFIG="/etc/kms.conf"      <br/>      - IGNORE_X_LOCKS=1<br/>      - QT_IM_MODULE=qtvirtualkeyboard<br/>    user: ierturk<br/>    working_dir: /workspace<br/>    depends_on:<br/>      - swayvnc</span></pre><p id="bdd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有两个服务定义。其中一个用于显示管理器，另一个用于应用程序。现在，它可以只是键入如下的一切ups和运行。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="33a8" class="nd kx iq mz b gy ne nf l ng nh">$ docker-compose -f Alpine/swayvnc-dc.yml up -d<br/>Creating alpine_swayvnc_1 ... done<br/>Creating alpine_app_1 ... done</span></pre><p id="7c2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它们都已启动并运行，相互连接并连接到基础系统资源。从现在开始，我们可以登录到应用程序容器如下</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="b32a" class="nd kx iq mz b gy ne nf l ng nh">$ docker exec -it alpine_app_1 ash</span></pre><p id="f034" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在这里运行任何任意应用程序，我们将尝试一个条形码阅读器— ZXing-C++。对于示例UI，我们将使用<strong class="ka ir"> OpenCV </strong>和<strong class="ka ir"> Qt5 — QuickControl 2 </strong> (QML类型)和一个<strong class="ka ir"> USB摄像头</strong>。条形码阅读器库源代码可通过<strong class="ka ir"> CMake </strong>下载并构建，如下所示</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="deb9" class="nd kx iq mz b gy ne nf l ng nh">$ git clone https://github.com/nu-book/zxing-cpp.git <br/># <!-- -->then go into zxing-cpp <!-- -->directory and craete a build folder <br/>$ cd zxing-cpp <br/>$ mkdir build <br/>$ cd build <br/>$ cmake .. <br/>$ make</span><span id="2e2e" class="nd kx iq mz b gy nj nf l ng nh"># then run the application <br/>$ ./example/ZXingOpenCV</span></pre><p id="2721" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会看到一些类似以下图像的屏幕</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/63cc2682938891f2fbab95a3dcf25cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0X4-IoknHOm6fs6_.png"/></div></div></figure><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/c85c0c17d6a16bfea18164f33ba1e1c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*liMhj0dbnO0s6f05.png"/></div></div></figure><p id="ad48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切顺利，我们可以退出容器命令行，关闭所有容器，如下所示</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="7223" class="nd kx iq mz b gy ne nf l ng nh"># close app application <br/># just press CTRL-C <br/>$ exit <br/>$ docker-compose -f Alpine/swayvnc-dc.yml down <br/>Stopping alpine_app_1 ... done <br/>Stopping alpine_swayvnc_1 ... done <br/>Removing alpine_app_1 ... done <br/>Removing alpine_swayvnc_1 ... done</span></pre><p id="3eab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，不会留下任何东西，容器将被停止和删除。</p><p id="cc43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后这是我的<strong class="ka ir"> RPI3 </strong>带<strong class="ka ir"> USB摄像头</strong>。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/946c67c8ef767549b5990a6cf0ff506d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i3EYVXOX48OZJp-P.jpeg"/></div></div></figure><h1 id="6491" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="2fcd" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">直到现在，我们从零开始开发了整个系统。你可以看到它在工作。你可以在这方面下功夫，根据你的要求修改一些部分。</p><p id="5003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你喜欢这个教程，觉得有用。感谢您的阅读。</p><p id="ab2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发布于:2022年8月20日长度:16分钟阅读，3206字类别:<a class="ae nl" href="https://erturk.me/categories/programming" rel="noopener ugc nofollow" target="_blank">编程</a> <a class="ae nl" href="https://erturk.me/categories/engineering" rel="noopener ugc nofollow" target="_blank">工程</a>系列:<a class="ae nl" href="https://erturk.me/series/getting-started" rel="noopener ugc nofollow" target="_blank">入门</a>标签:<a class="ae nl" href="https://erturk.me/tags/qt" rel="noopener ugc nofollow" target="_blank">qt</a>T8】yoctoT10】open embedded<a class="ae nl" href="https://erturk.me/tags/rpi" rel="noopener ugc nofollow" target="_blank">rpi</a><a class="ae nl" href="https://erturk.me/tags/docker" rel="noopener ugc nofollow" target="_blank">docker</a><a class="ae nl" href="https://erturk.me/tags/github" rel="noopener ugc nofollow" target="_blank">github</a>参见:<a class="ae nl" href="https://erturk.me/blog/getting-started-qt-with-vs-code/" rel="noopener ugc nofollow" target="_blank">入门使用VS代码开发容器开发Qt尽可能简单的</a></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="de65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mc">原载于2022年8月19日</em><a class="ae nl" href="https://erturk.me/blog/a-case-study-on-the-yocto-project/" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://er Turk . me</em></a><em class="mc">。</em></p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="6861" class="kw kx iq bd ky kz nt lb lc ld nu lf lg lh nv lj lk ll nw ln lo lp nx lr ls lt bi translated">分级编码</h1><p id="5629" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="bca9" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="44d7" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">📰查看<a class="ae nl" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="3050" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">🔔关注我们:<a class="ae nl" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae nl" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nl" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="b764" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🚀👉<a class="ae nl" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>