<html>
<head>
<title>Concurrency in Go: shared memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的并发性:共享内存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/concurrency-in-go-shared-memory-a2ef201b396b?source=collection_archive---------2-----------------------#2022-10-15">https://levelup.gitconnected.com/concurrency-in-go-shared-memory-a2ef201b396b?source=collection_archive---------2-----------------------#2022-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8da3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更好地理解Go的内存模型在并发程序上的表现，我一直在研究一些例子。我将尝试解释我在多核CPU上操作排序方面所学到的知识。</p><p id="a8b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我要展示的例子是Russ Cox在他的<a class="ae km" href="https://research.swtch.com/hwmm" rel="noopener ugc nofollow" target="_blank">硬件模型文章</a>中写的<em class="kl">消息传递</em>例子的扩展。读完之后，我想尝试一下这种行为，亲自看看。这就是结果。</p><h1 id="4a72" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">艾丽丝和鲍勃在办公室</h1><p id="2c4d" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">爱丽丝和鲍勃共用一间办公室。他们的轮班有时会重叠，但他们通常在不同的时间开始和结束。他们进去，做他们的工作，然后离开。然而他们有一个规则:最后一个离开的人必须关灯。问题是爱丽丝可能来得很早，甚至在鲍勃到达之前就离开了，所以当鲍勃离开时，他不知道爱丽丝是已经离开了还是还没有到达。他们想出了一个让彼此知道他们的工作已经完成的系统:当他们离开办公室时，他们在办公室的另一边放上一面旗子。这样，他们中的任何一个在离开之前，如果看到对面的旗子升起，就可以关灯并放下旗子。</p><p id="5f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">让我们用代码建模:</strong></p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><blockquote class="lx ly lz"><p id="a797" class="jn jo kl jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated"><em class="iq">为了叙述方便，我们暂且忽略</em> <code class="fe md me mf mg b"><em class="iq">sync.WaitGroup</em></code> <em class="iq">。这个练习的重点是强调Go同步模型的缺陷，这样我们可以更好地理解并发安全代码是如何(以及为什么)构建的。</em></p></blockquote><p id="99d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码很简单。假设一个<code class="fe md me mf mg b">Office</code>亮着灯开始它的一天，在所有工人跑完<code class="fe md me mf mg b">Work</code>之后，<code class="fe md me mf mg b">Office.lights</code>应该是关着的。</p><p id="19af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逻辑上，只能有三种情况:</p><ol class=""><li id="e0f6" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir">爱丽丝关灯:</strong>鲍勃的goroutine第一个完成</li></ol><p id="000c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.鲍勃关灯:爱丽丝的goroutine第一个完成</p><p id="512f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.他们都关掉了灯:他们同时升起了他们的旗帜</p><p id="0da2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设goroutines被公平地调度，那么从外部的角度来看，有一组交错的操作可以被看作是连续的。每一个事件都发生在一个<em class="kl">总的全局秩序</em>中。这使得第三种情况成为可能。在一个顺序一致的环境中，不可能有第四种情况<strong class="jp ir">没有人</strong>关灯。</p><p id="44b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让Bob关灯，我们假设Bob是到达<code class="fe md me mf mg b">if</code>语句的最后一个goroutine。我们肯定地知道<code class="fe md me mf mg b">f.flag[Bob]</code>是真的，因为它刚刚被设置在这个goroutine中。为了让鲍勃<strong class="jp ir">而不是</strong>关灯，<code class="fe md me mf mg b">f.flag[Alice]</code>必须为假，这意味着爱丽丝一定没有完成她的工作，所以鲍勃不是办公室里的最后一个人:这是一个矛盾。</p><p id="8098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过一个测试来看看这一点:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ec65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当单独运行时，测试很可能会通过。但是我们的代码中有一个错误。显而易见，我们应该使用并发结构，如通道、互斥、原子操作或等待组来正确指示他们的工作日已经结束，灯应该关闭。然而，一开始我并不清楚为什么这段代码是错误的，如果这样保存会出现什么问题。</p><p id="5530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了突出问题，请观察如果我运行这个测试一百万次会发生什么:</p><pre class="lq lr ls lt gt mq mg mr ms aw mt bi"><span id="6759" class="mu ko iq mg b gy mv mw l mx my">$ go test -count=1000000 .<br/>--- FAIL: Test_WorkingDays (0.00s)<br/>    mem_test.go:49: lights shouldn\'t be on after both finished their work<br/>--- FAIL: Test_WorkingDays (0.00s)<br/>    mem_test.go:49: lights shouldn\'t be on after both finished their work<br/>... (x15)<br/>FAIL<br/>FAIL	github.com/fredrb/concurrency/memory	10.114s<br/>FAIL</span></pre><p id="dfee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这项测试失败了17次，但通过了999983次。怎么可能呢？</p><blockquote class="lx ly lz"><p id="8b56" class="jn jo kl jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated"><em class="iq">免责声明:可能有些部分我不能完全理解，但我会尽我所能解释清楚。</em></p></blockquote><p id="e161" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要原因归结为多核CPU在与主内存同步之前缓存数据。在不同的体系结构中，行为(以及为什么会发生这种情况的原因)可能会有所不同。在x86中，每个访问共享内存的线程都有一个缓冲区写队列。每当线程必须从共享内存中读取数据时，首先从队列中读取值。这意味着一个线程比其他线程先看到自己的写操作。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/3eb16c66fe3bcb633794ddc300f6c01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JgvGIqLroJF1PNi-kvElaw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae km" href="https://research.swtch.com/hwmm" rel="noopener ugc nofollow" target="_blank"> Russ Cox:硬件内存模型帖子</a></figcaption></figure><p id="9725" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果两个goroutines被调度到不同的CPU内核，下面的内存模型是有效的，尽管可能性不大:</p><ul class=""><li id="7aa0" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk nk mn mo mp bi translated"><strong class="jp ir">线程1: </strong> <code class="fe md me mf mg b">flag: [ true, false ]</code> = &gt;不要关灯</li><li id="b656" class="mh mi iq jp b jq nl ju nm jy nn kc no kg np kk nk mn mo mp bi translated"><strong class="jp ir">线程2: </strong> <code class="fe md me mf mg b">flag: [ false, true ]</code> = &gt;不要关灯</li></ul><p id="29cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果出现以下情况，可能会导致此症状:</p><ol class=""><li id="09d4" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">写操作没有被传播，它位于相反线程的写缓冲区中</li><li id="9cbd" class="mh mi iq jp b jq nl ju nm jy nn kc no kg np kk mm mn mo mp bi translated">写操作被应用到主存储器，但是a线程从其高速缓存中读取数据</li></ol><p id="7562" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现代CPU架构<strong class="jp ir">不</strong>提供连续一致的环境。使得这个例子的第四种情况成为可能:<strong class="jp ir">没有人</strong>关灯。</p><p id="d21e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">证明CPU是罪魁祸首的一个有趣方法是只用一个CPU运行相同数量的测试:</p><pre class="lq lr ls lt gt mq mg mr ms aw mt bi"><span id="31ad" class="mu ko iq mg b gy mv mw l mx my">$ go test -cpu 1 -count=1000000 . <br/>ok github.com/fredrb/concurrency/memory	6.824s</span></pre><p id="63ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果只有一个CPU的话，你可以提高这个数字，测试总是会通过的。这是因为所有的goroutines都被调度到同一个OS线程。</p><h2 id="465c" class="mu ko iq bd kp nq nr dn kt ns nt dp kx jy nu nv lb kc nw nx lf kg ny nz lj oa bi translated">修复程序</h2><p id="6f04" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们希望我们的程序在多个内核上运行，所以我们需要解决这个问题。幸运的是，修复相当简单。在并发编程中有一个概念叫做<em class="kl">内存屏障</em>或<em class="kl">内存栅栏</em>，Go的并发API在幕后使用它来同步CPU的缓存和主内存。Go对并发操作有着惊人的一流支持。有许多方法可以解决这个问题，但最直接的方法是使用锁。</p><p id="3954" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">编辑:</strong>正如向我指出的，我下面提出的原始解决方案仍然存在问题。尽管测试会通过，但是在一个goroutine中设置共享变量会产生一个竞争条件——即使没有其他goroutine是活动的。另外，由于没有同步机制，在<code class="fe md me mf mg b">if</code>块中更新的数据有可能不会被其他goroutines看到。这是包含竞争条件的原始解决方案:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我试着变聪明。别耍小聪明。</p><p id="290d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个使用互斥的更好的解决方案:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="84a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单独运行可能会更慢，因为内存障碍是在存储和加载操作之前添加的，但这在我们的示例中可以忽略不计。</p><h1 id="10c9" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">进一步阅读</h1><p id="cd8d" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">如果您对此感兴趣，并想了解更多关于该主题的内容，我已经使用了以下资源来了解我的程序的行为:</p><ul class=""><li id="f3b6" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk nk mn mo mp bi translated">拉斯考克斯记忆模型系列:<a class="ae km" href="https://research.swtch.com/mm" rel="noopener ugc nofollow" target="_blank">https://research.swtch.com/mm</a></li><li id="e171" class="mh mi iq jp b jq nl ju nm jy nn kc no kg np kk nk mn mo mp bi translated">围棋记忆模型词条:<a class="ae km" href="https://go.dev/ref/mem" rel="noopener ugc nofollow" target="_blank">https://go.dev/ref/mem</a></li><li id="db2a" class="mh mi iq jp b jq nl ju nm jy nn kc no kg np kk nk mn mo mp bi translated">多进程编程的艺术(书):第7章。<em class="kl">尽管这一章是专门关于锁的，但它提供了一些与我上面展示的office例子非常接近的例子。</em></li></ul></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="b52f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于2022年10月15日https://blog.fredrb.com</em><a class="ae km" href="https://blog.fredrb.com/2022/10/15/go-concurrency-shared-memory/" rel="noopener ugc nofollow" target="_blank"><em class="kl"/></a><em class="kl">。</em></p></div></div>    
</body>
</html>