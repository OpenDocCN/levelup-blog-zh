<html>
<head>
<title>Is Goto Always Evil?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后藤一直是邪恶的吗？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/is-goto-always-evil-d31c6c945398?source=collection_archive---------9-----------------------#2020-05-19">https://levelup.gitconnected.com/is-goto-always-evil-d31c6c945398?source=collection_archive---------9-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="52e4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">c程序设计</h2><div class=""/><div class=""><h2 id="7807" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">标记分支使C代码更好的情况</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ccfe6dcd71c7138abbc4cc04777b4290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ckpc9663V-MfkX3w"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">特雷弗·科尔在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="af61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">1968年，Edgar Dijkstra写了一篇有影响力的文章<a class="ae lh" href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf" rel="noopener ugc nofollow" target="_blank">去声明被认为是有害的。他认为无条件分支的使用，也就是通常所说的<code class="fe me mf mg mh b">goto</code>语句，应该从高级编程语言中废除。</a></p><p id="04e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对<code class="fe me mf mg mh b">goto</code>声明的敌意是理所应当的。每一个用FORTRAN的基本或更老的方言编程的人都在纠结于错综复杂的逻辑。充斥着交织在一起的<code class="fe me mf mg mh b">goto</code>语句网络的密集语句序列很难理解，甚至更难维护。</p><p id="a54e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大多数时候，使用块结构编程更优雅。像<code class="fe me mf mg mh b">if</code>、<code class="fe me mf mg mh b">while</code>和<code class="fe me mf mg mh b">switch</code>这样的构造使你的代码意图清晰。</p><p id="5d68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，在Dijkstra的废奴宣言发表50多年后，C和其他语言仍然包含一个<code class="fe me mf mg mh b">goto</code>语句。虽然<code class="fe me mf mg mh b">goto</code>仍然是禁忌，但它的使用仍然是可能的。<code class="fe me mf mg mh b">goto</code>有过正当理由吗？它应该从地球上彻底消失吗？</p><p id="6597" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我认为在C程序中有些情况下<code class="fe me mf mg mh b">goto</code>是有帮助的。</p><p id="c603" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无条件分支是一种工具。有些工具，如链锯，是危险的。我们不希望人们到处乱跑，肆无忌惮地挥舞电锯。这并不意味着链锯应该被禁止。有些情况下，谨慎使用电锯是最好的选择。</p><p id="b59d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">goto</code>什么时候是明智的选择？这里有两个它有价值的场景。</p><h2 id="a420" class="mi mj it bd mk ml mm dn mn mo mp dp mq lr mr ms mt lv mu mv mw lz mx my mz iz bi translated">退出多个嵌套循环</h2><p id="96e0" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">c和其他编程语言认识到尽早离开循环的普遍需要。c为此提供了<code class="fe me mf mg mh b">break</code>语句。<code class="fe me mf mg mh b">break</code>语句是<code class="fe me mf mg mh b">goto</code>的变体。它是一个无条件的分支，从其包含的<code class="fe me mf mg mh b">for</code>、<code class="fe me mf mg mh b">while</code>或<code class="fe me mf mg mh b">switch</code>中跳出，而不是跳到一个显式标签。</p><p id="1736" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时我们想跳出不止一个嵌套循环。假设我们继承了一些打印3乘3整数数组内容的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b74e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在假设我们有了一个新的要求，如果任何数组元素是负的，我们必须立即停止打印任何东西。我们想打破两个循环。</p><p id="334a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可以使用一个标志来避免<code class="fe me mf mg mh b">goto</code>，就像这样:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e3bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是处理这种情况更好的方法是使用一个退出两个循环的<code class="fe me mf mg mh b">goto</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0bcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这比之前版本的代码更简洁，也更容易理解。它说明了它的含义。它用较少的概念开销来表达思想。</p><h2 id="b3c8" class="mi mj it bd mk ml mm dn mn mo mp dp mq lr mr ms mt lv mu mv mw lz mx my mz iz bi translated">统一清理逻辑</h2><p id="8329" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">c程序必须检测和处理错误。当错误发生时，重要的是在清理任何悬空资源的同时退出。代码应该关闭所有打开的文件并释放所有分配的内存。</p><p id="894d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设你的任务是编写一个从文件中读取文本行的C程序。每一行应该包含三个浮点数。该程序必须乘以每行的三个数字，并打印所有产品的总和，使用格式<code class="fe me mf mg mh b">SUM=<em class="nh">sum</em></code>。</p><p id="ae12" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还假设您的程序需要打印<code class="fe me mf mg mh b">BAD INPUT</code>,如果任何输入行不包含三个有效的浮点数，则中止。不管怎样，你的程序应该总是通过释放内存和关闭输入文件来进行清理。</p><p id="5435" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里显示了实现该程序的一种方法。这是一个符合所有要求的正确实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="21d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这段代码有些令人不快。它重复清理逻辑:三个位置的空闲内存分配给<code class="fe me mf mg mh b">line</code>，两个位置关闭<code class="fe me mf mg mh b">infile</code>。这些冗余违反了DRY原则— <a class="ae lh" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">不要重复自己</a>。</p><p id="7e47" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设有一天，您添加了另一个需要在每个停止点清理的资源:可能是一个要关闭的输出文件，或者是另一个要释放的内存块。您必须研究代码，找到所有的错误案例，并在每个案例中插入清理逻辑。</p><p id="e89c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有更好的方法。你猜对了——这涉及到<code class="fe me mf mg mh b">goto</code>。这不仅仅是我的观点。这种方法是Linux内核编码风格指南推荐的。这个想法是让一个函数有一个单一的出口点，位于末端，所有的清理都在一个地方。以下是以这种方式编写的相同程序的外观。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a5b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这段代码更容易审查。很明显，无论如何，<code class="fe me mf mg mh b">line</code>都将被释放，<code class="fe me mf mg mh b">infile</code>将被关闭。错误处理模式确保<code class="fe me mf mg mh b">line</code>和<code class="fe me mf mg mh b">infile</code>总是有定义的值:或者是<code class="fe me mf mg mh b">NULL</code>或者是一个有效的指针。清理代码只有在<code class="fe me mf mg mh b">infile</code>打开时才会关闭。也是利用了<code class="fe me mf mg mh b">free(NULL)</code>是安全的，没有效果。</p><p id="25b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，假设您想要添加另一个必须清理的资源。这一次，你的任务会更简单。您将资源初始化为一个安全值，然后尝试打开/分配它，如果尝试失败，添加一个<code class="fe me mf mg mh b">goto fail</code>，并在函数底部插入清理逻辑。无论函数成功还是发生任何错误，您都可以高枕无忧，因为您知道将会执行额外的资源清理。</p><h2 id="6716" class="mi mj it bd mk ml mm dn mn mo mp dp mq lr mr ms mt lv mu mv mw lz mx my mz iz bi translated">经验法则</h2><p id="47aa" class="pw-post-body-paragraph li lj it lk b ll na kd ln lo nb kg lq lr nc lt lu lv nd lx ly lz ne mb mc md im bi translated">一般来说，在大多数情况下避免使用<code class="fe me mf mg mh b">goto</code>是个好主意。在C程序中使用<code class="fe me mf mg mh b">goto</code>之前，问自己几个问题。</p><p id="b947" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种用法可能会产生意外的循环吗？一般来说，在代码中只使用<code class="fe me mf mg mh b">goto</code>向下跳转。避免用<code class="fe me mf mg mh b">goto</code>向后跳。这样做是朝着意大利面条逻辑的方向前进。如果需要迭代，尽量使用<code class="fe me mf mg mh b">while</code>或者<code class="fe me mf mg mh b">for</code>。</p><p id="0153" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">永远不要从外部代码块跳到代码块的中间。例如，下面的代码很难理解。它只是要求随着时间的推移，随着更改的进行，错误会慢慢出现。不要这样！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="6075" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一般来说，在使用<code class="fe me mf mg mh b">goto</code>之前，考虑是否是时候重构你的代码了。如果你有嵌套循环，有时你需要打破，你能把它们提取到自己的函数中吗？如果是这样的话，你可以早点从那个函数返回，而不是跳出循环。</p><p id="dd22" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我的总体观点是，我见过一些人为了避免<code class="fe me mf mg mh b">goto</code>而走极端，在这个过程中创造了更丑陋、更复杂的代码。编程是工程，不是宗教。使用<code class="fe me mf mg mh b">goto</code>并不“脏”是的，它是一个潜在的危险工具。经验表明，轻率地使用这一工具会导致灾难。</p><p id="6c63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但偶尔，<code class="fe me mf mg mh b">goto</code>是解决问题最优雅的方式。相信你的判断。使用合适的工具完成工作。尽一切努力让你的代码尽可能清晰优雅，然后昂首挺胸。</p></div></div>    
</body>
</html>