<html>
<head>
<title>Tips for Your Next Interview Coding Challenge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给你下一次面试编码挑战的提示</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tips-for-your-next-coding-challenge-7c1c90c121d0?source=collection_archive---------5-----------------------#2020-03-24">https://levelup.gitconnected.com/tips-for-your-next-coding-challenge-7c1c90c121d0?source=collection_archive---------5-----------------------#2020-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一份软件开发工作要经历许多关。第一扇门通过成功完成他们扔给你的编码挑战来解锁。在这篇文章中，我会给你一些解决这些挑战的方法，这些方法是我从自己的经历中获得的。希望其中一把钥匙能帮你打开自己的门。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="73b7" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">序言——编码挑战和面试</h1><p id="80ba" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">编码方面的挑战会让面试变得非常两极分化；他们要么进展顺利，要么进展不顺利。作为面试官和求职者，我已经参加了大约50次面试，我可以告诉你，情况不一定是这样的。挑战的对错性质愚弄了我们，让我们认为我们的面试要么通过，要么失败。</p><p id="a164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">挑战只是过程的一部分。还有其他品质，如沟通、个性、文化契合度、成长潜力等。和你的技术能力一样重要。我见过一些天才拒绝了一份工作，因为他们不是一个很好的文化适应者，或者他们很难共事，等等。所以不用担心，你完成编码挑战的能力不会让你生/死。</p><p id="3362" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">话虽如此，你需要超越一定的技术熟练程度门槛，编码挑战有助于面试官判断你是否准备好了申请的工作。您可能非常了解如何构建高质量的代码，但遗憾的是，我们必须通过编码挑战来交流我们的技术熟练程度。我将试着帮助你用“编码挑战”的语言更好地交流。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><h1 id="2d7b" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">3把钥匙</h1><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/5f88abc4c0fab6d0278c693fca55d322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VManFSVjbS8zzgHC"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">弗洛里安·伯杰在<a class="ae ml" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fb50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们进入要点之前，让我们先了解一些基础知识和准备工作:</p><ul class=""><li id="42e5" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">你需要了解如何分析一个算法的时间和空间复杂度。</li><li id="a694" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">回顾你的数据结构和算法。尤其是那些你认为不相关的(因为根据我的经验，那些是<em class="na">总是</em>在面试中出现的……)</li><li id="43f0" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">确保你精通至少一门编程语言。面试可能压力很大。你不希望本应帮助你战胜挑战的语言成为你失败的原因。</li><li id="9361" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">做网上练习题。有很多像<a class="ae ml" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>、<a class="ae ml" href="https://www.hackerrank.com/" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>这样的网站有丰富的练习材料。</li></ul><p id="b011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多其他的方法来准备，但是我相信你已经知道了。你来这里是为了好东西…嗯，在这里！</p><h1 id="b69e" class="ks kt iq bd ku kv nb kx ky kz nc lb lc ld nd lf lg lh ne lj lk ll nf ln lo lp bi translated">横向思维</h1><p id="8ef1" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">有些问题被“巧妙地”设计来测试你的<a class="ae ml" href="https://en.wikipedia.org/wiki/Lateral_thinking" rel="noopener ugc nofollow" target="_blank">横向思维</a>。你能从多少不同的角度来解决一个问题？通常，你对问题的第一个解释会导致最低效的解决方案。当你的面试官要求你“做得更好”的时候，是时候把那些横向思维齿轮转移到位了。</p><p id="9727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">横向思维就是要突破任何“感知”的限制。我不能教你怎么做，否则，我们都是天才。我<em class="na">能做的</em>就是教你如何营造一个培养横向思维的环境。</p><p id="08dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">秘密是——你不应该做任何事情……那是你的意识。看完问题，消化完，你的潜意识就会开始向你吐槽想法。似乎不知从哪里冒出来的想法。你的工作是评估和探索这些想法的优点。最终，一点灵感会帮助你找到解决办法。</p><p id="f933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不必要的想法会分散你的注意力，阻碍你的思考能力。像这样的想法:</p><ul class=""><li id="bfeb" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">如果我得不到这个解决方案怎么办？我会面试失败吗？</li><li id="400e" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">我还剩多少时间？我如何在7分钟内解决这个问题？</li></ul><p id="2aff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些想法就像一个通往恶性循环的大门，最终导致恐慌。把这些想法从你的头脑中驱散，把注意力集中在这个问题上。不要让这些无用的想法占据了宝贵的产生思想的不动产，应该分配给解决问题的不动产。</p><blockquote class="ng nh ni"><p id="2149" class="jn jo na jp b jq jr js jt ju jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj kk ij bi translated">面试时保持冷静。压力和恐慌会阻碍你解决问题的能力。试着享受乐趣，保持放松，让你的大脑做它最擅长的事情。</p></blockquote><p id="99a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，告诉你“不要惊慌”说起来容易做起来难，但这将随着实践而自然发生。现在我们来看一个问题。</p><h2 id="0bbf" class="nm kt iq bd ku nn no dn ky np nq dp lc jy nr ns lg kc nt nu lk kg nv nw lo nx bi translated">低买高卖</h2><p id="77f9" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">给你一只股票的历史价格数据:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/e2dff18db906aaaa016690adf27b5460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eAuJ15pzO8wYpQKwT8HCA.png"/></div></div></figure><p id="7064" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你必须找到一个<em class="na">开始时间</em>和<em class="na">结束时间</em>，这样在<em class="na">开始时间</em>买入一只股票，在<em class="na">结束时间</em>卖出这只股票会产生最高的利润。显然，<em class="na">结束时间</em>必须在<em class="na">开始时间:</em>之后</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/59fd7422e201018783c7e3fd8d14a015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_U78Vjp655SvlnTjqPT5mQ.png"/></div></div></figure><p id="60cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里停下来，试着想出一个解决方案。您的输入数据是一个价格数组，您的输出必须是买入/卖出的指数:</p><pre class="lw lx ly lz gt nz oa ob oc aw od bi"><span id="93a3" class="nm kt iq oa b gy oe of l og oh">Input:<br/>[5, 3, 2, 4, 6, 7, 6, 5, 5, 6, 7, 9, 10, 9, 7, 5, 6]</span><span id="6268" class="nm kt iq oa b gy oi of l og oh">Output:<br/>(2, 12)</span></pre><p id="8c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会考虑的第一个解决方案是“暴力”解决方案。您创建一个外部/内部循环来考虑每一对<em class="na">开始</em>和<em class="na">结束时间。</em>你在循环过程中跟踪哪双鞋的价格差异最大，并在结束时返回那双鞋:</p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6573" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法的复杂度为O(N)。我们能做得更好吗？当然可以！这就是横向思维发挥作用的地方。这个问题是以时间的概念为框架的，我们知道时间只能向前，不能向后。因此，我们的大脑会吐出“向前”的解决方案，也就是说从左到右。没有任何限制不允许我们反向遍历数据。</p><p id="8890" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们知道我们将总是在某个局部最小值买入，在某个局部最大值卖出(除非图形总是在下降)。问题的根源是将每个局部最小值与一个局部最大值配对，并选择利润最高的配对。“向前”方法的困难在于问题的时间性质。当我们从左到右时，我们必须记住我们过去见过的每个局部最小值/最大值的<em class="na">，以防将来出现更好的配对。这种配对逻辑在一个循环中编程极其复杂。</em></p><p id="a223" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们从右到左，我们不需要跟踪每个本地最小值/最大值的<em class="na">。问题就变得简单多了。我们知道过去还没有遍历过的数据，所以我们只需要跟踪我们看到的最好的数据，如果我们发现更好的数据，就替换它:</em></p><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="29eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码的简要说明:对于每个局部最大值，我们跟踪“最佳”局部最小值，直到找到更高的局部最大值。我们重复这个逻辑，直到遍历完数组，始终跟踪最佳配对。下面的图表说明了该算法:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/aa3d6cc2f851ae19a3247790159cfc82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4loqeuf2rJJntRLRFkgpow.png"/></div></div></figure><p id="0023" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法的复杂度为O(N)。当然，这是我们能做的最好的了。对于这个问题，横向思考意味着<strong class="jp ir">倒退</strong>。您可以考虑探索“向后”方法的情况:</p><ul class=""><li id="745b" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">当您处理时态数据时，就像我们在这个问题中所做的那样。</li><li id="5580" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">当你使用字符串(英语)时，我们从左到右阅读。如果向后遍历字符串更容易呢？</li></ul><p id="6d21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">练习</strong>:这里有一个练习的编码挑战:<a class="ae ml" href="https://leetcode.com/problems/backspace-string-compare/" rel="noopener ugc nofollow" target="_blank">退格字符串比较</a></p><h1 id="7a50" class="ks kt iq bd ku kv nb kx ky kz nc lb lc ld nd lf lg lh ne lj lk ll nf ln lo lp bi translated">使用数据结构</h1><p id="17d1" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">要想在编程面试中脱颖而出，你需要对数据结构有很好的掌握。当你开始写代码时，看起来“足够简单”的问题变得令人毛骨悚然。在这些情况下，利用数据结构来帮助简化您需要编写的代码是至关重要的。您可能需要使用多种数据结构，或者创建自己的数据结构。</p><h2 id="6c1c" class="nm kt iq bd ku nn no dn ky np nq dp lc jy nr ns lg kc nt nu lk kg nv nw lo nx bi translated">LRU高速缓存</h2><p id="792c" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在LRU(最近最少使用的)缓存中，缓存中最陈旧的项目会被驱逐，以便为新项目腾出空间:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/330c064a7f3379b4d7eeae5cb55998be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vt1ERio66Ut8NWGrOa7tig.png"/></div></div></figure><p id="4391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们考虑如何开发一个带有<em class="na"> get </em>和<em class="na"> put </em>操作的LRU缓存。</p><p id="92c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用链表形式的队列会怎么样？对于<em class="na"> put </em>操作，我们将一个项目插入到队列中，如果队列已满，则驱逐最陈旧(最后)的项目。对于<em class="na"> get </em>操作<em class="na">，</em>我们遍历队列来查找物品。如果找到，我们从当前位置移除该项目，并将其重新插入列表，从而使其“新鲜”:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/889a8349e70a0e55af112dc2bc9453c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHHm3t8hy6pVvGo6g1dDjg.png"/></div></div></figure><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="ff53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na"> put </em>操作将一个项目插入到队列中，如果需要，如果队列已满，则弹出一个项目。它的运行时间复杂度为O(1)。在最坏的情况下，<em class="na"> get </em>操作必须遍历整个队列来找到一个条目。该操作的运行时间复杂度为O(N)。缓存通常针对读取进行优化(即<em class="na"> get </em>操作)，所以我们需要一个更好的实现，最好是O(1)。(你知道一个简单的链表实现是不够的……)</p><p id="edae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个想到的数据结构是集合或散列表。具有O(1)查找的东西。但是我们如何编纂陈旧呢？链表漂亮地表现了一个条目的陈旧程度(条目在列表中的位置)。集合没有任何顺序的概念。</p><p id="47e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们也在散列表中存储一个条目的“陈旧性”会怎么样？那会有帮助吗？然后，关键字将是该项目的散列，值将是它的陈旧性。我们的缓存命中/未命中逻辑是O(1)，我们只需要确认该项是否存在于我们的hashmap中。我们仍然需要弄清楚如何在缓存命中时更新该项的“陈旧性”。</p><p id="9b57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个可能的解决方案是保持递增的计数。我们可以使用该计数来更新缓存命中时间的过期时间。较低的计数意味着一个潜行者项目。在<em class="na"> put </em>操作期间，如果我们需要驱逐一个项目，我们会驱逐计数最低的项目:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/ba2631c5b75802e84406b09be12d961e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-KGafy3rtSrMDbRQbZdAQ.png"/></div></div></figure><figure class="lw lx ly lz gt ma"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0e24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na"> get </em>操作现在的运行时复杂度为O(1)，而<em class="na"> put </em>操作的运行时复杂度为O(N)(因为如果我们需要驱逐一个项目，我们必须遍历整个hashmap来找到最陈旧的项目)。使用一个聪明的技巧，我们已经成功地优化了<em class="na"> get </em>操作。让我们看看我们是否能做得更好…</p><p id="ad04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的链表方法给出了一个O(1) <em class="na"> put </em>操作。我们的hashmap方法给了我们一个O(1) <em class="na"> get </em>操作。如果我们能以某种方式找到一种方法来合并这两种方法，我们就能实现恒定时间的<em class="na"> get </em>和<em class="na"> put </em>操作。</p><p id="1c9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="na">我准备在下一段描述解决方法，看你能不能想明白了再继续。</em></p><p id="0982" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链表的“缺点”是我们必须在<em class="na"> get </em>操作中遍历每一项。假设我们有一个散列表，我们不需要遍历列表。散列表的“糟糕”之处在于，当找到要驱逐的条目时，我们必须遍历散列表中的所有条目。如果我们有一个链表，那么我们可以弹出最后一个条目，这样我们就知道在散列表中应该删除哪个条目了。看起来散列表和链表互相利用了对方的弱点。让我们开始推理通过<em class="na">得到&amp;放</em>的操作。</p><p id="ab88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要添加一个新条目，我们将把它插入到散列表和链表中:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/e05b657b059d6f2879f32205e17abbc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-zOW3rjQjj2AURn89-1H6g.png"/></div></div></figure><p id="f8a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缓存满了怎么办？驱逐会是什么样子？对于驱逐，我们可以删除队列中的最后一项。因为我们手头有被驱逐的条目，所以我们也可以将它从散列表中移除:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/3cd0c9d20bd116466820b6039f77f8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VgHrJz4gqo8MPzmxAhFDPA.png"/></div></div></figure><p id="3681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了，效果很好。好了，现在让我们考虑一下<em class="na">得到</em>的操作。检查条目是否存在很简单，我们只需检查散列表。如果没有，我们说这是缓存未命中。如果存在呢？我们需要更新该项目的过期时间。这就是事情变得棘手的地方。我们需要遍历链表来找到条目，并把它移到前面。困难在于必须遍历列表。我们能以某种方式避免遍历吗？</p><p id="1262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某种意义上，链表是指向节点的指针的集合。我们需要遍历链表来得到我们想要的指针。我们需要另一种方法来访问这个指针。如果我们有一个常量时间查找数据结构来存储这些指针就好了…哦，等等，我们有！</p><p id="c832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们跟踪链表中每一项的指针，将它们作为值存储在hashmap中。现在我们可以使用hashmap来访问指针，并使用指针来重新定位链表中的条目:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/6f3da7679087a71784fc871d3ccc3acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1qDzFgXAPWsKmoqFUfNJQ.png"/></div></div></figure><p id="7d3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧啊。我们现在有了一个带有O(1) <em class="na"> get </em>操作和O(1) <em class="na"> put </em>操作的LRU缓存，这都是因为我们按照自己的意愿改变了数据结构。相当漂亮的东西。</p><p id="5990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">练习</strong>:我将让您来编写这个解决方案。这并不是说我懒，我<em class="na">会</em>把它编码并粘贴在这里……但是你可能会在面试中被问到这个问题，或者类似的问题，做这个练习是很好的练习。还有，我有点懒…</p><h1 id="d7bc" class="ks kt iq bd ku kv nb kx ky kz nc lb lc ld nd lf lg lh ne lj lk ll nf ln lo lp bi translated">理解时间和空间</h1><p id="3e52" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">几乎你尝试的每个问题都会有不同程度的运行时和时空复杂度的解决方案。就我所见，运行时复杂性和时空复杂性在某种程度上是相关的。</p><p id="d9ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当面试官问你是否可以比你最初的方法做得更好时，你可能需要牺牲时空复杂度来获得更好的运行时复杂度。幸运的是，面试官很少关心时空复杂性。他们可能会要求你分析，但很少会要求你改进。</p><p id="cfdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行时和时空复杂性之间权衡的例子数不胜数。以<strong class="jp ir">寻找重复</strong>为例:</p><p id="5586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给定一个数组，如果有重复的数字，返回True，否则返回False:</p><pre class="lw lx ly lz gt nz oa ob oc aw od bi"><span id="6a24" class="nm kt iq oa b gy oe of l og oh">[0, 1, 2, 3] -&gt; False<br/>[3, 1, 2, 3] -&gt; True</span></pre><p id="1624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个O(1)时空的解决方案是使用一个外/内循环来比较每一个数字与每一个其他数字，如果两个数字相同，则返回True。这个解决方案的运行时间复杂度为O(N)。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/861cfe8250c9ebaaa0c7a39e31f61e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PNOeKmhHRZqWpwsB0hRqQ.png"/></div></div></figure><p id="6934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们牺牲一些时空复杂度，创建一个排序数组。副本现在彼此相邻，我们只需遍历数组就可以找到它们。我们已经从O(1)到O(N)时空复杂度，并且我们已经将我们的运行时间复杂度降低到O(N log N)。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/b7b7739172f1fab3f54028631ebe8480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGpvdEhNoVTTIBj03uPQZg.png"/></div></div></figure><p id="f3ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们牺牲更多的时空复杂性，使用散列表。我们将遍历列表，使用数字作为hashmap的键，并记录我们看到这个数字作为值的次数。一旦我们创建了hashmap，我们就遍历hashmap，如果看到任何大于1的值，就返回True:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ny"><img src="../Images/f27e92075679c24a0bb574f6509e859f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ah4J0WSAwQDlB2d59p7vLg.png"/></div></div></figure><p id="94c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的运行时复杂度降低到O(N ),时空复杂度略有增加(因为hashmap的内存效率低于数组),尽管仍然是O(N)。</p><p id="b549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有无数其他的编码挑战展示了同样的时间-空间权衡。以我们在上一节中开发的LRU缓存为例。运行时效率最高的解决方案也使用了最多的空间。理解时间-空间复杂性权衡为您提供了一种系统的方法来提高解决方案的运行时复杂性。如果你被要求找到一个更好的方法，问问你自己，我如何利用空间成为我的优势:</p><ul class=""><li id="7d8c" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">有什么我可以预先计算的有用值吗？</li><li id="5d0f" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">我能不能以一种优化的方式重新格式化我的输入，以配合我的算法？</li><li id="1e20" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">我可以映射数据来表示我熟悉的问题吗？</li></ul><p id="dec4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某些情况下，您将被要求改善时间/空间的复杂性，而您将无法变出任何能够拯救您的数据结构。这类问题旨在难倒你，通常问题中有一个细节或问题的一个属性是你没有利用的。所以一定要非常仔细的看问题。</p><h1 id="28e0" class="ks kt iq bd ku kv nb kx ky kz nc lb lc ld nd lf lg lh ne lj lk ll nf ln lo lp bi translated">结束语</h1><p id="5f93" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">希望我的“提示”能改变你看待编码问题的方式，并在面试中帮助你。我将再次重复它们:</p><ul class=""><li id="7520" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><strong class="jp ir">横向思维</strong>——让你的大脑探索解决问题的不同方法。</li><li id="5a25" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir">使用数据结构</strong>——使用数据结构来获得更干净、更高效的代码。</li><li id="230c" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir">理解时间和空间</strong> —牺牲空间换取更好的时间复杂度(反之亦然)。当要求改善时间/空间时，尝试利用问题的属性/细节。</li></ul><p id="a416" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，仅仅完成编码题并不足以通过面试。面试官还会考虑其他事情。在面试过程中，确保你:</p><ul class=""><li id="0997" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">谈谈你的想法。我在这个问题的这个方面遇到了麻烦，我在想是否有什么办法可以绕过它。)</li><li id="0808" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">积极点！轻松的谈话和微笑会有很大的帮助。</li><li id="6aac" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">提问。你对公司的评价和他们对你的评价一样多。这是一家你每天都想为之工作的公司吗？</li></ul><h2 id="c7d8" class="nm kt iq bd ku nn no dn ky np nq dp lc jy nr ns lg kc nt nu lk kg nv nw lo nx bi translated">练习</h2><p id="2f7a" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">本文涉及的问题相对简单，但足以说明问题。除了每个部分中列出的练习之外，还有一些其他的编码挑战可以帮助您练习:</p><ul class=""><li id="678f" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><a class="ae ml" href="https://leetcode.com/problems/two-sum/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">两笔总和</strong> </a></li><li id="6942" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><a class="ae ml" href="https://leetcode.com/problems/merge-intervals/" rel="noopener ugc nofollow" target="_blank">T5】合并间隔T7】</a></li><li id="1317" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir">条目顺序数据结构</strong>:编写一个数据结构，用于跟踪列表中条目的顺序。数据结构应该有<em class="na"> insert_item </em>、<em class="na"> delete_item </em>和<em class="na"> reorder_item </em>操作。所有的操作都应该有O(1)的运行时间复杂度。</li></ul><p id="6287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你下次编码挑战好运！:)</p></div></div>    
</body>
</html>