<html>
<head>
<title>Road to Go Pro — Pointer &amp; Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pro之路—指针和功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/road-to-go-pro-pointer-functions-1b4f18b4fdb0?source=collection_archive---------2-----------------------#2020-10-09">https://levelup.gitconnected.com/road-to-go-pro-pointer-functions-1b4f18b4fdb0?source=collection_archive---------2-----------------------#2020-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="04a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">开始前的几句话。你可以在这个</em> <a class="ae kp" href="https://github.com/songx23/RoadToGoPro" rel="noopener ugc nofollow" target="_blank"> <em class="ko">资源库</em> </a> <em class="ko">中找到本教程使用的代码。你可以在这里</em>  <em class="ko">找到Road to Go Pro </em> <a class="ae kp" href="https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad" rel="noopener"> <em class="ko">的全部内容。如果你错过了最后一个，你可以通过这个</em> </a><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/road-to-go-pro-flow-control-dfcc7b9a5395"> <em class="ko">链接</em> </a> <em class="ko">找到它。</em></p><p id="a232" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在教程的最后一部分讨论了流量控制和循环。在这一篇中，我们将讨论指针和函数。在完成了Road to Go Pro的前4个部分后，您就可以开始使用Go编写脚本或控制台应用程序了。</p><h1 id="e77f" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">指针</strong></h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/9462dfd8c7244cb9874f0459ab111de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IRuc-JVGf9hnuZtl"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@nathalie_spehner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Nathalie SPEHNER </a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1162" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你用过C或C++，你就已经知道什么是指针了。然而，在像Java、C#、Javascript、Python等最流行的编程语言中。没有明确的语法来表示指针。当我第一次听说这个名字时，我不知道它是什么。</p><p id="f8dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，指针保存一个值的底层内存地址。等等，内存地址？Go不是高级编程语言吗？</p><blockquote class="me mf mg"><p id="d34e" class="jq jr ko js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">我们什么时候需要知道变量的内存地址呢？</p></blockquote><p id="7b8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个很好的问题，但在探索答案之前，我们需要快速绕道。让我们看看如何声明指针以及如何在函数中使用它们。一旦我们涵盖了这些，你将更容易理解下面的推理和例子。所以坚持住。</p><h2 id="229d" class="mk kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated"><strong class="ak">声明指针</strong></h2><p id="c96d" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">每当我们在Go中声明一个变量时，编译器都会分配一段内存来存储它。该变量的值存储在那里，直到被垃圾收集器回收。</p><p id="13f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">指针是复合数据类型。我们通过在指针指向的数据类型前添加一个<code class="fe nb nc nd ne b">*</code>来形成指针类型。例如，<code class="fe nb nc nd ne b">*string</code>表示指向字符串类型变量的指针的类型。</p><p id="e235" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要获得现有变量的指针值，我们需要在变量前面添加一个<code class="fe nb nc nd ne b">&amp;</code>。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">指针示例</figcaption></figure><p id="91c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在<a class="ae kp" href="https://medium.com/swlh/road-to-go-pro-types-structures-21e5fedc5fe0" rel="noopener">之前的教程</a>中提到过，声明变量时不需要指定数据类型。这也适用于指针类型。在上面的例子中，变量<code class="fe nb nc nd ne b">p</code>的类型将被自动推断为<code class="fe nb nc nd ne b">*string</code>。</p><p id="ec45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以通过使用<code class="fe nb nc nd ne b">*</code>解除对指针的引用，经由指针访问或设置存储的值。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">通过指针访问和更改var值</figcaption></figure><p id="0e18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，在处理指针时，我们需要记住<code class="fe nb nc nd ne b">nil</code>，因为指针的默认值是<code class="fe nb nc nd ne b">nil</code>。因此，我们需要小心零指针解引用。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">零指针取消引用异常</figcaption></figure><h1 id="a1a7" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">功能</strong></h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nh"><img src="../Images/a10b157e515667bbf66d19b0d10a8a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rixDlri0VPm781AG"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">莱尼·屈尼在Unsplash上的照片</figcaption></figure><p id="99ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数，也称为方法，创建执行特定任务的可重用逻辑。你可以把它想象成一个“工厂”。它接受0到n个参数，并返回0到n个结果。函数的结构如下所示:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">函数语法</figcaption></figure><p id="e9fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接收器、输入参数和输出参数是我们在声明函数时可以指定的三个可选组件。</p><h2 id="ec86" class="mk kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated"><strong class="ak">输入/输出</strong></h2><p id="260c" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">首先，让我们谈谈输入和输出参数。输入参数也称为函数参数，它们是传入工厂的成分。输出参数是工厂产生的返回值。下面是一个指定了输入和输出参数的函数示例。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">功能示例</figcaption></figure><p id="2a1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">字符串<code class="fe nb nc nd ne b">country</code>是<code class="fe nb nc nd ne b">isCovidSafe</code>函数的输入参数。当指定输入参数时，我们需要首先声明名称，然后声明类型。而对于输出参数，我们通常只声明类型。</p><p id="384a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们有一个以上的输入参数，我们可以使用一个方便的快捷方式来缩短声明，只有当部分参数具有相同的类型。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">具有多个输入参数的函数</figcaption></figure><p id="b457" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，<code class="fe nb nc nd ne b">isStateCovidSafe</code>函数有一个额外的参数<code class="fe nb nc nd ne b">state</code>，它和<code class="fe nb nc nd ne b">country</code>有相同的类型。我们可以省略重复的类型声明，而不是像<code class="fe nb nc nd ne b">(country string, state string)</code>那样指定两次类型。但是，这仅适用于输入参数。对于输出参数，我们必须单独指定它们，即使它们是相同的类型。关于输出的另一个注意事项，当我们有多个输出参数时，我们需要用括号<code class="fe nb nc nd ne b">()</code>将类型括起来。例如，如果一个函数返回两个字符串，那么这个函数应该看起来像<code class="fe nb nc nd ne b">func func_name(inputs string) (string, string) {}</code>。</p><p id="51b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上所述，输入和输出参数是可选的。然而，没有输入和输出参数的函数可能不是很有用。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">没有输入/输出参数的函数</figcaption></figure><h2 id="44dc" class="mk kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated"><strong class="ak">数值/指针接收器</strong></h2><p id="62a4" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">到目前为止，我们看到的示例函数可以在同一个包中的任何地方调用。一旦我们为一个函数添加了一个接收器组件，它就使该函数属于接收器。接收者只能是本地类型。我们不能定义属于原始类型或在当前包之外定义的类型的函数。让我们来看看一些例子。首先，我们需要定义一个名为<code class="fe nb nc nd ne b">Person</code>的局部类型。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">声明个人结构</figcaption></figure><p id="c5be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们可以添加<code class="fe nb nc nd ne b">Person</code>类型作为函数的接收者。Go中有两种形式的接收者，即值接收者和指针接收者。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">值接收器示例</figcaption></figure><p id="99ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nb nc nd ne b">FullName()</code>函数有一个值接收器(<code class="fe nb nc nd ne b">Person</code>)。当指定接收者时，我们需要说明接收者的名称和类型。接收者名称是可选的。如果在函数中没有使用接收方值，我们可以省略接收方名称。但是接收器类型是必需的。接收器命名的约定是使用接收器类型名的第一个字符。在函数内部，我们可以访问接收方值，并使用它们来执行某些操作。但是，值接收器不会将变量<code class="fe nb nc nd ne b">person</code>的原始副本传递给函数。而是传递了一个<code class="fe nb nc nd ne b">person</code>的副本。因此，即使我们改变函数中的年龄，也不会影响原始变量。你看，琼恩·雪诺还是23岁。唷。</p><p id="69a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想改变一个接收器的原始值，我们需要使用另一种形式的接收器，指针接收器。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">指针接收器示例</figcaption></figure><p id="dc82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">指针接收器将原始变量的指针传递给函数。因此，当我们修改它的值时，它会影响原始变量。大多数时候，我使用指针接收器而不是值接收器，因为它可以避免复制接收器值。因此，指针接收器效率更高。但是，我想指出的是，使用指针接收器来改变接收器值的模式并不理想。我会避免使用这种模式，因为它使代码库更难维护和调试。</p><h2 id="bc9c" class="mk kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated"><strong class="ak">实现一个接口</strong></h2><p id="7e99" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">我们在<a class="ae kp" href="https://medium.com/swlh/road-to-go-pro-types-structures-21e5fedc5fe0" rel="noopener">之前的教程</a>中学到了什么是接口。简单概括一下，接口是函数声明的集合。它定义了需要做什么，但没有具体说明如何去做。</p><p id="da20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要实现一个接口，我们需要定义一个结构，这个结构需要有该接口的所有声明的函数。当实现所需的函数时，我们必须在函数声明中使用值接收器或指针接收器。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用值接收器实现接口</figcaption></figure><p id="1782" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go自动识别出<code class="fe nb nc nd ne b">Dog</code>结构实现了<code class="fe nb nc nd ne b">Animal</code>接口，因为它已经实现了<code class="fe nb nc nd ne b">Animal</code>接口中所有声明的函数。</p><blockquote class="me mf mg"><p id="2517" class="jq jr ko js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">你可能会想:为什么我们在实现函数时不使用指针接收器？</p></blockquote><p id="daa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很高兴你问了。我们可以使用指针接收器。</p><p id="4172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们创建一个名为<code class="fe nb nc nd ne b">Cat</code>的结构，我们将在实现<code class="fe nb nc nd ne b">Animal</code>接口时使用指针接收器。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用指针接收器实现接口</figcaption></figure><p id="2685" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，指针<code class="fe nb nc nd ne b">*Cat</code>实现了<code class="fe nb nc nd ne b">Animal</code>接口而不是<code class="fe nb nc nd ne b">Cat</code>结构，因为我们在<code class="fe nb nc nd ne b">Eat()</code>和<code class="fe nb nc nd ne b">Drink()</code>函数中使用了指针接收器。</p><blockquote class="me mf mg"><p id="6727" class="jq jr ko js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">那么，哪种方式更好呢？</p></blockquote><p id="5dc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要回答这个问题，我们需要回到何时需要使用指针的问题上来。</p><h1 id="a727" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">回指针</strong></h1><p id="50c6" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">好吧，我承认，那不是快速绕道。现在我们知道了什么是指针以及如何使用它。是时候看看什么时候应该使用指针，以及使用指针时需要注意什么了。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ni"><img src="../Images/b9e46421aece883bd20448446f98b6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RUEPbZA7RvtZARy4"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">缺口编号</a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">防溅板</a>上拍摄</figcaption></figure><p id="1360" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一条通用的经验法则是，只有在万不得已的情况下才使用指针。否则，就放过它吧。</p><p id="7b72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是一些可以考虑使用指针的场景。</p><h2 id="4e1b" class="mk kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated">1.当你需要一个nilable (nullable)类型时。</h2><p id="602a" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">让我们为这个场景创建一个业务需求。假设您想存储人们是否愿意参加您的聚会的决定。有三种选择。首先，一个人可以决定加入。第二，一个人可以决定不加入。第三，一个人还没有做出决定。</p><p id="8dc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将该值存储在<code class="fe nb nc nd ne b">bool</code>类型中不符合要求，因为<code class="fe nb nc nd ne b">bool</code>只能有两个值，true和false。在这种情况下，我们可以使用一个指针<code class="fe nb nc nd ne b">*bool</code>，它可以保存三个值:真(连接)、假(不连接)和零(未决定)。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用*bool存储true、false和nil</figcaption></figure><p id="9635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然<code class="fe nb nc nd ne b">*bool</code>满足了需求，但是它引入了一个臭名昭著的副作用，<strong class="js iu">零解引用</strong>。</p><p id="7a9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在取消引用之前，我们需要检查<code class="fe nb nc nd ne b">Going</code>字段的值是否为零。否则，我们将遇到运行时错误:“无效内存地址或零指针取消引用”。这在处理<code class="fe nb nc nd ne b">Going</code>字段时增加了不必要的复杂性，并且非常容易出错，因为我们需要记住显式处理nil解引用。</p><p id="8a40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一个更好的方法来解决这个特殊的问题。它使用枚举作为<code class="fe nb nc nd ne b">Going</code>字段的类型。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用“枚举”替换*bool类型</figcaption></figure><p id="3399" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">*注意:</em> <code class="fe nb nc nd ne b"><em class="ko">iota</em></code> <em class="ko">是简化递增整数定义的关键字。更多信息请查看</em> <a class="ae kp" href="https://github.com/golang/go/wiki/Iota" rel="noopener ugc nofollow" target="_blank"> <em class="ko">维基</em> </a> <em class="ko">。</em></p><h2 id="5af2" class="mk kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated">2.当选择在函数中使用哪个接收器时。</h2><p id="c9dd" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">如前一节所述，在大多数情况下，我们选择指针接收器而不是值接收器，因为它们更有效。</p><p id="02a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，它也带来了一个副作用，就是偶然突变。意外的数据突变使得代码更难调试和维护。我不会改变指针值。如果必须的话，我会让变异变得小而明显。像上面的例子一样，<code class="fe nb nc nd ne b">ChangeName()</code>函数对一个人的名和姓进行变异。它做了一个简单的改变，函数名使得意图对其他人来说非常明显。</p><p id="5f65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个更详细的关于如何在值接收器和指针接收器之间选择的<a class="ae kp" href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-type" rel="noopener ugc nofollow" target="_blank">指南</a>。</p><h2 id="3969" class="mk kr it bd ks ml mm dn kw mn mo dp la kb mp mq le kf mr ms li kj mt mu lm mv bi translated">3.当需要单身的时候。</h2><p id="d832" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">一个<a class="ae kp" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例</a>是我们在一个应用程序的生命周期中只启动一次的东西。例如，当我们需要集成第三方API时，我们希望为该API创建一个客户端，它可以是单例的。或者当我们想在应用程序中使用缓存时，缓存客户端也可以是单例的。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">单例示例</figcaption></figure><p id="5f28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通常在<code class="fe nb nc nd ne b">main()</code>函数中初始化单例实例，然后将它传递给代码库的不同部分。在上面的例子中，我们创建了两个潜在的单例，<code class="fe nb nc nd ne b">PointerSlackClient</code>和<code class="fe nb nc nd ne b">ValueSlackClient</code>。如果我们像对待<code class="fe nb nc nd ne b">ValueService</code>一样将singleton作为函数参数传递，那么<code class="fe nb nc nd ne b">ValueSlackClient</code>就不再是真正的singleton了，因为当作为参数传递时，Go使用了<code class="fe nb nc nd ne b">ValueSlackClient</code>的副本。因此，我们将拥有不止一个<code class="fe nb nc nd ne b">ValueSlackClient</code>实例。使用指针时，Go不会复制实例。所以在应用程序中实际上只有一个<code class="fe nb nc nd ne b">PointerSlackClient</code>实例。</p><p id="e418" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是我认为我们可以利用指针的一些场景。也就是说，第一条规则仍然是:</p><blockquote class="me mf mg"><p id="3fb0" class="jq jr ko js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">尽可能避免使用指针。</p></blockquote><h1 id="1425" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">接下来是什么？</strong></h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nj"><img src="../Images/14f72cc9643321e377f1997ee32b550c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w8HESSTA6hkkl_yV"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@lsgr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Olesya Grichina </a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们已经学习了数据类型、流控制、循环、指针和函数。这些是围棋最基本的组成部分。在接下来的教程中，我们将从另一个角度来看围棋。我将讨论包、模块以及如何从头开始一个Go项目。希望这篇教程对你有所帮助。如果你想了解更多关于围棋的内容，请继续关注，我们下一期再见。</p><p id="b367" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你遇到任何问题或者需要帮助，请在下面留下你的评论。随时欢迎反馈。感谢您的阅读！</p><p id="1fc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">特别感谢</em> </strong> <a class="ae kp" href="https://medium.com/@mhumecook" rel="noopener"> <strong class="js iu"> <em class="ko">马克谟-库克</em> </strong> </a> <strong class="js iu"> <em class="ko">对本教程的点评。</em> </strong></p></div></div>    
</body>
</html>