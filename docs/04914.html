<html>
<head>
<title>Tools for implementing a Golang API server with auto-generated code and documentation, grpc-gateway — protobuf, gRPC, API, WebSocket.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自动生成的代码和文档实现Golang API服务器的工具，grpc-gateway — protobuf，grpc，API，WebSocket。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tools-for-implementing-a-golang-api-server-with-auto-generated-code-and-documentation-694262e3866c?source=collection_archive---------0-----------------------#2020-07-23">https://levelup.gitconnected.com/tools-for-implementing-a-golang-api-server-with-auto-generated-code-and-documentation-694262e3866c?source=collection_archive---------0-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/dcf31496924cc134b98b8617703966ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zc5FpwQKOm5d7bIbozXCA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">阿尔瓦罗·雷耶斯在<a class="ae kf" href="https://unsplash.com/photos/fSWOVc3e06w" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="2412" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">什么是OpenAPI和Swagger？</h1><p id="caea" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">OpenAPI是一个形式化的规范和完整的框架，用于描述、创建、使用和可视化<a class="ae kf" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a> web服务。目标是允许客户机系统和文档将它们的更新与服务器上的更改同步。这是可能的，因为方法、参数、模型和其他元素通过OpenAPI与服务器软件连接，并且始终与服务器软件保持同步。</p><p id="cb46" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">该规范不依赖于编程语言，可以在<a class="ae kf" href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" rel="noopener ugc nofollow" target="_blank"> HTTP </a>协议之外使用。OpenAPI同时应用于客户端、服务器以及根据<a class="ae kf" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a>创建的相应接口文档。</p><p id="2d62" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">客户机可以在不知道服务器实现细节的情况下使用该规范。同时，开发者和普通用户都可以使用现成的工具和提供的接口使用OpenAPI。<a class="ae kf" href="https://en.wikipedia.org/wiki/XML" rel="noopener ugc nofollow" target="_blank"> XML </a>和<a class="ae kf" href="https://en.wikipedia.org/wiki/JSON" rel="noopener ugc nofollow" target="_blank"> JSON </a>作为格式，但一般情况下可以选择另一种<a class="ae kf" href="https://en.wikipedia.org/wiki/Markup_language" rel="noopener ugc nofollow" target="_blank">标记语言</a> e(例如<a class="ae kf" href="https://en.wikipedia.org/wiki/YAML" rel="noopener ugc nofollow" target="_blank"> YAML </a>)。</p><h2 id="ef98" class="mh kh it bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">OpenAPI规范</h2><p id="8634" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了更好地理解OpenAPI规范，让我们来看看规范的一些摘录。</p><p id="badc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">OpenAPI元素有<code class="fe mt mu mv mw b">paths</code>、<code class="fe mt mu mv mw b">parameters</code>、<code class="fe mt mu mv mw b">responses</code>和<code class="fe mt mu mv mw b">security</code>。</p><p id="8799" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在OpenAPI规范中，你的端点是<code class="fe mt mu mv mw b">paths</code>。OpenAPI规范中的端点可能看起来像这样:</p><p id="58b4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">下面是这段代码中对象的含义:</p><ul class=""><li id="c06e" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">/pets</code> -路径端点；</li><li id="32f2" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">get</code> - HTTP方法；</li><li id="3f24" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">parameters</code> -查询的输入参数列表；</li><li id="8610" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">responses</code> -请求响应列表；</li><li id="0788" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">200</code> - HTTP状态码；</li><li id="faf4" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">$ref</code>是对描述中定义响应的另一部分的引用(在<code class="fe mt mu mv mw b">components</code>)。OpenAPI有许多像这样的<code class="fe mt mu mv mw b">$ref</code>链接来保持代码的整洁，并使其更容易重用。</li></ul><h2 id="ebde" class="mh kh it bd ki mi mj dn km mk ml dp kq lp mm mn ku lt mo mp ky lx mq mr lc ms bi translated">Swagger UI</h2><p id="9db9" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">分析OpenAPI规范最常用的工具之一是Swagger UI。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/0fc705bbc1505289d5541ecd8739c9ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gFX31XVntaUK_EY8.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank">https://editor.swagger.io/</a></figcaption></figure><p id="7cc0" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>是OpenAPI规范的原名，后来规范名改为OpenAPI。现在“Swagger”指的是支持<a class="ae kf" href="https://github.com/OAI/OpenAPI-Specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>规范的API工具，而不是规范本身。人们仍然经常交替使用这两个名字，但是“OpenAPI”才是这个规范应该使用的名字。</p><p id="fb2c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">除了Swagger UI，其他工具也可以分析我们的OpenAPI文档。以下是其中的一些:</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/adb0cd50d96a045161120677f73c55fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cvz2aXCDzVAGCcle"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://redocly.github.io/redoc/" rel="noopener ugc nofollow" target="_blank">https://redocly.github.io/redoc/</a></figcaption></figure><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/a6bfbc7764cd64c22f87125e15bec2af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8ihSLULNep7bIB_G"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://docs.readme.com/" rel="noopener ugc nofollow" target="_blank">https://docs.readme.com/</a></figcaption></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="bf62" class="kg kh it bd ki kj nz kl km kn oa kp kq kr ob kt ku kv oc kx ky kz od lb lc ld bi translated">I .从代码注释自动生成OpenAPI文件</h1><p id="b229" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您可以从程序代码中的注释自动生成OpenAPI规范文档，而不是手动编码。这种面向开发人员的方法在有大量API的情况下，或者在预先描述这些文档不太实际的情况下最有用。</p><p id="df13" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Swagger提供了许多库，您可以将这些库添加到您的程序代码中，以创建规范中的文档。本质上，它们分析开发人员添加的注释，并生成OpenAPI规范中的文档。但是，不同的编程语言有不同的注释方法。遵循特定于库的注释规则和准则来生成正确的等级库文件非常重要。</p><p id="7092" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">尽管这种方法“自动化”了规范生成，但是您仍然需要理解添加哪些注释以及如何添加它们(这与Javadoc注释和注释有太大的不同)。</p><h1 id="e2f6" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">二。按规格开发</h1><p id="7cde" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您可以从代码注释中生成您的规范，尽管人们普遍认为自动生成不是最好的方法。建议小组手动实现规范，然后将规范文档作为开发人员在执行编码时使用的文档进行处理。这种方法通常被称为“规格优先开发”。</p><p id="cffd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">换句话说，开发人员查看规范以了解参数名应该是什么样子，应该是什么响应，等等。</p><p id="79a6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">“规范优先开发”的方法主要帮助你为一个大的团队使用文档，而不仅仅是为工程师。在实现之前定义规范也有助于团队通过讨论和批准交互接口的最终版本来创建更好的API。</p><p id="d578" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">即使在创建API之前，如果您向规范中添加响应示例，规范也可能生成错误的响应。模拟服务器生成一个看起来像来自真实服务器的响应，但它只是代码中预定义的响应，对用户来说似乎是动态的。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="ba40" class="kg kh it bd ki kj nz kl km kn oa kp kq kr ob kt ku kv oc kx ky kz od lb lc ld bi translated">Golang的开源工具</h1><ul class=""><li id="de2a" class="mx my it lg b lh li ll lm lp oe lt of lx og mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/swagger-api/swagger-codegen" rel="noopener ugc nofollow" target="_blank">swagger-API/swagger-codegen</a>；</li><li id="8f52" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/go-swagger/go-swagger" rel="noopener ugc nofollow" target="_blank">招摇过市/招摇过市</a>；</li><li id="d5aa" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/swaggo/swag" rel="noopener ugc nofollow" target="_blank">swaggo/swag</a>；</li><li id="961d" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank">grpc-生态系统/grpc-网关</a>。</li></ul></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="b61e" class="kg kh it bd ki kj nz kl km kn oa kp kq kr ob kt ku kv oc kx ky kz od lb lc ld bi translated">斯瓦格-API/斯瓦格-codegen</h1><p id="822e" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">★11.6千</strong></p><p id="39d7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">Swagger Codegen是一个代码生成器，用于从OpenAPI规范中定义的RESTful API创建服务器和客户端SDK存根。剩下的工作就是实现API。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/a97f997348c6f6ab28ca42a5d80081ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5-IqOLcxPrPOPv7Q"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://editor.swagger.io/" rel="noopener ugc nofollow" target="_blank"><strong class="bd ki">https://editor.swagger.io/</strong></a></figcaption></figure><p id="5887" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">客户端包含发送请求的方法，以及处理请求的端点服务器和存根。</p><p id="8f2c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">文件夹结构的示例如下所示。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/51802dcf50d89e460f2cf4facfac239e.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*lpxtSgOUWpVJjUfM"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">客户端swagger-api/swagger-codegen的目录结构</figcaption></figure><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/b63afdd445dae3201909e214f38d8a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*Oph8x-0LgHWQvhP8"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">swagger-api/swagger-codegen服务器目录的结构</figcaption></figure><p id="f911" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">客户机和服务器包含相同的模型对象，这允许它们进行交互。下面的例子。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">模范宠物</figcaption></figure><p id="71ba" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">就其功能而言，这是最简单的工具。优点是您可以为几乎所有现代编程语言生成代码。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="0525" class="kg kh it bd ki kj nz kl km kn oa kp kq kr ob kt ku kv oc kx ky kz od lb lc ld bi translated">昂首阔步/昂首阔步</h1><p id="efaf" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu"> ★ 5，2k </strong></p><p id="07c6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">主<a class="ae kf" href="https://github.com/go-swagger/go-swagger" rel="noopener ugc nofollow" target="_blank"> go-swagger/go-swagger </a>工具包提供了命令行工具来帮助您使用swagger。</p><p id="87ef" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">该工具包具有广泛的定制选项，并为使用OpenAPI 2.0规范提供了许多功能:</p><ul class=""><li id="44b3" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">启动规范用户界面</li></ul><blockquote class="ol om on"><p id="3d0e" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">招摇发球。/petstore-expanded.json</p></blockquote><ul class=""><li id="d53d" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">检查规格</li></ul><blockquote class="ol om on"><p id="c7c9" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">swagger验证。/petstore-expanded.json</p></blockquote><ul class=""><li id="3491" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">创建API服务器</li></ul><blockquote class="ol om on"><p id="8c99" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">swagger生成服务器[-f ./swagger . JSON]-A[应用程序名称[ —主体[主体名称]]</p></blockquote><ul class=""><li id="823f" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">创建API客户端</li></ul><blockquote class="ol om on"><p id="2d50" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">swagger生成客户端[-f ./swagger . JSON]-A[应用程序名称[ —主体[主体名称]]</p></blockquote><ul class=""><li id="6486" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">从源代码生成规范</li></ul><blockquote class="ol om on"><p id="b57b" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">生成spec -o ./swagger.json</p></blockquote><ul class=""><li id="9000" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">为了生成数据模型</li></ul><blockquote class="ol om on"><p id="82d6" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">swagger生成模型—规格= {规格}</p></blockquote><ul class=""><li id="a046" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">转换规范，对齐，转换对象和指针，规范的统一</li></ul><blockquote class="ol om on"><p id="0a19" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">招摇扩展{spec}</p><p id="db6a" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">摇摆展平{spec}</p><p id="127d" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">swagger mixin {spec1} {spec2}</p></blockquote><ul class=""><li id="4e79" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">比较规格</li></ul><blockquote class="ol om on"><p id="3cc9" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">swagger diff {spec1} {spec2}</p></blockquote><p id="5ed5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在我们的例子中，只有API客户机和服务器创建命令是有趣的。</p><p id="3547" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">下面显示了生成客户端时我们得到的结果。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi os"><img src="../Images/3109c7f655cd0819f3143ab88a73aad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/0*3xWbd9C3MU3G0t-q"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">客户机go-swagger/go-swagger的目录结构</figcaption></figure><p id="c9dc" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">客户端不仅包含对象模型，还包含验证对象模型、将对象模型转换成请求、发送请求以及获得响应的方法。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Http客户端和请求实体验证</figcaption></figure><p id="df4c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">它的功能非常适合快速编写随时可用的SDK客户端与服务器进行交互。</p><p id="6551" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">服务器已经为实现做好了一切准备。它包括对象模型、端点、它们的描述、错误处理、查询验证以及服务初始化本身。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/8a7bc377db054661ad507eaa7e5914e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/0*kmUVFf4KBeAAU4oz"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">go-swagger/go-swagger服务器目录的结构</figcaption></figure><p id="7d3c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">服务器需要服务器配置和方法实现的最小配置。如果configure_swagger.go文件已经存在，则当您再次运行该命令时，将不会更新该文件。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">服务器配置和实施</figcaption></figure><p id="4aa9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">因此，我们有一个功能:</p><ul class=""><li id="aeaf" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">根据Swagger规范创建服务器；</li><li id="65d6" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">根据Swagger规范生成客户端；</li><li id="947b" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">支持JSON schema和swagger提供的大部分特性，包括多态性；</li><li id="b045" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">从代码批注创建OpenAPI规范；</li><li id="f534" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">使用swagger规范的附加工具；</li><li id="1dcf" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">定制功能，带有供应商扩展和定制模板；</li><li id="5e3e" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">用户界面服务规范。</li></ul><p id="2882" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">除了<a class="ae kf" href="https://github.com/go-swagger" rel="noopener ugc nofollow" target="_blank"> go-swagger </a>工具和生成器之外，<a class="ae kf" href="https://github.com/go-openapi" rel="noopener ugc nofollow" target="_blank"> go-openapi </a>包还提供了基于openapi创建定制解决方案的模块化功能。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="8d8f" class="kg kh it bd ki kj nz kl km kn oa kp kq kr ob kt ku kv oc kx ky kz od lb lc ld bi translated">swaggo/swag</h1><p id="4626" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu"> ★ 2，7k </strong></p><p id="cfb6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://github.com/swaggo/swag" rel="noopener ugc nofollow" target="_blank"> Swag </a>将Go注释转换成swagger 2.0文档。已经为流行的web框架编写了许多插件。</p><ul class=""><li id="1bc5" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><a class="ae kf" href="http://github.com/swaggo/gin-swagger" rel="noopener ugc nofollow" target="_blank">杜松子酒</a></li><li id="359d" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="http://github.com/swaggo/echo-swagger" rel="noopener ugc nofollow" target="_blank">回声</a></li><li id="8eaf" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/swaggo/buffalo-swagger" rel="noopener ugc nofollow" target="_blank">水牛</a></li><li id="bf64" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/swaggo/http-swagger" rel="noopener ugc nofollow" target="_blank"> net/http </a></li><li id="1ffa" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/i-love-flamingo/swagger" rel="noopener ugc nofollow" target="_blank">火烈鸟</a></li><li id="c506" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/arsmn/fiber-swagger" rel="noopener ugc nofollow" target="_blank">纤维</a></li><li id="96de" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi">…</li></ul><p id="a614" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">添加一个<code class="fe mt mu mv mw b">jsonschema</code>描述的过程与Javadoc注释和注解没有太大的不同。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">swaggo注释的示例</figcaption></figure><p id="7b73" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这允许您快速将<a class="ae kf" href="https://github.com/swaggo/swag" rel="noopener ugc nofollow" target="_blank"> swaggo/swag </a>集成到现有项目中。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="a433" class="kg kh it bd ki kj nz kl km kn oa kp kq kr ob kt ku kv oc kx ky kz od lb lc ld bi translated">grpc-生态系统/grpc-网关</h1><p id="2abf" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu"> ★ 8，8k </strong></p><p id="ac5f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank">grpc-生态系统/grpc-网关</a>是一个<code class="fe mt mu mv mw b">protoc</code>插件。它读取RPC服务定义，并生成一个反向代理服务器，将RESTful JSON API翻译成gRPC。该服务器是根据gRPC描述中的参数创建的。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ou"><img src="../Images/61505bb19fcb7803d579bf718d4ed3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d0SyYiso6dLLBCA8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">обратныйgrpc网关</figcaption></figure><p id="5f0c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这个项目旨在为你的gRPC服务提供一个HTTP + JSON接口。这有助于您同时提供gRPC和RESTful风格的API。</p><h1 id="4cc1" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">原蟾蜍</h1><p id="6096" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">gRPC用多种编程语言为服务器生成API客户端和存根，它速度快，易于使用，带宽效率高，其设计已经过Google验证。</p><p id="760c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">gRPC很容易定义。这使用了<a class="ae kf" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a> (protobuf)，一种独立于语言、独立于平台、可扩展的Google机制，用于序列化结构化数据。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">protobuf文件的描述</figcaption></figure><p id="72f4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">gRPC相对于其他协议的优势:</p><ul class=""><li id="65ff" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">比JSON紧凑2倍；</li><li id="da3b" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">比XML紧凑3倍；</li><li id="f44c" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">没有掩码，无法解密消息；</li><li id="f427" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">反序列化所需的CPU和内存更少；</li><li id="7cf5" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">提供所有语言版本；</li><li id="908f" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">向前和向后兼容性。</li></ul><p id="1f7c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">缺点:</p><ul class=""><li id="bba8" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">没有默认值；</li><li id="d04b" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">解码需要一个架构。</li></ul><h1 id="f9b5" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">向前和向后兼容性</h1><p id="9a52" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">编码记录是编码字段的串联。每个字段由它的标签号定义(图示例中的数字1、2和3)，并用数据类型标记(例如，字符串或整数)。如果没有设置字段值，它就不会包含在编码记录中。因此，字段标签对于编码数据的意义非常重要。您可以更改模式中的字段名称，编码的数据永远不会引用字段名称，但您不能更改字段标记，因为这将把所有现有的编码数据变成不正确的数据。</p><p id="e985" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果您没有忘记为每个字段设置一个新的标记号，那么您可以向模式中添加新的字段。试图读取由新代码写入的数据的旧代码(其不知道关于添加的新标签号的任何事情),包括具有它不理解的标签号的新字段，可以简单地忽略这个号。由于数据类型签名，解析器可以确定需要跳过多少字节。这确保了直接兼容性:旧代码可以读取新代码条目。</p><p id="69b6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果所有字段都有唯一的标签号，新代码将始终能够读取旧数据，因为标签号的含义没有改变。删除一个字段与添加一个字段没有什么不同，只是向后和向前的兼容性被颠倒了。您不能重复使用相同的标签号(因为包含旧标签号的数据可能仍存储在某个地方，新代码应忽略该字段)。</p><p id="1f34" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果更改字段的数据类型，则存在丢失字段准确性或截断字段的风险。例如，我们将一个32位整数改为同样的64位整数。新代码可以很容易地读取旧代码写入的数据，因为解析器可以用零填充所有缺失的位。但是，当旧代码读取新代码写入的数据时，旧代码仍然使用32位变量来存储值。如果解码的64位值不适合32位，它将被截断。</p><p id="8909" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在协议缓冲区格式中，没有列表或数组的数据类型，而是有一个重复的字段标记。相同的字段标记在记录中重复了几次。这样做的一个好处是，您可以将具有单个值的字段更改为重复的(具有多个值)。读取旧数据的新代码将看到一个零或一个元素的列表(取决于字段是否存在)，而读取新数据的旧代码将只看到最后一个元素。</p><h1 id="65e8" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">google.api.http</h1><p id="3654" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">GRPC代码转换是gRPC方法和一个或多个HTTP REST端点之间的转换功能。这允许开发人员创建一个支持gRPC API和REST API的API服务。包括<a class="ae kf" href="https://github.com/googleapis/googleapis" rel="noopener ugc nofollow" target="_blank"> API Google </a>、<a class="ae kf" href="https://cloud.google.com/endpoints" rel="noopener ugc nofollow" target="_blank">云端点</a>、<a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank"> gRPC网关</a>和<a class="ae kf" href="https://github.com/envoyproxy/envoy" rel="noopener ugc nofollow" target="_blank"> Envoy </a>代理服务器在内的许多系统都支持这一特性，并将其用于大规模生产服务。</p><p id="db64" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe mt mu mv mw b"><a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway" rel="noopener ugc nofollow" target="_blank">grcp-gateway</a></code>服务器是根据服务定义中的<code class="fe mt mu mv mw b"><a class="ae kf" href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto" rel="noopener ugc nofollow" target="_blank">google.api.http</a></code>注释创建的。</p><p id="cab3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><code class="fe mt mu mv mw b">HttpRule</code>定义gRPC / REST映射方案。映射定义了gRPC请求消息的不同部分如何映射到URL路径、URL请求参数和HTTP请求主体。它还控制gRPC响应消息在HTTP响应正文中的显示方式。在gRPC方法中，<code class="fe mt mu mv mw b">HttpRule</code>通常被指定为<code class="fe mt mu mv mw b">google.api.http</code>注释。</p><p id="91f4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">每个映射定义一个URL路径模板和一个HTTP方法。如果每个字段都是具有原始类型的非重复字段，则路径模板可以引用gRPC请求消息中的一个或多个字段。路径模板控制如何将请求消息字段映射到URL路径。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">google.api.http注释</figcaption></figure><p id="b6d4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您需要向<code class="fe mt mu mv mw b">protoc</code>编译器提供必要的第三方<code class="fe mt mu mv mw b">protobuf</code>文件。它们包含在<code class="fe mt mu mv mw b"><a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway/tree/master/third_party/googleapis" rel="noopener ugc nofollow" target="_blank">third_party/googleapis</a></code>文件夹的<code class="fe mt mu mv mw b">grpc-gateway</code>存储库中，我们建议将它们复制到项目文件结构中。</p><p id="d44c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您需要向<code class="fe mt mu mv mw b">protoc</code>编译器提供必要的第三方<code class="fe mt mu mv mw b">protobuf</code>文件。它们包含在<code class="fe mt mu mv mw b"><a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway/tree/master/third_party/googleapis" rel="noopener ugc nofollow" target="_blank">third_party/googleapis</a></code>文件夹中的<code class="fe mt mu mv mw b"><a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway/" rel="noopener ugc nofollow" target="_blank">grpc-gateway</a></code> <a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway/" rel="noopener ugc nofollow" target="_blank">存储库</a>中，我们建议将它们复制到项目文件结构中。</p><h1 id="5763" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">映射GET请求</h1><p id="9033" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">URL中HTTP映射的规则:</p><p id="78ad" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">1.请求消息中的嵌套消息分为三类:</p><ul class=""><li id="324d" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">路径模板引用的字段。它们通过URL路径传递；</li><li id="fed8" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">google.api.HttpRule.body</code>引用的字段。它们通过HTTP请求体传递；</li><li id="41bc" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">其他所有字段都通过URL请求参数传递，参数名是请求消息中字段的路径；</li><li id="0aaf" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">重复字段可以表示为同名的多个查询参数。</li></ul><p id="1634" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">2.如果<code class="fe mt mu mv mw b">google.api.HttpRule.body = "*”</code>，省略URL请求参数，所有字段都通过URL路径和HTTP请求体传递。</p><p id="e314" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">3.如果省略<code class="fe mt mu mv mw b">google.api.HttpRule.body</code>，则省略HTTP请求体，所有字段都通过URL请求的URL路径和参数传递。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">定义GET请求</figcaption></figure><p id="a4a7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果缺少HTTP请求正文，请求消息中未被路径模板链接的任何字段都会自动成为HTTP请求参数。</p><p id="a958" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">映射到URL请求参数的字段必须具有基本类型、重复基本类型或非重复消息类型。如果类型重复，参数可以在URL中重复为<code class="fe mt mu mv mw b">…?param=A&amp;param=B</code>。对于一个消息类型，每个消息字段被映射到一个单独的参数，比如<code class="fe mt mu mv mw b">…?foo.a=A&amp;foo.b=B&amp;foo.c=C</code>。</p><h1 id="7197" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">邮政</h1><p id="967b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对于允许请求<code class="fe mt mu mv mw b">body</code>的HTTP方法，body字段定义了显示。考虑消息资源集合的REST更新方法。</p><p id="e5ff" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">可以在主体映射中使用特殊名称<code class="fe mt mu mv mw b">“*“</code>来确定每个与路径模板不相关联的字段应该被映射到请求主体。这包括更新方法的以下替代定义:</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">定义发布请求</figcaption></figure><p id="f82e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">注意，当在主体显示中使用<code class="fe mt mu mv mw b">“*”</code>时，不可能有HTTP参数，因为所有字段都不与主体中的路径结尾相关联。这使得在定义REST API时很少使用这个选项。<code class="fe mt mu mv mw b">“*”</code>通常用于完全不使用URL进行数据传输的用户方法中。</p><h1 id="5b9d" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">附加方法包</h1><p id="c020" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">您可以使用<code class="fe mt mu mv mw b">additional_bindings</code>选项为单个RPC定义多个HTTP方法。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">附加路径绑定</figcaption></figure><h1 id="98fe" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">修补</h1><p id="2323" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">gRPC中没有空值，如果没有定义该值，则默认使用空值，即<code class="fe mt mu mv mw b">string = ””</code>或<code class="fe mt mu mv mw b">int = 0</code>。这很成问题，因为很难确定查询中的值是空的还是未定义的。解决这个问题的方法是列出在请求中设置的属性的名称。这必须由请求者设置，grpc-gateway自动从请求有效负载中检测属性名称，并自动发送列表。</p><p id="465c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">唯一的要求是protobuf请求消息必须有一个类型为的<code class="fe mt mu mv mw b">update_mask</code>字段，并且请求必须是一个<code class="fe mt mu mv mw b">PATCH</code>请求。其思想是，如果绑定被映射到一个修复，并且请求消息恰好包含一个消息字段掩码，则为网关处理程序创建额外的代码，该代码将基于请求体填充字段掩码。有两种情况:</p><ul class=""><li id="eb29" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">根据Google API设计指南，从REST请求中隐藏了<code class="fe mt mu mv mw b">FieldMask</code>。在这种情况下，<code class="fe mt mu mv mw b">FieldMask</code>从请求体更新，并在gRPC请求消息中设置；</li><li id="5dce" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">FieldMask</code>接受REST查询。在这种情况下，网关保持字段掩码不变。</li></ul><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">定义POST和PUT请求，使用FieldMask的示例</figcaption></figure><blockquote class="ol om on"><p id="b470" class="le lf oo lg b lh mc lj lk ll md ln lo op me lr ls oq mf lv lw or mg lz ma mb im bi translated">重要的是要知道，如果请求是一个PUT请求，<code class="fe mt mu mv mw b"><em class="it">update_mask</em></code>字段将不会自动填充。有关字段掩码的更多信息，请参见此<a class="ae kf" href="https://pkg.go.dev/google.golang.org/protobuf@v1.25.0/types/known/fieldmaskpb?tab=doc" rel="noopener ugc nofollow" target="_blank"> godoc </a>。</p></blockquote><h1 id="9ed9" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">WebSocket</h1><p id="fd45" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">gRPC请求有四种类型<a class="ae kf" href="https://www.grpc.io/docs/what-is-grpc/core-concepts/#rpc-life-cycle" rel="noopener ugc nofollow" target="_blank">:</a></p><ul class=""><li id="4f09" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><a class="ae kf" href="https://www.grpc.io/docs/what-is-grpc/core-concepts/#unary-rpc" rel="noopener ugc nofollow" target="_blank">一元</a> —这是一个单独的请求，一个RPC响应；</li><li id="ca20" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://www.grpc.io/docs/what-is-grpc/core-concepts/#client-streaming-rpc" rel="noopener ugc nofollow" target="_blank">客户端流</a> —这是一个具有多个请求和一个响应的RPC</li><li id="6029" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://www.grpc.io/docs/what-is-grpc/core-concepts/#server-streaming-rpc" rel="noopener ugc nofollow" target="_blank">服务器流</a> —这是一个具有一个请求和多个响应的RPC</li><li id="6440" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://www.grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc" rel="noopener ugc nofollow" target="_blank">双向流</a> —多请求多响应的RPC。</li></ul><p id="45c6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">将<code class="fe mt mu mv mw b">mux</code> <a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-gateway/blob/master/runtime/mux.go" rel="noopener ugc nofollow" target="_blank"> grpc-gateway </a>包装在<a class="ae kf" href="http://github.com/tmc/grpc-websocket-proxy" rel="noopener ugc nofollow" target="_blank"> grpc-websocket-proxy </a>中，以通过web sockets公开流端点。在网络上，它对消息使用带有换行符的编码。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">定义WebSocket路径</figcaption></figure><h1 id="2471" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">HTTP正文</h1><p id="1137" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="https://github.com/googleapis/googleapis/blob/master/google/api/httpbody.proto" rel="noopener ugc nofollow" target="_blank"> HTTP Body </a> messages允许您指定带有自定义数据内容和自定义内容类型头的响应消息。包含在<code class="fe mt mu mv mw b">http.Body</code>响应中的值将一字不差地用于从网关返回的消息中。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">生成带有自定义标头的响应</figcaption></figure><h1 id="2059" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">截击机</h1><p id="8752" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">gRPC Go最近获得了对拦截器的支持，即在将请求传递给用户的应用程序逻辑之前运行在gRPC服务器上，或者围绕用户的调用运行在gRPC客户端上的中间件。这是实现通用模板的理想方式:身份验证、日志、消息、验证、重试或监控。</p><p id="2fc2" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/go-grpc-middleware" rel="noopener ugc nofollow" target="_blank"> grpc_middleware </a>为拦截器链提供支持。有两种类型的拦截器:客户端和服务器端。这个包为两者都提供了对拦截器的监控。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">客户端和服务器端拦截器</figcaption></figure><p id="14ed" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">证明</p><ul class=""><li id="da3d" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/auth" rel="noopener ugc nofollow" target="_blank"> grpc_auth </a> —认证中间件的可配置部分(通过<code class="fe mt mu mv mw b">AuthFunc</code>)。</li></ul><p id="34f4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">记录</p><ul class=""><li id="6f63" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">grpc_ctxtags  —将<code class="fe mt mu mv mw b">Tag</code>地图添加到上下文中的库，其中数据是从请求体填充的；</li><li id="050b" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">grpc_zap  —将zap日志记录库集成到grpc处理程序中；</li><li id="3cc7" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">grpc_logrus  —将logrus日志记录库集成到grpc处理程序中；</li><li id="690a" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">grpc_kit  —将go-kit日志库集成到grpc处理程序中。</li></ul><p id="9ea9" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">监视</p><ul class=""><li id="f93c" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/go-grpc-prometheus" rel="noopener ugc nofollow" target="_blank"> grpc_prometheus </a> —客户端和服务器端监控中间件；</li><li id="c7fa" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/grpc-opentracing/tree/master/go/otgrpc" rel="noopener ugc nofollow" target="_blank"> otgrpc </a> — OpenTracing客户端和服务器端拦截器；</li><li id="be48" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/tracing/opentracing" rel="noopener ugc nofollow" target="_blank"> grpc_opentracing </a> —支持流和处理程序返回标签的客户端和服务器端opentracing拦截器。</li></ul><p id="0fd7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">客户</p><ul class=""><li id="9d89" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/retry" rel="noopener ugc nofollow" target="_blank"> grpc_retry </a> —用于重复grpc响应代码的通用机制，客户端中间件。</li></ul><p id="f755" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">计算机网络服务器</p><ul class=""><li id="9bd0" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/validator" rel="noopener ugc nofollow" target="_blank"> grpc_validator </a> —检查来自<code class="fe mt mu mv mw b">.proto</code>选项的传入codegen消息；</li><li id="5c87" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/recovery" rel="noopener ugc nofollow" target="_blank"> grpc_recovery </a> —把恐慌变成grpc错误；</li><li id="f052" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><a class="ae kf" href="https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/ratelimit" rel="noopener ugc nofollow" target="_blank">速率限制</a> —用限制器限制grpc速度。</li></ul><h1 id="99e9" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">规格扩展</h1><p id="4116" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要在单独的文件中设置OpenAPI的附加参数，需要描述选项<code class="fe mt mu mv mw b">grpc.gateway.protoc_gen_swagger.option.openapiv2_swagger</code>。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">OpenAPI的附加描述</figcaption></figure><h1 id="242d" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">只读的</h1><p id="bddc" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有些字段，比如<code class="fe mt mu mv mw b">ID</code>，更新没有意义。只需添加一条评论<code class="fe mt mu mv mw b">// Output only</code>，就可以将它们设置为<code class="fe mt mu mv mw b">“readOnly”: true</code>。在protobuf消息字段中，将该字段标记为只读。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">只读字段</figcaption></figure><h1 id="6318" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">产生</h1><p id="e56d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从生成模型需要在本地安装protobuf协议缓冲区编译器协议3.0.0版或更高版本。其他依赖关系可以通过<code class="fe mt mu mv mw b">go mod</code>设置。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安装依赖项</figcaption></figure><ul class=""><li id="1bf3" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">protoc-gen-go</code>是一个<code class="fe mt mu mv mw b">protoc</code>插件，用于在Go上生成缓冲协议包；</li><li id="d41e" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">protoc-gen-swagger</code>是一个生成swagger代码的插件；</li><li id="0477" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><code class="fe mt mu mv mw b">protoc-gen-grpc-gateway</code>是一个插件，用于生成反向代理服务器，将输入的RESTful HTTP/1请求转换为gRPC。</li></ul><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">生成grpc-网关反向代理</figcaption></figure><h1 id="9242" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">履行</h1><p id="cc7e" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">下面是一个在Golang中启动服务器的例子。</p><figure class="nm nn no np gt ju"><div class="bz fp l di"><div class="oj ok l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">正在初始化grpc网关的入口点</figcaption></figure><h1 id="ad0b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">优点和缺点</h1><p id="0819" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">grpc网关方法的优势:</p><ul class=""><li id="a83e" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">都在一个地方；</li><li id="5a41" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">RESTful JSON API</li><li id="4a8f" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">gRPC</li><li id="cc2c" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">网络插座；</li><li id="3bb3" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">支持自定义标题和数据(例如，上传文件)；</li><li id="c4af" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">OpenAPI文档。</li></ul><p id="280f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">缺点包括:</p><ul class=""><li id="61c5" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated">通过HTTP的低速；</li><li id="1d44" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated">OpenAPI没有灵活的描述。</li></ul></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="efb4" class="kg kh it bd ki kj nz kl km kn oa kp kq kr ob kt ku kv oc kx ky kz od lb lc ld bi translated">OpenAPI和Swagger UI的缺点</h1><p id="2130" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">尽管Swagger具有吸引用户“让我试试”欲望的交互能力，但Swagger和OpenAPI也有一些缺点:</p><ul class=""><li id="d838" class="mx my it lg b lh mc ll md lp mz lt na lx nb mb nc nd ne nf bi translated"><strong class="lg iu">仅链接信息:</strong>首先，OpenAPI规范和Swagger UI输出只覆盖链接文档。OpenAPI为每个端点提供了基础:描述、参数以及示例请求和响应。OpenAPI不包含入门空间、如何获得API密钥的信息、如何启动示例应用程序的信息、关于速度限制的信息，或者在开发人员指南中找到的一百个其他细节。因此，即使有这个很酷的交互工具允许用户探索和学习我们的API，我们仍然需要提供一个用户指南。</li><li id="ffb0" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><strong class="lg iu">信息冗余/重复:</strong>在OpenAPI中，可能有两个地方描述了端点和参数(Swagger UI链接描述和用户指南)，您需要同步它们，将一个嵌入到另一个中，或者指定它们之间的关系。</li><li id="e62e" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><strong class="lg iu">工作流API的复杂性:</strong>API的复杂性也可以创造一个Swagger的极限。如果有端点具有复杂的相互依赖关系，并且需要特殊的配置工作流或其他非直观的处理。例如，如果你需要在一个端点返回任何东西之前首先配置API服务，然后使用一个端点获得一个特定的对象，该对象被传递给另一个端点的参数，等等，在没有详细指南的情况下，Swagger UI中的<code class="fe mt mu mv mw b">Try-it-out</code>功能对用户来说没有太大意义。</li><li id="7acf" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><strong class="lg iu">对真实数据的请求:</strong>有些用户可能没有意识到，点击“试用”按钮会根据他们使用的API键对他们的帐户进行真实的调用。当用户开始询问如何删除所有测试数据或为什么他们的实际数据现在被破坏时，将Swagger等研究隔离软件环境与真实数据混合使用可能会导致问题。</li><li id="bfbb" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><strong class="lg iu"> CORS限制:</strong>进行API调用时可能会遇到CORS限制(跨产地资源共享)。并非所有API都接受来自网页的请求。</li><li id="342d" class="mx my it lg b lh ng ll nh lp ni lt nj lx nk mb nc nd ne nf bi translated"><strong class="lg iu">查询体参数多的问题:</strong>查询体参数长的端点通常有问题。单个API可以包含带有数百行长的请求主体参数的查询。请求体中有了这个参数，Swagger用户界面的显示就变得不可用了。</li></ul></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="7def" class="kg kh it bd ki kj nz kl km kn oa kp kq kr ob kt ku kv oc kx ky kz od lb lc ld bi translated">结论</h1><p id="6dba" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">尽管OpenAPI规范有缺点，但仍然强烈推荐使用它来描述API。OpenAPI正迅速成为越来越多工具的基础。您可以使用您的开放API规范将您的API导入到许多平台和系统中，并自动配置单元测试和原型。</p><p id="d87d" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">有了上面讨论的工具，文档也成为实现web服务器的工具。</p></div></div>    
</body>
</html>