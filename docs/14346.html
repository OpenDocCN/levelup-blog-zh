<html>
<head>
<title>How I Migrated my Mobile Game to Windows in a Single Night</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在一夜之间将手机游戏迁移到Windows</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-migrated-my-mobile-game-to-windows-in-a-single-night-b2827df6aea3?source=collection_archive---------3-----------------------#2022-11-18">https://levelup.gitconnected.com/how-i-migrated-my-mobile-game-to-windows-in-a-single-night-b2827df6aea3?source=collection_archive---------3-----------------------#2022-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a8e7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">颤动的力量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8aca55477e82db7f0f656bb596e818d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkMSKIl_toiu5PiRkda0hw.jpeg"/></div></div></figure><p id="98c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你以前看过我的作品，你就知道我是一个狂热的颤振爱好者。从它的声明式UI到它的活跃社区&amp;开发，有很多值得喜欢的地方。也许关于Flutter最好的事情是它对跨平台开发的关注。对于小型团队和个人开发人员来说，它在提供一种维护较小代码库和跨多个平台快速迭代的方法方面的能力是无与伦比的。在这篇文章中，我将分享这样一个经历的主要例子，我作为一个单独的开发者，能够在仅仅一个晚上就将一个Android &amp; iOS游戏移植到Windows。</p><p id="dadc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将看看我这样做的动机，以及从移动到桌面时要考虑的因素。然后，我们将看看我为实现这一目标所采取的具体步骤，以及我在这个过程中学到的一些东西。首先，我们来看看游戏。</p><h1 id="b055" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">灯光:记忆游戏</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d613" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这绝不是我的游戏的插件，但如果你想自己检查一下，它可以在iOS，Android和现在的Windows上使用！如果您打算尝试一下，我鼓励您在移动和Windows上尝试一下，看看这两个平台之间存在的细微差异。</p><p id="5494" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，这个游戏是经典的西蒙说的公式的现代版。它最初是一个个人项目，因为我正在学习Flutter框架的不同部分。接下来我知道的是，有超过15种游戏模式，成就&amp;排行榜，以及一个我想与世界分享的应用程序。你可能还会注意到，这就是所谓的类似应用程序的游戏，这意味着它利用触摸输入，有一个类似应用程序的界面，不需要传统的游戏循环。然而，颤振当然有能力处理<a class="ae mi" href="https://pinball.flutter.dev" rel="noopener ugc nofollow" target="_blank">更多的</a>。</p><h1 id="5793" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">动机</h1><p id="7645" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">我收到了一个喜欢和家人朋友一起玩的玩家发来的电子邮件，我想知道是否有可能在Windows上提供，这样他们就可以在更大的屏幕上玩了。用他们的话说，PC上的类似产品比不上我的游戏质量。因为我用Dart/Flutter编写了游戏，所以我知道软件的核心不需要改变。我设计的游戏引擎，以及关键的UI组件，比如发光的按钮，在移植过程中确实不会被触及。我很兴奋地感觉到，我的游戏让我爱的人在一起度过了一段美好的时光，并且感谢fluth，我可以用最少的努力改善他们的体验。男孩，我是对的！让我们来看看我在设计Windows端口时必须考虑的事情。</p><h1 id="6357" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">考虑</h1><h2 id="369f" class="mo lo iq bd lp mp mq dn lt mr ms dp lx la mt mu lz le mv mw mb li mx my md mz bi translated">不兼容的插件</h2><p id="0334" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">不是每个Flutter插件都适用于每个平台。有些可能最终会实现，而其他一些没有理由实现，因为它们提供了特定于一两个平台的功能。Lights for mobile使用了3个这样的插件:<a class="ae mi" href="https://pub.dev/packages/games_services" rel="noopener ugc nofollow" target="_blank"> games_services </a>、<a class="ae mi" href="https://pub.dev/packages/google_mobile_ads" rel="noopener ugc nofollow" target="_blank"> google_mobile_ads </a>和<a class="ae mi" href="https://pub.dev/packages/in_app_purchase" rel="noopener ugc nofollow" target="_blank"> in_app_purchase </a>。列出的第一个插件提供了游戏中心&amp;的Google Play游戏功能，这在Windows上没有任何用处。后两个是不言自明的，目前不支持Windows，尽管将来可能会支持。</p><p id="4bb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有两种方法可以处理你正在使用的应用程序。如果可能的话，我们可以重新设计应用程序，使其不依赖于目标平台上不可用的插件。否则，我们可以使用条件导入和代码块来避免不兼容的插件。我选择了后一种方法，因为我不想在手机上失去成就和排行榜。目前，移动版本仍然支持广告&amp;通过应用内购买实现无广告的能力，尽管这种体验让我开始对永久删除移动广告进行A/B测试。</p><h2 id="f271" class="mo lo iq bd lp mp mq dn lt mr ms dp lx la mt mu lz le mv mw mb li mx my md mz bi translated">用户界面/行为预期</h2><p id="9de7" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">移动应用和桌面应用的预期用户体验有很大不同。我们必须考虑UI特性(窗口对全屏)，行为(最小化/最大化等)，以及不同的输入设备(触摸屏对鼠标/触摸板和键盘)。</p><p id="5953" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要考虑的关键组件:</p><ul class=""><li id="dec6" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">你的app <em class="mh">自适应</em>吗？你的布局能在不同尺寸的屏幕/窗口上显示吗？请记住，你的应用程序将在桌面上的一个窗口中运行，当用户调整大小时，窗口的尺寸会有很大的变化。</li><li id="09eb" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">你的app <em class="mh">是反应式</em>吗？当用户调整窗口大小时，布局会调整以最好地显示信息吗？</li><li id="9277" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">用户会知道如何与你的应用程序交互吗？他们能以预期的方式最小化或最大化窗口吗？当一个项目是可点击的(通过改变指针)你中继吗？</li><li id="1471" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">你的应用需要处理替代输入吗？一些考虑包括键盘，游戏控制器，多按钮鼠标。总的来说，有了Flutter，点击就像移动设备上的触摸一样，内置的接收文本的小部件可以很好地处理键盘输入。但是，您可能需要处理一些事情来满足用户的期望。</li></ul><h2 id="f33a" class="mo lo iq bd lp mp mq dn lt mr ms dp lx la mt mu lz le mv mw mb li mx my md mz bi translated">分配</h2><p id="88f9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">你将如何分发你的应用？这是一个内部应用程序，可以用必要的文件作为exe分发吗？可以自签名打包成安装程序内部使用吗？您是否需要可信机构的证书来通过您自己的网站分发安装程序？还是会在微软商店发布？</p><p id="dd45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于几乎所有情况，我建议使用<a class="ae mi" href="https://pub.dev/packages/msix" rel="noopener ugc nofollow" target="_blank"> msix </a>包。它使用Windows最新的打包格式<a class="ae mi" href="https://learn.microsoft.com/en-us/windows/msix/" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> MSIX </em> </a>来提供一种现代且相对容易的打包体验。最后，您将获得一个可以作为安装程序分发或直接上传到微软商店的包。</p><h1 id="6a8d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">该过程</h1><p id="2f2c" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">老实说，Flutter/Dart让这个过程变得如此简单有点可笑。我敢说，在微软商店出售我的游戏之前，我只接触了不到1%的代码。在我的例子中，代码已经被设计为适应不同大小的设备，因为它在手机和平板电脑上可用。由于它是如何写的，布局也是反应性的。你可能会发现你需要花一点时间来更新你的布局。</p><p id="b0ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，那天晚上我花了大部分时间注册成为微软的合作伙伴&amp;弄清楚如何正确地打包我的应用程序，以便通过微软商店进行销售。如果您以前没有为Windows打包过，我也将帮助您避免一些学习曲线。现在让我们深入研究，从代码调整开始。</p><h2 id="5113" class="mo lo iq bd lp mp mq dn lt mr ms dp lx la mt mu lz le mv mw mb li mx my md mz bi translated">条件插件用法</h2><p id="75a1" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">首先，在使用任何手机特定插件之前，我们需要检查我们是否在手机上。我们可以编写一个简单的helper方法，当我们需要检查时，可以从任何地方调用它。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="afdb" class="nt lo iq np b be nu nv l nw nx">bool get isMobile =&gt; Platform.isIOS || Platform.isAndroid;</span></pre><p id="23d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，假设我们通过<code class="fe ny nz oa np b">Provider</code>传递控制器，这是颤振中的一种常见方法。我们基于<code class="fe ny nz oa np b">isMobile</code>实例化它们，如果我们在桌面上，就让它们<code class="fe ny nz oa np b">null</code>。这将允许我们根据控制器是<code class="fe ny nz oa np b">null</code>(桌面)还是非(移动)来调用控制器。为简洁起见，我将只展示一个正在使用的控制器。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="34e5" class="nt lo iq np b be nu nv l nw nx">// conditional instantiation<br/>GamesServicesController? gamesServicesController;<br/>if(isMobile) gamesServicesController = GamesServicesController();<br/><br/>// pass the object down the tree<br/>Provider&lt;GamesServicesController?&gt;.value(<br/>  value: gamesServicesController,<br/>);<br/><br/>// conditional use<br/>context.read&lt;GamesServicesController?&gt;()?.showAchievements();</span></pre><p id="09d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，如果我们在Windows上，就不会调用<code class="fe ny nz oa np b">showAchievements</code>方法。这种方法可以处理我们插件的所有条件使用。</p><p id="50da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们已经删除了不可用的功能，我们需要实现新的桌面特定功能。为此，我使用了两个包:<a class="ae mi" href="https://pub.dev/packages/bitsdojo_window" rel="noopener ugc nofollow" target="_blank">bitsdojo _ window</a>&amp;<a class="ae mi" href="https://pub.dev/packages/window_manager" rel="noopener ugc nofollow" target="_blank">window _ manager</a>。您的需求可能会有所不同。还有一个很棒的软件包叫做<a class="ae mi" href="https://pub.dev/packages/fluent_ui" rel="noopener ugc nofollow" target="_blank"> fluent_ui </a>，它将帮助你获得Windows的原生感觉。</p><h2 id="3336" class="mo lo iq bd lp mp mq dn lt mr ms dp lx la mt mu lz le mv mw mb li mx my md mz bi translated">桌面用户界面/功能</h2><p id="abf9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">大多数内置的Flutter窗口小部件已经能够正确处理鼠标指针的更新，但是您可能有一些自定义的窗口小部件在可点击时也应该这样做。对我来说，游戏按钮需要更新。这款游戏的真正目的是在二合一笔记本电脑上通过触摸屏来玩，但如果你愿意，也可以用鼠标/触摸板来玩。因此，鼠标指针应该反映这一点。幸运的是，像大多数东西一样，这是一个快速简单的添加。只需将您的小部件包装在一个<code class="fe ny nz oa np b">MouseRegion</code>中。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="280a" class="nt lo iq np b be nu nv l nw nx">MouseRegion(<br/>  cursor: SystemMouseCursors.click,<br/>  child: ...,<br/>)</span></pre><p id="e5e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要做最后的UI调整。即右上角的最小化、最大化和关闭按钮。这也是一个好主意，调整应用程序栏的情况，以允许标准的窗口功能，如窗口拖动和双击最大化/恢复。对于所有这些，我们将使用<a class="ae mi" href="https://pub.dev/packages/bitsdojo_window" rel="noopener ugc nofollow" target="_blank"> bitsdojo_window </a>。首先，我们将设置它。</p><p id="cabe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ny nz oa np b">windows\runner\main.cpp</code>的开头添加以下几行:</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="bac2" class="nt lo iq np b be nu nv l nw nx">#include &lt;bitsdojo_window_windows/bitsdojo_window_plugin.h&gt;<br/>auto bdw = bitsdojo_window_configure(BDW_CUSTOM_FRAME | BDW_HIDE_ON_STARTUP);</span></pre><p id="b20a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，在您调用<code class="fe ny nz oa np b">main</code>方法中的<code class="fe ny nz oa np b">runApp</code>之后，直接添加以下内容:</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="3b0b" class="nt lo iq np b be nu nv l nw nx">void main() {<br/>  ...<br/>  runApp(MyApp());<br/><br/>  // Add this code<br/>  doWhenWindowReady(() {<br/>    appWindow.size = Size(600, 450);<br/>    appWindow.alignment = Alignment.center;<br/>    appWindow.show();<br/>  });<br/>}</span></pre><p id="25cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在调用<code class="fe ny nz oa np b">show</code>之前有很多选项可以设置，所以我鼓励你查看一下软件包文档。</p><p id="ac0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们使用软件包提供的一些小部件来完成我们的设计。这个包还提供了许多小部件，旨在提供良好的桌面体验。我们将介绍我在这里使用的方法:</p><ul class=""><li id="50fc" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated"><code class="fe ny nz oa np b">WindowBorder</code>(不言自明)</li><li id="466c" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><code class="fe ny nz oa np b">WindowTitleBarBox</code> —这是定义窗口顶部的方式。类似于手机上的AppBar。</li><li id="0890" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><code class="fe ny nz oa np b">MoveWindow</code> —这是一个允许用户抓取&amp;拖动窗口的小部件。通常也是标题栏。</li><li id="c327" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><code class="fe ny nz oa np b">WindowButton</code>—窗口右上角按钮的基类。子类包括<code class="fe ny nz oa np b">MinimizeWindowButton</code>、<code class="fe ny nz oa np b">MaximizeWindowButton</code>和<code class="fe ny nz oa np b">CloseWindowButton</code>。</li></ul><p id="4509" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，让我们使用提供的类定义按钮的颜色。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="a33e" class="nt lo iq np b be nu nv l nw nx">final defaultButtonColors = WindowButtonColors(<br/>    iconNormal: const Color(0xff454545),<br/>    mouseOver: const Color(0xff363636),<br/>    mouseDown: const Color(0xff363636),<br/>    iconMouseOver: const Color(0xff525252),<br/>    iconMouseDown: const Color(0xff525252));<br/><br/>final closeButtonColors = WindowButtonColors(<br/>    mouseOver: const Color(0xffd32f2f),<br/>    mouseDown: const Color(0xffb71c1c),<br/>    iconNormal: const Color(0xff454545),<br/>    iconMouseOver: Colors.white);</span></pre><p id="82e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以在一个类中定义我们的<code class="fe ny nz oa np b">Row</code>按钮。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="5f53" class="nt lo iq np b be nu nv l nw nx">class WindowButtons extends StatelessWidget {<br/>  const WindowButtons({Key? key}) : super(key: key);<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    return Row(<br/>      mainAxisSize: MainAxisSize.min,<br/>      children: [<br/>        MinimizeWindowButton(colors: defaultButtonColors),<br/>        MaximizeWindowButton(colors: defaultButtonColors),<br/>        CloseWindowButton(colors: closeButtonColors),<br/>      ],<br/>    );<br/>  }<br/>}</span></pre><p id="8c99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们定义一个小部件，它将基于平台有条件地对我们的小部件树做出一些决定。为了简单起见，我们将在Windows上重用当前的移动设备<code class="fe ny nz oa np b">AppBar</code>。这是我们的小部件将要做的事情:</p><ul class=""><li id="c984" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">将身体包裹在桌面上的<code class="fe ny nz oa np b">WindowBorder</code>中。</li><li id="9429" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">给<code class="fe ny nz oa np b">Scaffold</code>提供一个<code class="fe ny nz oa np b">AppBar</code>在手机上。</li><li id="1d0b" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">将机身包裹在桌面上的<code class="fe ny nz oa np b">Column</code>中，提供一个<code class="fe ny nz oa np b">WindowTitleBarBox</code>。</li><li id="90f4" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">将<code class="fe ny nz oa np b">AppBar</code>包装在一个<code class="fe ny nz oa np b">MoveWindow</code>小部件中，并将二者传递给<code class="fe ny nz oa np b">WindowTitleBarBox</code>。</li><li id="f1ff" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated"><code class="fe ny nz oa np b">MoveWindow</code>将定义双击时的操作。</li></ul><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="c0e8" class="nt lo iq np b be nu nv l nw nx">class ConditionalScaffold extends StatelessWidget {<br/>  const ConditionalScaffold({<br/>    Key? key,<br/>    required this.isMobile,<br/>    required this.appBar,<br/>    required this.child,<br/>  }) : super(key: key);<br/><br/>  final bool isMobile;<br/>  final PreferredSizeWidget appBar;<br/>  final Widget child;<br/><br/>  @override<br/>  Widget build(BuildContext context) {<br/>    if (isMobile) {<br/>      return Scaffold(<br/>        appBar: appBar,<br/>        body: child,<br/>      );<br/>    }<br/>    return Scaffold(<br/>      body: WindowBorder(<br/>        color: const Color(0xff494949),<br/>        width: 1,<br/>        child: Column(<br/>          crossAxisAlignment: CrossAxisAlignment.stretch,<br/>          children: [<br/>            WindowTitleBarBox(<br/>              child: MoveWindow(<br/>                onDoubleTap: appWindow.maximizeOrRestore,<br/>                child: appBar,<br/>              ),<br/>            ),<br/>            child,<br/>          ],<br/>        ),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="5d31" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ny nz oa np b">maximizeOrRestore</code>方法由<a class="ae mi" href="https://pub.dev/packages/bitsdojo_window" rel="noopener ugc nofollow" target="_blank"> bitsdojo_window </a>包中的<code class="fe ny nz oa np b">appWindow</code>提供。</p><p id="09a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在只缺一件东西了！让我们将按钮添加到窗口的右上角。为此，我们将把我们的<code class="fe ny nz oa np b">MoveWindow</code>包装在一个<code class="fe ny nz oa np b">Stack</code>中，并把我们的<code class="fe ny nz oa np b">WindowsButtons</code>放在它的上面，与右上方对齐。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="ee9a" class="nt lo iq np b be nu nv l nw nx">WindowTitleBarBox(<br/>  child: Stack(<br/>    children: [<br/>      MoveWindow(<br/>        onDoubleTap: appWindow.maximizeOrRestore,<br/>        child: appBar,<br/>      ),<br/>      const Align(<br/>        alignment: Alignment.topRight,<br/>        child: WindowButtons(),<br/>      ),<br/>    ],<br/>  ),<br/>),</span></pre><p id="4ac3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干得好！现在，我们的UI和窗口行为正是用户在Windows上使用我们的应用程序时所期望的。接下来，我们将看看如何监听窗口变化，以防我们需要做一些响应。</p><h2 id="7c22" class="mo lo iq bd lp mp mq dn lt mr ms dp lx la mt mu lz le mv mw mb li mx my md mz bi translated">处理窗口事件</h2><p id="90a5" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当应用程序被放到移动设备的后台时，Lights游戏循环没有太多意义。为了处理这些事件，我们混合<code class="fe ny nz oa np b">WidgetsBindingObserver</code>并监听<code class="fe ny nz oa np b">AppLifecycleState</code>的变化。当app为<code class="fe ny nz oa np b">paused</code>时，我停止游戏，显示主菜单。在桌面上，等同于窗口最小化。为了监听这些事件，我们可以使用<a class="ae mi" href="https://pub.dev/packages/window_manager" rel="noopener ugc nofollow" target="_blank"> window_manager </a>包。你的应用程序可能不需要监听窗口事件，但是这个包有很多功能，所以你可能还是想看看。</p><p id="7ec5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将<code class="fe ny nz oa np b">WindowListener</code>混合到与<code class="fe ny nz oa np b">WidgetsBindingObserver</code>相同的类中，并覆盖<code class="fe ny nz oa np b">onWindowMinimize</code>方法来执行与<code class="fe ny nz oa np b">didChangeAppLifecycleState</code>相同的逻辑。不要忘记在<code class="fe ny nz oa np b">initState</code>中添加监听器，并在<code class="fe ny nz oa np b">dispose</code>中删除它。我们也应该以<code class="fe ny nz oa np b">isMobile</code>为条件。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="a9a9" class="nt lo iq np b be nu nv l nw nx">@override<br/>  void initState() {<br/>    if (isMobile) {<br/>      WidgetsBinding.instance.addObserver(this);<br/>    } else {<br/>        windowManager.addListener(this);<br/>    }<br/>    super.initState();<br/>  }<br/><br/>  @override<br/>  void dispose() {<br/>    if (isMobile) {<br/>      WidgetsBinding.instance.removeObserver(this);<br/>    } else {<br/>      windowManager.removeListener(this);<br/>    }<br/>    super.dispose();<br/>  }</span></pre><p id="44ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">厉害！现在，我们的应用程序正式Windows就绪。现在开始包装！</p><h2 id="72da" class="mo lo iq bd lp mp mq dn lt mr ms dp lx la mt mu lz le mv mw mb li mx my md mz bi translated">打包和上传</h2><p id="d732" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">win32格式的Flutter构建用于Windows。Flutter一度还提供UWP版本，但由于微软几乎已经宣布了该格式的消亡，这一版本已经被关闭。如今，打包win32应用程序的最佳方式是将其打包成MSIX软件包。它使处理元数据比以前容易得多，并提供了一个安装程序。一旦您在商店上有了列表，并将其与您产品的正确配置打包在一起，它就可以上传到Microsoft商店进行分发。</p><p id="363b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">msix Dart包为我们处理了大量的流程，使事情变得更加简单。我们只需要通过我们的<code class="fe ny nz oa np b">pubspec.yaml</code>文件为它提供正确的配置。让我们来看看如果我们为微软商店之外的发行或测试进行<a class="ae mi" href="https://learn.microsoft.com/en-us/windows/msix/package/create-certificate-package-signing#create-a-self-signed-certificate" rel="noopener ugc nofollow" target="_blank">自签名</a>时的配置是什么样子的。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="ba34" class="nt lo iq np b be nu nv l nw nx">msix_config:<br/>  display_name: App Name<br/>  publisher_display_name: Publisher Name<br/>  logo_path: assets/icons/app_icon.png<br/>  certificate_path: path/to/cert/TEST.pfx<br/>  certificate_password: certPassword<br/>  capabilities: internetClient, location, microphone, webcam</span></pre><p id="f8b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当不发布到微软商店时，这里没有什么可担心的。如果您的证书创建正确，您就可以开始了。为了将您的应用程序安装到电脑上，必须事先在电脑上安装证书。在<code class="fe ny nz oa np b">capabilities</code>选项中，您可以声明您的应用程序在设备上需要的任何<a class="ae mi" href="https://learn.microsoft.com/en-us/windows/uwp/packaging/app-capability-declarations" rel="noopener ugc nofollow" target="_blank">功能</a>。</p><p id="4758" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们来看看为了在微软商店上发布，我们需要做些什么改变。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="1a16" class="nt lo iq np b be nu nv l nw nx">msix_config:<br/>  display_name: App Name<br/>  publisher_display_name: Publisher Name<br/>  family_name: 3626482PubName.AppName_uw93xa52ug<br/>  identity_name: 38092PubName.AppName<br/>  logo_path: assets/icons/app_icon.png<br/>  languages: en, es, de, fr, it, ja, ko, nl, sv, tr, uk<br/>  store: true<br/>  sign_msix: false<br/>  publisher: CN=S797AJDU-128S-AFOU-S8WJ-JFA8EH7AFBH2<br/>  capabilities: internetClient, location, microphone, webcam</span></pre><p id="81b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先要注意的是，我们已经不签app了。Windows应用商店会为我们解决这个问题。我们还必须告诉<code class="fe ny nz oa np b">msix</code>,我们正在打包以发布到商店。我们还列出了我们的应用程序支持在商店中列出的所有语言。</p><p id="74bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们包括<code class="fe ny nz oa np b">family_name</code>、<code class="fe ny nz oa np b">identity_name</code>和<code class="fe ny nz oa np b">publisher</code>。这些都是微软商店提供的价值，可以从<a class="ae mi" href="https://partner.microsoft.com/dashboard" rel="noopener ugc nofollow" target="_blank">合作伙伴中心</a>访问。您可以在应用/游戏概述的<em class="mh">产品标识</em>下找到它们。您还必须确保提供给<code class="fe ny nz oa np b">display_name</code>和<code class="fe ny nz oa np b">publisher_display_name</code>的值与微软商店中注册的值相匹配。</p><p id="5663" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您可以使用以下命令打包您的应用程序。</p><pre class="kg kh ki kj gt no np nq bn nr ns bi"><span id="0a0d" class="nt lo iq np b be nu nv l nw nx">flutter pub run msix:publish</span></pre><p id="400a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，您将拥有一个可以通过合作伙伴中心上传的<code class="fe ny nz oa np b">.msix</code>文件。只需开始一个新的提交，在商店上填写详细信息，并将<code class="fe ny nz oa np b">.msix</code>文件拖放到<em class="mh">包</em>页面。在1-3个工作日内，您的Flutter应用程序将向Windows用户提供！</p><h1 id="4e62" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="8584" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">Flutter允许我将我的游戏带到一个全新的平台，以响应一个用户的请求。如果我被迫为Windows原生重写整个应用程序，这肯定是不可行的。这就是颤动的力量。我希望这篇指南已经为你提供了用最少的努力把你自己的Flutter移动应用程序带到Windows上的知识。</p><p id="b218" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您对该流程有任何问题或意见，我很乐意收到您的来信。如果你觉得某个方面需要更深入的指导，请告诉我。这是为了展示我们如何快速、轻松地用Flutter将移动应用移植到Windows上，而不是一个详尽的指南。</p><p id="0f56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你觉得这篇文章有帮助，请拍几下让我知道。您可以关注我，了解我在Flutter以及其他软件开发和IT主题方面的工作。同时，看看我目前的<a class="ae mi" href="https://medium.com/@lp3/list/flutter-eaade608fb9a" rel="noopener">颤振文章</a>目录。感谢阅读！</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="44d2" class="ln lo iq bd lp lq oi ls lt lu oj lw lx jw ok jx lz jz ol ka mb kc om kd md me bi translated">分级编码</h1><p id="f9e9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="7b41" class="na nb iq kt b ku kv kx ky la nc le nd li ne lm nf ng nh ni bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="bd70" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">📰查看<a class="ae mi" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="a2b0" class="na nb iq kt b ku nj kx nk la nl le nm li nn lm nf ng nh ni bi translated">🔔关注我们:<a class="ae mi" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae mi" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mi" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="9ff0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">🚀👉<a class="ae mi" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>