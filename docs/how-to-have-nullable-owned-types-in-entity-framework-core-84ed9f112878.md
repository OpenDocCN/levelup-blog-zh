# 在实体框架核心中支持可空的自有类型

> 原文：<https://levelup.gitconnected.com/how-to-have-nullable-owned-types-in-entity-framework-core-84ed9f112878>

![](img/409545121c97a25449b8be64c0adda4c.png)

Anthony DELANOIX 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

让我为你画这幅画。有一天你在做一个项目。您刚刚实现了价值对象并开始工作，您感觉很好。真的很棒。你看着窗外，猪在飞！所以你只是测试了一小段代码，你在这里点击了这一行:

```
context.SaveChanges();
```

然后嘣！它坏了，猪从天上掉了下来，你的计算机向你抛出一个异常，说了下面的话:

> “<entity>实体与“# <other_column>”列共享表“【T5”)，但没有相同键值的该类型实体被标记为“已添加”。</other_column></entity>

什么！？你说什么在我的上一篇文章[使用实体框架核心的值对象](https://medium.com/@austin.davies0101/using-value-objects-with-entity-framework-core-5cead49dbf9c)中，我引用了关于实体框架核心(EF Core)中所拥有类型的限制的信息。记住这一部分:

> 不支持与所有者映射在同一表中的可选(即可为 null)拥有的类型(即使用表拆分)。这是因为映射是针对每个属性进行的，我们没有针对整个空复数值 a 的单独标记。

还记得我提到过，为我们的值对象创建一个基类将有助于在我们的实体中标记这些对象吗？是的，这将在本文中派上用场。

所以现在的情况是这样的。你有一个实体，它的一个或多个值对象完全是空的。没有提到地址。没有。好吗？实体框架(EF)不喜欢当你启用了表拆分并试图保存一个空值对象时(如果你不记得什么是表拆分，请阅读我的上一篇文章[这里](https://medium.com/@austin.davies0101/using-value-objects-with-entity-framework-core-5cead49dbf9c))。).那么有哪些解决方法呢？

*   通过调用禁用表拆分。实体配置中的 ToTable( <string tablename="">)。</string>
*   不要利用价值对象，吃亏，最终很惨。
*   继续阅读这篇文章。

第一种选择是迄今为止最容易和最快的解决办法，但是如果你像我一样，那么你的固执和可能的受虐狂。但是老实说，当您使用空值对象调用 SaveChanges()时，事情应该会像预期的那样工作。第二个选择并不是一个真正的选择，至少，我希望你没有认真考虑它。对吗？…

# 第三个选择——也就是完全令人敬畏的修正，让你看起来像一个神级开发人员，并让你得到你一直想要的加薪(也许)。

我们都知道反射是什么，它能做什么，至少我希望你知道，因为我们将使用它来解决我们的小问题。前提是:我们将在 DbContext 中覆盖 SaveChanges 方法，并扫描所有包含“ValueObject”类类型属性的实体，然后检查该属性是否为 null。如果该属性为空，则实例化派生类类型的新实例，并在调用 base 之前将其赋给上述属性。保存更改()。听起来很简单明了，是吧？太好了！我们开始吧。

# 它很大，是灰色的。

首先，我们来谈谈房间里的大象。我刚才所说的是否合理和恰当？毕竟反思慢！让我用“是的，这是明智和恰当的，当以正确的方式在你的实体上执行它时，没有反射是不慢的。”。这就是为什么你**可以**在保存时几乎没有性能损失的情况下完成这个修复。EF Core 的跟踪系统缓存其上下文中被跟踪的所有实体的属性信息。仔细想想，这是有道理的:EF 必须知道如何基于给定类型的配置来构造查询。

# 该去工作了。

所以让我们继续吧。我们需要在“DbContext”类中覆盖 SaveChanges()方法。如果同时使用 SaveChanges 和 SaveChangesAsync，则需要覆盖这两个方法，并确保这两个方法都执行代码，如下所示:

我知道我刚刚丢了一大块代码给你，所以让我们解开它。首先，就性能而言，传统的`for`循环远远优于其对应的`foreach`循环，数组比其他可枚举类型迭代更快——我们知道这一点。

1.  我们需要深入到变更跟踪器中，遍历我们跟踪的实体，并提取出所谓的引用条目。您可能会认出其他类型的条目——有些是其他条目的子类——比如导航或属性；这只是取决于你想要的粒度。对于我们来说，我们想要引用，根据我阅读屏幕的外行知识，这意味着类型已经被配置为拥有的类型，即，用 OwnsOne() Fluent API 方法配置的类型。这让我们更接近我们所寻找的，但还没有完全实现。记住，我们关心的是使用上一篇文章中的“ValueObject”类[创建的拥有类型。](https://medium.com/@austin.davies0101/using-value-objects-with-entity-framework-core-5cead49dbf9c)
2.  接下来，我们将遍历所有的引用类型，并寻找那些为空并且是我们的“ValueObject”类的子类的引用类型。我们如何做到后者？非常简单，EF 提供了一个元数据属性，它包含了所有缓存的属性信息，我们需要这些信息来实现我们的目标，即判断这个当前属性是否是“ValueObject”的子类。出于整洁的考虑，我实现了一个名为 IsValueObject()的私有 helper 方法来处理这个问题。
3.  接下来，如果我们确实发现当前条目是“ValueObject”的子类，并且它的当前值为 null。然后，我们需要实例化该派生类型的新实例，并将其分配给当前条目的当前值属性。这可能会变得很棘手，这取决于您想如何处理它，但是对我来说，我知道在我的派生类中将有一个公共或私有的无参数构造函数，所以我使用 GetConstructor()方法，提供必要的标志和类型参数来获得我所需要的。

一旦我可能或者可能没有需要调用的 ConstructorInfo，我最后检查我的 ctorInfo 是否为 null，如果不是，那么我调用不带参数的 invoke()并将实例分配给当前条目的 CurrentValue 属性。

# 结论

现在你有了一个工作示例，请随意改进它，并让我知道你想出了什么。在此期间，您现在可以保存自己拥有的类型，而不用担心它是 null，也不用从本文开始就抛出那个难看的错误。