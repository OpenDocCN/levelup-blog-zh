<html>
<head>
<title>How to build Github’s file search functionality with Svelte + Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Svelte + Typescript构建Github的文件搜索功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-githubs-file-search-functionality-with-svelte-typescript-62ad415742aa?source=collection_archive---------11-----------------------#2020-08-06">https://levelup.gitconnected.com/how-to-build-githubs-file-search-functionality-with-svelte-typescript-62ad415742aa?source=collection_archive---------11-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7966821aa236f9bb2f5fea088e457d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MZ8JtD84lWfAUoR_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马库斯·温克勒在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9967" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几天前，我偶然看到了这个教程，它解释了如何用React构建GitHub文件搜索功能。如果你不知道那是什么，试着去任何一个<a class="ae kc" href="https://github.com/skflowne/github-file-search-svelte-ts" rel="noopener ugc nofollow" target="_blank"> github repo </a>然后按“t”开始文件搜索。</p><p id="4546" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个很好的训练组件，不太简单，也不太复杂。在这里，我将向您展示如何用Svelte + Typescript而不是React来构建它。</p><p id="6f15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们将要构建的应用程序的<a class="ae kc" href="https://github-file-search-svelte-ts.web.app/" rel="noopener ugc nofollow" target="_blank"> live版本。按“t”尝试文件搜索。</a></p><h1 id="912f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">项目设置</h1><p id="9fe7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">两个选项:</p><p id="06c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想学习如何手动操作，请关注我的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-to-setup-svelte-typescript-tailwindcss-scss-bebdca7b2a0a">文章。</a></p><p id="ef93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您只想立即开始构建组件，请遵循下面的说明</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e5f9" class="mn lc iq mj b gy mo mp l mq mr">npx degit <a class="ae kc" href="https://github.com/skflowne/svelte-ts-scss-tailwind-template" rel="noopener ugc nofollow" target="_blank">https://github.com/skflowne/svelte-ts-scss-tailwind-template</a> github-file-search-svelte<br/>cd github-file-search-svelte<br/>yarn</span></pre><p id="ac99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用<code class="fe ms mt mu mj b">yarn</code>作为包管理器，但是如果你愿意，你也可以使用<code class="fe ms mt mu mj b">npm</code></p><p id="75cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您现在可以运行<code class="fe ms mt mu mj b">yarn dev</code>来运行开发服务器</p><h1 id="76aa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">API数据</h1><p id="ca4f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们需要一些数据来渲染我们的组件，我使用的数据与最初的【React教程相同。</p><p id="18ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/skflowne/github-file-search-svelte-ts/blob/master/src/api/index.js" rel="noopener ugc nofollow" target="_blank">从这里下载API数据文件</a></p><p id="4bf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在应用程序的<code class="fe ms mt mu mj b">src</code>文件夹中创建一个新的<code class="fe ms mt mu mj b">api</code>文件夹，并将文件内容复制到<code class="fe ms mt mu mj b">index.js</code></p><p id="fd9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，在本文的其余部分，每次我告诉您创建一个新文件夹时，它都将位于<code class="fe ms mt mu mj b">src</code>文件夹中</p><p id="7c6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的数据看起来是这样的:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="24b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到我们的文件有一个<code class="fe ms mt mu mj b">id</code>，类型可以是<code class="fe ms mt mu mj b">file</code>或<code class="fe ms mt mu mj b">folder</code>，一个<code class="fe ms mt mu mj b">name</code>，一个提交<code class="fe ms mt mu mj b">comment</code>和文件的最后一个<code class="fe ms mt mu mj b">modified_time</code></p><p id="9d2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建一个名为<code class="fe ms mt mu mj b">File</code>的<code class="fe ms mt mu mj b">interface</code>来表示我们的数据</p><p id="6d7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的<code class="fe ms mt mu mj b">src</code>文件夹中，创建一个<code class="fe ms mt mu mj b">interfaces</code>文件夹和一个新文件<code class="fe ms mt mu mj b">file.interface.ts</code></p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a8d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有一个自定义的Typescript类型来表示我们的文件。</p><p id="8c06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能会想，为什么我们不为我们的<code class="fe ms mt mu mj b">type</code>属性使用一个<code class="fe ms mt mu mj b">string</code>类型呢？</p><p id="b7a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们只想接受<code class="fe ms mt mu mj b">file</code>或<code class="fe ms mt mu mj b">folder</code>作为该属性的值，这将允许Typescript在我们使用无效值时警告我们。</p><p id="aefb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Typescript还将提供带有有效值的自动完成功能，这是使用Typescript的另一个好处。</p><p id="e78d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这提供了一种简单的方法，可以直接在我们的IDE中知道我们的<code class="fe ms mt mu mj b">File</code>数据结构应该是什么样子。这将有助于我们项目中的其他人或我们未来的自己，他们可能没有我们现在的自己记得那么多。</p><h1 id="d40d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过一个苗条的商店访问我们的文件</h1><p id="dd64" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在我们在<code class="fe ms mt mu mj b">api/index.js</code>中有了数据，在<code class="fe ms mt mu mj b">interfaces/file.interface.ts</code>中有了自定义类型，让我们创建一个在应用程序中使用的瘦商店。</p><p id="7c32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这应该是来自API的数据，我们永远不会写入它，因此我们将使用来自<code class="fe ms mt mu mj b">svelte/store</code>的<code class="fe ms mt mu mj b">readable</code>创建一个只读存储</p><p id="90b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新建一个文件夹<code class="fe ms mt mu mj b">store</code>并在里面新建一个<code class="fe ms mt mu mj b">files.ts</code>文件。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6955" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe ms mt mu mj b">readable</code>是<code class="fe ms mt mu mj b">readable&lt;T&gt;</code>的形式，它允许我们指定商店的类型。</p><p id="d50c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有在<code class="fe ms mt mu mj b">files</code>变量上设置类型，因为<code class="fe ms mt mu mj b">files</code>不是<code class="fe ms mt mu mj b">File[]</code>，它是一个包含<code class="fe ms mt mu mj b">File[]</code>的存储，如果你在VSCode中将鼠标悬停在它上面，你会看到它的实际类型是<code class="fe ms mt mu mj b">Readable&lt;File[]&gt;</code>，一个包含<code class="fe ms mt mu mj b">File</code>数组的可读存储。</p><p id="61ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">readable</code>有两个参数:<code class="fe ms mt mu mj b">start</code>和一个setter函数<code class="fe ms mt mu mj b">(set)=&gt; void</code></p><p id="2756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们提供了一个空数组作为<code class="fe ms mt mu mj b">start</code>，并提供了setter函数，该函数简单地将我们的存储值设置为包含在我们的<code class="fe ms mt mu mj b">/api/index.js</code>文件中的数据</p><p id="a660" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这个存储不是很有用，因为我们使用的是静态数据，但是请记住，您可以使用setter函数进行API调用，或者设置对Firebase集合的订阅。</p><p id="af70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将我们所有的数据逻辑存储在存储中，这也有助于分离我们的关注点，例如，我们不必将<code class="fe ms mt mu mj b">App.svelte</code>与我们的<code class="fe ms mt mu mj b">File</code>类型的导入混在一起。</p><p id="5dab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们实现实际的文件搜索时，我们将对存储做更多有用的事情。</p><p id="c117" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将以一种“自由”的方式使用商店，展示它们如何让我们的生活变得更轻松。但是，在构建这样一个应该能够独立存在的组件时，应该避免依赖于子组件中的存储。</p><p id="5f38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理想情况下，<code class="fe ms mt mu mj b">file-search</code>中的所有东西都应该组成一个组件，您可以通过props将它可能需要的任何数据传递给它，这样，如果您以后决定在另一个项目中使用它，它就不会抱怨商店不存在。</p><p id="aa8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个选择可能是将商店作为组件的一部分，这样您仍然可以享受好处，而不会有未满足的依赖性。</p><p id="d88d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这是另一个时间的讨论，我不会在这里打扰它，只是要记住，这里显示的组织不是最好的可重用性。</p><h1 id="9a92" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构建我们的FileItem组件</h1><p id="7bbe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们将我们的<code class="fe ms mt mu mj b">files</code>存储导入到我们的根<code class="fe ms mt mu mj b">App.svelte</code>组件中，并开始构建我们的第一个组件<code class="fe ms mt mu mj b">FileItem.svelte</code></p><p id="fe7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，您可以通过完全删除style标签来清理<code class="fe ms mt mu mj b">App.svelte</code>，因为由于TailwindCSS，我们不再需要它，您也可以删除我们的<code class="fe ms mt mu mj b">&lt;main&gt;</code>标签中的HTML。</p><p id="8d42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个新的<code class="fe ms mt mu mj b">components</code>文件夹，在里面创建一个<code class="fe ms mt mu mj b">file-search</code>文件夹来保存所有与文件搜索相关的组件。</p><p id="d851" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那里，创建我们的第一个组件<code class="fe ms mt mu mj b">FileItem.svelte</code></p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9a4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意我们正在做<code class="fe ms mt mu mj b">import type</code>来导入我们的<code class="fe ms mt mu mj b">File</code>接口，因为如果你只是做<code class="fe ms mt mu mj b">import</code>你会得到一个错误，这是必需的，因为Svelte + Typescript默认配置是使用<code class="fe ms mt mu mj b">importsNotUsedAsValues</code>被设置为“错误”，你可以<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html" rel="noopener ugc nofollow" target="_blank">在这里阅读关于这个语法的更多信息</a>。</p><p id="30da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不确定为什么配置是这样设置的，你可以通过添加一个新的<code class="fe ms mt mu mj b">compilerOptions</code>对象并将其<code class="fe ms mt mu mj b">importsNotUsedAsValues</code>设置为<code class="fe ms mt mu mj b">preserve</code>或<code class="fe ms mt mu mj b">remove</code>来覆盖它。两者似乎都运行良好。如果有人知道为什么要这样设置，请在评论中告诉我。我的最佳猜测是，只有<code class="fe ms mt mu mj b">type</code>的导入将被完全删除，因此可能会避免不必要的导入。但是我也猜想将配置设置为remove会有相同的效果，同时仍然允许您使用普通的<code class="fe ms mt mu mj b">import</code>语法。</p><p id="5f5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，因为我不知道为什么要这样设置，所以我将保持配置不变。</p><p id="33bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意在我们的脚本标签上设置的<code class="fe ms mt mu mj b">lang="ts"</code>属性，这是我们告诉编译器把我们的代码当作Typescript的方式，如果你忘记了，你会得到一个关于任何Typescript特定语法的错误。</p><p id="d637" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还用关键字<code class="fe ms mt mu mj b">export</code>定义了一个<code class="fe ms mt mu mj b">File</code>类型的组件道具。这就是你告诉斯维特期待一个外部支持的方式。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cd14" class="mn lc iq mj b gy mo mp l mq mr">export let myProp: Type</span></pre><p id="bb70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新我们的<code class="fe ms mt mu mj b">App.svelte</code>来显示第一个文件</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e5e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入我们的<code class="fe ms mt mu mj b">FileItem.svelte</code>组件和<code class="fe ms mt mu mj b">files</code>存储</p><p id="9354" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们呈现一个<code class="fe ms mt mu mj b">FileItem</code>，通过使用<code class="fe ms mt mu mj b">$files</code>访问存储中包含的值，我们将第一个文件传递给它。</p><p id="aa7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在商店前面添加特殊的<code class="fe ms mt mu mj b">$</code>告诉Svelte我们想要订阅商店并访问里面的值。</p><p id="d755" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有前面的<code class="fe ms mt mu mj b">$</code>,您访问的是商店本身，而<code class="fe ms mt mu mj b">$</code>是告诉Svelte设置一个对该商店的自动订阅并获取实际价值。</p><p id="eb1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这相当于做</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="05da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，上面的代码是一种简化，通常您还应该在组件卸载时手动取消订阅。</p><p id="0712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们显示文件的其余信息，根据我们的<code class="fe ms mt mu mj b">File</code>的<code class="fe ms mt mu mj b">type</code>显示文件图标或文件夹图标，并用TailwindCSS设置组件的样式。</p><p id="991d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<code class="fe ms mt mu mj b">svelte-awesome</code>来显示fontawesome图标，使用<code class="fe ms mt mu mj b">date-fns</code>来显示我们的<code class="fe ms mt mu mj b">modified_time</code>作为距离，比如“一个月前”。</p><p id="7cc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最初的教程中，他们用的是<code class="fe ms mt mu mj b">moment</code>，我用的是<code class="fe ms mt mu mj b">date-fns</code>，因为它是一个更轻的包，并且有相似的特性。</p><p id="d262" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将快速比较一下React + Moment.js版本的包大小。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5fdc" class="mn lc iq mj b gy mo mp l mq mr">yarn add -D svelte-awesome <a class="ae kc" href="http://twitter.com/fortawesome/free-regular-svg-icons" rel="noopener ugc nofollow" target="_blank">@fortawesome/free-regular-svg-icons</a> date-fns</span></pre><p id="edd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们使用<code class="fe ms mt mu mj b">-D</code>是因为Svelte是一个编译器，它会在我们的包中包含它需要的代码，我们不需要它们作为<code class="fe ms mt mu mj b">dependencies</code></p><p id="1123" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新我们的组件，如下所示</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4e66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用TailwindCSS的类来设计一切，而不需要编写任何CSS。如果你想知道这些类是做什么的，可以去看看TailwindCSS的文档。</p><p id="8ea1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从<code class="fe ms mt mu mj b">svelte-awesome</code>导入<code class="fe ms mt mu mj b">Icon</code>，这将允许我们通过将它们传递到<code class="fe ms mt mu mj b">data</code>属性来显示由<code class="fe ms mt mu mj b">@fortawesome/free-regular-svg-icons</code>提供的字体图标。</p><p id="9787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将在IDE中得到一个关于<code class="fe ms mt mu mj b">data</code>属性的错误，因为<code class="fe ms mt mu mj b">svelte-awesome</code>没有Typescript类型定义，但是它仍然可以工作。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="878d" class="mn lc iq mj b gy mo mp l mq mr">const distance = formatDistanceToNow(parseJSON(file.modified_time))</span></pre><p id="c9da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们计算现在和我们的<code class="fe ms mt mu mj b">modified_time</code>之间的时间距离，首先用<code class="fe ms mt mu mj b">parseJSON</code>转换我们的JSON日期，并将结果<code class="fe ms mt mu mj b">Date</code>传递给<code class="fe ms mt mu mj b">formatDistanceFromNow</code>，这两个方法都由<code class="fe ms mt mu mj b">date-fns</code>提供</p><h1 id="651c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建文件列表组件</h1><p id="a78f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在我们的<code class="fe ms mt mu mj b">components/file-search</code>中创建一个名为<code class="fe ms mt mu mj b">FileList.svelte</code>的新文件</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5b14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义了一个类型为<code class="fe ms mt mu mj b">File[]</code>的<code class="fe ms mt mu mj b">files</code>道具</p><p id="b2c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当这个数组不为空时，我们用一个<code class="fe ms mt mu mj b">{#each as file (file.id)}</code>块循环遍历文件，这个块允许我们呈现一个<code class="fe ms mt mu mj b">FileItem</code>组件，我们将文件作为道具传递给这个组件。<code class="fe ms mt mu mj b">{file}</code>是<code class="fe ms mt mu mj b">file={file}</code>的简称。</p><p id="c066" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">(file.id)</code>负责为我们的组件提供一个惟一的键，就像你在Vue.js中使用React或<code class="fe ms mt mu mj b">key="file.id"</code>一样</p><p id="b348" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当数组为空时，我们显示“没有匹配文件”的消息。</p><p id="b439" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">修改<code class="fe ms mt mu mj b">App.svelte</code>以显示<code class="fe ms mt mu mj b">FileList</code>组件</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="5bfb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用苗条商店实现文件搜索</h1><p id="37b0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们将使用存储来跟踪用户在搜索输入中输入的内容，并从用户输入和我们的文件数据中获取搜索结果。</p><p id="1604" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe ms mt mu mj b">store</code>文件夹中创建一个<code class="fe ms mt mu mj b">fileSearch.ts</code>文件</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="225e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们简单地创建一个可写的存储，指定它将持有一个<code class="fe ms mt mu mj b">string</code>，这将是我们的用户的输入，并将其初始化为一个空字符串。</p><p id="f9da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe ms mt mu mj b">store</code>文件夹中为我们的搜索结果创建另一个名为<code class="fe ms mt mu mj b">fileSearchResults.ts</code>的文件。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6dbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当我们的<code class="fe ms mt mu mj b">fileSearch</code>商店或<code class="fe ms mt mu mj b">files</code>商店更新时，我们使用一个派生商店来重新计算我们的搜索结果。</p><p id="88cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">derived</code>接受一个存储或存储数组和一个回调函数。</p><p id="e1a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调函数将包含一个存储值数组，并在其中一个值发生变化时运行。</p><p id="65a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们的文件永远不会改变，因为我们从文件中读取静态数据，因此，每次我们的<code class="fe ms mt mu mj b">fileSearch</code>的存储更新时，回调都会被调用。</p><p id="7a03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，想象你的文件不是静态的，应用程序允许用户添加新文件。如果您使用Firebase来设置对一个<code class="fe ms mt mu mj b">files</code>集合的订阅，每当另一个用户添加一个新文件时，这将触发订阅，更新我们的<code class="fe ms mt mu mj b">files</code>存储，并重新运行我们的回调，为当前用户更新我们的搜索结果。这将允许我们的应用程序的状态总是保持一致，即使当其他用户进行更改时，也不需要刷新页面。</p><p id="5b17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在文件搜索模式下，我们希望只显示文件，首先总是过滤我们的<code class="fe ms mt mu mj b">files</code>数组，只返回带有<code class="fe ms mt mu mj b">type</code>“file”的文件。</p><p id="03bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查我们的搜索是否为空，在这种情况下，我们希望返回所有内容，否则，我们希望只返回匹配的结果。</p><p id="a2c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们注意使文件名和搜索输入都是小写的，以允许不区分大小写的搜索。否则，我们可能正在搜索<code class="fe ms mt mu mj b">readme</code>，而名为<code class="fe ms mt mu mj b">README.md</code>的文件将不会匹配。然后，只有当文件的<code class="fe ms mt mu mj b">name</code>包含我们的<code class="fe ms mt mu mj b">search</code>时，我们才返回该文件。</p><h1 id="3fbb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">文件搜索组件</h1><p id="e0ae" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在<code class="fe ms mt mu mj b">components/file-search</code>中创建一个<code class="fe ms mt mu mj b">FileSearch</code>组件</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5f53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入我们的<code class="fe ms mt mu mj b">fileSearch</code>存储，并用<code class="fe ms mt mu mj b">bind:value={$fileSearch}</code>设置我们输入值的双向绑定。</p><p id="b230" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们输入的值将总是被设置为我们商店的值，无论用户输入什么，我们商店的值都会自动更新。</p><p id="18db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们绑定到<code class="fe ms mt mu mj b">$fileSearch</code>而不是<code class="fe ms mt mu mj b">fileSearch</code>，因为我们想要绑定到商店的价值，而不是商店本身。</p><p id="c486" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我们的输入元素在组件出现时立即被聚焦，我们首先创建一个<code class="fe ms mt mu mj b">input</code>变量来保存对我们的输入元素的引用，并在我们的输入上使用<code class="fe ms mt mu mj b">bind:this={input}</code>来将它绑定到我们的变量。你可以把它想成“把这个元素绑定到<code class="fe ms mt mu mj b">input</code>变量上”。</p><p id="05e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当<code class="fe ms mt mu mj b">input</code>改变和存在时，我们使用Svelte的反应性陈述来集中我们的输入。一旦我们的input元素真正呈现出来，就会发生这种情况。</p><p id="11f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe ms mt mu mj b">$:</code>右侧的变量发生变化时，Svelte的反应语句将会更新。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="15d4" class="mn lc iq mj b gy mo mp l mq mr">$: if(input){<br/>   // ...runs when input changes and exists<br/>}</span></pre><p id="7bbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们进入搜索模式时，我们的组件将呈现，设置输入到现在存在的DOM中的实际<code class="fe ms mt mu mj b">HTMLElement</code>，这将触发我们的焦点代码。</p><h1 id="2ce8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调试失败错误</h1><p id="2caf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有时，汇总将无法解析您新创建的文件并出错:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bd9a" class="mn lc iq mj b gy mo mp l mq mr">Debug Failure. False expression: Expected fileName to be present in command line</span></pre><p id="831e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你得到这个，只需停止你的开发服务器，然后用<code class="fe ms mt mu mj b">yarn dev</code>重启它</p><p id="487c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果一些更改在您的浏览器中似乎没有生效，您可能需要再次保存您正在处理的文件或再次保存<code class="fe ms mt mu mj b">App.svelte</code>。</p><p id="c53e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种情况在我身上发生过几次，不确定是什么原因造成的。</p><h1 id="1530" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置键盘事件监听器以触发文件搜索模式</h1><p id="e59e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当用户按下<code class="fe ms mt mu mj b">t</code>键时，我们将进入文件搜索模式，当用户按下<code class="fe ms mt mu mj b">Escape</code>键时，我们将允许他们退出。</p><p id="af4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">修改<code class="fe ms mt mu mj b">App.svelte</code></p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6b08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">onMount</code>生命周期方法，当我们的组件第一次挂载时，我们会被调用一次。</p><p id="b4d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe ms mt mu mj b">keyup</code>事件上设置我们的事件监听器，并将其传递给我们的事件处理程序，它将负责检查哪个键被按下，并相应地设置搜索模式状态。</p><p id="19ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是<code class="fe ms mt mu mj b">t</code>或<code class="fe ms mt mu mj b">T</code>，我们通过将<code class="fe ms mt mu mj b">searching</code>设置为<code class="fe ms mt mu mj b">true</code>进入搜索模式，如果是<code class="fe ms mt mu mj b">Escape</code>，我们将其设置为<code class="fe ms mt mu mj b">false</code>退出搜索模式。</p><p id="6be8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们更新模板，只在<code class="fe ms mt mu mj b">searching</code>和<code class="fe ms mt mu mj b">{#if searching}</code>在一起时才呈现我们的文件搜索组件</p><p id="2689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以返回一个清理函数，在这种情况下，我们使用它来确保当我们的组件被卸载时，我们也删除了我们的事件监听器。</p><p id="19c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，<code class="fe ms mt mu mj b">App</code>永远不会被卸载，除非我们关闭选项卡。</p><p id="a62b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，想象一下，如果使用<code class="fe ms mt mu mj b">onMount</code>注册事件监听器的组件是元素可以改变的列表的一部分。</p><p id="7b7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当列表更新时，它所呈现的组件将会改变，这意味着新的组件将会被挂载，而那些不再需要的组件将会被卸载。</p><p id="c98e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次，新的事件侦听器将在装载时注册，如果您进行了清理，旧的事件侦听器将在卸载组件时被删除。</p><p id="964b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您没有清理您的事件侦听器，那么每次安装新组件时，都会添加新的事件侦听器，而不会删除现在不需要的旧事件侦听器。</p><p id="0c6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会造成内存泄漏，因为每次我们得到一个<code class="fe ms mt mu mj b">keyup</code>事件时，所有注册的监听器都会运行，即使注册它们的组件已经不存在。</p><p id="f197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从那以后，你的应用程序的性能严重下降只是时间问题。所以别忘了打扫卫生！</p><h1 id="6a54" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">显示搜索结果</h1><p id="2ad1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">现在，无论如何，我们总是显示完整的文件列表。我们需要改变这一点，以便当我们搜索时，我们显示我们的<code class="fe ms mt mu mj b">fileSearchResults</code>，否则显示完整的列表。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7272" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们的搜索结果已经从通过我们的<code class="fe ms mt mu mj b">fileSearchResults</code>存储的搜索输入中获得，所以当我们处于文件搜索模式时，我们可以简单地将完整列表替换为<code class="fe ms mt mu mj b">fileSearchResults</code>存储的值。</p><p id="aa9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在搜索可以工作了！</p><h1 id="675c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于卸载组件时的清理</h1><p id="e6bf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这一部分只是为了演示，如果你想知道不清理会发生什么。请在尝试之后删除下面的代码。</p><p id="2553" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将这段代码添加到<code class="fe ms mt mu mj b">FileItem.svelte</code>中，查看不清理事件侦听器的行为</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7a38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打开devtools控制台，用<code class="fe ms mt mu mj b">t</code>开始搜索</p><p id="43a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在搜索中键入一些内容并删除它，以更新我们的列表并安装/卸载组件。</p><p id="7d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重复几次，然后清空你的控制台并按键。</p><p id="8788" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将看到一个keyup事件现在可以触发比我们拥有的组件更多的回调调用。这很快就达到了一个点，一个<code class="fe ms mt mu mj b">keyup</code>事件触发了数百个回调调用，尽管我们从来没有超过13个<code class="fe ms mt mu mj b">FileItem</code>组件。</p><p id="10e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在添加清理代码，并重试上述过程</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="77a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不再打无用的电话。请记住，事件侦听器不是唯一需要清理的东西，商店订阅可能是另一个例子。</p><p id="c45a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Svelte商店的<code class="fe ms mt mu mj b">$</code>语法的好处在于它还可以自动处理商店的退订。</p><h1 id="0671" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">添加搜索词高亮显示</h1><p id="8e7b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以修改<code class="fe ms mt mu mj b">fileSearchResults</code>来返回带有匹配搜索词的HTML标记的文件名。</p><p id="c536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过在<code class="fe ms mt mu mj b">&lt;mark&gt;&lt;/mark&gt;</code>标签之间包装搜索词来做到这一点</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0a4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，当我们的搜索不为空时，我们创建与我们的<code class="fe ms mt mu mj b">$fileSearch</code>术语匹配的<code class="fe ms mt mu mj b">Regexp</code>。我们将<code class="fe ms mt mu mj b">gi</code>作为第二个参数传递给<code class="fe ms mt mu mj b">Regexp</code>，这些标志将使我们的<code class="fe ms mt mu mj b">Regexp</code>全局匹配<code class="fe ms mt mu mj b">g</code>，并且不区分大小写<code class="fe ms mt mu mj b">i</code></p><p id="79a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的过滤器返回我们的搜索结果之后，我们<code class="fe ms mt mu mj b">map</code>遍历每个结果，并返回我们的原始文件，但除了一个新的名称，我们的搜索词现在将被包装在<code class="fe ms mt mu mj b">&lt;mark&gt;&lt;/mark&gt;</code>标签之间。</p><p id="91e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，搜索“readme”会将文件名<code class="fe ms mt mu mj b">README.md</code>替换为<code class="fe ms mt mu mj b">&lt;mark&gt;README&lt;/mark&gt;.md</code></p><p id="eeb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你现在尝试这样做，你会看到没有高亮显示，只有一堆<mark>标签在我们的文件名里面。</mark></p><p id="c3b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为Svelte和大多数前端框架一样，默认情况下会对HTML标记进行转义。</p><p id="a34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要修改我们的<code class="fe ms mt mu mj b">FileItem</code>组件来将我们的<code class="fe ms mt mu mj b">file.name</code>呈现为HTML，因为它现在可能包含HTML标记。</p><p id="bf8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Svelte中，这是通过<code class="fe ms mt mu mj b">@html</code>指令完成的</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f376" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了高亮显示，因为Svelte知道它需要将<code class="fe ms mt mu mj b">file.name</code>呈现为HTML。</p><h1 id="3c17" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">添加键盘导航</h1><p id="08db" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，让我们添加一条漂亮的消息，一旦进入搜索模式，它将显示可用的键盘控件。</p><p id="1bec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mj b">components/file-search</code>内创建<code class="fe ms mt mu mj b">InfoMessage.svelte</code></p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7758" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mj b">App.svelte</code>中导入它，这样它就会显示在我们搜索的顶部</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6019" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用箭头键来实现导航，我们将使用一个存储来跟踪当前选择的文件索引。</p><p id="c004" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先创建一个新的商店<code class="fe ms mt mu mj b">fileIndex.ts</code></p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e637" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单的可写存储将我们的索引保存为一个<code class="fe ms mt mu mj b">number</code>，我们将其初始化为0，因此它指向列表的第一个文件。</p><p id="fbdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在为<code class="fe ms mt mu mj b">App.svelte</code>中的箭头键添加监听器</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8b49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入我们的<code class="fe ms mt mu mj b">fileIndex</code>存储，这样我们可以在我们的监听器中更新它。</p><p id="fc6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了<code class="fe ms mt mu mj b">handleKeyDown</code>监听器，并将其注册到关于<code class="fe ms mt mu mj b">keydown</code>事件的文档中。</p><p id="b99c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有使用<code class="fe ms mt mu mj b">keyup</code>,这样你就不必松开按键继续移动。<code class="fe ms mt mu mj b">keydown</code>只要按键就会开火。</p><p id="8806" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们得到我们的<code class="fe ms mt mu mj b">keydown</code>事件时，<code class="fe ms mt mu mj b">handleKeyDown</code>检查被按下的键是<code class="fe ms mt mu mj b">ArrowUp</code>还是<code class="fe ms mt mu mj b">ArrowDown</code>，并相应地更新<code class="fe ms mt mu mj b">fileIndex</code>存储。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d90c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mj b">ArrowDown</code>上，我们增加我们的索引并使用模<code class="fe ms mt mu mj b">%</code>操作符，这样当我们到达搜索结果的长度时，我们将我们的索引重置为0，因此当我们到达最后一个文件并按下时，我们返回到列表的顶部。</p><p id="78d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对<code class="fe ms mt mu mj b">ArrowUp</code>做同样的事情，检查我们是否得到一个负值，然后将我们的索引重置为结果中的最后一个文件。</p><p id="4940" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，导航将无缝地循环，我们将不会超出界限错误的索引。</p><p id="2a18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们现在也将<code class="fe ms mt mu mj b">searching</code>作为道具传递给<code class="fe ms mt mu mj b">FileList</code>，因为我们只想在搜索模式下在文件间导航。</p><p id="ec69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们修改我们的<code class="fe ms mt mu mj b">FileList</code>来接受<code class="fe ms mt mu mj b">searching</code>属性，并将<code class="fe ms mt mu mj b">active</code>属性传递给我们的<code class="fe ms mt mu mj b">FileItem </code>组件。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入我们的<code class="fe ms mt mu mj b">fileIndex</code>存储，这样我们就可以读取它的值，并将一个<code class="fe ms mt mu mj b">index</code>参数添加到我们的<code class="fe ms mt mu mj b">{#each file as file, index (file.id)}</code>块中。</p><p id="3780" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们的<code class="fe ms mt mu mj b">fileIndex</code>等于当前的<code class="fe ms mt mu mj b">index</code>并且我们处于搜索模式时，我们传递一个新的<code class="fe ms mt mu mj b">active</code>道具给<code class="fe ms mt mu mj b">FileItem</code>也就是<code class="fe ms mt mu mj b">true</code>，由新的<code class="fe ms mt mu mj b">searching</code>道具给出。</p><p id="cf27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们用这个道具给我们选中的<code class="fe ms mt mu mj b">FileItem</code>应用一个浅蓝色的背景</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a88e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们添加了<code class="fe ms mt mu mj b">active</code>作为道具，并使用<code class="fe ms mt mu mj b">class:className={condition}</code>语法来应用一个条件类，这个类只有在<code class="fe ms mt mu mj b">condition</code>为真时才会被添加。</p><p id="97a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，这看起来像这个<code class="fe ms mt mu mj b">class:bg-blue-200={active}</code></p><p id="b36d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在箭头键导航工程！</p><p id="5cd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有一件小事，如果你搜索什么，然后导航，然后改变搜索，我们的索引不会重置为0。</p><p id="f462" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要解决这个问题，只要修改我们的<code class="fe ms mt mu mj b">fileSearchResults</code>存储，每当搜索改变时就重置<code class="fe ms mt mu mj b">fileIndex</code></p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="47a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经导入了我们的<code class="fe ms mt mu mj b">fileIndex</code>商店并添加了<code class="fe ms mt mu mj b">fileIndex.set(0)</code>，因为每次<code class="fe ms mt mu mj b">$fileSearch</code>或<code class="fe ms mt mu mj b">$files</code>改变时都会运行。</p><h1 id="d2b1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更新postcss配置，使我们的图标不会在生产中消失</h1><p id="1945" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果你现在就开始生产，你会注意到当你访问应用程序时，图标不再出现。</p><p id="0f36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们正在使用<code class="fe ms mt mu mj b">purgecss</code>从CSS包中移除未使用的类。</p><p id="a76b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，<code class="fe ms mt mu mj b">svelte-awesome</code>生成了一个<code class="fe ms mt mu mj b">fa-icon</code>类，它被<code class="fe ms mt mu mj b">purgecss</code>从我们的产品包中移除，因为它没有出现在我们的代码中。</p><p id="035f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要将这个类列入白名单，这样它就不会从我们的CSS包中删除</p><p id="a6b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mj b">postcss.config.js</code>中，你会看到一个只包含<code class="fe ms mt mu mj b">/svelte/</code>的<code class="fe ms mt mu mj b">whitelistPatterns</code>数组，你也需要在那里添加<code class="fe ms mt mu mj b">/fa-icon/</code>。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="9290" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将包大小和加载时间与React + Moment.js版本进行比较</h1><p id="d504" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我想强调的是，这种比较可能并不能说明苗条和反应之间的差异。</p><p id="5057" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们使用的<code class="fe ms mt mu mj b">date-fns</code>比<code class="fe ms mt mu mj b">moment</code>轻3倍。所以不清楚有多少是由于这种差异，有多少是由于苗条/反应差异。</p><p id="c818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我对我们的应用程序做了一些修改，因为我们没有使用<code class="fe ms mt mu mj b">global.css</code>文件，我删除了它并移除了<code class="fe ms mt mu mj b">public.html</code>中的导入</p><p id="8f18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我添加了一个<code class="fe ms mt mu mj b">Header</code>组件，只显示“Github文件搜索”来更精确地匹配React应用程序。</p><p id="e872" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将使用devtools的网络选项卡，选中“禁用缓存”和匿名模式来确保扩展不会影响任何东西。</p><p id="4779" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从包的大小开始</p><p id="7f2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React版本提供了两个javascript文件，一个主javascript文件(1.9 kB)和一个块(58.7 kB)，一个主CSS文件(878 B)和HTML文件(1.1 kB)，总共62.5 kB</p><p id="93ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条版提供一个javascript文件(12.3 kB)，一个CSS文件(1.3 kB)和一个HTML文件(343 B)，总共大约14 kB</p><p id="4919" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们的超薄应用程序减少了48.5 kB，总重量减轻了77.6%</p><p id="62a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看它是如何影响加载时间的</p><p id="32fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我通过网络选项卡的负载值对每个应用程序采取了10项措施，我还删除了异常值，因为当托管平台需要比平时更多的时间来响应时会出现异常值。</p><p id="5c09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着React应用程序通常在100到200毫秒之间加载，而Svelte应用程序在50到60毫秒之间加载。</p><p id="a86d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React应用的平均时间为167毫秒</p><p id="c1fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条应用的平均时间是55毫秒</p><p id="0bab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，苗条/日期-fns应用程序的加载速度比反应/时刻应用程序快3倍。</p><p id="ac1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些都是很好的结果，但在一个更大的应用程序中用相同的第三方库进行比较会更有趣。</p><h1 id="0ca2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="da46" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你可以在这个<a class="ae kc" href="https://github.com/skflowne/github-file-search-svelte-ts" rel="noopener ugc nofollow" target="_blank"> github repo </a>中找到完整的教程代码</p></div></div>    
</body>
</html>