<html>
<head>
<title>Learning C++: Overloading the Relational Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:重载关系运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-overloading-the-relational-operators-bf3c127eaba0?source=collection_archive---------11-----------------------#2020-09-26">https://levelup.gitconnected.com/learning-c-overloading-the-relational-operators-bf3c127eaba0?source=collection_archive---------11-----------------------#2020-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bc9f8cb39a894affcb1dfd5841149596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6VOfO1EHLsZ16Sg2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kf" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清</a>拍摄的照片</figcaption></figure><p id="836b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将讨论如何重载C++关系运算符。我以前介绍过重载输入和输出操作符、赋值操作符以及递增和递减操作符。</p><h1 id="cbe5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">示范课</h1><p id="251f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">出于讨论的目的，我将创建并使用一个<code class="fe mh mi mj mk b">Item</code>类。下面是这个类的声明和定义，出于节省空间的目的，这个类很简单(没有getters和setters，也没有重载的构造函数，还有一些我没有提到的特性):</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c724" class="mt lf it mk b gy mu mv l mw mx">class Item {<br/>private:<br/>  string itemName;<br/>  int numStock;<br/>public:<br/>  Item(string name, int stock);<br/>  void display();<br/>};</span><span id="d3dd" class="mt lf it mk b gy my mv l mw mx">void Item::display() {<br/>  cout &lt;&lt; "Item name: " &lt;&lt; itemName &lt;&lt; ": " &lt;&lt; numStock;<br/>}</span><span id="2b9d" class="mt lf it mk b gy my mv l mw mx">Item::Item(string name, int number) {<br/>  itemName = name;<br/>  numStock = number;<br/>}</span></pre><h1 id="40f8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重载==运算符</h1><p id="699f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">关系运算符很容易重载。您将它们声明为友元函数，然后在函数体中执行重载的比较。下面是重载<code class="fe mh mi mj mk b">==</code>操作符的声明和定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a414" class="mt lf it mk b gy mu mv l mw mx">friend bool operator ==(const Item &amp;, const Item &amp;);</span><span id="8fae" class="mt lf it mk b gy my mv l mw mx">bool operator == (const Item &amp;lhs, const Item &amp;rhs) {<br/>  return (lhs.numStock == rhs.numStock);<br/>}</span></pre><p id="bafb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个测试程序可以使用:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="64ef" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  Item store1Widget("Widget", 3);<br/>  Item store2Widget("Widget", 3);<br/>  if (store1Widget == store2Widget) {<br/>    cout &lt;&lt; "Both stores have the same number of widgets."<br/>         &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "The stores don't have the same number of widgets."<br/>         &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>};</span></pre><p id="196b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b33a" class="mt lf it mk b gy mu mv l mw mx">Both stores have the same number of widgets.</span></pre><h1 id="2896" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重载剩余的关系运算符</h1><p id="8471" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们已经看到重载<code class="fe mh mi mj mk b">==</code>操作符是多么容易，我们可以快速重载剩余的关系操作符(<code class="fe mh mi mj mk b">!=</code>、<code class="fe mh mi mj mk b">&gt;</code>、<code class="fe mh mi mj mk b">&lt;</code>、<code class="fe mh mi mj mk b">&gt;=</code>和<code class="fe mh mi mj mk b">&lt;=</code>)。以下是声明和定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f5fb" class="mt lf it mk b gy mu mv l mw mx">friend bool operator !=(const Item &amp;, const Item &amp;);</span><span id="1535" class="mt lf it mk b gy my mv l mw mx">friend bool operator &gt;(const Item &amp;, const Item &amp;);</span><span id="d724" class="mt lf it mk b gy my mv l mw mx">friend bool operator &lt;(const Item &amp;, const Item &amp;);</span><span id="fe60" class="mt lf it mk b gy my mv l mw mx">friend bool operator &gt;=(const Item &amp;, const Item &amp;);</span><span id="5590" class="mt lf it mk b gy my mv l mw mx">friend bool operator &lt;=(const Item &amp;, const Item &amp;);</span><span id="5201" class="mt lf it mk b gy my mv l mw mx">bool operator &lt;=(const Item &amp;lhs, const Item &amp;rhs) {<br/>  return (lhs.numStock &lt;= rhs.numStock);<br/>}</span><span id="a0af" class="mt lf it mk b gy my mv l mw mx">bool operator &gt;=(const Item &amp;lhs, const Item &amp;rhs) {<br/>  return (lhs.numStock &gt;= rhs.numStock;<br/>}</span><span id="2c11" class="mt lf it mk b gy my mv l mw mx">bool operator &lt;(const Item &amp;lhs, const Item &amp;rhs) {<br/>  return (lhs.numStock &lt; rhs.numStock);<br/>}</span><span id="87a2" class="mt lf it mk b gy my mv l mw mx">bool operator &gt;(const Item &amp;lhs, const Item &amp;rhs) {<br/>  return (lhs.numStock &gt; rhs.numStock);<br/>}</span><span id="9857" class="mt lf it mk b gy my mv l mw mx">bool operator !=(const Item &amp;lhs, const Item &amp;rhs) {<br/>  return (lhs.numStock != rhs.numStock);<br/>}</span></pre><p id="c760" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试程序，用于测试每个重载运算符:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="46da" class="mt lf it mk b gy mu mv l mw mx">int main()<br/>{<br/>  Item store1Widget("Widget", 4);<br/>  Item store2Widget("Widget", 3);<br/>  // excuse the awkward formatting<br/>  (store1Widget != store2Widget) ?<br/>    cout &lt;&lt; "Not the same number of items." &lt;&lt; endl<br/>    : cout &lt;&lt; "The same number of items." &lt;&lt; endl;</span><span id="9aef" class="mt lf it mk b gy my mv l mw mx">  (store1Widget &gt; store2Widget) ? cout &lt;&lt; "Store 1 has more. "<br/>    &lt;&lt; endl : cout &lt;&lt; "Store 1 doesn't have more. " &lt;&lt; endl;<br/>    (store1Widget &gt;= store2Widget) ? cout &lt;&lt; "Store 1 has more. "<br/>    &lt;&lt; endl : cout &lt;&lt; "Store 1 doesn't have more. " &lt;&lt; endl;</span><span id="ffd7" class="mt lf it mk b gy my mv l mw mx">  (store2Widget &lt; store1Widget) ? cout &lt;&lt; "Store 2 has less."<br/>    &lt;&lt; endl : cout &lt;&lt; "Store 2 doesn't have less." &lt;&lt; endl;<br/>    (store2Widget &lt;= store1Widget) ? cout &lt;&lt; "Store 2 has less."<br/>    &lt;&lt; endl : cout &lt;&lt; "Store 2 doesn't have less." &lt;&lt; endl;</span><span id="ce03" class="mt lf it mk b gy my mv l mw mx">  return 0;<br/>}</span></pre><p id="8612" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个测试程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="779e" class="mt lf it mk b gy mu mv l mw mx">Not the same number of items.<br/>Store 1 has more.<br/>Store 1 has more.<br/>Store 2 has less.<br/>Store 2 has less.</span></pre><h1 id="cf6e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">过载就过载</h1><p id="3691" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我还没有介绍完在C++中可以重载的操作符。在我的下一篇文章中，我将介绍算术运算符的重载。</p><p id="41f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。如果你对我的在线编程课程感兴趣，请访问<a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank">https://learningcpp.teachable.com</a>。</p></div></div>    
</body>
</html>