<html>
<head>
<title>Best Practices To Use Pandas Efficiently As A Data Scientist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为数据科学家高效使用熊猫的最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/best-practices-to-use-pandas-efficiently-as-a-data-scientist-9198b3e7bb6d?source=collection_archive---------3-----------------------#2022-12-09">https://levelup.gitconnected.com/best-practices-to-use-pandas-efficiently-as-a-data-scientist-9198b3e7bb6d?source=collection_archive---------3-----------------------#2022-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c129" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">作为一个数据科学家如何高效利用熊猫？</h2></div><p id="5d1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">作为一名数据科学家，使用正确的工具和技术来充分利用数据是非常重要的。Pandas库是一个非常棒的数据操作、分析和可视化工具，也是任何数据科学家工具箱中必不可少的一部分。然而，有效地使用熊猫是一个挑战，这会导致时间和精力的浪费。幸运的是，有一些最佳实践可以帮助数据科学家充分利用他们的熊猫体验。从使用矢量化操作到利用内置函数，这些最佳实践将帮助数据科学家使用Pandas快速准确地分析和可视化数据。了解并应用这些最佳实践将有助于数据科学家提高工作效率和准确性，从而更快地做出更好的决策。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/46b8ca9335570ce24adf00451f70de40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xEs8POBpzfHmDWxs"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">由<a class="ae md" href="https://unsplash.com/@itookthose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">希德·巴拉钱德朗</a>在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="21e9" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">目录:</h2><ol class=""><li id="c677" class="mx my it kk b kl mz ko na kr nb kv nc kz nd ld ne nf ng nh bi translated">为什么我们需要高效的编码？</li><li id="2d75" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">有效选择和替换值<br/> 2.1。有效地选择行&amp;列。iloc[] &amp;。loc[] <br/> 2.2。有效替换数据帧中的值<br/> 2.3。选择和替换值的最佳实践摘要</li><li id="92f2" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">通过Pandas DataFrame <br/> 3.1进行有效迭代。使用有效地循环。iterrows() <br/> 3.2。使用有效循环。3.3应用()<br/>。使用矢量化<br/> 3.4有效循环。循环遍历数据帧的最佳实践摘要</li><li id="a52e" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">使用有效地转换数据。groupby() <br/> 4.1。与一起使用的常用函数。groupby() <br/> 4.2。缺失值插补使用。groupby() &amp;。4.3转换()<br/>。使用进行数据过滤。groupby() &amp;。过滤器()</li><li id="9e84" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">最佳实践总结</li></ol><h2 id="ab3e" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">您可以在GitHub知识库中找到本文中使用的代码和数据集:</h2><div class="nn no gp gr np nq"><a href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">GitHub-youssefHosni/面向数据科学家的高级Python</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe lx nq"/></div></div></a></div><p id="99fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将使用三个数据集:</p><ul class=""><li id="489d" class="mx my it kk b kl km ko kp kr of kv og kz oh ld oi nf ng nh bi translated"><a class="ae md" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/poker_hand.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">扑克牌游戏数据集</strong> </a></li><li id="c958" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated"><a class="ae md" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/Popular_Baby_Names.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">流行宝宝名字</strong> </a></li><li id="b8bd" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated"><a class="ae md" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/restaurant_data.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">餐厅数据集</strong> </a></li></ul><p id="77df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个数据集是<a class="ae md" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/poker_hand.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">扑克牌游戏数据集</strong> </a> <strong class="kk iu"> </strong>，如下所示。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ol"><img src="../Images/6822839d08a1f3b7b0c15bcc9719db6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDwYuZN1THDdvMVB0V14lQ.png"/></div></div></figure><p id="5277" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每一轮扑克游戏中，每个玩家手里都有五张牌，每张牌都有其符号和等级，符号可以是红心、方块、梅花或黑桃，等级从1到13不等。该数据集由一个人可能拥有的五张卡的所有可能组合组成。</p><ul class=""><li id="6855" class="mx my it kk b kl km ko kp kr of kv og kz oh ld oi nf ng nh bi translated">Sn:第n张牌的符号，其中:1(红心)，2(方块)，3(梅花)，4(黑桃)</li><li id="0cd0" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">Rn:第n张牌的等级，其中:1(王牌)，2–10，11(杰克)，12(王后)，13(国王)</li></ul><p id="f28d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用的第二个数据集是<a class="ae md" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/Popular_Baby_Names.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">流行的婴儿名字</strong> </a> <strong class="kk iu"> </strong>数据集，其中包括2011年至2016年间最流行的新生儿名字。数据集已加载，如下所示:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi om"><img src="../Images/d991964972e286d23a47fd04518f2c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dqmqO3lxPWIANGpHXXU-OA.png"/></div></div></figure><p id="8fd3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该数据集包括按年份、性别和种族划分的美国最受欢迎的名字等信息。例如，2011年，克洛伊这个名字在所有亚裔和太平洋岛民的新生儿中排名第二。</p><p id="67ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用的第三个数据集是<a class="ae md" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/restaurant_data.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">餐馆数据集</strong> </a>。这个数据集是在餐馆吃饭的人的集合。数据集已加载，如下所示:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi on"><img src="../Images/c902be2e9f319894d993545a65d3d95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*JPMgaPuIrf4NMRX5F-YDcg.png"/></div></figure><p id="dc16" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每个顾客，我们有各种各样的特征，包括支付的总金额，留给服务员的小费，星期几，一天中的时间。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="2a98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想免费学习数据科学和机器学习，看看这些资源:</p><ul class=""><li id="6d73" class="mx my it kk b kl km ko kp kr of kv og kz oh ld oi nf ng nh bi translated">免费互动路线图，自学数据科学和机器学习。从这里开始:<a class="ae md" href="https://aigents.co/learn/roadmaps/intro" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn/roadmaps/intro</a></li><li id="5ec4" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">数据科学学习资源搜索引擎(免费)。将你最喜欢的资源加入书签，将文章标记为完整，并添加学习笔记。<a class="ae md" href="https://aigents.co/learn" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn</a></li><li id="d26e" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">想要在导师和学习社区的支持下从头开始学习数据科学吗？免费加入这个学习圈:<a class="ae md" href="https://community.aigents.co/spaces/9010170/" rel="noopener ugc nofollow" target="_blank">https://community.aigents.co/spaces/9010170/</a></li></ul></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="c01f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如果你想在数据科学&amp;人工智能领域开始职业生涯，但不知道如何开始。我提供数据科学指导课程和长期职业指导:</strong></p><ul class=""><li id="922f" class="mx my it kk b kl km ko kp kr of kv og kz oh ld oi nf ng nh bi translated">长期师徒:【https://lnkd.in/dtdUYBrM】T4</li><li id="c794" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">辅导课程:<a class="ae md" href="https://lnkd.in/dXeg3KPW" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dXeg3KPW</a></li></ul><p id="07ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="ov">加入</em> </strong> <a class="ae md" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="kk iu"> <em class="ov">中等会员</em> </strong> </a> <strong class="kk iu"> <em class="ov">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em> </strong></p><div class="nn no gp gr np nq"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nz l"><div class="ow l ob oc od nz oe lx nq"/></div></div></a></div></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="b4cc" class="ox mf it bd mg oy oz pa mj pb pc pd mm jz pe ka mp kc pf kd ms kf pg kg mv ph bi translated">1.为什么我们需要高效的编码？</h1><p id="d55f" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">高效代码是指执行速度更快、计算内存更少的代码。在本文中，我们将使用<strong class="kk iu"> time() </strong>函数来测量计算时间。这个函数测量当前时间，所以我们将在代码执行前和执行后把它赋给一个变量，然后计算差值，就知道代码的计算时间。下面的代码显示了一个简单的例子:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8b13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一些应用高效代码方法将如何提高代码运行时间和降低计算时间复杂性的例子:我们将计算从零到一百万的每个数字的平方。首先，我们将使用list comprehension来执行这个操作，然后使用for循环重复相同的过程。</p><p id="9e7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一次使用列表理解:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pl"><img src="../Images/4eea99b1d0ce438588bb6209f6a8d271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uE7ZCLgKbkd3w8tYD6FU6Q.png"/></div></div></figure><p id="c94b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将使用for循环来执行相同的操作:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/b5df69aa613b092a8f0877e0b12ca341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*PSIZlykL1x1Ze-DY21fWHw.png"/></div></figure><p id="3db8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到它们之间有很大的差异，我们可以用百分比来计算它们之间的差异:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/7a23b3dc80d9676bdc538ff0050d818f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*WGYGbDdHU034g0wtvOOi9Q.png"/></div></figure><p id="6a91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有另一个例子来展示编写高效代码的效果。我们想计算从1到100万的所有连续数字的总和。有两种方法第一种是使用蛮力，我们将一个接一个地增加到一百万。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi po"><img src="../Images/aeb47af7e023205a9d36bebbf1305d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*DcSnv7ereBhgUPEuOqyDEg.png"/></div></figure><p id="e2b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个更有效的方法是用公式来计算。当我们想计算从1到一个数的所有整数的和时，比如说N，我们可以把N乘以N+1，然后除以2，这样就会得到我们想要的结果。这个问题实际上在19世纪就交给了德国的一些学生，一个名叫卡尔-弗里德里希·高斯的聪明学生设计了这个公式来在几秒钟内解决这个问题。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/4ee06d0c924145eee32944bfd2cf18bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*v6SCA4OWg3V6eMb96Q8N1g.png"/></div></figure><p id="66b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行这两种方法后，我们实现了超过160，000%的巨大改进，这清楚地表明了为什么我们需要高效和优化的代码，即使对于简单的任务也是如此。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="9da3" class="ox mf it bd mg oy oz pa mj pb pc pd mm jz pe ka mp kc pf kd ms kf pg kg mv ph bi translated">2.有效选择和替换价值</h1><p id="0f52" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">让我们首先从两个最常见的任务开始，这两个任务是您通常会在数据框架上执行的，尤其是在数据科学项目的数据操作阶段。这两项任务是有效地选择特定和随机的行和列，以及使用<strong class="kk iu"> replace() </strong>函数使用列表和字典替换一个或多个值</p><h2 id="6227" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">2.1.使用有效地选择行和列。iloc[] &amp;。位置[]</h2><p id="f408" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">在这一小节中，我们将介绍如何使用<strong class="kk iu">从数据帧中有效地定位和选择行。iloc[] </strong> &amp; <strong class="kk iu">。loc[] </strong>熊猫功能。我们将使用<strong class="kk iu"> iloc[] </strong>作为索引号定位器，使用<strong class="kk iu"> loc[] </strong>作为索引名定位器。</p><p id="8e36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，我们将选择扑克数据集的前500行。首先使用<strong class="kk iu">。loc[] </strong>功能，然后通过使用<strong class="kk iu">。iloc[] </strong>功能。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/b5052b84f8bd0eee511692420cc7d227.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*0PBzKnGC5J3yaZ3rFMRfvQ.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/7416768059e202dd65a59799bc64feff.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*R2VxqKKWccb6lQ_KfSDG3w.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/2badfa7c73ec800f2896298fb1fe7f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*I4yza63_IDRIcudl8l78Hw.png"/></div></figure><p id="218a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这两种方法具有相同的语法，但是<strong class="kk iu"> iloc[] </strong>的执行速度比<strong class="kk iu"> loc[] </strong>快近70%。<strong class="kk iu">。iloc[]函数</strong>利用了已经排序的索引的顺序，因此速度更快。</p><p id="f57a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以用它们来选择列，而不仅仅是行。在下一个示例中，我们将使用两种方法选择前三列。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/fb4b66bdf89eb8dcfbaa207cecec946b.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*zPbAm-wgNtk1qF-FZdHKEQ.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/5bbabce3b09403b146d8951a47d93f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*8Mfg6UOTGNRg86l_muempw.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/2cd83fc2518395061c2ce7a5006b7340.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*UgQLcKZ14UUdA8bQPPIqaA.png"/></div></figure><p id="0be4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以看到，使用<strong class="kk iu"> iloc[] </strong>的列索引仍然快了80%。所以最好使用<strong class="kk iu"> iloc[] </strong>，因为这样更快，除非使用<strong class="kk iu"> loc[] </strong>更容易按名称选择某些列。</p><h2 id="6ad8" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">2.2.有效替换数据帧中的值</h2><p id="2fde" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">替换数据帧中的值是一项非常重要的任务，尤其是在数据清理阶段。因为您必须保持代表相同对象的所有值不变。</p><p id="6275" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看我们之前加载的流行婴儿名字数据集:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pw"><img src="../Images/85e35a96e4339505425fe2499b865293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgFtT7C6yRSDQcYHbOEteg.png"/></div></div></figure><p id="d392" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们仔细看看性别特征，看看它们的独特价值:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi px"><img src="../Images/d930b74fd2617599f71795fbe4a89b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*2LMyVQTUzHQbStPpJ4KmbA.png"/></div></figure><p id="53dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，女性用大写和小写两个值来表示。这在真实数据中很常见，一种简单的方法是用一个值替换另一个值，以使其在整个数据集中保持一致。有两种方法可以做到这一点第一种是简单地定义我们想要替换的值，然后我们想要用什么来替换它们。这显示在下面的代码中:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pw"><img src="../Images/cdcd86df687a8ad27b399d0b80514199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jth-yHNQz07aNBB8VKCikQ.png"/></div></div></figure><p id="cdb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二种方法是使用熊猫的内置功能<strong class="kk iu">。replace() </strong>如下面的代码所示:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi py"><img src="../Images/7cbdfdaeacc1353654497e09dac5e62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arvo0__9a0HP9PnDnp5SMQ.png"/></div></div></figure><p id="81ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，内置函数<strong class="kk iu">的时间复杂度比使用<strong class="kk iu">快157% </strong>。loc() </strong>方法找到行和列的索引值并替换它。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/9c405564ce28c2125dc782882d433bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*tzbt0RPESDCaATOg1uSvsw.png"/></div></figure><p id="759d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用列表替换多个值。我们的目标是将所有被归类为白人<strong class="kk iu">非西班牙裔</strong>或<strong class="kk iu">白人非HISP裔</strong>的种族改为<strong class="kk iu"> WNH裔</strong>。使用<strong class="kk iu">。loc[] </strong>函数，我们将使用‘or’语句(在Python中用管道符号表示)定位我们正在寻找的种族的婴儿。然后我们将分配新的值。和往常一样，我们也测量这个操作所需的CPU时间。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qa"><img src="../Images/15b47d317aad5ebc9f0fdd4d4b5e1f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqKFCSKGgIAlbjj2BMr5tQ.png"/></div></div></figure><p id="572b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<strong class="kk iu">进行同样的操作。replace() </strong>熊猫内置函数如下:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qb"><img src="../Images/d1d6128dd6468fddcf7eefc37d4f7a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*bS6qJ3E0qxYMYDZi7bd1xA.png"/></div></div></figure><p id="4f7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<strong class="kk iu">我们可以再次看到这一点。replace() </strong>方法比使用<strong class="kk iu">要快得多。loc[] </strong>方法。为了更直观地了解速度有多快，让我们运行下面的代码:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/6e719066cb54d608b1cd40091a2fd661.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*B4PySm6n_z2UyGq6AELOUw.png"/></div></figure><p id="5b2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">的。replace()方法比使用<strong class="kk iu">的</strong>快87%。loc[] 方法。如果你的数据很大，需要大量清理，这个技巧将减少数据清理的计算时间，使你的熊猫代码更快，因此更有效。</p><p id="707f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们还可以使用<strong class="kk iu">字典</strong>来替换数据帧中的单值和多值。如果您想在一个命令中使用多个替换功能，这将非常有用。</p><p id="115e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用字典将每个男性的性别替换为男孩，将每个女性的性别替换为女孩。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/e253db2e20b8496ede792824be8d3225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*SnAN4IH_Z6RtKsvlRIKxnA.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/8d5c3b06ad223c4bc7b51aee2a9b5639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*Iy4Bfd3MVxa4QTUwLDnD0A.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/17b5c724b4715c7f9846338182cf9255.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*USBpPRnm-xFff4rmMLJY-w.png"/></div></figure><p id="785c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以对列表做同样的事情，但是会更加冗长。如果我们比较这两种方法，我们可以看到字典运行大约快22%。一般来说，与列表相比，在Python中使用字典是非常高效的:浏览列表需要传递列表中的每个元素，而查看字典则直接指向与条目匹配的键。这种比较有点不公平，因为两种结构服务于不同的目的。</p><p id="054c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<strong class="kk iu">字典</strong>允许你替换几个不同列上的相同值。在前面的所有示例中，我们指定了要替换的值来自的列。我们现在要用一个公共值替换同一列中的几个值。我们想把所有种族分为三大类:黑人、亚洲人和白人。语法也非常简单。我们在这里使用嵌套字典:外键是我们想要替换值的列。这个外键的值是另一个字典，其中的键是要替换的种族，以及新的种族(黑人、亚洲人或白人)的值。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="0b8f" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">2.3.选择和替换值的最佳实践摘要</h2><ul class=""><li id="3ee3" class="mx my it kk b kl mz ko na kr nb kv nc kz nd ld oi nf ng nh bi translated">使用可以更快地选择行和列。<strong class="kk iu"> iloc[] </strong>功能。所以最好使用，除非使用<strong class="kk iu">更容易或更方便。而且速度不是重点或者你只是做一次。</strong></li><li id="26e5" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">使用内置的<strong class="kk iu"> replace() </strong>函数比仅仅使用传统方法要快得多。</li><li id="63cf" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">使用python字典替换多个值比使用列表更快。</li></ul></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="cd59" class="ox mf it bd mg oy oz pa mj pb pc pd mm jz pe ka mp kc pf kd ms kf pg kg mv ph bi translated">3.有效地遍历熊猫数据框架</h1><p id="e4e9" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">作为一名数据科学家，您将需要广泛地迭代您的数据框架，尤其是在数据准备和探索阶段，因此能够高效地完成这项工作非常重要，因为这将为您节省大量时间，并为更重要的工作留出空间。我们将通过三种方法让您的循环更快、更有效:</p><ul class=""><li id="c994" class="mx my it kk b kl km ko kp kr of kv og kz oh ld oi nf ng nh bi translated">使用<strong class="kk iu">循环。iterrows() </strong>函数</li><li id="9fda" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">使用<strong class="kk iu">循环。apply() </strong>函数</li><li id="9efb" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">…向量化…</li></ul><h2 id="6993" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">3.1.使用<strong class="ak">有效循环。iterrows() </strong></h2><p id="a53b" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">在我们谈论如何使用<strong class="kk iu">之前。iterrows() </strong>函数为了改善循环过程，让我们刷新一下生成器函数的概念。</p><p id="f4c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">生成器</strong>是创建迭代器的简单工具。在生成器主体内部，您将发现只有<strong class="kk iu"> yield() </strong>语句，而不是return语句。可以只有一个，也可以有几个<strong class="kk iu"> yield() </strong>语句。在这里，我们可以看到一个生成器，<strong class="kk iu"> city_name_generator() </strong>，它生成四个城市名。为简单起见，我们将生成器分配给变量<strong class="kk iu"> city_names </strong>。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8130" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了访问生成器生成的元素，我们可以使用Python的<strong class="kk iu"> next() </strong>函数。每次使用<strong class="kk iu"> next() </strong>命令时，生成器将生成下一个要生成的值，直到不再有要生成的值。我们这里有4个城市。让我们运行下一个命令四次，看看它会返回什么:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/cac311d89fed01dfcd3a23246ba4a887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*Yc_Wr1HUyV9jwldJrh33WA.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/32cb469637efbe201e52d2de7d3a9b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*W7253HFONdCWE9OuSKZ1lg.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/1bcf8779b1e05b30bb53a8d6fe9c735d.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*7RCiSqA1Mmn4rQ1qA0E-GQ.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="d291" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们可以看到的，每次我们运行<strong class="kk iu"> next() </strong>函数，它都会打印一个新的城市名。</p><p id="ca39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回到。<strong class="kk iu"> iterrows() </strong>函数。<strong class="kk iu">。iterrows() </strong>函数是每个熊猫DataFrame的属性。当被调用时，它产生一个包含两个元素的列表。我们将使用这个生成器来遍历我们的<strong class="kk iu">扑克</strong>数据帧的每一行。第一个元素是该行的索引，而第二个元素包含该行每个特征的熊猫系列:五张卡片中每张卡片的符号和等级。它非常类似于<strong class="kk iu"> enumerate() </strong>函数的概念，当应用于列表时，返回每个元素及其索引。</p><p id="3efc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">遍历Pandas数据帧最直观的方法是使用<strong class="kk iu"> range() </strong>函数，这通常被称为粗循环。下面的代码显示了这一点:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/8dea135f2fdab71d54235eb473e48dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*J7aX4vylxbkIQq_D7InJtg.png"/></div></figure><p id="cc63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代熊猫数据框架的一个更聪明的方法是使用<strong class="kk iu">。iterrows() </strong>函数，该函数针对此任务进行了优化。我们简单地用两个迭代器定义了“<strong class="kk iu"> for </strong>”循环，一个用于每行的编号，另一个用于所有的值。</p><p id="e1fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在循环内部，<strong class="kk iu"> next() </strong>命令指示循环移动到迭代器的下一个值，而不实际做任何事情。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/00fd0d0d906dfdc13fe12b3f0bd3eec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*sqt_pjsR4Mvejt8TRk2qDw.png"/></div></figure><p id="c377" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比较这两个计算时间我们还可以注意到<strong class="kk iu">的使用。iterrows() </strong>没有提高遍历pandas数据帧的速度。当我们需要一种更简洁的方式来使用每一行的值时，它是非常有用的。</p><h2 id="642e" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">3.2.使用<strong class="ak">有效循环。apply() </strong></h2><p id="ba28" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">现在我们将使用<strong class="kk iu">。apply() </strong>函数能够在遍历熊猫数据帧时执行特定的任务。<strong class="kk iu">。apply() </strong>函数确实如它所说的那样；它对整个数据帧应用另一个函数。</p><p id="178f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">的语法。apply() </strong>函数很简单:我们创建一个映射，在本例中使用lambda函数，然后声明我们想要应用于每个单元格的函数。这里，我们将平方根函数应用于数据帧的每个单元格。就速度而言，它与在整个数据帧上只使用NumPy <strong class="kk iu"> sqrt() </strong>函数的速度相当。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ql"><img src="../Images/6a9a085b744b4733be281419ee25c941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpOG5f8-niEA9LSkOiB5Cg.png"/></div></div></figure><p id="1245" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个简单的例子，因为我们想将这个函数应用于数据帧。</p><p id="0857" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，当目标函数接受多个单元格作为输入时，会发生什么情况呢？例如，如果我们想计算每手牌中所有牌的排名之和，该怎么办？在这种情况下，我们将使用。apply()函数和我们之前做的一样，但是我们需要在行尾添加<strong class="kk iu"> 'axis=1' </strong>来指定我们正在将函数应用到每一行。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/d2c3ae10afe3ee812f278143de7010e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*qqkbc1NPNrtYYuvwWYuARA.png"/></div></figure><p id="c493" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将使用<strong class="kk iu">。iterrows() </strong>函数我们以前见过，并比较它们的效率。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/e7c1d5410f01bf73b31740aaeba48e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*womVeYylnE3GDyxprN0Qfg.png"/></div></figure><p id="a2f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<strong class="kk iu">。apply() </strong>函数明显比<strong class="kk iu">快。iterrows() </strong>函数，幅度约为400 %,这是一个巨大的改进！</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/8c6e15e0f0e65ec2eef5821a9e7cd280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*Saqgnht9V4brMEwpLW4GcA.png"/></div></figure><p id="d05b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们对行所做的那样，我们可以对列做完全相同的事情；对每列应用一个函数。通过将<strong class="kk iu">轴=1 </strong>替换为<strong class="kk iu">轴=0 </strong>，我们可以对每一列应用求和函数。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/5120b4d834371740ce6c7949bcee6799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*V9kzACIeimtuuhOAy31nPA.png"/></div></figure><p id="cafd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过比较。<strong class="kk iu"> apply() </strong>函数用原生熊猫的函数对多行求和，我们可以看到熊猫的原生<strong class="kk iu">。sum() </strong>函数执行相同操作的速度更快。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qq"><img src="../Images/b063a2e67bc210dd50bb3bf6f907777f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*kg3XlD31WQkOzhTrZTl1mg.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/87fe38cffedbe0e961645f506a17991f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*VUpdeESO6DYv-xamU30LnQ.png"/></div></figure><p id="e856" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">总之，我们观察到。当我们想要遍历pandas数据帧的所有行时，apply()函数执行得更快，但是当我们通过一列执行相同的操作时，它执行得更慢。</strong></p><h2 id="e9fe" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">3.3.使用矢量化有效循环</h2><p id="c530" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">为了理解如何减少函数执行的迭代次数，回想一下Pandas的基本单元DataFrames和Series都是基于数组的。当对整个数组执行操作时，Pandas的执行效率比对每个值单独或顺序执行更高。这可以通过<strong class="kk iu">矢量化</strong>来实现。<strong class="kk iu">矢量化</strong>是对整个数组执行操作的过程。</p><p id="b2cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码中，我们要计算每手牌中所有牌的等级之和。为此，我们对扑克数据集进行切片，只保留包含每张牌的等级的列。然后，我们称之为内置<strong class="kk iu">。DataFrame的sum() </strong>属性，使用参数axis = 1来表示我们需要每行的总和。最后，我们打印前五行数据的总和。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qs"><img src="../Images/e6ac7ac73c967ef16999a8d37955ba6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mopzizHarf-Nv2XTOMeyfA.png"/></div></div></figure><p id="c9b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们之前看到了各种方法，这些方法执行应用于数据帧的函数比简单地遍历数据帧的所有行要快。我们的目标是找到执行这项任务的最有效的方法。</p><ul class=""><li id="623b" class="mx my it kk b kl km ko kp kr of kv og kz oh ld oi nf ng nh bi translated">使用<strong class="kk iu">。iterrows() </strong>循环遍历数据帧:</li></ul><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qt"><img src="../Images/e0d27459ab1b90bdef655ee96d4ff476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*kr2UsHYM_e4Eeg1bJASYSQ.png"/></div></figure><ul class=""><li id="30fe" class="mx my it kk b kl km ko kp kr of kv og kz oh ld oi nf ng nh bi translated">使用。apply()方法</li></ul><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qu"><img src="../Images/de96448c66380ca27242f89b6d3bf7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*2Y9gONhHqEqM4UNNUk5Vlw.png"/></div></figure><p id="d0aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<strong class="kk iu">矢量化</strong>和<strong class="kk iu">比较每手牌中所有牌的等级相加所需的时间。iterrows() </strong>函数，以及<strong class="kk iu">。apply() </strong>函数，我们可以看到矢量化方法的性能要好得多。</p><p id="1a01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用另一种矢量化方法来有效地遍历数据帧，该方法使用Numpy数组对数据帧进行矢量化。</p><p id="0938" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NumPy库将自己定义为“Python中科学计算的基础包”，它在优化的预编译C代码中执行操作。与pandas处理数组类似，NumPy对名为<strong class="kk iu"> ndarrays </strong>的数组进行操作。Series和ndarrays之间的一个主要区别是ndarrays省略了许多操作，如索引、数据类型检查等。因此，在NumPy阵列上的操作比在pandas系列上的操作要快得多。当pandas系列提供的附加功能不重要时，NumPy阵列可以用来代替pandas系列。</p><p id="dd0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们在本文中探索的问题，我们可以使用NumPy ndarrays来代替pandas系列。关键的问题是这是否会更有效率。</p><p id="c17e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们将计算每手牌中所有牌的等级总和。我们简单地通过使用<strong class="kk iu">将我们的rank数组从pandas系列转换成NumPy数组。熊猫系列的values </strong>方法，该方法将熊猫系列作为NumPy <strong class="kk iu"> ndarray </strong>返回。与对序列进行矢量化一样，将NumPy数组直接传递给函数将导致pandas将函数应用于整个矢量。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/04f0b3126961b52e949ad97b79fec801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*CviEdAkQ7RtdywEyyPcFxg.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qv"><img src="../Images/11edf5cfeecac121d47c14805454a639.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*ATYexB_zZiImmLBY0ltrOA.png"/></div></figure><p id="26b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一点上，我们可以看到对pandas系列的矢量化实现了日常计算的绝大多数优化需求。然而，如果速度是最重要的，我们可以通过<strong class="kk iu"> NumPy </strong> Python库的形式来寻求帮助。与之前最先进的panda优化方法相比，我们仍然在运行时间上有所改进。</p><h2 id="06af" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated"><strong class="ak"> 3.4。</strong>循环遍历数据帧的最佳实践总结</h2><ul class=""><li id="a781" class="mx my it kk b kl mz ko na kr nb kv nc kz nd ld oi nf ng nh bi translated">使用。<strong class="kk iu"> iterrows() </strong>没有提高遍历数据帧的速度，但效率更高。</li><li id="7d61" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated"><strong class="kk iu">。当我们想要遍历熊猫数据帧的所有行时，apply() </strong>函数执行得更快，但是当我们通过一列执行相同的操作时，执行得更慢。</li><li id="c346" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">对pandas系列进行矢量化处理可以满足日常计算的绝大多数优化需求。然而，如果速度是最重要的，我们可以以<strong class="kk iu"> NumPy </strong> Python库的形式调用增援。</li></ul></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="4989" class="ox mf it bd mg oy oz pa mj pb pc pd mm jz pe ka mp kc pf kd ms kf pg kg mv ph bi translated">4.使用<strong class="ak">有效转换数据。groupby() </strong></h1><p id="7150" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">在文章的最后一部分，我们将介绍如何使用<strong class="kk iu">。groupby() </strong>根据特定特性的值有效地对数据帧的条目进行分组。<strong class="kk iu">。groupby() </strong>方法应用于数据帧，并根据特征对其进行分组。然后，我们可以对分组的对象应用一些简单或更复杂的函数。对于每个处理表格或结构化数据的数据科学家来说，这是一个非常重要的工具，因为它将帮助您以更有效的方式轻松操作数据。</p><h2 id="45ec" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">4.1.与一起使用的常用函数。groupby()</h2><p id="41ec" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">应用于聚合组的最简单方法之一是<strong class="kk iu">。计数()。</strong>在下面的例子中，我们将把它应用于餐馆数据集。首先，我们根据顾客是否吸烟对餐馆数据进行分组。然后，我们应用<strong class="kk iu">。</strong>计数()方法。我们获得了吸烟者和不吸烟者的人数。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qw"><img src="../Images/d7028fa2711bf24de529e9ee69914b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*_1tsWwJsEzXAPbeJz8jEnQ.png"/></div></figure><p id="7b5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">毫不奇怪，我们对所有特性都得到了与<strong class="kk iu">相同的结果。count() </strong>方法统计每组在每个特征中出现的次数。因为我们的数据中没有缺失值，所以所有列中的结果应该是相同的。</p><p id="cf9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据特定特性的值对数据帧的条目进行分组后，我们可以应用我们感兴趣的任何类型的<strong class="kk iu">变换</strong>。这里，我们将应用z得分，这是一种归一化变换，即每个值与平均值之间的距离除以标准差。这是统计学中非常有用的变换，通常在标准化测试中与z测试一起使用。要将这种转换应用于分组对象，我们只需调用。transform()方法包含我们定义的lambda转换。</p><p id="553e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这次，我们将根据<strong class="kk iu">餐</strong>的类型分组:是晚餐还是午餐？由于z得分转换是与组相关的转换，因此生成的表只是原始表。对于每个元素，我们减去平均值，然后除以它所属组的标准偏差。我们还可以看到，数值变换只应用于数据帧的数值特征。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qx"><img src="../Images/e6bde094fb28f219577a37088403b172.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*vfUPnrfAiO8CLuwAD_AsBg.png"/></div></figure><p id="0deb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然<strong class="kk iu"> transform() </strong>方法大大简化了事情，但它真的比使用原生Python代码更有效吗？正如我们之前所做的，我们首先对数据进行分组，这次是根据性别。然后，我们应用之前应用的z分数变换，测量其效率。我们在这里省略了测量每个操作时间的代码，因为您对此已经很熟悉了。我们可以看到，通过使用transform()函数，我们实现了巨大的速度提升。除此之外，我们只使用一行代码来执行感兴趣的操作。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="871e" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">4.2.缺失值插补使用。groupby() &amp;。转换()</h2><p id="91a6" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">既然我们已经看到了为什么以及如何在一个分组的熊猫对象上使用<strong class="kk iu"> transform() </strong>函数，我们将处理一个非常具体的任务，即输入缺失值。</p><p id="fa2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们实际了解如何使用<strong class="kk iu">变换()</strong>函数进行缺失值插补之前，我们将了解每组中我们感兴趣的变量中有多少缺失值。我们可以在下面看到每个“<strong class="kk iu">时间”</strong>特征的数据点数，它们是176+68 = 244。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi qy"><img src="../Images/81cf0dd3ce2a055d25ab09cf2f8e697d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_gA-nBOU1BIOdFJZZO5dxA.png"/></div></div></figure><p id="29da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将创建一个<strong class="kk iu"> restaurant_nan </strong>数据集，其中使用下面的代码将10%随机观察的总账单设置为<strong class="kk iu"> NaN </strong>:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="2a87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们打印每个“<strong class="kk iu">时间”</strong>特征中的数据点数，我们可以看到它们现在是155+62 = 217。由于我们拥有的总数据点是244个，那么丢失的数据点是24个，相当于10%。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qz"><img src="../Images/0b86c70a9ecc2a8ccacaad6c037110bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*0ClNZzLekV9jvs59PqyzUg.png"/></div></figure><p id="4fb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在统计了数据中缺失值的数量后，我们将展示如何用特定于组的函数来填充这些缺失值。最常见的选择是均值和中位数，选择与数据的偏斜度有关。正如我们之前所做的，我们使用<strong class="kk iu"> fillna </strong>()函数定义了一个<strong class="kk iu"> lambda </strong>转换，用它的组平均值替换每个缺失值。和以前一样，我们根据用餐时间对数据进行分组，然后通过应用预定义的转换来替换缺失的值。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qv"><img src="../Images/913ae910a8c468ba1fee03a6fc5c33b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*D0IlAIF3z0zpuRcwvWuouw.png"/></div></figure><p id="1785" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，索引0和索引4处的观察值完全相同，这意味着它们的缺失值已被它们组的均值所取代。</p><p id="50c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以看到使用这种方法的计算时间是0.007秒。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ra"><img src="../Images/cef58135a331a671facbe9408b4a01e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*JkJPsgaq_UFnAiXL6v5Qow.png"/></div></figure><p id="2e31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将其与传统方法进行比较:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi rb"><img src="../Images/546557535d5253799342886ae18af869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28R7TRJEbQCe6_BjDBtBSw.png"/></div></div></figure><p id="20ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到使用<strong class="kk iu">。transform() </strong>应用于分组对象的函数比执行此任务的原生Python代码执行速度更快。</p><h2 id="f703" class="me mf it bd mg mh mi dn mj mk ml dp mm kr mn mo mp kv mq mr ms kz mt mu mv mw bi translated">4.3.使用进行数据过滤。groupby() &amp;。过滤器()</h2><p id="4a32" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr pi kt ku kv pj kx ky kz pk lb lc ld im bi translated">现在我们将讨论如何在一个分组的熊猫对象上使用<strong class="kk iu"> filter() </strong>函数。这允许我们根据一些特定的条件，只包括这些组的一个子集。</p><p id="acd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，在根据特定特征对数据帧的条目进行分组之后，我们感兴趣的是基于某些条件只包括那些组的子集。过滤条件的一些示例包括缺失值的数量、特定要素的平均值或组在数据集中的出现次数。</p><p id="9b7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们感兴趣的是在支付给服务员的平均金额超过20美元的日子里，找到给小费的平均金额。<strong class="kk iu">。filter() </strong>函数接受对每个组的数据帧进行操作的<strong class="kk iu">λ</strong>函数。在本例中，lambda函数选择“total_bill”并检查<strong class="kk iu"> mean() </strong>是否大于20。如果lambda函数返回真，则计算小费<strong class="kk iu">平均值()</strong>。如果我们比较提示的总平均值，我们可以看到两个值之间存在差异，这意味着过滤正确执行。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi rc"><img src="../Images/5b6f28a655dedbbf923f73d84018885f.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*EiINeiA7NHrbGCZuiUPrrw.png"/></div></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/e782b88e29ffabf7f4dbe95851ed4ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*TPBKZ31hHCD7RglC4klwhQ.png"/></div></figure><p id="24a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们试图在不使用<strong class="kk iu"> groupby() </strong>的情况下执行这个操作，我们最终会得到这个低效的代码。首先，我们使用list comprehension来提取数据帧中涉及平均膳食超过20美元的日期的条目，然后使用for循环将它们添加到一个列表中并计算平均值。这可能看起来非常直观，但正如我们所见，这也是非常低效的。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><h1 id="ce5e" class="ox mf it bd mg oy oz pa mj pb pc pd mm jz pe ka mp kc pf kd ms kf pg kg mv ph bi translated">5.最佳实践总结</h1><ul class=""><li id="2cb4" class="mx my it kk b kl mz ko na kr nb kv nc kz nd ld oi nf ng nh bi translated">使用可以更快地选择行和列。<strong class="kk iu"> iloc[] </strong>功能。所以除非更容易或者更方便使用<strong class="kk iu">否则还是用起来比较好。而且速度不是重点或者你只是做一次。</strong></li><li id="6895" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">使用内置的<strong class="kk iu"> replace() </strong>函数比仅仅使用传统方法要快得多。</li><li id="c6b2" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">使用python字典替换多个值比使用列表更快。</li><li id="db53" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">使用。<strong class="kk iu"> iterrows() </strong>没有提高遍历数据帧的速度，但效率更高。</li><li id="427e" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated"><strong class="kk iu">。当我们想要遍历熊猫数据帧的所有行时，apply() </strong>函数执行得更快，但是当我们通过一列执行相同的操作时，执行得更慢。</li><li id="3c3f" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">对pandas系列进行矢量化处理可以满足日常计算的绝大多数优化需求。然而，如果速度是最重要的，我们可以通过<strong class="kk iu"> NumPy </strong> Python库的形式来寻求帮助。</li><li id="9568" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated">使用<strong class="kk iu">。groupby() </strong>根据某个特征将其分组，然后使用其他函数将其应用于数据，比使用常规编码方法要快得多。</li></ul></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="ac2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="ov">感谢阅读！如果你喜欢这篇文章，请务必:</em> </strong></p><ul class=""><li id="918d" class="mx my it kk b kl km ko kp kr of kv og kz oh ld oi nf ng nh bi translated"><strong class="kk iu">👏为这个故事鼓掌(50次)并跟我来👉</strong></li><li id="e3ce" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated"><strong class="kk iu">📰查看我的媒体档案中的更多内容</strong></li><li id="b650" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated"><strong class="kk iu">🔔关注我:</strong><a class="ae md" href="https://www.linkedin.com/in/youssef-hosni-b2960b135/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">LinkedIn</strong></a><strong class="kk iu">|</strong><a class="ae md" href="https://medium.com/@youssefraafat57" rel="noopener"><strong class="kk iu">Medium</strong></a><strong class="kk iu">|</strong><a class="ae md" href="https://twitter.com/Youssef70125494" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">Twitter</strong></a><strong class="kk iu">|</strong><a class="ae md" href="https://github.com/youssefHosni" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">GitHub</strong></a></li><li id="5cd0" class="mx my it kk b kl ni ko nj kr nk kv nl kz nm ld oi nf ng nh bi translated"><em class="ov">🚀👉</em> <strong class="kk iu"> <em class="ov">加入</em> </strong> <a class="ae md" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="kk iu"> <em class="ov">中等会员</em> </strong> </a> <strong class="kk iu"> <em class="ov">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em> </strong></li></ul><div class="nn no gp gr np nq"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nz l"><div class="ow l ob oc od nz oe lx nq"/></div></div></a></div></div></div>    
</body>
</html>