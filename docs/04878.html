<html>
<head>
<title>Angular Template Syntax Done Right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度模板语法做对了</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-template-syntax-done-right-3a6906c86c1a?source=collection_archive---------8-----------------------#2020-07-21">https://levelup.gitconnected.com/angular-template-syntax-done-right-3a6906c86c1a?source=collection_archive---------8-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="654c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何优化双向数据绑定</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bbe7f7cbd973fd652967c6c6c97dbf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvTkm6LfzQI71HXV0bY4Yg.jpeg"/></div></div></figure><p id="4838" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">如果您想构建大型应用程序而不存在与性能相关的问题，那么在使用Angular模板时拥有一个指南列表是一个很好的实践。</p><p id="4ded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将讨论Angular中的模板语法，以及如何通过正确的实践让我们的Angular模板代码<strong class="kw iu"> e </strong>更具可读性和性能。</p><p id="99f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将学习用模板语法绑定的一些常见用例来绑定数据的最合适的方法，以及我们如何有效地解决当前/未来的问题。</p><blockquote class="lz ma mb"><p id="0d5a" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">我假设你对<a class="ae mg" href="https://angular.io/guide/template-syntax" rel="noopener ugc nofollow" target="_blank"> Angular模板语法</a>有一个基本的了解，这是一篇关于模板语法的专题文章，你需要关于这个主题的基本知识。</p></blockquote><p id="434f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开始之前，让我们看一下在模板中绑定字符串变量的角度插值的基本实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a98f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> component.ts </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="9cfe" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">模板语法中的业务逻辑</h1><p id="8820" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4bc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mc">在HTML文件中编写业务逻辑不是一个好的做法。</em></p><p id="19d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">这在更大的模板上产生了代码可读性、可维护性和可重用性的问题</strong>,因为HTML模板不是用来编写业务逻辑的。</p><blockquote class="lz ma mb"><p id="1773" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">在TS文件中写一个逻辑代码是很好的。</p></blockquote><p id="eef5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">推荐的方法是<strong class="kw iu">在组件</strong>中创建一个getter属性，并在HTML模板中使用各自的属性。</p><p id="d6c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是转换后的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><blockquote class="lz ma mb"><p id="f2bc" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">上面的代码让我们有机会在多个领域使用相同的代码:在模板和组件中，如果需要的话。</p></blockquote><h1 id="8c99" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">从模板调用方法</h1><blockquote class="ng"><p id="a1c3" class="nh ni it bd nj nk nl nm nn no np lp dk translated"><em class="nq">当我还是一个初学Angular的开发者时，从模板中调用组件方法似乎是正确的</em></p></blockquote><p id="34b0" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">由于数据来自父组件，<strong class="kw iu">我习惯于从HTML中调用方法</strong>，因为这比其他方法更容易(快捷方式对开发人员总是有用的)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><blockquote class="lz ma mb"><p id="1bc1" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">根据Angular文档，上面的代码没有问题</p></blockquote><p id="9080" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这种方法有一些潜在的问题。</p><blockquote class="ng"><p id="2687" class="nh ni it bd nj nk nl nm nn no np lp dk translated">如果方法内部有复杂的业务，那么模板呈现将花费时间，并且性能会降低</p></blockquote><p id="d8f5" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">让我们转换代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4a41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经为<code class="fe nw nx ny nz b">items</code>属性使用了setter方法，无论何时调用setter方法，它都会根据值设置<code class="fe nw nx ny nz b">total</code>。</p><p id="27e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mc">所以不需要从模板调用方法。</em></p><p id="6e3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来不错，但是你可能会想，如果我们可以通过使用<code class="fe nw nx ny nz b">ngOnChanges</code>方法实现同样的事情，为什么我还要使用setter方法。</p><p id="5ff5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以，但是<strong class="kw iu">如果复杂性增加，那么就很难管理带有<code class="fe nw nx ny nz b">if</code>子句的<code class="fe nw nx ny nz b">ngOnChanges</code>方法中的大量代码</strong>，并且在某些地方<strong class="kw iu">我们失去了TypeScript </strong>中可伸缩代码的能力。</p><blockquote class="lz ma mb"><p id="0111" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">根据复杂性，由您决定哪一个更适合您的应用程序</p></blockquote><p id="a459" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mc">基于我的组件复杂性</em>，我更喜欢这两种方法。</p><p id="e188" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我有多个<code class="fe nw nx ny nz b">@Input</code>装饰器属性，那么我更喜欢用setter方法，否则就用<code class="fe nw nx ny nz b">ngOnChanges</code>。</p><p id="c8e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">按照惯例，<strong class="kw iu">一个方法代表一个动作</strong>，一个<strong class="kw iu">属性代表一些数据</strong>。</p><blockquote class="ng"><p id="ac41" class="nh ni it bd nj nk nl nm nn no np lp dk translated">Getter属性在没有计算复杂性、代理另一个对象的值或隐藏私有变量等情况下非常有用。</p><p id="2257" class="nh ni it bd nj nk nl nm nn no np lp dk translated">另一方面，这些方法在我们的业务运营过于昂贵或异步流程等情况下非常有用。</p></blockquote><p id="97cd" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">我想分享一个不适合<code class="fe nw nx ny nz b">setter</code> / <code class="fe nw nx ny nz b">ngOnChanges</code>方法的用例:</p><blockquote class="lz ma mb"><p id="fc6e" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">数据来自返回产品列表的服务器，我们必须在表格中显示产品名称和可用性(计算)。</p></blockquote><p id="9855" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我更喜欢从模板中调用方法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="6e3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决问题的一个办法是应用<a class="ae mg" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>。</p><p id="1cb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请参见下面转换后的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="28ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们讨论几个你可能有的问题。</p><h2 id="fcad" class="oa mk it bd ml ob oc dn mp od oe dp mt ld of og mv lh oh oi mx ll oj ok mz ol bi translated"><strong class="ak">为什么我们创造了一个阶级，而不用阶级也能达到同样的目的？</strong></h2><p id="5bf1" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi lq translated"><span class="l lr ls lt bm lu lv lw lx ly di">是的，我们可以，但是<strong class="kw iu">我们失去了单一责任原则实践的好处</strong>,因为除了类之外，我们还必须编写用于等级计算的代码，无论是在服务类/组件/角度模板中，并且如果在具有不同服务类的多个组件中使用相同的实体并对其进行微小的修改，则代码会变得笨拙/重复。</span></p><blockquote class="lz ma mb"><p id="a1fd" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">创建一个类使我们能够在多个组件中使用与实体相同的行为</p></blockquote><p id="f29b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这满足了代码可维护性和可重用性的需求。</p><p id="3756" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类是有价值的，这仅适用于我们需要初始化属性和方法<strong class="kw iu">来帮助创建对象/处理业务规则</strong>的时候。</p><h2 id="51a2" class="oa mk it bd ml ob oc dn mp od oe dp mt ld of og mv lh oh oi mx ll oj ok mz ol bi translated"><strong class="ak">为什么我们在组件的分级方法中不使用记忆化？</strong></h2><p id="73e0" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">简单来说，</p><blockquote class="ng"><p id="6f09" class="nh ni it bd nj nk nl nm nn no np lp dk translated">记忆用于繁重的计算逻辑，可以显著提高性能，我们的情况不适合记忆。</p></blockquote><p id="c495" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">如果我们采用这种方法，<strong class="kw iu">如果在模板中使用多个方法，可能会增加内存消耗和代码复杂性</strong>。</p><p id="fa24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，我们关注的是访问<strong class="kw iu">对象属性，而不是模板</strong>中的方法，但是这对于更快地渲染模板来说是不够的。</p><p id="06ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">为什么？</strong></p><p id="e06f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这段代码中我们可以做两个改进:用<code class="fe nw nx ny nz b">ngFor</code>绑定数据，并应用<code class="fe nw nx ny nz b">OnPush</code>变更检测策略。</p><h1 id="d5d5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">使用*ngFor绑定数据</h1><p id="ce5b" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在更新产品列表的“任何人”行后，将重新计算整个列表。</p><blockquote class="ng"><p id="a709" class="nh ni it bd nj nk nl nm nn no np lp dk translated">这影响了较大数据的性能问题。</p></blockquote><p id="7789" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">为了解决这个问题，我们可以使用<strong class="kw iu"> "trackBy" </strong>函数，它帮助Angular知道如何在产品集合中跟踪我们的元素，唯一修改的值将被重新计算和重新绘制，而不是整个集合。</p><p id="ac5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请参考下面修改后的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="8473" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">OnPush变化检测策略</h1><p id="7870" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">缺席</p><blockquote class="ng"><p id="2668" class="nh ni it bd nj nk nl nm nn no np lp dk translated">Angular在每次应用程序中发生变化时对所有组件执行变化检测，这将检查模板表达式的值是否发生了变化</p></blockquote><p id="71bf" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated"><strong class="kw iu">如果组件复杂度增加，那么检查</strong>就需要更多的时间，但是通过<code class="fe nw nx ny nz b">ChangeDetectionStrategy.OnPush</code>，我们告诉Angular只检查引用是否改变，而不是检查每个属性的值。</p><blockquote class="ng"><p id="68d0" class="nh ni it bd nj nk nl nm nn no np lp dk translated">通过这种方法，我们显著提高了性能</p></blockquote><p id="c1cc" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated">使用<code class="fe nw nx ny nz b">OnPush</code>，当出现以下情况时，对组件进行变更检测:</p><ul class=""><li id="fe9c" class="om on it kw b kx ky la lb ld oo lh op ll oq lp or os ot ou bi translated"><strong class="kw iu">输入参考值</strong>改变</li><li id="577f" class="om on it kw b kx ov la ow ld ox lh oy ll oz lp or os ot ou bi translated">一个本地的<strong class="kw iu"> DOM事件</strong>是由组件或者它的一个子组件触发的</li><li id="5602" class="om on it kw b kx ov la ow ld ox lh oy ll oz lp or os ot ou bi translated"><strong class="kw iu">变更检测</strong>是通过<a class="ae mg" href="https://angular.io/api/core/ChangeDetectorRef" rel="noopener ugc nofollow" target="_blank">changeedetorref</a>类的<code class="fe nw nx ny nz b">detectChanges</code>方法手动触发的</li><li id="a443" class="om on it kw b kx ov la ow ld ox lh oy ll oz lp or os ot ou bi translated"><strong class="kw iu">异步管道可观察值</strong>获得新值</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="36de" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="c76e" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">所讨论的方法提供了基于特定需求组装代码的灵活性。</p><blockquote class="ng"><p id="0de6" class="nh ni it bd nj nk nl nm nn no np lp dk translated">与方法方法相比，在模板中使用对象属性使我们的模板代码具有可读性和执行性是很好的</p></blockquote><p id="9961" class="pw-post-body-paragraph ku kv it kw b kx nr ju kz la ns jx lc ld nt lf lg lh nu lj lk ll nv ln lo lp im bi translated"><em class="mc">感谢阅读！</em></p></div></div>    
</body>
</html>