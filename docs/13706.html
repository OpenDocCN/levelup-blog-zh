<html>
<head>
<title>How I reduced the size of my Docker Image by 95%</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何将Docker图片的尺寸缩小95%</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-reduced-the-size-of-my-docker-image-by-95-520a05439300?source=collection_archive---------0-----------------------#2022-09-29">https://levelup.gitconnected.com/how-i-reduced-the-size-of-my-docker-image-by-95-520a05439300?source=collection_archive---------0-----------------------#2022-09-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3759" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用多阶段构建缩小Docker映像的大小</p><p id="dc3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写Dockerfile似乎很容易，除非您最终编写的docker映像的大小为0.5GB。我最近在做一个React JS项目，在那里我构建了一个前端应用程序。React JS项目并没有什么新内容。我使用的是同一个package.json，一组典型前端应用程序会使用的依赖项。现在，我决定将应用程序转移到Kubernetes。所以我把docker镜像推送到DockerHub，尝试部署一个Pod。</p><p id="6568" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用的是本地集群，pod启动时间为5分7秒。我肃然起敬。然后我把它部署到AKS集群(Azure Kubernetes集群)。令人惊讶的是用了3分40秒。这是巨大的。我试着给豆荚加压来触发Kubernetes HPA。新的pod需要同样的3分钟来启动，最终应用程序会被太多的请求淹没。经过调查，我发现图像的大小是瓶颈，当然，你不会想要这么大的docker图像(O.5GB)。这时候，我意识到我将不得不做一些关于docker图像大小的事情。因此我利用了Docker多阶段构建的概念。</p><h1 id="f748" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">整个故事是关于什么的？(TLDR)</h1><ol class=""><li id="ad4f" class="lj lk iq jp b jq ll ju lm jy ln kc lo kg lp kk lq lr ls lt bi translated">使用多阶段构建减小Docker图像的大小。</li><li id="ba27" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">理解多阶段构建的概念。</li></ol><h1 id="5275" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">故事资源</h1><ol class=""><li id="95eb" class="lj lk iq jp b jq ll ju lm jy ln kc lo kg lp kk lq lr ls lt bi translated">GitHub链接:【https://github.com/pavan-kumar-99/medium-manifests T2】</li><li id="bccb" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated">GitHub分支:<a class="ae lz" href="https://github.com/pavan-kumar-99/medium-manifests/tree/multistage-build-docker" rel="noopener ugc nofollow" target="_blank">多级构建码头</a></li></ol><h2 id="31cc" class="ma km iq bd kn mb mc dn kr md me dp kv jy mf mg kz kc mh mi ld kg mj mk lh ml bi translated">Docker版本:</h2><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="dc31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我的一个典型React JS应用程序的初始Docker图像。如果您看到第1行，我使用的是alpine版本的节点。构建docker文件后，这里是它的大小。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/b6e618e5637c3fc71cf0e93b7018ba57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVLK9Qcbjc26H4GkJ-yPYg.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">非多阶段构建</figcaption></figure><p id="70a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是构建图像的典型方式，编写这样的docker文件似乎很容易。但是从Kubernetes的角度来看，使用这种方法有一些缺点。</p><p id="2d9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a)图像的大小直接影响Pod启动时间。</p><p id="034a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b)图像越小，pod启动越快。</p><h2 id="3903" class="ma km iq bd kn mb mc dn kr md me dp kv jy mf mg kz kc mh mi ld kg mj mk lh ml bi translated">Docker多阶段构建:</h2><p id="f3f7" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">Dockerfiles中的多级构建特性使您能够创建更小的容器映像，具有更好的缓存和更小的安全足迹。对于多阶段构建，您可以在docker文件中使用多个<code class="fe nh ni nj nk b">FROM</code>语句。每条<code class="fe nh ni nj nk b">FROM</code>指令可以使用不同的基础，并且它们中的每一条都开始了构建的新阶段。您可以有选择地将工件从一个阶段复制到另一个阶段，在最终图像中留下所有不想要的东西。</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="eacd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好像不一样？好吧，让我们理解文件。</p><p id="125b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一行称为阶段。这些阶段没有命名，您通过它们的整数来引用它们，第一个<code class="fe nh ni nj nk b">FROM</code>指令从0开始。然而，你可以通过给<code class="fe nh ni nj nk b">FROM</code>指令添加一个<code class="fe nh ni nj nk b">AS &lt;NAME&gt;</code>来命名你的阶段。</p><p id="7246" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后剩下的步骤保持不变。改变游戏规则的一个步骤是COPY — from(第18行)。对于多阶段构建，您可以在docker文件中使用多个<code class="fe nh ni nj nk b">FROM</code>语句。每条<code class="fe nh ni nj nk b">FROM</code>指令可以使用不同的基础，并且每条指令都开始了构建的新阶段。您可以有选择地将工件从一个阶段复制到另一个阶段，在最终图像中留下所有不想要的东西。</p><p id="9695" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来构建图像。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nl"><img src="../Images/8b45975d3bbc6b05471711ca3bf64a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DCWPY6JKrGesWEqHpIJtA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">多阶段构建后图像的大小</figcaption></figure><p id="59f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇，是的！！这是真的。图像尺寸缩小了95%。图像大小现在是27.2 MB。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/5e13b5d1471f15eb7042bd2e7539e8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*6jVGEauhNs8CkMHd.gif"/></div></figure><p id="7622" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的本地集群花了25秒来提取图像并开始运行。我的AKS集群花了10秒钟提取图像并开始运行。</p><p id="738e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是很牛逼吗:)！！</p><p id="8b5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是如何利用docker中的多阶段构建来缩小docker图像的大小。请在评论区分享你在制定这些政策时的经验。</p><p id="51a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">直到下一次…..</p><h1 id="e754" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">被推荐的</h1><div class="nn no gp gr np nq"><a href="https://pavan1999-kumar.medium.com/policies-as-code-in-kubernetes-using-jspolicy-8d358d064bfd" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">使用jsPolicy在Kubernetes中将策略作为代码</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用jsPolicy在Kubernetes中进行开发</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">pavan1999-kumar.medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe my nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://medium.com/nerd-for-tech/mlops-machine-learning-pipelines-using-kubeflow-fc06508a3f0d" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">MlOps:使用kubeflow的机器学习管道</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用Kubeflow对Kubernetes进行有效的MLOps</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="of l ob oc od nz oe my nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://pavan1999-kumar.medium.com/hashicvault-secrets-in-kubernetes-with-csi-driver-ec917d4a2672" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">与CSI司机在Kubernetes哈希克沃特秘密</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用Vault CSI驱动程序向Kubernetes Pods注入秘密</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">pavan1999-kumar.medium.com</p></div></div><div class="nz l"><div class="og l ob oc od nz oe my nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://medium.com/nerd-for-tech/terraforming-the-gitops-way-9417cf4abf58" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">地球化吉托普斯之路！！！</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用Atlantis(拉式请求自动化)通过GitOps建立Terraform。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oh l ob oc od nz oe my nq"/></div></div></a></div></div></div>    
</body>
</html>