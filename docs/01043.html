<html>
<head>
<title>Managing State in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中管理状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-state-in-android-f4d042646521?source=collection_archive---------1-----------------------#2019-10-28">https://levelup.gitconnected.com/managing-state-in-android-f4d042646521?source=collection_archive---------1-----------------------#2019-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="db76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态管理可能是Android开发中最复杂的挑战之一。状态管理的复杂性背后的原因与Android架构紧密相关，为了提出解决方案，需要理解一些基本的Android设计决策。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/3c00204fdc4128a2982a69c59bb460b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*vR2enPM-j79iL4TcAz-CnQ.png"/></div></figure><h1 id="6b2a" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">以演示为中心</h1><p id="56b3" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">自从2011年我在Android开发者网站上读到第一篇文档以来，例子总是集中在活动中。该活动被描述为每个Android应用程序的基本起点。在<a class="ae lw" href="http://It is really funny to see Reto Meier talking about" rel="noopener ugc nofollow" target="_blank"> Google I/O 2018 </a>中，烈斗·梅尔概述了谷歌多年来提出的关于如何使用活动管理状态的不同方法。</p><p id="c8d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">活动的问题总是在于它的生命周期。让<strong class="jp ir">配置改变</strong>销毁活动的决定使得管理状态变得非常困难，特别是当工作线程被触发以获取数据时。同样，在活动中集中发展的想法，基本上意味着在<strong class="jp ir">展示</strong>中集中发展，而不是集中在<strong class="jp ir">领域</strong>中，那里应该是大部分逻辑。</p><h2 id="b2c9" class="lx ku iq bd kv ly lz dn kz ma mb dp ld jy mc md lh kc me mf ll kg mg mh lp mi bi translated">内存泄漏</h2><p id="dc38" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">销毁活动意味着销毁活动实例，并使其符合垃圾收集的条件。问题是我们倾向于保留对活动的引用，特别是那些我们用来获取数据的工作线程，这最终会产生<strong class="jp ir">内存泄漏</strong>。当一个活动线程引用一个对象(在本例中是我们的活动)时，<a class="ae lw" href="https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm#JSGCT-GUID-8A443184-7E07-4B71-9777-4F12947C8184" rel="noopener ugc nofollow" target="_blank">垃圾收集器</a>不能收集它。因为活动引用了视图层次结构，所以所有视图也保存在内存中。</p><p id="1488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工作线程可以使用<a class="ae lw" href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html" rel="noopener ugc nofollow" target="_blank">弱引用</a>来保存活动实例，或者可以在onDestroy中清除强引用以避免内存泄漏。此外，可以使用<a class="ae lw" href="https://developer.android.com/reference/android/app/Activity#onRetainNonConfigurationInstance()" rel="noopener ugc nofollow" target="_blank">onRetainNonConfigurationInstance</a>保存对工作线程的引用，并在使用<a class="ae lw" href="https://developer.android.com/reference/android/app/Activity.html#getLastNonConfigurationInstance()" rel="noopener ugc nofollow" target="_blank">getlastonconfigurationinstance</a>重新创建活动时进行检索。这种策略还要求工作线程将结果缓存在内存中，一旦设置了新的引用，就将结果返回给活动，以防它在活动重新创建期间结束。太复杂了，不是吗？</p><p id="e27f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当配置发生变化时，应该销毁活动的视图层次结构，而不是它的实例。但是按照设计，活动生命周期只有<strong class="jp ir"> onCreate </strong>和<strong class="jp ir"> onDestroy </strong>回调，视图层次结构和活动实例本身没有区别。</p><h2 id="62ad" class="lx ku iq bd kv ly lz dn kz ma mb dp ld jy mc md lh kc me mf ll kg mg mh lp mi bi translated">碎片</h2><p id="903e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Fragments试图通过引入onCreateView和onDestroyView以及使用<a class="ae lw" href="https://developer.android.com/reference/android/app/Fragment#setRetainInstance(boolean)" rel="noopener ugc nofollow" target="_blank"> setRetainInstance </a>方法来解决这个问题。有了片段，视图生命周期和片段生命周期之间就有了清晰的分离。然而，当片段被销毁时，我们会遇到与活动相同的问题。</p><h1 id="d585" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">转向以领域为中心</h1><p id="7dd5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Google曾多次尝试解决上述线程和状态问题。从Activity<a class="ae lw" href="https://developer.android.com/reference/android/app/Activity#onRetainNonConfigurationInstance()" rel="noopener ugc nofollow" target="_blank">onRetainNonConfigurationInstance</a>，Fragment<a class="ae lw" href="https://developer.android.com/reference/androidx/fragment/app/Fragment.html#setRetainInstance(boolean)" rel="noopener ugc nofollow" target="_blank">setRetainInstance</a>，<a class="ae lw" href="https://developer.android.com/guide/components/loaders" rel="noopener ugc nofollow" target="_blank"> Loaders </a>到Jetpack <a class="ae lw" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank"> ViewModel </a>。不要误解我，所有这些解决方案“工作”，他们只是很难理解和容易出错。</p><p id="a45e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，所有这些方法都是试图继续关注<strong class="jp ir">演示</strong>。所有这些解决方案最终都造成了意外的复杂性，而不是让开发人员了解Android应用程序的生命周期。</p><h2 id="5e10" class="lx ku iq bd kv ly lz dn kz ma mb dp ld jy mc md lh kc me mf ll kg mg mh lp mi bi translated">Android生命周期</h2><p id="25fe" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">所有五个Android组件:<a class="ae lw" href="https://developer.android.com/reference/android/content/BroadcastReceiver" rel="noopener ugc nofollow" target="_blank"> BroadcastReceiver </a>、<a class="ae lw" href="https://developer.android.com/reference/android/app/Service?hl=en" rel="noopener ugc nofollow" target="_blank"> Service </a>、<a class="ae lw" href="https://developer.android.com/reference/android/app/Activity?hl=en" rel="noopener ugc nofollow" target="_blank"> Activity </a>、<a class="ae lw" href="https://developer.android.com/reference/android/content/ContentProvider?hl=en" rel="noopener ugc nofollow" target="_blank"> ContentProvider </a>和<a class="ae lw" href="https://developer.android.com/reference/android/app/Application?hl=en" rel="noopener ugc nofollow" target="_blank"> Application </a>都有自己的生命周期。我将把重点放在活动和应用程序生命周期上，因为通过理解它们的区别，我们可以解决我们一直在谈论的问题。</p><blockquote class="mj mk ml"><p id="c4d3" class="jn jo mm jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">Application onCreate方法是Android应用程序的入口点。OnCreate是操作系统向应用程序发出信号的方式，表明其流程已准备就绪，可以开始处理业务逻辑了。</p></blockquote><p id="2a02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然活动将在流程的整个生命周期中被创建和销毁，但应用程序onCreate只被调用一次。更重要的是，应用程序实例在流程中是唯一的，因此与应用程序实例相关联的对象实例不受GUI流程的影响(例如，导航或配置更改)。</p><p id="84ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过理解应用程序相对于其他组件的特殊生命周期，可以将协调线程和业务逻辑的对象与应用程序生命周期相关联。这种方法使得线程和业务逻辑与活动(GUI)生命周期无关。</p><h2 id="e7a1" class="lx ku iq bd kv ly lz dn kz ma mb dp ld jy mc md lh kc me mf ll kg mg mh lp mi bi translated">封装状态</h2><p id="8570" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">一旦我们理解了应用程序对象与活动生命周期无关，我们就可以将<strong class="jp ir">状态</strong>和<strong class="jp ir">状态管理</strong>封装在一个对象中，并将其与应用程序实例相关联。我所说的状态是指描述应用程序当前状态的对象。我所说的状态管理是指从一种状态到另一种状态的转换。我们可以将状态和状态管理封装在一个对象中，并将其称为一个<strong class="jp ir">状态机</strong>。</p><p id="5481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，电子商务应用程序有一个显示用户订单的屏幕。对于那个应用程序，我们可以有一个带有<strong class="jp ir"> loadOrders </strong>方法的<strong class="jp ir"> OrderStateMachine </strong>类。还可以创建描述<strong class="jp ir">订单</strong>的数据类。在这种情况下，OrderStateMachine负责状态管理，列表&lt; Order &gt;代表状态。</p><p id="4c81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">控制流将从一个GUI事件的活动或片段开始，例如点击一个名为See Orders的按钮。该事件处理程序将调用OrderStateMachine loadOrders方法并导航到OrderListActivity(或片段)以显示订单。loadOrders不是基于OrderListActivity生命周期调用的，而是基于GUI中的一个显式事件。否则，当配置发生变化时，或者基于导航，我们将最终调用loadOrders。使用onCreate回调来触发用例是一种常见的方法，但是它会导致副作用，需要在我们的领域中根据表示细节进行更改。</p><p id="4488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，OrderListActivity将使用<strong class="jp ir"> OrderStateMachine </strong>注册一个回调，以呈现列表&lt;订单&gt;状态。这种方法很有意思，因为我们状态的任何变化都会反映在OrderListActivity中，即使是基于推送通知或不同活动或片段中的用户操作来执行。由于所有的更改都是由<strong class="jp ir"> OrderStateMachine </strong>控制的，所以它们发生在哪里以及为什么发生并不重要。</p><p id="fd07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了向活动或片段提供OrderStateMachine实例，可以使用<strong class="jp ir">依赖注入</strong>框架，或者应用实例可以作为依赖管理器工作。例如，我们可以有一个<strong class="jp ir"> ECommerceApplication </strong>，它包含Application的子类，并有一个getOrderStateMachine方法，因此通过应用程序上下文的简单转换，活动可以获得OrderStateMachine实例。</p><h2 id="d3fa" class="lx ku iq bd kv ly lz dn kz ma mb dp ld jy mc md lh kc me mf ll kg mg mh lp mi bi translated">分割域</h2><p id="8ceb" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在我们的例子中，除了OrderStateMachine之外，我们还有一个UserStateMachine来控制登录/注销。我们如何在不同的状态机类中分割我们的域应该由封装和顺序性来决定。</p><p id="da23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个方面是错误和加载状态。为了简单起见，在前面的例子中我省略了那些状态，但是它们可以封装在一个State <t>类中，该类可以是<strong class="jp ir">空闲</strong>、<strong class="jp ir">加载</strong>、<strong class="jp ir">错误</strong>或<strong class="jp ir">加载</strong>。在我们的OrderStateMachine中，我们会有一个State&lt;List&lt;Order&gt;&gt;，当调用loadOrders时，它会首先发出Loading和afterwords Loaded或Error。</t></p><p id="88e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有第二个取消订单的用例。在这种情况下，OrderStateMachine将有一个cancelOrder方法，但注意应该调用第一个loadOrders。用例是连续的，因为在装载订单之前不可能取消订单。事实上，OrderStateMachine将一直处于错误状态，直到订单加载成功。</p><p id="27a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们比较UserStateMachine注销方法和OrderStateMachine cancelOrder方法时，情况并非如此。用户可以点击取消订单按钮，并在操作完成前点击注销按钮。这种竞争情况是自然的，没有预期的顺序，因此用例可以在两个状态机之间分开。此外，当订单取消失败并且OrderStateMachine转换到错误状态时，我们仍然希望用户能够注销。</p><h2 id="0901" class="lx ku iq bd kv ly lz dn kz ma mb dp ld jy mc md lh kc me mf ll kg mg mh lp mi bi translated">内存中状态</h2><p id="f9fa" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">大多数应用程序依赖于存储在持久层(共享首选项、SQLite或文件系统)中的数据，或者由服务器通过Web服务公开的数据。这是应用程序的重要部分，通常被称为<strong class="jp ir">数据</strong>层。</p><p id="ba95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然<strong class="jp ir">数据</strong>层很重要，其实现细节会对应用程序的性能产生很大影响，但是<strong class="jp ir">域</strong>不应该知道它们。开发者决定为Shared Preferences更改SQLite或为GraphQL更改REST的事实不应该影响到<strong class="jp ir">域</strong>。为了抽象<strong class="jp ir">数据</strong>实现细节，可以使用一个接口(例如UserGateway)，该接口可以使用SQLite或HTTP来实现。</p><p id="9e30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序中的一个常见错误是将数据库的角色集中化，并将其用作不同类之间的通信渠道。如果UserStateMachine和OrderStateMachine需要共享数据，它们应该通过显式关系(例如回调)来实现。使用内存中的数据，如果数据过期，则由<strong class="jp ir">域</strong>负责与<strong class="jp ir">数据</strong>层交互以进行更新。例如，如果OrderStateMachine依赖于用户数据，它不应该与UserGateway对话，而是依赖于UserStateMachine回调。这样OrderStateMachine就不会受到UserGateway更改的影响，这些更改只由UserStateMachine处理。</p><p id="95a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些概念与微服务概念非常相似，其中每个服务都有自己的数据库，通信是通过HTTP或事件系统完成的。目标是让服务，或者在我们的例子中，状态机彼此解耦，并且不知道彼此的实现细节。</p><h2 id="dbee" class="lx ku iq bd kv ly lz dn kz ma mb dp ld jy mc md lh kc me mf ll kg mg mh lp mi bi translated">共享状态</h2><p id="18b1" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">有时，用例的触发并不直接与GUI事件或外部事件(如推送通知)相关，而是与应用程序中不同状态机的转换相关。例如UserStateMachine登录用例，可能触发装载订单用例。</p><p id="c017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，OrderStateMachine可以简单地向UserStateMachine注册一个回调，当用户状态通信时，用户登录，可以触发加载命令。这种方法很有趣，因为用例之间的关系与<strong class="jp ir">表示</strong>(例如，从登录屏幕导航到订单屏幕)或<strong class="jp ir">数据</strong>层没有关联。在描述用例的<strong class="jp ir">域</strong>中有一个明确的关系，数据和表示细节的变化不会影响它。</p><p id="b7ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得我们可以在本地JVM中测试用例，而不考虑GUI、数据库或Web服务，甚至不考虑Android SDK(我在这个<a class="ae lw" href="https://engineering.talkdesk.com/android-testing-strategy-73269539c13d" rel="noopener ugc nofollow" target="_blank">帖子</a>中对此进行了深入的描述)。</p><h1 id="52fc" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="fc6b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如果整个应用程序是用状态机建模的，那么应用程序的Android层就变得简单了。此外，整个业务逻辑封装在状态机及其关系中，允许应用程序中的用户关键路径与GUI、数据库或Web服务隔离开来进行测试。最后，这种方法维护了一个清晰的可伸缩的架构，并分离了表示层、域层和数据层。</p><h1 id="f7ac" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">参考</h1><ul class=""><li id="208b" class="mq mr iq jp b jq lr ju ls jy ms kc mt kg mu kk mv mw mx my bi translated">杰克·沃顿用RxJava管理状态</li><li id="b892" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae lw" href="https://engineering.talkdesk.com/android-testing-strategy-73269539c13d" rel="noopener ugc nofollow" target="_blank">Marcelo Benites的Android测试策略</a></li><li id="4b0f" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated"><a class="ae lw" href="https://github.com/marcelorbenites/android-testing-strategy/tree/master/app/src/main/java/com/droidcon" rel="noopener ugc nofollow" target="_blank">Marcelo Benites的状态机GitHub示例</a></li></ul></div></div>    
</body>
</html>