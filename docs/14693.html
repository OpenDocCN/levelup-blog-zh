<html>
<head>
<title>Defining Structs in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中定义结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/defining-structs-in-go-49c17fa26196?source=collection_archive---------3-----------------------#2022-12-17">https://levelup.gitconnected.com/defining-structs-in-go-49c17fa26196?source=collection_archive---------3-----------------------#2022-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="59ce" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">最终的旅行</h2><div class=""/><p id="8bf6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">Go的<em class="kx">结构</em>是字段的类型集合。它们对于将数据组合在一起形成记录很有用。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/8d27e10bc6200e706a9d9a6c4df26b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8H5-Fe4xmlinbZqD"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">加布里埃拉·克莱尔·马里诺在<a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="cdf7" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">基础知识:</h1><p id="15cb" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">Go的结构是字段的类型集合。它们对于将数据组合在一起形成记录很有用。在面向对象编程范例中，结构可以与类相比较。假设struct是一个声明其属性age和name的雇员。</p><p id="9d24" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">一个结构可以有相同或不同数据类型的不同字段。例如，Tom是一种雇员类型(结构类型),其属性/字段为firstName、lastName和salary。</p><h1 id="a00c" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">定义&amp;创建结构:</strong></h1><p id="7a76" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">要创建一个结构，它需要一个描述该结构包含的字段的蓝图，定义以关键字<code class="fe ms mt mu mv b">type</code>开始，后跟结构的名称。在这之后，<code class="fe ms mt mu mv b">struct</code>关键字后跟一对大括号<code class="fe ms mt mu mv b">{}</code>，在这里声明该结构将包含的字段。</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="2c37" class="na lq it mv b be nb nc l nd ne">type StructName struct {<br/>    field fieldType<br/>}</span></pre><p id="2789" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">一旦定义了结构，就可以声明使用该结构定义的变量。此示例定义并使用了一个结构:</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="d7b2" class="na lq it mv b be nb nc l nd ne">package main<br/><br/>import "fmt"<br/><br/>type Employee struct {<br/>    FirstName string<br/>    LasttName string<br/>    Salary int<br/>}<br/><br/>func main() {<br/>	var e := Employee{<br/>		FirstName: "Tommy",<br/>	}<br/>	fmt.Println(e.FirstName)<br/>}<br/><br/>output<br/>Tommy</span></pre><p id="2b2a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们首先在这个例子中定义一个<code class="fe ms mt mu mv b">Employee</code>结构，包含一个<code class="fe ms mt mu mv b">string</code>类型的<code class="fe ms mt mu mv b">FirstName</code>字段。在<code class="fe ms mt mu mv b">main</code>的主体中，我们通过在类型名称<code class="fe ms mt mu mv b">Employee</code>后放置一对括号来创建<code class="fe ms mt mu mv b">Employee</code>的实例，然后为该实例的字段指定值。<code class="fe ms mt mu mv b">e</code>中的实例将把它的<code class="fe ms mt mu mv b">FirstName</code>字段设置为“Tommy”。在<code class="fe ms mt mu mv b">fmt.Println</code>函数调用中，我们检索实例字段的值，方法是在创建实例的变量后加一个句点，后跟我们想要访问的字段的名称。例如，本例中的<code class="fe ms mt mu mv b">e.FirstName</code>返回<code class="fe ms mt mu mv b">FirstName</code>字段。</p><blockquote class="nf ng nh"><p id="4859" class="jz ka kx kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw im bi translated">💡<em class="it">使用上述语法创建struct时，</em> <strong class="kb jd"> <em class="it">逗号</em> </strong> <em class="it">(，)在最后一个字段赋值后很重要。</em></p></blockquote><h1 id="107f" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">替代方法</strong></h1><p id="03c2" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">我们也可以如下定义结构</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="6c85" class="na lq it mv b be nb nc l nd ne">package main<br/><br/>import "fmt"<br/>type Employee struct {<br/>    FirstName string<br/>    LasttName string<br/>    Salary int<br/>}<br/>func main() {<br/>    var e Employee<br/>    e.FirstName = "Tommy"<br/>    fmt.Println(e.FirstName)<br/>}<br/>Output<br/>Tommy</span></pre><p id="760d" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">首先我们声明一个类型为<code class="fe ms mt mu mv b">Employee</code>的变量<code class="fe ms mt mu mv b">e</code>,它现在将保存结构的零值。(如果你喜欢阅读，这是一份了解零价值的好材料:<a class="ae lo" href="https://dave.cheney.net/2013/01/19/what-is-the-zero-value-and-why-is-it-useful" rel="noopener ugc nofollow" target="_blank">https://Dave . Cheney . net/2013/01/19/什么是零价值以及它为什么有用</a>)</p><h2 id="2296" class="nl lq it bd lr nm nn dn lv no np dp lz kk nq nr md ko ns nt mh ks nu nv ml iz bi translated">getter/setter:</h2><p id="e77c" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">获取和设置struct字段非常简单。当一个结构变量被创建时，我们可以使用<code class="fe ms mt mu mv b">.</code> ( <em class="kx">点</em>)操作符来访问它的字段。</p><p id="034f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上面的程序中，我们创建了一个有3个字段的结构<code class="fe ms mt mu mv b">e</code>。要给字段<code class="fe ms mt mu mv b">FirstName</code>赋值，需要使用语法<code class="fe ms mt mu mv b">e.FirstName = "Tommy"</code>。<code class="fe ms mt mu mv b">e</code>中的实例将把它的<code class="fe ms mt mu mv b">FirstName</code>字段设置为“Tommy”。在<code class="fe ms mt mu mv b">fmt.Println</code>函数调用中，我们检索实例字段的值，方法是在创建实例的变量后加一个句点，后跟我们想要访问的字段的名称。例如，本例中的<code class="fe ms mt mu mv b">e.FirstName</code>返回<code class="fe ms mt mu mv b">FirstName</code>字段。</p><h1 id="5818" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">内嵌结构</h1><p id="82cb" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">除了定义一个新的类型来表示一个结构，还可以定义一个内联结构。这些动态结构定义在结构的作用域超出了它所操作的函数的情况下是有用的。例如，测试通常使用结构来定义组成特定测试用例的所有参数。当你看不到结构体在多个地方被使用时，管理结构体将会很乏味。</p><p id="d830" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">内联结构定义出现在变量赋值的右侧。实例化必须通过为您定义的每个字段提供一对额外的大括号来立即发生。下面的示例显示了内联结构定义:</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="bf54" class="na lq it mv b be nb nc l nd ne">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>	e := struct {<br/>		FirstName string<br/>		LastName string<br/>	}{<br/>		FirstName: "Tommy",<br/>		LastName: "Aberdeen",<br/>	}<br/>	fmt.Println(e.FirstName, ",", e.LastName)<br/>}<br/><br/>Output<br/>Tommy,Aberdeen</span></pre><p id="435b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这个例子没有用关键字<code class="fe ms mt mu mv b">type</code>定义一个描述我们的结构的新类型，而是通过将<code class="fe ms mt mu mv b">struct</code>定义放在短赋值操作符<code class="fe ms mt mu mv b">:=</code>之后来定义一个内联结构。我们定义结构的字段。您最常看到内联结构声明的地方是在测试期间，因为通常一次性结构被定义为包含特定测试用例的数据和期望。</p><h1 id="ddcf" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">指向结构的指针</h1><p id="7164" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">我们可以不用创建一个结构体，而是用一条语句创建一个指向结构体值的指针。</p><p id="8682" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">创建指向结构的指针的语法如下。</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="ca70" class="na lq it mv b be nb nc l nd ne">e := &amp;StructType{...}</span></pre><p id="45a8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">让我们创建一个指向结构值的指针<code class="fe ms mt mu mv b">tommy</code>。</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="3b41" class="na lq it mv b be nb nc l nd ne">package main<br/><br/>import "fmt"<br/><br/>type Employee struct {<br/>    FirstName string<br/>    LasttName string<br/>    Salary int<br/>}<br/><br/>func main() {<br/>	e := &amp;Employee {<br/>		FirstName: "Tommy"<br/>		LastName: "Aberdeen"<br/>	}<br/>	fmt.Println("First name", (*e).FirstName)<br/>}<br/><br/>Output<br/>Tommy</span></pre><p id="45e7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上面的程序中，由于eis是一个指针，我们需要使用<code class="fe ms mt mu mv b">*e</code> <strong class="kb jd">解引用语法</strong>来获取它所指向的结构的实际值，并使用<code class="fe ms mt mu mv b">(*e).FirstName</code>来访问该结构值的<code class="fe ms mt mu mv b">FirstName</code>。</p><p id="a152" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">Go还提供了另一种访问字段<strong class="kb jd">的语法，无需先解引用字段</strong>，如下所示</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="bd6b" class="na lq it mv b be nb nc l nd ne">e := &amp;Employee {<br/>  FirstName: "Tommy"<br/>  LastName: "Aberdeen"<br/> }<br/> fmt.Println("First name", e.FirstName) // e is a pointer</span></pre><h1 id="25b0" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">嵌套结构</h1><p id="b0a6" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">结构字段可以是任何数据类型。因此，我们可以用一个结构字段保存另一个结构。当结构字段具有结构值时，该结构值称为嵌套结构，因为它嵌套在父结构内。</p><p id="fe9a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated"><strong class="kb jd">例如:</strong></p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="a811" class="na lq it mv b be nb nc l nd ne">package main<br/><br/>import "fmt"<br/><br/>type Salary struct {<br/>    TravelAllowance int<br/>    OvertimeAmount int<br/>    Base int<br/>}<br/><br/>type Employee struct {<br/>    FirstName string<br/>    LasttName string<br/>    Salary Salary<br/>}<br/><br/>func main() {<br/>	e := Employee {<br/>		FirstName: "Tommy"<br/>		LastName: "Aberdeen"<br/>                Salary:   Salary{100, 10, 10}<br/>	}<br/>	fmt.Println("employee e firstname : ", e.FirstName)<br/>        fmt.Println("employee e travel allowance: ", e.Salart.TravelAllowance)<br/>}</span></pre><p id="a549" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上面的例子中，我们创建了一个新的结构类型<code class="fe ms mt mu mv b">Salary</code>，它定义了一个雇员的薪水。然后，我们修改了<code class="fe ms mt mu mv b">Employee</code> struct类型的<code class="fe ms mt mu mv b">salary</code>字段，该字段现在保存类型<code class="fe ms mt mu mv b">Salary</code>的值。</p><p id="2987" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">当创建类型为<code class="fe ms mt mu mv b">Employee</code>的<code class="fe ms mt mu mv b">e</code>结构时，我们初始化了所有字段。由于<code class="fe ms mt mu mv b">salary</code>字段保存了类型<code class="fe ms mt mu mv b">Salary</code>的结构，我们在初始化<code class="fe ms mt mu mv b">salary</code>结构时使用了一种排除字段名的简单方法给它分配了结构值。</p><p id="f582" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">通常，你会使用<code class="fe ms mt mu mv b">struct.field</code>语法访问一个结构的字段，就像我们之前看到的那样。您可以用与返回一个<strong class="kb jd">结构</strong>的<code class="fe ms mt mu mv b">e.Salary</code>相同的方式访问<code class="fe ms mt mu mv b">salary</code>字段。然后，您可以使用相同的方法访问这个<strong class="kb jd">嵌套结构</strong>的字段(<em class="kx">或更新</em>)，例如，<code class="fe ms mt mu mv b">ross.Salary.TravelAllowance</code></p><h1 id="4d50" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">嵌套结构—匿名:</strong></h1><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="5b84" class="na lq it mv b be nb nc l nd ne">type Config struct {<br/>    Server struct {<br/>        Host string `json:"host"`<br/>        Port string `json:"port"`<br/>    } `json:"server"`<br/>    Postgres struct {<br/>        Host     string `json:"host"`<br/>        User     string `json:"user"`<br/>        Password string `json:"password"`<br/>        DB       string `json:"db"`<br/>    } `json:"postgres"`<br/>}</span></pre><p id="ac81" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">基本上，我们可以通过使用嵌套的匿名结构将3个<code class="fe ms mt mu mv b">Config</code>、<code class="fe ms mt mu mv b">Server</code>和<code class="fe ms mt mu mv b">Postgres</code>结构声明为单一类型，而不是声明它们:</p><h1 id="978b" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">导出的字段</h1><p id="7e1c" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">任何以大写字母开头的变量或类型都会从该包中导出。比如<code class="fe ms mt mu mv b">Employee</code>、<code class="fe ms mt mu mv b">Salary</code></p><p id="9c3c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们还可以控制导出结构的哪些字段在包外可见(<em class="kx">或导出的</em>)。要导出一个结构的字段名，我们必须遵循同样的<strong class="kb jd">大写字母</strong>方法。</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="5d61" class="na lq it mv b be nb nc l nd ne">type Config struct {<br/>    Server struct {<br/>        Host string `json:"host"`<br/>        port string `json:"port"`<br/>    } `json:"server"`<br/>    Postgres struct {<br/>        Host     string `json:"host"`<br/>        User     string `json:"user"`<br/>        password string `json:"password"`<br/>        DB       string `json:"db"`<br/>    } `json:"postgres"`<br/>}</span></pre><p id="c0db" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">在上面的结构中，只有<code class="fe ms mt mu mv b">Host</code> <code class="fe ms mt mu mv b">User</code>和<code class="fe ms mt mu mv b">DB</code>被导出到外部包</p><h1 id="940b" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结构比较</h1><p id="831c" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">如果两个结构属于同一类型并具有相同的字段值，则它们是可比较的。</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="d5a6" class="na lq it mv b be nb nc l nd ne">package main<br/><br/>import "fmt"<br/><br/>type Salary struct {<br/>    TravelAllowance int<br/>    OvertimeAmount int<br/>    Base int<br/>}<br/><br/>type Employee struct {<br/>    FirstName string<br/>    LasttName string<br/>    Salary Salary<br/>}<br/><br/>func main() {<br/>	Tommy := Employee {<br/>		FirstName: "Tommy"<br/>		LastName: "Aberdeen"<br/>                Salary:   Salary{100, 10, 10}<br/>	}<br/>        Sammy := Employee {<br/>          FirstName: "Sammy"<br/>          LastName: "Nottingham"<br/>                        Salary:   Salary{100, 10, 10}<br/>         }<br/>	fmt.Println(Tommy == Sammy)<br/>}</span></pre><p id="4b27" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">上面的程序打印了<code class="fe ms mt mu mv b">false</code>因为<code class="fe ms mt mu mv b">To</code>和<code class="fe ms mt mu mv b">Sammy</code>属于相同的结构类型<code class="fe ms mt mu mv b">Employee</code>但是有不同的字段名，你可以试着让所有的字段名都相同并进行比较，它将打印<code class="fe ms mt mu mv b">true</code></p><p id="a935" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">但是，如果一个结构有可以比较的<strong class="kb jd">映射</strong>字段类型，例如不可比较的<strong class="kb jd">映射</strong>，那么这个结构就不可比较。</p><p id="d679" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">例如，如果<code class="fe ms mt mu mv b">Employee</code>结构类型有一个数据类型为<code class="fe ms mt mu mv b">map</code>的<code class="fe ms mt mu mv b">leaves</code>字段，我们就不能进行上面的比较。</p><pre class="kz la lb lc gt mw mv mx bn my mz bi"><span id="6030" class="na lq it mv b be nb nc l nd ne">type Employee struct {<br/>    FirstName string<br/>    LasttName string<br/>    SubjectEnrolled map[int]string<br/>}</span></pre><h1 id="52e5" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="858f" class="pw-post-body-paragraph jz ka it kb b kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw im bi translated">结构是用于组织信息的数据集合。当程序处理大量数据并具有结构时，将哪些<code class="fe ms mt mu mv b">string</code>或<code class="fe ms mt mu mv b">int</code>变量属于一起或哪些不同变得更容易。下一次，如果你发现自己在处理多组变量，问问自己是否可以使用<code class="fe ms mt mu mv b">struct</code>将这些变量更好地组合在一起。那些变量可能一直在描述一个对象类型。</p></div></div>    
</body>
</html>