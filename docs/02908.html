<html>
<head>
<title>Yet another TODO app! With Redis and Go [Part 2]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">又一个TODO应用！使用Redis和Go[第2部分]</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/yet-another-todo-app-with-redis-and-go-part-2-326379d94d8b?source=collection_archive---------21-----------------------#2020-04-09">https://levelup.gitconnected.com/yet-another-todo-app-with-redis-and-go-part-2-326379d94d8b?source=collection_archive---------21-----------------------#2020-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6c823752cdb04ec65c33d98f8d95cf96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uj9HTyAgCsGh0Ikj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">劳伦·索德在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e65d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是博客系列的第二部分(也是最后一部分),在一个简单而实用的<strong class="kf ir"> todo应用</strong>的帮助下，涵盖了一些Redis数据结构😉使用<code class="fe lb lc ld le b"><a class="ae kc" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">Go</a></code> <code class="fe lb lc ld le b"><a class="ae kc" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank">cobra</a></code>(一个流行的CLI应用程序库)和<code class="fe lb lc ld le b">Redis</code>作为后端存储构建。</p><div class="lf lg gp gr lh li"><a href="https://medium.com/@abhishek1987/yet-another-todo-app-with-redis-and-go-part-1-7a1134f5752e" rel="noopener follow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd ir gy z fp ln fr fs lo fu fw ip bi translated">又一个TODO应用！使用Redis和Go[第1部分]</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">通过使用Go构建CLI应用程序来学习Redis</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">medium.com</p></div></div></div></a></div><p id="2de9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Part 1</code>介绍了<code class="fe lb lc ld le b">todo</code>应用的概述、设置和试用过程。在这一部分，我们将深入了解代码</p><blockquote class="lr ls lt"><p id="7279" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">代码为</em> <a class="ae kc" href="https://github.com/abhirockzz/redis-todo-cli-app" rel="noopener ugc nofollow" target="_blank"> <em class="iq">可在Github </em> </a>上获得</p></blockquote><p id="1581" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，先回顾一下您可以用<code class="fe lb lc ld le b">todo</code> CLI做些什么——好的，老的<code class="fe lb lc ld le b">CRUD</code>！来自<code class="fe lb lc ld le b">todo --help</code>:</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="0bdc" class="mg mh iq le b gy mi mj l mk ml">Yet another TODO app. Uses Go and Redis</span><span id="7960" class="mg mh iq le b gy mm mj l mk ml">Usage:<br/>  todo [command]</span><span id="7480" class="mg mh iq le b gy mm mj l mk ml">Available Commands:<br/>  create      create a todo with description<br/>  delete      delete a todo<br/>  help        Help about any command<br/>  list        list all todos<br/>  update      update todo description, status or both</span><span id="a06f" class="mg mh iq le b gy mm mj l mk ml">Flags:<br/>  -h, --help      help for todo<br/>  -v, --version   version for todo</span><span id="dba1" class="mg mh iq le b gy mm mj l mk ml">Use "todo [command] --help" for more information about a command.</span></pre><p id="4908" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b"><a class="ae kc" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank">Cobra</a></code>用作CLI框架。这是一个受欢迎的项目，并支持CLI工具，如<code class="fe lb lc ld le b">docker</code>、<code class="fe lb lc ld le b">kubectl</code>等。</p><p id="381a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码结构如下所示:</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="4304" class="mg mh iq le b gy mi mj l mk ml">.<br/>├── cmd<br/>│   ├── create.go<br/>│   ├── delete.go<br/>│   ├── list.go<br/>│   ├── root.go<br/>│   └── update.go<br/>├── db<br/>│   └── todo-redis.go<br/>├── go.mod<br/>├── go.sum<br/>└── main.go</span></pre><p id="3b37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个<code class="fe lb lc ld le b">todo</code>操作(<code class="fe lb lc ld le b">create</code>、<code class="fe lb lc ld le b">list</code>等)。)由一个<code class="fe lb lc ld le b">cobra</code>命令控制。<code class="fe lb lc ld le b">cmd</code>包包含<code class="fe lb lc ld le b">create.go</code>、<code class="fe lb lc ld le b">list.go</code>等实现。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="0875" class="mu mh iq bd mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq bi translated"><code class="fe lb lc ld le b">root</code>命令</h1><p id="2b99" class="pw-post-body-paragraph kd ke iq kf b kg nr ki kj kk ns km kn ko nt kq kr ks nu ku kv kw nv ky kz la ij bi translated">在<code class="fe lb lc ld le b">cobra</code>中，根命令是最顶层的父命令。可以向其中添加其他子命令。在本例中，<code class="fe lb lc ld le b">todo</code>是根命令和<code class="fe lb lc ld le b">create</code>、<code class="fe lb lc ld le b">list</code>等。是子命令(同样，每个命令可以有一个或多个在调用期间传递的标志)</p><p id="2fb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">todo</code>根命令在<code class="fe lb lc ld le b">cmd/root.go</code>中定义</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="7ab1" class="mg mh iq le b gy mi mj l mk ml">var rootCmd = &amp;cobra.Command{Use: "todo", Short: "manage your todos", Version: "0.1.0"}</span></pre><p id="9997" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，它没有任何特定的标志—它只有子命令。让我们看看他们</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="d00c" class="mu mh iq bd mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq bi translated">子命令— <code class="fe lb lc ld le b">create</code>、<code class="fe lb lc ld le b">list</code>、<code class="fe lb lc ld le b">update</code>、<code class="fe lb lc ld le b">delete</code></h1><p id="00c7" class="pw-post-body-paragraph kd ke iq kf b kg nr ki kj kk ns km kn ko nt kq kr ks nu ku kv kw nv ky kz la ij bi translated">子命令实现逻辑遵循相同的模式:</p><ul class=""><li id="15a8" class="nw nx iq kf b kg kh kk kl ko ny ks nz kw oa la ob oc od oe bi translated">使用<code class="fe lb lc ld le b">init()</code>函数引导命令-设置其标志，标记强制标志(如果需要)并将其添加到根命令</li><li id="f387" class="nw nx iq kf b kg of kk og ko oh ks oi kw oj la ob oc od oe bi translated">定义执行逻辑/功能——在我们的例子中，是与<code class="fe lb lc ld le b">Redis</code>相关的操作(我们将很快深入其中)</li></ul><p id="85f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe lb lc ld le b">todo create</code>实现的样子(在<code class="fe lb lc ld le b">cmd/create.go</code>中)</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="04f4" class="mg mh iq le b gy mi mj l mk ml">...<br/>var createCmd = &amp;cobra.Command{Use: "create", Short: "create a todo with description", Run: Create}</span><span id="6697" class="mg mh iq le b gy mm mj l mk ml">func init() {<br/>	createCmd.Flags().String("description", "", "create todo with description")<br/>	createCmd.MarkFlagRequired("description")<br/>	rootCmd.AddCommand(createCmd)<br/>}</span><span id="5ccb" class="mg mh iq le b gy mm mj l mk ml">// Create - todo create --description &lt;text&gt;<br/>func Create(cmd *cobra.Command, args []string) {<br/>	desc := cmd.Flag("description").Value.String()<br/>	db.CreateTodo(desc)<br/>}<br/>...</span></pre><p id="e5f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">todo create</code>需要<code class="fe lb lc ld le b">description</code>的强制值，并使用<code class="fe lb lc ld le b">func Create(cmd *cobra.Command, args []string)</code>执行实际的<code class="fe lb lc ld le b">todo</code>创建。调用<code class="fe lb lc ld le b">db.CreateTodo(desc)</code>进行Redis相关操作，将<code class="fe lb lc ld le b">todo</code>信息保存到Redis中。</p><p id="02bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe lb lc ld le b">todo update</code>实现的一个片段(在<code class="fe lb lc ld le b">cmd/update.go</code>中)</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="4b0d" class="mg mh iq le b gy mi mj l mk ml">...<br/>var updateCmd = &amp;cobra.Command{Use: "update", Short: "update todo description, status or both", Run: Update}</span><span id="5b46" class="mg mh iq le b gy mm mj l mk ml">func init() {<br/>	updateCmd.Flags().String("id", "", "id of the todo you want to update")<br/>	updateCmd.MarkFlagRequired("id")<br/>	updateCmd.Flags().String("description", "", "new description")<br/>	updateCmd.Flags().String("status", "", "new status: completed, pending, in-progress")</span><span id="aae6" class="mg mh iq le b gy mm mj l mk ml">	rootCmd.AddCommand(updateCmd)<br/>}</span><span id="42af" class="mg mh iq le b gy mm mj l mk ml">// Update - todo update --id &lt;id&gt; --status &lt;new status&gt; --description &lt;new description&gt;<br/>func Update(cmd *cobra.Command, args []string) {<br/>	id := cmd.Flag("id").Value.String()<br/>	desc := cmd.Flag("description").Value.String()</span><span id="f715" class="mg mh iq le b gy mm mj l mk ml">	status := cmd.Flag("status").Value.String()</span><span id="2b3c" class="mg mh iq le b gy mm mj l mk ml">	if desc == "" &amp;&amp; status == "" {<br/>		log.Fatalf("either description or status is required")<br/>	}</span><span id="11b7" class="mg mh iq le b gy mm mj l mk ml">	if status == "completed" || status == "pending" || status == "in-progress" || status == "" {<br/>		db.UpdateTodo(id, desc, status)<br/>	} else {<br/>		log.Fatalf("provide valid status - completed, pending or in-progress")<br/>	}<br/>}</span></pre><p id="cc85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">todo update</code>需要一个强制<code class="fe lb lc ld le b">--id</code>标志，并且需要提供<code class="fe lb lc ld le b">status</code>或<code class="fe lb lc ld le b">description</code>(可以是两者)。它进一步调用<code class="fe lb lc ld le b">db.UpdateTodo</code>进行Redis相关操作，以更新通过CLI传入的<code class="fe lb lc ld le b">todo</code>信息</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="16e9" class="mu mh iq bd mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq bi translated">雷迪斯</h1><p id="b189" class="pw-post-body-paragraph kd ke iq kf b kg nr ki kj kk ns km kn ko nt kq kr ks nu ku kv kw nv ky kz la ij bi translated">现在，让我们来探索应用程序的核心——Redis相关的逻辑来管理<code class="fe lb lc ld le b">todo</code>信息。Redis操作已集中在一个地方，即<code class="fe lb lc ld le b">db</code>包中的<code class="fe lb lc ld le b">todo-redis.go</code>。它有四个功能，每个功能映射到各自的<code class="fe lb lc ld le b">todo</code>子命令:</p><ul class=""><li id="8743" class="nw nx iq kf b kg kh kk kl ko ny ks nz kw oa la ob oc od oe bi translated"><code class="fe lb lc ld le b">CreateTodo</code></li><li id="e732" class="nw nx iq kf b kg of kk og ko oh ks oi kw oj la ob oc od oe bi translated"><code class="fe lb lc ld le b">ListTodos</code></li><li id="e723" class="nw nx iq kf b kg of kk og ko oh ks oi kw oj la ob oc od oe bi translated"><code class="fe lb lc ld le b">UpdateTodo</code></li><li id="0b3b" class="nw nx iq kf b kg of kk og ko oh ks oi kw oj la ob oc od oe bi translated"><code class="fe lb lc ld le b">DeleteTodo</code></li></ul><p id="62b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用过<code class="fe lb lc ld le b"><a class="ae kc" href="https://github.com/go-redis/redis" rel="noopener ugc nofollow" target="_blank">go-redis</a></code></p><blockquote class="lr ls lt"><p id="3e40" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><code class="fe lb lc ld le b"><a class="ae kc" href="https://github.com/gomodule/redigo" rel="noopener ugc nofollow" target="_blank"><em class="iq">redigo</em></a></code> <em class="iq">是另一个流行的客户端</em></p></blockquote><p id="a4f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的命令都是从连接到<code class="fe lb lc ld le b">Redis</code>开始的(很明显！)</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="968a" class="mg mh iq le b gy mi mj l mk ml">c := redis.NewClient(&amp;redis.Options{Addr: redisHost})<br/>	err := c.Ping().Err()<br/>	if err != nil {<br/>		log.Fatal("redis connect failed", err)<br/>	}<br/>defer c.Close()</span></pre><p id="73d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个单用户<code class="fe lb lc ld le b">cli</code>应用，而不是一个长期运行的服务器组件。因此，我们可以在单独操作后连接和断开，而不是在全球层面处理Redis客户端<code class="fe lb lc ld le b">redis.Client</code>。现在我们来看看每个操作的相关片段</p><p id="d18f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">创建待办事项</strong></p><p id="54cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在Redis中创建一个<code class="fe lb lc ld le b">todo</code>，我们使用一个计数器作为todo <code class="fe lb lc ld le b">id</code>。Redis允许您使用<code class="fe lb lc ld le b">INCR</code>(和相关命令)将<code class="fe lb lc ld le b">String</code>用作原子计数器</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="1b09" class="mg mh iq le b gy mi mj l mk ml">id, err := c.Incr(todoIDCounter).Result()</span></pre><blockquote class="lr ls lt"><p id="86ce" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">检查</em> <code class="fe lb lc ld le b"><em class="iq">INCR</em></code> <em class="iq">命令为参考</em><a class="ae kc" href="https://redis.io/commands/incr" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://redis.io/commands/incr</em></a></p></blockquote><p id="5bdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redis <code class="fe lb lc ld le b">SET</code>中的这个递增ID(前置<code class="fe lb lc ld le b">todo:</code>)。Redis <code class="fe lb lc ld le b">Set</code>是<code class="fe lb lc ld le b">Strings</code>的无序集合，不允许重复。这个<code class="fe lb lc ld le b">id</code>构成了<code class="fe lb lc ld le b">HASH</code>(下一步)的名称，我们将在其中存储<code class="fe lb lc ld le b">todo</code>细节，例如，对于id为42的<code class="fe lb lc ld le b">todo</code>，细节将存储在名为<code class="fe lb lc ld le b">todo:42</code>的<code class="fe lb lc ld le b">HASH</code>中。这使得<code class="fe lb lc ld le b">list</code>、<code class="fe lb lc ld le b">update</code>和<code class="fe lb lc ld le b">delete</code>待办事项变得很容易</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="0ef1" class="mg mh iq le b gy mi mj l mk ml">err = c.SAdd(todoIDsSet, todoid).Err()</span></pre><blockquote class="lr ls lt"><p id="cf40" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">查看</em> <code class="fe lb lc ld le b"><em class="iq">SADD</em></code> <em class="iq">了解详情</em><a class="ae kc" href="https://redis.io/commands/sadd" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://redis.io/commands/sadd</em></a></p></blockquote><p id="bb00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，将<code class="fe lb lc ld le b">todo</code>信息(<code class="fe lb lc ld le b">id</code>、<code class="fe lb lc ld le b">description</code>、<code class="fe lb lc ld le b">status</code>)存储在<code class="fe lb lc ld le b">HASH</code>中。Redis是字符串字段和字符串值之间的映射。在这种情况下，这使得它们适合存储对象表示，如<code class="fe lb lc ld le b">todo</code> info</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="964a" class="mg mh iq le b gy mi mj l mk ml">todo := map[string]interface{}{"desc": desc, "status": statusPending}<br/>err = c.HMSet(todoid, todo).Err()</span></pre><blockquote class="lr ls lt"><p id="a4c6" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">检查</em> <code class="fe lb lc ld le b"><em class="iq">HMSET</em></code> <em class="iq">参考</em><a class="ae kc" href="https://redis.io/commands/hmset" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://redis.io/commands/hmset</em></a></p></blockquote><p id="44cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">列表待办事项</strong></p><p id="c1a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要获取todos，我们只需获取集合中的所有成员，即<code class="fe lb lc ld le b">todo:1</code>、<code class="fe lb lc ld le b">todo:2</code>等。</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="e429" class="mg mh iq le b gy mi mj l mk ml">todoHashNames, err := c.SMembers(todoIDsSet).Result()</span></pre><blockquote class="lr ls lt"><p id="d12a" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">查</em> <code class="fe lb lc ld le b"><em class="iq">SMEMBERS</em></code> <em class="iq">作参考</em><a class="ae kc" href="https://redis.io/commands/smembers" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://redis.io/commands/smembers</em></a></p></blockquote><p id="3499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们循环遍历这些，搜索每个<code class="fe lb lc ld le b">HASH</code>，提取信息(<code class="fe lb lc ld le b">id</code>、<code class="fe lb lc ld le b">description</code>、<code class="fe lb lc ld le b">status</code>)，创建一个<code class="fe lb lc ld le b">db.Todo</code>片段，最终以表格形式显示在CLI应用程序中</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="447c" class="mg mh iq le b gy mi mj l mk ml">for _, todoHashName := range todoHashNames {<br/>	id := strings.Split(todoHashName, ":")[1]<br/>	todoMap, err := c.HGetAll(todoHashName).Result()<br/>    ....<br/>    todo = Todo{id, todoMap["desc"], todoMap["status"]}<br/>    ....<br/>    todos = append(todos, todo)<br/>....</span></pre><blockquote class="lr ls lt"><p id="0606" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">检查</em> <code class="fe lb lc ld le b"><em class="iq">HGETALL</em></code> <em class="iq">参考</em><a class="ae kc" href="https://redis.io/commands/hgetall" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://redis.io/commands/hgetall</em></a></p></blockquote><p id="700f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">删除待办事项</strong></p><p id="6bf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要删除待办事项，包含信息的<code class="fe lb lc ld le b">HASH</code>将被删除</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="2c48" class="mg mh iq le b gy mi mj l mk ml">c.Del("todo:" + id).Result()</span></pre><blockquote class="lr ls lt"><p id="34c8" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">检查【https://redis.io/commands/del】</em>中的 <a class="ae kc" href="https://redis.io/commands/del" rel="noopener ugc nofollow" target="_blank"> <em class="iq">中的<code class="fe lb lc ld le b"><em class="iq">DEL</em></code> <em class="iq"/></em></a></p></blockquote><p id="ca4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随后从<code class="fe lb lc ld le b">SET</code>中移除<code class="fe lb lc ld le b">todo</code> id条目</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="7a78" class="mg mh iq le b gy mi mj l mk ml">err = c.SRem(todoIDsSet, "todo:"+id).Err()</span></pre><blockquote class="lr ls lt"><p id="5f4a" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">检查</em> <code class="fe lb lc ld le b"><em class="iq">SREM</em></code> <em class="iq">参考</em><a class="ae kc" href="https://redis.io/commands/srem" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://redis.io/commands/srem</em></a></p></blockquote><p id="7485" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">更新待办事项</strong></p><p id="2989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了通过id更新一个<code class="fe lb lc ld le b">todo</code>，我们首先需要确认它是否是一个有效的<code class="fe lb lc ld le b">id</code>。为此，我们需要做的就是检查<code class="fe lb lc ld le b">SET</code>是否包含那个<code class="fe lb lc ld le b">todo</code></p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="e26d" class="mg mh iq le b gy mi mj l mk ml">exists, err := c.SIsMember(todoIDsSet, "todo:"+id).Result()</span></pre><p id="9811" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是的话，我们可以继续更新它的信息。我们用用户传入的新的<code class="fe lb lc ld le b">status</code>、<code class="fe lb lc ld le b">description</code>(或两者)创建一个<code class="fe lb lc ld le b">map</code>，并调用<code class="fe lb lc ld le b">HMSet</code>函数</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="eb19" class="mg mh iq le b gy mi mj l mk ml">....<br/>	updatedTodo := map[string]interface{}{}<br/>	if status != "" {<br/>		updatedTodo["status"] = status<br/>	}</span><span id="eb76" class="mg mh iq le b gy mm mj l mk ml">	if desc != "" {<br/>		updatedTodo["desc"] = desc<br/>	}<br/>    c.HMSet("todo:"+id, updatedTodo).Err()<br/>    ....</span></pre><blockquote class="lr ls lt"><p id="c7c1" class="kd ke lu kf b kg kh ki kj kk kl km kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated"><em class="iq">查看</em> <code class="fe lb lc ld le b"><em class="iq">HMSET</em></code> <em class="iq">参考</em><a class="ae kc" href="https://redis.io/commands/hmset" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://redis.io/commands/hmset</em></a></p></blockquote><p id="4beb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个由两部分组成的博客系列到此结束。一如既往，敬请期待更多！如果觉得这有用，别忘了喜欢和分享😃很高兴通过<a class="ae kc" href="https://twitter.com/abhi_tweeter" rel="noopener ugc nofollow" target="_blank"> Twitter </a>获得您的反馈，或者发表评论🙏🏻</p></div></div>    
</body>
</html>