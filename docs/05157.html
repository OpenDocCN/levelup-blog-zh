<html>
<head>
<title>Anonymous file transfer with WebRTC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WebRTC进行匿名文件传输</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/anonymous-file-transfer-with-webrtc-f5e6d505770f?source=collection_archive---------4-----------------------#2020-08-07">https://levelup.gitconnected.com/anonymous-file-transfer-with-webrtc-f5e6d505770f?source=collection_archive---------4-----------------------#2020-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ce759502c69cf695865934a2b2c7a57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DvDW9WGTVpfRwRrQW21n8A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">WebRTC</figcaption></figure><h1 id="9b63" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="0fa3" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">回到2016年，我开发了一个名为<a class="ae ly" href="https://github.com/Acrecio/sharetc" rel="noopener ugc nofollow" target="_blank"> ShareTC </a>的应用程序，它允许用户通过他们的网络浏览器使用<a class="ae ly" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"> WebRTC技术</a>来<strong class="lc ir">分享他们的文件。该应用程序运行良好，但承诺是能够在没有任何服务器的情况下共享文件。第一个版本使用了<a class="ae ly" href="https://peerjs.com/" rel="noopener ugc nofollow" target="_blank"> PeerJS </a>，一个允许你实现<a class="ae ly" href="https://www.html5rocks.com/en/tutorials/webrtc/datachannels/" rel="noopener ugc nofollow" target="_blank"> WebRTC数据通道</a>用于文件共享的库，但有一个缺点，它需要一个服务器用于所谓的<a class="ae ly" href="https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" rel="noopener ugc nofollow" target="_blank">信令过程</a>。因此，我对这个项目做了一些改进，允许用户共享他们的文件，甚至不需要使用信令服务器。</strong></p><p id="bcf7" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">对技术实现不感兴趣的可以直接看GitHub  上的<a class="ae ly" href="https://github.com/Acrecio/sharetc" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">演示。</strong></a></p><h1 id="dc8b" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">移民</h1><p id="231c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">最初，这个项目是原生JavaScript的准系统，但是我决定将它升级到<strong class="lc ir"> Angular 8 </strong>，因为交换信号配置有点复杂，我需要一些框架来方便DOM操作。</p><p id="562d" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">因为这是一个附带的项目，我不想重新创建一个组件库，所以我使用了<a class="ae ly" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank"> @angular/material </a>库作为表单和用户反馈。</p><p id="4adf" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我还使用了<a class="ae ly" href="https://github.com/angular/flex-layout" rel="noopener ugc nofollow" target="_blank"> @angular/flex-layout </a>来轻松定义布局，因为我知道应用程序设计是非常基本的，因为它不是演示的主要目的。</p><h1 id="5ec6" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">它是如何工作的</h1><p id="dcc8" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在，有趣的部分是，应用程序将尝试使用WebRTC在发送方和接收方之间创建一个数据通道。协议需要知道它应该向谁发送数据，这被称为<a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling" rel="noopener ugc nofollow" target="_blank">对等发现</a>，它可以通过所谓的<a class="ae ly" href="https://github.com/peers/peerjs-server" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">信令服务器</strong> </a>自动完成，在该服务器上，您可以交换您的配置以开始通信，这是我想要删除的组件。对于手动配置，我们使用<a class="ae ly" href="https://en.wikipedia.org/wiki/Session_Description_Protocol" rel="noopener ugc nofollow" target="_blank">会话描述协议</a>(或SDP)。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/cf36338d478fefde4b745fc8ccae83b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*NKhU9hnga3BJoJGq.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">会话描述协议</figcaption></figure><p id="355b" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">但是因为网络是复杂的，在某些情况下，你需要一个用于NAT (或者<strong class="lc ir"> STUN </strong> ) <strong class="lc ir">服务器</strong>的<a class="ae ly" href="https://en.wikipedia.org/wiki/STUN" rel="noopener ugc nofollow" target="_blank">会话遍历工具。当你在一个</a><a class="ae ly" href="https://en.wikipedia.org/wiki/Network_address_translation" rel="noopener ugc nofollow" target="_blank">网络地址转换</a>(或<strong class="lc ir"> NAT </strong> ) <strong class="lc ir">防火墙</strong>后面交换文件时，会用到这个。有一些公共服务器可以这样做:<br/>—stun.services.mozilla.com<br/>—stun.l.google.com:19302</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/1d57fa4957c0b4cf20bc656721a16a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*G6qW2gHMRbhKp2oa.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">NAT的会话遍历实用程序</figcaption></figure><p id="066e" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在其他一些情况下，通信信道将被防火墙阻断。在这种情况下，您最终可以使用NAT (或<strong class="lc ir"> TURN </strong> ) <strong class="lc ir"> server </strong>周围的中继进行<a class="ae ly" href="https://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT" rel="noopener ugc nofollow" target="_blank">遍历，这将作为您和对等方之间的数据中继。它们很贵，而且只有在您处于阻塞型防火墙之后时才有必要，所以我没有为此集成解决方案😊</a></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/4546e0c670ab5e9be773b3328d465430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*WTGSiYGGm9QGGGpg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用NAT周围的中继进行遍历</figcaption></figure><p id="aeb7" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们要做的是，生成发送方配置SDP，需要与接收方共享。然后，接收方将能够生成他的SDP配置，发送方需要导入该配置以创建通信信道。然后，您将能够使用<a class="ae ly" href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank">数据报传输层安全性</a>(或<strong class="lc ir"> DTLS </strong>)发送文件，这是一个安全的通信通道。</p><h1 id="2e53" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">如何让它发生</h1><p id="8cf6" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在您已经有了WebRTC通信方案，让我们来看看项目中一些有趣的部分。你可能想打开代码来更好地理解这部分，通过访问项目库【https://github.com/Acrecio/sharetc<a class="ae ly" href="https://github.com/Acrecio/sharetc" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9310" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">首先，我选择使用伟大的<a class="ae ly" href="https://github.com/feross/simple-peer" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir">feross/simple-peer</strong></a><strong class="lc ir">库</strong>作为WebRTC的通信通道。要使用该库，我们必须将一些polyfills(检查polyfills.ts)添加到项目中，用于全局、流程和缓冲区对象，如下所示:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="67e6" class="mo kd iq mk b gy mp mq l mr ms"><strong class="mk ir">(</strong>window as any<strong class="mk ir">).</strong>global <strong class="mk ir">=</strong> window<strong class="mk ir">;</strong><br/><strong class="mk ir">(</strong>window as any<strong class="mk ir">).</strong>process <strong class="mk ir">=</strong> <strong class="mk ir">{</strong><br/>    nextTick<strong class="mk ir">:</strong> setImmediate<strong class="mk ir">,</strong><br/>    env<strong class="mk ir">:</strong> <strong class="mk ir">{</strong> DEBUG<strong class="mk ir">:</strong> <strong class="mk ir">undefined</strong> <strong class="mk ir">},</strong><br/><strong class="mk ir">};</strong><br/><strong class="mk ir">(</strong>window as any<strong class="mk ir">).</strong>global<strong class="mk ir">.</strong>Buffer <strong class="mk ir">=</strong> <strong class="mk ir">(</strong>window as any<strong class="mk ir">).</strong>global<strong class="mk ir">.</strong>Buffer <strong class="mk ir">||</strong> require<strong class="mk ir">(</strong>'buffer'<strong class="mk ir">).</strong>Buffer<strong class="mk ir">;</strong></span></pre><p id="50e8" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">如果您使用的是typescript，您可能还需要通过修改您的<em class="mt"> tsconfig.app.json </em>文件来添加本机模块的节点声明:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="784f" class="mo kd iq mk b gy mp mq l mr ms">"types"<strong class="mk ir">:</strong> <strong class="mk ir">[</strong><br/>  "node"<br/><strong class="mk ir">],</strong></span></pre><p id="86db" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我还决定<strong class="lc ir">使用<a class="ae ly" href="https://github.com/pieroxy/lz-string" rel="noopener ugc nofollow" target="_blank">基于LZ的压缩</a>来压缩SDP配置</strong>，这样更容易共享。这就是配置看起来更像这样的原因:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e2e1" class="mo kd iq mk b gy mp mq l mr ms">N4IgLgngDgpiBcID2AzFMBOIA0IDOAJlAiAG4C8ADADobUB2S5AtkgF4CWANlwIYB0ggCoAJAJIBlAPqSpEgCIAFAIIAlIcoC0Adkr89ARgAEBgEwAWSuYCcZ7dZsAOc6e2Ptpo5SNiAcj8VzL30Qmjp6PHJNWgYwKi8Y<strong class="mk ir">+</strong>l5yPBh6AgwYAGNSROSUDnoAc0woDEKweDwAC15NUwBWADYjJuV4JoaO63gAZgAxeEcm<strong class="mk ir">+</strong>ABRAGF4bXN4W3h5Qf7JxvhzLoNBptGxyYbt0ZGG9tH5eGVtpp63eH7KVZ7lRzGDeHG769M7<strong class="mk ir">+</strong>Rf5O4AhUZ5chFDBIACuUHgfwAqr55AAZUYJcLJZh4DgETSpZi8ehgDhZeAAdQAshIjAAqRLMci8KBQLgE3j4pD0IwNRyOUwtaFKAD08iE8IkfIk4yEiiMAHcYAAjDBgLKaAjM3hZWr0egwLiJLLkPwBILWPTG<strong class="mk ir">-</strong>iNfgGXqOIFZXEEDHMmDwbzGXmS0xmUyNRrmXomPR6UwWhpGXraXq2IyQKBGapIPBgG12h1gJ1<strong class="mk ir">+4</strong>xCcbugyUBoNCzmez<strong class="mk ir">+</strong>kJBgwh6xR6Cx<strong class="mk ir">+</strong>NgKNZKDRmBGNX40gwJPpFNO4yupQmJrDXOmYZ<strong class="mk ir">+02</strong>m82WxzszncysxvAYFBcAAeRgwvAIGWLgeDa6gSAVofDtiBqXSmRyQLSmNQmltnZVqbwQIJME0UClBCm9m0TVzsosUwshgbRZRgdx7GaAhZQIT4slMFAAJfYDNDBFB1yKeAGmsD0DHA3ogWYDFnVPGAwAheAWygXg8GfFEUiyMAoHfA9KgaSgOMI3hl00ZgYFo3gSixDg2G7Shw2mAwuQI8IQAAXyAA</span></pre><p id="0f1a" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">但是通过解压缩，你会得到一个有效的SDP信号消息。</p><p id="9baa" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">最后，为了发送和下载文件，我们使用了<a class="ae ly" href="https://www.html5rocks.com/en/tutorials/file/dndfiles/" rel="noopener ugc nofollow" target="_blank"> JavaScript文件API </a>，这样我们就可以通过数据通道发送它。事情是这样的，数据将被存储为一个<a class="ae ly" href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/ArrayBuffer" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> ArrayBuffer </strong> </a>，所以我们通过一个Blob为要下载的文件生成一个下载链接，文件名为file.dat，正如你在`<em class="mt"> download.component.ts` </em>中看到的。</p><p id="7a4a" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">为了通过通信数据通道交换消息，我们还需要使用以下函数将ArrayBuffer转换为string:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a6fc" class="mo kd iq mk b gy mp mq l mr ms"><strong class="mk ir">function</strong> ab2str<strong class="mk ir">(</strong>buf<strong class="mk ir">:</strong> ArrayBuffer<strong class="mk ir">):</strong> string <strong class="mk ir">{</strong><br/>  <strong class="mk ir">return</strong> String<strong class="mk ir">.</strong>fromCharCode<strong class="mk ir">.</strong>apply<strong class="mk ir">(null,</strong> <strong class="mk ir">new</strong> Uint16Array<strong class="mk ir">(</strong>buf<strong class="mk ir">));</strong><br/><strong class="mk ir">}</strong></span></pre><p id="c23b" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">可以在`<em class="mt"> upload.component.ts` </em>中查看如何使用。</p><h1 id="060a" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">演示</h1><p id="6a6d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">因为您必须在发送文件之前交换<strong class="lc ir"> SDP配置</strong>并创建数据通道，所以应用程序要稍微复杂一些。因此，要使用演示应用程序，您需要:</p><p id="4982" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">1.发送您的发送者配置<br/> 2。接收者将进入您的配置并点击连接(它连接到发送者)<br/> 3。接收者将与发送者分享他生成的配置。然后发送者点击连接创建数据通道<br/> 5。双工流已启动并正在运行</p><h1 id="e2c2" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="4e35" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">要得到我想要的应用程序，这是一条漫长的道路。允许用户在没有任何服务器的情况下安全地共享他们的文件，但除了网络复杂性之外，我真的很高兴实现了这一点。</p><p id="7aca" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">如果您需要软件开发或教学，可以在github资源库<a class="ae ly" href="https://github.com/Acrecio/sharetc" rel="noopener ugc nofollow" target="_blank"> acrecio/sharetc </a>和<a class="ae ly" href="https://acrecio.com/contact" rel="noopener ugc nofollow" target="_blank">保持联系</a>上查看项目源代码😊</p></div></div>    
</body>
</html>