<html>
<head>
<title>Maximum Even Sum Of K Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K个元素的最大偶数和</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/maximum-even-sum-of-k-elements-ca060ab3a9fd?source=collection_archive---------0-----------------------#2021-01-24">https://levelup.gitconnected.com/maximum-even-sum-of-k-elements-ca060ab3a9fd?source=collection_archive---------0-----------------------#2021-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4e1ee1a2fa1ff8ea0920dba2b7eb3d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prM6OUzSmF2IZSzSyKm7HQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com/s/photos/numbers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@carlosirineu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Carlos Irineu da Costa </a>拍摄的照片</figcaption></figure><p id="23a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个流行的算法问题，可以用<a class="ae kf" href="https://en.wikipedia.org/wiki/Greedy_algorithm" rel="noopener ugc nofollow" target="_blank">贪婪算法</a>方法解决。这是一个学习如何以贪婪的方式思考的极好例子。</p><p id="5552" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通俗地说，贪心方式就是利用局部最优解的优势，向外扩展到全局最优解。</p><p id="be2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们来看看问题陈述。</p><h1 id="1aa7" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">问题陈述:</h1><p id="db18" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我们得到了一个列表(坚持使用蟒蛇舌头，因为我无法停止爱它！)的正<strong class="ki iu"/>整数，我们必须从列表中找出<em class="le">最大值</em> <strong class="ki iu"> <em class="le">偶数</em> </strong> <em class="le">总和</em>为<strong class="ki iu"> K </strong>的元素。如果找不到，我们返回<em class="le"> -1。</em></p><p id="c386" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意单词<strong class="ki iu"> even的重音。</strong></p><h2 id="ddce" class="mi lg it bd lh mj mk dn ll ml mm dp lp kr mn mo lt kv mp mq lx kz mr ms mb mt bi translated"><strong class="ak">样本输入/输出:</strong></h2><p id="4d24" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated"><em class="le">输入</em>:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="e77b" class="mi lg it mz b gy nd ne l nf ng">[4, 2, 6, 7, 8], k = 3</span></pre><p id="fcc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">输出:</em></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="d953" class="mi lg it mz b gy nd ne l nf ng">18</span></pre><p id="fdaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">说明:</em></p><p id="f61a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<strong class="ki iu"> k = 3 </strong>，我们必须从这个列表中取出3个元素。别忘了我们必须使它成为一个偶数。因此，即使[8，7，6] = 21的和是我们能得到的最大和，但我们不能接受它，因为它是奇数。因此，最大偶数和将是[8，6，4] = 18的和，这是我们可以得到的最大偶数和。</p><p id="9315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们再尝试几个:</p><p id="ee04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">输入:</em></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="c5f7" class="mi lg it mz b gy nd ne l nf ng">[5,5,1,1,3], k = 3</span></pre><p id="6a56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">输出:</em></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="89ae" class="mi lg it mz b gy nd ne l nf ng">-1</span></pre><p id="e0e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">解释:</em></p><p id="98cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看这里，我们需要3个元素来得到最大的偶数和。但是请注意，我们根本没有偶数。同样，3个奇数加起来也不可能是偶数。考虑:1 + 3 + 5 = 9，所以永远是奇数和。所以，我们只返回<strong class="ki iu"> -1 </strong>。</p><h1 id="d3ef" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">图案:</strong></h1><p id="99a8" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">一开始理解这种模式可能有点棘手。让我们把它分成几块:</p><ul class=""><li id="8224" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">首先，让我们从最基本的角度考虑一下:我们什么时候能得到一个偶数？实际上，我们只有两种方法可以得到<strong class="ki iu">甚至</strong>和。注意:<strong class="ki iu">偶数+偶数=偶数(如2 + 4 = 6)或奇数+奇数=偶数(如1 + 3 = 4)。除了这两种方法，我们永远也得不到偶数。(例如偶数+奇数！=偶数，例如10 + 1 = 11，反之亦然)</strong></li><li id="c934" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki iu">其次，</strong>注意，在给定的列表中，我们混合了偶数和奇数整数。但是，为了创造上述条件，如果我们能够在一个单独的列表中把事件和概率分开，我们的生活就会容易得多。</li></ul><p id="812e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">最后</strong>，观察如果我们部署贪婪方法——在非常局部的级别我们会有:k = 1，即只有1个元素——那么我们会做什么？—我们必须取偶数(如果有的话)。</p><p id="ff97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，注意如果我们有k = 2，需要2个偶数或2个奇数，因为我们已经知道:</p><ul class=""><li id="2652" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated"><strong class="ki iu">偶数+偶数=偶数</strong></li><li id="b5bc" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki iu">奇数+奇数=偶数</strong></li><li id="7eb2" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><strong class="ki iu">偶数+奇数！=偶数</strong></li></ul><p id="de9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前两种情况下，我们必须取最大值以使最大值为偶数。</p><h1 id="b92d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">算法:</strong></h1><p id="ae0d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">实际上，解决这个问题的方法不止一种，我将选择我认为最容易理解和说明的一种。让我们用简单的英语来解释一下:</p><ol class=""><li id="888c" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nv nn no np bi translated">我们按照desc顺序对列表进行排序(降序在接下来的步骤中会很方便)。</li><li id="1f22" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nv nn no np bi translated">接下来，我们<strong class="ki iu">分离出</strong>偶数<strong class="ki iu">和</strong>奇数元素。在这一步之后，我们将有两个列表，一个是偶数<strong class="ki iu">元素，另一个是奇数</strong>元素，按降序排列。</li></ol><p id="3507" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们初始化一个<strong class="ki iu"> max_sum </strong>来跟踪当前的最大值，然后我们部署我们的贪婪方法:</p><ol class=""><li id="1f50" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nv nn no np bi translated">循环，直到我们获得了K个元素，同时循环偶数和奇数列表，在每一步中，我们执行以下操作:</li></ol><ul class=""><li id="0ba0" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">如果<strong class="ki iu"> K </strong>是<strong class="ki iu">奇数，</strong>我们从偶数列表中取最大的数。</li><li id="6b5a" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">如果<strong class="ki iu"> K </strong>是<strong class="ki iu">偶数</strong>，我们取两个最大偶数和两个最大赔率之和的最大值。</li></ul><p id="86e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这两种情况下，我们都必须更新<strong class="ki iu"> max_sum的运行值。</strong></p><p id="0d30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们只是利用了贪婪算法方法，即获取局部最优解(即k=1，k=2)并将其扩展到全局最优解。</p><h1 id="af38" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">代码:</strong></h1><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">从正整数列表中寻找最大值的代码。</figcaption></figure><p id="a28a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过取消对打印行的注释，尝试给定输入的输出。</p><h2 id="57c1" class="mi lg it bd lh mj mk dn ll ml mm dp lp kr mn mo lt kv mp mq lx kz mr ms mb mt bi translated"><strong class="ak">代码演练:</strong></h2><ul class=""><li id="ca6d" class="nh ni it ki b kj md kn me kr ny kv nz kz oa ld nm nn no np bi translated">首先，我们检查边缘案例并相应地返回<strong class="ki iu"> -1 </strong>。</li><li id="3264" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">直到<strong class="ki iu"> line: 8，</strong>我们初始化一个奇偶列表，我们将使用它来存储从主输入列表中分离出来的偶数和奇数。</li><li id="8a39" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">Net中，我们以相反的顺序对输入列表进行排序。</li><li id="ed95" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">从第<strong class="ki iu">11–15行:</strong>我们循环遍历输入列表，分离出偶数和奇数，并将它们放入各自的列表中。</li><li id="9da1" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">接下来在<strong class="ki iu">第18–19行</strong>:我们初始化偶数和奇数索引，这些索引将用于跟踪我们当前在奇偶列表中循环的位置。</li></ul><p id="1eb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从第<strong class="ki iu"> 32:52 — </strong>行开始，我们循环执行，直到满足k个元素的要求。</p><p id="3bc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意现在有两种情况:</p><ol class=""><li id="2309" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nv nn no np bi translated">如果<strong class="ki iu"> k%2 == 1，即当k为奇数时。</strong>我们检查偶数列表的长度是否大于0，即偶数项目列表中至少有1个项目。然后我们归还那个项目。对于贪婪方法，我们可以考虑<strong class="ki iu"> k = 1 </strong>的情况</li><li id="1892" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nv nn no np bi translated"><strong class="ki iu"> else: k是偶数。</strong>根据贪心法，我们可以认为这是当<strong class="ki iu"> k = 2，</strong>从上面我们知道:当<strong class="ki iu">偶数+偶数</strong>或<strong class="ki iu">奇数+奇数时，我们只能从2个数中得到偶数。</strong>所以，很自然地，我们采取了</li></ol><p id="a270" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，当我们进入第二种情况时，我们将偶数和奇数索引增加2。并且也将k减2。这是因为我们一次取两个数字。</p><p id="a156" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后我们返还最大金额，终于可以睡个好觉了！</p></div></div>    
</body>
</html>