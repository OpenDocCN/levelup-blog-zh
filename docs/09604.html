<html>
<head>
<title>Big O Notation: Bubble Search in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号:Unity中的冒泡搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/big-o-notation-bubble-search-in-unity-c90ca1f608d0?source=collection_archive---------1-----------------------#2021-08-25">https://levelup.gitconnected.com/big-o-notation-bubble-search-in-unity-c90ca1f608d0?source=collection_archive---------1-----------------------#2021-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fa18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之前在我们的<em class="kl"> Unity优化</em>系列(<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/big-o-binary-search-in-unity-f607d0f0919d">Big O:Unity</a>中的二分搜索法)中，我们理解了<em class="kl">二进制算法</em>搜索背后的概念，在这个搜索中，你在一个数组中找到一个目标值。提醒一下，这个搜索是<strong class="jp ir"> BIG O </strong>符号的一部分，在这个符号中，你划分一个数组以找到你的目标值。但是要做到这一点，数组<strong class="jp ir">必须</strong>被排序，在本文中我们将看到如何使用新的<strong class="jp ir">大O </strong>符号对数组进行排序。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/ec8cb495330804a65b59b69e502c5d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRm7MB5IWgrrJyg_SS7J5w.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">冒泡排序</figcaption></figure><blockquote class="ld le lf"><p id="6feb" class="jn jo kl jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">大O快速回顾</p></blockquote><p id="8e82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是我们目前看到的三个大O符号:</p><p id="74a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">a . O(1)</strong>= O/1这是最好的情况，其中目标值是数组中的第一个值</p><p id="182a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> B. O(n) </strong> = O of n这是一个线性搜索(对于循环是正常的),其中n是循环找到目标值的迭代次数</p><p id="8e78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> C. O(Log n) </strong> = O log of n，这是你划分数组并在新划分的数组中搜索目标的二分搜索法。</p><p id="b1f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">帮助我们对数组排序的新符号是:</p><ul class=""><li id="6b51" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><strong class="jp ir"> O(n ) </strong>它基本上是一个嵌套的for循环；循环中的循环。它也被称为冒泡排序。</li></ul><blockquote class="ld le lf"><p id="f686" class="jn jo kl jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">冒泡排序</p></blockquote><p id="bf75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">冒泡排序或O(n)正在使用嵌套循环。不建议使用这种方法，因为它增加了搜索的时间复杂度，并可能导致一些性能问题，但知道这一点是有好处的。</p><p id="b47a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以下面的数组为例:</p><pre class="ko kp kq kr gt ls lt lu lv aw lw bi"><span id="a2c7" class="lx ly iq lt b gy lz ma l mb mc">public int[] ages = {57, 90, 2, 15, 6, 35, 25, 3};</span></pre><p id="c6a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用冒泡排序对数组进行排序，该算法将查看每个数组索引，并与其他所有索引进行比较，然后进行排序，并在必要时进行交换。</p><p id="a846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，以57岁为例。冒泡排序算法将取57，并将其与90进行比较。它是否小于90，如果是，那么它将57与2进行比较。57是否小于2，如果是，那么它将57与2交换。然后，它再次将57与15进行比较，以此类推，直到它最终将57与数组中的最后一个索引3进行比较，并在必要时进行交换。当它以57结束时，该算法将取数组中的第二个索引90，然后将其与它之后的每一个索引进行比较。</p><h2 id="5376" class="lx ly iq bd md me mf dn mg mh mi dp mj jy mk ml mm kc mn mo mp kg mq mr ms mt bi translated">那么如何实现呢？</h2><p id="b9a0" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">冒泡排序的实现不像它的时间复杂度那么复杂。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mz"><img src="../Images/02a17a37fd96d4d4495c76d8ecd789cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YoKN1eyuoXoC_Ayetwgldg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">冒泡排序算法</figcaption></figure><p id="2e8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们首先获取索引ages[ <strong class="jp ir"> i </strong> ]，然后在继续下一个<strong class="jp ir"> i </strong>索引之前，我们将<strong class="jp ir"> i </strong>，与所有其他索引(<strong class="jp ir"> j </strong>)进行比较。如果年龄[ <strong class="jp ir"> j </strong>处的值大于年龄[ <strong class="jp ir"> i </strong>处的值，那么我们将<strong class="jp ir"> i </strong>与<strong class="jp ir"> j </strong>互换。为了交换数字，我们必须创建一个临时变量来保存索引<strong class="jp ir"> i </strong>处的值。</p><p id="7464" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果编写正确，冒泡排序算法将对年龄数组进行排序。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi na"><img src="../Images/48b4e3568fd89690ba959c0ab349979b.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*tNq39YDtioGRHoa3fqzG4w.jpeg"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">运行算法后的排序列表</figcaption></figure><p id="3390" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，不推荐使用这种算法(冒泡排序或嵌套for循环)-O(n )-因为它增加了时间复杂度。在下一篇文章中，我们将学习一种新的排序算法，它比这种算法快得多，它被称为合并排序或O(n Log n)。</p></div></div>    
</body>
</html>