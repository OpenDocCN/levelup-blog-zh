<html>
<head>
<title>How I Built a Production-ready Flutter Gaming Application that has 7500+ Daily Active Users (DAUs)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何构建一个拥有7500多日活跃用户(dau)的生产就绪型Flutter游戏应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-built-a-production-ready-flutter-product-that-has-3000-daily-active-users-daus-a3ef7fa3d37a?source=collection_archive---------10-----------------------#2021-09-07">https://levelup.gitconnected.com/how-i-built-a-production-ready-flutter-product-that-has-3000-daily-active-users-daus-a3ef7fa3d37a?source=collection_archive---------10-----------------------#2021-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2a99f8b3f7463ad4ada5e027bda3e831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWS9ZL1LA7ubzNJWtzplug.png"/></div></div></figure><p id="ed16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果全面使用，Flutter是一项非常好的技术，这对于每个人来说都是正确的。它超越了设计语言和期望的界限。它在开发者手中掌握着巨大的权力，并帮助构建像素级完美的移动应用程序故事，从而节省大量资金并创造收入。</p><blockquote class="kw"><p id="53c5" class="kx ky iq bd kz la lb lc ld le lf kv dk translated">但是对技术的巨大控制带来了巨大的责任</p></blockquote><p id="c873" class="pw-post-body-paragraph jy jz iq ka b kb lg kd ke kf lh kh ki kj li kl km kn lj kp kq kr lk kt ku kv ij bi translated">因为作为开发商，我们有很多控制权，事情很容易变糟。产品必须使用好的架构和好的工具系统来帮助为客户提供更好的用户体验。Flutter的工作原理是一样的。此外，该技术仍然相当新，不同的架构仍在开发中。虽然谷歌一直在宣传如何设计应用程序以及如何使用这项技术，但如果你想开发一个相当定制的应用程序，往往会有一段时间你不得不回到Android的基础上。</p><p id="c582" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，<a class="ae ll" href="https://gamezop.com" rel="noopener ugc nofollow" target="_blank">我们</a>在上个月，也就是2021年8月发布了我们的游戏<a class="ae ll" href="https://bit.ly/skillclash-app" rel="noopener ugc nofollow" target="_blank">应用</a>的1.0.0版本，我们的数量还在增加。这个产品已经酝酿了很长时间，但我对它的结果相当有信心。在这篇文章中，我将谈论如何构建一个<strong class="ka ir">生产就绪的Flutter游戏产品。</strong></p><h1 id="0c06" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">我造了什么——skill clash？</h1><p id="4ce9" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">SkillClash 是一个基于技能的真钱游戏平台，在这个平台上，人们可以在锦标赛和战斗中争夺真钱。有多种游戏可供选择，用户可以通过Paytm、Amazon、UPI、银行转账或移动充值等热门选项兑现他们的奖金。</p><p id="6456" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经为SkillClash开发了一个移动应用程序(目前是Android ),并且一直在使用Flutter。这里有一个讨论的链接，讨论的目的是决定我们为什么把<a class="ae ll" href="https://medium.com/flutter-community/how-i-convinced-my-team-lead-to-go-for-flutter-and-kotlin-9e9bde16d73" rel="noopener"> Flutter作为一项技术</a>。</p><p id="ca31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SkillClash已经在网上上线，移动应用程序也已经上线。我们的应用在play store上不可用，因为Google不允许基于技能的真钱游戏应用。但是<a class="ae ll" href="https://bit.ly/skillclash-app" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以下载我们的应用，试一试。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/4405e38120dedc2426724921c99a97a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHM5uUF14bcz_4a8xKC_Ew.png"/></div></div></figure><p id="27c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上图展示的是我们的设计师<a class="ae ll" href="https://www.linkedin.com/in/shanksgee/" rel="noopener ugc nofollow" target="_blank">沙尚克·库马尔</a>(现在在<a class="ae ll" href="https://www.linkedin.com/company/airtel/" rel="noopener ugc nofollow" target="_blank"> Airtel </a>)制作的一组非常小的屏幕</p><h1 id="62b0" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">建造的过程</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f76769d812acfdd28bcddf466ea9db29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/1*oKVc6c1IQSJRCEGB2COBIg.gif"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><a class="ae ll" href="https://thumbs.gfycat.com/TimelyHappygoluckyGalapagostortoise-max-1mb.gif" rel="noopener ugc nofollow" target="_blank">信号源</a></figcaption></figure><p id="f158" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我被提供了一组巨大的屏幕来交付之后，我打开我的笔记本电脑，回到Android Studio，开始一个模块一个模块地构建用户界面，没有任何API，只有模拟数据。</p><h2 id="451d" class="mz ln iq bd lo na nb dn ls nc nd dp lw kj ne nf ma kn ng nh me kr ni nj mi nk bi translated">首先要看的几件事:</h2><ol class=""><li id="cfe4" class="nl nm iq ka b kb mk kf ml kj nn kn no kr np kv nq nr ns nt bi translated">我要追随的建筑</li><li id="6000" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">状态管理</li><li id="e0af" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">应用程序中的导航</li><li id="7c15" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">添加游戏</li></ol><h1 id="2648" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">应用程序的架构</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/87d3de09915e4ceec98f4d9f7e15d0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*7gqlTnp4aFNYuEqzX4nTvA.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><a class="ae ll" href="https://resocoder.com/2019/08/27/flutter-tdd-clean-architecture-course-1-explanation-project-structure/" rel="noopener ugc nofollow" target="_blank"> Reso Coder博客</a></figcaption></figure><p id="7f37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道应用程序将会非常庞大，有超过1，500，000行代码，所以我需要一个好的架构设置，它很难被破坏，很容易测试，并且确保我在编写代码时使用好的模式。当平台有些冗长时，错误和糟糕的代码质量很容易渗透进来。</p><p id="4885" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">于是我就用<a class="ae ll" href="http://cleancoder.com/products" rel="noopener ugc nofollow" target="_blank">鲍勃大叔的干净架构</a>模式。</p><p id="a23f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">帮助我理解这个架构的分层系统的是Reso Coder博客。它们非常容易理解，易于复制和遵循。虽然在一个模块中集成第一个API的样板文件有点麻烦，但是当你掌握了它的窍门时，你不会感觉到太多。</p><p id="db6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单个模块，例如应用程序中用于闪屏和登录的模块，具有如下结构:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f49345112981ea4e935f03bff76e5c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*kDKF3EfIM3d6ZnAaduU4wg.png"/></div></figure><p id="d5ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用程序中的所有模块都遵循相同的结构。我称之为模块，是因为所有与登录相关的文件都分组在一起。类似地，另一个模块如钱包也有相同的结构。</p><p id="5fa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定在项目中使用2个Flutter应用模块。一个是主项目，也就是<code class="fe ob oc od oe b">main.dart</code>所在的地方。另一个是我保存公共功能、公共用户界面和公共实用程序类的地方。</p><h1 id="7718" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">状态管理</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/06f52d87f4c4367463b84243d7e50bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kC8xgTsDVSoZNt5pDm9-Dw.gif"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><a class="ae ll" href="https://www.spec-india.com/blog/flutter-state-management" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="ee40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，状态管理是整个游戏的一个重要部分，除非它是一个静态应用程序。我们的并不需要一些解决方案。</p><p id="2554" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我混合了两种。<a class="ae ll" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">提供商</strong></a>T5<a class="ae ll" href="https://pub.dev/packages/flutter_bloc" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">集团</strong> </a> <strong class="ka ir">。</strong>我使用provider来帮助特定屏幕的状态管理，使用bloc来帮助表示层与数据层的通信。</p><p id="bcb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">刚开始工作的人，或者不知道状态管理解决方案的人，如果它支持您的用例，请使用这个解决方案。因为我知道这个应用程序将会非常庞大，所以我必须同时使用它们。</p><p id="a752" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意事项:</strong></p><ol class=""><li id="c8d5" class="nl nm iq ka b kb kc kf kg kj og kn oh kr oi kv nq nr ns nt bi translated"><a class="ae ll" href="https://medium.com/flutter-community/improve-your-flutter-app-performance-split-your-widgets-935f97e93f7d" rel="noopener"> <strong class="ka ir">更小的小部件</strong> </a> <strong class="ka ir"> : </strong>记住要创建更小的小部件，而不是在同一个小部件类的函数中创建小部件。将一个较大的部件分解成较小的部件将有助于性能优化。</li><li id="2adf" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated"><a class="ae ll" href="https://github.com/rrousselGit/provider/issues/313" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">提供者上下文</strong> </a> <strong class="ka ir"> : </strong>更容易得到一个错误，指出“<em class="oj">试图从小部件树</em>之外监听提供者公开的值”。所以记住要么使用提供者小部件下的构建器小部件，要么将子小部件移动到不同的无状态或有状态小部件类中。</li><li id="e03e" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated"><strong class="ka ir">设定值时听假:</strong>很容易掉入这个陷阱。当您在构建函数中访问提供者状态值时，listen参数默认设置为true。每当状态值改变时，这有助于重新构建小部件。但是当我们需要改变一个状态值时，我们需要将该值设置为false，这样整个部件树就不会一直重建。像这样的<code class="fe ob oc od oe b">Provider.of&lt;Counter&gt;(providerContext, listen: false).add(n+1);<br/></code> <a class="ae ll" href="https://stackoverflow.com/a/58584363/7370876" rel="noopener ugc nofollow" target="_blank">这里的</a>是同样的另一种解释。</li><li id="18ed" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated"><strong class="ka ir">使用插件树深处的提供者状态:</strong>记住使用插件树深处的提供者值。这是因为无论您在小部件树中的什么地方使用提供者值，只要有变化，整个小部件都会重新构建。因此，明智地拆分您的小部件，并尽可能深地使用provider，以便减少小部件的重建来提高性能。</li></ol><h1 id="c433" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">项目中的导航</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/88b0d204fdfed9a6b4d5ef992226e909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Hyva6Jc7cKW7Ia9SvqnYiA.gif"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><a class="ae ll" href="https://www.smashingmagazine.com/2019/08/bottom-navigation-pattern-mobile-web-pages/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><blockquote class="ol om on"><p id="dc28" class="jy jz oj ka b kb kc kd ke kf kg kh ki oo kk kl km op ko kp kq oq ks kt ku kv ij bi translated">如果您需要在应用程序的许多部分导航到同一个屏幕，这种方法会导致代码重复。解决方法是定义一条<em class="iq">命名的路线</em>，并使用命名的路线进行导航。<a class="ae ll" href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="7b74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如Flutter官方网站所说，在一个相当大的应用程序中，命名导航路线是非常有效的。下面是如何在一个Flutter项目中实现同样的功能。</p><p id="6fe4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，定义一个非常基本的路由生成器类。这个类只包含一个方法来帮助你生成路线和导航。我们需要做的只是在应用程序中定义路线，这些只是屏幕小部件中简单的常量静态字符串。</p><p id="56f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想传入参数，你可以在<code class="fe ob oc od oe b">setting.arguments</code>的帮助下直接传入</p><pre class="mq mr ms mt gt or oe os ot aw ou bi"><span id="eb1b" class="mz ln iq oe b gy ov ow l ox oy">class RouteGenerator {<br/>  static Route&lt;dynamic&gt; <em class="oj">generateRoute</em>(RouteSettings settings) {<br/>    switch (settings.name) {<br/><br/>      // Language Selection Route<br/>      case LanguageSelectionRoute.<em class="oj">routeName</em>:<br/>        return <em class="oj">_transitionRoute</em>(<br/>            LanguageSelectionRoute(<br/>              args: settings.arguments,<br/>            ),<br/>        );</span><span id="a1c5" class="mz ln iq oe b gy oz ow l ox oy">        ...<br/>     }<br/>  }<br/>}</span><span id="da86" class="mz ln iq oe b gy oz ow l ox oy">// route_generator.dart</span></pre><p id="49fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦完成，您需要定义一个公共的<code class="fe ob oc od oe b">_transitionRoute</code>函数，该函数在同一个文件中抽象出调用路由的代码块。</p><pre class="mq mr ms mt gt or oe os ot aw ou bi"><span id="5c80" class="mz ln iq oe b gy ov ow l ox oy">static PageRoute <em class="oj">_transitionRoute</em>(Widget widget) {<br/>  return MaterialPageRoute(<br/>    builder: (_) =&gt; widget,<br/>  );<br/>}</span><span id="a642" class="mz ln iq oe b gy oz ow l ox oy">// route_generator.dart</span></pre><p id="ad0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置的最后一件事是分配一个初始路线，该路线将在应用程序启动后打开。您还需要分配一个函数，当路线被传递给导航器时，这个函数会被调用，导航器又会调用我们刚刚在<code class="fe ob oc od oe b">route_generator.dart</code>中创建的自定义generateRoute函数</p><pre class="mq mr ms mt gt or oe os ot aw ou bi"><span id="fe98" class="mz ln iq oe b gy ov ow l ox oy">class MyApp extends StatelessWidget <em class="oj">{<br/>  </em>final analytics = FirebaseAnalytics<em class="oj">()</em>;<br/>  // This widget is the root of your application.<br/>  @override<br/>  Widget build<em class="oj">(</em>BuildContext context<em class="oj">) {</em><br/>    return MaterialApp<em class="oj">(<br/></em>      title: 'Dummy Application',<br/>      initialRoute: ReceiverSplashScreenRoute.<em class="oj">routeName</em>,<br/>      onGenerateRoute: RouteGenerator.<em class="oj">generateRoute</em>,<br/>    <em class="oj">)</em>;<br/>  <em class="oj">}<br/>}</em></span><span id="6863" class="mz ln iq oe b gy oz ow l ox oy">// main.dart</span></pre><p id="2fb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你可以在导航仪上用<code class="fe ob oc od oe b">pushedNamed</code>功能轻松调用任何路线。</p><pre class="mq mr ms mt gt or oe os ot aw ou bi"><span id="53fd" class="mz ln iq oe b gy ov ow l ox oy">Navigator.pushNamed(context, LanguageSelectionRoute.routeName);</span><span id="d48c" class="mz ln iq oe b gy oz ow l ox oy">// dummy_widget.dart</span></pre><p id="5e7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我在应用程序中使用导航的方式。所有的路径处理都在同一个文件中，这让我相信项目会更干净，更容易管理。</p><h1 id="63cc" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">添加游戏</h1><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/753c8f7f11a621271d5b4c3253ca88e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/1*wOhlIQjiONIihIA2TDoWpQ.gif"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><a class="ae ll" href="https://www.skillclash.com/en-in/HJT46GkPcy7/Tower-Twist/tournaments-and-battles" rel="noopener ugc nofollow" target="_blank">塔扭</a></figcaption></figure><p id="b40c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的产品是一个游戏应用程序，我必须将HTML5游戏加入其中。尽管我们已经有了发布游戏的服务，但我需要以最真实、最自然的体验将游戏呈现给用户。为此，我使用了一个可信的Web活动。</p><p id="2deb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以没有一个包已经做到了这一点，所以我不得不基本上从头开始创建。目前，该应用程序创建了一个本地视图，我们在<code class="fe ob oc od oe b">MethodChannel</code>的帮助下调用该视图，我也围绕它建立了一个通信。但目前我正在测试平台视图的性能。尽管文件表明这是一种昂贵的操作，在没有颤振当量出现之前应该避免。但是我想比较一下性能，看看在一致性和滞后问题上哪个更好。</p><p id="ca27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经写了一篇文章，解释了我是如何在我们的应用程序中加入可信Web活动的。点击查看<a class="ae ll" rel="noopener ugc nofollow" target="_blank" href="/using-trusted-web-activities-twa-with-flutter-part-1-8722c3b3979b">。</a></p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="ac72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">暂时就这样了。我希望你喜欢这个项目。我总是支持更好的编码实践和策略。由于这个项目是由一个人开发的(当然还有一个测试人员)，这个项目必然会有一些问题。当有报道的时候，我总是在做。上个月，我们在团队中雇佣了一名新人，希望看到更快、更高效的表现。</p><h1 id="6e74" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">在下一篇文章中，我们将讨论</h1><ol class=""><li id="5c7e" class="nl nm iq ka b kb mk kf ml kj nn kn no kr np kv nq nr ns nt bi translated">应用程序中的文本管理</li><li id="2021" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">架构即将发生的变化</li><li id="db44" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">接下来还有什么</li></ol></div></div>    
</body>
</html>