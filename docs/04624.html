<html>
<head>
<title>Refine Objective-C Frameworks for Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完善Swift的目标-C框架</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/refine-objective-c-frameworks-for-swift-keynote-2d72ccbef7eb?source=collection_archive---------9-----------------------#2020-07-06">https://levelup.gitconnected.com/refine-objective-c-frameworks-for-swift-keynote-2d72ccbef7eb?source=collection_archive---------9-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Objective-C将逐渐被Swift取代。在此之前，有很多机会来提升您的Objective-C代码以支持Swift。本文是WWDC为Swift 提炼Objective-C框架的主题演讲。</p><h1 id="64c9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">摘要</h1><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="c282" class="lt kn iq lp b gy lu lv l lw lx"><strong class="lp ir">1. Provide richer type information<br/></strong>  1.1. Describe nullability to control optionals<br/>  1.2. Nullability mistakes</span><span id="3da9" class="lt kn iq lp b gy ly lv l lw lx"><strong class="lp ir">2. Follow Objective-C conventions<br/></strong>  2.1. Use Objective-C generics for Foundation types<br/>  2.2. Use Int for numbers<br/>  2.3. Strengthen stringly-typed constants<br/>  2.4. Specify initializer behavior<br/>  2.5. Follow the error handling convention</span><span id="3b37" class="lt kn iq lp b gy ly lv l lw lx"><strong class="lp ir">3. Address missing APIs<br/>  3.1. Fix missing APIs</strong></span><span id="caac" class="lt kn iq lp b gy ly lv l lw lx"><strong class="lp ir">4. Improve ergonomics in Swift<br/>  4.1. </strong>Improve naming<br/>  <strong class="lp ir">4.2.</strong> Improve error code enums</span></pre><h1 id="8440" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">提供更丰富的类型信息</h1><h2 id="a5c8" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated"><strong class="ak">描述控制选项的可空性</strong></h2><p id="1b38" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">下图描述了没有可空性注释的默认生成行为。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mp"><img src="../Images/66b8d47d845d9a7fa6a5c5e03ba4f542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pjUCIjUYxPRk1EVVIO1i8Q.png"/></div></div></figure><p id="a2ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过添加可空性，使我们的代码更健壮，风格更敏捷。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mx"><img src="../Images/6864e6f27ec8a5bb3dd6160dabb4705b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvVjTQGsQGpUnjpT1yZXJw.png"/></div></div></figure><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi my"><img src="../Images/eea2b689fcf314a8c1cda513ea3cacab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCsD_73aNqgdEmF1lm6vXQ.png"/></div></div></figure><p id="c202" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">常量、全局函数和块可以使用下划线限定符(_Nonnull/_Nullable)，并使其在Swift中成为可选或非可选的。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div class="ab gu cl mz"><img src="../Images/9f553f48724b422ee2a2f38e0e6e986f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wMZGWwYJH6GnI-rxYEhSxA.png"/></div></figure><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi na"><img src="../Images/6c27503fc8821838e7dddb147a1e85a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5SaoL-8vhvzY-ToWJ_NuQ.png"/></div></div></figure><h2 id="c015" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated"><strong class="ak">可空性错误</strong></h2><p id="7784" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">如果您在Objc端使用NSString或NSArray，当Objc为Swift认为不是可选的值返回nil时，非null注释是错误的。您将最终得到一个无效的对象，并且很难被注意到，因为Objc方法调用忽略nil，但是在某些情况下，您将由于空指针取消引用而崩溃或者得到其他意外的行为。</p><p id="0204" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器不保证会发生什么。因此，切换到发布模式或更改Xcode版本可以改变这种错误的症状。Swift相信什么Objc头那个东西不能是nil，Swift不强制-解包，所以你不会在它返回nil的地方看到崩溃。</p><p id="fb73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Objective-C编译器和clang静态分析器来帮忙了，它会检查可空性注释并给你一些警告。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nb"><img src="../Images/4a353b97cf8d4d0ab818b11e824c42a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6GpOs01ls1flHb2aWbQWg.png"/></div></div></figure><p id="f46e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您看到一些警告或分析器结果，但不能确定它们是否真的会发生。您可以使用<strong class="jp ir"> null_unspecified </strong>，这使得Swift将值作为隐式展开的可选值导入。如果您不确定API是否会返回nil，请使用null_unspecified，以防以后出现一些看似不可能的错误行为。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/5ba8e2110f706e05b957161bd1095b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLjsbEY5isYM08VgiNKUng.png"/></div></div></figure><h1 id="e0ec" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">遵循目标C约定</h1><h2 id="9505" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated">对基础类型使用Objective-C泛型</h2><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nd"><img src="../Images/c335e4de24d6fd00f407eedce25103d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Via43lh3GLwk-lfySDeVEg.png"/></div></div></figure><p id="4638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">指定集合元素的类型会让你编码更快捷。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ne"><img src="../Images/df15b17aa66c5ebe28335f066723c20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5oDqULdB8J7xE9X7oz1fA.png"/></div></div></figure><h2 id="80ba" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated">对数字使用Int</h2><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nf"><img src="../Images/4730c168e5cee61fccfc96735c72afd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhC5jH6DzHAkZSZrOQQO0A.png"/></div></div></figure><p id="59b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计数可以是负数，它以NSUInteger的形式返回，这意味着在Swift中它返回一个UInt。这意味着这个函数打破了Swift的惯例。</p><p id="6c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Objc和Swift中，当一个整数表示一组位时，通常使用无符号类型，并且您希望对这些位执行按位操作或进行其他一些算术运算。NSUInteger的大小因架构而异，所以人们很少以这种方式使用它。</p><p id="89aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Objc中使用NSInteger的原因是为了表明一个数字的值决不会是负数。Objective-C通过自动转换和小心溢出行为实现了这种风格。这个特性会导致严重的安全漏洞，所以Swift没有包括它们。相反，如果您想要有符号运算，Swift要求您显式地将无符号类型转换为有符号类型，如果无符号运算会产生负结果，则停止执行。传统的Swift风格是对从不为负的值使用Int。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ng"><img src="../Images/7ab2ff2fd4ada9d246e9d289e3c76a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHakgb8Dk13HDE2T7N37Nw.png"/></div></div></figure><h2 id="e70d" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated">加强字符串类型的常量</h2><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ne"><img src="../Images/2d4ac2f5c7df0f30faa43fdab06848cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Voe8CiMEvGZsEqzlJY0U1g.png"/></div></div></figure><p id="bb27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用typedef将常量组合在一起，并更改所有涉及常量的位置以使用该常量。typedef在Swift中作为typealias导入。这只是开始的一步。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nh"><img src="../Images/c742baf4d28ebbb1155311f9880c8256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0trq7YCQEW-vhh4ELxf1ZQ.png"/></div></div></figure><p id="c67c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在typedef后添加NS_STRING_ENUM宏。它现在作为一个结构导入，常量嵌套在其中，看起来和感觉起来就像一个带有原始字符串值的枚举。重要的是，这意味着阶段计数函数不再接受增加健壮性的任意字符串。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ni"><img src="../Images/3a87081618991b1ed36eebe3be5ddddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Juulmrhjcl_iPadSm7ieJw.png"/></div></div></figure><h2 id="8e49" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated">指定初始值设定项行为</h2><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nj"><img src="../Images/4673b491f94ec08553063023eba6de21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMYJH579XAnZCKQkIhD0sw.png"/></div></div></figure><p id="c28b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题:</p><ul class=""><li id="7aaa" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">Swift会让你覆盖它们，这似乎有点不必要</li><li id="7acc" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">方法init()是由编译器基于NSObject自动生成的</li></ul><p id="5d5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">指定初始化器约定</strong></p><p id="a765" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用NS _ DESIGNATED _ INITIALIZER使你的类成为子类。你可以看看实现文件，看看在重构的时候，你的类中指定的带有[super init]注释的初始化器，</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ny"><img src="../Images/7b8234d495c06eb8325c3d3e0a6e04f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEtphNfHlIMUgBMQ5JZ3LA.png"/></div></div></figure><p id="de02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用关键字NS_UNAVAILABLE显式标记init()方法不可用相当于不继承它们，如果您不覆盖指定的初始化器，Swift会自动这样做。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nz"><img src="../Images/6eee681385b513902ffc92aa0fed0484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCyfOT-0Po4O-K9ahJlTWA.png"/></div></div></figure><h2 id="12f1" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated">遵循错误处理惯例</h2><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oa"><img src="../Images/847a89d4a4afcf15424fbca19af874e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4gCZkmqQu8Bb9ZX2IEYGA.png"/></div></div></figure><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ob"><img src="../Images/1b6459dc0d51da86612adcbac5e9781f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dodnUjfCZ6BTK4x7fFAikg.png"/></div></div></figure><p id="c906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多开发人员误解了错误处理约定。他们认为，如果一个方法想要发出失败信号，它必须返回false并将错误设置为非零值。一个错误的返回和错误是零不是失败。</p><p id="a0a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">错误处理惯例是，如果一个方法返回一个假值，那就是失败，即使错误值为零。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ny"><img src="../Images/d0e1de555ef9cd813a54dcf4dd9f3283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DV7CC3YWS7Y6rS-JgdH9jQ.png"/></div></div></figure><p id="4cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Swift不允许抛出nil，所以如果没有错误，Swift抛出一个非公共的Foundation错误类型，Foundation。_GenericObjcError.nilError。如果您发现日志消息容器这种错误类型，这意味着一些Objc代码要么即使没有失败也返回false，要么失败了但没有告诉您原因。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oc"><img src="../Images/2f0901373398cf28a1e4f436edfb8d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P96jCCt2Maw7mWBWB52Twg.png"/></div></div></figure><p id="3d57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用NS _ SWIFT _ NOTHROW告诉SWIFT你没有遵循约定，手动编写自己的错误处理代码。此外，您可以将此函数标记为不推荐使用，并编写一个更好的替代函数。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi od"><img src="../Images/b7458783bdc0854d0eadcdd13bf57af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzmEiiaOdtvE_qsmzJOopQ.png"/></div></div></figure><p id="b530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循错误处理约定的更好的替代方法是添加一个布尔输出参数来表示文件是否被保存。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oe"><img src="../Images/93477fc3db0aa96969bc620100c15080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0zk9OzEdOpIyiKxpHrAKg.png"/></div></div></figure><p id="b444" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">雨燕版</strong></p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi of"><img src="../Images/28598fe4a37620c19b854c85d0370c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qz_f_ELLr7N8vjiGmVMOwg.png"/></div></div></figure><p id="ce11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过添加关键字:NS_REFINED_FOR_SWIFT，使Swift包装功能仅在Swift上可见。所以Objective-C开发者看不到包装器函数，也就是save(to:wasDirty:)。调用签名将通过添加两个下划线来更改。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi og"><img src="../Images/855e35061066d81d2b932a4fc6e984eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6FXK_OP5Xp9_E4Qc4qqpw.png"/></div></div></figure><h1 id="ef4a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解决缺失的API</h1><h2 id="d9cc" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated">修复缺失的API</h2><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oh"><img src="../Images/2b54f9324e18112cf95f421641a4f18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjbGTsg8ILXzetAlhrt9gA.png"/></div></div></figure><p id="6b2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四个宏被抛弃了。为什么？</p><p id="70b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同一个宏在不同的地方使用时可能意味着不同的事情，Swift没有办法弄清楚一个宏应该如何使用。Swift确实能识别与某些常用于声明常量的模式相匹配的宏。当它看到其中一个时，它会将其作为Swift常量导入。如果该宏替换了另一个宏，那么它会将一个字符串文字连接到该宏。Swift没有完全理解宏替换如何与其他Objc特性交互，所以跳过了它。</p><p id="eade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四个宏应该如下图所示进行重构。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oi"><img src="../Images/97af9354c2e70022b35bad9e0a0b7711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jX_72GS2OjtoNvwlSAGDkA.png"/></div></div></figure><h1 id="12e6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">改进Swift的人体工程学</h1><blockquote class="oj ok ol"><p id="599b" class="jn jo om jp b jq jr js jt ju jv jw jx on jz ka kb oo kd ke kf op kh ki kj kk ij bi translated">Swift的方法命名约定与Objc略有不同。Swift名称往往比较短，并且省略了类型中显而易见的信息。在Swift中，每个方法都有一个基本名称，默认情况下，每个参数都有一个标签。Objc选择器本质上只有参数标签，没有单独的基本名称，所以基本名称包含在第一个参数标签中。</p></blockquote><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oq"><img src="../Images/b94c27d30c33d10f238cdeee0c19bcd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8bETVWTdxDU-GWhB8Ww8A.png"/></div></div></figure><p id="22ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Objc函数由编译器自动拆分，结果通常很好，但您可以通过添加NS_SWIFT_NAME对其进行定制。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi or"><img src="../Images/5ef09479770179bfc5fe9c203d382a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uf1xhsVVF7Yx5OvQ_uZBAQ.png"/></div></div></figure><p id="c1ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NS_SWIFT_NAME不只是针对方法。它几乎可以应用于任何东西。例如，重命名枚举。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi os"><img src="../Images/abd4b4f43ba0df9b69a63df9d61b1949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_5qlrgAobEfO3BAD8ZGwg.png"/></div></div></figure><p id="b413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有一个SKFuel类并且有SKFuelKind枚举。可以改成SKFuel。善良，这可能就是你所说的Swift</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ot"><img src="../Images/c3cf770955e894d455ea4f9cb8355c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXA-Mw782pO4hdviw2u3lw.png"/></div></div></figure><p id="3b77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NS_SWIFT_NAME也可以与全局常量、变量和函数一起使用。例如，重命名功能。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ou"><img src="../Images/f8168d7fc8f62072f8933db2c0f076cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htCZx3CBiNr_GEzyGeBE_w.png"/></div></div></figure><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ov"><img src="../Images/b755943f3f8f53ce1e8e079196c2dbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Dki4o1hBRN6zTCNg1n66Q.png"/></div></div></figure><p id="07f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过指定类型的Objc名称，后跟一个点，以及静态方法的名称，可以将全局函数转换为静态方法。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ow"><img src="../Images/e9972b01816ab7160d090f71b4e76a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RheQSmc8wJDKhBQvnjclsw.png"/></div></div></figure><p id="3aa5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过将其中一个参数标签更改为“self”来将其转换为实例方法。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ox"><img src="../Images/c28dd5dc92ddb9c6b62adba54c938848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfZZdZdUNDKUBsfdVo6ubA.png"/></div></div></figure><p id="b1bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以通过在方法前面加上“getter:”来将方法转换成属性。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oy"><img src="../Images/d4f3232a39705cf96358f4e352df65b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q95zi6ZKv-o_WtPuDm_oIA.png"/></div></div></figure><h2 id="aa64" class="lt kn iq bd ko lz ma dn ks mb mc dp kw jy md me la kc mf mg le kg mh mi li mj bi translated">改进错误代码枚举</h2><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oz"><img src="../Images/48bbf3608e052ce88e0369ebb6772e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GG4zlNyA9izeeBn6dgm76A.png"/></div></div></figure><p id="3da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在为SKErrorCode生成的接口中没有明显的问题迹象。只有当您看到SKErrorCode将如何使用时，您才意识到还有改进的空间。记住，真正重要的是当你的客户试图使用它时，他们会写什么样的调用。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mp"><img src="../Images/c470e5a001fdb2e8295335715cfed7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_OekLPy5bnfzP4mH86sdQ.png"/></div></div></figure><p id="38f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用NS_ERROR_ENUM来增强使用网站的体验。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pa"><img src="../Images/1fcaa3c39767b7fc550ea3b9bfa52ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5doesrfzWn75KpLbeyjQA.png"/></div></div></figure><p id="6da6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器自动合成SKError代码。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi os"><img src="../Images/a52d7946351fc1fd4fee8a201e72b6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FERjtPgF8WruVujV5_1EBA.png"/></div></div></figure><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pb"><img src="../Images/fec3ccdb754b8cc7d89a906484f4ad44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FaQIiPa0ZZAon862dmX8aA.png"/></div></div></figure><p id="cac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以很好地处理错误了。</p><figure class="lk ll lm ln gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pc"><img src="../Images/32aebac4f9665f955c2b70f2e7ac845d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HV1Nd8UehOgiCVbrFeYujQ.png"/></div></div></figure><p id="2a01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读😄祝你今天愉快。</p></div></div>    
</body>
</html>