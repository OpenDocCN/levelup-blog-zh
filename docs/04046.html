<html>
<head>
<title>JavaScript Problem Solvers: Lucky Numbers In A Matrix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题解决者:矩阵中的幸运数字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problem-solvers-lucky-numbers-in-a-matrix-a2525986cdb4?source=collection_archive---------9-----------------------#2020-06-07">https://levelup.gitconnected.com/javascript-problem-solvers-lucky-numbers-in-a-matrix-a2525986cdb4?source=collection_archive---------9-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9f9e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">案例005:服用红色药丸</h2></div><p id="ea5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你和我一样，听到这个词，你会想到这部电影。你会想到尼欧、特工史密斯、锡安和墨菲斯。你会想到黑色背景上一列列无法辨认的绿色文字。</p><p id="0ca4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">matrix</code>这个词通常会让人立即联想到极其复杂的事物，其错综复杂的本质已经到了难以理解的边缘。</p><p id="84f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当涉及到数学或编程时，<code class="fe le lf lg lh b">matrix</code>是一个相反的简单概念。我们不需要插上任何东西或者接听一个一直在响的电话来找出什么是<code class="fe le lf lg lh b">matrix</code>，但是今天的问题让我们很好地体验了JavaScript世界中的矩阵。</p><p id="8630" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们开始解决。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="3f19" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">问题是</h2><p id="64d8" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated"><a class="ae mn" href="https://leetcode.com/problems/lucky-numbers-in-a-matrix/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">这里是LeetCode </strong> </a>上问题的链接</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="3e5e" class="lp lq it lh b gy mw mx l my mz">Given a m * n matrix of distinct numbers, return all lucky numbers in the matrix in any order.</span><span id="153a" class="lp lq it lh b gy na mx l my mz">A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.</span><span id="c918" class="lp lq it lh b gy na mx l my mz">Constraints:<br/>  m == mat.length<br/>  n == mat[i].length<br/>  1 &lt;= n, m &lt;= 50<br/>  1 &lt;= matrix[i][j] &lt;= 10⁵.<br/>  All elements in the matrix are distinct.</span><span id="fabd" class="lp lq it lh b gy na mx l my mz">Test Cases:<br/>  luckyNumbers([[3,7,8],[9,11,13],[15,16,17]]) =&gt; [15]<br/>   Explanation:<br/>    15 is the only lucky number since it is the minimum in its row and the maximum in its column</span><span id="612f" class="lp lq it lh b gy na mx l my mz">  luckyNumbers([[1,10,4,2],[9,3,8,7],[15,16,17,12]]) =&gt; [12]<br/>    Explanation:<br/>      12 is the only lucky number since it is the minimum in its row and the maximum in its column</span><span id="124d" class="lp lq it lh b gy na mx l my mz">  luckyNumbers([[7,8],[1,2]]) =&gt; [7]<br/>    Explanation:<br/>      7 is the only lucky number since it is the minimum in its row and the maximum in its column</span><span id="679e" class="lp lq it lh b gy na mx l my mz">***I added the next test case for a matrix that has more columns than rows</span><span id="8898" class="lp lq it lh b gy na mx l my mz">  luckyNumbers([[7,3],[8,9],[1,2]]) =&gt; [8]<br/>    Explanation:<br/>      8 is the only lucky number since it is the minimum in its row and the maximum in its column</span></pre></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="7e59" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">崩溃了</h2><p id="aa4d" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">首先让我们弄清楚什么是<code class="fe le lf lg lh b">matrix</code>的一些定义:</p><p id="8896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学中的一个<code class="fe le lf lg lh b">matrix</code>是一组按行和列排列的矩形<code class="fe le lf lg lh b">array</code>数字、符号或表达式。数学中矩阵的概念可能会变得非常复杂，虽然很重要，但也超出了本博客的范围。如果你想更深入地了解数学中的矩阵，<a class="ae mn" href="https://courses.lumenlearning.com/boundless-algebra/chapter/introduction-to-matrices/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">我建议查看我在谷歌上找到的第一个链接</strong> </a></p><p id="7290" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编程中的<code class="fe le lf lg lh b">matrix</code>是一个网格，用于以包含行和列的特定结构化格式存储一组数据。如果你有HTML的经验，一个<code class="fe le lf lg lh b">table</code>本质上就是一个<code class="fe le lf lg lh b">matrix</code>。有一些编程语言提供了对<code class="fe le lf lg lh b">matrix</code>数据类型的支持，使得对给定<code class="fe le lf lg lh b">matrix</code>的操作比使用类似<code class="fe le lf lg lh b">array</code>的东西更有效。编程中<code class="fe le lf lg lh b">matrix</code>更常见的用途之一是图形操作。CSS带有一个<code class="fe le lf lg lh b">matrix3d</code>转换属性，您可以使用它在3D空间中操作DOM元素。</p><p id="5fd3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">矩阵也用于在<code class="fe le lf lg lh b">graph</code>中存储关于<code class="fe le lf lg lh b">edge</code>和<code class="fe le lf lg lh b">vertice</code>的数据。我们也可以用一个<code class="fe le lf lg lh b">matrix</code>来表示存储在数据库中的信息。</p><p id="38c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript没有任何对<code class="fe le lf lg lh b">matrix</code>的本地支持。作为一种变通方法，我们通常可以使用嵌套的<code class="fe le lf lg lh b">array</code>，父<code class="fe le lf lg lh b">array</code>中的每个元素都是包含一组整数的子<code class="fe le lf lg lh b">array</code>，根据<code class="fe le lf lg lh b">matrix</code>的用途，这些整数可以表示许多不同的东西。<code class="fe le lf lg lh b">matrix</code>的大小通常由<code class="fe le lf lg lh b">n * n</code>定义，第一个<code class="fe le lf lg lh b">n</code>定义嵌套在父<code class="fe le lf lg lh b">array</code>(或<code class="fe le lf lg lh b">matrix</code>中的列)中的<code class="fe le lf lg lh b">array</code>的数量，第二个<code class="fe le lf lg lh b">n</code>定义每个子<code class="fe le lf lg lh b">array</code>中有多少个元素(或<code class="fe le lf lg lh b">matrix</code>中的行数)。</p><p id="4169" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，3x3 <code class="fe le lf lg lh b">matrix</code>看起来像这样:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="125e" class="lp lq it lh b gy mw mx l my mz">[[1,2,3],[4,5,6],[7,8,9]]</span></pre><p id="c74e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一个网格中，看起来像这样:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="92c1" class="lp lq it lh b gy mw mx l my mz">1 2 3<br/>4 5 6<br/>7 8 9</span></pre><p id="fb19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着第一行由第一个嵌套的<code class="fe le lf lg lh b">array</code>表示，第二行由下一个嵌套的<code class="fe le lf lg lh b">array</code>表示，依此类推。<code class="fe le lf lg lh b">matrix</code>中的一行称为行向量，一列称为列向量。</p><p id="3117" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在《黑客帝国》电影的介绍中所记得的那些黑色背景上的无法辨认的绿色文本列实际上只是矩阵中的列向量。在技术和理论意义上都是如此，因为它们应该代表矩阵中正在发生的事情。</p><p id="24a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe le lf lg lh b">matrix</code>也不需要有等量的行和列。列数多于行数的<code class="fe le lf lg lh b">matrix</code>称为宽<code class="fe le lf lg lh b">matrix</code>。</p><p id="e2ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以有一个像这样的<code class="fe le lf lg lh b">matrix</code>:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="5842" class="lp lq it lh b gy mw mx l my mz">[[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><span id="40ad" class="lp lq it lh b gy na mx l my mz">1  2  3  4<br/>5  6  7  8<br/>9 10 11 12</span></pre><p id="8409" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者像这样的<code class="fe le lf lg lh b">matrix</code>:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="e85e" class="lp lq it lh b gy mw mx l my mz">[[1,2],[3,4],[5,6],[7,8]]</span><span id="1741" class="lp lq it lh b gy na mx l my mz">1 2<br/>3 4<br/>5 6<br/>7 8</span></pre><p id="3636" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个都是有效的。</p><p id="b764" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，现在我们对什么是<code class="fe le lf lg lh b">matrix</code>有了一个清晰的定义，让我们把注意力重新集中到手头的问题上。</p><p id="cfda" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先将问题分解成更小的部分，这样我们就能确保理解对我们的期望:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="6607" class="lp lq it lh b gy mw mx l my mz">Given a m * n matrix of distinct numbers, return all lucky numbers in the matrix in any order.</span></pre><p id="9ed6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先看到的东西之一是<code class="fe le lf lg lh b">m * n</code> <code class="fe le lf lg lh b">matrix</code>。基于上面的定义，我们知道<code class="fe le lf lg lh b">m * n</code>定义了传递给<code class="fe le lf lg lh b">function</code>的<code class="fe le lf lg lh b">matrix</code>的大小。这里的问题是，由于<code class="fe le lf lg lh b">matrix</code>的大小被定义为<code class="fe le lf lg lh b">m * n</code>而不是<code class="fe le lf lg lh b">n * n</code>，我们需要考虑行数或列数不相等的<code class="fe le lf lg lh b">matrix</code>。</p><p id="ad9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到的下一个重要的东西是<code class="fe le lf lg lh b">distinct numbers</code>，这意味着<code class="fe le lf lg lh b">matrix</code>中的所有元素都是唯一的。</p><p id="56b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也知道我们的预期输出应该是什么，这与it的要求相当宽松:<code class="fe le lf lg lh b">return all lucky numbers in the matrix in any order</code></p><p id="d966" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，我们还不知道什么是幸运数字，但是不必按照特定的顺序排列<code class="fe le lf lg lh b">return</code>元素给了我们<code class="fe le lf lg lh b">function</code>如何操作的一些自由。</p><p id="7665" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们得到一个幸运数字的定义:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="613b" class="lp lq it lh b gy mw mx l my mz">A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.</span></pre><p id="f67f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是不言自明的。</p><p id="20d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我唯一的问题是，如果<code class="fe le lf lg lh b">matrix</code>中的所有数字都是唯一的，我们不是总能得到1个幸运数字吗？</p><p id="66fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不知道。</p><p id="228a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的约束给了我们一些更有用的信息，但似乎只是进一步概述了问题解释中已经解释的内容:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="f6ad" class="lp lq it lh b gy mw mx l my mz">m == mat.length</span></pre><p id="efe5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有助于我们理解，如果<code class="fe le lf lg lh b">m * n</code>定义了<code class="fe le lf lg lh b">matrix</code>的大小，那么<code class="fe le lf lg lh b">m</code>就等于嵌套<code class="fe le lf lg lh b">array</code>中sub <code class="fe le lf lg lh b">array</code>的数量，这也代表了矩阵网格中的列数。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="afa0" class="lp lq it lh b gy mw mx l my mz">n == mat[i].length</span></pre><p id="6714" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似于上面的约束，因为<code class="fe le lf lg lh b">m * n</code>定义了<code class="fe le lf lg lh b">matrix</code>的大小，那么<code class="fe le lf lg lh b">n</code>等于每个子<code class="fe le lf lg lh b">array</code>中的元素数量，这也表示矩阵网格中的行数。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="012c" class="lp lq it lh b gy mw mx l my mz">1 &lt;= n, m &lt;= 50</span></pre><p id="fea2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们得到了在给定的<code class="fe le lf lg lh b">matrix</code>中我们应该期望的行数和列数的范围。<code class="fe le lf lg lh b">1 &lt;= n</code>告诉我们，我们期望的最小行数是1，<code class="fe le lf lg lh b">m &lt;= 50</code>告诉我们，我们期望的最大列数是50。</p><p id="26f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也意味着<code class="fe le lf lg lh b">matrix</code>中的行数和列数相互独立。我想说它们是线性无关的，但是看完线性无关，我承认我不确定。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="6663" class="lp lq it lh b gy mw mx l my mz">1 &lt;= matrix[i][j] &lt;= 10⁵.</span></pre><p id="f858" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">matrix[i]</code>代表矩阵中的每个子<code class="fe le lf lg lh b">array</code>，或每个行向量。<code class="fe le lf lg lh b">matrix[i][j]</code>表示<code class="fe le lf lg lh b">matrix</code>中每个数字的计算成员访问表示。我们得到一个下限，这里的<code class="fe le lf lg lh b">1 &lt;= matrix[i][j]</code>，意味着在给定的<code class="fe le lf lg lh b">matrix</code>中没有一个数会是0。我们还得到一个上限，这里的<code class="fe le lf lg lh b">matrix[i][j] &lt;= 10⁵</code>，意味着给定<code class="fe le lf lg lh b">matrix</code>中的最大数将是100，000。</p><p id="037b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还从<code class="fe le lf lg lh b">matrix[i][j]</code>中得到一个小提示，这意味着我们需要在某个地方使用嵌套循环。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="d568" class="lp lq it lh b gy mw mx l my mz">All elements in the matrix are distinct.</span></pre><p id="b802" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很有帮助，允许我们排除相同数字的布尔比较。</p><p id="b3b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的测试用例也相当简单，因为我们正在<code class="fe le lf lg lh b">return</code>处理一组数字，我们看到我们应该<code class="fe le lf lg lh b">return</code>处理<code class="fe le lf lg lh b">array</code>。但是我们的测试用例的所有预期结果都是只有一个元素的。这是我又一次觉得奇怪的事情，并且回避了这个问题“既然给定的<code class="fe le lf lg lh b">matrix</code>中的所有数字都是唯一的，难道不会只有一个幸运数字吗？”</p><p id="4878" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不知道，我们继续吧。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="69bc" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">边缘案例</h2><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="03e2" class="lp lq it lh b gy mw mx l my mz">1.) A row or column vector contains a 0</span></pre><p id="dd48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们不必担心的事情，因为我们有一个约束<code class="fe le lf lg lh b">1 &lt;= matrix[i][j]</code></p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="8cae" class="lp lq it lh b gy mw mx l my mz">2.) A sub array is empty</span></pre><p id="2df2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再一次，由于给定了两个约束，我们不必担心这个问题:<code class="fe le lf lg lh b">n == mat[i].length</code>和<code class="fe le lf lg lh b">1 &lt;= n</code></p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="3450" class="lp lq it lh b gy mw mx l my mz">3.) Two numbers in the array are equal</span></pre><p id="9d06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，这是一个我们不必担心的边缘情况，因为它被我们的一个约束所覆盖:<code class="fe le lf lg lh b">All elements in the matrix are distinct.</code></p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="70a1" class="lp lq it lh b gy mw mx l my mz">4.) There are more row vectors than column vectors or visa versa</span></pre><p id="ccde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是事情变得有点奇怪的地方。我们被特别给定了大小为<code class="fe le lf lg lh b">m * n</code>的矩阵，以及<code class="fe le lf lg lh b">m == mat.length</code>和<code class="fe le lf lg lh b">n == mat[i].length</code>。</p><p id="bb8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不是这种情况，并且给我们一个大小为<code class="fe le lf lg lh b">n * n</code>而<code class="fe le lf lg lh b">n == mat.length</code>的矩阵，我们就能够将特定的操作(我将在下一节解释并指出)组合在一起。但是因为我们需要适应不同行和列长度的矩阵，我们将不得不把事情分开。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="e4b4" class="lp lq it lh b gy mw mx l my mz">5.) An element in the parent array is not an array, or an element in a sub array is not a number</span></pre><p id="27ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个问题并不重要，但我想我会把它放在这里，因为这可能是一个在技术面试中问的好问题。</p><p id="ccab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们假设每个sub <code class="fe le lf lg lh b">array</code>都是一个<code class="fe le lf lg lh b">array</code>，每个sub <code class="fe le lf lg lh b">array</code>中的每个元素都是一个数字。这在问题的解释中没有具体说明。我们可以得到一个与<code class="fe le lf lg lh b">matrix</code>中sub <code class="fe le lf lg lh b">array</code>的剩余部分长度相同的字符串，其中<code class="fe le lf lg lh b">m == mat.length</code>仍然为真，因为<code class="fe le lf lg lh b">mat.length</code>可能是一个字符串的长度。<code class="fe le lf lg lh b">mat[i]</code>将是字符串中的每个字符，这意味着<code class="fe le lf lg lh b">mat[i].length</code>将等于1，因为每个字符的长度为1。如果<code class="fe le lf lg lh b">mat</code>不是一个字符串，这仍然可以产生一个有效的<code class="fe le lf lg lh b">matrix</code>,如果sub <code class="fe le lf lg lh b">array</code>被一个字符串替换，这可能会丢弃我们函数的结果。</p><p id="3097" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简洁起见，我假设我们总是有子数组和数字。</p><p id="f977" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们已经彻底检查了提供给我们的所有信息，我们可以开始考虑如何解决这个问题。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="2faf" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">嫌疑犯</h2><p id="f14a" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">我提出了一些可能的解决方案，试图避免嵌套迭代，但最终我放弃了，提出了一个包含3个不同部分的解决方案。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="ac07" class="lp lq it lh b gy mw mx l my mz">1.) Find the smallest number in each row</span><span id="9af9" class="lp lq it lh b gy na mx l my mz">2.) Find the largest number in each column</span><span id="6c91" class="lp lq it lh b gy na mx l my mz">3.) Compare the smallest number in each row and the largest number in each column and when a match is found, it means it is a lucky number.</span></pre><p id="a6d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最初想将前两部分结合在一起，同时在同一个嵌套循环中找到每行中的最小数字和每列中的最大数字。如果我们将<code class="fe le lf lg lh b">matrix[i][j]</code>的计算成员访问操作符切换到<code class="fe le lf lg lh b">matrix[j][i]</code>，我们可以同时遍历每一列及其对应的行。</p><p id="aa5e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果每个矩阵的大小都是<code class="fe le lf lg lh b">n*n</code>的话，这是可行的。但事实并非如此。它们的尺寸是<code class="fe le lf lg lh b">m*n </code>。这意味着如果<code class="fe le lf lg lh b">matrix</code>中的列向量的数量不等于行向量的数量，传统上我们不能将两种搜索算法结合到同一个函数中。</p><p id="cf55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，让我们分别讨论每一部分:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="164d" class="lp lq it lh b gy mw mx l my mz">1.) Find the smallest number in each row</span></pre><p id="5dd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这相当简单。我们需要找到每行中最小的数字，因为它是幸运数字的特征，并将它们存储在名为<code class="fe le lf lg lh b">minRow</code>的<code class="fe le lf lg lh b">array</code>中。我们需要将每个数字存储在<code class="fe le lf lg lh b">minRow</code>中，这样我们就可以将它的每个元素与我们为每一列找到的最大数字进行比较。我们可以用一个简单的<code class="fe le lf lg lh b">for</code>循环或者一个<code class="fe le lf lg lh b">for…in</code>循环来实现，这个循环遍历整个<code class="fe le lf lg lh b">matrix</code>并将每个数字与<code class="fe le lf lg lh b">Math.min()</code>进行比较。我们可以通过调用<code class="fe le lf lg lh b">Math.min.apply()</code>来避免在这里嵌套循环。<code class="fe le lf lg lh b">.apply()</code> <code class="fe le lf lg lh b">function</code>很有趣，因为它调用了<code class="fe le lf lg lh b">function</code>并重新分配了<code class="fe le lf lg lh b">this</code>变量，但是需要一个数组来传递参数。</p><p id="57dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">Math.min()</code>上调用<code class="fe le lf lg lh b">.apply()</code>会自动找到我们传递给它的任何<code class="fe le lf lg lh b">array</code>中最小的数字。</p><p id="1b4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在每次迭代中调用<code class="fe le lf lg lh b">Math.min.apply()</code>，并将当前正在迭代的sub <code class="fe le lf lg lh b">array</code>传递给<code class="fe le lf lg lh b">Math.min.apply()</code>，那么我们可以将结果<code class="fe le lf lg lh b">push</code>传递给<code class="fe le lf lg lh b">minRow</code>。</p><p id="29a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有效地避免了嵌套一个<code class="fe le lf lg lh b">for</code>循环来寻找每一行的最小数字，我们可以进入下一步:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="ebb7" class="lp lq it lh b gy mw mx l my mz">2.) Find the largest number in each column</span></pre><p id="b46e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能遵循寻找每一行中最小数字的相同方法，因为我们将遍历和比较不同子<code class="fe le lf lg lh b">array</code>中的元素</p><p id="437a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了找到每一列中的最大数字，我们将(但不是必须)求助于嵌套一个<code class="fe le lf lg lh b">for</code>循环。</p><p id="d415" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道，我也讨厌它。</p><p id="1ac7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将想要定义另一个名为<code class="fe le lf lg lh b">maxCol</code>的空<code class="fe le lf lg lh b">array</code>。这个<code class="fe le lf lg lh b">array</code>将在每一列中存储最大值，这样我们以后可以使用它，并将它的元素与<code class="fe le lf lg lh b">minRow</code>中的元素进行比较。</p><p id="f55b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以设置一个<code class="fe le lf lg lh b">for</code>循环或者一个<code class="fe le lf lg lh b">for…in</code>循环，变量叫做<code class="fe le lf lg lh b">max</code>，并设置为0。这将记录一列中最大的数字。然后，我们可以建立一个嵌套的<code class="fe le lf lg lh b">for</code>循环或<code class="fe le lf lg lh b">for..in</code>循环，将<code class="fe le lf lg lh b">max</code>与一列中的每个数字进行比较，或<code class="fe le lf lg lh b">matrix[j][i]</code>，如果一列中的数字较大，则替换<code class="fe le lf lg lh b">max</code>的值。</p><p id="c8ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每次迭代结束时，我们可以将<code class="fe le lf lg lh b">push</code> <code class="fe le lf lg lh b">max</code>转换成<code class="fe le lf lg lh b">maxCol</code>。由于我们将<code class="fe le lf lg lh b">max</code>的值硬编码为0，并在嵌套的<code class="fe le lf lg lh b">for</code>循环的<code class="fe le lf lg lh b">scope</code>之外定义它，因此<code class="fe le lf lg lh b">max</code>将在每次迭代中自动重置为0。</p><p id="ac7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使我们进入了函数的最后一部分:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="ac93" class="lp lq it lh b gy mw mx l my mz">3.) Compare the smallest number in each row and the largest number in each column and when we find a match, we find a lucky number</span></pre><p id="4ffa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过在<code class="fe le lf lg lh b">minRow</code>上调用<code class="fe le lf lg lh b">.filter()</code>，然后在<code class="fe le lf lg lh b">.filter()</code>调用中调用<code class="fe le lf lg lh b">maxCol</code>上的<code class="fe le lf lg lh b">.includes()</code>，从技术上避免另一个嵌套循环。我说技术上是因为<code class="fe le lf lg lh b">.includes()</code>在技术上仍在重复<code class="fe le lf lg lh b">maxCol</code>。无论哪种方式，这都应该从<code class="fe le lf lg lh b">minRow</code>中删除任何在<code class="fe le lf lg lh b">maxCol</code>中找不到的数字，这意味着我们可以返回对<code class="fe le lf lg lh b">minRow</code>的<code class="fe le lf lg lh b">.filter()</code>调用的结果，并得到我们想要的结果。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="19a2" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">伪代码</h2><p id="58ba" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">因为要经历很多，可能很难想象，所以让我们从不同的角度来看我们潜在的解决方案，并编写一些伪代码:</p><figure class="mo mp mq mr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="e20b" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">评论</h2><p id="2f6b" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">让我们开始一步一步地编写代码，并以伪代码为基础:</p><p id="1947" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们定义我们的函数<code class="fe le lf lg lh b">luckyNumbers</code>，以及我们的<code class="fe le lf lg lh b">minRow</code>和<code class="fe le lf lg lh b">maxCol</code> <code class="fe le lf lg lh b">array</code> s:</p><figure class="mo mp mq mr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0a41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们定义两个<code class="fe le lf lg lh b">for..in</code>循环(您也可以使用普通的<code class="fe le lf lg lh b">for</code>循环),我们将使用这两个循环来查找每行中的最小数字和每列中的最大数字:</p><figure class="mo mp mq mr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c97e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，让我们将逻辑添加到第一个<code class="fe le lf lg lh b">for…in</code>循环中，该循环将查找每行中的最小数字:</p><figure class="mo mp mq mr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7355" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以设置第二个<code class="fe le lf lg lh b">for..in</code>循环以及<code class="fe le lf lg lh b">max</code>变量和嵌套的<code class="fe le lf lg lh b">for…in</code>循环:</p><figure class="mo mp mq mr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="33ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以将逻辑添加到嵌套的<code class="fe le lf lg lh b">for…in</code>循环中，查找每列中的最大数字，并将<code class="fe le lf lg lh b">push</code> <code class="fe le lf lg lh b">max</code>添加到<code class="fe le lf lg lh b">maxCol</code>:</p><figure class="mo mp mq mr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="668d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以返回对<code class="fe le lf lg lh b">minRow</code>的<code class="fe le lf lg lh b">.filter()</code>调用，过滤掉没有同时出现在<code class="fe le lf lg lh b">minRow</code>和<code class="fe le lf lg lh b">maxCol</code>中的任何数字:</p><figure class="mo mp mq mr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="da2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行我们的解决方案，我们应该通过我们的测试用例:</p><figure class="mo mp mq mr gt nb gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/2bb776947c10166e5f86c1ff105fe9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*dDV3qDTnIzeQAh0KKOlHyw.jpeg"/></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="d359" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">最终解决方案</h2><p id="5cba" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">让我们最后看一下不带注释的解决方案，并清理一些语法:</p><figure class="mo mp mq mr gt nb"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="514a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">超级骗子。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h2 id="4340" class="lp lq it bd lr ls lt dn lu lv lw dp lx kr ly lz ma kv mb mc md kz me mf mg mh bi translated">任务完成</h2><p id="0998" class="pw-post-body-paragraph ki kj it kk b kl mi ju kn ko mj jx kq kr mk kt ku kv ml kx ky kz mm lb lc ld im bi translated">如果您不熟悉矩阵，它可能会成为一个相当令人困惑或令人不知所措的话题。永远记住，它们远没有你想象的那么复杂，在JavaScript的世界里，矩阵只是一堆嵌套的数组。</p><p id="ac68" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再说一次，我写的关于解决LeetCode或HackerRank问题的博客并不是为了找到时间或空间复杂度最低的解决方案。他们关注的是解决问题的步骤。</p><p id="8842" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我当然明白我的解决方案不会是最好的或最有效的，但不管怎样，我希望它们能帮助你或其他人找到一种方法来解决你在这个旅程中遇到的问题，我们称之为JavaScript。</p><p id="bdc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保持安全…保持健康…继续为正义而战。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><div class="mo mp mq mr gt nh"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">编写面试问题</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">技术开发</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv nf nh"/></div></div></a></div></div></div>    
</body>
</html>