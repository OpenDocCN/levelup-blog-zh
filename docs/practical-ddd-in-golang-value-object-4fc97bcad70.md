# 戈朗实用 DDD:价值目标

> 原文：<https://levelup.gitconnected.com/practical-ddd-in-golang-value-object-4fc97bcad70>

让我们从最重要的模式——值对象——开始 Golang 领域驱动设计的实践之旅。

![](img/5eaf0254d802a3f184877bb2dfece35a.png)

[梁杰森](https://unsplash.com/@ninjason)在 [Unsplash](https://unsplash.com/) 上的照片

说某个模式是最重要的可能听起来有些夸张，但是我甚至不会为此争论。第一次听说[价值对象](https://martinfowler.com/bliki/ValueObject.html)是在[大红宝书](https://www.amazon.de/-/en/Martin-Fowler/dp/0321127420)里，来自[马丁福勒](https://twitter.com/martinfowler)。在那一点上，它看起来很简单，也没什么意思。下一次我读到关于它的东西是在埃里克·埃文斯的蓝色大书里。从那时起，这种模式开始变得越来越有意义，很快我就无法想象不到处使用值对象来编写代码。

# 简单却美丽

初看起来，值对象是一个简单的模式。它将一些属性组合成一个单元，提供特定的行为。这个单位代表了某种特定的质量或数量，我们可以在现实世界中找到，并将其与某种更复杂的物体联系起来。它提供了一些特定的价值或特征。它可以是颜色或货币([Value 对象的一个子类型](https://martinfowler.com/eaaCatalog/money.html))、电话号码或任何其他提供一些值的小对象，如下面的代码块所示。

在 Golang 中，值对象可以表示为新的结构或通过扩展一些原始类型来表示。在这两种情况下，想法都是为单个值或一组值提供额外的独特行为。在许多情况下，Value 对象可以提供特定的字符串格式化方法，以定义值在 JSON 编码或解码中的行为。尽管如此，这些方法的主要目的应该是支持与现实生活中的特征或质量相关的业务不变量。

# 身份和平等

值对象没有同一性，这是它与[实体](https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/)模式的关键区别。实体模式有一个身份作为其唯一性的描述。如果两个实体有一些相同之处，那么这意味着我们谈论的是相同的对象。值对象没有该标识。值对象只有一些更好地描述其值的字段。为了测试两个值对象之间的相等性，我们需要检查所有字段的相等性，如下面的代码块所示。

在上面的例子中，Money 和 Color 结构都定义了检查所有字段的 EqualTo 方法。另一方面，货币检查身份的相等性，在这个例子中是 UUID。

您可能会注意到，值对象也可以引用一些实体对象，比如本例中的货币。它还可以包含一些其他更小的值对象，如 struct Coin，它包含颜色和货币。或将切片定义为颜色的集合。

在一个[有界上下文](https://martinfowler.com/bliki/BoundedContext.html)中，我们可以有几十个值对象。尽管如此，它们中的一些实际上可以是其他有界上下文中的实体。货币的情况就是如此。在一个简单的 Web 服务上，当我们想要呈现一些货币时，我们可以将货币视为一个值对象，绑定到我们的货币上，我们不打算改变它。另一方面，在支付服务上，我们希望通过一些交换服务 API 进行实时更新，我们需要在域模型中使用身份。在这种情况下，我们将在不同的服务上有不同的货币实现。

我们想要使用的模式，无论是值对象还是实体，都只取决于该对象在有界上下文中表示的内容。如果它是一个可重用的对象，独立地存储在数据库中，可以改变并应用于许多其他对象，或者耦合到某个外部实体，当外部实体改变时，它也需要改变，我们就说实体。但是，如果一个对象描述了一些值，属于一个特定的实体，它是一个来自外部服务的简单拷贝，或者它不应该独立存在于数据库中，那么它就是一个值对象。

# 直言不讳

值对象最有用的特征是它的明确性。在 Golang(或任何其他编程语言)的原始类型不支持特定行为，或者所支持的行为不直观的情况下，它为外部世界提供了清晰性。我们可以在许多项目上与客户打交道，这些项目必须满足一些业务不变量，比如成为一个成年人或代表一些法律实体。在这些情况下，提供更显式的类型，如生日和合法形式，是一种合理的方法。

有时，值对象不需要明确定义为任何其他实体或值对象的一部分。不过，我们可以将值对象定义为帮助对象，为以后在代码中的使用提供清晰性。这就是与客户打交道的情况，客户可以是个人，也可以是公司。根据客户的类型，我们在应用程序中有不同的流程。其中一个更好的方法可以是转化客户，使之更容易处理。

尽管在一些项目中可能会发生转换的情况，但是在大多数情况下，它们告诉我们应该添加那些值对象，作为我们的领域模型的一个真实的部分。事实上，每当我们注意到一些特定的更小的字段组不断地相互作用，但它们在一些更大的组中，这已经是一个迹象，表明我们应该将它们分组到值对象中，并像在我们的更大的组(现在变得更小)中那样使用它。

# 不变

值对象是不可变的。在值对象的生命周期中，没有单一的原因、理由或其他参数来改变其状态。有时多个对象可以包含一个相同值的对象(尽管这不是一个完美的解决方案)。在这些情况下，我们绝对不希望在一些意想不到的地方改变值对象。因此，每当我们想要改变 Value 对象的内部状态或组合多个状态时，我们总是需要返回一个具有新状态的新实例，如下面的代码块所示。

在所有的例子中，唯一正确的方法是总是返回新的实例，而不动旧的实例。Golang 中的良好实践是始终将函数绑定到值，而不是值对象的引用，以确保我们永远不会改变内部状态。

这种不变性意味着我们不应该在值对象的整个生命周期中验证它，而应该只在创建时验证它，就像上面的例子一样。当我们想要创建一个新的值对象时，我们必须总是执行验证，如果不满足业务不变量，则返回错误，并且仅当值对象有效时才创建值对象。从那时起，不再需要验证值对象。

# 丰富的行为

值对象提供了许多不同的行为。它的主要目的是提供一个可及的接口。如果是贫血，我们或许应该在没有任何方法的情况下，想一个它存在的理由。如果值对象在某些特定的代码位置确实有意义，那么它提供了大量额外的业务不变量，可以更好地描述我们想要解决的问题。

将整个领域模型分解成像值对象(和实体)这样的小块，使得代码清晰，并且接近真实世界中的业务逻辑。每个值对象可以描述一些小组件，并支持许多类似于常规业务流程的行为。最后，这使得单元测试的整个过程更加容易，并且有助于覆盖所有的边缘情况。

# 结论

现实世界充满了不同的特征、品质和数量。当软件应用程序试图解决现实世界的问题时，使用这样的量词是不可避免的。价值对象是作为解决我们业务逻辑中这种显式性的解决方案呈现给我们的。

# 有用的资源:

*   [https://martinfowler.com/](https://martinfowler.com/)
*   https://www.domainlanguage.com/