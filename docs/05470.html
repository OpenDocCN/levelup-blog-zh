<html>
<head>
<title>Building the Web: Sockets and Servers for Dummies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建网络:虚拟的插座和服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-the-web-sockets-and-servers-for-dummies-886d1595a4f8?source=collection_archive---------6-----------------------#2020-09-01">https://levelup.gitconnected.com/building-the-web-sockets-and-servers-for-dummies-886d1595a4f8?source=collection_archive---------6-----------------------#2020-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/673b0827bd242570c34e00c2355937e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SBND0ika-psOFCr6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@tvick?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰勒维克</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c9ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">什么是web服务器？</em></p><p id="6e0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能熟悉这样的解释:<strong class="kf ir">web服务器是运行在计算机上的一个进程，它接受HTTP请求并发回HTTP响应</strong>。但是什么样的过程呢？它跑向哪里？运行情况如何？还有最重要的:<strong class="kf ir"> <em class="lb">我如何构建一个？</em>T13】</strong></p><p id="b81d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将剖析一个简单web服务器的基本软件组件——这些概念与语言无关，并使用我们的操作系统提供的一些核心基础设施。我将专门使用python的库，但是大多数编程语言都有某种访问套接字的方式。</p><p id="dec9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，我恳求你跟随你自己的终端。通过在您自己的python环境中构建web的基本组件，您将会发现更多。我会让这变得非常简单:只需打开一个终端并启动一个python shell。(你可以用python 2，但我更喜欢python 3)</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a0a1" class="ll lm iq lh b gy ln lo l lp lq">$ python3</span></pre><p id="da18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们进入web服务器之前，我们必须从您可能听说过，但从未真正理解的东西开始:</p><h1 id="0bf7" class="lr lm iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">插座</h1><p id="4a17" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">一般来说，网络通信和计算机通信的核心是不起眼的<strong class="kf ir">插座</strong>。套接字是一种软件抽象，用于表示和控制通信端点。它可以监听通信，连接到另一个套接字，发送响应，关闭这些连接，等等…</p><p id="4ea1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这看起来太抽象，现在，你可以想象一个理论上的邮箱。在python中，我可以非常简单地创建一个新的套接字。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="fcbe" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; import socket<br/>&gt;&gt;&gt; sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></pre><p id="a69f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这创建了一个套接字的<strong class="kf ir">实例</strong>，但是没有地址。不是很有用。这就像一个邮箱漂浮在真空中，没有人能找到它。为了给它一个地址，我<strong class="kf ir">将</strong>我的套接字绑定到一个地址<em class="lb">(例如:127.0.0.1:8888)。</em>你们中的一些人可能认识这个地址，这是一个用于本地web服务器的通用端口，尤其是节点服务器。现在让我们将套接字绑定到该地址。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ffd2" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; sock.bind(('', 8888))</span></pre><p id="61a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv lh b">bind</code>接受主机名和端口的元组。<code class="fe mt mu mv lh b">''</code>表示绑定到所有接口。</p><p id="3cfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我的邮箱位于本地机器的8888端口。问题是，它关门了——不接受邮件。任何发送消息的人都会发现他们无法连接。检查一下，打开一个新的shell窗口:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="df8a" class="ll lm iq lh b gy ln lo l lp lq">$ curl localhost:8888</span></pre><p id="dd89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">过一会儿，您的请求应该超时:“无法连接到本地主机端口8888”。那是因为你的插座关了。</p><p id="c924" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了允许传入的连接，您需要将您的套接字转换成一个<strong class="kf ir">监听套接字:</strong></p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d43d" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; REQUEST_QUEUE_SIZE = 5<br/>&gt;&gt;&gt; sock.listen(REQUEST_QUEUE_SIZE)</span></pre><p id="e599" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你的邮箱已经打开，可以接收邮件了。您的套接字正在侦听传入的请求。但是仍然有一个问题:没有人检查它。尝试通过curl再次连接到您的插座:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="f5f6" class="ll lm iq lh b gy ln lo l lp lq">$ curl localhost:8888<br/></span></pre><p id="8920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该永远挂着。注意，您没有连接失败——事实上，您已经成功地向套接字发送了请求！问题是套接字没有发送任何响应，它只是在侦听，就像你的前女友收件箱一样。但是请记住，我们的套接字一次只能容纳队列中的5条消息，所以我们需要快速开始处理这些消息！</p><p id="16e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是<code class="fe mt mu mv lh b">socket.accept</code>的作用。Accept告诉您的套接字等待队列中的下一封邮件(或者如果它已经在那里就抓取它)并使用<strong class="kf ir">客户端地址</strong>打开<strong class="kf ir">一个新的套接字</strong>。这有点令人困惑，但你会明白我的意思。在您的python shell中亲自尝试一下:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="c8f6" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; client_connection, client_address = sock.accept()<br/>&gt;&gt;&gt; client_address<br/>('127.0.0.1', 52095)  # your address won't be quite the same</span></pre><p id="07c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，<code class="fe mt mu mv lh b">socket.accept()</code>返回一个client_connection <em class="lb">，它实际上是一个全新的套接字</em>，以及该客户端的地址。在本例中，我们看到客户端来自本地主机(127.0.0.1)的端口52095。这是一个短暂的端口——计算机为了发出curl请求，凭空创建了它。请记住，这个新套接字是原始套接字端口和新客户端地址之间的一个<strong class="kf ir">连接</strong>。试试这个:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="d438" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; client_connection.getsockname()<br/>('127.0.0.1', 8888)<br/>&gt;&gt;&gt; client_connection.getpeername()<br/>('127.0.0.1', 52095  # your address won't be quite the same</span></pre><p id="117e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，这个套接字仍然位于端口8888。这种类型的插座称为<strong class="kf ir">连接</strong>插座<strong class="kf ir">。</strong>您最初的<strong class="kf ir">监听套接字</strong>仍然存在——它的工作是继续监听更多的请求(例如，您可以打开另一个终端，发出一个新的curl请求，然后再次调用<code class="fe mt mu mv lh b">socket.accept</code>，您将拥有另一个连接)</p><p id="6d19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过套接字向curl客户端发回一条消息:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5f5e" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; client_connection.recv(1024)  # read the request<br/>&gt;&gt;&gt; response = b"""HTTP/1.1 200 OK\n\nHello World!"""<br/>&gt;&gt;&gt; client_connection.sendall(response)<br/>&gt;&gt;&gt; client_connection.close()</span></pre><p id="d100" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“b”表示这是一个字节串。您应该会在curl终端中收到一条消息！<strong class="kf ir">万岁！！</strong></p><p id="f2ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种通过套接字发送HTTP的想法是服务器和web应用程序领域的开端，我迫不及待地想告诉大家这一切——但首先，让我们快速回顾一下:</p><ul class=""><li id="f202" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">套接字是绑定到地址的通信端点</li><li id="5c1e" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">一个<strong class="kf ir">监听插座</strong>监听特定地址的通信</li><li id="be03" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><strong class="kf ir">连接套接字</strong>由监听套接字在接受请求时创建，负责管理连接、完成请求并发送响应。</li><li id="2d93" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">您可以通过套接字接受HTTP请求和发送HTTP响应，等等。记住，套接字是一个通用的通信通道。你可以发送你想要的任何字节的数据。</li></ul><h1 id="db14" class="lr lm iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">一个简单的网络服务器</h1><p id="3b0d" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">您可能已经开始预料到这一点，但是<strong class="kf ir"> web服务器</strong>本质上是一个开放的套接字，在一个无限循环中监听和接受请求，就像这样:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="8419" class="ll lm iq lh b gy ln lo l lp lq">server_socket = ...<br/>&lt;instantiate_socket_here&gt;  # pseudocode</span><span id="ef30" class="ll lm iq lh b gy nk lo l lp lq">while true:  # do forever<br/>    client, _ = server_socket.accept()<br/>    request = client.recv(1024)  # read 1024 bytes from the request<br/>    <br/>    # run the request through your web framework of choice<br/>    response = run_web_application(request)</span><span id="7aef" class="ll lm iq lh b gy nk lo l lp lq">    # send the response back to the client<br/>    client.sendall(response)<br/>    client.close()</span></pre><p id="82a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务器接受连接、处理请求、发送响应，然后关闭连接并接受队列中的下一个请求。</p><p id="7cc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得我们说过客户端连接实际上是与<strong class="kf ir"> server_socket </strong>不同的<strong class="kf ir">套接字——这真的很有帮助，因为这意味着监听套接字(server_socket)不必处理通信。它可以自由地立即转到下一条消息，因此我们的简单架构有可能并发处理请求。我们需要一些魔法来实现并发性，但是我们正在超越自己。</strong></p><p id="183d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一件值得注意的事情是:一旦连接打开，服务器没有<strong class="kf ir">和</strong>来关闭它。当您听到“web套接字”时，您可能会想到这一点—您可以拥有一个直接与服务器通信的开放通道。这就是聊天应用程序给你实时更新信息的方式。每个人都与聊天服务器有一个开放的连接(每个人都有自己的服务器套接字)。当您关闭聊天时，您的连接也将关闭。</p><p id="9066" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跟随这个示例，看看保持与服务器的开放连接是什么样子的:</p><ol class=""><li id="5bbe" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nl nc nd ne bi translated">确保前面示例中的<code class="fe mt mu mv lh b">sock</code>正在监听端口8888。如果您不确定，请打开一个新的python shell并运行以下命令:</li></ol><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="ee9d" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; import socket<br/>&gt;&gt;&gt; SERVER_ADDRESS = (HOST, PORT) = '', 8888<br/>&gt;&gt;&gt; REQUEST_QUEUE_SIZE = 5<br/>&gt;&gt;&gt; sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>&gt;&gt;&gt; sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br/>&gt;&gt;&gt; sock.bind(SERVER_ADDRESS)<br/>&gt;&gt;&gt; sock.listen(REQUEST_QUEUE_SIZE)</span></pre><p id="2dbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">您现在应该打开了一个监听套接字并监听端口8888</em></p><p id="f5d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.用新插座连接到您的监听插座。为此，在新的终端中打开第二个python shell:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="133a" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; import socket<br/>&gt;&gt;&gt; connect_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>&gt;&gt;&gt; connect_sock.connect(('localhost', 8888))</span></pre><p id="7e7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.接受原始套接字上的连接，并开始监听消息</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="f8aa" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; connection, _ = sock.accept()<br/>&gt;&gt;&gt; while True:<br/>...    connection.recv(1024) # constantly read from the socket<br/></span></pre><p id="2085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.开始从连接的套接字发送消息</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="59bb" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; connect_sock.sendall(b'Hello World, this is my first live msg!')<br/>&gt;&gt;&gt; connect_sock.sendall(b'Second msg, this is still fun!')</span></pre><p id="bfb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.观察它们出现在您原来的套接字连接中。<strong class="kf ir">wheeee！</strong></p><p id="bbbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是位于<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank"> Javascript的WebSocket API </a>核心的OS级软件，以及流行web框架的相应WebSocket实现。而你是用Python从头开始构建的！</p><h2 id="3cee" class="ll lm iq bd ls nm nn dn lw no np dp ma ko nq nr me ks ns nt mi kw nu nv mm nw bi translated">HTTP服务器</h2><p id="f8bd" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">为了完善示例，我将使用python的socket API为您提供一个简单HTTP服务器的完整实现:</p><p id="eca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> webserver.py </strong>(盗自<a class="ae kc" href="https://ruslanspivak.com/lsbaws-part3/" rel="noopener ugc nofollow" target="_blank"> RuslansPivak </a>)</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="42e3" class="ll lm iq lh b gy ln lo l lp lq">import socket<br/>import time</span><span id="0003" class="ll lm iq lh b gy nk lo l lp lq">SERVER_ADDRESS = (HOST, PORT) = '', 8888<br/>REQUEST_QUEUE_SIZE = 5</span><span id="2ec0" class="ll lm iq lh b gy nk lo l lp lq"># Handle a request to the socket<br/>def handle_request(client_connection):<br/>    request = client_connection.recv(1024) #read from request stream<br/>    print(request.decode())<br/>    http_response=b"""HTTP/1.1 200 OK\n\nHello World!"""<br/>    client_connection.sendall(http_response)</span><span id="f34d" class="ll lm iq lh b gy nk lo l lp lq">def serve_forever():<br/>    listen_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br/>    listen_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br/>    listen_sock.bind(SERVER_ADDRESS)<br/>    listen_sock.listen(REQUEST_QUEUE_SIZE)<br/>    print('Serving HTTP on port {port}'.format(port=PORT))<br/>    <br/>    while True:<br/>        # wait for the next connection and process it<br/>        client_conn, _ = listen_sock.accept()<br/>        handle_request(client_conn)<br/>        client_conn.close()</span><span id="8470" class="ll lm iq lh b gy nk lo l lp lq">if __name__ == '__main__':<br/>    serve_forever()</span></pre><p id="4e2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要让这个基本的web服务器工作，您只需运行:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="71c3" class="ll lm iq lh b gy ln lo l lp lq">&gt;&gt;&gt; python webserver.py<br/>Serving HTTP on port 8888</span></pre><p id="75d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以用curl来测试它:</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="04b5" class="ll lm iq lh b gy ln lo l lp lq">curl localhost:8888<br/>Hello World!</span></pre><p id="bc35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你，你刚刚用套接字做了一个web服务器。当然，它所做的只是打印hello world，但是基本架构已经存在——只需在上面插入您选择的python web框架，它就会做更多的事情。</p><p id="fef6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">真正的开源python服务器，如<a class="ae kc" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> Gunicorn </a>，基本上与你构建的服务器结构相似，但它们实现了一个标准接口，称为<strong class="kf ir"> (Python) Web服务器网关接口(WSGI) </strong>。这就是为什么Gunicorn是一个“WSGI”服务器。类似WSGI的好处是所有流行的web框架(Django、Flask、Pyramid)都符合WSGI——这意味着任何WSGI服务器都可以使用这些框架来处理请求，不会有任何问题。</p><p id="fe68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将我们的服务器转变成有效的WSGI服务器实际上并不难；如果你想了解更多，我推荐<a class="ae kc" href="https://ruslanspivak.com/lsbaws-part2/" rel="noopener ugc nofollow" target="_blank">这篇博文</a>，它教会了我很多关于python服务器的知识。</p><h1 id="09be" class="lr lm iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">松散的末端</h1><p id="e159" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">我之前提到了并发性，但这是一个大问题。它本质上包括通过<code class="fe mt mu mv lh b">os.fork</code>复制套接字过程，并处理该决定的所有含义。那是另一个时间的故事，但是你可以在这里阅读更多。</p><p id="0633" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很难想象像HTTP这样建立在sockets这样的简单架构之上的简单协议能够创造出广阔的网络景观，但是我们做到了。套接字还可以做的不仅仅是web:这个简单的抽象足够强大，可以控制我们如何通过蓝牙、USB、HTTP或者您将来设计的一些应用程序进行通信。软件之所以如此强大，是因为有多少个这样简单的部分组合在一起，可以创建一个丰富而复杂的塑造世界的应用程序生态系统。</p><p id="e5a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">以下是我们所学内容的回顾</strong></p><ul class=""><li id="308f" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">套接字是用于多种目的的通信抽象</li><li id="8e4d" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">套接字是操作系统级的抽象，但是我们可以使用python的<strong class="kf ir">套接字</strong>库来访问它们</li><li id="f6e0" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">一个<strong class="kf ir">监听</strong> <strong class="kf ir">套接字</strong>存储&amp;管理一个连接请求队列</li><li id="d5cb" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><code class="fe mt mu mv lh b">socket.accept()</code>接受其中一个请求并打开一个新的<strong class="kf ir">连接的套接字</strong></li><li id="52af" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">一个<strong class="kf ir">连接的套接字</strong>使数据能够在客户端&amp;服务器之间来回发送</li><li id="5844" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">HTTP服务器是一个监听套接字，它快速接受传入的请求，并打开新的套接字来处理这些请求。连接套接字返回HTTP响应，并关闭连接。</li></ul><p id="1975" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">巨大的呐喊以鲁斯兰的</em><a class="ae kc" href="https://ruslanspivak.com/lsbaws-part1/" rel="noopener ugc nofollow" target="_blank"><em class="lb"/></a><em class="lb">博文为灵感</em></p><p id="8d79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想看更多这样的作品，请留言告诉我！感谢阅读。</p></div></div>    
</body>
</html>