<html>
<head>
<title>NodeJS Threads and the Event Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS线程和事件循环</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nodejs-threads-and-the-event-loop-5f39011d964b?source=collection_archive---------13-----------------------#2022-09-15">https://levelup.gitconnected.com/nodejs-threads-and-the-event-loop-5f39011d964b?source=collection_archive---------13-----------------------#2022-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/864ee84d35a9b454cfec93f391ca4336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8atZ_qXALqYk-DssurPyA.png"/></div></div></figure><div class=""/><div class=""><h2 id="7244" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">使用Libuv的单线程与多线程和事件循环</h2></div><p id="5f19" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">NodeJS是web开发中使用最多的技术之一，但互联网上有一些误导性的说法。人们常说NodeJS是一个异步单线程运行时，但它也被称为多线程，那么哪种说法是正确的？嗯，看情况。</p><p id="adb5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">众所周知，Javascript是一种单线程编程语言，这可能会导致人们相信第一种说法在经验上是正确的。</p><p id="911e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">本文将首先深入什么是异步和线程，然后通过深入分析来探索NodeJS的事件循环。</p><h1 id="1e77" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">同步与异步语言</h1><p id="fea6" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">根据《牛津英语词典》，synchronous的意思是“同时发生或存在”。</p><p id="a705" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们首先记住Javascript的本质是同步的。它一次只能做一件事，尽管它能够使用计时器和事件来推迟事件循环中的操作。这意味着它可以等到任务完成后才得到结果，并避免阻塞它唯一的线程。</p><p id="2337" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">使用计时器，特别是<em class="mm"> setTimeout </em>，可以很容易地说明这种行为。让我们看一个同步代码的例子:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/7dffef30520777ba4807507a7ee86619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*sEB6DqGtfHoMMCFAbEGz_Q.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图1:同步任务代码片段</em></figcaption></figure><p id="1bb9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这段代码运行两个任务，并将进程的开始、每个任务的结束和进程的结束打印到控制台。打印结果将是:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/0eb932c9378027e9c98952e3337deac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*cpMS7YX31j1qJb-fvFvdtQ.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图2:同步控制台输出</em></figcaption></figure><p id="6675" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下面是一个异步代码的例子:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/530d5791dd41f1a3ad1c69ce76b55762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*rQ7QlXA0JzS4xwJ9Zivuuw.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图3:异步任务代码片段</em></figcaption></figure><p id="f0df" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它可能看起来没什么变化，但是看看这个函数。现在它返回一个<em class="mm"> setTimeout </em>，这将把<em class="mm"> console.log </em>语句的执行延迟<strong class="kv jf">至少</strong>100毫秒。</p><p id="c065" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将很快解释为什么至少是<strong class="kv jf">而不是100毫秒。</strong></p><p id="0a54" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们看看控制台上会显示什么:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/a209af6dbab4a4a2e381af97684430fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*vLLuTlRoc0tgWW80CmT9UA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图4:异步控制台输出</em></figcaption></figure><p id="5efa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">令人惊讶？不完全是。这是动态的Javascript。现在返回setTimeout的函数在“End process”日志语句之后运行。这是怎么回事？一旦评估了对的调用，执行就被排队到事件循环中，并且只有在100毫秒后结果就绪时才被执行。</p><p id="5665" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这种推迟代码执行的能力对Javascript至关重要；因为它只有一个线程，所以它不能因为一些结果不可用或者一些异步操作没有结束而阻塞整个进程。</p><h1 id="f041" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">单线程与多线程</h1><p id="2128" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">进程是由一个或多个线程执行的程序的实例。它有自己的内存空间、文件、调用堆栈、寄存器和计数器。它可以被描绘成:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/38c1dd52411740c337f92829363f0ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*95BImTa1sOBhiP6-LyjB_A.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图5:工艺概述和主要部件</em></figcaption></figure><p id="b6df" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">默认情况下，进程将是单线程应用程序。因此，程序只有一个内存空间、一个寄存器队列、一个调用堆栈和一个计数器队列。</p><p id="53eb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了更快地处理事情，可以产生不同的进程来执行一项任务，这被称为多处理:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi my"><img src="../Images/c7a1f0d88f344c8ececdf38bd459edfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5b8OVITDHJB17U15wiGKjQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图6:多重处理</em></figcaption></figure><p id="0792" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这样，一个任务可以同时执行两次。同样的任务运行两次可能没什么意义，但是想象一下需要计算两个散列。当它们可以同时计算时，为什么要等一个完成呢？</p><p id="15e8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">视情况而定，还有更好的办法。在多线程进程中，所有线程将共享内存空间或堆，但它们将拥有自己的寄存器、堆栈和计数器，允许并行处理，但共享相同的应用数据，如图<em class="mm">图7:多线程进程</em>所示，这使得线程之间的通信非常快，而不是多个进程必须使用专用机制来共享数据。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0a3a885c806ca4caeb3a781cac312c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*STTDwYKK4hSRHlDl1hSlpA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图7:多线程进程</em></figcaption></figure><p id="0105" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">NodeJS中线程的使用由运行时环境管理(也由开发人员通过<em class="mm"> worker threads </em>)并使其对I/O、网络和其他耗时任务更有效。它可以用“加密”库和一些散列函数来说明。</p><p id="b7a7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">实验场景由一个循环组成，该循环将从“crypto”模块运行两次同步散列函数。然后，将针对相同的任务重复该实验，但是这次异步运行。</p><p id="af0c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">时间的测量，虽然没有在代码中表示出来，但是已经用<a class="ae na" href="https://nodejs.org/api/process.html#processhrtimebigint" rel="noopener ugc nofollow" target="_blank"> <em class="mm"> process.hrtime </em> </a>完成了。这些图形是用Octave得到的。</p><h1 id="0681" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">单线程(和同步功能)</h1><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/337c0da41e46d01f4776fd21e5d75282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*hK1o6j7ETp7vzWggnbYa_g.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图8:单线程同步哈希函数调用</em></figcaption></figure><p id="885e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对该过程进行计时会产生以下结果:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f0c425816133614e47babb6d9e54f606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*CRgLWCa9d0Bl5aRQ6WNiEg.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图9:单线程同步时间结果</em></figcaption></figure><p id="51c0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">由于该程序使用的是的同步版本，NodeJS会阻止执行，直到每次调用该函数返回。值得注意的是，第二个任务(迭代2)是在第一个任务完成后立即开始的，用了大约相同的时间来完成。这里没什么可看的，只是正常的、连续的、有序的状态。</p><p id="ead3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们看看如果程序使用异步版本会发生什么。</p><h1 id="2bf2" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">多线程(和异步功能)</h1><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/fbcee99bdc005c09e549e780c3ae0124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*J3cHog36cjxGogCMz-kB4A.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图10:多线程异步散列函数调用</em></figcaption></figure><p id="cbf8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下面我们可以看到相应的时间结果:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/32098a30dcd3ba25cc3a8293b684a54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*EjjGGHemvixcTnF0FoQCuQ.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图11:多线程异步散列时间结果</em></figcaption></figure><p id="39a1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">由于程序执行异步调用，NodeJS不需要在每次调用时阻塞，可以并行处理两个任务。这是一个相当大的改进，执行相同工作的时间减少了一半。这是因为NodeJS使用了第二个线程来运行第二个任务。这不仅适用于NodeJS，也适用于任何能够使用线程的语言，唯一的区别是这里没有任何线程处理代码，Node是在幕后自己处理的。</p><p id="c882" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">NodeJS为它的许多标准库函数提供了同步和异步函数，使用这两种函数会改变线程方面的行为。默认情况下，它总是试图通过使用多线程来提高性能，因此强烈建议尽可能使用异步函数。</p><h1 id="fab3" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">事件循环</h1><p id="7887" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">那么NodeJS如何利用这些概念并实现它们呢？更重要的是，为什么？</p><p id="b14e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">NodeJS被认为是普通web服务器的替代方案，开发它是为了在不同的线程或其他类型的上下文切换中处理每个请求，从硬件资源的角度来看，这是非常昂贵的。正如NodeJS创建者Ryan Dahl在runtime 的演示中所说的那样:“实现并发的正确方法不是对每个连接都使用线程，而是拥有一个线程和一个事件循环，这样你就可以完成一些事情。[……]但这要求你做的事情永远不要花太长时间。”这似乎是一个简单的想法，但它永远改变了web开发的进程。Dahl的动机是通过使用一个单线程环境来创建一个高效的运行时，该环境将多线程的使用抽象为阻塞操作。</p><p id="b7f2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">值得注意的是，NodeJS是用Javascript编写的，但是是在C之上，C为运行时提供了速度和OS通信层。大约三分之一的代码是用c编写的，这是其组件的顶级表示:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/d77dcfac82638f4e55ff3079ee85cf2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*2lhlr39Z6oDW30DwVqdzOA.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图12: NodeJS组件概述</em></figcaption></figure><p id="904c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里的概念是:</p><ul class=""><li id="64bd" class="nc nd je kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated">节点绑定是C语言编写的模块，用于与较低级别的库(如libuv和V8引擎)进行交互。</li><li id="79c4" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae na" href="https://v8.dev/docs" rel="noopener ugc nofollow" target="_blank">谷歌的V8 </a>是用C++和Javascript编写的高性能引擎，Node在其上运行，提供内存分配和垃圾收集等功能。</li><li id="ae1e" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">Libuv是一个用C编写的库，最初是为了支持NodeJS，但是现在被其他工具和语言使用。它创建了一个与内核交互的层，实现了如下特性:“‘句柄’和‘流’为套接字和其他实体提供了高级抽象；此外，还提供了跨平台文件I/O和线程功能”。</li></ul><p id="979b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在已经描述了组件，让我们更深入地了解一下底层组件及其工作原理。</p><p id="f4cb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Libuv包含NodeJS的两个核心组件:事件队列和线程池。任务被推送到事件队列，并根据其性质按一定的顺序进行处理。线程池是处理线程的组件，线程将被libuv使用，使用回调来委托阻塞任务的执行，并在它们完成时获得结果。让我们来看一个图形表示:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/b632c67870e7f293a30f128d99622902.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*6ioFhXagn0REqMs572sh5w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图13: Libuv和事件循环概述</em></figcaption></figure><p id="96c7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这里，代码语句被按节点推入事件队列。然后，事件循环遍历该队列，并决定应该执行哪些任务。当某个操作阻塞I/O时，事件循环在上下文线程中执行它。这是一个非常简单的推理，其中包含了结构化和有序的后续步骤。</p><p id="c3b4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如上所述，<a class="ae na" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank"> NodeJS事件循环</a>，顾名思义，是一个无限期运行直到程序结束或退出的事件循环。事件，基本上是关于做什么的指令，被推入一个队列，以严格的方式进行评估。但是，它是如何处理计时器、推迟操作或者能够为阻塞操作生成线程的呢？让我们来看看事件循环阶段的图形表示:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6a22a622cf7168c31c1d53f52c95fa8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*25B7J3xnzwygFvmanWVHtQ.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图14: NodeJS事件循环阶段</em></figcaption></figure><p id="adce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里的每个框代表一个阶段(基本上是一个队列)，它将包含该特定步骤的所有由节点标记的操作。让我们来看看这些阶段:</p><ol class=""><li id="e5fd" class="nc nd je kv b kw kx kz la lc ne lg nf lk ng lo ns ni nj nk bi translated"><strong class="kv jf">定时器</strong>:该阶段执行<em class="mm"> setTimeout() </em>和<em class="mm"> setInterval() </em>调度的回调。</li><li id="a8ba" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated"><strong class="kv jf">待定回调</strong>:执行推迟到下一次循环迭代的I/O回调。</li><li id="f099" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated"><strong class="kv jf">闲置，准备</strong>:仅供内部使用。</li><li id="fa0b" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated"><strong class="kv jf">轮询</strong>:检索新的I/O事件；执行与I/O相关的回调(除了关闭回调、由定时器调度的回调和setImmediate())之外的几乎所有回调；节点将在适当的时候阻塞这里。</li><li id="f866" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated"><strong class="kv jf">检查</strong> : <em class="mm"> setImmediate() </em>回调在这里被调用。</li><li id="094e" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated"><strong class="kv jf">关闭回调</strong>:一些关闭回调，比如<em class="mm"> socket.on('close '，…) </em>。</li></ol><p id="4dca" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这些步骤的详细描述可在<a class="ae na" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#phases-in-detail" rel="noopener ugc nofollow" target="_blank"> NodeJS事件循环文件</a>中找到。</p><p id="2d46" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这还不是全部，因为还有一层事件队列。这个图中缺少了一个部分:下一个<em class="mm">节拍</em>和<em class="mm">承诺</em>队列，也称为<strong class="kv jf">微任务队列</strong>。此队列不直接属于事件循环。更详细的讨论可能需要一篇完全独立的文章，但是这里有一些关于nextTick() 的信息。基本上，它是一个双队列，优先于事件循环中的其他阶段，将在每个阶段之后处理；将<em class="mm">下一个Ticks </em>优先于<em class="mm">承诺</em>。</p><p id="58b8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">与<strong class="kv jf">微任务队列</strong>相反，由事件循环本身推送和迭代指令的事件队列可以被称为<strong class="kv jf">宏任务队列(或图13: Libuv和事件循环概述中描述的事件队列)</strong>。</p><p id="8879" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，在执行代码时，NodeJS有两个队列:微任务队列<strong class="kv jf">和宏任务队列</strong>。每个语句都将作为一个事件被推送到一个或另一个中，这再次取决于它的性质。</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ad6611fa0515d36a724767d94e1ee936.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*0OkLisVCL0XQBBWu212Qig.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图15:微观和宏观任务队列概述</em></figcaption></figure><p id="3a2c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所有这些可能不是很直观，但是有没有比用例子更好的方法来理解事物的功能呢？让我们创建一个利用所有这些概念(定时器、阻塞I/O、关闭回调等)的程序。)来理解事件循环的事情顺序。</p><p id="b775" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这变得有点技术性，尽管不值得对所有函数进行详细说明，这里是对setTimeout、setImmediate和setInterval计时器的一些<a class="ae na" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout" rel="noopener ugc nofollow" target="_blank">解释。</a></p><p id="6ad0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该程序的输出将是:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/271560e2ecec9f492d24d16dbc2bced7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKg8YrlawarhdPDRZ3rU9w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图16: NodeJS事件循环解释片段</em></figcaption></figure><p id="4251" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">看到输出顺序与陈述出现的顺序不匹配了吗？这是因为语句是在事件循环的不同阶段处理的。我们来详细看看发生了什么。该程序的执行按以下方式发展:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/aa350e7e950ec8d969d5d9ae448cf0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*xM-GutTetA5C7yWQYj_B2w.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">图17: NodeJS事件循环解释控制台输出</em></figcaption></figure><p id="8cbf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">看到输出顺序与陈述出现的顺序不匹配了吗？这是因为语句是在事件循环的不同阶段处理的。</p><p id="2bc0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们来详细看看发生了什么。该程序的执行按以下方式发展:</p><ol class=""><li id="bb9d" class="nc nd je kv b kw kx kz la lc ne lg nf lk ng lo ns ni nj nk bi translated">所有同步调用都执行，所以<strong class="kv jf">“开始”和“结束”被打印到控制台</strong>。然后，所有其他语句都按照上面给出的事件循环图进行调度。这将用相应的语句填充每个步骤的队列。I/O调用(<em class="mm"> crypto.pbkdf2 </em>)将进入<em class="mm">轮询</em> <em class="mm">队列</em>，<em class="mm"> nextTicks </em>和<em class="mm">承诺</em>进入<em class="mm">微任务队列</em>和<em class="mm">退出回调</em>进入<em class="mm">关闭回调队列。</em></li><li id="afbc" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated">现在所有的事件都被推入它们的队列，事件循环运行它的第一次迭代。首先，它检查<em class="mm">定时器队列</em>，但是它仍然是空的，所以它移动到下一个阶段:微任务<em class="mm">队列。这个队列包含两个<em class="mm">下一个滴答</em>和两个<em class="mm">承诺</em>。如前所述，因为<em class="mm">微任务队列</em>在每个阶段之后运行，并且<em class="mm">滴答</em>具有高优先级，所以它们将首先执行，然后是承诺。因此，它将首先<strong class="kv jf">打印下一个记号，然后是承诺结果</strong>。</em></li><li id="34b1" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated">事件循环移动到I/O或<em class="mm">轮询</em>阶段，并调度<em class="mm"> crypto.pbkdf2 </em>回调。</li><li id="d6a9" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated">加密操作完成并发出一个事件，该事件将其回调推入<em class="mm">微任务</em> <em class="mm">队列</em>。循环继续，但是所有后续阶段的队列都是空的(除了<em class="mm">关闭回调</em>，它正在监听退出事件并且还没有准备好<em class="mm"> ) </em>。</li><li id="9c2b" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated">预定的加密回调在<em class="mm">微任务队列</em>中，它被执行，评估内部语句并将它们推入它们的队列。<em class="mm"> setTimeout </em>进入<em class="mm">定时器队列</em>和<em class="mm"> setImmediate </em>将进入<em class="mm">检查队列</em>，而<em class="mm"> nextTick </em>和<em class="mm"> Promise </em>进入<em class="mm">微任务队列</em>。它将执行同步操作<strong class="kv jf">打印“文件读取”</strong>并继续以下阶段。</li><li id="53fe" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated">在<em class="mm">微任务队列</em>中有新的任务，因此它们将被执行，并且<strong class="kv jf">按顺序打印“第二个下一滴答回调已执行”、“第二个承诺已解决”</strong>。</li><li id="7f47" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated">事件循环前进到下一阶段，即<em class="mm">检查阶段</em>，在该阶段执行所有立即回调。<strong class="kv jf">“立即执行回调”将被打印</strong>到控制台。</li><li id="1f0e" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated">现在<strong class="kv jf">第二次迭代</strong>开始运行第一阶段并处理<em class="mm">定时器队列</em>，因此<strong class="kv jf">“执行超时回调”将被记录</strong>。</li><li id="50f3" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo ns ni nj nk bi translated">在<em class="mm">关闭回调</em>阶段之前，阶段队列中没有任何其他元素，该阶段将执行<em class="mm">退出</em>回调和<strong class="kv jf">打印“流程以代码0退出”</strong>。</li></ol><p id="dbae" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">事件循环可以在这个沙盒中交互体验<a class="ae na" href="https://replit.com/@victorigualada/NodeJS-Event-Loop#index.js" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cb58" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这个例子取自并改编自<a class="ae na" href="https://github.com/zeroabsolute/Node-Internals" rel="noopener ugc nofollow" target="_blank"> zeroabsolute </a>的GitHub。还有其他很好的例子来理解NodeJS的内部工作方式。去看看！</p><h1 id="1505" class="lp lq je bd lr ls lt lu lv lw lx ly lz kk ma kl mb kn mc ko md kq me kr mf mg bi translated">结论和最终想法</h1><p id="3599" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">通过异步和多线程的不同机制，NodeJS实现了对Web服务器更有效的资源管理。它现在被广泛用于绝大多数新的实现，甚至在web平台之外，提供了一个简单的入门级别、一个快速的编程环境、来自开发人员的抽象流和线程。</p><p id="754a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">还有一个未涉及的话题。程序员如何随心所欲地利用多线程？通过<a class="ae na" href="https://nodejs.org/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank">工作线程</a>的方式，该过程将是一篇独立的技术文章。</p><p id="78a3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您对本文有任何疑问，或者需要更多相关信息，请联系<a class="ae na" href="https://www.zartis.com/contact" rel="noopener ugc nofollow" target="_blank">联系</a>！</p><p id="bf94" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi">—</p><h2 id="b104" class="nv lq je bd lr nw nx dn lv ny nz dp lz lc oa ob mb lg oc od md lk oe of mf og bi translated">参考</h2><ul class=""><li id="ffd0" class="nc nd je kv b kw mh kz mi lc oh lg oi lk oj lo nh ni nj nk bi translated"><a class="ae na" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick" rel="noopener ugc nofollow" target="_blank"> NodeJS事件循环</a></li><li id="d579" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae na" href="https://nodejs.dev/es/learn/understanding-setimmediate/" rel="noopener ugc nofollow" target="_blank">了解<em class="mm">setin mediate</em>T19】</a></li><li id="f9ed" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae na" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" rel="noopener ugc nofollow" target="_blank">不要阻塞事件循环</a></li><li id="2cda" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae na" href="https://www.youtube.com/watch?v=M-sc73Y-zQA" rel="noopener ugc nofollow" target="_blank">瑞安·达尔:NodeJS简介</a></li><li id="775c" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae na" href="https://www.youtube.com/watch?v=ztspvPYybIY" rel="noopener ugc nofollow" target="_blank"> Ryan Dahl:原始Node.js演示文稿</a></li><li id="0cb9" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae na" href="http://docs.libuv.org/en/v1.x/design.html" rel="noopener ugc nofollow" target="_blank"> Libuv文档</a></li><li id="9d79" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated"><a class="ae na" href="https://github.com/zeroabsolute/Node-Internals" rel="noopener ugc nofollow" target="_blank">节点-堆内构件Github报告</a></li></ul><p id="920d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">——</strong></p><h2 id="4892" class="nv lq je bd lr nw nx dn lv ny nz dp lz lc oa ob mb lg oc od md lk oe of mf og bi translated">作者:</h2><p id="b408" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">Víctor Igualada Calatrava是一名专注于后端开发和DevOps的软件工程师。他对自动化和结构充满热情，他喜欢学习新事物的所有细节。Víctor目前正在与NodeJS和key-store合作，生产通过CircleCI、Terraform和SaltState交付的高频、低延迟系统。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="aa45" class="lp lq je bd lr ls or lu lv lw os ly lz kk ot kl mb kn ou ko md kq ov kr mf mg bi translated">分级编码</h1><p id="e36f" class="pw-post-body-paragraph kt ku je kv b kw mh kf ky kz mi ki lb lc mj le lf lg mk li lj lk ml lm ln lo im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="90c9" class="nc nd je kv b kw kx kz la lc ne lg nf lk ng lo nh ni nj nk bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="6f2d" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">📰查看<a class="ae na" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="930c" class="nc nd je kv b kw nl kz nm lc nn lg no lk np lo nh ni nj nk bi translated">🔔关注我们:<a class="ae na" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae na" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae na" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="0620" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">🚀👉<a class="ae na" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kv jf">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>