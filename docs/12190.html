<html>
<head>
<title>In defense of fluent collections API for Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Python的流畅集合API辩护</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/in-defence-of-fluent-collections-api-for-python-f603b433cf03?source=collection_archive---------6-----------------------#2022-05-22">https://levelup.gitconnected.com/in-defence-of-fluent-collections-api-for-python-f603b433cf03?source=collection_archive---------6-----------------------#2022-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9be4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Python介绍一个新的带fluent API的集合库，以及为什么标准库不够用。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ef2751a8997c7e62dfa70a74b5f907ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uIOhiLLAUYQeVP8c.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自科特林的函数式集合操作<a class="ae kv" href="https://kotlinlang.org/docs/sequences.html#sequence" rel="noopener ugc nofollow" target="_blank">的例子。</a></figcaption></figure><p id="df8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一份工作，对我来说又是一次彻底的技术变革。继PHP，C++，Objective-C，.NET、Java、Kotlin等等。NET，我终于开始使用<strong class="ky ir"> Python </strong>了。在这篇文章中，我将讨论集合(在Python行话中称为<em class="ls">容器</em>，尽管它们位于<code class="fe lt lu lv lw b">collections</code>模块中)，以及我为了更高效地使用集合而开发的<a class="ae kv" href="https://github.com/mifeet/pyfluent-iterables" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">py fluent-iterables</strong></a><strong class="ky ir"/>fluent API库。</p><h2 id="11f2" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">Python理解</h2><p id="b3cb" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">我尊重生态系统中常见的惯例。除了标准的<a class="ae kv" href="https://docs.python.org/3/library/collections.html\" rel="noopener ugc nofollow" target="_blank">收藏库设施</a>，Python还提供了<a class="ae kv" href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noopener ugc nofollow" target="_blank">列表</a>和<a class="ae kv" href="https://docs.python.org/3/glossary.html#term-dictionary-comprehension" rel="noopener ugc nofollow" target="_blank">字典</a> <strong class="ky ir">释义</strong>。我特别喜欢字典理解——我不记得在其他主流语言中，有如此强大的构造可以在一个表达式中创建字典/地图。</p><pre class="kg kh ki kj gt mv lw mw mx aw my bi"><span id="6257" class="lx ly iq lw b gy mz na l nb nc"><em class="ls"># Find the number of occurrences of alphanumeric characters in text</em><br/>{ c: text.count(c) for c in text if c.isalnum() }</span></pre><p id="dc1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">似乎有一种强烈的 <a class="ae kv" href="https://www.artima.com/weblogs/viewpost.jsp?thread=98196" rel="noopener ugc nofollow" target="_blank">偏好</a>使用综合函数，而不是函数式语言中常见的<code class="fe lt lu lv lw b">map()</code>或<code class="fe lt lu lv lw b">filter()</code>之类的函数。我明白——这是一个既定的惯例，有一个单一的做事方式更好，它避免了多余的lambdas。</p><p id="961a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这加上标准容器库的当前状态<em class="ls">不能成为不使更复杂的集合操作更可读、更容易编写的借口</em>。</p><h2 id="b769" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">一个流畅的集合API会让事情更具可读性吗？</h2><p id="6420" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">下面是我看到的一个实际代码示例，它打印了一些CI/CD作业的统计数据，这些统计数据按它们相关的问题标识符分组:</p><pre class="kg kh ki kj gt mv lw mw mx aw my bi"><span id="3ef3" class="lx ly iq lw b gy mz na l nb nc">jobs = [Job.parse_obj(job) for job in get_all_jobs_from_api()]<br/>jobs.sort(key=get_issue_for_job)<br/>jobs_by_issue = itertools.groupby(jobs, key=get_issue_for_job)<br/>job_summaries = []<br/>for issue, jobs_iter in jobs_by_issue:<br/>    job_summaries.append((issue, JobSummary(list(jobs_iter)))) <br/>job_summaries.sort(key=lambda pair: pair[1].failed_rate,<br/>                   reverse=True)<br/>for issue, summary in job_summaries: <br/>    print(issue, summary)</span></pre><p id="b042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对你来说破译它的功能有多难？你如何将它与下面的片段进行比较？</p><pre class="kg kh ki kj gt mv lw mw mx aw my bi"><span id="bb7f" class="lx ly iq lw b gy mz na l nb nc">(fluent(get_all_jobs_from_api())<br/>  .map(Job.parse_obj)<br/>  .group_by(get_issue_for_job)<br/>  .map_values(JobsSummary)<br/>  .sort_items(lambda job, stats: stats.failed_rate, reverse=True)<br/>  .for_each_item(print))</span></pre><p id="a7f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许我对我的函数式编程经验有偏见，但是我发现后者更具可读性。</p><h2 id="c235" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">流畅的集合API会让事情更容易编写吗？</h2><p id="52a8" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">另一件事是，<a class="ae kv" href="https://www.martinfowler.com/bliki/FluentInterface.html" rel="noopener ugc nofollow" target="_blank">流畅的API </a>让编写帮助你利用现代ide提供的建议，加上Python中的标准集合库可以说不是最直观的使用方式。</p><p id="fa7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你能直接告诉我如何连接一个列表吗？这个库的方法是<code class="fe lt lu lv lw b">itertools.chain.from_iterable(lists)</code>。很直观的名字，对吧？现在对比一下<code class="fe lt lu lv lw b"><strong class="ky ir">fluent(lists).flatten()</strong></code>。即使你不记得<code class="fe lt lu lv lw b">flatten</code>的名字，你的IDE也会在你键入<code class="fe lt lu lv lw b">fluent(lists).</code>后在建议列表中提供(不像<code class="fe lt lu lv lw b">from_iterable()</code>)。</p><p id="0a91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，您可以使用列表理解，但它不是灵丹妙药——可读性问题仍然存在，并且它不能解决所有情况。如何从你的头顶<em class="ls">通过一个值列表</em>的键来分组项目？叫<code class="fe lt lu lv lw b">groupby(iterable, key)</code>？<em class="ls">错了</em>，你需要调用<code class="fe lt lu lv lw b">sort(iterable) ; groupby(iterable, key)</code>，即使那样也没有给你值作为列表(见解<a class="ae kv" href="https://stackoverflow.com/questions/3749512/python-group-by" rel="noopener ugc nofollow" target="_blank">此处</a>；理解也不是灵丹妙药。你觉得这个怎么样:</p><pre class="kg kh ki kj gt mv lw mw mx aw my bi"><span id="61b8" class="lx ly iq lw b gy mz na l nb nc">fluent(iterable).group_by(key)</span></pre><h1 id="b942" class="nd ly iq bd lz ne nf ng mc nh ni nj mf jw nk jx mi jz nl ka ml kc nm kd mo nn bi translated">为Python集合引入流畅的API</h1><p id="b1b3" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">出于以上原因，我创建了一个名为 <code class="fe lt lu lv lw b"><a class="ae kv" href="https://github.com/mifeet/pyfluent-iterables" rel="noopener ugc nofollow" target="_blank">pyfluent-iterables</a></code>的<a class="ae kv" href="https://github.com/mifeet/pyfluent-iterables" rel="noopener ugc nofollow" target="_blank">库，它提供了一个流畅的界面，就像上面建议的那样。</a></p><p id="7aab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它为任何类型的iterable ( <code class="fe lt lu lv lw b">list</code>、<code class="fe lt lu lv lw b">tuple</code>、generators、…)和mapping(<code class="fe lt lu lv lw b">dict</code>、…)提供了一个流畅的API。现有的容器可以用<code class="fe lt lu lv lw b">fluent()</code>函数包装，或者可以用工厂方法<code class="fe lt lu lv lw b">fluent_of(*values)</code>或<code class="fe lt lu lv lw b">fluent_dict(**kwargs)</code>直接创建集合。</p><p id="42b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">产生的fluent接口类提供了一个丰富的集合方法的<a class="ae kv" href="https://github.com/mifeet/pyfluent-iterables/blob/main/README.md#overview-of-methods" rel="noopener ugc nofollow" target="_blank">调色板，很大程度上遵循了标准Python库，但也增加了来自其他丰富库的方法，如</a><a class="ae kv" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-collection/#kotlin.collections.Collection" rel="noopener ugc nofollow" target="_blank"> Kotlin collections </a>。</p><h2 id="3103" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">结论</h2><p id="ef6e" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">由于我相对来说是Python的新手，我认识到更有经验的Python开发者可能会有不同的看法。我将把流畅的集合API的有用性留给读者——<strong class="ky ir">我很乐意在评论中听到您的意见。</strong></p><p id="f7c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，这是一个有趣的项目，我不认为已经建立的惯例会妨碍提供更好、功能更多的API。即使你更喜欢Python comprehensions，我也确实发现<strong class="ky ir"> fluent API非常有用，至少对于快速原型制作</strong>。</p></div></div>    
</body>
</html>