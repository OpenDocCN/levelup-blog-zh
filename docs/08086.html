<html>
<head>
<title>Object Indexing in React Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React第二部分中的对象索引</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/object-indexing-in-react-part-ii-6eac4995f89e?source=collection_archive---------12-----------------------#2021-04-01">https://levelup.gitconnected.com/object-indexing-in-react-part-ii-6eac4995f89e?source=collection_archive---------12-----------------------#2021-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a5ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何停止过度使用数组函数的另一个例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c9fa03188d7a4c4b9e80d59c05ea72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wc3MgXJ00mrdGO_-8vJXTw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@euwars?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法尔扎德·纳兹菲</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/object-indexing-in-react-269295e1eae2">之前的一篇文章</a>中，我提供了一个对象索引的潜在用例，以避免在react应用程序中过度使用数组函数。虽然它确实说明了对象索引的适用性，<a class="ae ky" href="https://medium.com/@vachev.t" rel="noopener"> Vachev T </a>指出它可能不是最好的例子，因为有更有效的替代方案。</p><blockquote class="lv"><p id="e09a" class="lw lx it bd ly lz ma mb mc md me lu dk translated">这个想法很好，我只是不明白为什么我们必须在useEffect中重新映射对象，并创建新的索引对象，为什么我们不简单地使用原始数组，当在渲染函数中映射项目列表时，我们只使用map的索引参数？它已经存在了… items.map((item，index，array)=&gt; { … })</p></blockquote><p id="f83d" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">这是一个伟大的观点，它促使我想出一个更好的用例。新的用例不能简单地使用当前条目的索引，但可以通过对象索引进行极大的优化。</p><p id="3d00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个由组和用户组成的应用程序。应用程序呈现一个组列表，其中包含它们的元数据(名称、是否私有等。).群组对象的属性之一是<code class="fe mk ml mm mn b">users</code>。该属性指向属于该组中每个用户对象的用户id列表。见下文。</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="bdf0" class="ms mt it mn b gy mu mv l mw mx">var users = [<br/>  {<br/>   id: 43562, <br/>   username: 'mattman', <br/>   email: 'mattman@mattman.com', <br/>   img: 'path/to/profile-pics/43562'<br/>  }, <br/>  {<br/>   id: 10453, <br/>   username: 'chester_cheetuh', <br/>   email: 'thuh_cheetuh@chester.com', <br/>   img: 'path/to/profile-pics/10453'<br/>  }<br/>]</span><span id="5941" class="ms mt it mn b gy my mv l mw mx">var groups = [<br/>  {<br/>   id: 234, <br/>   name: 'WestCoastDoges', <br/>   isPrivate: false,<br/>   users: [43562, 10453]<br/>  }, <br/>  {<br/>   id: 738, <br/>   name: 'EastCoastFloofs', <br/>   isPrivate: true,<br/>   users: [10453]<br/>  }<br/>]</span></pre><p id="fe0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的应用程序中，我们可以编写<code class="fe mk ml mm mn b">groups.map(group=&gt;&lt;Group group={group}/&gt;)</code>来呈现我们的组列表。这很容易，但是如果我们想为每个组呈现一个<code class="fe mk ml mm mn b">user</code>组件列表(包含用户名、个人资料图片等)呢？)来代表用户那个组？</p><p id="17b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将<code class="fe mk ml mm mn b">users</code>作为道具传递给每个<code class="fe mk ml mm mn b">Group</code>组件，然后在该组件中，当用户被映射时，执行<code class="fe mk ml mm mn b">props.users.find(user=&gt;user.id === groupUser)</code>，然后为该用户呈现数据。这是可行的，但是这篇文章的主旨是向你展示为什么使用对象索引是一个更有效的选择。在开始应用索引之前，让我们简单回顾一下大O符号的概念。</p><blockquote class="lv"><p id="c953" class="lw lx it bd ly lz ma mb mc md me lu dk translated">“大O符号是计算机科学家分析算法成本的最基本工具之一”<a class="ae ky" href="https://www.freecodecamp.org/news/author/shen/" rel="noopener ugc nofollow" target="_blank">黄慎</a></p></blockquote><p id="51be" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">简而言之，<a class="ae ky" href="https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/" rel="noopener ugc nofollow" target="_blank">大O </a>的概念是，算法的成本是以运行一个与所提供的数据集大小相关的进程所花费的时间来衡量的。这被称为<em class="mz">时间复杂度</em>。例如，JavaScript中的一个<code class="fe mk ml mm mn b">find</code>数组函数的时间复杂度可以表示为O(n)。这意味着处理时间相对于数据集的增加是线性的(100项=== 100次迭代，200项=== 200次迭代，等等。).</p><p id="d730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要执行一个<code class="fe mk ml mm mn b">find</code>函数，当我们在<code class="fe mk ml mm mn b">groups</code>的每次迭代中迭代<code class="fe mk ml mm mn b">users</code>时，我们正在执行一个<code class="fe mk ml mm mn b">find</code>，在一个循环中，在<strong class="lb iu">另一个</strong>循环中。相对而言，简单地渲染我们的组和他们的用户，我们的执行速度是O(n ),这很糟糕。这是一个<strong class="lb iu">指数</strong>关系。迭代次数等于组数(渲染每个组)、乘以每个组中的用户数(渲染组中的每个用户)、<strong class="lb iu">乘以总用户数(为每个用户执行一次查找)。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/7799f48f5d2b6305833b5f5474540fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*wyDNgvHrT87AddbTQyaI2w.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Ew大卫</figcaption></figure><p id="85ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象索引至少可以帮助我们避免这些循环中的一个，即<code class="fe mk ml mm mn b">find</code>。这是我们能做的。在<code class="fe mk ml mm mn b">GroupsContainer</code>中，我们可以创建一个映射，其中键是用户id，值是用户对象。见下文。</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="87b0" class="ms mt it mn b gy mu mv l mw mx">const [userMap, setUserMap] = useState({})</span><span id="862a" class="ms mt it mn b gy my mv l mw mx">useEffect(()=&gt;{ <br/>  var newUserMap = {}<br/>  users.forEach(user=&gt;userMap[user.id] = user)<br/>  setUserMap(newUserMap)<br/>})</span></pre><p id="a4c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了更新的<code class="fe mk ml mm mn b">userMap</code>，我们可以在渲染时将它作为道具传递给我们的<code class="fe mk ml mm mn b">Group</code>组件，而不是所有的<code class="fe mk ml mm mn b">users</code>。</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="b1dd" class="ms mt it mn b gy mu mv l mw mx">return (&lt;&gt;<br/>  &lt;h1&gt;Groups&lt;/h1&gt;<br/>  {groups.map(group =&gt; {<br/>     return &lt;Group group={group} <strong class="mn iu">userMap={userMap}</strong>/&gt; <br/>  })}<br/>&lt;/&gt;)</span></pre><p id="6c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的<code class="fe mk ml mm mn b">Group</code>组件已经可以访问<code class="fe mk ml mm mn b">userMap</code>，我们可以在迭代组用户时使用它。参见下面的<code class="fe mk ml mm mn b">Group</code>组件。</p><pre class="kj kk kl km gt mo mn mp mq aw mr bi"><span id="38ad" class="ms mt it mn b gy mu mv l mw mx">import React from 'react'</span><span id="e59b" class="ms mt it mn b gy my mv l mw mx">const Group = ({group, userMap}) =&gt;{</span><span id="8eec" class="ms mt it mn b gy my mv l mw mx">return (&lt;div&gt;<br/>   &lt;h3&gt;{group.name}&lt;/h3&gt;<br/>   {group.users.map(user=&gt;{<br/>     return &lt;User user={userMap[user]}/&gt;<br/>   })}&lt;/div&gt;)<br/>}</span><span id="c3bc" class="ms mt it mn b gy my mv l mw mx">export default Group;</span></pre><p id="55f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以避免使用昂贵的数组函数，只需在当前迭代中从用户id的关键字处的<code class="fe mk ml mm mn b">userMap</code>中获取值，就可以找到我们的用户对象。现在，当我们的应用程序加载时，我们只需在<code class="fe mk ml mm mn b">useEffect</code>中执行一次循环，而不必在<code class="fe mk ml mm mn b">group.users</code>的每次迭代中搜索整个用户列表。</p><p id="3105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的所有代码都可以在GitHub上找到。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="9323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此  <em class="mz">将你的免费中级会员升级为付费会员，每月只需5美元，你就可以获得数以千计作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="2f8e" class="ni mt it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">参考</h1><div class="nz oa gp gr ob oc"><a rel="noopener  ugc nofollow" target="_blank" href="/object-indexing-in-react-269295e1eae2"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">React中的对象索引</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">停止过度使用数组函数</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://medium.com/@vachev.t" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">瓦切夫T培养基</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">在介质上阅读瓦切夫T的作品。每天，瓦切夫T和成千上万的其他声音阅读，写作，并分享…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">medium.com</p></div></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">大O符号解释的是什么:空间和时间复杂性</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">你真的了解大O吗？如果是这样，那么这将在面试前刷新你的理解。如果没有，就不要…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">www.freecodecamp.org</p></div></div><div class="ol l"><div class="or l on oo op ol oq ks oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://github.com/macro6461/medium-object-indexing-part-II" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">macro 6461/medium-对象索引-第二部分</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">在GitHub上创建一个帐户，为macro 6461/medium-object-indexing-part-II开发做出贡献。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="os l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>