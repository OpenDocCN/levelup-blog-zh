<html>
<head>
<title>Functional Components for Experienced React Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向经验丰富的React开发人员的功能组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-components-for-experienced-react-developers-219eb4747617?source=collection_archive---------8-----------------------#2020-10-03">https://levelup.gitconnected.com/functional-components-for-experienced-react-developers-219eb4747617?source=collection_archive---------8-----------------------#2020-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/43ecb303faff72192df85740f3a8c482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ACz9Y9R0deO0psPc8lOzw.png"/></div></div></figure><p id="ddd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在软件开发领域，我们正处于一场巨大的范式转变之中。就像面向对象编程在几十年前变得流行一样，函数式编程可能会成为一种具有类似意义的思想。术语<em class="kw">功能性的</em>正成为像<em class="kw">纯粹的</em>和<em class="kw">无状态的</em>这样的词的同义词。如果你对这是为什么感兴趣，我建议你查一下函数式编程。在这篇文章中，我将介绍React在实践中从<em class="kw">有状态类</em>到<em class="kw">无状态函数</em>的转变。</p><h1 id="445c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">React类组件的剖析</h1><p id="41a9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们先来看看一个典型的React类组件。</p><h2 id="a583" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">构造器</h2><p id="4d69" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">构造函数设置组件的初始状态，并且它必须确保调用父组件的构造函数:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0590" class="ma ky iq mr b gy mv mw l mx my">constructor(props) {<br/>  super(props);<br/>  this.state = {text: "Initial state"};<br/>}</span></pre><h2 id="9250" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">生命周期</h2><p id="45a9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">以下是使用组件类时常用的三种生命周期方法:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="be67" class="ma ky iq mr b gy mv mw l mx my">componentDidMount() {<br/>  // do something on mount<br/>  this.setState({text: "Component did mount"});<br/>}</span><span id="e580" class="ma ky iq mr b gy mz mw l mx my">componentDidUpdate(prevProps) {<br/>  // do something on update<br/>  if (prevProps.prop != this.props.prop) {<br/>    this.setState({text: "prop changed"});<br/>  }<br/>}</span><span id="772d" class="ma ky iq mr b gy mz mw l mx my">componentWillUnmount() {<br/>  // do something on unmount<br/>}</span></pre><h2 id="fc34" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">提供；给予</h2><p id="6c1d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">render方法完成所有渲染工作:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4933" class="ma ky iq mr b gy mv mw l mx my">render() {<br/>  return &lt;div&gt;{this.state.text}&lt;/div&gt;;<br/>}</span></pre><h1 id="7e15" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解释的功能组件</h1><p id="e8a0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在，让我们做和上面一样的事情，但是使用一个功能组件:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="273f" class="ma ky iq mr b gy mv mw l mx my">(props) =&gt; {<br/>  const [text, setText] = useState("Initial state");</span><span id="221c" class="ma ky iq mr b gy mz mw l mx my">  useEffect(() =&gt; {<br/>    setText("Component did mount");</span><span id="5bfe" class="ma ky iq mr b gy mz mw l mx my">    return () =&gt; { /* do something on unmount */ };<br/>  }, []);</span><span id="a8a7" class="ma ky iq mr b gy mz mw l mx my">  useEffect(() =&gt; {<br/>    setText("prop changed");<br/>  }, [props.prop]);</span><span id="0f09" class="ma ky iq mr b gy mz mw l mx my">  return &lt;div&gt;{text}&lt;/div&gt;;<br/>};</span></pre><p id="44cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有很多东西要打开！让我们一行一行地过一遍:</p><ol class=""><li id="5ae4" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">正如你所看到的，<em class="kw">道具</em>是作为函数的参数给出的。</li><li id="dd40" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">为了初始化一个组件的状态，你调用<code class="fe no np nq mr b">useState</code>，它将返回初始状态(由函数的可选参数给出)以及另一个函数来更新状态。您可以任意多次调用<code class="fe no np nq mr b">useState</code>并初始化多个状态！</li><li id="0710" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">接下来的两个调用都是对<code class="fe no np nq mr b">useEffect</code>的调用，但是在第二个参数上有一个重要的区别。当所提供的依赖关系之一发生变化时，就会调用作为参数传递给<code class="fe no np nq mr b">useEffect</code>的函数。这些依赖关系由第二个参数指定，在第一次调用的情况下，该参数是一个空数组。这意味着没有依赖关系，因此<em class="kw">效果</em>在挂载时只被调用一次。</li><li id="beb1" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">传递给第一个<code class="fe no np nq mr b">useEffect</code>的函数也返回一个函数。这是一个<em class="kw">清理函数</em>，在本例中，它在卸载时被调用。</li><li id="ef14" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">传递给第二个<code class="fe no np nq mr b">useEffect</code>的函数依赖于<code class="fe no np nq mr b">props.prop</code>，因此每当这种依赖的值改变时都会被调用。注意:这不仅仅是一个<em class="kw"> componentDidUpdate </em>，因为只有当属性改变时才会调用它。它不在乎有没有其他道具！就像使用<code class="fe no np nq mr b">useState</code>一样，你可以随意调用<code class="fe no np nq mr b">useEffect</code>多次。</li><li id="c7c2" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">在传递给<code class="fe no np nq mr b">useEffect</code>的函数中，我们使用<code class="fe no np nq mr b">setText</code>来更新文本状态。</li><li id="613e" class="na nb iq ka b kb nj kf nk kj nl kn nm kr nn kv nf ng nh ni bi translated">最后，我们只是像在<em class="kw"> render </em>方法中一样返回渲染节点。</li></ol><p id="f986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在应该很清楚，它实际上是所有的函数。以函数为参数甚至可能返回函数的函数。其中一个好处是这些函数可以在你喜欢的任何地方、任何时候被调用，最重要的是，你可以随时调用。</p><p id="38fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想知道的话，我们在这里使用的所有内置函数都被称为<a class="ae nr" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">钩子</a>。</p><h1 id="8d9e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">但是等等，还有呢！</h1><h2 id="b739" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">高阶组件(HOC)</h2><p id="75cf" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">有经验的React开发人员可能非常熟悉高阶组件的概念。这些是包装其他组件并向其中注入某些道具的组件。假设您有一个将<code class="fe no np nq mr b">hocProp</code>注入到组件中的特设。在这种情况下，您可能会看到这样的内容:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="16e2" class="ma ky iq mr b gy mv mw l mx my">export withHocProp(MyComponent);</span></pre><p id="71c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe no np nq mr b">withHocProp</code>函数内部，很可能会发生这样的事情:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="fddb" class="ma ky iq mr b gy mv mw l mx my">…<br/>&lt;WrappedComponent<br/>  {...this.props}<br/>  hocProp=…<br/>/&gt;<br/>…</span></pre><p id="aa24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于功能组件，您不再创建<code class="fe no np nq mr b">withHocProp</code>函数——而是创建一个<code class="fe no np nq mr b">useHocProp</code>函数，它可以作为一个钩子被调用，并且只返回<em class="kw"> hocProp </em>的值:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="91e7" class="ma ky iq mr b gy mv mw l mx my">const useHocProp = () =&gt; {<br/>  …<br/>  return hocProp;<br/>};</span></pre><p id="ebc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个重要的注意事项是<em class="kw"> useHocProp </em>可能会调用其他钩子如<code class="fe no np nq mr b">useEffect</code>和<code class="fe no np nq mr b">useState</code>以便成为一个全功能组件本身！</p><p id="7d36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">官方的<a class="ae nr" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>对此有一个很好的例子。</p><h2 id="b4d4" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">上下文</h2><p id="ab3c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果您使用过React上下文，那么您也有可能创建了<code class="fe no np nq mr b">withContext</code>更高阶的组件来将所需的上下文注入组件。</p><p id="e188" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不再需要这些上下文专用函数，取而代之的是React自己的<code class="fe no np nq mr b">useContext</code>钩子。这只是组件内部的另一个函数调用:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2157" class="ma ky iq mr b gy mv mw l mx my">const context = useContext(MyContext);</span></pre><h2 id="107f" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">其他挂钩</h2><p id="8309" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">例如，为了优化应用程序的性能，你还可以使用其他重要的钩子。</p><p id="4130" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw"> useMemo </em> </strong>根据依赖关系优化函数调用，就像我们看到的<code class="fe no np nq mr b">useEffect</code>一样。假设您有一个基于属性计算值的函数。你可以将它移入一个状态，并在属性改变时用<code class="fe no np nq mr b">useEffect</code>更新状态——或者你可以在属性改变时用<code class="fe no np nq mr b">useMemo</code>调用这个函数:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="a27e" class="ma ky iq mr b gy mv mw l mx my">const value = useMemo(<br/>  () =&gt; expensiveFunction(props.prop),<br/>  [props.prop]<br/>);</span></pre><p id="9d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<code class="fe no np nq mr b">value</code>的值在每次<code class="fe no np nq mr b">props.prop</code>改变时更新，但不是每次组件改变时更新。因此，函数<code class="fe no np nq mr b">expensiveFunction</code>仅在需要时调用。</p><p id="3d2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw"> useCallback </em> </strong>与<em class="kw"> useMemo </em>相似，都是返回记忆化的回调。假设您有一个仅依赖于<code class="fe no np nq mr b">props.prop</code>的点击处理程序。然后，您可以创建一个回调函数，只有当它的依赖关系发生变化时，才会重新计算这个函数(当然，每次单击都会调用这个函数):</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="d69e" class="ma ky iq mr b gy mv mw l mx my">const clickHandler = useCallback(<br/>  () =&gt; {<br/>    // do stuff depending on props.prop<br/>  },<br/>  [props.prop]<br/>);</span><span id="5727" class="ma ky iq mr b gy mz mw l mx my">return &lt;button onClick={clickHandler}&gt;Press me&lt;/button&gt;;</span></pre><p id="50bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想知道还有哪些钩子存在，我建议你看看React的<a class="ae nr" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">钩子API参考</a>。</p><h1 id="417f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="303d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">虽然可能需要一些时间来适应，但对我个人来说，functional React感觉更强大，甚至更优雅。</p><p id="d2b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您或您的公司还没有转向函数式组件，那么现在可能是您重新考虑的时候了，因为函数式编程的概念已经根深蒂固——随着许多语言和框架在本质上变得越来越函数化，这是显而易见的。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="c020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢你的阅读，希望你喜欢。如果你有任何问题，或者想了解更多关于React和函数式编程的知识，欢迎发表评论！</p><p id="33cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">你也可以在我公司的</em> <a class="ae nr" href="https://www.productionbuild.de" rel="noopener ugc nofollow" target="_blank"> <em class="kw">网站</em> </a> <em class="kw">或</em> <a class="ae nr" href="https://twitter.com/nenharma82" rel="noopener ugc nofollow" target="_blank"> <em class="kw">推特</em> </a> <em class="kw">上联系我。</em></p></div></div>    
</body>
</html>