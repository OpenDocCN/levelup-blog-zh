<html>
<head>
<title>Using Google’s reCAPTCHA with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用Google的reCAPTCHA</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/protect-your-endpoints-with-google-recaptcha-in-go-f4da5669ed9?source=collection_archive---------1-----------------------#2020-08-30">https://levelup.gitconnected.com/protect-your-endpoints-with-google-recaptcha-in-go-f4da5669ed9?source=collection_archive---------1-----------------------#2020-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/56a95596966f49d021871cdba84dd3fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*2laZ0v3nYnPjY6Zf2MrgDQ.png"/></div></figure><h1 id="1c43" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="db3a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">防止恶意软件在您的web应用程序上从事滥用活动始终是一个好的做法。最流行的工具是谷歌的reCAPTCHA。在当前状态下，它支持v2和v3。在本文中，我们将重点关注v3，因为它需要更少的用户交互并支持分析。</p><h1 id="424f" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">先决条件</h1><ul class=""><li id="c9db" class="lq lr iq ku b kv kw kz la ld ls lh lt ll lu lp lv lw lx ly bi translated">Go环境(<a class="ae lz" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">指令</a>)</li><li id="956f" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp lv lw lx ly bi translated">一个已经在谷歌的reCAPTCHA控制台上注册的网站</li><li id="4ab0" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp lv lw lx ly bi translated">一个新的目录，e.x <code class="fe mf mg mh mi b">recaptcha-endpoints</code>，在你的<code class="fe mf mg mh mi b">GOPATH</code>里面，我们所有的代码都将存放在那里</li></ul><h1 id="05c6" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">入门指南</h1><p id="e6ed" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">注册您的网站后，将生成一个新的API密钥和秘密对。要使reCAPTCHA工作，需要对web应用程序的前端和后端服务进行更改。我们将只演示如何在后端服务上使用它，因为Google的<a class="ae lz" href="https://developers.google.com/recaptcha/docs/v3?hl=nl#placement_on_your_website" rel="noopener ugc nofollow" target="_blank">文档</a>对于前端的挑战设置非常直接。</p><h1 id="d08f" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">履行</h1><p id="29bb" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们将实现一个简单的服务器，它有一个端点来处理用户的登录，给定一个电子邮件和密码，用Google reCAPTCHA保护。</p><p id="5d06" class="pw-post-body-paragraph ks kt iq ku b kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">验证reCAPTCHA令牌的方法是在<code class="fe mf mg mh mi b"><a class="ae lz" href="https://www.google.com/recaptcha/api/siteverify" rel="noopener ugc nofollow" target="_blank">https://www.google.com/recaptcha/api/siteverify</a></code>上发出一个<code class="fe mf mg mh mi b">POST</code>请求，然后是作为URL参数的秘密和响应令牌。然后评估回答，以确定挑战是否成功。源代码就要出来了。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="39f9" class="pw-post-body-paragraph ks kt iq ku b kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">让我们一步一步地深入了解它</p><ul class=""><li id="e165" class="lq lr iq ku b kv mj kz mk ld mu lh mv ll mw lp lv lw lx ly bi translated">保存Google的reCAPTCHA请求链接的常量变量</li><li id="88ec" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp lv lw lx ly bi translated">一个<code class="fe mf mg mh mi b">LoginRequest</code>结构，包含验证凭证的用户电子邮件和密码，外加一个reCAPTCHA令牌的额外字段。</li><li id="c6ec" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp lv lw lx ly bi translated">一个<code class="fe mf mg mh mi b">SiteVerifyResponse</code>结构，用于解码来自Google reCAPTCHA API的响应。</li><li id="38ca" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp lv lw lx ly bi translated"><code class="fe mf mg mh mi b">main</code>函数定义登录端点处理程序，传递reCAPTCHA秘密作为参数。</li><li id="1148" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp lv lw lx ly bi translated">作为处理程序运行的<code class="fe mf mg mh mi b">Login</code>函数首先解码请求体。然后检查并验证调用<code class="fe mf mg mh mi b">CheckRecaptcha</code>函数的reCAPTCHA令牌，最后验证所提供的凭证。</li><li id="f303" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp lv lw lx ly bi translated">执行所有reCAPTCHA验证相关工作的<code class="fe mf mg mh mi b">CheckRecaptcha</code>函数。接受秘密和响应令牌作为参数，构造适当的<code class="fe mf mg mh mi b">POST</code>请求并发出请求。将响应解码成<code class="fe mf mg mh mi b">SiteVerifyResponse</code>结构并检查验证是否成功，将收到的分数与提供的最小值(<strong class="ku ir"> 0.5 </strong>)进行比较，并检查动作名称(<strong class="ku ir">登录</strong>)</li></ul><blockquote class="mx my mz"><p id="6650" class="ks kt na ku b kv mj kx ky kz mk lb lc nb ml lf lg nc mm lj lk nd mn ln lo lp ij bi translated">通过设置<code class="fe mf mg mh mi b">data-action</code>属性，您可以为网站上的任何操作设置自定义操作名称。通过这种方式，您可以在管理控制台中访问数据的详细细分，并可以为每个操作应用不同的业务逻辑(例如，针对低分登录的2FA身份验证)。</p></blockquote><h1 id="5a78" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">中间件</h1><p id="49a5" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">上面的解决方案是可行的，尽管它不能随着web服务器的增长而扩展。它需要代码复制、处理程序中的通用代码和每个结构中的额外字段，用于解码请求体。</p><p id="b6f8" class="pw-post-body-paragraph ks kt iq ku b kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">为了避免这一切，我们可以实现一个中间件来处理所有的reCAPTCHA验证，并应用于任何需要的端点。前面的代码现在变成了。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cda7" class="pw-post-body-paragraph ks kt iq ku b kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">我们将提到我们代码的第一个版本的变化。</p><ol class=""><li id="f878" class="lq lr iq ku b kv mj kz mk ld mu lh mv ll mw lp ne lw lx ly bi translated"><code class="fe mf mg mh mi b">RecaptchaResponse</code>字段已经从<code class="fe mf mg mh mi b">LoginRequest</code>结构中移除，因为不再需要它。</li><li id="fdb1" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp ne lw lx ly bi translated">引入了一个新的结构<code class="fe mf mg mh mi b">SiteVerifyRequest</code>,它将在中间件函数中用于从请求体中检索reCAPTCHA令牌。</li><li id="dad1" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp ne lw lx ly bi translated"><code class="fe mf mg mh mi b">Login</code>处理函数现在由<code class="fe mf mg mh mi b">RecaptchaMiddleware</code>包装。</li><li id="604f" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp ne lw lx ly bi translated">任何关于reCAPTCHA的源代码都已从处理程序中删除。</li><li id="f4be" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp ne lw lx ly bi translated">接受秘密的新函数<code class="fe mf mg mh mi b">RecaptchaMiddleware</code>已经被创建，它作为中间件运行。包含所有关于谷歌reCAPTCHA验证的代码。将请求体读取并解码成<code class="fe mf mg mh mi b">SiteVerityRequest</code> struct，然后像以前一样检查并验证reCAPTCHA。</li><li id="1d60" class="lq lr iq ku b kv ma kz mb ld mc lh md ll me lp ne lw lx ly bi translated">第125行有一个棘手的部分需要注意。在Go中，http请求体是一个只能读取一次的<code class="fe mf mg mh mi b">io.ReadCloser</code>类型。因此，我们必须恢复它，以便能够在任何后续处理程序中再次使用它。</li></ol><p id="2f1d" class="pw-post-body-paragraph ks kt iq ku b kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll mn ln lo lp ij bi translated">这就是我们解决方案第一版的所有不同之处。这样代码就干净多了，处理程序只包含已经创建的业务逻辑，Google的reCAPTCHA验证只发生在中间件内部的一个地方。</p><h1 id="7a75" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">源代码</h1><p id="1a29" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我实现了一个处理Google reCAPTCHA验证的开源包，它支持v2和v3。还包括一个开箱即用的中间件。可以在<a class="ae lz" href="https://github.com/chanioxaris/go-recaptcha" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>