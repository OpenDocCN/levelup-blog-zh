<html>
<head>
<title>Immutability and Security — From Java to Kotlin to Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不变性和安全性——从Java到Kotlin到Haskell</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/immutability-from-java-to-kotlin-to-haskell-eea641ca1db1?source=collection_archive---------7-----------------------#2020-10-31">https://levelup.gitconnected.com/immutability-from-java-to-kotlin-to-haskell-eea641ca1db1?source=collection_archive---------7-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2fb84fa73410f36d22cc24c24cea8b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4qLZ7_eOeMY1SmWWPNecQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自<a class="ae kc" href="https://pixabay.com/photos/cocoon-butterfly-larva-larvae-209096/" rel="noopener ugc nofollow" target="_blank">来自Pixabay的GLady】</a></figcaption></figure><p id="2a24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不可变对象的状态在创建后不能修改。如果对象在创建后可以被修改，我们称之为对象的变异。简而言之，对象是可变的。</p><p id="c031" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Java_(programming_language)" rel="noopener ugc nofollow" target="_blank"> Java </a>中的例子。</p><p id="81f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe lb lc ld le b">allowedUsers</code>列表，一个<code class="fe lb lc ld le b">getAllowedUsers</code>方法和一个检查<code class="fe lb lc ld le b">username</code>是否为<code class="fe lb lc ld le b">canUserAccessResource</code>的方法。我们可以把它看作是一种简单的访问控制方法，比如<code class="fe lb lc ld le b">canUserAccessResource("Mallory")</code>，它将并且应该返回<code class="fe lb lc ld le b">false</code>。马洛里不在<code class="fe lb lc ld le b">allowedUsers</code>的名单中。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更详细的例子可以在Coursera 的<a class="ae kc" href="https://www.coursera.org/learn/programming-languages/lecture/aOQ26/optional-java-mutation" rel="noopener ugc nofollow" target="_blank">编程语言中找到</a></figcaption></figure><p id="e7bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码有一个与突变相关的问题。具体在哪里？我们想一会儿。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="ebc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的列表<code class="fe lb lc ld le b">allowedUsers</code>可以被修改以允许最初不在列表中的用户访问。</p><p id="71b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个测试来使问题可见并可修复。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="3978" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两项测试都通过了。马洛里，开始时不在<code class="fe lb lc ld le b">allowedUsers</code>中，可访问列表突变后的资源。<strong class="kf ir">那就糟了</strong>。</p><p id="8401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与其学习如何减轻上述问题，我们为什么不使用更多的现代语言呢？这些语言可能会给我们带来开箱即用的不变性。</p><p id="fd5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如<a class="ae kc" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank">科特林</a>？：</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="dbd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不再需要吸气剂了。另外，<a class="ae kc" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html" rel="noopener ugc nofollow" target="_blank">文件</a>在<code class="fe lb lc ld le b">listOf</code>状态:</p><blockquote class="lt lu lv"><p id="0a08" class="kd ke ls kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">返回给定元素的新只读列表。</p></blockquote><p id="ab79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是否解决了安全问题？</p><p id="0ac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次我们用科特林克REPL来代替测试</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="a043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尝试，例如</p><pre class="lf lg lh li gt lz le ma mb aw mc bi"><span id="f4c2" class="md me iq le b gy mf mg l mh mi">authorizedUsers[2] <strong class="le ir">=</strong> "Mallory"</span></pre><p id="d139" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><pre class="lf lg lh li gt lz le ma mb aw mc bi"><span id="762d" class="md me iq le b gy mf mg l mh mi">authorizedUsers <strong class="le ir">=</strong> listOf<strong class="le ir">(</strong>"Mallory"<strong class="le ir">)</strong></span></pre><p id="1ffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会失败。</p><p id="3d0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既没有一个<code class="fe lb lc ld le b">set</code>方法来提供对<code class="fe lb lc ld le b">list</code>的访问，也没有一个方法来重新分配<code class="fe lb lc ld le b">authorizedUsers</code>，因为我们使用的是<code class="fe lb lc ld le b">val</code>而不是<code class="fe lb lc ld le b">var</code>。看起来不错。</p><p id="911f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们能做的就是把它转换成<code class="fe lb lc ld le b">MutableList</code>，然后修改它</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="86dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际对象<code class="fe lb lc ld le b">authorizedUsers</code>可由另一个参考改变。尽管措辞<code class="fe lb lc ld le b">MutableList</code>可能暗示使用<code class="fe lb lc ld le b">List</code>将是不可变的，但事实并非如此。</p><p id="5bfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为科特林辩护:人们经常强调如何使用措辞<code class="fe lb lc ld le b">read-only</code>而不是<code class="fe lb lc ld le b">immutability</code>。<code class="fe lb lc ld le b">listOf</code>的文档再次声明</p><blockquote class="lt lu lv"><p id="8e91" class="kd ke ls kf b kg kh ki kj kk kl km kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">返回一个新的给定元素的只读列表。</p></blockquote><p id="23e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只读的，不是不可变的。让我们离开JVM，继续我们在Haskell中的不变性之旅。Haskell是一种纯函数式语言。</p><p id="19a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<a class="ae kc" href="https://docs.haskellstack.org/en/stable/README/" rel="noopener ugc nofollow" target="_blank">堆栈</a>哈斯克尔REPL。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="db13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Haskell中，数据是不可变的。我们不会改变现有的列表，而是通过应用函数来构建一个新的列表。Haskell帮助我们避免了默认的安全问题。</p><p id="fb26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么以上这些都很重要？这是关于可预测性。高级程序员会认识到Java例子中的问题吗？很有可能。睡眠不足的大三或大四学生会在最后期限前完成任务吗？也许吧。我们会想记住代码库的其他部分是如何修改允许的用户的吗？让我们猜测答案是否定的。</p><p id="c7d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没错。我们可以通过简单地复制getter中的列表来解决Java的问题。现在，是否有人试图改变返回的副本已经无关紧要了。初始的<code class="fe lb lc ld le b">allowedUsers</code>不会改变。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="ff64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管创建副本是我们必须时刻记住的事情。精神开销。</p><p id="3ea9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从Kotlin开始的人会在文档中偶然发现它之前或遇到bug时意识到<code class="fe lb lc ld le b">read-only</code>和<code class="fe lb lc ld le b">immutability</code>之间的区别吗？</p><p id="01b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决上述问题的最简单方法似乎是，我们的编程语言是否默认使用了不变性？</p></div></div>    
</body>
</html>