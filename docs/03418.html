<html>
<head>
<title>Different Ranking Functions in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL中不同的排名函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/difference-between-ranking-functions-in-sql-71d00a5fe11c?source=collection_archive---------7-----------------------#2020-05-07">https://levelup.gitconnected.com/difference-between-ranking-functions-in-sql-71d00a5fe11c?source=collection_archive---------7-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ae3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">等级，密集等级，行数，整数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2baa0d47b8789246a2aeb9dc781bf4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mlyj064nK4sJt2OlBK6vXw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:via <a class="ae ky" href="https://pxhere.com/en/photo/997112" rel="noopener ugc nofollow" target="_blank"> Pxhere </a> (CC0)</figcaption></figure><p id="4672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">排名函数用于根据每行数据相对于所分配的部分或整个数据表的位置对每行数据进行排名。SQL支持如下所示的4种不同类型的排名函数，所有排名函数输出都是从1开始的正整数:</p><p id="2aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">排名:</strong>最常用的排名功能。它根据用户指定的列和顺序为每行数据分配一个排名号。如果列中的多个值相同，它们将收到相同的等级输出，并且顺序中的下一个值将跳过接下来的几个值来填充列中的真实等级。例如，如果两个值相同，并且在组中排名为3，则顺序中的下一个值将被赋值为5。</p><p id="ce3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">密集等级:</strong>密集等级的想法和之前的等级一样。唯一的区别是，即使前几个值相同，顺序中的下一个值也不会跳过。例如，如果两个值相同，并且它们的等级为3，则顺序中的下一个值将被赋值为4。</p><p id="6972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Row_Number: </strong>从1开始到指定组中每一行的顺序号</p><p id="09c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Ntile: </strong>用户需要指定N，即他们想要划分数据组的组数。数据将被平均分割，并根据其所属的数值范围分配输出编号。</p><p id="43e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有4个不同排名函数的语法非常相似:</p><blockquote class="lv"><p id="a1b3" class="lw lx it bd ly lz ma mb mc md me lu dk translated"><em class="mf"> &lt;秩函数&gt;(</em>分区按&lt;列名&gt; <em class="mf">排序按&lt;列名&gt; ) </em></p></blockquote><p id="b32d" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated"><rank function="">这里指的是如上图所示的4个不同的秩函数。“Over”后面的括号定义了您想要对其进行排序的方式。括号中的“Order by”子句是<strong class="lb iu">必需的</strong>，它定义了您想要对数据进行排序的列。您可以在&lt;列名&gt;后加上ASC或DESC，表示升序或降序(默认为降序)。“Partition by”子句是<strong class="lb iu">可选的</strong>，它定义了您想要对数据进行排序的子类别。例如，您希望根据员工各自的部门对其工资进行排名，因此您应该按部门进行分区。Order by和Partition by也可以在其他SQL窗口函数中使用。</rank></p><p id="9e1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4个排名函数之间唯一的语法差异是Ntile需要在<rank function="">之后的括号中指定组的数量，而其他3个需要将其留空。例如，Ntile(4)Over(Partition by department Order by salary)根据薪金在每个部门中创建4个不同的组，并为每一行分配一个从1到4的整数。</rank></p><p id="9925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看一个真实的数据例子。表“公司”包含3个不同部门10名员工的工资信息。我在关于salary的select语句中应用了所有4个排名函数，以显示4个函数之间的差异。</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="a2a3" class="mq mr it mm b gy ms mt l mu mv">SELECT employee_id, department, salary, <br/>rank() over (order by salary desc) as salary_rank,<br/>dense_rank() over (order by salary desc) as salary_denseRank, <br/>row_number() over (order by salary desc) as salary_rowNumber, <br/>ntile(4) over(order by salary desc) as salary_quantile<br/>FROM company;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/48bae77ca8b0992cf65f25968e72403f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YjdLhJGx7WttTGzAIVj-g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">按查询结果排序函数</figcaption></figure><p id="49cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Rank和Dense_Rank函数，如果多个值相同，它们会给<strong class="lb iu">相同的排名号。它们之间唯一的区别是<strong class="lb iu">秩函数将跳过相同值的空格，而dense_rank将只是+1 </strong>，不会跳过空格。例如，我们可以看到有4名员工的薪金为7000，排名为3，因此下一个薪金人员将跳到排名7，而dense_rank将跳到4。Rank函数输出表示将row视为一个实体的公司中的真实薪金位置，而dense_rank表示将每个唯一值视为一个实体的薪金值的等级。</strong></p><p id="1fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Row_number函数不会考虑相同值的情况，只会给出该行在整个表中位置的真实表示。Ntile函数在这里，我将N指定为4，这样我们就可以看到每个雇员的工资处于哪个分位数之下。</p><blockquote class="lv"><p id="a9fc" class="lw lx it bd ly lz ma mb mc md me lu dk translated">如果我们希望看到他们在自己部门内的薪资排名，该怎么办？</p><p id="132f" class="lw lx it bd ly lz ma mb mc md me lu dk translated"><em class="mf">对于每个等级列，我们只需要在上方括号中添加“按部门划分”。</em></p></blockquote><pre class="mx my mz na nb ml mm mn mo aw mp bi"><span id="84db" class="mq mr it mm b gy ms mt l mu mv">SELECT employee_id, department, salary, <br/>rank() over (partition by department order by salary desc) as salary_rank,<br/>dense_rank() over (partition by department order by salary desc) as salary_denseRank, <br/>row_number() over (partition by department order by salary desc) as salary_rowNumber, <br/>ntile(4) over(partition by department order by salary desc) as salary_quantile<br/>FROM company;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/e7edbde7df9b7427c0475ffe044afecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mRpCM6OkVUp1t6ubc6QMg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">按部门排序功能查询结果分区</figcaption></figure><p id="ed52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，所有4个排名输出都基于他们部门内的排名，而不是整个数据表</p></div></div>    
</body>
</html>