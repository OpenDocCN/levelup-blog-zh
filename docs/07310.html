<html>
<head>
<title>Java Chapter 2 : Why Functional Programming in Object-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java第2章:为什么在面向对象编程中使用函数式编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/super-java-functional-programming-in-object-oriented-programming-84dab44a915f?source=collection_archive---------3-----------------------#2021-02-08">https://levelup.gitconnected.com/super-java-functional-programming-in-object-oriented-programming-84dab44a915f?source=collection_archive---------3-----------------------#2021-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e5fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">请先阅读</em> <a class="ae km" href="https://medium.com/swlh/super-basic-java-anonymous-class-functional-interface-and-lambda-expression-fba411a787" rel="noopener"> <em class="kl">我之前的帖子</em> </a> <em class="kl">再继续阅读。</em></p><p id="afb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我之前的文章中，我展示了如何使用函数接口和Lambda表达式给代码添加语法糖。这是我们应该考虑使用它们的充分理由。但是，他们提供的就这些吗？Java引入这些概念肯定有更多的原因。</p><p id="8930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了直接得到答案，函数接口和Lambda表达式允许我们在Java中采用函数式编程。等一下。Java不是一种面向对象的编程语言吗？首先什么是函数式编程，为什么我们必须在Java中采用函数式编程？</p><p id="c613" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将从什么是面向对象编程语言开始，并探究在Java中采用函数式编程背后的动机。然后，我将概述函数式编程的一些关键概念。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/a16ea7bb344eacee31c339f34b3646b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WeIrB0Bgr75QPmkc"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">布莱克·迈耶在<a class="ae km" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="53da" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为什么在Java中使用函数式编程</h1><p id="7c73" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">Java是一种面向对象的编程语言。面向对象编程到底是什么意思？你可能知道OOP是一种编程方式，我们用属性定义对象，分配数据，并使用方法操作数据。你可能也熟悉OOP的概念:封装、抽象、多态和继承。让我们回顾一下。</p><ul class=""><li id="fc2d" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">封装是将数据和代码包装在一个单元中进行操作。封装是通过数据隐藏来控制数据流实现的。</li><li id="9dfc" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">抽象就是隐藏逻辑。想想接口是如何工作。你不需要知道它是如何工作的，只需要知道它能做什么。</li><li id="1f11" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">多态性是采取多种形式的能力。它允许以不同的方式执行相同的动作，这通常是通过继承实现的。</li><li id="3a82" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">继承是扩展一个类。扩展超类的子类继承超类的公共方法和变量。</li></ul><p id="e4ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们思考一下<strong class="jp ir"> <em class="kl">为什么</em> </strong>我们会想到这些概念，我们就能更好地理解OOP。因为Java对象中的数据是可变的，所以容易产生副作用和不希望的变化。这就是为什么我们使用封装和抽象来控制谁可以查看和编辑数据。由于OOP的构建块是一个对象，我们经常以大量样板代码来创建每一个对象而告终。这就是为什么我们使用多态性和继承来实现代码的可重用性和可扩展性。</p><p id="06f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有另一种方法来解决OOP中关于可变状态和长样本代码的一些潜在问题呢？这就是函数式编程发挥作用的地方。</p><h2 id="566a" class="mu le iq bd lf mv mw dn lj mx my dp ln jy mz na lr kc nb nc lv kg nd ne lz nf bi translated">函数式编程简介</h2><p id="6753" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">函数式编程(FP)是将计算编程为数学函数的一种方式。FP既没有状态也没有可变变量。这怎么可能呢？这类似于用final关键字使用所有变量。最初，FP并没有受到太多的关注，因为FP使用了大量的内存来实现无状态，并且内存非常昂贵。但是，内存已经不贵了。更具有讽刺意味的是，这种特殊的特性使得FP更有吸引力。随着现代软件程序变得越来越复杂，对多线程和并行处理的需求也在增加。因为FP没有状态，所以不存在阻塞或并发问题。</p><p id="bcb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FP去除了移动部分，优化了操作，得到了简洁无错的代码。在OOP中采用这种特殊的编码方式(没有状态和可变变量)难道不会使代码更加有效和高效吗？</p><h1 id="fb34" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">二。函数式编程如何工作</h1><p id="d34a" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">为了在Java中使用函数式编程，让我们深入函数式编程的基础。FP的两个关键概念是一级函数和纯函数。</p><h2 id="58a8" class="mu le iq bd lf mv mw dn lj mx my dp ln jy mz na lr kc nb nc lv kg nd ne lz nf bi translated">一流的功能</h2><p id="6138" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">一等职能意味着职能被当作一等公民对待。一等公民支持所有的操作，比如赋值给变量、传递给参数、作为值返回。该属性支持高阶函数。高阶函数是接收一个函数作为参数并返回一个函数的函数。在FP中，高阶函数用于函数合成和currying。</p><h2 id="8704" class="mu le iq bd lf mv mw dn lj mx my dp ln jy mz na lr kc nb nc lv kg nd ne lz nf bi translated">纯函数</h2><p id="5ccf" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">当执行没有副作用，返回值只取决于输入时，函数就是纯函数。</p><p id="01e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个函数在函数之外改变状态时，它会产生副作用。如果一个函数的执行改变了一个类或一个对象的成员变量，甚至改变了一个外部系统，比如数据库，那么这个函数就会产生副作用。</p><p id="3f73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一些例子。</p><pre class="ko kp kq kr gt ng nh ni nj aw nk bi"><span id="13b4" class="mu le iq nh b gy nl nm l nn no">public class Tiger {<br/>   public String cry (String sound) {<br/>      return "Tiger cries" + sound;<br/>   }<br/>}</span></pre><p id="9b08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">cry没有副作用，因为它不会改变函数之外的状态。返回值<strong class="jp ir">只有</strong>取决于输入的声音。</p><p id="f4ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，下面的cry2有副作用。</p><pre class="ko kp kq kr gt ng nh ni nj aw nk bi"><span id="0f95" class="mu le iq nh b gy nl nm l nn no">public class Tiger {<br/>   String tigerCry = "Tiger cries ";<br/>   public String cry2 (String sound) {<br/>      tigerCry += sound;<br/>      return tigerCry;<br/>   }<br/>}</span></pre><p id="fc07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们执行Tiger . cry 2(“roar”)时，它会将成员变量tigerCry更新为“Tiger cries roar”。这违背了纯函数不改变函数外部状态的特性。</p><pre class="ko kp kq kr gt ng nh ni nj aw nk bi"><span id="0b98" class="mu le iq nh b gy nl nm l nn no">Tiger tiger = new Tiger();<br/>System.out.println(tiger.cry("roar")); </span></pre><p id="be96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也因为tigerCry的值被改变，下面代码的执行还“老虎叫吼嚎叫”这里，输出不仅取决于输入，还取决于成员变量tigerCry。这违背了纯函数的特性，在纯函数中，返回值只取决于输入</p><pre class="ko kp kq kr gt ng nh ni nj aw nk bi"><span id="b5d1" class="mu le iq nh b gy nl nm l nn no">System.out.println(tiger.cry("howl")); </span></pre><p id="8009" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">澄清一下，方法可以有局部变量，来临时存储它的状态，只是不能引用类或对象的任何成员变量。</p><h1 id="1818" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">三。Lambda表达式和函数式编程</h1><p id="6d74" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">引入了Java中的Lambda表达式和函数接口，使函数式编程更容易在Java中采用。使用Lambda表达式，我们可以模仿函数式编程语法，将方法赋给变量或将其传递给参数。这几乎就像我们对待一等公民的职能。不过从技术上来说，lambda expression还是实现了一个函数接口。因此，它是一个对象，而不是一个函数。</p><p id="9b03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我结束这篇文章之前，我想分享一段总结OOP和FP的引言。</p><blockquote class="np nq nr"><p id="4579" class="jn jo kl jp b jq jr js jt ju jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj kk ij bi translated">OO通过封装移动部分使代码变得可以理解。FP通过最大限度地减少可移动部分来使代码变得可理解。</p><p id="8822" class="jn jo kl jp b jq jr js jt ju jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj kk ij bi translated">迈克尔·费哲</p></blockquote><p id="7069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的下一篇文章中，我将提供使用Lambda表达式和函数接口的例子，以在Java中应用函数式编程概念。</p></div></div>    
</body>
</html>