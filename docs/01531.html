<html>
<head>
<title>Introduction to Creating Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Web组件简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-creating-web-components-868b53b89799?source=collection_archive---------8-----------------------#2020-01-10">https://levelup.gitconnected.com/introduction-to-creating-web-components-868b53b89799?source=collection_archive---------8-----------------------#2020-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bc6c47dc29204009977f8f2a996469b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0-8ZEAGyeFrHXjLz"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">罗宾·格劳泽在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2c25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着web应用变得越来越复杂，我们需要某种方式将代码分成易于管理的块。要做到这一点，我们可以使用Web组件来创建可以在多个地方使用的可重用组件。</p><p id="1b28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Web组件也与其他代码片段隔离开来，因此很难从其他代码片段中意外修改它们并创建冲突的代码。</p><p id="7f95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看Web组件的不同部分，以及如何创建基本部分。</p><h1 id="0011" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Web组件的组成部分</h1><p id="905a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Web组件有3个主要部分。它们一起封装了可以随时重用的功能，而不用担心代码冲突。</p><ul class=""><li id="7a57" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">自定义元素——一组JavaScript APIs，允许我们定义自定义元素及其行为，我们可以根据需要在UI中使用它们</li><li id="d381" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">shadow DOM —一组JavaScript APIs，用于附加元素的封装shadow DOM树。它与主文档DOM分开呈现。这保持了元素特性的私密性，因此可以编写它们的脚本，而不用担心与文档的其他部分冲突</li><li id="7fd5" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">HTML模板——<code class="fe mv mw mx my b">template</code>或<code class="fe mv mw mx my b">slot</code>元素使我们能够编写不在呈现的页面上显示的标记模板。它们可以作为定制元素结构的基础被多次重用。</li></ul><h1 id="357f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建Web组件</h1><p id="30ea" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了创建Web组件，我们执行以下步骤:</p><ol class=""><li id="8bb5" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mz mn mo mp bi translated">创建一个类或函数来指定web组件功能。</li><li id="cc45" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mz mn mo mp bi translated">使用<code class="fe mv mw mx my b">CustomElementRegistry.define()</code>方法注册我们的新定制元素，传递要定义的元素名和指定功能的类或函数，以及可选地传递它从哪个元素继承而来</li><li id="bd5b" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mz mn mo mp bi translated">使用<code class="fe mv mw mx my b">Element.attachSHadow()</code>方法将阴影DOM附加到定制元素。添加子元素、事件侦听器等。使用普通的DOM方法添加到影子DOM</li><li id="0390" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mz mn mo mp bi translated">使用<code class="fe mv mw mx my b">template</code>和<code class="fe mv mw mx my b">slot</code>标签定义HTML模板。我们使用常规的DOM方法克隆模板，并将其附加到我们的影子DOM。</li><li id="91bf" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mz mn mo mp bi translated">像使用其他常规HTML元素一样，在页面上的任何地方使用自定义元素</li></ol><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/ef5ed25d9aee21d0577b800a92d67888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MMFsDyc9hqfvzMAz"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@lensilium?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">女仆米林基</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="f757" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基本示例</h1><p id="0b53" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx my b">CustomElementRegistry</code>保存了一个已定义的定制元素列表。这个对象让我们在页面上注册新的定制元素，并返回关于注册了哪些定制元素的信息。</p><p id="71fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在页面上注册一个新的定制元素，我们使用了<code class="fe mv mw mx my b">CustomElementRegistry.define()</code>方法。它采用以下参数:</p><ul class=""><li id="1d53" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">表示元素名称的字符串。要求在其中使用虚线。它们不能是单个单词。</li><li id="6661" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">定义元素行为的类对象</li><li id="65f3" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">包含一个<code class="fe mv mw mx my b">extends</code>属性的可选参数，该属性指定我们的元素继承的内置元素(如果有的话)</li></ul><p id="2fa4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下定义自定义元素:</p><pre class="nb nc nd ne gt nf my ng nh aw ni bi"><span id="5134" class="nj lf it my b gy nk nl l nm nn">class WordCount extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    const shadow = this.attachShadow({<br/>      mode: 'open'<br/>    });<br/>    const span = document.createElement('span');<br/>    span.textContent = this.getAttribute('text').split(' ').length;<br/>    const style = document.createElement('style');<br/>    style.textContent = 'span { color: red }';<br/>    shadow.appendChild(style);<br/>    shadow.appendChild(span);<br/>  }<br/>}</span><span id="5a70" class="nj lf it my b gy no nl l nm nn">customElements.define('word-count', WordCount);</span></pre><p id="883c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过调用<code class="fe mv mw mx my b">attachShadow</code>将一个影子DOM附加到我们的文档。<code class="fe mv mw mx my b">mode</code>设置为<code class="fe mv mw mx my b">'open'</code>意味着可以从根之外的JavaScript访问影子根。也可以是<code class="fe mv mw mx my b">'closed'</code>表示相反的意思。</p><p id="dd8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们创建一个<code class="fe mv mw mx my b">span</code>元素，在这里，我们将文本内容设置为<code class="fe mv mw mx my b">text</code>属性的<code class="fe mv mw mx my b">length</code>，只要有空格，我们就将其中的单词拆分出来。</p><p id="f8c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们创建了一个<code class="fe mv mw mx my b">style</code>元素，然后将内容设置为<code class="fe mv mw mx my b">color: red</code>。</p><p id="c7d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们将它们都附加到影子DOM根。</p><p id="737e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，在我们的类中，我们扩展了<code class="fe mv mw mx my b">HTMLElement</code>。我们必须这样做来定义一个自定义元素。</p><p id="6491" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用我们的新元素:</p><pre class="nb nc nd ne gt nf my ng nh aw ni bi"><span id="cc52" class="nj lf it my b gy nk nl l nm nn">&lt;word-count text='Hello world.'&gt;&lt;/word-count&gt;</span></pre><p id="a55f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种类型的自定义元素。它们是:</p><ul class=""><li id="4a76" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">自主定制元素——它们是独立的，不从标准HTML元素继承。我们可以通过直接引用名称来创建它们。比如我们可以写<code class="fe mv mw mx my b">&lt;word-count&gt;</code>，或者<code class="fe mv mw mx my b">document.createElement("word-count")</code>。</li><li id="6cc5" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">定制的内置元素—这些元素继承自基本的HTML元素。我们可以扩展一个内置的HTML元素来创建这些类型的元素。我们可以通过编写<code class="fe mv mw mx my b">&lt;p is="word-count"&gt;</code>或<code class="fe mv mw mx my b">document.createElement("p", { is: "word-count" })</code>来使用它们。</li></ul><p id="3c27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们之前创建的定制元素是自治的定制元素。我们可以通过编写以下内容来创建定制元素:</p><pre class="nb nc nd ne gt nf my ng nh aw ni bi"><span id="6198" class="nj lf it my b gy nk nl l nm nn">class WordCount extends HTMLParagraphElement {<br/>  constructor() {<br/>    super();<br/>    const shadow = this.attachShadow({<br/>      mode: 'open'<br/>    });<br/>    const span = document.createElement('span');<br/>    span.textContent = this.getAttribute('text').split(' ').length;<br/>    const style = document.createElement('style');<br/>    style.textContent = 'span { color: red }';<br/>    shadow.appendChild(style);<br/>    shadow.appendChild(span);<br/>  }<br/>}</span><span id="e917" class="nj lf it my b gy no nl l nm nn">customElements.define('word-count', WordCount, {<br/>  extends: 'p'<br/>});</span></pre><p id="bcc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在我们的页面上写下:</p><pre class="nb nc nd ne gt nf my ng nh aw ni bi"><span id="e74d" class="nj lf it my b gy nk nl l nm nn">&lt;p is='word-count' text='Hello world.'&gt;&lt;/p&gt;</span></pre><p id="960c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，自主的定制元素和定制的内置元素没有什么不同。唯一的区别是我们扩展了<code class="fe mv mw mx my b">HTMLParagraphElement</code>而不是<code class="fe mv mw mx my b">HTMLElement</code>。</p><p id="e170" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们使用了<code class="fe mv mw mx my b">is</code>属性来引用定制元素，而不是在定制的内置元素中使用元素名称。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/9dc8a1ebb3de1b5e221d5a20e67f575e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OMFP-Hv-ZPApz3Ih"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Alex bl Jan在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f308" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">内部与外部风格</h1><p id="ad5e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以像下面这样引用外部样式，而不是像上面那样使用内部样式。例如，我们可以写:</p><pre class="nb nc nd ne gt nf my ng nh aw ni bi"><span id="1340" class="nj lf it my b gy nk nl l nm nn">const linkElem = document.createElement('link');<br/>linkElem.setAttribute('rel', 'stylesheet');<br/>linkElem.setAttribute('href', 'style.css');<br/>shadow.appendChild(linkElem);</span></pre><p id="87d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这引用了来自<code class="fe mv mw mx my b">style.css</code>的样式。我们创建了一个<code class="fe mv mw mx my b">link</code>元素，就像我们在HTML和普通DOM操作中所做的一样。</p><p id="c3bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建Web组件很简单。我们只需为该功能定义一个类或函数，然后通过使用<code class="fe mv mw mx my b">customElements.define</code>方法将它放入自定义元素注册表中。</p><p id="9021" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以扩展现有的元素，比如<code class="fe mv mw mx my b">p</code>元素，或者从头开始创建。此外，我们可以通过创建一个<code class="fe mv mw mx my b">link</code>元素并引用外部文件来添加内部样式或引用外部样式。</p></div></div>    
</body>
</html>