<html>
<head>
<title>Prefixing your commands or scripts with a timestamp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在命令或脚本前添加时间戳</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/prefixing-your-commands-or-scripts-with-a-timestamp-1eb408e92a1c?source=collection_archive---------17-----------------------#2020-05-22">https://levelup.gitconnected.com/prefixing-your-commands-or-scripts-with-a-timestamp-1eb408e92a1c?source=collection_archive---------17-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4d82ab28818f8c0830b96511411f5a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ig9clVbT7Z7tw_Ic"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@goumbik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡斯·布拉塞克</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f1fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您运行一个长时间运行的命令或脚本时，让它的所有输出以时间戳为前缀可能会有所帮助。例如，我们想改变这一点:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3693" class="lk ll iq lg b gy lm ln l lo lp">foo<br/>bar<br/>baz</span></pre><p id="59a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对此:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="172d" class="lk ll iq lg b gy lm ln l lo lp">[2020-12-13 12:20:38] foo<br/>[2020-12-13 12:21:32] bar<br/>[2020-12-13 12:22:20] baz</span></pre><p id="bc67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是你可以做到的。</p><h1 id="a109" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">管道至Awk</h1><p id="2d18" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">关键是将输出传输到另一个工具，该工具从标准输入中读取所有内容，并打印相同的内容，但添加了前缀。</p><p id="b8d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用什么工具？Awk 是一个完美的候选，因为它几乎安装在任何地方。Awk是一个处理文本流的工具。</p><h1 id="9a8e" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">单个命令中的用法</h1><p id="8202" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">下面是一个包含单个命令的示例:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3db7" class="lk ll iq lg b gy lm ln l lo lp">command | awk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'</span></pre><p id="da66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，请注意，上面只是将时间戳前缀添加到写入标准输出的文本中。如果您希望写入标准错误的文本也带有时间戳前缀，那么请确保将标准错误重定向到标准输出，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4a45" class="lk ll iq lg b gy lm ln l lo lp">command 2&gt;&amp;1 | awk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'</span></pre><p id="409c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">神奇的部分是<code class="fe ms mt mu lg b">2&gt;&amp;1</code>。这意味着:将文件描述符2(标准错误)重定向到文件描述符1(标准输出)。</p><h1 id="111d" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Bash脚本中的用法</h1><p id="fcd2" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Bash脚本通常调用多个命令。您不希望手动将每个命令都传送到awk:脚本会很快转向<code class="fe ms mt mu lg b">awk</code>。🙃</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cabb" class="lk ll iq lg b gy lm ln l lo lp"><em class="mv">#!/bin/bash</em><br/>set -e<br/>set -o pipefail</span><span id="9e21" class="lk ll iq lg b gy mw ln l lo lp"><em class="mv"># Yeah, no...</em><br/>apt-get update 2&gt;&amp;1 | awk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'<br/>apt-get install -y foo 2&gt;&amp;1 | awk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'<br/>systemctl restart foo.service 2&gt;&amp;1 | awk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'</span></pre><p id="b1a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们能做得更好吗？是的:您可以告诉Bash，它自己的所有输出(包括Bash运行的命令的所有输出)都应该被重定向到另一个命令:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="13a1" class="lk ll iq lg b gy lm ln l lo lp">exec <strong class="lg ir">&gt;</strong> <strong class="lg ir">&gt;(</strong>awk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'<strong class="lg ir">)</strong> 2&gt;&amp;1</span></pre><p id="9718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是什么诡异的魔法？！？！</p><ul class=""><li id="c82c" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">一个赤裸裸的<code class="fe ms mt mu lg b">exec</code>语句，没有给出进一步的命令，意味着:我们不想实际执行任何东西，我们只想操纵当前Bash进程中的一些文件描述符(管道)。</li><li id="2c2d" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe ms mt mu lg b">&gt;</code>表示:将标准输出(现在包括标准错误)重定向到给定的文件。</li><li id="cc75" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe ms mt mu lg b">&gt;(some command)</code>是一个<a class="ae kc" href="https://www.linuxjournal.com/content/shell-process-redirection" rel="noopener ugc nofollow" target="_blank">过程的替代</a>。这意味着:创建一个新管道，然后使用连接到该管道的标准输入运行<code class="fe ms mt mu lg b">some command</code>，然后向该管道返回一个文件名。</li><li id="695c" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">所以<code class="fe ms mt mu lg b">&gt; &gt;(some command)</code>的意思是:将标准输出重定向到由流程替换创建的管道。</li><li id="159b" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><code class="fe ms mt mu lg b">2&gt;&amp;1</code>的意思是:在当前的Bash进程中，将标准错误重定向到标准输出。</li></ul><p id="b48f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由进程替换创建的管道是临时的，并且在该行结束时立即关闭。在这里你可以看到它的作用:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b33d" class="lk ll iq lg b gy lm ln l lo lp">$ echo The named pipe filename is &gt;(true)<br/>The named pipe filename is /dev/fd/63</span></pre><p id="e588" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您尝试在此后立即访问它，您会发现它已经消失了:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4bde" class="lk ll iq lg b gy lm ln l lo lp">$ ls /dev/fd/63<br/>ls: /dev/fd/63: Bad file descriptor</span></pre><p id="0a87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，将所有这些放在一起，上面这个尴尬的脚本就变成了:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="143f" class="lk ll iq lg b gy lm ln l lo lp"><em class="mv">#!/bin/bash</em><br/>set -e</span><span id="0fed" class="lk ll iq lg b gy mw ln l lo lp">exec <strong class="lg ir">&gt;</strong> <strong class="lg ir">&gt;(</strong>awk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'<strong class="lg ir">)</strong> 2&gt;&amp;1</span><span id="78fc" class="lk ll iq lg b gy mw ln l lo lp">apt-get update<br/>apt-get install -y foo<br/>systemctl restart foo.service</span></pre><h1 id="06e4" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">警告:这是Bash，不是sh</h1><p id="afd1" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated"><code class="fe ms mt mu lg b">sh</code>不是迎头痛击。<code class="fe ms mt mu lg b">sh</code>是一个历史比Bash还老的shell。尽管<code class="fe ms mt mu lg b">/bin/sh</code>可能指向与Bash相同的可执行文件，但是当Bash作为<code class="fe ms mt mu lg b">sh</code>运行时，它将以一种“遗留模式”执行，并禁用一些特性。因此，如果您的shell脚本使用了这篇博客中描述的技巧，请确保您的shebang行是<code class="fe ms mt mu lg b">#!/bin/bash</code>而不是<code class="fe ms mt mu lg b">#!/bin/sh</code>。</p><h1 id="36a9" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">警告:块缓冲</h1><p id="acea" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">如果命令的输出被重定向到管道，命令的行为会有一点不同。</p><p id="06ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常情况下，命令使用<em class="mv">行缓冲</em>，这意味着每当它们打印完一个完整的行，该行将被写入终端。</p><p id="d2e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当输出被重定向到不是终端的东西时，那么命令将使用<em class="mv">块缓冲</em>，这意味着它们实际上并没有写出它们想要打印的内容；直到达到阈值，或者直到命令退出。这个阈值大约为16 KB。您可以在这里看到块缓冲的作用:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a6ee" class="lk ll iq lg b gy lm ln l lo lp">python -c 'import time; print("x" * (1024 * 15)); time.sleep(10)' | cat</span></pre><p id="bc00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个Python命令将15 KB的数据打印到标准输出，然后休眠10秒钟。输出通过管道传输到cat。请注意，在10秒钟的睡眠期间，不会打印任何内容。只有在10秒钟后，它才会打印一些东西。</p><p id="ebd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您将<code class="fe ms mt mu lg b">15</code>增加到<code class="fe ms mt mu lg b">16</code>，那么您将立即看到输出。</p><p id="504d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这种行为对您来说有问题，那么有各种方法来强制行缓冲:</p><h1 id="cf49" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Linux，FreeBSD</h1><p id="4872" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在Linux和FreeBSD上，可以使用<a class="ae kc" href="https://linux.die.net/man/1/stdbuf" rel="noopener ugc nofollow" target="_blank"> stdbuf </a>。将它作为任何要强制行缓冲的命令的前缀:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5803" class="lk ll iq lg b gy lm ln l lo lp">stdbuf -oL python -c 'import time; print("x" * (1024 * 15)); time.sleep(10)' | cat</span></pre><h1 id="8b37" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">马科斯</h1><p id="53ac" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在macOS上，可以从Homebrew安装stdbuf。这是《古兰经》的一部分。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a432" class="lk ll iq lg b gy lm ln l lo lp">brew install coreutils<br/>/usr/local/opt/coreutils/libexec/gnubin/stdbuf -oL python -c 'import time; print("x" * (1024 * 15)); time.sleep(10)' | cat</span></pre><h1 id="6c5e" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">计算机编程语言</h1><p id="a84a" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">对于Python脚本，您可以设置环境变量<code class="fe ms mt mu lg b">PYTHONUNBUFFERED=1</code>，它告诉Python完全禁用任何类型的输出缓冲。</p><h1 id="c191" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Awk替代方案的注意事项</h1><p id="57c3" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Awk有多种实现，具有不同的特性。在Linux上，您通常会使用GNU实现。在macOS上，您将使用BSD实现。如果您打算编写运行在多个操作系统上的shell脚本，那么一定要在您打算支持的所有平台上进行测试。</p><p id="1a6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，macOS上的Awk实现并不支持<code class="fe ms mt mu lg b">strftime</code>功能！</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f13a" class="lk ll iq lg b gy lm ln l lo lp">$ echo hi | awk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'<br/>/usr/bin/awk: calling undefined function strftime<br/> input record number 1, file<br/> source line number 1</span></pre><p id="d790" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用Perl作为替代。Perl也被广泛安装。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="767e" class="lk ll iq lg b gy lm ln l lo lp">$ echo hi | perl -pe 'use POSIX strftime; print strftime "[%Y-%m-%d %H:%M:%S%z] ", localtime; STDOUT-&gt;flush()'<br/>[2020-04-27 15:13:33+0200] hi</span></pre><p id="2aa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者你可以明确地安装GNU实现并使用它。GNU实现也被称为<code class="fe ms mt mu lg b">gawk</code>:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="27af" class="lk ll iq lg b gy lm ln l lo lp">$ brew install gawk<br/>$ echo hi | gawk '{ print strftime("[%Y-%m-%d %H:%M:%S]"), $0 }'<br/>[2020-04-27 15:15:51] hi</span></pre><h1 id="c74c" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">关于Awk的更多信息</h1><p id="9399" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">Awk惊人地强大，却又简洁！这里有一个<a class="ae kc" href="http://www.grymoire.com/Unix/Awk.html" rel="noopener ugc nofollow" target="_blank"> Awk教程</a>。更多深入的信息，请查看<a class="ae kc" href="https://www.gnu.org/software/gawk/manual/gawk.html" rel="noopener ugc nofollow" target="_blank"> GNU Awk用户指南</a>。</p><p id="ecdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你好运，不要害怕被<code class="fe ms mt mu lg b">awk</code>病房。🙃</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="85fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">原载于2020年4月26日https://www.joyfulbikeshedding.com</em><em class="mv"/><a class="ae kc" href="https://www.joyfulbikeshedding.com/blog/2020-04-26-prefixing-your-commands-or-scripts-with-a-timestamp.html" rel="noopener ugc nofollow" target="_blank"><em class="mv">。</em></a></p></div></div>    
</body>
</html>