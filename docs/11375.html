<html>
<head>
<title>React Context: Sync vs Async</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应上下文:同步与异步</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-context-sync-vs-async-8d67562d4b4a?source=collection_archive---------0-----------------------#2022-03-12">https://levelup.gitconnected.com/react-context-sync-vs-async-8d67562d4b4a?source=collection_archive---------0-----------------------#2022-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8f16e0e2b5e58e1255a1918cbda9e1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9coiyG5R0IciHGBLm7v3g.png"/></div></div></figure><div class=""/><p id="4ec3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我在用TypeScript和Firebase写React的个人项目中偶然发现了一个小问题。当我在输入我的凭证后按下登录按钮时，应用程序没有将我重定向到主页。我可以看到上下文正在用Firebase中的用户对象进行更新，但是这些变化似乎并没有传播开来。我在codesandbox中重新创建了这个问题，用最小的上下文和应用程序来复制这个问题。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6785" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">同步案例</h1><p id="c694" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">上下文有一个用户(或未定义的用户)，一个设置默认用户的登录函数，和一个删除用户的注销函数。</p><p id="c686" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Auth.tsx</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c151" class="mp le jb ml b gy mq mr l ms mt">import React, { useState, FC, useContext, createContext } from "react";</span><span id="fe4d" class="mp le jb ml b gy mu mr l ms mt">interface User {<br/>  username: string;<br/>  uid: string;<br/>}</span><span id="297c" class="mp le jb ml b gy mu mr l ms mt">interface AuthContext {<br/>  user?: User;<br/>  signIn: () =&gt; void;<br/>  signOut: () =&gt; void;<br/>}</span><span id="26e2" class="mp le jb ml b gy mu mr l ms mt">const authContext = createContext({} as AuthContext);</span><span id="abc8" class="mp le jb ml b gy mu mr l ms mt">export const useAuth = () =&gt; {<br/>  return useContext(authContext);<br/>};</span><span id="36c4" class="mp le jb ml b gy mu mr l ms mt">const DEFAULT_USER: User = { username: "theo", uid: "123456" };</span><span id="e94f" class="mp le jb ml b gy mu mr l ms mt">function useProvideAuth() {<br/>  const [user, setUser] = useState&lt;User&gt;();</span><span id="0cd5" class="mp le jb ml b gy mu mr l ms mt">const signIn = () =&gt; {<br/>    setUser(DEFAULT_USER)<br/>  };</span><span id="9703" class="mp le jb ml b gy mu mr l ms mt">const signOut = () =&gt; {<br/>    setUser(undefined);<br/>  };</span><span id="474a" class="mp le jb ml b gy mu mr l ms mt">return { user, signIn, signOut };<br/>}</span><span id="007f" class="mp le jb ml b gy mu mr l ms mt">const ProvideAuth: FC = ({ children }) =&gt; {<br/>  const auth: AuthContext = useProvideAuth();<br/>  return(<br/>    &lt;authContext.Provider value={auth}&gt;<br/>      {children}<br/>    &lt;/authContext.Provider&gt;;<br/>  );<br/>};</span><span id="f71d" class="mp le jb ml b gy mu mr l ms mt">export default ProvideAuth;</span></pre><p id="8e9f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">App.tsx:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e417" class="mp le jb ml b gy mq mr l ms mt">import React from 'react';<br/>import ProvideAuth from "./Auth";<br/>import Child from "./Child";</span><span id="5113" class="mp le jb ml b gy mu mr l ms mt">export default function App() {<br/>  return (<br/>    &lt;ProvideAuth&gt;<br/>    &lt;Child /&gt;<br/>    &lt;/ProvideAuth&gt;<br/>  );<br/>}</span></pre><p id="c6c9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Child.tsx</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6ff7" class="mp le jb ml b gy mq mr l ms mt">import React, { FC } from "react";<br/>import { useAuth } from "./Auth";</span><span id="2719" class="mp le jb ml b gy mu mr l ms mt">const Child: FC = () =&gt; {<br/>  const { user, signIn, signOut } = useAuth();</span><span id="1472" class="mp le jb ml b gy mu mr l ms mt">return (<br/>    &lt;div&gt;<br/>    &lt;div&gt;User: {user?.username}&lt;/div&gt;<br/>    {<br/>      user ? <br/>        (&lt;button onClick={signOut}&gt;Sign Out&lt;/button&gt;) : <br/>        (&lt;button onClick={signIn}&gt;Sign in&lt;/button&gt;)<br/>    }<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="743b" class="mp le jb ml b gy mu mr l ms mt">export default Child;</span></pre><p id="b5c7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是应用程序在两种可能状态下的外观:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a824637f084df42546e4437f9bc0e596.png" data-original-src="https://miro.medium.com/v2/resize:fit:164/format:webp/1*vAL6C9Q0Gf_BKDpCJgiSrQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">当用户没有登录时</figcaption></figure><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi na"><img src="../Images/4aa2fa2c9280545b8dac46b63f188bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:182/format:webp/1*OXgBz8YjnqaXm3GkR9r2cQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">当用户登录时</figcaption></figure><p id="fd90" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正如预期的那样工作，更改是即时的，只要单击按钮就会显示用户名。当让用户登录和退出的函数是同步的时，就没有问题，一切都按预期运行。</p><p id="5edd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，在许多情况下，这还不够。让用户登录的函数可以是异步的，就像我的例子一样。Firebase必须发出一个网络请求，并且不确定该操作需要多长时间，以及是否完成。</p><h1 id="15c9" class="ld le jb bd lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma bi translated">异步案例</h1><p id="0f8b" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">让<code class="fe ng nh ni ml b">SignIn </code>和<code class="fe ng nh ni ml b">SignOut</code>函数返回一个<code class="fe ng nh ni ml b">Promise&lt;void&gt;</code>反而有助于复制底层问题:</p><p id="c6cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Auth.tsx中，更新界面:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="e3be" class="mp le jb ml b gy mq mr l ms mt">interface AuthContext {<br/>  user?: User;<br/>  signIn: () =&gt; Promise&lt;void&gt;;<br/>  signOut: () =&gt; Promise&lt;void&gt;;<br/>}</span></pre><p id="f3ad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以及功能:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c89e" class="mp le jb ml b gy mq mr l ms mt">const signIn = async () =&gt; {<br/>  console.log('set DEFAULT_USER in context');<br/>  setUser(DEFAULT_USER);<br/>};</span><span id="9411" class="mp le jb ml b gy mu mr l ms mt">const signOut = async () =&gt; {<br/>  console.log('set undefined user in context');<br/>  setUser(undefined);<br/>};</span></pre><p id="62bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了查看<code class="fe ng nh ni ml b">Child.tsx</code>组件是如何看到这些变化的，我对其进行了修改，以便在点击 登录按钮时，在<strong class="ka jc"> <em class="nj">显示用户的用户名。</em></strong></p><p id="5571" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对Child.tsx的修改:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="bc45" class="mp le jb ml b gy mq mr l ms mt">const Child: FC = () =&gt; {<br/>  const { user, signIn, signOut } = useAuth();</span><span id="8704" class="mp le jb ml b gy mu mr l ms mt">const handleSignIn = async () =&gt; {<br/>    console.log("clicked sign in");<br/>    await signIn();<br/>    console.log("in Child component, user is: ",user ? user.username : "undefined");<br/>  };</span><span id="010b" class="mp le jb ml b gy mu mr l ms mt">return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;User: {user?.username}&lt;/div&gt;<br/>      {<br/>        user ? <br/>          (&lt;button onClick={signOut}&gt;Sign Out&lt;/button&gt;) : <br/>          (&lt;button onClick={handleSignIn}&gt;Sign in&lt;/button&gt;)<br/>      }<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="6a22" class="mp le jb ml b gy mu mr l ms mt">export default Child;</span></pre><p id="508e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果揭示了根本问题:</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c558ef4c82fa725bda9cabddf18426bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*7-V8H1TN-GapT_ADIqeujw.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">尽管用户是在上下文中设置的，但它在嵌套组件中并不立即可用</figcaption></figure><p id="a36c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">控制台输出显示，当单击按钮时，<code class="fe ng nh ni ml b">DEFAULT_USER</code>在上下文中被签名，但是嵌套的<code class="fe ng nh ni ml b">Child.tsx</code>组件可用的用户仍未定义。</p><p id="6f97" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这表明在当前渲染中，即使我们等待异步函数完成，<code class="fe ng nh ni ml b">Child.tsx</code>组件的状态也不会立即更新，<code class="fe ng nh ni ml b">user</code>对象仍然是<code class="fe ng nh ni ml b">undefined</code>。</p><p id="90a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个简化的例子中，这不是问题，因为下一次渲染进行得非常快，并且显示了用户名。只有当一些代码依赖于异步函数的输出时，这才是一个问题。</p><h1 id="2a06" class="ld le jb bd lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma bi translated">使用效果:次优方法</h1><p id="ade8" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">当我第一次写这个的时候，我最初的方法是以下面的方式使用<code class="fe ng nh ni ml b">useEffect</code><strong class="ka jc">(不要这样做，因为它会导致双重渲染！)</strong>:</p><p id="eea7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Child.tsx:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="94cb" class="mp le jb ml b gy mq mr l ms mt">const Child: FC = () =&gt; {<br/>  const { user, signIn, signOut } = useAuth();</span><span id="a747" class="mp le jb ml b gy mu mr l ms mt">useEffect(() =&gt; {<br/>    console.log(user ? user.username : "undefined");<br/>  }, [user]);</span><span id="3923" class="mp le jb ml b gy mu mr l ms mt">return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;User: {user?.username}&lt;/div&gt;<br/>      {<br/>        user ? <br/>          (&lt;button onClick={signOut}&gt;Sign Out&lt;/button&gt;) : <br/>          (&lt;button onClick={signIn}&gt;Sign in&lt;/button&gt;)<br/>      }<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="a985" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如<a class="ae nl" href="https://medium.com/@alexndreazevedo" rel="noopener"><strong class="ka jc">Alex Azvezdo</strong></a><strong class="ka jc"/>所指出的，这是次优的。我浏览了一下，发现了一篇<a class="ae nl" href="https://betterprogramming.pub/updating-state-from-properties-with-react-hooks-5d48693a4af8" rel="noopener ugc nofollow" target="_blank">精彩的文章</a>讨论了这个确切的问题(这篇文章是关于作为道具传递的价值观，而不是通过上下文获得它们，但我认为同样的逻辑也适用)。</p><p id="2cf1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果任何状态正在被更新，那么<code class="fe ng nh ni ml b">useEffect</code>钩子将导致<strong class="ka jc">第二次渲染</strong>,这是浪费。</p><h1 id="3dbb" class="ld le jb bd lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma bi translated">更好的方法</h1><p id="ccf1" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在这个简单的例子中，可以完全避免在钩子内部进行某些操作。</p><p id="6ee8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Child.tsx</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8f94" class="mp le jb ml b gy mq mr l ms mt">const Child: FC = () =&gt; {</span><span id="451c" class="mp le jb ml b gy mu mr l ms mt">const { user, signIn, signOut } = useAuth();</span><span id="96ec" class="mp le jb ml b gy mu mr l ms mt">if(user){<br/>  console.log("user is: ", user);<br/>  <em class="nj">//DO other operations here<br/></em>} else {<br/>  console.log("undefined user");<br/>}</span><span id="780d" class="mp le jb ml b gy mu mr l ms mt">return (<br/>  &lt;div&gt;<br/>  &lt;div&gt;User: {user?.username}&lt;/div&gt;<br/>    {user ? <br/>      (&lt;button onClick={signOut}&gt;Sign Out&lt;/button&gt;) : <br/>      (&lt;button onClick={signIn}&gt;Sign in&lt;/button&gt;)<br/>    }<br/>  &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="55ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之前我有一个<strong class="ka jc">异步</strong> <code class="fe ng nh ni ml b">handleSignIn</code>函数，当点击<strong class="ka jc">按钮时触发，</strong>将<strong class="ka jc">等待</strong>来自<strong class="ka jc">上下文的登录函数。</strong>这是<strong class="ka jc">没有必要的。</strong></p><p id="6488" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，来自<strong class="ka jc">上下文</strong>的<code class="fe ng nh ni ml b">signIn</code>函数可以被按钮的<code class="fe ng nh ni ml b">onClick</code>函数直接调用<strong class="ka jc">。这避免了完全使用钩子。</strong></p><p id="818a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这分离了用户登录的逻辑(这是在上下文中完成的，<strong class="ka jc">然后</strong>传播到子组件)，然后用它做一些事情(在我的例子中，导航到其他页面)。</p><figure class="mg mh mi mj gt is gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f39d0bb56e02c4f712eb1d0299411cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*LMzmfYuiNxoEmflvu-CBPA.png"/></div></figure><p id="5bda" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所示，这比我以前的方法简单多了。</p><h1 id="05fb" class="ld le jb bd lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma bi translated">当前组件的挂钩</h1><p id="1b55" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated"><a class="ae nl" href="https://michaellandis.medium.com/" rel="noopener"> Michael Landis </a>提议将<a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/think-of-react-hooks-as-state-machines-not-functions-39cf9d086a94">反应功能组件视为有限状态机</a>而非功能。这是一个很好的见解，对我解决这个问题很有帮助。</p><p id="d56b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将功能组件状态视为<strong class="ka jc">确定性有限状态机</strong>中的状态，并将钩子视为这些状态之间的<strong class="ka jc">转换</strong>，由此可见<code class="fe ng nh ni ml b">useEffect</code>钩子对于更新其所属组件<strong class="ka jc">的状态是有用的。如果useEffect依赖于组件状态之外的东西，那么它就不是一个确定性的转移函数。</strong></p><p id="bc42" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为解决方案是确保钩子不依赖于其组件之外的东西。在我的例子中，<code class="fe ng nh ni ml b">useEffect</code>在依赖数组中有<code class="fe ng nh ni ml b">user</code>，它来自<strong class="ka jc">上下文，这是错误的。</strong></p><p id="b87c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为<strong class="ka jc">道具</strong>接收的变量和从<strong class="ka jc">上下文</strong>获得的变量将总是<strong class="ka jc">新鲜的，</strong>因为当它们改变时，会触发重新渲染。在这种情况下，当<code class="fe ng nh ni ml b">user</code>在<strong class="ka jc">上下文</strong>中被更新时，更新的值被传播给任何观察者。这导致了重新渲染，并且<code class="fe ng nh ni ml b">Child</code>组件可以确保它得到最新的<code class="fe ng nh ni ml b">user</code>。</p><h1 id="4a27" class="ld le jb bd lf lg nb li lj lk nc lm ln lo nd lq lr ls ne lu lv lw nf ly lz ma bi translated">结论</h1><p id="bb87" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我不得不艰难地学习如何尊重React生命周期，并且我希望与任何面临类似挑战的人分享我的经验。希望这能帮助某人避免我的错误！</p></div></div>    
</body>
</html>