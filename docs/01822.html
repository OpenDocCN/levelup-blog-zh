<html>
<head>
<title>MERNN: To-Do App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MERNN:待办事项应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mernn-to-do-app-dab1e3173493?source=collection_archive---------3-----------------------#2020-01-31">https://levelup.gitconnected.com/mernn-to-do-app-dab1e3173493?source=collection_archive---------3-----------------------#2020-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/f44e0fe1a1ce20fba74726cd1f81212c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*h7wRW-3ZS4Qc11cFk6BP1A.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">MongoDB，Express.js，React Native + Node.js</figcaption></figure><p id="ab61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我上一篇关于Express.js的文章<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/introduction-to-express-js-a-node-js-framework-fa3dcbba3a98">的基础上，我们将通过创建一个待办事项应用程序并使用MongoDB在本地保存数据来扩展我们的应用程序的功能。</a></p><p id="c7a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子更多的是针对Express + MongoDB，而不是React Native。我已经提供了带有工作前端的样板代码来帮助您开始:</p><div class="kx ky gp gr kz la"><a href="https://github.com/TylerKnvpp/mernn-todo-boilerplate.git" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">TylerKnvpp/mernn-todo-boilerplate</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">github.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo js la"/></div></div></a></div><p id="434c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">分叉repo，然后打开两个终端，导航到项目目录并输入以下命令:</p><p id="a6a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lp">端子1 = &gt; </em> <code class="fe lq lr ls lt b">/client</code></p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="70fa" class="mc md iq lt b gy me mf l mg mh">cd client<br/>yarn</span></pre><p id="4a73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lp">端子1 = &gt; </em> <code class="fe lq lr ls lt b">/backend</code></p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="df79" class="mc md iq lt b gy me mf l mg mh">cd backend<br/>yarn</span></pre><p id="5109" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回顾一下后端的依赖性。如果打开package.json，您会看到以下内容:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="2bc8" class="mc md iq lt b gy me mf l mg mh"><strong class="lt ir">{<br/>  "name": "mernn-todo-boilerplate",<br/>  "version": "1.0.0",<br/>    "scripts": {<br/>      "client": "cd client &amp;&amp; yarn start",<br/>      "server": "nodemon server.js",<br/>      "dev": "concurrently --kill-others-on-fail \"yarn server\" \"yarn client\""<br/>     },<br/>  "dependencies": {<br/>    "body-parser": "^1.18.3",<br/>    "cors": "^2.8.5",<br/>    "dotenv": "^8.2.0",<br/>    "express": "^4.16.4",<br/>    "mongoose": "^5.8.9",<br/>    "morgan": "^1.9.1",<br/>    "nodemon": "^2.0.2"<br/>   },<br/>  "devDependencies": {<br/>    "concurrently": "^4.0.1"<br/>     }<br/>   }</strong></span></pre><p id="a01d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的快递依赖关系是<code class="fe lq lr ls lt b">express</code>、<code class="fe lq lr ls lt b">body-parser</code>、<code class="fe lq lr ls lt b">morgan</code>。<code class="fe lq lr ls lt b">mongoose</code>是用于<strong class="ka ir"> MongoDB </strong>和Node的对象数据建模(ODM)库。它管理数据之间的关系，提供模式验证，并用于在代码中的对象和那些对象在<strong class="ka ir"> MongoDB </strong>中的表示之间进行转换。<code class="fe lq lr ls lt b">nodemon</code>是一个实用程序，它将监视源代码中的任何变化，并自动重启服务器。<code class="fe lq lr ls lt b">dotenv</code>是一个零依赖模块，将环境变量从<code class="fe lq lr ls lt b">.env</code>文件加载到<code class="fe lq lr ls lt b">process</code>。</p><p id="28ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看后端目录的设置。我们有一个<code class="fe lq lr ls lt b">server.js</code>文件，我们所有的服务器/ Express应用程序逻辑都将存在其中。我们有一个数据模型的目录，在那里我们将创建并定义什么构成了“待办事项”然后我们有了一个路由目录和<code class="fe lq lr ls lt b">todos.routes.js</code>文件，所有的路由逻辑都将在这里实现。node——Express是在其上构建的——与CommonJS配合得非常好，所以我们将在需要时使用require语句和第三方模块</p><p id="25a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从旋转我们的MongoDB数据库开始。要做到这一点，请确保您的机器上已经下载了mongo。</p><div class="kx ky gp gr kz la"><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">在macOS上安装MongoDB社区版- MongoDB手册</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">MongoDB Atlas MongoDB Atlas是云中托管的MongoDB服务，可以在几分钟内启动并运行。获得…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">docs.mongodb.com</p></div></div><div class="lj l"><div class="mi l ll lm ln lj lo js la"/></div></div></a></div><p id="3fc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">先决条件:</p><ol class=""><li id="68af" class="mj mk iq ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated">你需要安装自制软件</li><li id="1e14" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">您需要安装xCode</li></ol><p id="01d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的终端中，在您机器的根目录下运行以下命令:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="37af" class="mc md iq lt b gy me mf l mg mh">brew tap mongodb/brew<br/>brew install mongodb-community@4.2</span></pre><p id="f26c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在已经安装了MongoDB，运行以下命令创建一个DB:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="cfaf" class="mc md iq lt b gy me mf l mg mh">mongo<br/>use todos</span></pre><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/d18525e215a68c986ab154e08cfe19d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUmwCXF1EC8F307fU6rSig.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">使用mongo cli创建本地数据库</figcaption></figure><p id="a149" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们按代码。</p><p id="4aec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<code class="fe lq lr ls lt b">server.js</code>，让我们与新的本地数据库建立连接。</p><p id="9b01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lp"> server.js </em></p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="b491" class="mc md iq lt b gy me mf l mg mh">...<br/>app.use(bodyParser.json());</span><span id="95df" class="mc md iq lt b gy nc mf l mg mh"><strong class="lt ir">mongoose.connect("mongodb://127.0.0.1:27017/tasks", { useNewUrlParser: true });</strong></span><span id="9412" class="mc md iq lt b gy nc mf l mg mh"><strong class="lt ir">const connection = mongoose.connection;</strong></span><span id="82cb" class="mc md iq lt b gy nc mf l mg mh"><strong class="lt ir">connection.once("open", function() {<br/>    console.log("MongoDB database connection established successfully");<br/>});</strong></span><span id="2d36" class="mc md iq lt b gy nc mf l mg mh">...</span></pre><p id="b12e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了。现在，让我们通过启动服务器来检查连接。打开终端，导航到后端目录并运行以下命令:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0003" class="mc md iq lt b gy me mf l mg mh">node server.js</span></pre><p id="e71f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会在终端上看到以下输出:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/e1eba6328f857d958e5aada411feee40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVJ21eKaL_EIbpUYhGVUKQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">MongoDB数据库连接成功</figcaption></figure><p id="572d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们建立我们的待办事项数据模型。打开<code class="fe lq lr ls lt b">/models/todos.model.js</code>我们将使用<code class="fe lq lr ls lt b">mongoose</code>的模式模块来构建我们的数据模型。</p><p id="a33c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lp"> /models/todos.model.js </em></p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="37c8" class="mc md iq lt b gy me mf l mg mh">const mongoose = require("mongoose");<br/>const Schema = mongoose.Schema;</span><span id="b5c8" class="mc md iq lt b gy nc mf l mg mh">let Todo = new Schema(<br/>{<strong class="lt ir"><br/> todo_description: {<br/>   type: String<br/>  },<br/> todo_responsible: {<br/>   type: String<br/>  },<br/> todo_priority: {<br/>   type: String<br/>  },<br/> todo_completed: {<br/>   type: Boolean<br/>  }<br/> </strong>},<br/>  { timestamps: true }<br/> );</span><span id="422e" class="mc md iq lt b gy nc mf l mg mh">module.exports = mongoose.model("ToDo", Todo);</span></pre><p id="c7fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在新的模式中，我们定义了数据库的键以及接受什么值。Mongo将生成id和时间戳。现在让我们设置我们的路由逻辑。打开<code class="fe lq lr ls lt b">routes/routes.js</code>即可上手。</p><p id="555b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用该文件中的快速路由器模块来设置逻辑。我们还将导入我们刚刚创建的Todo模型。我已经添加了一些路线来开始，所以我们所要做的就是添加逻辑。让我们从我们的<code class="fe lq lr ls lt b">GET</code>请求开始。因此，当我们的前端向<code class="fe lq lr ls lt b"><a class="ae kw" href="http://localhost:3000/todos/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/todos/</a></code>发出请求时，我们将发回一个包含所有待办事项的响应。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="be24" class="mc md iq lt b gy me mf l mg mh">router.route("/").get((req, res) =&gt; {<strong class="lt ir"><br/>  Todo.find(function(err, todos) {<br/>    if (err) {<br/>     console.log(err);<br/>    } else {<br/>     res.json(todos);<br/>    }<br/>  });<br/></strong> });</span></pre><p id="ddac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">够简单！但是，假设我们希望能够独立于已完成的任务呈现未完成的任务，而不必在前端实现任何复杂的逻辑。为了节省一些麻烦，让我们为已完成和未完成的任务创建一个自定义路线。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="72ad" class="mc md iq lt b gy me mf l mg mh">router.route("/completed").get((req, res) =&gt; {<strong class="lt ir"><br/>  Todo.find(function(err, todos) {<br/>   if (err) {<br/>    console.log(err);<br/>   } else {<br/>    let completedTodos = todos.filter(todo =&gt; todo.todo_completed);<br/>    res.json(completedTodos);<br/>   }<br/>  });<br/></strong>});</span><span id="9222" class="mc md iq lt b gy nc mf l mg mh">router.route("/incomplete").get((req, res) =&gt; {<br/> <strong class="lt ir">Todo.find(function(err, todos) {<br/>    if (err) {<br/>     console.log(err);<br/>    } else {<br/>    let incompleteTodos = todos.filter(todo =&gt; !todo.todo_completed);    <br/>    res.json(incompleteTodos);<br/>    }<br/>  });<br/></strong>});</span></pre><p id="be2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以向这些自定义路由发出一个<code class="fe lq lr ls lt b">GET</code>请求来获取我们需要渲染的数据，而不是循环遍历我们在前端接收到的数据。接下来，我们需要通过将id作为参数传递来覆盖返回单个todo的路由。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="1793" class="mc md iq lt b gy me mf l mg mh">router.route("/:id").get((req, res) =&gt; {<strong class="lt ir"><br/>  let id = req.params.id;<br/>    Todo.findById(id, (err, todo) =&gt; {<br/>   res.json(todo);<br/>  });<br/></strong>});</span></pre><p id="97b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们的前端向<code class="fe lq lr ls lt b"><a class="ae kw" href="http://localhost:3000/1234" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/1234</a></code>发出一个请求，我们的服务器将发送回这个任务。这涵盖了我们的<code class="fe lq lr ls lt b">GET</code>请求，让我们继续下一条RESTful路线。要添加todo，我们需要从前端发出一个<code class="fe lq lr ls lt b">POST</code>请求。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="f8b4" class="mc md iq lt b gy me mf l mg mh">router.route("/add").post((req, res) =&gt; {<strong class="lt ir"><br/>   const todo = new Todo(req.body);</strong></span><span id="39e5" class="mc md iq lt b gy nc mf l mg mh">   <strong class="lt ir">todo</strong><br/>    <strong class="lt ir">.save()<br/>    .then(todo =&gt; {<br/>        res<br/>         .status(200)<br/>         .json({ addedTodo: todo, todos: "Task added successfully." });<br/>     })<br/>     .catch(err =&gt; {<br/>         res.status(400).json({ todos: "ERROR: Task could not be added." });<br/>     });<br/></strong> });</span></pre><p id="9acf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的最终路线，让我们覆盖一个<code class="fe lq lr ls lt b">PATCH</code>的逻辑，这样我们就可以更新任务(将它们标记为完成)。</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="21bd" class="mc md iq lt b gy me mf l mg mh">router.route("/update/:id").post(function(req, res) {<strong class="lt ir"><br/>   Todo.findById(req.params.id, function(err, todo) {<br/>     if (!todo) res.status(404).send("data is not found");<br/>     else todo.todo_description = req.body.todo_description;<br/>          todo.todo_responsible = req.body.todo_responsible;<br/>          todo.todo_priority = req.body.todo_priority;<br/>          todo.todo_completed = req.body.todo_completed;<br/>    </strong>todo<br/>      <strong class="lt ir">.save()<br/>      .then(todo =&gt; {<br/>        res.json("Task Updated!");<br/>       })<br/>      .catch(err =&gt; {<br/>        res.status(400).send("Cannot update task");<br/>       });<br/>   });<br/></strong> });</span></pre><p id="72c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到你的<code class="fe lq lr ls lt b">server.js</code>文件，这样我们就可以把所有的东西联系起来。这种将路由从服务器文件中分离出来的惯例是不必要的，但它有助于代码更加简洁。您可以将所有的路由逻辑放在<code class="fe lq lr ls lt b">server.js</code>中，但是这个文件很快就会变得非常冗长和复杂。接下来，我们需要做的就是告诉我们的Express应用程序使用todos路由器。我们可以通过向<code class="fe lq lr ls lt b">server.js</code>添加以下代码来实现这一点:</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="0abe" class="mc md iq lt b gy me mf l mg mh"><strong class="lt ir">...</strong></span><span id="894c" class="mc md iq lt b gy nc mf l mg mh"><strong class="lt ir">const todosRouter = require("./routes/todos");<br/>app.use("/todos", todosRouter);</strong></span><span id="ca70" class="mc md iq lt b gy nc mf l mg mh">app.listen(PORT, function() {<br/>   console.log("Server is running on Port: " + PORT);<br/>});</span></pre><p id="cd4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！我们的后端逻辑是为一个简单的应用程序设置的。我们可以把两个都旋转起来测试一下。打开单独的终端并输入以下内容:</p><p id="4f7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">终端1 = &gt;/客户端</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="7530" class="mc md iq lt b gy me mf l mg mh">cd client<br/>yarn start</span></pre><p id="8ab3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">终端2 = &gt;/后端</p><pre class="lu lv lw lx gt ly lt lz ma aw mb bi"><span id="2d5b" class="mc md iq lt b gy me mf l mg mh">cd backend<br/>node server.js</span></pre><p id="3191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以走了！如果所有内容都已正确添加(或者如果我没有出错)，您应该会看到以下内容:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/32b4842d1a6d66f84884a5432b7896f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RK8rCUnVYgidrGQPEpTTbg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">首次运行该应用程序</figcaption></figure><p id="52d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加一些任务:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nf"><img src="../Images/1403e6640e1771f0ceea4d17967bc340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99GZhZEQxl5G-I2eN-tOFw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">添加了一些任务</figcaption></figure><p id="681c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成一两项任务:</p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ng"><img src="../Images/5ea8e198f83c5addec210b182a843d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oOASRmEa1KeMOUkigBTUzg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">已完成的任务</figcaption></figure><p id="67ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给你。您创建了一个Express服务器，并用MongoDB提供的本地数据库持久化数据。没那么难，对吧？从来都不是。</p><p id="2f2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续磨！</p></div></div>    
</body>
</html>