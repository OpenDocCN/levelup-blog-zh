<html>
<head>
<title>NodeJS — Virtual Domains with VHost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS —带有VHost的虚拟域</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nodejs-virtual-domains-with-vhost-ce2d039db040?source=collection_archive---------6-----------------------#2020-01-22">https://levelup.gitconnected.com/nodejs-virtual-domains-with-vhost-ce2d039db040?source=collection_archive---------6-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f977" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用vhost中间件创建虚拟域</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5fbd508c07735ba20157f23671fcc05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gLYO_cPFUl10p6gvd3gAgA.jpeg"/></div></div></figure><h1 id="24d0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">首先，什么是VHost？</h1><p id="1a3b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe mi mj mk ml b">vhost</code>是一个NodeJS中间件包，作为一个简单的管理器，根据请求的主机名将流量分段到特定的服务。更常见的是，你会看到在Express服务器中使用的<code class="fe mi mj mk ml b">vhost</code>，因为它通过<code class="fe mi mj mk ml b">Express.vhost</code>与<strong class="lo iu"> Express </strong>标准库捆绑在一起。</p><p id="3fc8" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">看github 上的<code class="fe mi mj mk ml b">vhost</code> <a class="ae mr" href="https://github.com/expressjs/vhost/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">源码，代码其实挺简单的。它所做的就是读取<code class="fe mi mj mk ml b">req.headers.host</code>值，然后有一些帮助函数用于对解析后的主机名进行<strong class="lo iu">正则表达式</strong>验证。<strong class="lo iu">在其核心，该包根据指定的RegEx </strong>验证请求主机名。</a></p><p id="67c5" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">尽管它的实现很简单，但它允许您的服务器组织和限制不同主机名的HTTP流量。</p><h1 id="f55b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">应该在什么时候使用？</h1><p id="536f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">服务器上<code class="fe mi mj mk ml b">vhost</code>中间件的一些常见用途:</p><ul class=""><li id="74cd" class="ms mt it lo b lp mm ls mn lv mu lz mv md mw mh mx my mz na bi translated">您的服务器需要以不同的方式处理来自不同主机名(包括子域)的请求。</li><li id="3881" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">您希望限制来自某些路由的传入流量(尽管可以通过其他方式实现)。</li><li id="4cef" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">您可以创建多个主机名来避免浏览器上的“最大主机连接数限制”。</li><li id="fe0b" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">您希望根据请求主机名添加/删除/更新特定的请求属性(如自定义标题)..</li></ul><h1 id="aba2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">简单的VHost示例</h1><p id="284b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个例子展示了如何通过虚拟主机名(在这个例子中是一个子域)将应用程序分段，并将它们路由到一个特定的服务。</p><pre class="kj kk kl km gt ng ml nh ni aw nj bi"><span id="681a" class="nk kv it ml b gy nl nm l nn no">const <strong class="ml iu">connect</strong> = require('<strong class="ml iu">connect</strong>')<br/>const <strong class="ml iu">vhost</strong> = require('<strong class="ml iu">vhost</strong>')<br/>const <strong class="ml iu">server</strong> = <strong class="ml iu">connect</strong>()</span><span id="969e" class="nk kv it ml b gy np nm l nn no">const <strong class="ml iu">emailApp</strong> = <strong class="ml iu">connect</strong>()<br/><br/>const <strong class="ml iu">userApp</strong> = <strong class="ml iu">connect</strong>()<br/><br/><strong class="ml iu">server</strong>.use(<strong class="ml iu">vhost</strong>('email.local', <strong class="ml iu">emailApp</strong>))<br/><br/><strong class="ml iu">server</strong>.use(<strong class="ml iu">vhost</strong>('*.user.local', <strong class="ml iu">userApp</strong>))<br/><br/><strong class="ml iu">server</strong>.listen(3000)</span></pre><p id="e57c" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这个简单的服务器将只对与<code class="fe mi mj mk ml b">email.local</code>匹配的主机的请求使用<code class="fe mi mj mk ml b">emailApp</code>，而<code class="fe mi mj mk ml b">userApp</code>将只处理来自子域<code class="fe mi mj mk ml b">*.user.local</code>的请求。</p><p id="d4a8" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">存储库中记录了几个类似的例子:<br/>【https://github.com/expressjs/vhost/blob/master/README.md】T21</p><p id="aa12" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><strong class="lo iu">中间件还为请求对象添加了各种</strong> <code class="fe mi mj mk ml b">.vhost</code> <strong class="lo iu">属性，如下所示。</strong></p><pre class="kj kk kl km gt ng ml nh ni aw nj bi"><span id="34d2" class="nk kv it ml b gy nl nm l nn no"><strong class="ml iu">app</strong>.use(<strong class="ml iu">vhost</strong>('*.*.example.com', (<strong class="ml iu">req</strong>, res, next) =&gt; {<br/>  console.log(req.<strong class="ml iu">vhost</strong>.<strong class="ml iu">host</strong>) // =&gt; 'foo.bar.example.com:8080'<br/>  console.log(req.<strong class="ml iu">vhost</strong>.<strong class="ml iu">hostname</strong>) // =&gt; 'foo.bar.example.com'<br/>  console.log(req.<strong class="ml iu">vhost</strong>.<strong class="ml iu">length</strong>) // =&gt; 2<br/>  console.log(req.<strong class="ml iu">vhost[0]</strong>) // =&gt; 'foo'<br/>  console.log(req.<strong class="ml iu">vhost[1]</strong>) // =&gt; 'bar'<br/>}))</span></pre><p id="de0a" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">您可以看到<code class="fe mi mj mk ml b">vhost</code>中间件已经很好地解析了主机，以便在处理程序中更容易使用。</p><h1 id="335a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="c320" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">希望这篇文章能帮助你认识到<code class="fe mi mj mk ml b">vhost</code>中间件的简单性。“<strong class="lo iu">虚拟域名</strong>的概念可能听起来令人生畏，但在实践中，我们能够看到它们是多么简单。它提供了一种简单干净的方式来管理不同的主机如何与你的服务器通信。</p></div></div>    
</body>
</html>