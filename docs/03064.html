<html>
<head>
<title>Elements of an OpenShift CI/CD Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenShift CI/CD管道的元素</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/elements-of-an-openshift-ci-cd-pipeline-dd996f10c29?source=collection_archive---------15-----------------------#2020-04-17">https://levelup.gitconnected.com/elements-of-an-openshift-ci-cd-pipeline-dd996f10c29?source=collection_archive---------15-----------------------#2020-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9fb9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建企业级DevSecOps生产就绪管道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c0f88a72d756ecec8af52d3c624781e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_ReKr4BPT-mggF12"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@realaxer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">田宽</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="fcea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目的是解释与构建CI/CD管道相关的一些基本概念，以及它们与OpenShift的关系。这是一个介绍性的指南，事实上，这是一个相当大的主题。在适当的时候，更深入和面向实施的指导方针被链接到本文件。</p><p id="3ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">主题:</strong></p><ul class=""><li id="0d87" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">不变的基础设施</li><li id="1968" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">管道阶段和管道流程</li><li id="d4dd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">管道阶段的类型</li><li id="67c7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj">构建阶段</em></li><li id="1f3b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj">晋升阶段</em></li><li id="c156" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj">验证阶段</em></li><li id="1dc7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="mj">合规阶段</em></li><li id="9444" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">管道的所有权</li><li id="20c3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">指标和仪表板</li><li id="744b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">结论</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="cb34" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">不变的基础设施</h1><p id="8b46" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">不可变基础设施的一般概念是，只有一种方法可以将变更引入到系统中，那就是破坏并重新创建该系统。这种方法的主要好处是以一种非常可控的方式引入更改，从而最大限度地减少偏差和错误配置。此外，采用单一的方法来引入变更允许更多地关注自动化和优化。<a class="ae ky" href="https://en.wikipedia.org/wiki/Infrastructure_as_Code" rel="noopener ugc nofollow" target="_blank">代码形式的基础设施</a>是一种用于实现不可变基础设施的常用方法(这个主题超出了本文的范围)。</p><p id="7e82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">系统和基础设施可以被迅速摧毁和重建。因此，不变性不应该被解释为僵化，而是一个关于如何引入变化的非常规定性的规则。对于给定系统实例的生命周期，它是不可变的。</p><p id="a1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不可变基础设施的概念可以应用于基于容器的解决方案和部署管道，其思想是逐步锁定基础设施:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/f9594162ad7ffe0be2b4b0e5960f00e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CsZa5g-uKJPIkwhz.png"/></div></div></figure><p id="e37a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基础设施的各个部分在不同的阶段被锁定，并且每个基础设施部分在被锁定之后变得不可改变。</p><p id="c00a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">代码构建阶段</strong>锁定业务逻辑。这是关于从我们的代码开始创建一个可部署的工件。我们一直做到这一步。<br/><strong class="lb iu">映像构建阶段</strong>锁定二进制执行环境并创建容器映像。创建容器映像后，业务逻辑可以在任何地方执行，不会出现偏差(对于二进制文件和其他运行时依赖项)。<br/><strong class="lb iu">拓扑定义阶段</strong>锁定解决方案的拓扑。假设部署涉及由几个组件组成的解决方案，这个阶段创建并锁定描述必须部署哪些组件及其依赖关系的拓扑。利用声明性API来创建所需的计算、网络和存储资源的清单。</p><p id="8c47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们已经锁定了大部分基础架构，还没有部署任何东西。</p><p id="cace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个阶段执行环境部署。在部署过程中，会注入依赖于环境的属性，包括公共属性和机密凭据。</p><p id="fb29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了遵守部署后基础设施不变的原则，在环境中引入新变化的唯一方法是重复前面的过程。不管我们想要引入的变化的性质如何，这都是正确的，这可能包括:</p><ul class=""><li id="75db" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">代码发布</li><li id="7904" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">运行时更新</li><li id="7f93" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">安全补丁</li><li id="723a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">配置更改</li></ul><p id="5bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在传统环境中，后三项通常是运营团队的责任，执行时开发团队不一定参与。对于不可变的基础设施和容器，部署过程需要彻底地重新思考，并且需要开发团队的参与。</p><p id="dc06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经描述的进展锁定过程的阶段可以在CI/CD管道中实现。以下部分讨论管道的类型以及管道中的步骤类型。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="100f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">管道阶段和管道流程</h1><p id="e5e9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><a class="ae ky" href="https://jenkins.io/doc/book/pipeline/#stage" rel="noopener ugc nofollow" target="_blank"> <em class="mj">管道阶段</em> </a>是一组逻辑分组的任务，旨在实现管道内的特定功能(例如，构建应用、部署应用、测试应用、推广应用)。当所有阶段无故障完成时，管道成功。通常，阶段以一致的顺序连续运行(一个接一个)，但有些阶段可能会并行运行。我们将从一个阶段到下一个阶段的移动称为<em class="mj">触发</em>。</p><p id="5f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功的流水线的最终目标是它能够自动运行(<em class="mj">自动触发</em>)，将工作负载带入生产状态，而无需任何人工干预。这种级别的延续允许开发团队快速且低风险地发布少量代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/cd439f5809db213b2a0e85f1528d1540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*muEjz_niRZWypHNX.png"/></div></div></figure><p id="8393" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实现这种能力水平的管道，需要开发和运营团队进行高水平的投资，以在自动化管道中建立适当的测试和验证。这确保了在将代码部署到生产环境之前，代码的质量和合规性。由于这个原因，许多管道最初包括<em class="mj">手动触发器</em>——在特定阶段后停止或暂停，需要手动干预来运行测试、审查代码或在批准管道继续进入更高阶段之前接收签署。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/eb7d4cef854e49f5a53d1c60d9ca4502.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eT5zkk2GfvcMp2Am.png"/></div></div></figure><p id="7e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在严格手动触发的管道和自动触发的管道之间有一个连续体。大多数组织可能会从阶段之间的完全手动触发开始，但应该尽可能多地移除这些手动触发，以减少系统中的瓶颈。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8f4e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">管道阶段的类型</h1><p id="da08" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">通常，管道中有四个步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/5e8db2f6a6ca7be3b85247bc7a0a17a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOQ0giKKBKXg53q6Nyl0Eg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">因为管道的主要任务是通过各种<a class="ae ky" href="https://en.wikipedia.org/wiki/Systems_development_life_cycle" rel="noopener ugc nofollow" target="_blank">软件开发生命周期</a> (SDLC)环境将软件推广到生产，所以一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Minimum_viable_product" rel="noopener ugc nofollow" target="_blank"> MVP </a>(最小可行产品)管道可能只需要构建和推广步骤，由人工执行验证和符合性检查。</figcaption></figure><p id="a892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推荐的方法是创建一个MVP管道，并且在MVP管道被验证之后才添加验证和符合性步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/b2eec4c2ca03e5fb093e8eb0e9c65d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WeKlWjE5giWHSr6U.png"/></div></div></figure><h1 id="096b" class="mr ms it bd mt mu ns mw mx my nt na nb jz nu ka nd kc nv kd nf kf nw kg nh ni bi translated">构建阶段</h1><p id="6c58" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">构建步骤包括构建容器映像所需的一切。尽管版本控制对于容器映像总是有效的，但是出于合规性的原因，其他部署工件(例如jar文件)也可能需要版本控制。管道所有者必须与发布策略所有者合作，以确保符合合规性要求。</p><p id="0f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建docker映像有三种方式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/125f3eeef8321d407adf2ed6c30dcaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_8bBsroRkMOixUIWJGIJQ.png"/></div></div></figure><p id="8924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些构建类型中的每一种都会产生期望的输出，但是有不同的优点和缺点。因为构建是尖峰类型的工作负载，所以内部Docker构建非常适合容器平台，在容器平台中，容量在构建结束时被返还给池。在OpenShift中运行构建可以提高整体环境效率。然而，在OpenShift内部运行构建会产生需要清除的垃圾(参见文档中关于<a class="ae ky" href="https://docs.openshift.com/container-platform/3.9/admin_guide/garbage_collection.html" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>的章节)。</p><p id="e5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">S2I编译的主要优点是它们不需要学习Dockerfile语法。构建良好的docker形象是一项后天的技能，可能不值得花费成本来培训一个组织中的所有开发人员。另一个优点是S2I构建中的构建步骤不是以root权限运行的。另一个优点是，S2I构建中的构建步骤按照用户在基础映像中定义的方式运行。这使组织能够控制构建的权限范围，同时仍然允许开发人员完全自助。</p><p id="d5bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，因为S2I版本不是Kubernetes API的一部分，所以S2I版本不能跨基于Kubernetes的平台移植。尽管定制S2I过程是可能的，但是学习定制S2I构建会像学习如何正确构建docker映像一样耗时且复杂。</p><h2 id="2da6" class="ny ms it bd mt nz oa dn mx ob oc dp nb li od oe nd lm of og nf lq oh oi nh oj bi translated">二进制版本</h2><p id="0b7d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果构建过程已经存在，并且目标是定制它以部署到OpenShift，那么<a class="ae ky" href="https://docs.openshift.com/container-platform/3.7/dev_guide/builds/build_inputs.html#binary-source" rel="noopener ugc nofollow" target="_blank">二进制构建</a>是一个不错的选择。二进制构建使用前一步产生的工件作为OpenShift构建(docker或S2I)的输入。</p><h2 id="ae35" class="ny ms it bd mt nz oa dn mx ob oc dp nb li od oe nd lm of og nf lq oh oi nh oj bi translated">詹金斯管道建设战略</h2><p id="0c9a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">可用的OpenShift构建类型集最近增加了<a class="ae ky" href="https://docs.openshift.com/container-platform/3.7/dev_guide/builds/build_strategies.html#pipeline-strategy-options" rel="noopener ugc nofollow" target="_blank"> Jenkins管道构建策略</a>。Jenkins管道构建是一种构建策略，它包括一种通过API调用从OpenShift内部触发Jenkins构建的机制。构建逻辑驻留在Jenkins中。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0e35" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">推广阶段</h1><p id="c4de" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">升级步骤用于将解决方案(由多个组件组成)部署到SDLC环境中。在OpenShift中，环境是驻留在集群中的项目。假设有一个表示解决方案的现有OpenShift模板，则使用以下命令执行部署:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="6f61" class="ny ms it ol b gy op oq l or os">oc process &lt;template&gt; ... | oc apply -f -</span></pre><p id="12bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将使用依赖于环境的模板参数(不要与依赖于环境的属性混淆)将模板实例化到目标环境，并将其应用于OpenShift。</p><p id="a8d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ot ou ov ol b">apply</code>命令确定当前状态和新的期望状态之间是否有差异，如果有，将差异作为补丁应用到现有的API对象。因为现有的对象没有被销毁，所以相关的应用程序不会导致停机。</p><p id="87f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果此时触发器处于活动状态，则开始新的部署。一般来说，应该仔细考虑部署的自动触发器。事实上，如果我们有一个管道编制器(如Jenkins ),触发部署的逻辑应该驻留在编制器中。</p><h2 id="e79b" class="ny ms it bd mt nz oa dn mx ob oc dp nb li od oe nd lm of og nf lq oh oi nh oj bi translated">推广策略</h2><p id="a31e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">以下展示策略是可行的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/4291194ea61836cd7664b821d39fd248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lm48_kLYSCq1PB2i7zw7tA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">(*)注意:A/B测试的定义不同于您可以在<a class="ae ky" href="https://docs.openshift.com/container-platform/3.7/dev_guide/deployments/advanced_deployment_strategies.html#advanced-deployment-a-b-deployment" rel="noopener ugc nofollow" target="_blank"> OpenShift文档</a>中找到的定义。</figcaption></figure><p id="c681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署策略特征</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/dfea9efe5df5a5bb87a9c3ce465d7c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsllBw7Jl1Gcdd3GCA-GxQ.png"/></div></div></figure><h1 id="f194" class="mr ms it bd mt mu ns mw mx my nt na nb jz nu ka nd kc nv kd nf kf nw kg nh ni bi translated">验证阶段</h1><p id="3d77" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">验证步骤往往是特定于组织的，并且在一定程度上反映了该组织所采用的开发方法。</p><p id="69af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">验证步骤可以分为环境无关和环境相关。为了尽可能快地捕捉错误，应该在第一次部署之前执行与环境无关的步骤。相反，依赖于环境的步骤只能在解决方案部署后的环境中执行。</p><p id="ed14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下表提供了独立于环境和依赖于环境的验证步骤的示例。</p><p id="8785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">独立于环境的验证步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/56bdd2d237d97775e6a85404c5168225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6QE4dzhF4AhdKv5U0JxIg.png"/></div></div></figure><p id="10fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像安全扫描是由容器技术引入的新步骤。它在安全漏洞方面确保图像的质量(<a class="ae ky" href="https://en.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures" rel="noopener ugc nofollow" target="_blank"> CVEs </a> ) <br/>这个过程有两个方面:一方面我们需要扫描图像以确定其中是否有已知的漏洞，另一方面我们需要防止没有通过质量检查的图像作为容器运行。这种强制存在于流水线之外，并且可以通过<a class="ae ky" href="https://docs.openshift.com/container-platform/3.7/admin_guide/image_policy.html" rel="noopener ugc nofollow" target="_blank">图像许可控制</a>在OpenShift中进行配置。</p><p id="22e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像扫描流水线步骤的例子可以在<a class="ae ky" href="https://github.com/redhat-cop/openshift-image-signing-scanning" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="34e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖于环境的验证步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/7dea41107bb92d293d402940338d7492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hx5mbldClHuuHnImrVUq3A.png"/></div></div></figure><p id="1276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">行为驱动开发(BDD) </strong>测试是一个有价值的选项，应该用于测试web和移动应用程序。BDD测试用例是使用伪自然语言(<a class="ae ky" href="https://github.com/cucumber/cucumber/wiki/Gherkin" rel="noopener ugc nofollow" target="_blank">小黄瓜</a>)创建的，允许非技术用户快速而容易地创建它们。测试用例在测试运行时被翻译成机器指令(一个流行的例子是<a class="ae ky" href="https://cucumber.io/" rel="noopener ugc nofollow" target="_blank">黄瓜</a>)。<br/>BDD测试的一般架构如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/f952b17a577d6bb68a4d46b264352d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tUjo_79oWS83zmJ9.png"/></div></div></figure><p id="9fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述架构可以完全部署并包含在OpenShift中。浏览器/操作系统和移动设备/操作系统测试的多种组合可以并行执行。Windows容器的出现将为测试在Internet Explorer和Edge上运行的应用程序提供额外的机会。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="81ac" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">合规阶段</h1><p id="1e8c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">当管道必须遵从组织的发布过程和变更管理时，可能需要遵从步骤。</p><p id="6f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下表提供了合规步骤的示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/fed0b30a5881a1020037d2d23cc7982e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZfE-e12ba2pnOUu7Tsw8Q.png"/></div></div></figure><p id="3362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器图像签名提供了一种使断言可加密验证的方法。当图像被签名时(一个可以赋予任何意义的事实，例如，图像被批准执行)，任何人都可以验证该断言。同样，拥有断言只是流程的一部分，位于管道之外的另一部分是拥有验证和执行断言的方法。<a class="ae ky" href="https://github.com/redhat-cop/openshift-image-signing-scanning" rel="noopener ugc nofollow" target="_blank">在这里</a>您可以找到一个带有容器映像签名步骤的管道示例。</p><p id="df48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Google目前正在为部署管道开发一个更通用的断言框架(见<a class="ae ky" href="https://cloudplatform.googleblog.com/2017/10/introducing-grafeas-open-source-api-.html" rel="noopener ugc nofollow" target="_blank"> Grapheas和Kritis </a>)。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="eb94" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">管道的所有权</h1><p id="dd8a" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">确定组织中谁拥有发布过程、工具和管道是很重要的。对于传统的<a class="ae ky" href="https://en.wikipedia.org/wiki/ITIL" rel="noopener ugc nofollow" target="_blank">位于ITIL的</a>组织，通常有一个拥有发布过程的发布管理团队。该团队还可能拥有支持管道所涉及的工具，并且在某些情况下，拥有实际的管道。</p><p id="3edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有与管道相关的方面都应明确定义所有权:</p><ul class=""><li id="84b4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">发布策略和合规性规则</li><li id="2f1d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模板和其他通用的可重用管道工件</li><li id="b25b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">支持管道所需的工具</li><li id="1b46" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">独立管道</li></ul><p id="d654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敏捷组织的当前趋势是让开发团队拥有他们特定应用程序的管道。在这种情况下，开发团队负责创建和更新管道，并确保管道符合企业发布的发布管理标准。</p><p id="2961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为管道过程可以被描述为代码，开发者必须学习管道领域特定语言，否则学习曲线会很短。</p><p id="8804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更传统的组织可能不喜欢这种方法，因为他们希望在开发活动和部署任务之间有明确的职责分离。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="828f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">指标和仪表板</h1><p id="4c5f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">可以从CI/CD管道中收集大量指标，如果没有收集指标并在仪表板中提供，管道的大部分价值都将丢失。DevOps团队利用指标进行快速反馈。</p><p id="1e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有用的指标可能包括大量部署错误和总管道执行时间。</p><p id="44fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管目前没有很多工具可以提供管道指标，但一个值得研究的例子是来自<a class="ae ky" href="https://developer.capitalone.com/open-source/" rel="noopener ugc nofollow" target="_blank"> Capital One </a>的<a class="ae ky" href="https://github.com/capitalone/Hygieia" rel="noopener ugc nofollow" target="_blank">heagie ia</a>。</p><p id="7eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的屏幕截图展示了一个管道仪表板:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/d4a9aa40449f4c136b3551ac8c4ad221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AgePHSF-wYL1N9-_.jpg"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0d55" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="41f7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">本指南在OpenShift容器平台和OCI容器的上下文中描述了各种部署管道概念。不可变的基础设施和容器平台自动化不会改变持续交付的策略或目标，但是它们会影响管道的操作。可以调整管道阶段、类型和所有权的定义，以利用OpenShift行为。构建、升级、验证和合规步骤都可以受益于专为支持CICD而设计的OpenShift特性。管道指标和仪表板可以与Kubernetes集成，以提供关于部署自动化性能的有用反馈。我们建议使用这里描述的OpenShift自动化和集成可能性来增强您的部署管道，以提供快速、无摩擦、高质量的软件发布。</p></div></div>    
</body>
</html>