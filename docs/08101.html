<html>
<head>
<title>Multithreading with NodeJS is a reality!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NodeJS多线程是现实！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/multithreading-with-nodejs-is-reality-10871986b8a9?source=collection_archive---------1-----------------------#2021-04-03">https://levelup.gitconnected.com/multithreading-with-nodejs-is-reality-10871986b8a9?source=collection_archive---------1-----------------------#2021-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="56bb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Javascript以单线程语言而闻名，但是现在有办法解决这个问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c713229635f92e8d7ef67eaf391daee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5FPc6KnwmjRNiF8NeJbbA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@surene-palvie-1075224?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Surene Palvie </a>从<a class="ae ky" href="https://www.pexels.com/photo/four-green-yarns-on-chopping-board-2062061/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</figcaption></figure><p id="370a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Javascript是一种很棒的编程语言，但是长期以来，Javascript的一个主要问题是它是单线程的。</p><p id="8074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前端，我们可以访问web worker API，这是一个标准的API，允许在浏览器端使用多线程。</p><p id="0796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在后端，这是另一个故事。对于版本10。x带来了一个名为<code class="fe lv lw lx ly b">worker thread</code>的新模块，作为实验特性和版本12。x使其稳定。</p><blockquote class="lz"><p id="24c8" class="ma mb it bd mc md me mf mg mh mi lu dk translated">请记住，异步函数不是JS中的线程。这是一个常见的错误。</p></blockquote><h2 id="7d75" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">它是如何工作的？</h2><p id="dcaf" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">NodeJS团队让它变得非常简单。你需要一个用ES5 Javascript编写的入口文件(ES6+不被支持，你不能在你的工作线程直接或间接使用的文件上使用Babel/Typescript)</p><p id="7eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须从<code class="fe lv lw lx ly b">worker_threads</code>模块导入属性<code class="fe lv lw lx ly b">Worker</code>并实例化它。使用从package.json位置到条目文件的绝对路径(这里不能使用相对路径)。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="b3a9" class="no mk it bd ml np nq nr mo ns nt nu mr jz nv ka mu kc nw kd mx kf nx kg na ny bi translated">一些练习</h1><h2 id="8c17" class="mj mk it bd ml mm nz dn mo mp oa dp mr li ob mt mu lm oc mw mx lq od mz na nb bi translated">基本设置</h2><p id="2570" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">首先，确保至少在12版本上。NodeJS的x。您可以通过运行命令<code class="fe lv lw lx ly b">node -v</code>进行检查</p><p id="a39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过在一个空文件夹中运行命令<code class="fe lv lw lx ly b">npm init -y</code>来建立一个npm项目。</p><p id="d971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在一个<code class="fe lv lw lx ly b">src</code>文件夹中，创建两个文件，<code class="fe lv lw lx ly b">index.js</code>和<code class="fe lv lw lx ly b">thread-entry.js</code>这是我们将要使用的两个文件。</p><p id="47ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在您的package.json中，添加以下脚本:<br/> <code class="fe lv lw lx ly b">"start": "node ./src/index.js"</code></p><p id="bff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们只是在线程入口文件中记录一些东西，只是为了确保我们的线程被正确初始化。<br/>只需在<code class="fe lv lw lx ly b">thread-entry.js</code>文件中添加一个<code class="fe lv lw lx ly b">console.log("Hello world");</code>。</p><p id="8c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们开始我们的工人。请记住，我们必须只与ES5代码。所以这里没有进口，只有要求！</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="4b6d" class="mj mk it ly b gy oi oj l ok ol">// index.js<br/>const { Worker } = require("worker_threads");</span><span id="18ee" class="mj mk it ly b gy om oj l ok ol">(function () {<br/>  new Worker("./src/thread-entry.js")<br/>})()</span></pre><p id="326e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在从<code class="fe lv lw lx ly b">worker_threads</code>导入<code class="fe lv lw lx ly b">Worker</code>，它是一个类。</p><p id="b051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建一个自动执行的函数，该函数实例化Worker并给出线程条目文件的路径作为参数。</p><blockquote class="on oo op"><p id="82ca" class="kz la oq lb b lc ld ju le lf lg jx lh or lj lk ll os ln lo lp ot lr ls lt lu im bi translated">注意我们是如何从项目的根开始的，尽管文件就在索引旁边。如果你尝试键入<code class="fe lv lw lx ly b">./thread-entry.js</code>，你的程序将不会运行。</p></blockquote><p id="2f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">npm start</code>运行你的程序，如果一切正常，你应该会在控制台上看到<code class="fe lv lw lx ly b">Hello world</code>！</p><h2 id="4a4d" class="mj mk it bd ml mm nz dn mo mp oa dp mr li ob mt mu lm oc mw mx lq od mz na nb bi translated">处理线程退出</h2><p id="3d19" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当运行一个线程时，父线程需要知道线程什么时候完成了它的工作。为此，我们将向worker实例添加一个处理程序。</p><p id="1575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们编辑我们的<code class="fe lv lw lx ly b">index.js</code>文件，我们将让我们的函数返回一个承诺，并在线程关闭时解决它。</p><p id="6aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，nodejs不会等待这个承诺得到解决，而是退出。我们必须建立一个运行的函数，直到这个承诺实现</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="083e" class="mj mk it ly b gy oi oj l ok ol">const { Worker } = require("worker_threads");<br/><br/>let canRun = true;<br/><br/>(function () {<br/>  return new <strong class="ly iu"><em class="oq">Promise</em></strong>((resolve) =&gt; {<br/>    const worker = new Worker("./src/thread-entry.js");<br/>    worker.on("exit", () =&gt; {<br/>      <strong class="ly iu"><em class="oq">console</em></strong>.log("Closing");<br/>      resolve()<br/>    });<br/>  })<br/>})().then(() =&gt; {<br/>  canRun = false;<br/>})<br/><br/>function infiniteLoop() {<br/>  <strong class="ly iu"><em class="oq">setTimeout</em></strong>(() =&gt; {<br/>    if (canRun) {<br/>      infiniteLoop();<br/>    }<br/>  }, 1000)<br/>}<br/><br/>infiniteLoop();</span></pre><p id="5d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始了。如您所见，我们编辑了函数，现在返回一个承诺。然后，我们在close消息上添加一个事件监听器，直接解析这个承诺。</p><p id="75bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦承诺完成，我们就将变量<code class="fe lv lw lx ly b">canRun</code>设置为false，这样无限循环就停止了。</p><p id="fefa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于无限循环，一个简单的<code class="fe lv lw lx ly b">setTimeout</code>递归调用相同的函数就可以完成这项工作！</p><p id="f963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在线程方面，我们必须从<code class="fe lv lw lx ly b">worker_thread</code>包中导入<code class="fe lv lw lx ly b">parentPort</code>。这使我们能够与父母沟通，并向其发送消息。</p><p id="8850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们只是关闭线程并通知父线程，以便它可以解决承诺。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="1d12" class="mj mk it ly b gy oi oj l ok ol">// thread-entry.js<br/>const {<strong class="ly iu"><em class="oq">parentPort</em></strong>} = require("worker_threads");<br/><br/><br/><strong class="ly iu"><em class="oq">console</em></strong>.log("Hello world");<br/><br/><strong class="ly iu"><em class="oq">parentPort</em></strong>.close();</span></pre><p id="bc19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切正常，运行程序后，您的控制台将显示</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="d65a" class="mj mk it ly b gy oi oj l ok ol">Hello world<br/>Closing</span></pre><p id="ee56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的程序也应该关闭了！</p><h2 id="af0c" class="mj mk it bd ml mm nz dn mo mp oa dp mr li ob mt mu lm oc mw mx lq od mz na nb bi translated">将消息发回给家长</h2><p id="bba3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">向父节点发送消息允许您在处理完数据后将数据发送回父节点。尽管请记住这些数据是深度复制的，因此，您需要考虑是否值得使用线程！</p><p id="e895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将消息发送回父对象，我们将使用来自同一个<code class="fe lv lw lx ly b">parentPort</code>对象的函数<code class="fe lv lw lx ly b">postMessage</code>。</p><p id="40d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们在worker对象上添加一个新的处理程序。将这段代码添加到实例化工人的承诺中</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="4dc7" class="mj mk it ly b gy oi oj l ok ol">// index.js</span><span id="6d8d" class="mj mk it ly b gy om oj l ok ol">worker.on("message", (value) =&gt; {<br/>  <strong class="ly iu"><em class="oq">console</em></strong>.log("message received: ", value);<br/>})</span></pre><p id="66b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个句柄将打印接收到的值。</p><p id="d4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在我们的<code class="fe lv lw lx ly b">thread-entry.js</code>中添加下面一行</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="4564" class="mj mk it ly b gy oi oj l ok ol"><strong class="ly iu"><em class="oq">parentPort</em></strong>.postMessage("Hello from the other side")</span></pre><p id="298a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行您的程序，这一新行将出现在您的控制台中</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="4141" class="mj mk it ly b gy oi oj l ok ol">message received:  Hello from the other side</span></pre><p id="7d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始了。我们收到了来自线程的消息！</p><h2 id="b5bb" class="mj mk it bd ml mm nz dn mo mp oa dp mr li ob mt mu lm oc mw mx lq od mz na nb bi translated">运行多个线程</h2><p id="6db4" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">当然，一个线程本身是没有意义的，你要同时运行多个线程！我们要做的是在<code class="fe lv lw lx ly b">index.js</code>文件中编辑更多的主函数。这个函数将访问大量线程并实例化所有线程。然后，我们将等待他们完成之前，完成该计划。</p><p id="c757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的新index.js文件现在看起来像这样</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="5c7c" class="mj mk it ly b gy oi oj l ok ol">//index.js</span><span id="da78" class="mj mk it ly b gy om oj l ok ol">// imports and canRun</span><span id="99a9" class="mj mk it ly b gy om oj l ok ol">const THREADS_AMOUNT = 4;<br/>(function () {<br/>  // Array of promises<br/>  const promises = [];<br/>  for (let idx = 0; idx &lt; THREADS_AMOUNT; idx += 1) {<br/>    // Add promise in the array of promises<br/>    promises.push(new <strong class="ly iu"><em class="oq">Promise</em></strong>((resolve) =&gt; {<br/>      const worker = new Worker("./src/thread-entry.js");<br/>      worker.on("exit", () =&gt; {<br/>        <strong class="ly iu"><em class="oq">console</em></strong>.log("Closing ", idx);<br/>        resolve()<br/>      });<br/>      worker.on("message", (value) =&gt; {<br/>        <strong class="ly iu"><em class="oq">console</em></strong>.log(`message received from ${idx}: ${value}`);<br/>      })<br/>    }))<br/>  }<br/>  // Handle the resolution of all promises<br/>  return <strong class="ly iu"><em class="oq">Promise</em></strong>.all(promises);<br/>})().then(() =&gt; {<br/>  canRun = false;<br/>})</span><span id="bdce" class="mj mk it ly b gy om oj l ok ol">// infinite loop</span></pre><p id="831c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们将实例化4个线程。我们还编辑了日志，以便知道哪些线程发送了哪些消息。</p><p id="4ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，当你运行程序的时候，你将会有日志告诉你哪些线程是相关的。此外，顺序可能有所不同。这是完全正常的，证明了它是并行运行的(如果顺序没问题，再次运行您的程序，您最终会看到顺序发生了变化)</p><h2 id="d62e" class="mj mk it bd ml mm nz dn mo mp oa dp mr li ob mt mu lm oc mw mx lq od mz na nb bi translated">向线程发送参数</h2><p id="5541" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">首先，Javascript线程不像在其他编程语言如C、C++或Java(仅引用它们)上那样工作，因为在这里并发不是一件事情。你要传递给线程的参数，将会是一个深层拷贝。不需要担心访问这些参数！但是，在JS中深度复制对象也是很耗费资源的，永远不要忘记这一点，想想它的价值。</p><p id="238e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在线程中发送参数超级简单！你所要做的就是使用Worker构造函数的第二个参数并填充一个名为<code class="fe lv lw lx ly b">workerData</code>的对象</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="795f" class="mj mk it ly b gy oi oj l ok ol">const worker = new Worker("./src/thread-entry.js", {<br/>  workerData: {<br/>    workerId: idx<br/>  }<br/>});</span></pre><p id="90a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的worker的新实例现在应该看起来像这样。我们作为参数workerId发送，这个Id将是for循环的索引。</p><p id="4a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在线程端，我们将获取这个id，并通过消息将其发送回父线程。为此，我们从<code class="fe lv lw lx ly b">worker_threads</code>包中导入对象<code class="fe lv lw lx ly b">workerData</code>。<code class="fe lv lw lx ly b">workerData</code>将会是与你之前在<code class="fe lv lw lx ly b">index.js</code> <br/>中发送的对象完全相同的对象。我们只需要从它那里获得workerId并编辑postMessage来发送Id(我们已经有足够的console.log)</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="1e4c" class="mj mk it ly b gy oi oj l ok ol">// thread-entry.js</span><span id="3d0c" class="mj mk it ly b gy om oj l ok ol">const {<strong class="ly iu"><em class="oq">parentPort</em></strong>, <strong class="ly iu"><em class="oq">workerData</em></strong>} = require("worker_threads");<br/><br/><strong class="ly iu"><em class="oq">console</em></strong>.log("Hello world");<br/><br/><strong class="ly iu"><em class="oq">parentPort</em></strong>.postMessage(`ThreadId: ${<strong class="ly iu"><em class="oq">workerData</em></strong>.workerId}`)<br/><br/><strong class="ly iu"><em class="oq">parentPort</em></strong>.close();</span></pre><p id="9cea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是<code class="fe lv lw lx ly b">thread-entry.js</code>文件的最终外观。现在，如果您启动您的程序，您将在控制台中看到一些变化。还要确保workerId对应于idx。</p><h1 id="6f1e" class="no mk it bd ml np ou nr mo ns ov nu mr jz ow ka mu kc ox kd mx kf oy kg na ny bi translated">小心工作线程</h1><p id="f1dd" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Worker threads是一个很好的工具，但是请记住NodeJS(和V8 VM)也在做一些多线程和优化工作。始终对您的代码进行基准测试，以确保最佳实践。</p><p id="5858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线程也很难维护，这也是实现它之前要考虑的事情。你的代码比以前快了400毫秒，但是值得吗？</p><p id="688c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个技术选择都必须在一些概念验证和基准测试之后完成，以确保您的方法正确！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="3a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢读这篇文章，就像我喜欢写它一样！</p><p id="aa8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，你可以访问我的github查看最终代码。</p><p id="8a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看看多线程提高NodeJS执行速度的例子，你可以看看<a class="ae ky" href="https://github.com/psyycker/gameOfLifeGenerator" rel="noopener ugc nofollow" target="_blank">这个报告</a>。</p><p id="687e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p><p id="9b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">雷米</p></div></div>    
</body>
</html>