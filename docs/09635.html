<html>
<head>
<title>Explain by Example: Object-Oriented Programming (OOP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">举例说明:面向对象编程(OOP)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/explain-by-example-oop-24fe5d6c978?source=collection_archive---------1-----------------------#2021-08-30">https://levelup.gitconnected.com/explain-by-example-oop-24fe5d6c978?source=collection_archive---------1-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a252" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我在大学的时候，我很少被教授面向对象编程的概念。我希望在我的Java课程中向我介绍OOP时，我有<a class="ae ko" href="https://www.freecodecamp.org/news/object-oriented-programming-concepts-21bb035f7260/" rel="noopener ugc nofollow" target="_blank">这样的解释</a>。我从未真正理解的一件事是为什么OOP很重要。我的代码可以工作，为什么我要修改它来适应这种OOP设计呢？</p><p id="7714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案很简单:可重用性、简单性和安全性。我以为是因为程序员想成为<em class="kp">看中</em>(在某些方面，这是真的)。因此，与其告诉你<strong class="js iu"> <em class="kp">什么是</em> </strong> OOP，我将从<strong class="js iu"> <em class="kp">为什么</em> </strong>开始，因为我认为它提供了一个更有说服力的论据，说明为什么我们应该在OOP设计中编写代码。</p><p id="7302" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，为什么要在OOP设计中编写代码呢？</p><p id="d89f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我刚才提到了可重用性，所以让我们看一个简单的flower例子，看看为什么可重用性很重要。</p><p id="866f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">人们经常问我如何制作图纸，老实说，我用的是一种更高级的画板，叫做微软白板，这通常是设计过程。</p><p id="6d20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将从一个组件一个组件地构建我的花开始:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/2c2e50e27bd2dab626e4e7abf78ae5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Ol3j6CHV6fHlToxjsNUaw.png"/></div></div></figure><p id="1eba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么要以这种一个组件一个组件的方式构建我的花？</p><p id="2338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这允许我重用组件。让我们想象一下，我想要构建一朵不同颜色的花，我只需要改变一些组件的颜色属性，然后重用其余的组件来构建一朵不同颜色的花。所以可重用性是关键。</p><p id="9838" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">另一个是什么？</strong></p><p id="9cf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我也提到了简单。通过将它分解成组件，我可以在不影响其他组件的情况下维护我的花的组件。想象一下，如果我把这朵花粘在学校的练习本上。现在，如果我想要我的花的另一个副本，我将不得不从我的练习本上剪下它，如果任何人以前曾经试图变得狡猾，就会知道，剪下比建造困难得多。同样的逻辑也适用于软件代码，你可以剪切和复制代码片段，但这通常是混乱的，需要更多的时间，并且你可能最终得到难以定制或修改的副本。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lc"><img src="../Images/9f50d515f88b7b26f16102925177d130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8MM4Od2-cjpN2b9-yaXkrw.png"/></div></div></figure><p id="9781" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以想象一下，你可以一个组件一个组件地构建你的代码，并在进行过程中进行定制，而不是剪切和复制。你可能最终得到一个全新的软件，同时重用你或其他人过去做过的大量工作。</p><p id="6ac5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是OOP背后的思想。像对待物体一样对待一切事物(或者我到目前为止一直称之为“组件”)，并以这样一种方式编写程序，即这些物体可以相互作用并在彼此之上构建，就像使用<a class="ae ko" href="https://www.lego.com/" rel="noopener ugc nofollow" target="_blank"> Lego </a>建造房屋和城市一样。</p><p id="90a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先你用模板定义这些对象，称为“类”。一个类就像是你的对象的蓝图。当你想创建一个对象时，你可以使用这个类模板，它概括了你构建这个对象所需要的一切，你只需要简单地说，“去为我创建这个对象”。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ld"><img src="../Images/e588eb6601340f13ffce730c3ddd8c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlMyW0awaHtvMiTv2D8w1w.png"/></div></div></figure><p id="a23e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，每次我们通过flower类模板实例化一个Flower对象时(这是一个时髦的说法，意思是“创建一个实例”)，我们都有一个Flower对象，它由一定数量的花瓣、叶子、茎干组成，并且能够让我们的花变得快乐或悲伤。</p><p id="a90a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们的Flower类可能如下所示:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi le"><img src="../Images/49ff97f1dea87ec726ac41d48a534177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmLoVuXfc5_QIWel6QG3qA.png"/></div></div></figure><p id="b72d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在花瓣、叶子、茎和情感就是我们在OOP中所说的属性。你可以把它想象成默认值。你可以使用我马上要谈到的方法来改变这些缺省值，但是让我们来讨论为什么属性是重要的。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lf"><img src="../Images/3fb198c0abe3f03a73ab3be0f2ca6287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UYKfvWbyANlFNpUsNpUDg.png"/></div></div></figure><p id="6415" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么属性很重要？</strong></p><p id="eb0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">属性允许我们定义花对象的外观。如果我对你说“去做一朵花吧”，你大概会问我“什么样的花？多少花瓣。什么颜色？你想要多大的？”</p><p id="595d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我给你一个带有一些属性的flower类，这将为你我节省一些问答时间，因此OOP鼓励代码的简单性。</p><p id="b568" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">你也提到了方法，它们是什么？</strong></p><p id="5cdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不喜欢我在flower类属性中给你的默认值怎么办。假设你想要一朵叶子多花瓣少的花。你会如何改变？</p><p id="73ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是方法(我经常称之为“类函数”)的用武之地。方法允许您修改所实例化的类对象的功能或行为。因此，如果您想改变flower对象的情感，您可以调用happy()方法或sad()方法。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lg"><img src="../Images/694abf209aa02dc805015a801588652a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p1WG_RgchlNtxmZgzrZYlQ.png"/></div></div></figure><p id="23d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些happy()和sad()方法是如何工作的？</p><p id="905a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我将要介绍的OOP的首要原则之一，即'<a class="ae ko" href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)" rel="noopener ugc nofollow" target="_blank">抽象</a>。抽象可能是我在大学时最喜欢听到的短语之一，那时教授会告诉我们，“考试时你不需要知道这些。”这是我<strong class="js iu">一直</strong>记下的事情。OOP中的抽象也是如此。抽象告诉我们，“嘿，你不需要知道这个方法是如何在幕后实现的。你只需要知道，如果你调用这个方法，你应该得到它承诺要做的事情。”在这种情况下，如果我们调用happy()方法，我们可以让我们的flower对象开心。如果我们调用sad()方法，我们可以使我们的花对象悲伤。</p><p id="4f03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，到目前为止，我们的flower类不允许我们修改花瓣、叶子或茎的数量，所以让我们在我们的类中添加一些方法来允许我们这样做。我们将添加一个setPetals()方法。这允许我们封装我们的属性。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lh"><img src="../Images/c677bf0c519292d67a0ccc32e72df426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pwIK9zEXsmGZlrwqDp3OQ.png"/></div></div></figure><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi li"><img src="../Images/34444224cbb78bdcbb34d8e56298fd83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_hNDTzDbGUYs6_RceOeaw.png"/></div></div></figure><p id="4ff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">等等，封装？</strong></p><p id="66f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">封装是OOP的另一个原则。有时，我们可能希望对某些信息保密。例如，我们可能希望允许花对象的花瓣数量被更新，但是我们不想向任何人公开该信息。这个花的例子可能不是这里的最佳用例，所以让我们想一个不同的例子。</p><p id="73d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我在大学时，我是助教，这意味着我必须批改作业和考试。现在，对于那些曾经不幸得不得不批改成堆的作业和考试的人来说，你会知道“这难以辨认的字迹想表达什么？”以及“该不该给这个学生加分？”。作业和考试需要交叉标记，以尽量减少这样的偏差。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lj"><img src="../Images/226f02f10e3839046182526bc84bb344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COsGbX5IIfSlIUv1GuSmAw.png"/></div></div></figure><p id="7386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果我们要编写一些软件代码来允许我们的助教将他们的标记和反馈提交到系统中，这就是我们需要考虑封装的地方。该系统的一个要求是，“我们希望允许我们的助教提交他们的反馈，但不要查看其他助教的反馈，因为这样我们的学生将得到公平的评价和分数。”</p><p id="77a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以声明一个私有属性“score”和“feedback ”,并且只允许通过类中的“updateScore()”和“updateFeedback()”方法更新这些属性。没有方法允许助教访问其他助教的分数和反馈，这可能会影响他们的判断和反馈评估。</p><p id="1c53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您刚刚了解了为什么封装很重要。有时，我们希望在我们的类中保持某些信息的私密性，只允许访问可以公开的内容。这是一个支持OOP如何在代码设计中鼓励安全性的原则。</p><p id="11d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不是种花人，但即使是我也知道有不同种类的花，如“向日葵”、“雏菊”、“兰花”、“百合”、“罂粟”等等。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lk"><img src="../Images/6718798ca34ece90c42f860fc3bfd3b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIr3C6j3-Z6XMz5VRN-tpg.png"/></div></div></figure><p id="c462" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在这种情况下，我们的Flower类有点过于通用，无法创建任何特定类型的花，这就是为什么我要在OOP中引入第三个原则，称为'<a class="ae ko" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">继承</a>'来克服这个问题。</p><p id="c085" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继承允许我们定义类之间的父子关系。这意味着您可以扩展flower类(它是一个超类)并创建Flower的子类型(它是一个子类)。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ll"><img src="../Images/d7f619e522a5646b2b3f03ba0086a91f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cic6jhsFqhvZMqiH7CwwHg.png"/></div></div></figure><p id="0206" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么继承？</strong></p><p id="fd10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继承允许代码重用。例如，雏菊也有花瓣、茎和叶，就像任何其他普通的花一样，所以我们可以从Flower类继承所有这些属性和方法，而不是在Daisy类中重新定义所有这些属性和方法。除此之外，雏菊还有一些特殊的特征，例如，它们通常很小，有很多花瓣，本质上是白色的，等等。我们可以在Daisy类中指定所有这些细节。</p><p id="3768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里要注意的另一个重要概念是，您可以重写子类中的方法或重载同一类中的方法。这触及了我将要讨论的OOP的最后一个原则，叫做“<a class="ae ko" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">多态性</a>”。</p><p id="b30b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很长一段时间，我从来没有真正理解继承和多态之间的区别，但归结到基础，继承允许你共享特征和行为，多态允许你改变或修改共享的特征和行为。</p><p id="3b92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举例。我们了解到，我们可以创建一个Daisy子类来表示更具体的Flower类。我们的Daisy类继承了我们的Flower类中定义的所有特征，但是如果我们想要改变一些特征呢？</p><p id="9731" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在前面的Flower类中，我们说过将有一个“setPetals()”方法，它允许您确定Flower对象中花瓣的数量。如果一朵标准的花只有5片花瓣，而一朵雏菊花却有20片花瓣呢？</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lm"><img src="../Images/1c1a94360190506010233ce671e856f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05MvOX0xEbsDJndR13yiyw.png"/></div></div></figure><p id="ecc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们可以用Daisy类中的“setPetals()”方法覆盖Flower类中的“setPetals()”方法。</p><p id="3b2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，当我们实例化Daisy对象并调用' setPetals()'时，我们将把花瓣数设置为20而不是5。</p><p id="b04d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多态的另一种工作方式是重载同一个类中的方法。例如，我们可以通过重载Flower类中的一些方法，在Flower类中创建不同类型的花。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ln"><img src="../Images/cf856697f25b4b95990b9f0ed4940d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kg-78h_vxbBp2t9pbaonQg.png"/></div></div></figure><p id="0c33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能想知道(因为我确实想知道)，为什么您应该用一种方法而不是另一种方法进行变形呢？</p><p id="ec52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现的这篇<a class="ae ko" href="https://hackernoon.com/overloading-vs-overriding-in-c-nn1331h4" rel="noopener ugc nofollow" target="_blank">文章</a>给出了一个使用计算器的很好的例子，我打算偷一个，所以不再有花的例子。</p><p id="37dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么超载？</strong></p><p id="67ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重载也称为编译时多态性。基本上，这意味着编译器会在编译时决定使用哪种方法。</p><p id="8d8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设你在一个计算器类中有3个方法。这些方法让我们可以把一些数字加在一起。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi lo"><img src="../Images/ae88fe5726d1c94f34ffa386c776f874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThzhcFoGXzESMbqSjNCikQ.png"/></div></div></figure><ol class=""><li id="ac07" class="lp lq it js b jt ju jx jy kb lr kf ls kj lt kn lu lv lw lx bi translated"><strong class="js iu"> int <em class="kp"> sum </em> (int <em class="kp"> x </em>，int <em class="kp"> y </em> ) </strong></li></ol><p id="6548" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个sum方法接受两个参数，x和y，它们都是整数类型。返回值也是一个<a class="ae ko" href="https://en.wikipedia.org/wiki/Integer_(computer_science)" rel="noopener ugc nofollow" target="_blank">整数类型</a>。</p><p id="32cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果我们称之为:计算器()。sum(2，2)。我们拿回4美元。</p><p id="b35d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2 <strong class="js iu">。double<em class="kp">sum</em>(double<em class="kp">x</em>，double <em class="kp"> y </em> ) </strong></p><p id="4372" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个sum方法再次接受两个参数，x和y，但是这一次，它们都是Double类型。返回值也是<a class="ae ko" href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" rel="noopener ugc nofollow" target="_blank">双型</a>。</p><p id="f5c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们调用:计算器()。sum(2.0，2.0)。我们拿回4.0。</p><p id="74b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.<strong class="js iu">double<em class="kp">sum</em>(int<em class="kp">x</em>，double <em class="kp"> y </em> ) </strong></p><p id="9266" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三个sum方法再次接受两个参数，x和y，但这次它是一个整数类型和一个双精度类型。结果值以双精度类型返回。</p><p id="df84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们调用:计算器()。sum(2，2.0)。我们拿回4.0。</p><p id="168f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重载是简单性的一个很好的证明。我们已经简化了类方法，使用相同的名称“sum ”,它可以接受不同类型(通常是不同数量)的参数。在编译时，根据传递给方法的参数类型，编译器决定是否执行“sum”方法1、2或3。</p><p id="b277" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么要压倒一切？</strong></p><p id="c28d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重写也称为运行时多态性。还记得我们之前谈到的继承的概念吗，关于类的整个“父子”关系。大多数父母都知道，并不是所有告诉孩子的事情都会得到孩子的同意。OOP中的超类和子类也是如此。子类(子类)不一定与超类(父类)中的所有东西都一致。在这种情况下，他们有能力覆盖某些方法，同时重用他们同意的所有其他方法。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ly"><img src="../Images/1223c03dd800a15e4c1addae201b74fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3Kq-keDq2Z0torMvS15yA.png"/></div></div></figure><p id="fe4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次，我们可以通过用另一个名为“Math”的类扩展Calculator类来添加更多的“sum”方法。Math类将继承Calculator类中定义的所有方法，并用自己的实现覆盖“sum”方法。也许，我们希望我们的数学计算器能够计算更复杂的东西，比如一个数学方程，所以如果我们调用:Math()。sum("2+2+0 ")，结果我们得到“4”。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="2be9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你做到了。</p><p id="93f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你刚刚学习了对象、类、属性、方法、抽象、封装、继承和多态。最重要的是，我希望你理解OOP设计中编码背后的<em class="kp"> why </em>。</p><p id="a5fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和往常一样，我喜欢在博客文章的结尾大声疾呼。第一个大声喊出来的是在OOP上通读<a class="ae ko" href="https://www.educative.io/blog/object-oriented-programming" rel="noopener ugc nofollow" target="_blank">这篇博文</a>。第二个呼喊是非常自私的，那就是在Twitter (@mishxie)上<a class="ae ko" href="https://twitter.com/mishxie" rel="noopener ugc nofollow" target="_blank">关注我</a>我的博客公告。不要忘记<a class="ae ko" href="https://medium.com/@michelle.xie" rel="noopener">在Medium上关注我</a>，留下任何评论/反馈/批评。</p><p id="81a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次感谢阅读。希望你觉得有用:)</p></div></div>    
</body>
</html>