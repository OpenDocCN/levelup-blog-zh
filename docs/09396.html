<html>
<head>
<title>Optimizing your BigQuery tables using partitioning: Time-unit column-partitioned tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用分区优化BigQuery表:时间单位列分区表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimizing-your-bigquery-tables-using-partitioning-time-unit-column-partitioned-tables-c93cfbf3828d?source=collection_archive---------6-----------------------#2021-08-05">https://levelup.gitconnected.com/optimizing-your-bigquery-tables-using-partitioning-time-unit-column-partitioned-tables-c93cfbf3828d?source=collection_archive---------6-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="672a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尤其是在处理大数据时，当数据开始堆积时，成本可能会迅速爆炸，性能可能会迅速下降。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/9fd63a1780110b8b300c6c86363838bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s3jSewAJFPH1RAG6"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae la" href="https://www.unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="04bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">BigQuery提供了创建分区表的可能性，这有助于防止成本激增和性能下降。</p><p id="5b46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，用例必须符合分区背后的理念，尽管大多数大数据用例应该以某种方式符合这一理念。</p><p id="2d6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Google提供了三种不同的方法来划分BigQuery表:</p><p id="70fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">摄取时间</strong> —表根据它们摄取的时间进行分区。</p><p id="b67e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">时间单位列</strong> —基于时间单位列对表进行分区。这里的有效值是<em class="lb">时间戳</em>、<em class="lb">日期</em>和<em class="lb">日期时间</em>。</p><p id="0cbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">整数范围</strong> —基于整数列对表进行分区。</p><h1 id="72a7" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是时间单元划分，它是如何工作的？</h1><p id="d8ff" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">对一个表进行分区就像把这个表分成几个“子”表。这些分区表中的每一个都有其唯一的键，便于快速访问。</p><p id="1634" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当使用分区时，您可以只在一组特定的已分区表上运行查询，这样可以保存许多行，您的查询不必迭代来检查您的条件。</p><p id="6ca9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在BigQuery中使用“时间单位列”分区的工作方式如下:</p><p id="3168" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您用类型<em class="lb">时间戳</em>、<em class="lb">日期</em>或<em class="lb">日期时间</em>指定表中的一列，并指定分区的粒度。这里的有效值是每小时、每天、每月和每年。如果选择daily，所有分区表都将包含特定日期的所有行，因此您可以快速获取所有行或筛选特定日期的行，而无需遍历所有其他分区表。</p><p id="766f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您在一年(365天)内每天至少写一个条目，并且使用每日分区，那么到年底您将有365个分区表。这是因为每个分区反映一天的数据。</p><p id="e1ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的两幅图中，您可以看到一个“普通的”未分区表，紧接着是在“Day”列上有每日分区的同一个表。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/880355b61e063096e34c027311bc3759.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*B2S6qty8xS0mnY456m9qeA.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">未分区表</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/c2dfc91d46b6c02eb0a6cad349c454d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_YrusYxkSdb6SjI4cyPAQ.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">分区表</figcaption></figure><p id="a457" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，在实际使用分区时，您的查询也必须反映分区。例如，当您按日期列对表进行分区，但没有按日期进行筛选，这会导致再次进行全表扫描，这样做没有好处。</p><p id="457f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">它能在多大程度上提高性价比？</strong></p><p id="f48d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们已经讨论了基础知识，那么最关键的问题之一就是“它能在多大程度上提高成本/性能？”。没有适合所有用例的答案，但是让我们提供一个例子，您可以使用它作为计算的蓝图。</p><p id="8dc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了得到一些具体的值，让我们假设如下:</p><ul class=""><li id="ee92" class="ml mm it js b jt ju jx jy kb mn kf mo kj mp kn mq mr ms mt bi translated">您使用每日分区，因为您必须查询一天或一天范围内的数据。</li><li id="ee9d" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">您已经有了六年的数据，产生了大约2190天/分区表。</li><li id="cffe" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">您将数据均匀地分布在所有的日子里(当然，有点不太可能，但是我们必须在这里做一个假设)。</li><li id="f0b7" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">您的数据总大小为72 TB -&gt;每年12tb-&gt;每月1tb-&gt;每天约33 GB</li></ul><p id="be6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于未分区表，您的查询将始终必须进行全表扫描，导致每次查询需要处理7，2e+13字节(72 TB)的数据并进行计费。</p><p id="979c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">示例#1:在某一天运行查询</strong></p><p id="c776" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只请求一个特定日期的数据意味着查询可以直接访问所需的分区并处理这一个分区，而不必处理另一个分区2189。</p><p id="175e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面，我们假设一天/分区包含大约3，3e+10 (33 GB)的数据。这意味着我们将只处理整个数据集的大约0.046% (33 GB / 72，000 GB或1 / 2190)，导致数据使用量<strong class="js iu">减少99.954% </strong>，从而降低成本！</p><p id="86af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">示例2:运行30天范围的查询</strong></p><p id="22f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请求30天的范围类似于上面的例子，可以简化为30 / 2190 =&gt; 1.37%。尽管这比示例1中的多得多，但与全表扫描相比，它仍然在大小和成本上减少了<strong class="js iu"> 98.6% </strong>！</p><p id="1f29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">实例的实际成本:</strong></p><p id="ce43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们来看看与未分区表相比，上述示例查询的成本是多少。Google根据其官方定价文档收取每TB美元的费用，从而得出以下值。</p><p id="1aaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">未分区表:5.00美元* 72tb =<strong class="js iu">；360.00美元</strong></p><p id="9ed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例# 1:5.00美元* 0.033 TB =<strong class="js iu">；0.165美元</strong></p><p id="6654" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例2:5.00美元* 0.99 TB =<strong class="js iu">；4.95美元</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a6ae175cbe6f2689646b8673b97548e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*SUEtTF6isWxWOsTYk2Phew.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">每次查询的成本</figcaption></figure><p id="70c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">差别非常惊人，对吧？😏</p><p id="43fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，分区将提高与成本降低成比例的性能。当查询需要评估的行数减少了99%时，您可以想象它需要减少大约99%的时间来完成。</p><p id="c087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么使用分区可以节省更多资金</strong></p><p id="e258" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管上面的例子已经大大降低了成本，但当我们考虑BigQuery中的第二个成本驱动因素时，还有更多的问题。存储成本。</p><div class="na nb gp gr nc nd"><a rel="noopener  ugc nofollow" target="_blank" href="/whats-the-deal-with-google-bigquery-and-what-does-it-cost-9077c3f2fed0"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">谷歌大查询是怎么回事，它的成本是多少？</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">本文的目的是让您对BigQuery有一个大致的了解，并对它的定价因素有一些见解。</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ku nd"/></div></div></a></div><p id="4b4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如在<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/whats-the-deal-with-google-bigquery-and-what-does-it-cost-9077c3f2fed0">第一篇文章</a>中已经提到的，BigQuery有主动和长期存储的概念。虽然谷歌对长期存储只收取一半的费用，但这并没有带来任何不利。唯一的标准是至少90天没有修改表数据。当您使用分区表时，从长期存储定价的角度来看，每个分区都是单独考虑的。</p><p id="cf5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们采用上述关于数据大小(每天33 GB)和分布(平均)的假设，并检查其存储成本。此外，我们进一步假设，在过去的90天里，我们每天都添加一些数据。</p><p id="4202" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种假设导致未分区表永远不会达到长期存储状态，因为表每天都有变化。另一方面，分区表在活动存储中总是只有90个分区，其余2100个分区在长期存储中。</p><p id="96a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于主动存储，谷歌目前对美国地区(多地区)收取每GB 0.02美元的费用。</p><p id="b326" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">未分区表:每月$ 0.02 * 33 GB * 2190 =<strong class="js iu">$ 1445.40</strong></p><p id="1ae8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分区表:0.02 * 33 GB * 90天+0.01 * 33gb * 2100天= 59.40美元+693.00美元=<strong class="js iu"/>每月752.40美元</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b8790a41e24113da4daf116af54c1373.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*umw3qEPygyUE1IoxLRYIew.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">每月费用</figcaption></figure><p id="5656" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，通过分区，您不仅可以显著降低按需分析成本，还可以大幅降低存储成本。</p><h1 id="4901" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">亲自动手</h1><p id="cbb5" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">现在让我们动手做一些实际的实现，并分析查询结果。</p><div class="na nb gp gr nc nd"><a href="https://javascript.plainenglish.io/working-with-data-in-bigquery-using-node-js-4738561f5329" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">使用Node.js在BigQuery中处理数据</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">本文将介绍BigQuery的实际用法，并展示如何使用Node.js读写数据。</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nm l"><div class="ns l no np nq nm nr ku nd"/></div></div></a></div><p id="92d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们已经在<a class="ae la" href="https://javascript.plainenglish.io/working-with-data-in-bigquery-using-node-js-4738561f5329" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中处理了Node.js BigQuery项目的设置，这里就不再赘述了。我还希望在下面的代码片段中存在一个名为“bigquery”的全局初始化变量，并且BigQuery数据集是可用的。</p><p id="548e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先必须用相同的数据集创建两个表，以便将一些实际的(即使相对较小的)未分区表与已分区表进行比较。</p><p id="72c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用CSV文件中的数据创建新表格</strong></p><p id="b975" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个例子，我准备了一些包含大约72k行的CSV文件，格式如下:</p><p id="0ec8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">日期、名称、事件</p><p id="4bb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">亚当，4岁</p><p id="8130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">汤姆，2岁</p><p id="da37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">杰伊，1岁</p><p id="40ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">杰伊，3岁</p><p id="d789" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">….</p><p id="6806" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一行“日期”的类型为<em class="lb">日期时间</em>，因此格式如下:<em class="lb"> YYYY-MM-DD HH:MM:SS[。SSSSSS] </em></p><p id="2a06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际值并不那么重要；我只是确保这里提到了四个不同的日期，所以BigQuery创建了四个分区，我可以在以后相应地查询。然后，我将CSV文件命名为“dump.csv ”,并将其添加到我的脚本文件“importCSV.js”下，其内容可以在下面的代码片段中看到。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a104" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面代码片段中的' importCSV()'方法类似于您应该从<a class="ae la" href="https://javascript.plainenglish.io/working-with-data-in-bigquery-using-node-js-4738561f5329" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中了解的内容。不同之处在于，我们不是调用一些“createTable(…)”，而是引用“Table(…)”，然后通过“load(…)”方法将初始数据和一些模式定义一起加载到其中。</p><p id="809d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“importCSV”方法的“特定于分区”部分只是传递给函数的“timePartitioning”变量。</p><p id="54d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您检查对象时，脚本为该参数传入；这很简单。我们将类型定义为‘DAY ’,告诉BigQuery应该创建每日分区表。此外，通过' field '属性，我们命令BigQuery使用名为' date '的列作为分区列。你可以在这里找到“时间分割”对象<a class="ae la" href="https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#timepartitioning" rel="noopener ugc nofollow" target="_blank">的官方文档。</a></p><p id="2370" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在运行了上面的脚本并创建了两个表之后，我们现在可以运行查询并与下面的代码片段进行比较。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8d24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">脚本保持非常简单。在“runQueryWithStatistics()”中，我们运行提供的查询，然后将完成的作业传递给某个方法，该方法将作业统计信息打印到控制台。这里的关键部分是我们设置了“useQueryCache: false ”,这样BigQuery就不会在后台使用任何缓存。这一点很重要，因为我们无法比较缓存提供的指标。当然，在生产环境中运行时，您应该始终将此标志保持为“true ”(默认值)!</p><p id="e761" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“printJobStatistics()”方法甚至更简单。它或多或少只访问某些相关的属性，并将它们打印到控制台。稍后我们将讨论各个指标。</p><p id="cab3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们进一步转到“main()”方法。这里定义了用于创建查询的变量和辅助方法。“createQuery()”仅将“tableId”作为输入参数，以便为未分区和已分区的表生成相同的查询，不同之处仅在于被引用的表。</p><p id="ffcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们运行“runQueryWithStatistics()”方法。一次在' non _ partitioned _ table '-表上，一次在' partitioned _ table '-表上，并记录结果。</p><p id="430f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在下面的代码片段中看到上面脚本的输出。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="74d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">了解统计数据</strong></p><p id="ee9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了工作统计数据，我们必须相应地理解和解释它们，以验证我们的假设。</p><p id="bf1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缓存命中</strong> —这个值只告诉我们缓存没有被命中，我们可以确定我们没有收到篡改我们指标的缓存结果。</p><p id="7504" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们显式地将缓存设置为禁用，所以它应该始终为“false”。如果它看起来是“真的”，那就一定是出了问题。</p><p id="99a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">耗时</strong> —定义从开始到结束运行查询所花费的时间。</p><p id="54bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们可以看到分区表快了一点(~19%)。根据我的经验，我可以说这在我们的例子中没有意义，因为我们仍然在毫秒的范围内，并且只有大约2 MB的数据。这里，与实际查询相比，副作用占用了太多的时间。</p><p id="4609" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果查询处理时间达到几秒或几分钟，这个指标就变得非常重要。</p><p id="0a38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">已处理的分区</strong> —指示查询读取了多少个分区。对于非分区表，该值始终为0。</p><p id="246e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在分区表的输出中，我们可以看到它只读取了一个分区，因为只查询了一个特定的日期，而不是一个日期范围。</p><p id="59c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">读取的行数</strong> —查询必须读取多少行才能完成。</p><p id="eff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们已经可以看到这两种变体有很大的不同。在非分区表的情况下，我们有大约73k行，而在分区表中只有大约12k行。读取的行数已经减少了大约83.6%，反映在下面的指标“处理的字节数”中。</p><p id="8b6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">已处理的字节数</strong> —查询必须处理的字节数。</p><p id="d610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与“读取的行数”类似，我们可以看到这里的大小明显减小。非分区查询必须扫描全部约1.6 MB的数据，而分区查询只需处理约0.26 MB的数据，从而减少了约83.4%。</p><p id="ec0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">计费字节数</strong> —谷歌就此查询向你收取的字节数。</p><p id="7a82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常情况下，人们会认为“计费字节数”也会相差83%左右。但是机警的读者会注意到这些值是相同的。</p><p id="08b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这第一个意外的行为有一个相对简单的起源。在查看BigQuery 的<a class="ae la" href="https://cloud.google.com/bigquery/pricing#on-demand-pricing-details" rel="noopener ugc nofollow" target="_blank">定价详情页面时，您会发现以下报价:</a></p><p id="a877" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“…每个查询至少处理10 MB的数据。”</p><p id="33dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们在两个查询中只处理了1.6 MB和0.26 MB，Google将成本向上舍入到最少10 MB的计费字节，反映在我们的统计数据中。</p><p id="fc63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在实际数据的情况下，当您有几GB、TB甚至PB的数据时，“计费字节”会有很大不同，并与“处理字节”成比例。</p><h1 id="2d6c" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">配额分区和需要注意的常见缺陷</h1><p id="962c" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated"><strong class="js iu">分区的最大数量</strong> —在BigQuery表上使用分区，每个分区表有4，000个分区的硬性限制。</p><p id="cef5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><p id="a87f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您在表上使用每日分区时，您最多可以覆盖4，000天(10.96年)的数据。向表中写入更多天的数据将导致BigQuery方面的错误或拒绝。</p><p id="f329" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使使用每日分区不太可能很快遇到这种情况，但使用每小时分区，大约5.47个月后就会遇到这种情况。</p><p id="79ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">将数据流式传输到已分区表</strong> —当将数据流式传输到已分区表时，可以预期BigQuery会立即将数据添加到正确的分区。<a class="ae la" href="https://cloud.google.com/bigquery/streaming-data-into-bigquery#streaming_into_partitioned_tables" rel="noopener ugc nofollow" target="_blank">不幸的是，事实并非如此。</a>当数据在流缓冲区时，BigQuery首先将流数据写入名为“<em class="lb">_ _未分区__ </em>”的临时分区。目前，没有办法手动刷新这个缓冲区。因此，在一定量的未分区数据可用或一定量的时间过去后，您必须等到BigQuery自动刷新该缓冲区。谷歌没有提供任何关于上述金额的确切数字。</p><p id="d9a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使在运行BigQuery命令时:</p><p id="9b26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lb">' bq show—format = pretty JSON YOUR _ GCP _ PROJECT:DATASET _ ID。TABLE_ID </em></p><p id="6c20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以检查“streamingBuffer”对象的属性“estimatedBytes”和“estimatedRows ”,以查看流缓冲区中当前有多少字节和多少行。</p><p id="3376" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">需要分区过滤器</strong> —使用已分区表时，最好在创建已分区表时启用“Require partition filter”标志。有了这个标志，BigQuery将总是要求对试图访问表的SQL查询使用谓词过滤器。此标志有助于防止意外触发全表扫描而不是访问特定分区或一组分区的查询，这些查询会导致高成本。</p><p id="7746" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">不要“或”您的分区过滤器</strong> —有人可能认为在他的SQL语句的过滤条件中有分区列就足够了。尽管使用' OR '仍然会触发全表扫描，但它不需要分区过滤器来匹配。</p><p id="3d41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><p id="e67b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将触发全表扫描:</p><p id="4ff0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lb">WHERE(partition _ column = " 2021–01–01 "或f = "a" </em></p><p id="3c8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不会触发全表扫描:</p><p id="4e11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lb">其中(partition _ column = " 2021–01–01 "和f = "a" </em></p><p id="9f99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一个最佳实践，我总是建议隔离分区过滤条件，然后将它与您想要应用于行的实际过滤器进行“与”运算。这也有助于防止错误/昂贵的查询。</p><p id="6a40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><p id="69e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lb">WHERE partition _ column = " 2021–01–01 " AND(ALL _ THE _ OTHER _ CONDITIONS)</em></p><h1 id="4050" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">下一步是什么？</h1><p id="cfb7" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">在下面的文章中，我们将学习如何在BigQuery中创建和使用聚簇表，以进一步提高性能。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h2 id="1efd" class="oc ld it bd le od oe dn li of og dp lm kb oh oi lq kf oj ok lu kj ol om ly on bi translated">你想联系吗？</h2><p id="6350" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">如果你想联系我，请在LinkedIn上联系我。</p><p id="c598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，可以随意查看<a class="ae la" href="https://medium.com/@mr-pascal/my-book-recommendations-4b9f73bf961b" rel="noopener">我的书籍推荐</a>📚。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt nd"><a href="https://mr-pascal.medium.com/my-book-recommendations-4b9f73bf961b" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">我的书籍推荐</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">在接下来的章节中，你可以找到我对所有日常生活话题的书籍推荐，它们对我帮助很大。</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="nm l"><div class="oo l no np nq nm nr ku nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://mr-pascal.medium.com/membership" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">通过我的推荐链接加入Medium—Pascal Zwikirsch</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="nm l"><div class="op l no np nq nm nr ku nd"/></div></div></a></div></div></div>    
</body>
</html>