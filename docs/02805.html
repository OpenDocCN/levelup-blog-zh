<html>
<head>
<title>Solving a Sudoku Puzzle using Deep Learning and Backtracking Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习和回溯算法解决数独难题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solving-a-sudoku-puzzle-using-deep-learning-and-backtracking-algorithm-c6cef475ae3?source=collection_archive---------10-----------------------#2020-04-05">https://levelup.gitconnected.com/solving-a-sudoku-puzzle-using-deep-learning-and-backtracking-algorithm-c6cef475ae3?source=collection_archive---------10-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/95fea0ca09e870b200e6334860b4e73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eeA7C8k2z5YYOAIzVTY-uQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">数独游戏</figcaption></figure><p id="8c89" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">早上八点零五分。警报嗡嗡响。向窗外望去，天不像往常那么亮，前一天晚上一定下雨了。床很暖和。</p><p id="ab1c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是我起床了。我勇敢地面对清晨，像冠军一样站在冰冷的地板上。</p><p id="24e9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为什么？</p><p id="4f85" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为我很兴奋。</p><p id="82f9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">很高兴今天能和大家分享一些特别的东西。</p><p id="2a0a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在过去的几周里，我一直在做这个惊人的项目，现在我想公布并给出一个完整的分析。</p><h1 id="1882" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">简要概述</h1><p id="2581" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">这个项目是一个计算机视觉应用程序，它使用<strong class="kh iu">深度学习</strong>、<em class="mg">解决了一个9x9数独难题，深度学习是更广泛的机器学习家族的一部分，也是人工智能</em>和<strong class="kh iu">回溯算法</strong>的子集，后者是一种用于解决难题的流行递归算法。</p><p id="4664" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这个项目中有两种主要的方法来解决这个难题；上传难题的图像或通过计算机的网络摄像头解决它。</p><p id="0b90" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我将带你经历解决这个难题的5个主要阶段。</p><p id="d6a1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我假设每个人都知道什么是数独以及如何玩数独，否则检查这个<a class="ae mh" href="https://sudoku.com/how-to-play/sudoku-rules-for-complete-beginners/" rel="noopener ugc nofollow" target="_blank">链接</a>。应用程序的结果如下所示。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/075fe16a5e8bfb39a57fbb1e1177ca53.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*RAkcVt67u6FbkwOXN-YoZA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">解决前的数独难题</figcaption></figure><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/e0bbf89265d7ed8bcb9b770aa3932bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*0Ua1xQiTMwcWvPK9exGujw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">数独解谜后</figcaption></figure><h1 id="7ff7" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">快速入门</h1><h2 id="34e8" class="mo le it bd lf mp mq dn lj mr ms dp ln kq mt mu lr ku mv mw lv ky mx my lz mz bi translated">阶段A:图像预处理</h2><p id="40c5" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">让我们从最开始说起，语言选择。Python是这种情况下选择的语言，因为它的简单性、可移植性和OpenCV的创造性，尽管它的运行时间比C/C++慢。项目中使用的一些重要库包括:</p><blockquote class="na"><p id="bd8b" class="nb nc it bd nd ne nf ng nh ni nj lc dk translated">OpenCV、Tensorflow、Keras、Pillow、Numpy和Matplotlib</p></blockquote><p id="b050" class="pw-post-body-paragraph kf kg it kh b ki nk kk kl km nl ko kp kq nm ks kt ku nn kw kx ky no la lb lc im bi translated"><strong class="kh iu">读取灰度图像</strong></p><p id="eabe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用OpenCV的输入函数读取图像，颜色通道从3个减少到1个，以满足一些尚未使用的图像库的适当要求。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a1a0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">高斯模糊减少背景噪声</strong></p><p id="29a8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">高斯滤波器是一种低通滤波器，可以去除图像中的高频成分，即噪声。在我们的例子中，由于噪声较少，使用了(1，1)的核大小</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9586" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">逆二进制阈值</strong></p><p id="bf62" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果对应的源像素大于阈值，则将目标像素设置为零，如果源像素小于阈值，则将目标像素设置为maxValue。在这种情况下，我们的阈值是0-255范围内的180。霍夫变换库需要这种图像格式。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4e97" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">概率霍夫变换</strong></p><p id="3980" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">概率霍夫变换是霍夫变换的一种优化。它用于图像中互连为边缘的线条的稳健检测。这有助于检测数独板的网格形式。</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/1de5bc7250486e10b9f420306db0fd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*Hnh5NwaIesR69bpmfLbtLg.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">霍夫变换在数独图像上的应用</figcaption></figure><p id="787d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">透视变换</strong></p><p id="97a9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是这个阶段的一个有趣的部分，因为无论棋盘在图像中的什么位置，获得棋盘的“自上而下”的视图都是非常重要的。<code class="fe nr ns nt nu b">order_points</code>函数接受一个参数<code class="fe nr ns nt nu b">pts</code>，它是一个包含四个点的列表，指定矩形中每个点的<em class="mg"> (x，y) </em>坐标。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ba0f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe nr ns nt nu b">four_point_transform</code>函数接受要转换的图像和新点作为参数。新图像的宽度和高度分别通过计算它们的水平点和垂直点之间的最大距离来导出。我们利用<code class="fe nr ns nt nu b">cv2.getPerspectiveTransform </code>函数，它需要两个参数，<code class="fe nr ns nt nu b">rect,</code>是原始图像中4个ROI点的列表，而<code class="fe nr ns nt nu b">dst</code>是我们转换后的点的列表。函数返回<code class="fe nr ns nt nu b">M</code>，这是实际的变换矩阵。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="92ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe nr ns nt nu b">cv2.warpPerspective </code>的输出是我们的扭曲图像，这是我们自上而下的视图。</p><p id="b341" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这一过程在CamScanner应用中广泛使用，以获得要扫描的纸张的准确边角，并将其重新整形为图像的原始形状。这是用于这个项目的情况下，你的数独图像有一些背景！</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/4d7b5a7a3a8f2e05d4709d49cc5ffd02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bD9nayUvSJ0tDG_sUfspGQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">透视变换</figcaption></figure></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h2 id="d3e8" class="mo le it bd lf mp mq dn lj mr ms dp ln kq mt mu lr ku mv mw lv ky mx my lz mz bi translated">阶段B:卷积神经网络模型</h2><p id="a5bf" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">训练了Keras MNIST手写数字分类模型并用于该模型，准确率为98.7%。这是深度学习初学者非常常见的模型。要掌握它，请跟随这个<a class="ae mh" href="https://www.sitepoint.com/keras-digit-recognition-tutorial/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="b004" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最初，模型建立在来自<a class="ae mh" href="http://www.ee.surrey.ac.uk/CVSSP/demos/chars74k/" rel="noopener ugc nofollow" target="_blank"> Chars 74k数据集</a>的自定义图像上，该数据集包含来自具有4种变体(斜体、粗体和正常组合)的计算机字体的字符。在<a class="ae mh" href="https://towardsdatascience.com/a-comprehensive-hands-on-guide-to-transfer-learning-with-real-world-applications-in-deep-learning-212bf3b2f27a" rel="noopener" target="_blank">迁移学习的帮助下，</a>我能够获得91%的准确率，这对于预测谜题中的数字来说还不够准确。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h2 id="9fd2" class="mo le it bd lf mp mq dn lj mr ms dp ln kq mt mu lr ku mv mw lv ky mx my lz mz bi translated">阶段C:数字提取</h2><p id="a5fd" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">这是项目中最具挑战性的阶段，但我还是挺过来了。执行的第一步是编写一个函数，以二维数组的形式获取拼图中所有81个单元格的位置。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1b03" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下一步是编写一个有两个参数的函数，单元格位置和图像。使用单元格位置中的<code class="fe nr ns nt nu b">cv2.findContours</code>函数，可以定位精确的数字位置，并且模型能够预测图片的这一部分。在空单元格上，<code class="fe nr ns nt nu b">cv2.findContours</code>函数返回空位置，因此，该逻辑用于在空位置放置0。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4cdf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后一步是创建另一个函数，它接受图像作为参数。它遍历从<code class="fe nr ns nt nu b">getCellPositions</code>函数获得的单元格位置，并调用上一步中的<code class="fe nr ns nt nu b">predictDigit</code>函数对所有单元格进行预测。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h2 id="1693" class="mo le it bd lf mp mq dn lj mr ms dp ln kq mt mu lr ku mv mw lv ky mx my lz mz bi translated">阶段D:回溯</h2><blockquote class="od oe of"><p id="ae6b" class="kf kg mg kh b ki kj kk kl km kn ko kp og kr ks kt oh kv kw kx oi kz la lb lc im bi translated">回溯<strong class="kh iu"> </strong>算法是一种递归算法，它试图通过测试通向解决方案的所有可能路径来解决给定的问题，直到找到解决方案。每次测试一条路径时，如果没有找到解决方案，则该算法返回测试另一条可能的路径，依此类推，直到找到解决方案或所有路径都已测试完毕。</p></blockquote><p id="b14a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的函数solve使用了两个额外的辅助函数；<code class="fe nr ns nt nu b">valid</code> &amp; <code class="fe nr ns nt nu b">find_empty</code>采用这种算法解决谜题。为了更深入地了解回溯，您可以查看这个<a class="ae mh" href="https://www.geeksforgeeks.org/backtracking-algorithms/" rel="noopener ugc nofollow" target="_blank">链接</a>。下面显示了一个片段。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h2 id="e295" class="mo le it bd lf mp mq dn lj mr ms dp ln kq mt mu lr ku mv mw lv ky mx my lz mz bi translated">阶段E:手指放置</h2><p id="65f3" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">这是项目的最后阶段。它包括在原始图像中放置新发现的数字。一个名为<code class="fe nr ns nt nu b">detectEmptyCell</code>的函数将图像作为参数，使用轮廓方法扫描图像中的空单元格，并返回所有单元格的位置</p><p id="e6d3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样将图像作为参数的<code class="fe nr ns nt nu b">placeSudokuDigits</code>函数调用<code class="fe nr ns nt nu b">detectEmptyCell</code>函数。它遍历所有的空单元格，并将新找到的数字放在适当的位置。</p><figure class="mj mk ml mm gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="94e4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">笔记本的其余部分可以在我的Github repo <a class="ae mh" href="https://github.com/Pydare/Sudoku-Game-Solver" rel="noopener ugc nofollow" target="_blank">这里</a>找到。网络摄像头功能是在阅读实时图像时上述所有阶段的应用。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="493e" class="ld le it bd lf lg oj li lj lk ok lm ln lo ol lq lr ls om lu lv lw on ly lz ma bi translated">如何使用该应用程序</h1><p id="ab83" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">包含应用程序完整目录的repo在这个<a class="ae mh" href="https://github.com/Pydare/Sudoku-Game-Solver" rel="noopener ugc nofollow" target="_blank">链接</a>中。</p><p id="da2b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">上传</strong></p><ul class=""><li id="2813" class="oo op it kh b ki kj km kn kq oq ku or ky os lc ot ou ov ow bi translated">首先，用git克隆<a class="ae mh" href="https://github.com/Pydare/Sudoku-Game-Solver.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Pydare/Sudoku-Game-Solver.git</a>克隆存储库，并进入克隆的文件夹。</li><li id="efb7" class="oo op it kh b ki ox km oy kq oz ku pa ky pb lc ot ou ov ow bi translated">从requirements.txt文件创建一个包含所需库的虚拟环境，并激活它。</li><li id="f5cf" class="oo op it kh b ki ox km oy kq oz ku pa ky pb lc ot ou ov ow bi translated">上传一个你想解决的数独图像。一些样本图像在回购，3个主要困难(容易，中等和困难)</li><li id="9119" class="oo op it kh b ki ox km oy kq oz ku pa ky pb lc ot ou ov ow bi translated">打开sudoku-solver目录，在base.py文件中，在第二行输入图像文件的名称。</li><li id="37f3" class="oo op it kh b ki ox km oy kq oz ku pa ky pb lc ot ou ov ow bi translated">在您的终端/bash中使用python run.py解决这个难题</li></ul><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/b5e5c954b73bc2bbf052785d73ed6ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2_TdEAHbvLKr7pKSjTi0Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">求解easy.png的输出</figcaption></figure><p id="68e8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">目录里还有另外两张中难度和硬难度的数独拼图图片，也可以测试。</p><p id="01ce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">网络摄像头</strong></p><ul class=""><li id="db10" class="oo op it kh b ki kj km kn kq oq ku or ky os lc ot ou ov ow bi translated">首先，用https://github.com/Pydare/Sudoku-Game-Solver.git的git克隆<a class="ae mh" href="https://github.com/Pydare/Sudoku-Game-Solver.git" rel="noopener ugc nofollow" target="_blank">克隆仓库，并进入克隆的文件夹。</a></li><li id="41d4" class="oo op it kh b ki ox km oy kq oz ku pa ky pb lc ot ou ov ow bi translated">从requirements.txt文件创建一个包含所需库的虚拟环境，并激活它。</li><li id="3c76" class="oo op it kh b ki ox km oy kq oz ku pa ky pb lc ot ou ov ow bi translated">面对你的摄像头和拼图的图像，在你的终端输入python sudokuWebcam.py，拼图就解决了</li></ul><p id="9f2f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">笔记本文件也可以用来执行以上两种操作。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="7201" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">合作对游戏开发者是开放的，他们可能有额外的功能可以添加到适当的应用程序中。你可以通过<a class="ae mh" href="https://www.linkedin.com/in/joseph-adewumi-66ab3914b/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我。</p><p id="61f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个季节保持安全。</p></div></div>    
</body>
</html>