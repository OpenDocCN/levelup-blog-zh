<html>
<head>
<title>Building an API for encrypting files with NodeJS, TypeScript, and Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NodeJS、TypeScript和Express构建加密文件的API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-an-api-for-encrypting-files-with-nodejs-typescript-and-express-3b31480cf4b3?source=collection_archive---------0-----------------------#2020-07-07">https://levelup.gitconnected.com/building-an-api-for-encrypting-files-with-nodejs-typescript-and-express-3b31480cf4b3?source=collection_archive---------0-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5281fcd4c5f548bd1cb1735a6d9cce8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BNjWpCaq2rJoZUkP6axkqA.jpeg"/></div></div></figure><p id="66f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将建立加密用户文件的快速API。与其他文件加密服务相比，它有一些优势，用户可以选择加密算法，服务器不会保存文件，所有操作都将在内存中完成。</p><p id="b05f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用程序应该接受一个带有其他参数的文件，这些参数描述了它应该如何被加密，并且它应该能够加密\解密这个文件并将其发送回客户端。听起来不错。开始吧！</p><blockquote class="kw kx ky"><p id="743e" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">要理解这里发生的事情，您应该熟悉基本的JavaScript和TypeScript。</p></blockquote><p id="d5b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建一个项目，我们将使用“express-generator-typescript”。</p><p id="d749" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在你的终端运行<code class="fe ld le lf lg b">npx express-generator-typescript "projectName"</code>。<br/>然后通过运行<code class="fe ld le lf lg b">cd projectName</code>CD到这个项目，安装所有的包<code class="fe ld le lf lg b">npm install</code>，并在你的代码编辑器中打开这个文件夹。</p><p id="94b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在src文件夹中，您将有许多我们不需要的文件，这些文件是由脚本生成的。您可以将其中一些作为文件和导入文件删除。这是你的src文件夹的截图。如果您没有一些文件，请不要担心，我们稍后会创建它们。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/122ce5833adc595bb686ecafea46a4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*QKxnC0tQbigh8WCFUTleUw.png"/></div></figure><p id="3bb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来编辑Server.ts文件吧！转到一个文件的末尾，删除注释下面写着“提供前端内容”的代码块，但是不要碰导出。我们这样做是因为我们不会渲染任何前端。我们将只关注应用程序的后端。</p><p id="a428" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们希望根据用户的请求访问文件，所以我们还应该安装express中间件，以便能够轻松地做到这一点。这个包叫做“快速文件上传”。要安装它，运行<code class="fe ld le lf lg b">npm i express-fileupload --save</code>。然后在Server.ts中导入，并通过添加以下行使express使用它:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="89b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里做的是应用中间件。因此，当express收到请求时，它会调用fileUpload来处理请求，这样我们就可以轻松地访问文件。我们作为参数提供的对象是选项。在那里，我们规定了文件大小的限制(5MB ),并要求fileUpload在文件大小超过限制时发送403代码。如果您想了解更多选项，请访问packages <a class="ae lo" href="https://github.com/richardgirges/express-fileupload" rel="noopener ugc nofollow" target="_blank"> GitHub页面</a>。</p><p id="7e75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们为我们的应用程序创建路线。转到src/routes/index.ts，它应该是这样的:</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="5a7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">删除第8行并在第2行导入，因为我们的项目中不需要用户，而是添加2个新的POST路由。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="ce10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在我们可以通过这条路线<code class="fe ld le lf lg b">/api/encrypt</code>和<code class="fe ld le lf lg b">/api/decrypt</code>访问这些路线。为什么会有<code class="fe ld le lf lg b">api</code>？因为我们刚刚创建了子路由，并且通过这一行<code class="fe ld le lf lg b">app.use(‘/api’, BaseRouter)</code>将它们添加到<code class="fe ld le lf lg b">api</code>下的Server.ts文件中</p><p id="cbee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在src中创建一个utils文件夹，并在那里创建index.ts文件。在这里，我们将存储我们所有的助手方法。我们将创建的第一种方法将用于加密。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="ee42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回顾一下这个要点。首先，我们导入了crypto，这个包默认包含在Node中，所以你不需要安装任何东西。在接下来的2行中，我们为TypeScript导入了类型，在最后一次导入中，我们导入了尚不存在的文件。但是我们将很快创建它，它将保存一个具有所有可用加密算法的对象。</p><p id="2843" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们为我们的函数创建了类型。我想那里的一切都很明显。我们的函数将接受文件，解密值(如果它是假的，我们将加密文件，否则解密)，然后一个有3个密钥的主体。Algo将包含一个我们将用于加密的算法名称，key和salt将包含用于加密\解密文件的值。</p><blockquote class="kw kx ky"><p id="7f9c" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">你可能知道什么是密钥，它基本上是一个文件的密码。<strong class="ka ir">但是盐是什么？</strong>它的另一个名字是<strong class="ka ir">初始化向量</strong>。它是添加到文件开头的一组随机字节。因此，如果有人破解了你的加密文件，他就不能解密其他文件，因为盐是不同的。至少应该是。因此，请确保每次加密文件时都提供不同的salt。密钥可能是相同的。</p></blockquote><p id="6808" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续讨论函数本身。<code class="fe ld le lf lg b">decrypt</code>参数默认为假，<code class="fe ld le lf lg b">algo</code>默认包含一个“aes-256-ctr”字符串，它是算法的名称。该算法需要32位密钥和16位初始化向量。所以对于key和salt，我们生成随机字节，并将其转换为十六进制字符串(16字节转换为十六进制将成为32位字符串)。该函数将返回一个缓冲区。</p><p id="96ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在函数中，我们首先决定我们应该做什么，加密还是解密。然后使用参数创建新的加密/解密实例，然后通过连接<code class="fe ld le lf lg b">cipher.update()</code>和<code class="fe ld le lf lg b">cipher.final()</code>获得加密/解密文件缓冲区。<code class="fe ld le lf lg b">update</code>方法对数据进行加密，在调用<code class="fe ld le lf lg b">final</code>方法之前可以使用。最后，我们返回加密/解密文件缓冲区。</p><p id="9a75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们返回到路线并使用我们的功能。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="46b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们首先从请求文件中获取文件字段。因此，您应该在文件字段中将文件发送到服务器。然后，我们将这个文件传递给我们刚刚创建的函数，并将其发送回客户端。</p><p id="6c18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但这不是结束。很可能它不能正常工作，我们仍然应该添加一个参数检查，并设置头来告诉客户端我们想要发送一个文件。所以让我们开始吧。</p><p id="5659" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是首先，让我们定义我们的服务器将接受什么算法。cryptos <code class="fe ld le lf lg b">createcipheriv</code>函数可以与安装在您机器上的OpenSSL支持的任何算法一起工作。要列出所有可用的密码算法，请在终端中运行<code class="fe ld le lf lg b">openssl list-cipher-algorithms</code>。</p><p id="2e97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从列表中选择3种算法。在<code class="fe ld le lf lg b">shared/constants</code>中添加一个新的常量算法列表。我们将定义密钥和初始化向量所需的算法名称和位。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="c365" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到我们的<code class="fe ld le lf lg b">utils/index.ts</code>。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="48e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们添加了一些函数来检查文件是否存在，如果提供了所有的参数，并且key和salt具有有效的长度。然后我们设置头，<code class="fe ld le lf lg b">Content-Type</code>会给客户端关于文件扩展名的信息，<code class="fe ld le lf lg b">Content-disposition</code>会给客户端关于文件名的信息。</p><p id="8525" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们使用这些函数。</p><figure class="li lj lk ll gt jr"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="c364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们的API已经准备好了！让我们测试一下。我会用邮递员。你可以在<a class="ae lo" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">链接</a>免费下载。</p><p id="09d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们项目的根文件夹中运行<code class="fe ld le lf lg b">npm run start:dev</code>。</p><p id="ed80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发送用这些参数创建一个请求(我已经附上了图片)并发送它。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/3ad143461f9dc7cca7d3ca81baa31ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lY4fsTPjvEg4NgfGA65FA.png"/></div></div></figure><p id="b278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你得到的回复是一个无法读取的文件，那么一切都正常！保存这个文件，我们将测试解密功能。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/35cca6b088646a281db99035ca502a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQUfOjP1VxD7OsGrkboG-Q.png"/></div></div></figure><p id="e23d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在创建另一个请求并附加这个加密文件</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/cd7339cdfc755d33d05665d943b8e2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdEEcd1TdMFJlThtMp-pow.png"/></div></div></figure><p id="2f64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">点击发送按钮。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/b5a3d9118849e082c04f4fc9212611d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*NYw9Ru0fS3uKNR04yyeKQA.png"/></div></figure><p id="19d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我收到了最初发送的文件。感谢意味着一切正常！</p><p id="86d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您阅读本文！如果有用，请鼓掌并跟随。</p><p id="b1a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GitHub链接到已完成并略有改进的项目:<a class="ae lo" href="https://github.com/webmarkyn/cryptme-server" rel="noopener ugc nofollow" target="_blank">https://github.com/webmarkyn/cryptme-server</a></p></div></div>    
</body>
</html>