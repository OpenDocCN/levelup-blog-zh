<html>
<head>
<title>Airflow: Decorators for a Clean Data Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流:干净数据管道的装饰者</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/airflow-decorators-for-a-clean-data-pipeline-48ebdf12e9b0?source=collection_archive---------3-----------------------#2021-08-26">https://levelup.gitconnected.com/airflow-decorators-for-a-clean-data-pipeline-48ebdf12e9b0?source=collection_archive---------3-----------------------#2021-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ccf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用气流装饰器抽象出数据管道中的复杂性</h2></div><p id="a0cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想象一下这样一个场景，您必须运行多个日常作业来从数据湖中提取数据，对它们进行预处理，并将清理后的数据集存储到专用数据库中。如果我们必须每天运行流水线，不断检查可能的错误，那将是非常乏味的。这就是Airflow派上用场的地方:它为您提供了自动构建和监控多个数据管道的所有工具。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/7b52c64e6847c461e4fa4550fa27bc89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DC057Ssbtp5Ifk-d"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lu" href="https://unsplash.com/@pietrozj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pietro Jeng </a>拍摄</figcaption></figure><p id="eebe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章是我最近开始的与气流相关的系列文章的一部分:</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="c7df" class="ma mb it lw b gy mc md l me mf">1. <a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/airflow-for-data-pipeline-101-7a42cc28cf3a">Airflow for Data Pipeline 101</a><br/>2. <strong class="lw iu">Airflow: Decorators for a Clean Data Pipeline</strong><br/>3. <a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/airflow-unit-testing-for-bug-free-data-pipeline-d96f87a3cc8f">Unit Testing Your Airflow Data Pipeline</a><br/>4. <em class="mg">TBD...</em></span></pre><p id="9307" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我将讨论装饰者的主题，以及如何在Airflow中使用它们来抽象出构建数据管道时的许多Airflow复杂性。</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="8900" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Table of Content:<br/></strong>1. Airflow 101<br/>2. Defining an Extract-Transform-Load (ETL) data pipeline<br/>3. Airflow before decorators<br/>4. Airflow after decorators</span></pre><h1 id="fc5c" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">气流101</h1><p id="9bf7" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">在我们开始之前，请确保您的机器中的气流设置正确，并且您对气流的工作原理有一个基本的了解。下面的帖子将指导你完成安装和设置过程。</p><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/airflow-for-data-pipeline-101-7a42cc28cf3a"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">数据管道101的气流</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">如何使用Apache Airflow设置自动化数据管道</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu lo ng"/></div></div></a></div><p id="f390" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正确设置后，您将能够查看Airflow web GUI，如下图所示。该页面将突出显示您的所有管道、它们的所有者、时间表以及用于监控系统健康状况的相关诊断。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nv"><img src="../Images/53dddb9a7468b32eaebf5b32b17eec57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5_BQ10jLCcGxxyWv0pOaQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">气流网络用户界面(图片由作者提供)</figcaption></figure><h1 id="1583" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">定义ETL数据管道</h1><p id="78ca" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">提取-转换-加载(ETL)是一个数据摄取管道，它组合来自多个来源的数据，应用转换，并将它们加载到一致的数据仓库或数据库中。</p><p id="03b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程中，我们将定义一个简单的ETL管道，如下所示:</p><ol class=""><li id="b2ac" class="nw nx it kk b kl km ko kp kr ny kv nz kz oa ld ob oc od oe bi translated"><strong class="kk iu">提取</strong>一个JSON文件，</li><li id="c289" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated"><strong class="kk iu">转换</strong>数据并返回总行数，</li><li id="be30" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ob oc od oe bi translated"><strong class="kk iu">加载</strong>转换后的数据并打印出来(而不是存储到数据库/仓库中)</li></ol></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="f1c4" class="mh mb it bd mi mj or ml mm mn os mp mq jz ot ka ms kc ou kd mu kf ov kg mw mx bi translated"><strong class="ak">装修工前的气流</strong></h1><p id="1f17" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">在传统的气流管道中，上述过程看起来会像这样:</p><p id="ed45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第一步:导入库</strong></p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="ddad" class="ma mb it lw b gy mc md l me mf">import datetime as dt<br/>import json</span><span id="ad43" class="ma mb it lw b gy ow md l me mf">from airflow import DAG<br/>from airflow.operators.python_operator import PythonOperator</span></pre><p id="ba67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第二步:建立默认设置</strong></p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="0214" class="ma mb it lw b gy mc md l me mf">default_args = {<br/>    'owner': 'me'<br/>}</span></pre><p id="7500" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第三步:定义一个有向无环图(DAG)任务</strong></p><p id="df5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DAG到底是什么？</p><ul class=""><li id="345d" class="nw nx it kk b kl km ko kp kr ny kv nz kz oa ld ox oc od oe bi translated"><strong class="kk iu">定向</strong>是指按预定顺序发生的有序任务</li><li id="1864" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ox oc od oe bi translated"><strong class="kk iu">非循环的</strong>意味着一个终止的任务，没有进入永久循环的可能性</li><li id="0129" class="nw nx it kk b kl of ko og kr oh kv oi kz oj ld ox oc od oe bi translated"><strong class="kk iu">图</strong>表示可以建立多对多任务关系的结构</li></ul><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="8ca5" class="ma mb it lw b gy mc md l me mf">with DAG('airflow_tutorial_v01',<br/>         default_args=default_args,<br/>         schedule_interval='0 * * * *',<br/>         ) as dag:<br/><br/>    extract = PythonOperator(task_id='extract',<br/>                             python_callable=extract)<br/>    <br/>    transform = PythonOperator(task_id='transform',<br/>                               python_callable=transform)<br/>    <br/>    load = PythonOperator(task_id='load',<br/>                          python_callable=load)</span></pre><p id="e6e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第四步:定义ETL函数</strong></p><p id="818b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">for extract()函数</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="99a3" class="ma mb it lw b gy mc md l me mf">def extract():<br/>    order_data_dict = json.loads(data_string)<br/>    <br/>    return order_data_dict</span></pre><p id="0318" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于transform()函数，我们有</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="fe6f" class="ma mb it lw b gy mc md l me mf">def transform(order_data_dict: dict):<br/>    return {"total_count": <!-- -->len(<!-- -->order_data_dict<!-- -->)<!-- -->}</span></pre><p id="beaf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于load()函数，我们有</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="ca06" class="ma mb it lw b gy mc md l me mf">def load(total_count: int):<br/>    print(f"Total order value is: {total_count}")</span></pre><p id="e4d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第五步:连接管道</strong></p><p id="a8d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在DAG函数之外，我们可以如下连接管道:</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="afa0" class="ma mb it lw b gy mc md l me mf">extract &gt;&gt; transform &gt;&gt; load</span></pre><p id="38e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，这些步骤看起来不错，但如果我们的管道变得复杂，它们可能会很乏味。气流提供的关键抽象技术之一是<strong class="kk iu">装饰者</strong>。所以现在让我们看看如何使用decorators来简化上面的步骤。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="dc76" class="mh mb it bd mi mj or ml mm mn os mp mq jz ot ka ms kc ou kd mu kf ov kg mw mx bi translated"><strong class="ak">装修工后的气流</strong></h1><p id="eae1" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">现在让我们使用decorators重构上面的管道。</p><p id="60e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python中的decorators是什么？简单地说，decorators使我们能够包装一个函数并扩展它的功能。您可以在此<a class="ae lu" href="https://www.geeksforgeeks.org/decorators-in-python/" rel="noopener ugc nofollow" target="_blank">链接</a>中找到更多详细信息。</p><p id="5e59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第一步:导入库</strong></p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="744c" class="ma mb it lw b gy mc md l me mf">import json<br/><br/>from airflow.decorators import dag, task</span></pre><p id="81dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第二步:建立默认设置</strong></p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="5a70" class="ma mb it lw b gy mc md l me mf">default_args = {<br/>    'owner': 'me'<br/>}</span></pre><p id="3273" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第三步:定义DAG和函数</strong></p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="9b2e" class="ma mb it lw b gy mc md l me mf">@dag(default_args=default_args, tags=['etl'])<br/>def etl_pipeline():<br/>    <br/>    @task()<br/>    def extract():<br/>        return json.loads(data_string)</span><span id="348c" class="ma mb it lw b gy ow md l me mf">    @task(multiple_outputs=True)<br/>    def transform(order_data_dict: dict):<br/>        return {"total_count": <!-- -->len(<!-- -->order_data_dict<!-- -->)<!-- -->}</span><span id="ce5a" class="ma mb it lw b gy ow md l me mf">    @task()<br/>    def load(total_order_value: float):<br/>        print(f"Total order value is: {total_count}")</span><span id="c32e" class="ma mb it lw b gy ow md l me mf">    extracted = extract()<br/>    transformed = transform(extracted)<br/>    load(transformed["total_count"])</span></pre><p id="5544" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第四步:连接管道</strong></p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="4968" class="ma mb it lw b gy mc md l me mf">etl_dag = etl_pipeline()</span></pre><p id="e1e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们没有为DAG和不同的ETL步骤定义一个单独的函数，而是使用<strong class="kk iu">decorator</strong>将所有东西放在一个完整的序列中。不仅如此，对于工程师来说，代码看起来更实用、更自然。</p><h1 id="4237" class="mh mb it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="8b29" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我们已经成功地抽象出使用decorators在Airflow中构建数据管道的复杂性。Decorators允许你以一种有序且易处理的方式编写数据管道函数。不仅如此，decorators还允许您为相同数量的功能编写更少的代码！和往常一样，如果你喜欢这篇文章，我会写更多的文章详细介绍气流中更先进的概念。</p><p id="7a04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mg">请订阅我的电子邮件简讯:</em><a class="ae lu" href="https://tinyurl.com/2npw2fnz" rel="noopener ugc nofollow" target="_blank"><em class="mg">https://tinyurl.com/2npw2fnz</em></a><em class="mg">在那里，我会定期用通俗易懂的英语和漂亮的可视化方式总结编程技巧和AI研究论文。</em></p></div></div>    
</body>
</html>