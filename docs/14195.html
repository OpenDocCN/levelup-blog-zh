<html>
<head>
<title>How to Implement the Golang Reflect Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现Golang反射函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-the-golang-reflect-function-63a1f684e11d?source=collection_archive---------8-----------------------#2022-11-08">https://levelup.gitconnected.com/how-to-implement-the-golang-reflect-function-63a1f684e11d?source=collection_archive---------8-----------------------#2022-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f133" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">深入分析Golang体现的基本原则</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/947d44ad75697edad63b8291652f6248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ccwKnQW4j0txjO_E2d84Tw.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@imoflow_me?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米拉</a>在<a class="ae la" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b329" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">reflect</code>包的实现主要基于操作内存对齐和通过<code class="fe lb lc ld le b">unsafe</code>包调用<code class="fe lb lc ld le b">runtime</code>变量。</p><p id="af84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近由于工作需要，我研究了它们的底层实现，今天分享给大家。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="0317" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先我们来看一个简单的<code class="fe lb lc ld le b">reflect</code>的例子。<code class="fe lb lc ld le b">reflect.TypeOf</code>和<code class="fe lb lc ld le b">reflect.ValueOf</code>方法将一个<code class="fe lb lc ld le b">runtime type</code> and变量转换成一个<code class="fe lb lc ld le b">reflect type</code> and变量，依靠<code class="fe lb lc ld le b">unsafe</code>操作内存对齐来强制转换。<code class="fe lb lc ld le b">reflect type</code>和变量与<code class="fe lb lc ld le b">runtime</code>中的相同。可以自由操作。</p><p id="9ea8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，<code class="fe lb lc ld le b">reflect.Value</code>调用<code class="fe lb lc ld le b">Interface()</code>方法将变量从<code class="fe lb lc ld le b">reflect</code>状态转换回<code class="fe lb lc ld le b">runtime</code>状态。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="1ef1" class="lq lr it le b gy ls lt l lu lv">package main</span><span id="1f73" class="lq lr it le b gy lw lt l lu lv">import (<br/>    "fmt"<br/>    "reflect"<br/>)</span><span id="e490" class="lq lr it le b gy lw lt l lu lv">type Student struct {<br/>    Name string<br/>    Age  int<br/>}</span><span id="79c9" class="lq lr it le b gy lw lt l lu lv">func main() {<br/>    s := new(Student)<br/>    fmt.Println(reflect.TypeOf(s))<br/>    fmt.Println(reflect.TypeOf(s).Elem())<br/>    fmt.Println(reflect.TypeOf(*s))</span><span id="ccc3" class="lq lr it le b gy lw lt l lu lv">v := reflect.ValueOf(s).Elem()<br/>    v.Field(0).SetString("66")<br/>    fmt.Printf("%#v\n", v.Interface())<br/>}</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="6a29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">运行时变量。</strong></p><p id="06b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先我们简单的按照Golang的规则定义一个变量类型<code class="fe lb lc ld le b">Value</code>。<code class="fe lb lc ld le b">Value</code>有两种类型的成员属性<code class="fe lb lc ld le b">typ</code>和<code class="fe lb lc ld le b">ptr</code>。<code class="fe lb lc ld le b">typ</code>是表示这个变量是什么对象的类型，<code class="fe lb lc ld le b">ptr</code>是指向这个变量地址的地址。</p><p id="0f66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来看看官方源代码中的定义。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="51c0" class="lq lr it le b gy ls lt l lu lv">type Value struct {<br/>    typ Type<br/>    ptr uintptr<br/>}</span><span id="5c3a" class="lq lr it le b gy lw lt l lu lv">type Type interface {<br/>    Name() string         // by all type<br/>    Index(int) Value      // by Slice Array<br/>    MapIndex(value) Value // by Map<br/>    Send(Value)           // By Chan<br/>}</span></pre><p id="a078" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们操作一个变量时，我们按照<code class="fe lb lc ld le b">Type</code>类型进行操作，操作对象的数据在内存的ptr位置。</p><p id="df24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">变量类型<code class="fe lb lc ld le b">Type</code>定义了一个<code class="fe lb lc ld le b">interface</code>，因为不同的类型有不同的操作方法。</p><p id="7996" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如Map中<code class="fe lb lc ld le b">getting/setting</code> a值的方法，Slice和Array中获取索引的方法，Chan类型对象的发送和接收方法，Struct中获取结构属性的方法，属性也可以有标签。</p><p id="cb17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样不同类型有不同独特的操作方法。如果<code class="fe lb lc ld le b">Map</code>类型不能实现<code class="fe lb lc ld le b">Index</code>方法，它将<code class="fe lb lc ld le b">panic</code>。</p><p id="2701" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">明白变量的本质是一个数据地址和一种数据类型，然后基于这两个变量进行操作就是<code class="fe lb lc ld le b">reflect</code>。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="9ebe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">反映类型。</strong></p><p id="12e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来看源文件<code class="fe lb lc ld le b">reflect/type.go</code>中的一段代码。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="1873" class="lq lr it le b gy ls lt l lu lv">type rtype struct {<br/>    size    uintptr<br/>    ptrdata uintptr<br/>    kind    uint8<br/>    ...<br/>}</span></pre><p id="e241" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">rtype</code>对象是<code class="fe lb lc ld le b">Type</code>接口的简化实现，<code class="fe lb lc ld le b">kind</code>是该类型的类型，然后是其他复合类型(<code class="fe lb lc ld le b">Ptr, Slice, Map</code>等等。)有额外的属性和方法。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="7b87" class="lq lr it le b gy ls lt l lu lv">// ptrType represents a pointer type.<br/>type ptrType struct {<br/>    rtype<br/>    elem *rtype // pointer element (pointed at) type<br/>}</span></pre><p id="c633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">ptrType</code>是指针类型的定义，属性<code class="fe lb lc ld le b">rtype</code>是指针的类型，<code class="fe lb lc ld le b">elem</code>是指针指向的类型。</p><p id="6cbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后a <code class="fe lb lc ld le b">Ptr Type</code>调用<code class="fe lb lc ld le b">Elem</code>获取指针类型并返回<code class="fe lb lc ld le b">elem</code>值。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="292f" class="lq lr it le b gy ls lt l lu lv">// structType represents a struct type.<br/>type structType struct {<br/>    rtype<br/>    pkgPath name<br/>    fields  []structField // sorted by offset<br/>}</span><span id="817e" class="lq lr it le b gy lw lt l lu lv">// Struct field<br/>type structField struct {<br/>    name        name    // name is always non-empty<br/>    typ         *rtype  // type of field<br/>    offsetEmbed uintptr // byte offset of field&lt;&lt;1 | isEmbedded<br/>}</span></pre><p id="b9cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">structType</code>是指针类型的定义，<code class="fe lb lc ld le b">rtype</code>是结构类型的基本信息，<code class="fe lb lc ld le b">pkgPath</code>是结构的名称。</p><p id="c47e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当结构调用<code class="fe lb lc ld le b">Name</code>方法时，返回<code class="fe lb lc ld le b">pkgPath</code>，如果用结构指针调用<code class="fe lb lc ld le b">Name</code>方法，则不返回数据。</p><p id="61bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为没有<code class="fe lb lc ld le b">pkgPath</code>，所以<code class="fe lb lc ld le b">Elem</code>需要先转换成结构类型，结构类型的<code class="fe lb lc ld le b">Field, FieldByIndex, FieldByName, FieldByNameFunc</code>方法只是对结构类型的<code class="fe lb lc ld le b">fields</code>信息的变量操作。</p><p id="9acd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在结构属性<code class="fe lb lc ld le b">structField</code>中，<code class="fe lb lc ld le b">name</code>和<code class="fe lb lc ld le b">typ</code>分别记录属性的名称和类型，<code class="fe lb lc ld le b">offsetEmbed</code>是属性的偏移位置。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="e88b" class="lq lr it le b gy ls lt l lu lv">// chanType represents a channel type.<br/>type chanType struct {<br/>    rtype<br/>    elem *rtype  // channel element type<br/>    dir  uintptr // channel direction (ChanDir)<br/>}</span></pre><p id="0680" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">chanType</code>是<code class="fe lb lc ld le b">chan</code>类型的<code class="fe lb lc ld le b">ing</code>，<code class="fe lb lc ld le b">rtype</code>是<code class="fe lb lc ld le b">chan</code>本身，<code class="fe lb lc ld le b">elem</code>是<code class="fe lb lc ld le b">chan</code>操作对象和指针相识的类型，<code class="fe lb lc ld le b">dir</code>是chan的反向进入、退出、进入、退出。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="f93f" class="lq lr it le b gy ls lt l lu lv">// sliceType represents a slice type.<br/>type sliceType struct {<br/>    rtype<br/>    elem *rtype // slice element type<br/>}</span></pre><p id="851a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">sliceType</code>是切片类型的定义，切片类型<code class="fe lb lc ld le b">rtype</code>是自己的信息，<code class="fe lb lc ld le b">elem</code>是切片操作的对象类型。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="ab7d" class="lq lr it le b gy ls lt l lu lv">// arrayType represents a fixed array type.<br/>type arrayType struct {<br/>    rtype<br/>    elem  *rtype // array element type<br/>    slice *rtype // slice type<br/>    len   uintptr<br/>}</span></pre><p id="b36e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">arrayType</code>是数组类型，切片上有两个附加属性，<code class="fe lb lc ld le b">slice</code>是转化为切片的数组类型，是预先静态定义的，<code class="fe lb lc ld le b">len</code>是数组的长度。</p><p id="9c54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的例子描述了一些类型的定义，参见完整的源代码<code class="fe lb lc ld le b">reflect.type.go</code>。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="e906" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">体现善良。</strong></p><p id="9fe0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">reflect.Kind</code>是定义反射类型的常量，是类型的标识符。<code class="fe lb lc ld le b">rtype</code>的<code class="fe lb lc ld le b">kind</code>属性是指<code class="fe lb lc ld le b">reflect.Kind</code>。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="5a5e" class="lq lr it le b gy ls lt l lu lv">// A Kind represents the specific kind of type that a Type represents.<br/>// The zero Kind is not a valid kind.<br/>type Kind uint</span><span id="3504" class="lq lr it le b gy lw lt l lu lv">const (<br/>    Invalid Kind = iota<br/>    Bool<br/>    Int<br/>    Int8<br/>    Int16<br/>    Int32<br/>    Int64<br/>    Uint<br/>    Uint8<br/>    Uint16<br/>    Uint32<br/>    Uint64<br/>    Uintptr<br/>    Float32<br/>    Float64<br/>    Complex64<br/>    Complex128<br/>    Array<br/>    Chan<br/>    Func<br/>    Interface<br/>    Map<br/>    Ptr<br/>    Slice<br/>    String<br/>    Struct<br/>    UnsafePointer<br/>)</span></pre><p id="5090" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">反映式方法。</strong></p><p id="cfd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Kind()</code>方法注释表示返回的<code class="fe lb lc ld le b">kind</code>值为<code class="fe lb lc ld le b">rtype.kind</code>，类型为<code class="fe lb lc ld le b">reflect.Kind</code>是Go中类型的主要分类，是由<code class="fe lb lc ld le b">iota</code>定义的类型常量。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="9a3c" class="lq lr it le b gy ls lt l lu lv">// Kind returns the specific kind of this type. <br/>Kind() Kind</span></pre><p id="ec0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由变量实现的方法在类型continuation后面的内存块中定义。可以用<code class="fe lb lc ld le b">unsafe</code>读取一个类型的所有方法，可以实现<code class="fe lb lc ld le b">Implements()</code>方法来判断一个接口是否实现。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="a0c5" class="lq lr it le b gy ls lt l lu lv">// Implements reports whether the type implements the interface type <br/>Implements(u Type) bool</span></pre><p id="6886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">ChanDir</code>方法简单地返回<code class="fe lb lc ld le b">chanType.dir</code>。注解说如果类型不是<code class="fe lb lc ld le b">Chan</code>，那就是<code class="fe lb lc ld le b">panics</code>。</p><p id="1596" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果类型不是<code class="fe lb lc ld le b">chan</code>，则没有<code class="fe lb lc ld le b">dir</code>属性和它<code class="fe lb lc ld le b">panics</code>。打电话之前，一般都清楚种类是变化的。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="080d" class="lq lr it le b gy ls lt l lu lv">// ChanDir returns a channel type's direction.<br/>// It panics if the type's Kind is not Chan.<br/>ChanDir() ChanDir</span></pre><p id="07ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Elem</code>方法的全称是<strong class="js iu">元素</strong>，也就是说元素类型也可以称为指向类型。注释要求种类必须是一个<code class="fe lb lc ld le b">Array, Chan, Map, Ptr, or Slice</code>类型。恐慌和Chan的ChanDir方法是一样的。只有这5种类型可用。<code class="fe lb lc ld le b">elem</code>地产。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="26a5" class="lq lr it le b gy ls lt l lu lv">// Elem returns a type's element type.<br/>// It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice.<br/>Elem() Type</span></pre><p id="ab67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看前面的定义可以知道Arry，Slice，Ptr，Chan的<code class="fe lb lc ld le b">elem</code>是指向的对象的类型，map是值的类型。例如，以下类型的Elem后跟Kind is Int。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="8c8c" class="lq lr it le b gy ls lt l lu lv">[20]int <br/>[]int <br/>*int <br/>chan <br/>int <br/>map[string]int</span></pre><p id="bcba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Field</code>和<code class="fe lb lc ld le b">NumField</code>方法是获取结构的指定指标的属性和结构属性的个数。注释还指出了种类是否是结构类型，因为只有[] StructField可以为结构类型实现这些方法。</p><p id="236f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据前面的<code class="fe lb lc ld le b">structType</code>定义两个方法的实现思路是将<code class="fe lb lc ld le b">typ.fields[i]</code>和<code class="fe lb lc ld le b">len(typ.fields)</code>转换。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="b7c6" class="lq lr it le b gy ls lt l lu lv">// Field returns a struct type's i'th field.<br/>// It panics if the type's Kind is not Struct.<br/>// It panics if i is not in the range [0, NumField()).<br/>Field(i int) StructField</span><span id="0a1e" class="lq lr it le b gy lw lt l lu lv">// NumField returns a struct type's field count.<br/>// It panics if the type's Kind is not Struct.<br/>NumField() int</span></pre><p id="807e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">NumIn()</code>和<code class="fe lb lc ld le b">In()</code>方法是<code class="fe lb lc ld le b">Func</code>种类独有的。</p><p id="ff53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">NumIn()</code>返回此<code class="fe lb lc ld le b">Func</code>有多个输入参数，为返回参数<code class="fe lb lc ld le b">NumOut</code>；In方法是获取这个Func指定的<code class="fe lb lc ld le b">i-th</code>参数的类型。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="18e1" class="lq lr it le b gy ls lt l lu lv">// NumIn returns a function type's input parameter count.<br/>// It panics if the type's Kind is not Func.<br/>NumIn() int<br/>    <br/>// In returns the type of a function type's i'th input parameter.<br/>// It panics if the type's Kind is not Func.<br/>// It panics if i is not in the range [0, NumIn()).<br/>In(i int) Type</span></pre><p id="4ec6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Key()</code>方法对于Map Kind是唯一的，它返回Map键的类型。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="26cc" class="lq lr it le b gy ls lt l lu lv">// Key returns a map type's key type. <br/>// It panics if the type's Kind is not Map. <br/>Key() Type</span></pre><p id="426f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Len()</code>方法对于数组类型是唯一的，它返回数组定义的长度。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="ce38" class="lq lr it le b gy ls lt l lu lv">// Len returns an array type's length. <br/>// It panics if the type's Kind is not Array. <br/>Len() int</span></pre><p id="b454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上描述了<code class="fe lb lc ld le b">reflect.Type</code>的一些方法的实现原理，其余方法的原理也差不多，就是操作<code class="fe lb lc ld le b">rtype</code>的属性，有些种类类型有唯一的方法可以调用。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="95cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">体现价值法。</strong></p><p id="973d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">反射对象定义了三种属性类型，数据位置和标志。数据存储位置在ptr位置，操作方法需要依靠<code class="fe lb lc ld le b">typ</code>类型来决定数据类型的操作。</p><p id="9186" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Type</code>为静态数据，<code class="fe lb lc ld le b">Value</code>为动态数据。很多值的方法都是与数据相关的特定值。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="0414" class="lq lr it le b gy ls lt l lu lv">type Value struct {     <br/>    typ *rtype     <br/>    ptr unsafe.Pointer     <br/>    flag <br/>}</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="b9bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">万能功能。</p><p id="8707" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通用方法是指所有类型都具有的方法。它只描述了根据类型和值定义实现该方法的一般思想。具体实现代码不同，以源代码为准。</p><p id="8624" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Type</code>方法返回这个值的类型。大意是返回<code class="fe lb lc ld le b">v.typ</code>。对于特定的实现，还有一些额外的处理。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="9939" class="lq lr it le b gy ls lt l lu lv">func (v Value) Type() Type</span></pre><p id="431e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">善良方法的大意是返回<code class="fe lb lc ld le b">v.typ.kind</code>。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="0185" class="lq lr it le b gy ls lt l lu lv">// Kind returns v's Kind. If v is the zero Value (IsValid returns false),<br/>//  Kind returns Invalid.</span><span id="aca1" class="lq lr it le b gy lw lt l lu lv">func (v Value) Kind() Kind</span></pre><p id="c11b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接口方法的思想是返回<code class="fe lb lc ld le b">v.ptr</code>值并将其转换为<code class="fe lb lc ld le b">interface{}</code>变量，这样变量就从<code class="fe lb lc ld le b">reflect.Value</code>重新转换而来。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="dfa7" class="lq lr it le b gy ls lt l lu lv">// Interface returns v's current value as an interface{}.<br/>// It is equivalent to:<br/>//    var i interface{} = (v's underlying value)<br/>// It panics if the Value was obtained by accessing unexported struct fields.</span><span id="7217" class="lq lr it le b gy lw lt l lu lv">func (v Value) Interface() (i interface{})</span></pre><p id="1336" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Set()</code>方法的实现是设置<code class="fe lb lc ld le b">v.ptr=x.ptr</code>，要求<code class="fe lb lc ld le b">v</code>和<code class="fe lb lc ld le b">x</code>的类型相同。</p><p id="90cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，如果这个<code class="fe lb lc ld le b">Value</code>是<code class="fe lb lc ld le b">CanSet</code>，如果一个int转换成<code class="fe lb lc ld le b">reflect.Value</code>，函数传递一个值的副本，那么给int设置一个新值是无效的，<code class="fe lb lc ld le b">CanSet</code>的返回是<code class="fe lb lc ld le b">false</code>，需要传递一个<code class="fe lb lc ld le b">* int</code>之类的指针。要有效设置的类型。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="3963" class="lq lr it le b gy ls lt l lu lv">// Set assigns x to the value v. <br/>// It panics if CanSet returns false. <br/>// As in Go, x's value must be assignable to v's type.</span><span id="c994" class="lq lr it le b gy lw lt l lu lv">func (v Value) Set(x Value)</span></pre><p id="73bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">SetBool()</code>方法是设置bool类的值。前置要求是<code class="fe lb lc ld le b">Kind</code>相同，类型也有<code class="fe lb lc ld le b">SetInt()</code>和<code class="fe lb lc ld le b">SetString()</code>等方法。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="934d" class="lq lr it le b gy ls lt l lu lv">// SetBool sets v's underlying value. <br/>// It panics if v's Kind is not Bool or if CanSet() is false.<br/>func (v Value) SetBool(x bool)</span></pre><p id="2150" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">Method()</code>返回该值的指定索引方法。</p><pre class="kp kq kr ks gt lm le ln lo aw lp bi"><span id="e698" class="lq lr it le b gy ls lt l lu lv">// Method returns a function value corresponding to v's i'th method.<br/>// The arguments to a Call on the returned function should not include<br/>// a receiver; the returned function will always use v as the receiver.<br/>// Method panics if i is out of range or if v is a nil interface value.</span><span id="a5e2" class="lq lr it le b gy lw lt l lu lv">func (v Value) Method(i int) Value</span></pre><p id="1e46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上描述了reflect库操作运行时变量的原理，运行时变量是类型加地址。</p><p id="bc58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文没有全面分析反射库。通过这些原理，你可以大致了解这些方法的作用和操作。详细内容请参考源代码。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="4742" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读。</p><p id="947e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这样的故事，想支持我，请给我鼓掌。</p><p id="1a8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的支持对我来说非常重要，谢谢你。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="445d" class="lx lr it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">分级编码</h1><p id="34a4" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="68ed" class="mz na it js b jt ju jx jy kb nb kf nc kj nd kn ne nf ng nh bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="ce16" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">📰查看更多内容请参见<a class="ae la" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="0524" class="mz na it js b jt ni jx nj kb nk kf nl kj nm kn ne nf ng nh bi translated">🔔关注我们:<a class="ae la" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae la" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae la" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="f7c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae la" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>