<html>
<head>
<title>Introduction to Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-binary-search-b3ce843b1221?source=collection_archive---------9-----------------------#2021-07-25">https://levelup.gitconnected.com/introduction-to-binary-search-b3ce843b1221?source=collection_archive---------9-----------------------#2021-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/90682e9a4a337a3764705fe8739652d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SfBEvWNJpmLRf-Lj_M5f-g.png"/></div></div></figure><h1 id="9b68" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.二进位检索</h1><p id="b184" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">二分搜索法是一种有效的算法，用于从元素的排序列表中寻找元素。它是一种基于<strong class="ky ir">分而治之</strong>设计范式的搜索算法。与最坏情况下的线性搜索的O(n)相比，它给出了相当不错的运行时间<strong class="ky ir"> O(log n) </strong>。在这个算法中，我们递归地将数组一分为二，直到我们找到要搜索的元素，或者列表缩小到一个与我们的元素不匹配的元素。</p><h1 id="f019" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.二分搜索法的需要</h1><p id="4773" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们在日常生活中以这样或那样的形式使用二分搜索法。例如，当我们需要在字典中搜索一个单词时，我们不会像线性搜索那样一个单词一个单词一页一页地搜索。根据我们对这个单词可能在哪里的猜测，我们从字典中随机选择一页。然后我们查看页面上是否有这个单词，然后我们决定我们需要再次搜索书的哪个分区，我们丢弃其他知道我们要搜索的单词的分区。最后，我们要么找到这个单词，要么找到可能包含这个单词的最后一页，然后决定这个单词在字典中不存在。还有许多其他的例子，比如在一本书里找页码，在一个街区里找房子，等等。</p><p id="05a2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我们对项目进行排序，并使用二分搜索法搜索一个项目，我们可以实现复杂度为<strong class="ky ir"> O(log n) </strong>。<strong class="ky ir">使用二分搜索法，搜索结果所花费的时间随着数据集的大小而增加，但不是成比例的。</strong></p><h1 id="93b0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.二分搜索法算法</h1><p id="1e92" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，让我们探索二分搜索法是一个简单而有效的算法，以及它是如何工作的。二分搜索法将要搜索的元素与数据集中间的元素进行比较。</p><p id="4a9b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">它基于以下步骤:</p><p id="4eb8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">第一步:</strong>计算中间元素。</p><p id="f3ff" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">第二步:</strong>检查中间元素的值。可能有三种情况:</p><ol class=""><li id="86b0" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">列表的中间元素<strong class="ky ir">等于被搜索的元素</strong>。<br/>在这种情况下，你找到了你要找的东西，你停下来了。</li><li id="f7dd" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">列表的中间元素<strong class="ky ir">小于被搜索的元素</strong>。<br/>在这种情况下，我们将想要搜索的列表作为中间元素到最后一个元素之后的列表。</li><li id="bd92" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">列表的中间元素大于被搜索的元素。<br/>在这种情况下，我们将我们想要搜索的列表作为从第一个元素到中间元素之前的元素的列表。</li></ol><p id="5381" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">步骤3: </strong>重复步骤1和2，直到我们得到要搜索的元素的位置，或者我们要搜索的列表只剩下一个元素，该元素不是必需的元素，因此列表中不存在该元素。</p><p id="89e1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">注意:</strong>我们可以使用下面的公式来计算列表中的中间元素:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c27d" class="mw jz iq ms b gy mx my l mz na"><strong class="ms ir">mid = left + (right - left) / 2</strong></span></pre><p id="48eb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里左边的<strong class="ky ir">是我们要搜索的列表的起始索引</strong>，右边的<strong class="ky ir">是该列表的最后一个索引</strong>。</p><h1 id="54ef" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.二分搜索法的例子</h1><p id="a1a6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，让我们通过一个示例来看看二分搜索法算法的预演或工作情况:</p><p id="3f42" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如我们之前提到的，二分搜索法的强制条件是<strong class="ky ir">列表应该被排序</strong>。因此，让我们来看一个包含10个元素的列表，如下所示:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/8bbc8414d9e281d85e71d4858475c42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*YOgxXY0ESVdFh6Xx"/></div></figure><h2 id="085e" class="mw jz iq bd ka nc nd dn ke ne nf dp ki lh ng nh km ll ni nj kq lp nk nl ku nm bi translated">4.1.案例:列表中存在要搜索的元素</h2><p id="293f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们<strong class="ky ir">搜索列表中存在的元素31 </strong>。</p><p id="cac0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">正如我们在上面解释的算法中看到的，最初这些变量将具有以下值:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ba63" class="mw jz iq ms b gy mx my l mz na">left = 0<br/>right = 9<br/>mid = 0 + (9 – 0) / 2 = 4.5 = 4 (as we need integer value for index)<br/>key = 31</span></pre><p id="728d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，根据算法，我们将索引4处的元素与我们的密钥进行比较。这里，我们看到mid元素的值为27。因为27不等于31。</p><p id="2c4c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">实际上，我们知道元素在列表的下半部分。因此，我们遵循算法并改变搜索列表:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f5c4e1df5cf6b027d81e3438f62fa853.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*U5klOan-J8j79lJd"/></div></figure><p id="b781" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，中间元素的新计算索引是5。根据算法，我们发现中间的元素是关键元素，即31。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6cb2" class="mw jz iq ms b gy mx my l mz na">left = mid + 1 = 5<br/>right = 9<br/>mid = 5 + (9 – 5) / 2 = 7</span></pre><p id="fd38" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">4.2.案例:列表中不存在要搜索的元素</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e94220d6a8f073a158da00b8d5cf683f.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*JTsKD0JLH-aPsAWP"/></div></figure><p id="76c7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">假设，我们需要<strong class="ky ir">搜索列表中不存在的元素32 </strong>。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/9c72601d364980ed2a44a36252fa9e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*AJo42BB6UVb-fSW4"/></div></figure><p id="c6fd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">继续上一步，我们看到31 &lt; 32. So, we redefine the search list:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ffcc" class="mw jz iq ms b gy mx my l mz na">left = 5<br/>right = mid - 1 = 6<br/>mid = 5 + (6 – 5) / 2 = 5</span></pre><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/cd723a34d6c92702f88e76bbf036f1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*RQ8xiI-7yi7WEn61"/></div></figure><p id="fb74" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">Now, the new calculated index of the middle element is 6. Again, we compare the value at this index with our key. The value of the middle element is 33. Since 33 &gt; 32。我们再次修改列表:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/cb655648393f44683d9e642d7f301d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*BVTsy8Jz8xAkmqBC"/></div></figure><h2 id="b118" class="mw jz iq bd ka nc nd dn ke ne nf dp ki lh ng nh km ll ni nj kq lp nk nl ku nm bi translated">我们可以看到，现在右索引<strong class="ky ir">比左索引</strong>小，但这在列表中是不可能的。因此，我们断定列表中不存在<strong class="ky ir">元素。</strong></h2><p id="1c99" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以从上面的例子中推断出，当我们停止算法时，有两种情况。首先是我们找到所需的元素。第二是右索引变得比左索引小。</p><p id="eb6d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">5.Java中的二分搜索法实现</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="a540" class="mw jz iq ms b gy mx my l mz na">left = mid + 1 = 6<br/>right = 6<br/>mid = 6 + (6 – 6) / 2 = 6</span></pre><p id="2124" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们现在有了实现二分搜索法算法所需的所有知识和信息。二分搜索法最基本和直观的实现是通过递归，因为我们用不同的值递归地做同样的事情几次。但是您可能已经知道，通过递归实现的每个代码也可以通过迭代实现。我们将通过Java中的递归和迭代来了解实现。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="cdfb" class="mw jz iq ms b gy mx my l mz na">left = 6<br/>right = mid - 1 = 5</span></pre><p id="ea84" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">5.1.递归实现</p><p id="13e0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">5.2.迭代实现</p><h1 id="3608" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">6.二分搜索法的复杂性</h1><p id="5c9c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">6.1.时间复杂度</p><h2 id="25d6" class="mw jz iq bd ka nc nd dn ke ne nf dp ki lh ng nh km ll ni nj kq lp nk nl ku nm bi translated">二分搜索法的时间复杂度为O(log n)。最好的时间复杂度是O(1 ),其中列表的中间元素是被搜索的元素。最坏的情况可能是被搜索的元素要么在列表的末端，要么不在列表中。</h2><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="189f" class="mw jz iq bd ka nc nd dn ke ne nf dp ki lh ng nh km ll ni nj kq lp nk nl ku nm bi translated">6.2.空间复杂性</h2><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="0038" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">二分搜索法的空间复杂度取决于算法的实现。</h1><h2 id="d8ab" class="mw jz iq bd ka nc nd dn ke ne nf dp ki lh ng nh km ll ni nj kq lp nk nl ku nm bi translated">在迭代实现的情况下，空间复杂度为O(1)。而在递归实现的情况下，空间复杂度是O(log n)。</h2><p id="2bee" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">7.结论</p><h2 id="9207" class="mw jz iq bd ka nc nd dn ke ne nf dp ki lh ng nh km ll ni nj kq lp nk nl ku nm bi translated">二分搜索法算法是计算领域中广泛使用的算法。这是一个简单、可靠、高效的搜索算法，在大数据集和小数据集上都可以很好地工作。</h2><p id="6d4f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本文中，我们学习了二分搜索法算法及其在Java中的递归和迭代实现。</p><p id="83ba" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi">In the case of iterative implementation, the space complexity is O(1). While in the case of recursive implementation, the space complexity is O(log n).</p><h1 id="264c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi">7. Conclusion</h1><p id="185c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi">The binary search algorithm is a widely used algorithm in the computational domain. It is a simple, reliable, and efficient search algorithm that can work well on both big and small datasets.</p><p id="3ae1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi">In this article, we learned about the Binary Search Algorithm and its recursive and iterative implementations in Java.</p></div></div>    
</body>
</html>