<html>
<head>
<title>Deploying UI applications using Docker and NGINX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker和NGINX部署UI应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-your-ui-applications-using-docker-and-nginx-b65ffa8f744e?source=collection_archive---------0-----------------------#2018-07-15">https://levelup.gitconnected.com/deploying-your-ui-applications-using-docker-and-nginx-b65ffa8f744e?source=collection_archive---------0-----------------------#2018-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2437199148520f2b7c4057bbc5c6b4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mzOA5bH0EqG4L44WJvsWA.png"/></div></div></figure><p id="23fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是你——你日以继夜地试图创建你的网站，这个网站很棒，能解决未来的问题。但是现在，您需要想出如何部署它。虽然您可以使用Heroku之类的服务来部署应用程序，但在这个例子中，我们将看到一种将您的应用程序dockerizing和使用nginx的基本方法。</p><h1 id="aede" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">打包应用程序</h1><p id="0bed" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当在我们的机器上本地运行时，我们总是需要一个开发服务器，它可以热重载和服务传输的代码。无论是被转换成JS的React JSX文件还是被编译成JS的Angular TypeScript文件都是如此。</p><p id="404f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是当部署到服务器时，我们不需要任何transpilation，因为它不再需要任何更改，所有的最终代码都准备好了。在这种情况下，我们只需要生成准备好发布的静态文件和<em class="lz">一些可以服务这些静态文件的东西</em>。在我们的例子中，<em class="lz">是nginx。你可以在这里了解更多关于nginx <a class="ae ma" href="https://docs.nginx.com/" rel="noopener ugc nofollow" target="_blank">的信息。</a></em></p><p id="55e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有人可能会问，Docker适合做什么？我们把申请归档是什么意思？简而言之，我们使用Docker来避免在部署应用程序的每台服务器上安装和重新安装nginx(或任何其他系统级依赖项)。点击了解更多关于Docker <a class="ae ma" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="1856" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于本文，我们将使用这个<a class="ae ma" href="https://github.com/40x/httpclient" rel="noopener ugc nofollow" target="_blank">演示应用程序</a>，它生成一个简单的HTTP请求，并将响应记录到控制台。首先，让我们继续为项目创建分发文件。由于这是一个Angular项目，我们将使用CLI命令来构建项目。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="73e0" class="mk kx iq mg b gy ml mm l mn mo">npm run build</span></pre><p id="078a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据项目的类型，您将看到一个<code class="fe mp mq mr mg b">dist</code> / <code class="fe mp mq mr mg b">build</code>文件夹，在我们的例子中，它将采用以下结构:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/0fab2f5c98a33f7e4db749e00150d990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qigT2MsQpnb-poNHKN63Aw.png"/></div></div></figure><h1 id="e441" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">创建Dockerfile文件</h1><p id="8e29" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">既然应用程序已经打包，我们将创建一个简单的<strong class="ka ir"> Dockerfile </strong>，它将把<code class="fe mp mq mr mg b">dist</code>文件夹的内容复制到nginx的<code class="fe mp mq mr mg b">html</code>文件夹，nginx是作为我们映像的一部分下载的。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f7bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的docker文件中，我们只是指定我们的基本图像是nginx，它在这里<a class="ae ma" href="https://hub.docker.com/_/nginx/" rel="noopener ugc nofollow" target="_blank">可用</a>，然后我们用我们的内容替换默认的nginx html页面。我们可以在这里添加其他内容，以便nginx可以将我们的请求代理到我们的自定义后端，这将在上一节讨论。</p><h1 id="3fcc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">构建图像</h1><p id="bc71" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要在nginx上构建映像，即打包的代码，我们可以使用以下命令:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b76d" class="mk kx iq mg b gy ml mm l mn mo">docker build --rm -f Dockerfile -t httpclient:latest .</span></pre><p id="13ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们显式地指定了我们希望它使用的<code class="fe mp mq mr mg b">Dockerfile</code>(默认情况下它会选择这个文件名的文件，如果你愿意，你可以重命名它)然后我们指定了图像名<code class="fe mp mq mr mg b">httpclient:latest</code>，最后一个<code class="fe mp mq mr mg b">.</code>指定了我们希望在这个项目中构建所有东西。</p><p id="14be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行该命令后，我们会看到如下响应:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/11f2ae9c9128824eb90a2c276c1435de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgX0IePBAsfYK4ENC0b8Rg.png"/></div></div></figure><p id="5683" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了验证映像是否已创建，我们可以通过运行命令<code class="fe mp mq mr mg b">docker images</code>进行检查，我们会看到如下结果:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/3d337cad2f16a934371a883d673ca312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VFkjEsXLtO_o83Oj6muDIA.png"/></div></div></figure><h1 id="81f4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">运行图像</h1><p id="01ef" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在我们已经准备好了映像，我们将使用一个简单的命令来运行它</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c3d9" class="mk kx iq mg b gy ml mm l mn mo">docker run --rm -d -p 9999:80 httpclient:latest</span></pre><p id="f5ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在运行刚刚创建的docker映像，并使用<code class="fe mp mq mr mg b">-p</code>参数指定端口映射。我们知道nginx公开了端口号80，我们希望将它映射到我们机器上的端口9999。因此，当我们的浏览器试图访问端口9999时，请求将被转发到运行在我们的映像中的端口80。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/9377143851d08dc69833b5b9d3869e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuNIpuTECdzgJG0GOtndcA.png"/></div></div></figure><p id="1719" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要测试应用程序，请在浏览器上打开<code class="fe mp mq mr mg b">http://localhost:9999</code>，您会看到应用程序按预期运行。</p><h1 id="23f0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">代理后端API</h1><p id="2dac" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在示例应用程序中，我们指向第三方服务器来获取允许<a class="ae ma" href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing" rel="noopener ugc nofollow" target="_blank">跨源请求</a>的数据。但是，对于生产后端应用程序，这是不推荐的，如果您正在分别运行您的UI和后端，那么您可能也想代理请求。为了设置代理，nginx提供了一个配置文件，它可以为我们保存必要的配置，并根据定义转发请求。该文件的一个简单示例如下所示:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8cd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只是将从<code class="fe mp mq mr mg b">/api/</code>开始的请求转发到后端服务器，并将UI页面请求等其他内容转发回索引页面，因为路由是由spa自己处理的。</p><p id="a61f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了告诉nginx选择我们的nginx配置而不是默认配置，我们只需修改我们的<code class="fe mp mq mr mg b">Dockerfile</code>来选择我们的配置文件。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e1d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下次我们构建映像时，nginx配置会被复制到映像中。像映像构建和运行方式这样的其他事情都与上面解释的一样。</p><h1 id="161c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="ac48" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">既然应用程序已经按预期运行，下一步就是使用一些云服务，比如AWS、Azure或Google Cloud，将您的图像保存在图像存储库中，启动服务器并在其上运行您的图像。</p><p id="f3c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的代码样本可在<a class="ae ma" href="https://github.com/40x/httpclient/tree/docker-nginx" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="24cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢这个博客，一定要为它鼓掌或者关注我的 <a class="ae ma" href="https://www.linkedin.com/in/kashyap-mukkamala/" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> LinkedIn </em> </a></p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><figure class="mb mc md me gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com/?utm_source=bottom-banner"><div class="gh gi nf"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure><div class="ng nh gp gr ni nj"><a href="https://gitconnected.com/learn/docker" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">学习Docker -最佳Docker教程(2019) | gitconnected</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">31大Docker教程。课程由开发者提交和投票，使你能够找到最好的Docker…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">gitconnected.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jw nj"/></div></div></a></div></div></div>    
</body>
</html>