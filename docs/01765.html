<html>
<head>
<title>TCP/IP Connection Primer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TCP/IP连接初级程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/linux-kernel-tuning-for-high-performance-networking-5999a13b3fb4?source=collection_archive---------5-----------------------#2020-01-28">https://levelup.gitconnected.com/linux-kernel-tuning-for-high-performance-networking-5999a13b3fb4?source=collection_archive---------5-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2210" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">高性能网络系列的Linux内核调优</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3234d154ba9ee7df54b922ff1efbaac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DNsiIkraimKW0Iu5"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@heftiba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Toa Heftiba </a>拍摄的照片</figcaption></figure><h1 id="4ab5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">TCP/IP套接字和开放式连接底漆</h1><p id="04ea" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">每个TCP/IP连接都由所谓的<strong class="lq ir">三次握手</strong>组成。服务器将在与侦听器端口关联的欢迎套接字上进行侦听。</p><blockquote class="mk ml mm"><p id="90a9" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">服务器欢迎套接字:服务器IP地址+监听器端口</p></blockquote><p id="5330" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">当客户端连接到服务器时，如果可能，客户端将使用临时端口范围中以前未使用的端口。客户端使用与可以到达服务器的网络设备相关联的临时端口和客户端IP地址来创建套接字。</p><blockquote class="mk ml mm"><p id="74d1" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">客户端套接字:客户端IP地址+来自<a class="ae kv" href="https://medium.com/@johnhpatton/linux-kernel-tuning-for-high-performance-networking-f3256ffecf98" rel="noopener">临时端口范围</a>的端口。</p></blockquote><p id="2aa2" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">1.客户端通过向服务器和服务器正在监听的端口发送一个带有序列号的同步包，或<strong class="lq ir"> SYN </strong> (1)，来启动TCP连接。</p><p id="f287" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">2.服务器从网卡上的rx环读取数据包，并将其放入接收积压队列。准备就绪后，服务器从接收队列中读取数据包，确定它是一个<strong class="lq ir"> SYN </strong>数据包，创建一个处于“SYN_RECV”状态的新连接，并将这个连接放入SYN backlog队列。然后，服务器将带有自己序列号的同步+确认包，或<strong class="lq ir"> SYN+ACK </strong> (2)发送回客户端。</p><p id="d898" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">3.客户端通过向服务器发回确认或<strong class="lq ir"> ACK </strong> (3)来确认收到<strong class="lq ir"> SYN+ACK </strong>数据包，从而完成连接。收到<strong class="lq ir"> ACK </strong>数据包后，服务器创建一个连接套接字，该连接从SYN backlog队列中移除并移到accept队列中，状态从“SYN_RECV”变为“ESTABLISHED”</p><p id="d85a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">应用程序在下一次调用accept()时从已建立的连接接收客户机套接字，现在可以与客户机通信了。</p><blockquote class="mk ml mm"><p id="7c7c" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">服务器连接套接字:映射到服务器欢迎套接字，但专用于已建立的连接。</p></blockquote><h2 id="21bc" class="mw kx iq bd ky mx my dn lc mz na dp lg lx nb nc li mb nd ne lk mf nf ng lm nh bi translated">开放连接序列</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/7a225c51e1e5fca1b5bd73987d70b0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EeW51iL_6KEB_lm4IdncDg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ky"> TCP/IP三次握手</strong></figcaption></figure><blockquote class="mk ml mm"><p id="9ddb" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated"><strong class="lq ir"> TCP连接:<br/>客户端IP &amp;临时端口+服务器IP &amp;监听器端口<br/>或<br/>客户端套接字+服务器套接字</strong></p></blockquote><h1 id="3e07" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">TCP/IP紧密连接底漆</h1><p id="c6b6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当客户机和服务器完成发送和接收数据时，需要以类似于打开连接的方式关闭连接。客户端通常控制关闭连接的触发时间。然而，该协议在关闭连接之前给服务器应用程序时间来做一些清理工作，这在客户机和服务器上都增加了一个额外的状态。</p><p id="6cdc" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">1.客户端应用程序通过向服务器套接字发送一个终结包或<strong class="lq ir"> FIN </strong> (1)来启动关闭TCP连接，并将客户端连接置于“FIN_WAIT1”状态。</p><p id="ac72" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">2.服务器接收到<strong class="lq ir"> FIN </strong>数据包，将连接转移到“关闭等待”状态，并将<strong class="lq ir"> ACK </strong> (2)数据包发送回客户端。服务器等待服务器应用程序调用<code class="fe nj nk nl nm b">close()</code>。</p><p id="9f3e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">客户端接收到<strong class="lq ir"> ACK </strong>数据包，将连接转移到“FIN_WAIT2”状态，等待服务器上的应用程序完成，等待服务器发送一个<strong class="lq ir"> FIN </strong>数据包，指示一切完成。</p><p id="3a93" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">3.服务器应用程序调用<code class="fe nj nk nl nm b">close()</code>，服务器发送<strong class="lq ir"> FIN </strong> (3)数据包，并将连接转移到“LAST_ACK”状态。</p><p id="6886" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">4.客户端接收到<strong class="lq ir"> FIN </strong>包，向服务器发送最后的<strong class="lq ir"> ACK </strong> (4)包，并将连接转移到“TIME_WAIT”状态。客户端连接在最大段生存期加倍后关闭(MSL)。</p><blockquote class="mk ml mm"><p id="127f" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">在大多数系统上，MSL默认为60秒，客户端连接将及时—等待120秒。</p></blockquote><h2 id="bcc9" class="mw kx iq bd ky mx my dn lc mz na dp lg lx nb nc li mb nd ne lk mf nf ng lm nh bi translated">闭合连接序列</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/ef3abd398f9a8226f56b987f86ac91cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyptVUyDjb68S7UGeEZGXQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ky"> TCP连接关闭序列</strong></figcaption></figure><h1 id="35e0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">交通高峰的影响</h1><p id="e750" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当一个事件一下子吸引了大量的流量，比如产品发布会、音乐会门票销售、时事新闻等，网站就会超载。它们过载的原因多种多样，但配置不佳的web服务器可能是一长串潜在瓶颈中的第一个。web服务器过载的主要原因之一是网络堆栈调整不当，或者更糟糕的是，默认的网络堆栈配置。</p><h2 id="6940" class="mw kx iq bd ky mx my dn lc mz na dp lg lx nb nc li mb nd ne lk mf nf ng lm nh bi translated">半开连接</h2><p id="6bd8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">客户端连接发起并完成三次握手，以创建已建立的连接。因此，在等待部分连接完成时，接收服务器可能处于不稳定状态。此外，大多数TCP应用程序无法访问该状态，因为这些细节是由内核的网络驱动程序和网络堆栈处理的。TCP/IP服务器应用程序创建一个绑定到欢迎套接字的侦听器(<code class="fe nj nk nl nm b">listen()</code>)，从TCP栈上已建立的连接队列中检索一个客户端套接字(<code class="fe nj nk nl nm b">accept()</code>)，从/向客户端套接字执行读/写操作(<code class="fe nj nk nl nm b">recv()</code> / <code class="fe nj nk nl nm b">send()</code>)，最后关闭连接(<code class="fe nj nk nl nm b">close()</code>)。</p><p id="d5e4" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">内核负责一个CPU在所有侦听器的接收缓冲区中可以拥有的最大数据包数量，包括在3次握手中使用的数据包。接收缓冲区位于网络接口卡(NIC)和协议栈处理器之间。一旦接收队列变满，进入接收缓冲区的速度超过处理速度的数据包将导致数据包被丢弃。</p><p id="62f0" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">内核配置控制着等待<strong class="lq ir"> ACK </strong>的半开连接的数量。如果SYN backlog队列是128，那么每个监听器最多只能容纳128个SYN 包。这意味着一次只有128个客户端可以尝试握手，或者128个半开连接。在握手的这一点上，有几个因素需要注意:</p><ul class=""><li id="a259" class="no np iq lq b lr mo lu mp lx nq mb nr mf ns mj nt nu nv nw bi translated">任何服务器+端口都可以从各种来源接收到大量的<strong class="lq ir"> SYN </strong>数据包，而且并非所有的数据包都来自合法来源。</li><li id="0af7" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">客户端不必完成握手，将许多SYN<strong class="lq ir">数据包留在SYN backlog队列中，直到它们超时。</strong></li><li id="eaf1" class="no np iq lq b lr nx lu ny lx nz mb oa mf ob mj nt nu nv nw bi translated">积压队列已满将导致任何额外的客户端连接尝试失败。</li></ul><h2 id="ee79" class="mw kx iq bd ky mx my dn lc mz na dp lg lx nb nc li mb nd ne lk mf nf ng lm nh bi translated">等待应用程序的已建立连接</h2><p id="7b85" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当连接状态变为“已建立”时，它被移动到接受队列，在那里它将被服务器应用程序在调用<code class="fe nj nk nl nm b"><strong class="lq ir">accept()</strong></code> <strong class="lq ir">时拾取。这个队列的大小由内核和应用程序共同设置。应用程序在调用<code class="fe nj nk nl nm b"><strong class="lq ir">listen()</strong></code>时请求大小，内核设置队列的最大大小限制。如果应用程序请求一个大于内核限制的接受队列积压，这将被静默地截断到内核限制。</strong></p><p id="449b" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">结果是，满的接受队列将导致内核限制接收<strong class="lq ir"> SYN </strong>数据包的速率，以匹配接受队列的处理速率，从而丢弃超过阈值的数据包。增加SYN积压队列和accept积压队列是一种有效的补救措施。</p><h2 id="cd1e" class="mw kx iq bd ky mx my dn lc mz na dp lg lx nb nc li mb nd ne lk mf nf ng lm nh bi translated">半封闭连接</h2><p id="0dfd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">另一个有问题的迹象可能发生在连接的两端，其中一个处于半封闭状态。客户端连接上的“TIME_WAIT”表示连接已关闭，但需要等待最大段生存期的2倍才能被回收。这是在反向代理服务器上看到的问题，这些服务器不重用“TIME_WAIT”中的连接，或者具有keepalive。服务器连接上的“CLOSE_WAIT”表示连接正在等待应用程序完成清理。</p><p id="d7ff" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><em class="mn"> TIME_WAIT Starvation </em> <br/>对于HTTP反向代理，如果代理目标支持，可以通过启用keepalive设置来减少“TIME_WAIT”中的大量连接，但请确保该值在3到5秒之间，以便在不再需要连接时可以更快地关闭连接。这是一个HTTP/1.1协议，通常用于HTTP反向代理。</p><p id="42d4" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">可以调整内核来重用处于“TIME_WAIT”状态的连接。重用“TIME_WAIT”连接会带来一些小风险，尤其是在NAT之后或在不兼容的客户端操作系统上运行时。此外，4.12版之前的linux内核允许端口被回收而不是关闭。这不是一个推荐的设置，应小心使用，并且永远不要在NAT后的系统或不兼容的操作系统上启用，但在某些环境中可以提供一些价值。检查这些系统上增加的<strong class="lq ir"> RST </strong>数据包或连接重置，以验证这些设置。</p><blockquote class="mk ml mm"><p id="8c50" class="lo lp mn lq b lr mo jr lt lu mp ju lw mq mr lz ma ms mt md me mu mv mh mi mj ij bi translated">重用连接时等待2分钟(MSL x 2)的目的是确保协议不会创建包含网络中可能仍然存在的前一个数据段的重复序列的数据段。</p></blockquote><p id="5927" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">或者，也可以在某些系统上降低MSL，以允许更快地回收“TIME_WAIT”连接，但这样做时应该小心。在负载较重的反向代理服务器上，降低MSL可能是提高代理连接性能的好方法。</p><p id="538d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated"><em class="mn"> CLOSE_WAIT饥饿<br/> </em>在拥有大量“CLOSE_WAIT”连接的服务器上，应用程序无法完成对<code class="fe nj nk nl nm b"><strong class="lq ir">close()</strong></code>的调用。在正常情况下，这些问题会很快得到解决，而反向代理web服务器往往能很好地解决这个问题。然而，当大量的“CLOSE_WAIT”连接滞留时，这是应用程序无法及时调用CLOSE()的结果。如果这些连接被锁定，清除它们的唯一方法是等待或重新启动应用程序。这可能会导致内存问题，因为连接会占用内存；然而，更大的问题是应用程序正在做什么导致这些堆积起来。对于“CLOSE_WAIT”连接数量增加的原因，除了调整或修复保持连接打开的服务器应用程序之外，没有太多可以做的事情。</p><h1 id="45b9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="12c7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本文中的概述旨在提供对打开和关闭TCP连接的基础元素的基本理解。本文中没有涉及到很多细节，但是这应该为进一步研究TCP协议提供了一个良好的基础。</p><p id="695a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mr lz ma mb mt md me mf mv mh mi mj ij bi translated">如果这篇文章中的任何信息不准确，请发表评论，我会更新文章以纠正信息。</p></div></div>    
</body>
</html>