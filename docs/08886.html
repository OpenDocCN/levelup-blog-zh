<html>
<head>
<title>GraphQL — Common Disadvantages Over REST and Solutions to Overcome them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">graph QL——REST的常见缺点以及克服这些缺点的解决方案</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-common-disadvantages-over-rest-and-solutions-to-overcome-them-70cbaca42a44?source=collection_archive---------6-----------------------#2021-06-15">https://levelup.gitconnected.com/graphql-common-disadvantages-over-rest-and-solutions-to-overcome-them-70cbaca42a44?source=collection_archive---------6-----------------------#2021-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f1c98e2f527acd0112b97d095b34049f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpCtCEG5orPMqJFiTSORRQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">蒂姆·莫斯霍尔德在<a class="ae kf" href="https://unsplash.com/s/photos/question?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c3ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">在2015年推出之后，<strong class="ki iu"> GraphQL </strong>已经走了很长一段路，被视为在<strong class="ki iu"> REST </strong> API架构上实现API的替代或更好的方式。一开始，开发人员看到了GraphQL相对于REST的优点和许多缺点。现在，GraphQL在过去的六年里变得更加成熟，对于这些缺点，可以通过GraphQL生态系统本身找到解决方案。在本文中，我将介绍GraphQL中最常见的一些缺点，以及在当前的GraphQL生态系统中有哪些解决方案。</span></p><p id="e57c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文按以下顺序描述了以下缺点和解决方案。</p><ul class=""><li id="9dee" class="ln lo it ki b kj kk kn ko kr lp kv lq kz lr ld ls lt lu lv bi translated"><strong class="ki iu"> N+1问题</strong></li><li id="b4d4" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated"><strong class="ki iu"> HTTP缓存</strong></li><li id="90a1" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated"><strong class="ki iu">模式复制</strong></li><li id="a059" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated"><strong class="ki iu"> API监控</strong></li><li id="804d" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated"><strong class="ki iu">速率限制</strong></li></ul><h1 id="528e" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">N+1问题</h1><p id="bfbc" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">大多数GraphQL API开发人员面临的最常见问题之一是<strong class="ki iu"> N+1 </strong>问题。<strong class="ki iu"> N+1 </strong>当GraphQL解析器向底层数据源发出一个初始查询以及<strong class="ki iu"> N </strong>个后续查询以获取与解析器相关的所有数据时，会出现问题。下面是一个简单的模式，写的是车辆品牌和车辆。我将使用这个模式解释N+1问题。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="95b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的模式可以看出，我们可以假设在我们的底层数据库模式中有两个表/集合，分别代表<strong class="ki iu">品牌</strong>和<strong class="ki iu">车辆</strong>。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/5f5809bb083a3ade1a48b61fad38627b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEdVc9D4y1hLOm_dvvH8tQ.png"/></div></div></figure><p id="a3e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们想获得单个品牌的信息，下面的操作将在我们的服务器上完成。</p><ul class=""><li id="5cf4" class="ln lo it ki b kj kk kn ko kr lp kv lq kz lr ld ls lt lu lv bi translated">使用过滤器(<strong class="ki iu"> name </strong>)查询品牌表/集合</li><li id="7950" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">使用过滤器查询Vehicle表，以获取与该品牌相关的所有车辆。(<strong class="ki iu">品牌名称</strong>)</li></ul><p id="02db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，正如我们所看到的，我们需要发出两个查询，以便获得一个品牌数据和车辆数据。现在让我们看看有哪些方法可以从我们的GraphQL API中获取这些信息。正如我们从模式中看到的，有一个查询可以用来查询所有可用的品牌。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4ebc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据我们的模式，这个查询是一个完全有效的查询。但是让我们尝试分析这个查询将如何在我们的GraphQL API服务器中执行。正如我们所知，GraphQL解析器按照准确的顺序遍历所有字段，从底层数据库中获取数据。由于这种行为，我们不希望在解析器中发生的事情。</p><ul class=""><li id="c565" class="ln lo it ki b kj kk kn ko kr lp kv lq kz lr ld ls lt lu lv bi translated">首先，它将查询所有品牌的品牌表/集合。</li><li id="53c6" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">接下来，它将从查询中获得第一个品牌结果，并从车辆表/集合中获得该品牌的车辆。</li><li id="43ff" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">接下来，它会对下一个品牌做同样的事情。</li><li id="7d1b" class="ln lo it ki b kj lw kn lx kr ly kv lz kz ma ld ls lt lu lv bi translated">下一个品牌的下一个…</li></ul><p id="b031" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想你现在可能能够确定我们面临的问题是什么。因此，它不是查询底层的车辆表/集合一次，而是查询在品牌表/集合中找到的<strong class="ki iu"> N </strong>项的数量。所以现在我们有<strong class="ki iu"> N+1 </strong>个查询被发送到数据库进行我们的简单查询。</p><h2 id="3690" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">休息方式</h2><p id="ddc2" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">在其余情况下，这将主要是两个不同的端点。</p><pre class="ne nf ng nh gt nx ny nz oa aw ob bi"><span id="6da1" class="nl mc it ny b gy oc od l oe of">GET /Brands<br/>GET /Vehicles?filterBy={}</span></pre><p id="165d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使现在我们需要在服务器中发出两个API请求，这也只是发送到底层数据库的两个查询，当N变大时，这可能比N+1个数据库查询更快。</p><h2 id="36bc" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">GraphQL解决方案</h2><p id="c127" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">解决方案应该是，应该有某种方法来获取所有品牌名称，并向车辆表/集合发送一个过滤查询。这可以在GarphQL中使用<a class="ae kf" href="https://github.com/graphql/dataloader" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">数据加载器</strong> </a>来实现。</p><p id="4c3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据加载器所做的是，它提供了一个批处理/缓存机制，因此我们可以针对这个问题实现一个单一的查询场景。因此，我们可以缓存从第一个查询中获得的所有品牌名称，并在最后使用它发出一个包含所有品牌名称的查询，而不是一个接一个地查询。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="50e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的数据加载器中我们可以看到，只有一个针对车辆表/集合的查询，因为所有的品牌名称都由数据加载器本身缓存。到目前为止，它只会发出2个查询，而不是N+！查询。下面是展示如何在GraphQL API项目中实现这一点的完整实现。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="f04e" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">HTTP缓存</h1><p id="b1b6" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">GraphQL开发人员将面临的另一个问题是无法实现HTTP缓存。不要混淆，我们可以在客户机上实现客户端缓存，在服务器上实现数据库级捕获。但是因为我们的GraphQL请求是通过POST请求中的主体发送的，所以我们不能使用标准的HTTP缓存。</p><h2 id="02fb" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">休息方式</h2><p id="22d8" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">Rest没有这个问题，因为根据功能，我们有HTTP标准方法，可以用于REST。例如，如果我们只想获取信息，我们可以使用HTTP缓存支持的<strong class="ki iu"> GET </strong> HTTP方法。</p><h2 id="de00" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">GraphQL解决方案</h2><p id="75b1" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">这里的主要问题是HTTP缓存不可用于<strong class="ki iu"> POST </strong> HTTP方法。对于突变，这不是问题，因为我们不需要缓存突变。但是在GraphQL中，查询也作为POST请求发送。因此，解决方案是将查询作为<strong class="ki iu"> GET </strong>请求发送。</p><p id="61c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，解决方案似乎很简单。但这有一个问题。现在，因为我们使用GET for查询，所以我们之前通过主体发送的所有查询参数都应该作为URL参数在请求本身上发送。更严重的问题是，这些查询跨越多行。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="94da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，GET URL参数不支持这些多行。这意味着我们需要对这些参数进行编码，以获得类似这样的多行。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e7f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有两个问题。首先，这不容易理解我们发送的查询，另一个是当查询变得更加复杂时，我们可能会达到GET参数的范围。如果我们可以为一个查询发送某种ID，而不是发送整个查询，那会怎么样？这就是我们可以使用<strong class="ki iu">持久查询的地方。</strong></p><p id="c369" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用持久查询，我们可以发送一个查询的ID，它也将存储在我们的服务器上。目前，有许多支持GraphQL持久查询的库。阿波罗就是这样一个图书馆。下面是我们如何使用Apollo实现持久查询。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e4b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用Apollo，它将首先尝试使用散列Id查询服务器，如果服务器已经存储了散列Id，它将简单地返回数据。如果散列Id在服务器中不可用，那么Apollo将发送查询和散列Id，这样它可以为后续查询存储散列Id。</p><p id="7e66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个挑战将是如何控制这些缓存值。为此，我们可以使用<strong class="ki iu"> @cacheControl </strong>指令来提供字段级缓存控制。现在，基于最小缓存年龄，Apollo将自动检索缓存值或将缓存值发送给客户端。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="f197" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">模式复制</h1><p id="4349" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">当您开发GraphQL APIs时，您会很快发现，每当我们对模式进行修改时，总有两个地方需要进行更改。第一个位置是我们的模式本身，第二个位置是我们的数据库模式。这将很快成为一个问题，因为在大多数情况下，两个位置都有相同的重复数据。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="e6cf" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">休息方式</h2><p id="f5c5" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">在REST中我们不会有这个问题，因为我们只有一个数据库模式而没有一个图表模式。</p><h2 id="cff4" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">GraphQL解决方案</h2><p id="7be0" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">这可以通过使用像<strong class="ki iu"> TypeGraphQL + TypeORM </strong>或<strong class="ki iu"> TypeGraphQL + typegoose </strong>这样的库很容易地解决。下面是一个使用TypeGraphQL + typegoose实现的解决方案。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a2d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用两个库提供的修饰，我们可以在一个位置定义两个模式，而不是在不同的位置复制它们。如果您想了解更多相关信息，您可以关注这篇<a class="ae kf" href="https://towardsdatascience.com/graphql-code-first-resolver-first-using-typegraphql-and-typegoose-747616223786" rel="noopener" target="_blank">文章</a>，其中我有一个如何实现该解决方案的分步指南。</p><h1 id="a23d" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">API监控</h1><p id="25ba" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">大多数API监控都是基于API返回的HTTP状态代码。但是在GraphQL API中，GraphQL本身只会返回200个状态代码，即使我们有来自解析器的错误。只有当底层HTTP服务出错时，它才会返回其他HTTP状态代码。(500、401等……)这是基于HTTP代码的API监控的问题。</p><h2 id="34a2" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">休息方式</h2><p id="c31d" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">REST已经可以根据它面临的每个问题优化不同的HTTP状态代码。</p><h2 id="1350" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">GraphQL解决方案</h2><p id="130b" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">监控背后的主要思想是快速识别错误和性能问题。尽管使用HTTP代码不容易识别错误，但GraphQL本身有一种标准的方法来指定API中的错误。我们可以使用这些错误对GraphQL API本身进行监控。幸运的是，GraphQL生态系统中已经有了这样的监控工具，其中一个就是Apollo Studio。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/21d0f41fe101d863b47a8a16b568822f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNKVDzdyftORMpYbl0P3fQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">抄送—阿波罗<a class="ae kf" href="https://www.apollographql.com/docs/studio/getting-started/" rel="noopener ugc nofollow" target="_blank">文件</a></figcaption></figure><p id="7d79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用Apollo Studio，它已经可以根据标准的GraphQL错误标准计算错误，除此之外，我们还可以根据其他标准添加自定义指标。</p><h1 id="51aa" class="mb mc it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">限速</h1><p id="4ef2" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">想象一个具有以下模式的GraphQL API。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8871" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里我们可以看到，用户可以针对该模式发出以下有效查询。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5749" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想你可能会明白为什么这对我们的GraphQL API不好。当这个查询被提供给我们的API时，它很可能必须处理大量的计算数据，这对其他请求来说也是一个问题。或者在最坏的情况下，一个人可以故意发送一个无限的查询来使我们的整个API服务器崩溃。我们需要引入速率限制来避免这些场景，这在GraphQL中是很困难的。</p><h2 id="9827" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">休息方式</h2><p id="e8f9" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">在REST端点中，输出的结构和生成输出所需的查询数量不会改变。因此，我们可以根据调用该端点时会产生多少成本来限制每个特定时间段的请求数，作为速率限制器。</p><h2 id="e3a4" class="nl mc it bd md nm nn dn mh no np dp ml kr nq nr mp kv ns nt mt kz nu nv mx nw bi translated">GraphQL解决方案</h2><p id="5495" class="pw-post-body-paragraph kg kh it ki b kj mz kl km kn na kp kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">我们不能使用REST中使用的解决方案，因为我们只使用了一个端点。即使我们在解析器级别考虑，基于每次查询请求的字段，查询输出也不会与REST输出相同，因为客户端可以为同一个解析器请求不同的字段。因此，解决方案是在生成输出之前，计算输出的成本，并在此基础上应用一个限制。</p><p id="291c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以使用<a class="ae kf" href="https://github.com/pa-bru/graphql-cost-analysis" rel="noopener ugc nofollow" target="_blank"> graphql-cost-analysis </a>库来实现。通过使用这个，我们可以使用<strong class="ki iu"> @cost </strong> decorator将成本附加到查询的每个字段。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2cbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用<a class="ae kf" href="https://github.com/pa-bru/graphql-cost-analysis" rel="noopener ugc nofollow" target="_blank"> graphql-cost-analysis </a>，现在我们可以定义什么是成本以及如何基于其他字段计算成本，并定义在执行查询之前将被验证的最大成本。</p></div></div>    
</body>
</html>