<html>
<head>
<title>The “Open Sesame” of Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的“芝麻开门”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-open-sesame-of-kubernetes-d656639f330f?source=collection_archive---------15-----------------------#2020-06-03">https://levelup.gitconnected.com/the-open-sesame-of-kubernetes-d656639f330f?source=collection_archive---------15-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="125d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp kq kr bm ks kt ku kv kw di"/>命令行工具充当用户和系统之间的桥梁。有一个构建良好的CLI来使一项技术或工具更加强大并惠及社区是至关重要的。<strong class="js iu"> kube-see-tee-el </strong>或<strong class="js iu"> kube-cuttle </strong>就是一个被证明的例子。Kubectl是Kubernetes成功背后的主要支柱之一。</p><blockquote class="kx ky kz"><p id="b713" class="jq jr la js b jt ju jv jw jx jy jz ka lb kc kd ke lc kg kh ki ld kk kl km kn im bi translated">命令行工具是相应应用程序的“芝麻开门”咒语。如果我们有效地使用它们，我们的生活会变得更轻松。</p></blockquote><p id="3895" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们日复一日的Kubernetes任务中，大部分时间我们把自己限制在kubectl <strong class="js iu">获取、描述、删除、创建、应用</strong>、<strong class="js iu"> </strong>和<strong class="js iu">编辑</strong>。在这篇文章中，我将分享我最近遇到的一些有趣的(隐藏的宝藏)kubectl用例。</p><ul class=""><li id="5f6b" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated"><strong class="js iu"> kubectl首次展示重启</strong></li></ul><p id="449d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有些情况下，我们必须重新启动部署或状态集中所有正在运行的pod。我们要么一个一个删除它们，要么缩小到0，然后扩大规模(如果可以接受停机时间)。我们可以通过卷展重新启动命令使这个过程更容易和更快。<br/> <code class="fe ln lo lp lq b"><strong class="js iu">$ kubectl rollout restart [deployment|sts] &lt;deployment/sts&gt;</strong></code></p><ul class=""><li id="2c58" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated"><strong class="js iu"> kubectl详细</strong></li></ul><p id="771d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Verbose是CLI非常需要的命令。它节省了我们排除故障的时间。说到kubectl，我们通常使用<strong class="js iu">描述</strong>命令来收集详细信息。但是kubectl有自己的冗长子命令。默认的kubectl详细级别是1。我们可以看到，它在一次操作后立即向控制台打印一个简短的响应，像<code class="fe ln lo lp lq b">pod/nginx created</code>、<code class="fe ln lo lp lq b">Error from server (NotFound): pods “mysql” not found</code>。我们可以提高详细级别，以获得更全面的日志，也可以看到正在发生的事情。<br/>T3】</p><ul class=""><li id="97e1" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated"><strong class="js iu"> kubectl补丁</strong></li></ul><p id="f76a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们使用Kubernetes时，在许多情况下我们必须修改清单。在这种情况下，<code class="fe ln lo lp lq b">kubectl edit</code>是最常用的命令。如果我们做一个小的更新，Edit是好的，但是有时当我们修改一长串YAML清单的行时，它会唤醒YAML。如果是这样的话，我们可能不得不花今天剩下的时间来修正YAML的错误。我们可以通过使用<code class="fe ln lo lp lq b">kubectl patch</code>命令来避免这种情况。<br/> <code class="fe ln lo lp lq b"><strong class="js iu">$ kubectl patch [kind] &lt;resource&gt; -p &lt;yaml content&gt;</strong></code> <strong class="js iu">。</strong></p><p id="10e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过应用<code class="fe ln lo lp lq b">kubectl patch</code>，我们也可以将一个元素合并到一个数组中。</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="0840" class="lz ma it lq b gy mb mc l md me">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRoleBinding<br/>metadata:<br/> name: developers<br/>roleRef:<br/> apiGroup: rbac.authorization.k8s.io<br/> kind: ClusterRole<br/> name: developers<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: dev<br/>  namespace: dev</span></pre><p id="5e2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我想向主题添加/合并一个新的服务帐户。如果我使用<code class="fe ln lo lp lq b">kubectl patch</code>，它将覆盖现有的内容。但是我不想。</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="1306" class="lz ma it lq b gy mb mc l md me">$ kubectl patch clusterrolebinding devevloper — type=’json’ -p=’[{“op”: “add”, “path”: “/subjects/1”, “value”: {“kind”: “ServiceAccount”, “name”: “qa”,”namespace”: “qa” } }]’</span></pre><blockquote class="kx ky kz"><p id="eb14" class="jq jr la js b jt ju jv jw jx jy jz ka lb kc kd ke lc kg kh ki ld kk kl km kn im bi translated"><em class="it">看一下这个命令，在</em> <code class="fe ln lo lp lq b"><em class="it">p=</em></code> <em class="it">参数下我已经指定了<br/> </em> <code class="fe ln lo lp lq b"><em class="it">op</em></code> <em class="it">:这是一个添加操作<br/> </em> <code class="fe ln lo lp lq b"><em class="it">path</em></code> <em class="it">:将一个元素添加到数组主题的位置一<br/> </em> <code class="fe ln lo lp lq b"><em class="it">value</em></code> <em class="it">:服务账号详情</em></p></blockquote><p id="4194" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">样本输出，</p><pre class="lr ls lt lu gt lv lq lw lx aw ly bi"><span id="9518" class="lz ma it lq b gy mb mc l md me">apiVersion: rbac.authorization.k8s.io/v1<br/>kind: ClusterRoleBinding<br/>metadata:<br/> name: dev<br/>roleRef:<br/> apiGroup: rbac.authorization.k8s.io<br/> kind: ClusterRole<br/> name: dev<br/>subjects:<br/>- kind: ServiceAccount<br/>  name: dev<br/>  namespace: dev<br/>- kind: ServiceAccount<br/>  name: qa<br/>  namespace: qa</span></pre><ul class=""><li id="da82" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated"><strong class="js iu">库贝特尔差异</strong></li></ul><p id="bbcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<code class="fe ln lo lp lq b">kubectl diff</code>已经和Kubernetes住在一起很久了。但是在1.18版中，它已经作为一个稳定的特性被提升了。它显示了活动对象和我们要应用的对象之间的变化。我们可以确保在更新对象之前没有做任何不必要的更改。<br/> <code class="fe ln lo lp lq b"><strong class="js iu">$ kubectl diff -f &lt;file&gt;.yml</strong></code></p><blockquote class="kx ky kz"><p id="6c81" class="jq jr la js b jt ju jv jw jx jy jz ka lb kc kd ke lc kg kh ki ld kk kl km kn im bi translated">尽管它在1.18版中被宣布为一个稳定的功能，但实际上并不是。在1.18版中，如果你输入<code class="fe ln lo lp lq b"><em class="it">kubectl diff</em></code>，它会自动应用修改，而不是显示差异。在v1.18.1中已经修复了，所以，在使用<code class="fe ln lo lp lq b"><em class="it">kubectl diff</em></code>之前，请确保你的Kubernetes版本是1.18.1或以上。</p></blockquote><ul class=""><li id="81ea" class="le lf it js b jt ju jx jy kb lg kf lh kj li kn lj lk ll lm bi translated"><strong class="js iu"> kubectl转换</strong></li></ul><p id="d26f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在每个Kubernetes版本中找到至少一个API弃用。在Kubernetes升级期间，当我们不得不更新现有对象时，这是很痛苦的。<code class="fe ln lo lp lq b">kubectl convert</code>将根据我们的集群版本更新对象。<br/> <code class="fe ln lo lp lq b"><strong class="js iu">$ kubectl convert -f &lt;file&gt;.yml</strong></code></p><p id="900a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以后就好办了。</p><blockquote class="kx ky kz"><p id="dd89" class="jq jr la js b jt ju jv jw jx jy jz ka lb kc kd ke lc kg kh ki ld kk kl km kn im bi translated">kubectl convert已被弃用，将在未来版本中删除。<br/>为了进行转换，kubectl将对象应用到集群中，然后kubectl得到想要的版本。</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="4f17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>