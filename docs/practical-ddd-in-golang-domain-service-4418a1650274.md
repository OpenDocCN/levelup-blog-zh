# 戈朗实用 DDD:域名服务

> 原文：<https://levelup.gitconnected.com/practical-ddd-in-golang-domain-service-4418a1650274>

## 领域驱动设计

## Go 中 DDD 的故事继续呈现了无状态构建块之一——域服务。

![](img/9000145ba867c4ff59f2469302e069e3.png)

照片由[内森·杜姆劳](https://unsplash.com/@nate_dumlao)在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上拍摄

在讨论了实体和值对象之后，我将在本文中介绍一组领域建模模式中的第三个。它的名字是域名服务。

服务可能是最被滥用的 DDD 模式。对域服务目的的误解来自许多不同的 web 框架。在大多数框架中，服务就是一切。

它是为了保持业务逻辑。它创建 UI 组件，如表单域。它处理会话和 HTTP 请求。有时它只是扮演一个巨大的“utils”类的角色。有时保留最简单的值对象可以拥有的代码。定期执行数据库迁移。

上面的例子几乎都不是域服务的一部分。直到本文结束，我会尽量更好地解释它的用途和用法。

```
Other articles from DDD series:**1\.** [**Practical DDD in Golang: Value Object**](/practical-ddd-in-golang-value-object-4fc97bcad70)**2\.** [**Practical DDD in Golang: Entity**](/practical-ddd-in-golang-entity-40d32bdad2a3)
```

# 它代表行为

域服务代表来自[问题域](https://www.definitions.net/definition/problem+domain)的行为。它为过于复杂而无法存储在单个实体或值对象中的业务不变量提供了解决方案。

有时，一个特定的行为可能与多个实体或值对象交互。在这些情况下，很难找到该行为属于哪个实体。当遇到这种情况时，域服务就是解决方案。

> 域服务不处理会话或请求。它对 UI 组件一无所知。它不执行数据库迁移。它不验证用户输入。域服务只管理业务逻辑。

域服务的示例

上面的例子中，有一个`ExchangeRateService`的情况。每当我提供一些应该注入到另一个对象内部的无状态结构时，我就定义了一个接口。它有助于稍后的单元测试。

该服务处理货币兑换的完整业务逻辑。它包含`ExchangeRateRepository`来获取所有的利率，因此它可以转换任何金额的货币。

一个行为复杂的案例

如前所述，域服务包含的业务不变量太复杂，无法存储在单个实体或值对象中。在上面的例子中，`CasinoService`持有复杂的逻辑，每当有来自某个`Account`的新赌注时就应用`Bonuses`。

我们应该创建一个域服务，而不是强迫`Account`或`Bonus`实体相互依赖，或者更糟糕的是，为实体的方法提供预期的存储库或服务。该服务可以封装完整的业务逻辑，用于将`Bonuses`应用于任何必要的`Account`。

# 它代表合同

有时候，我们的[有界上下文](https://martinfowler.com/bliki/BoundedContext.html)依赖于其他的。一个典型的例子是一个微服务集群，其中一个微服务通过 REST API 访问另一个微服务。

在大多数情况下，从外部 API 接收的数据对于初始有界上下文的工作至关重要。因此，在我们的领域层中，我们应该能够访问这些数据。

> 我们必须始终将领域层从技术细节中分离出来。这意味着，如果我们将外部 API 或数据库集成到我们的业务逻辑中，就会产生代码味道。

在这里，域服务进入适当的位置。在领域层，我总是为服务提供一个接口，作为外部集成的契约。然后，我们可以在我们的业务逻辑中注入该接口，但是实现是在基础设施层。

作为契约的域服务

在上面的例子中，我在域层定义了`AccountService`接口。它表示其他域服务可以调用的契约。但是，我们以`AccountAPIService`的形式提供实现。

`AccountAPIService`向外部 [CRM 系统](https://financesonline.com/what-are-examples-of-crm-different-tool-types-you-should-know-about/)或我们内部的微服务发送 HTTP 请求，专用于`Accounts`。我们可以为`AccountService`提供一个额外的实现，它将使用这种方法在一个隔离的测试环境中与来自一个文件的测试`Accounts`一起工作。

# 无国籍的

**域服务不能保持状态。域服务也不能包含任何具有状态的字段。**

这个规律可能是显而易见的，但不幸的是，事实并非如此。根据每个开发人员的背景，他们中的一些人拥有使用为每个请求运行独立流程的语言进行 web 开发的经验。

在这种情况下，服务是否包含状态并不重要。但是，当您使用 Go 时，您可能会为整个应用程序使用一个域服务实例。因此，您可以想象如果许多不同的客户端访问内存中的同一个值会发生什么。

域服务与实体和值对象的比较

正如我们在上面的例子中看到的，实体和值对象持有状态。实体可以在运行时改变状态，而值对象总是保持不变。当我们需要一个新的值对象时，我们创建一个新的值对象。

域服务不包含任何有状态的对象。它只保存其他无状态的结构，比如存储库、其他服务、工厂、配置值。它可以启动一个状态的创建或它的持续，但它不持有它。

在域服务中存储状态的错误方法

在上面的例子中，`TransactionService`以`Money`值对象的形式保存一个有状态字段。每当我们想要进行新的存款时，我们执行应用`Bonuses`的逻辑，然后将其添加到最终结果中，最终结果是服务中的一个字段。

这种做法是错误的。无论何时，只要有人存款，结果就会改变。我们不想这样做，但是要按照`Account`保持这种总结。相反，我们应该将计算结果作为方法的结果返回，如下例所示。

从域服务返回状态的正确方法

新的`TransactionService`总是产生最新的计算结果，而不是把它们存储在里面。不同的用户不能共享内存中的同一个对象，域服务可以再次像单个实例一样工作。

这个服务的客户端现在负责保存新的结果，并在发生存款时刷新它。

# 域名服务与其他类型的服务

到目前为止，提供域服务的理由是很清楚的。但是，在某些情况下，不清楚某些服务是否也是域服务。或者更好地说，服务属于哪一层？

基础设施服务是最容易识别的。它们总是包含技术细节、与数据库的集成或外部 API。在大多数情况下，它们是来自其他层的接口的实际实现。

表象服务也很容易识别。它们总是提供一些与 UI 组件或验证用户输入相关的逻辑。[表单服务](https://symfony.com/doc/current/forms.html)就是一个典型的例子。

当要区分应用程序和域服务时，问题就出现了。我发现很难区分这两种类型。

根据我的经验，我使用应用程序服务只是为了提供处理会话或请求的一般逻辑。将授权和访问权限放在应用层中也很好。

应用服务的一个例子

在许多情况下，我将应用服务作为域服务的包装结构。每当我想在会话中缓存一些东西并使用域服务作为数据的后备时，我就使用这种方法。这种方法你可以在上面的例子中找到。

在那里，`AccountSessionService`是一个应用服务，它从领域层包装了`AccountService`。它负责从会话存储中提取一个值，然后使用它在下面的服务中查找`Account`细节。

# 结论

域服务代表了一种无状态的结构，它提供了真实商业世界中的行为。它与许多不同的对象交互，如实体和值对象。这需要它们的复杂行为，或者至少是我们不知道它们属于哪里的行为。

域服务与其他层的服务没有任何相似之处，除了名称。它只与业务逻辑相关，不应该与技术细节、会话、请求或任何其他特定于应用程序的细节相联系。

```
Other articles from DDD series:**1\.** [**Practical DDD in Golang: Value Object**](/practical-ddd-in-golang-value-object-4fc97bcad70)**2\.** [**Practical DDD in Golang: Entity**](/practical-ddd-in-golang-entity-40d32bdad2a3)
```

# 有用的资源:

*   [https://martinfowler.com/](https://martinfowler.com/)
*   [https://www.domainlanguage.com/](https://www.domainlanguage.com/)