<html>
<head>
<title>A Serving Flask on Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头上的服务瓶</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-serving-flask-on-docker-4a1fb917614c?source=collection_archive---------15-----------------------#2020-03-03">https://levelup.gitconnected.com/a-serving-flask-on-docker-4a1fb917614c?source=collection_archive---------15-----------------------#2020-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="26f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">docker改进了打包应用程序以获得跨环境的可再现结果。Docker允许我们将应用程序与其所有依赖项捆绑在一起，这样生成的图像可以在任何地方使用兼容的docker运行时运行。我们感兴趣的应用需要资源，例如:</p><ol class=""><li id="4945" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">一个网络应用框架(例如<a class="ae ku" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a></li><li id="41af" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">一个WSGI服务器(例如<a class="ae ku" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> gunicorn </a></li><li id="927f" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">网络服务器(例如<a class="ae ku" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> Nginx </a></li><li id="35df" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">数据存储(例如<a class="ae ku" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a></li><li id="504e" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated">编排引擎(例如<a class="ae ku" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a></li></ol><p id="53af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于篇幅原因，这篇文章的重点是1到3，并对它们进行排序。我们将把这里的工作作为Kubernetes实现的一个跳板，在随后的一篇文章中涵盖整个领域。这篇文章讲述了以下内容:</p><ul class=""><li id="beaa" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk la kr ks kt bi translated">构建一个app容器，在gunicorn后面运行Flask应用程序。</li><li id="1035" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk la kr ks kt bi translated">构建一个web容器来提供静态内容，同时将动态数据请求代理回应用程序容器。</li><li id="c7c6" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk la kr ks kt bi translated">使Flask应用程序能够与主机上的Elasticsearch实例对话。您可以用您选择的任何其他数据存储来替换它。</li></ul><p id="0031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的驱动者是早先的文章<a class="ae ku" href="http://xplordat.com/2020/02/16/a-flask-full-of-whiskey-wsgi/" rel="noopener ugc nofollow" target="_blank">一个装满威士忌的瓶子(WSGI)</a>——它是在我的笔记本电脑上实现的。将代码、系统配置和命令整合在一起并与post共享是一件苦差事。此外，如果最终用户使用不同的操作系统，或者拥有不同配置的系统，那么其中的一些内容需要由最终用户进行调整。捆绑了活动部件的docker映像更容易共享，也更容易重用！那就让我们开始吧。</p><p id="745c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章中有一些代码片段用于说明。完整的代码可以从<a class="ae ku" href="https://github.com/ashokc/Serving-Flask-on-Docker" rel="noopener ugc nofollow" target="_blank"> github </a>获得。</p><h1 id="649b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.这个计划</h1><p id="50ae" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">下面的图1简单地展示了我们计划实现的内容。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/2897d92511492785045e15d4f64190a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/0*hqBnYO4YEccOSWQI"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图一。大局。web和app容器由docker-compose提供。主机上的Elasticsearch开放供docker网络访问。通过web容器访问应用服务，该web容器将请求代理给应用容器</figcaption></figure><p id="92ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们选择让Elasticsearch在主机上运行，因为它也服务于其他应用程序。此外，我们还想模拟容器应用程序需要访问主机上的应用程序的情况。应用程序很简单。根据API中的<em class="mq"> id </em>值，它在elasticsearch索引中查询具有该<em class="mq"> id </em>的报价，并使用模板构建一个Html片段。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="f865" class="mw lc iq ms b gy mx my l mz na">from elasticsearch import Elasticsearch<br/>from flask import Flask, request, render_template<br/>app = Flask(__name__)<br/># 'host.docker.internal' will be resolved by the container to point to the host<br/>client = Elasticsearch([{'host':'host.docker.internal','port':9200}])<br/>index = 'quotes'<br/><a class="ae ku" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/byId', methods=['GET'])<br/>def getById():<br/>    docId = request.args.get('id')<br/>    quote = client.get(index=index, id=docId)<br/>    return render_template('quote.html',quote=quote)</span></pre><p id="c0c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在点击一个像<a class="ae ku" href="http://localhost:8080/quotes/byId?id=797944" rel="noopener ugc nofollow" target="_blank">这样的网址http://localhost:8080/quotes/byId？id=797944 </a>您将得到:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/0790de26011b81d89f6ef6beb00f7663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*RKS1-oB8As4cq_E9"/></div></figure><h1 id="66bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.Docker撰写</h1><p id="34a0" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">从图1中我们知道我们需要设置两个服务，其中一个应该可以从主机访问。这是目录/文件布局，以及每个文件用途的一些细节。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="0413" class="mw lc iq ms b gy mx my l mz na">.<br/>├── app <br/>│   ├── Dockerfile # instructions to build the app_container image<br/>│   ├── quoteserver<br/>│   │   ├── config.py    # some config options for gunicorn<br/>│   │   ├── quotes.py    # the 'app'<br/>│   │   ├── requirements.txt <br/>│   │   └── templates<br/>│   │       └── quote.html<br/>│   └── start.sh         # script to be run by the container<br/>├── docker-compose.yml<br/>└── web <br/>    ├── Dockerfile<br/>    ├── index.html<br/>    ├── nginx.conf<br/>    └── static<br/>        ├── css<br/>        │   └── quote.css<br/>        ├── favicon.ico<br/>        └── images<br/>            └── abraham lincoln.jpg</span></pre><p id="263a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组合文件很简单——两个服务，每个服务都有自己的Dockerfile，位于各自的目录中，如上所示。Nginx容器被设置为主机可以在端口8080访问。这里是完整的<em class="mq"> docker-compose.yml </em>。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="d9f7" class="mw lc iq ms b gy mx my l mz na">version: '3.7'<br/>services: <br/>  app_service:<br/>    build: <br/>      context: ./app<br/>      dockerfile: Dockerfile<br/>  web_service:<br/>    build: <br/>      context: ./web<br/>      dockerfile: Dockerfile<br/>    ports: <br/>      - 8080:80</span></pre><h1 id="8974" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.Web容器</h1><p id="6244" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们导入官方的Nginx映像，并在web容器下面的<em class="mq"> Dockerfile </em>中添加我们的配置和静态文件</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="182b" class="mw lc iq ms b gy mx my l mz na">FROM nginx</span><span id="fb18" class="mw lc iq ms b gy nc my l mz na">COPY ./nginx.conf /etc/nginx/<br/>COPY index.html /var/www/html/<br/>COPY ./static/ /var/www/html/</span></pre><p id="5b0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要将请求发送到在gunicorn下运行的Flask应用程序，该应用程序监听应用程序容器的端口9999。该服务在docker-compose中被命名为“app_service”。下面是来自<em class="mq"> nginx.conf </em>的相关片段。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="1eab" class="mw lc iq ms b gy mx my l mz na">#'/quotes/byId?id=nnn' =&gt; '<a class="ae ku" href="http://app_service:9999/byId?id=nnn'" rel="noopener ugc nofollow" target="_blank">http://app_service:9999/byId?id=nnn'</a><br/>location /quotes/ {<br/>   proxy_pass <a class="ae ku" href="http://app_service:9999/" rel="noopener ugc nofollow" target="_blank">http://app_service:9999/</a>;<br/>}</span></pre><h1 id="9b2b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4.应用程序容器</h1><p id="cd97" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">应用程序容器的映像从精益python-alpine映像开始，并从requirements.txt安装所需的模块。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="8503" class="mw lc iq ms b gy mx my l mz na"># Pull a lean base image<br/>FROM python:3.8-alpine<br/># We need the "ip" command used in 'start.sh'<br/>RUN apk add --update iproute2<br/>COPY start.sh /<br/>RUN chmod +x /start.sh<br/>COPY ./quoteserver /quoteserver<br/># requirements.txt lists the modules &amp;amp; their versions to be installed<br/>RUN pip install --upgrade pip<br/>RUN pip install -r ./quoteserver/requirements.txt<br/># Update /etc/hosts and start gunicorn<br/>CMD ["/start.sh"]</span></pre><p id="fc88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">flask应用程序需要能够访问主机上运行的Elasticsearch。但是我们不想硬编码主机的潜在可变IP地址。在Mac和Windows上，docker自动将'<em class="mq"> host.docker.internal </em>'解析为主机IP地址——但不幸的是在Linux上没有。找到这个帖子<a class="ae ku" href="https://dev.to/bufferings/access-host-from-a-docker-container-4099" rel="noopener ugc nofollow" target="_blank">https://dev . to/buffer ings/access-host-from-a-docker-container-4099</a>来解决这个问题。这个修复与启动<em class="mq"> gunicorn </em>的命令结合在一起——这就是我们下面的<em class="mq"> start.sh </em>。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="75f4" class="mw lc iq ms b gy mx my l mz na">#!/bin/sh<br/># Resolve 'host.docker.internal' so we can access the host<br/>HOST_DOMAIN="host.docker.internal"<br/>HOST_IP=$(ip route | awk 'NR==1 {print $3}')<br/>echo -e "$HOST_IP\t$HOST_DOMAIN" &gt;&gt; /etc/hosts<br/># Start gunicorn<br/>/usr/local/bin/gunicorn -c /quoteserver/config.py -b 0.0.0.0:9999 --chdir /quoteserver quotes:app</span></pre><h1 id="dbaa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">5.Docker网络和防火墙规则</h1><p id="8192" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我在笔记本电脑上要做的最后一件事是允许从docker网络访问Elasticsearch。docker中的默认地址范围相当大，例如在172集合中，从172.17.0.0/16到172.31.0.0/16。每次运行“<em class="mq"> docker-compose up </em>”时，你都可以从该范围内的任何地方获得具有地址的容器，因此我们必须开放整个范围进行访问。对于我的爱好来说，这个范围太大了，以至于我无法在家里的网络中访问Elasticsearch。我们通过在下面提供一个定制的更小范围的<em class="mq">/etc/docker/daemon . JSON</em>文件来改变这一点。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="a866" class="mw lc iq ms b gy mx my l mz na">{<br/>  "default-address-pools":<br/>  [<br/>    {"base":"172.24.0.0/16","size":24}<br/>  ]<br/>}</span></pre><p id="8fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们重启docker服务，单独开放172.24.0.0/16访问Elasticsearch。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="61c8" class="mw lc iq ms b gy mx my l mz na">sudo systemctl restart docker.service<br/>sudo ufw allow from 172.24.0.0/16 proto tcp to any port 9200</span></pre><h1 id="ffca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">6.测试和验证</h1><p id="ddb4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们用docker-compose打开容器。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="a8a2" class="mw lc iq ms b gy mx my l mz na">[quoteserver] ls<br/>app/  docker-compose.yml  web/<br/>[quoteserver] docker-compose build<br/>[quoteserver] docker-compose up --d<br/>[quoteserver] docker network ls<br/>NETWORK ID          NAME                  DRIVER              SCOPE<br/>f60dfeab8f95        bridge                bridge              local<br/>...<br/>90cf5e594e9d        quoteserver_default   bridge              local</span></pre><p id="49f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查<em class="mq"> quoteserver_default </em>网络确认我们的<em class="mq"> daemon.json </em>是有效的。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="1014" class="mw lc iq ms b gy mx my l mz na">[quoteserver] docker inspect 90cf5e594e9d<br/>...<br/>"IPAM": {<br/>            "Driver": "default",<br/>            "Options": null,<br/>            "Config": [<br/>                {<br/>                    "Subnet": "172.24.11.0/24",<br/>                    "Gateway": "172.24.11.1"<br/>                }<br/>            ]<br/>        },<br/>...</span></pre><p id="e0cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">列出正在运行的容器表明，我们让web容器在8080为主机公开其端口80。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="2d9c" class="mw lc iq ms b gy mx my l mz na">[quoteserver] docker ps -a --format="table {{.Names}}\t{{.Image}}\t{{.Ports}}\t{{.Command}}"</span><span id="89cc" class="mw lc iq ms b gy nc my l mz na">NAMES           IMAGE                     PORTS                COMMAND<br/>app_container  quoteserver_app_service                     "/start.sh"<br/>web_container  quoteserver_web_service   0.0.0.0:8080-&gt;80/tcp   "nginx -g 'daemon of…"</span></pre><p id="7ef7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查app容器显示/etc/hosts已经附加了用于解析的网关地址。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="364f" class="mw lc iq ms b gy mx my l mz na">[quoteserver] docker exec -it 56fe0df26e36 /bin/sh -c "tail -3 /etc/hosts"<br/>ff02::2 ip6-allrouters<br/>172.24.11.3 app_host<br/>172.24.11.1 host.docker.internal</span></pre><p id="906d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在剩下要做的就是测试功能。</p><pre class="mf mg mh mi gt mr ms mt mu aw mv bi"><span id="09aa" class="mw lc iq ms b gy mx my l mz na">curl <a class="ae ku" href="http://localhost:8080/quotes/byId?id=86789" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/quotes/byId?id=86789</a></span></pre><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/03d0ae4937200b077d336b742880ca47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/0*NZJEymxCB_jCXGnU"/></div></figure><p id="6550" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我们结束了这篇相当短的帖子。我们将在随后的文章中讨论Kubernetes的成熟的容器编排。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="d93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【http://xplordat.com】原载于2020年3月3日<a class="ae ku" href="http://xplordat.com/2020/03/03/a-serving-flask-on-docker/" rel="noopener ugc nofollow" target="_blank"><em class="mq"/></a><em class="mq">。</em></p></div></div>    
</body>
</html>