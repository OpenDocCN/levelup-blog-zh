<html>
<head>
<title>How to Create a Content Aggregator with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python创建内容聚合器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-content-aggregator-with-python-381a3e6cff12?source=collection_archive---------9-----------------------#2021-11-02">https://levelup.gitconnected.com/how-to-create-a-content-aggregator-with-python-381a3e6cff12?source=collection_archive---------9-----------------------#2021-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在一个地方获取您最喜欢的内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/192cc93a1e167faf0c2d4d26981ee3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ln-7Y5MExceQMSum"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Susn Matthiessen 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="38f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对内容聚合器的需求显而易见。互联网上充斥着无穷无尽的信息，为了让您及时了解最新消息或任何其他类型的内容，您可能每天都要浏览各种网站。</p><p id="af11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内容聚合有助于我们优化内容消费——我们只需要一个网站，而不是滚动浏览5个不同的网站，也不是没完没了地滚动试图过滤我们关心的内容，我们可以看到与我们感兴趣的主题相关的内容。</p><p id="3049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，您将学习如何使用python从头开始创建自己的定制内容聚合器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4f7d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="54d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要完成本教程，您需要:</p><ul class=""><li id="e663" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">Python 3.6+的本地开发环境</li><li id="a0f8" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">熟悉Python。</li></ul><h1 id="f49e" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">步骤1 —安装依赖项</h1><p id="0ded" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建一个名为<code class="fe ns nt nu nv b">requirements.txt</code>的新文件，并复制以下内容</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="f29f" class="oa md it nv b gy ob oc l od oe">praw==7.4.0</span></pre><p id="8224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下命令安装所有依赖项</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="c3fa" class="oa md it nv b gy ob oc l od oe">pip install -r requirements.txt</span></pre><p id="e002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将为我们的内容聚合器提出一个设计，这样就可以很容易地添加新的来源和主题。</p><h1 id="b020" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">第二步——设计</h1><p id="7027" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们将从一个单一的来源——Reddit——创建一个内容聚合器，但是为了更容易地添加新的来源，我们必须适当地设计我们的项目。</p><p id="f666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个<code class="fe ns nt nu nv b">Source</code>抽象类，它将是我们想要包含的不同来源(Reddit、Medium等)的基类。<br/>在我们的内容聚合器中，我们将创建一个继承自<code class="fe ns nt nu nv b">Source</code>的<code class="fe ns nt nu nv b">RedditSource</code>类。<br/>最后，我们将创建另一个类<code class="fe ns nt nu nv b">RedditHotProgramming</code>,它将代表我们希望从源中获取内容的主题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9a3861bdc08b4d82b07154e46b202881.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*QRwTawOTMPczC_pJCmoDkQ.png"/></div></figure><p id="070f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望输入将从Reddit源获取的第二个主题，您只需创建一个新的类，例如<code class="fe ns nt nu nv b">RedditHotNews</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e4afafd2a06d802807223f78107dba0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*y2v4BT5HoJJ_kUndqhdJTQ.png"/></div></figure><p id="d1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从不同的平台(例如Medium)获取帖子，您将创建一个<code class="fe ns nt nu nv b">MediumSource</code>类和您希望关注的主题类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/79d0e67262982af4ccaff268f4e45e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zo8GIPa-2jbOzeXpE33VOw.png"/></div></div></figure><p id="ebdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将开始编写我们的内容聚合器，从<code class="fe ns nt nu nv b">Source</code>抽象类开始。</p><h1 id="83cc" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">步骤3 —创建源类</h1><p id="de3b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建一个名为<code class="fe ns nt nu nv b">content_agg.py</code>的新文件，并导入以下库</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="b3be" class="oa md it nv b gy ob oc l od oe"><strong class="nv iu">from </strong>abc import ABC, abstractmethod<br/><strong class="nv iu">import </strong>praw<br/><strong class="nv iu">import </strong>os</span></pre><p id="a67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们定义我们的<code class="fe ns nt nu nv b">Source</code>抽象类。<br/><code class="fe ns nt nu nv b">Source</code>类将有两个抽象方法，这两个方法将允许我们<em class="oi">将</em>连接到一个源(例如它的API)并<em class="oi">从中获取</em>帖子。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="b68f" class="oa md it nv b gy ob oc l od oe"><strong class="nv iu"><em class="oi">class</em> </strong>Source(ABC):</span><span id="e62a" class="oa md it nv b gy oj oc l od oe">  @abstractmethod<br/>  <strong class="nv iu"><em class="oi">def</em> </strong>connect(<em class="oi">self</em>):<br/>    <strong class="nv iu">pass</strong></span><span id="8c32" class="oa md it nv b gy oj oc l od oe">  @abstractmethod<br/>  <strong class="nv iu"><em class="oi">def</em> </strong>fetch(<em class="oi">self</em>):<br/>    <strong class="nv iu">pass</strong></span></pre><p id="1457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将创建<code class="fe ns nt nu nv b">RedditSource</code>类，它将实现<code class="fe ns nt nu nv b">Source</code>类中的抽象方法。</p><h1 id="24ec" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">步骤4 —创建Reddit源类</h1><p id="0eda" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一节中，我们将把<code class="fe ns nt nu nv b">RedditSource</code>类写入<code class="fe ns nt nu nv b">content_agg.py</code>。</p><p id="d99d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个类中，我们将实现到Reddit API的连接。为了访问Reddit的API，您需要生成一个密钥。<br/>幸运的是这个过程非常简单和简短，在github的Reddit-archive上跟随它。</p><p id="4bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦有了必要的键，就为它们创建环境变量，或者简单地在代码中将它们作为常量使用(仅当您不打算在其他地方共享您的代码时)。如果你像我一样选择为这两个键创建环境变量，下面是你如何从代码中访问它们</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="ebde" class="oa md it nv b gy ob oc l od oe">CLIENT_ID = os.environ.get('REDDIT_CLIENT_ID')<br/>CLIENT_SECRET = os.environ.get('REDDIT_CLIENT_SECRET')</span></pre><p id="649f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在继续创建<code class="fe ns nt nu nv b">RedditSource</code>类</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="27d4" class="oa md it nv b gy ob oc l od oe"><strong class="nv iu"><em class="oi">class</em> </strong>RedditSource(<em class="oi">Source</em>):</span><span id="5f5c" class="oa md it nv b gy oj oc l od oe">  <strong class="nv iu"><em class="oi">def</em> </strong>connect(<em class="oi">self</em>):<br/>    <em class="oi">self</em>.reddit_con = praw.Reddit(<em class="oi">client_id</em>=CLIENT_ID,<br/>                      <em class="oi">client_secret</em>=CLIENT_SECRET,<br/>                      <em class="oi">grant_type_access</em>='client_credentials',<br/>                      <em class="oi">user_agent</em>='script/1.0')<br/>    <strong class="nv iu">return </strong><em class="oi">self</em>.reddit_con</span><span id="b15b" class="oa md it nv b gy oj oc l od oe"><em class="oi">  </em><strong class="nv iu"><em class="oi">def</em> </strong>fetch(<em class="oi">self</em>):<br/>    <strong class="nv iu">pass</strong></span></pre><p id="680c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个到Reddit的API的工作连接。<br/>函数<code class="fe ns nt nu nv b">fetch</code>在这个类中没有实现，因为我们将为每个主题实现它。</p><p id="08cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将创建<code class="fe ns nt nu nv b">RedditHotProgramming</code>类，在那里我们将从r/programming中获取热门帖子。</p><h1 id="25a0" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">步骤5 —创建Reddit热编程类</h1><p id="0967" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一节中，我们将实现一个类，它将使我们能够从r/programming中获取热帖。<br/>我们将依赖从我们的父类<code class="fe ns nt nu nv b">RedditSource</code>到Reddit的API的连接。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="bf85" class="oa md it nv b gy ob oc l od oe"><strong class="nv iu"><em class="oi">class</em> </strong>RedditHotProgramming(<em class="oi">RedditSource</em>):</span><span id="1ca7" class="oa md it nv b gy oj oc l od oe"><em class="oi">  </em><strong class="nv iu"><em class="oi">def</em> </strong>__init__(<em class="oi">self</em>) -&gt; None:<br/>    <em class="oi">self</em>.reddit_con = <em class="oi">super</em>().connect()<br/>    <em class="oi">self</em>.hot_submissions = []</span><span id="76b0" class="oa md it nv b gy oj oc l od oe"><em class="oi">  </em><strong class="nv iu"><em class="oi">def</em> </strong>fetch(<em class="oi">self</em>, <em class="oi">limit</em>: <em class="oi">int</em>):<br/>    <em class="oi">self</em>.hot_submissions =  <br/>           <em class="oi">self</em>.reddit_con.subreddit('programming').hot(<em class="oi">limit</em>=limit)</span><span id="7e77" class="oa md it nv b gy oj oc l od oe"><em class="oi">  </em><strong class="nv iu"><em class="oi">def</em> </strong>__repr__(<em class="oi">self</em>):<br/>    urls = []<br/>    for submission in <em class="oi">self</em>.hot_submissions:<br/>      urls.append(vars(submission)['url'])<br/>    <strong class="nv iu">return </strong>'\n'.join(urls)</span></pre><p id="894d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了获取功能，我们还实现了<code class="fe ns nt nu nv b">__repr__</code>方法，这样当我们在<code class="fe ns nt nu nv b">RedditHotProgramming</code>对象上调用<code class="fe ns nt nu nv b">print</code>时，我们将打印它的自定义表示，在我们的例子中，它将是来自热帖的URL列表。</p><p id="8f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将把所有东西粘在一起，并执行我们的内容聚合器。</p><h1 id="1920" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">第六步——把所有东西粘在一起</h1><p id="ca3e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了运行一切，我们将创建一个<code class="fe ns nt nu nv b">RedditHotProgramming</code>实例，并从中获取一些帖子。然后，我们将能够打印我们的对象，并获得出现在每个热帖中的所有URL。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="779d" class="oa md it nv b gy ob oc l od oe"><strong class="nv iu">if </strong>__name__ == '__main__':<br/>  reddit_top_programming = RedditHotProgramming()<br/>  reddit_top_programming.fetch(<em class="oi">limit</em>=10)<br/>  print(reddit_top_programming)</span></pre><p id="6a40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要执行，只需在您的终端中运行<code class="fe ns nt nu nv b">python content_agg.py</code>。</p><h1 id="bc47" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">结论</h1><p id="dd43" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，您完全从零开始构建了一个新闻聚合器。现在，您可以选择任何您想要添加和扩展这个项目的平台和主题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="oi">对我的更多内容</em> </strong>感兴趣？通过<strong class="lb iu">我的</strong> <a class="ae ky" href="https://eliran9692.medium.com/membership" rel="noopener"> <strong class="lb iu">推荐链接</strong> </a>加入媒介会员，在<a class="ae ky" href="https://twitter.com/CodingKaiser" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Twitter </strong> </a>上关注我，在<a class="ae ky" href="http://codingkaiser.blog/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">我的博客</strong> </a>上阅读我所有的作品。</p><p id="e77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我所有的链接都在这里。</p></div></div>    
</body>
</html>