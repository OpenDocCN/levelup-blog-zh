<html>
<head>
<title>JavaScript Design Patterns — Adapters and Facades</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式—适配器和外观</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-design-patterns-adapters-and-facades-4b96aa274ab4?source=collection_archive---------14-----------------------#2020-06-08">https://levelup.gitconnected.com/javascript-design-patterns-adapters-and-facades-4b96aa274ab4?source=collection_archive---------14-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9684a90c52b84a121c1d74ed1aead53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nSS3nqLIxuMEdU_Z"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·温克勒在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9e92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设计模式是任何好软件的基础。JavaScript程序也不例外。</p><p id="15cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究适配器和外观模式。</p><h1 id="dc0b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">适配器</h1><p id="9bc0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">适配器模式对于为另一个对象创建一致的接口很有用。</p><p id="328c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们正在为其创建界面的对象不符合它的使用方式。</p><p id="4a37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们创建了一个适配器，以便我们可以轻松地使用它们。</p><p id="e4be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还隐藏了实现，这样我们就可以轻松地使用它，并且耦合度很低。</p><p id="b568" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下创建一个适配器对象:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5ce3" class="mq lf it mm b gy mr ms l mt mu">const backEnd = {<br/>  setAttribute(key, value) {<br/>    //.,,<br/>  },<br/>  getAttribute() {<br/>    //...<br/>  }<br/>}</span><span id="b7c2" class="mq lf it mm b gy mv ms l mt mu">const personAdapter = {<br/>  setFirstName(name) {<br/>    backEnd.setAttribute('firstName', name);<br/>  },<br/>  setLastName(name) {<br/>    backEnd.setAttribute('lastName', name);<br/>  },<br/>  getFirstName() {<br/>    backEnd.getAttribute('firstName');<br/>  },<br/>  getLastName() {<br/>    backEnd.getAttribute('lastName');<br/>  }<br/>}</span></pre><p id="9f00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了一个名为<code class="fe mw mx my mm b">personAdapter</code>的适配器对象，这样我们就可以使用<code class="fe mw mx my mm b">backEnd</code>来设置所有的属性。</p><p id="1c2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">适配器有一个人们更容易理解的接口，因为方法名是显式的。</p><p id="c5a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他对象或类可以使用对象来操作属性。</p><p id="046e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用适配器来创建我们想以任何方式向公众公开的接口。</p><h1 id="537e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用适配器继承对象</h1><p id="b9a6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有了适配器，我们还可以为多个类或对象创建一个接口。</p><p id="2a63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f825" class="mq lf it mm b gy mr ms l mt mu">const backEnd = {<br/>  setAttribute(key, value) {<br/>    //.,,<br/>  },<br/>  getAttribute() {<br/>    //...<br/>  }<br/>}</span><span id="08f7" class="mq lf it mm b gy mv ms l mt mu">const parentAdapter = {<br/>  //...<br/>  getAdapterName() {<br/>    //...<br/>  }<br/>}</span><span id="7f44" class="mq lf it mm b gy mv ms l mt mu">const personAdapter = Object.create(parentAdapter);</span><span id="3b96" class="mq lf it mm b gy mv ms l mt mu">personAdapter.setFirstName = (name) =&gt; {<br/>  backEnd.setAttribute('firstName', name);<br/>};</span><span id="cd86" class="mq lf it mm b gy mv ms l mt mu">personAdapter.setLastName = (name) =&gt; {<br/>  backEnd.setAttribute('lastName', name);<br/>};</span><span id="5cb0" class="mq lf it mm b gy mv ms l mt mu">personAdapter.getFirstName = () =&gt; {<br/>  backEnd.getAttribute('firstName');<br/>};</span><span id="3c37" class="mq lf it mm b gy mv ms l mt mu">personAdapter.getLastName = () =&gt; {<br/>  backEnd.getAttribute('lastName');<br/>}</span></pre><p id="f469" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mw mx my mm b">Object.create</code>创建了<code class="fe mw mx my mm b">personAdapter</code>，这允许我们从另一个父对象继承。</p><p id="c9b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们从<code class="fe mw mx my mm b">parentAdapter</code>原型对象得到了<code class="fe mw mx my mm b">getAdapterName</code>方法。</p><p id="fe56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们给<code class="fe mw mx my mm b">personAdapter</code>加上自己的方法。</p><p id="7cf0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以从另一个对象继承方法，再加上适配器中我们自己的适配器对象中的方法。</p><p id="9702" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以对类语法做同样的事情。</p><p id="7a5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建一个适配器类来代替一个对象。</p><p id="dc8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4622" class="mq lf it mm b gy mr ms l mt mu">const backEnd = {<br/>  setAttribute(key, value) {<br/>    //.,,<br/>  },<br/>  getAttribute() {<br/>    //...<br/>  }<br/>}</span><span id="4d2d" class="mq lf it mm b gy mv ms l mt mu">class ParentAdapter {<br/>  //...<br/>  getAdapterName() {<br/>    //...<br/>  }<br/>}</span><span id="94ab" class="mq lf it mm b gy mv ms l mt mu">class PersonAdapter extends ParentAdapter {<br/>  setFirstName(name) {<br/>    backEnd.setAttribute('firstName', name);<br/>  }</span><span id="7830" class="mq lf it mm b gy mv ms l mt mu">  setLastName(name) {<br/>    backEnd.setAttribute('lastName', name);<br/>  }</span><span id="50ab" class="mq lf it mm b gy mv ms l mt mu">  getFirstName() {<br/>    backEnd.getAttribute('firstName');<br/>  }</span><span id="92da" class="mq lf it mm b gy mv ms l mt mu">  getLastName() {<br/>    backEnd.getAttribute('lastName');<br/>  }</span><span id="e49f" class="mq lf it mm b gy mv ms l mt mu">}</span><span id="46a0" class="mq lf it mm b gy mv ms l mt mu">const personAdapter = new PersonAdapter();<br/>console.log(personAdapter);</span></pre><p id="0d91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有一个<code class="fe mw mx my mm b">PersonAdapter</code>和<code class="fe mw mx my mm b">ParentAdapter</code>类而不是对象。</p><p id="710d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mw mx my mm b">extends</code>关键字从<code class="fe mw mx my mm b">ParentAdapter</code>继承成员。</p><p id="96ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们从父实体继承成员的另一种方式。</p><h1 id="0e38" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">立面图案</h1><p id="d74e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用facade模式来创建一个类或对象，以隐藏其背后复杂内容的实现。</p><p id="e4af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这用于为外部创建一个易于使用的接口，同时保留内部的复杂实现。</p><p id="b29f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4166" class="mq lf it mm b gy mr ms l mt mu">const complexProduct = {<br/>  setShortName(name) {<br/>    //...<br/>  },</span><span id="0e8f" class="mq lf it mm b gy mv ms l mt mu">  setLongName(name) {<br/>    //...<br/>  },</span><span id="23e6" class="mq lf it mm b gy mv ms l mt mu">  setPrice(price) {<br/>    //...<br/>  },</span><span id="6fd4" class="mq lf it mm b gy mv ms l mt mu">  setDiscount(discount) {<br/>    //...<br/>  },<br/>  //...<br/>}</span><span id="afc6" class="mq lf it mm b gy mv ms l mt mu">const productFacade = {<br/>  setName(type, name) {<br/>    if (type === 'shortName') {<br/>      complexProduct.setShortName(name);<br/>    } else if (type === 'longName') {<br/>      complexProduct.setLongName(name);<br/>    }<br/>  }<br/>  //...  <br/>}</span></pre><p id="3d9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了一个<code class="fe mw mx my mm b">productFacade</code>，它有一些调用<code class="fe mw mx my mm b">complexProduct</code>对象中各种方法的方法。</p><p id="7b25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以使用facade来简化我们所做的事情，并且减少与<code class="fe mw mx my mm b">complexProduct</code>对象的耦合。</p><p id="a961" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们让<code class="fe mw mx my mm b">productFacade</code>对象与<code class="fe mw mx my mm b">complexProduct</code>对象通信。</p><p id="351c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还用于减少来自复杂对象的耦合。</p><p id="2f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，一个门面也可以为一些不会像它背后的东西那样经常变化的东西创建一个接口。</p><p id="1c34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个不经常改变的界面是好的，因为更多的改变意味着更多的错误风险。</p><p id="238d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以创建一个facade类来做同样的事情，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f98a" class="mq lf it mm b gy mr ms l mt mu">const complexProduct = {<br/>  setShortName(name) {<br/>    //...<br/>  },</span><span id="fc0b" class="mq lf it mm b gy mv ms l mt mu">  setLongName(name) {<br/>    //...<br/>  },</span><span id="242e" class="mq lf it mm b gy mv ms l mt mu">  setPrice(price) {<br/>    //...<br/>  },</span><span id="edfa" class="mq lf it mm b gy mv ms l mt mu">  setDiscount(discount) {<br/>    //...<br/>  },<br/>  //...<br/>}</span><span id="6ea4" class="mq lf it mm b gy mv ms l mt mu">class ProductFacade {<br/>  setName(type, name) {<br/>    if (type === 'shortName') {<br/>      complexProduct.setShortName(name);<br/>    } else if (type === 'longName') {<br/>      complexProduct.setLongName(name);<br/>    }<br/>  }<br/>  //...  <br/>}</span></pre><p id="46c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以创建一个<code class="fe mw mx my mm b">ProductFacade</code>的实例，而不是直接使用object literal。</p><p id="f4b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个外观可以用来操作一个或多个对象。这与适配器模式不同，在适配器模式中，我们为一个对象创建一个适配器。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/04ff43d53b56b6b378ec4d506ffe127a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6UUkvk351O_s9P93"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@daniel_von_appen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·冯·阿彭</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="765e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="c804" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用适配器模式来隐藏一个对象的实现，但创建一个更容易与外部使用的接口。</p><p id="14b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">facade模式让我们可以将复杂的实现隐藏在一个接口之后，而不是使用一个或多个复杂的对象作为facade。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><div class="mh mi mj mk gt nh"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">编写面试问题</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">技术开发</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jz nh"/></div></div></a></div></div></div>    
</body>
</html>