<html>
<head>
<title>Understanding Reflection using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin理解反射</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-reflection-using-kotlin-a5874bf63010?source=collection_archive---------0-----------------------#2021-08-02">https://levelup.gitconnected.com/understanding-reflection-using-kotlin-a5874bf63010?source=collection_archive---------0-----------------------#2021-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0cd6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">几乎所有的框架或库都利用了反射的力量。了解这一点会让你成为更好的开发人员。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/67fd19e915127cc971a55127fba2ff6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfxqdwgOPniZ5rhB1PO23A.png"/></div></div></figure><p id="26c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你有没有想过依赖于基于JVM的语言(如Kotlin或Java)的库或框架是如何工作的？对我来说，这是某种黑魔法，除非我遇到了反射的想法。在像Retrofit或Kotlin-serialization这样的库中，你定义了一堆类或接口，并用一些预定义的关键字对它们进行注释，它就能在运行时完美地工作。安卓也是如此。您扩展了一些类，如Main-Activity或ViewModel，最终结果是一个正常运行的应用程序。</p><p id="bbd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，这些库如何知道你定义了什么，或者你在哪里定义的，这真的不是很明显。这些语言必须内置某种机制，允许在运行时使用静态定义的类和接口。这正是建立反射的目的。</p><p id="35d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将尝试通过一些琐碎的代码示例来揭开反射的神秘面纱。我知道你不应该总是钻研图书馆的细节。对于开发人员来说，能够理解抽象是至关重要的。尽管如此，对这些框架如何在幕后工作有一个高层次的了解，当然会增加您的开发工具箱。</p><p id="056e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">谁知道你可能会建立一个尖端的框架，解决现在存在的许多问题，在未来几年左右。</p><p id="9ef8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">免责声明:</strong> <em class="ln">请记住，大多数框架或库不会总是对所有事情都使用反射。因为与其他原始编程相比，反射是一个较慢的过程，所以框架会实现中间编译器。</em></p><h2 id="2beb" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">什么是反思？</h2><p id="ad49" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">简而言之，反射使您能够在运行时引用静态定义的类、函数或接口。发帖说可以自省一下。你可以，</p><ol class=""><li id="4cb6" class="mm mn iq kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">访问类的属性或函数，而不考虑访问修饰符</li><li id="3596" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">找出这个类中是否有任何成员用一些特殊的注释进行了注释</li><li id="2009" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">根据需要操作类/接口</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/266c8b7f6f7287d7797c25d964c15dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ArjhOfXGB5KdzlA3l1nBg.png"/></div></div></figure><p id="830c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一种巨大的力量。正如我提到的，你甚至可以操纵一个类的私有属性。所以，是的，在使用反射时你必须小心谨慎，因为它破坏了封装。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated"><strong class="ak"> <em class="nh">权力大责任大</em> </strong></figcaption></figure><h1 id="cdc8" class="ni lp iq bd lq nj nk nl lt nm nn no lw jw np jx lz jz nq ka mc kc nr kd mf ns bi translated">属国</h1><p id="9b60" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">在Kotlin项目中使用反射之前，您必须向您的<code class="fe nt nu nv nw b">build.gradle</code>文件添加以下依赖项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><h2 id="4c2b" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">行动中的反思</h2><p id="f5bd" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们将从定义一个虚拟类开始，这个虚拟类将让您体验反射。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><p id="091a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以从类名或该类的对象实例化该类本身。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><p id="7ba6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如代码片段所示，有两种方法来获取该类的引用。我们可以使用<code class="fe nt nu nv nw b">className::class</code>或<code class="fe nt nu nv nw b">objectReference::class</code>。</p><p id="de99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要获得Java等价类，你可以使用<code class="fe nt nu nv nw b">className/objectReference::class.java</code>语法。</p><p id="6efe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这些几乎相同，但是这些不同的语法产生的类型之间还是有细微的差别。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><p id="30ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么该语言的设计者决定使用两种不同的类型，即<code class="fe nt nu nv nw b">KClass&lt;T&gt;</code>和<code class="fe nt nu nv nw b">KClass&lt;out T&gt;</code>或者<code class="fe nt nu nv nw b">Class&lt;T&gt;</code>和<code class="fe nt nu nv nw b">Class&lt;out T&gt;</code>，这超出了本文的范围。</p><p id="3830" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你熟悉Kotlin在泛型中表达类型差异的方式，你可能已经明白拥有<code class="fe nt nu nv nw b">&lt;out T&gt;</code>的接口实际上是用声明站点差异实现的。如果你不知道类型变异实际上是什么，你可以稍后查看这个关于科特林类型变异的启发性图解指南。然而，您现在不必太担心类型变化。你不需要学习它来理解反射。</p><h2 id="f173" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">访问成员函数</h2><p id="f4f2" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">是时候对类引用做些什么了。让我们从简单的开始—打印该类的所有成员函数的名称。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><p id="bf3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">属性返回一个给定类的所有成员函数的列表。如果你想知道在哪里做这些方法，那我们还没有明确地声明，即<code class="fe nt nu nv nw b">equals</code> <code class="fe nt nu nv nw b">hashCode</code>和<code class="fe nt nu nv nw b">toString</code>，从这里就可以得到解释。这三个方法是在Kotlin的<code class="fe nt nu nv nw b">Any</code>类中声明的，默认情况下，所有其他类都是从这个类继承的，除非另有说明。</p><h2 id="fa6c" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">调用成员函数</h2><p id="ce93" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">这就是我们如何使用<code class="fe nt nu nv nw b">KClass&lt;out Dummy&gt;</code>变量调用成员函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><p id="2b09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里唯一要注意的是，每当我们想要使用<code class="fe nt nu nv nw b">KFunction&lt;*&gt;</code>类型的引用调用函数时，我们需要传递一个对象，该对象是使用<code class="fe nt nu nv nw b">call</code>函数时相应类的实例化。原因很简单，类只是一个蓝图，它不能独立运行。因此，需要一个对象。</p><h2 id="453b" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">调用私有函数</h2><p id="e0b2" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">到目前为止，我们只使用过该类的公共函数。然而，正如我所提到的，私有函数和属性也可以被访问，这里就是一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><p id="7fdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要访问私有函数，还有一个额外的步骤。我们需要显式地将那个<code class="fe nt nu nv nw b">KFunction&lt;*&gt;</code>变量的<code class="fe nt nu nv nw b">isAccessible</code>属性设置为<code class="fe nt nu nv nw b">true</code>。如果做不到这一点，运行时将不可避免地迎来一个<code class="fe nt nu nv nw b">IllegalAccessException</code>。</p><h2 id="e081" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">访问属性(私有)</h2><p id="b779" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">下面是如何访问该类的属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><p id="fd04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所看到的，这个过程与前面的演示非常相似。就像私有函数一样，有必要显式地使私有属性可访问。在这种情况下，属性的类型，即<code class="fe nt nu nv nw b">KProperty1&lt;out Dummy, *&gt;</code>，有点麻烦。虽然，如果你不能马上掌握它，你不必太担心。<code class="fe nt nu nv nw b">KProperty</code>型有几个针对不同属性设计的变体。你可以在 <code class="fe nt nu nv nw b"><a class="ae ny" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/" rel="noopener ugc nofollow" target="_blank">KProperty</a></code>的<a class="ae ny" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/" rel="noopener ugc nofollow" target="_blank"> Kotlin API参考中了解更多。</a></p><h2 id="00bd" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">操作属性值</h2><p id="901a" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">为了操作属性值，我们需要将属性转换成<code class="fe nt nu nv nw b">KMutableProperty</code>类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx nc l"/></div></figure><p id="46c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在所示的代码片段中，我们在getter实际访问它之前修改了属性值。因此输出是不同的。</p><h1 id="b19a" class="ni lp iq bd lq nj nk nl lt nm nn no lw jw np jx lz jz nq ka mc kc nr kd mf ns bi translated">简短的总结</h1><ol class=""><li id="804c" class="mm mn iq kt b ku mh kx mi la nz le oa li ob lm mr ms mt mu bi translated">反射使我们能够在运行时自省或操作类或接口的行为。</li><li id="5cac" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">使用反射，我们甚至可以访问用<code class="fe nt nu nv nw b">private</code>访问修饰符标记的属性和函数。</li><li id="8554" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">反射在一个库或框架中被大量使用。</li><li id="82e1" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">可以发现任何类或其成员是否被标记了一些预定义的注释，以便库或框架可以相应地动作。</li><li id="bff7" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">反思不是一个很快的过程。所以重框架或者库很少实现中间编译器。</li><li id="19ca" class="mm mn iq kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">反思给了我们巨大的力量。因此，在使用时必须非常小心。</li></ol><h1 id="4525" class="ni lp iq bd lq nj nk nl lt nm nn no lw jw np jx lz jz nq ka mc kc nr kd mf ns bi translated">总结</h1><p id="fd2b" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">我们今天就到此为止。希望你已经对反射有了基本的了解。当我们的代码使用一个框架或库时，你也有一个大概的概念。</p><p id="cecd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不过，我们不会就此结束我们的探索。在下一篇文章中，我们将构建一个简单的注释处理器。我们会定义自己的注释。最终结果将是一个伪字符串解析器，它将编码/解码JSON数据。注解和反思是齐头并进的。所以，我劝你继续关注下一集。</p><p id="fbbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">非常感谢你能坚持到现在。我真的希望你能就你的想法说几句话，✏️.</p><p id="7dc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以给我买杯咖啡来支持我的工作。☕</p><div class="oc od gp gr oe of"><a href="https://www.buymeacoffee.com/nilTheDev" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">尼兰詹🌱🌱正在写编程相关的文章</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">嘿👋我写编程相关的文章。我还是个学生。你可以请我喝杯咖啡，让我开心一天。</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.buymeacoffee.com</p></div></div></div></a></div></div></div>    
</body>
</html>