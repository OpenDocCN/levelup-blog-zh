# Vue.js 3 完整指南

> 原文：<https://levelup.gitconnected.com/vue-js-3-complete-guide-8545454f2c4a>

![](img/c4f8289b9643ec5d3981386f02969803.png)

Vue 是一个渐进的框架。进步意味着 Vue 不会寻求对整个项目的独家控制。您可以轻松地将 Vue 与其他库或现有项目集成。

Vue 帮助我们构建用户界面。有两种类型的用户界面:命令行和图形。显然，Vue 是用来构建图形用户界面的。

![](img/f81a4502b74062d0b8a8c5bbd226c174.png)

图形用户界面的专业术语是视图。它是用户查看的内容，因此被命名为视图。它是使用 HTML 和 CSS 创建的。

![](img/b3230127bcfb4a03b71b32fdf76d89c9.png)

视图的主要工作是向用户展示数据。它还从用户那里收集数据和命令。

![](img/4c26419affd04fcbccd3934594bde8f1.png)

视图只是一个 HTML 文件。它只存储有限数量的静态数据，不能永久存储用户数据。我们需要一个数据库来为视图提供和存储数据。但问题是视图不能操作数据库。

![](img/bfc8f713f54b4b3f85b70b86328f4657.png)

我们需要一个中间人。中间的人被称为模型。它指的是操作数据库的后端程序。模型的主要工作是进行 CRUD 操作。

![](img/76cd4f1b8b4add500f6a54d0613f0073.png)

CRUD 代表创建、读取、更新和删除。它们是四种最常用的数据库操作。创建意味着将新数据保存到数据库中。读取意味着从数据库中检索数据。更新和删除意味着修改或删除数据库中的现有数据。

![](img/d61700272e935aabb55efa28031a7b20.png)

我们仍然无法将视图与模型联系起来。

![](img/3ecccb8606f0dece72d9f60ec8ada01d.png)

我们需要第二个中间人，也就是控制者。控制器与双方交换数据。

![](img/741a62c943545c770aac2f36e285d103.png)

根据用户命令，控制器从模型中检索数据，并从视图中选择一个 HTML 模板。

![](img/1ece27e51f6b514f2172d4f046a50dd1.png)

检索到的数据将被注入 HTML 模板并呈现给用户。

![](img/a7b196be6a369115407936202a0eef86.png)

这种架构被称为 MVC:模型视图控制器。

![](img/c7ae54315a49097c8db58f9cad5d21f6.png)

让我们来看一个 MVC 架构的真实例子。

这是摘自 CodeIgniter 手册的一段示例代码。CodeIgniter 是一个典型的 MVC 框架。控制器在左边。右边的文件是视图文件。

![](img/fee5ddac6a80180da1ea902660261923.png)

View 函数选择一个视图文件并将数据注入其中。然后，完成的视图文件将呈现给用户。

![](img/b23c62913ed04ad443847a0649231a74.png)

MVC 开发出了一种新的架构。它叫做 MVVM。控制器已经被视图模型所取代。ViewModel 和视图通过双向数据绑定连接。那么什么是双向数据绑定呢？

![](img/ed5f14408009aa9ecf147933bd0fe943.png)

视图和视图模型是两个独立的程序。视图是使用 HTML 和 CSS 创建的。ViewModel 是一个 JavaScript 程序，能够操作 DOM 对象。

![](img/bf5b5681955b5431b7a1dfa07ef57602.png)

ViewModel 从模型端检索数据。在双向数据绑定下，检索到的数据会自动同步到视图端。

![](img/fbdeb93ffec508036551162d822e7c2b.png)

如果我们在视图模型端修改数据，那么视图端的相应数据将会自动更新。

![](img/9b6b15378ebce8b91999304e252b16f9.png)

数据是双向同步的，如果我们在视图端更新数据，ViewModel 端的相应数据也会被更新。

![](img/e18141a7f89ac913acd36d57092adc84.png)

那么如何实现双向数据绑定呢？

假设在视图模型端，我们有一个变量:城市。它的价值来自模型，我们希望通过视图向用户展示它的价值。该视图使用 HTML 标签显示数据。我们以 P 标签为例。

![](img/f00646e322b5af7b1762c7df6fec17be.png)

P 标签主要使用它的内部文本来表示数据。HTML 属性也存储数据。例如，我们给 P 标签一个标题属性。

![](img/7cc8fae6dcb0c582761f0180ac482a62.png)

我们使用 city 变量设置 P 标签的内部文本或标题属性。

![](img/3724bae53278381e8b326b1bfdf8b773.png)

我们需要城市变量是反应性的。被动意味着如果我们设置了一个新的城市名称，P 标签应该自动更新，没有任何延迟。

![](img/70225acf375d022a5000eef19dd75762.png)

知道如何实现这一点吗？

为了避免任何延迟，我们必须能够截取值分配，以便我们可以在最早的时间更新 P 标签。

![](img/72f3a48cd55887143e294e5998cf52c5.png)

setter 函数负责给变量赋值。我们定制 setter 并将 DOM 更新代码合并到其中。这样，当我们重新设置城市值时，P 标签的 DOM 对象将会立即自动更新。

![](img/3710d5676a08262a5fb718011230c960.png)

将数据从视图同步到视图模型意味着将用户数据提交到视图模型。

![](img/aa4ca71782fe6739417339b9ed670fea.png)

视图通过输入标签收集用户数据。每当我们在输入标签中输入一个字符，它就会发出一个输入事件。

![](img/efa508d4a255ed8f48ba2a5db97bb101.png)

在 ViewModel 端，我们监听输入事件，并使用回调拦截用户提交的数据。这就是数据从视图端同步到视图模型端的方式。

![](img/2292348cea7b717de91941fee8f0daf5.png)

回调可以将用户提交的值赋给城市变量。这样，输入框可以实时更新 P 标签。

![](img/ca9ceff542a312d14495eefa08727d45.png)

Vue 是使用 MVVM 架构开发的。它扮演视图模型的角色，并且还构建视图。

![](img/66089573eec1136bfab5aa352dcfc31d.png)

ViewModel 从模型中检索数据。然后，它使用定制的 setter 将检索到的内容同步到视图中。这个过程是自动发生的。我们不需要手动将数据注入视图模板。

![](img/53925b09f6e4eced0c09d01ac6fad4bd.png)

视图通过输入标签从用户那里收集数据。ViewModel 通过监视输入事件来捕获这些数据。然后，它将用户提交的数据传递给模型，以便将它们保存到数据库中。

![](img/54cc7d0d6903742ebcf28baa55514948.png)

一个视图模型与一个视图配对。ViewModel 和它的视图一起构成了一个组件。视图也称为组件模板。组件是 Vue 项目的构建块。

![](img/cb35ae86540fc58aa3745866c756a832.png)

每个 Vue 项目必须有一个并且只能有一个根组件。在根组件中，我们可以根据需要安装任意数量的子组件。每个子组件都可以有自己的子组件。

![](img/b5a6b7d8de17e822d2738757f77e67e3.png)

通过切换和重新定位组件，我们可以生成不同的虚拟页面。每个组件负责最终页面的一个部分。整个程序是模块化的。未来的维护和调整变得更加容易。

![](img/c0692127a65c4980e273692e83783a29.png)

接下来，我们来看一个现实生活中的例子。这是 Vue3 的官方手册。这个页面是使用几个组件创建的。我们在左边有一个侧边栏，在右上角有一个导航栏。在中间，我们有一个主要区域。这些部分是独立的，可以单独维护。

![](img/e5bde5c83e74d958338a1877f3f8d025.png)

在主区域中，我们有一个注释部分和一个提示部分。仔细看看这两个部分。找到相似之处了吗？

![](img/8715f43467e9065835c3a39f08d5faa3.png)

他们都有一个标题。标题下面，都有一段话。它们有相同的装饰和相同的背景颜色。

![](img/08d088a00d8cef86eb6dc744073265c8.png)

我们可以只用同一个组件创建这两个部分。我们只需要安装两次，自定义标题和段落内容。Vue 组件实际上是一个构造函数。它是预定义视图和视图模型的蓝图。

![](img/3a42ce5d286eeac5e3ef148253f55e91.png)

当我们安装一个组件时，我们实际上是在创建该组件的一个实例。组件实例由视图实例和视图模型实例组成。同一组件的实例是独立的。这使我们能够定制组件实例。

![](img/52b5be2b49228d0f23b40c616cdf546f.png)

为了保持每个组件实例的独立性，我们在定义组件时需要工厂模式。工厂模式本质上是一个返回对象的函数。每次运行工厂函数，都会收到一个独立的对象。它防止引用类型的值被共享。我们将在后面的课程中学习更多关于工厂模式的知识。

![](img/99801c2c838f313c150505cfc4a64501.png)

只有 Vue 提供了一个视图和一个视图模型。这通常是不够的。我们可以使用插件来扩展 Vue，赋予它更多的功能。VueRouter 和 VueX 是两个必备的官方插件。没有理由不去学习它们。你还需要学习至少一个 Vue UI 库，这样你才能用最小的成本创建出好看的页面。

![](img/804e1353c48062501505606919b19085.png)

以下是我们的 Vue 路由器和 VueX 指南的链接:

[](/complete-vue-router-4-guide-basics-programmatic-routing-navigation-guards-transition-effects-31b21a2f444d) [## 完整的 Vue 路由器 4 指南:编程路由、防护、过渡效果和合成 API

### 基础知识介绍

levelup.gitconnected.com](/complete-vue-router-4-guide-basics-programmatic-routing-navigation-guards-transition-effects-31b21a2f444d) [](/complete-vuex-4-guide-states-getters-mutations-actions-modules-plugins-and-composition-api-eff469c43b4f) [## 完整的 VueX 4 指南:状态、Getters、突变、动作、模块、插件和组合 API

### Vue 应用由一系列嵌套组件组成。我们在最外面有一个根组件。它有零或…

levelup.gitconnected.com](/complete-vuex-4-guide-states-getters-mutations-actions-modules-plugins-and-composition-api-eff469c43b4f) 

在上一课中，我们学习了 ViewModel 使用定制的 setter 将数据同步到视图。定制的 setter 包含了 DOM 更新代码。因此，如果我们在 ViewModel 端修改数据，视图会自动更新。Vue2 和 Vue3 在定制 setter 时采用了不同的方法。

![](img/0de51753e13918813dda766a0c7ee9d3.png)

在本课中，我们将展示 Vue2 使用的策略。在工作面试中，你经常会被要求解释 Vue2 和 Vue3 的区别。

我们这里有一个物体。它有一个属性:消息。我们首先获得 H1 标签的 DOM 对象。然后我们获取它的 innerText 属性，并将 message 属性赋给它。

现在，消息属性的值显示在 H1 标记内。但这只是一次性绑定。如果我们重置消息值，H1 标签保持不变。

![](img/21a6edfdd16371e8cf49270f2d155aba.png)

我们希望让 H1 标签与消息属性保持同步。如果我们重置消息值，H1 标签的内部文本应该立即自动更新。这就需要我们拦截消息属性的设置者。

我们使用对象点定义属性向 info 对象添加一个新属性。defineProperty 方法允许我们设置自定义的 setter 和 getter。我们将 info 对象作为第一个参数传递给 defineProperty 方法。第二个参数是新属性的名称。我们将其命名为 reactiveMessage。第三个参数是一个对象。我们在这里设置自定义的 getter 和 setter 函数。setter 函数接收分配给 reactiveMessage 属性的新值。

![](img/65dd37418ac5531d939a60632ec095b8.png)

当我们读取 reactiveMessage 属性时，getter 函数将被触发。它返回的值将被用作属性值。在这里，我们返回 info 点消息。这样，reactiveMessage 将始终返回消息属性的值。info 对象可以通过 defineProperty 方法的第一个参数来访问。

![](img/eea9836d4602d1055b99c00af96bf035.png)

当我们为 reactiveMessage 属性分配一个新值时，setter 函数将被触发。新值作为第一个参数传递给 setter 函数。我们将新值赋给信息点消息。这样，reactiveMessage 属性可以重置消息属性的值。

![](img/29f59a30ab666726754ba0fe8688adcd.png)

新的属性完成了。让我们检查 info 对象。

我们可以看到 reactiveMessage 属性已添加到其中。我们还可以从 info 对象的根级别找到它的 getter 和 setter。

![](img/6c869630be2446bd0e79d06e53421e42.png)

reactiveMessage 属性不是非常规属性。为了输出它的值，我们需要调用它的 getter 函数。

![](img/40753b3e94e56317342412ebd51fe7e5.png)

我们可以看到它的 getter 函数返回了消息属性的值。

![](img/dc36d8cf518180b412a633d7235216f8.png)

让我们将消息值设置为 apple，并再次检查 info 对象。

我们可以看到 reactMessage 的价值也变成了*苹果*。

![](img/d9b0371af9335460094bcb084053b4c2.png)

接下来，我们将 reactiveMessage 的值重置为*橙色*。该操作触发 setter 函数，该函数将*橙色*分配给消息属性。

我们可以看到消息值变成了橙色。reactiveMessage 属性也返回我们 orange，这是消息属性的当前值。

![](img/3c215f3c315189ec1920dcf4b3807a46.png)

setter 本质上是一个钩子函数，当我们给 reactiveMessage 属性赋一个新值时，它就会被触发。我们可以用它来更新 H1 标签的内部文本。我们选择 H1 标记的 DOM 对象，并使用分配给 reactiveMessage 属性的新值重置其 innerText 属性。

![](img/7f415cb1f4102563cd18c50c27e6ee93.png)

现在，每当我们为 reactiveMessage 属性分配一个新值时，就会发生两件事。H1 标签的内部文本将使用新值进行更新。那么新值将被分配给消息属性。这样，H1 标签的内部文本与消息属性保持同步。

![](img/95505f4bd216c60c94a560eac57cdc6f.png)

整个计划:

![](img/263741a1beda6ca4684e4e06623baae8.png)

reactiveMessage 属性充当 Message 属性的代理。它帮助我们检索和重置消息属性的值。我们可以在其 setter 中更新 DOM 对象。这就是 Vue2 更新 HTML 代码的方式。它使用 Object defineProperty 方法拦截 setter。

> 我知道你过去喜欢对象定义属性方法，但是我可以全心全意地支持 ES6 的一种新特性:代理和反射。

与其只为一个属性创建代理，为什么不为整个对象创建代理呢？

我们声明一个新变量，并将其命名为 infoProxy。我们通过实例化代理构造函数来设置变量值。我们将 info 对象作为第一个参数传递给代理构造函数。信息对象被称为目标对象。它是我们正在创建的代理对象的目标。

第二个参数是一个称为 handler 对象的对象。它定义了我们想要拦截和定制的操作。这个对象中的函数称为处理函数。这里，我们添加了一个 getter 和一个 setter 来拦截对代理对象属性的读写操作。请注意，getter 和 setter 只在我们读取或修改代理对象的属性时才起作用。我们直接操作目标对象，他们不会有反应。

![](img/c967ffc6572626ea7a5fb619018bbe36.png)

getter 函数有三个参数。第一个是代理的目标对象。第二个是目标属性的名称。第三个名为接收器。它指向由代理构造函数创建的代理对象。通常，我们不会需要它。

![](img/b5f231d416d47a9d61f84a3e957cdc57.png)

setter 函数接收四个参数。前两个参数仍然是目标对象和目标属性名。我们将第三个参数命名为 newValue。它存储分配给目标属性的新值。最后一个仍然是指向代理对象的接收者。

![](img/1327af859425aecff0c7b8f20672c6a1.png)

让我们输出目标对象和代理对象。乍一看，代理对象与目标对象非常相似。

![](img/8c0b580cde0b326db30bd8eb975af84a.png)

但是如果我们打开它，我们会发现代理对象是由两个对象组成的。第一个是处理程序对象。自定义处理函数存储在这里。此物品供内部使用。第二个对象是目标对象。

![](img/b7b75651209ff9c174edba4ebc37957d.png)

您在目标对象中看到的属性值可能不是您从代理对象中获得的实际值。得到什么取决于 getter 函数。

让我们通过代理对象输出消息属性。该操作将被 getter 截获。我们得到的值取决于 getter 返回的内容。当前，getter 为空。所以我们会变得不确定。setter 也是空的。如果我们通过代理给消息属性分配一个新值，这个新值将不会到达目标对象。

![](img/7ebc5486ddbdbeb6005a1d1202949139.png)

**你要明白，当你读写一个代理对象的属性时，最终结果取决于 getter 和 setter，这一点非常重要。**

接下来，让我们完成 getter 函数，这样我们就可以从代理对象中读取属性。

getter 本质上是一个钩子函数，当我们从代理对象中读取属性时就会被触发。它返回的值就是我们将获得的属性值。

与只作用于一个属性的 Object defineProperty 方法不同，代理 getter 应用于目标对象的所有属性。

目标对象的属性可以有各种各样的值。例如，我们添加一个数字属性，并将其值设置为 10。然后我们定义一个测试方法。我们在控制台中记录了这一点。

![](img/41140cf2319db66e918145bb2836890c.png)

所有这些属性和方法都将被 getter 返回。所以如果你想返回一个修改过的值，你必须首先检查属性值的数据类型。

![](img/cd00cf440e57866712a61ffc1f820daa.png)

在 getter 函数中，我们添加了一个 IF 语句。我们检查目标属性是否是字符串。如果是，我们首先返回原始属性值。然后我们用一个定制的字符串附加它。如果属性值不是字符串，我们返回原始属性值。我们不能将字符串连接到非字符串值。

![](img/d70302d4f7bbbef6e661d0a41328c111.png)

在 setter 函数中，我们做了同样的事情。

如果目标属性值是一个字符串，我们给它分配一个修改后的值。我们用一个自定义字符串作为新值的附录。对于其他值类型，我们直接将新值赋给目标属性。

![](img/6a7db6efbacb6d5badeb9ce8469d160d.png)

让我们测试这个程序。我们通过代理对象输出消息属性。这个操作触发代理 getter 函数。消息值是一个字符串，getter 函数返回一个定制的值。我们得到了原始消息值和自定义附录。

![](img/f0eca080f7b7ecd1af4009aeeb0d5456.png)

接下来，让我们通过代理对象重置消息属性。我们将苹果分配给它。

这个操作触发了 setter。消息值是一个字符串，新值*苹果*将首先与自定义字符串连接。那么新的字符串将被分配给 info 对象的 message 属性。

我们可以看到消息属性的值已经变成了由代理设置器设置的*苹果。*

![](img/01e3d49be0228cc367d5f93a7490538a.png)

如果我们从代理对象输出消息属性，它将从自定义 getter 接收第二个附录。

我们得到的消息值是代理 getter 返回的代理 setter 设置的 *apple。它有两个附录，第一个来自 setter，第二个来自 getter。*

![](img/55f849d9d0a46c13a2b518dc1a7f3038.png)

接下来，让我们通过代理对象输出 num 属性。

它的值是一个数字，getter 不会修改它的值。所以我们会得到它的初始值 10。

如果我们通过代理对象给 number 属性加 1，number 值将变成 11。

![](img/75aa44197ef9ac9cb3a3ef8cbd90852f.png)

测试方法输出它的这个。

![](img/e7e98a3f3a310a19ce998e76ef1082f8.png)

如果我们通过 info 对象调用它，它就指向 info 对象。

![](img/cc73d7f496478508a15bba3c7b048bff.png)

如果我们通过代理对象调用它会发生什么？它将指向哪里？信息对象还是代理对象？

![](img/a18667422165697688daeb0530077f67.png)

我们可以看到这个指向代理对象的点。

![](img/a9d14c393be261d1d724c25cc99ced8e.png)

在测试方法中，我们控制台记录消息属性。

如果我们通过 info 对象运行测试方法，我们将获得原始消息值。如果我们通过代理对象运行它，我们将获得由代理 getter 返回的自定义值。

![](img/f7a38d5451c90e70990453f48f5e73b7.png)

有没有发现 getter 函数有问题？

我们只定制字符串类型的值。但是我们需要返回两次。如果我们设置更多的自定义值，那么我们需要几个 return 语句。

![](img/0e413fe57620be37fe828f66b54b208f.png)

为了解决这个问题，ES6 提供了反射对象，它是代理对象的助手。它具有与代理处理程序对象相同的方法。我们在代理处理函数中安装反射方法。例如，在代理 getter 函数的最后，我们返回反射 get 方法。

我们需要将 getter 函数的参数传递给 Reflect 方法。最简单的解决方案是直接在 Reflect get 方法中传播 arguments 变量。这样，getter 函数的参数会自动传递给 Reflect get 方法。实际上，Reflect get 方法只需要前两个参数。

![](img/25a5fa442c88409d31f64f7cbc131f8e.png)

Reflect get 方法返回目标属性值。这就是为什么它需要访问目标对象和目标属性名。

要返回自定义值，我们只需将修改后的值赋回目标属性。不再需要 ELSE 部分。在 IF 部分，我们删除关键字 *return* ，并将修改后的值赋回目标属性。我们只需要在 getter 函数结束时返回一次。相比之下，getter 函数看起来干净多了。

![](img/806beb8396b4e0b3c3f7dac4652f1c3d.png)

在 setter 函数的末尾，我们添加了 Reflect set 方法。我们仍然把自变量分布在其中。

![](img/605b31d608b5437cffc458ec11a3bd17.png)

反射集方法的作用是将 newVal 参数赋给目标属性。

![](img/8d2b6ad34a49ed2f44fd2d87ec578b49.png)

为了自定义分配给目标属性的值，我们将修改后的值重新分配给 newVal 参数。**将修改后的值赋回 newVal 参数**非常重要。不再需要 ELSE 部分。在 IF 部分，我们将自定义值赋回 newVal 参数。

![](img/dddfd2acace5b3e4d5b4ca32042a8e13.png)

现在，setter 完成了。让我们刷新页面并测试程序。

我们先测试吸气剂。我们输出消息属性。我们得到了修改后的消息值。

![](img/8d99923687d37386239c5053677f8032.png)

如果我们输出 number 属性，我们将得到它的原始值。只会修改字符串类型的值。

![](img/2053f4e7756b7560e27e91cb79a35412.png)

接下来，让我们试试二传手。

我们通过代理对象将*苹果*分配给消息属性。字符串类型的值将被修改。所以*苹果*不会是消息属性实际接收到的。

让我们输出 info 对象。我们可以看到消息值是由代理设置器设置的*苹果。*

![](img/01528591f802de21d756ccc4679b463d.png)

接下来，我们将数值加 1。我们可以看到数值变成了 11。

![](img/847ec9cd0c2e1f6769d178d9b0c8830f.png)

在 setter 函数的末尾，我们选择 H1 标签的 DOM 对象，并使用 newVal 参数重置其内部文本。

![](img/b713d5d92783fe3c0e39cc0eeb1e3399.png)

现在，如果我们通过代理对象重置消息属性的值，H1 标签将使用自定义值自动更新。

这就是 Vue3 构建双向数据绑定的方式。它通过创建一个代理对象来截取并重新定义 setter 和 getter。我们通过目标对象的代理来操作它。

![](img/fcff444467b644653576beed741cd923.png)

在创建我们的第一个 Vue 3 程序之前，我们需要学习两种设计模式:单例模式和工厂模式。这两种模式都被 Vue 使用。

![](img/c2d16f74da8172d55770d5a6fed809db.png)

我们将从单例模式开始。

首先，我们声明一个变量。我们将其命名为 info，并为其分配一个对象。在对象内部，我们定义了一个城市属性，并将其值设置为 London。我们将这个对象命名为城市对象。

对象、数组和函数都是引用类型的值。与数字或字符串等原始值不同，我们通过引用类型值的内存地址来访问它们。info 变量实际存储的是 city 对象的内存地址。

![](img/3504c6f8cdafefc8cf4edf80ab7abfd3.png)

接下来，我们声明一个新变量。我们将其命名为 instanceA，并将 info 变量赋给它。然后我们声明另一个变量。我们将其命名为 instanceB，并为其分配 info 变量。

![](img/ff2d6abf965f278535b0ba23844e6cf4.png)

现在，城市对象的内存地址存储在三个变量中。换句话说，我们可以通过三个变量来访问和修改城市对象。

![](img/bf9f55c88c9c66677c4ea4c8bc246f0a.png)

我们通过 instanceA 重置城市名。InstanceA 和 instanceB 指向同一个对象。因此，它们将总是返回相同的值。

![](img/4a4a8962e0f40e67d9086dc9b91c9291.png)

我们可以看到 instanceB 返回了新的城市名称。

同样，如果我们通过 instanceB 重置城市名，instanceA 将返回新的城市名。

![](img/c79e0ad3a99aa9b18ea18642c71bf1f4.png)

城市对象同时由 instanceA 和 instanceB 控制，这是单例模式的典型场景。一个引用类型值被几方共享。它们从同一个引用类型值中读取和写入。**单例模式保证了数据的一致性。**各方将始终访问相同的值。

接下来，让我们试试**工厂模式**。它返回给我们与相反的**结果作为单例模式。**

我们创建了一个函数。我们称之为信息工厂。在里面，我们返回一个对象。在返回的对象中，我们设置了 city 属性，并将其值也设置为 London。

返回的对象是在工厂函数中定义的。每次我们运行工厂函数，它都会返回一个新的对象。换句话说，每次我们运行工厂函数时，都会收到一个新的内存地址。

![](img/ece78c9337e9221755f7f7af89c35e85.png)

我们将工厂函数的调用分配给 instanceA 和 instanceB。

![](img/b2af279935440d618892f30d8af4a217.png)

让我们输出它们。似乎这两个变量返回给我们两个相同的对象。但是这两个物体是不一样的。他们只是看起来一模一样。

![](img/cf410aa84db7a2d39b99b0ac7cb0784e.png)

如果我们通过 instanceA 重置城市名，instanceB 不会受到影响。同样，如果我们通过 instanceB 重置城市名称，instanceA 也不会受到影响。

![](img/e3f7af533ea1a1dccdd29f712de6b1a6.png)

InstanceA 和 instanceB 指向两个独立的对象。它们之间没有联系，这意味着它们不会互相干扰。

总之，单例模式保证了数据的一致性，因为只有一个数据副本。每个人都在同一个副本上工作。工厂模式保证了数据独立性。每个人都有自己的副本，并且只使用自己的副本。无法保证数据的一致性。

在你以后的 Vue 研究中，这两种模式都是需要的。有时，我们需要保证数据的一致性，而有时，数据独立性是优先考虑的。

在本课中，我们将创建我们的第一个 Vue 3 应用程序。为了让你更容易，我们将创建一个虚拟程序。本课的主要目的是向您介绍真正的 Vue3 程序是什么样子的，并让您对后面的课程有一个大致的了解。

![](img/f0ed1791d15f591d31746fbe3b1feba7.png)

首先，我们需要一个空的 HTML 文件。

我们添加一个脚本标签来链接 Vue3 的源代码。这个 CDN 地址是 Vue 3 官方手册提供的。全局 API 名称是 Vue。第一个字母 V 应该大写。然后我们添加第二组脚本标签。这是我们定义 Vue 程序的 ViewModel 部分的地方。

![](img/d9dd9c56c8e3e29e8c5375fd3e0c8136.png)

我们需要启动一个新的 Vue 程序的方法是 createApp 方法。我们通过全球 API Vue 访问它。createApp 方法将一个对象作为其参数值。这个对象称为 options 对象。options 对象是我们定义 Vue 数据属性和帮助我们处理数据的 Vue 方法的地方。Vue 生命周期挂钩和观察器也在这里定义。

![](img/17f3d534dea0050f8d8ae29ac3093e8d.png)

watcher 只是一个特殊的钩子函数，当 watched Vue 属性的值改变时会自动触发。最后两项特别重要。它们支持预定义代码的自动执行。在接下来的课程中，你会学到更多这方面的知识。

![](img/47b5584f1423cf738eb106e69c2c737c.png)

createApp 方法返回 Vue 应用实例。app 实例有一个 mount 方法。该方法将 Vue 应用程序实例连接到页面元素。

![](img/2623e8431bec3ee0b4a84e17f349e3e2.png)

我们创建一个 DIV 并给它一个 ID。我们将其 ID 值设置为 VueApp。在 Head 区域，我们添加了 style 标签来定义 CSS 代码，这些代码对嵌套在 VueApp DIV 中的元素进行样式化。CSS 代码和 VueApp DIV 一起构成了视图。

![](img/a04952d734c6519b6438b0bdc1c818db.png)

我们将 DIV ID 传递给 mount 方法。一旦 Vue 应用程序实例被安装到页面元素上，ViewModel 就被创建了。

![](img/9b27c7fe7bba7403b953bc1e00bf3109.png)

ViewModel 及其视图构成了根组件。VueApp DIV 被称为根组件模板。

![](img/ca62a23c4e290dd53a4e20fd1d8b7619.png)

接下来，让我们看看根组件是如何管理它的模板的。我们在 VueApp DIV 中添加了一个 H1 标签。

![](img/79110ce6eb4b70ada3f072b7b51e1e32.png)

开始和结束 H1 标签之间的文本称为内部文本。我们可以使用文本模板控制 H1 标签的内部文本。

文本模板是使用两个嵌套的花括号创建的。它被称为小胡子标签。它创建了一个可访问 Vue 数据属性的范围。我们将在以后的课程中了解更多。

![](img/48ee7bc8b7c71f7abd0cd84d7d49ad10.png)

除了内部文本，HTML 标签还使用其属性存储信息。

Vue 指令是 HTML 属性的 Vue 等价物。它们安装在 HTML 标签中。Vue 指令可以与指令值成对出现。我们使用等号将它们连接起来，就像本地 HTML 属性一样。在指令名和值之间，我们可以添加一个指令参数。指令参数和名称使用冒号连接。总之，一个 Vue 指令最多可以存储三条信息。

![](img/b9f2031de578893ac97f0f0b8a6f27be.png)

Vue 还可以控制原生 HTML 属性。但是事情比你想象的要复杂。我们将在后面的课程中向您展示细节。

接下来，让我们分离出只属于根组件的代码。

![](img/386ee553fa0ea50a4ae4854f5ba1143d.png)

总之，这些代码可以分为三个部分。

第一部分是风格部分。CSS 代码存储在这里。第二部分是模板部分。它存储 HTML 代码。最后一节是脚本部分。定义视图模型的 JS 代码存储在这里。

![](img/c939946b3c8b8b01fcb414b4a7e149e2.png)

如果我们能把这三个部分放在一个文件里，那就太好了。这样，一个 Vue 组件使用一个专用文件来定义。程序维护会容易得多，因为组件需要的所有东西都存储在同一个文件中。

Vue 的开发者也想到了这一点。Vue 支持一个称为单文件组件的特性。使用一个点 vue 文件定义一个组件。

![](img/f01a12ab0c108785820d99eebe5f7d6d.png)

dot vue 文件由三部分组成:模板、脚本和样式。如果我们将 scoped 属性添加到 style 标签中，那么 style 标签中的所有 CSS 代码只适用于当前组件的模板。

![](img/e9235a7b1f3f81e4315a386157a7b0d9.png)

当然，这样的文件不能单独工作，也不能被浏览器处理。

我们需要一个脚手架工具来帮助我们建立一个开发环境。我们还需要一个捆绑器将所有的点 Vue 文件和 Vue 源代码合并成一个 JavaScript 文件。

官方的安装和捆绑工具是 VueCLI。我们将在以后的课程中学习。它是高度自动化的，基本上开箱即用。

![](img/d20f2cd80053d3357322fedf604f0cbe.png)

在我们的 Vue 研究的开始，我们的 Vue 程序将看起来像这样。

![](img/43d46747d550da34da39acb967fdcdc6.png)

这是一个带有两个脚本标签的 HTML 文件。第一个链接的是 Vue 源代码。第二个是我们定义自己的 Vue 代码的地方。

在我们学习了关于 Vue 的所有基础知识并理解了 Vue 的工作原理之后，我们将向您展示如何使用 Vue CLI 并使用单个文件组件开发 Vue 项目。

在这一课中，我们将创建我们的第一个 Vue 3 程序。

![](img/dd35521a3054ee9cff20d1499d253661.png)

您所需要的只是一个空的 HTML 文件。我已经通过 CDN 链接了 Vue 3 的源代码。

![](img/a9fdde40810b05244b681cbabb9c3f83.png)

全局 API 名称是 Vue。第一个字母 Vue 需要大写。我们在控制台上输出它。我们得到了一个有很多方法和属性的对象。

![](img/bb1d2980c5073a27b6a74f18c91afa31.png)

一直滚动到最后，我们会找到一个名为 version 的属性。它告诉我们正在使用的 Vue 的版本。确保您的版本是 3。

![](img/826ac7290bba31f52bfefc2adb207789.png)

在 Vue 2 中，全局 API Vue 是一个构造函数。我们实例化它来启动一个新的 Vue 程序。但是在 Vue 3 中，你不能再实例化 Vue 了。Vue 现在是一个对象，而不是一个构造函数。我们使用它的 createApp 方法来启动一个新的 Vue 程序。

![](img/efe6b09b031fd6921ca1938de5dbcac4.png)

我们添加了另一个脚本标签来定义我们自己的 Vue 代码。

我们通过 Vue api 调用 createApp 方法。我们传递一个对象给它。这个对象称为 options 对象。我们用它来定义 Vue 组件。其中的属性称为选项。

createApp 方法向我们返回应用程序实例。我们将它保存到一个名为 app 的变量中。

![](img/7225a09c7aef79defca4ca94595efaf5.png)

让我们输出 app 变量。

app 实例也为我们提供了一些方法和属性。挂载方法是我们下一步操作所需要的。

![](img/d9ad1b527cf06ac7988ec394b659a568.png)

我们通过 app 实例调用 mount 方法。mount 方法将应用程序实例挂载到页面元素。

![](img/d1a8ecc2f14b538f4bb4d8fae93abbd6.png)

在 H2 标签下面，我们添加了一个 DIV 并给它一个 ID。确保 DIV 不完全为空。空行就可以了。然后，我们将 DIV ID 传递给 mount 方法。

一旦应用程序实例被装载到页面元素，它就成为根组件。根组件的实例对象由 mount 方法返回。我们将它保存到一个名为 VM 的变量中。

![](img/8d8b90ae1b938e9eb244d1c00a68de75.png)

让我们刷新页面并输出 VM 变量。我们得到一个代理对象。在 Vue 3 中，所有组件实例都是代理对象。

![](img/d77df3de978f41af2b0f9b73e0f20526.png)

打开它的目标对象，我们可以找到几个属性，它们的名字都以美元符号开头。每个属性都有一个 getter 和一个 setter。美元符号前缀意味着该属性是由 Vue 内部创建和使用的内置属性。

使用传递给 createApp 方法的 options 对象，我们可以将自己的自定义属性添加到组件实例中。

![](img/7413a1d892407831763be3951862e0df.png)

美元符号数据属性是存储所有数据属性的地方。目前，它是一个空对象。一旦我们定义了数据属性，它也将成为一个代理对象。

![](img/1eb8e229965c211a5fcc8bc105135e14.png)

美元符号 EL 属性指向组件实例管理的根 DOM 元素。这也是 VueApp DIV 不能完全为空的原因。美元符号 EL property 肯定有所指。目前，它指向 19 行的空行。

![](img/a7dde5b18ad4c8833fdf18766992f592.png)

我们将 H2 标签移动到 VueApp DIV 中。H2 标签是 VueApp DIV 中的唯一元素，它的 DOM 对象将由美元符号 EL 属性返回。

![](img/9f717e267b6e535d2c6d5be4bc5aabfb.png)

美元符号 EL 属性的问题是它只能指向一个页面元素。Vue 3 不再要求每个组件必须有一个根分区。如果我们在 VueApp DIV 中添加另一个 P 标签，美元符号 EL 属性就不能同时指向 H2 标签和 P 标签。它只是返回一个占位符 DOM 节点。

![](img/3d01f80f0e33a8e34ede62b3d2b8a854.png)

在实际项目中，避免使用美元符号 EL 属性访问任何页面元素。还有其他方法可以做到。我们将在后面的课程中向您展示如何操作。

接下来，让我们在 options 对象中设置第一个选项:数据选项。

![](img/2199a3614cb3b47b0cf46f5ad53535bd.png)

我们给数据选项分配一个对象，看看会发生什么。

![](img/bac2ec1df06e2c356589985a7142225e.png)

我们得到一个警告和一个错误。从 Vue3 开始，所有数据选项都必须使用工厂模式定义，包括根组件的数据选项。

![](img/442f2c879b5467873afeab59c33ec49d.png)

我们为数据选项分配一个完整的函数，并在其中返回一个对象。数据属性在返回的对象中定义。我们定义一个消息属性，并给它分配一个字符串值。

![](img/e39d55ca411f8e928ce80a08ba97a7c6.png)

让我们检查根组件实例。我们可以看到消息属性已经被添加到根组件实例的根级别中。

![](img/28b51018c8d8cef6c528b4724aa141fc.png)

您在根级别找到的消息属性只是一个别名。真实消息属性存储在美元符号数据属性中。数据属性及其别名始终保持同步。它们总是输出相同的值。

如果我们改变一个别名值，相应的数据属性将被更新。同样，如果我们改变一个数据属性的值，它的别名将自动重置。

美元符号数据的值已经成为一个代理对象。消息属性存储在其目标对象中。

![](img/a708ef9a7354649a88857e3e9d270d3a.png)

现在我们已经创建了一个数据属性，如何将它的值呈现给用户呢？

VueApp DIV 由根组件控制。可以在 VueApp DIV 中访问根组件的数据属性。

让我们先来看看一个原生 HTML 标签是如何向用户呈现数据的。我们将以 H2 标签为例。

![](img/151357ecaa4e8f3a022f4ac8aaf0c0f7.png)

H2 标签向用户呈现一段文本。这段文本是 H2 标签的内部文本。除了内部文本，H2 标签还在其标题属性中存储信息。当然，您也可以使用其他属性。

![](img/9374afa997597fcf48ef0954fe8e6d57.png)

我们可以使用 Vue 数据属性设置内部文本和属性值。我们将从内部文本开始。在下一课中，我们将向您展示如何设置属性值。

我们清空 H2 标签，并在其中添加两个嵌套的花括号。

![](img/bbce0163d27ff53b13eb808d5ac02cec.png)

这两个嵌套的花括号被称为 mustache 标记。mustache 标签创建了一个文本模板，我们可以在其中定义一个 JS 表达式。表达式值将被用作 H2 标签的内部文本。

例如，我们在 mustache 标签中放了一个比较表达式。我们比较 10 和 5。比较结果为 true，因此 true 将作为其内部文本显示在 H2 标签中。

![](img/ab36faa3f15773b2575ac216f924b95d.png)

mustache 标签可以访问内置的 JS 对象。例如，我们可以在其中实例化日期构造函数。当前日期和时间将作为内部文本显示在 H2 标签中。

![](img/396b7dcbaeff6ad3fa3dfe5cae9d6249.png)

mustache 标签不能访问窗口对象。您不能控制台日志或警告任何东西，因为这些方法来自窗口对象。

我们可以看到我们得到了两个警告和一个错误。Vue 项目也被关闭了。

![](img/f66f7e71073850e10486d208e013ddce.png)

mustache 标签可以直接访问组件实例的根级别。我们可以在这里输出美元符号数据属性。仅属性名称就足够了。不需要前缀。

![](img/3c58580dc3b6382d4454f92cbd5e5050.png)

为了访问消息属性，我们在消息中附加了美元符号数据。

![](img/ea954b9a946c635c50042f3efbcd8cd7.png)

我们也可以使用消息属性的别名。别名存储在组件实例的根级别中。我们可以跳过美元符号数据前缀。

![](img/36fabaaf3a1a118235d75e0a9cf370af.png)

Vue 数据属性都是反应性的。如果我们重置消息属性的值，H2 标签将自动更新其内部文本。

![](img/1f6c4c456b2985f747bd1af8750cdca5.png)

在将消息属性的值呈现给用户之前，我们可以进一步处理它。例如，我们可以用 toUpperCase 方法附加它。用户现在将看到一个完全大写的消息值。

![](img/f54b3fc92672a04e4815c37048537c5c.png)

在您的实际项目中，mustache 标记应该尽可能简单，最好只包含 Vue 属性名。所有数据处理代码最好保存在 options 对象中。

我添加 toUpperCase 方法的原因是为了强调 mustache 标记创建了一个我们可以定义 JS 表达式的范围。它不仅仅是一个用于设置数据属性名称的插槽。

Vue 数据属性还可以存储引用类型的值，并保证它们的反应性。我们创建一个名为 list 的属性，并为它分配一个数组。然后我们创建另一个属性，并将其命名为 car。我们给它分配一个对象。

![](img/b0a4f79f318ad2e9384bc207fc69a1a6.png)

让我们检查根组件实例。car 和 list 属性的别名已添加到组件实例的根级别中。打开美元符号数据属性，我们可以找到汽车并列出属性。

![](img/518a0fbedfbb5b45acd40b31d2540663.png)

组件实例是一个代理对象。您在它的目标对象中看到的值可能不是最终的输出值。list 属性是目标对象中的一个数组。但是当我们输出它的时候，它会被转换成一个代理对象。这同样适用于汽车对象。它也将被转换成一个代理。

![](img/a3ca93de12d5ac2ef4518a0b98f96fbf.png)

Vue 进行这种转换的原因是为了使引用类型的值具有反应性。我们将在后面的课程中学习更多关于 Vue 反应性的知识。

数组代理的行为与普通数组相同。我们可以使用 length 属性检查元素总数。所有与数组相关的方法都使用数组代理对象。

![](img/26ac8d16f5624f70ced10d1416ee8ea1.png)

对象代理的工作方式与汽车对象相同。我们可以通过属性值的名称来检索属性值。

![](img/a0f5dff56de35156c0333a7dbd0ed006.png)

在 mustache 标记中，我们显示了列表数组的第一个元素和汽车对象的 brand 属性。

![](img/f76b451afa3329e4a969a4e869ab7699.png)

然后我们重置列表数组的第一个元素。我们可以看到模板已经自动更新。如果我们重置品牌价值，模板也会更新。

![](img/22139ba4dbd68fa8c692c1de6b750bda.png)

Vue 3 已经引入了设置功能。setUp 函数返回一个对象。返回对象中定义的属性将被添加到组件实例的根级别。

我们定义一个城市属性，并将其值设置为伦敦。顺便说一下，你应该随时随地避免命名冲突。设置功能中的属性不应与数据选项中定义的属性相同。

![](img/26b3ca6d9889dd38eb3525a05078e35a.png)

我们输出 VM 变量。city 属性已经添加到组件实例的根级别中。但是您不会在$data 对象中找到它，因为它是**而不是**一个数据属性。

![](img/86d6f75f4003063597fe813a61d05a02.png)

被添加到组件实例的根级别使得 city 属性在组件模板中可见。我们可以使用它的名称在 mustache 标签中显示它。

现在，城市名称显示在 P 标签中。

![](img/fc8fd7570c8e9151ac5bc9ce0274f187.png)

如果我们给 city 属性分配一个新值，模板不会自动更新。城市财产还没有反应。稍后我们将了解更多关于 setUp 函数的内容，包括如何使 city 属性具有反应性。

![](img/2dfb7ccc7ff2a12eb38a5fa29022504e.png)

我在这里向您展示设置功能的原因是为了强调两点。

第一个是数据选项不是将属性添加到组件实例的根级别的唯一方法。换句话说，并不是组件实例的根级别中的每个自定义属性都是数据属性的别名。

第二点是来自组件实例根级别的定制属性并不总是反应性的，但是它们保证在组件模板中是可见的。

HTML 标签也在其属性中存储信息。例如，H2 标签有一个标题属性。那么 Vue 是如何控制 HTML 属性的呢？

解决方案是使用 v bind 指令。我们使用 v bind 指令作为 title 属性的前缀，并用冒号将它们连接起来。

![](img/4c323dd2dd49239ae6ae55cc582f6517.png)

Vue 指令是虚拟的 HTML 属性。它们被安装在 HTML 标签中。v bind 指令是最常用的 Vue 指令之一。

当我们用 v bind 指令作为 title 属性的前缀时，一切都变了。让我们刷新页面，看看会发生什么。

我们得到一个警告和一个错误。现在无法识别原始属性值。

![](img/d980126bf2674ba1dc4149fe69ef2c66.png)

一旦我们用 v bind 指令作为 title 属性的前缀，原来的属性值就变成了 Vue 指令值。它不再是字符串了。

原来的标题值现在被认为是两个 Vue 属性名，不再是一个字符串。我们当前的 Vue 程序在这两个名称下没有属性。这就是我们得到警告和错误消息的原因。

Vue 指令值实际上是一个作用域。我们可以在其中定义一个 JS 表达式，表达式的值将被用作最终值。例如，我们在指令值中比较 10 和 5。比较结果为真。因此标题值将被设置为 true。

![](img/93a2d558eea267b81b6882b39abdadfc.png)

我们也可以在范围内实例化日期构造函数。当前日期和时间将被设置为标题属性的值。

![](img/99dd13fe17f49f28bbf60d286674f2c0.png)

窗口对象在这里不可用，所以不要尝试控制台日志或更改任何内容。

![](img/de622ad8231a3a2500e78b4a37d3a47a.png)

Vue 指令值为我们提供了对组件实例根级别的直接访问，就像 mustache 标签所做的那样。

Vue 属性在指令值中可见。这里，我们将 title 属性赋给 v bind 指令。

![](img/db2f925eb497885cb47663839e8dbf00.png)

让我们刷新页面。title 属性的值现在已经分配给了 H2 标签的 title 属性。

![](img/0d6344a2af90ee2aa490fa9789f197e7.png)

理解指令值是一个作用域，而不仅仅是 Vue 属性名的位置，这一点非常重要。我们可以在其中定义一个 JS 表达式。例如，我们用 toUpperCase 方法附加 title 属性。

现在，将使用 title 属性的大写值来设置 H2 标签的 title 属性。

![](img/97b4ef5d072c761b720d743b8811d538.png)

在您的实际项目中，最好还是**保持指令值尽可能简单**。建议您仅使用**的一个 Vue 属性**设置一个指令值。数据处理代码最好放在 options 对象中。本建议适用于所有 Vue 指令。

对于一些 HTML 标签，v bind 指令是它们使用 Vue 的唯一方式。

例如，我们添加一个输入标签。输入标记没有内部文本。它依靠它的值属性来工作。

![](img/c8ea3f4a94649780b05a7980ecebc657.png)

v bind 指令使我们的 Vue 程序能够控制输入标签的 value 属性。我们用 v bind 指令作为 value 属性的前缀。v bind 指令可以简称为冒号。我们使用消息属性设置指令值。

现在，消息属性的值将显示在输入框中。

![](img/549851e71de30cc637a5f2636d2dba36.png)

如果我们修改 message 属性的值，输入框中的文本会自动改变。

![](img/d3f15018483a3059f8d5ed785c93c609.png)

接下来，我们来澄清一些可能的误解。

vue 指令由三部分组成:指令名、指令参数和指令值。指令名和指令参数用冒号连接。

任何 HTML 属性，一旦以 v bind 指令为前缀，就不再是 HTML 属性。它成为 v bind 指令的一个参数。

v bind 指令有意将其参数命名为与原生 HTML 属性相同的名称。这样做是为了降低用户的学习障碍。

我们来证明一下这个说法。我们将禁用的属性添加到输入标签中。disabled 属性禁用接收它的元素。

![](img/3c343ab9c45bbdf4ad583d493bed1569.png)

*禁用*属性比较特殊。它不接受任何值。要禁用输入框，只需将 *disabled* 属性添加到输入标签中。要打开一个禁用的输入框，您需要删除*禁用的*属性。

将*禁用的*属性赋值为 false 将不起作用。输入框仍处于禁用状态。

![](img/1be0b42fc10c6eecf755f1b3b42a931a.png)

让我们用 v bind 指令作为 *disabled* 属性的前缀，看看会发生什么。

![](img/24a95438b8a5e0a4b01805c175407f4a.png)

输入框再次被启用。

![](img/3b1dd8a707f0d78efc976effcdf9938b.png)

这证明了一旦以 v bind 指令为前缀，*禁用的*属性就不再是 HTML 属性。它成为 v bind 指令的一个参数。否则，将它赋值为 false 不会起作用。

如果指令值为 false，Vue 不做任何事情。呈现的输入标记不会接收禁用的属性，因此可以接受用户提交的数据。如果指令值为 true，Vue 会将禁用的属性添加到呈现的输入标记中。因此，输入框被禁用。

理解 v bind 指令不仅仅是为现有的 HTML 属性赋值，这一点非常重要。它实际上呈现了整个 HTML 属性。它的参数决定了将呈现哪个 HTML 属性。它的值将被用作呈现的属性值。如果呈现的属性不接受任何值，就像我们刚刚展示的禁用属性，那么指令值决定属性是否将被呈现。

![](img/811534f9282835a35c051210756cf991.png)

在这一课中，我们将讨论条件渲染。Vue 为这项工作提供了四个指令:v show、v if、v else 和 v else if。

最后三个指令一起工作。v 秀单干。它不适用于 v else。请记住这一点。

条件呈现，就像它的名字所暗示的那样，意味着基于一个条件来呈现元素。

我们这里有两个 P 标签。第一个说*吃你的蛋糕*，第二个说*吃你的蛋糕*。显然，我们不能鱼和熊掌兼得。所以一次只能显示一个 P 标签。

![](img/9b0dc60dd81a515d9852a95e488c002a.png)

在第一个 P 标记中，我们添加了 v show 指令。不需要任何指示性参数。我们将指令值设置为 true。

![](img/2629da7911da385901f554a5b8ebce68.png)

让我们运行文件。

![](img/8387be7d4d74b22bf3b216ba5732dcd1.png)

两个 P 标签都正常显示。

接下来，我们回到 v show 指令，将其值从 true 切换到 false。

![](img/cf0021e2af6f6410971e6a0fc93e7972.png)

这次，我们只有第二个 P 标签。第一个 P 标签没了。但是在呈现的 HTML 文件中，第一个 P 标签仍然存在。它只是隐藏了它的 CSS 属性*显示*设置为无。

![](img/9660f41949be4da092ef224c09e4a8c7.png)

接下来，我们创建一个新的数据属性。我们将其命名为 *have* ，并将其值设置为 false。然后，我们将 *have* 属性分配给 v show 指令。

我们复制了 v show 指令，并将其粘贴到第二个 P 标记中。我们在 *have* 属性前面加上感叹号来反转它的值。这样，两个 P 中的 v show 指令总是接收相反的值。因此，一次只能显示其中一个。

![](img/ff8b0b3e0b4760de6a79d40636e4cbee.png)

默认情况下，显示第二个 P 标记。我们将*的属性设置为 true。现在，第一个 P 标签出现了。第二个已经藏起来了。*

![](img/409885aff8f36dfc750b6fc2de128a32.png)

接下来，我们将两个 v show 指令切换到 v if 指令。

好像结果和以前一样。当我们第一次加载页面时，显示的是第二个 P 标签。

![](img/fdbf615462df455023262bbd47f0b02b.png)

在我们将 *have* 属性的值反转为 true 之后，第一个 P 标签出现，第二个消失。

![](img/69c2fd96c92e1578cf29acedae3632ee.png)

让我们检查 HTML 代码。与 v show 指令不同，v if 指令直接从 HTML 文件中删除隐藏元素。

![](img/116166cd76d2f0e893aa3afd4f9a4d52.png)

现在你知道 v show 指令和 v if 指令的区别了。V show 通过将元素的 *display* 属性设置为 none 来隐藏元素。V if 指令直接从呈现的 HTML 文件中删除 an 元素。

第二个 v if 指令可以替换为 v else 指令。不需要指令参数或值。结果和之前一样。一次只显示一个 P 标签。

![](img/a9af449d12b9605eb8f6066c553901cd.png)

v else 指令不能单独使用。这取决于安装在前一个元素中的 v if 指令。在 v if 指令和 v else 指令之间不能有额外的元素。否则，v else 指令将不起作用。

![](img/0af737fa30a18524d76e38f2a286706a.png)

接下来，我们创建一个新的数据属性。我们把它命名为水果，把它的价值设定为苹果。

然后我们添加一个 UL 标签来创建一个列表。我们添加一个 Li 标签，并在其中显示苹果。然后我们添加另一个李标签，并在其中显示*其他*。

![](img/9b64478c270d3c638f945d9b00bb3a2e.png)

在第一个 Li 标签中，我们添加了 v if 指令，并使用比较表达式设置了它的值。我们用苹果比较果实性状。在第二个 Li 标记中，我们添加了 v else 指令。

fruit 属性的默认值是 apple，因此比较表达式返回 true。结果，第一个 Li 标签被显示。

![](img/a81da61bfad94d8a3a345c9e18403368.png)

接下来，我们添加另一个 Li 标签并在其中显示 orange。

![](img/763b7c7da8b5c828d57748b468e42aee.png)

我们这里有个问题。使用 v if 指令和 v else 指令，我们只能切换两个页面元素。现在我们有三个列表项。我们做什么呢

我们将 *v else if* 指令添加到中间元素中。我们将水果的特性与橘子进行比较。

![](img/d7625652bcc9341e6e5dfe7bfb028dfc.png)

您可以根据需要添加任意多的 v else if 指令。只要确保它们的值都不同。您需要确保在 v if、v else if 和 v else 指令之间没有额外的元素。v else if 指令必须安装在 v if 指令和 v else 指令之间。

在这节课中，我们将学习一个非常有用的开发工具:ref 属性。在下面的课程中，我们将经常使用 ref 属性。它帮助我们更好地理解 Vue 是如何工作的。

![](img/86c05147ebcb67bf6b359b9ffd63d5bb.png)

您可以将 ref 属性视为 HTML 元素 ID 的 Vue 等价物。它是一个唯一的标识符，帮助我们检索页面元素。

参考值由我们设定，并且必须是唯一的。ref 值也称为参考 ID。ref 属性由 Vue 内部使用，不会出现在最终呈现的 HTML 代码中。

ref 属性帮助我们访问所选模板元素的 DOM 对象。由 ref 属性检索的 DOM 对象由美元符号 refs 属性存储。该属性是内置属性，所有组件实例对象都具有该属性。

![](img/68288d6c35557474702b0ae58835fb26.png)

在后面的课程中，我们将学习如何使用子组件。我们可以使用 ref 属性来访问子组件实例。访问子组件实例实际上是 ref 属性的主要应用。

让我们检查美元符号 refs 属性。目前，它的值是一个空对象。这是因为我们还没有为任何元素设置任何 ref 属性。

![](img/2d8eb4909630799ae0ff03e1a6a69367.png)

我们转到 H2 标签，并在其中设置 ref 属性。我们还给 H2 标签一个 ID。在下面的 P 标签中，我们做同样的事情。我们给它一个引用和一个 ID。

![](img/0bc1459019245ee61d50e7badf1f5737.png)

我们刷新页面并再次检查美元符号引用对象。

这一次，它的值变成了代理对象。代理目标对象有两个属性:消息和标题。

这两个属性名与我们在 H2 和 P 标签中设置的 ref 值相同。属性值是 H2 和 P 标签的 DOM 对象。

![](img/fbb867d729c9301cff3e3e81b09abc74.png)

让我们输出标题属性。

我们得到了 H2 标签的 DOM 对象。

![](img/29fa90efdd4227136f06d9e5f373cd11.png)

message 属性返回给我们 P 标签的 DOM 对象。

![](img/1895f60140a1251d6e60808446f68254.png)

在 Vue 3 中，代理对象通常意味着反应性。美元符号引用对象也不例外。它的属性都是反应性的，这意味着它们都返回了最新的 DOM 对象。

使用 title 属性设置 H2 标签的内部文本。我们给 title 属性分配一个新值。

![](img/843eff2a50f595d33093804a7c2433c0.png)

然后我们检查标题 ref 返回的 DOM 对象。

我们可以看到 H2 标签的 DOM 对象已经被更新。它的内部文本是 title 属性的新值。简单地说，ref 属性总是返回给我们最新的 DOM 对象。

![](img/422b07e551b5ad7fca745a8f85b338a3.png)

当我们改变标题值时，Vue 只改变 H2 标签的内部文本。H2 标签本身已被重新使用。重用页面元素有助于提高程序效率。

我们可以使用 ref 属性来证明这一点。

在我们的 Vue 程序的最后，我们声明了一个名为 H2 的变量。我们使用美元符号 refs 对象的 title 属性来设置它的值。现在，当我们第一次加载程序时，H2 标签的 DOM 对象将被保存到 H2 变量中。

![](img/fbcb671ea290c193dd698661bbcfcb41.png)

接下来，我们重置 title 属性的值。

然后我们再次输出 H2 变量。我们可以看到它的内部文本已经更新为新的标题值。

![](img/1e30367dc10de71615dfba789377e6f2.png)

这证明了在我们重置了 title 属性的值之后，原来的 H2 标签仍然在使用。使用原来的 H2 标签显示新的标题值。

在上一课中，我们学习了 v if 指令删除一个元素。让我们证明这一点。

我们添加一个新的数据属性。我们将其命名为*控件*，并将其值设置为 true。

然后，我们转到 H2 标签，并在其中设置 v if 指令。我们使用 control 属性设置指令值。

![](img/25217805e1aef826d54c14b76d28c10b.png)

让我们运行文件。

我们输出美元符号 refs 属性。此时，title 属性与 H2 变量指向同一个 DOM 对象。

![](img/ec82ccc47cfbd1fd74e929eb3a532fd0.png)

接下来，我们将控件属性设置为 false，以移除 H2 标签。然后让我们检查美元符号 refs 属性。

我们可以看到 title 属性仍然存在，但是它的值已经变成 null。美元 sin refs 对象中的属性都是反应性的。它们总是返回最新的 DOM 对象状态。

H2 标签已经被 v if 指令删除，自然地，它的 ref 属性返回 us null。然而，H2 变量仍然保存着被删除的 H2 标签的 DOM 对象。

![](img/2d45dea3633471616e13efb83eadc507.png)

接下来，我们将控件属性的值设置为 true，以取回 H2 标签。

让我们检查美元符号 refs 对象。

它的 title 属性现在指向新的 H2 标签的 DOM 对象。

如果我们将 title 属性与 H2 变量进行比较，我们将得到 false。

目前的 H2 标签是新创建的。原来的 H2 标签已被删除。

![](img/34c65c3ea6c5cdff79d3179ae2c1e508.png)

refs 属性应该只用作开发工具。在实际项目中，应该避免依赖 ref 属性来操作模板元素或子组件。

在这节课中，我们将学习一个新的 Vue 指令:v 代表。

for 指令的 v 是 FOR 循环语句的 Vue 等价物。我们用它来迭代数组或对象。如果我们将一个 v for directive 嵌套在另一个 v for directive 中，我们就可以遍历一个对象数组。

文本模板可以处理数组和对象。但是很多时候，我们需要检索每个数组元素或对象属性，并单独显示它们。

![](img/f5324cc41525eb83c9e5814fad481045.png)

我们将从迭代一组原始值开始。

我们首先添加一个 UL 标签。在它里面，我们添加了一个李标签。第一个问题是我们应该在哪里安装 v for 指令？在标签里还是在李标签里？

![](img/ab5be33e3407c01658e6b6925479a8ed.png)

记住这个结论，接收 v for 指令的元素将根据迭代数组的元素总数重复创建。

我们希望为每个数组元素创建一个 Li 标记，并只使用一个列表显示所有数组元素。

这意味着我们需要多个 L1 标签和一个 UL 标签。所以在这里，指令的 v 应该放在 Li 标记中，而不是标记中。

v for 指令对其值使用特殊的语法。我们在括号中声明了两个别名。第一个表示元素值，第二个表示元素索引。我们要给这两个化名命名。在这里，我将它们命名为元素和索引。你可以选择其他名字，但要确保你的名字容易理解。

然后我们在括号后面的中添加关键字*。在*中的关键词*后面，我们放置了城市属性。如果只需要元素值，可以跳过括号。*

![](img/b5c1c37280b5845d2c243538b0f30513.png)

v for 指令遍历 cities 数组，并为每个数组元素创建一个 Li 标记。这两个别名在 Li 标签内部和之间都是可见的。在 Li 标记之间，我们添加了两个 mustache 标记来显示这两个别名。

![](img/1b483aea7b06be482831dbc90a0fb8e2.png)

让我们测试这个程序。

我们可以看到已经自动创建了一个列表。该列表有四个项目，每个项目对应于城市数组中的一个元素。第一个别名给出了元素值，第二个别名给出了元素索引。

在 HTML 文件中，我们有一个标签和四个 Li 标签。

![](img/386df97b97f8ad1706cdedc9f9df273b.png)

最好给每个动态生成的元素一个键。该键作为唯一标识符工作，因此它的值必须是唯一的。

保持键值唯一的最简单方法是使用元素索引作为它的值。关键属性是给 Vue 内部用的。你不会在最终呈现的 HTML 文件中找到它。

![](img/fe75adc2a676f23b0fc7fa4dbf834c98.png)

那么关键属性是什么呢？

关键属性是 Vue 用来区分动态生成的元素。在当前程序中，key 属性帮助 Vue 区分四个 Li 标签。

如果一个元素的键值改变了，Vue 会创建一个新元素来替换当前的元素。如果键值保持不变，Vue 将继续使用当前元素。

简而言之，key 属性决定了一个元素应该被重用还是被替换。通过手动更改键值，我们可以强制 Vue 重新呈现页面元素。

我们以第一个李标签为例。它的内部文本来自城市数组的第一个元素。

我们重置了城市数组的第一个元素。我们把它从伦敦改成达拉斯。

我们可以首先看到 Li 标签已经自动更新了它的内部文本。

![](img/1573d11eff37ded410097ca0e7805194.png)

问题是 Vue 如何更新第一个 Li 标签？仅重置其内部文本还是用新的 Li 标签替换它？

这取决于 Li 标签的键值是如何设置的。目前，键值是使用元素索引设置的。更改第一个元素的值不会影响它的索引。所以键值保持不变。因此，最初的李标记仍在使用。Vue 所做的只是改变了它的内部文本。

让我们证明这一点。

我们将 ref 属性添加到 Li 标记中，以帮助我们访问呈现的 Li 标记的 DOM 对象。

因为 Li 标签是动态生成的，所以我们需要为 ref 属性设置一个动态值。我们通过将标签名 *Li* 与索引值连接起来来设置它的值。这样，每个 Li 标签都有不同的 ref 值。

![](img/d71c1f0cb1b6a165e06a44db2659e80d.png)

我们输出美元符号 refs 属性。

我们在目标对象中有四个属性。属性名由标签名*李*和元素索引组成。属性值是四个 Li 标签的 DOM 对象。

![](img/52f656ef0b49d113917e0119e6b8e997.png)

接下来，我们声明一个新变量，并将其命名为 *first* 。

我们使用美元符号 refs 对象的第一个属性来设置它的值。现在，变量 *first* 指向第一个 Li 标签的 DOM 对象。

![](img/75e4d49661e1dd407d9813414be49ed6.png)

让我们测试这个程序。

我们先输出变量*。我们有李牌。它的内部文本是伦敦。*

*![](img/e89a83b688bfd3a0e5d997af58036213.png)*

*然后，我们将城市数组的第一个元素更改为达拉斯。*

*然后我们先检查*再检查*变量。*

*它的内部文本值变成了 Dallas。这证明最初的李标记仍在使用。Vue 所做的只是更新其内部文本。*

*![](img/cc7ca4b5a3c856aedbe69d532d7aa8d7.png)*

*如果我们将*第一个*变量与美元符号引用对象的第一个属性进行比较，我们将得到 true。这再一次证明了李的第一个标记从未被替换过。*

*![](img/97771295ad3381b5c9659c15825ff25d.png)*

*接下来，我们重置键属性的值。我们通过将元素和索引值连接在一起来设置它的值。我们不单独使用元素值的原因是可能存在重复的元素。索引保证每个值都是唯一的。*

*现在，更改元素值也会更改键值。因此，Vue 将创建一个新的 Li 标签来替换旧标签。*

*![](img/945cbc9d69ee0546d736b2dd579d23aa.png)*

*我们将城市数组的第一个元素设置为奥斯汀。*

*让我们先检查一下*变量。我们可以看到它的内部文本仍然是伦敦。**

*![](img/936c63ead687cb3b892bedc1a78fd6c7.png)*

*我们使用其 ref 值检索第一个 Li 标签的 DOM 对象，并将其与第一个变量*进行比较。**

*这一次结果是假的。*

*![](img/3d81ce759305732db67903a99c55bed7.png)*

*之前的对比结果是真的。这证明原来的第一个李标签已被一个新的所取代。通过改变键值，我们已经强迫 Vue 用一个新的标签替换第一个 Li 标签。*

*在后面的课程中，我们将学习如何创建过渡效果。只有移除或重新创建的元素才能触发过渡效果。通过改变键值，我们强制 Vue 用一个新元素替换当前元素，这样就可以触发转场效果。*

*接下来，让我们尝试迭代一个对象。*

*![](img/6493001f6b7d84e0437f2586ecdf28d9.png)*

*我们添加了一个新的 UL 标签。*

*在 Li 标记中，我们添加了 v for 指令来迭代 car 对象。*

*与数组相比，对象可以使用属性名存储额外的值。所以在这里，我们声明三个别名。第一个表示属性值，第二个表示属性名，最后一个表示属性索引。对象属性不需要索引。这里的索引主要是为了帮助我们创建唯一的键值。*

*在 Li 标记中，我们显示了所有三个别名。*

*![](img/674c7b435f7c461018723908baf14033.png)*

*让我们运行文件。*

*我们有了新名单。每个列表项对应一个对象属性。我们有属性名、值和索引。迭代一个对象和迭代一个数组是一样的。我们只需要为属性名设置一个额外的别名。*

*![](img/54faed4e15b495f9af4219dfe5c3097f.png)*

*接下来，让我们尝试一个更复杂的场景:遍历一个对象数组。*

*![](img/da7375996d5c86ce060fac01012eb64c.png)*

*首先我们迭代外部数组。*

*每个元素都是一个对象。我们可以简单地通过它们的名字输出属性值。*

*![](img/88dae73b313bb8a46c7285781e4386f0.png)*

*我们有了新名单。每个列表项对应一个对象。*

*![](img/cae3701e5a1636e395f2419d63297d54.png)*

*如果我们正在查询一个像 MySQL 这样的 SQL 数据库，这个解决方案是不错的，因为每个对象都有相同的形状。所有对象的属性名称都相同。*

*![](img/68c1d7403f0a58a5554a37c4cd1e41fb.png)*

*但是如果我们查询一个像 mongoDB 这样的非 SQL 数据库，那么每个对象都可能是唯一的。没有一致的对象形状。预定义属性名是不可能的。*

*![](img/c39ad0cced2e53e037085f7ca2dadd37.png)*

*在这种情况下，我们需要迭代两次。我们首先迭代数组。对于每个数组元素，我们进行另一次迭代来输出每个对象属性。*

*我们希望为每个元素创建一个列表。这意味着我们需要多个列表，所以我们在 UL 标签中为指令添加了第一个 v。我们用它来迭代数组。*

*这样，每个元素都有自己的列表。*

*![](img/5069a74a93ddb9eb288ab2c3402db44e.png)*

*在 Li 标记中，我们添加了第二个 v 来表示指令。我们用它来迭代每个元素。将输出每个属性名称。*

*![](img/f83895e791912e330e29eed9c23d7f41.png)*

*让我们运行文件。*

*我们有三个独立的列表。每个列表对应一个对象。这三个对象具有不同的属性。但这并不重要。内部 v for 指令简单地遍历对象并输出每个属性名和值。*

*![](img/50f0b16e1dcced8217eee4477d49548f.png)*

*这里我们有三个数据属性。它们是品牌、型号和注册年份。在我们的实际项目中，这三个值分别从后端 API 中检索。*

*![](img/044443c2f9684c4971beebdd0416c469.png)*

*有时，我们需要在将检索到的数据呈现给用户之前对其进行处理。例如，我们想向用户显示车龄。车龄的计算方法是从当前年份中减去注册年份。*

*![](img/622654115fcc6ba827a9e7a6400a5677.png)*

*我们可以在组件模板中定义数学表达式。Vue 将执行表达式并返回计算结果。*

*![](img/25720fd8d7a9a789be7e036c7ac7a34b.png)*

*将逻辑代码放在组件模板中并不是一个好主意。最好将逻辑代码集中在 options 对象中。模板最好保持干净和简单，最好只显示 Vue 属性。*

*为了帮助我们基于数据属性创建新的值，Vue 为我们提供了计算属性。计算属性就像数据属性的扩展，使我们能够基于现有的数据属性创建新的值。*

*为了创建计算属性，我们添加了 computed 选项。它的值是一个对象。*

*![](img/79e16153a498a3b725ef4db853c18d83.png)*

*我们添加了一个名为 carAge 的新属性。我们可以使用函数语法或对象语法来设置它的值。*

*大多数时候，函数语法是最好的选择。我们依靠它来访问数据属性，所以要确保使用完整的函数。我们在函数中返回的值将被用作 carAge 属性的值。*

*我们实例化了日期构造函数，并用 getFullYear 方法对其进行了附加。然后我们从当前年份中减去 registrationYear 属性。*

*carAge 属性实际上是 registrationYear 属性的一个 getter。它返回一个基于 registrationYear 属性值的值。*

*![](img/c9f43a7c14430fbf760b2e77cf0ee38e.png)*

*就像数据属性一样，计算属性在组件模板中也是可见的。*

*我们可以看到车龄已经计算出来并显示给用户。*

*![](img/2b094d1fe54ef9329a0d2cd369d916d5.png)*

*我们打开根组件实例。*

*carAge 属性已添加到目标对象的根级别。计算属性不是数据属性，它们不会被添加到美元符号数据对象中。*

*![](img/50c9a9eb27fef87cb2f0aa71c51047e2.png)*

*计算的属性是反应性的。如果我们设置一个新的注册年份，carAge 属性将相应地改变，组件模板将自动更新。*

*![](img/71e3d119c0a0e46921f642d987f10761.png)*

*carAge 属性是只读的。原因是我们用函数语法定义了它。它只有一个吸气剂。没有设置器来处理新值。*

*![](img/84032f8919a4a7c55bd49ea30028fe65.png)*

*大多数时候，只读的计算属性正是我们所需要的。我们不需要担心数据属性被无意中修改。*

*计算属性和数据属性不应同名。让我们看看如果我们确实有一个命名冲突会发生什么。*

*我们创建一个新的计算属性，并将其命名为 brand。此名称下已经有一个数据属性。*

*![](img/e26c888323527bbdcc539af5669371ad.png)*

*让我们运行程序。我们可以看到数据品牌比计算品牌具有更高的优先级。*

*警告称计算属性品牌已经在数据中定义。这证明数据属性是在计算属性之前处理的。*

*![](img/1aa8040e154e6912eb8fc77085445323.png)*

*让我们检查 vm 点品牌并检查组件实例对象。*

*VM.brand 返回给我们数据品牌的价值。但是实例对象根级别的 brand 属性存储计算出的 brand 值。*

*![](img/b366d7a3af0490057ec2c7e339f10a25.png)*

*我们在这里看到的品牌属性来自代理目标对象。vm 点品牌的价值由品牌获取者决定。品牌获取器返回数据品牌属性，而不是计算的品牌属性。这意味着可以创建计算的品牌属性，但永远无法检索。*

*这也证明了目标对象的属性值可能不总是与从代理对象中检索到的属性值相同。我们得到的最终值取决于代理 getter。*

*接下来，让我们试试对象语法。我们创建一个新的计算属性:FullName。我们给它分配一个对象。*

*![](img/d0db97416d3e637adde3dfd47ef97d47.png)*

*这个对象允许我们设置一个 getter 和一个 setter，从而使 fullName 属性可读和可写。*

*getter 和 setter 必须使用完整的函数来定义。原因和之前一样。我们需要它指向组件实例。*

*![](img/edeee065de63b9203a210d569292bee6.png)*

*在 getter 中，我们一起返回品牌和模型值。我们用空格将它们连接起来。*

*当我们访问 fullName 属性时，我们将收到一个包含品牌和型号值的字符串。*

*![](img/d2846418b9443f8e8ffc166d1759f122.png)*

*getter 返回的值和分配给 setter 的值不必相同，甚至不必是相同的数据类型。*

*我们给 setter 分配一个数组。我们将第一个元素分配给品牌属性，将第二个元素分配给模型属性。*

*![](img/bdee0ed8ca51e26d83c891719d1416cf.png)*

*让我们测试这个程序。我们首先检查组件实例。*

*全名属性的值包括品牌值和型号值。*

*![](img/f815e278a9093743af517de30a7233e6.png)*

*接下来，让我们试试它的 setter。我们给它分配一个数组。*

*![](img/d6b46c8d225e9d4072ec5c3ae848b103.png)*

*我们可以看到品牌和型号的价值已经被重置。我们可以使用一个计算属性重置两个数据属性。*

*![](img/b9c10bd9d125e422ae029b0cec509f63.png)*

*计算属性依赖于此来访问数据属性，所以要确保只使用完整的函数来定义 getters 和 setters。*

*在这节课中，我们将学习如何定义和使用 Vue 方法。我们还将学习如何使用 v on 指令来监听事件和触发 Vue 方法。*

*![](img/1b3852f0834337ac27a58def70f0be80.png)*

*Vue 方法是在方法选项中定义的。*

*每个 Vue 方法都应该使用完整的函数来定义。不要使用箭头功能。原因和之前一样，我们需要 Vue 方法有一个可控的这个。*

*一旦定义了 Vue 方法，它将被添加到组件实例的根级别。就像数据属性或计算属性一样，Vue 方法可以通过它来访问，并且在组件模板中也是可见的。*

*![](img/c3dff9f21e3c27aa335cb54ad6a5e74c.png)*

*让我们运行测试方法，看看它指向哪里。*

*我们可以看到它指向拥有测试方法的根组件实例。因此，Vue 方法可以通过它访问其他 Vue 属性和方法。*

*![](img/1c95110202668f686cf1fcd25c743970.png)*

*接下来，我们使用 Vue 方法创建一个简单的计数器应用程序。我已经预定义了一个名为 number 的数据属性。我们把它放在 H2 标签里。*

*![](img/69d7172db10b3a09150a06430751cf23.png)*

*然后我们创建一个名为 increment 的新方法。*

*出于演示的目的，我们首先在控制台记录方法名。我们通过这个方法访问 number 属性，并将它的值加 1。*

*![](img/790d025ed37a3abacd1581a819621eca.png)*

*让我们测试这个程序。*

*我们调用 increment 方法两次。*

*数字值从 0 到 2。*

*![](img/63e238012dd45b4cc971507e011bf12e.png)*

*手动调用增量相当不方便。让我们创建一个按钮，并用它来触发 increment 方法。*

*![](img/72b4b792514a395263a6afaaa0f72bea.png)*

*使用本机 JS，我们选择按钮并将 addEventListener 方法绑定到它。我们监听点击事件并触发回调。*

*addEventListener 方法的 Vue 等价物是 v on 指令。它监视绑定事件并触发一个或多个 Vue 方法。*

*应该将 v on 指令添加到触发受监控事件的元素中。在这里，我们将它放在按钮标签中。*

*指令参数是被监视事件的名称。在这里，我们将其设置为点击。Click 是一个本机 HTML 事件。在后面的课程中，我们还将学习自定义事件。*

*指令值是我们想要触发的方法的名称。这里，我们将其设置为*增量*。我们只需要方法名。方法名后面的括号是不需要的。*

*![](img/fcf0713da47e8455ae4ec0cbff45efb5.png)*

*让我们测试这个程序。*

*每次我们点击按钮，我们触发*增量*方法，数值增加 1。*

*![](img/90fd7573a9735164f47edb0a9fba92fa.png)*

*被监视的事件向被触发的方法发送一个事件对象。这个对象代表本地点击事件。它与传递给 addEventListener 方法的回调的值相同。*

*不同的事件发送不同的事件对象。本机 click 事件发送本机 mouseEvent。*

*![](img/e5e5fbab87b1d8207f43dcf73bdcc96c.png)*

*我们可以在方法名后面放一组括号。*

*让我们测试这个程序。*

*单击该按钮仍会触发 increment 方法。但是事件对象不见了。参数值未定义。*

*![](img/cd871d7b2fbd2945272adae0d66f68e3.png)*

*这个问题可以通过将事件对象显式传递给 increment 方法来解决。事件对象存储在全局变量$event 中。在后面的课程中，我们将经常使用这个全局变量。*

*![](img/0b56ca131534136df53488211a879ca1.png)*

*现在，本机 mouseEvent 对象已经发送回增量。*

*大多数时候，你应该跳过括号。只需将方法名赋给 v on 指令就足够了。*

*如果你需要设置你自己的参数值，那么括号是必要的。确保将美元符号事件设置为第一个参数。否则，您自己的参数值将覆盖事件对象。但是如果您不需要事件对象，那么您可以使用自己的值设置第一个参数。*

*![](img/ac05d563e7bb6418f63a3306284fdd68.png)*

*v on 指令也适用于内联方法。*

*指令值可以访问组件实例。number 属性可以直接访问，不需要任何前缀。我们可以直接在它后面加上增量运算符。*

*![](img/28b5d713a6d3a7b66b8f3a34afb00646.png)*

*指令值的 v 是一个 JS 表达式，但它是一个相当有限的表达式。它无权访问窗口对象。因此，如果您想要控制台记录某些内容，您就不能这样做。*

*![](img/087b523e5d707c6d6d3afa301b6a755f.png)*

*在我们的实际项目中，我们应该保持模板简单和干净。逻辑代码最好保存在 options 对象中。实际项目中不推荐使用内联方法。*

*v on 指令可以一次触发几个方法。*

*我们定义了两种新方法:M1 和 M2。*

*![](img/8819575c8ba555df335257924619c8b6.png)*

*我们想同时触发 M1 和 M2。*

*我们创建了一个新按钮，并在其中添加了 v on 指令。在指令值中，我们列出了这两种方法的名称，并用逗号分隔它们。*

*![](img/00112eefa1d7311d29c75c6f0f7e0fa1.png)*

*让我们测试这个程序。*

*它不起作用。这两种方法都没有被触发。*

*![](img/8c251dcf3acd043dc2b33151dc92a2d7.png)*

*当触发多个方法时，括号是必需的。*

*我们可以看到 M1 和 M2 现在一起被触发。*

*![](img/f42a0449da99a7232df5c3832ef3e840.png)*

*就像我们之前说过的，空括号覆盖了事件对象。所以我们需要在两个方法中显式声明事件对象。*

*![](img/f314c9fe4d199aacb74f4710fb6aeb64.png)*

*手册上说我们应该用逗号来分隔方法，但是如果你用分号，你的程序仍然会工作得很好。*

*你甚至可以混合逗号和分号。*

*你的程序会运行良好，但最好坚持使用手册的建议:逗号。*

*您可以混合使用内联方法和 Vue 方法。用昏迷把他们分开。根据我的测试，分号也可以。*

*![](img/abd27f89f4f0784f7276bffb96d51458.png)*

*在这一课中，我们将一起讨论闭包和 v on 指令。*

*首先，我们创建两个按钮。我们将第一个按钮命名为 Vue 按钮，将第二个按钮命名为 name 按钮。为了选择第二个按钮，我们给它一个 ID。*

*![](img/4558f6f01db6ea6c66a4173c94622035.png)*

*原生按钮需要原生 JS 代码。我们添加了一对新脚本标记来定义本机 JS 代码。*

*我们从原生按钮开始。我们通过它的 ID 选择它，并将其绑定到 addEventListener 方法。我们监听点击事件。*

*![](img/b08839f1c8b8eb9ff7a04aaf49155bb2.png)*

*然后我们创建一个函数并命名为 outer。*

*在外部函数的根级别，我们控制台日志*本地外部函数*。*

*![](img/0ac404656d2a37b7fa43eebbedeea5ed.png)*

*然后我们返回一个子函数。返回的函数是使用完整函数定义的。在返回的函数中，我们控制台日志*原生内部函数*。*

*![](img/fe89634c33664686c9737d12902f9992.png)*

*我们将外部函数传递给 addEventListener 方法。*

*![](img/0c7981ec71ee2c04bcf56fa06d66b288.png)*

*现在，我们每点击一次原生按钮，就会触发外层功能。*

*![](img/aba2e1e2e660e72a6eaaffd5dc319f03.png)*

*为了触发内部函数，我们需要在 outer 后面添加一组括号。这样，返回的子函数将绑定到 click 事件。*

*这也意味着当我们刷新页面时，在我们点击任何按钮之前，外部函数将被触发。*

*![](img/dad23d037decad7845f38e89fec0d00a.png)*

*让我们试试这个程序。*

*返回的子函数现在被绑定到 click 事件。每次点击 native 按钮，都会触发内部的子函数。*

*![](img/9ad207f7ec35f358e0cb866d8ad72069.png)*

*在外部函数中，我们声明了一个变量:Number。我们将其值设置为零。然后在内部函数中，我们控制台 log number++。我们在这里创建了一个基于闭包的计数器程序。*

*![](img/b2d2b9d96108cd41e92d6ac70a7bf2d4.png)*

*每次我们点击 nativeButton，内部函数都会给 number 属性加 1。每执行一次内部函数，同一个数字变量就加 1。这就是计数器程序工作的原因。*

*![](img/085e0da782178e377f62164cb2d98d8f.png)*

*接下来，让我们使用 Vue 创建一个类似的程序。*

*我们添加了方法选项，并在其中定义了一个名为 outer 的方法。我们控制台日志 *Vue 外部函数*在里面。然后我们返回一个内部函数。*

*![](img/fb6ad7c037d6942c7e82cdc6e7704f66.png)*

*在我们继续之前，你发现程序设计有什么问题吗？*

*返回的内部函数被定义为完整函数。这样做合适吗？*

*这取决于内部函数是否需要访问组件实例。*

*如果返回的内部函数是一个完整的函数，那么它将指向窗口对象。Vue 只重定向这个外部函数。返回的内部函数只是一个原生函数。我们需要使用 bind 方法手动将其 THIS 重定向到组件实例。*

*更好的选择是使用箭头函数定义返回的内部函数。arrow 函数从 outer 函数继承 THIS。*

*![](img/07766b38df8e11f84ee500fc6fa1b810.png)*

*在返回的内部函数中，我们控制台日志 *Vue 内部函数*。*

*在 VueButton 标签中，我们添加了 v on 指令并触发了外部方法。*

*![](img/886a1954676318f0712bc9b7c12ea045.png)*

*单击 VueButton 只会触发外层方法。*

*![](img/0d3454b8f3d1403bf7a2762a0484fecb.png)*

*为了触发返回的内部方法，我们需要添加一对额外的括号。*

*![](img/0a1b27d063d8425ab063494b4d770ee0.png)*

*我们每点击一次 Vue 按钮，Vue 外层方法和 Vue 内层方法就会一起触发。*

*![](img/d47ee6c73e58c5645d5c50a7992e9410.png)*

*这意味着我们不会有一个结束。内部函数的每次执行都有自己的外部作用域。让我们证明这一点。*

*在 Vue 外部方法中，我们声明了一个名为 number 的变量。我们将其值设置为 100。*

*然后在返回的内部函数中，我们将控制台日志的*号减去*。*

*![](img/446044a0f0764404e1ed0028f44bbd0b.png)*

*让我们试试这个程序。*

*我们可以看到 Vue 计数器应用程序不起作用。内部函数的每次执行都有它自己的外部作用域，因此每次我们点击 VueButton，我们总是得到 100。内部函数的当前执行不能处理其前任的结果。*

*![](img/d4a6443e95602115de5b5868e0f26b32.png)*

*在本课中，我们将学习如何使用 Vue 收集用户提交的数据。*

*![](img/31ca09a0ceebbf660317a44ee1cb9b05.png)*

*首先，我们创建一个输入框。我们添加输入标签并给它一个 ID。输入标签的 value 属性决定了输入框中显示的初始内容。*

*![](img/a7871b780520e4193e09c95868afc842.png)*

*我们在输入框中输入的任何内容都将存储在 value 属性中，覆盖其默认值。*

*Vue 使用 v bind 指令控制 HTML 属性。我们用 v bind 指令作为 value 属性的前缀，并将指令值设置为 message 属性。*

*现在，消息属性的值已经作为初始值发送到输入框中。*

*![](img/121ea32f9c42a82957bc74452a55d03d.png)*

*数据现在可以从消息属性传输到输入框。我们下一步的工作是扭转方向。我们希望使用输入标签修改消息值。*

*首先，让我们来看看原生输入框是如何工作的。*

*我们得到了输入框的 DOM 对象。然后我们将它绑定到 addEventListener 方法。我们监听输入事件。输入事件对象将被传递给 addEventListener 方法的回调。*

*我们在输入框中输入的每个字符都会触发输入事件。*

*![](img/63ee1f3d6c5086b0336d0c7a6037c37b.png)*

*我们打开最后一个输入事件对象。*

*向下滚动，您将找到一个目标属性。目标属性指向输入标记的 DOM 对象。*

*![](img/54dd842740638b169bf6bc0657171024.png)*

*打开它，滚动到最后。这是一个很长的物体。*

*在最底部，我们会发现一个名为 value 的属性。它对应于输入标记的 value 属性，使我们能够访问用户提交的数据。*

*![](img/1d890e34617976ef5d88df12501e322d.png)*

*结论是实时获取用户提交的数据，我们监听输入事件并监视 **event.target.value** 。*

*在输入标签中，我们使用 v on 指令来监控输入事件。我们使用 inline 方法重置消息属性。*

*在您的实际项目中，避免使用内联方法来保持模板的整洁和简单。我们在这里仅用于演示目的。*

*可以通过$event 变量访问输入事件对象。我们用网点目标值作为附录。*

*现在，用户提交的数据已经被分配给了 message 属性。*

*![](img/859a9b68ae00e17ebef3ab429066b975.png)*

*让我们测试这个程序。*

*我们可以看到输入框现在可以控制消息属性。我们可以实时控制消息属性的值。*

*![](img/b7fd7ca59c383ca988c3b9d10c8075c6.png)*

*在输入标签中设置两个指令相当不方便。Vue 为我们提供了一个语法糖:v 模型指令。*

*v 模型指令不需要参数。我们给它分配消息属性。这就是我们需要做的。*

*![](img/a9c39f1223524c1570e851cf9ac88495.png)*

*相比之下，输入标签看起来更干净，也更容易阅读。我们可以很容易地看出这个输入标签与消息属性相关联。*

*语法糖只是一段较长代码的较短别名。我们在这里使用的输入标记是一个文本类型的输入标记，它的 v model 指令将自动扩展成下面列出的 v bind 指令和 v on 指令。v bind 指令控制 value 属性，v on 指令监控输入事件。*

*![](img/66c1fba5c9a34fb93d650edcd206dd60.png)*

*默认情况下，输入框收集的所有内容都被视为一个字符串，包括数字。*

*![](img/6999f71d1f8db22a2784d49a39a1872f.png)*

*为了解决这个问题，我们需要在 v 模型指令后面加上数字修饰符。修改器通过点连接到 v 模型指令。数字修饰符只影响数值，其他值类型仍被视为字符串。*

*现在，数值将被保存为数字，而不是字符串。*

*![](img/082ddba2b2961cf3012cf82d39b01f81.png)*

*每当我们在输入框中输入一个字符，输入事件就会被触发，bind 方法就会被执行。*

*对每个事件都做出反应通常是不必要的，尤其是对于较长的文本。为了提高程序效率，我们可以在 v 模型指令后面加上 lazy 修饰符。*

*我已经输入了几个字符，但是消息属性保持不变。*

*![](img/df63721c34bc4bbe9dade29fd65764ae.png)*

*要提交文本，我们要么按 ENTER 按钮，要么将焦点从输入框中移开。*

*![](img/2df23e85e13ddf672450906270cf7773.png)*

*现在，v model 指令不再响应我们在输入框中输入的每个字符，而是等到输入结束后才做出一个响应。*

*有时，用户可能会不小心在单词前后键入一些不需要的空格。这些不需要的空白仍然被保存，浪费内存空间并导致格式化问题。*

*![](img/4724df312a5e8832a0a81276fb160270.png)*

*我们可以使用 trim 修饰符来删除这些不需要的空白。*

*![](img/0a167632162a09913b059220b2a218ea.png)*

*trim 修饰符不会删除单词之间的空格。无论你在两个单词之间放多少空格，它们都将被保留。*

*![](img/b5fa2b484cb632b9bf09f8ce36fafc5a.png)*

*我们这里有一个输入标签。它连接到消息属性。*

*很多时候，我们需要限制用户可以输入的字符数。假设我们将最大字符总数限制为 10。*

*![](img/fa8c9acd9022381497f8ff42d74e3f54.png)*

*我们首先创建一个新的数据属性:Max。我们将其值设置为 10。我们用它来控制最大字符串长度。将来，如果我们需要重置最大字符串长度，我们只需要修改 max 属性。*

*![](img/2905d5765c125b5e24408d59951b13b8.png)*

*在输入标签下面，我们添加了一个 span 标签。我们用它来实时显示用户还剩多少字符。*

*为了计算剩余的字符，我们从 max 属性中减去*消息点长度*。*

*我们现在可以得到我们还剩下多少字符的实时反馈。*

*![](img/d640754032c2eeed23fcb73e197d089a.png)*

*需要删除多余的字符。我们回到输入标签，添加 v on 指令。我们监控输入事件。不要监控变更事件。稍后我们会告诉你为什么。*

*我们触发检查方法。*

*![](img/3a93aa92badd89464671dcb89b9762f6.png)*

*然后我们添加 methods 选项来定义检查方法。*

*我们首先检查消息长度是否超过最大值。如果是，我们重置消息值。我们将 message 属性连接到 substring 方法。我们使用 max 属性将第一个参数值设置为零，将第二个参数值设置为零。这样，只有前十个字符将被赋回消息属性。*

*![](img/0c43bfb66440d8abac8671ea68658fbf.png)*

*让我们测试这个程序。*

*输入框现在最多只接受 10 个字符。*

*![](img/c039dbf6c8689a4020933127b21999bc.png)*

*接下来，我们将*输入*事件切换到*改变*事件。*

*change 事件监视输入框中的文本更改。只有在我们提交了不同的文本后，它才会被触发。这意味着我们可以输入任意多的字符。*

*![](img/b4904452b4062fc81229ac62f6ef3c0c.png)*

*只有在我们提交文本后，文本才会被截断。相比之下，输入事件提供了更好的用户体验，因为用户不会看到他们输入的一部分突然消失。*

*![](img/77ad82c95d9d4909966422f4c12545c3.png)*

*在这一课中，我们将向您展示如何使用其他类型的输入标签。我们将从无线电类型开始。*

*![](img/0de00549d893194dfc7d465c69661a54.png)*

*单选类型的输入标签生成一个可点击的圆圈。一旦选中，就无法取消选中。*

*![](img/858e59f358bdc748f9f92cba5ec124d6.png)*

*圆圈本身需要代表一个值。默认值为上的*，表示圆已被检查。**

*使用 value 属性，我们可以设置一个自定义值。在这里，我们将其设置为 apple。*

*![](img/b87ac0755898e343b4b5298ed30e1101.png)**![](img/941a1c12b5f1b1d66e86660a35fdd024.png)*

*现在，我们有一个代表苹果的单选按钮。*

*接下来，我们制作输入标签的另外两个副本。我们将第二个设置为橙色，第三个设置为桃色。*

*现在，我们有三个单选按钮代表三个值。*

*![](img/f5d066db6b1e38b00cc38cbbda0a4cea.png)*

*单选按钮用于单项选择。我们列出了几个选项，只允许用户选择一个。*

*目前，这三个单选按钮是独立的。为了将它们组合在一起，我们需要 name 属性。名字值由我们决定。具有相同名称属性值的单选按钮将被组合在一起，一次只能选中一个按钮。*

*现在，这三个单选按钮属于同一组。*

*![](img/2037931215a00809fd56b790f9ec8319.png)*

*让我们测试这个程序。*

*我们一次只能检查一个单选按钮。选中新按钮会取消选中当前按钮。一次只能提交一个值。*

*![](img/e5abc2c3c8d9116a90b7a02ecbd91a85.png)**![](img/7571a7aabb5c9c754b13e8e2d4507553.png)**![](img/788762ab751d86881058de94db06fbe7.png)*

*我们希望将提交的值保存到 *picked* 属性中。*

*我们添加 v on 指令并监控输入事件的变化。结果是一样的。*

*我们使用 **$event.target.value** 重置*选择的*属性。机理和以前一样。*

*![](img/2355a8fd1e35902813a132075bc0106b.png)*

*我们将 v on 指令复制到剩下的两个输入标签中。*

*![](img/4d3662d869aed4f3c27f4702176ffa56.png)*

*现在，所有三个单选按钮都向 *picked* 属性发送值。让我们测试这个程序。*

*![](img/b5e4677abe4fc85f5fc22a3e1499f58e.png)**![](img/5d68c2617eef148ed27d4c4184ea2582.png)**![](img/83ef8929ae43b8bdefc098190ca675b7.png)*

*我们可以通过单击三个单选按钮中的一个来重置 *picked* 属性。*

*我们的工作只完成了一半。我们希望 *picked* 属性也能控制三个单选按钮。当我们手动修改 picked 属性时，我们希望相应的按钮被自动选中。*

*![](img/5278ae8423dabf2ae2a31c254ae3f3a7.png)*

**选中*属性决定单选按钮是否被选中。我们用 v bind 指令作为它的前缀。*

*然后，我们将选择的*属性与当前输入标签的值进行比较。如果两个值匹配，比较表达式返回 true，v bind 指令将安装 checked 属性。单选按钮将被选中。**

*否则，v bind 指令将删除选中的属性，单选按钮将被取消选中。*

*![](img/a717dd07d5ef31efa62c2f328188fdb4.png)*

*我们将 v bind 指令复制到另外两个输入标签中。记得更新比较值。*

*![](img/3f4e6f00567fc61cefb471cd1c42f50d.png)*

*让我们测试这个程序。*

*picked 属性的初始值是 apple。当我们第一次加载页面时，第一个单选按钮被选中。*

*![](img/9884b0c0d8ef8a5259250e65dd760ab1.png)*

*点击其他单选按钮重置*选择的*属性。*

*![](img/9f74ce59dab3e03877f792760093d720.png)*

*如果我们手动为 *picked* 属性分配一个新值，相应的单选按钮将被自动选中。*

*![](img/e1bbc5a6cb9ec332c6552b936b995433.png)*

*所有输入标签的检查属性都由我们控制，不再需要名称属性。*

*![](img/a177995312cf15f8d75d1e518d37f652.png)*

*v on 指令和 v bind 指令可以替换为 v model 指令。我们只需要将选中的属性分配给它。*

*我们将 v 模型指令复制到第二个输入标签中。我们保留最后一个输入标签不变，以提醒我们 v model 指令在单选类型的输入标签中真正代表了什么。*

*![](img/5421f69d99ab3e564a737281f0673181.png)*

*v model 指令是一个语法糖，它实际代表什么取决于它的安装位置。当安装在 radio 类型的输入标记中时，v model 指令仍然扩展为 v on 指令和 v bind 指令。但是 v bind 指令并不控制 value 属性，它控制的是 *checked* 属性。*

*在这一课中，我们将尝试另外两种类型的输入标签:复选框和选择列表。我们将从复选框开始。*

*复选框用于多项选择。这就是我将 list 属性设置为数组的原因。*

*![](img/7e5f189579236c7250cce555380ed912.png)*

*我们添加一个输入标签，并将其类型设置为 checkbox。*

*我们将得到一个可点击的正方形。就像单选按钮一样，我们需要 value 属性来指定复选框代表什么。这里我们将 value 属性设置为 apple。*

*![](img/d4d216fbfcea91076ae2a7714ab9aa07.png)*

*然后，我们再制作两个输入标记的副本，并将它们的值属性更改为 orange 和 peach。*

*![](img/b1bddd4e5a52019ef40d889fa8e6425e.png)*

*现在，我们有三个复选框，分别代表苹果、橘子和桃子。*

*![](img/911fd8ca8076a0afa8cbd635c53be6c7.png)*

*在第一个输入标记中，我们添加了 v model 指令，并将其值设置为 list 属性。您需要确保 v model 指令连接到一个数组。*

*![](img/6b42d8f17baed33b9bc6d748a1582ad0.png)*

*然后，我们将 v model 指令复制到接下来的两个输入标签中。*

*![](img/8546c67c6cae9b674ef063f5809a55ec.png)*

*让我们测试这个程序。*

*列表数组已经有 apple 和 orange。所以前两个复选框是自动选中的。*

*![](img/e1eab4bff5d1c854fb49305a99d6d1d5.png)*

*单击第三个复选框将 peach 添加到列表数组中。*

*![](img/3138e92e7715371600b769354a05efaa.png)*

*取消选中最后一个复选框将从列表数组中删除 peach。*

*![](img/2830fc763fac4c78190328ef93d47a89.png)*

*我们也可以用同样的方法去掉橘子和苹果。*

*![](img/6c0bf35402da7c74a0524048afa340f9.png)*

*如果我们手动修改列表数组，这三个复选框将相应地被选中和取消选中。*

*例如，我们清空列表数组。所有复选框都会自动取消选中。*

*![](img/01ca16a4625e37b745e54e9c8533a189.png)*

*接下来，我们从最后一个输入标签中删除 v model 指令。我们将使用 v bind 指令和 v on 指令重新创建 v model 指令。*

*复选框仍然由选中的属性控制。我们 v 绑定了*选中的*属性。我们使用*包含*方法设置指令值。*

*我们检查当前复选框的值是否存在于列表数组中。如果是，includes 方法返回 true。将添加选中的属性。否则，includes 方法返回 false，选中的属性将被移除。*

*![](img/ec364ffb236aca4737a9194b5a88b776.png)*

*当我们取消选中一个复选框时，相应的元素应该从列表数组中删除。*

*如果我们再次检查它，被移除的元素应该被推回到列表数组中。*

*那么如何做到这一点呢？*

*在 checked 属性下面，我们添加了 v on 指令来监视输入事件。您还可以监控变更事件。*

*当输入事件被触发时，我们检查复选框的值是否存在于列表数组中。*

*如果是，我们使用拼接方法将其从列表数组中删除。*

*slice 方法的第一个参数是开始元素的索引。*

*我们将输入标记的值传递给 indexOf 方法来获取它的索引。*

*第二个参数控制将删除多少元素。我们把它设置为 1。*

*如果复选框的值在列表数组中不存在，我们将它推入列表数组。*

*![](img/3f8d6e93385ad18ecc5545eccedc9f9c.png)*

*现在您知道了当 v model 指令安装在复选框类型的输入标签中时，它代表了什么。*

*接下来，我们来试试选择列表。*

*我们添加选择标签。*

*在它里面，我们添加了 option 标签。value 属性决定了当前选项标记所代表的内容。像往常一样，我们添加三个选项标记来表示三个值:apple、orange 和 peach。*

*然后我们给选择标签一个 ID。*

*![](img/584f66d5ff10accbe9e7ba9861be80a0.png)*

*我们检索 select 标记的 DOM 对象，并将其存储在一个名为 *select* 的变量中。*

*![](img/43df2919630cc79b4f8a5573c8330f58.png)*

*让我们运行程序。*

*我们有一份选择名单。它有三个选项。目前，选择了第一个选项。*

*![](img/9216dcd5a1ac7a18e193ca8209a157af.png)*

*我们输出选择标签的值属性，这是当前选择的选项的值。*

*![](img/84f48b8bb631c58ceed58a70022ac6ac.png)*

*让我们将橙色分配给值属性。橙色是第二个选项的值。*

*我们可以看到，赋值完成后，选择了第二个选项。*

*![](img/5a28539402bf0f4803ec7204ab25981e.png)*

*如果我们将 value 属性设置为 peach，将向用户显示第三个选项。*

*![](img/4afd0789281f4c00ab94d0629e89c83d.png)*

*总之，有了 select 标签，我们不需要处理*选中的*属性。其值与选择标签的值相匹配的选项标签将被选择。*

*在 select 标签中，我们绑定了 value 属性，并使用 *picked* 属性设置了指令值。*

*现在，我们可以控制 select 标记的值，这意味着我们可以控制选择哪个选项标记。*

*被选中的*属性的当前值是橙色的，所以当我们重新加载页面时，第三个选项标签将被选中。**

*![](img/b4366a0c36b448b127198b954f5a9db2.png)*

*通过改变 *picked* 属性的值，我们可以选择不同的选项标签。*

*![](img/92e7f1a520614de67fa9ddc9ba3019f7.png)*

*接下来，让我们反转数据流。我们想使用选择列表重置 *picked* 属性的值。*

*我们转到 select 标签并添加 v on 指令。我们监控输入或变更事件。*

*我们使用可以从美元符号事件变量访问的 select 标记的 value 属性来重置 *picked* 属性。*

*![](img/61e593aeec1013b6e6a77d05e4770730.png)*

*现在我们可以使用选择列表重置 *picked* 属性的值。*

*![](img/63b941b486acec1a2b632682c77aff42.png)**![](img/de907dc663fe522b293053e1a9249cd9.png)*

*v model 指令也适用于 select 标记。我们只需要将*选择的*属性分配给它。*

*![](img/c60de8e591849132cefa747bc1665218.png)*

*当安装在 select 标记中时，v model 指令的行为与它在文本类型输入标记中的行为相同。*

*select 标签也支持多重选择，要启用它，我们需要在 select 标签中添加*多重*属性。不需要属性值。*

*我们需要将 v model 指令的值重置为一个数组来存储多个选择的选项。*

*![](img/42c53ae00984cbd8ecb24c7e365cc468.png)*

*从这节课开始，我们将学习如何使用 Vue 控制 CSS 样式。我们将从添加和删除类开始。我们将在下一课处理内联 CSS。*

*我已经预定义了四个类:两个背景类和两个文本类。*

*![](img/c26f06fcc7c8e5bf07966037e6e335fd.png)*

*在项目样板中，我创建了一个 span 标记。span 标记有一个外部 DIV。我们将在这个 DIV 中添加和删除类。*

*![](img/495be9abfb863eb2b92cc419bf375c7a.png)*

*通过 class 属性将类添加到页面元素中。让我们将 bgOne 和 textOne 分配给外部 DIV。*

*现在，外部 DIV 已经接收了 bgOne 类和 textOne 类。*

*![](img/0da57288999df0f443150779f1094d81.png)**![](img/accfda05a1276d702a2af73da701d1db.png)*

*接下来，我们用 v bind 指令作为 class 属性的前缀。*

*原来的 class 属性值现在已经变成了一个 JS 表达式。我们不能在其中直接列出类名。我们需要使用对象语法或数组语法来设置 JS 表达式。*

*![](img/729dab78f6db5b45ec1dea4c89b5d905.png)*

*我们将从对象语法开始。*

*我们使用 CSS 类名作为属性名。属性值是一个布尔值。True 表示将应用 CSS 类。*

*![](img/e2b8dea23b6a09589cc64fe7722f2d9d.png)*

*让我们测试这个程序。*

*我们可以看到外部 DIV 接收了两个新类:bgTwo 和 textTwo。*

*![](img/e2f73f901e50a1d4c00f7a05c7b06291.png)*

*我们可以用根组件中的数据属性代替静态布尔值作为属性值。这样，根组件可以控制类。*

*我们把 BG 赋给 bgOne。然后我们把反转的 BG 赋值给 bgTwo。将只应用一个背景类。*

*对于这两个文本属性，我们以相同的方式设置它们的值。我们使用文本属性来控制它们。将只应用一个文本类。*

*![](img/6c87afea7e04501f1bef94e8976cf55a.png)*

*接下来，我们转到数据选项来定义 BG 属性和 Text 属性。我们将这两个属性都设置为 true。*

*![](img/cb28ac8d502deb21a952bdacbfd750ae.png)*

*让我们测试这个程序。*

*我们可以看到已经应用了 bgOne 和 textOne 类。*

*![](img/2299259a94fb646e0714f34acf8d749d.png)*

*通过反转 bg 和 text 属性的值，我们可以更改应用于外部 DIV 的类。*

*![](img/1114857d02e8f0f08cd47ba7e4fb07db.png)*

*接下来，我们创建一个按钮来帮助我们改变背景颜色。我们用它来反转 BG 属性的值。*

*我们创建另一个按钮来改变文本颜色。机理和以前一样。当我们单击按钮时，我们反转 text 属性的值。*

*![](img/6e6cf8974196bae48cd34de900f90138.png)*

*现在，通过点击这两个按钮，我们可以改变背景颜色和文本样式。*

*![](img/0a298b9066b5367076c12fcb5727122c.png)*

*接下来，我们为 class 属性分配一个新的 Vue 数据属性。我们称之为主题。*

*然后我们转到根组件来定义主题属性。*

*我们使用一个对象来设置它的值。在对象中，我们设置了两个属性:bgOne 和 textOne。两个属性值都为真。现在，仅主题属性就可以设置两个类。*

*![](img/0d59870f585e91d78a2f2a5372cbf577.png)*

*我们也可以将主题属性定义为一个数组。将添加数组中列出的类。*

*![](img/677a7b40ac65b312b98d50364d35caea.png)*

*接下来，我们为四个类定义了四个数据属性。这四个属性是四个类的别名。*

*![](img/f3c48f3ad00aac1974679aa675db78fe.png)*

*我们为 class 属性分配一个数组，并使用类别名设置元素。*

*![](img/6c1f89517a0beac11e9833b49dad559a.png)*

*我们可以看到 bgTwo 类和 textTwo 类都已成功应用。*

*![](img/0381363eb330d5bfede725e803df41d4.png)*

*我们也可以使用更严格的对象语法和数组语法。我们使用一个对象来设置元素。语法和以前一样。属性名是类名，属性值决定是否添加该类。*

*![](img/ab1761cb776fb71368149e2afbc79af3.png)**![](img/e72088e098234fd9e50a8d1221c4bf33.png)*

*一旦我们用 v bind 指令给 class 属性加上前缀，class 值就变成了一个 JS 表达式。类名只能在 JS 表达式中用作属性名。*

*在这一课中，我们将向您展示如何控制内联 CSS 属性。*

*我们用 v bind 指令作为 style 属性的前缀，并给它分配一个对象。*

*![](img/8c1684d7cbcfe21d65d90be6d0b9a1a5.png)*

*本机 CSS 属性用作属性名。属性值可以是组件实例中的静态值或数据属性。*

*小心使用原生 CSS 属性名。对于 JS 属性名，破折号是非法字符。我们不能直接使用它。*

*![](img/946d1705e5ceb1f82bbb08ed2701af1c.png)*

*我们可以看到我们得到了一个警告和一个错误。这个问题是由仪表板引起的。合法的属性名不能有它。*

*![](img/b9a640572f682c95185e6ca3c7110e04.png)*

*我们需要去掉破折号，把它后面的字母大写。*

*![](img/8c7394b18dce0f915cb16398104ea7a3.png)*

*让我们再试一次这个程序。*

*这一次，问题解决了。外部 DIV 的背景色设置为红色。*

*![](img/8c7394b18dce0f915cb16398104ea7a3.png)*

*接下来，我们用 Vue 数据属性替换静态值。我们把它命名为 bgColor。*

*![](img/45d463c548246059f84622c5c09b9476.png)*

*然后，我们转到数据选项，在 bgColor 的名称下定义一个属性。我们使用颜色代码设置它的值。*

*![](img/dd0e7116851a8b10fc22ddebc6c78720.png)*

*我们可以看到新的背景色已经设置好了。*

*![](img/5940846fcf90475a42b83d9f32ee896f.png)*

*通过更改 bgColor 属性的值，我们可以控制外部 DIV 的颜色。bgColor 的值将被分配给本机 CSS backgroundColor 属性。*

*有时，我们可能需要一起控制几个 CSS 属性。*

*在数据选项中，我们创建了一个新的属性:styleObject。它的值是一个对象。*

*![](img/e66eaa72dc0a76f0ea1d4d5452d428b9.png)*

*我们在其中设置了三个 CSS 属性:背景颜色、文本颜色和字体大小。破折号应该去掉，后面的字母应该大写。*

*![](img/f07c01e7b9a84cd50ae9e7d4fdbd8e4e.png)*

*然后，我们使用 v bind 指令将 styleObject 属性分配给 style 属性。*

*![](img/a1e759709a2939f807c76cf64c495793.png)*

*让我们测试这个程序。*

*我们可以看到所有三个 CSS 属性都应用到了外部 DIV。*

*![](img/d94c3f067e3018eb652dc4c4fc83494b.png)*

*styleObject 属性存储分配给 style 属性的值。通过更改其属性值，我们可以重置外部 DIV 的样式。*

*对尺寸值要非常小心。它的值是字符串，而不是数字。你必须保留附录 PX。不要仅使用数字来设置大小值。*

*![](img/2442650c1201798ba523f6b8786be90c.png)*

*有时，我们可能需要修改尺寸值。在这种情况下，我们必须将 size 属性定义为一个数字。*

*我们绑定了另一个样式属性，并给它分配了一个对象。我们将 fontSize 属性的值与 PX 连接起来。*

*![](img/215f5736db6c5e8826bc92e03402f240.png)*

*让我们测试这个程序。*

*我们可以看到我们的字体大小设置不工作，即使我们有 PX 的附录。*

*![](img/cea0747cd0fc5303bdfb14529a40f569.png)*

*原因是我们设置了两个样式属性。一个 HTML 标记只能有一个样式属性。*

*![](img/264fa225d5f38b13f4940ec864edd69a.png)*

*如果您需要设置几个 CSS 属性，并且它们的值分散在几个数据属性中，您可以组合数组语法和对象语法。我们给样式属性分配一个数组。每个元素都是一个对象。*

*我们将 styleObject 属性设置为第一个元素。*

*至于第二个元素，我们使用一个对象文字来设置它。我们使用本机 fontSize 属性作为键。记住去掉破折号，将字母 s 大写，然后我们使用 Vue 数据属性 fontSize 设置该值。记得加 PX 附录。*

*![](img/18ee9ea79688b7a936ad4fc8c1ba2651.png)*

*让我们测试这个程序。*

*我们可以看到所有三个 CSS 属性都被添加到了外部 DIV 中。*

*![](img/e0069262a6a79cf43ee1a77f6282ba1a.png)*

*在本课中，我们将讨论 Vue 生命周期挂钩。钩子是在预先定义的时间自动执行的函数。这是将我们的定制代码集成到已建立的程序中的一种非常有效的方式。*

*![](img/eda40c88f7eefe2cf3a67d3a9de5ebdf.png)*

*Vue 挂钩是在组件级别定义的。每个组件都有自己的挂钩。这个 in hook 函数指向拥有它的组件实例，这样我们就可以轻松地访问组件数据属性和方法。*

*前四个钩子标记了一个全功能组件实例创建过程中的四个关键点。*

*![](img/2b268ccfc55e896c58632c51859be792.png)*

*此图显示了根组件的生命周期。对于子组件来说，情况基本上是一样的。*

*这两个创建钩子在应用程序实例准备好之前和之后执行。一旦完全创建了应用程序实例，它就可以接受和存储外部数据。*

*这两个安装挂钩在组件安装之前和之后执行。只有安装的组件对用户可见。*

*创建的钩子是与后端 API 交换数据的最佳位置。此时，data 选项中定义的属性都已经创建好了，可以接收数据了。*

*当我们修改组件模板中显示的组件属性时，两个更新钩子将被触发。这里注意，两个更新钩子不是 watchers。他们只监视组件模板中使用的组件属性。*

*组件属性包括数据属性、计算属性和属性。我们将在后面的课程中学习什么是道具。*

*当从模板中删除一个组件时，将触发两个卸载挂钩。移除的组件可以是根组件或普通的子组件。*

*在 Vue 2 中，这两个卸载钩子被称为 beforeDestroy 和 Destroy。*

*在我们的实际项目中，我们通常只移除子组件。根组件总是被挂载，否则整个程序就消失了。*

*![](img/db70bcbd1097f1453731377594d3ef3f.png)*

*接下来，我们来试试这八个挂钩。*

*我们这里有一个非常简单的 Vue 程序。根组件有两个数据属性:标题和钩子。它们都显示在组件模板中。*

*![](img/9d0eb28c80e7bd25d6ca9c7e28b38d57.png)*

*首先，我们添加 beforeCreate 钩子。我们输出钩子名称并检查它的 THIS。*

*![](img/c4f575c61a7dde83c8b711bf9d170cfb.png)*

*beforeCreate 挂钩在应用程序实例准备就绪之前被触发。控制台日志语句以某种方式向我们返回完全创建和挂载的组件实例对象。*

*这是一个误导性的巧合。这是由我们访问引用类型值的方式造成的。*

*对象(包括代理对象)是引用类型的值。我们通过它们的内存地址来访问它们。相同的内存地址在不同的时间会返回不同的结果。*

*这在生命周期挂钩中存储组件实例对象的内存地址。*

*当我们打开代理对象时，组件实例已经被创建和挂载了。这就是我们得到完整创建的组件实例对象的原因。*

*在 beforeCreate 钩子的执行过程中，组件实例对象远远没有准备好。如果我们试图通过这个输出一个特定的数据属性，我们会得到未定义的。例如，我们在 beforeCreate 钩子中输出这个点标题。*

*![](img/aa10e7c3d9a37a9b6c7426aa18488856.png)*

*在完全创建的组件实例对象中，美元符号数据属性指向存储数据属性的代理对象。*

*如果在 beforeCreate 钩子中输出美元符号数据对象，我们将得到一个空对象。这个对象还是一个普通的对象。还没有变成代理。*

*![](img/0efd32507cc2bdc66f6666c3ffcd1687.png)*

*接下来，我们添加创建的钩子。*

*我们首先输出钩子名称。*

*如果我们输出这个，我们将遇到同样的问题:我们将得到一个完全创建和挂载的组件实例对象。*

*![](img/26da8e196c8a1ee03283c88795e8c513.png)*

*在创建的钩子的执行过程中，APP 实例已经创建，但是还没有挂载。组件离完全就绪只有一步之遥。*

*我们输出美元符号数据对象。*

*我们得到了一个存储数据属性的代理对象。这些属性可以存储外部数据。*

*![](img/ee85dbbe2e255d84f917d8fda0cf4380.png)*

*该组件尚未安装。如果我们检查美元符号 EL 属性，我们将得到 null。*

*![](img/eb4955d93879e18b626d8d0e4baa97b0.png)*

*接下来，我们添加 beforeMount 钩子。*

*我们已经知道直接输出这个的问题。在这里，我们只检查美元符号 EL 属性。*

*让我们运行文件。*

*我们可以看到美元符号 el 返回我们 null。该组件尚未安装，尚未呈现任何页面元素。*

*![](img/f31b6c4c9637bd40b9bef7819e918839.png)*

*接下来，我们尝试安装挂钩。*

*我们仍然检查美元符号 EL 属性。*

*这一次，美元符号 EL 属性返回程序根 DIV 的 DOM 对象。*

*组件已经安装好了，它的模板已经呈现到实际的 DOM 元素中。*

*![](img/263869333ac8b6a12c94e25f9e996b5a.png)*

*H1 标签有一个 ref 属性，我们可以通过它的 ref 值访问它的 DOM 对象。*

*我们在挂载的钩子中输出$refs 属性。*

*我们得到一个代理对象。h1 标签的 DOM 对象存储在其中。从现在开始，我们可以访问由组件呈现的页面元素。*

*![](img/87765f3c01c4f8c887cfc1e461a26491.png)*

*接下来，我们移动到一个新文件。我们将在这里尝试两个卸载挂钩。*

*我们从 beforeUnmount 钩子开始。*

*我们首先输出钩子名称。然后我们检查三个关键属性:$data、$el 和$refs。*

*![](img/a9178723a98077077d80a88c5060d69a.png)*

*我们调用 app.unmount()方法来卸载根组件。*

*![](img/162d90233bbe5351a98ad1ee9766b91c.png)*

*当 beforeUnmount 挂钩被触发时，组件仍然是挂载的，并且完全正常工作。*

*美元符号数据属性仍然完好无损。所有数据属性都可用。*

*美元符号 EL 属性返回项目根 DIV 的 DOM 对象。在 beforeUnmount 钩子的执行过程中，这个 DOM 对象仍然显示。*

*美元符号引用属性返回给我们一个代理对象。*

*属性名是 H1，属性值是 H1 标签的 DOM 对象。*

*![](img/9b704c1ad76dd22cdf80f7c0b48b48d1.png)*

*让我们打开代理对象。*

*H1 房产的价值不知何故变成了零。*

*![](img/ca71c0f6571a465700633c03b54c59fa.png)*

*这与我们在 beforeCreate 挂钩中遇到的巧合是一样的。*

*当我们打开代理对象时，组件已经被卸载了。它渲染的所有页面元素都不见了。自然，H1 属性无法找到被移除的 H1 标签的 DOM 对象。这就是它返回 NULL 的原因。*

*在执行 beforeUnmount 挂钩的过程中，呈现的元素仍然显示。让我们证明这一点。*

*我们从美元符号引用对象中输出 H1 属性。*

*为了使我们的实验更有说服力，我为 H1 标签设置了一个 ID，我们可以使用本机文档 dot getElementById 方法来获取 H1 标签的 DOM 对象。*

*![](img/64a89573279a14cc56f58bcd92188a1a.png)*

*让我们再试一次这个程序。*

*我们可以看到 H1 标签的 DOM 对象已经被成功地获取了。我们可以通过它的 ref 属性或 ID 来访问 H1 标签。这证明了在 beforeUnmount 钩子执行期间，所有呈现的元素仍然在显示。*

*![](img/35a14053076fe2b1b2787e78c247facc.png)*

*接下来，让我们试试卸载的钩子。我们复制了一个 beforeUnmount 挂钩，并将其重命名为 unmounted。*

*![](img/9ebcde79ac77f15b2f4d5fc6bc7aa7ee.png)*

*让我们运行文件。*

*我们调用 unmount 方法来删除组件。*

*美元符号数据属性仍然完好无损。数据属性仍然可用。*

*![](img/5eb0f770add3198bf2e40354a3110b64.png)*

*美元符号 EL 属性返回根 DIV 的 DOM 对象。此 DOM 对象仍然存在，但已从浏览器窗口中删除。它不再展出了。您可以将此视为内存泄漏。我们不再需要这个 DOM 对象，但是它仍然存在于内存中。*

*![](img/fc3440dfe9fbe745660d526d04b49395.png)*

*美元符号 refs 对象仍具有 H1 属性，但其值为 null。*

*![](img/f63d8529deff0a8d66190316289d096d.png)*

*在 beforeUnmount 钩子中，H1 属性的值是 h1 标签 h1 。*

*![](img/3b2b8d586c546ea6a8bc0f0c5494d576.png)*

*在卸载钩子的执行过程中，由卸载组件呈现的所有页面元素都从浏览器窗口中移除。ref 属性和元素 ID 都返回 null。*

*![](img/24c9e41d69aaba6252a2db37dab5aa70.png)*

*您可能想知道为什么美元符号 EL 属性的值没有变成 NULL。*

*![](img/ef9b7c04ffc58d7b644b4376b8a0a226.png)*

*调用 app.unmount()方法不会删除根组件的实例对象。*

*如果我们输出 VM 变量，我们仍然可以获得根组件的实例对象。这件物品大部分完好无损。*

*![](img/db65d1020049f883c13376ae6290fc6f.png)*

*它的$el 属性仍然存储根 DIV 的 DOM 对象。这就是为什么卸载钩子的$el 属性仍然可以输出根 DIV 的 DOM 对象。*

*![](img/361cd52f892cbac9496f977554bdd3cf.png)*

*打开美元符号 refs 属性，你会发现一个不同的结果。*

*没有 DOM 对象。H1 属性的值为空。*

*ref 属性是 Vue 用来访问浏览器窗口中显示的元素的属性。H1 标签已被删除，因此 H1 属性的值已变为 NULL。*

*![](img/70af59427a95493b6a268a1af31cc64d.png)*

*结论是，在执行未计数钩子的过程中，组件呈现的所有 DOM 元素都已从浏览器窗口中移除。应用程序实例仍然完好无损。数据属性仍然可用。*

*![](img/b121948a7c599ec12c1694e94b1da9c2.png)*

*在这一课中，我们将尝试四个渲染相关的钩子。我们将从两个更新挂钩开始。*

*![](img/9b72b47bb2dd31ef70df0e0df4cc2814.png)*

*我们添加 beforeUpdate 挂钩，并在控制台日志中记录其名称。*

*然后我们以同样的方式创建更新的钩子*

*根组件有两个数据属性，它们都显示在组件模板中。修改其中任何一个都会触发两个更新挂钩。通过 DOM 对象进行的更改不会触发两个更新挂钩。*

*![](img/56b0553a985bd2d881825c4c3fbf78f3.png)*

*接下来，我们添加一个新的数据属性:City。我们做**而不是**在模板中显示它。*

*让我们给 city 属性分配一个新值，看看会发生什么。*

*值分配已成功。这两个更新挂钩不会被触发，因为组件模板中没有使用 city 属性。*

*![](img/b4f9ab8e6211ab3ecdb50db0469b74a7.png)*

*在 H2 标签中，我们绑定了标题属性，并使用城市属性设置其值。*

*现在，更改 city 属性的值可以触发两个更新挂钩。*

*![](img/698e74cebee78b8572a3c1973ad9bd1f.png)*

*不要让钩名误导你。更新意味着更新视图，而不是更新数据属性。*

*beforeUpdate 挂钩在赋值结束后触发。在赋值之前不可能触发 beforeUpdate 钩子，因为 Vue 无法预测你的操作。如果您需要监视数据属性的值变化，请使用观察器。稍后我们将了解更多关于观察者的信息。*

*接下来，我们用两个钩子输出 H1 标签的 DOM 对象。我们使用 H1 标签的 ref 属性来选择它。*

*![](img/be8c37a580af2ae3c8203ac97ce0bbf2.png)*

*我们重置消息值来触发两个更新挂钩。*

*两个更新挂钩的结果是相同的。它们都具有更新的消息值。*

*![](img/3d2f4e4509bdbc2d3845047cb78ab10f.png)*

*这不是真实的情况，原因和以前一样。我们来证明一下。*

*我们输出两个 DOM 对象的 innerText 属性。*

*让我们测试这个程序。*

*这一次，两个钩子的输出是不同的。beforeUpdate 钩子返回旧的内部文本。更新后的钩子返回给我们新的文本。*

*![](img/216e63921579a1d2beec724f7c08696c.png)*

*在更新后的钩子中，我们添加了 alert 方法。我们在其中输出标题属性。*

*![](img/ca4b072b1b4fda7aaf63c904dbf0cc96.png)*

*然后我们重置 title 属性的值来触发两个更新挂钩。*

*警报窗口将暂停程序执行，直到我们单击 OK 按钮。这使我们有机会检查 beforeUpdate 挂钩中的控制台日志语句是如何执行的。*

*仔细查看控制台表上的输出。*

*结果很有意思。*

*beforeUpdate 挂钩有四个控制台日志语句。控制台上有四个输出。第三个输出为空。*

*第三个输出来自第 24 行。我们在第 24 行输出 H1 标签的 DOM 对象。*

*预警窗口设置在更新后的钩子中。这意味着在更新钩子被触发之前，来自 beforeUpdate 钩子的控制台日志语句不会输出 H1 标记的 DOM 对象。这就是 DOM 对象和它的 innerText 属性不匹配的原因。*

*![](img/e08816a7ad04d23f5c34e1bdcb13aad0.png)*

*我们单击 OK 按钮恢复程序执行。*

*我们可以看到，单击 OK 按钮后，第 24 行留下的空白被 H1 标签的 DOM 对象填充。*

*只要记住 beforeUpdate 钩子是在 Vue 开始重新渲染模板之前触发的。它无权访问**更新的** DOM 对象。*

*打开 Vue API，你会发现一个叫 nextTick 的方法。*

*![](img/51355becafe3bf4477eea0a63348c22d.png)*

*打开根组件实例，您会发现一个类似命名的方法:$nextTick。*

*![](img/3248b1f82d85c838c7657ff20048dd9b.png)*

*这两个方法在下一个 DOM 更新周期后执行，它们可以返回给我们更新后的 DOM 属性值。*

*我们将它放在 beforeUpdate 方法中，并向它传递一个回调。在回调中，我们输出 H1 标签的 innerText 属性。*

*![](img/9590cb1569aeabda64436220b7092625.png)*

*我们重置 title 属性来触发两个更新挂钩。*

*nextTick 方法的回调在最后执行，在更新的钩子后面。因此，它返回给我们更新的内部文本值。*

*![](img/b5ea90e124245370d6eef09ab128e261.png)*

*接下来，我们打开警报方法。*

*我们可以看到，如果我们不点击 OK 按钮，传递给 nextTick 方法的回调就不会执行。*

*![](img/95ca4d14f1cae6902dae4de8b089cd00.png)*

*这是我们之前创建的程序。*

*我们有一个输入标签。它的 v 模型指令连接到消息属性。在输入框中键入的字符将被保存到消息属性中。*

*输入框也监视输入事件。每次我们输入一个字符，check 方法就会被触发。*

*check 方法首先检查消息属性的长度。如果长度超过要求，它将被 subString 方法截断。截断的值将被赋回消息属性。这就是我们如何控制用户可以提交的最大字符数。*

*![](img/cb9ddf9a1b1047550d558c53bd9491a9.png)*

*check 方法仅由输入事件触发。如果我们通过组件实例重置消息属性，检查方法将不会响应。*

*![](img/8b19c15a2611a3dccc1340850533a4ea.png)*

*为了能够从各个角度观察消息属性，我们需要观察器。Vue 为我们提供了三种设置观察器的方法。*

*打开组件实例，您会发现一个名为$watch 的方法。这是我们在组件实例中使用的。*

*![](img/c691d83502aaf91d856094c746d56a26.png)*

*打开 Vue API 并滚动到底部，您会发现一个名为 watch 的方法。该方法不依赖于工作组件实例。我们主要在设置功能中使用。我们将在以后的课程中学习。*

*![](img/d449b0db8ad0776479a9aa9f125ad410.png)*

*第三个选项是观察选项。我们在选项对象中设置它，就像数据选项或方法选项一样。其行为与美元符号监视方法相同。*

*我们将从手表选项开始，因为它使用起来更方便。*

*![](img/8cd1889f07079a27a3702223e031d6e0.png)*

*我们希望观察消息属性。我们创建了一个同名的函数。*

*函数名必须与被监视的属性完全相同。除了数据属性，您还可以观察计算属性和属性。我们后面会学到什么是道具。*

*watcher 函数接收两个参数。第一个是表源的新价值。第二个是前一个值。*

*我们控制台记录这两个参数。*

*![](img/ba52e075ea3b0e9c371ef0d96388dbf7.png)*

*让我们测试这个程序。*

*我们可以看到，每当我们输入一个新的字符，消息监视器功能触发。它输出最新的消息值和先前的消息值。*

*![](img/3d5c57eae3014b112af6ab7451d9348a.png)*

*观察者的反应就像 v on 指令一样及时。这使得 v on 指令过时了。我们可以将它从输入标签中移除。*

*也不需要 check 方法。*

*![](img/74c26d0227ea540f70be5d4809b3db56.png)*

*我们在消息观察器函数中检查和处理消息值。*

*问题是如何从 watcher 函数内部访问 message 属性？如果你是 Vue 的设计师，你会怎么做？*

*让我们在消息观察器中输出它，看看它指向哪里。*

*我们得到一个代理对象。*

*该对象是根组件的实例对象。这在观察器函数中指向拥有观察器函数的组件实例。*

*![](img/858e9c63481c7224f51137de76790aa8.png)*

*我们添加一个 IF 语句。*

*我们将新值的长度与 max 属性进行比较。max 属性是通过这个访问的。我们截断新值，并将截断的值分配给消息属性。*

*![](img/18b34b38291db751b389b359974d8ee3.png)*

*让我们测试这个程序。*

*每当我们输入一个新字符，消息监视器就会被触发。*

*达到限制后，多余的字符将被删除。因此，输入框最多接受十个字符。第 11 个字符会一直被删除。*

*![](img/92e7fa4ac7f4f0f1c46811e07666f954.png)*

*如果我们直接给消息属性赋值，多余的字符也会被删除。*

*任何改变消息值的操作都会触发消息监视器。换句话说，消息属性从各个角度受到保护。*

*![](img/241b7e773eb4f761ca302b18339afa4d.png)*

*您可以为同一个目标设置多种监视功能。我们将在后面的课程中向您展示细节。*

*接下来，我们来看看 watchers 的现实应用。*

*我们这里有一个模拟天气应用程序。我们将在后面的课程中创建一个可用的天气应用程序。*

*![](img/a23a399ea576dc1be015cf23bf8f7da4.png)*

*我们有两个数据属性:city 和 weatherInfo。*

*我们还有一个名为 query 的方法。它有一个论点:城市。它使用传递给它的城市名查询后端 API。然后，它将检索到的天气信息分配给 weather info 属性。*

*![](img/097efde604417c18f3e8d327cb2399bb.png)*

*我们希望用户从预定义的城市列表中进行选择。每当他们选择一个新的城市，该城市的天气信息应自动检索。*

*为了帮助用户选择城市，我们添加了一个输入标签，并将其类型设置为 radio。*

*我们添加 value 属性并将其设置为 London。然后，我们添加 v model 指令，并将其值设置为 city 属性。*

*让我们运行文件。*

*我们有一个单选按钮，它代表伦敦。单击它会将城市属性设置为伦敦。*

*![](img/bb346b11ba2e1069232b15bf04489ae3.png)*

*接下来，我们再复制两个单选按钮。我们将城市名称分别改为达勒姆和悉尼。*

*现在，我们有三个单选按钮。他们都与城市财产有关。通过单击这三个按钮，我们可以更改 city 属性的值。*

*![](img/3f995b7014a2111d519c5087fd5dc00c.png)*

*更改城市属性只是第一步，我们还需要触发查询方法，使用新的城市名称进行新的查询。*

*知道如何用查询方法连接这三个单选按钮吗？*

*我们添加 v on 指令并监控输入事件。我们触发查询方法，并将当前单选按钮代表的城市名传递给它。*

*然后我们将 v on 指令复制到另外两个输入标签中。*

*传递给查询方法的城市名称需要手动更新。*

*![](img/dad5f0dae9b38b59abe6d2f6a70a8c46.png)*

*这个程序可以很好地工作，但是它的设计并不优雅。每个输入标签需要两个 Vue 指令:v model 和 v on。*

*每个输入标签都要求我们用不同的城市名设置一个查询方法。这使得以后的程序维护相当不方便。例如，如果需要用另一种方法替换查询方法，就需要修改所有的输入标签。*

*你知道如何改进这个项目吗？*

*只有当 city 属性的值改变时，我们才会触发查询方法。为什么我们不为城市财产设立一个监视者？我们可以从 watcher 函数内部触发查询方法，并将新的城市名称传递给它。*

*输入标签不再需要 v on 指令来触发查询方法。他们唯一的工作就是修改城市财产的价值。*

*我们添加了监视选项，并为 city 属性设置了一个监视器。*

*出于演示目的，我们在控制台日志中记录了以前的和新的城市名称。*

*我们通过这个调用查询方法，并将新的城市名传递给它。*

*![](img/ed9c641854db421a082f5c7c97a862fe.png)*

*这个程序和以前一样工作。每当我们切换到一个新的城市时，查询方法就会被触发，并使用新的城市名称进行新的查询。*

*相比之下，代码质量要高得多。*

*![](img/142c879d8396c3e0b9bb78ed7a7e676a.png)*

*所有输入标签只有一个 Vue 指令:v 模型指令。所有输入标签的指令值都是相同的。*

*要添加新的输入标记或修改现有的输入标记，我们只需要更改 value 属性，其他都是一样的。*

*最重要的是，这些输入标签和查询方法之间没有硬连接。*

*输入标记与查询方法完全分离，它们只负责修改城市属性的值。*

*城市财产由城市守望者无线监控。每当它的值发生变化时，城市观察器就会注意到并触发带有新城市名称的查询方法。*

*如果我们需要用另一种方法替换查询方法，我们只需要在 city watcher 中进行一次修改。在前面的程序中，我们必须更新所有输入标签中的 v on 指令。*

*接下来，我们给 city 属性一个初始值。我们把它设定在伦敦。*

*让我们刷新页面。*

*城市名称已设置为伦敦，但天气描述保持不变。*

*![](img/faff0a039e86cfaf82c8f434e8512b72.png)*

*当我们刷新页面时，我们希望查询方法被自动触发，并使用默认的城市名进行查询。知道怎么做吗？*

*最简单的解决方案是在创建的钩子中手动调用查询方法。*

*或者，我们可以简单地要求城市观察者在程序初始加载时做出响应。*

*我们使用对象语法设置城市观察器。*

*在对象内部，我们添加了处理函数。在它后面，我们添加了 *immediate* 属性，并将其值设置为 true。其默认值为 false。*

**Immediate* 表示当我们第一次加载页面时，观察器立即响应。*

*处理函数的语法和以前一样。它有两个参数:当前值和前一个值。当被监视的属性的值改变时，它将被触发。*

*处理函数应该使用完整的函数来定义，这样 Vue 就可以将其 THIS 重定向到组件实例。*

*我们通过这个方法访问查询方法，并将新的城市名传递给它。*

*![](img/04fb2a75f8ee2266a39f622095503c3b.png)*

*让我们测试这个程序。*

*我们可以看到，刷新页面后，城市观察器被触发。*

*以前的值是未定义的，新值是伦敦，这是我们为 city 属性设置的默认值。查询方法已被触发，并使用伦敦进行了查询。*

*![](img/cf260395fae0e4b113e896eb2dd38e0d.png)*

*在我们的实际项目中，我们经常将 *immediate* 属性设置为 true，以使程序能够自动查询后端 API 来检索初始数据。这样，我们就不必在创建的钩子中手动调用查询方法。*

*如果需要设置几个观察器函数，将对象放在一个数组中。*

*大多数时候，我们只观察像数字或字符串这样的原始值。但是您还应该知道如何观察引用类型的值，比如数组或对象。*

*![](img/07c95a61172ade3c4ef84659b1dc9b8a.png)*

*我们将从数组开始。*

*首先，我们观察整个数组。我们用数组来命名观察器。我们使用对象语法设置观察器。*

*![](img/7f7c0567fadd4574c3fbc2975598dd24.png)*

*为了支持反应性，Vue 将引用类型的值转换成代理对象。*

*![](img/6e30044a83b0bc769a2657b3d2d47547.png)*

*这意味着列表监视器实际监视的是数组代理对象的内存地址。*

*操作数组元素不会改变数组代理对象的内存地址。因此，列表观察者不会响应。*

*![](img/aaedb2a2fed0085144d5283faef7b87b.png)*

*为了触发列表监视器，我们需要给列表属性分配一个新的数组体。*

*![](img/5e60bd7bc07a2d17fe4c9940140b797c.png)*

*没有两个数组是相同的，这意味着它们不会共享相同的内存地址。如果我们给列表属性分配一个相同的数组，列表监视器仍然会响应，因为内存地址已经改变。*

*![](img/af84d31bf33095eb3185aab94184b4bc.png)*

*显然，这不是我们想要的结果。*

*为了监视元素的变化，我们需要将 *deep* 属性设置为 true。其默认值为 false。*

*![](img/352991c50398cbedff7b2448cdfc8c97.png)*

*现在，修改数组元素可以触发列表监视器。*

*因为只有一个数组，所以处理函数的两个参数都指向更新后的数组。我们会得到同样的结果。*

*![](img/691659e80f80b3969e0834c23d47acb3.png)*

*在我们的实际项目中，我们可能需要监控给定数组的元素总数。我们可以为数组长度创建一个观察器。*

*我们用引号将列表点长度括起来，并将其用作观察器名称。*

*![](img/da711ceb86d9fac2fcec296653a196ff.png)*

*让我们测试这个程序。*

*我们去掉一个元素。*

*长度监视器已被触发。它显示了以前的元素总数和当前的元素总数。*

*![](img/5b97a179c233d66ccab4fadfaf9cef3a.png)*

*接下来，让我们尝试观察一个选定的元素。我们选第一个。*

*![](img/20779e957b7b2e8c4fa3cedcf4b49be5.png)*

*我们重置第一个元素值。*

*第一个元素的观察者没有反应。触发的观察器是数组观察器，而不是第一个元素的观察器。*

*![](img/20779e957b7b2e8c4fa3cedcf4b49be5.png)*

*接下来，我们添加 deep 属性并将其设置为 true。*

*![](img/662ce6db05586a2d2e2d81b7d9d73559.png)*

*让我们再试一次这个程序。*

*第一个元素的观察者仍然没有反应。*

*![](img/f129729e9200705bf9e3df91ea468e2c.png)*

*结论是在观察选项中，避免观察特定的数组元素。*

*![](img/bffdb1af3292883299ad47df4918ac43.png)*

*但是，可以观察对象属性。例如，我们观察汽车对象的品牌属性。*

*![](img/03a53ca31888987720e600020d6ec314.png)*

*我们重新设定了品牌价值。*

*我们可以看到品牌观察器已被触发。*

*![](img/58a38f13d5d3160cc4a04b01fc32fc95.png)*

*在本课中，我们将讨论观察器函数的刷新时间。我们有三个选项:前置、后置和同步。Pre 是默认值，也是推荐值。*

*flush 属性决定是在页面重新呈现之前还是之后执行观察器。如果将其设置为 sync，则在页面重新呈现的同时执行观察器。*

*![](img/f914c06051845f2fe156dc331516be74.png)*

*我们这里有一个消息属性。它显示在 H2 标签中。H2 标签有一个 ref 属性，帮助我们检索它的 DOM 对象。*

*![](img/c5b6c7466e5d748907c322ac749fbfad.png)*

*在设置 watch 选项之前，我们首先添加四个生命周期挂钩。它们是在更新之前创建、装载和更新的。我们将比较消息观察器和这四个钩子的执行时间。*

*![](img/fcbeb22d31e8eb022220cb36d2df2df1.png)*

*接下来，我们添加 watch 选项来为消息属性设置一个观察器。*

*我们使用对象语法。在处理函数中，我们输出前一个值和当前值。我们将 immediate 属性设置为 true。*

*默认刷新值是 pre。观察器在页面重新呈现之前触发。*

*![](img/15888b878b7f5a2ab36fa9037c232a7b.png)*

*让我们运行程序。*

*我们可以看到消息监视器甚至在创建钩子之前就被触发了。*

*![](img/263709dc82e4f1b6ba56976ecf177e73.png)*

*接下来，我们重置消息值。*

*消息观察器在 beforeUpdate 挂钩之前触发。*

*![](img/d5322bd8d42859304eccf1720b5fe10f.png)*

*我们回到处理函数，输出 H2 标签的内部文本。因为消息观察器在页面重新呈现之前触发，所以我们应该获得前一个消息值。*

*![](img/b50bc2729ae707495b78e38348519b43.png)*

*我们得到一个警告和一个错误消息。*

*因为我们已经将 immediate 属性设置为 true，所以当我们刷新页面时，消息观察器会在组件挂载之前触发。因此，H2 标签还没有被创建。因此我们无法访问它的 innerText 属性。*

*![](img/5b8f47708699c7272bed9bd13066c250.png)*

*在输出 innerText 属性之前，我们需要检查 H2 标签是否存在。*

*![](img/1598e364204714cc546e94cf017f9d0a.png)*

*让我们再试一次这个程序。*

*我们可以看到 H2 标签的内部文本是旧的消息值。这证明了消息观察器在页面重新呈现之前触发。*

*![](img/2e2b4c15aa5e87dc95f7e1aa2106b5ff.png)*

*接下来，我们将前置转换为后置。*

*让我们再运行一次文件。*

*在创建钩子之前，观察器仍然被触发。*

*![](img/f23b7c5a4f790f4ac92a91ac6d3b3776.png)*

*我们重置了消息属性。*

*我们可以看到这次执行顺序改变了。*

*消息观察器在 beforeCreate 挂钩之后但仍在 created 挂钩之前被触发。*

*H2 标签的内部文本现在是更新的消息值。这证明消息观察器是在页面重新呈现后触发的。*

*![](img/200c0108ede3269d5ff458bd0850d53f.png)*

*接下来，我们来试试 sync。不建议同步，因为它会消耗过多的资源。*

*初始监视仍然发生在创建钩子之前。*

*![](img/276f4fd3007d8d9adfab2fd223e99ec4.png)*

*我们重置消息值。*

*我们可以看到消息观察器在 beforeCreate 挂钩之前被触发。H2 标记的内部文本仍然是旧的消息值。当页面重新呈现自身时，消息观察器触发，因此消息观察器不能访问更新的内部文本。*

*![](img/41e236fe48c77bae9d51e8b599adb472.png)*

*在现实项目中，最好的同花选项是 pre，因为它允许观察者尽快做出反应。*

*您可以将观察器视为一种特殊类型的挂钩。它监控目标值，并在目标值改变时触发。*

*我们可以为同一个目标设置多个观察函数。我们把它们放在一个数组中，它们将按照数组中定义的顺序执行。*

*![](img/dfc5c91f0a8ab801f158f7d6c9bb76e9.png)*

*如果使用函数语法，应该使用完整的函数来使 Vue 将其 THIS 重定向到组件实例。*

*语法和以前一样。watcher 函数接收两个参数。第一个是新值，第二个是以前的值。*

*![](img/3b8d8522006ffd054ee8cee36609582d.png)*

*我们复制了一个监视函数。我们在新的观察器中控制台日志*第二个消息观察器*。现在，我们已经将两个观察器函数绑定到消息属性。这两个函数将按照它们在消息数组中定义的顺序执行。*

*![](img/21870775430e5b36ee1c6e9682590dbf.png)*

*让我们运行文件。*

*我们重置消息值。*

*两个观察器功能都被触发。它们的触发顺序与在消息数组中定义的顺序相同。*

*![](img/a21ed380b2b3f4b16fbc86cf3b428abd.png)*

*接下来，让我们试试对象语法。*

*我们将两个对象添加到消息数组中。*

*语法还是和以前一样。我们首先定义处理函数。在处理函数后面，我们设置了三个配置属性。我们将*立即*设置为真，将*刷新*为预。*

*![](img/de413b90e7821b22fa9e4dc901f9d63a.png)*

*然后，我们将处理函数和两个配置属性复制到第二个对象中。*

*在这里，我们将*立即*设置为假，并将*刷新*到 post。*

*![](img/b1359d670ed3aac346e6dd63d598bb7d.png)*

*现在，我们已经将两个观察器函数绑定到消息属性。这两种观察器功能具有不同的设置，因此具有不同的性能。*

*让我们运行程序。*

*当我们第一次加载页面时，只有第一个处理函数被触发。*

*![](img/597021c7c1f05eac80070a0b10d8c743.png)*

*我们重置消息值。*

*这一次，两个处理函数都被触发。*

*第一个是在 beforeUpdate 挂钩之前触发的。第二个在两个更新挂钩之间触发。这是因为两个处理函数有不同的刷新设置。*

*![](img/b200186bcca6b97ae2887fa4b7ec33c9.png)*

*接下来，我们切换两个处理函数的刷新设置。*

*![](img/4b3a0c35a39a3222b80088bba262d0f7.png)*

*让我们再运行一次文件。*

*我们重置消息值。*

*这一次，第二个处理程序首先被触发，因为它的刷新时间比第一个早。*

*![](img/303c31369a0dcb373fcf0ef82e7327e7.png)*

*通过 watch 选项监视数据变化很方便，我们只需要列出目标名称和属性名称。然后我们给它分配一个函数或者一个对象。*

*作为一个折衷，watch 选项并没有为我们提供对观察器和观察源的足够控制。*

*我们无法控制观察器的开始和结束。*

*使用目标名称作为属性名称意味着我们不能设置复杂的表达式来监视计算值。*

*这就是 Vue 在每个组件实例对象中提供$watch 方法的原因。*

*![](img/b5731cba959d224ae3bcbc51d6195187.png)*

*$watch 方法的行为与 watch 选项相同，但给了我们更多的控制权。*

*Vue API 还提供了一个观察方法。这两种方法很相似。我们将在后面的课程中学习 Vue 手表方法。*

*![](img/972c9027d64affd1e24ad82f66071986.png)*

*我们删除了监视选项，并添加了创建的钩子。*

*在创建的钩子中，我们通过这个调用$watch 方法。现在，当应用程序实例被创建时，一个观察器将自动启动。*

*如果您将$watch 方法放在一个普通的 Vue 方法中，那么观察器只会在我们调用该方法之后启动。因此，我们可以控制观察器的启动。*

*![](img/d4a7165ff5e18dff79c690b5852bff3f.png)*

*$watch 方法有三个参数。第一个指定了观察源。手表来源是我们监控的值。*

*这里，我们使用城市属性的名称来设置它。城市需要用引号括起来。我们使用属性名作为观察源。我们不将属性传递给$watch 方法。*

*现在，城市财产的价值受到关注。*

*![](img/fe811c90fb92ff7be18e790afa797ff4.png)*

*第二个参数是处理函数。它接收观察源的新值和以前的值。顺便说一下，这里的函数应该使用 arrow 函数来定义，这样它就可以从创建的钩子中继承 THIS。*

*![](img/b00246ff6b6b78b9c471ec5dcbac92d3.png)*

*最后一个参数是一个配置对象。我们在这里设置了三个属性:immediate、deep 和 flush。*

*我们将 immediate 属性设置为 true，并跳过其他两个属性。*

*![](img/b5a54be27fc824349255fa4adedf3a2c.png)*

*让我们测试这个程序。*

*因为我们已经将 *immediate* 属性设置为 true，所以城市观察器在我们第一次加载页面时触发。*

*![](img/a0dce69293440ce05e2f701227e5a494.png)*

*我们重置了城市值。*

*城市守望者又被触发了。处理函数已经输出了以前和当前的城市名称。*

*![](img/ae11e6f052d759a3de7040a2c13bd95c.png)*

*您可以使用多种美元符号监视方法来监视同一个目标。*

*我们复制了美元符号手表功能。*

*我们仍然监视着城市财产。*

*在 handler 函数中，我们输出了*第二城市观察者*。*

*然后我们将*的直接*属性改为 false。*

*![](img/3b001b37ac053e9e300e219006d0046a.png)*

*让我们刷新页面。*

*只有第一个$watch 方法被触发。第二个没有响应，因为它的*立即*属性被设置为 false。*

*![](img/da4ea9724a5db2d51593c1140e4ee371.png)*

*我们给城市财产赋予一个新的价值。*

*这一次，两个$watch 方法都被触发了。*

*![](img/9292d713918a40341c407981e197e302.png)*

*接下来，我们创建一个新的数据属性。我们将其命名为 *stop* ，并将其值设置为 null。*

*我们将第一个美元符号监视方法分配给 *stop* 属性。*

*![](img/6998266fa920405e231dba66d614472c.png)*

*让我们检查一下*停止*属性。*

*我们可以看到它的值是一个停止函数。每个美元符号监视方法都返回一个专用的停止函数。*

*![](img/d49062fa22fbfbfa70a1d4556056c839.png)*

*如果我们不运行停止功能，第一个观察器将继续工作。*

*一旦我们调用了 stop 函数，第一个观察者就会停止。*

*我们可以看到我们已经重置了城市名称，但是第一个观察者没有反应。已经被制止了。第二个守望者仍然照常工作。*

*![](img/0efcf517c1804ca5d4c391de5f1a51de.png)*

*第二个$watch 方法在我们第一次加载页面时不会响应，但这并不意味着它会被搁置。当程序加载时，Vue 仍然注册它。*

*我们声明一个新的数据属性:stopTwo。*

*我们将第二个$watch 方法分配给 stopTwo 属性。*

*此时此刻，第二个$watch 方法还没有被触发。*

*我们检查 stopTwo 属性。*

*我们可以看到它的值是一个停止函数。*

*![](img/67c75f171de16989cc2733fe57bb6ce0.png)*

*我们援引它。*

*然后我们重置城市值。*

*我们可以看到只有第一个美元符号方法被触发。第二个美元符号观看方法已停止。*

*![](img/e61b860f1edfbe3953def2b68b81402d.png)*

*在上一课中，我们向您展示了如何使用美元符号观察方法来观察原始值。在这一课中，我们将学习如何观察引用类型值。*

*![](img/c43d217ea3efbf5acf3f0cfc8fb5c6a0.png)*

*我们将从数组开始。*

*我们仍然在创建的钩子内部设置$watch 方法。*

*我们使用属性名*列表*作为第一个参数值。不要忘记引用。*

*在处理函数中，我们输出前一个值和当前值。*

*在 config 对象中，我们将 immediate 属性设置为 true，将 deep 属性设置为 false。*

*![](img/b9f3de687f9aa4fc1b403cd22ad0efe8.png)*

*让我们运行文件。*

*为了支持反应性，Vue 将列表数组转换成了一个代理对象。但是这个代理对象的行为仍然像一个数组。它适用于所有与数组相关的方法。*

*![](img/d314fab6d0a88d6e591dff54210a49ec.png)*

*让我们从列表数组中移除一个元素。*

*列表监视器没有响应。*

*让我们重置第一个元素值。*

*观察者仍然没有反应。*

*![](img/d0ce48205bc7673ef12fb6d57757c5dc.png)*

*列表监视器只监视列表数组的代理对象的内存地址。操作数组元素不会改变内存地址，因此不会触发列表监视器。*

*让我们给 list 属性分配一个新的数组体。分配新的数组体会改变内存地址，从而触发观察器。*

*![](img/a5dfbe6639bde3327a5b7f8b15f26118.png)*

*每个数组都有自己的内存地址。因此，如果我们给 list 属性分配一个相同的数组体，list watcher 仍然会响应。*

*![](img/a82dbc0e6a01232a60ad28661e576dc6.png)*

*如果我们观察汽车物体，我们会得到同样的结果。*

*重置对象属性不会触发汽车监视器。*

*![](img/d0405fddee9294148a942ee7c33d41ef.png)*

*我们需要给汽车属性分配一个新对象来触发汽车监视器。*

*![](img/58ba9a27ef2ff62b468d4717e95d3b9e.png)*

*当 deep 属性设置为 false 时，观察器只监视被观察值的内存地址。*

*手册上说我们只能将顶级数据、属性或计算属性名作为字符串传递。对于更复杂的表达式或嵌套属性，我们应该使用 getter 函数。*

*这意味着如果您使用字符串设置$watch 方法的第一个参数，那么该字符串只能是顶级数据、属性和计算属性的名称。*

*但是根据我自己的实验，你可以直接看一个数组的元素总和。只需将 list.length 放在引号中。$watch 方法将观察目标数组的元素总数。*

*![](img/890d7c94310420079169e47e3220aa84.png)*

*如果我们能监视元素总数，我们能监视特定的元素吗？让我们找出答案。我们观察第一个数组元素。*

*观察器已被触发，但不需要测试程序。我们变得模糊不清。处理函数无法访问第一个数组元素。列表零不能作为字符串直接传递给美元符号监视方法。它不能被识别。*

*![](img/4e54be2b7c3b8c0e26f5ec8769f6f93b.png)*

*接下来，让我们看看是否可以观察一个对象属性。我们以品牌资产为例。*

*我们可以看到它起作用了。*

*改变品牌价值会触发观察者。*

*注意这里，品牌价值是一个字符串，是一个原始值。如果它的值是一个嵌套对象，那么监视器仍然只监视嵌套对象的内存地址。*

*![](img/f8e95be9e33f68f394271d9ad45f7ff9.png)*

*接下来，我们将 deep 属性设置为 true。这使观察者能够观察数组元素和对象属性。嵌套的数组和对象也会被监视。*

*让我们看看列表数组。*

*![](img/b5de78050133b30b4bcb1597b74d0468.png)*

*我们去掉一个元素。*

*观察器被触发了。*

*重置元素值也会触发观察器。*

*分配一个新的数组体也会触发观察器。*

*![](img/fe6baff26bc9077f67bc1f58d187f4e8.png)*

*接下来，我们来看汽车对象。*

*这一次，重置属性值可以触发对象观察器。*

*给汽车属性分配一个新对象也会触发观察器。*

*![](img/ae800a635d6d708fb321cffd55ab846d.png)*

*美元符号手表方法的第一个参数可以设置为函数。此函数需要是一个箭头函数，以便它可以从美元符号监视方法中继承 This。*

*![](img/64716e2fdcb984eba5046665e39684f7.png)*

*在我们继续之前，我们将深属性设置回 false。*

*![](img/53a07be7146c5584413b1e7dbadfa583.png)*

*传递给美元符号 watch 方法的函数实际上是一个 getter。它返回一个表达式。表情值会被关注。*

*![](img/1edef6c86104ec6b23ff2090f7876ed2.png)*

*getter 提供了一个函数作用域，允许我们设置一个复杂的表达式。*

*这是我们有时选择美元符号手表方法而不是更方便的手表选项的另一个原因。“监视的”选项使用监视源作为属性名。这给我们能看的东西设置了很多限制。getter 函数将我们从这些限制中解放出来。*

*例如，我们可以只用一个观察者来观察多个目标。*

*我们转到数据选项来添加新的数据属性。我们将其命名为 *nation* ，并将其值设置为 UK。我们想一起看城市资产和国家资产。*

*![](img/bf0b2cd0ddf58f543530c38b2661c040.png)*

*在 getter 函数中，我们返回一个数组，并将城市属性和国家属性放入其中。*

*注意这里，我们将这两个属性传递给 getter 函数。你需要在他们的名字前加上这个。*

*![](img/d095cf89d981fa16fd8e528dd1321f46.png)*

*现在，我们有了一个监视城市财产和国家财产的监视者。更改任一属性值都会触发观察器。*

*![](img/d60a808dbc80d89896c67edd5b04fed5.png)*

*我们也可以观看数学结果。*

*我们添加了另外两个数据属性。我们将它们命名为 A 和 B，并将它们的值分别设置为 10 和 5。*

*我们返回 A 加 b。*

*![](img/6c427a1ca4a6cb999253970a9ef266c3.png)*

*让我们运行文件。*

*我们可以看到观察者观察 A 和 b 的和。*

*![](img/fe8c3aec500b098f6923136d0007edc3.png)*

*我们把 A 设为 100。*

*观察器被触发了。*

*新的总数是 105。*

*![](img/e3ee3ceaa47404b42280995af72b08ab.png)*

*接下来，我们定义一个函数来一起改变 A 和 B 的值。*

*我们把 A 设为 105，B 设为 0。*

*总和不变。因此，即使 A 和 B 的值都被重置，观察器也不会响应。*

*![](img/4b11a2e784f874463c8ad920b494a796.png)*

*在我们的实际项目中，我们可以使用这个特性来监控总成本、平均评分等数据。*

*使用 spread 操作符，我们可以将数组的代理对象转换回数组。该表达式不能用作属性名，因此不能在 watch 选项中使用。但是我们可以在 getter 函数中返回它。*

*我们仍然保持深属性为假。*

*![](img/16ee96c905f8963ba7fb7bf7c03597d9.png)*

*让我们试试这个文件。*

*我们可以看到观察器现在观察列表数组，而不是它的代理对象。*

*![](img/8235cf8f843af1e5fb3688ae4cce2d48.png)*

*我们从数组中移除最后一个元素。*

*观察器被触发。*

*我们重置第一个元素值。*

*观察器再次被触发。*

*分配新的数组体也会触发观察器。*

*![](img/8c5971fcea7fc0214d5806dd6ca2b496.png)*

*接下来，让我们看看是否可以观察一个选定的元素。我们返回第一个元素。*

*我们可以看到，与上节课中的实验不同，第一个元素值已被成功检索。*

*![](img/4d23bd5aba20852a1b0a95686d69f3f2.png)*

*我们给第一个数组元素赋值。*

*我们可以看到监视器被触发了。*

*![](img/e72ee7476df29298a74fef9fc9239e17.png)*

*到目前为止，我们只使用了一个组件:根组件。在本课中，我们将向您展示如何创建和使用子组件。*

*打开 APP 实例对象，你会发现一个名为*的方法组件*。这个方法是我们用来声明全局组件的。全局组件在根组件和其他子组件中可见。*

*![](img/d67c4cfcfde16bc7e55d957f01a35b11.png)*

*组件方法有两个参数。第一个将用于命名子组件标签。*

*第二个是选项对象。该对象与传递给 createApp 方法的对象相同。*

*![](img/ef261e14975d64d4540f90b11839c682.png)*

*我们可以使用 name 选项为子组件设置一个名称。名称选项是可选的，但我们建议您保留它。在后面的课程中，我们将向您展示它能为我们做什么。*

*![](img/1daf63d46edbf7c5446fc4fcde222447.png)*

*接下来，我们添加数据选项。它的值是一个返回对象的函数。数据属性在返回的对象中定义。*

*在函数中返回一个对象被称为工厂模式。*

*![](img/979425beabe0e10796a3512ad20c6e97.png)*

*知道为什么我们要在函数中返回对象吗？为什么我们不直接把对象赋给数据选项呢？为什么要费这么大的劲？稍后我们会告诉你为什么。*

*其他选项如计算、方法、观察器与根组件中的完全相同。*

*根组件通过 mount 方法连接到它的模板。我们如何将一个子组件连接到它的模板？*

*我们使用模板选项。我们将 HTML 模板作为一个字符串分配给它。*

*![](img/c2892d5d80686bfe4d39f5a87a969a08.png)*

*现在，一个非常简单的全局组件完成了。它可以安装在任何组件中，并且可以重复安装。每次安装都会创建子组件的新实例。*

*接下来，我们安装子组件。子组件标签被视为 HTML 标签。为了遵循 HTML 规则，我们需要将大写字母转换成小写字母，并在前面加一个破折号。*

*![](img/31adaa743b1dad02d0033eb41ea0055f.png)*

*让我们测试这个程序。*

*子组件已成功安装。*

*![](img/d834be1d50b261d92dd26b7e0b417504.png)*

*将模板设置为字符串非常不方便，尤其是对于复杂的模板。更好的解决方案是单独定义子组件模板。我们为模板选项分配一个元素 ID。*

*然后我们添加一组模板标签。模板标记的 ID 必须与分配给模板选项的 ID 相同。*

*![](img/c2fbabd38e01f3d8089beddda26133f8.png)*

*从 Vue 3 开始，子组件模板不再需要根 DIV。位于根 DIV 之外的元素称为片段。但是最好还是为子组件模板设置一个根 DIV。*

*![](img/e23737986d16dd0d02ee22b1aee90d67.png)*

*为了访问子组件实例，我们在子组件标签中设置了 *ref* 属性。*

*![](img/f5f88d6eaee6ec61da8db74857379fa1.png)*

*现在，我们可以通过它的 ref 值访问子组件实例。*

*同一个子组件可以重复安装。*

*![](img/00cf7bc2a3f567d2d90cfa68940c5408.png)*

*每次安装都会创建一个新的组件实例。*

*![](img/00cf7bc2a3f567d2d90cfa68940c5408.png)*

*所有实例都是独立的。如果我们修改一个实例的数据属性，其他实例不会受到影响。*

*使用工厂设置数据选项可以使同一组件的实例相互独立。*

*每当我们创建一个子组件实例时，分配给数据选项的函数将被执行并返回一个新的对象。*

*![](img/fae4a91f8ec7f9c213f3d0de18bed654.png)*

*因此，每个组件实例都有自己的数据对象。这保证了同一个组件的实例是独立的，不会互相干扰。*

*接下来，我们来试试本地组件。*

*在根组件中，我们添加了组件选项。它的值是一个对象。*

*属性名将用作组件标记名。属性值是 options 对象。语法和以前一样。数据选项必须是返回对象的函数。*

*![](img/ebce209c2816bf4fad1deef1c803b6cb.png)*

*这个本地组件是在根组件中定义的，所以它只在根组件中可见。它在子组件中不起作用。*

*![](img/7855a6bce211563bb886cced8e20df91.png)*

*在这一课中，我们将比较子组件钩子函数和父组件钩子函数的执行时间。*

*在根组件中，我安装了六个生命周期挂钩。*

*![](img/5d484eb010d751747a81c9e9b9254ae7.png)*

*我将这六个钩子复制到子组件中。*

*记住手动修改 beforeCreate 挂钩，因为它不能访问数据属性。*

*![](img/2e21126192a49e138770eabc365885c4.png)*

*让我们运行文件。*

*子组件被视为根组件模板的一部分。*

*子组件的创建和挂载挂钩在根组件的 beforeMount 和 mounted 挂钩之间执行。*

*![](img/461570de3c92a32cb49671a80c2f3f91.png)*

*接下来，我们调用 unmount 方法来删除根组件。*

*子组件的 beforeUnmount 挂钩和 Unmount 挂钩在根组件的 beforeUnmount 和 Unmount 挂钩之间执行。*

*![](img/9e2af8cb1436c77b7985b9a6db58db13.png)*

*接下来，让我们尝试更新和渲染挂钩。*

*我们在根组件中启用它们，并将它们复制到子组件中。*

*![](img/bfd9cf8f4ff82af9398898df6f9da9cf.png)*

*让我们刷新页面。*

*我们可以看到子组件是在根组件的 renderTracked 钩子被触发后创建的。*

*![](img/c3a0fad19c9de1c85d2fdfe53583f8c4.png)*

*我们更新根组件的 title 属性。*

*子组件不受影响。子组件中没有触发任何更新或呈现挂钩。*

*![](img/7100603cc36e069c9a506d84561aa6ee.png)*

*同样，如果我们更新子组件的 title 属性，根组件不会受到影响。不会触发来自父组件的更新或渲染挂钩。*

*![](img/5ea71d4373c336c640eecd7f8693a77f.png)*

*接下来，我们转到子组件的已创建钩子，并在其中抛出一个错误。*

*![](img/d27d89cb2e93c52605bac239bdb7954c.png)*

*我们可以看到整个程序都停止了。*

*![](img/3be7ad9fa37366766437bbce625ec5fe.png)*

*根组件可以拦截来自其子组件的错误。*

*在根组件中，我们添加了 errorCaptured 钩子。errorCaptured 挂钩有三个参数:错误消息、触发错误的组件实例和包含错误捕获位置信息的字符串。*

*![](img/67d3f1a89f892f2751877242c6e142c1.png)*

*让我们再试一次这个程序。*

*我们可以看到来自子组件的错误已经被安装在根组件中的错误挂钩捕获。*

*我们收到了错误消息。*

*错误消息下的代理对象是子组件实例。*

*错误在创建的钩子处被捕获。*

*![](img/f6df23854acc0e2e68c0aa2d65df5e29.png)*

*在 errorCaptured 钩子中，我们可以返回 false 来阻止错误进一步传播。这样 Vue 会想尽办法挽救程序。*

*我们可以看到根组件已经成功装载。我们有一些警告，但是没有致命的错误关闭整个程序。*

*![](img/f0fc4f4067b174043688a36607848781.png)*

*根组件的创建、挂载和呈现都是成功的。*

*子组件也已创建并成功挂载。*

*![](img/bc98ca0e22abacb4501690dc29049367.png)*

*根组件的属性仍然可以更新。*

*我们还可以更新子组件的属性。尽管在子组件创建的钩子中抛出了错误，但是根组件和子组件仍然可以正常工作。*

*![](img/2c7c52cf69f0ff9735953dba511755f2.png)*

*在您的实际项目中，您可以使用 errorCaptured 钩子来最小化损害。*

*子组件标签起着特殊的作用。它是父组件标记和子组件标记之间的交集。因此，它可以访问父组件和子组件。这使得它成为在父组件和子组件之间交换数据的最佳位置。*

*![](img/27815dcbed310afc038979f87ad8571e.png)*

*为了将数据从父组件发送到子组件，我们使用 props。Prop 是 property 的缩写。在下面的课程中，我们将区分这两个词。Props 仅指用于将数据从父组件发送到子组件的属性。*

*![](img/5a708d177e782d8c52cf97cd934a2259.png)*

*道具属于子组件，但可以从父组件获取它们的值。这就是父组件将数据发送到子组件的方式。*

*在我们使用一个道具之前，我们必须先声明它。*

*在子组件的选项对象中，我们添加了 props 选项。它的值可以是数组或对象。我们将从数组语法开始。每个元素都是一个专有名称。*

*![](img/adb3c8e1c8f847ddbbcc6cea08e3e386.png)*

*现在，子组件有了一个名为 mail 的新道具。mail prop 在子组件标记中是可见的，它作为一个属性工作。*

*让我们检查子组件实例。*

*我们可以在子组件实例的根级别找到一个名为 prop 的属性。其当前值为*未定义*。*

*![](img/11d957a0c71b95bbb0cb56a9dd1e82d8.png)*

*向下滚动，您会发现一个名为美元符号道具的属性。这是 Vue 组件存储其道具的地方。它的值是一个代理对象。代理对象使道具成为被动的。*

*![](img/b36704d27b3f2e5090ee2b6cc955db36.png)*

*组件实例根级别的属性在组件模板中可见。我们可以直接用道具的名字来展示道具。不需要前缀。在组件方法、钩子和计算属性中，我们可以通过这个来访问 props。*

*![](img/33ad2a91d857fa768be27d49153ce3ad.png)*

*在子组件标签中也可以看到属性。如果我们将子 compose 标签视为 HTML 标签，那么 props 只是 HTML 标签的属性。*

*我们用 v bind 指令作为邮件属性的前缀。v bind 指令允许我们访问父组件实例。我们将消息属性分配给邮件属性。*

*我们可以看到，message 属性的值已经分配给了 mail prop，现在显示在子组件中。*

*![](img/ff0fff5aa9372475476203beee91f63c.png)*

*属性是被动的，邮件属性从消息属性中获取它的值，如果我们重置了消息属性的值，邮件属性将自动更新。*

*![](img/bd5764ce8f7901d8c5bd65e40c20f172.png)*

*然而，道具被设计成只读的。不要试图通过组件实例修改道具。*

*![](img/55ddf26033b9a6afa8ce8a9e92b1ca66.png)*

*如果您需要处理一个属性值，请创建一个数据属性并将属性分配给它。避免直接修改属性值。*

*道具可以看，就像普通的数据属性一样。watcher 函数的名称与被监视的道具相同。它将在被监视的道具接收到新值后被触发。*

*![](img/5bada258e2ec0bb6db9279f8e7e724cf.png)*

*可观看性非常重要。我们经常使用 props 查询后端 API。通过为道具设置一个监视器，我们的程序可以在道具值改变后自动重新查询后端 API。*

*![](img/2e3620b56dabf09b6ba4fbbdb825bfed.png)*

*beforeCreate 钩子在组件实例准备好之前被触发。因此，它不能访问任何数据属性，因为它们还没有被创建。*

*道具是不同的，它们在很早的时候就准备好了，甚至在子组件实例本身之前。我们可以在 beforeCreate 钩子中访问 props。记住这个结论非常重要:道具在拥有它们的组件实例之前就准备好了。*

*![](img/ebb012701bceeed80a19eac053ed77e5.png)*

*通过 v bind 指令分配的值可以保持其原始值类型。*

*![](img/cfe3ecdc05c1acb5eec6a825d3fa59c4.png)*

*有时，我们可以给道具分配一个静态值。如果值是一个字符串，那么我们应该删除 v bind 指令。否则，Vue 可能会将静态字符串值误认为是父组件的属性名。*

*![](img/f5c67d32f1f9abe4ef4f50786678f8ae.png)*

*但是对于其他值类型，移除 v bind 指令会导致一个问题:无论它们的值类型是什么，都被视为字符串类型的值。*

*![](img/230bcd044d589c424160444efde74ace.png)*

*为了保留数据类型信息，我们需要带回 v bind 指令。*

*![](img/205d92b2e5bbc6084d457057031671c6.png)*

*静态值可以不带引号地赋值。但是报价还是推荐的。*

*![](img/9b7e765df4c0b8e958581131ec8b69b1.png)*

*这里的引号标记的是 JS 表达式的边界，而不是字符串。*

*![](img/288af558a4b6696f6f27bb8f3f12a666.png)*

*根据手册，只有设置道具名称才意味着道具值为真。但是这个功能可能并不总是有效。该属性值更可能被视为空字符串。*

*![](img/719090b196d2fbd551a87fc21d0d943c.png)*

*我们在上一课中使用的属性值是一个字符串，它是一个原始值。*

*具有原始值的道具是只读的。它们只从子组件标签中获取值。您不能通过组件实例重置它们的值。*

*![](img/9fca28c99f669ea9ca8df14271ba6a11.png)*

*这是一个很好的安全特性。它确保数据只向一个方向流动。子组件不会无意中修改父组件的属性。*

*但是有一个漏洞。如果我们给一个属性赋一个引用类型的值，这个属性又变得可写了。*

*![](img/887af0b974463f69e4479b05e9062321.png)*

*对象是引用类型的值。邮件道具实际收到的是消息对象的内存地址。*

*现在，子组件的邮件属性和父组件的消息属性指向同一个对象。*

*![](img/dd40157ab46b8d65ee369841b0526fe3.png)*

*如果我们通过邮件属性修改消息对象，父组件也将被更新。*

*![](img/a0a54a52506951e3a1897892e3b4f13e.png)*

*乍一看，这似乎是一件好事。Props 设计用于将数据从父组件发送到子组件。但是现在它也可以反向发送数据。感觉就像买一送一。*

*仔细观察就会发现问题所在:我们无法阻止数据被反向发送。如果我们修改子组件中的属性值，父组件将不可避免地受到影响。*

*![](img/7ce64d53f5928a9c4f02e8c85cf5f6be.png)*

*如果我们多次安装了同一个子组件，那么所有这些实例共享同一个内存地址，因此修改同一个对象。这意味着没有实例是真正独立的。*

*在您的实际项目中，当您将一个引用类型的值传递给一个 prop 时，要格外小心。*

*如果可能，避免直接使用引用类型值。*

*数组语法只声明属性名。使用 object 语法，我们可以为 props 设置默认值和其他要求。*

*属性名将被用作专有名称。属性值是一个对象。*

*![](img/d2f03bcd1c19c0ff8959861d1281ce75.png)*

*使用*默认*选项，我们可以设置一个默认的属性值。*

*原始值可以直接分配给默认属性。对象和数组必须使用工厂模式。我们将默认选项设置为一个函数，并返回其中的对象或数组。*

*部件可以重复使用。我们不允许不同的组件实例共享同一个对象或数组。工厂模式确保每个实例都有默认属性值的新副本。*

*![](img/f4d13dbcdfb7f578d5c574b6a8f474a4.png)*

*使用类型选项，我们可以限制属性的可接受值类型。*

*![](img/06049c035cf84ae1d8c33400864b990b.png)*

*让我们测试这个程序。*

*我们从子组件标签中删除邮件属性。*

*现在已经使用了默认的 prop 值。它的工作原理和普通的属性值一样。*

*![](img/b812b454fe526355ae4383062eeb0ac0.png)*

*我们要求邮件属性的值是一个字符串。让我们给它分配一个数字，看看会发生什么。*

*我们得到了警告，仅此而已。非法属性值已被接受并显示给用户。*

*如果您需要设置几个可接受的值类型，请将它们放在一个数组中。*

*总之，我们可以设置八种数据类型。除了字符串和数字，我们还可以设置布尔、数组、对象、日期、函数和符号。*

*![](img/a4acf7ee0b49a614f3c18e0d7ab2fb12.png)*

*对象语法还允许我们设置一个验证器函数。validator 函数接收当前的属性值，并在我们加载页面或更改属性值时被触发。*

*![](img/c70c34cf2129a367fc45f6cb28494552.png)*

*我已经提供了合法的属性值，但是验证器仍然失败。*

*![](img/b7cc69f09893801a5d6b382ad46e2ae9.png)*

*为了使验证器成功，我们需要在其中显式返回 true。失败的验证器只会生成一个警告。程序仍然正常加载。*

*验证器在 beforeCreate 挂钩之前被触发。这意味着验证器函数在组件实例创建之前被触发。因此，验证器函数中的 THIS 不能指向当前组件实例。*

*我们可以看到它指向窗口对象。*

*![](img/9db34784dce004d2da3667adb1669005.png)*

*一旦我们显式返回 true，警告就消失了。*

*![](img/503d05d87e05473fd135f98041de5684.png)*

*这里我们有一个父组件和一个子组件。*

*子组件有一个名为 message 的数据属性。父组件也有一个同名的数据属性。*

*我们希望将子消息的值发送给父消息。*

*![](img/a31f9434b7dfe5d21a0fec8e853a180f.png)*

*数据交换仍然发生在子组件标签中。我们首先将子消息向上发送到子组件标记，然后将它拉下到父组件。*

*![](img/154a1b03e9a67b7e196ec26d9da8827e.png)*

*从子组件向其父组件发送数据需要自定义事件。*

*实际上，更准确的说法应该是将数据从子组件发送到子组件标签需要定制事件。*

*![](img/b40727069dca01a05ac4851d7a335a32.png)*

*自定义事件在子组件中声明。我们使用$emit 方法发出它。*

*$emit 方法有两个参数。第一个是发出的自定义事件的名称。第二个是绑定到发出的事件的一段数据。任何侦听自定义事件的人都会收到绑定的数据。*

*![](img/a12e1a88d1830ef843cd93d67e74c786.png)*

*$emit 方法来自组件实例的根级别。它可以直接访问整个组件实例。我们可以通过这个访问数据属性。*

*![](img/2587862f18535a86630ab172fab2f2c9.png)*

*自定义事件被发送到子组件标记。*

*就像本地事件一样，我们使用 v on 指令来监控定制事件。由 v on 指令触发的方法属于父组件。*

*被触发的方法接收*美元符号事件*对象。美元符号事件存储绑定到发出的自定义事件的值。*

*![](img/66f3ee1d2379d974a905841f0c46f4e1.png)*

*被触发的方法属于父组件，因此它可以访问父组件的实例。*

*![](img/bd67daba2ad59bf7c1ad7d634dfad185.png)*

*我们将*美元符号事件*分配给父组件的数据属性。这就是子消息属性的值发送到父消息属性的方式。*

*![](img/ea3469384ff9d738be31b384f6f4e5c2.png)*

*自定义事件完成了一半的工作:将数据从子组件发送到子组件标记。v on 指令和 inline 方法完成剩下的工作:将绑定到自定义事件的数据分配给父组件的数据属性。*

*接下来，让我们在一个真实的项目中尝试自定义事件。*

*![](img/b855f8a0551d7c78528660f1ad125221.png)*

*从 Vue 3 开始，所有自定义事件都必须首先声明。声明是使用 emits 选项完成的。它的值是一个数组。每个元素都是一个事件名称。*

*现在，我们宣布了一个名为*接力*的自定义事件。*

*![](img/9ce8a9ca010ea2a33fa9d433ffadc0e8.png)*

*接下来，我们转到子模板并添加一个按钮。当我们点击按钮时，我们触发了一个名为 send 的方法。*

*send 方法是一个 shell，我们用它来触发 emit 方法。*

*在 send 方法中，我们通过这个来访问 emit 方法。*

*我们将其第一个参数设置为 *relay* ，将其第二个参数设置为 *this dot message* 。*

*现在，子消息属性已经绑定到中继事件。当我们单击 send 按钮时，中继事件将被发送到子组件。*

*![](img/7f27d10fc0597ebe82c3d764fdb96389.png)*

*接下来，我们转到子组件标签，使用 v on 指令来监控中继事件。*

*我们触发一个内联方法。这个内联方法属于父组件，因此可以访问根消息属性。我们将*美元符号事件*分配给消息。*

*![](img/dd8cff70093dd50af03c48f8b21d116d.png)*

*让我们试试这个程序。*

*我们点击按钮。*

*我们可以看到根消息已经被子消息所取代。*

*![](img/1716071399af1d6bc85710215f813a72.png)*

*接下来，我们用一个输入框替换这个按钮。*

*我们添加 v model 指令，并将输入框绑定到子消息属性。然后我们监视本地输入事件并触发 send 方法。*

*![](img/79ed4a41e4b057ef1234bbc8cbd1126d.png)*

*输入框修改子消息属性。每当我们在输入框中键入一个新字符时，send 方法就会被触发，并发出 relay 事件，并将最新的子消息值绑定到它。*

*让我们测试这个程序。*

*输入框同时修改两个消息属性。*

*![](img/ca1be1c074c7ce99d4a19aebb6638c7d.png)*

*假设我们有一个父组件和一个子组件。它们的模板中都有一个输入框。我们希望这两个输入框保持同步。*

*![](img/0ed10bcc983e6059371f028c06a87718.png)*

*这要求我们在父组件和它的子组件之间建立一个双向数据路径。这种路径需要一个属性和一个自定义事件。*

*首先，我们向下发送数据:从父输入框到子输入框。*

*![](img/9f4dbf00749c75284b8a44d6adf89dd1.png)*

*父输入标记依赖于 v 模型指令，并连接到消息属性。我们需要将消息属性发送到子组件中。这就要求我们在子组件端声明一个 prop。我们称之为道具邮件。*

*在子输入标记中，我们将邮件属性分配给 value 属性。子输入框中显示的内容现在由邮件属性决定。*

*![](img/75a7d67dcd892933bb903fed88bb53be.png)*

*然后在子组件标记中，我们将消息属性分配给邮件属性。*

*现在，父输入框中的内容将被发送到子输入框中。道具是反应性的，在父输入框中输入的任何东西都会立即出现在子输入框中。*

*![](img/35b1ffd573d9e40b09e0ad7db89c2ef5.png)*

*接下来，让我们向上发送数据，从子输入框到父输入框。*

*![](img/ea7b91e46d044ec1b6c336fb89890d00.png)*

*从子组件发送数据需要一个自定义事件。我们称之为接力赛。*

*在子输入标签中，我们监控本地输入事件并触发一个发送方法。*

*![](img/859e9804716be189eb483491d7cf7f4b.png)*

*send 方法自动从 v on 指令接收美元符号事件对象。用户提交的数据存储在事件对象中。*

*在 send 方法内部，我们调用 emit 方法来发出中继事件，并将用户提交的数据绑定到该事件。*

*![](img/a200dbeba789277e7dd4264a94725a2f.png)*

*在子组件标记中，我们监视中继事件并触发一个内联方法，在该方法中，我们将*美元符号事件*分配给消息。这就是子框标签向父输入框发送数据的方式。*

*![](img/57ac3740d69a11577e2da41a83d8c227.png)*

*在子输入标签中，我们监控本地输入事件。每个输入都会触发发送方法，发送方法会发出中继方法。因此，子输入框中的任何新输入都会立即显示在父输入框中。*

*![](img/ea6db4825c3584f5def8ecc5b809f48d.png)*

*接下来，让我们将刚刚学到的内容应用到一个真实的项目中。*

*我们有一个根组件和一个子组件。为了清楚起见，我将从头开始构建两个输入框。*

*![](img/73419d89772258c462609ad6d4eb1383.png)*

*在根模板中，我们添加了一个输入标签，并将其 v model 指令设置为 message。*

*然后，我们转到根组件的 options 对象来定义消息属性。*

*现在，根组件有了一个输入框。输入框连接到消息属性。*

*![](img/ba7f857760915c83e9099148e11f2671.png)*

*接下来，我们转到子组件的 options 对象来声明一个新的道具。我们称之为邮件。*

*在子组件标签中，我们将消息分配给邮件。*

*![](img/d87a74e0db61c3586b65ec4f51c37dfb.png)*

*然后我们转到子模板，定义一个新的输入标签。我们使用邮件属性设置它的值属性。*

*现在，父输入框能够向子输入框发送数据。*

*![](img/eeae3f9afab3f2e6945a656b3ee8c8f3.png)*

*我们的下一项工作是反向发送数据。*

*![](img/3ad430aa4b9aaafd1d17904c3b3900c2.png)*

*我们转到子输入标签，添加 v on 指令。我们监视输入事件并触发 send 方法。*

*![](img/d1077ea158da76006be3d96b252c3485.png)*

*然后，我们转到子组件的 options 对象来定义 send 方法。*

*send 方法从 v on 指令接收美元符号事件对象。*

*我们从 send 方法内部调用 emit 方法。*

*![](img/41bc922211a2fc27391f34dd3cdb900d.png)*

*从 Vue 3 开始，所有自定义事件都需要先声明。*

*我们称之为自定义事件中继。*

*![](img/bd583fcd585ccca0af621c464c9d9c83.png)*

*我们将 relay 传递给 emit 方法，并使用$event dot target dot value 设置第二个参数值。*

*现在，输入到子输入框中的所有内容都将被绑定到中继事件，并被发送到子组件标签。*

*![](img/69da62912bcaf6275afb9e4ba5d66cfb.png)*

*在子组件标记中，我们监视中继事件并触发一个内联方法。*

*我们将$event 分配给消息属性。对于自定义事件，美元符号事件直接指向绑定数据。不需要点目标点值。*

*![](img/ea9123b369131193798d5869f7a124e4.png)*

*现在，程序完成了。这两个输入标签相互绑定，并实时保持同步。*

*![](img/1f6012f28d65d651e0c05335d122ae2c.png)*

*在之前的课程中，我们学习了 v 模型指令的真正含义。它实际上是一种语法糖。当安装在输入标签中时，Vue 将其转换成另外两个 Vue 指令:v bind 和 v on。*

*v bind 指令设置输入标记的 value 属性的值。v on 指令监视本机输入事件。*

*v model 指令的值是 message。它也用作 v bind 指令的值。*

*message 属性的值在由 v on 指令触发的 inline 方法中重置。新值来自被监控的事件。*

*这种安排是固定的，意味着 v bind 和 v on 指令以及 line 方法的参数都是固定的。*

*![](img/529c77f177c823fc66dd18967499a776.png)*

*如果我们在组件标签中安装 v model 指令，我们将得到类似的结果。*

*v model 指令仍将被转换为 v bind 和 v on 指令。*

*v bind 指令的参数现在是*模型破折号值*。*

*由 v on 指令监控的事件被命名为*更新结肠模型破折号值*。*

*v model 指令的值仍然用作 v bind 指令的值。*

*v on 指令的 inline 方法做的工作和以前一样。只是这一次，绑定数据直接来自美元符号事件，因为我们正在处理一个自定义事件。*

*![](img/3fe1d2cdd77876124d914284616076e5.png)*

*这是我们在上一课中使用的子组件。它有 v bind 指令和 v on 指令。*

*![](img/9f15f59339e404f19a00244c0a31c5f7.png)*

*v bind 指令的值由 v on 指令使用绑定到自定义事件的数据重置。*

*道具和自定义事件都是由我们命名的。如果我们将属性重命名为 modelValue，并将自定义事件重命名为 update colon modelValue，我们将能够在子组件标记中使用 v model 指令。*

*![](img/08ec42f79fd29e8579af3953db018e61.png)*

*还有一件事你需要记住。当我们声明 prop 时，我们需要的 prop 名称是 modelValue。破折号 V 应该转换成大写字母 V。*

*![](img/8de77606e93cb452904b862d0cb1b4c3.png)*

*属性名被用作 HTML 属性名。HTML 属性名只接受小写字母。因此，当我们在子组件标签中使用 prop 时，我们需要进行转换。我们转换大写字母 V 并在它前面加一个破折号。*

*![](img/bb29a5d8a59317d133ec0ad14f2a4739.png)*

*总之，为了能够在组件标签中使用 v model 指令，属性名应该是 modelValue。字母 V 应该大写。*

*我们回到上一课创建的程序。*

*![](img/0fb75e74bad199e9683ee6c187dc33fd.png)*

*我们清除当前的子组件。*

*![](img/ae6ae9108c78a0fad878037dcf39498f.png)*

*我们安装 v model 指令，并为它分配消息属性。现在，我们在子组件标签中的工作已经完成。相比之下，子组件标签现在简洁多了。*

*![](img/2529b3b34c96095993789a099e1c7c28.png)*

*v model 指令只是一个语法糖，为了让它工作，我们需要确保 prop 和自定义事件有正确的名称。*

*我们将该道具重命名为 modelValue。记住字母 v 要大写。*

*![](img/4486dabaa52087dc86aa5a38a8dd6c7f.png)*

*在子输入标记中，我们将邮件属性重命名为 modelValue。*

*![](img/0975908cb3bd470e493a91cb001f8c32.png)*

*然后，我们转到 emits 选项，并将自定义事件重命名为 *update colon modelValue* 。不要忘记在 emit 方法中更新事件名称。*

*![](img/3a1d8e058e44499537aca27a38ce07e5.png)*

*让我们测试这个程序。*

*这个程序和以前一样工作。这两个输入标签总是同步的，并且可以互相控制。*

*![](img/23cac6c94b9154dcf9055e7061859bcf.png)*

*v 模型指令可以使用我们自己专有名称。我们使用 v model 指令的参数来声明新的 prop 名称。当转换 v 模型指令时，Vue 将使用新的 prop 名称。*

*我们在子组件中声明新的道具。*

*![](img/cb82541a3b49b2e1d842fbe479e6d715.png)*

*在子输入标记中，我们将新的属性分配给 value 属性。*

*自定义事件名称还包括属性名称。所以我们也需要更新自定义事件名称。*

*![](img/5f422c82873e5317ede13db24da6e6c9.png)*

*现在我们可以同时使用 v 模型指令和我们自己的专有名称。*

*这里我们有一个根组件和一个子组件。*

*![](img/e9b7532c3c2d7efb7dc5b5168248b49d.png)*

*根组件的根 DIV 可以设置嵌套在其中的所有内容的样式，包括子组件中的元素。*

*![](img/595fb9d8a3b10d1b44a1540302d5bf71.png)*

*子组件可以为自己的元素设置不同的样式，覆盖从根组件继承的样式。*

*![](img/793e976fe7c5fd57a22523bcc1296e3e.png)*

*如果我们能把这个特性应用到子组件标签上，那就太好了。*

*让我们将子组件标记视为一个 HTML 标记。嵌套在子组件标记中的元素应该能够从子组件继承 CSS 样式。如果我们在这里放一个 iTag，那么这个 iTag 应该能够继承子类的 CSS 属性。*

*开始和结束子组件标记之间的空间属于根组件的模板，因此我们可以访问根组件的属性。让我们将消息属性放在 iTag 中。*

*![](img/35ac26a81eae4dd3b0180ef29d21ab3b.png)*

*如果这个程序可以工作，我们将能够使用子组件中的 CSS 样式显示父组件中的数据。与使用道具不同，我们从来不需要向子组件发送任何东西。*

*让我们测试这个程序。*

*我们可以看到 iTag 被忽略了。整个节目中没有它的痕迹。*

*![](img/08b1b4dab0e57fa8afe1b22044572f41.png)*

*默认情况下，嵌套在子组件标记中的元素将被忽略。但是有一种方法可以解决这个问题。*

*根模板可以访问根组件实例。*

*![](img/cc8fc63ece63baf4d2cace533503b213.png)*

*子组件标签安装在根模板中，从而在最终呈现的 HTML 文件中创建一个独立的区域。*

*![](img/20e1f0e57077b2d8dd376f18655f2a20.png)*

*插槽是一个内置组件。我们把它放在子组件模板中。*

*![](img/6be4c4ac7006a9d47c8868210c332fe9.png)*

*slot 组件创建一个特殊区域，显示嵌套在子组件标记中的元素。*

*从 Vue 的角度来看，嵌套在子组件标签中的元素仍然属于父组件模板，因此可以访问父组件实例。*

*![](img/3c9d23cab0aa32f2808081a9c96dc326.png)*

*但是从原生 HTML 代码的角度来看，通过 slot 组件显示的元素嵌套在子模板中，因此，它们将从子组件继承 CSS 样式。*

*![](img/e68f82ce9ed1c5381036da40be9b0069.png)*

*总之，插槽使我们能够使用子组件显示父组件的数据，而不需要向子组件发送任何东西。*

*UI 库经常使用插槽，尤其是它们的按钮组件。*

*例如，bootStrap Vue 使用 bButton 组件呈现按钮。*

*按钮样式和交互行为是在 bButton 组件中预定义的。但是按钮名称不能提前决定。*

*我们在最后一分钟设置按钮名称，当安装 bButton 组件时。*

*按钮名称嵌套在 bButton 标记中。bButton 组件在其模板中有一个槽。这就是按钮名称的显示方式。*

*![](img/74c35930d13cf999263e44eed7fbedcc.png)*

*对于其他设置，如选择按钮样式，我们使用道具。*

*按钮名称也可以使用道具来设置。使用 slot 更好，因为它保持了与本机按钮标记相同的语法。用户没有学习成本。*

*接下来，我们回到我们的 Vue 计划。*

*我们转到子模板，在 H3 标签下安装插槽组件。*

*![](img/a1ec9476cecb6ddefd907450c28496e0.png)*

*让我们运行文件。*

*我们可以看到 message 属性显示在子组件中。它从子组件继承了 CSS 样式。*

*![](img/356bc4a3cf97a07785e8bbe644b16c5a.png)*

*消息属性本身仍然属于根组件。我们可以通过根组件实例重置它的值。*

*![](img/a5dc1d36e58dae9401bb23d3995d8ea1.png)*

*您可以添加几个插槽组件。*

*每个 slot 组件都独立工作，并显示嵌套在子组件标记中的元素的副本。*

*![](img/691c390e3510899c99d9d0ccaaa34a8e.png)*

*同样，您可以在子组件标记之间设置多个元素。它们都将被发送到插槽组件。*

*![](img/456323408161281acd6dba7a5c830cc9.png)*

*通常，我们希望将选定的元素发送到选定的插槽。这要求我们能够区分插槽。解决方案就是*名*道具。我们将它添加到插槽标签中。*

*我们命名第一个吃角子老虎城市。没有名称 prop 的插槽将被视为默认插槽。它作为一个安全网，接收没有分配插槽的元素。*

*![](img/a5a2d09b8215868f366009655d87220c.png)*

*接下来，我们将 B 标签分配给 city 插槽。*

*Vue 3 中的语法发生了变化，变得更加完整。为了将 B 标签发送到 city 插槽中，我们首先添加一个模板标签，并将 B 标签放入其中。*

*模板标签有一个 v slot 指令。我们使用指令参数指定插槽名称。注意这里，我们使用的是指令参数，而不是指令值。指令值有不同的使命。*

*![](img/a4608424797af0219535625daecb30d9.png)*

*现在，包装在城市模板标记中的元素将全部被发送到城市槽。*

*其余元素将被发送到默认插槽。*

*让我们运行文件。*

*城市属性已被分配给城市插槽。消息属性没有指定的槽。它已被发送到默认插槽。*

*![](img/5b77473e3658a9fad6873e388899ff3b.png)*

*接下来，我们在 city 模板标签下添加一个 span 标签。*

*此 span 标签也将被发送到默认插槽，显示在 iTag 后面。*

*![](img/c16915cf544877876930b27f45949d8d.png)*

*我们可以使用模板标签将元素分配给缺省槽。只需将 v slot 的参数设置为*默认*即可。*

*![](img/556ad3fd4511c5ad431690f2a6d6d975.png)*

*一旦将模板标签分配给默认槽，就不能有任何松散的元素。松散元素是那些放置在任何模板标签之外的元素。它们不会被渲染，并且会导致警告。*

*![](img/97f73a77839acc49d4d90a4ea88fb329.png)*

*我们需要禁用 iTag 或者将它移动到一个模板标签中。*

*![](img/cd59118c933837d20fbb71b06080cd57.png)*

*槽元件不能与参照一起使用。如果我们给它一个 ref，并试图访问它，我们会得到 undefined。*

*![](img/b0d08a12538916b85c3e321c6f1e36e1.png)*

*组件实例有一个专用的属性来管理插槽。它的名字是$slots。它的值是一个代理对象。*

*每个插槽在代理对象中都有一个代表性的方法。方法名与插槽名相同。*

*![](img/346874f9bde3265ff0a2cd5c263c696a.png)*

*v slot 指令使用其参数指定目标插槽。那么我们能用它的价值做什么呢？*

*![](img/1e943f3edc810499efad3950c3ebf529.png)*

*子组件有一个名为 nation 的数据属性。让我们说，要显示它背后的城市财产。这意味着我们需要将数据从子组件发送到属于父组件的城市模板中。*

*![](img/7cab6128e509093306c18faff55b15a5.png)*

*城市模板通过 v slot 指令的参数连接到城市插槽。*

*city slot 组件属于子组件，因此可以访问 nation 属性。*

*![](img/6debf19ce72f8083f727b70ba18111a1.png)*

*在 slot 标签中，我们声明了一个名为 nationProp 的道具。我们把国家财产分配给它。*

*![](img/588364133ead971238a4212a833e550f.png)*

*城市槽的道具将作为指令值发送给 v 槽指令。一个 slot 组件可以有几个 props，所以 v slot 指令将接收一个对象，在其中存储所有的 props。我们可以给物体命名。*

*![](img/59218e394418c12ee69f6a790682dff4.png)*

*这就是我们将数据从子组件发送到插槽模板的方式。*

*![](img/0aef92cdcd9e81b771b2821031ce0a2b.png)*

*道具是反应性的。如果我们更改 nation 属性的值，子模板将相应地更新。*

*![](img/69cad31e5ddf212b8454256daf75c2f8.png)*

*当设置 v slot 指令的值时，我们可以使用析构赋值。这样，我们可以直接在模板中使用道具名称。不再需要前缀。*

*![](img/2711d136cb4b4003a0ab83bc3f0befbe.png)*

*插槽是独立的。他们不会互相干扰，这意味着他们不会分享道具。*

*为了让默认的 slot 模板访问 nation 属性，我们需要在默认的 slot 标签中设置一个 prop，并为它分配 nation 属性。*

*![](img/de3e97fcf2e1ac4d48f4a8d45cca6f76.png)*

*在后面的课程中，我们将学习如何手动呈现作用域槽。到那时，您将对作用域插槽的工作方式有更深的理解。现在，只要记住语法。*

*我们这里有一个根组件。它有一个子组件。*

*根组件通过 mount 方法安装。我们选择一个 DIV 并将根组件安装到它上面。*

*在当前程序中，根组件被挂载到 VueApp DIV。这意味着整个 Vue 程序只控制 VueApp 分区。*

*![](img/536650bc7ce66cf0893aaf68fb142321.png)*

*对于 VueApp DIV 之外的元素，Vue 程序无法控制它们，因为它们不在 Vue 程序的管辖范围内。*

*有时候，我们的 Vue 计划需要打破这个限制，在 VueApp DIV 之外设立一个‘海外分支’。*

*假设我们需要创建一个通知横幅或模态。横幅需要和浏览器窗口一样宽。最佳解决方案是将横幅的外部 DIV 设置为 body 标记的直接子元素。这样，横幅的外部 DIV 可以继承 body 标记的宽度。我们不需要手动设置它的大小。*

*问题是通知 DIV 被放在 Vue 程序的根 DIV 之外。Vue 无法控制它。*

*这个问题可以用传送组件来解决。*

*Teleport 是一个内置组件，它使 Vue 组件能够将其自己的页面元素从其模板外部 DIV 发送到指定的页面元素中。*

*指定的页面元素被称为传送目标，应该位于组件的模板外部 DIV 之外，最好是在 Vue 程序的根 DIV 之外。*

*在当前示例中，teleport 组件安装在根组件中，因此它的目标应该只来自 VueApp DIV 之外。*

*子组件不能访问其父模板。它可以使用传送组件将自己的页面元素发送到父模板中。但不建议这样做。最好只使用 teleport 来访问整个 Vue 程序的根 DIV 之外的元素。*

*我们选择通知 DIV 作为传送目标。我们使用元素 ID 将*设置为*属性的值。您也可以使用类名或标记名。所有嵌套在 teleport 标签中的元素都将被发送到 notification DIV 中，放在它的原始元素后面。*

*让我们创建一个 P 标签。这个 P 标签仍然属于根组件的模板。因此，它可以访问根组件实例。我们在 P 标记中显示根消息属性。*

*让我们运行程序。*

*![](img/3c664c7b9d06c7aeeb64f014fc185ee3.png)*

*我们可以看到通知 DIV 现在有两个 P 标签。消息 P 标签放在原始 P 标签的后面。*

*消息属性仍然是反应性的，我们可以通过根组件实例修改它的值。*

*![](img/bf2779a11f1925f920ea0b5b83123228.png)*

*在我们的实际项目中，我们通常将通知 DIV 留空，并将其用作锚点。*

*![](img/a3be169014e1bb4e45dfe11d57fb9ef1.png)*

*在根组件中，我们声明了一个名为*显示*的新数据属性。我们将其值设置为 false。*

*然后在 P 标签中，我们添加 V IF 指令，并给它分配*显示*属性。*

*在 transport 标签下面，我们添加了一个按钮来反转 display 属性的值。*

*现在，我们能够挂载和卸载位于 Vue 程序的根 DIV 之外的横幅。*

*![](img/d09c1cb817c7282332e3d15d305a03bc.png)*

*你也可以“传送”子组件。*

*如果您的通知横幅或模式具有相对复杂的设计，您可以使用组件来创建它。*

*传送目标只能从位于安装传送组件的组件的根 DIV 之外的页面元素中选择。最好的选择是只选择整个 Vue 程序的根 DIV 之外的元素。*

*目前，传送组件由根组件使用，如果我们将它移动到 VueApp DIV 中，我们的程序可能无法工作。*

*我们可以看到我们得到了警告。*

*![](img/3696a96ab5a29bf8fc79dca66c2aa79b.png)*

*传送目标必须在使用传送组件的 Vue 组件挂载之前存在。否则，传送组件将试图找到一个尚未创建的元素。*

*Vue 根 DIV 之外的元素总是在 any Vue 组件之前呈现。所以我们不会有这样的问题。*

*Vue 3 使得根 DIV 对于子组件模板是可选的。放置在根 DIV 之外的元素称为片段。在实际项目中，最好避免组件设计中的碎片。*

*![](img/7cc6f422a3da56a47c338588e283f122.png)*

*打开一个组件实例，你会发现一个名为$attributes 的属性。*

*它的值是一个代理对象。这个对象是组件存储通过组件标签从父组件继承的非属性的地方。非属性也是反应性的。*

*![](img/63b5598e8e3ec0d3d246b99a6fa7ea59.png)*

*那么什么是非道具属性呢？*

*如果我们把子组件标签看成一个普通的 HTML 标签，我们在里面设置的道具只是 HTML 属性。*

*![](img/bd9296b7844bf063cc0b42dc36269b90.png)*

*除了道具，我们还可以设置原生 HTML 属性。例如，我们将 class 属性从子组件的根 DIV 移动到子组件标签。*

*![](img/23fbdea03ca43a727753f52f2b30db7c.png)*

*class 属性将由子组件的根 DIV 继承。*

*我们可以看到程序看起来和以前一样。*

*子组件的根 DIV 已收到 class 属性。*

*![](img/3a08068bd179c8a0d2e284f1662c4755.png)*

*接下来，我们检查子组件的实例对象。*

*我们打开美元符号属性属性。它的值是一个代理对象。*

*打开它，我们可以找到类属性。它的值是类名 *childOne* 。所有非属性及其值都存储在这里。*

*![](img/5b39da82b12440dbfd8e894bfde6701e.png)*

*美元符号属性对象的属性是只读的。不要通过组件实例重置它们。*

*![](img/69b9cb949365dac7d170c9b9b94c3af4.png)*

*在子组件标签中，我们可以使用 v bind 指令为 class 属性设置一个动态值。*

*我们使用 className 属性设置指令值。*

*然后我们定义 className 属性，并将其值设置为 childOne。*

*让我们测试这个程序。*

*![](img/228d9432d608b89c56b15647ef8a190a.png)*

*程序看起来和以前一样。已成功应用 childOne 类。*

*接下来，我们将 className 属性的值重置为 classTwo。*

*![](img/3f466d425a08f44cfe7da78d6c988433.png)*

*我们可以看到子组件接受了新的样式。*

*childTwo 类已应用于它。*

*接下来，让我们尝试另一个原生 HTML 属性:title。*

*我们为它设置了一个动态值。*

*在根组件中，我们添加了一个名为 *title* 的新数据属性。*

*现在，title 属性将被子组件的根 DIV 继承。它的值来自 title 属性。*

*![](img/c2e54d3d051b1d79d655cd55a92f7b25.png)*

*只有子根 DIV 可以从子组件标记继承非属性。嵌套在其中的元素不会。这就是 Vue 2 要求每个子组件模板必须有一个根 DIV 的原因。*

*![](img/d492a9d730a17cef0c96772ada46fe8b.png)*

*在子根 DIV 中，让我们设置一个 tittle 属性。让我们看看将使用哪个标题值。*

*我们可以看到从子组件标签继承的标题值具有更高的优先级。它覆盖子组件的根 DIV 中的那个。*

*![](img/ac43bffacfa360f769cc3e803e501b3c.png)*

*接下来，我们恢复 P 标签。现在子模板不再有根 DIV。它如何决定哪个元素获得哪个非属性？*

*![](img/94a75028ca5f353a66a0399375e49f82.png)*

*让我们运行程序，看看会发生什么。*

*我们可以看到所有非属性都丢失了。子模板中没有元素继承任何非属性。*

*![](img/a226061a8eac8a47c647dfdedf68efdb.png)*

*我们也得到了警告。它说非 prop 属性不能被自动继承，因为有 fragment 元素。*

*![](img/7fe9867f4c7f91e1718aaaaa40885bf4.png)*

*如果子模板有片段元素，我们需要手动分配非属性。*

*首先，我们转到子组件实例来关闭自动继承。*

*我们添加 inheritAttribute 选项，并将其值设置为 false。子组件标签中设置的所有非属性都将被忽略。*

*![](img/010cf7c46b7e717c20d7a9ba00b1c89b.png)*

*让我们运行程序。*

*我们可以看到警告消失了。子组件中的任何元素都没有继承任何非属性。*

*![](img/d168a42e54e62a05b6cb4d4bcc258cee.png)*

*就像我们之前展示的那样，所有非属性都存储在美元符号属性对象中。我们只需要从$attributes 对象中选择属性，并将它们分配给我们选择的元素。*

*例如，我们给外部 DIV 一个 class 属性。我们绑定了 class 属性，并将其值设置为美元符号属性。*

*现在，childOne 类已经应用于外部 DIV。*

*![](img/a9905990ddd3f7a0ce14757e74fdcfe5.png)*

*在 P 标签中，我们绑定了 title 属性，并将其值设置为美元符号属性 dot title。*

*现在，title 属性已经添加到 P 标记中。P 标记也是唯一获得 title 属性的元素。*

*![](img/a6a269478dae26cefeae8a0e3ca6dba8.png)*

*不同元素可以继承相同的非属性。我们可以给 H3 标签赋予标题属性。*

*![](img/23283beb704985ebed8261de8c5c4e24.png)*

*在本课中，我们将学习如何动态安装和移除组件。*

*假设我们选择主 DIV 作为挂载点。*

*我还准备了一系列组件。我们一次只安装一个组件，由用户决定安装哪个组件。*

*![](img/12e774e346ae703c4513503507d48c13.png)*

*我们有两种解决方案:Vue 路由器和动态组件。*

*对于更简单的项目，动态组件是更好的解决方案。*

*为了创建挂载点，我们需要组件标签。它有一个决定安装哪个组件的属性。通过改变 IS prop 的值，我们可以向用户呈现不同的组件。IS prop 的值是子组件标记的名称。*

*![](img/e1acbc22fc8074aa3b6fa0cb5571d78a.png)*

*接下来，我们来试试动态组件。*

*这里我们有三个组件:一个根组件和两个子组件。这两个子组件被命名为 C1 和 C2。*

*![](img/b533a15b028fddef6761dcae9dd63288.png)*

*我们一次只需要呈现一个子组件，我们希望用户能够从两个子组件中进行选择。*

*我们首先删除两个子组件标签。*

*![](img/1804f11a629717ef6af0870ea13e91b2.png)*

*然后我们添加组件标签。它的位置决定了 C1 和 C2 的安装位置。*

*使用 IS prop，我们选择想要安装的组件。IS prop 的值是组件方法的第一个参数值。在这里，我们将其设置为 C1。*

*我们可以看到子组件 C1 已经安装。*

*![](img/d4d7db8ce2cfeed00c077dd4af68ac0b.png)*

*通过改变 IS prop 的值，我们可以切换组件。*

*![](img/dc5feace5d6a3d27c64578917f00d942.png)*

*组件标签的工作方式与普通的子组件标签相同。您可以在其中设置道具、非道具属性和自定义事件。它们的行为与普通子组件标签中的行为相同。*

*我们还可以设置 ref 属性来访问挂载的子组件的实例对象。*

*目前，C2 已安装完毕。ref 属性返回给我们 C2 的实例对象。*

*![](img/5da8fd22d39ea0da5639ca5c56b68519.png)*

*通过给 IS prop 分配一个动态值，我们可以控制子组件的安装和移除。*

*我们 v bind IS prop 并将其值设置为 cName。*

*然后，我们转到数据选项来定义 cName 属性。我们将其价值设定为 C1。*

*C1 现在是默认的子组件。*

*![](img/20ae650918238ae65a56beda74e40c0a.png)*

*接下来，我们添加一个按钮，并将其命名为 C1。我们监控点击事件，并将 cName 属性的值设置为 C1。*

*然后，我们复制 C1 按钮，将 C1 改为 C2。*

*现在，通过点击这两个按钮，我们可以切换 C1 和 C2。*

*![](img/ba2b3fbfda004cffa0266d0ab5f0e2dd.png)*

*接下来，让我们来看看动态组件的生命周期。*

*在组件 C1 中，我们添加了三个钩子:已创建的、已挂载的和未计数的。*

*然后我们把这三个钩子复制到组件 C2。*

*让我们刷新页面。*

*C1 已经建立和安装。还不需要 C2，所以不会创建它。*

*![](img/c3991b335f4deaa76d6a06056cdd2548.png)*

*在我们点击 C2 按钮后，C2 将首先被创建。然后 C1 将被卸下，为 C2 腾出空间。*

*![](img/1cb7c4f3ceb4bdfb762fba0b652b6ebe.png)*

*每次我们切换组件时，当前组件都会被卸载。将从头开始创建新的组件实例。*

*![](img/75c9c9df35e283f2405f6098cbb1611c.png)*

*有时，我们需要刷新页面，这意味着我们需要 Vue 来重新创建和重新挂载当前组件。这可以使用 key 属性来完成。*

*在组件标签中，我们添加了 key 属性。当键属性的值改变时，当前组件将被重新装载。*

*我们使用 refresh 属性设置 title 属性的值。*

*然后，我们转到数据选项来定义刷新属性。我们将它的值设为 1。您可以使用其他值。*

*![](img/f020d993ab5bd0f67bba3ec33e9c4138.png)*

*我们将刷新属性的值更改为 2。*

*我们可以看到 C1 又被创造了。然后卸载当前的 C1 实例，创建并装载新的 C1 实例。*

*![](img/f794ba740c6678ed6aca361598d6b77c.png)*

*目前，组件 C1 正在展出。我们可以通过 ref 属性访问它的实例对象。*

*我们给 title 属性分配一个新值。*

*![](img/d0202230cfbdaef18c89b98f47064462.png)*

*然后，我们单击 C2 按钮切换到组件 C2。*

*然后，我们单击 C1 按钮切换回组件 C1。*

*我们可以看到 C1 的称号又回到了它原来的价值。我们在切换到 C2 之前设置的新标题值不见了。*

*![](img/262b8d3f3c2b93f2ddb48b3da2a7fd22.png)*

*当我们单击 C2 按钮时，C1 的当前实例对象被卸载。与根组件实例不同，C1 组件实例的内存地址不存储在任何变量或对象属性中。JS 垃圾收集系统将销毁 C1 的实例对象。*

*当我们单击 C1 按钮时，将会创建并挂载一个新的 C1 实例对象。这就是 title 属性保持原始值的原因。*

*使用 keepAlive 组件，我们可以保留和重用组件实例。我们只需要将组件标记包装在 keepAlive 标记中。*

*![](img/8438f5684a6e2c65994062c93b594e7f.png)*

*让我们测试这个程序。*

*我们点击 C2 按钮。*

*我们得到一个警告和一个错误。C2 也没能上马。*

*该问题是由使用固定值的 key 属性引起的。*

*![](img/a542db0dd10526e202989f0b1f4524e9.png)*

*在添加 keepAlive 组件之前，在创建新的组件实例之前，将销毁未安装的组件实例。因此，新的组件实例可以重用以前的键。*

*现在我们已经添加了 keepAlive 组件，卸载的组件实例仍然存在于内存中。自然，新的组件实例不能使用以前的键值。*

*这就是我们得到警告和错误消息的原因。新组件也未能安装。*

*为了解决这个问题，我们只需要确保每次切换到新组件时键值都会改变。最简单的解决方案是将组件名合并到键属性的值中。*

*![](img/7eb09d70523bb5eebce1e431aa75b12a.png)*

*让我们试试这个程序。*

*问题已经解决了。我们可以通过点击这两个按钮来切换组件。*

*组件 C1 和 C2 将只创建和挂载一次。*

*卸载的挂钩从未被触发。这意味着没有组件实例被销毁。C1 和 C2 都活在人们的记忆中。*

*![](img/5474f904948841a3c3544cb8f65808c0.png)*

*让我们证明这一点。*

*目前，C1 正在展出。我们将其 title 属性的值重置为 apple。*

*![](img/b9836294fd43db942f3532061183fa74.png)*

*然后我们转到 C2。*

*![](img/26c9e1ceaacdd572877a132488c9d4ca.png)*

*然后我们转回 C1。*

*我们可以看到标题值仍然是苹果。这证明了 C1 的原始实例对象从未被破坏，并且在我们切换回 C1 时被重用。*

*![](img/02875fab2f0375cd89a9f12781521dad.png)*

*在 keep-alive 组件中，我们可以使用激活的和停用的钩子来替换 beforeUnmount 和 Unmount 钩子。*

*当我们在 C1 和 C2 之间切换时，这两个活跃的钩子将被触发，但它们不会在服务器端渲染时被触发。*

*我们可以看到每次切换组件时，旧组件的停用钩子和新组件的激活钩子都会被触发。*

*![](img/a1d4c3b68bb02807e72b4a9aad4bd41f.png)*

*接下来，我们移动到一个新文件。*

*我已经创建了四个子组件。*

*![](img/9af96abfd96d5c3fdb79d5bc42c06729.png)*

*让我们将组件标记包装在 keepAlive 标记中。现在，所有卸载的组件实例都将保存在内存中。*

*![](img/3431d59b48c0587e0bcc47eeeadb1ca7.png)*

*如果我们有很多组件，保存它们会是一个很大的负担。使用 max 属性，我们可以限制保存的动态组件实例的数量。*

*我们将最大值设置为 2。现在，内存中最多会保存两个动态组件实例。包括当前安装的组件实例。这意味着将只保存最后一个卸载的组件实例。*

*![](img/84bd3715ec6279098a4d125b70c85566.png)*

*我们刷新页面。目前，只有 C1 已经建立。*

*![](img/05658a3276fd1c98d85e0402a4772938.png)*

*我们转到 C2。*

*现在，我们已经创建了两个组件实例:C1 和 C2。它们都保存在内存中。*

*![](img/e6197bab97bbc07a3b1fcea2edace42a.png)*

*如果我们切换到 C3，我们将创建另一个组件实例。结果，C1 将被挤出队列，因为 max 属性要求最多只能保存两个组件实例。*

*我们可以看到 C1 已经卸载。*

*![](img/b3a21ef0235dee597e1630e1dd6cc6e0.png)*

*如果我们转向 C4，C2 将被挤出队列。只有 C3 和 C4 会留在记忆中。*

*![](img/96f0762446a9ccae26035d0cbbedee64.png)*

*我们切换回 C1，C3 将被挤出。记忆中只有 C1 和 C4 还活着。*

*![](img/a67ac69307e0e51bb32350d8a6e381f1.png)*

*在任何时候，只有当前组件和它的前一个组件会被保存在内存中。*

*总之，max 属性遵循 FIFO 规则:先进先出。*

*![](img/e15634b67ff171fa1f84f33ca0eec0fa.png)*

*使用 include 属性，我们可以指定想要保存的组件。*

*例如，我们拯救了 C1 和 C3。*

*![](img/e5e19eb71b9c1d0a620cfea3c3e290cc.png)*

*似乎 include 属性不起作用。C1 和 C3 已经被卸载。*

*![](img/48bf57475ed9f25459a5786475dbc5de.png)*

*include 属性基于组件实例的名称选项来区分组件实例，而不是基于组件方法中设置的组件标记名称。*

*我们需要为每个子组件设置名称选项。*

*![](img/211b7f7dd1f9d30d219a731dcd85c40e.png)*

*现在，include 属性可以工作了。它将拯救 C1 和 C3。*

*![](img/b7569ee25dcca87ba096046764252821.png)*

*使用 exclude 属性，我们可以指定不想保存的组件。exclude 属性仍然只适用于 name 选项。*

*在这一课中，我们将向您展示如何一起使用指令和子组件的 v。*

*在根组件中，我们有一个名为 list 的数据属性。它的值是一个数组。每个元素都是一个城市名。*

*![](img/b6d676ed774362b4c36745d03b642a87.png)*

*我们使用 V FOR 指令迭代数组。*

*首先，我们添加一个 UL 标签。*

*在它里面，我们添加了李标签。LI 标签是我们添加 v for 指令来遍历列表数组的地方。*

*每个 Li 标签都需要一个唯一的键值。通常，我们使用元素索引来设置键值。这是保证每个元素都有唯一键值的最简单的方法。*

*现在，我们已经遍历了列表数组。每个元素都已输出。*

*![](img/286e3bb9475861a665949ae78955ab94.png)*

*接下来，我们使用子组件显示每个元素。*

*一个子组件显示一个数组元素。所以 v for 指令应该安装在子组件标签中。*

*![](img/412a45cdcd988a23fad97fcf2743f097.png)*

*为了将元素值发送到子组件中，我们需要声明一个属性。我们把它命名为城市。*

*在子组件标记中，我们将数组元素分配给城市属性。*

*现在，我们已经遍历了数组，并为每个数组元素安装了一个子组件。*

*![](img/79cc3cd74772ad1486eceed7524e1d98.png)*

*在子组件中，我已经添加了卸载挂钩。当我们从列表数组中移除元素时，它将被触发。*

*![](img/fa3817d02e0d420e1b956aab5b55ea2b.png)*

*我们从列表数组中移除最后一个元素。*

*我们可以看到卸载挂钩已经被触发了一次。*

*![](img/843a7c130c62160ee7e01087c4d59c92.png)*

*如果我们改变一个元素的值，卸载钩子将不会被触发。Vue 将在原始组件中显示新元素值。*

*![](img/a7cd43392e8416e6752c81a190fb2102.png)*

*接下来，我们一起使用元素索引和元素值来设置键属性的值。*

*当我们改变元素值时，键值也会改变。因此，Vue 将重新创建并重新安装显示修改元素的组件。*

*![](img/6cee1591440105d6f0ec2562b84479a8.png)*

*从这节课开始，我们将向你展示如何在 Vue 程序中创建过渡和动画。*

*仍然由原生 CSS 属性生成的过渡和动画。Vue 只是帮助我们应用和删除那些属性。Vue 也支持基于 CSS 或基于 JS 的第三方 CSS 库。*

*在这一课中，我们将快速回顾三个 CSS 属性:过渡、变换和动画。我们将在以后的课程中用到它们。*

*我这里有一个 DIV。它由一个名为 *initialStyle* 的类进行样式化。*

*![](img/3ff213cb21d38b3b21ff91893c3625ab.png)*

*我们创建另一个类，并将其命名为 *newStyle* 。*

*新类设置了较小的宽度和高度以及不同的背景颜色。*

*我们希望新的类覆盖旧的类，所以一定要在前一个类的后面定义新的类。*

*![](img/59618ca7d6dcc64cc565f6ca5b51a270.png)*

*我们将新类应用于 DIV。*

*我们使用对象语法设置 class 属性。我们使用*显示*属性来控制新类的应用。*

*然后我们转到数据选项来定义*显示*属性。我们将其值设置为 false。*

*在 DIV 的顶部，我们添加了一个按钮来反转*显示*属性的值。*

*现在，通过单击按钮，我们可以在 DIV 中添加和删除新类。因此，DIV 将在新旧样式之间切换。*

*![](img/8e441c0a7684b6e89998d56a6ea8690a.png)*

*目前，这两种风格之间没有过渡。DIV 会立即从一种样式切换到另一种样式。*

*在 initialStyle 类中，我们添加了*转换*属性。它的值有三个部分。第一部分列出了我们想要转换的 CSS 属性。这里，我们把 *all* 放入所有 CSS 属性。*

*第二部分设置过渡时间。我们把它设置为 2 秒。最后一个控制过渡过程。默认值为*缓动*。过渡开始缓慢，然后快速进行，然后缓慢结束。*

*![](img/ec3cb610a617808ab20069e83948e061.png)*

*现在单击按钮，DIV 逐渐在两种样式之间转换。从一种风格到另一种风格只需要两秒钟。*

*这里有个问题:过渡物业的位置有什么要求吗？如果我们把它移到 newStyle 类中会发生什么？*

*![](img/b2137b38548d7f9e8ef155be38601f14.png)*

*DIV 可以从初始样式转换到新样式。*

*但它不会转变回来。它直接迎合了旧风格。*

*原因是这两个类是如何设置的。*

**newStyle* 类覆盖了 *initialStyle* 类。通过单击按钮，我们可以添加和删除 newStyle 类。然而， *initialStyle* 类总是被绑定到 DIV。*

*当我们删除 newStyle 类时，其中定义的 transition 属性也消失了。DIV 不再有任何过渡属性。因此，它将恢复到默认样式。当我们将 newStyle 类添加到 DIV 时，我们将只有过渡效果。*

*如果我们在 *initialStyle* 类中定义了 *transition* 属性，那么 DIV 将总是具有 transition 属性，因此可以在两种样式之间转换。*

*设置转换属性的关键是确保**总是**应用于被转换的元素。*

**变换*属性将 2D 或 3D 变换应用于元素。它允许我们移动、旋转、缩放等。，元素。*

*一起使用*变换*和*过渡*属性，我们可以创建简单的双关键帧动画。*

*默认元素样式和位置设置开始关键帧。transform 属性设置结束关键帧。使用 transition 属性，DIV 从开始的关键帧过渡到结束的关键帧，从而生成动画。*

*![](img/60bb920dca4abaccf0838b179baabe07.png)*

*transform 属性仅适用于块和内嵌块元素。它不适用于行内元素，因为行内元素没有自己的大小。*

*总之，*转换*属性应该永久绑定到被转换的元素。不要将它放入将被删除的类中。*

**转换*属性仅适用于块和内嵌块元素。*

*过渡是一个元素从一种风格逐渐变为另一种风格的过程。这是一个双关键帧动画。*

**initialStyle* 类设置第一个关键帧。 *newStyle* 类设置第二个关键帧。*

*transition 属性使元素能够从一个关键帧过渡到另一个关键帧。它还控制过渡的持续时间。*

*过渡属性的限制是我们只能从一个关键帧改变到另一个关键帧。如果我们想要设置更多的关键帧呢？*

*在这种情况下，我们需要*动画*属性。*

*我们禁用 newStyle 类。*

*也不需要过渡属性。*

*我们创建了一个新的类。我们将其命名为*动画*，并在其中设置了*动画*属性。*

*动画属性要求我们至少设置两个值:动画名称和持续时间。动画名称实际上是一个类名。*

*接下来，我们定义动画类。*

*我们用@keyframes 作为类名的前缀。*

*我们设置了三个关键帧。0%表示动画的开始。50%表示动画的中间部分。100%表示动画结束。*

*设置的关键帧越多，动画就越复杂和平滑。*

*在第一个关键帧中，我们没有对 DIV 进行任何更改。*

*在第二个关键帧中，我们将 DIV 分别向右和向下移动 200 个像素。然后我们把它旋转 360 度，放大 50%。我们还将背景颜色改为红色。*

*在结束的关键帧中，我们将 DIV 分别向右和向下移动 200 个像素。我们将 DIV 旋转另一整圈。我们将其大小和背景颜色设置为原始值。*

*![](img/c51d7cb1f8c6093b96b5c449e3d422b6.png)*

*我们用 animate 类替换 newStyle 类。我们可以使用显示按钮来控制动画。*

*![](img/68b0adffe7c2c55ed927e0ff55d96f81.png)*

*让我们测试这个程序。*

*现在我们已经创建了一个三个关键帧的动画。DIV 首先扩展，然后收缩回来。它的颜色从绿色变成红色，然后又变回绿色。动画一结束，DIV 就会恢复到原来的样式。如果需要，您可以添加更多关键帧，以使动画 DIV 过渡回其原始样式。*

*![](img/27005caefe1e5e5a4023a5a21ee75f43.png)**![](img/18b4ddfb92f57db8de71f6cbcc82eadd.png)**![](img/448e5f6d0d35953caf731fd4e73866a4.png)*

*在本课中，我们将向您展示如何使用 Vue 创建休假和进入过渡。*

*![](img/f3a2eb714824aa59b295afbfafbac22f.png)*

*Vue 为我们提供了两个内置组件来创建过渡。他们是过渡和过渡集团。我们将从过渡开始。TransitionGroup 用于从动态生成的列表中转换项目。我们以后再处理。*

*为了定义自定义过渡效果，Vue 提供了六个过渡类。在离开或进入转换期间，这六个类将在预定义的时间自动添加和删除。*

*六个过渡类必须由我们来定义。因此，我们也为现有的转换类提供了 9 个挂钩点。这些挂钩点允许我们使用第三方动画库中的类。*

*有十一个转换事件允许我们绑定十一个类型的钩子函数。这些事件允许我们使用基于 JS 的动画库。*

*![](img/52b50871d5a86285a78aadd35f512402.png)*

*首先，让我们仔细看看过渡过程。*

*假设我们有一个页面元素。目前它在默认样式设置下正常显示。*

*![](img/4e9301af7068a30fc8bfdd8558584ff1.png)*

*首先，我们将它转换出来。离开过渡包括将元素大小缩小到零，并使元素完全透明。*

*![](img/dfde0b4ffe90e606167724d32fa4ec53.png)*

*然后我们把元素转换回来。进入转换是离开转换的镜像。元素大小从零增长到默认大小。它的不透明度从 0 到 100。*

*![](img/da5f4e8abdafcdb42c77cbd4009b05c7.png)*

*enter 转换结束后，该元素将返回到默认样式下的正常显示中。*

*![](img/0af3e03379b6a7a401432bd5e1370993.png)*

*在整个过程中，默认样式一直应用于元素。进入和离开过渡由覆盖默认元素样式的过渡类创建。Vue 保证在被转换元素的默认样式后面定义六个转换类，这样它们可以覆盖默认样式。*

*![](img/70c03840139c9eb3a57e31fa487a59e2.png)*

*总之，我们可以绘制四个关键帧:离开和进入过渡的开始和结束。Vue 为四个关键帧中的每一个都提供了一个专用类。它们是 leaveFrom、leaveTo、enterFrom 和 enterTo。*

*![](img/20d23781e8520fb34d38db7b300ebc4d.png)*

*来自类的两个*定义开始关键帧，两个*到*类定义结束关键帧。转换后的元素从*类的*设置的样式变为*到*类设置的样式。**

*![](img/fce16d074f389e8e098714f158ed3a5f.png)*

*为了管理过渡过程，Vue 为我们提供了两个特殊的类:leaveActive 和 enterActive。这两个类是我们定义转换属性的地方。*

*![](img/c1dc52dddd975813461957c8e966d07c.png)*

*这两个活动类在整个转换过程中应用于转换后的元素，并将在转换结束后被移除。由于两个活动类中定义的转换属性，转换的元素可以逐渐从一种风格转换到另一种风格。*

*![](img/886457e07347bd606b1dd6b82f932097.png)*

*我们希望元素平滑地过渡出来和过渡进去。*在离开转场开始和进入转场结束时，转场元素看起来应该和正常显示时一样。*因此，leaveFrom 类和 enterTo 类不应该对元素样式进行任何更改。这就是为什么我们通常不定义这两个类。Vue 将在离开过渡开始和进入过渡结束时应用两个空的**类。这样，转换后的元素可以进入它们的默认样式，也可以离开它们的默认样式。风格不会有什么突变。***

*![](img/8f57254da8bd6c6380e7f4f96b21d733.png)*

*在离开转换结束和进入转换开始时，转换的元素不可见。它的大小和不透明度都为零。因此，*离开到*班和*从*班进入是相同的。*

*![](img/73376ff65bbcd5b36f12bbe4cc56b463.png)*

*通常，我们希望离开转换和进入转换相互镜像。所以这两个活动类通常也是相同的。*

*![](img/eb58cc07356395c4193101fc63aa45da.png)*

*总之，我们有六个转换类，但是通常我们只需要定义其中的四个。两个*活动的*类通常是相同的，并且*离开*和*进入*类大部分时间是相同的。*

*我们可以定义任意多的过渡效果。为了区分它们，转换类需要一个自定义前缀。自定义前缀通过*名称*属性在转换组件中声明。*

*![](img/78c9eef030e347b1611ee88b287cac76.png)*

*接下来，我们来试试这六个过渡类。我还不会创建任何过渡效果，我将首先向您展示六个过渡类的添加和删除。*

*我们这里有一个 H1 标签。我将 *display* 属性赋给了它的 V IF 指令。通过反转*显示*属性的值，我们可以挂载和卸载 H1 标签。*

*![](img/5a1778a1087d679816d054b1e812b563.png)*

*首先，我们将 H1 标签移动到转换组件中。*

*在过渡组件中，我们添加了*名称*道具，并将其值设置为*演示*。*

*![](img/70d9681cb2986378f0673666ec5e394d.png)*

*然后我们定义六个过渡类。都需要加上前缀 *demo* 。*

*在 enterFrom 类中，我们为 H1 标签设置了蓝色背景。*

*在 enterActive 类中，我们添加了 transition 属性。我们选择所有 CSS 属性，并将持续时间设置为 5 秒。*

*在 enterTo 类中，我们将背景色设置为绿色。*

*在 leaveFrom 类中，我们将背景色设置为黑色。*

*leaveActive 类与 enterActive 类相同。*

*在 leaveTo 类中，我们将背景颜色设置为黄色。*

*通过监视 H1 标签的颜色变化，我们可以知道何时添加和删除了一个转换类。*

*![](img/5a8fac969e3e1f5064d4a079c19dba0b.png)*

*让我们试试这个程序。*

*我刷新页面。目前，H1 标签在其默认样式下正常显示。*

*![](img/a1e63066d883cbcba1b4658e591b9aec.png)*

*我们单击按钮将 H1 标签移出。*

*我们可以看到，当我点击按钮时，H1 标签的背景色变成了黑色，这证明了 *leaveFrom* 类已经应用到了 H1 标签。*

*![](img/7f369e36ee567f15ad58a04cf1acce41.png)*

*然后逐渐变成黄色。这个过程需要 5 秒钟*

*![](img/5c74e1589a5d661b111870daf3fc3c7c.png)**![](img/f2e123f5bb103afb96af68305b7282fc.png)*

*当背景变成黄色时，H1 标签就消失了。这证明了 leaveTo 类防御是 leave 过渡的结束关键帧。*

*![](img/fad3f8cc0b70b01939c529550db9041c.png)**![](img/47d9a4bd249594d45dc731d1663ac43b.png)*

**leaveActive* 类使 H1 标签逐渐从 *beforeLeave* 类设置的样式变为 *leaveTo* 类设置的样式。在离开转换结束后，H1 标签被卸载。*

*接下来，让我们尝试进入过渡。我再次单击按钮，将 H1 标签转换回来。*

*当我点击按钮时，H1 标签以蓝色背景出现。这证明了 *beforeEnter* 类已经应用于 H1 标签。*

*![](img/0ba04f37400573c290acc9f0f5aca1b2.png)**![](img/c4d588b2266644d3ba99f0e6e0c14bfc.png)*

*然后 H1 标签开始变绿。这个过程也需要五秒钟。*

*![](img/8003134ff69618c9aa8d87752b4449dc.png)**![](img/37d20f2736e5b72f929154c799e63da4.png)*

*当 H1 标签变成绿色时，它会恢复到默认样式。*

*![](img/13e38937fa1768934bc8dacf46e35f7e.png)**![](img/d19a607f6d611e5db20749eb7a1af93e.png)*

*让我们打开源 HTML 代码，再次运行该文件。请注意将要添加到 H1 标签中的类。*

*当我单击 display 按钮时，H1 的背景色变成黑色，并接收两个类:leaveActive 和 leaveTo。*

*![](img/a22b57d669cb07cc56ad01fe2bcf8cbc.png)*

*休假过渡结束的那一刻，H1 标签和两个休假类都消失了。*

*![](img/850c78b1f4596ca6fb300e707f22a979.png)*

*我们再次点击按钮。*

*H1 标签立即以蓝色背景显示出来。它有两个类:enterActive 和 enterTo。*

*![](img/166b737968f14d511e0abd535a90666c.png)*

*当回车键转换结束时，两个回车键类消失了，H1 标签恢复到原来的样式。*

*![](img/e3ceb6a4138513a6d80944f458f22a13.png)*

*Vue 所做的只是添加和删除预定义的时序转换类。我们负责将正确的 CSS 属性放在正确的转换类中。*

*当过渡开始时，将应用来自类的*。在转换过程中，*活动的*和*到*类被应用于被转换的元素。过渡一结束，*激活的*和*到*类将被立即移除。**

*默认情况下，Vue 将根据 transition 属性设置的持续时间来确定过渡持续时间。*

*![](img/7e21be1582a340b2db62064f8b9630c7.png)*

*使用持续时间属性，我们可以手动控制过渡持续时间。持续时间属性以毫秒为单位测量时间。在这里，我们将其设置为 8000。*

*![](img/ff5fead1ad94a8e44e6f7174a0916de6.png)*

*CSS 转场只持续 5 秒。这意味着*活动的*类和*到*类将被额外绑定到被转换的元素三秒钟。*

*让我们测试这个程序。*

*我点击按钮开始离开过渡。*

*H1 标签的背景颜色已经是黄色，但是 H1 标签仍然显示。active 和 to 类仍然绑定到 H1 标签。*

*![](img/9699c9008571a0d4fbb6d70a50b71417.png)*

*三秒钟后，H1 的标签不见了。*

*![](img/29f0f3636a78a9b8db4a8cb88cc3764f.png)*

*再次点击按钮，我们将得到相同的结果。*

*H1 标签的背景颜色在五秒钟内从蓝色变成绿色。背景颜色将保持绿色三秒钟。*

*![](img/ce333130d91791ad4380ed4388a70de2.png)*

*三秒钟后，*激活的*和*到*类被移除。H1 标签恢复到默认样式。*

*![](img/474dfa076c7409992bfc687766100c8d.png)*

*我们可以为进入和离开转换设置不同的持续时间。*

*我们用 v bind 指令绑定 duration 属性，并给它分配一个对象。*

*该对象有两个属性:进入和离开。我们将输入设置为 8000，将输出设置为 80。duration 属性的优先级高于 CSS transition 属性。这意味着进入过渡有足够的时间完成，但离开牵引没有足够的时间完成。*

*![](img/2cbda940c6c8dfd8c46a4892bde55b71.png)*

*在上一课中，我们向您展示了 Vue 何时添加和删除过渡类。在本课中，我们将创建一个完整的过渡计划。*

*![](img/580e519cedd584adb5e198e2e318875a.png)*

*在 enterFrom 类中，我们将不透明度设置为零，并将缩放设置为零。*

*我们保持 enterActive 类不变。*

*enterTo 和 leaveFrom 类应该为空。目前，我们出于演示目的保留它们。*

*![](img/6c3458ea79d542e143e8bc0467c3e69e.png)*

*leaveActive 类与 enterActive 类相同。*

*leaveTo 类与 enterFrom 类相同。*

*![](img/ff53d23807fe8d8575000ee1b748e890.png)*

*现在，让我们检查程序。*

*当我点击按钮时，H1 标签的背景变成黑色。*

*![](img/ad4afa00f8047d2e394ad43b0ad7ecf9.png)*

*然后它会缩小，变得更加透明，直到完全看不见。*

*![](img/e8dd8f34683ebb6138f0aabbe4b9c1e3.png)**![](img/70d2f7375f47890a3cf611d8558c5360.png)*

*我再次点击按钮。*

*H1 标签以其默认的背景颜色显示。随着它的扩大，它的背景逐渐变成绿色。*

*![](img/7d335fb76734624b8366a4de09dd9a4e.png)**![](img/e968ddf04edf6b48b36ae7a141b105b4.png)*

*当回车转换结束时，H1 标签会马上回到默认的背景色。*

*![](img/fd0cba7fe109ac52cfcda3596ed15e39.png)**![](img/b28969995519221feceecdafdcab54d7.png)*

*大多数时候，我们不希望风格有任何突然的变化。所以我们通常不定义类的入口和出口。*

*![](img/dd40e5dd13504b90acff0460d6f9fc7a.png)*

*H1 标签现在从默认样式中淡出。当它重新进入时，它直接转换到默认样式。*

*接下来，我们创建一个 H2 标签，并将其添加到转换组件中。*

*![](img/8f7979d782cb8e9931aa97018196382d.png)*

*现在我们在转换标签中有两个元素。两者都可以过渡吗？*

*我们可以看到我们得到了警告。转换标记之间只能有一个元素。*

*![](img/77f50a0daafca7456b43d061fa889fea.png)*

*在 H2 标签中，我们添加了 V ELSE 指令。*

*现在，问题已经解决了。*

*![](img/4fa009e15d7e98648e0904a03854e383.png)*

*单击按钮。*

*H1 标签逐渐消失。与此同时，H2 标签淡入。*

*![](img/193a3887c9f2918cc2ea907545a6e66b.png)*

*再次点按该按钮，H2 标签淡出，H1 标签淡入。*

*![](img/2892bbbd7fb7172f694c5a9af836897a.png)*

*通常，我们不希望两个转换同时发生。更合理的安排是先淡出当前元素，然后淡入新元素。*

*在过渡组件中，我们添加了*模式*道具，并将其值设置为中的*输出破折号。现在，当前元素将过渡出来，然后新元素过渡进来。**

*![](img/ee9e4e8fa8053de3accbd3e753dae6d3.png)*

*您也可以在破折号中使用*，其工作顺序与此相反。**

*当我们刷新页面时，当前元素直接显示出来。没有进入转换。默认情况下，在初始渲染期间不会触发进入过渡。*

*为了打开初始渲染的过渡，我们将*出现*道具添加到过渡组件中。我们可以在这里使用较短的语法:我们直接将 appear 放在转换组件中。我们可以跳过在它前面加上 v bind 指令并将 true 赋值给它。*

*现在，当我们刷新页面时，当前元素将会过渡到页面中。*

*![](img/4ce46c8e154a9714ef95124e77d919fc.png)*

*我们还可以使用 CSS animation 属性创建过渡效果。这一次，我们只需要两个活动类。*

*![](img/a30d89f55a21cf7271d216a0d2e79e00.png)*

*在 enterActive 类中，我们添加了 animation 属性，并为其设置了动画名称和持续时间。*

*在 leaveActive 类中，我们设置了相同的动画，但是反转了动画方向。*

*然后我们使用关键帧来定义动画。这里，我们只创建一个简单的弹出动画。*

*![](img/369da35eb4474c9782017e747026ceb7.png)*

*让我们试试这个程序。*

*我们可以看到当前元素将弹出，新的元素将弹出。*

*在转换过程中，*活动的*和*到*类都将被应用到被转换的元素，即使*到*类没有被定义。*

*![](img/e03d2a903de71f67b9e8c1b055fd23ef.png)**![](img/f72ccc5e335145c03af7226e7ae1c23f.png)*

*这证明了 Vue 通过在预定义的时间添加和删除转换类来创建转换。我们需要确保在正确的转换类中定义了正确的 CSS 属性。*

*在这一课中，我们将向您展示如何向动态生成的列表添加过渡效果。*

*我们这里有一个数组。每个元素都是一个城市名。*

*![](img/3292259b240e65e85f5a63c9d5567918.png)*

*我们还有一个名为 newCity 的空数据属性。我们用它向列表数组中添加新的城市名。*

*![](img/d7230d3e7d6d3f3ecd3238c41d010d99.png)*

*首先，我们呈现一个列表。*

*在 Li 标签中，我们添加了 v for 指令来遍历列表数组。*

*我们为每个列表项创建一个删除按钮。使用拼接方法，我们可以使用元素的索引来删除元素。*

*![](img/f3bbb159a3f913c4e068efeb313c8a1a.png)*

*我们列出了列表数组中的每个城市。每个城市都有一个专用的删除按钮。*

*假设我们在删除列表项时想要一个过渡效果。*

*我们首先用 transitionGroup 标记替换 UL 标记。列表是动态生成的，所以我们需要 transitionGroup 组件，而不是 transition 组件。*

*![](img/37704509f70fa197960a4104a6243328.png)*

*你可能想知道为什么我没有保留 UL 的标签。使用*标签*属性，我们可以将 transitionGroup 组件转换成一组 UL 标签。*

*我们可以看到 UL 标签已经创建。所有 LI 标签都嵌套在其中。*

*![](img/46edb1ffbb1ef7ca2c08a0add89e17a1.png)*

*tag 属性可以将 transitionGroup 组件呈现为任何标记。*

*![](img/b25c2750afb366d1947300378ed445e0.png)*

*接下来，我们添加 *name* 属性来声明转换类的前缀。我们还是把前缀命名为 *fade* 。*

*然后我们从类定义*回车。我们将*不透明度*属性设置为零。我们添加了*转换*属性来将项目向右移动 40 个像素。**

*然后我们从类中复制了*enter，并将其重命名为 *leaveTo* 。**

*接下来，我们定义了 *enterActive* 类。这是我们定义*转换*属性的地方。我们选择所有 CSS 属性，并将持续时间设置为 2 秒。*

*以同样的方式定义了 *leaveActive* 类。*

*![](img/f873f35c847068f28f8a03163e23f81a.png)*

*让我们检查程序。*

*我们每删除一个项目，被删除的项目就会淡出，向右移动。*

*但是有一个问题。在被删除的项目完全淡出之前，它仍然保持其原始位置，这意味着在它后面定义的项目将继续停留在它们的原始位置。*

*![](img/75f15ac5d4dfcdf3f0fabb8ebef782dd.png)*

*删除的项目消失后，在它后面定义的项目会吸附到它们的新位置，而不是平滑过渡。*

*![](img/a259995de3ed2c57e8cf30dccdf43260.png)*

*知道怎么解决这个问题吗？*

*在 *leaveActive* 类中，我们添加了 *position* 属性并将其值设置为 *absolute* 。绝对定位的元素将从文档流中提取出来。因此，它们不会阻塞在它们后面定义的元素。*

*现在，当我们单击 delete 按钮时，被删除的项目停止阻塞它后面定义的元素。但是这些元素仍然会快速进入新的位置。*

*![](img/d2504fd2c8e173fc6dfc9b86196f0709.png)*

*为了解决这个问题，我们需要添加一个新的类:move。它仍然需要由 *name* 属性声明的前缀。*

*在 *move* 类中，我们添加了转换属性并监控转换属性。move 类将自动应用于移动到新位置的元素。*

*在我们删除了一个项目后，后面定义的项目会逐渐被提起。*

**move* 类只会被添加到在已删除项目后面定义的元素中。在删除项目之前定义的项目不会接收*移动*类。*

*![](img/851e47dda9f7066873b47b96f3ac6df0.png)*

*接下来，我们添加一个输入标签。我们把它和新城物业联系起来。*

*然后我们创建四个按钮。*

*第一个按钮将新城市添加到列表数组的开头。*

*第二个按钮将新城市添加到列表数组的中间。*

*第三个按钮将新城市添加到列表数组的末尾。*

*最后一个按钮按字母顺序排列城市名。*

*![](img/d8a91fc331f150aa9f88b40e3c940531.png)*

*我们在列表的开头添加了一个新的城市。*

*列表中的每一项都收到了 move 类。它们将逐渐下移，为新的第一个项目腾出空间。*

*![](img/5c32e3951405d88acb5c7b1b920c048d.png)*

*接下来，我们在列表中间添加一个新城市。*

*这一次，只有列表后半部分的项目被归入了*移动*类。*

*![](img/cf5eb39aaf65728f44b5f94bf598f926.png)*

*如果我们在列表末尾添加一个新城市，只有新项目本身会有过渡效果。*

*![](img/fe37268adeab326f81622f04580827bd.png)*

*我们单击最后一个按钮，按字母顺序对城市名称进行排序。*

*所有物品这次都复活了移动类。他们将向上或向下移动到他们的新位置。*

*![](img/268eee4699ac10cf0000938891f0dd4a.png)**![](img/0c2a770881ae007cad90f036d3dcc684.png)**![](img/81c983fc4ec11beec9c2f130ff2617ef.png)*

*Vue 支持第三方动画库。我们将以 animate.css 为例。在开始之前，让我们先快速回顾一下如何使用 animate.css。*

*![](img/5abeec94707c4809eb8a562037d0c52f.png)*

*Animate.css 是一个免费的动画库。它为我们提供了许多预定义的动画效果。我们可以使用这些动画来创建过渡的效果。*

*动画点 css 是纯粹基于 CSS 的。要安装它，我们只需要导入它的源 CSS 文件。*

*![](img/131ed7c032a429722d231fd69538c5f8.png)*

*为了将动画效果应用于页面元素，我们为它分配了两个类。第一个是*动画*。它以 animate 为前缀。注意这里，我们需要两个下划线。*

*![](img/50641522b8eb54388d028e8098d3c68b.png)*

*第二个类决定应用哪个动画效果。*

*我们选择一个我们想要的动画并复制它的类名。*

*![](img/95a1b6d721c0c04a1dd4c5e53c098847.png)*

*接下来，让我们在一个 Vue 程序上尝试 animate.css。*

*首先，我们将链接标签粘贴到 Vue 文件中。*

*![](img/cc5edff52857f31487bd2c0127e1d441.png)*

*文想搞活的主儿。*

*我们为它设置了两个类。第一个是*动画*。*

*第二个类决定哪个动画效果将应用于 H1 标签。*

*我们选择摆动动画。我们复制它的类名，并将该名称粘贴到 H1 标签中。*

*![](img/a806a3f37112b3808c3a9cf0b186dd1b.png)*

*现在，当我们刷新页面时，H1 标签会抖动。*

*![](img/eb3c636201a28a2ec5f336d414f123c7.png)*

*我们可以控制动画的持续时间。*

*我们选择分配给 H1 标签的两个动画类。我们添加了*动画持续时间*属性，并设置了一个新的持续时间。*

*Animate 需要以两个下划线为前缀。*

*![](img/1b8cdcdf283d916fabcf8548dc68a2c7.png)*

*在本课中，我们将使用 animate.css 中的类创建进入和离开过渡。*

*所有六个转换类都可以转换成类挂钩点。我们只需要去掉它们的前缀，在它们后面加上*类*。*

*![](img/afda682254d573e0c7582c178b2907aa.png)*

*其他三个挂钩点用于过渡元素的初始呈现。*

*![](img/3ce58e2fee8ab50b3c9b7e5beca44a77.png)*

*所有这些类挂钩点实际上都是转换组件的道具。它们的值是类名。分配给它们的类将在预定义的时间添加和删除。*

*这九个道具允许我们使用来自第三方库(如 animate.css)的现有类来创建过渡*

*动画库使用关键帧创建动画。所以很多时候，我们只需要设置两个*主动*道具。*

*![](img/14ad0556b4f12db46e1f83f83d29663c.png)*

*目前，Vue 有一个 bug。*外观类*道具不工作。根据我自己的测试，正确的名字应该是 *appearFromClass* 。这节课结束时，我会向你证明这一点。可能等你看到这个视频的时候，Vue 已经修复了这个 bug。*

*![](img/bc229c93f9dd3e61efd9eb07749d2c17.png)*

*接下来，我们来试试这些过渡道具。我们将从进入和离开道具开始。*

*这是我们以前用过的程序。两个活动的*类控制动画的持续时间。**

**pop* 类定义动画的关键帧。*

*![](img/dca9fadb0b0c6859898ddf1d50075231.png)*

*我们将使用 animate.css 提供的类创建*进入*和*离开*过渡。所以这三个类都不需要。*

*也不需要*名称*道具。*

*![](img/4f852f81087cecea4ba9dede87281056.png)*

*我们从 animate.css 的手册中复制链接标签。*

*![](img/4ab65c637c38e44676210570176e5a27.png)*

*现在，我们已经在程序上安装了 animate.css。*

*在过渡组件中，我们添加了两个*活动类*道具。*

*![](img/ef49dcc50289aeef619d3e10f3fc9f2a.png)*

*它们的值是类名。他们都需要*动画*类。*

*![](img/2c4fbbd9ed11a4d25dd75249a038b1b6.png)*

*然后，我们为 enter 过渡选择一个动画类，并将其类名分配给 *enterActiveClass* 属性。*

*在 *leaveActiveClass* 道具中，我们设置了相反的动画类。*

*![](img/a4bf58ab06184cf8bf44e083e834def3.png)*

*现在，两个*活动类*道具将在离开和进入过渡期间应用分配给它们的动画类。当过渡结束时，应用的动画类将被移除。*

*接下来，我们为*进入*和*离开*动画设置更长的持续时间。*

*![](img/8aaef38bd590e0ba09e47ac0c6c1a98f.png)*

*让我们测试这个程序。*

*请注意将要添加到 H1 标签中的类。*

*当 H1 标签被过渡出来时，它有三个类:来自 animate dot css 的两个动画类和 *leaveTo* 类。*

*这两个动画类是由 *leaveActiveClass* 道具添加的。 *leaveTo* 类是六个过渡类之一。它尚未定义，但已被添加。我们没有在转换组件中设置*名称*属性，所以前缀是 V，这是默认值。*

*这也揭示了一个事实，即 Vue 只添加和删除预定义时间的转换类。我们负责正确设置过渡类。*

*当 H2 标签过渡进来时，它仍然有三个类。前两个来自 animate dot css，最后一个是我们没有定义的 *enterTo* 类。*

*![](img/2899b336a10ae27eaaad9e3759928894.png)*

*接下来，我们添加*持续时间*道具，并将其值设置为 5000。*

*![](img/4f5a4e7a55ef0fd46e6a8744fffc49e0.png)*

*现在，Vue 将把 5 秒分配给进入过渡，另外 5 秒分配给离开过渡。进入和离开动画各只需三秒钟。因此，过渡元素和分配给它的动画类将在过渡动画结束后多停留两秒钟。*

*![](img/d3dc1fd19169214eaf079a00dbdf3d9c.png)*

*接下来，我们来试试三个*出场类*道具。它们允许我们在第一次加载或刷新页面时为转换后的元素设置专用动画。*

*首先，我们去看 Vue 手册。我们打开 API 列表并找到转换组件。*

*![](img/084fcedd56d1527a33e6b58031bd8b67.png)*

**外观类*道具有问题。它不起作用。正确的名字应该是 *appearFromClass* 。*

*![](img/1d76c2ecb1ac7bef1158f35b5a4f7d34.png)*

*在过渡组件中，我已经添加了*出现*道具来启用初始渲染的过渡。*

*![](img/0fd45fac0d8cd67dfe20b441efeab907.png)*

*让我们刷新页面。*

*H1 标签已经使用由 *enterActiveClass* 道具设置的动画重新进入浏览器。*

*![](img/3f1d64b59cb7ef543431ce28c53d98d6.png)*

*接下来，我们添加*appearractiveclass*道具，并为初始渲染设置一个专用动画。*

*我们再次刷新页面。*

*这一次，H1 标签有了新的动画效果。*

*![](img/e388269a63994dfddf176eb5d22d31a0.png)*

*H1 标签中增加了三个类别。前两个来自动画点 css。最后一个还是 *enterTo* 类。*

*![](img/cd4c220612fc0b0885d18c830e130ef9.png)*

*接下来，让我们一起尝试所有三个*道具。**

*我首先从中定义了一个名为*appear 的新类。我将 H1 标签放大 25%,并给它一个蓝色背景。**

*然后我给定义了一个名为*的类。我将 H1 标签缩小了 25%,并给它一个绿色背景。**

*最后，我定义了*appearance active*类来设置 *transition* 属性。*

*接下来，我将三个*出现*职业分配给三个*出现职业*道具。*

*![](img/030a33316921036620c1483a340e1f06.png)*

*让我们测试这个程序。*

*我刷新页面。*

*H1 标签首先放大并变成蓝色。这证明了 *appearFromClass* 道具正在工作。它将来自类的*appear 应用于 H1 标签。**

*![](img/6b603889a3c97555636635dd6086609e.png)*

*然后，H1 标签逐渐缩小，变成绿色。*

*在这个过程中，它接收了*appear activate*和 *appearTo* 类。这证明了*外观类*和*外观类*道具正在工作。*

*![](img/290fa7c6a2fe4c92a9ece9f8a4a067a4.png)*

*转换结束后， *appearActive* 和 *appearTo* 类都被移除，H1 标签恢复到默认样式。*

*![](img/114ca49f097b3f763d60ca9cceadcd50.png)*

*接下来，我将*外观职业*道具切换到*外观职业*道具。*

*![](img/cecbb1ca925ae6e34158b795e9418182.png)*

*让我们测试这个程序。*

*我们可以看到 H1 标签从默认风格转变过来。来自类的*外观尚未添加到其中。**

**外观类*道具无法识别。它被当作一个未知的道具。*

*![](img/c25c9a02a42db85cbeb34551371f7f47.png)*

*transition 组件为我们提供了 11 个事件，允许我们绑定 11 种类型的钩子函数。*

*![](img/e50813ccfdbaa2d28d40b8042f5e9259.png)*

*这十一个事件可以分为四组:之前、期间、之后和取消。*

*除了组之前的*组，每个组都有三个事件:进入、离开、出现。在出现*事件之前没有*。 *leaveCancelled* 事件仅适用于 v show 指令。V IF 指令删除了转换后的元素，当然，我们不能取消它。**

*![](img/5e4dac3b4941afc6543b93513cea7230.png)*

*这是我们创建的第一个过渡程序。进入和离开转换由转换类创建。*

*![](img/b6d0da46805beaef91feb6b3bab52ac2.png)*

*让我们试试上面的四个项目。*

*我们先去掉*出现的*和*模式下的*道具。也不需要 H2 标签。*

*H1 标记的显示由 display 属性控制。我们将 display 的值重置为 false。*

*然后，我们将过渡持续时间缩短到 2 秒。*

*![](img/9766f9584807c20ce9687d012ef5556c.png)*

*接下来，我们监视四个输入事件。我们将每个输入事件绑定到同名的方法。*

*![](img/abd19e081860cab42f7ea5fd035332e8.png)*

*然后我们转到组件选项对象来定义这四个方法。*

*每个事件方法将接收转换元素的 DOM 对象作为其第一个参数值。*

*![](img/665d2f00b9a8a57cb536d8dbd6750c9d.png)*

*让我们试试这个程序。*

*我单击按钮来过渡 H1 标签。*

*总共触发了三个钩子函数。*

*![](img/d27a15a2a9e9c443d54eea5ca9619e3f.png)*

*当过渡结束时，afterEnter 功能将被触发。*

*![](img/cd36206a9e383345eefe6cc3c0689273.png)*

*从 *beforeEnter* 钩子和从 *enter* 钩子得到的 El 参数是相同的。H1 标签有 enterActive 和 enterTo 类。*

*当 afterEnter 挂钩被触发时，转换已经结束，所以 H1 标签是空的。*

*![](img/0b0e5a7324a0c19fd5d04a11fb0ee858.png)*

*接下来，我们刷新页面并尝试使用*回车取消*挂钩。当我们取消进入转换时，离开转换将立即接管。 *enterCancel* 钩子捕获离开过渡的第一个关键帧。*

*我们可以看到 *enterCancelled* 钩子的 EL 参数有 *leaveFrom* 和 *leaveActive* 类。注意这里，我们有从类的*leave，而不是从*leave 到*类。 *enterCancelled* 钩子捕获了离开过渡的第一个关键帧。**

*![](img/1db2927cb6f03bfc4085f08a5a46796c.png)*

**回车*钩子有第二个参数:*完成*功能。一旦你声明了 *done* 函数，你必须显式调用它。否则，过渡将永远不会结束。*

*回车键转换的动画已经结束，但是 *afterEnter* 钩子还没有被触发。*

*![](img/82dbc934f0acc30598baca5157645889.png)*

*我们调用 *done* 函数并再次运行该文件。*

*这一次，我们遇到了一个新问题。过渡立即结束。没有时间让动画结束。*

*![](img/a2bdce4c9adc6794328a555822f81e2d.png)*

*当我们调用 *done* 函数时，我们必须确保过渡动画已经完成。*

*我们添加了 setTimeout 函数，并设置了三秒钟的延迟。*

*现在，有足够的时间来完成过渡动画。*

*![](img/bcaf50bd6eae25578219a4b376139b36.png)*

*过渡钩子允许我们使用基于 JS 的动画库。我们不再需要 Vue 为我们添加和删除过渡类。在这种情况下，我们可以添加 CSS 属性并将其值设置为 false。*

*转换挂钩仍然会在预定义的时间触发。但是不会再添加过渡类了。*

*![](img/5f61ae2fe231346f69c92b3be7adc176.png)*

*在这节课中，我们将简单介绍如何使用 GSAP:绿袜子动画平台。它的官方网站是 greensock.com。*

*你可以在它的主页上找到它的 CDN 地址。只要链接这个 JS 文件，你的程序就可以访问 GSAP 提供的所有东西。不需要任何配置。*

*![](img/c2d777dfedf37e0e43d96a18fd9bf44a.png)*

*GSAP 有两个库:补间和时间轴。这里，我们只使用补间库。*

*![](img/05f46ff7f4af62c66aa0b717792fa638.png)*

*我们主要使用的是*到*的方法。它有一个相当独特的语法。*

*![](img/9e5d2c9c31d73370721e2c0f2213f5ae.png)*

*我们首先选择目标 DOM 对象。我们可以使用类、ID 或标记名。*

*GSAP 方法的第二个参数是一个对象。该对象可以直接访问所选 DOM 对象的属性。我们从 DOM 对象中选择属性，并为它们设置新的值。*

*然后，我们使用 duration 属性来设置动画持续时间。 *GSAP 到*方法的第二个参数设置结束关键帧。默认元素样式是开始关键帧。*

*![](img/91c388e5773811b409acf35c94f94098.png)*

**GSAP 到*的方法为我们提供了几个定制动画的特性。*

*duration 属性控制动画的持续时间。其值以秒为单位，默认持续时间为半秒。*

**缓动*属性允许我们控制动画过程中的变化率。*

*![](img/ed1de1d38adb92d9239f95032138cbdf.png)*

**onComplete* 属性允许我们在动画完成时设置一个钩子函数。我们可以用它来触发 enter 和 leave 钩子中的 *done* 函数。*

*![](img/c235ba01a150e588899a8118d18b04b1.png)*

*如果动画设计涉及几个关键帧，请使用*关键帧*属性，并为其分配一个数组。每个元素定义一个关键帧。*

*![](img/11fe3c3c5e852492e0365a9097fc6863.png)*

*接下来，我们回到我们的 Vue 计划。*

*我们添加一个新的脚本标签来安装 GSAP。现在我们可以通过全局 API GSAP 访问 GSAP 方法和属性。*

*![](img/84a43dfa0db455621d3a8be121bf6409.png)*

*我们将需要*到*的方法和*设置*的方法。*

*在转换组件中，我们首先添加 CSS 属性并为其赋值 false。这可以防止 Vue 添加任何过渡类。*

*![](img/6333db131145c13881235d4db4809e65.png)*

*然后我们监控 *leave* 事件，并触发一个同名的钩子函数。*

*![](img/d1a6cffe538b9b5d7889c1177fa3efc3.png)*

*接下来，我们定义*离开*函数。*

**leave* 函数有两个参数:EL 和 done。*

*我们在 leave 方法中安装了 *GSAP 到*的方法。*

*我们把埃尔传给 GSAP 的*传给*的方法作为它的第一个论证。*

*第二个参数是一个对象。这个对象可以直接访问 EL 对象。*

*我们设置不透明度和比例为零。*

*然后我们将持续时间设置为 1。*

*我们将 *Done* 函数分配给 *onComplete* 属性。动画结束后，会自动调用 *Done* 功能。*

*![](img/a71f15cd313dc4be867612bd15afdf7f.png)*

*让我们测试这个程序。*

*请注意即将添加到 H1 标签中的内容。*

*在我点击按钮后，H1 标签开始收缩和褪色。*

*H1 标签收到了样式属性。GSAP 仍然通过控制 CSS 属性来生成动画。*

*![](img/9da9561b6b8db1c3af7361181cdd6678.png)*

*接下来，让我们创建一个进入过渡。这一次，我们需要两个钩子:进入之前的*和进入*之前的*。**

*![](img/763fa4403905d8fc3e466995cdbb9e55.png)*

*在 *beforeEnter* 钩子中，我们调用 GSAP *Set* 方法来设置 *enter* 过渡的初始关键帧。我们将不透明度和范围属性都设置为零。*

*在*中输入*钩子，我们将 GSAP *添加到*方法中。*

*我们设置不透明度和缩放回一。然后我们将持续时间设置为 1。我们将 *Done* 函数分配给 onComplete 属性。*

*![](img/765ba6951160ee4bd8c207c37b808c61.png)*

*现在，输入转换完成了。*

*让我们测试这个程序。*

*离开和进入的传统都被设定好了。*

*![](img/adb29ab24b73a33e53ae4580dba8aea1.png)**![](img/6895a02329f3200fe5ba8d624b2f21e1.png)*

*接下来，我们添加*出现*钩子。*

*记住还要添加*出现*属性。*

*![](img/1ddb14ec90fd9addacb94e4e07ccd584.png)*

*我们想为初始渲染创建一个弹出效果。这就需要我们设置两个关键帧。*

*在 *GSAP 到*方法的第二个参数中，我们添加了*关键帧*属性，并为其分配了一个数组。*

*在第一个元素中，我们放大了 H1 标签。然后在第二个元素中，我们将 H1 标签设置回默认大小。然后我们添加 *onComplete* 属性来调用 *Done* 函数来结束转换。*

*![](img/2efd31bf46c4d656e18771e27946716f.png)*

*让我们测试这个程序。*

*当我们刷新页面时，H1 标签将会弹出。*

*![](img/b52f4bb59f8ff92be603181d46be7eb0.png)*

*我们这里有一个输入标签。它连接到数字属性。*

*![](img/bf1c2f1800027e6a6d22dbc22ea87d76.png)*

*我们将*类型*属性添加到输入标签中，并将其值设置为*号*。*

*现在，输入标签中有两个按钮。单击向上按钮，数值增加 1。单击向下按钮，数值减一。*

*![](img/52ee9d5d5294653761bf7b5da919ed6b.png)*

*接下来，我们添加*步骤*属性，并将其值设置为 5。现在，当我们单击两个按钮中的一个时，number 属性的值将增加或减少 5。*

*![](img/3ccce53166b2e3be42c13be5abc9f297.png)*

*数值会立即改变。我们希望将价值变化制成动画。我们在上一课中使用的 *GSAP 到*方法可以帮助我们做到这一点。*

*首先，我们安装 GSAP。*

*在上一课中，我们使用 *GSAP 到*的方法制作了一个页面元素的动画。*

*![](img/7274b30687f1e8a11546b7d4166ebb8e.png)*

*我们将动画元素的 DOM 对象作为第一个参数值传递给该方法。仔细想想，DOM 对象还是 JS 对象，就像 Vue 组件的数据对象一样。有什么灵感吗？*

*在组件选项对象中，我们添加了监视选项。*

*我们监控数字属性。*

*我们在数字监视器中安装了 GSAP 方法。*

*我们将这个点美元符号数据作为它的第一个参数值传递给 GSAP 方法。*

*在第二个参数中，我们将持续时间设置为 5 秒，并将*缓解*设置为*无*。在这个对象中，我们可以直接访问所有数据属性。*

*![](img/26d1f50bd40d2a4609d957d3329ce487.png)*

*当数字属性更新时，将触发数字监视器。它将接收最新的数值。*

*我们创建一个新的数据属性，并将其命名为 *tweenedNumber* 。我们将其值设置为零，这与 number 属性的初始值相同。*

*在 *GSAP 到*方法的第二个参数中，我们将 number 属性的新值赋给了 *tweenedNumber* 属性。*

*![](img/f49dbb156a35a10e20b238e045dbf999.png)*

*这是关键操作。我们通过 *GSAP 到*方法重置 *tweenedNumber* 属性的值。GSAP 将为 *tweenedNumber* 属性的值变化创建动画效果。*

*我们在组件模板中显示 *tweenedNumber* 属性。*

*![](img/40289d0857910878bb6b0fb82aa5dba0.png)*

*让我们测试这个程序。*

*我们可以看到 *tweenedNumber* 属性的值变化现在是动态的。它逐渐上升。整个过程需要五秒钟，这是我们在 *GSAP 到*方法中设置的持续时间。*

*![](img/c4706eed51206f7cd7ce56b78709f8bd.png)*

*我们不需要小数点后的四位数。我们添加 computed 选项并为 *tweenedNumber* 属性创建一个 getter。*

*我们将 getter *命名为 formatedNumber* 。*

*我们使用数学点截断方法处理 *tweenedNumber* 属性的值。声明点后面的所有数字都将被删除。*

*![](img/1e5585d2c25f1472acb1c2de3887d983.png)*

*让我们测试这个程序。*

*有了 formatedNumber getter，我们基本上已经创建了一个数字时钟。数值每秒增加一。*

*![](img/2857afa78a920e142e8b08105e34b572.png)*

*在上一课中，我们向您展示了如何使用 GSAP 制作属性值变化的动画。*

*输入标记只连接到数字属性。number 属性本身永远不会向用户显示。过渡效果应用于作为 number 属性代理的其他属性。*

*我们设置了一个监视器来监视 number 属性。我们将最新的数值赋给 *tweenedNumber。tweenedNumber* 是我们在组件模板中显示的内容。*

*使用 GSAP 方法完成赋值。这是实现状态转换的关键操作。*

*![](img/80d12ea1333ffa30c1de85aaf1f4412d.png)*

*如果我们需要转换其他属性，我们需要为每个属性创建一个观察器和一个代理属性。这是相当不方便的。更好的解决方案是创建一个专用组件来转换属性状态。这样，我们可以重用观察器和代理属性。*

*我们声明一个新的组件。我们把它命名为*动画数字*。*

*在组件模板中，我们显示了 *tweenedNumber* 属性。*

*![](img/6b07e70ddc146a908655bc8b9c49a791.png)*

*接下来，我们添加数据选项来定义 tweenedNumber 属性。我们将它的初始值设置为零。*

*接下来，我们声明一个道具。我们将道具类型设置为 number。*

*![](img/2a6109e31b7d004c390a3856d53dc440.png)*

*我们添加了方法选项。*

*我们定义了一个名为*补间*的方法。我们将其参数命名为 *newNumber* 。*

*我们将补间方法中的 *GSAP 调用到*方法。我们通过了。$data 给 *GSAP 给*方法作为它的第一个参数值。在第二个对象中，我们将持续时间设置为两秒，并将*补间*方法的参数赋给*补间编号*属性。*

*![](img/7aeea512de54ac5ccec54fdbbb93b503.png)*

*接下来，我们添加监视选项，为*号*道具设置一个监视者。*

*在数字监视器中，我们触发刚刚定义的 *tween* 方法，并将数字属性的新值传递给它。*

*![](img/a4d55b0997558862c482a531d6052cc7.png)*

*接下来，我们添加挂载的钩子。我们调用 *tween* 方法，并将当前数字道具的新值传递给它。*

*![](img/778d00622fa00bd03f906c4c4aa18955.png)*

*现在，*动画数字*组件完成了。让我们安装它。*

*我们通过*数字*属性将根组件的*数字*属性发送到 animatedNumber 组件中。*

*![](img/e83d78eaed70ac2e35ae642f7801888b.png)*

*让我们测试这个程序。*

*我们可以看到我们得到了我们想要的过渡效果。*

*![](img/902bfeee3dac5521484039682612b81c.png)*

*在这节课中，我们将学习混音。这是开发 Vue 项目中重用代码的最简单的方法。*

*这里，我们有两个组件:一个根组件和一个子组件。*

*![](img/f1bb1ee5f55e8978bc14d13ef3d435aa.png)*

*两个组件的选项对象可以共享相同的选项。共享选项可以在独立对象中定义，并通过混合添加回选项对象。*

*首先，我们声明一个变量。我们称之为我的混合。我们给它分配一个对象。该对象存储共享选项。这里的语法与普通组件选项对象中的语法相同。对象中的 THIS 指向接收混合对象的组件实例。*

*我们首先添加数据选项。我们定义一个名为 city 的数据属性。*

*然后我们添加计算选项。我们定义了一个名为 capTitle 的计算属性。我们把它定义为吸气剂。*

*我们在 getter 函数中返回 this.title。这指向使用 mix-in 对象的组件实例。为了确保 getter 能够正常工作，接收这个 mix-in 对象的组件必须有一个名为 title 的数据属性。*

*![](img/8e35b930f0c1958bbbe47b474766990a.png)*

*接下来，我们将混合对象添加到组件实例中。*

*在根组件中，我们添加了 mix-ins 选项，并为其分配了一个数组。然后我们将 mix-in 对象传递到数组中。该数组允许我们传递几个混合对象。*

*现在，city 和 capTitle 属性将被添加到根组件实例中。CapTitle 是一个计算属性。它的值基于根组件的 title 属性。城市是一种数据属性。它将被添加到美元符号数据对象中。*

*![](img/a28bee0cdfccdfd8993623be150ee553.png)*

*在根组件模板中，我们可以将首都和城市显示为普通数据和计算属性。*

*![](img/7fe5a327faf8704dc73b102a67a0931a.png)*

*它们都是反应性的。*

*![](img/49f3fece2cbd40f5d105757ba281ca0f.png)*

*如果混合对象有重复的数据属性怎么办？例如，在 mix-in 对象中，我们设置了一个标题属性。*

*![](img/01b0a4f6e763ebc7fc241d749d4c27bc.png)*

*接收 mixin-in 对象的根组件已经有一个名为 title 的数据属性。那么哪个将被添加到组件实例中呢？*

*组件自身的数据属性具有更高的优先级。它们不会被混合对象的重复属性覆盖。*

*![](img/dd5daf4cd3313d1d857d65605b4567a0.png)*

*我们也可以在混音对象中设置挂钩。我们将创建的钩子和控制台日志*混合创建*在其中。*

*然后在根组件中，我们还添加了创建的钩子。我们在控制台日志的*根组件中创建了*。*

*让我们运行程序。*

*我们可以看到两个创建的钩子都被触发了。首先触发来自混音对象的那个。*

*![](img/3500475d78d5da6add8e87a7c7f11bbb.png)*

*mix-in 选项仅将 mix-in 对象添加到当前组件实例中。其他组件实例不会受到影响。*

*![](img/1bf883fae517ea8fdab9e1fcb1807f2d.png)*

*如果我们希望所有组件接收相同的 mix-in 对象，我们可以使用 mix-in 方法。这个方法来自 app 对象。它将混合对象发送到所有组件实例。*

*![](img/8b89a643e1c4f1295b19e748a60bdc54.png)*

*mix-in 方法仍然返回 app 对象。我们可以将挂载方法链接到它后面。*

*在本课中，我们将学习 Vue 自定义指令。*

*Vue 指令基本上是 Vue 提供的虚拟 HTML 属性。它们被插入到 HTML 标签中，从而允许我们直接控制页面元素。*

*例如，V-IF 指令安装在 H1 标签中。我们可以用它来移除和安装 H1 标签。V IF 指令可以在其他地方重用。*

*![](img/40293fffeb8e0cc01f328befa2c4a87d.png)*

*通过创建我们自己的 Vue 指令，我们可以定义定制的 DOM 操作。我们的自定义 DOM 操作可以很容易地在其他地方重用。我们甚至可以同时控制几个元素。*

*有两种类型的 Vue 指令:本地和全局。*

*使用*指令*选项定义本地指令。*

*我们选择一个指令名，然后给它分配一个对象或者一个函数。*

*![](img/eb0adc3e767e3ee797bd44e5533e330f.png)*

*全局指令是使用来自应用程序实例的指令方法定义的。所有组件都可以平等地访问它们。*

*第一个参数是指令名。第二个参数要么是对象，要么是回调。我们将首先尝试对象语法。*

*![](img/c6fd440ed9f860a43b61f5cf4298c18f.png)*

*这个对象给了我们定义 7 种钩子函数的空间。它们是在装载和装载之前、更新和更新之前、卸载和未计数之前创建的。指令挂钩与 Vue 生命周期挂钩相同，只是不包括 beforeCreate 挂钩。*

*![](img/9ccbeecbb615c66d1afe3902a76db3ae.png)*

**创建*这里指的是自定义指令的创建。 *Mount* 表示被挂载到绑定页面元素的自定义指令。 *Update* 表示被修改的绑定元素。*

*每个指令钩子函数接收三个参数:el、binding 和 Vnode。El 代表元素，它指向绑定元素的 DOM 对象。它使我们能够执行 DOM 操作。*

*绑定是一个对象。它存储传递给指令的外部信息。VNode 指向绑定元素的 VNode 对象。*

*VNode 对象是 HTML DOM 对象的 Vue 等价物。这是内部使用的。我们不需要访问或修改它。*

*![](img/4f5d1af8aa0b01b9b2847863f2160fce.png)*

*然后，我们在 H1 标签中安装自定义指令。所有的 Vue 指令名称都应该以字母 v 为前缀，我们的自定义指令也不例外。*

*指令被视为 HTML 属性。大写字母需要转换成小写字母，并以破折号为前缀。*

*![](img/0bb44934427d5c8f7e9ae395975a9f6e.png)*

*现在，我们的自定义指令已经安装到 H1 标签上。让我们刷新页面。*

*我们可以看到三个钩子函数都被触发了。*

*![](img/f175189847f8178bebfa0595c4490bd1.png)*

*接下来，让我们看看传递给指令钩子函数的参数。我们使用创建的钩子作为例子。*

*我们控制台记录所有三个参数。我们还检查它指向哪里。*

*![](img/0c8231bbe0a91a4fdb03e0a62328bc18.png)*

*第一个参数给出了绑定元素的 DOM 对象。我们可以通过它执行各种 DOM 操作。*

*绑定对象使我们能够访问传递给指令的外部信息。DIR 属性列出了指令拥有的所有钩子函数。instance 属性指向使用该指令的组件实例。其余的属性存储传递给自定义指令的信息，包括参数名称、旧的和当前的指令值以及修饰符。我们稍后会处理它们。*

*![](img/17a032e2b856f1f300cc5bd77e0a2673.png)*

*第三个参数给出了 H1 标签的 VNode 对象。*

*这个 in 指令钩子函数指向窗口对象。由于指令挂钩不依赖于此，我们可以使用 arrow 函数来定义它们。*

*![](img/eefcc2d0ca5de5c8cd82be234d688233.png)*

*接下来，让我们添加两个卸载挂钩。*

*![](img/3e2ed7e65ccdc9e829a2de4ac09fb3bd.png)*

*当绑定的元素被卸载时，它们将被触发。*

*![](img/f505ead0427cff9a20d8825e86b44db5.png)*

*我们现在只剩下两个更新挂钩了。我们将在本地指令中尝试它们。*

**指令*选项允许我们定义任意多的本地指令。*

*我们将本地指令命名为 *trackUpdate* 。我们仍然使用对象语法。*

*两个更新钩子函数是特殊的。它们都有第四个参数，即更新前 vNode。前三个论点和前面一样。*

*![](img/9a9e0177e780761d376798c29f833fa9.png)*

*我们用本地指令替换全局指令。别忘了 V 字头。*

*![](img/268ba393935677e8c5b3502825211b07.png)*

*让我们运行文件。*

*我们重置 title 属性来触发两个更新挂钩。*

*我们可以看到前两个论点和之前一样。*

*![](img/b3ca555fcad5daad91ed6de76949c40b.png)*

*让我们试试第三和第四个论点。*

*![](img/0401154cd4e989f2f5f446bc13b10000.png)*

*我们重置标题值来触发两个更新挂钩。*

*![](img/b513fd8dcaaa408885d09982c50af694.png)*

*第三个参数返回更新后的 vNode。它的 children 属性存储新的标题值。*

*![](img/d3b36f339993add8b873e594f0939afe.png)*

*第四个返回前一个 vNode。它的 children 属性存储以前的 title 值。*

*![](img/cf773b14b3a834c72c1b0675952761df.png)*

*我们创建一个新的本地指令。这一次，我们使用函数语法。指令挂钩不依赖于此。所以可以用全功能或者箭头功能。这次没关系了。*

*指令函数将作为两个钩子使用:挂载和更新。我们将指令安装在 H1 标签中。*

*![](img/57e831d737c54eaa1c03b6b71b4889d4.png)*

*让我们刷新页面。指令功能已被触发为挂接。*

*![](img/71d88cb7a5d9236389f73cbc29c47449.png)*

*我们可以通过修改 H1 标签再次触发它。*

*这一次，它被触发为更新的钩子。*

*![](img/0d463137eeed6535d27afdbf19170832.png)*

*挂载和更新的钩子实际上是最常用的方向钩子，可以满足我们的大部分需求。*

*接下来，让我们仔细看看第二个参数:绑定对象。顾名思义，binding 对象存储绑定到自定义指令的信息。*

*![](img/32f9f67b1a126ffbbedfe53d5e09d8f2.png)*

*函数语法只包括挂载的和更新的钩子。所以 dir 属性只有挂载和更新的钩子。*

*![](img/45e4f842ded03550184d6a0d759ecb48.png)*

*instance 属性指向安装自定义指令的组件实例。*

*![](img/f5e4c825d0374861b8055766c7fb2031.png)*

*Vue 指令可以有一个参数。参数名存储在 ARG 属性中。当前参数值本身存储在*值*属性中。oldValue 属性存储前一个参数值。*

*指令名和参数名用冒号连接。我们可以使用一组方括号来设置动态参数名。*

*在组件数据选项中，我们将参数名定义为 *info* 。现在，通过更改 *arg* 数据属性，我们可以更改自定义指令的参数名称。这给了我们一个额外的位置来存储信息。*

*在指令参数后面，我们可以使用点符号链接修饰符。*

*最后，我们使用 description 属性作为指示值。*

*![](img/8b9597da14d8c54bec04926a2d90f54a.png)*

*让我们重新加载页面。*

*我们可以看到传递给自定义指令的所有外部信息都可以在 binding 对象中找到。我们可以找到指令参数名以及当前和以前的指令值。*

*![](img/b7eabb78d7fbead8f2be2c71b5eb7977.png)*

*如果我们重置自定义指令的值，更新后的钩子也将被触发。*

*在绑定对象中，我们可以找到新旧指令值。*

*![](img/80b1f5adab8477ad93a5d1a50dd1b8dc.png)*

*同样，如果我们重置参数名，更新后的钩子也将被触发。ARG 属性存储新的参数名称。*

*![](img/ed0d2c3327feb890fd4a1d01fef478dc.png)*

*如果需要向自定义指令传递几段数据，请使用对象设置其值。*

*![](img/ced067c92e79af5e32adfc0d4cc682ea.png)*

*接下来，我们移动到一个新文件。该文件有一个子组件。*

*![](img/1d6abcf7eb695c96501ef9abc77223ce.png)*

*local 指令是在根组件中定义的，因此它只适用于根组件模板中的元素。从技术上讲，子组件标签是安装在根组件模板中的标签。那么我们可以在子组件标签中安装本地指令吗？让我们找出答案。*

*我们将本地指令移到子组件标签中。*

*![](img/a80a87c6c28a80283512c7bb70c6498f.png)*

*我们可以看到它起作用了。安装的挂钩已被触发。*

*第一个参数 EL 返回子组件模板的 DOM 对象。*

*![](img/c47712462376d536b72a3ecd937b4130.png)*

*绑定对象的实例属性仍然指向根组件实例。*

*![](img/d42c91e8e0f0a9d11f2395c178bcfa1e.png)*

*子组件的模板只有一个元素。让我们在不设置根 DIV 的情况下向它添加第二个元素。*

*![](img/7bc0198af92343365d9253faa4aec9ec.png)*

*让我们重新加载页面。*

*我们收到了警告。该警告是由子组件的模板没有根节点引起的。*

*![](img/9660fb90c9a86f337376f0b2dcedb3f0.png)*

*自定义指令不同于其他非属性，我们不能控制哪个元素继承它。*

*即使我们关闭子组件的属性继承，我们仍然会得到相同的警告。*

*![](img/ce39ae9f7089879dbc2cf63ad782548f.png)*

*解决方案是为子组件的模板设置一个根 DIV。*

*这样，第一个参数 EL 返回给我们整个子组件的模板。*

*![](img/abadd06ff88a3e3d590dbbe6926ecdf9.png)*

*在上两节课中，我们已经学习了自定义指令的基本语法。在本课中，我们将向您展示自定义指令的实际应用。我们将创建一个自定义指令来帮助我们控制所选页面元素的 CSS 样式。*

*首先，我们创建一个输入标签。我们将它的类型设置为 range。然后我们设置一个最小值和最大值。使用 v model 指令，我们将输入标签连接到 size 属性。*

*然后，我们转到数据选项来定义 size 属性。我们将其值设置为 30。*

*现在，我们可以通过向左和向右滚动按钮，在 15 和 100 之间重新设置大小值。*

*滚动到右端，*尺寸*值将增加到 100。滚动到左端，大小值将减少到 15。*

*![](img/0cc23ecef20efd4c576e2c952d7ad91e.png)*

*假设我们想使用滚动按钮来控制任何选定页面元素的文本大小。这要求我们定义一个自定义指令。*

*我们称 app 点指令为定义全局指令。我们把它命名为*调整*。*

*我们使用函数设置第二个参数，因为我们只需要更新的钩子。我们记录第一个参数。然后我们控制台记录绑定对象的 value 属性。value 属性存储当前指令值。*

*![](img/b1df0a95e1ff6387386fcf7d141263df.png)*

*我们在 P 标签中安装了*调整*指令。我们使用 size 属性作为指示值。*

*![](img/c772bbab4efa2afd4eb699040caa1b66.png)*

*让我们刷新页面。*

*我们可以看到我们得到了 P 标签的 DOM 对象和 size 属性的值。*

*如果我们滚动按钮，我们将更改 size 属性的值，这将触发自定义指令的更新挂钩。*

*![](img/e43e88baf399219c3fbeffd9b1e02bb6.png)*

*有什么灵感吗？*

*在自定义指令中，我们通过第一个参数 EL 访问 CSS fontSize 属性。*

*然后，我们使用指令值重置 fontSize 属性。记得在参数值后面加上 PX。*

*![](img/007de021e400aa1c5e775540f2e8b00d.png)*

*让我们测试这个程序。*

*我们可以通过滚动按钮来控制 P 标签的字体大小。*

*![](img/874a329626014631287e0d44bbeb03de.png)*

*自定义指令允许我们重用 DOM 操作代码。我们可以将 *adjust* 指令添加到根模板的其他元素中。这里，我们将*调整*指令复制到 P 标签中。*

*现在，我们可以一起控制 H1 和 P 标签。*

*![](img/8e14384604f479fe0aa34fff4fe2e6f0.png)*

*adjust 指令是一个全局指令。它在子组件的模板中也是可见的。*

*例如，我们可以将它添加到 H2 标签中。*

*但是有一个问题，adjust 指令的值是使用属于根组件的 size 属性设置的。它在子模板中不可见。*

*我们可以看到我们得到了警告。它说无法从子组件实例中找到 size 属性。*

*![](img/47f9eec2d9f855b641b648fcd61e1665.png)*

*此外，我们用来重置 size 属性的输入标记也来自根组件。*调整*指令不是完全独立的。它是全局可见的，但是只有根组件可以提供它所需要的一切。*

*为了控制子组件的字体大小，我们可以在子组件标签中安装 adjust 指令。size 属性在这里是可见的。但是这也要求子组件有一个根 DIV 或者只有一个元素。*

*![](img/0c530814fa5e30b044a2e9a901d5774a.png)*

*我们可以看到，现在我们可以同时控制三个段落的字体大小。*

*![](img/a8f4933b3650944cfa72722daf5c37fb.png)*

*接下来，我们向 *adjust* 指令添加另一个特性。*

*总之，我们有三个 HTML 标签:h1、h2 和 p。它们都是块元素，这意味着我们可以控制文本对齐。我们希望使用 adjust 指令来控制文本对齐。*

*![](img/27e87e4d3b2a02884d14f1085c335e69.png)*

*我们添加了另一个输入标签。我们将它的类型设置为无线电。*

*我们将其值设置为 left。我们将输入标签连接到 *align* 数据属性。*

*![](img/e64d3e3db2e9e3dc717c5a617d19f442.png)*

*我们制作了输入标签的另外两个副本。我们将它们的值设置为居中和向右。*

*![](img/bcc3472538f94e1d1c68b5b4010c433c.png)*

*在根组件的数据选项中，我们添加了 *align* 属性，并分别将其值设置为 left。*

*![](img/5f543b946c267b1020541b04380aea8d.png)*

*现在，我们可以通过单击三个单选按钮之一来重置 align 属性的值。*

*![](img/db2795ce2461b20e9296664e59659b38.png)*

*为了使用这三个按钮控制文本对齐，我们需要将 *align* 属性的值传递给 adjust 指令。*

*adjust 指令已经有一个值。它的当前值存储字体大小。它的当前值存储字体大小。要将对齐方向添加到指令值中，我们需要使用对象来设置指令值。这样，我们可以在指令值中存储两条信息。*

*就像我们之前说过的，Vue 指令可以在两个位置存储外部值:指令值和指令参数。*

*我们可以使用指令参数存储 align 属性的值。这样，我们可以保持当前的指令值不变。*

*![](img/4284aad91a79b15ac7f256c891cc8cc7.png)*

*在 directive 函数中，我们可以通过 binding.ARG 访问 *align* 属性的值。我们使用它来控制接收 adjust 指令的元素的文本对齐。*

*![](img/0034737dec339e624d06f1611796e324.png)*

*现在，我们可以使用三个单选按钮来控制文本对齐。*

*![](img/216d888b120afa59452599fce97c602f.png)**![](img/85efbdb8ba7e6da33def26a6658ffe92.png)*

*在您的实际项目中，如果您需要一起控制几个页面元素，那么自定义指令通常是最好的解决方案。*

*从这节课开始，我们将学习渲染函数。它使我们能够以编程方式生成页面元素。*

*![](img/01c0ffca81146f70f33f9b4721204001.png)*

*打开 Vue API 向下滚动，你会发现一个名为 H 的方法，H 方法就是我们用来生成页面元素的。*

*![](img/216d874051a4cdf8e91a859fdc5b6b2b.png)**![](img/2fd323259aa0ea66e226c1a27e2ca10b.png)*

*让我们以 chid 组件为例。我们删除它的模板选项。我们将使用 H 方法重新创建同一个模板。*

*![](img/90795c3b655505da710bff179b5203a3.png)*

*H 方法不能单独工作。它需要一个由渲染选项创建的外部环境。*

*使用工厂模式设置渲染选项。我们必须给渲染选项分配一个完整的功能。不要在这里使用箭头功能。我们需要它指向组件实例。*

*在 render 函数中，我们返回 H 方法。在 Vue 2 中，H 方法作为回调传递给了 render 函数。在 Vue 3 中，我们通过 Vue api 访问它。*

*![](img/ea3a486741ee856ddb0864544deefc50.png)*

*H 方法通常需要我们为它设置三个参数。第一个是我们想要创建的 HTML 标签的名称。*

*第二个参数是 options 对象。这里定义了新创建的 DIV 标签的属性。属性名用作属性名。我们希望 DIV 拥有*子* CSS 类，所以我们将属性名设置为*类*，属性值设置为*子*。*

*第三个参数通常是一个数组。我们在这里定义子元素。每个子元素都是一个 H 方法。*

*![](img/7891e06642065a9dc9ee1ff23cc49f67.png)*

*但是原始子组件模板没有根 DIV。子 DIV 和 H4 标签是兄弟。*

*![](img/05c7906ac97a247f0129a202df446a8a.png)*

*在这种情况下，我们不直接返回 H 方法。我们返回一个数组，并在其中设置两个 H 方法。第一个用于子 DIV，第二个用于 H4 标记。*

*![](img/ea2dcd437e45d1c6ad27d3ede3212dd8.png)*

*H2 标签没有属性。我们使用一个空对象来设置第二个参数。H2 标签的文本内容来自 title 属性。我们使用*这个点标题*设置第三个参数值。为了指向组件实例，我们需要使用完整的函数来定义呈现函数。我们不能使用箭头功能。*

*至于 H3 标签，我们用同样的方法设置它。*

*![](img/f11881a2d46cad97443106c5e84a24d4.png)*

*接下来，我们设置 H 4 标签。*

*H4 标签有内嵌的 CSS 代码。在 options 对象中，我们使用 *style* 作为属性名，并为其分配一个对象。我们在对象中定义 CSS 属性。以破折号为前缀的字母应该大写。*

*H4 标签的文本内容被包装在一个 *i* 标签中。我们使用另一个 H 方法设置第三个参数，该方法呈现一个 *i* 标签。*

*![](img/3454cba3ca6c053ca2b7c53437b9f0f0.png)*

*现在，我们已经使用 render 函数重新创建了子模板。让我们刷新页面。*

*我们可以看到结果和以前一样。*

*![](img/c849d554e7336cf492cd77ffd0dc3698.png)*

*让我们快速总结一下。*

*H 方法的语法非常简单。设置需要三个步骤。首先声明您想要创建的标签。然后设置一个选项对象来设置该标签的属性。最后，使用第三个参数来设置新创建的标记的内容。*

*接下来，让我们呈现根组件的模板。这里的事情有点挑战性。子组件安装在根组件中。如何渲染子组件标签？*

*![](img/4e7e4798a7fdd1599f151a66af75d680.png)*

*打开 Vue API 并向下滚动，您会发现四个名称以 resolve 开头的方法。resolveComponent 方法是我们需要的。*

*![](img/4c4d049c1a837b22e016b73e888be2b1.png)*

*我们转到根组件的 options 对象。我们添加了渲染选项。根组件的模板有一个根 DIV。所以我们直接返回 H 方法。我们在 H 方法中呈现父 DIV。*

*![](img/d381fb5170876fe8b01de4bc6ceb4bfb.png)*

*父 DIV 有四个子元素。我们需要一个有四个元素的数组。*

*前三个元素非常简单。他们只是 H 标签。我们甚至不需要设置任何属性。*

*![](img/d25a10c55a392ec8b9eaafbf1378af30.png)*

*最后一个元素是子组件标签，我们仍然使用 H 方法来呈现它。我们使用 resolveComponent 方法设置它的第一个参数。我们将子组件的名称传递给 resolveComponent 方法。现在，将呈现子组件标记。*

*子组件有一个道具。道具还是属性。我们将它们设置在 H 方法的第二个参数中。*

*![](img/0f9d8f9c2b4c8f6c8c8a36d19cf5c63e.png)*

*现在，render 函数已经重新创建了整个父 DIV。我们删除原始的父 DIV 并重新加载页面。我们可以看到结果和以前一样。*

*![](img/96bbab7b7d78a0e623237695b596d25f.png)*

*接下来，我们在呈现的组件标记中设置一个非属性。*

*![](img/f4e4b00845860cfb36e8c7517cd6a8b7.png)*

*子组件没有根 DIV。因此，不能自动继承非属性。*

*![](img/40c2a9b33a12297e6cb90f6543092089.png)*

*我们转到子组件的 options 对象，并关闭属性继承。*

*然后我们手动分配非 prop 属性。我们希望 H2 标签继承它。所有非道具属性都存储在*这个。$attributes* 。*

*现在，来自子组件的 H2 标签已经从呈现的子组件标签继承了标题属性。请记住，所有与属性相关的设置都是在 H 方法的第二个参数中完成的。*

*![](img/16d458a06ff51f01d7167a3b4e7f4c78.png)*

*在这一课中，我们将向您展示如何渲染插槽。在开始本课之前，请复习一下命名和限定作用域的插槽。*

*根模板有四个子元素。他们都是兄弟姐妹。让我们将 H2 和 H3 标签移到子组件标签中。*

*![](img/e8563ac702494beda322ad10ba9b9102.png)**![](img/33d30289e26a5cebb7f48e79bc2afb97.png)*

*在子组件的模板中，我们添加了一个槽来显示它的子元素。*

*![](img/cf442bf41f9b686d276c411e83d12a01.png)*

*那么我们如何渲染插槽呢？*

*我们找到了呈现子组件标签的 H 方法。*

*![](img/0aa8ae8f2c93b954738f394f35beab38.png)*

*我们向它传递一个数组作为它的第三个参数值。*

*![](img/ac3f72f60d880c6a811139f5bc10bff9.png)*

*我们将上面列出的两个 H 方法移到数组中。现在，H2 和 H3 标签嵌套在子组件标签中。*

*![](img/b6017ec36e581c6eb7e0af10d81464eb.png)*

*接下来，我们转到子组件的 render 函数。我们希望将插槽放在 H2 和 H3 标签之间。*

*在 H2 和 H3 标签之间，我们添加了一个新的 H 方法来呈现一个空的 DIV。这个 DIV 将用于容纳插槽。为了更好地跟踪它，我们给它一个标题。我们使用 *this 设置 DIV 内容。$slots* 。*

*这是我们渲染插槽的方式。与其他标签不同，我们不呈现 slot 标签本身，我们创建一个外部 DIV 并使用分配给 slot 的内容设置外部 DIV 的内部内容。*

*让我们测试这个程序。*

*我们可以看到该插槽已成功创建。根组件中的 H2 和 H3 标签现在显示在子组件中。它们嵌套在 slots DIV 中。*

*![](img/a16a992cef43f10338e9552a20169407.png)*

*我们正在使用的插槽没有名称，它被视为默认插槽。*这背后。$slots* ，我们可以附加默认的方法来标记它的身份。*

*![](img/04568665b2d0077c334cd1ccea4846fe.png)*

*在控制台桌上，有一个警告。它表示默认插槽遇到了非函数值。为了获得更好的性能，我们应该使用函数槽。*

*![](img/49b2577bfb8a4ef0e40d2400006c3000.png)*

*我们找到了呈现子组件的 H 方法。我们用一个对象替换数组。*

*![](img/67155e5e91e00c8ac88aa8776476bab9.png)*

*在对象中，我们添加了*默认的*方法。在默认方法中，我们返回原始数组。*

**默认*方法对应默认槽。它帮助 Vue 将内容映射到正确的位置。*

*![](img/6bd11a3b4a94daa99911502d15309ee3.png)*

*现在，警告消失了。呈现的 HTML 代码和以前一样。*

*![](img/5ad108201a2df0511a6ef822c9635c9d.png)*

*以默认方法呈现的元素将被发送到默认槽。我们用 H 方法替换返回的数组。我们呈现一个 H2 标签，并使用根组件的 title 属性设置其内部文本。*

*![](img/5400aeafd2c089e842b81f1e78400e9d.png)*

*在默认方法下面，我们添加了一个 author 方法。*

*作者方法对应于作者槽。我们呈现一个 H2 标签，并使用 author 属性设置其文本内容。*

*![](img/85f6bf453650f80eab7f7f377c954a71.png)*

*然后我们添加一个 book 方法。我们呈现一个 H3 标签，并使用 book 属性设置其文本内容。*

*![](img/c771902c50c158c4dba0852396e155be.png)*

*现在，我们给作者位置分配了一个 H2 标签，给图书位置分配了一个 H3 标签。*

*接下来，我们转到子组件来创建作者和书籍插槽。*

*我们制作了默认插槽的两个副本。*

*我们将第一个副本的方法名改为 author，将第二个副本的方法名改为 book。*

*![](img/c95ee68faa51cc17c0a848b840638bfd.png)*

*让我们检查程序。*

*我们可以看到两个命名的插槽已经成功渲染。他们收到了分配给他们的元素。*

*![](img/3eca84486ee2e3b6f47b75dc0f087940.png)*

*接下来，让我们试试作用域插槽。作用域插槽允许我们向后发送数据，这意味着我们可以将数据从子组件发送到属于父组件的插槽区域。*

*在子组件的数据选项中，我们有一个名为 realName 的属性。我们想把它发送到 author 槽，并显示在 author 属性后面。*

*当我们呈现 author 插槽时，我们将一个对象传递给 author 方法。在对象内部，我们添加了 realName 属性。我们使用*这个点 realName* 来设置它的值。*

*![](img/019060d82099aeb602669b80998ffb96.png)*

*接下来，我们转到根组件并找到 author 方法。我们传递给$ *slots.author 方法*的对象将被传递给 author 方法。因此，我们可以在 H 方法中访问 realName 属性。*

*![](img/23e275b2d00eb7543d93cd6fdd17e151.png)*

*让我们测试这个程序。*

*在作者名字后面，我们得到了真实姓名。我们现在在同一行显示一个根组件数据属性和一个子组件数据属性。*

*![](img/143dd2fa8095ff888b62549cce529876.png)*

*在这一课中，我们将向您展示如何呈现 Vue 的内置指令。*

*在数据选项中，我们定义了一个列表属性。它的值是一个数组。*

*使用 V FOR 指令，我们可以遍历数组并输出每个元素。*

*如果数组为空，V IF 和 V ELSE 指令将用 P 标记替换该列表。*

*![](img/9d415abee1cf34a57432c8cbb50e15cc.png)*

*让我们使用 render 函数重新创建这三个指令。*

*我们将渲染功能添加到选项对象中。*

*我们首先添加一个 IF 语句来检查数组长度。如果它不为空，我们将呈现一个列表。否则，我们渲染一个 P 标签。*

*我们将错误类分配给 P 标签，并将其文本内容设置为 *no item found* 。*

*![](img/25105b8b0fac85189356cdb6226859ee.png)*

*为了呈现列表，我们首先呈现 UL 标签。*

*我们使用 map 方法设置它的子元素。它遍历数组并对每个元素执行相同的操作。*

*在 map 方法的回调中，我们返回 H 方法并呈现一个 LI 标记。*

*每个 LI 标签都应该有 key 属性。我们使用元素索引设置键属性的值。*

*我们使用元素值设置 LI 标签的内部文本。*

*![](img/3b4197cdab75a20f6226393adb3d6867.png)*

*让我们测试这个程序。*

*我们可以看到一切都在按预期运行。*

*![](img/6cd8d2d6467e4cf051951790f557e70c.png)*

*使用 V model 指令，我们可以在输入框和数据属性之间创建双向连接。*

*![](img/459966f65483ee43a058dcfb6796d8eb.png)*

*在本课中，我们将向您展示如何呈现 v 模型指令。*

*根 DIV 中有两个元素:一个输入标签和一个 P 标签。*

*在 render 函数中，我们返回一个数组，并在其中设置两个 H 方法。*

*在第二个 H 方法中，我们呈现 P 标签。我们使用 message 属性设置它的内部文本。*

*![](img/ca6874784dd38285517080005db7ca72.png)*

*输入标签依赖于它的属性来工作。*

*我们首先使用消息属性设置它的值属性。*

*![](img/c3da2af9aa78c87c422f4e44ba99bcfb.png)*

*然后我们需要监控输入事件。我们使用 onInput 方法。*

*onInput 方法将接收*$事件*对象。*

*我们使用 *$event.target.value* 重置消息属性的值。*

*![](img/912b159255b35bab01123827282fc50b.png)*

*现在，我们已经手动呈现了输入标签。*

*它的工作原理和以前一样。*

*![](img/e82dc5d3cdf30b70c2346c78a996e4f3.png)*

*在本课中，我们将向您展示如何呈现安装在组件标记内的 v 模型指令。*

*我们有两个输入标签，一个在根组件中定义，另一个在子组件中定义。这两个输入标签总是同步的。*

*![](img/5dfcaaa746443e1ecdf80614d0ea63c2.png)*

*V model 指令实际上是一种语法糖。它将被扩展成一个 *v bind* 指令和一个 *v on* 指令。道具名为*模型值*，事件名为*更新:模型值*。*

*在子组件中，如果我们将属性*模型值*和事件*更新:模型值*，我们将能够在子组件标签中使用 *v 模型*指令。*

*![](img/42626c31fe27a3250355415fe9eba1cf.png)*

*让我们首先呈现根组件的模板。我们有三个要素。我们用三个 H 方法返回一个数组。*

*![](img/55b61a8ec97991fb9266ee5244981a45.png)*

*在第一个 H 方法中，我们呈现一个输入标签。在 options 对象中，我们使用 *this.message* 设置 value 属性。然后我们添加 *onInput* 方法。我们将 *$events.target.value* 分配给*这个点消息*。现在，根组件的输入标记已经完成。*

*![](img/30033ce05e6b9667c5bd939ec62b0404.png)*

*在第二个 H 方法中，我们呈现一个 HR 标签。*

*在第三个 H 方法中，我们调用 resolveComponent 方法来呈现子组件标记。道具被视为属性。所以我们在选项对象中设置它们。我们使用*模型值*作为属性名，并将 *this.message* 分配给它。*

*接下来，我们监视自定义事件。*

*对于默认的输入事件，我们使用 onInput 方法来监视它。对于自定义事件，我们使用相同的策略。*

*事件名称为*更新:模型值*。我们在的前面加上*，并用引号将全名括起来。更新的第一个字母应该大写。**

*自定义事件由 emit 方法发出。emit 方法还将向自定义事件发送一个值。该值将作为第一个参数值传递给 onUpdate 方法。我们将它的第一个参数命名为 *$event* 。*

*在回调中，我们将 *$event* 分配给 *this.message* 。与我们对本地事件所做的不同，我们不需要在 *$event* 后面附加 *target.value.**

*$ *事件*本身就是传递给自定义事件的值。*

*现在，根组件完成了。我们已经重新渲染了它的模板。*

*![](img/4ab33e72d4de250c285c56d9d6c7c940.png)*

*让我们测试这个程序。*

*我们可以看到两个输入标签仍然是同步的。*

*![](img/2b239a938264ed10447570b485936a2b.png)*

*接下来，我们呈现子组件的模板。*

*![](img/ee515cceb7e4197bedded8c432ed72ed.png)*

*我们只需要呈现一个输入标签。*

*在 options 对象中，我们首先将 prop 值分配给 input 标记的 value 属性。*

*然后我们添加 onInput 方法来监控本地输入事件。*

*我们称之为发射方法。自定义事件名称必须是*更新:模型值*。*

*我们使用 *$event.target.value* 设置第二个参数值。我们通过输入标签提交的文本存储在这里。*

*![](img/7e43d0bfa4d3fcb92036ed38777aff97.png)*

*现在，子组件完成了。*

*让我们测试这个程序。*

*我们可以看到它和以前一样工作。这两个输入标签是同步的。*

*![](img/54e4bec653112f285231ca35c72d6144.png)*

*如果你不明白这个程序是如何工作的，那就复习一下我们上一课的内容，我们解释了 v model 指令是如何在组件标签中工作的。*

*在本课中，我们将向您展示如何渲染动态组件。*

*![](img/58905a42ec1c75df9f2b7b0a63083804.png)*

*打开 Vue api 并向下滚动，您会发现一个名为 resolveDynamicComponent 的方法。这种方法正是我们所需要的。*

*![](img/2186d3afb13ebb906a22e1883daeea66.png)*

*我们转到根组件的渲染函数。*

*目前，它呈现三个子元素。第二个和第三个 H 方法呈现两个子组件。我们删除最后一个 H 方法。*

*![](img/9fdc0760c520730d8a71a3856c2e9c73.png)*

*然后，我们将剩余的 resolveComponent 方法更改为 resolveDynamicComponent 方法。*

*通过更改传递给 resolveDynamicComponent 方法的名称，我们可以呈现不同的子组件。*

*![](img/87d7d0b5d1e914bee87bcc712232cf9f.png)**![](img/442642b117f4a85f55e5afbc133507c8.png)*

*在数据选项中，我们定义了一个新的属性:componentName。我们将其值设置为 childOne，这是第一个子组件的名称。*

*然后我们将新的数据属性传递给 resolveDynamicComponent 方法。*

*![](img/ecdc014cbbe714869ec3dea36d63220c.png)*

*接下来，我们渲染两个按钮。*

*![](img/4c97da461b58f182d929cff199d90644.png)*

*在 options 对象中，我们添加了 onClick 方法来监视本机 Click 事件。我们使用两个按钮重置 componentName 属性的值。*

*![](img/ab6394075c34c19ebe82842fc8dcf523.png)*

*现在，我们可以通过单击这两个按钮来切换组件。*

*在本课中，我们将学习如何向呈现的元素添加自定义指令。我们不提供指令。我们仍然需要使用 directive 方法来定义它们。*

*![](img/f17ce854ccf68d3db36f8838f8b8301a.png)*

*假设我们想要将测试指令添加到呈现的 H1 标签中。*

*![](img/191e736622893d36e928fd7483ed3fa9.png)*

*打开 Vue API，向下滚动找到这些解决方法。*

*我们需要的是解决问题的方法。*

*![](img/48a74adfec98d07633cbc3771da578d3.png)*

*仅有这种方法是不够的，我们还需要 withDirectives 方法。*

*![](img/2cb76e8d75e93d8da0d12df908f15376.png)*

*我们首先将 H 方法作为第一个参数值传递给 withDirectives 方法。*

*我们使用数组设置第二个参数值。*

*在数组内部，我们添加了一个子数组。一个子数组在自定义指令上设置，通常有三个元素。第一个是 resolveDirective 方法。我们将指令名传递给它。第二个是我们希望测试指令拥有的参数值。第三个是参数名。*

*![](img/39d4ebd9b11e4236313740d617bd360c.png)*

*通过添加更多的子数组，可以呈现更多的指令。*

*让我们测试这个程序。*

*我们可以看到测试指令已经被添加到 H1 标签中。它还接收了参数值。*

*参数值来自 info 属性，如果我们修改 info 属性，我们将触发测试指令的更新钩子。*

*![](img/5322e949c4daf0db81fcea234b35280e.png)*

*打开应用程序实例，我们将找到一个配置属性。它有一个名为 globalProperties 的属性。目前，它的值是一个空对象。*

*![](img/bedefac4c508df3780c92aa21046f50e.png)*

*所有组件都可以访问添加到该对象中的属性。它们将被添加到所有组件实例的根级别中。*

*我们添加一个 info 属性，并使用一个字符串设置它的值。*

*![](img/e17fdf569476135db8c62ca02492192a.png)*

*让我们运行程序。*

*我们首先检查根组件实例。*

*我们可以看到它已经接收了 info 属性。注意，info 属性不是一个数据属性。*

*![](img/3afc2524dea819eec139b91942a7dcf6.png)*

*接下来，让我们检查子组件实例。*

*这里的情况是一样的。子组件实例已收到 info 属性，但 info 属性不是数据属性。*

*![](img/bd429a038cdb5bcc3221ce8b0cfc3393.png)*

*接下来，我们在两个组件的模板中显示 info 属性。*

*![](img/1b8606b2c3173ce1188f09ac0d5414fa.png)*

*我们可以通过 vm.info 访问 info 属性。*

*让我们给它赋值。*

*值分配已成功，但模板未更改。*

*![](img/a525b0beb8c0c99aeb9e12aeb50f58a4.png)*

*让我们试试子组件。*

*事情和以前一样。我们可以重置 info 属性的值，但模板不会更新。*

*![](img/0d032f55a64c6ca82cf627480a70f6ce.png)*

*模板不会自动更新的原因是因为 *info* 属性的值只是一个普通的字符串。它不是被动的。我们在数据选项中设置的属性被 Vue 自动激活。*

*info 属性不是数据属性。它不会自动反应。我们需要手动激活它。那么如何做到这一点呢？*

*打开 Vue API。*

*向下滚动，你会发现一个名为 *ref* 的方法。意思是参考。我们用它来使像字符串或数字这样的原始值具有反应性。*

*![](img/8359d79194a4319971fe13c47cc5a012.png)*

*上面列出的*无功*方法用于使参考型值无功。*

*![](img/1f7d8c397c0d57d0e793161bf6b05cce.png)*

*先试试 *ref* 方法。*

*我们向它传递一个字符串。*

*它返回给我们一个引用对象。value 属性存储我们传递给 ref 方法的值。*

*![](img/611fb08c5b055b5d706cb103986fb02f.png)*

*reactive 方法仅适用于引用类型的值，如 objects 或 array。不要向它传递原始值。*

*![](img/ebf4c755e94969dd764690985fd483c6.png)*

*reactive 方法通过为引用类型的值创建一个代理对象来使引用类型的值具有反应性。*

*![](img/8b38d060131e3b0b934ad6ba94b823c2.png)*

*您可以将引用类型的值传递给 ref 方法。*

*您将获得与字符串相同的引用对象。但是这样做没有意义，因为对象的反应仍然是通过创建代理对象来实现的。value 属性存储一个代理对象，而不是传递给 ref 方法的原始对象。*

*![](img/4751b544e1091740cc7eb367be38c285.png)*

*总之，要使基元类型的值具有反应性，请使用 ref 方法。对于引用类型的值，请使用反应式方法。*

*我们使用 *ref* 方法重置 info 值。*

*![](img/680837221b8c228e20643e4a0459f1ec.png)*

*现在，info 属性的值是一个对象。在组件模板中，我们不能再直接显示 info 属性。我们需要给它加上*点值*。*

*让我们再运行一次程序。*

*![](img/5e3c264ffee198b25901d21ddd4bdcfc.png)*

*我们首先通过根组件实例重置 info 值。*

*两个组件模板都已更新。*

*![](img/36943e79c2478dc3961caf136363ed15.png)*

*让我们通过子组件来尝试一下。*

*结果是一样的。两个组件模板都已自动更新。*

*![](img/be314bbf00196fd44f5649ed26b89dff.png)*

*当你使用 ref 方法时，记住它返回一个对象。我们在组件模板中使用它的 value 属性。*

*![](img/b3114f27b3b3a15b6f5286872d119af9.png)*

*接下来，让我们尝试一个引用类型值。*

*我们创建一个对象，并将其传递给 reactive 方法。*

*![](img/c9a668ea3ccad0577006397b3c5846ee.png)*

*reactive 方法返回一个代理对象。代理对象的处理程序使原始对象具有反应性。这意味着由于代理对象，品牌和模型属性只是反应性的。*

*![](img/3ef0ca600b619e74b234d35b2f5a0ade.png)*

*因此，我们不能使用析构赋值来检索品牌或模型属性。为了保持反应性，必须通过代理对象访问品牌和型号值。一旦我们从代理对象中取出它们的值，它们将失去反应性，因为它们的值只是普通的字符串。*

*![](img/4adfea91ebe5a441337ea93149663f1a.png)*

*在上一课中，我们学习了如何手动创建反应。对于原始值，我们将它们传递给 V *ue.ref()* 方法。对于引用类型的值，我们将它们传递给 V *ue.reactive()* 方法。*

*![](img/67d883ec3d4dfbbb48ef6972ec03acc4.png)*

*在 Vue API 中，我们可以找到一个计算方法。它帮助我们创建计算属性。*

*![](img/6e3cbedebb2019422383aae4129f1b25.png)*

*我们创建一个新变量，并将其命名为 capMessage。我们将它构建在消息变量之上。我们返回大写的消息值。*

*![](img/c1179bfb048b31e3d20c74b39f8834c3.png)*

*我们使用 computed 方法设置 capMessage 值。我们传递一个对象给它。在对象内部，我们设置了一个 getter 和 setter 函数。*

*![](img/b192f3796d3076879af288bfa0c2034b.png)*

*在 getter 函数中，我们返回 *message.value* 并用 *toUpperCase* 方法附加它。在 setter 函数中，我们将新值赋给 message.value。*

*![](img/78f1e5085ef071f928ec6b1fe8ac3c0c.png)*

*让我们运行程序。*

*消息值是一个引用对象。原始消息值存储在 value 属性中。*

*capMessage 值也是一个引用对象。getter 返回的值也存储在 value 属性中。*

*capMessage 值是大写的消息值。*

*![](img/d3caa7677b868dccedc6d94f1d9141cd.png)*

*CapMessage 和 Message 同步。改变其中一个会影响另一个。*

*![](img/ca8f9b19b88bba0e6e601e1aeffddd13.png)*

*让我们将消息值转换成一个字符串。*

*然后在 capMessage getter 和 setter 中，我们直接操作消息变量。*

*![](img/9e585b2df44e34e57000a5eb557b71a9.png)*

*让我们再试一次这个程序。*

*CapMessage 仍然可以访问消息值。*

*![](img/07ab5fdb669a5926e0c8df8f4e034bc6.png)*

*如果我们重置消息值，capMessage 不会受到影响。*

*![](img/12ebe6eb55f41fde9eabf554d0eb2215.png)*

*capMessage 的设置者仍然可以影响消息值。*

*![](img/501a00e03dcc2d57fdf616b879fdee4c.png)*

*总之，计算属性应该建立在反应属性之上。*

*接下来，我们创建另一个变量:carAge。在这里，我们只需要吸气剂。我们可以直接将回调传递给 computed 方法。这个回调函数将被用作 getter 函数。*

*我们通过从当前年份中减去 year 属性来计算车龄。我们可以通过创建一个日期对象，然后调用 getFullYear 方法来获取当前年份。*

*![](img/306dcd84df5d44e5027fbbf1519076a7.png)*

*让我们运行文件。*

*我们可以看到卡拉格是一个。*

*![](img/cbde49c4d31cafe491e8b54d432ef41d.png)*

*汽车对象是反应性的，如果我们改变它的 year 属性的值，那么 carAge 值也会相应地改变。*

*我们可以汽车时代现在已经成为 22。*

*![](img/a6bfa26c069199df092af91e856331b7.png)*

*在本课中，我们将了解 Vue 提供的其他反应方法。*

*Vue 为我们提供了三种测试方法:isProxy、isReactive 和 isReadOnly。他们的名字已经告诉你他们做什么。*

*为了节省时间，我创建了一个结合了三种测试方法的测试函数。它告诉我们测试的值是代理值、反应值还是只读值。*

*![](img/547a30fca1375f243bcc33b9095a209d.png)*

*我这里有一个对象字面量。它只有一个属性:标题。*

*我们首先让它反应。我们将它传递给 reactive 方法，并将返回的结果存储在名为 reactive 的变量中。*

*![](img/06ad60779da22cc044041f374aba4a7b.png)*

*然后我们调用 readOnly 方法，并将原始对象文字传递给它。readOnly 方法返回传递给它的对象的只读副本。*

*![](img/5a07217a5cb6bfc8b5f6bc86d34d2d1e.png)*

*如果我们向 readOnly 方法传递一个 reactive 对象，那么返回的对象将同时是 readOnly 和 reactive。*

*![](img/fc8b397a19fda8dab3bfe13841241b76.png)*

*反应变量是一个代理对象。处理者让它变得被动。*

*![](img/6a66345efffa63cc81a04691a272e1c8.png)*

*readOnly 变量也是一个代理对象。它的处理程序截获所有写操作，因此使它成为只读的。我们可以输出它的属性。但是我们不能给它的任何属性赋值。*

*![](img/e5f37aea536ed3281f6783ee3ea5a50b.png)*

*ReadOnlyReactive 仍然是一个代理对象。但是它有一个额外的代理层。外层使其只读，内层使其反应。*

*![](img/2c31e6427e5f1d2021caa632b9ce3ad5.png)*

*接下来，我们将这三个变量传递给测试函数。*

*isProxy 方法在所有三次执行中都返回 true。*

*![](img/c931464fb9e3ec473013c0d2090077ce.png)*

*isReactive 方法仅对 Reactive 方法创建的值返回 true。*

*![](img/ef7711e1dcefdac06cb6a1dec34bf6bd.png)*

*同样，isReadOnly 方法仅对 ReadOnly 方法创建的值返回 true。*

*![](img/b6684f90b7a4ba072ec29f10e6372143.png)*

*使用 toRaw 方法，我们可以将所有类型的代理值转换回对象文字。*

*![](img/350f77777de0b139e2c15c01ea02c569.png)*

*如果需要保护一个对象文本，可以将它传递给 markRaw 方法。*

*这样，reactive 和 readOnly 方法将无法为它创建代理。*

*markRaw 方法返回原始的对象文本，并在其中添加了一个额外的属性。额外的属性被命名为 _ *V_skip* 。其值为真。此属性供内部使用。*

*![](img/90e913c1a6d90a286353c004b678043f.png)*

*将 *markRaw* 对象传递给测试函数将在所有三个帐户上返回 false。*

*![](img/c2d0b659827362419e6a3ea28303e217.png)*

*接下来，我们禁用 markRaw 方法。在原始对象文本中，我们添加了一个嵌套对象。*

*![](img/a502866645328f0027d308b219056b84.png)*

*反应式方法可以处理嵌套对象。*

*我们可以看到嵌套对象仍然是一个代理对象，仍然是反应性的。*

*![](img/fb47d996fc444cb14e877ad3ab168db0.png)*

*readOnly 方法也可以处理嵌套对象。*

*![](img/5fc372670569b0ff72f98fb7f588c74c.png)*

*禁止向嵌套对象分配新的属性值。*

*![](img/5fc372670569b0ff72f98fb7f588c74c.png)*

*结论是 reactive 和 readOnly 方法都可以处理嵌套对象。这也是开发 shallowReactive 和 shallowReadOnly 方法的原因。*

*![](img/f84159920a402098ff849f4c7857951a.png)*

*这两种方法只对根级别的属性有效。嵌套对象不会受到影响。*

*浅层反应对象本身就是反应性的。但是嵌套在其中的对象不是。*

*同样，浅只读对象本身也是只读的。嵌套在其中的对象不是。*

*![](img/75a59d624399e19373e2638cf670996d.png)*

*我们可以通过一个浅只读对象来重置嵌套对象的属性值。*

*![](img/c195cbdf6ea381f83bae88d71c32d9e3.png)*

*在本课中，我们将了解 Vue 提供的其他 ref 方法。*

*![](img/e3448ca8d2ff1724494dcdc65d2fed74.png)*

*首先，我们创建一个字符串。*

*然后，我们使用 Vue.ref()方法使其具有反应性。*

*ref 方法返回给我们一个引用对象。value 属性存储原始字符串值。*

*![](img/5348c08d2e6ed57a897cfc650397c3e1.png)*

*使用 *isRef* 方法，我们可以检查一个对象是否是引用对象。*

*![](img/e6ac3280b6d194dbb9aa399cd7db152a.png)*

*参考对象不是反应对象。将其传递给 isReactive 方法将返回 false。*

*![](img/ecbaab8f1e41211b6513acbe5b2f79be.png)*

*为了去除参考物体的反应性，我们使用 unRef 方法。它将引用对象变回其原始值。*

*![](img/8d16639e5b007a66c25bbd4f25bc0174.png)*

*接下来，我们创建一个反应对象。*

*![](img/121700cd3c896fd89afedf557c12e261.png)*

*有时，我们需要将一个属性从一个反应对象转换成一个参考对象。这样，属性本身就是反应性的。它不必依赖代理对象来保持其反应性。*

*toRef 方法一次进行一次转换。我们向它传递两个参数。第一个参数是反应对象。第二个是目标属性的名称。*

*我们会得到一个参照物。原始属性值仍存储在 value 属性中。*

*![](img/e17e2e82ed8baf30d687612a9c2efa8a.png)*

*这个引用对象与 ref 方法返回的对象略有不同。但是将传递给 isRef 方法仍然会返回 true。*

*![](img/cfa3bdaaf36009b08b9aa211111ed924.png)*

*使用 toRefs 方法，我们可以将每个对象属性转换成一个引用对象。这里要注意，必须将一个 reactive 对象传递给 toRefs 方法。你不能像普通对象一样传递它。*

*返回值是一个普通对象，但是每个属性值都是一个引用对象。*

*![](img/de0c2ea6e61b4b4d817a44cc639c1747.png)**![](img/a8402979a4ef7406d97e12e7b3621e79.png)*

*你可能想知道这样做有什么意义。传递给 toRefs 方法的对象已经是反应性的了，为什么还要让它再次反应呢？*

*reactive 方法返回一个代理对象。反应由代理对象的处理程序启用。属性值只是普通的值。他们不是被动的。*

*如果我们在代理对象上使用析构赋值，我们将只检索它的属性值。这些值不是反应性的。*

*toRefs 将每个属性值转换成一个引用对象，并以普通的对象文本形式返回它们。*

*返回对象的每个属性都是独立的，这意味着它们的反应性是由它们自己实现的。它们不依赖代理对象的反应。*

*这使我们能够使用析构赋值来检索我们需要的属性。检索到的属性仍然是反应性的。*

*![](img/f0184d874c15ccf6227ce1dfd421c98c.png)*

*toRefs 方法只接受一个反应值。然而，shallowRef 方法没有这样的要求。*

*我们传递一个普通的对象给它。*

*shallowRef 方法返回一个引用对象。value 属性存储原始对象。未创建代理对象。这是 shallowRef 和 Ref 方法之间最重要的区别。*

*![](img/a953fcbe1a38a53ee8334d007b5fefa8.png)*

*如果我们将一个对象传递给 ref 方法，value 属性将是一个代理对象。*

*![](img/d6ec4b016e470b388620747546109d33.png)**![](img/1686948335bf2626e61e7f9b591eaae4.png)**![](img/648294c4665c02a1589a9e69adf01d19.png)*

*让我们试试 Vue 组件中的 shallowRef 方法。*

*我们将被动方法转换为浅层方法。*

*![](img/aa5c8e06ddd4bea472cc116c8ae9c364.png)*

*汽车属性的值将成为一个引用对象。*

*![](img/f75d4614dae616290ad5ce4eb7b3a4bd.png)*

*在组件模板中，我们需要给它附加*点值*。*

*让我们刷新页面。*

*我们可以看到品牌和车型价值都得到了成功的展示。*

*![](img/01ccc967132d8fbc425eeddd9278abec.png)*

**Car.value* 只是一个普通的物体。更改其品牌或型号值不会导致组件模板更新。*

*![](img/ccade6b12cf4439e3493a2ae83e77bb9.png)*

*为了启用反应性，我们需要为 value 属性分配一个全新的对象。*

*![](img/ef8b6f2f3700fe964aaed0205096bbbb.png)*

*如果你需要监控对象交换，这意味着你不只是修改属性，而是切换整个对象，那么 *shallowRef* 方法是你最好的选择。*

*但是大多数时候，我们只需要监控一个对象的属性，在这种情况下，*反应式*方法总是最好的选择。*

*计算值不是独立的。它们建立在其他反应值的基础上。一个计算值基本上是另一个反应值的附属值。它所做的只是将一个 getter 和 setter 应用于该反应值。*

*customRef 方法允许将自定义的 getter 和 setter 设置为独立的值。*

*![](img/45aa3ec75865375c5456f02a4a7de408.png)*

*通常，我们需要创建一个构造函数来存放 customRef 方法。*

*这里，我们将构造函数命名为 carAge，并使用它根据汽车的制造年份来计算汽车的年龄。我们将生产年份传递给 carAge 函数，并期望它为我们计算车龄。*

*![](img/abe7c47853ba56ae4d1b9c6c645a7885.png)*

*在 carAge 函数中，我们首先创建当前年份。我们创建一个新的 date 对象并调用 getFullYear 方法。然后我们返回 customRef 方法。*

*![](img/e580913dbdffa916e8c946d20a4ac872.png)*

*customRef 方法接收回调。回调接收两个函数:跟踪和触发。跟踪先于触发。不要弄错顺序。*

*![](img/4df8680ebef91785613fd7123990e23f.png)*

*在回调中，我们返回一个对象，并在其中设置一个 getter 和 setter。*

*![](img/68a5cf404a13c8904610820c70e7edc0.png)*

*在 getter 中，在我们返回任何东西之前，记得先调用 track 函数。track 函数确保我们返回最新的状态。*

*我们返回车龄，它是通过从当前年份中减去制造年份来计算的。*

*现在，吸气剂完成了。*

*![](img/da260cfc7340c9c3fa807170ad68c3dc.png)*

*在 setter 中，我们将新值赋给 year 参数。*

*然后我们调用触发函数。*

*现在，自定义 ref 方法已经设置好了。*

*![](img/6044d8717b91aa869c0c3c4cb6022121.png)*

*我们在 getter 的开头调用 track 函数，在 setter 的结尾调用 trigger 方法。*

*![](img/3263a8b28f5009101f65fa01d6b500b7.png)*

*接下来，我们创建一个名为 myCar 的变量，并使用 carAge 函数设置它的值。我将 2010 传递给 carAge 函数。*

*我们得到了一个自定义参考对象。它与 ref 方法返回的值略有不同。但它仍然是一个参照物。*

*value 属性存储 11。一辆 2010 年造的车，现在 11 岁了。*

*![](img/ce76ea4f62f5d97f32fbf7300cdb6269.png)*

*接下来，我们将 1991 分配给我的汽车点值。*

*value 属性的值现在是 30。*

*![](img/4311d601234f58c0f11e1ed9ae6cc6b1.png)*

*myCar.value 返回 30。*

*将 myCar 传递给 isRef 方法会返回 true。*

*![](img/ac77297b5c3ca134b42f8623006b1ede.png)**![](img/38b9698cc7d4c8a2b9125604b961f775.png)*

*在上一课中，我们学习了如何创建自定义引用对象。自定义引用对象最常见的应用是创建去抖程序。*

*在这一课中，我们将向您展示什么是去抖程序，以及如何只用 JavaScript 创建一个去抖程序。如果你已经熟悉去抖程序，你可以跳过这一课。*

*简单地说，去抖程序是我们用来避免用户滥用的。如果用户在短时间内发出大量请求，就没有必要回答所有这些请求。我们在给定的时间内只回答一个请求。其他请求将被忽略。*

*我们有一个 H1 标签和一个按钮标签。*

*我们有一个 H1 标签和一个按钮标签。*

*clickNumber 变量帮助我们记录点击按钮的次数。*

*![](img/78b003e874a2635b8b5582222517739d.png)*

*接下来，我们使用 H1 和按钮标签创建一个计数器应用程序。*

*我们声明一个新变量，并将其命名为 counter。我们将其值设置为零。我们使用计数器变量设置 H1 标签的内部文本。然后，我们向按钮标签添加另一个 eventListener。*

*当点击按钮时，我们将计数器值加 1，并使用新的计数器值重置 H1 标签的内部文本。*

*现在，柜台 app 完成了。我们每点击一次按钮，计数器的值就增加一。*

*![](img/5bfec9945c2b937d9c8477bedfa016cd.png)*

*在我们的现实项目中，我们必须非常小心用户操作。高频操作应该受到限制。让我们在计数器程序中添加一个去抖动功能。我们从 addEventListener 方法中移除回调。*

*![](img/c77bc7ff37629777a5687994df62f8ea.png)*

*我们定义了一个新函数，并将其命名为去抖。我们向它传递两个参数:数量和延迟。*

*![](img/a36611752f1ae86736664bb5a70a5c3b.png)*

*在去抖函数中，我们首先声明一个局部变量。我们将其命名为 stop，并将其值设置为 null。然后我们返回一个子函数。*

*![](img/1be0fdcd3e1e0265170407afdb0b6c8a.png)*

*在子函数内部，我们调用 clearTimeOut 函数并向其传递 stop 变量。*

*![](img/5a58ee5c336b4e2a747f8f8317bf5060.png)*

*然后，我们使用 setTimeOut 函数重置停止值。clearTimeOut 函数必须放在 setTimeOut 函数之前。*

*![](img/1f1ceee9a0d9fd88f258522eabea7fc7.png)*

*函数的作用是:设置一个定时器并返回一个定时器 ID。clearTimeOut 函数根据定时器的 ID 取消定时器。如果我们传递 null 给它，它不会有任何反应。*

*我们向 setTimeOut 函数传递一个回调。我们使用传递给去抖函数的第二个参数来设置延迟时间。在回调中，我们将计数器值加 1，并使用新的计数器变量重置 H1 标签的 innerText。*

*![](img/6df15ce8b8959b2ba6e211b897037608.png)*

*现在，去抖功能完成了。我们可以看到这是一个典型的闭包程序。去抖功能是外部功能。stop 变量是在返回的子函数的父作用域中定义的。*

*我们将去抖功能传递给 addEventListener 方法，并在那里调用它。*

*我们使用计数器变量作为第一个参数值。我们将第二个参数值设置为 1000。*

*![](img/42a8ad90f275c869490c48bdb96c884d.png)*

*由去抖函数返回的子函数被绑定到 click 事件。当我们点击按钮时，它就会被触发。*

*![](img/b7b29759757ccae187ac0ef31d0981ed.png)*

*stop 变量是在去抖函数的作用域中定义的，它将被返回的子函数的执行所共享。*

*![](img/80cd33eb4c679ff29e1181170a376c75.png)*

*无论我们执行多少次返回的子函数，都只会有一个 stop 变量。每次子函数触发时，它会取消之前的计时器，并使用自己的计时器 ID 重置 *stop* 变量的值。*

*如果我们一直点击按钮，子函数的当前执行总是取消其前任设置的定时器。只有最后一个 setTimeOut 函数才能完成它的执行*

*让我们测试这个程序。*

*我们点击一次按钮，然后等待。*

*![](img/34605d1563e2452486b53a05271cc2df.png)*

*H1 标签在我们点击按钮一秒钟后更新。*

*![](img/f2c64783560a590201616dae17ff9cdc.png)*

*如果我们一直点击按钮，H1 标签不会更新。在我们停止点击按钮一秒钟后，更新才会开始。最重要的是，数值只涨一。*

*![](img/2e1d1b2364c5f33d83e02eb43c8f621d.png)**![](img/2e1d1b2364c5f33d83e02eb43c8f621d.png)*

*去抖程序本质上是一个关闭程序。关键是要确保只有一个停止变量，并且返回的子函数的所有执行都使用同一个停止变量。*

*在去抖功能中，我们控制 log outer。然后在返回的子函数中，我们控制台日志内部。*

*![](img/5b9f7e7112ce0774bdf24ec2485c56ae.png)*

*让我们刷新页面。*

*我们在桌案上找到了。*

*![](img/8d0ca603f1a1090ff504dbd6fbd004bb.png)*

*然后我们点击按钮。*

*每次我们点击按钮，我们将得到控制台表内。*

*这证明了当我们第一次加载程序时，去抖功能只执行一次。每次我们点击按钮，返回的子函数都会被执行。单击该按钮不会再次触发去抖功能。*

*![](img/432ba35eb2a25db77cb88a87fadd46ad.png)*

*在上一课中，我们学习了如何只用 JavaScript 创建一个去抖程序。在本课中，我们将在 Vue 组件中创建一个去抖程序。*

*我已经使用 Vue 重新创建了计数器应用程序。数字是一种数据属性。它显示在组件模板中。它的初始值为零。*

*在 button 标记中，我添加了 v on 指令来监控 click 事件。当点击按钮时，将触发两个方法。*

*addOne 方法将数值加 1。record 方法记录我们点击按钮的次数。*

*![](img/b02767910d46905d09f96dc781874d26.png)*

*我们直接将上节课创建的去抖函数移植到 addOne 方法中。让我们看看它是否能工作。*

*在 addOne 方法中，我们声明了一个局部变量。我们将其命名为 *stop* ，并将其值设置为 null。*

*然后我们返回一个箭头函数。不要在这里返回完整的函数。这在一个完整的函数中指向窗口对象，而不是 Vue 实例对象。*

*在返回的 arrow 函数中，我们调用 clearTimeOut 函数，并将 stop 变量传递给它。*

*我们将 setTimeOut 函数赋给 stop 变量。*

*我们将延迟设置为 1000 毫秒。*

*在 setTimeOut 函数的回调中，我们将 number 变量的值加 1。*

*在 v on 指令中，我们给 addOne 方法添加了一对额外的括号。*

*![](img/def32d5c1440f22a8b89495c5931952c.png)*

*让我们测试这个程序。*

*我们可以看到这个程序根本不起作用。每单击一次，数值就增加一。*

*![](img/9edd5322b23dae06c497c5789459acb9.png)*

*让我们找出原因。我们添加了三个控制台日志语句来跟踪 addOne 方法的执行过程。*

*在 addOne 方法的根级别，我们控制台日志*外部*。*

*在返回箭头功能中，我们控制台日志*内部*。*

*在传递给 setTimeOut 函数的回调中，我们将控制台日志*的编号*加 1。*

*![](img/f88b0da3eb26fc1c7974aa0766295930.png)*

*让我们再运行一次程序。*

*我们可以看到，每次我们点击按钮，我们将触发一个新的 addOne 方法，因此创建一个新的停止变量。这就是去抖程序不起作用的原因。*

*![](img/230756807c7afa0ebcba231c49a719cf.png)*

*为了解决这个问题，我们必须将计时器 ID 存储在一个唯一的位置。addOne 方法的子函数必须能够访问那个地方。*

*知道这是哪里吗？*

*根组件实例是惟一的，并且总是可以被 addOne 方法访问。*

*我们在数据选项中定义了一个 stop 属性，并将其值设置为 null。然后，我们将 setTimeOut 函数分配给 stop 属性。我们将 stop 属性传递给 clearTimeOut 函数。*

*![](img/5d7bd65f28273e08af06c5503edfa53a.png)*

*没有必要保留子功能。也不再需要 stop 变量。*

*![](img/ff0f77f8cbd5ed5a8a554d21ace30468.png)*

*在按钮标签中，我们从 addOne 方法中删除了第二对括号。*

*![](img/91aa3b1930aa0735bb1963953d32f24b.png)*

*让我们试试这个程序。*

*我们可以看到，去抖程序按预期工作。根组件实例扮演外部函数的角色。addOne 方法的所有执行都共享 stop 属性。*

*![](img/dae31eb71a49ae8a162b849b2b5ce570.png)*

*在上一课中，我们在 Vue 中创建了一个去抖程序。关键是*停止*属性。根组件扮演外部函数的角色。setTimeOut 和 clearTimeOut 函数都访问同一个 *stop* 属性。这就是去抖程序能够工作的原因。*

*在本课中，我们将通过使用 customRef 方法创建属性来重新创建去抖程序。*

*我们清空 addOne 方法。然后，我们从数据选项中删除停止和编号属性。*

*![](img/ba49a0de5efa7c241b14ed1eabec4ad7.png)*

*我们将使用 customRef 方法重新创建 number 属性。number 属性将是一个引用对象。我们需要操作它的值属性。在组件模板中，我们用点值附录编号。*

*![](img/a84110cf452aa583b390dbbfa5cb3dec.png)*

*在 addOne 方法中，我们有两个选项来设置 number 属性的值。*

*我们可以在数字点值上加 1，然后将总和赋回数字点值。*

*或者，我们可以只给数字点值分配 1。我们在 setter 中计算总和。*

*![](img/8be4788789701a5697bcf55d7bb9d9b3.png)*

*接下来，我们为 number 属性定义一个构造函数。我们将该函数命名为 customNumber。我们向它传递两个参数:数量和延迟。*

*在 customNumber 函数中，我们首先声明一个局部变量。我们将其命名为 stop，并将其值设置为 null。然后我们返回 customRef 方法。*

*![](img/6600337ad111b279e1bcf72829579186.png)*

*我们将一个函数传递给 customRef 方法。这个函数接收两个函数:跟踪和触发。*

*我们在其中返回一个对象。在返回的对象中，我们定义了一个 getter 和一个 setter。*

*![](img/f92752ca9ffcf7c937e8b9a47a7869c5.png)*

*在 getter 中，我们首先运行 track 方法，然后返回 number 参数。getter 不会对数字值进行任何更改。它只是返回传递给 customNum 函数的第一个参数。*

*![](img/8cd6f19fb338b205da26d8a0003ac468.png)*

*在 setter 函数中，我们首先调用 clearTimeOut 函数。我们把 stop 变量传递给它。*

*我们使用 setTimeOut 函数重置停止值。*

*setter 函数的参数值取决于 addOne 方法。*

*如果 addOne 方法已经计算了总和并将总和分配给 number.value，那么 setter 将接收总和。我们只需要将总和分配给*号*。*

*如果 addOne 方法只给 number.value 赋值一个，那么 setter 就会收到一个。我们需要计算总和，并将其分配给*号*。*

*最后，我们调用触发函数。*

*![](img/42f7d7aba099f7e71b172d74e0cf8aa3.png)*

*现在，customNumber 函数完成了。*

*我们通过*app dot config dot global properties*将 number 属性添加到组件实例中。*

*我们使用 customNumber 函数创建数字值。我们将其初始值设置为零，延迟设置为 1000 毫秒。*

*![](img/d551aaa5eedf8eca564b5dee62cc24fd.png)*

*让我们测试这个程序。*

*我们可以看到它像预期的那样工作。*

*![](img/bcc23314018fa215140b08e7abc512ec.png)*

*接下来，我们用第二种方式设置 addOne 方法。我们只给数字点值分配 1。*

*在 setter 函数中，我们需要计算总和并将总和赋给*号*。*

*![](img/0f0f42318e6db2478a4c30572b52378f.png)*

*让我们运行程序。*

*我们可以看到结果和以前一样。*

*![](img/c476e51d70bf56dda1fb19f145263fd8.png)*

*如果我们给 number.value 赋值一个，那么就会给 setter 函数发送一个。setter 函数需要计算太阳并重置数值。*

*![](img/e68a80c3dd234d6ec516a084ef9be05a.png)*

*让我们删除 stop 变量和 clearTimeOut 函数。*

*![](img/48df11ea5e7e933c83886de4ed2469d9.png)*

*让我们再次运行程序，看看会发生什么。*

*因为 clearTimeOut 函数已被删除。所以没有计时器会被取消。每次点击都会有效，只有一秒钟的延迟。*

*![](img/f00963afc0f6f5a05be01816838b78fa.png)*

*接下来，我们重置 addOne 方法。我们在里面计算总数。*

*在 setter 函数中，我们只需要将新值赋给*号*。*

*![](img/b061d1acfe1ddb53407f569195302154.png)*

*这会造成什么样的不同？*

*我只按了一次按钮。*

*数值保持不变一秒钟，然后变成一。*

*![](img/13d806b7137a9df70ce3f5017bb3c775.png)*

*然后我不停地按按钮。*

*数值每秒增加一。我不需要停止单击来改变数值。*

*![](img/3fa3630896133507bec2f3df6410e047.png)*

*我点击按钮 53 次，数值从 0 到 10。最重要的是，我不需要停下来换号码。*

*![](img/a9a7ce2a3a3ef21ecacc7a178328a067.png)*

*基本上，我把去抖程序转换成了节流程序。知道这是怎么发生的吗？*

*我们来追溯一下 setter 的执行过程。我们控制台记录它的参数值。*

*我一直在按按钮。注意 setter 函数的参数值。*

*addOne 方法执行两个操作:检索数字值并重置它。新数值基于旧数值。*

*number getter 会立即返回数值。但是数字设置器以一秒钟的延迟更新数字值。*

*![](img/39b19e86eb9d66dee2d0d8c9b5a32cd7.png)*

*我们以第一秒为例。*

*在第一秒，无论我们触发 addOne 方法多少次，由 number getter 返回的 number 值将总是零，但是 setter 直到第一秒结束才工作。因此，将使用零加一来计算新数字。这就是为什么在前五次点击中，setter 总是接收一个新值。作为一个额外的副作用，无论我们多么频繁地触发 addOne 方法，每秒钟，数字值最多只能增加 1。*

*![](img/7937b1e096a719264fcdb6fd079de5fc.png)*

*使用 props 和自定义事件，我们只能在一个组件和它的子组件之间交换数据。*

*![](img/4bb90bfda12b60b8ddb9efc9347a8612.png)*

*如果我们需要将数据发送得更远一点，从一个组件发送到它的孙组件，该怎么办？例如，message 是根组件的数据属性。我们希望在孙组件中显示它。*

*我们可以使用 provide 和 inject，而不是要求子组件传递消息值。*

*![](img/35c01c71f3d43995aa51efe7c1b7e463.png)*

*父组件是提供方。它将数据发送出去。它的子组件或孙组件是注入端。他们接收数据。*

*![](img/1eb4e1ac0908696d9b3f1e1dad53a20f.png)*

*无论嵌套有多深，所有子组件都可以平等地访问父组件提供的数据。*

**提供*和*注入*的挑战是保持反应性。稍后我们将向您展示详细信息。*

*在根组件中，我们添加了一个提供选项。我们使用一个对象来设置它的值。*

*此对象中定义的属性将提供给子组件。*

*我们定义了一个名为 info 的属性，并使用一个字符串来设置它的值。*

*![](img/61038fbae1a795831afd8cd1309c08d1.png)*

*在孙组件中，我们添加了注入选项。它的值是一个数组。我们将 info 列为数组元素。*

*![](img/ee7fc0c678e5a7444fc7959dfc7e9451.png)*

*让我们检查孙组件的实例对象。*

*我们可以看到它的实例对象已经接收了 info 属性。注意，info 属性不是一个数据属性。*

*![](img/f1a61a132b36143397d68f915fc83cd4.png)*

*我们在孙组件的模板中显示 info 属性。*

*现在，根组件提供的 info 属性已经被注入到孙组件中，并显示在它的模板中。*

*![](img/39561b08d1e2e7e343ab56e84bfcf71b.png)*

*让我们通过孙组件重置 info 值。模板未更新。这意味着默认情况下，innjected 属性是不可反应的。*

*![](img/e293e1f8c7020092faa8883844bce0e2.png)*

*info 值是一个字符串，为了使它具有反应性，我们需要将字符串传递给 Vue.ref()方法。*

*info 值现在是一个引用对象。在组件模板中，我们需要在附录*信息*中添加点值。*

*![](img/b89103c604d6e4473eb162a7912b8c7f.png)*

*让我们重新载入程序。*

*我们通过孙组件输出 info 属性。我们可以看到它的值是一个参照物。*

*![](img/4ee17f4cb2beeca91c76bbed750180c8.png)*

*我们赋予它新的价值。*

*我们可以看到孙组件的模板已经自动更新。*

*![](img/c622fd4884d33d0a2911326eb4545849.png)*

*接下来，我们也将 info 属性注入到子组件中。*

*![](img/6db98bd30af649566f91a2bebaac4aaf.png)*

*如果我们通过子组件修改 info 值，孙组件也将被更新。*

*![](img/6b9038a5e451a95d589b5e3a0f187c34.png)*

*同样，如果我们通过孙组件重置 info 值，子组件也将被更新。*

*![](img/0564ec96afbb0b0bd7ddce03ea167675.png)*

*要使提供的属性具有反应性，我们需要使用 Vue.ref()或 Vue.reactive()方法。但是如果我们想提供一个数据属性呢？例如，我们希望提供消息属性。如何访问它？*

*![](img/ff6d210c318980b87bda80df73f300d8.png)*

*为了从数据选项中访问属性，我们需要使用函数语法重置*提供*选项的值。*

*我们在 provide 函数中返回一个对象。在返回的对象中，我们设置了 info 属性。我们可以通过这个访问数据属性。*

*![](img/7d59631ffcbde8c22ad562660d62e8b3.png)*

*让我们测试这个程序。*

*我们输出子组件实例。它已收到 info 属性。info 值与 message 值相同。*

*![](img/fb858f561e144bf7337b26a514323d9d.png)*

*请注意，info 值是使用 message 值设置的。仅此而已。他们之间没有进一步的联系。如果我们重置消息值，信息值不会受到影响。同样，如果我们重置 info 值，消息值也不会受到影响。*

*![](img/e61947ead8c36470537630e81abd9000.png)*

*如果我们需要将消息和信息链接在一起。*

*在这种情况下，我们使用 Vue.computed()方法设置 info 值。*

*我们将 getter 函数传递给 computed 方法。*

*在 getter 函数中，我们返回 this.message*

*![](img/211b6dff03e5db7ceb4a502dd1e569a4.png)*

*我们给消息分配一个新值。*

*我们可以看到 info 值也被更新了。*

*![](img/2f1234fee6ba28eed9a3fa1f1a6511d0.png)*

*info 属性只有一个 getter 函数。这使它成为只读的。我们不能赋予它任何东西。*

*![](img/794b3f68c40a928768a366ea6657619c.png)*

*接下来，我们重置 info 值。这一次，我们添加了 bot 的 getter 和 setter 函数。*

*![](img/d53102d696ac2e16c63108076af913e9.png)*

*现在，info 属性和 message 属性将始终保持同步。*

*更改消息值也会更改信息值。*

*![](img/c083d4c2dce270e9e1dde885a7c49201.png)*

*更改信息值也会更改消息值。*

*![](img/8a0bb2105128f04090b382d014ec27d1.png)*

*我们有三个变量:城市、列表和汽车。都是反应性的。*

*![](img/9e95caecaf5276666eef5f05478755c0.png)*

*城市值是一个引用对象。它由 Vue ref 方法创建。Vue ref 方法使诸如字符串和数字之类的原始值具有反应性。*

*为了访问原始值，我们使用 ref 对象的 value 属性。*

*![](img/8fda0a93c41746cc71aa0993fbdadb0d.png)*

*list 的值是一个代理对象。汽车的价值也是如此。*

*![](img/b88d905a11a01c315a0d7a4cff2be6d9.png)*

*这两个代理对象也称为反应对象。它们是通过 Vue 反应方法创建的。Vue reactive 方法使引用类型的值(如数组和对象)具有反应性。*

*经常需要观察反应值。在组件实例中，我们可以使用 watch 选项或$watch 方法来观察反应值。*

*Vue API 还为我们提供了两个选项。它们是观察方法和观察效果方法。这两种方法用于处理不同的情况。*

*![](img/8598efdd11de960043a59dfab0099c3d.png)*

*我们将从观看方法开始。*

*Vue 手表方法和我们之前学的$手表方法很像。*

*如果你知道如何使用$watch 方法，那么你可以相当快地学会 Vue watch 方法。但是这两种方法还是有一些区别的。*

*我们从 Vue api 调用 watch 方法。*

*![](img/0664ab1b0f7aae51206291b714604025.png)*

*语法与美元符号监视方法相同。我们仍然提出三个论点。第一个指定了观察源。这里，我们使用城市变量来设置它。我们将城市变量传递给 watch 方法。不要用引号将变量名括起来。*

*第二个参数是处理函数。它接收两个参数:新值和以前的值。最后一个是配置对象。有三个配置属性:立即、深度和刷新。我们将 immediate 设置为 true，将 deep 设置为 false。这里不需要 flush 属性。*

*Vue watch 方法返回一个停止函数。我们使用一个名为 stop 的变量来接收它。*

*现在，我们建立了一个 Vue 观看方法。它监视城市变量。让我们试一试。*

*![](img/b43b653e7dfef212aa909a3ccb6d0cfe.png)*

*我们刷新页面。*

*我们得到了未定义和伦敦。*

*![](img/5daca9adf3862bb4db95264383442d6b.png)*

*注意这里，city 的值是一个 ref 对象。城市名称存储在 value 属性中。*

*虽然 ref 对象被设置为观察源，但是 Vue watch 方法实际上监视的是 ref 对象的 value 属性。它自动打开 ref 对象并将 value 属性传递给它的处理函数。这就是为什么我们得到了伦敦而不是 ref 对象。*

*![](img/edbf97216b7b5ab26f246e2d96831928.png)*

*要触发 Vue watch 方法，应该为 ref 对象的 value 属性分配一个新的城市名称。不要重置城市变量本身。*

*我们将达拉斯分配给城市点值。*

*我们可以看到 watch 方法已经被触发。它输出伦敦达拉斯。*

*![](img/4a885d3b8b0978a3ca2c2fabeecf43f7.png)*

*让我们看看如果给 city 变量分配一个新的 ref 对象会发生什么。*

*我们给 city 变量分配了一个新的 Vue ref 方法。我们设定了一个新的城市名称。*

*现在，city 变量存储了一个新的 ref 对象，这意味着它不再被第 18 行定义的 Vue watch 方法监视。*

*![](img/e5c99dda3ceb18fbf488f6affc93d385.png)*

*如果我们重置新的 ref 对象的 value 属性，那么第 18 行定义的 Vue watch 方法将不会被触发。*

*![](img/b7de0e770f83e58e623cd33becae0b2b.png)*

*在继续之前，我们先来对比一下 Vue 手表方法和之前学过的$手表方法。*

*![](img/b39f109c99cbd857b2e6e6d850e66498.png)*

*乍一看，这两种看表方法是一样的。它们都观察一个城市名称，当城市名称改变时，它们都被触发。*

*Vue watch 方法是独立使用的，不与任何组件实例关联。*

*传递给 Vue watch 方法的 city 变量只是一个原生 JS 变量，而不是 Vue 数据属性。*

*city 变量实际保存的是第 10 行的 vue ref 方法创建的 ref 对象的内存地址。*

*这个 ref 对象是 Vue watch 方法实际接收和监视的对象。城市变量只是一个信使。它所做的只是提供对第 10 行创建的 ref 对象的访问。*

*![](img/697759bb9595549242137f4c31db9b65.png)*

*$watch 方法不同。它的第一个参数值用引号括起来。它只是一个属性名。我们没有通过这个引用城市属性。$watch 方法实际上观察的是城市属性本身。为了触发$watch 方法，我们为 city 属性分配一个新值。*

*![](img/2bec97ffc6c6187a3f0b1690ad12ae3f.png)*

*接下来，让我们调用停止函数。*

*Vue watch 方法现已停止。重置城市点值将不再触发它。*

*![](img/093843826487a4951488aef4c1831b0c.png)*

*接下来，我们更改观察源。我们观察列表变量。*

*我们仍然将*深度*属性设置为 false。*

*![](img/35d23500fa257479551a2c8957cacd3a.png)*

*list 的值是一个代理对象，但它的行为与普通数组相同。*

*我们移除最后一个数组元素。观察器被触发了。*

*![](img/cd52984cdb0d9c09fceede08d4596082.png)*

*让我们重置第一个元素值。*

*观察器又被触发了。*

*![](img/356459c7c45c2e38219520f597022d5d.png)*

*如果我们使用美元符号监视方法，操作数组元素不会触发数组监视器，除非 deep 属性设置为 true。*

*如果我们将另一个数组赋给列表变量，watch 方法将不会响应，也不会再监视列表变量。Vue watch 方法和 list 变量之间的连接不再存在。watch 方法只监视第 12 行创建的反应对象。*

*![](img/31f8079bb496d05c3c312e3b0d0c1770.png)*

*接下来，让我们看看是否可以观看元素总量。*

*我们收到了警告。*

*vue watch 方法已被触发，但处理函数的两个参数都没有定义。这意味着监视源不可访问。*

*警告称，监视源只能是 getter 函数、ref 对象、reactive 对象或这些类型的数组。*

*![](img/73ea8581cb7d47e100a35cfee86a1d4a.png)*

*这个警告很有用。它清楚地告诉我们什么可以作为 vue watch 方法的第一个参数值。*

*接下来，我们来看汽车变量。*

*我们可以看到重置品牌价值已经触发了观察器，即使 deep 属性设置为 false。*

*出于同样的原因，如果我们给 car 变量分配一个新的对象，vue watch 方法将不会响应，并将停止监视 car 变量。*

*![](img/5b114eca863bd2a71663731d89709429.png)*

*如果我们试图观察汽车对象的属性，我们将得到与观察数组长度相同的结果。*

*![](img/22d59b80aded2dd2751ddbe59214a789.png)*

*Vue 观察方法仅观察参考对象和反应对象。要观察其他值，如元素总数或选定的对象属性，需要在 getter 中设置它们。*

*我们使用函数设置 watch 方法的第一个参数。我们首先返回列表变量。我们仍然将 deep 属性设置为 false。*

*![](img/c9d3c07a6dd83993a8b9867fe6548d06.png)*

*我们移除最后一个数组元素。*

*这一次，Vue 手表法没有回应。深层属性正在起作用。*

*如果我们给列表变量分配一个新数组，Vue watch 将不再监视列表变量。*

*![](img/457e7620a95fba1c8db50a6d2a4570e4.png)*

*我们将 deep 属性设置为 true。*

*![](img/70f58d8f3e1c15f1d4d0ef609ec9658d.png)*

*让我们试试这个程序。*

*这一次修改数组元素可以触发 Vue watch 方法。*

*![](img/c6a1ae11b6ad1eac56559e0c1755745f.png)*

*对于汽车对象，您将得到相同的结果。我将跳过这里的演示。*

*接下来，我们将深度属性切换回 false。*

*在 getter 函数中，我们使用 spread 操作符将代理对象转换回数组。*

*![](img/8869450da732707b6135828094ef3166.png)*

*这一次，Vue watch 方法监视列表数组。*

*移除和重置数组元素会触发观察器。*

*![](img/a46840d573ca57ccdb7567c3d5af8d02.png)*

*我们还可以观察一个特定的数组元素、元素总数和一个选定的对象属性。*

*![](img/b41a51bbf216d44cec8f0ac41cc2c910.png)*

*这里有一个问题要问你。如果我们在 getter 中返回城市变量会发生什么？不推荐。但你还是应该知道我们做的时候会发生什么。自己做实验。*

*在本课中，我们将尝试 watchEffect 方法。*

*![](img/e63d71984c9d5041768c7e7c6839b879.png)*

*首先，让我们看看 watchEffect 方法的基本语法。*

*watchEffect 方法有两个参数。第一个是回调函数。第二个是配置对象。*

*![](img/f3cfc3b3e668f2fbfebd780ad99194e4.png)*

*前面的 watch 方法有三个配置属性。让我们在这里也设置同样的三个属性。*

*![](img/9aec56cc17f3edb3a902444c615f695f.png)*

*让我们刷新页面。*

*我们收到了两个警告。这两个警告就是我想给你看的。*

*watchEffect 方法的 config 对象只接受 flush 属性。immediate 和 deep 属性在这里不适用。flush 属性的默认值仍然是 pre。*

*![](img/70e6dffbe2fb0fe0c11ad3f86dc04303.png)*

*就像 watch 方法一样，watchEffect 方法也返回一个 stop 函数。*

*![](img/6adc9d283025ed43c33a49ebf2478db5.png)*

*既然我们已经有了 watch 方法，为什么还需要另一个方法呢？*

*首先，watchEffect 方法不是用来比较 watch 源的以前值和当前值的。我们已经有了这项工作的观察方法。事实上，watchEffect 方法甚至不能访问观察源的前一个值。*

**watchEffect* 这个名字包含了两个字:手表和副作用。*

*观察意味着观察反应变量或属性的值变化。*

*副作用只是钩子函数的另一个名字。watch 方法的 handler 函数也可以看作是副作用。*

*watchEffect 方法允许我们设置两个而不是一个副作用函数。然而，这两个功能不会总是同时触发。*

*回调接收一个名为 onInvalidate 的函数。回调本身就是第二个副作用函数。onInvalidate 函数也接受回调。这个回调是第一个副作用函数。*

*![](img/118f92da2b93f0f6383faa8782c91380.png)*

*让我们重新加载文件。*

*我们可以看到只有第二个副作用功能被触发。*

*![](img/8aeff39a24420fa066ceb1c83276a2e9.png)*

*这也证明了 watchEffect 方法在我们第一次加载页面时触发。这就是它不需要立即属性的原因。它总是立即做出反应。*

*让我们调用停止函数。*

*这次只触发了第一个副作用功能。*

*![](img/31389c0ab3a18e565f52326758784e6e.png)*

*结论是当我们第一次加载程序时，只有第二个副作用函数触发。当我们停止 watchEffect 方法时，只有第一个副作用函数触发。*

*目前，watchEffect 方法没有观察任何东西。*

*对于 watch 方法，我们使用它的第一个参数来指定观察源。watchEffect 方法没有用于指定观察源的专用参数。我们只需要确保观察源出现在第二个副作用函数的范围内。这里注意，还得是第二个副作用函数。*

*例如，我们希望观察城市变量。我们声明一个变量，并将其命名为 target。然后我们将城市分配给目标。出于演示目的，我们控制台记录目标变量。*

*让我们试试这个程序。*

*只有第二个副作用功能被触发。*

*![](img/ca01e077279451ca3b21d550c5b15873.png)*

*我们重置城市点值。*

*什么都没发生。watchEffect 方法监视 ref 对象，而不是城市名。*

*![](img/63fa49bcfa73ad33fa5dfc6fbe5c4a9e.png)*

*城市网点值需要在第二个副作用函数中显示出来。*

*我们将城市名重置为达拉斯。*

*watchEffect 方法已被触发。这一次，两个副作用功能都被执行了。*

*![](img/b07eb0a0f78d2e63db8bc1da3a3c7120.png)*

*看看这两个副作用函数的执行顺序。*

*onInvalidate 方法是在最后定义的，但它是第一个被执行的方法。这就是为什么它是第一个副作用函数。*

*![](img/8062cc921439b7db909cbb4ccfe5e53b.png)*

*观察源必须出现在第二个副作用函数的范围内。让我们把它移到第一个副作用函数中，看看会发生什么。*

*我们重设了城市名。什么都没发生。watchEffect 方法没有响应。两个副作用功能都没有被触发。*

*![](img/781c2bc53fabd68c0b6dd7feb3ce2990.png)*

*所以请记住，手表源必须出现在第二个副作用函数中。对于 ref 对象，您需要指定它的 value 属性。*

*接下来，我们来看列表数组。列表数组已被转换为反应对象。我们不需要在它后面附加 value 属性。*

*我们移除最后一个数组元素。*

*watchEffect 方法没有响应。*

*![](img/abd8e5f608b0754b0939d9df78f303ab.png)*

*原因和之前一样。watchEffect 方法不监视列表数组。它监视列表数组的反应对象的内存地址。*

*修改 list 数组的数组元素不会改变内存地址，因此不会触发 watchEffect 方法。*

*我们需要使用 spread 操作符将反应对象转换回数组。*

*现在，watchEffect 方法监视数组体，修改数组元素会触发 watchEffect 方法。两个副作用功能都被触发。*

*![](img/c775d2463be848d1f2df699c80b295a0.png)*

*接下来，我们来看元素总和。*

*我们调用 pop 方法来删除最后一个元素。*

*watchEffect 方法已被触发。两种副作用功能都已执行。*

*![](img/3149c1724b642866dae7f4ddd55f3b22.png)*

*接下来，让我们看看是否可以观察一个特定的数组元素。我们还是选第一个。*

*我们重置第一个元素值。*

*watchEffect 方法已被触发。*

*![](img/53198c5f5b801ed635e801eaa66e5ce6.png)*

*接下来，我们监视汽车对象。*

*我们重置了品牌属性。watchEffect 方法没有响应。原因还是因为 watchEffect 方法只监控 car 对象的内存地址。*

*![](img/45ac13f1f811b13bc2122493c85f25ec.png)*

*我们需要指定目标属性。这里，我们选择品牌属性。属性值应该是原始值。*

*现在，重置 brand 属性会触发 watchEffect 方法。*

*![](img/44b82e5a2aec2d826f80caa7c6fa5588.png)*

*我们称之为停止函数。*

*第一个副作用函数被触发。第二个不会回应。*

*![](img/2d54b00c6a6b14583cb320c5178fd7f9.png)*

*flush 属性的工作方式与美元符号监视方法相同。默认值为 pre。另外两个值是 post 和 sync。*

*flush 属性控制是否在页面重新呈现之前、之后或同时触发 watchEffect 方法。我将跳过这里的演示。*

*现在，只需要记住 watchEffect 方法的语法以及它的两个副作用函数的行为。在接下来的课程中，我们将向您展示它的实际应用。*

*在本课中，我们将向您展示如何使用 axios 发出可取消的请求。我们将在后面的课程中将其与 watchEffect 结合使用。但首先，我们需要确保您知道如何创建可取消的 axios 请求。*

*我们将使用 openWeather API 作为数据源。*

*![](img/7ec329a4dfc29ea615c4f1126cea5322.png)*

*转到 openWeatherMap 并创建一个新帐户。*

*然后转到“我的 API 密钥”页面。*

*![](img/3fe1afe63181b2f41b24164c7557ed58.png)*

*您将获得一个默认的验证密钥。您也可以创建自己的密钥。新密钥通常需要几分钟才能生效。因此，在使用新密钥进行任何查询之前，您需要等待一段时间。*

*![](img/d3c4a007e9c24c822616ae9175784e2d.png)*

*我们复制验证密钥并将其粘贴到我们的程序中。*

*接下来，我们转到 API 页面。*

*![](img/9f4e7a63eabd18e45c41dee707e8b1be.png)*

*我们有很多选择。这里，我们选择第一个:当前天气数据。*

*![](img/51528efbdda7aeb670f542287a9210b1.png)*

*API 地址非常简单。我们只需提供一个城市名和验证密钥。*

*![](img/04f90814e7d29a13f18e65b0cf4edf46.png)*

*接下来，我们创建一个函数，并将其命名为 query。我们给它传递一个城市名。*

*此函数需要异步。*

*我们将 API 地址移到查询函数中。*

*我们从 API 地址中去掉了花括号。*

*![](img/9d134c94fefa736e5f89a7500245ceb7.png)*

*然后我们需要给地址加上前缀 *https 冒号双斜杠*。*

*![](img/1ea1b68133a94715d1567b120fb82ee4.png)*

*现在，API 地址完成了。它从函数参数中获取城市名，从全局范围中获取验证密钥。*

*接下来，我们添加 TRY CATCH 语句。*

*在 TRY 部分，我们“等待”axios get 方法返回查询结果。我们需要这个查询是可取消的。除了 API 地址，我们还需要设置一个配置对象。我们稍后将处理配置对象。我们控制台记录查询结果。*

*在 THEN 部分，我们输出错误消息。*

*![](img/963eec8074160dc81703a19e4c513da9.png)*

*让我们运行函数。我们把伦敦交给它。*

*openWeather API 返回给我们一个对象。在数据属性中，我们可以找到伦敦的天气信息。*

*天气属性值是一个数组。第一个元素讲述被查询城市的天气描述。*

*![](img/73f520f1241dbc7438bd82f7b9ca2d31.png)*

*在下面的课程中，我们将只显示 description 属性。*

*![](img/ce756aa52077b73bafd55a8c6fc1c982.png)*

*接下来，让我们使 axios get 方法可取消。*

*在 config 对象中，我们设置了 cancelToken 属性。*

*![](img/ef2dae3ed601eb5a713ec8081c198e7c.png)*

*然后在查询函数之外，我们创建一个新变量:source。我们使用 source 方法设置它的值。源方法来自 cancelToken 属性。*

*现在，我们已经得到了源对象。我们在 get 方法中注册它，这样源对象和 get 方法就连接起来了。*

*我们使用源点标记设置 cancelToken 属性。*

*![](img/12a7af64b953dcd03c4471cfa8ef5350.png)*

*现在，我们可以从源对象中使用 cancel 方法取消 get 方法。我们可以向 cancel 方法传递一个通知 tex。当我们取消 get 方法时，此通知将用作错误消息。*

*![](img/2b030f39e7220c656461fc28dd38d443.png)*

*让我们试试这个程序。*

*我们可以看到查询已被取消。错误消息是我们在 cancel 方法中设置的通知。*

*![](img/1a38327116a3fd72ea2b851e9507f52a.png)*

*接下来，我们添加另一个查询方法。*

*我们进行了两次查询，但只取消了一次。让我们运行程序。*

*我们可以看到两个查询都被取消了。*

*![](img/a0cc4eda7b4b04f3fa52b7e5208dc053.png)*

*让我们将 cancel 方法移到两个查询方法之间。*

*结果和之前一样。这两个查询都已被取消，尽管第二个查询发生在 cancel 方法之后。*

*![](img/4c9fabe7c18cf9d4406093b44d27331a.png)*

*源对象是独立的。它取消注册到它的每个查询。如果我们想单独取消查询，那么我们必须给每个查询一个专用的源对象。知道怎么做吗？*

*解决方案是工厂模式。*

*我们定义了一个 queryFactory 函数。*

*我们将源变量和查询函数都粘贴到其中。*

*然后我们在一个对象文本中返回它们。*

*![](img/339d264769296698c1b8a74e39e22f1b.png)*

*查询方法现在被“密封”在 queryFactory 函数中。要访问它，我们必须首先运行 query 函数。我们将得到一个对象，它不仅包含查询方法，还包含一个新的源对象。*

*每次运行 queryFactory 函数，都会得到一个新的源对象和一个新的查询方法。*

*我们运行 queryFactory 函数两次，并将返回的对象存储在变量 A 和 b 中。*

*现在，我们有两个源对象和两个查询方法。*

*![](img/e78f29d5f9292bce13f368da50d2ba69.png)*

*让我们使用实例 A 和 b 进行两个查询。*

*两次查询都成功了。*

*![](img/b70d26841776b772cea6b8b67c1fbd7e.png)*

*然后我们从实例 a 调用 cancel 方法。*

*让我们运行程序。*

*我们可以看到第一个查询被取消了，但是第二个查询成功了。*

*![](img/a2e9c2fdfc381cc30536b3fa8aaed702.png)*

*如果我们从实例 B 调用 cancel 方法，我们将得到相反的结果。*

*![](img/f79f53352afd9edf002f72f845b7d147.png)*

*在上一课中，我们使用工厂模式创建了一个可取消的查询函数。工厂函数保证每个查询方法都有自己的源对象。这允许我们单独取消查询。*

*在这节课中，我们将把它移植到一个 Vue 程序中。*

*在组件数据选项中，我们创建一个密钥属性，并将验证密钥存储在其中。*

*![](img/482ac631752099b289b7928304a5cc9f.png)*

*然后我们创建两个空属性:city 和 description。*

*我们在组件模板中显示这两个属性。*

*![](img/59d29b61919d8c75af4dd1132e5cd95d.png)*

*接下来，我们定义一个组件方法。我们将其命名为 query。我们给它传递一个城市名。查询方法需要是异步的。*

*我们将 API 地址复制到查询方法中。*

*我们需要用这个作为验证密钥的前缀。*

*![](img/93548e0c9729ebab1bea9dacf8d1dedf.png)*

*接下来，我们添加 TRY CATCH 语句。*

*在 TRY 部分，我们“等待”axios get 方法。然后，我们将检索到的数据存储到一个名为 result 的变量中。*

*我们将参数值赋给 city 属性，将检索到的天气描述赋给 description 属性。为了跟踪程序如何工作，我们还记录了城市和描述属性的控制台日志。在 CATCH 部分，我们在控制台记录错误消息。*

*![](img/5235c36cea782bd6a5f80b7770f3195d.png)*

*让我们检查一下查询方法。我们通过根组件实例运行它。我们把伦敦交给它。*

*我们可以看到它起作用了。*

*![](img/26c8920671393b6b5c59953a8b847020.png)*

*接下来，我们安装创建的钩子，并从那里触发查询方法。*

*现在，程序将自动使用 London 进行查询。*

*![](img/6c001a22d2528a74d588c5650e138ebf.png)*

*要更改为不同的城市，我们再次运行查询方法，并向其传递一个新的城市名称。*

*![](img/04e0858c741dd25d87670cff8e8b7c37.png)*

*接下来，让我们使查询方法可取消。*

*我们添加了一个新的数据属性:source。*

*我们在查询方法中设置源值。我们将源对象分配给它。*

*然后我们在 axios get 方法中注册源对象。*

*让我们检查程序。*

*我们可以看到源对象已经被创建并存储在 source 属性中。*

*![](img/4b86a9514338f4395e0d1d3b3aa91afa.png)*

*接下来，我们创建一个新的组件方法:cancel。*

*我们用它来取消 axios 查询。我们通过 source 属性调用 cancel 方法。*

*![](img/21f94bbb62409214d412cc9bbc13ecb8.png)*

*查询已经完成。让我们运行 cancel 方法。*

*我们变得模糊了。结论是取消一个已完成的查询会返回未定义的结果。*

*![](img/9995eb3921fc1eedbecbd3415873010e.png)*

*接下来，我们创建一个测试方法。我们在其中调用查询和取消方法。*

*我们可以看到查询已被成功取消。*

*![](img/179500bd97a207ebae65e47e7cd82726.png)*

*接下来，我们在测试方法中进行两个查询。*

*我们可以看到两个查询都成功了。*

*![](img/bb2a0ccfd94f080665164e4bee4af498.png)*

*然后我们在两个查询方法之间设置一个 cancel 方法。*

*![](img/d94bf7ff5a7e38f2c1ce7755c1df2937.png)*

*你认为我们会得到什么样的结果？是取消两个查询还是只取消第一个查询？*

*让我们找出答案。*

*我们可以看到第一个查询被取消了，但是第二个查询成功了。*

*![](img/ad43e82c59d14e0694dd5c1099a5b479.png)*

*每次运行查询方法时，我们都会创建一个新的源对象，并将其分配给 source 属性。然后，我们使用 source 属性注册源对象。*

*这意味着每次运行查询方法时，我们都用一个新的源对象更新源属性的值。这就是为什么 cancel 方法只取消在它之前执行的查询方法。组件实例扮演工厂功能的角色。*

*要取消第二个查询，我们需要调用它背后的 cancel 方法。*

*![](img/71d7ec6216dbbb3eb4e911f46e8feb33.png)*

*在上一课中，我们创建了一个可取消的查询方法。cancel 方法取消之前执行的查询方法，但不会影响后面的查询方法。*

*关键是在每次运行查询方法时，使用一个新的源对象来重置源属性的值。存储在 source 属性中的源对象总是指向在它之前执行的查询方法。*

*接下来，我们移除测试方法。*

*在组件模板中，我们添加了一个按钮标签。*

*我们添加了 v on 指令来监控点击事件。我们触发 change 方法，并将 *London* 传递给它。我们也给这个按钮一个 ref，这样我们就可以从 Vue 方法中访问它。*

*我们再复制三份按钮标签。我们设置了三个不同的城市和参考值。*

*![](img/e6b01f4572c7d63833f4f6c0a7bdfd64.png)*

*然后我们转到方法选项来定义*变更*方法。*

*改变的方法很简单。我们用它来改变城市财产的价值。*

*为了跟踪程序的执行过程，我们控制台记录了当前和新的城市名称。当前城市名称是城市属性的当前值。新的城市名称是传递给 *change* 方法的参数值。*

*然后，我们将参数值赋给 city 属性。更改城市名称是操作的开始。接收天气信息需要一段时间。所以我们将描述属性的值重置为*加载信息*。*

*![](img/007b0e4467d6ef897075c07d0ecbc56c.png)*

*现在，城市方法完成了。它所做的只是更改 city 和 description 属性的值。它不包含任何 axios 代码。*

*让我们检查程序。*

*我们有四个按钮。点击按钮更改城市名称，并将描述属性 a 的值设置为*加载信息*。*

*![](img/eb89666f609b6dbaa198e96bde035ceb.png)*

*我们已经在 *change* 方法中更新了城市属性。在查询方法中不需要再做一遍。我们删除第 35 行。*

*![](img/540950519095cd8de16bbb2f901d5c2f.png)*

*接下来，我们转到创建的钩子来安装 watchEffect 方法。传递给 watchEffect 方法的回调是第二个副作用函数。*

*![](img/c1dccf2e55028c789cdc6fa5f45201c9.png)*

*第二个副作用函数将在我们第一次加载程序时被触发。*

*![](img/3c9b7cdae3cacacc95038a8604824df9.png)*

*我们调用查询方法，并将这个点城市传递给它。*

*![](img/c41bef171af64ca1f179f647e8d5abd0.png)*

*现在，城市属性已经出现在第二个副作用函数的范围内。这使它有资格被 watchEffect 方法监控。*

*查询方法将在两种情况下被触发:当我们第一次加载程序时和当我们改变城市值时。*

*查询方法检索新城市的天气描述，并将其分配给 description 属性。*

*让我们运行程序。*

*我们刷新页面。*

*查询方法已被触发。我们还没有设置初始城市值，所以我们得到了一个错误消息。但这确实证明了查询方法会在我们第一次加载程序时被触发。*

*![](img/a99b2c37d1d8da87a3e0139de02abe60.png)*

*在创建钩子的开始，我们给 city 属性一个初始值。我们把它设定在伦敦。*

*让我们再试一次这个程序。*

*我们可以看到伦敦的天气信息已经被检索并显示在组件模板中。*

*![](img/95b0ecfc8396dcb77ef480a279a94ee2.png)*

*我们换到一个不同的城市。*

*城市名称会立即改变。*

*天气描述首先变成*装载信息*。*

*![](img/bec0a9a53e7ca332f9ce5f827af8a1b7.png)*

*然后，它成为检索的天气信息。*

*![](img/e2c780cc5208ea11ea67617e90bf3e89.png)*

*检索新城市的天气信息需要一段时间。如果我们在检索到当前城市的天气信息之前切换到一个新的城市，那么就不再需要完成当前的查询。我们只需要上一个城市的天气信息。那么如何取消一个中断的查询操作呢？*

*source 属性为可取消的 axios 查询奠定了基础。*

*![](img/bab25481c2b42146c0f08934e86ba6f8.png)*

*它存储当前查询操作的源对象。它的 *cancel* 方法使我们能够取消当前正在进行的查询操作。挑战在于何时调用 cancel 方法。*

*![](img/36703e7cf2f6519ea213694090c06f59.png)*

*我们回到观看效果方法。我们安装 onInvalidate 函数来设置第一个副作用函数。*

*第一个副作用函数在城市值改变时触发。最重要的是，它在我们在 watchEffect 方法中设置的所有东西之前触发，包括 query 方法。*

*我们在第一个副作用函数中运行 cancel 方法。*

*![](img/bd5337fc802e7f5fadb466560ba7e02f.png)*

*当城市值改变时，第一个副作用函数将首先触发，在查询方法之前。*

*如果前面的查询已经完成，cancel 方法只返回 false。其他都不会受到影响。查询方法仍将正常执行。*

*如果正在进行的查询尚未完成。它将被 cancel 方法取消。查询方法仍将按计划进行新的查询。*

*当我们取消正在进行的查询时，city 值已经发生了变化。因此，在通知文本中，我们无法访问正在进行的查询所使用的城市名称。在通知文本中，我们告诉用户当前城市之前的查询已被取消。*这个圆点城市*指向新的城市名称。*

*让我们测试这个程序。*

*首先，我们慢慢切换城市。在正在进行的查询结束之前，我们不会单击城市按钮。*

*该程序运行良好。每当我们切换到一个新的城市，它的天气信息可以成功检索。第二个副作用函数不影响程序的执行。*

*![](img/c80d1b2e30b8dcecfa08360e5c5b1310.png)*

*接下来，我们转到 methods 选项来定义一个新方法。我们把它命名为*种族*。*

*我们设置了一个 setTimeout 函数。我们选择第一个按钮，使用它的 ref 并调用 click 方法来触发它。*

*我们以同样的方式触发其他三个按钮。*

*点击两个相邻按钮之间的时间间隔只有 0.1 秒，这不足以完成查询。所以只有最后一个查询会成功。前三个查询都将被取消。*

*![](img/d087f65e4c5b4d249261cc3dec6123c6.png)*

*让我们试试这个程序。*

*我们称之为竞赛方法。*

*初始城市值是伦敦，巧合的是，比赛方法切换到的第一个城市也是伦敦。从伦敦换到伦敦不会触发 watchEffect 方法。因此，不会进行任何查询。*

*![](img/6a5f7e972f89500d926e6bed4ede076a.png)*

*总共进行了三次查询。最后只有最后一个成功了。之前对达勒姆和桑德兰的询问都被取消了。桑德兰是最后一个城市，它的天气信息终于恢复了。*

*![](img/7091094a6b587dd690461b8e4682dd49.png)*

*接下来，我们调整四个按钮的点击顺序。我们最后点击伦敦按钮。*

*![](img/4a0f401f3a4e70300dbf9f067d83b9c5.png)*

*让我们再试一次这个程序。*

*已经进行了四次查询，前三次都被取消了。最后，我们得到了伦敦的天气信息。*

*![](img/a65edae39e0639fd744e77c92e47ccd4.png)*

*在我们后面的课程中，我们将继续学习这个程序。让我们对它做一个简短的回顾。*

*![](img/e1259c7edb74250cd2937e7ac5d34230.png)*

**change* 方法由我们点击城市按钮触发。它重置城市值并将描述值更改为*装载信息*。它不直接触发查询方法。*

*查询方法在 watchEffect 方法中触发。每当城市属性的值发生变化时，它就会被触发。新的城市名称将被传递给查询方法。*

*查询方法使用新的城市名称查询后端 API，并将检索到的天气信息分配给 description 属性。*

*query 方法做的第一件事是创建一个新的 source 对象，并将其分配给 source 属性。*

*只有一个源属性。查询方法的所有执行都用新的源对象重置相同的源属性。换句话说，每次我们运行查询方法时，source 属性将被重置为一个新值。这里的根组件作为一个闭包，为查询方法的所有执行提供一个惟一的共享源属性。*

*这也意味着一旦新的查询方法被触发，它将重置源属性，这意味着源属性将失去与前一个查询的连接，因此无法取消它。*

*但是在城市名称的改变和查询方法的执行之间有一个时间差。watchEffect 方法的设计允许我们利用这个时间间隙。*

*watchEffect 方法有两个副作用函数。*

*第一个副作用函数总是在第二个副作用函数中定义的任何东西之前执行。这个设计至关重要。*

*我们在第一个副作用函数中取消查询，在第二个副作用函数中运行查询方法。*

*这意味着当第一个副作用函数触发时，城市名称已经更改，但查询方法尚未触发。源对象仍然指向正在进行的查询。这使我们能够取消正在进行的查询。*

*如果我们耐心地更改城市名，意味着我们只在当前查询结束后更改城市名，那么第一个副作用函数会取消已完成的查询。在上一课中，我们已经了解到取消一个已完成的查询只是返回 undefined。程序将继续执行。什么都不会受影响。*

*如果我们在当前查询结束前更改城市名称，第一个副作用函数将触发并取消当前查询。然后第二个副作用函数将触发并执行带有新城市名的查询方法。*

*不得不说 watchEffect 方法的设计堪称杰作。它使我们能够利用更改城市名和使用新的城市名进行新的查询之间的时间差。在这段时间间隔内，源对象仍然指向正在进行的查询。第一个副作用函数执行 cancel 方法并取消正在进行的查询。然后第二个副作用函数用新的城市名触发并运行查询方法。*

*Vue 3 引入了设置功能。它使我们能够将组件的可重复部分提取到可重用的代码片段中。这些可重用代码以函数的形式存储。这个函数可以被任何组件使用。它的功能范围帮助我们存储和保护数据。*

*![](img/98b086e81b1351e1511735caef3648cc.png)*

*设置功能通过设置选项添加到组件中。该选项是一个挂钩点，在解析所有属性之后、创建组件实例之前执行。在创建组件实例之前，记住设置函数触发器是非常重要的。*

*setUp 函数接收两个参数:props 和 context。这两个参数存储传递给组件的外部信息。稍后我们将向您展示详细信息。*

*![](img/60820aa95a32dcb4347435c89c952545.png)*

*让我们在一个真实的程序中试试 setUp 函数。*

*我们这里有一个非常简单的 Vue 程序。它只有一个组件:根组件。*

*我们安装安装选项并为其分配一个功能。*

*我们控制台记录*设置*并运行程序。*

*我们可以看到设置函数在 beforeCreate 钩子之前触发。这意味着设置功能在创建组件实例之前触发。*

*![](img/1709117c895a41b76c8dd0caf0ea9fa6.png)*

*因此，setUp 函数中的 THIS 不能指向组件实例，因为组件实例尚未创建。*

*我们可以看到它实际上指向了窗口对象。*

*![](img/96796bd4addb30f2171e0b99f8860b89.png)*

*当你设计你的设置函数时，你应该避免使用它。不要试图访问属于组件实例的属性或方法。*

*设置功能只是分配给设置选项的普通功能。它有自己的功能范围。我们可以在里面定义变量和函数。这些属性和功能仅在设置功能中可见，因此受到保护。*

*我们声明一个变量:city。我们把它的价值定在伦敦。*

*然后我们返回一个对象并把城市放入其中。返回对象的属性和方法将被添加到组件实例中。*

*![](img/36aad513cdc5a505ddd64d8e3a80054e.png)*

*让我们检查程序。*

*我们可以找到城市财产，它的价值是伦敦。*

*![](img/9d68eda6b91ef8da231f166bb14b6dd5.png)*

*这里注意，城市属性不是数据属性。它只是添加到组件实例根级别的一个属性。但是这足以使它在组件模板中可见。我们可以通过双嵌套的花括号来显示它。*

*![](img/1d7eccc9351743c2206e12be53fb0ca2.png)*

*城市财产不是被动的。当我们改变它的值时，模板不会更新。*

*![](img/ac69ee018b02921f881089ba94ca5404.png)*

*城市值是一个字符串。我们可以使用 Vue ref 方法使其反应。*

*现在，城市价值是无功的。ref 方法返回给我们一个引用对象。但是 Vue 为我们解开了那个物体。我们只是返回城市，并在模板中显示城市。不需要用*点值*附录城市。*

*我们可以看到伦敦仍在展出。让我们检查组件实例。城市值是*伦敦*，不是参照物。Vue 为我们提取了 value 属性。*

*![](img/44ea36fade87a64f4deb02cad84c2f0d.png)*

*我们给 vm 点城市分配一个新值。*

*我们可以看到模板已经自动更新。*

*![](img/67cd20874fdda981ad575aea6744a446.png)*

*接下来，我们创建了一个基于城市的计算属性。我们将其命名为 CapCity。*

*我们使用 *Vue dot computed* 方法设置它的值。我们向它传递一个对象，并设置一个 getter 和 setter。在 getter 中，我们返回 *city.value.toUpperCase()* 。这里我们需要 value 属性。city 属性的值是一个引用对象。这里就不拆开了。接下来，我们添加 setter。我们将新值分配给城市点值。不要忘记 value 属性。*

*然后我们把 capCity 加到返回的对象上。*

*![](img/00d6b223a6ea8b6596aa2948651ffd14.png)*

*在组件实例中，我们可以找到一个新的属性:capCity。它的值是大写的城市名。*

*![](img/525ed63c96af8744e3d0a8033374b4db.png)*

*它在组件模板中也是可见的。*

*![](img/3c2215fbde009c40956899c74b6bc623.png)*

*如果我们改变城市值，capCity 也会随之改变。*

*![](img/e3e3ee7ae452cc58430f587de8a52a87.png)*

*同样，如果我们给 capCity 分配一个新值，城市值也会改变。*

*![](img/e44468fb6b741d08fe2d79205ccf2b16.png)*

*我们添加了一个子组件。*

*![](img/570fea961d0533f491883858aebf32a2.png)*

*从设置函数返回的属性将被添加到组件实例中。如果我们想将属性发送给子组件甚至孙组件，我们可以*提供*它们。*

*我们从 Vue 调用 provide 方法。我们提出两个论点。第一个是属性名，第二个是属性值。*

*![](img/990eb44210422e40fdcdddfec9f237dd.png)*

*一个提供方法只能提供一个属性。如果要提供多个属性，需要设置多个提供方法。*

*提供的属性不会自动添加到当前组件实例中。我们仍然需要归还他们。*

*![](img/9ee83a266c7ff028464293f63923a0df.png)*

*现在，城市和国家已经被添加到根组件实例中，并提供给所有子组件。*

*在子组件中，我们添加了 *inject* 选项来注入两个提供的属性。*

*![](img/89db85754ab9e7d1c757647b6a22e9fe.png)*

*让我们运行程序。*

*我们检查子组件实例。我们可以看到它有城市和国家的属性。两个属性值都是引用对象。*

*![](img/38ec274975969d932d91ea57c3eef9f9.png)*

*我们不能在子组件模板中直接显示这两个属性。*

*![](img/0221d7e7eb21d67d881fb22d727c1ca3.png)*

*我们需要给它们加上*点值*。*

*![](img/015932a1a52c6beb198b9d466a02cb4f.png)*

*如果我们可以在 setUp 函数中提供属性，那么我们也可以在其中注入属性。*

*我们在子组件中添加了一个设置函数。*

*我们声明一个变量，并用它来接收 vue 点注入方法的返回值。一个注入方法只能注入一个属性。*

*然后我们返回一个对象，将城市和国家添加到子组件实例中。*

*![](img/649641deba4d7461bd846092f6c618a0.png)*

*让我们检查子组件实例。*

*我们可以看到这一次,《城市与国家》被展开了。在城市模板中，我们不再需要值附录。*

*![](img/65755c53c9fdd4b39754175dc1c6da2b.png)*

*城市和国家都是反应性的。如果我们从根组件端改变它们，子组件模板将自动更新。*

*![](img/cae9ecc67d7f983fccfa62764514ecc0.png)*

*在这一课中，我们将讨论在设置函数中定义函数。*

*我们创建了一个函数，并将其命名为 test。*

*我们控制台日志函数名和这个。*

*然后我们返回它，将它添加到组件实例中。*

*![](img/fa4c1908fa08d832528ea827af7f9f3b.png)*

*测试函数将被添加到根组件实例中，因此成为它的一个方法。*

*![](img/c8987667f89be1da8cd61392929e06c6.png)*

*这在函数中是由函数的位置决定的。如果我们通过根组件实例运行该函数，它将指向根组件。*

*![](img/5ea75e6b1fd0360f82ffd8a303c0b1ec.png)*

*因此，我们可以访问根组件的数据属性。我们可以看到测试函数已经成功地输出了标题属性。*

*![](img/b5b19fc86d4156623063b7b71b525ba7.png)*

*我们在组件模板中添加一个按钮。我们用它来触发测试功能。这次，*这个点标题*返回未定义。*

*![](img/e769b1162493b1f1b53645823e1c98c9.png)*

*这实际上指向了窗口对象。*

*![](img/a207b59dc881960a222e5818b3879dad.png)*

*如果我们通过根组件实例运行测试方法，它可以指向根组件。*

*![](img/1eb4f7664de42587fbafcd141a4ba97a.png)*

*设置功能不是预定义组件属性和方法的地方。我们已经有适合这项工作的 MixIn 了。*

*在 setUp 函数中定义的函数可以利用 setUp 函数的作用域。*

*我们在设置函数中声明了一个消息变量。我们不退货。这使得消息变量仅在设置函数内部可见。*

*![](img/b0fd2bc8548c003ab3b5de6edc4219be.png)*

*然而，测试函数可以访问消息变量。如果我们返回测试函数，那么我们可以通过根组件实例发送消息属性。*

*![](img/a8c0e49b4c29bbb4781e1a90485fea15.png)*

*我们可以看到，无论我们如何触发测试函数，我们总能获得消息值。*

*![](img/9b6e15cd0bf53367a93439b076b5ceb3.png)*

*你们中的一些人可能已经意识到我们刚刚创建了一个结束程序。设置函数扮演外部函数的角色，测试函数是返回的子函数。测试功能可以访问设置功能中定义的变量。测试函数本身将被加载到组件实例中。因此，组件实例可以访问 setUp 函数范围内定义的变量。*

*非常重要的一点是，你要明白设置函数不是用来预定义普通的 Vue 组件方法的。这是 mixins 的工作。*

*在这节课中，我们将讨论 setUp 函数的两个参数。*

*Props 是将数据从父组件发送到其子组件的最常用方法。我们首先在子组件中声明一个道具。*

*![](img/0f73c16110a60fcd4025d669f88280d7.png)*

*在根组件的 data 选项中，我们创建了一个新的属性:message。我们可以通过邮件属性将消息值发送到子组件中。我们找到子组件标签。我们添加了 *v bind* 指令来将消息属性分配给邮件属性。*

*![](img/4dd4225ab446b8e245fef046bed665a4.png)*

*现在，邮件道具有了它的价值。让我们在子组件模板中显示它。*

*如果我们打开子组件实例，我们可以找到名为$props 的属性。*

*属性值是双重嵌套的代理对象。它致力于管理道具。我们可以在里面找到邮件道具。*

*![](img/3dbfd8818b5ca9d11f260a2ede136839.png)*

*这个对象将作为它的第一个参数被传递给设置函数，从而使设置函数能够访问组件的属性。*

*我们转到子组件并添加设置功能。我们控制台记录了它的两个参数。*

*第一个参数让我们可以访问传递给子组件的所有属性。*

*![](img/a11d0c5607f508a08153a5f381811cb4.png)*

*在第二个参数中，我们可以找到 emit 方法。它使 setUp 函数能够发出一个自定义事件并向其传递一个属性。*

*![](img/05cfdd75c0aee82e12acf052925971fc.png)*

*让我们试试 emit 方法。*

*同样，我们要发送的属性不应该在组件实例中定义。它应该在设置函数中定义。*

*我们声明一个变量:city。我们把它的价值定在伦敦。*

*然后我们通过*上下文*调用 emit 方法。我们把这个事件称为接力赛。我们将城市变量作为第二个参数传递给 emit 方法。*

*![](img/6cd5f640d3b3eccca0f4d9c71eee8700.png)*

*然后我们转到根组件的数据选项。*

*我们设置了一个新的属性:位置。我们把它的初始值设为*未知。*然后我们在根组件的模板中显示位置属性。*

*![](img/6c4439ce081ed72865564670119d99b9.png)*

*在子组件标签中，我们添加了 *v on* 指令来监控中继事件，并将 *$event* 分配给位置属性。*

*我们可以看到伦敦已被发送到根组件。*

*![](img/1a68cb4afd70268b87bd64957ba282a8.png)*

*在这一课中，我们将看看上下文对象的另外两个属性:属性和槽。*

*![](img/76f706147b05a5eb53bd4a5dcc2672c1.png)*

*expose 方法供内部使用。我们不需要它。*

*我们将从属性开始。属性是我们添加到子组件标签中的非属性。*

*在子组件标记中，我们添加了 title 属性，并使用 info 属性设置其值。*

*![](img/00acef4ea7fce5b97ac7106261830272.png)*

*然后我们转到根组件的数据选项来定义 info 属性。我们将其值设置为 hello。*

*![](img/3979503cf845edeac958e91d7d9f23ce.png)*

*title 属性将被添加到子组件模板的根 DIV 中。*

*![](img/b216b22a73a2cd2e201fb3dc455884cb.png)*

*在上下文对象中，我们还可以找到关于标题属性的信息。*

*![](img/e141d0f45c58f33432c9a4af0005a7c6.png)*

*请注意，尽管 attributes 属性是一个代理对象，但它不是反应性的。未来对标题属性所做的更改将不会反映出来。我们给 info 属性分配一个新值。*

*![](img/5a11cd118b04d31198f10850cdf7ba29.png)*

*标题值已自动更新。*

*![](img/53c04866ff06a0bf1eb0ed31ca6838bc.png)*

*属性对象的标题属性保持不变。*

*![](img/a7dc5507e1726ed194914d6462200b0e.png)*

*只有道具对象是被动的。*

*![](img/b617e860e43c8aec3eb3a3a4ca456db2.png)*

*如果需要观察非道具属性，不要在设置功能中将观察者设置为*上下文，属性*永远不会改变。将观察器安装在子组件的一个生命周期挂钩中。*

*接下来，我们来试试吃角子老虎机。插槽属性也不是反应性的。*

*在子组件模板中，我们添加了两个命名的插槽。我们把它们分别命名为*城市*和*国家**

*![](img/2b009074a568a389afb50618658d8f82.png)*

*然后，在开始和结束子组件标记之间，我们将内容分配给两个命名的槽。*

*对于城市位置，我们设置了两个页面元素。*

*在国家插槽中，我们只放了一个页面元素。*

*![](img/181b859d783ef55c6cd8a3d530cf0726.png)*

*我们可以看到两个插槽工作正常。*

*![](img/1cc89a634c40b23880969ce3ab2bf4c6.png)*

*让我们检查上下文对象的 slots 属性。*

*我们有两个命名的槽，所以我们有两个以这两个槽命名的方法。*

*![](img/c281b7f89e9ddfdbaecd54da3e787d60.png)*

*如果我们调用两个 slot 方法，我们将得到由两个 slot 显示的内容的虚拟节点。同样，上下文点槽没有反应。*

*![](img/de14254dcee513d8de0cbdfe85993ea2.png)*

*在本课中，我们将使用闭包和工厂模式创建一个计数器应用程序。*

*![](img/88dff85add8c0cb60c48d4d34de32d9d.png)*

*首先，我们创建一个工厂函数，它也作为外部函数。我们称之为反工厂。在工厂函数内部，我们声明了一个变量:number。我们将其值设置为零。*

*![](img/563dd9091482caae6f4027a4f9b52ea8.png)*

*然后我们定义一个子函数:increment。increment 函数将 number 的值加 1，然后返回该值。*

*![](img/cd46061d0df1af7dc602fce62c5ee0cf.png)*

*最后，我们返回一个对象。*

*在返回的对象中，我们设置了一个数字属性，并使用数字变量设置其值。属性名和变量名相同。我们可以使用简写语法。*

*我们使用相同的简写语法将 increment 函数添加到返回的对象中。*

*![](img/95bfddb09814215b9848e675cee87e97.png)*

*工厂功能现在完成了。*

*我们用它创建一个对象。number 属性的初始值为零。*

*![](img/a45caf22955f4bde65716844ad6fd4e7.png)*

*让我们运行几次 increment 方法。*

*总之，我们执行了两次 increment 方法。第二次执行返回 2。但是 number 属性的值仍然为零。知道为什么吗？*

*![](img/308e326fdd2deda24cd30fe0e51868bb.png)*

*数字属性是**而不是**数字变量。number 属性的值是使用 number 变量的初始值设置的。除此之外，他们之间没有任何联系。对 number 变量的更改不会影响 number 属性。*

*如果我们使用一个对象来设置 number 变量的值，事情会完全不同。我们添加 value 属性，并给它赋零。*

*![](img/51975dd0c2aa554afa3dcdc57a8cef53.png)*

*对象是一个参考值。通过将 number 变量赋给 number 属性，我们实际上是将该对象的内存地址赋给了 number 属性。*

*因此，number 属性和 number 变量指向同一个对象。通过 number 变量对 value 属性所做的更改将由 number 属性反映出来。*

*在增量函数中，我们用点值附录数字。*

*increment 函数不再需要返回数字变量。*

*![](img/1f700c9eb95c9d305f28251a821dd154.png)*

*让我们检查程序。*

*我们运行增量法。然后我们输出计数器对象。我们可以看到 number 属性已经更新。它的值现在是 1。*

*![](img/daffcac9c00423c3907498474634da90.png)*

*我们再次运行增量。*

*数值现在是 2。*

*![](img/f9ca3765c614e2a6a1a729dc2a740365.png)*

*接下来，我们将计数器对象连接到页面元素。*

*我们选择 B 标签，并使用 number 属性设置其内部文本。我们需要给附录编号加上*点值*。*

*然后我们选择按钮标签并监听点击事件。*

*我们称之为增量法。*

*然后我们重置 B 标签的内部文本。*

*![](img/f2a3b936f59cbf35e2b96d0b8ae1a05c.png)*

*让我们试试这个程序。*

*我们可以看到，每点击一次按钮，旁边的数字就会增加一。*

*![](img/52988ac5c9c2570c8a86f4fb82f84a53.png)*

*关键是使用对象设置 number 变量的值。该对象使数字变量和数字属性保持同步。*

*![](img/4e85446a891b825efde76607d6bcf587.png)*

*我们得到了另一个计数器应用程序。这个应用程序是使用 Vue 创建的。*

*数字属性是一个数据属性，这意味着它是反应性的。增量为 number 属性的值加 1。*

*![](img/e99516484491694f1267baa353d6646f.png)*

*让我们在设置功能中重新创建这个计数器应用程序。*

*我们不再需要数字属性。也不需要 increment 方法。*

*![](img/b3be33c9b5a077c9cc4bbe9755f45acb.png)*

*我们增加了设置功能。*

*我们声明一个名为 number 的变量。我们需要数字是反应性的。所以我们使用 Vue 点引用方法来设置它的值。我们将零传递给 ref 方法。这一步至关重要。它使 number 变量的值成为一个参考值的对象。*

*![](img/e64c59bf791a379c4898edd57035f390.png)*

*然后我们创建一个子函数:increment。*

*我们给数字点值加 1。*

*![](img/5cc5096cf3768ed7ee13c4a10c1a179f.png)*

*然后我们返回一个对象，把数字和增量放在里面。*

*number 属性存储引用对象的内存地址，因此可以反映其属性的最新状态。*

*![](img/88a3c3749527d4e057199f6afae06049.png)*

*现在，柜台 App 完成了。*

*我们来测试一下。*

*我们可以看到它和以前一样工作。*

*数字变量的值是一个引用对象。number 属性和 number 变量指向同一引用对象。因此，通过 number 变量对引用对象所做的更改也可以通过 number 属性反映出来。*

*Vue 为我们解开了参照物。我们可以直接在模板中显示数字属性。我们不需要在附录中添加点值。但是在增量法中，我们仍然需要点值附录。*

*![](img/3c37bafdd29367d6b794bf150400528e.png)*

*接下来，我们创建另一个变量:step。我们将其值设置为 5。*

*然后在增量函数中，我们把步长加到数字点值上。*

*![](img/9590e6a776285e4562915d8fc5e78f8a.png)*

*现在，每次我们单击按钮，number 属性的值都会增加 5。*

*![](img/951efd82676500bea6dfd62f234089f4.png)*

*我们没有返回步长变量。所以它不会被添加到组件实例中。换句话说，它在设置功能中受到保护。在我们的实际项目中，我们可以使用这个特性来保护敏感信息。*

*![](img/3eae3f8be8001854c6cbc1209203d07d.png)*

*这是我们之前创建的天气应用程序。*

*总共有四个按钮，代表四个城市。单击这些按钮会触发 *change* 方法，该方法会更新 city 属性的值并将天气描述设置为加载通知。*

*![](img/93115253c485ba8fc85a3565a5735066.png)*

*query 方法查询 openWeather API 并将检索到的天气描述分配给 description 属性。*

*![](img/9dc53e9bac3703eef75737d4f6c03d8f.png)*

*在创建的钩子中，我们使用 watchEffect 方法安装了一个观察器。它监视城市属性并触发查询方法。*

*![](img/eba3d6009f202a2cb2438d3cf6297e40.png)*

*如果新的查询在当前查询完成之前开始，当前正在进行的查询将被取消。这有助于提高程序效率，因为我们最终只需要一个查询结果。*

*![](img/8043d11b942e010b6d246a4a91954ec0.png)**![](img/791152785fd3cf1d1ec5e6874109de3c.png)*

*source 属性是我们可以取消查询的原因。*

*每次运行 query 方法时，我们都会创建一个新的 cancelToken 对象，并将其分配给 source 属性。*

*axios get 方法注册 cancelToken。*

*在 *onInvalidate* 方法中，我们可以使用来自 source 属性的 cancel 方法取消查询。*

*![](img/904a3b8fd0c072a654d1ebb816124d80.png)*

*在数据选项中，我们有关键属性。它存储了我们用来查询 openWeather API 的验证密钥。*

*显然，验证密钥是一条非常敏感的信息。如果其他组件需要查询 openWeather API，它们也需要这个键。*

*![](img/1a9ddff5c771ee8cfc3bb5e2672aee27.png)*

*存储验证密钥的最佳位置是设置功能。只要我们不返回验证密钥，它就只在 setUp 函数的范围内可见。这也意味着我们需要将整个查询程序移到 setUp 函数中。*

*我们将设置功能添加到组件实例中。我们定义了一个变量:key。我们使用验证密钥设置它的值。我们不再需要密钥属性。*

*![](img/c83429f46433774c0c3ca018e8ce5d51.png)*

*这个程序的挑战是使查询可取消。这就要求每个查询方法都必须有自己的 cancelToken，这样才能被准确识别。*

*知道如何将每个查询方法与一个专用的 cancelToken 配对吗？*

*解决方案是工厂模式。我们定义一个工厂函数:queryFactory。*

*![](img/e491a7d1105775e5090142f272cf2623.png)*

*在工厂函数内部，我们首先声明一个变量:source。我们用它来存储 cancelToken。然后我们定义查询函数。*

*![](img/e88268075846ca2107be726be8b2c2cd.png)*

*我们给它传递一个城市名。*

*为了追溯查询过程，我们控制台日志*查询*和*城市名称*。该语句标志着查询的开始。*

*![](img/89ff25faa85072f2d1c1f643ba288e0b.png)*

*然后我们准备 API 地址。*

*验证是在父范围中定义的。没有必要以此为前缀。*

*![](img/0e882a46f88ca308f3a0fa1efb5aca0d.png)*

*然后我们添加一个 TRY CATCH 语句。*

*在 TRY 部分，我们“等待”axios get 方法返回查询结果。*

*![](img/d1081224eae167e3840c9611a85f9cd2.png)*

*在 get 方法的 config 对象中，我们使用工厂函数中定义的 source 变量注册 cancelToken。*

*现在，每个查询方法都有自己的 cancelToken。*

*![](img/47397a0813baf99846cc1d1d26cd39e9.png)*

**等待*需要与*异步*配合工作。记得在查询函数前加上前缀 *async* 。*

*![](img/02cb7d52a2730a74fa80cf0b80b13952.png)*

*我们将查询结果存储在一个名为 result 的变量中。我们在控制台日志中记录了城市名称和天气描述。然后我们返回天气描述。*

*在 CATCH 部分，我们在控制台记录错误消息。*

*![](img/d199ddd1762bfc6220bcb0a82be520ed.png)*

*在查询函数之外，我们返回一个对象。我们将源变量和查询函数放入其中。*

*![](img/c0ad64f51e7eb50bf81ad3c282454c6b.png)*

*现在，我们每次运行工厂函数，都会得到一个查询方法和一个专用的 source 属性。*

*在 setUp 函数结束时，我们返回一个对象并将 queryFactory 函数放入其中。queryFactory 函数将被添加到组件实例中。*

*我们不返回关键变量。因此受到保护。但是返回的 queryFactory 函数仍然可以访问 key 变量。*

*![](img/0b74d6e6d3e607f0d5fe545019a1d327.png)*

*接下来，我们转到创建的钩子。*

*我们移除查询方法。*

*![](img/576ccee1b6553a4dd2062a010d2b00d5.png)*

*我们使用 queryFactory 函数创建一个实例。*

*我们将 cancelToken 对象分配给 source 属性。现在， *invalidate* 方法可以访问 *cancelToken* 并取消查询。*

*然后我们调用查询方法，并将检索到的天气描述分配给 description 属性。*

*我们将这个点城市传递给查询方法。现在，这个点城市已经出现在 watchEffect 方法的第二个副作用函数中。因此，watchEffect 方法将开始监视城市属性的值。当我们重置城市属性的值时，它将被触发。*

*![](img/7f56b17a16b38f0fd18b6836df3e6913.png)*

*查询方法是异步的。*

*所以我们需要等待。我们还需要用 async 作为回调的前缀。*

*![](img/ca00845fd7d071d581af042d35d50d38.png)*

*不再需要原来的查询方法。*

*![](img/373e9e0d8e4a52b7c626664b1c63a07f.png)*

*让我们检查程序。*

*我们刷新页面。*

*伦敦的天气信息已经被自动检索。*

*![](img/9efb3a22364ea2ad14a3f6b7aac41772.png)*

*让我们试试其他城市。*

*该计划正在按预期运行。城市更改由 watchEffect 方法检测，查询方法由新的城市名称触发。*

*![](img/4d7f2748943aa5442f364bf49e266335.png)*

*让我们检查源属性。*

*它的值是一个 cancelToken 对象。*

*![](img/42bf05dd30b1f45f69827f367e1b5593.png)*

*让我们运行 race 方法。*

*最后，只检索到了伦敦的天气信息。*

*起始城市价值是桑德兰。巧合的是，桑德兰是第一个采用比赛方式的城市。*

*从 Sunderland 改为 Sunderland 不会触发查询方法。*

*所以只进行了三次查询，其中只有两次最终被取消。只有最后一个查询成功。*

*![](img/7a8032a047495244d2422cca787b0d6b.png)*

*我们切换到伦敦，再次运行比赛方法。*

*这一次，进行了四次查询，其中三次被取消。*

*![](img/8f700545ffa9dc170817aead02849e65.png)*

*最终的城市值是伦敦，我们已经检索了伦敦的天气信息。*

*queryFactory 函数将被添加到组件实例中。但是与其他普通的组件方法不同，queryFactory 函数是在 setUP 函数内部定义的，因此可以访问验证密钥。*

*![](img/8d9c95d168d47b91387c764462ffed52.png)*

*当我们执行工厂函数时，我们将创建一个源属性和一个查询方法。*

*source 属性存储 cancelToken 对象。*

*在创建的钩子中，在我们执行了 queryFactory 函数之后，我们将 cancelToken 对象分配给 source 属性。现在，组件实例已经收到了 cancelToken。*

*如果 onInvalidate 方法被触发，它将使用 source 属性中存储的 cancelToken 取消查询。*