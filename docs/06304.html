<html>
<head>
<title>Compose, Pipe, and Curry from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始作曲、吹笛子和咖喱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/compose-pipe-and-curry-from-scratch-99b417608d57?source=collection_archive---------1-----------------------#2020-11-13">https://levelup.gitconnected.com/compose-pipe-and-curry-from-scratch-99b417608d57?source=collection_archive---------1-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e311cb91e9443b3ad05fafb1bd884f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8jMFzunn7XGSehe9FHYBKw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/photos/ImcUkZ72oUs" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/ImcUkZ72oUs</a></figcaption></figure><div class=""/><p id="10c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多文章解释什么是烹饪和作曲。甚至还有我写的<a class="ae jd" href="https://medium.com/@rolandpeelen/function-composition-currying-in-real-life-e74c86302205" rel="noopener">一个</a>。</p><p id="a713" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，虽然我觉得我的文章很全面，但我认为仍有一些解释的余地。当看着咖喱和组成，以及实际的实现，他们似乎很简洁，可能很难理解到底发生了什么。本文的目的是建立一些直觉，从头开始创建一个<code class="fe lb lc ld le b">compose</code>、<code class="fe lb lc ld le b">pipe</code>、<strong class="kf jh">、</strong>和<code class="fe lb lc ld le b">curry</code>函数。从最基本的版本开始，到最简洁/复杂但也最灵活的版本结束。</p><h1 id="f754" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">咖喱</h1><blockquote class="md me mf"><p id="8a00" class="kd ke mg kf b kg kh ki kj kk kl km kn mh kp kq kr mi kt ku kv mj kx ky kz la ij bi translated">让函数一次接受一个参数的过程。</p></blockquote><p id="b9f1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一些代码。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="10ae" class="ms lg jg le b gy mt mu l mv mw">// Uncurried<br/>const add = (x, y) =&gt; x + y;<br/>[1,2,3].map(x =&gt; add(x, 4)); // [5, 6, 7]</span><span id="5f10" class="ms lg jg le b gy mx mu l mv mw">// Curried<br/>const add = x =&gt; y =&gt; x + y;<br/>[1,2,3].map(add(4)); // [5, 6, 7]</span></pre><p id="a3a3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，这有一些优点，不那么冗长。然而，以这种方式编写函数是令人讨厌的，并且不是特别灵活(相当极端的例子)；</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="adcb" class="ms lg jg le b gy mt mu l mv mw">// Curried<br/>const add5args = a =&gt; b =&gt; c =&gt; d =&gt; e =&gt; a + b + c + d + e;<br/>add5args(1)(2)(3)(4)(5); // 15</span><span id="3013" class="ms lg jg le b gy mx mu l mv mw">// Possible uncurried variant<br/>const add5args = (a,b,c,d,e) =&gt; a + b + c + d + e;<br/>add5args(1, 2, 3, 4, 5); // 15</span></pre><p id="0b13" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个函数会将我们的第二个变量转换成一个可以一次接受一个变量的变量，所以我们可以在例如<code class="fe lb lc ld le b">Array.map</code>中使用它。</p><h1 id="843a" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">合成和管道功能(0级)</h1><blockquote class="md me mf"><p id="9536" class="kd ke mg kf b kg kh ki kj kk kl km kn mh kp kq kr mi kt ku kv mj kx ky kz la ij bi translated">将多个函数链接在一起以创建一个新函数过程。</p></blockquote><p id="f116" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看这是如何工作的一些代码。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="796f" class="ms lg jg le b gy mt mu l mv mw">const add5 = x =&gt; x + 5;<br/>const multiply6 = x =&gt; x * 6;</span><span id="6a4c" class="ms lg jg le b gy mx mu l mv mw">const multiply6Add5 = compose(add, multiply);</span><span id="293d" class="ms lg jg le b gy mx mu l mv mw">multiply6Add5(2); // 17 😎</span></pre><p id="5653" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以从<code class="fe lb lc ld le b">add5</code>和<code class="fe lb lc ld le b">multiply6</code>中，我们创建了一个新的函数，它是两者的<strong class="kf jh">组合</strong>。给了我们一个既能乘以6又能加上5的新函数。但是为什么这个是反的呢？</p><p id="2ea9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数合成的概念来源于数学。在加、乘、除之类的东西旁边，有一个<code class="fe lb lc ld le b">composition</code>操作符。它是一个点，上面有一个洞。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="02ab" class="ms lg jg le b gy mt mu l mv mw">(f ° g)(x) = f(g(x));</span></pre><p id="68ee" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样读的话就是x的g后的<strong class="kf jh">f</strong>和取<code class="fe lb lc ld le b">x</code>，应用到<code class="fe lb lc ld le b">g</code>，再应用到<code class="fe lb lc ld le b">f</code>是一样的。我们在这里看到的是，合成以相反的顺序进行。第二个功能(<code class="fe lb lc ld le b">g</code>)在第一个功能之前应用。这也是函数组合在编程中落后的原因。在代码中，我们引入了<code class="fe lb lc ld le b">pipe</code>函数的概念，该函数反转应用程序，使其成为我们直觉认为的样子。</p><p id="478e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们编写自己的组合和管道函数。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="2c5c" class="ms lg jg le b gy mt mu l mv mw">// Uncurried<br/>const composeU = (f, g, x) =&gt; f(g(x));<br/>const pipeU = (f, g, x) =&gt; g(f(x));</span><span id="18a4" class="ms lg jg le b gy mx mu l mv mw">// Curried<br/>const compose = f =&gt; g =&gt; x =&gt; f(g(x));<br/>const pipe = f =&gt; g =&gt; x =&gt; g(f(x));</span><span id="a49d" class="ms lg jg le b gy mx mu l mv mw">// Or reverse arguments for the pipe function<br/>const pipe = f =&gt; g =&gt; x =&gt; compose(g)(f)(x);</span></pre><p id="882c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，这与数学符号非常相似。我用一个<code class="fe lb lc ld le b">U</code>在后面固定了未绑定的函数，这样我们以后可以区分它们。让我们试用一下。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="e493" class="ms lg jg le b gy mt mu l mv mw">const add5 = x =&gt; x + 5;<br/>const multiply6 = x =&gt; x * 6;</span><span id="1fc5" class="ms lg jg le b gy mx mu l mv mw">// Uncurried<br/>composeU(add, multiply, 2); // 17<br/>pipeU(add, multiply, 2); // 42</span><span id="c607" class="ms lg jg le b gy mx mu l mv mw">// Curried<br/>const multiply6Add5 = compose(add)(multiply);<br/>const add5Multiply6 = pipe(add)(multiply);</span><span id="092c" class="ms lg jg le b gy mx mu l mv mw">multiply6Add5(2); // 17<br/>add5Multiply6(2); // 42</span><span id="9ba2" class="ms lg jg le b gy mx mu l mv mw">[1,2,3].map(multiply6Add5) // [11, 17, 23]</span></pre><p id="42f2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时候，能够将<a class="ae jd" href="https://en.wikipedia.org/wiki/Partial_application#:~:text=In%20computer%20science%2C%20partial%20application,producing%20a%20function%20of%20type%20." rel="noopener ugc nofollow" target="_blank">的两个函数部分应用到</a>的作品中真的很好，这样以后就可以在<code class="fe lb lc ld le b">map</code>中使用它们了。然而，有时候，能够在它们的未受影响的变体中使用它们也是很好的。理想情况下，我们希望拥有两个世界的优点，但是我们不想写两次函数。所以我们来做个帮手吧。</p><h1 id="1f43" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">咖喱功能(0级)</h1><p id="a6fc" class="pw-post-body-paragraph kd ke jg kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们将直接进入我们的基本咖喱功能。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="3621" class="ms lg jg le b gy mt mu l mv mw">const curry = fn =&gt; x =&gt; y =&gt; fn(x, y);</span><span id="946f" class="ms lg jg le b gy mx mu l mv mw">const addU = (x, y) =&gt; x + y;<br/>const add = curry(addU);</span><span id="80d0" class="ms lg jg le b gy mx mu l mv mw">addU(4, 2); // 6<br/>add(4)(2); // 6</span><span id="acd0" class="ms lg jg le b gy mx mu l mv mw">const add4 = add(4);<br/>add4(10) // 14</span></pre><p id="fba7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的curry函数只是接受另一个函数，然后接受一些参数，并将它们应用到参数中。所以现在我们只需要定义我们的addU函数，然后我们可以根据另一个函数来定义我们的curried版本。不错！</p><h2 id="4708" class="ms lg jg bd lh nd ne dn ll nf ng dp lp ko nh ni lt ks nj nk lx kw nl nm mb nn bi translated">但是等等…</h2><p id="a7dc" class="pw-post-body-paragraph kd ke jg kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果我们想要组合两个以上的函数呢？还是库里一个有三个参数的函数？</p><h1 id="b95e" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">撰写功能(第1级)</h1><p id="cf21" class="pw-post-body-paragraph kd ke jg kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">再补充几个版本吧。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="b492" class="ms lg jg le b gy mt mu l mv mw">const compose = f =&gt; g =&gt; x =&gt; f(g(x));<br/>const compose3 = f =&gt; g =&gt; h =&gt; x =&gt; f(g(h(x)));<br/>const compose4 = f =&gt; g =&gt; h =&gt; i =&gt; x =&gt; f(g(h(i(x))));<br/>// …</span></pre><p id="dfc9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这可行，但并不理想。让我们使用<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameter" rel="noopener ugc nofollow" target="_blank"> rest运算符</a>。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="f71f" class="ms lg jg le b gy mt mu l mv mw">const composeU = (...fns) =&gt; x =&gt; {<br/> let val = x;<br/>   for (const fn of fns.reverse()) {<br/>     val = fn(val)<br/>   }<br/> return val;<br/>};</span><span id="f90a" class="ms lg jg le b gy mx mu l mv mw">const add3 = x =&gt; x + 3;<br/>const add4 = x =&gt; x + 4;<br/>const add5 = x =&gt; x + 5;</span><span id="2644" class="ms lg jg le b gy mx mu l mv mw">const add12 = compose(add3, add4, add5);</span><span id="bc5f" class="ms lg jg le b gy mx mu l mv mw">add12(2); // 14 😎</span></pre><p id="2016" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这太棒了！我们取我们的函数，以相反的顺序一个接一个地检查它们，并将函数应用到我们想要使用的值上。但是，我们的函数是非常必要的，我们在做任何操作之前都要反转整个数组…也许我们可以做些什么。从概念上讲，我们接受一个类似数组的东西，一个接一个地遍历它，把它简化成一个值。嗯……<code class="fe lb lc ld le b">reduce</code>……</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="c40e" class="ms lg jg le b gy mt mu l mv mw">const compose = (...fns) =&gt; x =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc), x);</span></pre><p id="ce60" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那更好。我们从右到左减少数组，将每个函数应用到累加器，从输入值开始。但是现在有一个问题…</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="1206" class="ms lg jg le b gy mt mu l mv mw">const composeU = (...fns) =&gt; x =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc), x);<br/>const compose = curry(composeU);</span><span id="bb86" class="ms lg jg le b gy mx mu l mv mw">const add3 = x =&gt; x + 3;<br/>const add4 = x =&gt; x + 4;<br/>const add5 = x =&gt; x + 5;</span><span id="c558" class="ms lg jg le b gy mx mu l mv mw">const add12 = compose(add3, add4, add5);</span><span id="788c" class="ms lg jg le b gy mx mu l mv mw">add12(2); // [Function] 😥</span></pre><p id="575b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎我们的咖喱功能坏了，我们不能使用它与组成…</p><h1 id="a44f" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">咖喱功能(1级)</h1><p id="adb1" class="pw-post-body-paragraph kd ke jg kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">再补充几个版本吧。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="c257" class="ms lg jg le b gy mt mu l mv mw">const curry = fn =&gt; x =&gt; y =&gt; fn(x, y);<br/>const curry3 = fn =&gt; x =&gt; y =&gt; z =&gt; fn(x, y, z);<br/>const curry4 = fn =&gt; x =&gt; y =&gt; =&gt; z =&gt; a =&gt; fn(x, y, z, a);<br/>// …</span></pre><p id="bad1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这也可行，但也许我们也可以用rest参数做些什么…</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="6966" class="ms lg jg le b gy mt mu l mv mw">const curry = fn =&gt; {<br/> return function curried (...args) {<br/>   if(args.length &gt;= fn.length) {<br/>     return fn.apply(null, args);<br/>   }<br/>   return curried.bind(null, ...args);<br/> };<br/>};</span></pre><p id="9872" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这到底是怎么回事？我们的curry函数需要一个函数。检查…但是然后…从概念上来说，即使它不是这样实现的，也要把它想象成一个缓冲区。我们的<code class="fe lb lc ld le b">…args</code>是根据它们的<code class="fe lb lc ld le b">length</code>(我们已经提供的数量)来检查的，如果我们已经达到了我们需要的数量(我们可以通过检查<code class="fe lb lc ld le b">fn</code>的参数数量—或者<a class="ae jd" href="https://en.wikipedia.org/wiki/Arity#:~:text=Arity%20(%2F%CB%88%C3%A6r%C9%AAt,also%20called%20adicity%20and%20degree." rel="noopener ugc nofollow" target="_blank"> arity </a> —来检查)，那么我们将所有的参数应用到最初提供的函数(<code class="fe lb lc ld le b">fn</code>)并返回它。如果没有，返回内部函数，但是将我们已经收到的参数绑定到它(准备接收更多)。</p><p id="002b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，递归地返回<code class="fe lb lc ld le b">curried</code>，直到我们遇到最初提供的函数的arity。</p><p id="894e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个漂亮简洁的es6等价物。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="8089" class="ms lg jg le b gy mt mu l mv mw">const curry = fn =&gt; {<br/> const curried = (...args) =&gt;<br/>   args.length &gt;= fn.length<br/>     ? fn.apply(null, args)<br/>     : curried.bind(null, ...args);<br/> return curried;<br/>};</span></pre><p id="7cc7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用之前的<code class="fe lb lc ld le b">add5args</code>函数来看看它的作用。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="43ae" class="ms lg jg le b gy mt mu l mv mw">const add5argsU = (a, b, c, d, e) =&gt; a + b + c + d + e;<br/>const add5args = curry(add5argsU);</span><span id="6b37" class="ms lg jg le b gy mx mu l mv mw">const a = add5args(1); // [Function] — 4 arguments left<br/>const b = a(2); // [Function] — 3 arguments left<br/>const c = b(3); // [Function] — 2 arguments left<br/>const d = c(4); // [Function] — 1 arguments left</span><span id="4c1c" class="ms lg jg le b gy mx mu l mv mw">a(2,3,4,5) // 15<br/>b(3,4,5) // 15<br/>c(4,5) // 15<br/>d(5); // 15</span></pre><p id="67c1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了，我们现在可以一次提供所有的参数，或者一半，或者只有一个，并继续添加，直到我们有了完整的函数。不错！让我们看看是否可以在我们的compose函数中使用它。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="376b" class="ms lg jg le b gy mt mu l mv mw">// From earlier<br/>const composeU = (...fns) =&gt; x =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc), x);<br/>const compose = curry(composeU);</span><span id="deae" class="ms lg jg le b gy mx mu l mv mw">const add1 = x =&gt; x + 1;<br/>const add2 = x =&gt; x + 2;<br/>const add3 = x =&gt; x + 3;<br/>const add4 = x =&gt; x + 4;</span><span id="06c8" class="ms lg jg le b gy mx mu l mv mw">const add5 = compose(add2, add3);<br/>const add7 = compose(add3, add4);<br/>const add11 = compose(add4, add4, add3);</span><span id="3291" class="ms lg jg le b gy mx mu l mv mw">add5(4); // 9<br/>add7(4); // 11<br/>add11(4); // 15</span><span id="aca0" class="ms lg jg le b gy mx mu l mv mw">const add12 = compose(add5, add7); // Already composed functions 😎<br/>add12(4); // 16</span></pre><p id="6f08" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不错！无论我们提供多少参数，我们都可以按照自己喜欢的方式组合函数，并在以后使用它们。我们甚至可以用另一篇作文来定义我们的作文。</p><h1 id="901d" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">管道功能(1级)</h1><p id="06d6" class="pw-post-body-paragraph kd ke jg kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们太兴奋了，完全忘记了我们的<code class="fe lb lc ld le b">pipe</code>功能。这很容易定义。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="533a" class="ms lg jg le b gy mt mu l mv mw">const composeU = (...fns) =&gt; x =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc), x);<br/>const pipeU = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x);<br/>const compose = curry(composeU);<br/>const pipe = curry(pipeU);</span></pre><p id="d1f4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好。对吗？嗯，anal-retentive-me有点恼火，因为我们实际上在管道函数中重复了我们的compose函数，但只是参数颠倒了。也许我们可以根据彼此来定义它们。我们应该能够简单地反转函数的参数，并且做得很好。对吗？</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="f774" class="ms lg jg le b gy mt mu l mv mw">const composeU = (...fns) =&gt; x =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc), x);<br/>const pipeU = (...fns) =&gt; x =&gt; composeU(...fns.reverse())(x)<br/>const compose = curry(composeU);<br/>const pipe = curry(pipeU);</span></pre><p id="bac3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好多了。我们也接近于<code class="fe lb lc ld le b">pipeU</code>拥有如此少的语法，我们可以开始省略它的一些测试… <br/>但不是现在。我认为我们可以走得更远。</p><h1 id="b1e1" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">奖金水平</h1><p id="f0e0" class="pw-post-body-paragraph kd ke jg kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">还有一件事很烦。我们有这个漂亮的curry函数，当我们用它把我们的<code class="fe lb lc ld le b">composeU</code>变成一个curry函数时，它已经以单独接受‘数据’参数的方式被curry化了。如果我们能让它直接变成curried，或者立刻接受它的所有参数，那就太好了，这样我们至少感觉到我们的<code class="fe lb lc ld le b">curry</code>函数做了一些好事。或许我们可以试试:</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="217b" class="ms lg jg le b gy mt mu l mv mw">const composeU = (...fns, x) =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc), x);</span></pre><p id="03fd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们不能…</p><blockquote class="md me mf"><p id="9f44" class="kd ke mg kf b kg kh ki kj kk kl km kn mh kp kq kr mi kt ku kv mj kx ky kz la ij bi translated">语法错误:Rest参数必须是最后一个形参。那是令人失望的。</p></blockquote><p id="6576" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而。这还没完…如果我们阅读数组的归约函数的<a class="ae jd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">文档，我们会看到以下内容:</a></p><blockquote class="md me mf"><p id="0f97" class="kd ke mg kf b kg kh ki kj kk kl km kn mh kp kq kr mi kt ku kv mj kx ky kz la ij bi translated">initialValue <strong class="kf jh">可选</strong> <br/>一个值，用作回调的第一次调用的第一个参数。如果未提供initialValue，数组中的第一个元素将用作初始累加器值，并作为currentValue跳过。在没有initialValue的空数组上调用reduce()将引发TypeError。</p></blockquote><p id="5f40" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">啊哈。所以是<strong class="kf jh">可选</strong>。如果我们不提供参数，它会自动从数组中取出第<strong class="kf jh">个</strong>项。乍一看，这似乎对我们没有帮助，因为我们提供的参数是我们想要使用的<strong class="kf jh"> last </strong>，所以它将是数组中的最后一个。但是，仔细研究一下，因为我们是从右边开始减少的，所以当我们到达那里时，它实际上是第一个元素！</p><p id="90f7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不能把<code class="fe lb lc ld le b">x</code>放在第二个位置。但是我们可以完全忽略它。甚至更好！</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="157a" class="ms lg jg le b gy mt mu l mv mw">const compose = (...fns) =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc));<br/>const pipe = (...fns) =&gt; compose(...fns.reverse());</span></pre><p id="9903" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好…那正合我意。现在我们的函数有了一个可变的arity，我们就不用去修饰它了！</p><h1 id="a2e8" class="lf lg jg bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结束的</h1><p id="6251" class="pw-post-body-paragraph kd ke jg kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">因此，我们已经经历了几次<code class="fe lb lc ld le b">compose</code>、<code class="fe lb lc ld le b">pipe</code>和<code class="fe lb lc ld le b">curry </code>函数的迭代。从最简单的变体开始，建立一些直觉，以非常灵活的抽象变体结束。</p><pre class="mk ml mm mn gt mo le mp mq aw mr bi"><span id="2da5" class="ms lg jg le b gy mt mu l mv mw">const compose = (...fns) =&gt; fns.reduceRight((acc, fn) =&gt; fn(acc));<br/>const pipe = (...fns) =&gt; compose(...fns.reverse());</span><span id="5066" class="ms lg jg le b gy mx mu l mv mw">const curry = fn =&gt; {<br/> const curried = (...args) =&gt;<br/>   args.length &gt;= fn.length<br/>     ? fn.apply(null, args)<br/>     : curried.bind(null, ...args);<br/> return curried;<br/>};</span></pre></div></div>    
</body>
</html>