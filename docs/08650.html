<html>
<head>
<title>5 Easy Ways to Improve Software Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进软件设计的5种简单方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-easy-ways-to-improve-your-software-design-quickly-e738f2bcf97e?source=collection_archive---------1-----------------------#2021-05-21">https://levelup.gitconnected.com/5-easy-ways-to-improve-your-software-design-quickly-e738f2bcf97e?source=collection_archive---------1-----------------------#2021-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5bd4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简单的解决方案在80%的情况下都有帮助。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65e73d419ed2c50b49e75297d3c40a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qlNWybAX9N0oppk_"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@ralexnder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alex Chumak </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以面向对象、函数式或混合风格设计代码是一门艺术，需要软件开发人员通过阅读基础书籍、实践、犯错误并从中学习来不断磨练他们的知识和技能。</p><p id="48fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码设计包括各种复杂程度的无数技术、模式和原则。然而，不仅仅是应用难学的知识可以显著提高你申请的质量。通常，简单的方法会让软件开发人员受益匪浅。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b88" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.避免部分初始化的对象</h1><p id="e5e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">域类中缺少构造函数会导致应用程序中的对象部分初始化，这反过来又会导致令人讨厌的错误。</p><h2 id="5c5c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="3927" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">糟糕的实现允许开发人员创建没有姓名和/或电子邮件的客户——开发人员很容易忘记初始化属性，但代码会编译。</p><p id="b19c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">坏的例子从编程语言的角度来看是完全正确的，但是从领域的角度来看是无效的。每个新创建的客户都必须有一个名字和电子邮件——这是领域语言规定的，但是一个坏例子的代码没有强制执行这个领域规则。</p><p id="7dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个好的<strong class="lb iu"> </strong>例子需要构造函数中的参数。构造器是<code class="fe nn no np nq b">Customer</code>类和每个客户端之间的契约，客户端将通过<code class="fe nn no np nq b">new</code>关键字实例化它。现在客户必须提供用户名和电子邮件，否则他们将无法获得<code class="fe nn no np nq b">Customer</code>实例。</p><p id="862f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，设置器也被移除了，这提供了更好的封装——实例<code class="fe nn no np nq b">Customer</code>在创建后不会因为意外清除<code class="fe nn no np nq b">Email</code>或<code class="fe nn no np nq b">Username</code>属性而被破坏。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="72fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.将您的代码编写为管道</h1><p id="0d5d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当需要执行一系列对象突变时，编写代码的流水线方式可以保护应用程序免受错误的影响，并且更易于阅读。</p><h2 id="2ba9" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="00e8" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的和坏的例子在行为上是完全等价的。</p><p id="68e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一个坏的例子是坏的，因为方法是顺序敏感的。在试图过滤掉不活跃的客户之前，必须加载客户。有人可能会不小心交换了<code class="fe nn no np nq b">RemoveNonActiveCustomers</code>和<code class="fe nn no np nq b">LoadCustomers</code>方法。代码可以编译，但是在运行时会失败。</p><p id="c514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个好例子中，上面的缺点被消除了，在这个例子中，方法不仅修改集合，还将结果返回给调用者。</p><p id="1b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">偶然交换行，比如1和2，将导致编译时错误。此外，基于纯函数的代码更容易阅读，因为在一个很好的例子中，代码看起来像管道。在每一个阶段，我们收到什么和我们传递给下一个阶段的东西都很清楚。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad64" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.使用IReadOnlyList <t>而不是IEnumerable <t>作为返回类型</t></t></h1><p id="106a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nn no np nq b">IEnumerable&lt;T&gt;</code>接口提供了一种迭代来自内存、数据库、网络、文件等的数据的方法。</p><p id="d35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回类型<code class="fe nn no np nq b">IEnumerable&lt;T&gt;</code>是存储库方法的典型选择。然而，使用<code class="fe nn no np nq b">IEnumerable&lt;T&gt;</code>可能会导致性能问题。</p><h2 id="7c37" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="a96d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d3f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr">注意:对于第三方库，当方法将被其他外部代码库使用时，最好返回更通用的类型IEnumerable &lt; T &gt;。这允许您轻松地在不同的集合类型之间切换，例如HashSet &lt; T &gt;，List &lt; T &gt;，Dictionary &lt; TKey，TValue &gt;等，并且不会中断您的客户端。</em></p><p id="ed9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe nn no np nq b">IEnumerable&lt;T&gt;</code>作为返回类型时，开发人员应该记住在将结果返回给调用者之前，通过调用<code class="fe nn no np nq b">ToList, ToArray or ToWhatever</code>方法在方法内部具体化结果。如果不这样做，每次调用方遍历集合时，结果都将被具体化，这可能会导致严重的性能下降。</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">5种免费提高C#代码性能的方法</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">慢速代码是可选的。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><p id="f918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe nn no np nq b">IEnumerable&lt;T&gt;.</code>时，很容易忘记在方法中具体化集合，然而，使用<code class="fe nn no np nq b">IReadOnlyList&lt;T&gt;</code>接口将要求开发人员在将结果发送给调用者之前调用<code class="fe nn no np nq b">ToList()</code>方法。否则，代码将无法编译。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.使用dto代替部分初始化的对象</h1><p id="bc98" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有时有必要从数据库中只获取一个对象的一些属性，而不是整个对象。这通常是获得最佳性能所必需的。</p><h2 id="37e1" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="b653" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="604c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">糟糕的例子使用相同的<code class="fe nn no np nq b">Customer</code>模型，即使存储库方法只需要返回客户的一个或几个属性。这导致在应用程序中有部分初始化的对象。</p><p id="6c01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开发人员通过调用抽象顶层的<code class="fe nn no np nq b">GetCustomerContacts</code>方法来获得客户类型的实例时，他们不确定客户的哪些属性被初始化了，哪些没有。要回答这个问题，开发人员必须深入研究存储库实现细节。</p><p id="4581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个很好的例子是使用非常特殊的类型<code class="fe nn no np nq b">Guid</code>和<code class="fe nn no np nq b">CustomerContactsDto</code>，它们总是被完全初始化，所以更容易使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="25b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.使用只读和只写类</h1><p id="82bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">存储库、服务、控制器和其他类可以混合读写数据的职责。将这样的类分成只读类和只写类，是一种简单的技术，可以带来更好的软件设计。</p><h2 id="0aba" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">严重的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="b740" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">好的</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阶级的这种划分导致几个很大的优势:</p><ul class=""><li id="2ce1" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">有两个小班，而不是一个大班。类越小，依赖就越少，分析、调试、维护和单元测试就越容易。</li><li id="801f" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">写入和读取数据通常需要不同的方法和工具。比如把对象的复杂图形保存到数据库，用实体框架核心比较好，从数据库快速检索数据，用Dapper比较好。从可维护性的角度来看，在同一个类中混合EF核心和Dapper逻辑不是一个好主意。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed88" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="364a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">简单的解决方案可以带来巨大的进步。它总是值得考虑，他们主要是一个有效的开发人员谁得到快速完成工作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="eb1f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">我的其他文章</h2><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="oy l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/treat-if-else-as-a-code-smell-until-proven-otherwise-3bd2c4c577bf"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">将If-Else视为代码气味，直到被证明并非如此</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">C#中If-Else重构技术</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="oz l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://medium.datadriveninvestor.com/estimation-hell-or-what-can-developers-do-better-with-their-estimates-614f9e71f43d" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">评估地狱，或者开发人员如何利用他们的评估做得更好？</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">估计过程很难，但没那么难。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="oe l"><div class="pa l og oh oi oe oj ks nv"/></div></div></a></div></div></div>    
</body>
</html>