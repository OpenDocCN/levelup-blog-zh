<html>
<head>
<title>Combine Python &amp; Go for Machine Learning With gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Python &amp; Go用于机器学习与gRPC相结合</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/combine-python-go-for-machine-learning-with-grpc-fb1316a2219b?source=collection_archive---------8-----------------------#2021-08-05">https://levelup.gitconnected.com/combine-python-go-for-machine-learning-with-grpc-fb1316a2219b?source=collection_archive---------8-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7620" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用2021年最流行的两种编程语言的优势！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cac656974865df690a43de9b17794b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*38pP25zOVX_L3h4R.jpeg"/></div></div></figure><p id="e040" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">ython和Go都发现自己处于各自角色的编程食物链的顶端。Python已经成为数据科学的首选语言(没有双关语的意思),因为它有大量的库支持，例如Scikit-Learn、Pandas、Numpy和TensorFlow等等。另一方面，Go已经成为微服务、分布式系统和高效服务器端架构的标准选择。各有各的长处，为什么不把两者结合起来呢？</p><blockquote class="lz ma mb"><p id="29ff" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">我们可以通过使用gRPC (google远程过程调用)来充分利用Python和Go。这将允许我们在Go中构建一个简单的客户端，同时我们在Python中创建并利用一个Scikit-Learn模型，该模型将充当查询的服务器。Go客户端将发送一个葡萄酒的文本描述，Python服务器将对该描述的多样性做出预测。这将展示一个概念证明(PoC ),说明如何使用gRPC以有效的方式更好地结合一些顶级语言。</p></blockquote></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="eaf3" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">gRPC的快速概述</h1><p id="a656" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">我不会对gRPC做太深入的探讨，因为我在过去已经写过了。基本上，它是一种独立于语言的高效通信方法。它通过用字节码表示的protobuf消息传输数据，这比标准的基于json的REST API要有效得多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2a343b9fa717906405ed26fed92ba4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sJSsbcTcdlktzBQ8.jpg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">来自<a class="ae np" href="https://programmer.group/images/article/60a127ec15564eedd8336c3f772b858a.jpg" rel="noopener ugc nofollow" target="_blank">程序员组</a></figcaption></figure><p id="3217" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">启动和运行gRPC有三个主要步骤。第一个是通过。原型文件，我们接下来会看到。</p><p id="a412" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，您需要为客户机和服务器各自的数据绑定和方法生成代码。最后一步是实现方法存根。一旦完成，您现在就可以在服务器和客户机代码之间发送高效的字节编码请求和响应。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="decb" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">创造。原型文件和生成gRPC绑定</h1><p id="4ab8" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">我们将为这个例子维护一个简单的项目设置。项目的根层将是我们的Go客户端加上<code class="fe nq nr ns nt b">go.mod/sum</code>。然后我们将拥有自己填写的根文件<code class="fe nq nr ns nt b">.proto</code>。在<code class="fe nq nr ns nt b">pb</code>文件夹中还有一个存放Go的protobuf数据绑定的文件夹，而Python代码依赖于<code class="fe nq nr ns nt b">py</code>文件夹中自动生成的<code class="fe nq nr ns nt b">.py</code>文件。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="2d52" class="ny mo it nt b gy nz oa l ob oc">.<br/>├── client.go<br/>├── go.mod<br/>├── go.sum<br/>├── wine_varieties.proto<br/>├── pb<br/>│   └── wine_varieties.pb.go<br/>└── py<br/>    ├── wine_varieties_pb2_grpc.py<br/>    ├── wine_varieties_pb2.py<br/>    └── server.py</span></pre><h2 id="9a81" class="ny mo it bd mp od oe dn mt of og dp mx ld oh oi mz lh oj ok nb ll ol om nd on bi translated">定义原型文件</h2><p id="8b52" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在我们需要填写<code class="fe nq nr ns nt b">wine_varieties.proto</code>。首先，我们将语法设置为最新版本的<code class="fe nq nr ns nt b">proto3</code>，并将包设置到我们的目录<code class="fe nq nr ns nt b">pb</code>。我们还将<code class="fe nq nr ns nt b">go_package</code>设置为相对路径<code class="fe nq nr ns nt b">“./pb”</code>。然后，我们为葡萄酒评论的请求和响应定义消息。最后，我们定义一个服务，它将作为一个接口来生成我们必须在Python代码中实现的<code class="fe nq nr ns nt b">GetWineVariety()</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="ae29" class="ny mo it bd mp od oe dn mt of og dp mx ld oh oi mz lh oj ok nb ll ol om nd on bi translated">生成protobuf和gRPC代码</h2><p id="9b42" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在我们已经定义了原型文件，让我们首先生成Go代码。protoc命令是协议缓冲区的编译器，协议缓冲区是gRPC使用的数据格式。标志<code class="fe nq nr ns nt b">go_out=plugins=grpc:pb</code>告诉<code class="fe nq nr ns nt b">protoc</code>使用gRPC插件并将文件放在<code class="fe nq nr ns nt b">pb</code>目录中。go_opt=paths=source_relative告诉<code class="fe nq nr ns nt b">protoc</code>在相对于当前目录的<code class="fe nq nr ns nt b">pb</code>目录中生成代码。<code class="fe nq nr ns nt b">wine_varieties.proto</code>文件将用于生成代码。这将用数据绑定和助手方法填充<code class="fe nq nr ns nt b">wine_varieties.pb.go</code>。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="ca83" class="ny mo it nt b gy nz oa l ob oc">$ protoc --go_out=plugins=grpc:pb --go_opt=paths=source_relative wine_varieties.proto</span></pre><p id="b3de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以生成Python代码了。这将为<code class="fe nq nr ns nt b">wine_varieties_pb2_grpc.py</code>和<code class="fe nq nr ns nt b">wine_varieties_pb2.py</code>创建代码。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="414c" class="ny mo it nt b gy nz oa l ob oc">$ python3 -m grpc_tools.protoc -I.. --python_out=. --grpc_python_out=. ../wine_varieties.proto</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="2b33" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Python中的文本分类</h1><p id="6b1d" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在我们已经生成了protobuf和gRPC代码，是时候实现服务器了。服务器将首先在葡萄酒数据的csv上训练线性支持向量分类器(SVC)。它还将实现方法<code class="fe nq nr ns nt b">GetWineVariety()</code>供Go客户端查询。我们将在<code class="fe nq nr ns nt b">server.py</code>中一次处理一件。首先，让我们导入必要的库。</p><blockquote class="lz ma mb"><p id="2220" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:我不会详细讨论SVC或特征提取，因为这超出了本文的范围。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="2f2b" class="ny mo it bd mp od oe dn mt of og dp mx ld oh oi mz lh oj ok nb ll ol om nd on bi translated">构造服务器类</h2><p id="3d95" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">接下来我们需要定义Python类<code class="fe nq nr ns nt b">WineClassifierServer</code>，它将在<code class="fe nq nr ns nt b">wine_varieties_pb2_grpc</code>中生成的<code class="fe nq nr ns nt b">WineClassifierServiceServicer</code>作为参数。不要太担心这个，这只是进行我们的远程过程调用的管道。</p><p id="616a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是，我们在<code class="fe nq nr ns nt b">__init__(self):</code>中初始化这个类，以便对葡萄酒数据进行训练，并获得我们的初始模型训练估计值。您会注意到某些对象，如<code class="fe nq nr ns nt b">top_10_varieties</code>或<code class="fe nq nr ns nt b">count_vect</code>被声明为该类的属性——这是因为我们需要这些属性来在下面的方法<code class="fe nq nr ns nt b">GetWineVariety()</code>中进行预测。我不打算解释这段代码的细节，但它是Python中简单的文本分类，很容易学会。</p><p id="3718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子的数据可以在Kaggle的<a class="ae np" href="https://www.kaggle.com/zynicide/wine-reviews/version/4" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="28dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好，现在我们可以在我们的类中实现<code class="fe nq nr ns nt b">GetWineVariety()</code>方法了。该方法接收protobuf请求以及来自Go客户端的上下文。这里我们利用了类属性，比如<code class="fe nq nr ns nt b">self.count_vect</code>和我们训练的初始SVC模型<code class="fe nq nr ns nt b">self.lsvc</code>，以便对葡萄酒评论进行预测。在第10–13行，我们找到了与我们的预测相匹配的葡萄酒品种的名称，并将该名称用作我们的<code class="fe nq nr ns nt b">WineReviewResponse</code>的<code class="fe nq nr ns nt b">variety</code>字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="9e7b" class="ny mo it bd mp od oe dn mt of og dp mx ld oh oi mz lh oj ok nb ll ol om nd on bi translated">用Python创建gRPC服务器</h2><p id="3759" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">差不多了，现在我们只需要定义实际启动和运行服务器的代码。这里没有什么特别的，只是一些日志配置，然后在端口8080上启动一个gRPC服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="c9c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们运行<code class="fe nq nr ns nt b">server.py</code>，我们将获得排名前10的葡萄酒品种以及我们的模型训练准确性，并记录服务器已准备好接受请求。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="9109" class="ny mo it nt b gy nz oa l ob oc">$ python3 server.py <br/>2021-08-05 09:13:30,262 - INFO - {'Pinot Noir': 0, 'Chardonnay': 1, 'Cabernet Sauvignon': 2, 'Red Blend': 3, 'Bordeaux-style Red Blend': 4, 'Riesling': 5, 'Sauvignon Blanc': 6, 'Syrah': 7, 'Rosé': 8, 'Merlot': 9}<br/>Accuracy: 81.15%<br/>2021-08-05 09:13:36,308 - INFO - server ready on port 8080</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="c354" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Go中的简单客户端</h1><p id="c91a" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在是容易的部分。我们已经通过为Python生成protobuf和gRPC代码完成了所有繁重的工作，并继续实现服务器逻辑。我们在这里只执行三个简单的步骤。首先，我们在端口8080上启动一个gRPC客户机。然后我们用自己的自定义<code class="fe nq nr ns nt b">Review</code>声明一个<code class="fe nq nr ns nt b">WineReviewRequest</code>来进行预测。最后，我们查询<code class="fe nq nr ns nt b">client.GetWineVariety()</code>并打印我们得到的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="bd96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为这些都是通过本地模块完成的，所以您需要稍微调整一下您的<code class="fe nq nr ns nt b">go run</code>命令。如果运行这个程序，下面是输出:</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="3be8" class="ny mo it nt b gy nz oa l ob oc">$ GO111MODULE=off go run client.go <br/>2021/08/05 09:17:48 Predicted wine variety: Riesling</span></pre><p id="2852" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很酷，是吧？</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="b2b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，您已经将Go中的客户端与Python服务器结合起来，以便使用gRPC对葡萄酒评论进行预测。这是一个简单的例子，还有很多需要改进的地方，但是它表明了今天的编程语言在互操作性方面继续发展。这是个好消息，因为它让我们能够利用每种语言的核心优势。感谢阅读！</p></div></div>    
</body>
</html>