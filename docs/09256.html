<html>
<head>
<title>Text-to-Speech with Application Services API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用应用服务API的文本到语音转换</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/text-to-speech-with-application-services-api-7106e1bc3381?source=collection_archive---------18-----------------------#2021-07-20">https://levelup.gitconnected.com/text-to-speech-with-application-services-api-7106e1bc3381?source=collection_archive---------18-----------------------#2021-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">[macOS]—一个简单的文本到语音转换程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10c55ccdf55e59ad3e7fd5619d36570e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oF2gDtB7VT0CV0NRo6GIw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/darkmoon_art-1664300/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3495236" rel="noopener ugc nofollow" target="_blank"> Darkmoon_Art </a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3495236" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><h1 id="de69" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="20b8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">文本到语音转换是一项非常激动人心的技术，如今它被广泛应用于各种应用中，从支持屏幕阅读器到制作营销视频，而无需真正的讲述者。</p><p id="1067" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，我解释了我如何开发一个简单的命令行应用程序，它将一个短语作为第一个参数，然后<em class="ms">把它说出来。</em></p><h1 id="d74e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">观看它的运行</h1><p id="a92f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可以在此处观看该视频，以了解该程序的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="ac20" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">源代码</h1><p id="4464" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">程序的源代码可以在<a class="ae ky" href="https://github.com/pmatsinopoulos/SpeechSynthesisExample" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="181d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">首先是一些实用函数</h1><p id="d174" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在解释代码的主要部分之前，我们想快速解释一下程序中使用的两个实用函数:</p><h2 id="33cb" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">检查错误</h2><p id="d39d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们使用的API返回类型为<code class="fe nh ni nj nk b">OSStatus</code>的结果代码。我们需要评估这段代码，以确定是否发生了错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="fda1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个<code class="fe nh ni nj nk b">CheckError()</code>功能将<code class="fe nh ni nj nk b">exit(1)</code>。这意味着如果传递给它的<code class="fe nh ni nj nk b">error</code>不同于<code class="fe nh ni nj nk b">noErr</code>，它将终止程序。然而，在退出之前，它会尝试解释<code class="fe nh ni nj nk b">error</code>值，并将其转换为对人类更友好的值。希望您将看到的错误对调试这种情况更有帮助。</p><h2 id="5424" class="mv la it bd lb mw mx dn lf my mz dp lj ma na nb ll me nc nd ln mi ne nf lp ng bi translated">在标准输出上打印消息</h2><p id="d5da" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该功能<code class="fe nh ni nj nk b">NSPrint()</code>只使用一次。但是您通常可以使用它将消息打印到标准输出中。另一方面，请注意<code class="fe nh ni nj nk b">NSLog()</code>应该用于调试消息。此外，您必须知道，它在标准错误通道中打印它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><h1 id="3b6b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">该计划的主要步骤</h1><p id="d6f9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下图显示了该程序的主要步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/70cc890c03a0ef1bcb76fbedd800294c.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*9urGI2mbofSUfNGPDRWbqQ.png"/></div></figure><p id="84f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们一个一个地看这些步骤。</p><h1 id="fa9e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">步骤1:创建一个语音通道</h1><p id="c28a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我们必须创建一个语音通道。这是如何做到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><ul class=""><li id="7d9a" class="nn no it lt b lu mn lx mo ma np me nq mi nr mm ns nt nu nv bi translated">第1行:我们定义了一个类型为<code class="fe nh ni nj nk b">SpeechChannel</code>的局部变量<code class="fe nh ni nj nk b">channel</code>。</li><li id="b55e" class="nn no it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">第3行:我们调用函数<code class="fe nh ni nj nk b">NewSpeechChannel()</code>来创建新的通道。我们作为第一个参数<code class="fe nh ni nj nk b">NULL</code>传递，以表明我们希望语音合成管理器使用系统默认语音创建一个语音通道。</li></ul><h1 id="96fb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">步骤2:设置语音完成回拨</h1><p id="1d2b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">文本到语音的合成和所生成音频的回放将在下一个步骤3中异步完成。异步意味着在另一个线程中。这意味着我们程序的主线程需要等到演讲结束。文本到语音的应用服务API允许我们定义一个<em class="ms">语音完成</em>回调，即一个在语音完成时可以调用的函数。因此，主程序将知道何时停止等待并结束。</p><p id="f3f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让两个线程(主线程和发言线程)一起工作涉及到一些线程级编程。</p><p id="03d0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们已经在函数<code class="fe nh ni nj nk b">SetSpeechDoneCallback()</code>中实现了语音回调调用的准备工作。让我们来看看细节:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><ul class=""><li id="7b2a" class="nn no it lt b lu mn lx mo ma np me nq mi nr mm ns nt nu nv bi translated">第2行:首先我们获取函数<code class="fe nh ni nj nk b">SpeechDone()</code>的地址，并将其保存到一个本地变量<code class="fe nh ni nj nk b">speechDoneAddress</code>。<code class="fe nh ni nj nk b">SpeechDone()</code>函数是我们定制的语音完成回调函数，我们将在本文后面解释它的实现。</li><li id="5060" class="nn no it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">第4–7行:然后我们使用<code class="fe nh ni nj nk b">CFNumberCreate()</code>函数将地址值转换成一个<code class="fe nh ni nj nk b">CFNumber</code>。这是必要的，因为对<code class="fe nh ni nj nk b">SetSpeechProperty()</code>的下一个调用要求我们将回调函数地址作为<code class="fe nh ni nj nk b">CFNumber</code>传递。(Ref: <a class="ae ky" href="https://medium.com/codex/core-foundation-working-with-numbers-1ef9f259f4d3" rel="noopener">这里</a>看我关于 <code class="fe nh ni nj nk b">CFNumber</code> s <a class="ae ky" href="https://medium.com/codex/core-foundation-working-with-numbers-1ef9f259f4d3" rel="noopener">的帖子)。注意，我们将<code class="fe nh ni nj nk b">CFNumberRef</code>保存到一个自定义的<code class="fe nh ni nj nk b">AppState</code>类型的数据结构中。我们这样做是因为我们将不得不在节目结束时，在回放讲话之后，释放对这个号码的引用。</a></li><li id="d350" class="nn no it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">第8–11行:我们使用应用服务API <code class="fe nh ni nj nk b">SetSpeechProperty()</code>为名为<code class="fe nh ni nj nk b">kSpeechSpeechDoneCallBack</code>的属性设置值。这就是API如何允许我们指定当语音结束时应该调用哪个函数。</li><li id="9ec6" class="nn no it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">第13行:正如我们前面所说的，我们必须让两个线程，主线程和发言线程一起工作。为了做到这一点，我们必须使用线程级编程做一些准备。这是在自定义函数<code class="fe nh ni nj nk b">InitializeSynchronizationState()</code>中完成的，接下来将对此进行解释。</li><li id="c0a2" class="nn no it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">第14行:最后，对自定义函数<code class="fe nh ni nj nk b">SetSpeechCustomData()</code>的调用允许我们定义需要从speak线程发送到回调函数的数据。这将允许speak线程不仅调用回调函数，还传递回调函数执行任务所需的一些运行时数据。接下来我们也将看到它的实现。</li></ul><p id="84bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">第二步</strong>T2】</p><p id="0f98" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该自定义函数的定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="f656" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nh ni nj nk b">appState</code>是一个内存缓冲区，我们在其中记录演讲是否结束。最初，我们假设它没有。这就是为什么我们将<code class="fe nh ni nj nk b">appState-&gt;stopSpeaking</code>的值设置为<code class="fe nh ni nj nk b">false</code>。</p><p id="8633" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还使用POSIX threads <code class="fe nh ni nj nk b">pthread</code> API来支持主线程和发言线程之间的同步。正如您可能会想到的，speak线程将调用我们的回调函数(<code class="fe nh ni nj nk b">SpeechDone()</code>)，该函数必须将<code class="fe nh ni nj nk b">appState-&gt;stopSpeaking</code>设置为<code class="fe nh ni nj nk b">true</code>。但是，在同一块内存上工作的两个线程需要线程同步编程。这就是使用<code class="fe nh ni nj nk b">pthread</code> API的目的。我们用一个<code class="fe nh ni nj nk b">mutex</code> ( <code class="fe nh ni nj nk b">appState-&gt;mutex</code>)和一个<code class="fe nh ni nj nk b">condition</code> ( <code class="fe nh ni nj nk b">appState-&gt;cond</code>)。为了让我们使用它们，我们首先需要初始化它们。这分别通过<code class="fe nh ni nj nk b">pthread_mutex_init()</code>和<code class="fe nh ni nj nk b">pthread_cond_init()</code>完成。</p><p id="7fd7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意:POSIX线程<code class="fe nh ni nj nk b">pthread</code> API超出了本文的范围。但是，这里有很多免费的内容供你升级，<a class="ae ky" href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html" rel="noopener ugc nofollow" target="_blank">比如这里的这篇文章</a>。</p><p id="7810" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">第二步</strong>T18】</p><p id="cadd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该自定义功能的实现方式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="f2ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它在内部调用应用服务API <code class="fe nh ni nj nk b">SetSpeechProperty()</code>来设置属性<code class="fe nh ni nj nk b">kSpeechRefConProperty</code>的值。该属性用于指定调用回调函数时，speak线程应该将哪些自定义数据传递给回调函数。定制数据需要被指定为一个封装成<code class="fe nh ni nj nk b">CFNumber</code>对象的内存地址。</p><p id="5847" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们会告诉语音管理器，我们想要传递的自定义数据是结构<code class="fe nh ni nj nk b">appState</code>背后的数据。因此，我们首先需要将这个内存缓冲区的内存地址转换成一个<code class="fe nh ni nj nk b">CFNumber</code>对象。这在第2–6行完成。我们已经在我们的博客文章中解释了如何将内存地址转换为T5。</p><p id="fd0c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，我们将<code class="fe nh ni nj nk b">CFNumberRef</code>保存回<code class="fe nh ni nj nk b">appState</code>缓冲区本身，特别是保存到<code class="fe nh ni nj nk b">appState-&gt;appStateRef</code>成员中。这是我们给第9行的<code class="fe nh ni nj nk b">SetSpeechProperty()</code>调用的最后一个参数。</p><p id="b484" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，<code class="fe nh ni nj nk b">channel</code>的speak线程将知道回调函数和调用它时要传递的数据。</p><h1 id="7ed1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">第三步:开始说话</h1><p id="5c07" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们准备启动speak线程，即在一个与主线程并行运行的线程中以异步方式开始说话。</p><p id="b205" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是如何做到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="21ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">触发speak线程的主要函数是来自应用服务语音合成API的<code class="fe nh ni nj nk b">SpeakCFString()</code>函数。正如您所想象的，它将使用的<code class="fe nh ni nj nk b">channel</code>和要转换成音频并输出的<code class="fe nh ni nj nk b">CFString</code>对象作为输入。它还将一些语音定制选项作为第三个参数，如果想要使用默认选项，可以给它赋值<code class="fe nh ni nj nk b">NULL</code>。</p><p id="7215" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，在函数<code class="fe nh ni nj nk b">CFStringCreateWithCString()</code>的帮助下，用户在调用程序时给出的字符串<code class="fe nh ni nj nk b">argv[1]</code>被转换为一个<code class="fe nh ni nj nk b">CFString</code>对象。这个<code class="fe nh ni nj nk b">CFString</code>对象将在程序结束之前被释放。</p><h1 id="99b2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">第四步:等待发言结束</h1><p id="a89c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上一步产生了一个单独的线程，负责将文本转换为语音，并在指定的通道中朗读出来。</p><p id="8974" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当前的主线程需要等待输出结束。这是通过以下调用完成的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="419e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是一个自定义函数，实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="9797" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个函数阻塞主线程，直到<code class="fe nh ni nj nk b">appState-&gt;stopSpeaking</code>变成<code class="fe nh ni nj nk b">true</code>，这是通过语音完成回调函数实现的(见后面)。</p><p id="9f6e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个等待的实现遵循标准的<code class="fe nh ni nj nk b">pthread</code> API模式，该模式与<code class="fe nh ni nj nk b">mutex</code>和<code class="fe nh ni nj nk b">condition</code>一起工作。这段代码的解释超出了这篇博文的范围。同时，你可能想在这里阅读<a class="ae ky" href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html" rel="noopener ugc nofollow" target="_blank">这篇关于pthreads的非常好的教程。</a></p><h1 id="9dcc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">语音完成回调函数</h1><p id="b0a2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在让我们看看语音完成回调函数的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="80ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该函数从参数<code class="fe nh ni nj nk b">refCon</code>指向的内存缓冲区中获取所需的数据。这就是为什么，我们首先将它类型化为一个<code class="fe nh ni nj nk b">AppState</code>指针。</p><p id="6a57" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在<code class="fe nh ni nj nk b">appState</code>指向同步运行时数据的情况下，我们首先锁定互斥体<code class="fe nh ni nj nk b">appState-&gt;mutex</code>，然后我们将<code class="fe nh ni nj nk b">appState-&gt;stopSpeaking</code>设置为<code class="fe nh ni nj nk b">true</code>以指示语音回放已经完成，然后我们在<code class="fe nh ni nj nk b">appState-&gt;cond</code>上发信号以告诉主线程它可以继续工作(或停止等待)。在我们离开函数之前，我们不要忘记对互斥体的访问。</p><h1 id="127e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">步骤5:释放资源</h1><p id="6f20" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，我们需要确保在结束之前释放程序保留的所有资源。下面是实现这一点的一段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><ul class=""><li id="fac6" class="nn no it lt b lu mn lx mo ma np me nq mi nr mm ns nt nu nv bi translated">第1行:我们从语音服务API调用<code class="fe nh ni nj nk b">DisposeSpeechChannel()</code>函数。我们传递<code class="fe nh ni nj nk b">channel</code>引用，这确保它释放通道背后的资源。</li><li id="4db9" class="nn no it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">第3行:我们调用自定义函数<code class="fe nh ni nj nk b">UnsetSpeechDoneCallBack()</code>。这具有以下实现:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="c4ef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">前两行调用<code class="fe nh ni nj nk b">CFRelease</code>，这是核心基础资源的标准做法。给出的参数是我们在程序初始化时创建的<code class="fe nh ni nj nk b">CFNumber</code>对象。</p><p id="61e7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">函数<code class="fe nh ni nj nk b">DestroySynchronizationState()</code>是一个自定义函数，代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mu l"/></div></figure><p id="b6df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是标准的<code class="fe nh ni nj nk b">pthread</code> API，用于销毁保留的资源，首先是互斥，然后是条件。</p><p id="15a0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">程序通过释放<code class="fe nh ni nj nk b">stringToSpeak</code>后面的资源结束，它是一个<code class="fe nh ni nj nk b">CFString</code>对象，需要通过调用<code class="fe nh ni nj nk b">CFRelease</code>来释放。</p><h1 id="0b15" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结束语</h1><p id="8b3f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们开发了一个小程序，演示了应用服务API的文本到语音合成功能。该程序将文本作为输入，并将其转换为语音，然后从标准输出设备播放出来。该程序还演示了如何同步两个线程，让一个线程等待另一个线程完成。</p><p id="c23e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们随时欢迎您的反馈。希望你能从我的帖子中学到一些东西，但是我确实从你那里学到了很多。</p><p id="72fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">附属参考:</em><a class="ae ky" href="https://speechify.com/?source=fb-for-mobile&amp;via=panagiotis" rel="noopener ugc nofollow" target="_blank"><em class="ms">speech ify</em></a><em class="ms">是一款出色的文本到语音转换应用程序，可以在许多不同的设备上运行，并将您的文档转换为您可以收听的音频。</em></p></div></div>    
</body>
</html>