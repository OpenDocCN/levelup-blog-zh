<html>
<head>
<title>How to Write Data to a File with FS2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用FS2将数据写入文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-data-to-a-file-with-fs2-b665e5d19e27?source=collection_archive---------16-----------------------#2020-10-12">https://levelup.gitconnected.com/how-to-write-data-to-a-file-with-fs2-b665e5d19e27?source=collection_archive---------16-----------------------#2020-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9de5a6fc9299500beb354e38335f0c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kp5MSxVMihc-DaKU"/></div></div></figure><p id="9ab3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上周，我试图在工作中调查死信队列(DLQ)的原始数据。我想做的功能之一是从SQS DLQ民意调查的来源，并将这些数据写入一个文件供进一步调查。我认为使用FS2将是一个很好的用例。</p><p id="90b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">FS2是一个轻量级的流库，可以帮助您完成许多数据处理功能。通常，我们希望从上游获取一些数据，并将其写入文件中，以便进行任何调查。</p><p id="ed74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想分享我们如何创建一个简单的<a class="ae kz" href="https://edward-huang.com/functional-programming/2020/01/02/wtf-is-a-type-class/" rel="noopener ugc nofollow" target="_blank">类型类</a>来用FS2将数据写入文件系统。</p><p id="bb78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将通过向文件写入任何值的最简单的用例来分解它。然后，我们将探讨如何合并队列来减少写入文件的反压力。</p><p id="1077" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从定义我们的函数开始。</p><p id="2807" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在fs2 <a class="ae kz" href="https://fs2.io/guide.html" rel="noopener ugc nofollow" target="_blank">指南</a>中，已经有一个我们希望如何写入外部文件系统的示例。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="8332" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码指定我们将从文件中读取所有内容，并对某个函数<code class="fe lg lh li lj b">fahrenheitToCelsion</code>进行过滤。然后，将其编码成一个字节，写入<code class="fe lg lh li lj b">testdata/celsius.txt</code>。</p><p id="2bf8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lg lh li lj b">through</code>将一个流合并到另一个流中，<code class="fe lg lh li lj b">text.utf8Encode</code>返回一个<code class="fe lg lh li lj b">Pipe[F[_], I+, O-]</code>，相当于<code class="fe lg lh li lj b">Stream[F,I] =&gt; Stream[F,O]</code>。</p><p id="2864" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们得到了我们的第一个问题的答案！</p><p id="a1c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以编写初始函数，接收一个上游数据，并将其写入文件。让我们创建<code class="fe lg lh li lj b">toFile(fileName:String, upstream:Stream[IO, String]): Stream[IO, Unit]</code>:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="a528" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要一个阻塞器<code class="fe lg lh li lj b">writeAll</code>，因为它是一个会<code class="fe lg lh li lj b">block</code>线程的操作。因此，cats-effect提供了一个专用的线程池<code class="fe lg lh li lj b">Blocker[IO]</code>来显式处理阻塞<a class="ae kz" href="https://typelevel.org/cats-effect/concurrency/basics.html#blocking-threads" rel="noopener ugc nofollow" target="_blank">操作</a>。</p><p id="9b4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止看起来不错。然而，我们可以将<code class="fe lg lh li lj b">toFile</code>作为<code class="fe lg lh li lj b">Pipe</code>，因为它需要<code class="fe lg lh li lj b">upstream:Stream[IO,String]</code>作为依赖项。让我们重构我们的<code class="fe lg lh li lj b">toFile</code>来返回一个<code class="fe lg lh li lj b">Pipe</code>:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="13fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们可以像这样运行这个操作:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="a663" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经有了写文件的基本操作，让我们通过使用队列来减轻写文件的反压力。</p><p id="dd33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本质上，调用者想要调用<code class="fe lg lh li lj b">write(item: String)</code>，这个函数将处理把这些项目写到一个文件中。让我们从定义函数参数开始:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="259a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们想创建一种方法，当每次调用者调用<code class="fe lg lh li lj b">write(item)</code>时，它将同时将项目写入一个队列，并且将有另一个线程同时轮询该队列中的值并将这些值写入文件。</p><p id="16f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们如何创建内部队列呢？</p><p id="4721" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，FS2有一个并发包，它实现了一个队列来帮助创建一个内部队列。</p><p id="4a1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现队列时有两个部分——入队和出队。</p><p id="4d5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据您的应用程序，有时您希望将其中一部分留给调用者来完全控制它。</p><p id="1c57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个场景中，我们将把<code class="fe lg lh li lj b">enqueue</code>封装成调用方的<code class="fe lg lh li lj b">write</code>，并通过写入文件的值来实现出列。</p><h1 id="e55d" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">从FS2队列中出列</h1><p id="f3c8" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">让我们先实现我们的<code class="fe lg lh li lj b">dequeue</code>方法。下面的代码片段相当于我们之前创建的队列和管道流的功能。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="880f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们创建一个<code class="fe lg lh li lj b">Queue[IO, Option[Either[Throwable, String]]]</code>的队列。</p><p id="217e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们通过类型为<code class="fe lg lh li lj b">None</code>的<code class="fe lg lh li lj b">enqueue1</code>创建一个资源，如果没有更多来自上游的值，该资源将关闭队列。如果你不使用<code class="fe lg lh li lj b">NoneTerminatedQueue</code>，这通常是<a class="ae kz" href="http://www.aimplicits.com/posts/2018-05-09-fs2-queue-stop/" rel="noopener ugc nofollow" target="_blank">的变通方法</a>。</p><p id="0c7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lg lh li lj b">Stream.bracket</code>内的值为下游。如果它得到一个<code class="fe lg lh li lj b">None</code>，它将终止，这意味着我们在队列中没有剩余的数量。</p><p id="f013" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lg lh li lj b">write(item:String)</code>将<code class="fe lg lh li lj b">item</code>排入内部<code class="fe lg lh li lj b">Queue</code>:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="e90d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们可以将入队和出队连接在一起，方法是将出队生成到另一个线程中，同时让调用者访问<code class="fe lg lh li lj b">WriteToFile</code>实例。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="3516" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的关键是<code class="fe lg lh li lj b">start</code>方法，它将生成一个纤程并在后台运行<code class="fe lg lh li lj b">constantPoll</code>。如果移除<code class="fe lg lh li lj b">start</code>,操作将按顺序进行。</p><p id="c3fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过让用户调用<code class="fe lg lh li lj b">WriteToFile.create</code>来重构我们的函数。用户需要提供队列和文件目的地——如下所示:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="b739" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们的<code class="fe lg lh li lj b">WriteToFile</code>函数看起来像这样:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="73cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们可以编写一个简单的程序来利用我们的实现，如下所示:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="b406" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，执行程序:</p><pre class="la lb lc ld gt mn lj mo mp aw mq bi"><span id="7eca" class="mr ll it lj b gy ms mt l mu mv">program.unsafeRunSync</span></pre><h1 id="2f1b" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="4455" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">首先，我们创建了<code class="fe lg lh li lj b">toFile</code>方法，该方法获取一个流块，将其编码成字节码，并将其写入文件。</p><p id="9f79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们试图围绕<code class="fe lg lh li lj b">WriteToFile</code>创建一个包装器，封装所有的复杂性，并在后台使用FS2原语<code class="fe lg lh li lj b">Queue[F,A]</code>来处理大量数据。呼叫者可以呼叫<code class="fe lg lh li lj b">write(item: String): F[Unit]</code>并为他们完成工作。</p><p id="a291" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们将所有东西连接起来，解开复杂的逻辑，将我们的<code class="fe lg lh li lj b">WriteToFile</code>特征连接到<code class="fe lg lh li lj b">toFile</code>，并创建了一个库，使用户能够将任何值写入外部文件。</p><p id="7432" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们利用FS2 API用一小段代码编写了一个复杂的逻辑。如果没有API的所有组合器，并发创建一个内部队列将会很有挑战性并且容易出错。</p><p id="7e5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有源代码都是<a class="ae kz" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ScalaTutorial/fs2/src/main/scala/WriteToFile" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="007d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae kz" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"/></a><strong class="kd iu">以获得关于科技职业的文章、有趣的链接和内容的通知！</strong></p><p id="1c14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以关注我，也可以在<a class="ae kz" href="https://medium.com/@edwardgunawan880" rel="noopener"> Medium </a>上关注我，获取更多类似的帖子。</p><p id="cf2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nd">原载于【https://edward-huang.com】<a class="ae kz" href="https://edward-huang.com/fs2/functional-programming/programming/scala/2020/10/11/how-to-write-data-to-a-file-with-fs2/" rel="noopener ugc nofollow" target="_blank"><em class="nd"/></a><em class="nd">。</em></em></p></div></div>    
</body>
</html>