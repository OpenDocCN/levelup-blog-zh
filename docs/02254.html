<html>
<head>
<title>A Comprehensive Guide to ‘this’ — Weird Parts of JavaScript Visually Explained (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“this”综合指南——可视化解释JavaScript的怪异部分(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/weird-parts-of-javascript-visually-explained-part-2-7d5122618d76?source=collection_archive---------10-----------------------#2020-02-29">https://levelup.gitconnected.com/weird-parts-of-javascript-visually-explained-part-2-7d5122618d76?source=collection_archive---------10-----------------------#2020-02-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/20574bed7e151c5ccf295cc6284219d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aKpttrS3Z3rN4epx5mhrvg.jpeg"/></div></div></figure><p id="ea07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是本系列的第2部分，假设您已经阅读了第1部分。如果您还没有看过，请点击这里查看第1部分:</p><div class="kw kx gp gr ky kz"><a href="https://medium.com/swlh/weird-parts-of-javascript-visually-explained-part-1-25efb0eea153" rel="noopener follow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">JavaScript的怪异部分:可视化解释(第1部分)</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">深入探究JavaScript的古怪之处</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">medium.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="cac6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们对什么是词法环境、执行上下文是如何创建的、作用域链是如何工作的有了相当好的理解，我们现在可以在现有知识的基础上进行构建。</p><h1 id="5c10" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">这</h1><p id="b8a4" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">正如我们前面看到的，<code class="fe mr ms mt mu b"><strong class="ka ir">this</strong></code> <strong class="ka ir">是一个执行上下文</strong> <em class="mv">的属性。</em></p><p id="06e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在非严格模式下，<code class="fe mr ms mt mu b">this</code>的值总是<strong class="ka ir">一个对象，</strong>而在严格模式下，它可以是<strong class="ka ir">任何值</strong>。</p><p id="ba9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不知道<strong class="ka ir">严格模式👨‍🔧</strong>，它增加了某些限制，使JS代码更安全，并可能允许JavaScript执行某些优化。本系列后面将详细讨论严格模式。</p><p id="b327" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看<code class="fe mr ms mt mu b">this</code>在几乎所有可能的场景中的值是多少，这样你就永远不必去猜测了💩</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="5277" class="lo lp iq bd lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh nh mj mk ml bi translated">this ===全局对象🌐</h1><h2 id="ab2f" class="ni lp iq bd lq nj nk dn lu nl nm dp ly kj nn no mc kn np nq mg kr nr ns mk nt bi translated">在全局执行上下文中🌻</h2><p id="d6f5" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated"><code class="fe mr ms mt mu b">this</code>的值在全局执行上下文中，总是<code class="fe mr ms mt mu b">global object</code>(浏览器中的窗口)，无论是否处于严格模式。</p><h2 id="70e5" class="ni lp iq bd lq nj nk dn lu nl nm dp ly kj nn no mc kn np nq mg kr nr ns mk nt bi translated">在被直接调用的函数中🌷</h2><p id="be22" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">如果一个函数被直接调用而不是作为对象的方法，那么那个函数里面的<code class="fe mr ms mt mu b">this</code>的值在<strong class="ka ir">非严格</strong>模式下是一个<code class="fe mr ms mt mu b">global object</code> <strong class="ka ir"> </strong>，在严格模式下是一个<code class="fe mr ms mt mu b">undefined</code> <strong class="ka ir">。</strong></p><p id="1210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们举个例子:</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/e7494aa5a3e4593a14e4374e77803847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JssHo2zmD4YGWS8vIMPFtw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">非严格模式示例</figcaption></figure><p id="85b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mr ms mt mu b">window</code>如果运行此代码，将在控制台中记录四次。</p><p id="8151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然前两个日志可能看起来很直观，但另外两个一开始可能看起来很奇怪。让我们逐一分析，看看发生了什么。</p><p id="db2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第一个日志</strong>是<code class="fe mr ms mt mu b">window</code> <strong class="ka ir"> </strong>因为，在全局执行上下文中，它的值总是一个全局对象，在浏览器的情况下是窗口对象</p><p id="b27e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第二个日志</strong>是<code class="fe mr ms mt mu b">window</code> <strong class="ka ir"> </strong>因为<strong class="ka ir"> </strong>函数<code class="fe mr ms mt mu b">a()</code>被直接调用，而不是作为某个对象的方法</p><p id="81d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第三个日志</strong>是<code class="fe mr ms mt mu b">window</code> <strong class="ka ir"> </strong>因为函数<code class="fe mr ms mt mu b">f()</code>的定义来自<code class="fe mr ms mt mu b">someObject</code>的<code class="fe mr ms mt mu b">someMethod</code>，函数调用是直接完成的，而不是作为某个对象的某个方法。</p><p id="ab0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第四个日志</strong>是<strong class="ka ir"> </strong> <code class="fe mr ms mt mu b">window</code> <strong class="ka ir"> </strong>因为，虽然我们调用<code class="fe mr ms mt mu b">someMethod2</code>作为<code class="fe mr ms mt mu b">someObject</code>的方法，但是实际的函数调用<code class="fe mr ms mt mu b">x()</code>是作为直接调用而不是作为对象的一部分来完成的。<strong class="ka ir">这经常被描述为JavaScript语言</strong>中的一个错误，但是如果你知道<code class="fe mr ms mt mu b">this</code>如何工作的基本逻辑，这是合乎逻辑的。如果这个结果看起来很奇怪，有几个解决方法，其中一个将在本文后面讨论(使用箭头函数代替函数语句)</p><p id="4d31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是在严格模式下运行的相同代码:</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/b8e635856e8bd90974f01856d9b9ac92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvoIe26H8DaJlJbuDMNi4Q.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">严格模式</figcaption></figure><h2 id="473a" class="ni lp iq bd lq nj nk dn lu nl nm dp ly kj nn no mc kn np nq mg kr nr ns mk nt bi translated">在生活中🌺</h2><p id="9a2f" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">在非严格模式下，无论使用函数语句还是箭头函数，IIFE内部的值总是全局对象。</p><p id="c60e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不知道什么是生活，这有点像定义一个函数，同时又调用它。我将在本系列的后面详细解释。</p><blockquote class="od oe of"><p id="5465" class="jy jz mv ka b kb kc kd ke kf kg kh ki og kk kl km oh ko kp kq oi ks kt ku kv ij bi translated">您可能已经注意到我不使用分号，但是我在下面的代码中使用了它，因为在编写IIFEs时不使用分号会使语法分析器混乱并抛出错误。这将在后面的系列中解释</p></blockquote><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/98dc7ee2fefab2b0a9c06b53d1958bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37L_dUn9V4Y1BUBar5xODw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">非严格模式</figcaption></figure><p id="0724" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<strong class="ka ir">严格模式下，</strong>带有<strong class="ka ir">函数语句</strong>的life中该值为<strong class="ka ir">未定义，</strong>而在带有<strong class="ka ir">箭头函数的life中，</strong>仍为<strong class="ka ir">全局对象。</strong></p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/92258d753cd0e826af186ada9058d795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znhVAvqhohWT-EZj1JAL0Q.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">严格模式</figcaption></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="ed45" class="lo lp iq bd lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh nh mj mk ml bi translated">this ===新实例🌟</h1><p id="6c17" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这个值是<strong class="ka ir">构造函数</strong>中的<strong class="ka ir">新对象实例</strong>，在严格和非严格模式下都用<code class="fe mr ms mt mu b">new</code>关键字调用</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/0526509143e7068132db858facbfedd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJrG2fywZHVg9SRPcJxILQ.png"/></div></div></figure><blockquote class="od oe of"><p id="0422" class="jy jz mv ka b kb kc kd ke kf kg kh ki og kk kl km oh ko kp kq oi ks kt ku kv ij bi translated">好吧，刚刚发生了什么？</p></blockquote><p id="38c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关键字<code class="fe mr ms mt mu b">new</code>创建一个新的空对象，并使变量指向新创建的对象。然后，它执行构造函数并返回新创建的对象，除非构造函数返回某些内容。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="a6d7" class="lo lp iq bd lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh nh mj mk ml bi translated">this ===调用函数⚡的对象</h1><p id="ffe0" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">用某个对象调用的函数内的<code class="fe mr ms mt mu b">this</code>的值就是对象本身。函数的定义来自哪里并不重要。这对于严格和非严格模式都是一样的。</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/0628bd3bf8533dc74c076bcc4b802562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1zOtSdTX3BDCqZq1B4naBw.png"/></div></div></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="9b38" class="lo lp iq bd lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh nh mj mk ml bi translated">这个===和外面一样🌞</h1><p id="b279" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这发生在我们使用箭头函数的时候。<strong class="ka ir">箭头函数</strong>内部没有自己的this值，所以该值不会改变，在函数外部保持不变。这对于严格和非严格模式都是一样的。</p><p id="6fc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">arrow函数的这种行为是确保对象的方法中的所有函数都有指向该对象而不是全局对象的值<code class="fe mr ms mt mu b">this</code>的最佳变通方法之一。这在下面通过使用正常功能<code class="fe mr ms mt mu b">x()</code>和箭头功能<code class="fe mr ms mt mu b">y()</code>来说明</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/8025d1f49068d6f06eb3b282847ee5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcKi2orwSeD7zVi05E_XYQ.png"/></div></div></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="4350" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哇，这是很多信息，让我们快速回顾一下:😴</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/1889a78be24b76cb82826728cd8f4430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlwwatZDlXqfAimXK1hvhw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">此表的值</figcaption></figure><p id="bd09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">起初这可能看起来让人不知所措，但是随着你不断使用<code class="fe mr ms mt mu b">this</code>，它变得非常直观。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="e7fc" class="lo lp iq bd lq lr nd lt lu lv ne lx ly lz nf mb mc md ng mf mg mh nh mj mk ml bi translated">设置此☕的自定义值</h1><p id="0bab" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">有时我们想为某个函数设置自定义值。这可以通过使用<code class="fe mr ms mt mu b">call()</code>、<code class="fe mr ms mt mu b">bind()</code>和<code class="fe mr ms mt mu b">apply()</code>来完成。</p><blockquote class="od oe of"><p id="68a0" class="jy jz mv ka b kb kc kd ke kf kg kh ki og kk kl km oh ko kp kq oi ks kt ku kv ij bi translated">注意:箭头功能内 <code class="fe mr ms mt mu b"><em class="iq">this</em></code> <strong class="ka ir">的<strong class="ka ir">值不可更改。</strong>使用<code class="fe mr ms mt mu b"><em class="iq">call()</em></code>、<code class="fe mr ms mt mu b"><em class="iq">bind()</em></code>、<em class="iq">、</em>和<code class="fe mr ms mt mu b"><em class="iq">apply()</em></code>中的任何一个，在非严格模式下不做任何事情，在严格模式下给出错误。</strong></p></blockquote><h2 id="bad3" class="ni lp iq bd lq nj nk dn lu nl nm dp ly kj nn no mc kn np nq mg kr nr ns mk nt bi translated">绑定( )🥨</h2><p id="9098" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated"><code class="fe mr ms mt mu b">bind</code>创建一个函数的副本，该函数的给定值设置为<code class="fe mr ms mt mu b">this</code>的值，并返回该函数。</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/1b5390fe6989a1c651009e7ab76b6ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjVjMHgh97TBR4A6wnhA0w.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">绑定()</figcaption></figure><h2 id="aff8" class="ni lp iq bd lq nj nk dn lu nl nm dp ly kj nn no mc kn np nq mg kr nr ns mk nt bi translated">调用( )😏</h2><p id="bcac" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated"><code class="fe mr ms mt mu b">call</code>调用函数，第一个参数设置为<code class="fe mr ms mt mu b">this</code>的值，其余参数用作普通参数。</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/3f94367879cce97f5ca75461dc79d221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*seZrTwh8EuvUCvvrL_MWaw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">调用( )</figcaption></figure><h2 id="2752" class="ni lp iq bd lq nj nk dn lu nl nm dp ly kj nn no mc kn np nq mg kr nr ns mk nt bi translated">应用( )😙</h2><p id="13f4" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">它与<code class="fe mr ms mt mu b">call()</code>相同，唯一的区别是它只需要两个参数。第一个用于设置<code class="fe mr ms mt mu b">this</code>的值，第二个用作参数数组。</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/29bae2d4aba0dc9f9286b91fd51b61dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMVdB4dLp_nG5WMBtT-0mw.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">应用( )</figcaption></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="71df" class="ni lp iq bd lq nj nk dn lu nl nm dp ly kj nn no mc kn np nq mg kr nr ns mk nt bi translated">奖励:函数currying with bind()👏</h2><p id="e70e" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">函数currying是一种使用一些预设参数创建函数副本的机制。如果您正在创建一些数学密集型库，这将非常有用</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/6e91a0c13cd3421a0ec63c9a6cae4c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PazllcF7XeEfC7FihNoBxQ.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">使用绑定的函数</figcaption></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="596e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是第2部分🤗请关注本系列的未来更新。</p><p id="9080" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读👏</p></div></div>    
</body>
</html>