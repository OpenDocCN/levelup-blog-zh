<html>
<head>
<title>Python Command-Line Project — Architecture Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python命令行项目—架构设计</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-command-line-project-architecture-design-2c0adfed4da8?source=collection_archive---------4-----------------------#2020-04-24">https://levelup.gitconnected.com/python-command-line-project-architecture-design-2c0adfed4da8?source=collection_archive---------4-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/abd198f920f18121d3d9e83c077b253d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lMKy6Jxebk86Arwd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@lanceanderson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">兰斯·安德森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="5d06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用Python设计你的命令行应用程序通常会很棘手，因为我们没有像Java或Ruby那样严格的架构设计概念。</p><p id="e493" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们将讨论一种可能的项目结构，它可以帮助您构建一个定义良好、组织有序的命令行实用程序。</p><h1 id="0836" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">骨骼</h1><p id="122e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，让我们在父目录<strong class="ki iu">根目录</strong>下创建一个事实上的python项目存储库。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e4a9" class="mq lf it mm b gy mr ms l mt mu">/root<br/>├── /app<br/>├── .gitignore<br/>├── MANIFEST.in<br/>├── Dockerfile<br/>├── LICENSE.txt<br/>├── README.md<br/>└── setup.py</span></pre><p id="4b0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加一个名为<strong class="ki iu"> <em class="mv"> app </em> </strong> <em class="mv">的目录。这个目录将保存我们所有的代码。我们将更进一步，把我们的代码放在不同的子目录下，我们将构建一个Python模块方法。</em></p><ul class=""><li id="c49a" class="mw mx it ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">一个目录包含所有公开的代码</li><li id="ac4f" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">一个目录包含所有实用程序、助手方法</li><li id="8584" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">一个包含所有配置的目录</li><li id="9bc9" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">一个包含所有模型类的目录(<em class="mv">我们将在后面讨论</em>)</li></ul><h2 id="3712" class="mq lf it bd lg nk nl dn lk nm nn dp lo kr no np ls kv nq nr lw kz ns nt ma nu bi translated">/ <strong class="ak"> app </strong>目录</h2><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7bb9" class="mq lf it mm b gy mr ms l mt mu">root<br/>├── /app<br/>│   ├── /bin<br/>│   │   └── /resources<br/>│   ├── /lib<br/>│   │   └── /resources<br/>│   └── /config</span></pre><p id="9afb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们添加了<strong class="ki iu"> <em class="mv"> app/bin，</em> </strong>将托管所有脚本和方法。当我们运行python程序时会调用这个目录。我们可能<strong class="ki iu">不</strong>想让我们的业务逻辑与这部分分开——因为这可能成为我们的主要活动场所。这也可能包含参数解析、条件逻辑和退出策略。</p><p id="633f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加了<strong class="ki iu"> <em class="mv"> app/lib </em> </strong>，它将托管所有不直接作为业务成果的脚本，但有助于开发人员在整个项目中重用。这些文件可以是数据库连接器、<em class="mv">记录器</em>、<em class="mv"> sftp </em>实用程序等。</p><h2 id="c459" class="mq lf it bd lg nk nl dn lk nm nn dp lo kr no np ls kv nq nr lw kz ns nt ma nu bi translated">非python资源</h2><p id="f8c3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在上面的结构中，我们添加了<strong class="ki iu"> <em class="mv"> resources </em> </strong>目录，该目录将只保存非python文件，这些文件可能会在其父目录中的某些代码中使用。我们不想添加一个<em class="mv"> __init__。py </em>在这里，因为这个地方不会有任何python代码。然而，我们需要告诉我们的构建工具包含这些目录。我们可以将它们添加到<strong class="ki iu"> <em class="mv"> MANIFEST.in </em> </strong>文件中。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="889e" class="mq lf it mm b gy mr ms l mt mu"># MANIFEST.in</span><span id="c77e" class="mq lf it mm b gy nv ms l mt mu">include app/bin/resources/*<br/>include app/lib/resources/*</span></pre><p id="2130" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，每当我们构建一个项目的发行版时，<strong class="ki iu"> <em class="mv"> resources </em> </strong>目录中的项目将被原样包含。</p><h1 id="22b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参数解析</h1><p id="bebc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于参数解析，我们需要做的第一件事是确定我们的入口点。这可以使用我们的<em class="mv"> setup.py </em>来完成。下面的官方文件可以帮助你。</p><p id="30ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.python.org/3/distutils/setupscript.html" rel="noopener ugc nofollow" target="_blank">编写安装脚本—docs.python.org</a></p><p id="3fb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在假设文件<em class="mv"> app/bin/app.py </em>是你的一个入口点。我们继续写一些像下面这样的行。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="02dd" class="mq lf it mm b gy mr ms l mt mu"># MANIFEST.in</span><span id="a124" class="mq lf it mm b gy nv ms l mt mu"><em class="mv">import</em> argparse<br/>..<br/>..<br/>Your code<br/>..<br/>..<br/></span><span id="d2c0" class="mq lf it mm b gy nv ms l mt mu">def main():<br/>  parser = argparse.ArgumentParser(description='Arguments being passed to the program')<br/>  parser.add_argument('--partner', '-p', required=False, default='paypal', help='Partner name')<br/>  args = parser.parse_args()<br/>  print(f'partner is {args.partner.lower()}')</span><span id="922e" class="mq lf it mm b gy nv ms l mt mu"><em class="mv">if</em> __name__ == "__main__":<br/>  main()</span></pre><p id="e175" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你在上面看到的，我们保留了<em class="mv"> main() </em>中的所有内容，并没有过多使用<em class="mv">_ _ name _ _ = _ _ main _ _</em>部分。这里有两个好处:</p><ul class=""><li id="b3cb" class="mw mx it ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">事情保持清晰和紧凑</li><li id="ec8e" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">代码行为没有歧义，无论它是作为python包运行还是独立运行。</li></ul><p id="f288" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果你有以下情况，</p><ul class=""><li id="999a" class="mw mx it ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">你的项目会越来越大</li><li id="2a75" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">你会有很多切入点</li><li id="acaa" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">你的程序有复杂的参数</li></ul><p id="8d45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这些情况下，拥有一个专用于参数解析的单独文件是一种更合适的方式。它给了你在任何需要的地方调用模块的灵活性。然后你必须想出你的策略来在项目间共享你的参数变量，也许你可以考虑将它们设置为一个<em class="mv">环境变量</em>。</p><h1 id="dbb0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">模型和用户类别</h1><p id="13ec" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在用一堆Python模型类进行面向对象编程时，您可以选择两条路径中的任何一条。</p><ul class=""><li id="c6fb" class="mw mx it ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">创建一个目录<strong class="ki iu"> <em class="mv"> app/models </em> </strong>把你的文件放在那里。此外，您可以通过创建更多的嵌套目录来打破它。当你有很多这样的类时，这是很有帮助的。</li><li id="08db" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">放在<strong class="ki iu"> <em class="mv"> app/lib </em> </strong>目录下。正如我们之前所讨论的，该模块设计用于<em class="mv">这样的原因</em>仅<em class="mv">。</em>当你有几个类并且已经正确应用了OOP概念的时候，这可能是有帮助的。</li></ul><h1 id="b6bb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用__init__。巴拉圭</h1><p id="d95f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们常常低估了<em class="mv"> __init__。py </em>文件。这个文件不仅初始化python中的模块，还充当该模块的入口点。我们可以把任何预处理的东西放在这个文件下。</p><p id="d660" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们假设我们有3个类写在3个文件中，它们位于<strong class="ki iu"> <em class="mv"> app/lib </em> </strong> <em class="mv">下。</em></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c65c" class="mq lf it mm b gy mr ms l mt mu"># app/lib/myclass1.py</span><span id="0a8b" class="mq lf it mm b gy nv ms l mt mu">class MyCustomClass1(object):<br/>..<br/>..</span><span id="3ff3" class="mq lf it mm b gy nv ms l mt mu"># app/lib/myclass2.py</span><span id="8a03" class="mq lf it mm b gy nv ms l mt mu">class MyCustomClass2(object):<br/>..<br/>..</span><span id="9ab1" class="mq lf it mm b gy nv ms l mt mu"># app/lib/mylogger.py</span><span id="dc90" class="mq lf it mm b gy nv ms l mt mu">class Logger(object):<br/>..<br/>..</span></pre><p id="b0fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，为了使用/导入任何类，用户不仅需要知道它在<strong class="ki iu"> <em class="mv"> app/lib </em> </strong>中，还需要知道要查找哪个文件。相反，我们可以将所有这样的引用放在<em class="mv"> __init__.py. </em></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a848" class="mq lf it mm b gy mr ms l mt mu"># __init__.py</span><span id="dff2" class="mq lf it mm b gy nv ms l mt mu">from myclass1 import MyCustomClass1<br/>from myclass2 import MyCustomClass2<br/>from mylogger import Logger</span></pre><p id="4f84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在用户可以从<strong class="ki iu"> <em class="mv"> app/lib </em> </strong>中导入需要的类目录，不需要再去找了。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4c4a" class="mq lf it mm b gy mr ms l mt mu"># script1.py</span><span id="be6a" class="mq lf it mm b gy nv ms l mt mu">from app.lib import Logger, MyCustomClass1, MyCustomClass2</span></pre><h1 id="d610" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">非Pyhton人工制品</h1><h2 id="baaf" class="mq lf it bd lg nk nl dn lk nm nn dp lo kr no np ls kv nq nr lw kz ns nt ma nu bi translated">键</h2><p id="1f90" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们有时需要在代码中使用各种公钥。如果是这种情况，您可以在<strong class="ki iu">根</strong>级别创建一个目录作为<strong class="ki iu"> <em class="mv">密钥</em> </strong>并将所有公钥保存在该目录下。</p><blockquote class="nw nx ny"><p id="f764" class="kg kh mv ki b kj kk kl km kn ko kp kq nz ks kt ku oa kw kx ky ob la lb lc ld im bi translated">将私钥放在存储库中会带来威胁；你应该想出自己处理这种情况的方法。</p></blockquote><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8547" class="mq lf it mm b gy mr ms l mt mu">/root<br/>├── /app<br/>├── <strong class="mm iu">/keys</strong><br/>├── .gitignore<br/>├── MANIFEST.in<br/>├── Dockerfile<br/>├── LICENSE.txt<br/>├── README.md<br/>└── setup.py</span></pre><blockquote class="nw nx ny"><p id="68ff" class="kg kh mv ki b kj kk kl km kn ko kp kq nz ks kt ku oa kw kx ky ob la lb lc ld im bi translated">请确保在MANIFEST.in文件中包含该目录。</p></blockquote><h2 id="6cce" class="mq lf it bd lg nk nl dn lk nm nn dp lo kr no np ls kv nq nr lw kz ns nt ma nu bi translated">日志文件</h2><p id="3b0f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我希望你基本上会使用任何<strong class="ki iu"> logger </strong>框架来记录对你重要的事情。通常，我们将日志捕获到文件中，并将其打印到标准输出中。在这种情况下，我们有两条路可走。</p><ul class=""><li id="d46c" class="mw mx it ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated">您有带循环的时间戳日志文件。他们很快就会成为一群。在根目录下创建一个名为<strong class="ki iu"> <em class="mv"> logs </em> </strong>的目录，在这里保存你的时间戳日志文件。</li><li id="008f" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated">每次应用程序运行时，您都有一个重新创建的日志文件。将文件目录放在<strong class="ki iu"> <em class="mv">根目录下</em> </strong>。</li></ul></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="89a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个<a class="ae kf" href="https://github.com/arghajit/init-python" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到代码。</p><p id="7b00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前就这些。我希望这有所帮助。让我们知道你在遵循什么样的架构设计。</p><p id="3db9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！</p></div></div>    
</body>
</html>