<html>
<head>
<title>OOP: When to use `abstract` base class vs `interface`</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OOP:何时使用“抽象”基类与“接口”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oop-when-to-use-abstract-base-class-vs-interface-41509a43cd7?source=collection_archive---------9-----------------------#2020-05-24">https://levelup.gitconnected.com/oop-when-to-use-abstract-base-class-vs-interface-41509a43cd7?source=collection_archive---------9-----------------------#2020-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个定义一个对象的特征，另一个建立这个对象能做什么的契约</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5c6a75d03e561f0d96e104e08304d54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qs3z6_zST3Du2Qma"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">阿列克斯·马林科维奇在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="fb5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在设计类的架构时，会出现一些问题:</p><ul class=""><li id="fb58" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">它的<strong class="ky ir">实例</strong>将如何被<strong class="ky ir">使用</strong></li><li id="131a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">发现<strong class="ky ir">公共属性</strong>和<strong class="ky ir">模式</strong></li><li id="7cc8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">预见这个类在未来将如何扩展</li></ul><p id="a3a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过使用<strong class="ky ir">抽象基类</strong>和<strong class="ky ir">接口</strong>来利用您的实现。通常这两者会引起很多混淆，因为它们是相似的，然而，它们实际上有不同的实现。</p><p id="8bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们找出何时使用每一个。为此，我们将看到使用不同编程语言(Kotlin、TypeScript、Java)的例子，但是理论适用于所有这些语言。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="9baa" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">什么是抽象类？</h2><p id="0902" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">当你想让其他类(或其他抽象类)扩展<strong class="ky ir">公共方法或属性时，可以将一个类声明为<strong class="ky ir">抽象</strong>。</strong></p><p id="179b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个抽象类定义一个<strong class="ky ir">抽象方法</strong>时，这个方法<strong class="ky ir">必须被扩展子类</strong>覆盖——除非这个抽象类被另一个抽象类扩展，在这种情况下，你将得到一个级联继承。</p><p id="9c18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些在抽象类中定义的抽象方法，被创建时只有它们的签名。此时它们不应该有主体，主体将在被覆盖的方法中定义。</p><p id="efae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样地，<strong class="ky ir">你可以定义具体的(非抽象的)方法，这些方法将被扩展类继承。</strong></p><p id="714a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一下这个:</p><ul class=""><li id="bf8e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">X教授是一个<strong class="ky ir">教授</strong>，他也是一个<em class="nl">延伸</em>的<strong class="ky ir">人</strong></li><li id="b81c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">所有的<strong class="ky ir">教授</strong>都会<strong class="ky ir">用特定的方式跟</strong>打招呼:“<em class="nl">嗨，我是……</em>教授。”</li><li id="0e80" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">所有的<strong class="ky ir">人</strong>都会<strong class="ky ir">以同样的方式</strong>说再见:“<em class="nl">再见！</em>”。</li><li id="d7a5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">每个<strong class="ky ir">人</strong>都有一个<strong class="ky ir">效忠</strong>，他们可以用同样的方式表示效忠:“<em class="nl">万岁…！</em>”。</li></ul><p id="f2e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用面向对象编程你会怎么做？首先，让我们试试<strong class="ky ir">科特林</strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Kotlin中抽象基类的示例</figcaption></figure><p id="2f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前面脚本的输出将是:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="9da3" class="mn mo iq np b gy nt nu l nv nw">Starting up...<br/>Hello, you can call me Doctor Doom.<br/>Long live Sorcerers Supreme!<br/>Hello, you can call me Professor X.<br/>Long live X-Men!<br/>The end.</span></pre><p id="6624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们所做的是创建一个抽象类<strong class="ky ir"> Person </strong>，这个类有两个具体的方法(<strong class="ky ir"> showLoyalty </strong>和<strong class="ky ir"> sayGoodbye </strong>)。这两个将被继承到任何扩展这个抽象。</p><p id="ca36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还有一个抽象变量(<strong class="ky ir">忠诚度</strong>)。这个变量必须被两个扩展<strong class="ky ir"> Person </strong>的类覆盖。这些类(<strong class="ky ir"> Professor </strong>，<strong class="ky ir"> Doctor </strong>)在它们的构造函数中这样做。<strong class="ky ir">人</strong>的<strong class="ky ir">名</strong>也在构造函数中定义。</p><p id="6794" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们看到每个类都覆盖了抽象类中定义的抽象方法<strong class="ky ir"> intro </strong>。如果没有，它会抛出一个类似于下面的错误:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="9786" class="mn mo iq np b gy nt nu l nv nw">Class ‘Professor’ is not abstract and does not implement abstract base class member public abstract fun intro(): Unit defined in Person</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="f642" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">什么是接口？</h2><p id="1d8c" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">另一方面，一个<strong class="ky ir">接口</strong>传统上被称为一个<strong class="ky ir">契约</strong>，这个契约将被强制<strong class="ky ir">到任何实现它们的类。</strong></p><p id="b033" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本质上，一个接口将向实现类的用户展示这个类能够做什么。相反，一个抽象的定义<strong class="ky ir">是一种平等关系</strong>:一个<strong class="ky ir">医生</strong> <em class="nl">是一个</em> <strong class="ky ir">人</strong>。</p><p id="bc7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要注意，<strong class="ky ir">接口没有定义要实现的方法</strong>的主体。</p><p id="bdb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能注意到的另一件事是，传统上，接口是以“<em class="nl">-able”</em>后缀命名的。这不是强制性的，但有助于确定他们的目的。其他程序员倾向于添加“<em class="nl">I-”</em>作为前缀，例如一个接口<strong class="ky ir">克隆</strong>将最终被称为IClonable——个人认为这有点矫枉过正，但是，各有各的！</p><p id="751e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，观察下面的Java代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Java中的接口示例。</figcaption></figure><p id="4a4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前面的程序将在终端中打印出如下内容:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="99b4" class="mn mo iq np b gy nt nu l nv nw">Abilities check...<br/>Nightcrawler teletransported to X-Mansion.<br/>Storm started to fly.<br/>Suddenly we see 4 clones of Multiple Man.<br/>End of exercise.</span></pre><p id="844d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里实例化的类是<strong class="ky ir">学生</strong>，实现了接口<strong class="ky ir">突变体</strong>。变种人定义了3种方法:<strong class="ky ir">瞬移</strong>，<strong class="ky ir">飞翔，</strong>和<strong class="ky ir">自复制</strong>。这意味着这3个方法必须在<strong class="ky ir">学生</strong>类中实现。否则，您会看到如下错误:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="4201" class="mn mo iq np b gy nt nu l nv nw">Main.java:7: error: Student is not abstract and does not override abstract method selfDuplicate(int) in Mutant</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="a8a7" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">把所有的放在一起</h2><p id="3de1" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">面向对象编程的一个很好的特性是能够将接口与抽象类混合起来，使你的类完全符合你的需要。</p><p id="0d61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的TypeScript代码中，注意类的定义为<code class="fe nx ny nz np b">class Male extends Person implements Mutantable</code>。现在，这是非常强大的，因为你可以定义这个<strong class="ky ir">男</strong>到<em class="nl">是一个</em> <strong class="ky ir">人</strong>并且<em class="nl">拥有一个<strong class="ky ir">突变</strong>能人的能力</em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">TypeScript上的抽象和接口示例。</figcaption></figure><p id="aca0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前面的代码运行时将产生以下输出:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="2a5c" class="mn mo iq np b gy nt nu l nv nw">An X-Men Short Story<br/>A new X-Men is about to be born...<br/>Wolverine is born.<br/>Checking Wolverine's abilities:<br/>Regeneration: true<br/>Fly: false<br/>Wolverine met Kayla.<br/>Kayla is now Wolverine's girlfriend.<br/>The end.</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="31c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，本文的主要观点是:</p><blockquote class="oa ob oc"><p id="f2dc" class="kw kx nl ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated">一个接口将定义<strong class="ky ir">这个类能够做什么</strong>:一个<strong class="ky ir">医生</strong>可以<strong class="ky ir">操作()</strong></p><p id="a136" class="kw kx nl ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated">一个抽象定义<strong class="ky ir">一个平等关系</strong>:一个<strong class="ky ir">医生</strong> <em class="iq">是一个</em> <strong class="ky ir">人</strong>。</p></blockquote></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="e43d" class="og mo iq bd mp oh oi oj ms ok ol om mv jw on jx my jz oo ka nb kc op kd ne oq bi translated">感谢阅读！</h1><p id="8bbb" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在<a class="ae kv" href="https://www.linkedin.com/in/pablo-del-valle" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kv" href="https://medium.com/@pablo.delvalle.cr" rel="noopener"> Medium </a>、<a class="ae kv" href="https://github.com/delvalle" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找我。</p></div></div>    
</body>
</html>