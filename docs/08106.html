<html>
<head>
<title>Site Reliability using AWS Fargate with CDK and Gatling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Fargate和CDK和加特林的站点可靠性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/site-reliability-using-aws-fargate-with-cdk-and-gatling-18d340a43588?source=collection_archive---------6-----------------------#2021-04-03">https://levelup.gitconnected.com/site-reliability-using-aws-fargate-with-cdk-and-gatling-18d340a43588?source=collection_archive---------6-----------------------#2021-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">站点的可靠性需要持续监控，以确保系统性能不会偏离非功能性要求，因为系统性能可能会受到新版本或数据增长的影响。</p><p id="cc74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">衡量性能的一种方法是使用一个能够模拟关键业务活动的客户机，并能够衡量关键指标，如响应时间或每秒请求数。Gatling是常用于此目的的流行库之一。</p><p id="60d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://gatling.io" rel="noopener ugc nofollow" target="_blank"> Gatling </a>是一个SCALA库，它利用SCALA灵活的语法来提供负载测试领域特定语言(DSL ),以及性能测量的关键指标。Gatling将AKKA用于分布式加载代理，与普通Java线程相比，它提供了更好的资源利用率。</p><p id="bba0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文考察了与测试相关的三个重要概念:可靠性、可重复性和再现性。然后，它向您展示了如何使用<code class="fe km kn ko kp b">Gatling</code>来建立一个使用<code class="fe km kn ko kp b">AWS’s Cloud Development Kit</code> (CDK)的性能测试基础设施，并为您提供了在对您自己的系统运行性能测试时需要考虑的一些要点。</p><h1 id="fd94" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">测试的可靠性</h1><p id="305c" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在任何监测和测量中，我们都需要可以信任的真正积极的结果。例如，当测试工具向web服务报告连接性问题时，我们希望结果是web服务不可用的<em class="lt">真肯定</em>，而不是由于错误配置运行该工具的坏主机而导致的<em class="lt">假肯定</em> <strong class="jp ir"> </strong>。</p><p id="7b7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，利用无服务器架构来运行测试工具对于确保工具执行的可靠性是理想的。</p><h1 id="64ff" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">测试的再现性</h1><p id="0172" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">当从测试中报告问题时，我们希望能够复制结果以便于故障排除，或者试验不同的因素以减少任何不确定性。例如，当QA团队发现测试工具报告的问题时，开发团队可以复制相同的结果来解决报告的相同问题。</p><p id="59bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自动化构建和容器化测试框架允许我们冻结代码变更和预定义测试框架的库依赖。使用文档化的映像，可以在团队和环境中重复相同的测试。</p><h1 id="8aba" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">测试的可重复性</h1><p id="9f92" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">我们希望在事件触发时(比如在部署新版本之前)或者在时钟事件触发时(比如每个月末)重复运行测试，以根据服务级别目标衡量系统性能。</p><p id="307d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了一遍又一遍地运行测试，我们需要自动构建容器映像以实现可再现性，并在触发时启动基础设施，在不需要时拆除，并在下一次触发时重复。</p><p id="00f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一目标，<a class="ae kl" href="https://aws.amazon.com/cdk/" rel="noopener ugc nofollow" target="_blank"> AWS云开发套件(AWS CDK) </a>提供了一些功能，我们可以利用这些功能来构建docker映像并提供必要的基础设施，以实现测试的可靠性。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="1c62" class="kq kr iq bd ks kt mb kv kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln bi translated">使用AWS云开发工具包(AWS CDK)创建AWS资源</h1><p id="01a8" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在https://github.com/kangks/distributed_gatling可以找到CDK和加特林的仓库。</p><p id="57c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">存储库的结构由两个主文件夹组成，<code class="fe km kn ko kp b">cdk/</code>和<code class="fe km kn ko kp b">gatling/</code>。</p><p id="9305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">cdk/bin/app.ts</code>是用打字稿写的CDK应用程序。当用命令<code class="fe km kn ko kp b">cdk deploy ecsLoadTestTask</code>调用时，它将从<code class="fe km kn ko kp b">cdk/lib/ecsTaskStack.ts</code>创建堆栈<code class="fe km kn ko kp b">DistributedECSTaskStack</code>。</p><p id="18c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">堆栈使用<a class="ae kl" href="https://docs.aws.amazon.com/cdk/api/latest/docs/aws-ecr-assets-readme.html#aws-cdk-docker-image-assets" rel="noopener ugc nofollow" target="_blank"> AWS CDK Docker映像资产API </a>，它使用<code class="fe km kn ko kp b">gatling/Dockerfile</code>在本地构建Docker映像，并将Docker映像部署到ECR。然后，堆栈将继续提供AWS Fargate资源以及其他必要的基础设施，如NAT网关。</p><p id="39ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署的架构如下所示:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/6007bce5fe82c1c3a952d161b49dee4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gc6WUGEMwh-Obbtg2OvNHA.png"/></div></div></figure><p id="67d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe km kn ko kp b">sdk/lib/ecsTaskStack.ts</code>中，堆栈<code class="fe km kn ko kp b">DistributedECSTaskStack</code>使用<code class="fe km kn ko kp b">ContainerDefinition</code>创建<code class="fe km kn ko kp b">FargateService</code>，使用API <code class="fe km kn ko kp b">ContainerImage.fromAsset()</code>在本地构建映像:</p><pre class="mh mi mj mk gt ms kp mt mu aw mv bi"><span id="27d8" class="mw kr iq kp b gy mx my l mz na">const containerDef = new ecs.ContainerDefinition(this, 'containerDef', {</span><span id="d5f4" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="9584" class="mw kr iq kp b gy nb my l mz na">image: ecs.ContainerImage.fromAsset(path.resolve(__dirname, '../../gatling'), {file: "Dockerfile"}),</span><span id="040c" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="33cf" class="mw kr iq kp b gy nb my l mz na">})</span></pre><p id="6883" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">gatling</code>容器使用包装器脚本<code class="fe km kn ko kp b">gatling.sh</code>来运行<code class="fe km kn ko kp b">Gatling Highcharts</code>。</p><pre class="mh mi mj mk gt ms kp mt mu aw mv bi"><span id="15cd" class="mw kr iq kp b gy mx my l mz na">const containerDef = new ecs.ContainerDefinition(this, 'containerDef', {</span><span id="0e1d" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="b035" class="mw kr iq kp b gy nb my l mz na">command: [ "gatling.sh", "-sf", "/tests/test", "-s", "perfTest.simulations.WebServiceSimulation" ],</span><span id="4a3d" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="766a" class="mw kr iq kp b gy nb my l mz na">})</span></pre><p id="0a8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标志<code class="fe km kn ko kp b">-sf</code>告诉加特林在哪里可以找到模拟类，模拟类是<code class="fe km kn ko kp b">/tests/test</code>在Dockerfile文件中构建的，模拟运行时带有标志<code class="fe km kn ko kp b">-s</code>。</p><p id="e7f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于Gatling容器，还需要测试服务的端点，定义为<code class="fe km kn ko kp b">web.baseUrl</code>，通过<code class="fe km kn ko kp b">JAVA_OPTS</code>传入:</p><pre class="mh mi mj mk gt ms kp mt mu aw mv bi"><span id="ae3e" class="mw kr iq kp b gy mx my l mz na">const containerDef = new ecs.ContainerDefinition(this, 'containerDef', {</span><span id="81d7" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="a1c4" class="mw kr iq kp b gy nb my l mz na">environment: {</span><span id="bc4f" class="mw kr iq kp b gy nb my l mz na">"GATLING_CONF": "/tests/test/resources",</span><span id="51ce" class="mw kr iq kp b gy nb my l mz na">"JAVA_OPTS": "-Dweb.baseUrl=http://simpl-simpl-1tvem419lsgf7-18442615.us-west-1.elb.amazonaws.com"</span><span id="89c8" class="mw kr iq kp b gy nb my l mz na">},</span><span id="22d3" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="74ba" class="mw kr iq kp b gy nb my l mz na">})</span></pre><h1 id="cda9" class="kq kr iq bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">格林机关枪</h1><p id="cb49" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">一个典型的加特林<code class="fe km kn ko kp b">simulation</code>由一个或多个<code class="fe km kn ko kp b">scenarios</code>组成，每个<code class="fe km kn ko kp b">scenarios</code>调用一个或多个<code class="fe km kn ko kp b">requests</code>。</p><p id="2a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，负载测试购物车服务的模拟可能包含两个场景，一个场景到<code class="fe km kn ko kp b">search product</code>，另一个场景到<code class="fe km kn ko kp b">add-to-cart</code>。</p><p id="6897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe km kn ko kp b">search product</code>场景，请求将是向搜索服务发送一个搜索字符串，并验证来自搜索服务的响应。</p><p id="d46f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个场景可能需要多个请求。一个请求调用身份验证服务，并在会话中存储JWT令牌。另一个请求将从搜索结果中检索产品ID，从会话中检索JWT令牌，并发送到添加到购物车服务，并验证响应。最后，一个验证请求通过对<code class="fe km kn ko kp b">cart</code>服务的GET调用来验证产品已经被添加到购物车中。</p><p id="e1b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在这个例子中，我们将关注点分离到单独的文件夹中，即，</p><ul class=""><li id="3c35" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated"><code class="fe km kn ko kp b">gatling/src/test/simulations</code>对于所有使用负载曲线设置场景的模拟</li><li id="7e0c" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><code class="fe km kn ko kp b">gatling/src/test/scenarios</code>针对所有场景的用例，如<code class="fe km kn ko kp b">product search</code></li><li id="1224" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><code class="fe km kn ko kp b">gatling/src/test/requests</code>为实际请求，如<code class="fe km kn ko kp b">authentication</code>请求</li></ul><p id="0c92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当调用<code class="fe km kn ko kp b">gatling.sh</code>时，它将在用标志<code class="fe km kn ko kp b">-sf</code>指定的文件夹中查找扩展<code class="fe km kn ko kp b">io.gatling.core.scenario.Simulation</code>的类。如果在文件夹中发现不止一个模拟，并且没有用标志<code class="fe km kn ko kp b">-s</code>指定的模拟类，<code class="fe km kn ko kp b">gatling.sh</code>将提示选择运行哪个模拟类。</p><p id="b36d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了参数化Fargate任务中<code class="fe km kn ko kp b">gatling</code>的执行，自定义配置器<code class="fe km kn ko kp b">perfTest.config.Configurations</code>将首先从<code class="fe km kn ko kp b">System properties</code>中读取配置值，如果没有找到，则从<code class="fe km kn ko kp b">GATLING_CONF</code>文件夹中默认为<code class="fe km kn ko kp b">application.conf</code>的配置文件中读取值。</p><p id="5de1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过<code class="fe km kn ko kp b">JAVA_OPTS</code>可以配置的3个参数是:</p><ul class=""><li id="2f53" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated"><code class="fe km kn ko kp b">web.baseUrl</code>哪一个是待测系统的端点；</li><li id="91c6" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><code class="fe km kn ko kp b">load.rps</code>哪个是并发用户模拟的场景；</li><li id="5ec8" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><code class="fe km kn ko kp b">load.durationInSeconds</code>是整个模拟的持续时间。</li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="8885" class="kq kr iq bd ks kt mb kv kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln bi translated">针对简单的web服务运行Gatling</h1><p id="b051" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">使用Docker image <code class="fe km kn ko kp b">amazon/amazon-ecs-sample</code>的示例web服务将被用作测试中的系统。</p><p id="4103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CDK应用程序包含示例web服务<code class="fe km kn ko kp b">SimpleFargateWebService</code>，它可以用命令<code class="fe km kn ko kp b">cdk deploy simpleWebFargate</code>部署。</p><p id="2275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">堆栈将按如下方式部署:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nq"><img src="../Images/71afd5ae39c18a57bc23cf1358dafe47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpcXuJ0d9SuxAqWCzLiaKQ.png"/></div></div></figure><p id="4c48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦创建了堆栈，就可以使用AWS CLI从CloudFormation获取URL</p><pre class="mh mi mj mk gt ms kp mt mu aw mv bi"><span id="5e31" class="mw kr iq kp b gy mx my l mz na">% aws cloudformation describe-stacks --stack-name simpleWebFargate --query "Stacks[0].Outputs[?OutputKey=='SvcUrl'].OutputValue" --output text<br/>simpl-simpl-1TVEM419LSGF7-18442615.us-west-1.elb.amazonaws.com</span></pre><p id="6543" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在CDK应用程序<code class="fe km kn ko kp b">new SimpleFargateWebService(app, ‘simpleWebFargate’)</code>中定义了<code class="fe km kn ko kp b">stack-name</code>，返回值将是应用程序负载平衡器的端点。</p><p id="78d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将更新<code class="fe km kn ko kp b">simpleWebFargate</code>的端点，在<code class="fe km kn ko kp b">cdk/lib/ecsTaskStack.ts</code>中作为<code class="fe km kn ko kp b">web.basedUrl</code>:</p><pre class="mh mi mj mk gt ms kp mt mu aw mv bi"><span id="a9a8" class="mw kr iq kp b gy mx my l mz na">export class DistributedECSTaskStack extends cdk.Stack {</span><span id="06af" class="mw kr iq kp b gy nb my l mz na">constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {</span><span id="dbce" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="42cf" class="mw kr iq kp b gy nb my l mz na">const containerDef = new ecs.ContainerDefinition(this, 'containerDef', {</span><span id="a7ed" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="3326" class="mw kr iq kp b gy nb my l mz na">environment: {</span><span id="b251" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="b760" class="mw kr iq kp b gy nb my l mz na">"JAVA_OPTS": "-Dweb.baseUrl=http://simpl-simpl-1tvem419lsgf7-18442615.us-west-1.elb.amazonaws.com"</span><span id="1fcb" class="mw kr iq kp b gy nb my l mz na">},</span><span id="ebf3" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="9ce6" class="mw kr iq kp b gy nb my l mz na">})</span><span id="36de" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="5dfd" class="mw kr iq kp b gy nb my l mz na">}</span><span id="aa30" class="mw kr iq kp b gy nb my l mz na">}</span></pre><p id="fbdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着<code class="fe km kn ko kp b">web.baseUrl</code>根据<code class="fe km kn ko kp b">simpleWebFargate</code>堆栈的输出更新，我们可以使用命令<code class="fe km kn ko kp b">cdk deploy ecsLoadTestTask</code>部署<code class="fe km kn ko kp b">DistributedECSTaskStack</code>来部署堆栈。</p><p id="7a5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦栈<code class="fe km kn ko kp b">ecsLoadTestTask</code>被部署，Fargate任务将运行。<code class="fe km kn ko kp b">Gatling</code>的日志输出将在<code class="fe km kn ko kp b">CloudWatch log</code>中可用。</p><p id="2993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了检查Gatling输出，我们可以使用AWS CLI来<code class="fe km kn ko kp b">tail</code>log group<code class="fe km kn ko kp b">perfTest</code>，它是在创建<a class="ae kl" href="https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-ecs.AwsLogDriver.html" rel="noopener ugc nofollow" target="_blank"> ECS AWSLogDriver </a>时定义的:</p><pre class="mh mi mj mk gt ms kp mt mu aw mv bi"><span id="cd9b" class="mw kr iq kp b gy mx my l mz na">const logging = new ecs.AwsLogDriver({</span><span id="c6c3" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="be02" class="mw kr iq kp b gy nb my l mz na">logGroup: new log.LogGroup(this, 'gatlingLogGroup', {</span><span id="9ae0" class="mw kr iq kp b gy nb my l mz na">logGroupName: 'perfTest',</span><span id="16f3" class="mw kr iq kp b gy nb my l mz na">[...]<br/>})</span><span id="0ec0" class="mw kr iq kp b gy nb my l mz na">})</span></pre><p id="9ebb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要运行的AWS CLI是<code class="fe km kn ko kp b">aws logs tail perfTest</code>。如果执行成功，您应该能够看到断言通过了:</p><pre class="mh mi mj mk gt ms kp mt mu aw mv bi"><span id="f83a" class="mw kr iq kp b gy mx my l mz na">2021-04-03T15:06:43.886000+00:00 gatling/containerDef/8b703ac477474209b0b1ef076c90fd56 Global: percentage of successful events is greater than 99.0 : true<br/>2021-04-03T15:06:43.886000+00:00 gatling/containerDef/8b703ac477474209b0b1ef076c90fd56 Global: max of response time is less than 5000.0 : true</span></pre><p id="3c29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加特林模拟中的断言是</p><pre class="mh mi mj mk gt ms kp mt mu aw mv bi"><span id="d2ee" class="mw kr iq kp b gy mx my l mz na">package perfTest.simulations</span><span id="f8be" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="381f" class="mw kr iq kp b gy nb my l mz na">class WebServiceSimulation extends Simulation {</span><span id="8a05" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="2d5b" class="mw kr iq kp b gy nb my l mz na">setUp(</span><span id="f07b" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="7dde" class="mw kr iq kp b gy nb my l mz na">)</span><span id="c752" class="mw kr iq kp b gy nb my l mz na">.assertions(</span><span id="ee42" class="mw kr iq kp b gy nb my l mz na">global.successfulRequests.percent.gt(99),</span><span id="8d1a" class="mw kr iq kp b gy nb my l mz na">global.responseTime.max.lt(5000),</span><span id="1c14" class="mw kr iq kp b gy nb my l mz na">)</span><span id="4205" class="mw kr iq kp b gy nb my l mz na">[...]</span><span id="8206" class="mw kr iq kp b gy nb my l mz na">}</span></pre></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="4c55" class="kq kr iq bd ks kt mb kv kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln bi translated">结论</h1><p id="0434" class="pw-post-body-paragraph jn jo iq jp b jq lo js jt ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk ij bi translated">在本文中，我们介绍了加特林测试的基本组件，从一个<code class="fe km kn ko kp b">Simulation</code>的入口点开始，它调用由多个<code class="fe km kn ko kp b">Requests</code>组成的<code class="fe km kn ko kp b">Scenarios</code>。</p><p id="a1a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了一个简单的Gatling模拟来测试web服务，并将其构建到Gatling Docker映像中，该映像允许通过Docker运行时将负载配置文件参数化为环境变量，这些变量是web服务的URL、压力的<code class="fe km kn ko kp b">concurrent requests per second</code>和<code class="fe km kn ko kp b">duration</code>。</p><p id="6d2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用AWS Fargate运行负载测试，以利用无服务器计算，这样我们就可以专注于测试策略。例如，为了确保系统性能在非功能性需求范围内，可以安排在每天结束时运行一个1小时的小并发负载测试。另一方面，跨越多个AWS Fargate任务的大型并发负载可以在任何主要产品发布之前用作发布检查。</p></div></div>    
</body>
</html>