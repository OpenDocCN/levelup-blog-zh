<html>
<head>
<title>Unix Internal Concepts That Every Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的Unix内部概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unix-internal-concepts-that-every-developer-should-know-374c3fb78b2e?source=collection_archive---------4-----------------------#2022-02-07">https://levelup.gitconnected.com/unix-internal-concepts-that-every-developer-should-know-374c3fb78b2e?source=collection_archive---------4-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24d8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从程序员喜欢的操作系统中理解有趣的概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/924fd16b47fedbc46a2bde6ab4b5245b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wSiUz2k4bVph90_0xucqQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cgower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯多佛·高尔</a>在<a class="ae ky" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由Canva编辑</figcaption></figure><p id="8fa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算机用户通常使用各种操作系统进行日常计算活动。由于开发人员友好的环境、核心安全特性、可移植性和性能，大多数开发人员<a class="ae ky" href="https://medium.com/swlh/why-i-switched-to-linux-after-using-windows-for-10-years-247de78058ef" rel="noopener">倾向于使用</a>基于Unix或类似Unix的操作系统进行软件开发。的开源运动。NET框架(。NET Core)促使Windows开发者使用类似Unix的操作系统。</p><p id="5424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以使用基于Unix和类Unix的操作系统。举个例子，如果你热爱苹果硬件，你可以从macOS获得Unix的体验。如果你钦佩自由软件运动(GNU software freedom)背后的程序员所做的工作，你可能会使用基于GNU/Linux的操作系统。此外，基于BSD的操作系统，如FreeBSD和Solaris，它们扩展了最初的Unix研究项目，也给了您很好的Unix体验。</p><p id="5f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习操作系统内部是回答每个人对计算系统背后的好奇心的一个很好的方法。学习操作系统内部也有助于我们设计高质量的软件系统，构建操作系统友好的应用程序，学习低级编程，以及创新新的软件项目。在这个故事中，我将解释Unix/Linux操作系统的概念，帮助你理解你的操作系统最喜欢的部分。</p><h1 id="57fc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Unix处理文件的原始设备I/O</h1><p id="5696" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Unix将系统文件存储在根目录中，Unix在内部用一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Inode" rel="noopener ugc nofollow" target="_blank"> inode </a>结构表示每个文件。有没有看过<code class="fe ms mt mu mv b">/dev</code>目录里面的文件？一些开发人员仍然认为这个目录包含与开发相关的文件，因为单词<em class="mw"> dev </em>通常代表<em class="mw">开发</em>。但是，在操作系统上下文中，<em class="mw"> dev </em>指的是设备，<code class="fe ms mt mu mv b">/dev</code>目录包含设备文件。设备文件为I/O设备提供了一致的接口——然后，用户程序可以通过标准的文件处理系统调用来访问硬件设备。</p><p id="ca71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以通过读取Linux上的鼠标设备文件来直接捕获原始鼠标事件。运行下面的代码，移动鼠标，看看会发生什么——它会将一些二进制字符传输到控制台。</p><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="c66d" class="nb lw it mv b gy nc nd l ne nf">sudo cat /dev/input/mice</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/49d159302858c234870e70a786ffa61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhCYxNKmTsJGjiU-KyLdUw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从鼠标设备文件中捕获原始鼠标事件，由作者截图</figcaption></figure><p id="a5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<a class="ae ky" href="https://github.com/boppreh/keyboard" rel="noopener ugc nofollow" target="_blank"> Python键盘</a>模块这样的流行库直接从<code class="fe ms mt mu mv b">/dev/input</code>文件中读取设备事件。然而，程序员也使用X display服务器工具(如<code class="fe ms mt mu mv b">xdotool</code>)和API来捕获I/O设备事件，而不是处理原始设备事件。macOS core不像Linux那样使用<code class="fe ms mt mu mv b">/dev/input</code>目录来发出鼠标和键盘事件——它通过Carbon和Cocoa等框架API提供输入设备事件，并通过<a class="ae ky" href="https://developer.apple.com/documentation/iokit" rel="noopener ugc nofollow" target="_blank"> IOKit </a>和Quartz事件taps提供低级人机界面设备(HID)访问。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="de84" class="lv lw it bd lx ly no ma mb mc np me mf jz nq ka mh kc nr kd mj kf ns kg ml mm bi translated">特殊设备文件:零、空和随机</h1><p id="f0c5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Unix设备文件通常连接到物理硬件设备或虚拟终端(<a class="ae ky" href="https://en.wikipedia.org/wiki/Tty_(Unix)" rel="noopener ugc nofollow" target="_blank"> TTY </a>或<a class="ae ky" href="https://en.wikipedia.org/wiki/Pseudoterminal" rel="noopener ugc nofollow" target="_blank"> PTS </a>)，但是有三种特殊的虚拟设备:零、空和随机。众所周知的空设备(<code class="fe ms mt mu mv b">/dev/null</code>)不返回输出，接受任何输入，因此它有助于丢弃任何不需要的输出流。同时，<code class="fe ms mt mu mv b">/dev/zero</code>设备接受任何输入，但提供一个无休止的零字节流。</p><p id="f8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机设备基于硬件噪声提供随机数。换句话说，随机设备比其他伪随机数发生器(PRNGs)产生更安全的随机数。在Linux上，随机设备用设备驱动状态、中断和内部定时器更新随机性的熵。例如，参见下面的Linux内核函数，它增加了来自设备的随机性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/6236e1c5427cd206b68b874dfb432430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8y3NIL6MgvMaELAIDj2UA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Linux随机设备的源代码，作者截图</figcaption></figure><p id="10d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Unix系统上有两个随机设备:<code class="fe ms mt mu mv b">/dev/random</code>和<code class="fe ms mt mu mv b">/dev/urandom</code>。Linux的<code class="fe ms mt mu mv b">/dev/random</code>设备通常会等到内核事件产生足够的随机性。另一方面，<code class="fe ms mt mu mv b">/dev/urandom</code>不会等待，总是提供随机位。在macOS上，这两种随机设备的行为方式相同。当您使用终端接口、加密系统和操作系统级实用程序时，了解这些设备是很有帮助的。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="d8b1" class="lv lw it bd lx ly no ma mb mc np me mf jz nq ka mh kc nr kd mj kf ns kg ml mm bi translated">POSIX系统调用与操作系统库API</h1><p id="a12c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果所有操作系统都使用唯一的系统调用，本地跨平台软件开发活动就会变得困难。想象一下，如果您需要将一个原生Unix程序移植到没有Cygwin (Windows POSIX兼容层)的Windows平台上，会有多大的工作量。然后，你需要用Windows系统调用重写你的程序。如果有一个新的操作系统，并且您需要将您的程序移植到那个特定的操作系统，该怎么办？</p><p id="1f55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">POSIX通过为操作系统系统调用、命令行解释器和核心实用程序引入定义良好的标准解决了这个问题。几乎所有基于Unix和类Unix的操作系统都遵循POSIX标准。因此，我们可以用可移植的源代码编写本机操作系统级的程序。例如，下面的C++函数在GNU/Linux和macOS上创建了一个目录。</p><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="e721" class="nb lw it mv b gy nc nd l ne nf">#include &lt;<a class="ae ky" href="https://pubs.opengroup.org/onlinepubs/009695299/basedefs/sys/stat.h.html" rel="noopener ugc nofollow" target="_blank">sys/stat.h</a>&gt;</span><span id="eff2" class="nb lw it mv b gy nu nd l ne nf">void createDir(const std::string &amp;path) {<br/>  mkdir(path.c_str(), 0700);<br/>}</span></pre><p id="289e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，POSIX并没有为所有用户空间库提供严格的标准，但是它努力为核心系统服务和实用程序提供可移植性。例如，符合POSIX的操作系统可能会提供独特的本机UI工具包、图形库API、核心硬件库(如macOS <a class="ae ky" href="https://developer.apple.com/documentation/iokit" rel="noopener ugc nofollow" target="_blank"> IOKit </a>等)。</p><p id="960a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Unix POSIX合规知识有助于构建可移植的本地软件和自动化脚本。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="3bdb" class="lv lw it bd lx ly no ma mb mc np me mf jz nq ka mh kc nr kd mj kf ns kg ml mm bi translated">基于Unix与类似Unix的操作系统</h1><p id="a5df" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有两种类型的Unix实现:基于Unix的和类Unix的。基于Unix的操作系统，如BSD、Solaris和macOS，都是从最初的Unix研究项目中派生出来的源代码模块。Linux和Minix等类Unix操作系统是基于Unix的特性和内部设计概念从零开始开发的。</p><p id="482b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管所有流行的Unix实现都通过POSIX标准为用户提供了可移植的核心接口，但这些操作系统遵循不同的体系结构模式。例如，GNU/Linux发行版在主要的Linux内核项目中使用了单片内核架构。另一方面，macOS使用Darwin XNU内核项目的混合内核实现。</p><p id="31c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，GNU/Linux和macOS遵循不同的系统启动流程，但是系统核心组件仍然遵循Unix原则。例如，所有Unix实现都使用Unix的init守护进程概念来启动强制服务。GNU/Linux用PID <code class="fe ms mt mu mv b">1</code>启动systemd守护进程，并通过<code class="fe ms mt mu mv b">systemctl</code>命令提供管理后台服务的方法。同时，macOS类似地启动launchd守护进程，并提供用于服务管理的<code class="fe ms mt mu mv b">launchctl</code>命令。了解这些概念有助于您为多种类Unix和基于Unix的操作系统编写无错误的可移植本机程序。</p><p id="60d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我编写了一个可移植的C++函数来为几乎所有流行的Unix实现实现一个URL打开器，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f3cca3bfaeb87402b8653a6add3aeb78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*K_NGgASSUsZZMr9OVAURqg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个便携的URL打开器C++函数，作者截图</figcaption></figure><p id="c496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，一些Linux发行版甚至为创建GUI提供了各种预安装的二进制文件。我在下面的故事中解释了Ubuntu GUI二进制文件。</p><div class="nw nx gp gr ny nz"><a href="https://medium.com/swlh/how-to-modernize-your-bash-scripts-by-adding-gui-cba613a34cb7" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">如何通过添加GUI使Bash脚本现代化</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">厌倦了在控制台上显示原始文本？尝试Zenity &amp;通知-发送</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="61d9" class="lv lw it bd lx ly no ma mb mc np me mf jz nq ka mh kc nr kd mj kf ns kg ml mm bi translated">GUI层、CLI访问和命令行解释程序</h1><p id="dc82" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以通过GUI和CLI与Unix操作系统进行交互。类似Unix的操作系统如GNU/Linux有一个非常松散耦合的GUI层。换句话说，GUI不是GNU/Linux的一部分。因此，我们可以通过内置TTYs的CLI使用GNU/Linux，并通过安装各种桌面环境(如GNOME、KDE、Xfce等)来使用GUI。macOS通常带有一个有点紧密耦合的桌面环境，名为<a class="ae ky" href="https://en.wikipedia.org/wiki/Aqua_(user_interface)" rel="noopener ugc nofollow" target="_blank"> Aqua </a>，但仍然通过<a class="ae ky" href="https://github.com/apple/darwin-xnu" rel="noopener ugc nofollow" target="_blank"> Darwin </a>开源项目提供核心操作系统。</p><p id="6433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用C/C++我们可以使用Unix syscalls根据命令生成进程，但是操作系统如何为从命令生成进程提供高效的接口呢？几乎所有类Unix和基于Unix的操作系统都预装了命令行解释器，如Bash，用于从GUI终端和tty输入命令。</p><p id="1686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令行解释器带有一种友好的命令语言来产生本地进程。此外，这些命令行语言为您提供了几个用于执行各种任务的预建命令。让我们通过一个简单的实验来确定一个本机进程和内置命令。当我们在GUI终端上输入<code class="fe ms mt mu mv b">ls</code>时，Bash将<code class="fe ms mt mu mv b">/usr/bin/ls</code>二进制文件作为本地进程执行，并通过连接的PTS将输出返回到终端。我们可以用下面的命令来验证它。</p><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="9b28" class="nb lw it mv b gy nc nd l ne nf">which ls # outputs /usr/bin/ls</span></pre><p id="e7d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，<code class="fe ms mt mu mv b">which</code>命令没有为<code class="fe ms mt mu mv b">history</code>、<code class="fe ms mt mu mv b">cd</code>、<code class="fe ms mt mu mv b">jobs</code>和<code class="fe ms mt mu mv b">alias</code>命令提供任何输出，因为这些不是Unix二进制文件，而是Bash的内置命令。使用以下命令验证它。</p><pre class="kj kk kl km gt mx mv my mz aw na bi"><span id="1a16" class="nb lw it mv b gy nc nd l ne nf">which history # no output</span></pre><p id="165a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从<a class="ae ky" href="https://github.com/bminor/bash/tree/master/builtins" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的Bash源代码中看到所有支持的Bash内置命令实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f3d21e5819ce9211892ec955b93b8ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*1Qbjn2AxbB2mdG8nKaUL4Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Bash内置命令源码，作者截图</figcaption></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="37b1" class="lv lw it bd lx ly no ma mb mc np me mf jz nq ka mh kc nr kd mj kf ns kg ml mm bi translated">结论</h1><p id="5533" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这个故事中，我们学习了基于Unix和类Unix操作系统中一些有趣的概念，如设备文件、特殊设备文件、系统调用、POSIX标准、GUI层和Shell解释器。理解这些概念有助于我们去除Unix系统背后的神奇部分——这样我们就可以更自信地完成日常的编程任务，因为我们知道其内部原理。从下面的故事中了解更多关于Unix命令的知识。</p><div class="nw nx gp gr ny nz"><a href="https://betterprogramming.pub/5-unix-terminal-tips-to-boost-your-coding-speed-c85f880606ed" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">提高编码速度的5个Unix终端技巧</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">使用这些实践可以更快地完成编程任务</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">better编程. pub</p></div></div><div class="oi l"><div class="op l ok ol om oi on ks nz"/></div></div></a></div><p id="0304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>