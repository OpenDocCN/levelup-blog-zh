<html>
<head>
<title>Finite State Machines in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的有限状态机</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/finite-state-machines-in-go-a99adb7f7850?source=collection_archive---------14-----------------------#2021-03-02">https://levelup.gitconnected.com/finite-state-machines-in-go-a99adb7f7850?source=collection_archive---------14-----------------------#2021-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aa88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">造一个电灯开关甚至一个敌人AI！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f6e21c0d78a1176a624dee6fc14e4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hntFZK-7u6-w7y1x.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://wallpapercave.com/future-technology-hd-wallpapers" rel="noopener ugc nofollow" target="_blank">壁纸洞穴</a></figcaption></figure><p id="cf51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">有限状态机(FSM)是技术工程中最灵活、最广泛使用的面向对象设计模式之一。FSM由具有“转换”的给定模型的状态集合组成，该“转换”允许基于预定义的条件从一个状态切换到另一个状态。尽管FSM的想法很简单，但它的适应性非常强，可以应用于非常广泛的实现，包括:</p><ul class=""><li id="8d28" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated"><strong class="lb iu">自适应UI设计</strong> —如果用户的行为可以映射到一个有限状态机上，那么用户超出程序范围并导致错误的风险就会最小化。</li><li id="615a" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><strong class="lb iu">马尔可夫链</strong> —假设有一个概率框架和一组有限的状态，有限状态机可以用来模拟马尔可夫链。</li><li id="ab33" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><strong class="lb iu">测试网络协议</strong> —可以使用FSM对TCP等网络协议进行建模，以验证流量和通信的流动。在这种情况下，FSM通常不能用于生产，因为它们在数据存储能力方面存在固有的局限性。</li><li id="58ad" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><strong class="lb iu">常见应用</strong> —交通灯、自动售货机和电梯本质上是基于状态的，因此非常适合FSM的应用。</li></ul><blockquote class="ms mt mu"><p id="e4b4" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><em class="it">在本文中，我们将探索用Go编写的有限状态机的两个不同例子。读完这篇文章后，你应该对什么是FSM，如何手工实现以及优缺点有一个很好的了解。我们将涉及的例子包括:</em></p></blockquote><ol class=""><li id="afcc" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mz mk ml mm bi translated">一个模拟电灯开关的简单例子。</li><li id="7419" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mz mk ml mm bi translated">一个敌人AI使用地图。</li><li id="2537" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mz mk ml mm bi translated">关键要点</li></ol><p id="97af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="9822" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">一种简单的光开关FSM</h1><p id="7af9" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">第一个例子只是为了给我们一个什么是状态机和一般结构的概念。电灯开关是第一个很好的应用，因为电灯只有两种状态——开或关。首先，我们的项目需要三个文件。</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="38e0" class="oj ni it of b gy ok ol l om on">$ mkdir state-machine-go<br/>$ cd state-machine-go<br/>$ touch main.go state.go switch.go</span></pre><h2 id="be88" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">state.go</h2><p id="bf78" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">这个文件将保存我们的状态机中的状态逻辑。我们首先创建一个名为<code class="fe oz pa pb of b">LightSwitchState</code>的<code class="fe oz pa pb of b">interface</code>，它有两个方法来实现<code class="fe oz pa pb of b">On()</code>和<code class="fe oz pa pb of b">Off()</code>。这两种方法都需要引用一个<code class="fe oz pa pb of b">Switch</code>类型，我们将在下一个文件中定义。</p><p id="c414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们必须为系统中的相关状态定义<code class="fe oz pa pb of b">struct{}</code>类型。这些只是我们的开或关状态，它们目前没有内在的逻辑(尽管如果你愿意，你可以添加特定的属性)。然后我们有两个构造函数<code class="fe oz pa pb of b">NewOnState()</code>和<code class="fe oz pa pb of b">NewOffState()</code>，它们都返回对各自状态的引用。</p><p id="9865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在第34–50行有多个<code class="fe oz pa pb of b">LightSwitchState</code> <code class="fe oz pa pb of b">interface</code>的实现。注意每个方法是如何基于传递给它的状态对象的类型的。如果<code class="fe oz pa pb of b">On()</code>或<code class="fe oz pa pb of b">Off()</code>方法接收到一个基本状态，那么这意味着灯已经打开</p><p id="13a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们有两种可能的状态开和关，以及两种可能的转换开和关，所以我们有2x2=4个方法实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="c635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:这不是构建你的状态机的理想方式。这导致了高度耦合的代码，其中方法实现的数量等于状态的数量乘以可能的转换的数量，这非常容易扩展。这只是让你了解一个有限状态机。</p><h2 id="1a59" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">切换。开始</h2><p id="d4d7" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">接下来，我们必须定义灯开关本身。首先，我们定义了基础结构<code class="fe oz pa pb of b">Switch</code>，它具有前面文件<code class="fe oz pa pb of b">state.go</code>中类型<code class="fe oz pa pb of b">LightSwitchState</code>的属性<code class="fe oz pa pb of b">State</code>。这样，<code class="fe oz pa pb of b">Switch</code>结构现在可以访问<code class="fe oz pa pb of b">On()</code>和<code class="fe oz pa pb of b">Off()</code>方法。这就是我喜欢FSM的原因，它让事情变得直观！</p><p id="a653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续，我们还有一个构造函数<code class="fe oz pa pb of b">NewSwitch()</code>，它返回一个新的<code class="fe oz pa pb of b">Switch</code>引用，默认状态为off，由嵌套的构造函数<code class="fe oz pa pb of b">NewOffState{}</code>调用。如果您有基本状态要组成，状态机可以利用一个轻型装饰器模式(如果您需要复习，请查阅我关于装饰器模式的文章)。</p><p id="513f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们只有两个方法<code class="fe oz pa pb of b">On()</code>和<code class="fe oz pa pb of b">Off()</code>，它们使用命令链来实际改变灯开关的状态。这些方法引用<code class="fe oz pa pb of b">Switch</code>结构，然后调用链开关- &gt;状态- &gt;开/关。这看起来可能有点奇怪，因为我们引用了switch对象，同时还将对象本身传递给了方法调用。</p><p id="d9c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你很困惑，可以这样想。调用<code class="fe oz pa pb of b">sw.State.On()</code>只是我们用来进行转换的方法，我们还没有做任何影响开关对象的事情。当我们将switch对象传递给这个方法调用时，我们实际上改变了switch对象的状态。它基本上是在建造自己。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><h2 id="2d5d" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">main.go</h2><p id="4575" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">最后，主Go文件只是编排我们的FSM。我们创建一个新的灯开关，打开它，然后关闭它两次。这将展示我们的FSM如何处理重复事件和转换。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="ac04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行这个程序，我们可以看到我们的有限状态机在工作。请注意默认状态是如何关闭的，然后在状态实际变为“开灯”之前会有一些转换，如“开灯…”。</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="df13" class="oj ni it of b gy ok ol l om on">$ go run *.go<br/>Light turned off<br/>Switching light on...<br/>Light turned on<br/>Switching light off...<br/>Light turned off<br/>Light is already off</span></pre><p id="fed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了。现在我们已经有了基础，让我们来看一个更加灵活和优雅的例子。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="91cf" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">使用有限状态机向人工智能添加行为</h1><p id="c29e" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">在这一节中，我们将创建一个源于本文的人工智能来展示简单有限状态机的强大功能。下面提供的图片来自文章，展示了一个示例FSM图。状态用圆圈表示，触发器列在箭头旁边。我们将在Go中实现这个逻辑，以获得一个更好的FSM功能工作版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/d575c64df5eb96623ee1beb3e44d5262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8iHqH6WBkHwVj7XP8tcodg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://stackabuse.com/theory-of-computation-finite-state-machines/" rel="noopener ugc nofollow" target="_blank">堆栈的FSM图</a></figcaption></figure><p id="98f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的项目很小，只需要四个文件:</p><pre class="kj kk kl km gt oe of og oh aw oi bi"><span id="20ed" class="oj ni it of b gy ok ol l om on">$ mkdir enemyAI<br/>$ cd enemyAI<br/>$ touch main.go trigger.go state.go rules.go</span></pre><h2 id="6337" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">state.go</h2><p id="7d4e" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">转到实现，我们需要做的第一件事是定义我们的状态。我们可以通过声明一个<code class="fe oz pa pb of b">const()</code>块来实现，同时利用<code class="fe oz pa pb of b">iota</code>关键字——它给每个变量一个从0开始的递增索引。我们还将这些常量定义为类型<code class="fe oz pa pb of b">EnemyState</code>，为了可读性和我们的例子，它只是扩展了<code class="fe oz pa pb of b">int</code>类型。</p><p id="a063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有一个功能块，它用一个<code class="fe oz pa pb of b">switch{}</code>语句简单地将每个状态转换成相应的字符串表示。这样，当我们想要打印我们的任何州时，只需调用<code class="fe oz pa pb of b">EnemyState.String()</code>就很容易了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><h2 id="5342" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">触发.开始</h2><p id="188d" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">接下来是我们的触发器，同样也只是迷人的<code class="fe oz pa pb of b">int</code>对象。就像上面一样，我们有一个函数块来将我们所有的状态转换成字符串格式。此外，我们还有另一种类型<code class="fe oz pa pb of b">EnemyTriggerResult{}</code>，它既包含触发器又包含状态。我们将在下一个文件中使用这种类型来组成映射，它将我们的状态与我们的触发器联系起来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><h2 id="e57f" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">规则.开始</h2><p id="91d3" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">这个文件将保存<code class="fe oz pa pb of b">map</code>对象，它是我们的FSM的主要结构。该映射将一个<code class="fe oz pa pb of b">EnemyState</code>作为一个键，并将一个数组<code class="fe oz pa pb of b">EnemyTriggerResults</code>作为相应的值。让我们仔细看看。</p><p id="9f19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第4行开始，我们有了第一个<code class="fe oz pa pb of b">Patrolling</code>州的<code class="fe oz pa pb of b">map</code>条目。当FSM处于此<code class="fe oz pa pb of b">EnemyState</code>时，它有两个触发选项。第一个可能是触发器<code class="fe oz pa pb of b">PlayerApproaches</code>，它导致<code class="fe oz pa pb of b">EnemyState</code>变为<code class="fe oz pa pb of b">Attacking</code>(这个还没有实现，但是会在下一个文件中实现)。</p><p id="2a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对于每个<code class="fe oz pa pb of b">EnemyState</code>，我们将可能的触发器附加到我们希望在FSM中允许的状态对。这个规则集遵循(几乎)与上面StackAbuse中列出的图表相同的模式。对我来说，这就是FSM模式的美妙之处，因为它可以创建一个直观的、可读性很强的事件转换列表！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><h2 id="6e6e" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">main.go</h2><p id="d626" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">最后，我们有了主要的Go文件。这里有更多的逻辑，所以让我们走一遍。首先，我们将变量<code class="fe oz pa pb of b">currentState</code>初始化为我们希望敌人AI默认的状态——在本例中为<code class="fe oz pa pb of b">Patrolling</code>状态。</p><p id="5def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们开始一个无限循环，首先更新什么是<code class="fe oz pa pb of b">currentState</code>以及可能的触发器选择。我们通过遍历<code class="fe oz pa pb of b">enemyRules[currentState]</code>中列出的所有规则，在第16行列出了可能的触发器。我们还在第18行做了一些数据转换，将int <code class="fe oz pa pb of b">i</code>转换成一个字符串，然后列出<code class="fe oz pa pb of b">currentState</code>的触发器。</p><p id="51f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第21行，我们反复询问用户他们想要转换到什么状态，并将他们的响应存储在字节对象<code class="fe oz pa pb of b">input</code>中。之后，我们将字节对象转换成一个<code class="fe oz pa pb of b">string</code>，然后转换成一个<code class="fe oz pa pb of b">int</code>以在第22行得到<code class="fe oz pa pb of b">i</code>。</p><p id="fbd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后我们试图从<code class="fe oz pa pb of b">elevatorRules[currentState][i]</code>内部的<code class="fe oz pa pb of b">i</code>中得到触发。如果触发器存在，当我们将<code class="fe oz pa pb of b">currentState</code>重新分配给<code class="fe oz pa pb of b">trigger.State</code>时，状态将适当地转换。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="cfb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一点层叠调用，所以你可能想看几遍这些文件来了解这个想法。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="7198" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">关键要点</h1><p id="1bc2" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们已经看到了Go中FSM的两种不同实现。我们在light switch中看到的第一个问题是，方法实现的数量随着状态和转换的数量成倍增长。我们在第二个例子中对此进行了改进，加入了一个显示每个状态的所有可能转换的映射，但是我们仍然需要创建一个扩展性很差的综合映射。</p><p id="0ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，虽然我们能够用有限状态机直观地映射灯开关和敌人的AI，但还是有一些缺点。总之，FSM的优点和缺点如下:</p><h2 id="20c3" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">赞成的意见</h2><ul class=""><li id="e96d" class="me mf it lb b lc nz lf oa li pf lm pg lq ph lu mj mk ml mm bi translated">如果我们有一个有组织的映射，添加新状态会变得很容易——我们只需要用相应的转换来更新触发结果映射，以扩展我们的FSM。</li><li id="c5dc" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">FSM保护我们免于到达未知状态，因为我们为可能发生的事情和时间设定了界限。</li><li id="026d" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">状态机的概念降低了代码的复杂性，并使通向任何状态的路径变得清晰。</li><li id="58b7" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">强大的系统和用户行为验证。</li></ul><h2 id="2ae1" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">骗局</h2><ul class=""><li id="3564" class="me mf it lb b lc nz lf oa li pf lm pg lq ph lu mj mk ml mm bi translated">有限状态机会导致较差的数据效率，因此必须进行相应的设计。如果状态空间不是有限的或者太大，就会导致可伸缩性问题。</li><li id="0be8" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">并行运行FSM需要复杂的编排来防止数据泄漏和死锁。</li><li id="a771" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">会导致实现的过度规范。</li></ul><h2 id="d9a6" class="oj ni it bd nj oo op dn nn oq or dp nr li os ot nt lm ou ov nv lq ow ox nx oy bi translated">后续步骤</h2><p id="06a5" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">从这些例子中可以继续进行很多工作。首先，实际上有两种正式的FSM——Mealy和Moore机器。虽然FSM是很好的软件应用程序，但它们背后也有大量的形式数学，可以在更亲密的层次上学习它们。创造多个并行工作的FSM也可能是下一个巨大的挑战。</p><p id="83b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于上面的程序，有大量的错误检查和额外的逻辑可以实现。您还可以基于一个简单的switch语句创建一个新的FSM，其中每种情况都映射到一个无限for循环中的不同状态。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="6dc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，并且能够理解有限状态机及其在Go中的实现。如果你想了解更多的信息，或者你想了解软件工程中的任何新话题，我鼓励你在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>