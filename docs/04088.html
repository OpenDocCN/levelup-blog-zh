<html>
<head>
<title>JavaScript Object Features in TypeScript — Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的JavaScript对象特性—继承</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-object-features-in-typescript-inheritance-a53a46efe43?source=collection_archive---------31-----------------------#2020-06-08">https://levelup.gitconnected.com/javascript-object-features-in-typescript-inheritance-a53a46efe43?source=collection_archive---------31-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d8c059daedeeb29096e2b7444fd3d5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K1N0dGEL7kthVyEy"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ae5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript是JavaScript的自然扩展，在许多项目中取代了JavaScript。</p><p id="cc57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，并不是每个人都知道它实际上是如何工作的。</p><p id="7dfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究应该在TypeScript项目中使用的JavaScript的一些特性，包括对象继承。</p><h1 id="3a78" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript对象继承</h1><p id="7522" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript对象可以链接到另一个对象。</p><p id="869f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个物体被称为原型。</p><p id="ab6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对象从原型继承属性和方法。</p><p id="3fd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这允许我们实现复杂的特性，只需定义一次，就可以一致地使用。</p><p id="2ffd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们使用字面语法创建一个对象时，那么它的原型就是<code class="fe mh mi mj mk b">Object</code>。</p><p id="0303" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object</code>提供了一些它们继承的基本特性，比如返回对象的字符串表示的<code class="fe mh mi mj mk b">toString</code>方法。</p><p id="2766" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下对象:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="59db" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  foo: 1,<br/>  bar: "baz"<br/>};</span><span id="3973" class="mt lf it mk b gy my mv l mw mx">console.log(obj.toString());</span></pre><p id="f051" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们定义<code class="fe mh mi mj mk b">obj</code>并运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c40f" class="mt lf it mk b gy mu mv l mw mx">console.log(obj.toString());</span></pre><p id="a416" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们让<code class="fe mh mi mj mk b">[object Object]</code>登录。</p><p id="0f42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是默认的<code class="fe mh mi mj mk b">toString</code>方法在<code class="fe mh mi mj mk b">Object</code>原型中的作用。</p><h1 id="0a4f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象的原型</h1><p id="07d5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Object</code>是大多数对象的原型。</p><p id="0804" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以直接用一些方法。</p><p id="3026" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有<code class="fe mh mi mj mk b">getPrototypeOf</code>、<code class="fe mh mi mj mk b">setPrototypeOf</code>和<code class="fe mh mi mj mk b">getOwnPropertyNames</code>方法。</p><p id="c8f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">getPrototypeOf</code>返回对象的原型。</p><p id="d70c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bdcb" class="mt lf it mk b gy mu mv l mw mx">const proto = {};<br/>const obj = Object.create(proto);</span><span id="778d" class="mt lf it mk b gy my mv l mw mx">let objPrototype = Object.getPrototypeOf(obj);</span></pre><p id="0705" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mh mi mj mk b">objPrototype</code>就是<code class="fe mh mi mj mk b">Object</code>。</p><p id="5b90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">proto</code>是我们传入<code class="fe mh mi mj mk b">Object.create</code>以来<code class="fe mh mi mj mk b">obj</code>的原型。</p><h1 id="4b03" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建定制原型</h1><p id="03ca" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">同样，我们可以使用<code class="fe mh mi mj mk b">setPrototypeOf</code>方法来设置现有对象的原型。</p><p id="676c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7351" class="mt lf it mk b gy mu mv l mw mx">const proto = {};<br/>const obj = {<br/>  foo: 1<br/>};</span><span id="a47e" class="mt lf it mk b gy my mv l mw mx">Object.setPrototypeOf(obj, proto);<br/>const objProto = Object.getPrototypeOf(obj);<br/>console.log(proto === objProto);</span></pre><p id="5153" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有两个对象，<code class="fe mh mi mj mk b">obj</code>和<code class="fe mh mi mj mk b">proto</code>。</p><p id="ba24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">obj</code>和<code class="fe mh mi mj mk b">proto</code>调用<code class="fe mh mi mj mk b">setPrototype</code>，将<code class="fe mh mi mj mk b">proto</code>设置为<code class="fe mh mi mj mk b">obj</code>的原型。</p><p id="b002" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最后一行，我们检查<code class="fe mh mi mj mk b">proto</code>是否引用了与从<code class="fe mh mi mj mk b">getPrototypeOf</code>返回的原型对象相同的对象。</p><p id="d474" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">控制台日志返回<code class="fe mh mi mj mk b">true</code>所以我们知道<code class="fe mh mi mj mk b">obj</code>的原型其实是<code class="fe mh mi mj mk b">proto</code>。</p><h1 id="a980" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构造函数</h1><p id="93d8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">构造函数用于创建一个新对象，配置其属性，并分配其原型。</p><p id="70d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下内容来创建一个:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1b39" class="mt lf it mk b gy mu mv l mw mx">let Dog = function(name, breed) {<br/>  this.name = name;<br/>  this.breed = breed;<br/>};</span><span id="1e05" class="mt lf it mk b gy my mv l mw mx">Dog.prototype.toString = function() {<br/>  return `name: ${this.name}, breed: ${this.breed}`;<br/>};</span></pre><p id="8ffb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个带有<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">breed</code>字段的<code class="fe mh mi mj mk b">Dog</code>构造函数。</p><p id="6f2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们创建了一个名为<code class="fe mh mi mj mk b">toString</code>的实例方法来返回一个<code class="fe mh mi mj mk b">Dog</code>实例的字符串表示。</p><p id="db37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以创建一个<code class="fe mh mi mj mk b">Dog</code>实例并如下调用<code class="fe mh mi mj mk b">toString</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b468" class="mt lf it mk b gy mu mv l mw mx">console.log(new Dog('joe', 'labrador').toString());</span></pre><p id="6360" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="dc73" class="mt lf it mk b gy mu mv l mw mx">'name: joe, breed: labrador'</span></pre><p id="bddb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在控制台日志输出中。</p><p id="1723" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用关键字<code class="fe mh mi mj mk b">new</code>调用了我们的构造函数。</p><p id="9f94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参数被传入并在构造函数中设置为<code class="fe mh mi mj mk b">this</code>的属性。</p><p id="d030" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构造函数使用设置为新对象的<code class="fe mh mi mj mk b">this</code>配置对象自身的属性。</p><p id="0f03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构造函数返回的对象原型的<code class="fe mh mi mj mk b">__proto__</code>设置为<code class="fe mh mi mj mk b">Dog.prototype</code>。</p><p id="f7d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<code class="fe mh mi mj mk b">toString</code>来自<code class="fe mh mi mj mk b">Dog</code>实例的<code class="fe mh mi mj mk b">prototype</code>属性。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/a532214fbe3deaf375d43eb657eefab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xEb5xGNSgE3EWnIc"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@peterwendt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Peter Wendt </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="bfb2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">链接构造函数</h1><p id="689e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过编写以下代码来链接多个函数的压缩函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b10a" class="mt lf it mk b gy mu mv l mw mx">const Animal = function(name) {<br/>  this.name = name;<br/>};</span><span id="dd2c" class="mt lf it mk b gy my mv l mw mx">Animal.prototype.toString = function() {<br/>  return `toString: name: ${this.name}`;<br/>};</span><span id="c331" class="mt lf it mk b gy my mv l mw mx">const Dog = function(name, breed) {<br/>  Animal.call(this, name);<br/>  this.breed = breed;<br/>};</span><span id="f0b0" class="mt lf it mk b gy my mv l mw mx">Object.setPrototypeOf(Dog.prototype, Animal.prototype);<br/>Dog.prototype.bark = function() {<br/>  return "woof";<br/>};</span><span id="0205" class="mt lf it mk b gy my mv l mw mx">const dog = new Dog("joe", "labrador");<br/>console.log(dog.toString());<br/>console.log(dog.bark());</span></pre><p id="84b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个父<code class="fe mh mi mj mk b">Animal</code>构造函数，它的原型中有一个<code class="fe mh mi mj mk b">toString</code>方法。</p><p id="dc70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们添加了一个<code class="fe mh mi mj mk b">Dog</code>构造函数，它继承了<code class="fe mh mi mj mk b">Animal</code>构造函数。</p><p id="1380" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">Dog</code>构造函数中，我们调用<code class="fe mh mi mj mk b">Animal</code>上的<code class="fe mh mi mj mk b">call</code>方法来调用父<code class="fe mh mi mj mk b">Animal</code>构造函数，但是将<code class="fe mh mi mj mk b">this</code>设置为<code class="fe mh mi mj mk b">Dog</code>构造函数。</p><p id="92b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Dog</code>通过调用<code class="fe mh mi mj mk b">setPrototypeOf</code>继承<code class="fe mh mi mj mk b">Animal</code>，子构造函数在第一个参数中，父构造函数在第二个参数中。</p><p id="cb27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们向原型添加另一个方法，叫做<code class="fe mh mi mj mk b">bark</code>到<code class="fe mh mi mj mk b">Dog</code>的原型，所以我们只能在<code class="fe mh mi mj mk b">Dog</code>实例上被调用。</p><p id="0f3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">toString</code>对<code class="fe mh mi mj mk b">Dog</code>和<code class="fe mh mi mj mk b">Animal</code>都可用。</p><h1 id="66d3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f682" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript的继承系统不同于其他面向对象语言的继承系统。</p><p id="59c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript有构造函数和原型，而不是类。</p><p id="486f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对象可以直接从其他对象继承。构造函数可以从其他构造函数继承。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><div class="ml mm mn mo gt nh"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">编写面试问题</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">技术开发</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jz nh"/></div></div></a></div></div></div>    
</body>
</html>