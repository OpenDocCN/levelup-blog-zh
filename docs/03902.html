<html>
<head>
<title>GraphQL for iOS Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于iOS开发的GraphQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-for-ios-development-cfeff5bdc043?source=collection_archive---------15-----------------------#2020-06-01">https://levelup.gitconnected.com/graphql-for-ios-development-cfeff5bdc043?source=collection_archive---------15-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/214d82554d8cb9c36b5452d2ddd5aed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1hJS26ybQHwWlFpNuHBFA.png"/></div></div></figure><h1 id="4803" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是GraphQL(初级读本)</h1><p id="0a7d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">GraphQL是一种用于API的查询语言。它指定了客户端与服务器通信的方式。如果您熟悉REST API，您可以将它视为一种替代方法。REST APIs通常被定义为一组端点，这些端点代表可以通过HTTP方法执行CRUD操作的资源……对于一个博客应用程序(像Medium)来说，这些资源可能是<code class="fe lx ly lz ma b">Authors</code>、<code class="fe lx ly lz ma b">Posts</code>、<code class="fe lx ly lz ma b">Comments</code>等。在GraphQL中，资源不是由API端点定义的<strong class="lb iu">而不是</strong>，它们是由客户端自省的模式定义的，然后客户端将制定他们想要的任何查询，只要根据该模式它们是有效的。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/0fe208aaadfb9afc0c2ba670f4c79d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*d7dqtWIUrepkYONm9xix2w.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">！？但这到底意味着什么！？</figcaption></figure><p id="582f" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">如果这听起来像是一堆术语，我将尝试简化它:使用REST，<strong class="lb iu"> API端点决定了什么数据可以通过网络交换。有了GraphQL端点，<strong class="lb iu">客户机</strong> <strong class="lb iu">确定</strong>将通过网络交换什么数据，只要它受模式支持。</strong></p><p id="f5fc" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">从客户端的角度来看，GraphQL的实现如下:</p><ul class=""><li id="81cc" class="mp mq it lb b lc mk lg ml lk mr lo ms ls mt lw mu mv mw mx bi translated">从GraphQL API获取模式</li><li id="2974" class="mp mq it lb b lc my lg mz lk na lo nb ls nc lw mu mv mw mx bi translated">自省模式以了解哪些操作和类型是可用的</li><li id="ddf8" class="mp mq it lb b lc my lg mz lk na lo nb ls nc lw mu mv mw mx bi translated">为您的客户端构建所需的查询</li><li id="d7e9" class="mp mq it lb b lc my lg mz lk na lo nb ls nc lw mu mv mw mx bi translated">将您的查询指向GraphQL API端点。</li></ul><p id="1e21" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">…稍后将详细介绍。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="8d6e" class="kb kc it bd kd ke nk kg kh ki nl kk kl km nm ko kp kq nn ks kt ku no kw kx ky bi translated">为什么选择GraphQL？</h1><p id="0c99" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们的应用程序本身完全没问题！为什么我要从使用REST转向使用GraphQL？</p><p id="454b" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">这个论点是公平的，GraphQL有一点点的学习曲线……你可能无法通过使用它而不是REST来解决太多问题。但它确实非常好地解决了一系列问题:</p><h2 id="724a" class="np kc it bd kd nq nr dn kh ns nt dp kl lk nu nv kp lo nw nx kt ls ny nz kx oa bi translated">更少的网络呼叫和“特殊端点”</h2><p id="d88c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">大多数数据模型都是相互关联的，以博客为例:<code class="fe lx ly lz ma b">Users</code>可能有<code class="fe lx ly lz ma b">Posts</code> , <code class="fe lx ly lz ma b">Posts</code>可能有<code class="fe lx ly lz ma b">Comments</code>，那些评论会有关联的<code class="fe lx ly lz ma b">Users</code>，如此循环往复。作为iOS开发人员，我们都遇到过这样的问题，我们需要链接API请求来获得所有的资源，以便填充特定的视图。我们<strong class="lb iu"> <em class="ob">讨厌</em> </strong>这个。我们希望尽可能少地访问网络，这样可以获得更干净、更高性能的代码和更好的用户体验。这个问题的一个解决方案是不断地向API作者询问“特殊”的端点。这是休息开始崩溃的地方。这个“特殊的”端点不一定代表任何特定的资源，但是它代表了特定客户端将需要的微调响应。API作者可能不愿意创建这些“特殊的”端点，因为它会分散整个REST范式的注意力，并可能导致他们端出现一些混乱的代码…但是出于性能原因，我们通常可以强迫他们这么做。</p><p id="a8a9" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">使用GraphQL，客户端可以在每个请求中准确地指定它想要的内容，不多也不少。响应的形状将与请求的形状相同。这意味着:</p><h2 id="562c" class="np kc it bd kd nq nr dn kh ns nt dp kl lk nu nv kp lo nw nx kt ls ny nz kx oa bi translated">不再有对多个资源的链式请求。</h2><h2 id="bab4" class="np kc it bd kd nq nr dn kh ns nt dp kl lk nu nv kp lo nw nx kt ls ny nz kx oa bi translated">不再有没有明确要求的无关数据，拥挤的回应</h2><h2 id="de1d" class="np kc it bd kd nq nr dn kh ns nt dp kl lk nu nv kp lo nw nx kt ls ny nz kx oa bi translated">对于特殊的端点，不再需要与API devs来回切换</h2></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="b0d8" class="kb kc it bd kd ke nk kg kh ki nl kk kl km nm ko kp kq nn ks kt ku no kw kx ky bi translated">GraphQL:细节</h1><p id="bc3a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">GraphQL支持三种不同的操作</p><p id="717e" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated"><strong class="lb iu"> <em class="ob">查询</em> </strong>，取数据。</p><p id="5a97" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated"><strong class="lb iu"> <em class="ob">突变</em> </strong>，哪个(你猜对了！)变异数据。</p><p id="93fe" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated"><strong class="lb iu"> <em class="ob">订阅</em> </strong>，为客户端订阅实时更新。</p><p id="7a57" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">要执行其中的任何一个，您都必须使用GraphQL查询语言来表述它们。</p><p id="a660" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">下面是一个查询示例，后面是一个变异示例。要了解更多关于GraphQL查询语言语法的信息，请查看文档</p><pre class="mc md me mf gt od ma oe of aw og bi"><span id="dfa1" class="np kc it ma b gy oh oi l oj ok">query HeroNameAndFriends {<br/>  hero {<br/>    name<br/>    friends {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="e5bc" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">事实是，当<strong class="lb iu">通过查询获取</strong>数据时，GraphQL比REST更出色，但是所有的CRUD操作当然都受GraphQL规范的支持。</p><pre class="mc md me mf gt od ma oe of aw og bi"><span id="e1c9" class="np kc it ma b gy oh oi l oj ok">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {<br/>  createReview(episode: $ep, review: $review) {<br/>    stars<br/>    commentary<br/>  }<br/>}</span></pre><p id="8184" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">如果您第一次看到这种类型的语法，您肯定会有一些疑问:</p><ul class=""><li id="7f9b" class="mp mq it lb b lc mk lg ml lk mr lo ms ls mt lw mu mv mw mx bi translated">我如何知道这些字段代表什么数据类型？T29】</li><li id="008d" class="mp mq it lb b lc my lg mz lk na lo nb ls nc lw mu mv mw mx bi translated"><strong class="lb iu"> <em class="ob">我怎么知道</em> </strong> <code class="fe lx ly lz ma b"><strong class="lb iu"><em class="ob">createView(:)</em></strong></code> <strong class="lb iu"> <em class="ob">是我可以在这个API上执行的操作？</em> </strong></li><li id="8f8c" class="mp mq it lb b lc my lg mz lk na lo nb ls nc lw mu mv mw mx bi translated">我怎么知道我可以请求这些字段呢？T3】</li></ul><p id="270c" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">嗯，答案很简单<strong class="lb iu"> GraphQL模式自省。</strong>客户可以自省API提供的模式，以生成文档和验证查询。这是我最喜欢GraphQL的一点。您不需要关于每个端点的请求/响应数据的文档。一旦你自省了这个模式，你将能够看到这个API的所有可能。</p><p id="ac83" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">在我的工作流程中，我使用了一个叫做<em class="ob">失眠(</em><a class="ae oc" href="https://insomnia.rest/graphql/" rel="noopener ugc nofollow" target="_blank">https://insomnia.rest/graphql/</a>)的工具。它充当一个GraphQL客户端，可以自省您的模式并生成所有必要的文档。由于失眠症患者现在知道了您的模式，您可以在您的服务器上测试一些查询和变化，并提供完全的自动完成和实时验证支持！</p><p id="24f2" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">最后，现在我们可以得到这个职位的面包和黄油。你可以用失眠作为客户端，这很可爱，但我们真的希望我们的iOS应用程序成为客户端！</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="68bc" class="kb kc it bd kd ke nk kg kh ki nl kk kl km nm ko kp kq nn ks kt ku no kw kx ky bi translated">iOS上GraphQL的问题</h1><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/86de03104fc95f657dddb5047bc96649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6b0piWyAmAm2NNnVBH_Z1Q.jpeg"/></div></div></figure><p id="d53c" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">如果你在寻找如何在iOS上实现GraphQL的参考资料时偶然发现了这篇文章，你可能已经意识到大多数途径都将你带到一个框架:<a class="ae oc" href="https://www.apollographql.com/docs/ios/" rel="noopener ugc nofollow" target="_blank"> Apollo Client for iOS </a>。</p><p id="93da" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">这不一定是个问题，毕竟Apollo可能是GraphQL在任何平台上的行业标准实现。我要告诉你我在使用阿波罗客户端时遇到的问题。这些问题可能不适用于您的用例，如果不适用，您应该尽快跳到他们的文档中开始！</p><p id="e95b" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">阿波罗客户端对你的应用程序非常苛刻。它将参与您的建模、网络和缓存层。它将自省您的模式，并允许您用GraphQL查询语言在文本文件中编写查询。它将接受您编写的查询，并为您生成代码中的模型和操作。然后，您将使用Apollo的网络和缓存抽象在代码中执行这些查询。由于所有这些工作，您可以绝对肯定您的请求将会工作，并且您的模型的形状是正确的(当然，如果API的模式在您下面没有改变的话)。</p><p id="cbb3" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">虽然阿波罗客户端会为你做好这一切，但这可能不是你想要的。也许你的应用程序已经有了一个相当广泛的网络层，它有你所依赖的缓存机制。也许你的应用程序使用了过多的API，而你正慢慢地将其中一些转移到GraphQL。也许您有一些现有的模型，由于某些特殊的原因，您不想用Apollo客户端生成的模型来替换它们。这些都是阻止我将这个框架集成到一个app中的原因。对于你来说，它们可能是完全无效的理由，尤其是在你从头开始开发一个将严重依赖GraphQL的应用程序的情况下。这些也是我对这个框架的<strong class="lb iu">*结论，如果有方法使用它而不遇到这些问题，我很乐意听到它们或者在他们的文档中澄清它们。</strong></p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="e47c" class="kb kc it bd kd ke nk kg kh ki nl kk kl km nm ko kp kq nn ks kt ku no kw kx ky bi translated">Apollo客户端iOS的替代方案</h1><p id="31ca" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果我们想避免一个笨重的框架的开销，我们将不得不放弃它的一些奢侈品。没有Apollo-Client，我们可以用几种不同的方式编写请求。我们仍将获得GraphQL查询的好处(减少我们的网络调用)，但我们不会直接*<em class="ob">*</em>享受模式验证，让我们知道我们正在做的事情在我们的API上是可能的。</p><p id="1fbf" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">归根结底，GraphQL请求通常是HTTP POST请求主体中的JSON编码字符串。这意味着我们可以自己用代码生成这个字符串，然后把它发送给我们的API。这并不理想，它甚至在GQL文档中这样说，作为使用GQL变量的论据:</p><blockquote class="om on oo"><p id="f8bc" class="kz la ob lb b lc mk le lf lg ml li lj op mm lm ln oq mn lq lr or mo lu lv lw im bi translated">直接在查询字符串中传递这些动态参数并不是一个好主意，因为这样我们的客户端代码将需要在运行时动态操作查询字符串，并将其序列化为特定于GraphQL的格式</p></blockquote><p id="be25" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated"><strong class="lb iu"> <em class="ob">但是</em> </strong>，这真的是我们目前在不集成阿波罗客户端的情况下得到的最好的了。幸运的是，有一些开源库可以让我们以一种非常快捷友好的方式构建我们的GraphQL查询。我目前使用的这个叫做<a class="ae oc" href="https://github.com/NicholasBellucci/SociableWeaver" rel="noopener ugc nofollow" target="_blank"> Sociable Weaver </a>，它是一个很好的轻量级库，允许我们使用GraphQL查询构建由新的<code class="fe lx ly lz ma b">@functionbuilder</code> Swift语言特性支持的DSL。我强烈建议你去看看！</p><p id="29e1" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">创建一个请求(在这个库中称为<code class="fe lx ly lz ma b">Weave</code>)看起来像这样:</p><pre class="mc md me mf gt od ma oe of aw og bi"><span id="9db1" class="np kc it ma b gy oh oi l oj ok">Weave(.query) {<br/>    Object(Post.self) {<br/>        Field(Post.CodingKeys.id)<br/>        Field(Post.CodingKeys.title)<br/>        Field(Post.CodingKeys.content)<br/>    }<br/>}</span></pre><p id="bf27" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">这将生成以下请求</p><pre class="mc md me mf gt od ma oe of aw og bi"><span id="c4fc" class="np kc it ma b gy oh oi l oj ok">query {<br/>    post {<br/>        id<br/>        title<br/>        content<br/>    }<br/>}</span></pre><p id="a73d" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">这是一个非常基本的库，但是这个库可以用来表达更复杂的请求…</p><p id="ff04" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">那么，如果你想绕开Apollo客户端iOS，使用像SociableWeaver这样的库，工作流程会是什么样的呢？</p><p id="c48d" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">首先，我会推荐使用某种GraphQL IDE/Playground/Client，不管你想叫它什么(正如我在使用<a class="ae oc" href="https://insomnia.rest/graphql/" rel="noopener ugc nofollow" target="_blank">失眠症GQL IDE </a>之前提到的)。因此，您仍然可以自省API的模式并测试请求。这样，您就知道您计划在代码中构建的请求实际上是有效的。此外，这将为您提供完整的API文档！</p><p id="2209" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">接下来，使用您认为合适的查询构建库来生成您的请求。了解数据是如何从服务器返回的非常重要，这样您就可以正确地解码它。在GraphQL中，您将得到一个<code class="fe lx ly lz ma b">data</code>字段，可能还有一个操作名，您必须钻取它才能得到您的响应对象。</p><p id="dc52" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">请记住，对于一些GQL纯粹主义者来说，这种方法可能看起来不太好，但是我发现对于那些不想进行大规模重构的移动开发人员来说，这种方法非常有用，可以开始支持一些很酷的新GQL API。我确信会有更多的工具在我们的iOS应用中无缝实现GraphQL！</p><p id="b571" class="pw-post-body-paragraph kz la it lb b lc mk le lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw im bi translated">我希望这有所帮助，并随时留下任何问题或评论！</p></div></div>    
</body>
</html>