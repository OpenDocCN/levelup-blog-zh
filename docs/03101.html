<html>
<head>
<title>JavaScript Best Practices — Classes and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—类和函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-classes-and-functions-5c7f47a4b307?source=collection_archive---------11-----------------------#2020-04-19">https://levelup.gitconnected.com/javascript-best-practices-classes-and-functions-5c7f47a4b307?source=collection_archive---------11-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d42c39582c623ccbfef451a17c9c79ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bqix-o67iiTf_ESL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dead____artist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">捕捉人心。</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="ae7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用默认参数和属性缩写，清理我们的JavaScript代码很容易。</p><p id="1073" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究创建类和函数时的最佳实践。</p><h1 id="6147" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免创建神类</h1><p id="31f9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">神类是全知的类。如果一个类主要用于使用get和set方法从其他类中检索数据，那么我们不需要这个类。</p><p id="1f47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以如果我们有这样的东西:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a94a" class="mq lf it mm b gy mr ms l mt mu">class Foo {<br/>  getBar() {}<br/>  setBar() {}<br/>  getBaz() {}<br/>  setBaz() {}<br/>  getQux() {}<br/>  setQux() {}<br/>}</span></pre><p id="9351" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以去掉类，直接访问我们需要的东西。</p><h1 id="7e07" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">消除不相关的类</h1><p id="cefa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们需要一个类，那么我们应该删除它。</p><p id="b7f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这适用于只有数据的类。如果我们有这个类中的成员，那么我们应该考虑他们是否应该是另一个类的成员。</p><h1 id="ba90" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免以动词命名的类</h1><p id="a5cf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该用动词来命名类，因为只有行为而没有数据的类不应该是类。</p><p id="ae0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0f5c" class="mq lf it mm b gy mr ms l mt mu">class GetFoo {<br/>  //...<br/>}</span></pre><p id="83b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么应该是函数而不是类。</p><h1 id="dfe3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们应该什么时候创建函数？</h1><p id="4135" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该创建函数来使我们的代码更好。以下是创建函数的原因。</p><h2 id="6f6c" class="mq lf it bd lg mv mw dn lk mx my dp lo kr mz na ls kv nb nc lw kz nd ne ma nf bi translated">降低复杂性</h2><p id="6af6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">降低复杂性是创建函数的最重要的原因之一。</p><p id="7ee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须创建它们，这样我们就不会重复编码，并最小化代码大小。</p><p id="d57f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们编写的所有过程都没有函数，那么我们会有很多相似的代码。</p><p id="6323" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1a7a" class="mq lf it mm b gy mr ms l mt mu">const greet1 = `hi joe`;<br/>const greet2 = `hi jane`;</span></pre><p id="f8b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用一个函数来概括:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0353" class="mq lf it mm b gy mr ms l mt mu">const greet = (name) =&gt; `hi ${name}`;<br/>const greet1 = greet('joe');<br/>const greet2 = greet('jane');</span></pre><p id="329e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以在任何地方调用<code class="fe ng nh ni mm b">greet</code>来创建类似的字符串。</p><h1 id="d403" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">引入一个中间的、可理解的抽象</h1><p id="5831" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">上面的代码也是一个抽象。我们概括了返回问候字符串的代码。</p><p id="c2a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以传入不同的值<code class="fe ng nh ni mm b">name</code>并返回一个新的字符串。</p><h1 id="cfbb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免重复代码</h1><p id="1081" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">避免重复代码也是创建函数的一个很好的理由。</p><p id="94a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，从上面的例子中我们可以看到，我们可以调用<code class="fe ng nh ni mm b">greet</code>来创建更多相同的字符串。</p><p id="eb0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那我们就不用到处重复<code class="fe ng nh ni mm b">hi</code>部分了。</p><h1 id="7658" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">支持子类化</h1><p id="3f26" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在子类中创建一个方法来覆盖超类中的方法。</p><p id="bf5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用JavaScript编写以下代码来实现这一点:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3d60" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  speak() {<br/>    return `${this.name} speaks`;<br/>  }<br/>}</span><span id="edba" class="mq lf it mm b gy nj ms l mt mu">class Dog extends Animal {<br/>  constructor(name) {<br/>    super(name);<br/>  }<br/>  speak() {<br/>    return `${super.speak(this.name)} in dog language`;<br/>  }<br/>}</span></pre><p id="74db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过调用<code class="fe ng nh ni mm b">super.speak</code>覆盖了<code class="fe ng nh ni mm b">Dog</code>中的<code class="fe ng nh ni mm b">speak</code>方法。</p><p id="cd6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以保持<code class="fe ng nh ni mm b">Dog</code>中的<code class="fe ng nh ni mm b">speak</code>方法更简单。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/5e6ef05b3897e41d7375354e3c304955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-ojg24ytzqNbEZhx"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">丹尼尔·塞鲁洛在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="02ca" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">隐藏序列</h1><p id="ad06" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数有利于隐藏过程的实现。</p><p id="64ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以有一个函数调用其他函数并对它们做一些事情。</p><p id="6c6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bcee" class="mq lf it mm b gy mr ms l mt mu">const calcWeight = () =&gt; {<br/>  //...<br/>}</span><span id="2520" class="mq lf it mm b gy nj ms l mt mu">const calcHeight = () =&gt; {<br/>  //...<br/>}</span><span id="eb2c" class="mq lf it mm b gy nj ms l mt mu">const calcWidth = () =&gt; {<br/>  //...<br/>}</span><span id="dcfc" class="mq lf it mm b gy nj ms l mt mu">const getAllDimensions = () =&gt; {<br/>  const weight = calcWeight();<br/>  //...<br/>  const height = calcHeight();<br/>  //...<br/>  const width = calcWidth();<br/>  //...<br/>}</span></pre><p id="9d4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在上面的代码中调用了多个函数。但是我们程序的其他部分不知道它们被调用的顺序。</p><p id="bc14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这减少了公开的实现并减少了耦合。</p><h2 id="9970" class="mq lf it bd lg mv mw dn lk mx my dp lo kr mz na ls kv nb nc lw kz nd ne ma nf bi translated">提高便携性</h2><p id="141d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">功能可以很容易地移动到任何地方。我们可以很容易地移动它和其他依赖它的东西。</p><h2 id="8b71" class="mq lf it bd lg mv mw dn lk mx my dp lo kr mz na ls kv nb nc lw kz nd ne ma nf bi translated">简化复杂的布尔测试</h2><p id="9fdd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有很长的布尔表达式，那么我们应该把它们放入自己的函数中。</p><p id="86ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d9b7" class="mq lf it mm b gy mr ms l mt mu">const isWindowsIE = navigator.userAgent.toLowerCase().includes('windows') &amp;&amp;<br/>  navigator.userAgent.toLowerCase().includes('ie');</span></pre><p id="f6a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以把整个事情写成一个函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7dd5" class="mq lf it mm b gy mr ms l mt mu">const isWindowsIE = () =&gt; {<br/>  const userAgent = navigator.userAgent.toLowerCase()<br/>  return userAgent.includes('windows') &amp;&amp;<br/>    userAgent.includes('ie');<br/>}</span></pre><p id="1d55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比使用长布尔表达式要干净得多。</p><h1 id="4428" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="14ce" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">神类，只有数据或者行为的类都是不好的。我们应该确保在创建两者之前有一个混合。</p><p id="73b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建函数来降低复杂性，删除重复的代码，并进行抽象。</p><p id="c418" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们擅长创造任何东西。</p></div></div>    
</body>
</html>