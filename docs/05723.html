<html>
<head>
<title>Working Selectable “Rating Stars” Without JavaScript FIRST, Then Enhance It With Scripting.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">首先在没有JavaScript的情况下工作可选择的“评级星”,然后用脚本增强它。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/working-selectable-rating-stars-without-javascript-first-then-enhance-it-with-scripting-f9d61876c850?source=collection_archive---------2-----------------------#2020-09-25">https://levelup.gitconnected.com/working-selectable-rating-stars-without-javascript-first-then-enhance-it-with-scripting-f9d61876c850?source=collection_archive---------2-----------------------#2020-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0cb46340db15e90ac77cb337d2a27f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouASh6CKH7KqNJK_rMeIpQ.png"/></div></div></figure><p id="b053" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="kz la ep" href="https://medium.com/u/1d679de5005f?source=post_page-----f9d61876c850--------------------------------" rel="noopener" target="_blank"> Hans McMurdy </a>的文章<a class="ae lb" href="https://medium.com/javascript-in-plain-english/how-to-create-an-animated-star-rating-with-just-css-4df50286ea4b" rel="noopener">中，他展示了</a><a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_combinator" rel="noopener ugc nofollow" target="_blank">通用兄弟组合器</a>的优秀用例。问题是，除了悬停之外，它实际上不做任何事情。</p><p id="68f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是因为:</p><ol class=""><li id="3374" class="lc ld it kd b ke kf ki kj km le kq lf ku lg ky lh li lj lk bi translated">没有语义，只是一堆DIV和无意义的类。</li><li id="79ef" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky lh li lj lk bi translated">因为它只是一堆DIV，所以单击选择它们是没有意义的。</li><li id="e647" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky lh li lj lk bi translated">因为它们只是DIV，任何使它们永久化的钩子都必须基于脚本。</li></ol><p id="ee55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决这个问题的方法很简单，首先为它编写实用的标记。在你尝试使用CSS或JavaScript之前，一定要先尝试做一些有用的标记。</p><p id="8897" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个我已经打算讨论一段时间的主题，如何你不必仅仅因为想要一些奇特的视觉效果或者使用脚本来避免页面负载而牺牲渐进增强/优雅降级。两者兼而有之，<strong class="kd iu"> <em class="lq">往往更容易！</em> </strong></p><h1 id="1b2e" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">加价</h1><p id="fac7" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">我们最好的答案是制作一个充满单选按钮的表单。这提供了禁用脚本的功能，键盘导航挂钩，以及可访问性所需的许多其他东西，嗯…只是理智和理性的web开发。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="bc03" class="nd ls it mz b gy ne nf l ng nh">&lt;form action="#" method="get" class="ratingStars"&gt;<br/>  &lt;fieldset&gt;<br/>    &lt;legend&gt;Rate This:&lt;/legend&gt;<br/>    &lt;input type="radio" name="rating" id="toggle_rating_5" value="5"&gt;<br/>    &lt;label for="toggle_rating_5"&gt;<br/>      &lt;span&gt;5 Stars&lt;/span&gt;<br/>    &lt;/label&gt;&lt;br&gt;<br/>    &lt;input type="radio" name="rating" id="toggle_rating_4" value="4"&gt;<br/>    &lt;label for="toggle_rating_4"&gt;<br/>      &lt;span&gt;4 Stars&lt;/span&gt;<br/>    &lt;/label&gt;&lt;br&gt;<br/>    &lt;input type="radio" name="rating" id="toggle_rating_3" value="3"&gt;<br/>    &lt;label for="toggle_rating_3"&gt;<br/>      &lt;span&gt;3 Stars&lt;/span&gt;<br/>    &lt;/label&gt;&lt;br&gt;<br/>    &lt;input type="radio" name="rating" id="toggle_rating_2" value="2"&gt;<br/>    &lt;label for="toggle_rating_2"&gt;<br/>      &lt;span&gt;2 Stars&lt;/span&gt;<br/>    &lt;/label&gt;&lt;br&gt;<br/>    &lt;input type="radio" name="rating" id="toggle_rating_1" value="1"&gt;<br/>    &lt;label for="toggle_rating_1"&gt;<br/>      &lt;span&gt;1 Stars&lt;/span&gt;<br/>    &lt;/label&gt;&lt;br&gt;<br/>    &lt;input type="radio" name="rating" id="toggle_rating_0" value="0"&gt;<br/>    &lt;label for="toggle_rating_0"&gt;<br/>      &lt;span&gt;0 Stars&lt;/span&gt;<br/>    &lt;/label&gt;<br/>  &lt;!-- .ratingStars --&gt;&lt;/fieldset&gt;<br/>  &lt;div class="submitsAndHiddens"&gt;<br/>    &lt;button&gt;Submit&lt;/button&gt;<br/>  &lt;!-- .submitsAndHiddens --&gt;&lt;/div&gt;<br/>&lt;/form&gt;</span></pre><p id="d343" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，它必须是一个表单，以便用户可以提交更改。作为单选按钮集，只能选择一个。<strong class="kd iu">所有的</strong>表单都应该在用户可以更改的任何输入周围有<code class="fe ni nj nk mz b">&lt;fieldset&gt;</code>，这实际上给了我们一个很好的父元素，我们可以使用它在增强时快速<code class="fe ni nj nk mz b">querySelectorAll</code>我们的脚本钩子输入，以及选择器驱动的样式。<em class="lq">后者是为了让我们不必在标记上浪费无休止的无意义的类。</em></p><p id="6dbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在任何用户交互<code class="fe ni nj nk mz b">&lt;fieldset&gt;</code>之后，我总是把我的提交/重置/隐藏按钮放在一个<code class="fe ni nj nk mz b">DIV</code>中。更容易设计风格，在语义上更有意义。</p><p id="1a41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ni nj nk mz b">&lt;span&gt;</code>在那里，所以我们可以使用绝对定位来伪造它们像工具提示一样的行为。当CSS被禁用、阻止或完全不相关时，它们表现为普通文本。</p><p id="846a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它们从高到低排列，因此我们可以使用“任意兄弟组合子”来选择后面的样式元素。</p><p id="d9c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，要在同一个页面上有多个这样的实例，您需要确保任何新的实例在所有输入上都有不同的名称，并且每个输入都有不同的ID。</p><p id="6e3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此我们以此为基线。如果你了解HTML或可访问性，你就会知道这基本上是搜索引擎、盲文阅读器、屏幕阅读器和其他非屏幕设备将使用的:</p><p id="57d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae lb" href="https://cutcodedown.com/for_others/medium_articles/ratingStars/ratingStars.noStyle.html" rel="noopener ugc nofollow" target="_blank">https://cut code down . com/for _ others/medium _ articles/rating stars/rating stars . no style . html</a></p><h1 id="5047" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">CSS是奇迹发生的地方</h1><p id="abb7" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">对于我们的风格，我们首先要做的是隐藏<code class="fe ni nj nk mz b">&lt;input&gt;</code>。当我们在那里时，我们应该继续隐藏<code class="fe ni nj nk mz b">&lt;span&gt;</code>,不幸的是，由于黑帽SEO垃圾搜索引擎和许多屏幕阅读器会处理可见性:隐藏；或者显示:无；作为内容，他们应该忽略的怀疑是被称为“内容伪装”的低俗伎俩。为此，使用绝对定位来隐藏东西是我们在这里应该使用的首选方法。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="4feb" class="nd ls it mz b gy ne nf l ng nh">.ratingStars input,<br/>.ratingStars span {<br/>  position:absolute;<br/>  left:-999em;<br/>}</span></pre><p id="b59d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将希望它们都在同一行上。显示器:flex是实现这一点的最简单的方法。我把行高设得很高，这样我们的星星就可以放大而不会出现对齐问题。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="0994" class="nd ls it mz b gy ne nf l ng nh">.ratingStars {<br/>  display:flex;<br/>  align-items:center;<br/>  justify-content:left;<br/>  line-height:2em;<br/>}</span></pre><p id="2e1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设计传奇“曾经”很难，人们曾经经历过各种疯狂的考验，试图让它有所作为。结果是，如果你浮动你的图例，它会弹出来，去掉浏览器控制的填充和放置，我们通常无法控制。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="935b" class="nd ls it mz b gy ne nf l ng nh">.ratingStars legend {<br/>  float:left;<br/>}</span></pre><p id="c0f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lq">哦，边注。我假设正在使用复位，所以</em> <code class="fe ni nj nk mz b">fieldset</code> <em class="lq">被设置为</em> <code class="fe ni nj nk mz b">border:none;</code> <em class="lq">和零填充/余量。如果你不使用重置，请添加它！</em></p><p id="e5e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还需要隐藏BR，当CSS不可用时，它使一切变得漂亮。如果我们对它们进行绝对定位，除了Firefox，它会打乱所有东西的排列，所以我们会<code class="fe ni nj nk mz b">display:none;</code>在这种情况下没问题。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="4ed4" class="nd ls it mz b gy ne nf l ng nh">.ratingStars br {<br/>  display:none;<br/>}</span></pre><p id="a546" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要颠倒标签的视觉顺序，让它们从低到高；从高到低的源代码顺序，所以我们可以使用任何兄弟组合符。最快的方法就是让它们正确浮动。我们不需要担心浮点清除，因为父节点<code class="fe ni nj nk mz b">&lt;fieldset&gt;</code>在flex容器中。我们还需要定位:相对的；放置我们的<code class="fe ni nj nk mz b">tooltip</code> &lt; span &gt;时悬停，当然还有想要的颜色。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="f44e" class="nd ls it mz b gy ne nf l ng nh">.ratingStars label {<br/>  position:relative;<br/>  float:right;<br/>  color:#0007;<br/>}</span></pre><p id="fcb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于明星我们可以使用一个<code class="fe ni nj nk mz b">:before</code>生成的内容。增大字体大小，然后设置行高，使它们在视觉上居中。遗憾的是，大多数utf-8特殊字符不与文本对齐，而是与完整的字形高度(行高)对齐。因此，我们需要一根短于行高的头发来使它们正确。<em class="lq">又忘了</em> <code class="fe ni nj nk mz b">vertical-align:middle;</code> <em class="lq">那就更破了。</em></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9f98" class="nd ls it mz b gy ne nf l ng nh">.ratingStars label:before {<br/>  content:"\2605";<br/>  font-size:2em;<br/>  line-height:0.9em;<br/>  vertical-align:top;<br/>}</span></pre><p id="3077" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">\2605是UTF-8的“黑星”字符。</p><p id="e233" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“最后一个”我们其实不想成为明星，因为它意味着零明星。解决方案？请使用取消X。它在2em看起来太大了，所以只需缩小它并调整行高来对齐它。同样，我也将使它总是红色的，以便突出。:last-of-type伪类让我们可以轻松地获取它。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="45c7" class="nd ls it mz b gy ne nf l ng nh">.ratingStars label:last-of-type:before {<br/>  content:"\1F5D9";<br/>  font-size:1.5em;<br/>  line-height:1.2em;<br/>  color:#F00;<br/>}</span></pre><p id="40e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了区分悬停和选中，我们只需将:选中与:悬停分开。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="8874" class="nd ls it mz b gy ne nf l ng nh">.ratingStars input:checked ~ label {<br/>  color:#F80;<br/>}</span><span id="1e42" class="nd ls it mz b gy nl nf l ng nh">.ratingStars input:hover ~ label {<br/>  color:#F00;<br/>}</span></pre><p id="82e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们真正的魔力。通过简单地使用:checked和:hover和“任意兄弟组合符”,我们立即得到两个额外的颜色状态。有趣的是——也是许多人不知道的——这种关系的标签有多深。不仅点击<code class="fe ni nj nk mz b">&lt;label&gt;</code>和点击<code class="fe ni nj nk mz b">&lt;input&gt;</code>是“为了”谁的ID是一样的，它也适用于悬停。悬停在<code class="fe ni nj nk mz b">&lt;label&gt;</code>上与悬停在<code class="fe ni nj nk mz b">&lt;input&gt;</code>上是一样的，这让我们将每个状态的选择器数量减少到一个。</p><p id="8902" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于替代/键盘导航，也应设置一个<code class="fe ni nj nk mz b">:focus</code>状态。这也将让我们清楚地突出显示最后点击的是哪一个。每边一个简单的文字阴影可以完成我们的脏活。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="b9e1" class="nd ls it mz b gy ne nf l ng nh">.ratingStars input:focus + label:before {<br/>  text-shadow:<br/>    -1px -1px 0 #800,<br/>    -1px 1px 0 #800,<br/>    1px 1px 0 #800,<br/>    1px -1px 0 #800; <br/>}</span></pre><p id="e0ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们需要设计工具提示的样式。首先，容器<code class="fe ni nj nk mz b">&lt;span&gt;</code>需要放置在我们希望它显示的顶部，固定宽度以适应文本，对齐，<code class="fe ni nj nk mz b">transform:translateX(-50%);</code>通常的“技巧”是将跨度本身置于我们的位置中心，然后是通常的样式。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="3603" class="nd ls it mz b gy ne nf l ng nh">.ratingStars label span {<br/>  top:2em;<br/>  width:6em;<br/>  text-align:center;<br/>  transform:translateX(-50%);<br/>  background:#FFF;<br/>  border:1px solid #0006;<br/>  border-radius:0.5em;<br/>  color:#000;<br/>}</span></pre><p id="3dc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后为悬停状态显示它:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="4de3" class="nd ls it mz b gy ne nf l ng nh">.ratingStars input:hover + label span {<br/>  left:50%;<br/>}</span></pre><p id="722f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们使用的是“左”而不是<code class="fe ni nj nk mz b">display:none;</code>，如果需要的话，你可以很容易地用CSS动画来扩展它。</p><p id="3028" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，填充<code class="fe ni nj nk mz b">.submitsAndHiddens</code>区域，让它看起来更漂亮。在大多数字体中，0.3em大约是一个空格宽度。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="401a" class="nd ls it mz b gy ne nf l ng nh">.ratingStars .submitsAndHiddens {<br/>  padding-left:0.4em;<br/>}</span></pre><p id="2aa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了重置之外，这就是实现这一点的全部CSS。</p><p id="1b48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CSS舞台现场演示在此:<br/><a class="ae lb" href="https://cutcodedown.com/for_others/medium_articles/ratingStars/ratingStars.noJS.html" rel="noopener ugc nofollow" target="_blank">https://cutcodedown . com/for _ others/medium _ articles/rating stars/rating stars . nojs . html</a></p><h1 id="8375" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">现在我们可以用JavaScript来增强它！</h1><p id="0784" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">再说一次，JavaScript本身并不违反可访问性，地狱WCAG 2甚至不再列出它。<strong class="kd iu">但是</strong>编写脚本来避免优雅的退化仍然很重要，这就是为什么我们首先尽可能不使用JavaScript来实现。我们需要它做的事情的99%现在已经编码了！我们的JS要做的唯一一件事就是把它换成ajax提交，而不是普通的提交。</p><p id="eaee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，让我们把生活中的一切都包装起来，把“文档”作为“d”传递给表达式，这样我们就不用输入“文档”了。遍布这该死的东西。它隔离了范围，加速了对文档的访问，等等。<em class="lq">如果这种技术对谷歌来说足够好，对我来说也足够好。</em></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="1058" class="nd ls it mz b gy ne nf l ng nh">(function(d) {<br/>  // our code will go here<br/>})(document);</span></pre><p id="7529" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为这将使用AJAX，而不是为我们都应该知道如何做的事情创建一个完整的服务器端案例，所以我将在顶部实现一个“live”标志，如果我们不是live，它将跳过发送AJAX。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="31c0" class="nd ls it mz b gy ne nf l ng nh">var live = false;</span></pre><p id="14d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来我们需要遍历所有的<code class="fe ni nj nk mz b">form.ratingStars</code>来应用我们的各种事件、类等。在其中，我们需要提取所有的输入，并同样地挂钩它们。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a227" class="nd ls it mz b gy ne nf l ng nh">for (var form of d.getElementsByClassName('ratingStars')) {<br/>  form.addEventListener('submit', ratingChange, false);<br/>  form.classList.add('ratingStarsScripted');<br/>  form.lastElementChild.appendChild(<br/>    d.createElement('div')<br/>  ).className = 'ratingStarsProgress';<br/>  for (var input of form.getElementsByTagName('input')) {<br/>    input.addEventListener('change', ratingChange, false);<br/>  }<br/>}</span></pre><p id="c10c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很简单。我们将表单的“submit”和输入的“change”事件挂钩为一个submit函数。然后，我们向表单添加一个类，这样CSS就可以知道表单是活动的，并做出适当的更改，比如删除submit按钮。在窗体的内部。submitsAndHiddens——我们的最后一个元素子元素——我们添加了一个DIV，可以在其中添加“发送”或“接受”这样的消息，或许还有一个CSS动画？</p><p id="e9c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过类名进行循环的好处是，这个脚本可以在同一个页面上处理多个这样的表单。你不仅限于一个。可重用性，非常重要！</p><p id="cf8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们使用相同的事件处理程序，所以我们需要确保当输入确实“改变”了currentTarget时，我们得到了表单。很多人会将表单硬编码到输入中，或者作为一个变量…我？我只是在散步。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="f624" class="nd ls it mz b gy ne nf l ng nh">function findParentTag(node, tagName) {<br/>  // force case since XHTML and HTML use different cases for tagName<br/>  tagName = tagName.toLowerCase();<br/>  do {<br/>    if (tagName === node.tagName.toLowerCase()) return node;<br/>  } while (node = node.parentNode);<br/>} // findParentTag</span></pre><p id="88fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的“DOM Walker”还检查传递给它的元素，因此我们可以自由地传递表单，简化了我们在“节点”何时成为表单以及何时成为表单内部的输入之间的逻辑。do/while，又名“帕斯卡逻辑”…派上了用场。不管有多少迂腐的无知之人会愤怒地说“永远不要用它！”。不开玩笑，这样的小丑就在外面。他们中的很多人写“linters ”,抱怨switch dropthrough、yodish和其他各种完美的代码。</p><p id="0639" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还添加了小写检查，以防我们遇到XML情况，其中<code class="fe ni nj nk mz b">Element.tagName</code>以大写而不是小写结束。</p><p id="d43d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来是我们的ratingSubmit处理程序，用于提交和更改。让我们把这个分成几块。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="5f31" class="nd ls it mz b gy ne nf l ng nh">function ratingChange(event) {<br/>  <br/>    if (event.eventType === 'submit') event.preventDefault();</span></pre><p id="0ca4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不想阻止改变，只是提交…非常简单。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="cb66" class="nd ls it mz b gy ne nf l ng nh">var form = findParentTag(event.currentTarget, 'form');<br/>form.classList.add('ratingStarsSending');</span></pre><p id="99aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的DOM walker获取表单，不管它是<code class="fe ni nj nk mz b">event.currentTarget</code>还是它的父表单。然后我们添加一个类来告诉CSS“发送已经开始”,然后它将执行重要的任务来显示我们的动画和状态。</p><p id="5e27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于动态XML状态，这几乎是一个普通的AJAX发送。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="ac5b" class="nd ls it mz b gy ne nf l ng nh">if (live) {<br/>    <br/>  var<br/>    ajax = new XMLHttpRequest(),<br/>    data = new FormData(form);<br/>        <br/>  /*<br/>    Let the server know this is an ajax request, not a pageload.<br/>    This way we can use the same URI<br/>  */<br/>  data.set('ajax', 1);<br/>        <br/>  ajax.onreadystatechange = function(event) {<br/>    ratingAjaxStateChange(ajax);<br/>  };<br/>  ajax.open('post', form.action);<br/>  ajax.send(data);</span></pre><p id="9e39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你知道如何使用<code class="fe ni nj nk mz b">XMLHttpRequest</code>和<code class="fe ni nj nk mz b">FormData</code>，这对你来说应该不是什么新鲜事。不，我不会使用derpy的“获取”承诺废话。 <em class="lq">我，我喜欢错误检查和处理200以外的状态代码的能力，而不是只是去永不永不着陆！</em></p><p id="4133" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我经常使用状态代码而不是发送响应数据，所以更是如此。</p><p id="ea6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将事件包装在一个匿名中，以确保AJAX被传递给我们的函数，而不会将所述函数加入代码的这一部分。很好，因为这意味着我们可以再次拥有多个代码实例，而不会互相干扰。</p><p id="5320" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这也很方便，因为我们希望在非实时测试中重用该处理程序:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="6dfc" class="nd ls it mz b gy ne nf l ng nh">    } else {<br/>      /* fake it for testing*/<br/>      setTimeout(function() {<br/>      ratingAjaxStateChange({<br/>        readyState : 4,<br/>        status : 200<br/>      });<br/>    }, 500);<br/>  }<br/>  <br/>} // ratingChange</span></pre><p id="f95e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们只是使用一个超时，并伪造ajax对象来调用相同的例程。</p><p id="a03f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所述程序是简单的:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9791" class="nd ls it mz b gy ne nf l ng nh">function ratingAjaxStateChange(ajax) {<br/>  if (ajax.readyState == 4) {<br/>    form.classList.remove('ratingStarsSending');<br/>    if (ajax.status == 200) {<br/>      // handle the success.<br/>    } else console.warn(<br/>      'ratingAjaxStateChange - Unhandled Status Code ' + ajax.status<br/>    );<br/>  }<br/>} // ratingAjaxStateChange</span></pre><p id="f46e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在生产中，我会在错误状态处理方面做更多的工作，但是对于演示来说，这已经足够了。不管成功还是失败，我们都要调用那个类。将我们的报告DIV的textContent改为pass/fail可能是值得的，但是现在这样就可以了。</p><p id="e3e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们需要CSS来使它变得纯净。既然这个CSS只是JavaScript，为什么我们不浪费时间把它发送到没有脚本的页面，而是把它放在脚本中呢？JS中的CSS很方便，但是您必须知道何时使用它，何时不使用它。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="4062" class="nd ls it mz b gy ne nf l ng nh">  d.head.appendChild(d.createElement('style')).textContent = `<br/>  <br/>    .ratingStarsScripted .submitsAndHiddens button {<br/>      display:none;<br/>    }<br/>    <br/>    .ratingStarsProgress {<br/>      color:#0007;<br/>      opacity:0;<br/>      transition:opacity 0.5s;<br/>    }<br/>    <br/>    .ratingStarsProgress:after {<br/>      content:"approved";<br/>      padding-left:0.5em;<br/>      font-style:italic;<br/>    }</span><span id="f1b8" class="nd ls it mz b gy nl nf l ng nh">    .ratingStarsProgress:before {<br/>      content:"";<br/>      display:inline-block;<br/>      position:relative;<br/>      top:0.25em;<br/>      width:0.75em;<br/>      height:0.75em;<br/>      animation:spin 0.5s linear infinite;<br/>      border-radius:50%;<br/>      border:0.25em solid;<br/>      border-color:#F80 #F00 #800;<br/>    }<br/>    <br/>    .ratingStarsSending .ratingStarsProgress {<br/>      opacity:1;<br/>      transition:opacity 0s;<br/>    }<br/>    <br/>    .ratingStarsSending .ratingStarsProgress:after {<br/>      content:"sending";<br/>    }</span><span id="76d7" class="nd ls it mz b gy nl nf l ng nh"><a class="ae lb" href="http://twitter.com/keyframes" rel="noopener ugc nofollow" target="_blank">    @keyframes</a> spin {<br/>      100% { transform:rotate(0deg) }<br/>      0% { transform:rotate(360deg) }<br/>    }<br/>    <br/>  `;</span></pre><p id="fa52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">起初，我对反斜杠不感兴趣，但是它们对于CSS-in-JS来说很好，所以你不必在每一行都加上反斜杠。</p><p id="53bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了分解它，首先我们隐藏提交按钮。Durr…对于我们的进度DIV，我们为文本设置了一个漂亮的灰色透明度，不透明度为0，所以它是隐藏的，还有一个淡出过渡。</p><p id="84c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我通过<code class="fe ni nj nk mz b">:after </code>的生成内容添加“批准”文本作为默认状态。当我们的班级在场时，我们将其改为“发送”。</p><p id="8aef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用<code class="fe ni nj nk mz b">:before</code>我们可以制作一个简单的圆形边框，在边框上设置一些颜色，并用CSS动画旋转它。使用position:relative我们可以向下摆动动画使其对齐，因为行高或其他类似的技巧会引起一些麻烦。手动就行了。</p><p id="3c18" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Boom，AJAX状态指示器，所有脚本要做的就是打开和关闭一个类。90%以上的时间你看到JavaScript为动画做计算，你看到的是垃圾过时的代码。也有例外，但在任何现代网站上应该很少。</p><p id="37a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">工作演示在这里:<br/>T3】https://cutcodedown . com/for _ others/medium _ articles/rating stars/rating stars。JSEnhancement.html</p><h1 id="7aed" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">现场演示和来源</h1><p id="f914" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">所有的演示和代码都可以在这里找到:<br/><a class="ae lb" href="https://cutcodedown.com/for_others/medium_articles/ratingStars/" rel="noopener ugc nofollow" target="_blank">https://cutcodedown . com/for _ others/medium _ articles/rating stars/</a></p><p id="0df9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">包括一个供人们玩耍的完整的资源库。请注意它的三个不同阶段，没有CSS，有CSS但没有JS，以及完整的脚本增强版本。</p><h1 id="f9ba" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">利弊</h1><p id="1640" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">一如既往，先说它有什么问题。</p><h2 id="b086" class="nd ls it bd lt nm nn dn lx no np dp mb km nq nr mf kq ns nt mj ku nu nv mn nw bi translated">不足之处</h2><ul class=""><li id="114d" class="lc ld it kd b ke mp ki mq km nx kq ny ku nz ky oa li lj lk bi translated">由于对通过for/id的输入/标签配对的依赖和额外的跨度，标记可能感觉有点沉重。这也使得创建多个实例变得更加困难，因为您需要确保所有不同的集合都有不同的名称和id。</li><li id="69bd" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky oa li lj lk bi translated">作为编码，这目前有零IE支持，虽然它确实优雅地降级在上述浏览器可接受的。这是可以调整的，但是这些天IE和基于查克拉的edge都到了生命的终点？不值得修复，我只会在这些平台上屏蔽CSS和JS。</li><li id="3f7f" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky oa li lj lk bi translated">未在OSX或Safari上测试。目前，我的机器库存中没有这种价格过高的垃圾。</li></ul><h2 id="71fc" class="nd ls it bd lt nm nn dn lx no np dp mb km nq nr mf kq ns nt mj ku nu nv mn nw bi translated">优势</h2><ul class=""><li id="d2d4" class="lc ld it kd b ke mp ki mq km nx kq ny ku nz ky oa li lj lk bi translated">适当的语义标记，以便替代导航和非屏幕用户不会被冷落。保持基本的可访问性。</li><li id="c68a" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky oa li lj lk bi translated">可以为非脚本用户实现该功能，即使这意味着触发页面加载。</li><li id="b84a" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky oa li lj lk bi translated">脚本增强功能可以选择性地阻止页面加载，让我们两全其美。</li><li id="14bf" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky oa li lj lk bi translated">关注点的分离得到了维护，即使加载某种样式的脚本可能看起来不是这样。说CSS只是给脚本用的，那为什么在可能用不到的时候发给所有用户呢？</li><li id="4506" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky oa li lj lk bi translated">跨多个页面使用，其中大部分可以缓存在同一个样式表和脚本中。</li><li id="7696" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky oa li lj lk bi translated">脚本挂钩使用现有的<code class="fe ni nj nk mz b">&lt;form&gt;</code>中的<code class="fe ni nj nk mz b">action=””</code></li><li id="32a4" class="lc ld it kd b ke ll ki lm km ln kq lo ku lp ky oa li lj lk bi translated">适用于所有现代浏览器。<em class="lq">(基本上都是壁虎和类Chrome。我不再认为Safari像webkit一样现代，而是像牛奶一样老化！)</em></li></ul><h1 id="4533" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="444d" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">制作用户界面的“渐进增强”方法在可访问性和易用性方面总是有回报的。您最终需要更少的脚本，并且不管CSS是否相关或者JS是否存在，页面都可以工作。</p><p id="5698" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CSS和JavaScript的进步无疑使整个过程变得更加容易，过去需要几十行JavaScript代码的许多事情现在可以由CSS处理，而不需要任何JS……当需要/保证/期望脚本时，只需进行类交换并让CSS做真正的工作就容易多了。</p></div></div>    
</body>
</html>