<html>
<head>
<title>Ufonaut for Postman</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">邮递员的Ufonaut</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ufonaut-for-postman-aeacd87142be?source=collection_archive---------26-----------------------#2021-07-14">https://levelup.gitconnected.com/ufonaut-for-postman-aeacd87142be?source=collection_archive---------26-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自动化并加速测试REST服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a57e8d64e3f158a15501585089347c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4ZzifTdARN2VFAl02X_oQ.png"/></div></div></figure><p id="435b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本帖面向所有喜欢<a class="ae lq" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">邮差</em> </a>测试API服务的人。它是一个非常棒的工具，有许多特性，并且允许一些脚本功能，这使得手工测试人员的生活更加容易。</p><p id="40e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，没有什么是完美的，也没有什么能够处理世界上人们提出的所有情况。对我来说，我发现<em class="lr"> Postman </em>缺少一些使其更适用于自动化测试场景的特性。</p><p id="f7d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是我的观点，可以改进的地方。</p><h1 id="4e0d" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">#1订单节约</h1><p id="61a1" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">这是其中的一件事，每次你想用runner处理一个集合时，你都必须拖放订单。<em class="lr"> Postman </em>的更新版本(8.6.2)具有可以用作新运行的模板的历史，但是如果集合被更新或者如果我们想要测试稍微不同的场景，那么我们将需要每次调整顺序。</p><h1 id="f3d4" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">#2保存预先请求和测试</h1><p id="9dd8" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在一些情况下，这可能是有用的。第一个是当我们的脚本变得足够大时，在小窗口中工作开始变得令人讨厌，启用了一些linters或拼写检查器的文件会更有吸引力。<br/>第二，当有一些新的变化时，可能需要集合导入，我们不想丢失这些宝贵的脚本或手动移动它们。</p><h1 id="9b3a" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">#3为跑步者保存预设</h1><p id="4a31" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">这与第一个问题半相关，可以通过历史得到部分解决。但是它面临与第一个相同的问题，因为当集合被更新时，新的端点不包括在历史中。在快节奏的工作场所，事情往往出现得非常快，因此变化开始妨碍我们的工作，让我们慢下来，或者让事情变得非常烦人。</p><h1 id="4b23" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">#4发送前修改请求正文</h1><p id="c283" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">实际上<em class="lr">是</em>的一个问题，在任务前脚本中无法修改请求体(<a class="ae lq" href="https://github.com/postmanlabs/postman-app-support/issues/4808" rel="noopener ugc nofollow" target="_blank"> #4808 </a>)。然而，当我决定写点什么的时候，它似乎已经解决了。</p><h1 id="e479" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">#5场景测试</h1><p id="4b24" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">为场景测试保存预设的能力。这是第一个和第三个问题的结合。缺少这种功能会导致我们不得不将所有场景编写到一个单独的“预请求”或“测试”选项卡中，或者拥有许多包含不同情况的不同集合，这从长远来看很难管理，例如，当每天都有新的端点被创建、删除或更改时。</p><p id="9b83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我创造了一个叫做<a class="ae lq" href="https://github.com/b-pagis/ufonaut" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> ufonaut </em> </a>的工具来解决上面提到的问题。我知道这个工具并不适用于所有的情况，但是它确实有助于自动化和管理测试过程。</p><p id="cbd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr"> Ufonaut </em>是一个CLI实用程序，用于将开放API文档转换为带有自动测试附加选项的<em class="lr"> Postman </em>集合。转换后的收藏可以用<a class="ae lq" href="https://github.com/postmanlabs/newman" rel="noopener ugc nofollow" target="_blank"> <em class="lr">纽曼</em> </a>代替<em class="lr">邮差</em>中的转轮启动。</p><p id="f011" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文章的剩余部分将简要描述用例，如何使用<em class="lr"> Postman </em>解决它们，以及如何在CI/CD过程中重用这些用例以进行自动化测试。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="dd74" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">准备</h1><p id="89ce" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">为了演示这些问题并提供解决方案，我将使用我的<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/go-swagger-and-open-api-e6b6ea4ce48f">其他文章</a>中的<a class="ae lq" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Go </em> </a>中编写的简单服务。</p><p id="7c27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，通过编译<em class="lr"> Go </em>二进制文件并将其作为服务运行来启动服务，其中开放API文档可在<code class="fe nb nc nd ne b">http://localhost:8080/swagger/doc.json</code>获得(在我的例子中)。</p><blockquote class="nf ng nh"><p id="9edb" class="ku kv lr kw b kx ky ju kz la lb jx lc ni le lf lg nj li lj lk nk lm ln lo lp im bi translated"><em class="it">如果由于某种原因，你没有心情进行自编译，那么你可以从这里</em> <a class="ae lq" href="https://github.com/b-pagis/medium-go-swagger2openapi/releases/tag/1.0.0" rel="noopener ugc nofollow" target="_blank"> <em class="it">下载二进制文件</em> </a> <em class="it">。</em></p></blockquote><p id="db9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">服务正在运行，所以让我们使用<em class="lr"> Postman </em>来准备我们的案例。只需打开应用程序，点击导入并选择链接(或使用其他选项)。更多信息可以查看<a class="ae lq" href="https://learning.postman.com/docs/getting-started/importing-and-exporting-data/#importing-data-into-postman" rel="noopener ugc nofollow" target="_blank">官方文档页面</a>。</p><p id="40bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">导入完成后，我们应该看到以下集合</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/118887a356b77c9b58270b59845ed586.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*bPQGoAPrI3JSNfO9KCUmkg.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated"><em class="nq">已将open API doc文件转换为Postman集合</em></figcaption></figure><p id="a64c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步是为我们的服务设置<code class="fe nb nc nd ne b">baseUrl</code>。创建新环境并定义<code class="fe nb nc nd ne b">baseUrl</code>属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/4ec1416c23a4c2fbf8d214d6cff3805e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJNN0t4jcYeRjnuG9stSaA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">在Postman中设置环境</figcaption></figure><p id="3868" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们需要通过运行以下命令来安装<em class="lr"> ufonaut </em>:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="ee01" class="nw lt it ne b gy nx ny l nz oa">npm install -g @b-pagis/ufonaut</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="c91b" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">入门指南</h1><p id="9f58" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">初始设置已经完成，现在让我们运行服务二进制文件，并第一次调用<code class="fe nb nc nd ne b">list all boxes</code>端点。我们应该得到以下响应:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="efe0" class="nw lt it ne b gy nx ny l nz oa">[<br/>  {<br/>    "isFragile": true,<br/>    "createdAt": "2021-06-05T11:13:33.387273692Z",<br/>    "price": 5.77<br/>  },<br/>  {<br/>    "isFragile": false,<br/>    "createdAt": "2021-06-05T11:13:33.387273826Z",<br/>    "price": 1.23<br/>  }<br/>]</span></pre><p id="39b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这没什么特别的，因为它只是返回一些硬编码的值，但是它表明服务是活动的并且可访问的。现在，如果我们尝试调用另一个名为<code class="fe nb nc nd ne b">Create new box</code>的端点，我们会看到这种情况发生。</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="e2f6" class="nw lt it ne b gy nx ny l nz oa">{<br/>  "code": "unauthorized"<br/>}</span></pre><p id="d0c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它返回<em class="lr">未授权的</em>，这意味着我们需要首先调用<code class="fe nb nc nd ne b">Sign In</code>端点，以便启动假会话。该服务使用以下硬编码凭据:</p><ul class=""><li id="320d" class="ob oc it kw b kx ky la lb ld od lh oe ll of lp og oh oi oj bi translated"><code class="fe nb nc nd ne b">demo</code> -用于登录</li><li id="c10a" class="ob oc it kw b kx ok la ol ld om lh on ll oo lp og oh oi oj bi translated"><code class="fe nb nc nd ne b">12356</code> -为密码。</li></ul><p id="34a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">成功登录请求后，我们可以再次呼叫<code class="fe nb nc nd ne b">Create new box</code>，如果一切如预期，我们应该得到以下响应:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="a2ca" class="nw lt it ne b gy nx ny l nz oa">{<br/>  "status": "success"<br/>}</span></pre><p id="5f9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要为我们的端点编写一些测试。为了简单起见，检查正确的状态代码就可以了，邮递员<em class="lr">已经有了这个代码片段，所以只需点击几下。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/63a92e45f682ad519a7b729cc2e77114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HEysq6ctsx-uqdiECKYabg.gif"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">从可用片段添加简单的状态测试</figcaption></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="f94c" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">#1订单节约—解决方案</h1><p id="2780" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们已经完成了基础知识，所以，我们可以通过启动runner来处理第一个问题，看看会发生什么。在点击<code class="fe nb nc nd ne b">Start Run</code>按钮之前，确保我们有以下设置:</p><p id="7e38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">🗹保持响应<br/> ☐保持变量值<br/> 🗹运行收集而不使用存储的cookie<br/>☐在收集运行后保存cookie</p><p id="75b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不要改变集合的任何顺序，点击<code class="fe nb nc nd ne b">Start Run</code>看看会发生什么(我猜你已经知道了😃).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/b869fe5b39e90011b1171f75be59c691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1nYJoNdKYnKV7ca42G7Pdg.gif"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">在“创建新盒子”请求时运行测试失败</figcaption></figure><p id="35eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您从上面的GIF中看到的，运行在<code class="fe nb nc nd ne b">Create new box</code>步骤失败，如果我们调查响应，我们将看到401未授权，响应正文也包含<code class="fe nb nc nd ne b">unauthorized</code>错误代码。</p><p id="ff98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，为了解决这个问题，我们需要改变流道中端点的顺序。我们可以说这没什么大不了的，只要把列表中的条目拖拽到第一个位置就搞定了。<br/>是的，对于下面的例子来说，这没什么大不了的，但是如果我们进入现实世界，想象我们自己在工作环境中，我们需要移动五个端点，而不是一个端点，只是为了进行授权。但是授权本身可能没有任何意义，因为我们通常倾向于测试业务案例，所以我们需要重新排序其他七个端点来创建必要的对象，如开户、进行交易、查看语句等等…</p><p id="e982" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了让事情变得更“有吸引力”,想象一下我们必须每30分钟运行一次，因为重大变更、快速发布或其他“有效”的原因，如下所示😂</p><div class="kj kk kl km gt ab cb"><figure class="or kn os ot ou ov ow paragraph-image"><img src="../Images/b41344bb6f8605838e0bc3004a0766d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*2NeJzKUAFIJ6s6PvpYy9kQ.gif"/></figure><figure class="or kn ox ot ou ov ow paragraph-image"><img src="../Images/c0b285c0602a30306d332bf705b08607.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*ft1hPGJkd66pXb-xpC-p1g.gif"/></figure></div><p id="a602" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">突然事情变得很烦人。</p><p id="c208" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们可以使用<a class="ae lq" href="https://github.com/b-pagis/ufonaut" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> ufonaut </em> </a>来应用解决方案。它有一个选项来配置我们想要运行的端点的顺序。首先，我们需要创建配置文件，并指定运行程序的顺序。</p><p id="7b15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要获得服务中可用端点的列表，我们可以手动完成，或者运行以下命令:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="3b22" class="nw lt it ne b gy nx ny l nz oa">ufonaut endpoints -i <a class="ae lq" href="http://localhost:8080/swagger/doc.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger/doc.json</a></span></pre><p id="aaf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将输出以下结果</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="6c50" class="nw lt it ne b gy nx ny l nz oa">get boxes<br/>post boxes<br/>post boxes/big<br/>post signin</span></pre><p id="d4fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以很容易地将这个输出转换成配置文件，同时将我们的<code class="fe nb nc nd ne b">signin</code>方法作为第一个条目。结果应该是这样的:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="3561" class="nw lt it ne b gy nx ny l nz oa">{<br/>  "order": [<br/>    {<br/>      "method": "post",<br/>      "path": "signin"<br/>    },<br/>    {<br/>      "method": "get",<br/>      "path": "boxes"<br/>    },<br/>    {<br/>      "method": "post",<br/>      "path": "boxes"<br/>    },<br/>    {<br/>      "method": "post",<br/>      "path": "boxes/big"<br/>    }<br/>  ]<br/>}</span></pre><p id="3e6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将此保存到名为<code class="fe nb nc nd ne b">box-order.json</code>的文件中。</p><p id="6371" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们将需要使用<em class="lr"> ufonaut </em>将开放API文档转换为应用了订单配置的<em class="lr"> Postman </em>集合。此外，应用一个额外的选项，并重命名我们的集合。下面是这样做的命令:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="1508" class="nw lt it ne b gy nx ny l nz oa">ufonaut convert -i <a class="ae lq" href="http://localhost:8080/swagger/doc.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger/doc.json</a> -o postman-collection-ordered.json -cr "Example Box Service - Ordered" -d box-order.json</span></pre><p id="3a45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们再次将我们的新集合导入到<em class="lr"> Postman </em>中，我们会看到<code class="fe nb nc nd ne b">Sign up</code>方法位于列表的顶部</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/59f1c33118563a536b2ef72751b32b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*CH5Z4DKNoqHnlZfTe-gmRg.png"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">应用了“排序”选项的集合</figcaption></figure><p id="bf83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们用相同的配置启动runner，我们将看到所有请求都返回成功结果。不幸的是，我们的测试也不见了，因为我们已经用有序的配置导入了这个集合。这导致了第二个问题——将<code class="fe nb nc nd ne b">pre-request</code>和<code class="fe nb nc nd ne b">test</code>信息保存到文件中，但是无法将其加载回集合中。</p><p id="5978" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lr">注意:不幸的是，如果使用订单配置，集合将保存为平面结构。主要原因是为了避免复制文件夹或将端点添加到不属于它们的文件夹中。为了避免混淆和其他问题，选择了扁平结构，所以换句话说，这是在使用该选项时应该考虑的预期行为。</em></p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="153f" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">#2保存预先请求和测试—解决方案</h1><p id="473d" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们可以说这个问题是我们人为造成的，但是再一次，想象一下快节奏的环境，10个开发人员正在构建新的服务，同时也在进行设计。在这样的环境中，我们必须预料到可能会有一些变化，比如请求或响应主体、请求参数甚至端点名称。</p><p id="c3b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可能有两个选项来处理这些变化，或者在现有集合中手动进行所有调整，或者在发生这种变化时重新导入开放API文档。两者都有各自的弊端。</p><p id="9dac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，<a class="ae lq" href="https://github.com/b-pagis/ufonaut" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> ufonaut </em> </a>有一个从文件中加载<code class="fe nb nc nd ne b">pre-request</code>和<code class="fe nb nc nd ne b">test</code>脚本的选项。这是一个方便的特性，如果您经常需要重新导入open API文档，并且您不想丢失那些宝贵的脚本或者将它们从旧的集合复制并粘贴到新的集合，那么它可以节省大量时间。</p><p id="7506" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使用这个特性，我们必须创建一个工作空间，其中有两个文件夹<code class="fe nb nc nd ne b">pre-request</code>用于预请求文件，而<code class="fe nb nc nd ne b">test</code>用于测试文件。它应该是这样的:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="a5df" class="nw lt it ne b gy nx ny l nz oa">workspace/<br/>├── pre-request<br/>└── test</span></pre><p id="266b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们之前的集合中，我们添加了一些状态代码测试，以确保一切正常工作。让我们将它们保存到文件中！这部分有点棘手，因为我们需要知道如何命名这些文件。<em class="lr"> Ufonaut </em>使用规范化函数，该函数采用方法和端点的路径值，并将其连接成单个字符串。我们可以使用下面的命令找出<em class="lr"> box-service </em>规范化的端点名称:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="170b" class="nw lt it ne b gy nx ny l nz oa">ufonaut endpoints -i <a class="ae lq" href="http://localhost:8080/swagger/doc.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger/doc.json</a> -n</span></pre><p id="8812" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它应该输出以下信息:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="1b40" class="nw lt it ne b gy nx ny l nz oa">get boxes | get-boxes<br/>post boxes | post-boxes<br/>post boxes/big | post-boxesbig<br/>post signin | post-signin</span></pre><p id="f9f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出的结构很简单，由<code class="fe nb nc nd ne b">&lt;original HTTP method&gt; &lt;original URL&gt; | &lt;normalized name&gt;</code>负责。我们可以转到<code class="fe nb nc nd ne b">workspace</code>目录中的<code class="fe nb nc nd ne b">test</code>文件夹并创建这些文件。您可以像<code class="fe nb nc nd ne b">&lt;normalized-name&gt;.js</code>一样手动创建它们，或者如果您使用的是Linux，可以运行以下命令:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="7b1c" class="nw lt it ne b gy nx ny l nz oa">touch $(ufonaut endpoints -i <a class="ae lq" href="http://localhost:8080/swagger/doc.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger/doc.json</a> -n | awk '{print $4".js"}')</span></pre><p id="e9ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，文件夹结构应该是这样的:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="94e2" class="nw lt it ne b gy nx ny l nz oa">workspace/<br/>├── pre-request<br/>└── test<br/>    ├── get-boxes.js<br/>    ├── post-boxesbig.js<br/>    ├── post-boxes.js<br/>    └── post-signin.js</span></pre><p id="ee75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要通过匹配相应的端点名称来将这些测试脚本复制到这些文件中。之后，我们需要用附加选项再次转换开放API文档。这是一个命令:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="32bd" class="nw lt it ne b gy nx ny l nz oa">ufonaut convert -i <a class="ae lq" href="http://localhost:8080/swagger/doc.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger/doc.json</a> -o postman-collection-ordered-with-scripts.json -cr "Example Box Service - Ordered - With Scripts" -d box-order.json -s workspace/</span></pre><p id="c0c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">工具自动在指定的<code class="fe nb nc nd ne b">workspace</code>位置寻找<code class="fe nb nc nd ne b">pre-request</code>和<code class="fe nb nc nd ne b">test</code>目录。然后它获取端点列表，将其规范化，映射具有匹配名称的文件，并将脚本文件中的内容加载到<em class="lr"> Postman </em>集合中。</p><p id="26eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在将这个新的<code class="fe nb nc nd ne b">postman-collection-ordered-with-scripts.json</code>集合导入到<em class="lr"> Postman </em>之后，我们会看到我们所有的请求都有来自文件的脚本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/7ba47f1d8a14672b5394349b50833167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJDxWrCdU90ZFTAxKK-b6g.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">包含从文件加载的测试内容的集合</figcaption></figure><p id="0e99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们用之前的设置将这个文件放到runner中，我们将会看到所有的请求都被成功执行，并且有4个测试已经通过。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/966da8ef36cdb6491e8deec00df35900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9FVjt78KB9D05NqdQxRlPQ.gif"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">使用从文件加载的排序和测试在runner中运行集合</figcaption></figure><p id="e0d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样的逻辑也适用于<code class="fe nb nc nd ne b">pre-request</code>脚本。它们必须以相同的方式命名，但是放置在<code class="fe nb nc nd ne b">pre-request</code>目录中。这两种组合特别方便，节省了大量时间，因为我们只需要定义一次<code class="fe nb nc nd ne b">*.js</code>文件，然后我们可以根据需要多次重新导入开放API文档，并且不会丢失那些宝贵的<code class="fe nb nc nd ne b">test</code>和<code class="fe nb nc nd ne b">pre-request</code>文件。</p><p id="40b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果我们想跳过运行程序中的一些端点，这种方法仍然不能解决问题，因为各种原因，比如知道它有问题，还没有对它们进行测试，或者只是不想为这个业务流调用它们。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="563a" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">#4发送前修改请求正文—解决方案</h1><p id="10be" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在进入下一个问题之前，我只想提到还有另一个问题，即<a class="ae lq" href="https://github.com/postmanlabs/postman-app-support/issues/4808" rel="noopener ugc nofollow" target="_blank">不可能在请求</a>之前修改请求前脚本中的请求内容，从今天起，我们似乎不再需要将请求体放入<code class="fe nb nc nd ne b">pre-request</code>脚本并存储到变量中的解决方法。<a class="ae lq" href="https://github.com/postmanlabs/postman-app-support/issues/4808#issuecomment-826838064" rel="noopener ugc nofollow" target="_blank"> <em class="lr">邮差</em>团队实现了开箱即用的解决方案</a>。尽管事实上，我只是想展示这个特性，而我们仍然在预请求/测试主题。</p><p id="1c7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该选项允许通过将请求体放入变量来模板化<code class="fe nb nc nd ne b">pre-request</code>脚本，并使其在预请求脚本中可访问。为了看到这个特性的运行，我们必须创建一个模板文件。让我们在我们的工作区中这样做，将其命名为<code class="fe nb nc nd ne b">template-example.js</code>(或者我们喜欢的任何其他名称，例如<code class="fe nb nc nd ne b">my-template.template</code>)，并将以下内容放入其中:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="9848" class="nw lt it ne b gy nx ny l nz oa">var requestBody = &lt;%%=requestBody=%%&gt;;</span><span id="8046" class="nw lt it ne b gy pa ny l nz oa">&lt;%%=scriptContent=%%&gt;</span><span id="9f27" class="nw lt it ne b gy pa ny l nz oa">pm.environment.set('requestBody', JSON.stringify(requestBody));</span></pre><p id="453d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过运行以下命令，为带注释的登录端点创建<code class="fe nb nc nd ne b">pre-request</code>:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="591b" class="nw lt it ne b gy nx ny l nz oa">echo "// this is pre-request script file and it could contain any logic" &gt; workspace/pre-request/post-signin.js</span></pre><p id="e6b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的工作区结构应该是这样的:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="acc4" class="nw lt it ne b gy nx ny l nz oa">workspace/<br/>├── pre-request<br/>│   └── post-signin.js<br/>├── template-example.js<br/>└── test<br/>    ├── get-boxes.js<br/>    ├── post-boxesbig.js<br/>    ├── post-boxes.js<br/>    └── post-signin.js</span></pre><p id="6a81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用模板选项为<em class="lr"> ufonaut </em>运行之前的<code class="fe nb nc nd ne b">convert</code>命令:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="d9fc" class="nw lt it ne b gy nx ny l nz oa">ufonaut convert -i <a class="ae lq" href="http://localhost:8080/swagger/doc.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger/doc.json</a> -o postman-collection-ordered-with-scripts-templated.json -cr "Example Box Service - Ordered - With Scripts - Templated" -d box-order.json -s workspace/ -t workspace/template-example.js</span></pre><p id="245a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将<code class="fe nb nc nd ne b">postman-collection-ordered-with-scripts-templated.json</code>集合导入到Postman中会得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/edc22b76fc82558a7294164ee0671904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IXFCd544nLXteDFwHIHJYQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">集合，其中请求体被替换为变量I</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/1f24465d8c60b9ef37491e4ee8b9d985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BBIsLuQOHX78dgC7dW-XA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">用变量II替换请求体的集合</figcaption></figure><p id="db10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模板选项是全局的，因此通过将请求正文放在请求前脚本中，它将应用于所有请求。正如我之前提到的，这是几年前的一个老问题的解决方案，当时缺少开箱即用的功能。但也许这在某些情况下还是有用的。</p><p id="2e63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论如何，让我们回到主题，转移到最后一个问题——检查和取消检查用于测试不同场景的复选框。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="8103" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">#3保存跑步者预设&amp; #5场景测试-解决方案</h1><p id="a3a6" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">当涉及到持续测试时，排序和应用脚本确实很有帮助，但是当我们的端点列表变得非常大，而开发团队只对特定的端点子集进行更改时，会发生什么呢？或者，如果我们想测试特定的业务流，比如用户注册，而不是其他，该怎么办？</p><p id="2e57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的开放API文档不适合展示这类情况的好例子，因为它只有4个端点。但是尽力想象有一个业务流，我们只想唱进去，创造一个盒子。每次我们启动运行程序时，我们总是需要取消选中<code class="fe nb nc nd ne b">List all boxes</code>和<code class="fe nb nc nd ne b">Create new Big box</code>端点，这样它们就不会包含在运行中。</p><p id="7356" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，你可以说这可以通过创建许多不同的订单文件来解决，但是订单文件并不删除端点，并且<a class="ae lq" href="https://github.com/b-pagis/ufonaut" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> ufonaut </em> </a>有另一个选项来处理这类问题— <em class="lr">集合</em>。</p><p id="c5d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以把集合想象成小的<em class="lr"> Postman </em>集合，它可以应用所有以前的选项，但是另外从其中删除未使用的端点。为了看到这一点，我们需要通过运行<code class="fe nb nc nd ne b">touch workspace/box-sets.json </code>来创建<em class="lr"> set </em>配置，并为我们的业务场景放置以下配置:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="af8c" class="nw lt it ne b gy nx ny l nz oa">{<br/>  "sets": [<br/>    {<br/>      "collectionName": "login-create-box-example",<br/>      "scriptsPath": "workspace/",<br/>      "template": {<br/>        "preRequestTemplateFilePath": "workspace/template-example.template"<br/>      },<br/>      "order": [<br/>        {<br/>          "method": "post",<br/>          "path": "signin"<br/>        },<br/>        {<br/>          "method": "post",<br/>          "path": "boxes"<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="109d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将添加先前关于模板、<code class="fe nb nc nd ne b">pre-request</code>和<code class="fe nb nc nd ne b">test</code>脚本的设置。</p><p id="3f2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当配置文件准备好时，我们需要运行以下命令来创建<em class="lr"> Postman </em>集合:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="634b" class="nw lt it ne b gy nx ny l nz oa">ufonaut create-sets -i <a class="ae lq" href="http://localhost:8080/swagger/doc.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger/doc.json</a> -c box-sets.json  -o workspace/sets</span></pre><p id="0d4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一切顺利，那么在我们的工作区目录中应该有新的目录<code class="fe nb nc nd ne b">sets</code>，它应该包含我们的set文件，就像这样:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="1e68" class="nw lt it ne b gy nx ny l nz oa">workspace/<br/>├── pre-request<br/>│   └── post-signin.js<br/>├── sets<br/>│   └── signin-create-box-example.json<br/>├── template-example.template<br/>└── test<br/>    ├── get-boxes.js<br/>    ├── post-boxesbig.js<br/>    ├── post-boxes.js<br/>    └── post-signin.js</span></pre><p id="019d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将这个<code class="fe nb nc nd ne b">signin-create-box-example.json</code>集合导入到Postman中，我们应该会看到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/5e9818f738a1a3d872630ae50c7e1494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLhAVXuVxubhzQbGuddKzw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">从集合配置创建的集合</figcaption></figure><p id="c321" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如图所示，只有两个端点，这是我们的场景所需要的，并且它们具有加载了实际请求正文的测试和预请求文件内容，这些正文放在预请求文件中。就像我们在模板中指定的那样。</p><p id="fabf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在另一种情况下，我们想得到所有的盒子，然后登录，然后创建一个大盒子，但没有模板。哦，应用附加的基本认证设置。听起来很复杂，但配置变化不大:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="6c12" class="nw lt it ne b gy nx ny l nz oa">{<br/>  "sets": [<br/>    {<br/>      "collectionName": "signin-create-box-example",<br/>      "scriptsPath": "workspace/",<br/>      "template": {<br/>        "preRequestTemplateFilePath": "workspace/template-example.template"<br/>      },<br/>      "order": [<br/>        {<br/>          "method": "post",<br/>          "path": "signin"<br/>        },<br/>        {<br/>          "method": "post",<br/>          "path": "boxes"<br/>        }<br/>      ]<br/>    },<br/>    {<br/>      "sets": [<br/>        {<br/>          "collectionName": "list-box-signin-create-big-box-with-auth-example",<br/>          "scriptsPath": "examples/scripts",<br/>          "auth": {<br/>            "type": "basic",<br/>            "forced": true,<br/>            "basic": {<br/>              "username": "some-username",<br/>              "password": "some-password"<br/>            }<br/>          },<br/>          "order": [<br/>            {<br/>              "method": "get",<br/>              "path": "boxes"<br/>            },<br/>            {<br/>              "method": "post",<br/>              "path": "signin"<br/>            },<br/>            {<br/>              "method": "post",<br/>              "path": "boxes"<br/>            }<br/>          ]<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="a24b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没有什么复杂的，只是列表中的另一个配置。是的，这确实意味着在一个文件中描述不同的集合是可能的。例如，当我们想要从有错误的场景中分离出成功的场景时，这就变得很方便，因为我们可以使用不同的<code class="fe nb nc nd ne b">scripts</code>目录，这可能会导致不同的请求前检查测试用例。</p><p id="cf34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行相同的命令:</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="a40a" class="nw lt it ne b gy nx ny l nz oa">ufonaut create-sets -i <a class="ae lq" href="http://localhost:8080/swagger/doc.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/swagger/doc.json</a> -c box-sets.json  -o workspace/sets</span></pre><p id="f359" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">应该在我们的工作区目录中添加名为<code class="fe nb nc nd ne b">list-box-signin-create-big-box-with-auth-example.json</code>的附加文件</p><pre class="kj kk kl km gt ns ne nt nu aw nv bi"><span id="8da2" class="nw lt it ne b gy nx ny l nz oa">workspace/<br/>├── pre-request<br/>│   └── post-signin.js<br/>├── sets<br/>│   ├── list-box-signin-create-big-box-with-auth-example.json<br/>│   └── signin-create-box-example.json<br/>├── template-example.template<br/>└── test<br/>    ├── get-boxes.js<br/>    ├── post-boxesbig.js<br/>    ├── post-boxes.js<br/>    └── post-signin.js</span></pre><p id="5e6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，最后一次将这个导入到<em class="lr">邮递员</em>中，看看最后的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/4037fb7d32cf3dcf9bb6b56f855dd621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EO8hLevmg1t05wF6eKB2Hg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">应用了基本授权的集合</figcaption></figure><p id="52bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个新的集合包含三个端点，它们在集合配置中列出。最重要的是，这些端点被强制应用了基本身份验证选项。</p><blockquote class="nf ng nh"><p id="f06c" class="ku kv lr kw b kx ky ju kz la lb jx lc ni le lf lg nj li lj lk nk lm ln lo lp im bi translated"><em class="it">边注:在</em> <code class="fe nb nc nd ne b"><em class="it">convert</em></code> <em class="it">命令中也可以使用强制认证设置。</em></p></blockquote><p id="d52d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">差不多就这些了。差不多吧，因为有些事我以前没提过，有些事我还想提。所以再忍耐一点点。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="46ce" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">插入文字</h1><p id="ba73" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在转换和创建器械包或将订单配置应用到器械包<a class="ae lq" href="https://github.com/b-pagis/ufonaut" rel="noopener ugc nofollow" target="_blank"> <em class="lr">时，ufonaut </em> </a>还会做一件事。它用<a class="ae lq" href="https://en.wikipedia.org/wiki/String_interpolation" rel="noopener ugc nofollow" target="_blank">插值</a>值替换请求体值，这意味着它们可以在环境或全局变量中设置。这与前面描述的功能相结合，增加了额外的灵活性。例如，我们可以在预请求脚本文件中生成随机信息，加载它，每个请求将使用这些现成的生成值。当然如果名字正确的话。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="ccb2" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">和纽曼一起经营</h1><p id="7cb0" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">这款工具的初衷并不是为了配合<em class="lr">邮递员</em>奔跑者使用，而是配合<a class="ae lq" href="https://www.npmjs.com/package/newman" rel="noopener ugc nofollow" target="_blank"> <em class="lr">纽曼</em> </a>使用。想法是在<em class="lr"> Postman </em>的帮助下编写一次这些测试/集合，然后将测试保存在文件中，并将其全部放入某个存储库中。然后在CI/CD步骤中，克隆这个存储库启动服务，使用<a class="ae lq" href="https://github.com/b-pagis/ufonaut" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> ufonaut </em> </a>将开放API文档转换成多个集合，并使用<em class="lr"> newman </em>并行运行它们以测试各种情况。然后检查业务流程中是否有任何问题。</p><p id="9af3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当公司有更多/只有手动测试人员时，这种方法是有用的，因为它使他们永远不会一遍又一遍地测试相同的场景，而是通过各种示例编写几行代码，将信息推送到存储库，然后享受一些时间，而自动化方法覆盖了每次构建应用程序时的大多数事情。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/30c632b35558131d1d083fc7a27898c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*hh5rLWhewWM5FjLTXAwTJQ.gif"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="31f2" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">html-extra的积分</h1><p id="91e7" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">还有一点我想提的是<em class="lr">纽曼</em>有一个插件，叫<a class="ae lq" href="https://github.com/DannyDainton/newman-reporter-htmlextra" rel="noopener ugc nofollow" target="_blank"> <em class="lr">纽曼-记者-htmlextra </em> </a>(无关系)，允许以漂亮易懂的格式导出测试结果。这对那些不太懂技术的人来说也是一件非常好的事情，因为他们可以清楚地看到提出了什么要求，得到了什么回应等等。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="79b2" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">结尾注释</h1><p id="c97b" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">唉，结局。这似乎是一个相当长的帖子，描述了<a class="ae lq" href="https://github.com/b-pagis/ufonaut" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> ufonaut </em> </a>的可能用途，以及它如何帮助解决一些角落的情况，这是<em class="lr">邮递员</em>没有涉及的。也许这个帖子之后，他们会添加这些功能(戳，戳)，也许不会。但在关键时刻，ufonaut会帮助并加速事情的进展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/aa10b9aa7f9a3a820be85bc2bbd14d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/1*ZgT2bTEx2A9pITM73ObNOQ.gif"/></div></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="5ee5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果这有帮助的话，那么你可以请我喝一杯热的☕虚拟咖啡</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://ko-fi.com/W7W04WZNY"><div class="gh gi pg"><img src="../Images/f70fb2bbb97e021536fd6f765c321c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*JTEj4geAZKmQXuEoWoZj7w.png"/></div></a></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://www.buymeacoffee.com/b.pagis"><div class="gh gi ph"><img src="../Images/fdca75bbe0eee382398964b8e17af001.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*2EZTVBB8eamy2BEJJYAnBg.png"/></div></a></figure><h1 id="72ff" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">链接</h1><div class="pi pj gp gr pk pl"><a href="https://github.com/b-pagis/ufonaut" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">b-pagis/ufonaut</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">用于将open api文档转换为postman集合的CLI，以及用于集成测试的附加选项，请使用…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">github.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://www.postman.com/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">postman | API开发的协作平台</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">进行任何种类的API调用——REST、SOAP或普通HTTP——并轻松检查最大的响应。邮递员也有…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">www.postman.com</p></div></div><div class="pu l"><div class="qa l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://github.com/DannyDainton/newman-reporter-htmlextra" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">丹尼登顿/纽曼-记者-htmlextra</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">一个纽曼HTML报告器，已经扩展到包括迭代运行的分离，所以这些不再…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">github.com</p></div></div><div class="pu l"><div class="qb l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://github.com/postmanlabs/newman" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">邮政实验室/纽曼</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">利用业界最完整的API开发环境，在Postman中管理您组织的所有API…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">github.com</p></div></div><div class="pu l"><div class="qc l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a rel="noopener  ugc nofollow" target="_blank" href="/go-swagger-and-open-api-e6b6ea4ce48f"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">Go，Swagger，并打开API</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">用S̶w̶a̶g̶g̶e̶r̶开放API记录Go REST服务</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pu l"><div class="qd l pw px py pu pz ks pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a href="https://en.wikipedia.org/wiki/String_interpolation" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">字符串插值-维基百科</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">编辑描述</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div></div></div>    
</body>
</html>