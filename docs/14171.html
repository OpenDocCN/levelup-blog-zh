<html>
<head>
<title>Generics in TypeScript — Must-Know Fundamentals Stupidly Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的泛型——愚蠢地简化了的基础知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/generics-in-typescript-must-know-fundamentals-stupidly-simplified-e7b4d7ffc0e3?source=collection_archive---------21-----------------------#2022-11-06">https://levelup.gitconnected.com/generics-in-typescript-must-know-fundamentals-stupidly-simplified-e7b4d7ffc0e3?source=collection_archive---------21-----------------------#2022-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="441e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文旨在通过应用于<strong class="js iu">函数的参数</strong>、应用于<strong class="js iu">函数的</strong> <strong class="js iu">返回类型</strong>以及应用于<strong class="js iu">类字段或方法</strong>的示例，以简单实用的方式解释和演示typescript泛型。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/31811d00ca675fc699d24af5d4d65032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GMtzgfJ5wbuvjMF7Ma-7gw.png"/></div></div></figure><p id="5196" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TL；这里的<a class="ae la" href="https://github.com/caopengau/typescript-generics-demo" rel="noopener ugc nofollow" target="_blank">博士码回购</a>。让我们开始吧…</p><h2 id="fdf4" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">没有泛型的问题</h2><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="3e34" class="lb lc it lv b gy lz ma l mb mc">function getArray(items : any[] ) : any[] {<br/>    return new Array().concat(items);<br/>}<br/><br/>let myNumArr = getArray([100, 200, 300]);<br/>let myStrArr = getArray(["Hello", "World"]);<br/><br/>myNumArr.push(400); // OK<br/>myStrArr.push("Hello TypeScript"); // OK<br/><br/>myNumArr.push("Hi"); // OK<br/>myStrArr.push(500); // OK<br/><br/>console.log(myNumArr); // [100, 200, 300, 400, "Hi"]<br/>console.log(myStrArr); // ["Hello", "World", "Hello TypeScript", 500]</span></pre><p id="8bc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，<code class="fe md me mf lv b">getArray()</code>函数接受any类型的数组。它创建一个any类型的新数组，将项连接到该数组，并返回新数组。因为我们使用了类型<code class="fe md me mf lv b">any</code>作为参数，所以我们可以将任何类型的数组传递给函数。但是，这可能不是我们想要的行为。我们可能希望将数字添加到数字数组中，或者将字符串添加到字符串数组中，而不是将数字添加到字符串数组中，反之亦然。</p><h2 id="cd25" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">解决办法</h2><p id="584c" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">泛型使用类型变量<code class="fe md me mf lv b">&lt;T&gt;</code>，一种特殊的表示类型的变量。type变量记住用户提供的类型，并且只使用该特定类型。这被称为保留类型信息。</p><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="d023" class="lb lc it lv b gy lz ma l mb mc">function getArray&lt;T&gt;(items : T[] ) : T[] {<br/>    return new Array&lt;T&gt;().concat(items);<br/>}<br/><br/>let myNumArr = getArray&lt;number&gt;([100, 200, 300]);<br/>let myStrArr = getArray&lt;string&gt;(["Hello", "World"]);<br/><br/>myNumArr.push(400); // OK<br/>myStrArr.push("Hello TypeScript"); // OK<br/><br/>myNumArr.push("Hi"); // Compiler Error<br/>myStrArr.push(500); // Compiler Error</span></pre><p id="3679" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，类型变量<code class="fe md me mf lv b">T</code>是用尖括号<code class="fe md me mf lv b">getArray&lt;T&gt;</code>中的函数指定的。类型变量<code class="fe md me mf lv b">T</code>也用于指定参数和返回值的类型。这意味着在函数调用时指定的数据类型也将是参数和返回值的数据类型。</p><p id="e6d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们调用通用函数<code class="fe md me mf lv b">getArray()</code>并传递数字数组和字符串数组。例如，调用函数为<code class="fe md me mf lv b">getArray&lt;number&gt;([100, 200, 300])</code>会将<code class="fe md me mf lv b">T</code>替换为<code class="fe md me mf lv b">number</code>，因此，参数和返回值的类型将是一个数字数组。同理，对于<code class="fe md me mf lv b">getArray&lt;string&gt;(["Hello", "World"])</code>，参数的类型和返回值都将是字符串数组。所以现在，如果你试图在<code class="fe md me mf lv b">myNumArr</code>中添加一个字符串或者在<code class="fe md me mf lv b">myStrArr</code>数组中添加一个数字，编译器会显示一个错误。因此，您获得了类型检查的优势。</p><p id="e7b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，泛型提供了一种创建可重用组件的方法，并提供了一种使组件与任何数据类型一起工作而不局限于一种数据类型的方法。因此，组件可以被多种数据类型调用或使用。</p><h1 id="8101" class="ml lc it bd ld mm mn mo lg mp mq mr lj ms mt mu lm mv mw mx lp my mz na ls nb bi translated">在API返回类型中使用泛型的示例</h1><p id="fd37" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">假设我们将两个外部数据源(随机电影和银行详细信息)集成到我们的系统中。</p><p id="9aa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有泛型</p><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="e484" class="lb lc it lv b gy lz ma l mb mc">import axios from "axios";<br/>const movieUrl = "<a class="ae la" href="https://k2maan-moviehut.herokuapp.com/api/random" rel="noopener ugc nofollow" target="_blank">https://k2maan-moviehut.herokuapp.com/api/random</a>";<br/>const bankUrl = "<a class="ae la" href="https://random-data-api.com/api/v2/banks" rel="noopener ugc nofollow" target="_blank">https://random-data-api.com/api/v2/banks</a>";</span><span id="36bf" class="lb lc it lv b gy nc ma l mb mc">const mainWithoutType = async () =&gt; {<br/>  const movieRes = await axios.get(movieUrl);<br/>  console.log(movieRes.data); // no way of knowing its data type<br/>  const bankRes = await axios.get(bankUrl);<br/>  console.log(bankRes.data); // no way of knowing its data type<br/>};<br/>mainWithoutType();</span></pre><p id="6395" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了泛型，我们可以在开发过程中更好地防止Typescript的错误。首先让我们创建一个文件<code class="fe md me mf lv b">types.ts</code>并定义类型<code class="fe md me mf lv b">Movie</code>和<code class="fe md me mf lv b">Bank</code></p><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="cf81" class="lb lc it lv b gy lz ma l mb mc">export type Movie = {<br/>  _id: string;<br/>  name: string;<br/>  releaseYear: number;<br/>  certificate: string;<br/>  runtime: string;<br/>  genre: string;<br/>  imdbRating: number;<br/>  overview: string;<br/>  metaScore: number;<br/>  director: string;<br/>};</span><span id="2092" class="lb lc it lv b gy nc ma l mb mc">export type Bank = {<br/>  id: number;<br/>  uid: string;<br/>  account_number: string;<br/>  iban: string;<br/>  bank_name: string;<br/>  routing_number: string;<br/>  swift_bic: string;<br/>};</span></pre><p id="184c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后让我们定义一个助手函数来包装API调用</p><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="9f53" class="lb lc it lv b gy lz ma l mb mc">import { Bank, Movie } from "./types";</span><span id="43b0" class="lb lc it lv b gy nc ma l mb mc">const getDataWithType = async &lt;T&gt;(<br/>  url: string<br/>): Promise&lt;AxiosResponse&lt;T&gt;&gt; =&gt; {<br/>  const response = await axios.get&lt;T&gt;(url);<br/>  return response;<br/>};</span></pre><p id="c53b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以在调用每个API时确定数据的类型。</p><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="cb61" class="lb lc it lv b gy lz ma l mb mc">...</span><span id="1081" class="lb lc it lv b gy nc ma l mb mc">const main = async () =&gt; {<br/>    const { data: movie } = await getDataWithType&lt;Movie&gt;(movieUrl);<br/>    const { data: bank } = await getDataWithType&lt;Bank&gt;(bankUrl);<br/>    console.log(movie); // Typing movie. hints Movie properties<br/>    console.log(bank); // Typing bank. hints Bank properties<br/>};<br/>...</span></pre><h1 id="cfeb" class="ml lc it bd ld mm mn mo lg mp mq mr lj ms mt mu lm mv mw mx lp my mz na ls nb bi translated">在API参数类型中使用泛型的示例</h1><p id="cb52" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">假设我们有一个util函数来帮助我们从<code class="fe md me mf lv b">movie</code>或<code class="fe md me mf lv b">bank</code>中提取名字</p><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="8f99" class="lb lc it lv b gy lz ma l mb mc">const extractName = &lt;T extends { name?: string, bank_name?: string}&gt;(<br/>  obj: T<br/>) =&gt; {<br/> if('name' in obj) return obj.name;<br/> if('bank_name' in obj) return obj.bank_name;<br/> return 'No name found';<br/>};</span></pre><p id="7915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以在我们的主函数中使用它</p><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="b706" class="lb lc it lv b gy lz ma l mb mc">const main = async () =&gt; {<br/>  const { data: movie } = await getDataWithType&lt;Movie&gt;(movieUrl);<br/>  const { data: bank } = await getDataWithType&lt;Bank&gt;(bankUrl);</span><span id="8476" class="lb lc it lv b gy nc ma l mb mc">  console.log(extractName(movie));<br/>  console.log(extractName(bank));<br/>};</span></pre><h1 id="a188" class="ml lc it bd ld mm mn mo lg mp mq mr lj ms mt mu lm mv mw mx lp my mz na ls nb bi translated">在类字段和方法中使用泛型的示例</h1><p id="f155" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">TypeScript支持泛型类。泛型类型参数在类名后的尖括号中指定。泛型类可以有泛型字段(成员变量)或方法。</p><pre class="kp kq kr ks gt lu lv lw lx aw ly bi"><span id="2c4c" class="lb lc it lv b gy lz ma l mb mc">class KeyValueProcessor&lt;T,U&gt;<br/>{<br/>    <!-- -->// adding ! to avoid TS2564 error<br/>    <!-- -->private key!: T;<br/>    private val!: U;<br/><br/>    setKeyValue(key: T, val: U): void { <br/>        this.key = key;<br/>        this.val = val;<br/>    }<br/><br/>    display():void { <br/>        console.log(`Key = ${this.key}, val = ${this.val}`);<br/>    }<br/>}<br/><br/>let kvp1 = new KeyValuePair&lt;number, string&gt;();<br/>kvp1.setKeyValue(1, "Steve");<br/>kvp1.display(); //Output: Key = 1, Val = Steve <br/><br/>let kvp2 = new KayValuePair&lt;string, string&gt;();<br/>kvp2.SetKeyValue("CEO", "Bill"); <br/>kvp2.display(); //Output: Key = CEO, Val = Bill</span></pre><h2 id="386e" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">延伸阅读:</h2><ul class=""><li id="41b8" class="nd ne it js b jt mg jx mh kb nf kf ng kj nh kn ni nj nk nl bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/typescript-must-know-fundamentals-for-your-next-tech-interview-or-project-255ae70df0a3"> TypeScript必备基础知识—类型别名和接口</a></li><li id="6067" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-keyof-like-a-pro-56f3a3d06b73">像专业人士一样使用Typescript keyof】</a></li><li id="81d8" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/typescript-classes-from-zero-to-hero-a429a3c96189">打字稿类——从零到英雄</a></li><li id="c559" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/next-level-your-typescript-runtime-type-validation-using-class-and-decorators-ddd2ce3c86f3">使用类和装饰器的下一级Typescript运行时类型验证</a></li><li id="68aa" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/mastering-typescript-generics-the-ultimate-guide-3a62afeff44">掌握类型脚本泛型:终极指南</a></li><li id="c096" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" href="https://bootcamp.uxdesign.cc/typescript-tricks-and-tips-become-a-pro-in-no-time-5390aba151be" rel="noopener" target="_blank">打字技巧和提示:立即成为专业人士</a></li><li id="c0f9" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/typescript-missed-this-but-you-shouldnt-runtime-type-validation-aa8a81ce4289"> Typescript遗漏了这一点，但你不应该—运行时类型验证</a></li><li id="ff23" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/typescript-enum-pitfalls-and-solutions-must-know-bb971cb0f7d2"> Typescript枚举陷阱和解决方案必须知道</a></li><li id="27e6" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" href="https://bootcamp.uxdesign.cc/mastering-typescript-generics-the-ultimate-guide-essential-interface-techniques-86e793cf1fc" rel="noopener" target="_blank">掌握打字稿泛型—终极指南—基本接口技术</a></li><li id="0a9f" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">Javascript开发人员经常忽略的Typescript特性</li><li id="bc34" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/mastering-intersection-and-union-types-in-typescript-the-ultimate-guide-essential-techniques-49aa9f6a188a">掌握打字稿中的交集和并集类型:终极指南和基本技巧</a></li></ul></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="0569" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae la" href="https://medium.com/@caopengau/membership" rel="noopener">这个链接</a>加入medium，你可以在medium上看到我和所有其他优秀作家的优质文章。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="4f96" class="ml lc it bd ld mm ny mo lg mp nz mr lj ms oa mu lm mv ob mx lp my oc na ls nb bi translated">分级编码</h1><p id="1c05" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="8c1d" class="nd ne it js b jt ju jx jy kb od kf oe kj of kn ni nj nk nl bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="e3a5" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">📰查看<a class="ae la" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="5317" class="nd ne it js b jt nm jx nn kb no kf np kj nq kn ni nj nk nl bi translated">🔔关注我们:<a class="ae la" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae la" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae la" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="d398" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae la" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>