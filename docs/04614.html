<html>
<head>
<title>JavaScript Tips — Throwing Errors, Hostnames, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript提示—抛出错误、主机名等等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-tips-throwing-errors-hostnames-and-more-cc1577fa6a6c?source=collection_archive---------28-----------------------#2020-07-05">https://levelup.gitconnected.com/javascript-tips-throwing-errors-hostnames-and-more-cc1577fa6a6c?source=collection_archive---------28-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9a845ea0098f0bc036e1c6e32dc5a678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K8AlkuqR7cG8BzEI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Justin Young 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d954" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="2965" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">提取URL的主机名部分</h1><p id="23b5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">window.location</code>的<code class="fe mh mi mj mk b">hostname</code>属性提取URL的主机名部分。</p><p id="a9b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们去<a class="ae kf" href="http://example.com/," rel="noopener ugc nofollow" target="_blank">http://example.com/,</a>然后<code class="fe mh mi mj mk b">window.location.hostname</code>返回<code class="fe mh mi mj mk b">“example.com”</code>。</p><h1 id="b2a7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从数组中获取前N个元素</h1><p id="bcf3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要从数组中获得第一个<code class="fe mh mi mj mk b">n</code>数量的元素，我们可以使用<code class="fe mh mi mj mk b">slice</code>方法。</p><p id="d72b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0269" class="mt lf it mk b gy mu mv l mw mx">arr.slice(0, n)</span></pre><p id="942f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">获取数组的第一个<code class="fe mh mi mj mk b">n</code>元素。</p><p id="e0a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不包括索引为<code class="fe mh mi mj mk b">n</code>的项目。</p><p id="16a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以设置数组的<code class="fe mh mi mj mk b">length</code>属性。</p><p id="9f3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<code class="fe mh mi mj mk b">arr.length = n</code>会把<code class="fe mh mi mj mk b">arr</code>截断成长度<code class="fe mh mi mj mk b">n</code>。</p><h1 id="9d4e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在Javascript中查找对象数组中的值</h1><p id="9795" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要在具有给定值的对象数组中找到一个值，我们可以使用<code class="fe mh mi mj mk b">find</code>方法。</p><p id="8fdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有给定的数组:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="13c3" class="mt lf it mk b gy mu mv l mw mx">const arr = [<br/>  { name: "james", value:"foo", other: "that" },<br/>  { name: "mary", value:"bar", other: "that" }<br/>];</span></pre><p id="e5d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5a2a" class="mt lf it mk b gy mu mv l mw mx">const obj = arr.find(o =&gt; o.name === 'james');</span></pre><p id="1bed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">找到<code class="fe mh mi mj mk b">name</code>属性设置为`<code class="fe mh mi mj mk b">'james'</code>的条目，并将其分配给<code class="fe mh mi mj mk b">obj</code>。</p><h1 id="6275" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">有条件地向对象添加属性</h1><p id="d245" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用三元运算符有条件地给对象添加一个属性。</p><p id="f1a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c220" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  b: addB ? 5 : undefined,<br/>  c: addC ? 5 : undefined,<br/>}</span></pre><p id="40e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<code class="fe mh mi mj mk b">addB</code>和<code class="fe mh mi mj mk b">addC</code>是布尔表达式，用于确定<code class="fe mh mi mj mk b">b</code>和<code class="fe mh mi mj mk b">c</code>是否应该分别有一个值。</p><h1 id="6fde" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在Javascript中四舍五入到小数点后1位</h1><p id="6f0f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要将一个数字四舍五入到小数点后一位，我们可以使用<code class="fe mh mi mj mk b">toFixed</code>方法来实现。</p><p id="4b62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a9b3" class="mt lf it mk b gy mu mv l mw mx">number.toFixed(1)</span></pre><p id="b8b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">四舍五入到小数点后1位。</p><h1 id="c58f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么Node.js的fs.readFile()返回的是缓冲区而不是字符串？</h1><p id="9a97" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果没有指定编码，那么<code class="fe mh mi mj mk b">fs.readFile</code>返回一个缓冲区。</p><p id="d968" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让它返回一个字符串，我们传入编码。</p><p id="cf64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8cf6" class="mt lf it mk b gy mu mv l mw mx">fs.readFile("foo.txt", "utf8", (err, data) =&gt; {...});</span></pre><p id="006a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们读取<code class="fe mh mi mj mk b">foo.txt</code>的内容，并指定编码为<code class="fe mh mi mj mk b">'utf8'</code>，以确保它被读取为文本。</p><h1 id="6731" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Node.js Array.forEach是异步的吗？</h1><p id="6ca3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Node.js的数组<code class="fe mh mi mj mk b">forEach</code>方法与常规的<code class="fe mh mi mj mk b">forEach</code>方法相同。</p><p id="6298" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这是一个同步函数。</p><p id="b7e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想要异步迭代，我们可以使用带有承诺的for-of循环或者来自<code class="fe mh mi mj mk b">async</code>库的<code class="fe mh mi mj mk b">async.each</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6ce6" class="mt lf it mk b gy mu mv l mw mx">async.each(files, saveFile, (err) =&gt; {<br/>  //...<br/>});</span></pre><p id="47b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们传入数组作为第一个参数进行迭代。</p><p id="f530" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为第二个参数在每个条目上运行的函数。</p><p id="4a4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个参数是迭代完成时要调用的回调。</p><p id="347f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">er</code>使用遇到错误时定义的错误对象。</p><h1 id="0b7f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">直接从对象生成格式化的易读JSON</h1><p id="678a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">JSON.stringify</code>可以用来格式化已经字符串化的JSON。</p><p id="94ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bcd5" class="mt lf it mk b gy mu mv l mw mx">JSON.stringify(obj, null, 2);</span></pre><p id="1bbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将字符串化的JSON缩进两个空格。</p><p id="a66d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以传入一个缩进字符:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="aa89" class="mt lf it mk b gy mu mv l mw mx">JSON.stringify(obj, null, '\t');</span></pre><p id="f897" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用制表符缩进。</p><h1 id="a91e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">“抛出新错误”和“抛出对象”的区别</h1><p id="bba2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">投掷错误和投掷任何其他种类的物体是有区别的。</p><p id="c873" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Error</code>对象有名称、消息和堆栈跟踪。</p><p id="3959" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">抛出任何其他类型的对象都会将消息暴露给用户。</p><p id="1b39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="11d3" class="mt lf it mk b gy mu mv l mw mx">try {<br/>  throw "error";<br/>} catch (e) {<br/>  console.log(e);<br/>}</span></pre><p id="5b4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后控制台日志将记录<code class="fe mh mi mj mk b">'error'</code>。</p><p id="f9a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不会有<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">message</code>属性。</p><p id="285d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="61a3" class="mt lf it mk b gy mu mv l mw mx">try {<br/>  throw new Error("error")<br/>} catch (e) {<br/>  console.log(e.name, e.message);<br/>}</span></pre><p id="fd33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">e.name</code>将是<code class="fe mh mi mj mk b">'Error'</code>并且<code class="fe mh mi mj mk b">e.message</code>将是<code class="fe mh mi mj mk b">'error'</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/0a170bffd68cec4f2654b92dd099c5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wimDidl8O6oMpKJp"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7dba" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="d5e9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">window.location.hostname</code>属性提取URL的主机名部分。</p><p id="2ee6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">slice</code>从数组中获取第一个<code class="fe mh mi mj mk b">n</code>条目。</p><p id="dec6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要从对象数组中找到具有给定属性值的对象，我们可以使用<code class="fe mh mi mj mk b">find</code>。</p><p id="9cd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">抛出<code class="fe mh mi mj mk b">Error</code>实例和任何其他类型的对象或值是有区别的。</p></div></div>    
</body>
</html>