<html>
<head>
<title>Let Me Teach You How To Implement Monad With Cats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我来教你如何用猫实现Monad</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/let-me-teach-you-how-to-implement-monad-with-cats-5da159386700?source=collection_archive---------6-----------------------#2020-03-17">https://levelup.gitconnected.com/let-me-teach-you-how-to-implement-monad-with-cats-5da159386700?source=collection_archive---------6-----------------------#2020-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/fe5e3df48b79560cfb669d033c87bdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/0*ARYjBGyfrtTL7mO3"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><em class="jy">原载于</em><a class="ae jz" href="https://edward-huang.com/functional-programming/scala/programming/monad/2020/03/16/let-me-teach-you-how-to-implement-monad-with-cats/" rel="noopener ugc nofollow" target="_blank"><em class="jy">https://edward-huang.com</em></a></figcaption></figure><p id="8845" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">单子是Scala中最常见的抽象之一。我们经常在Scala和其他语言中使用它们，但是我们经常不知道它们的名字。</p><p id="133b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">我在学习函数式编程的时候，除了理解了引用透明和纯的规则之外，对什么是单子，函子，半群，幺半群完全是一头雾水。</p><p id="860d" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">在本文中，我想分享一下如何通过实现<code class="fe ky kz la lb b">pure</code>、<code class="fe ky kz la lb b">flatMap</code>和<code class="fe ky kz la lb b">tailRecM</code>来用Cats库创建单子。</p><p id="0b71" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">在此之前，我想分享一些关于map和flatMap的信息，以及Monad的一个简短定义，然后我们将深入探讨如何为自定义类型实现一个Monad。</p><h1 id="e5ea" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是单子</h1><p id="2f62" class="pw-post-body-paragraph ka kb iq kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ij bi translated">简单地说，Monad是一种对计算进行排序的机制。它是任何具有平面图功能的东西。</p><p id="3862" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">Monad是函子的子集，具有映射功能。因此，所有的单子也是一个函子，它们可以在机制上应用一个映射。</p><p id="0390" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">单子的一些例子包括:列表、选项、未来。为了便于理解，人们经常使用Scala的特殊语法来支持单子运算。</p><p id="12fe" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">让我们直接进入地图和平面地图的区别。然后，将自定义类型实现为Monad。</p><h1 id="a12c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">地图与平面地图</h1><p id="773b" class="pw-post-body-paragraph ka kb iq kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ij bi translated">当您从JavaScript的角度来看map和flatMap时，它是一个在迭代器上迭代的函数，转换迭代器中的那些元素，并返回一个包含转换后的迭代器的全新数组。</p><p id="c1de" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">例如，您可以映射一个整数列表，并调用回调函数来转换字符串中的元素。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="b5a8" class="mn ld iq lb b gy mo mp l mq mr">val lst = List(1,2,3)<br/>val stringList = lst.map{el =&gt; s"${el}" }<br/>println(stringArr);</span></pre><p id="bf70" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><code class="fe ky kz la lb b">stringArr</code>的输出将是<code class="fe ky kz la lb b">List("1","2","3)</code>。地图在那边做了什么？</p><p id="aecc" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">map函数基本上将列表中的每个整数元素转换成一个字符串。然后，它返回一个新的列表，分配给<code class="fe ky kz la lb b">stringList</code>。</p><p id="0e72" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">在Scala中，map的含义不仅仅是迭代一个迭代器。该映射不是迭代模式。Put、flatMap和Map是一种转换计算序列的方法。map和flatMap通过忽略由相关数据类型决定的复杂性，对值执行一系列计算。</p><p id="83d8" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">您不仅可以在列表中绘制地图，还可以选择未来，或者两者都选。</p><p id="452b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">map对这些数据类型所做的是剥离数据类型、列表的外层，并将回调函数应用于列表中的每个元素。然后，一旦操作完成，它就用剥离的现有数据类型(List)覆盖其中的值。</p><p id="ea3f" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">期权也是如此。Map将其函数应用于选项内部的值。得到的值仍然是一个选项，但是选项中的值被改变和转换了。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/3d51da8645f65135550ebee1238c3ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ebSkljn3YO1taFzb.png"/></div></div></figure><p id="12d4" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">Map在某种程度上受到限制，它们只允许在计算开始时出现复杂性。Flatmap走得更远，不仅可以在数据类型内部转换值，还可以将它链接到一系列计算中。</p><p id="f3eb" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">当您调用flatMap时，它主要用<code class="fe ky kz la lb b">map</code>做同样的事情，但是随后它调用<code class="fe ky kz la lb b">flatten</code>来展平结果值。一个例子是当你试图将一个2D列表扁平化为一个1D列表。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="b0ed" class="mn ld iq lb b gy mo mp l mq mr">val twoDList = List(List(1,2), List(3,4), List(5,6))<br/><br/>twoDList.flatMap(el =&gt; el)</span></pre><p id="fb71" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">上面的代码和做<code class="fe ky kz la lb b">twoDList.map(el =&gt; el).flatten</code>是一样的。</p><p id="7161" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">让我们采取另一个选项。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="b44b" class="mn ld iq lb b gy mo mp l mq mr">def divide(a:Int, b:Int): Option[Int] = if(b == 0) None else Some(a/b)<br/><br/>Some(1).flatMap{ one =&gt;<br/>  Some(2).flatMap{two =&gt;<br/>    divide(one,two)<br/>  }<br/>}</span></pre><p id="4573" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">在这个例子中，flatMap去掉了中间的复杂性。选项的平面图考虑了中间选项。在flatMap内部传递的函数指定了特定于应用程序的计算。如果任何中间值为None，则上面示例中的flatMap函数会缩短操作。</p><h1 id="fa0a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">你如何定义一个自定义单子</h1><p id="cd10" class="pw-post-body-paragraph ka kb iq kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ij bi translated">在Cats库中，您可以通过实现以下三种方法来定义自定义的monad:</p><ul class=""><li id="c00a" class="mx my iq kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">平面地图</li><li id="decc" class="mx my iq kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">纯(适用)</li><li id="6238" class="mx my iq kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">tailRecM</li></ul><p id="bf52" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">我们已经讨论过平面地图。Pure是应用程序提供的功能。Applicative还扩展了Functor，这给了Monad一个映射方法。tailRecM是Cats库中使用的一种优化，用于限制使用的堆栈空间量。</p><p id="d80a" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">当您可以实现tailRecM tail递归时，Cats库可以保证大型操作(如折叠扩展列表)中的堆栈安全。然而，如果您不能使tailRecM尾部递归，那么就不能保证cats在极端用例中是堆栈安全的。</p><p id="afe5" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">让我们将CustomMonad类创建为Monad。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="5402" class="mn ld iq lb b gy mo mp l mq mr">case class CustomMonad[A](value:A)</span></pre><p id="3e16" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">之前，您需要在build.sbt中导入Cats库，以便实现自定义monad。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="7e11" class="mn ld iq lb b gy mo mp l mq mr"><em class="nl">// build.sbt<br/></em>lazy val customMonad = project.in(file("customMonad"))<br/>  .settings(<br/>    name := "Custom Monad",<br/>    commonSettings,<br/>    libraryDependencies ++= Seq(<br/>      "org.typelevel" %% "cats-core" % "2.0.0"<br/>    )<br/>  )</span></pre><p id="0dc9" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">首先，我们实现了pure，它将一个值转换为一个选项。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="5a85" class="mn ld iq lb b gy mo mp l mq mr">override def pure[A](x: A): CustomMonad[A] = CustomMonad(x)</span></pre><p id="aa85" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">下面是平面图函数:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="5894" class="mn ld iq lb b gy mo mp l mq mr">override def flatMap[A, B](fa: CustomMonad[A])(f: A =&gt; CustomMonad[B]): CustomMonad[B] = f.apply(fa.value)</span></pre><p id="a516" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">由于平面图函数<code class="fe ky kz la lb b">f</code>接受了一个<code class="fe ky kz la lb b">A =&gt; CustomMonad[B]</code>，我们只需要将该函数应用于<code class="fe ky kz la lb b">fa</code>。</p><p id="b504" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">最后，让我们实现tailRecM函数。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="39f1" class="mn ld iq lb b gy mo mp l mq mr">@tailrec<br/>override def tailRecM[A, B](a: A)(f: A =&gt; CustomMonad[Either[A, B]]): CustomMonad[B] =        f(a) match {<br/>      case CustomMonad(either) =&gt; either match {<br/>        case Left(a) =&gt; tailRecM(a)(f)<br/>        case Right(b) =&gt; CustomMonad(b)<br/>      }<br/>    }</span></pre><p id="92e9" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">tailRecM函数将需要递归调用自身，直到<code class="fe ky kz la lb b">f</code>的结果返回一个<code class="fe ky kz la lb b">Right</code>。所以左边的函数会再次调用<code class="fe ky kz la lb b">tailRecM</code>，因为它不是序列的结尾。</p><p id="4e0c" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">将上述实现结合在一起:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="68b2" class="mn ld iq lb b gy mo mp l mq mr">import cats.Monad<br/><br/> implicit val customMonad = new Monad[CustomMonad] {<br/>    override def pure[A](x: A): CustomMonad[A] = CustomMonad(x)<br/><br/>    override def flatMap[A, B](fa: CustomMonad[A])(f: A =&gt; CustomMonad[B]): CustomMonad[B] = f.apply(fa.value)<br/><br/>    @tailrec<br/>    override def tailRecM[A, B](a: A)(f: A =&gt; CustomMonad[Either[A, B]]): CustomMonad[B] = f(a) match {<br/>      case CustomMonad(either) =&gt; either match {<br/>        case Left(a) =&gt; tailRecM(a)(f)<br/>        case Right(b) =&gt; CustomMonad(b)<br/>      }<br/>    }<br/>  }</span></pre><p id="a38a" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">一旦你完成了这个类的实现，不要忘记导入<code class="fe ky kz la lb b">cats.implicits._</code>来获取你的<code class="fe ky kz la lb b">main</code>函数中的隐式。</p><p id="e2d2" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">你可以用仿函数的语法执行<code class="fe ky kz la lb b">CustomMonad</code>:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="cc9e" class="mn ld iq lb b gy mo mp l mq mr">import cats.implicits._<br/><br/><br/>object Main extends App {<br/><br/>  val endResult = for {<br/>    a &lt;- CustomMonad(1)<br/>    b &lt;- CustomMonad(2)<br/>  } yield {<br/>    a + b<br/>  }<br/>  println(endResult)<br/>}</span></pre><p id="bb7a" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">一旦你完成了自定义单子的实现，你可以导入猫<a class="ae jz" href="https://typelevel.org/cats/typeclasses/lawtesting.html" rel="noopener ugc nofollow" target="_blank">法则依赖</a>来检查你的自定义单子是否遵守<a class="ae jz" href="https://wiki.haskell.org/Monad_laws" rel="noopener ugc nofollow" target="_blank">法则</a>。这个<a class="ae jz" href="https://stackoverflow.com/questions/39561525/how-to-test-monad-instance-using-discipline" rel="noopener ugc nofollow" target="_blank"> StackOverflow问题</a>展示了如何用纪律来检验莫纳德定律。</p><h1 id="b157" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">外卖食品</h1><ul class=""><li id="a67b" class="mx my iq kc b kd ma kh mb kl nm kp nn kt no kx nc nd ne nf bi translated">Monad是一种对操作和任何可以平面映射的事物进行排序的机制。</li><li id="ee54" class="mx my iq kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">Map和flatMap是Monad对操作进行排序的一种方式，无需考虑任何复杂的数据类型和中间操作。</li><li id="f5ce" class="mx my iq kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">通过在Cats库中定义flatMap、pure和tailRecM函数来实现自定义Monad。</li></ul><p id="5429" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">源代码在<a class="ae jz" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ScalaTutorial/customMonad" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="7b3d" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><strong class="kc ir">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯，每周都会收到关于科技职业的文章、有趣的链接和内容。</strong></p><p id="6c8f" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">你也可以在<a class="ae jz" href="https://medium.com/@edwardgunawan880" rel="noopener"> Medium </a>上关注我更多类似的帖子。</p></div></div>    
</body>
</html>