<html>
<head>
<title>Interface Segregation Principle made simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">界面分离原理变得简单</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/interface-segregation-principle-made-simple-990da495441c?source=collection_archive---------6-----------------------#2021-04-27">https://levelup.gitconnected.com/interface-segregation-principle-made-simple-990da495441c?source=collection_archive---------6-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9ab1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">粒度将如何提高您的代码对现实应用程序中不断变化的需求的弹性。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d51924a31d0be7c28f9d69c23829d7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4VS9XUxG_EZqClInuiGGg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">米海三都</figcaption></figure><p id="cc72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的两幅图像都是由相同数量的像素组成的，但是一幅看起来像一只熊，另一幅看起来更像一个震惊的正方形。这不是数量的差别，而是粒度的差别。用更小的片段创作更容易。</p><p id="1650" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样的逻辑也适用于编写优秀的、有弹性的代码。不应该强迫客户端代码实现它不使用的方法。这就是罗伯特·c·马丁定义的界面分离原理。</p><p id="6261" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码应该足够灵活，允许客户端代码只使用所需的抽象。这使得类更容易理解和构建。</p><h1 id="c729" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">自动驾驶系统问题</h1><p id="9f66" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在Liskov替换<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-made-simple-5e69165e7ab5">文章</a>中，我们必须构建两个模块来控制一辆普通的汽车。这些模块是:</p><ul class=""><li id="0b8d" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">将汽车转化为“可驾驶”物体的模块。该模块支持四个简单的命令:前进或后退，左转或右转。</li><li id="6b88" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">自动驾驶模块计算路线，并在可驾驶模块显示的四个命令的帮助下驾驶汽车。</li></ul><p id="cb17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在构建好软件之后，我们已经将它安装在轿车和卡车上。一切都很顺利，直到公司决定扩展到火车市场。这是我们遇到的第一个减速带。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/fa8a9ff6726455176a134a338e1ea587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1ssa2070cIhtJ2Uhv39nQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">火车不能左转或右转。米海三都</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0ec1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们基于Car类的第一个实现定义了IDrivable接口，所以我们最终得到了一个包含四个方法的接口。虽然对汽车和卡车来说不成问题，但对火车来说却是个大问题。我们需要重新构想解决方案。</p><h2 id="77c3" class="nj lv it bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">隔离接口</h2><p id="3929" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">因为问题出在右转或左转上，我们可以将接口分为可右转和不可右转接口。现在，对象可以选择它们做什么，并且只实现需要的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0243" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的，这看起来是一个很好的抽象，对吗？在继续阅读之前，想想我们是否能发现任何问题。</p><h2 id="0640" class="nj lv it bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">绘图扭曲-平面自主模块</h2><p id="0cba" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们的软件非常棒，公司想在另一个市场——飞机市场——扩张。这就产生了另一个问题:飞机可以前进和转弯，但不能后退(至少在飞行时不能)。</p><p id="6fd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们再次打破了<a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-made-simple-5e69165e7ab5">利斯科夫替代原则</a>。因为IDrivable定义了GoForward()和GoBackward()方法，所以我们必须为GoBackward抛出一个NotImplementedException。</p><h1 id="0b7c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">在现实世界中，你不可能总是有完美的抽象</h1><p id="607c" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">有时候，根本不可能预见客户需要什么。所以有时候过去的抽象被证明是错误的。我们能做什么？</p><p id="a8bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">别管它们，创造新的。把你的代码想象成一个只追加的系统。因此，每当我们在生产中有一些错误的抽象时，就让它们去吧。此时，可能其他客户端已经在使用这些接口，对它们的任何更改都会产生一连串的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/14a289c8333c81f3b8c537f6bd153fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rJCQRNp2L3AOwozG"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">你的代码可以像扼杀者一样运行</figcaption></figure><p id="f252" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，<strong class="la iu">使用扼杀者模式</strong>。扼杀者无花果是一种生长在树周围的植物。慢慢地，这种植物长得如此之大，以至于它覆盖了整个寄主树，从土壤中吸取阳光和养分。最后，树会死去，无花果会变成树一样。它会保留原来的树形，但没有宿主的痕迹。</p><p id="7dda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在真实世界的代码中也可以做同样的事情。回到IDrivable问题，我们可以离开原来的接口，创建两个新的接口，IForwardDrivable和IBackwardDrivable。</p><p id="b2db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，将旧接口标记为不推荐使用。Java，C#，Javascript，Python都支持信令弃用的方法。这允许客户端代码按照自己的时间表进行更新。至少一年后，您可以假设代码已经更新，并安全地“杀死”原来的接口。这种方法类似于延迟执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="eaa4" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">当心</h1><p id="0223" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">理想的接口应该只有一个方法，也称为角色接口。这是最精细的界面，它将提供最大的灵活性。正如我们在自动驾驶问题中看到的，从一开始就打破GoForward()和GoBackward()可以为我们节省一次重构。</p><p id="6e46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，为什么我没有破坏ITurnable接口呢？我可以定义一个ITurnRight和ITurnLeft接口。但是这有意义吗？有没有只能往一个方向转而不能往另一个方向转的机动车？个人觉得一个都想不出来。</p><p id="421d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将方法分成两个接口会增加代码的复杂性，但没有任何好处。这就是为什么这个原则会使你的代码库过于细粒度化。所以要小心。分开但是如果有一些方法离不开其中一个，也许最好把它们放在一起。</p><p id="4099" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要把这个原则和单一责任原则混淆。乍一看，它们似乎很相似，但是它们针对不同的问题。单一责任原则试图帮助您围绕变更的单一原因定义一个类别。接口分离原则是如何定义接口的蓝图。一个类可以实现任意多的接口。</p><h1 id="7793" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">外卖食品</h1><ul class=""><li id="65bc" class="ms mt it la b lb mm le mn lh nw ll nx lp ny lt mx my mz na bi translated">不惜一切代价避免提取基于类的接口。接口不是由类定义的，而是由客户的需求定义的。</li><li id="4fc9" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">接口中的方法越少越好。但是不要过度。例如，如果你实现一个存储库接口，不要写一个Add接口，一个Update接口，一个Get接口，等等。但是像IReadOnlyRepository和IFullAccessRepository这样的东西可能有意义。</li><li id="b2e0" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">生产代码应该是只追加的(并最终删除)。使用扼杀者模式。每当一个已部署的接口需要更改时，就离开它。创建新的抽象，并将旧的抽象标记为已弃用。仅在至少一年后，删除已弃用的接口。</li><li id="7d53" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">当这项原则与其他坚实的原则一起应用时，它的全部好处就会被收获</li></ul><p id="9719" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">坚实的原理制作简单的系列:</strong></p><ul class=""><li id="0d0a" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-made-simple-4e1597a44d7d">单一责任原则</a> (SRP)</li><li id="b127" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/the-open-closed-principle-made-simple-cc3d0ed70553">开合原理</a> (OCP)</li><li id="3818" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-made-simple-5e69165e7ab5">利斯科夫替代原理</a> (LSP)</li><li id="2bff" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">接口隔离原则(ISP)</li><li id="233a" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><a class="ae mr" rel="noopener ugc nofollow" target="_blank" href="/the-dependency-inversion-principle-made-simple-70108b88dc76">依存倒置原则</a> (DIP)</li></ul><h1 id="427a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">进一步阅读</h1><div class="nz oa gp gr ob oc"><a href="https://www.baeldung.com/java-interface-segregation" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">Java | Baeldung中的接口分离原则</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">在本教程中，我们将讨论固体原理之一的界面分离原理。代表…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">www.baeldung.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://stackify.com/interface-segregation-principle/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">坚实的设计原则解释:界面分离与代码示例</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">与单一责任原则相似，界面分离原则的目标是减少副作用</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">stackify.com</p></div></div><div class="ol l"><div class="or l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>