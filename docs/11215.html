<html>
<head>
<title>Asymmetric encryption: a JavaScript and PHP example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不对称加密:JavaScript和PHP示例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asymmetric-encryption-a-javascript-and-php-example-4cf9d5f95d7d?source=collection_archive---------1-----------------------#2022-02-27">https://levelup.gitconnected.com/asymmetric-encryption-a-javascript-and-php-example-4cf9d5f95d7d?source=collection_archive---------1-----------------------#2022-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="06a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何为你的web应用程序与服务器端API的通信增加额外的加密层。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/6166e305ec7a8f5eb01db41a4ce4e86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tfQPj7elgpXYjHgc"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Georg Bommeli 在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5d5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我直截了当地说明这一点:这并不意味着要取代任何加密系统，其目标是为那些试图窥探客户机和服务器之间传输的数据的人增加一层难度。它也不是要深入这个主题，而是一个简单的介绍性方法。</p><p id="8d51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这只是由于项目安全需求，我们不得不在<a class="lc ld ep" href="https://medium.com/u/3f6778c629bf?source=post_page-----4cf9d5f95d7d--------------------------------" rel="noopener" target="_blank">布利斯应用</a>实施的一个简单例子。</p><p id="581c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种实现在前端并不常见，尤其是web (JS)，所以开发起来有点挑战性和趣味性。通常你可以在需要额外安全层的系统上看到这种实现，比如银行。</p><h1 id="4b39" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这个概念</h1><p id="5d91" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">目标是有一种安全的方法来加密前端和后端之间的通信，而不仅仅依赖于HTTPS。</p><p id="4dfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们以密码恢复系统为例。我们希望以加密的方式将新用户的密码发送到服务器。现在，由于web前端代码在设计上是不安全的(这意味着任何人都可以对代码进行逆向工程)，如果有一个系统，我们可以在前端对消息进行安全加密，确保除了收件人之外没有其他人可以解密它，那就太好了。</p><p id="cb8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用公钥加密，或者非对称加密，我们能够一方面实现强大的加密因子，另一方面确保只有公钥的所有者才能加密消息，最重要的是，只有匹配的私钥的所有者才能解密消息。</p><p id="7cda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面您可以找到解决方案的一般工作流程，代表客户端和服务器之间的迭代。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/ffa26cc29dc9c16986466fef0aeb0298.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*n2KLs4-tLK6-qDyARsUwwA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">代表客户端和服务器之间的过程和通信的一般工作流</figcaption></figure><p id="7d6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">以下是更详细的步骤:</strong></p><ol class=""><li id="6d75" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">客户端生成公钥/私钥对；</li><li id="dfc1" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">客户端将PEM格式的公钥发送给服务器；</li><li id="0dde" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">服务器生成(强)随机共享密钥，并用客户端的公钥加密该密钥(因此只有具有匹配私钥的客户端才能解密该共享密钥)；</li><li id="94c9" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">服务器用唯一标识符(handshakeId)临时存储共享密钥，该共享密钥应该只在几分钟内有效；</li><li id="29d1" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">服务器将加密的共享密钥和握手Id返回给客户端；</li><li id="8701" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">客户端使用它的私钥解密共享密钥；</li><li id="f5c1" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">然后，客户端使用共享密钥来加密数据(例如密码)；</li><li id="1a52" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">客户端将加密后的数据连同握手码一起发送给服务器；</li><li id="ab3a" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">服务器使用handshakeId搜索相应的共享密钥，并检查它是否仍然有效；</li><li id="2773" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">服务器使用经验证的共享密钥来解密客户端的数据(并最终对其进行处理，比如再次加密并将其存储在数据库中)。</li></ol><p id="10a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面提供的代码示例将直接连接到这些步骤。</p><h1 id="e136" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这项技术</h1><p id="59f4" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">在这些例子中，我将尽量保持简单，只关注加密/解密和通信组件。</p><p id="0690" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JavaScript方面，我将只依赖两个库:<a class="ae lb" href="https://github.com/digitalbazaar/forge" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> node- </em> forge </a>用于加密，而<a class="ae lb" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> axios </em> </a>用于API连接。这是使用节点14和NPM 6.14测试的。</p><p id="50e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于后端，我将使用OpenSSL提供PHP (Laravel)示例。但是我会尽量使它通用，这样它就可以移植到任何其他框架上。</p><h1 id="3496" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实施</h1><p id="7470" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">让我们首先安装必要的前端库，用于api通信的<strong class="jp ir"> axios </strong>和用于加密的<strong class="jp ir"> node-forge </strong>:</p><pre class="km kn ko kp gt mx my mz na aw nb bi"><span id="c42a" class="nc lf iq my b gy nd ne l nf ng">npm install axios<br/>npm install node-forge</span></pre><p id="cc62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将库导入到JavaScript文件中:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7582" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们能够生成公钥和私钥对，并将公钥转换为PEM格式(步骤1):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a9bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将公钥发送到服务器，以获得共享密钥和handshakeId(步骤2):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="44e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的服务器端API上，我们需要从客户端的请求中检索公钥，重新生成一个强随机共享密钥，并用公钥加密它(步骤3):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3fc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要临时存储共享密钥，并为它创建一个惟一的标识符。在本例中，我将它存储在一个带有过期时间戳的数据库中，自动生成的uuid具有handshakeId(步骤4):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d19b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以使用Base64中的加密共享密钥和它的唯一标识符——handshakeId(步骤5)将响应返回给客户端:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fa6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前端，收到加密的共享密钥后，我们需要对它进行Base64解码，并使用之前生成的私钥对它进行解密(步骤6):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ed46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了共享密钥的值，我们将使用它来加密一些数据。因为只有客户端和服务器知道这个共享密钥的值，所以只有它们能够解密数据。</p><p id="e3bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将使用AES-CBC算法和16字节的随机IV(初始化向量)(步骤7):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4021" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据加密后，客户端要做的就是将数据连同握手码一起发送给服务器(步骤8):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9f63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们对加密数据进行了Base 64编码，并且还连接了IV和加密输出，因此服务器应该获取前16个字节，并将它们用作IV来解密数据。</p><p id="277b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看服务器代码的剩余步骤。</p><p id="02b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在客户端完成加密并将数据发送到服务器后，它需要验证握手(步骤9):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e452" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果握手有效，我们就可以进入最后一步:解密数据(步骤10):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">就这样！</strong></p><p id="ed8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经成功地为客户端-服务器通信增加了另一层安全性。</p><p id="fff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，关于这个话题还有很多要说的。加密过程甚至可以更加安全(例如，客户机和服务器都有自己的公钥/私钥对),但是，正如我所说的，这只是一种简化的初始方法。</p><p id="cb40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加密级别和您需要投入的时间取决于您正在构建的项目类型，当然，还取决于需要传输的数据类型。</p><p id="6280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的项目中，我们使用了额外的加密密钥和代码来进一步保护通信，也是C#(。网芯5)被使用。所以对于那些喜欢C#的人，请继续关注，我可能会在本文的第2部分添加一些代码示例。</p><p id="0db1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢<a class="lc ld ep" href="https://medium.com/u/d7cd7daa5269?source=post_page-----4cf9d5f95d7d--------------------------------" rel="noopener" target="_blank"> Marcelo Nunes </a>(后端大师)在这方面的所有帮助！</p><p id="4e01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果您想看看这段代码的运行情况，可以看看后端和前端存储库的工作示例:</p><p id="dc2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【https://github.com/nrgribeiro/async-encrypt-laravel<br/><a class="ae lb" href="https://github.com/nrgribeiro/async-encrypt-javascript" rel="noopener ugc nofollow" target="_blank">https://github.com/nrgribeiro/async-encrypt-javascript</a></p><p id="5143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！干杯！</p></div></div>    
</body>
</html>