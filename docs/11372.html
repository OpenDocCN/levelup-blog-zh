<html>
<head>
<title>Techniques to Create Brilliant Functions for Software Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为软件开发人员创建出色功能的技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/techniques-to-create-brilliant-functions-for-software-developers-44fcb4a78e3e?source=collection_archive---------4-----------------------#2022-03-11">https://levelup.gitconnected.com/techniques-to-create-brilliant-functions-for-software-developers-44fcb4a78e3e?source=collection_archive---------4-----------------------#2022-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc4e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">注意你的功能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f522ac69a34460aca5488616431f0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*17_8ari9MvcKwXNi"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alexacea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandru Acea </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="913e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是分组到类中的最小的自定义构建块。然后将类分组到模块中，依此类推直到工作产品。</p><p id="ae50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是低级的构建块，应该根据最佳实践来编写，这样它们就可以很容易地组合成更高级的块。</p><p id="6eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何写出一个很棒的函数？没有简单的答案，但我可以分享一些好的技巧:</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="55f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.用值对象替换输入参数验证</h1><p id="37d2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在方法开始时验证输入参数似乎是开发人员应该遵循的防御性编程的一个很好的例子。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="dbb0" class="ne md it na b gy nf ng l nh ni">public void ApplyDiscount(double discount)<br/>{<br/>    if (discount &lt; 1 || discount &gt; 100)<br/>        throw new Exception();</span><span id="54fa" class="ne md it na b gy nj ng l nh ni">    //...<br/>}</span></pre><p id="5ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这样的输入参数检查经常指出域设计的问题。使用基本类型来表示折扣域概念将导致需要在所有其他接受<code class="fe nk nl nm na b">double discount</code>参数的方法中复制验证规则。</p><p id="3b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的解决方案是引入一个<code class="fe nk nl nm na b">Discount</code>值对象:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="be5c" class="ne md it na b gy nf ng l nh ni">public class Discount<br/>{<br/>    public double Value { get; private set; }</span><span id="4f4d" class="ne md it na b gy nj ng l nh ni">    <strong class="na iu">//Factory method to create an instance of Discount type    </strong><br/>    public static Discount Create(double value)<br/>    {<br/>        if (value &lt; 1 || value &gt; 100)<br/>            throw new Exception();</span><span id="e256" class="ne md it na b gy nj ng l nh ni">        return new Discount() { Value = value };<br/>    }<br/>}</span><span id="dde6" class="ne md it na b gy nj ng l nh ni">public void ApplyDiscount(<strong class="na iu">Discount discount</strong>)<br/>{<br/>    //No validation! The object is already valid.</span><span id="82c1" class="ne md it na b gy nj ng l nh ni">    //...<br/>}</span></pre><p id="2a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">验证折扣值的验证规则封装在一个地方。任何采用<code class="fe nk nl nm na b">Discount discount</code>参数的方法都不应该验证它，因为不可能用无效状态创建它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="03bc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.跟踪方法输入参数的数量</h1><p id="7c80" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有许多输入参数的方法很难维护。然而，一长串参数本身并不是问题。</p><p id="f7b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一长串方法参数通常是一种代码味道，通常表明一个方法正在做许多事情，即违反了<strong class="lb iu">单一责任原则</strong>。在这种情况下，如果一个方法实际上做了几件事，它应该被分成几个更小的方法，每个小方法做一件事。</p><p id="ad4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有长参数列表的另一个原因通常是<strong class="lb iu">缺少域模型</strong>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="680f" class="ne md it na b gy nf ng l nh ni">public decimal Calculate(decimal amount, string currency)<br/>{<br/>    //...<br/>}</span></pre><p id="12a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过分析两个输入参数<code class="fe nk nl nm na b">amount</code>和<code class="fe nk nl nm na b">currency</code>的性质，我们可以得出结论，它们表示“货币”的单个域概念。这意味着参数必须归入一个<code class="fe nk nl nm na b">Money</code>值对象。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cb42" class="ne md it na b gy nf ng l nh ni">public class <strong class="na iu">Money</strong><br/>{<br/>    public decimal Amount { get; set; }<br/>    public string Currency { get; set; }<br/>}</span><span id="8e3a" class="ne md it na b gy nj ng l nh ni">public decimal Calculate(<strong class="na iu">Money money</strong>)<br/>{<br/>    //...<br/>}</span></pre><p id="ae54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您看到应用程序中有几个不同的方法接受相同的基本参数组合，那么这些方法最有可能组合成一个单一的值对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ece4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.创建尽可能多的纯函数</h1><p id="539c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">开发人员喜欢处理纯函数，因为它们更容易阅读、调试和维护。</p><p id="6bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纯函数的第一个关键特征是，对于相同的输入，它总是返回相同的输出，因此函数的行为总是确定的。</p><p id="9dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当函数的行为取决于以下因素时，函数的执行可能会产生不确定的结果:</p><ul class=""><li id="993a" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">外部(全局)状态。纯函数的行为应该只取决于它的输入参数。</li><li id="3a30" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">日期和时间逻辑或多线程。在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-avoid-the-headache-with-non-deterministic-bugs-in-software-e24457f05c9b">我的另一篇文章</a>中有更多关于这些问题的内容。</li></ul><p id="4b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纯函数的另一个重要特征是没有副作用。一个函数应该尽可能不改变状态。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="67dc" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">//Not a pure function</strong><br/>public class Math<br/>{<br/>   public int Value { get; set; }</span><span id="1114" class="ne md it na b gy nj ng l nh ni">   public void <strong class="na iu">Increment</strong>() =&gt;<br/>      Value = Value + 1; //Modifying external state<br/>}</span><span id="3e69" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">//Pure function</strong><br/>public int Increment(int value) =&gt; <br/>   value + 1;<br/></span></pre><p id="0144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并不是应用程序中的每个函数都是纯函数。某些功能肯定会改变外部状态，比如将数据保存到数据库中。但是，开发人员应该努力在应用程序中创建尽可能多的纯函数，以确保代码具有良好的可维护性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c069" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.从方法名中排除输入参数名</h1><p id="f7c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在查询某些数据的方法名称中包含输入参数的名称通常很有诱惑力。这通常指的是存储库方法。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="69b3" class="ne md it na b gy nf ng l nh ni">public Order <strong class="na iu">GetById</strong>(int <strong class="na iu">id</strong>)<br/>{<br/>   //...<br/>}</span></pre><p id="79a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这样的命名约定应该可以提高代码的可读性，但实际上效果恰恰相反。</p><p id="8543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在方法名中包含输入参数名是方法签名级别的一种干违规，可能会导致一些问题:</p><ul class=""><li id="72fc" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">重命名参数时，开发人员可能会忘记相应地更改方法名。</li><li id="fc19" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当添加或删除参数时，开发人员可能会忘记更改方法名。</li><li id="7e25" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">长的参数列表会导致麻烦的方法名，比如<code class="fe nk nl nm na b">GetByThisAndThatAndAlsoThat...</code></li></ul><p id="c5f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好的选择是简单地从方法名中排除参数名:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="02c0" class="ne md it na b gy nf ng l nh ni">public Order <strong class="na iu">GetBy</strong>(int <strong class="na iu">id</strong>)<br/>{<br/>   //...<br/>}</span></pre><p id="d113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，方法签名中只剩下基本要素。</p><h1 id="9860" class="mc md it bd me mf ob mh mi mj oc ml mm jz od ka mo kc oe kd mq kf of kg ms mt bi translated">摘要</h1><ul class=""><li id="7d6e" class="nn no it lb b lc mu lf mv li og lm oh lq oi lu ns nt nu nv bi translated">注意输入参数验证吗？考虑将该参数和有效性规则包装到值对象中。</li><li id="a4db" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">通过将该方法分成更小的方法或/和将原语的组合包装成值对象来减少该方法的输入参数的数量。</li><li id="d7eb" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">纯函数是确定性的，不会导致副作用。在应用程序中创建尽可能多的纯函数。</li><li id="cb63" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">不要在方法名中重复方法输入参数名，因为这违反了方法签名级别的DRY原则。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="1b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">5种免费提高C#代码性能的方法</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">慢速代码是可选的。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>