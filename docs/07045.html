<html>
<head>
<title>Create a Full Stack Web App with the MEVN Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MEVN堆栈创建全堆栈Web应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-a-full-stack-web-app-with-the-mevn-stack-42473aabb822?source=collection_archive---------5-----------------------#2021-01-20">https://levelup.gitconnected.com/create-a-full-stack-web-app-with-the-mevn-stack-42473aabb822?source=collection_archive---------5-----------------------#2021-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ff228ea99c37a169990f8da1b6c0d099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_ZIRiPcihtyLa3o1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">维克多·塔拉舒克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9364" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">MEVN堆栈是一套用于全堆栈应用的技术。MEVN代表MongoDB、Express、Vue.js和Node.js。在本文中，我们将了解如何使用MEVN堆栈创建一个简单的带有身份验证的todo应用程序。</p><h1 id="4d13" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置项目</h1><p id="0bca" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">创建全栈MEVN应用的第一步是设置项目。</p><p id="c4d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们创建一个项目文件夹，然后在其中添加<code class="fe mh mi mj mk b">backend</code>和<code class="fe mh mi mj mk b">frontend</code>文件夹。</p><p id="1877" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">backend</code>有快递app。</p><p id="3973" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">frontend</code>有Vue.js app。我们会用Vue 3做前端。</p><p id="b317" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，为了创建我们的Express应用程序，我们运行Express生成器来创建文件。</p><p id="4b48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，进入<code class="fe mh mi mj mk b">backend</code>并运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4921" class="mt lf it mk b gy mu mv l mw mx">npx express-generator</span></pre><p id="f16b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能需要管理员权限来做到这一点。</p><p id="e1e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们进入<code class="fe mh mi mj mk b">frontend</code>文件夹。</p><p id="517b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过运行以下命令来安装最新版本的Vue CLI:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c800" class="mt lf it mk b gy mu mv l mw mx">npm install -g @vue/cli</span></pre><p id="77a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Vue CLI 4.5或更高版本可以创建Vue 3项目。</p><p id="ff3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">frontend</code>文件夹中，我们运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3ce5" class="mt lf it mk b gy mu mv l mw mx">vue create .</span></pre><p id="2796" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们选择“Vue 3(默认)”选项。</p><p id="89a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们必须安装软件包。</p><p id="d2ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们停留在<code class="fe mh mi mj mk b">frontend</code>文件夹中并运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="af56" class="mt lf it mk b gy mu mv l mw mx">npm i axios vue-router@4.0.0-beta.12</span></pre><p id="8678" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装Axios HTTP客户端和与Vue 3兼容的Vue Router 4.x。</p><p id="1dcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">backend</code>文件夹中，我们运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2e9a" class="mt lf it mk b gy mu mv l mw mx">npm i cors momgoose jsonwebtoken</span></pre><p id="1d01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装CORS和Mongoose包以支持跨域通信并使用MongoDB。</p><p id="7313" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">jsonwebtoken</code>让我们将JSON web令牌认证添加到我们的应用程序中。</p><h1 id="614e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建后端</h1><p id="9ca8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们已经准备好创建后端应用程序来使用MongoDB并添加身份验证。</p><p id="e5f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们在后端文件夹中创建<code class="fe mh mi mj mk b">db.js</code>,并添加:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d3ef" class="mt lf it mk b gy mu mv l mw mx">const { Schema, createConnection } = require('mongoose');<br/>const connection = createConnection('mongodb://localhost:27017/mevn-example', { useNewUrlParser: true });</span><span id="0664" class="mt lf it mk b gy my mv l mw mx">const userSchema = new Schema({<br/>  name: String,<br/>  password: String<br/>});</span><span id="1f5d" class="mt lf it mk b gy my mv l mw mx">const User = connection.model('User', userSchema);</span><span id="a4c2" class="mt lf it mk b gy my mv l mw mx">const todoSchema = new Schema({<br/>  name: String,<br/>  done: Boolean,<br/>  user: { type: Schema.Types.ObjectId, ref: 'User' },<br/>});</span><span id="7a49" class="mt lf it mk b gy my mv l mw mx">const Todo = connection.model('Todo', todoSchema);</span><span id="7dcc" class="mt lf it mk b gy my mv l mw mx">module.exports = {<br/>  User,<br/>  Todo<br/>}</span></pre><p id="6dbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用Mongoose连接到MongoDB数据库并创建模型。</p><p id="a3a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建模型，我们使用<code class="fe mh mi mj mk b">Schema</code>构造函数来创建模式。</p><p id="1727" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加属性和它们的数据类型。</p><p id="53a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">user</code>属性引用来自<code class="fe mh mi mj mk b">User</code>模型的对象ID，以便我们可以将todo条目链接到用户。</p><p id="da2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mh mi mj mk b">connection.model</code>来使用模式创建模型。</p><p id="19c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们在<code class="fe mh mi mj mk b">backend</code>文件夹中创建<code class="fe mh mi mj mk b">constants.js</code>，并写入:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6c62" class="mt lf it mk b gy mu mv l mw mx">module.exports = {<br/>  SECRET: 'secret'<br/>}</span></pre><p id="b5f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将JSON web令牌的秘密放在这个文件中，并在路由文件中使用它们。</p><p id="72b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们进入<code class="fe mh mi mj mk b">routes</code>文件夹，为API路由添加文件。</p><p id="63b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在<code class="fe mh mi mj mk b">routes</code>文件夹中创建<code class="fe mh mi mj mk b">todos.js</code>，并写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c4e6" class="mt lf it mk b gy mu mv l mw mx">var express = require('express');<br/>var router = express.Router();<br/>const { Todo } = require('../db');<br/>const jwt = require('jsonwebtoken');<br/>const { SECRET } = require('../constants');</span><span id="0ccb" class="mt lf it mk b gy my mv l mw mx">const verifyToken = (req, res, next) =&gt; {<br/>  try {<br/>    req.user = jwt.verify(req.headers.authorization, SECRET);<br/>    return next();<br/>  } catch (err) {<br/>    console.log(err)<br/>    return res.status(401);<br/>  }<br/>}</span><span id="d415" class="mt lf it mk b gy my mv l mw mx">router.get('/', verifyToken, async (req, res) =&gt; {<br/>  const { _id } = req.user;<br/>  const todos = await Todo.find({ user: _id })<br/>  res.json(todos);<br/>});</span><span id="55ff" class="mt lf it mk b gy my mv l mw mx">router.get('/:id', verifyToken, async (req, res) =&gt; {<br/>  const { _id } = req.user;<br/>  const { id } = req.params;<br/>  const todo = await Todo.findOne({ _id: id, user: _id })<br/>  res.json(todo);<br/>});</span><span id="6237" class="mt lf it mk b gy my mv l mw mx">router.post('/', verifyToken, async (req, res) =&gt; {<br/>  const { name } = req.body;<br/>  const { _id } = req.user;<br/>  const todo = new Todo({ name, done: false, user: _id })<br/>  await todo.save()<br/>  res.json(todo);<br/>});</span><span id="2eb8" class="mt lf it mk b gy my mv l mw mx">router.put('/:id', verifyToken, async (req, res) =&gt; {<br/>  const { name, done } = req.body;<br/>  const { id } = req.params;<br/>  const todo = await Todo.findOneAndUpdate({ _id: id }, { name, done })<br/>  await todo.save();<br/>  res.json(todo);<br/>});</span><span id="fe21" class="mt lf it mk b gy my mv l mw mx">router.delete('/:id', verifyToken, async (req, res) =&gt; {<br/>  const { id } = req.params;<br/>  await Todo.deleteOne({ _id: id })<br/>  res.status(200).send();<br/>});</span><span id="56cd" class="mt lf it mk b gy my mv l mw mx">module.exports = router;</span></pre><p id="710f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">verifyToken</code>中间件有<code class="fe mh mi mj mk b">jwt.verify</code>方法用我们的<code class="fe mh mi mj mk b">SECRET</code>密钥验证令牌。</p><p id="d5d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有效，我们将<code class="fe mh mi mj mk b">req.user</code>设置为解码后的令牌。</p><p id="51cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mh mi mj mk b">next</code>来调用路由器处理程序。</p><p id="35f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们使用GET <code class="fe mh mi mj mk b">/</code>路由从<code class="fe mh mi mj mk b">req.user</code>获取用户数据，然后调用<code class="fe mh mi mj mk b">Todo.find</code>来查找用户的todo条目。</p><p id="da92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Todo</code>是我们之前创建的模型。</p><p id="14e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GET <code class="fe mh mi mj mk b">/:id</code>路由通过ID获取<code class="fe mh mi mj mk b">Todo</code>条目。</p><p id="41bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">findOne</code>获取<code class="fe mh mi mj mk b">todos</code>集合中的第一个结果。</p><p id="5f2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">req.params</code>从URL参数中获取URL参数。</p><p id="9f67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后POST <code class="fe mh mi mj mk b">/</code> route从<code class="fe mh mi mj mk b">req.body</code>属性中获取<code class="fe mh mi mj mk b">name</code>，该属性具有请求体daya。</p><p id="5485" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe mh mi mj mk b">req.user</code>属性中获取<code class="fe mh mi mj mk b">_id</code>属性来获取用户数据。</p><p id="d99c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用这两者来创建todo条目。</p><p id="8a2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">user</code>拥有用户的对象ID。</p><p id="1bab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输入<code class="fe mh mi mj mk b">/:id</code>路线用于更新用户。</p><p id="6e2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从有请求体的<code class="fe mh mi mj mk b">req.body</code>中得到<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">done</code>。</p><p id="257a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">req.params</code>具有<code class="fe mh mi mj mk b">id</code>属性，该属性具有todo条目的ID。</p><p id="db18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj mk b">id</code>来查找todo条目。</p><p id="e305" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并更新<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">done</code>属性以更新条目。</p><p id="2266" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mh mi mj mk b">todo.save()</code>保存数据。</p><p id="45d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">删除<code class="fe mh mi mj mk b">/:id</code>路径允许我们通过ID删除todo条目。</p><p id="0ea4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mh mi mj mk b">_id</code>调用<code class="fe mh mi mj mk b">deleteOne</code>来做这件事。</p><p id="ade7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们运行路由处理程序之前，<code class="fe mh mi mj mk b">verifyToken</code>将确保令牌有效。</p><p id="542e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">req.headers.authorization</code>有授权令牌。<code class="fe mh mi mj mk b">req.headers</code>有HTTP请求头。</p><p id="19b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们在<code class="fe mh mi mj mk b">routes</code>文件夹中创建<code class="fe mh mi mj mk b">users.js</code>，并写入:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f00b" class="mt lf it mk b gy mu mv l mw mx">var express = require('express');<br/>var router = express.Router();<br/>const bcrypt = require('bcrypt');<br/>const { User } = require('../db');<br/>const { SECRET } = require('../constants');<br/>const jwt = require('jsonwebtoken');<br/>const saltRounds = 10;</span><span id="f037" class="mt lf it mk b gy my mv l mw mx">router.post('/register', async (req, res) =&gt; {<br/>  const { name, password } = req.body;<br/>  const existingUser = await User.findOne({ name });<br/>  if (existingUser) {<br/>    return res.json({ err: 'user already exists' }).status(401);<br/>  }<br/>  const hashedPassword = await bcrypt.hash(password, saltRounds);<br/>  const user = new User({<br/>    name,<br/>    password: hashedPassword<br/>  })<br/>  await user.save();<br/>  res.json(user).status(201);<br/>});</span><span id="0147" class="mt lf it mk b gy my mv l mw mx">router.post('/login', async (req, res) =&gt; {<br/>  const { name, password } = req.body;<br/>  const { _id, password: userPassword } = await User.findOne({ name });<br/>  const match = await bcrypt.compare(password, userPassword);<br/>  if (match) {<br/>    const token = await jwt.sign({ name, _id }, SECRET);<br/>    return res.json({ token });<br/>  }<br/>  res.status(401);<br/>});</span><span id="9a6d" class="mt lf it mk b gy my mv l mw mx">module.exports = router;</span></pre><p id="fcb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它类似于<code class="fe mh mi mj mk b">todos.js</code>。</p><p id="11c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有POST <code class="fe mh mi mj mk b">/register</code>路径从JSON请求体获取<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">password</code>属性。</p><p id="71f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们检查具有给定名称的用户是否存在。</p><p id="3bf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mh mi mj mk b">bcrypt.hash</code>来散列密码和秘密。</p><p id="93d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">hashedPassword</code>保存用户。</p><p id="12f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">POST <code class="fe mh mi mj mk b">/login</code>路由从JSON请求体获得<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">password</code>。</p><p id="d250" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj mk b">bcrypt.compare</code>方法来比较密码。</p><p id="da84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们创建令牌，如果验证成功，就在响应中返回它。</p><p id="f54b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们发送401响应。</p><p id="9779" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们将所有内容都放在<code class="fe mh mi mj mk b">backend</code>文件夹的<code class="fe mh mi mj mk b">app.js</code>中。</p><p id="1422" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用以下内容替换现有内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d8b9" class="mt lf it mk b gy mu mv l mw mx">var createError = require('http-errors');<br/>var express = require('express');<br/>var path = require('path');<br/>var cookieParser = require('cookie-parser');<br/>var logger = require('morgan');<br/>var cors = require('cors')</span><span id="468c" class="mt lf it mk b gy my mv l mw mx">var todorouter = require('./routes/todo');<br/>var usersRouter = require('./routes/users');</span><span id="070b" class="mt lf it mk b gy my mv l mw mx">var app = express();<br/>app.use(cors())<br/>// view engine setup<br/>app.set('views', path.join(__dirname, 'views'));<br/>app.set('view engine', 'jade');</span><span id="6939" class="mt lf it mk b gy my mv l mw mx">app.use(logger('dev'));<br/>app.use(express.json());<br/>app.use(express.urlencoded({ extended: false }));<br/>app.use(cookieParser());<br/>app.use(express.static(path.join(__dirname, 'public')));</span><span id="e46b" class="mt lf it mk b gy my mv l mw mx">app.use('/todos', todorouter);<br/>app.use('/users', usersRouter);</span><span id="c557" class="mt lf it mk b gy my mv l mw mx">// catch 404 and forward to error handler<br/>app.use(function(req, res, next) {<br/>  next(createError(404));<br/>});</span><span id="d96a" class="mt lf it mk b gy my mv l mw mx">// error handler<br/>app.use(function(err, req, res, next) {<br/>  // set locals, only providing error in development<br/>  res.locals.message = err.message;<br/>  res.locals.error = req.app.get('env') === 'development' ? err : {};</span><span id="1b49" class="mt lf it mk b gy my mv l mw mx">// render the error page<br/>  res.status(err.status || 500);<br/>  res.render('error');<br/>});</span><span id="d69e" class="mt lf it mk b gy my mv l mw mx">module.exports = app;</span></pre><p id="93fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加了<code class="fe mh mi mj mk b">cors</code>中间件，这样我们就可以和前端通信了。</p><p id="6867" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj mk b">todorouter</code>和<code class="fe mh mi mj mk b">usersRouter</code>将路线添加到我们的应用程序中。</p><h1 id="a0e6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Vue 3前端</h1><p id="13cf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们完成了后端，我们在前端工作。</p><p id="2865" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，在<code class="fe mh mi mj mk b">components</code>文件夹中，我们创建<code class="fe mh mi mj mk b">TodoForm.vue</code>并写入:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6493" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;h1&gt;{{ edit ? "Edit" : "Add" }} Todo&lt;/h1&gt;<br/>    &lt;form <a class="ae kf" href="http://twitter.com/submit" rel="noopener ugc nofollow" target="_blank">@submit</a>.prevent="submit"&gt;<br/>      &lt;div class="form-field"&gt;<br/>        &lt;label&gt;Name&lt;/label&gt;<br/>        &lt;br /&gt;<br/>        &lt;input v-model="form.name" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        &lt;label&gt;Done&lt;/label&gt;<br/>        &lt;input type="checkbox" v-model="form.done" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/form&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="4846" class="mt lf it mk b gy my mv l mw mx">&lt;script&gt;<br/>import axios from "axios";<br/>import { APIURL } from "../constants";</span><span id="3b19" class="mt lf it mk b gy my mv l mw mx">export default {<br/>  name: "TodoForm",<br/>  data() {<br/>    return {<br/>      form: { name: "", done: false },<br/>    };<br/>  },<br/>  props: {<br/>    edit: Boolean,<br/>    id: String,<br/>  },<br/>  methods: {<br/>    async submit() {<br/>      const { name, done } = this.form;<br/>      if (!name) {<br/>        return alert("Name is required");<br/>      }<br/>      if (this.edit) {<br/>        await axios.put(`${APIURL}/todos/${this.id}`, { name, done });<br/>      } else {<br/>        await axios.post(`${APIURL}/todos`, { name, done });<br/>      }<br/>      this.$router.push("/todos");<br/>    },<br/>    async getTodo() {<br/>      const { data } = await axios.get(`${APIURL}/todos/${this.id}`);<br/>      this.form = data;<br/>    },<br/>  },<br/>  beforeMount() {<br/>    if (this.edit) {<br/>      this.getTodo();<br/>    }<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="2dd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个表单让我们添加或编辑待办事项条目。</p><p id="58c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它使用<code class="fe mh mi mj mk b">edit</code>属性来指示我们是否正在编辑一个todo。</p><p id="27f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj mk b">v-model</code>将输入绑定到无功属性。</p><p id="9607" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们检查<code class="fe mh mi mj mk b">this.edit</code>值。</p><p id="b5c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果是<code class="fe mh mi mj mk b">true</code>，我们用todo条目的<code class="fe mh mi mj mk b">id</code>发出一个PUT请求。</p><p id="4d7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们发出POST请求来创建一个新的todo条目。</p><p id="9a96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们编辑的时候，<code class="fe mh mi mj mk b">getTodo</code>方法让我们通过ID获得todo。</p><p id="bd64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，在<code class="fe mh mi mj mk b">src</code>文件夹中，我们创建<code class="fe mh mi mj mk b">views</code>文件夹来添加路线组件。</p><p id="826d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建<code class="fe mh mi mj mk b">AddTodoForm.vue</code>文件并添加:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ca14" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;TodoForm&gt;&lt;/TodoForm&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="1a6f" class="mt lf it mk b gy my mv l mw mx">&lt;script&gt;<br/>import TodoForm from "@/components/TodoForm";</span><span id="6c94" class="mt lf it mk b gy my mv l mw mx">export default {<br/>  components: {<br/>    TodoForm,<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="9165" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们注册了<code class="fe mh mi mj mk b">TodoForm</code>组件，并将其呈现在模板中。</p><p id="b3cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们在<code class="fe mh mi mj mk b">views</code>文件夹中创建<code class="fe mh mi mj mk b">EditTodoForm.vue</code>并添加:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8d2c" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;TodoForm edit :id='$route.params.id'&gt;&lt;/TodoForm&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="6217" class="mt lf it mk b gy my mv l mw mx">&lt;script&gt;<br/>import TodoForm from "@/components/TodoForm";</span><span id="d77b" class="mt lf it mk b gy my mv l mw mx">export default {<br/>  components: {<br/>    TodoForm,<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="8228" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mh mi mj mk b">edit</code>和<code class="fe mh mi mj mk b">id</code>属性传递给<code class="fe mh mi mj mk b">TodoForm</code>，这样它就可以通过ID获得todo条目。</p><p id="fc89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">$route.params.id</code>具有todo条目的对象ID。</p><p id="5624" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们在<code class="fe mh mi mj mk b">views</code>文件夹中创建<code class="fe mh mi mj mk b">Login.vue</code>文件来添加一个登录表单。</p><p id="8afa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个文件中，我们添加了:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d332" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;h1&gt;Login&lt;/h1&gt;<br/>    &lt;form @submit.prevent="login"&gt;<br/>      &lt;div class="form-field"&gt;<br/>        &lt;label&gt;Username&lt;/label&gt;<br/>        &lt;br /&gt;<br/>        &lt;input v-model="form.name" type="text" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="form-field"&gt;<br/>        &lt;label&gt;Password&lt;/label&gt;<br/>        &lt;br /&gt;<br/>        &lt;input v-model="form.password" type="password" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        &lt;input type="submit" value="Log in" /&gt;<br/>        &lt;button type="button" @click="$router.push('/register')"&gt;<br/>          Register<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/form&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="5620" class="mt lf it mk b gy my mv l mw mx">&lt;script&gt;<br/>import axios from "axios";<br/>import { APIURL } from "../constants";</span><span id="3ed5" class="mt lf it mk b gy my mv l mw mx">export default {<br/>  data() {<br/>    return {<br/>      form: { name: "", password: "" },<br/>    };<br/>  },<br/>  methods: {<br/>    async login() {<br/>      const { name, password } = this.form;<br/>      if (!name || !password) {<br/>        alert("Username and password are required");<br/>      }<br/>      try {<br/>        const {<br/>          data: { token },<br/>        } = await axios.post(`${APIURL}/users/login`, {<br/>          name,<br/>          password,<br/>        });<br/>        localStorage.setItem("token", token);<br/>        this.$router.push("/todos");<br/>      } catch (error) {<br/>        alert("Invalid username or password.");<br/>      }<br/>    },<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="8427" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个表单，接受用户名和密码，让用户登录。</p><p id="e770" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们提交表单时，会调用<code class="fe mh mi mj mk b">login</code>方法。</p><p id="8c11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在该方法中，我们检查<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">password</code>是否有值。</p><p id="2364" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它们都不为空，我们继续发出<code class="fe mh mi mj mk b">login</code>请求。</p><p id="6fe7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果成功了，我们就走<code class="fe mh mi mj mk b">/todos</code>路线。</p><p id="ed19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们应该得到一个错误信息。</p><p id="2538" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，我们为注册表单创建<code class="fe mh mi mj mk b">Register.vue</code>组件。</p><p id="94ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用下面的代码填充它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="043f" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;h1&gt;Register&lt;/h1&gt;<br/>    &lt;form @submit.prevent="register"&gt;<br/>      &lt;div class="form-field"&gt;<br/>        &lt;label&gt;Username&lt;/label&gt;<br/>        &lt;br /&gt;<br/>        &lt;input v-model="form.name" type="text" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="form-field"&gt;<br/>        &lt;label&gt;Password&lt;/label&gt;<br/>        &lt;br /&gt;<br/>        &lt;input v-model="form.password" type="password" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        &lt;input type="submit" value="Register" /&gt;<br/>        &lt;button type="button" @click="$router.push('/')"&gt;Login&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/form&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="7399" class="mt lf it mk b gy my mv l mw mx">&lt;script&gt;<br/>import axios from "axios";<br/>import { APIURL } from "../constants";</span><span id="62da" class="mt lf it mk b gy my mv l mw mx">export default {<br/>  data() {<br/>    return {<br/>      form: { name: "", password: "" },<br/>    };<br/>  },<br/>  methods: {<br/>    async register() {<br/>      const { name, password } = this.form;<br/>      if (!name || !password) {<br/>        alert("Username and password are required");<br/>      }<br/>      try {<br/>        await axios.post(`${APIURL}/users/register`, {<br/>          name,<br/>          password,<br/>        });<br/>        alert("Registration successful");<br/>      } catch (error) {<br/>        alert("Registration failed.");<br/>      }<br/>    },<br/>  },<br/>};<br/>&lt;/script&gt;</span></pre><p id="5ce6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们以同样的方式获得用户名和密码。</p><p id="f8d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它们都不为空，那么我们向<code class="fe mh mi mj mk b">register</code>路线发出请求。</p><p id="57cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦成功，我们将显示一条成功消息。</p><p id="02ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们显示一条失败消息，该消息在<code class="fe mh mi mj mk b">catch</code>块中。</p><p id="c6de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们有一个组件来显示待办事项。</p><p id="1d26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在<code class="fe mh mi mj mk b">views</code>文件夹中创建<code class="fe mh mi mj mk b">Todo.vue</code>并写入:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="55e8" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;h1&gt;Todos&lt;/h1&gt;<br/>    &lt;button @click="$router.push(`/add-todo`)"&gt;Add Todo&lt;/button&gt;<br/>    &lt;button @click="logOut"&gt;Logout&lt;/button&gt;<br/>    &lt;table&gt;<br/>      &lt;thead&gt;<br/>        &lt;tr&gt;<br/>          &lt;th&gt;Name&lt;/th&gt;<br/>          &lt;th&gt;Done&lt;/th&gt;<br/>          &lt;th&gt;Edit&lt;/th&gt;<br/>          &lt;th&gt;Delete&lt;/th&gt;<br/>        &lt;/tr&gt;<br/>      &lt;/thead&gt;<br/>      &lt;tbody&gt;<br/>        &lt;tr v-for="t of todos" :key="t._id"&gt;<br/>          &lt;td&gt;{{ t.name }}&lt;/td&gt;<br/>          &lt;td&gt;{{ t.done }}&lt;/td&gt;<br/>          &lt;td&gt;<br/>            &lt;button @click="$router.push(`/edit-todo/${t._id}`)"&gt;Edit&lt;/button&gt;<br/>          &lt;/td&gt;<br/>          &lt;td&gt;<br/>            &lt;button @click="deleteTodo(t._id)"&gt;Delete&lt;/button&gt;<br/>          &lt;/td&gt;<br/>        &lt;/tr&gt;<br/>      &lt;/tbody&gt;<br/>    &lt;/table&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="20fb" class="mt lf it mk b gy my mv l mw mx">&lt;script&gt;<br/>import axios from "axios";<br/>import { APIURL } from "../constants";</span><span id="bc81" class="mt lf it mk b gy my mv l mw mx">export default {<br/>  data() {<br/>    return {<br/>      todos: [],<br/>    };<br/>  },<br/>  methods: {<br/>    async getTodos() {<br/>      const { data: todos } = await axios.get(`${APIURL}/todos`);<br/>      this.todos = todos;<br/>    },<br/>    async deleteTodo(id) {<br/>      await axios.delete(`${APIURL}/todos/${id}`);<br/>      this.getTodos();<br/>    },<br/>    logOut() {<br/>      localStorage.clear();<br/>      this.$router.push("/");<br/>    },<br/>  },<br/>  beforeMount() {<br/>    this.getTodos();<br/>  },<br/>};<br/>&lt;/script&gt;</span><span id="3a3f" class="mt lf it mk b gy my mv l mw mx">&lt;style scoped&gt;<br/>th:first-child,<br/>td:first-child {<br/>  width: 60%;<br/>}</span><span id="bf47" class="mt lf it mk b gy my mv l mw mx">th {<br/>  text-align: left;<br/>}<br/>&lt;/style&gt;</span></pre><p id="c659" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有Add Todo按钮，当我们点击它时会转到<code class="fe mh mi mj mk b">add-todo</code>路线。</p><p id="b178" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将被映射到<code class="fe mh mi mj mk b">AddTodoForm.vue</code>组件。</p><p id="667b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当注销按钮被点击时，它调用<code class="fe mh mi mj mk b">logOut</code>方法。</p><p id="21a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它只是清除本地存储并将用户重定向到登录页面。</p><p id="ebba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">getTodos</code>方法获取用户的todo条目。</p><p id="4066" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从解码的令牌中确定用户身份。</p><p id="17a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">指令呈现并显示这些项目。</p><p id="3597" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“编辑”按钮转到编辑表单。</p><p id="2e59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们点击删除按钮时，它会调用<code class="fe mh mi mj mk b">deleteTodo</code>。</p><p id="b4fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">deleteTodo</code>向<code class="fe mh mi mj mk b">todos</code>路由发出删除请求。</p><p id="3521" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在删除一个todo条目后或者在加载页面时调用<code class="fe mh mi mj mk b">getTodos</code>。</p><p id="ed20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来在<code class="fe mh mi mj mk b">src/App.vue</code>中，我们添加我们的<code class="fe mh mi mj mk b">router-view</code>来显示路线:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="058a" class="mt lf it mk b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;router-view&gt;&lt;/router-view&gt;<br/>&lt;/template&gt;</span><span id="b660" class="mt lf it mk b gy my mv l mw mx">&lt;script&gt;<br/>export default {<br/>  name: "App",<br/>};<br/>&lt;/script&gt;</span><span id="f2a1" class="mt lf it mk b gy my mv l mw mx">&lt;style&gt;<br/>.form-field input {<br/>  width: 100%;<br/>}</span><span id="fb7e" class="mt lf it mk b gy my mv l mw mx">#app {<br/>  margin: 0 auto;<br/>  width: 70vw;<br/>}<br/>&lt;/style&gt;</span></pre><p id="bad2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在<code class="fe mh mi mj mk b">src</code>文件夹中创建<code class="fe mh mi mj mk b">constants.js</code>并添加:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c4bd" class="mt lf it mk b gy mu mv l mw mx">export const APIURL = 'http://localhost:3000'</span></pre><p id="fb2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在任何地方都可以使用<code class="fe mh mi mj mk b">APIURL</code>,这样我们就不必在发出请求时重复后端API的基本URL。</p><p id="c82e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在<code class="fe mh mi mj mk b">main.js</code>中，我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ba02" class="mt lf it mk b gy mu mv l mw mx">import { createApp } from 'vue'<br/>import App from './App.vue'<br/>import { createRouter, createWebHashHistory } from 'vue-router';<br/>import Login from '@/views/Login';<br/>import Todo from '@/views/Todo';<br/>import Register from '@/views/Register';<br/>import AddTodoForm from '@/views/AddTodoForm';<br/>import EditTodoForm from '@/views/EditTodoForm';<br/>import axios from 'axios';</span><span id="08c3" class="mt lf it mk b gy my mv l mw mx">axios.interceptors.request.use((config) =&gt; {<br/>  if (config.url.includes('login') || config.url.includes('register')) {<br/>    return config;<br/>  }<br/>  return {<br/>    ...config, headers: {<br/>      Authorization: localStorage.getItem("token"),<br/>    }<br/>  }<br/>}, (error) =&gt; {<br/>  return Promise.reject(error);<br/>});</span><span id="5e92" class="mt lf it mk b gy my mv l mw mx">const beforeEnter = (to, from, next) =&gt; {<br/>  const token = localStorage.getItem('token');<br/>  if (token) {<br/>    next()<br/>    return true;<br/>  }<br/>  next({ path: '/' });<br/>  return false<br/>}</span><span id="43eb" class="mt lf it mk b gy my mv l mw mx">const routes = [<br/>  { path: '/', component: Login },<br/>  { path: '/register', component: Register },<br/>  { path: '/todos', component: Todo, beforeEnter },<br/>  { path: '/add-todo', component: AddTodoForm, beforeEnter },<br/>  { path: '/edit-todo/:id', component: EditTodoForm, beforeEnter },<br/>]</span><span id="4f98" class="mt lf it mk b gy my mv l mw mx">const router = createRouter({<br/>  history: createWebHashHistory(),<br/>  routes<br/>})</span><span id="466d" class="mt lf it mk b gy my mv l mw mx">const app = createApp(App);<br/>app.use(router);<br/>app.mount('#app')</span></pre><p id="3c4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加<code class="fe mh mi mj mk b">vue-router</code>和Axios请求拦截器，为认证路由添加认证令牌。</p><p id="a166" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">beforeEnter</code>是一个路由保护，允许我们限制对已认证路由的访问。</p><p id="055c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在将用户重定向到他们要去的页面之前，我们检查令牌是否存在。</p><p id="7b8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们重定向到登录页面。</p><p id="3f0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">routes</code>拥有所有的航线。<code class="fe mh mi mj mk b">path</code>有路由URL，而<code class="fe mh mi mj mk b">component</code>有我们想要加载的组件。</p><p id="f7f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">beforeEnter</code>是在路线加载之前加载的路线防护。</p><p id="0c4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">createRouter</code>创建路由器对象。</p><p id="ab05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们对URL使用散列模式。</p><p id="70a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，URL在基本URL和其余URL段之间会有一个<code class="fe mh mi mj mk b">#</code>符号。</p><p id="f981" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mh mi mj mk b">app.use(router)</code>来添加路由器，并使<code class="fe mh mi mj mk b">this.$route</code>和<code class="fe mh mi mj mk b">thuis.$router</code>属性在组件中可用。</p><p id="5119" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以从<code class="fe mh mi mj mk b">frontend</code>文件夹和<code class="fe mh mi mj mk b">node bin/www</code>中运行<code class="fe mh mi mj mk b">npm run serve</code>来启动后端。</p><h1 id="7faa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b91e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以毫不费力地用最新的JavaScript框架和特性创建一个简单的MEVN stack应用程序。</p></div></div>    
</body>
</html>