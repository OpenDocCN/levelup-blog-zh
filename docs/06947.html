<html>
<head>
<title>Accessible modals in Gatsby using portals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">《盖茨比》中使用门户的可及情态动词</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/accessible-modals-in-gatsby-using-portals-1e80e33a8a2?source=collection_archive---------1-----------------------#2021-01-13">https://levelup.gitconnected.com/accessible-modals-in-gatsby-using-portals-1e80e33a8a2?source=collection_archive---------1-----------------------#2021-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8d0b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">和附加反作用钩</h2></div><p id="01ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向你的网站或应用程序添加一个模态(对话框)是一个常见的场景。我们如何在React中做到这一点？具体在《盖茨比》里？在React version 16之前，开发人员不得不稍作改动来创建这个简单的元素。这是因为没有直接的方法在根/父元素旁边创建DOM元素，这可能会导致定位问题(z-index，overflow: hidden)。React v16引入了一个名为Portals的新特性来实现这一点。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a82e34eda7d6f7e7605a8d27b820017d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r2pyOyMw_649wfa9"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated"><a class="ae lr" href="https://unsplash.com/@zoltantasi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zoltan·塔斯</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="e17a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">React门户</h1><p id="db4c" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在Gatsby的例子中，在实现React门户后，DOM看起来像这样。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="fa92" class="mu lt iq mq b gy mv mw l mx my">&lt;html&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="___gatsby"&gt;&lt;/div&gt;<br/>    &lt;div id="portal"&gt;&lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="4666" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mz"> #___gatsby </em>是父元素，<em class="mz"> #portal </em>是一个新的兄弟节点，我们可以在其中注入我们的模态。</p><p id="6a83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们创建门户的方式:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="b59a" class="mu lt iq mq b gy mv mw l mx my">ReactDOM.createPortal(child, container)</span></pre><blockquote class="na nb nc"><p id="1d7f" class="kf kg mz kh b ki kj jr kk kl km ju kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated"><em class="iq">第一个参数(</em> <code class="fe ng nh ni mq b"><em class="iq">child</em></code> <em class="iq">)是任何</em> <a class="ae lr" href="https://reactjs.org/docs/react-component.html#render" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> renderable React子</em> </a> <em class="iq">)，如元素、字符串或片段。第二个参数(</em> <code class="fe ng nh ni mq b"><em class="iq">container</em></code> <em class="iq">)是一个DOM元素。</em></p></blockquote><p id="32f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在HTML中我们可以添加一个新元素#portal，就像上面一样，访问它</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="1bf7" class="mu lt iq mq b gy mv mw l mx my">var container = document.getElementById('portal')</span></pre><p id="9a09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并将其作为第二个参数传递给<em class="mz"> createPortal() </em>。</p><p id="c3c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">重要提示</strong>:</p><blockquote class="na nb nc"><p id="d4ca" class="kf kg mz kh b ki kj jr kk kl km ju kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated">尽管门户可以在DOM树中的任何位置，但它在其他方面的行为都像普通的React子节点。无论子节点是否是门户，上下文之类的特性都完全相同，因为门户仍然存在于 React树<em class="iq">中，而与</em> DOM树<em class="iq">中的位置无关。</em></p></blockquote><p id="cdb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在《盖茨比》中我们如何做到？</p><h1 id="d713" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><a class="ae lr" href="https://www.gatsbyjs.com/plugins/gatsby-plugin-portal/?=gatsby-plugin-portal" rel="noopener ugc nofollow" target="_blank">盖茨比插件门户</a></h1><p id="2de1" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如果我们想在Gatsby中使用门户，我们可以使用一个插件来处理一些令人不安的挑战。其中两个是:</p><ul class=""><li id="0379" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated"><strong class="kh ir">index.html在《盖茨比》中并不存在(只在《营造》之后)</strong></li><li id="2898" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><strong class="kh ir">在构建期间未定义文档对象。</strong></li></ul><p id="8e9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装插件:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="7c24" class="mu lt iq mq b gy mv mw l mx my">npm install --save gatsby-plugin-portal</span></pre><p id="8bf8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在gatsby-config.js中我们添加:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="ceda" class="mu lt iq mq b gy mv mw l mx my">module.exports = {<br/>  plugins: [`gatsby-plugin-portal`]<br/>}</span></pre><p id="655e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个选项<a class="ae lr" href="https://gist.github.com/miresk/abe67ef6ab1f8e76675d0a1fe44170ce" rel="noopener ugc nofollow" target="_blank">你可以指定，创建元素的键和id，默认设置为“门户”。</a></p><p id="9faf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">插件使用<code class="fe ng nh ni mq b"><em class="mz">onRenderBody </em></code> API为我们添加了div组件，但是我们仍然需要覆盖第二点。是时候创建portal.js文件了，它会处理这些问题。</p><p id="595e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> portal.js </strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d6fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对它创建的文档模型有一些检查。</p><p id="279e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建一个模态组件。</p><h1 id="1fe0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模态和附加挂钩</h1><p id="3010" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如何创建模态取决于项目和您的需求，但是我想使用一些React挂钩和如下有趣的技术与您一起构建一个可访问的模态组件:</p><ul class=""><li id="ccb6" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated"><code class="fe ng nh ni mq b"><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code></li><li id="6cb7" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><code class="fe ng nh ni mq b"><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">useRef</a></code></li><li id="8b04" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><code class="fe ng nh ni mq b"><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank">useImperativeHandle</a></code></li><li id="5992" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">转发参考</li></ul><p id="bf49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">啊！我们需要所有这些来创建一个简单的模态窗口吗？</p><p id="2953" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我明白你的意思，但别担心，这只是几行代码。让我先给你看完整的代码。</p><p id="b082" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> modal.js </strong></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="aa73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模态组件已经准备好了，所以我们可以在其他组件(例如about.js)中导入它，并像这样使用它:</p><p id="f320" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> about.js </strong></p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="5859" class="mu lt iq mq b gy mv mw l mx my">import React, {useRef} from 'react';<br/><strong class="mq ir">import Modal from './modal';</strong></span><span id="bc39" class="mu lt iq mq b gy nz mw l mx my">export default function About() {<br/>    <strong class="mq ir">const modalRef1 = useRef();</strong><br/>    <br/>    return (<br/>        &lt;section&gt;<br/>            &lt;button className="btn" onClick={<strong class="mq ir">() =&gt; modalRef1.current.openModal()</strong>}&gt;Open modal&lt;/button&gt;</span><span id="57c6" class="mu lt iq mq b gy nz mw l mx my"><strong class="mq ir">            &lt;Modal ref={modalRef1}&gt;<br/>                &lt;h3&gt;Modal title 1&lt;/h3&gt;<br/>            &lt;/Modal&gt;</strong><br/>        &lt;/section&gt;<br/>    )<br/>}</span></pre><p id="141b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们浏览一下上面的代码。</p><h2 id="22f1" class="mu lt iq bd lu oa ob dn ly oc od dp mc ko oe of me ks og oh mg kw oi oj mi ok bi translated">useState()挂钩</h2><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="d84b" class="mu lt iq mq b gy mv mw l mx my"><em class="mz">const</em> [display, setDisplay] = useState(false)</span></pre><p id="ebd2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认状态为false，这意味着模式是关闭的。我们有两个显示/隐藏模态的函数，我们相应地调用<em class="mz"> setDisplay() </em>。True或false值存储在<em class="mz"> display </em>变量中，我们在呈现我们的模态(门户)之前检查该变量。</p><h2 id="7569" class="mu lt iq bd lu oa ob dn ly oc od dp mc ko oe of me ks og oh mg kw oi oj mi ok bi translated"><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"> useRef </a>和<a class="ae lr" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank"> forwardRef </a></h2><blockquote class="na nb nc"><p id="2d7a" class="kf kg mz kh b ki kj jr kk kl km ju kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated"><strong class="kh ir"><em class="iq">Ref forwarding</em></strong><em class="iq">是一种自动将</em><a class="ae lr" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"><em class="iq">Ref</em></a><em class="iq">通过一个组件传递给它的一个子组件的技术。</em></p><p id="ffdb" class="kf kg mz kh b ki kj jr kk kl km ju kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated"><strong class="kh ir"> useRef() </strong> <em class="iq">返回一个可变的Ref对象，其</em> <strong class="kh ir">。当前</strong> <em class="iq">属性被初始化。</em></p></blockquote><ol class=""><li id="1e29" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la ol np nq nr bi translated">我们在About组件中创建了一个变量<em class="mz"> modalRef1 </em>，在这里我们想要显示模态，我们将<em class="mz"> useRef() </em>赋给这个变量。<br/> <code class="fe ng nh ni mq b"><em class="mz">const </em><strong class="kh ir"><em class="mz">modalRef1 = useRef()</em></strong><em class="mz">;</em></code></li><li id="6102" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la ol np nq nr bi translated">我们通过将<code class="fe ng nh ni mq b">ref</code>指定为JSX属性，将其传递给<code class="fe ng nh ni mq b">modal</code>。<br/> <code class="fe ng nh ni mq b">&lt;Modal <strong class="kh ir">ref={modalRef1}</strong>&gt;<br/></code> <strong class="kh ir">故意为<em class="mz">。当前的</em>属性(来自useRef)将指向这个元素。</strong></li><li id="a51d" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la ol np nq nr bi translated">React将<code class="fe ng nh ni mq b">ref</code>作为第二个参数传递给<code class="fe ng nh ni mq b">forwardRef</code>中的<code class="fe ng nh ni mq b">(props, ref) =&gt; ...</code>函数。<br/> <code class="fe ng nh ni mq b">const Modal = <strong class="kh ir">forwardRef((props, ref)</strong> =&gt; { // modal.js</code>(在modal.js中)</li></ol><h2 id="da71" class="mu lt iq bd lu oa ob dn ly oc od dp mc ko oe of me ks og oh mg kw oi oj mi ok bi translated"><a class="ae lr" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank"> useImperativeHandle() </a>钩子</h2><blockquote class="na nb nc"><p id="f6f4" class="kf kg mz kh b ki kj jr kk kl km ju kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated"><code class="fe ng nh ni mq b"><em class="iq">useImperativeHandle</em></code> <em class="iq">定制使用</em> <code class="fe ng nh ni mq b"><em class="iq">ref</em></code> <em class="iq">时暴露给父组件的实例值。</em></p></blockquote><p id="94a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在modal.js中我们可以使用我们在<em class="mz"> forwardRef中传递的Ref((props，</em><strong class="kh ir"><em class="mz">ref</em></strong><em class="mz">)</em>中的<em class="mz"> useImperativeHandle() </em>钩子。语法如下所示:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="0399" class="mu lt iq mq b gy mv mw l mx my">useImperativeHandle(ref, createHandle, [deps])</span></pre><p id="774b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="mz"> createHandle </em>的位置，我们返回一个具有两个属性的对象:<em class="mz"> openModal </em>和<em class="mz"> closeModal </em>，这两个属性都是函数。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="d581" class="mu lt iq mq b gy mv mw l mx my">useImperativeHandle(<br/>    ref,<br/>    () =&gt; {<br/>      return {<br/>        openModal: () =&gt; handleOpen(),<br/>        closeModal: () =&gt; handleClose(),<br/>      }<br/>    }<br/>  )</span></pre><p id="a945" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们正在定制ref的<em class="mz">当前</em>属性。在about.js中，我们使用我们的&lt;模态&gt;组件，并且ref指向它。Ref被转发，modal.js接收它并在返回<em class="mz"> openModal() </em>和<em class="mz"> closeModal() </em>函数的<em class="mz"> useImperativeHandle() </em>钩子中使用它。因此，我们可以调用这些函数，例如当我们单击一个按钮时:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="79b0" class="mu lt iq mq b gy mv mw l mx my">&lt;button onClick={() =&gt; <strong class="mq ir">modalRef1.current.openModal()</strong>}&gt;Open modal&lt;/button&gt;</span></pre><p id="e0af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迪伦·科勒在他的文章中是这样说的:</p><blockquote class="na nb nc"><p id="7a78" class="kf kg mz kh b ki kj jr kk kl km ju kn nd kp kq kr ne kt ku kv nf kx ky kz la ij bi translated"><code class="fe ng nh ni mq b"><em class="iq">useImperativeHandle</em></code> <em class="iq">为双向数据和逻辑流提供redux和props之间的中间地带。</em></p></blockquote><p id="75b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这在某些情况下非常有用。而且记住要和<code class="fe ng nh ni mq b"><a class="ae lr" href="https://reactjs.org/docs/react-api.html#reactforwardref" rel="noopener ugc nofollow" target="_blank">forwardRef</a>.</code>一起用</p><p id="0205" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看用户daryanka制作的这个沙箱<a class="ae lr" href="https://codesandbox.io/s/affectionate-fermat-vrc76?file=/src/Modal.js" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"/></a><strong class="kh ir"/>来看看<em class="mz"> useImperativeHandle() </em>的运行情况。</p><h1 id="636f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">可接受性</h1><p id="ee08" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">作为web开发人员，我们应该记住的一件事是可访问性。这个主题本身就值得写一篇文章，所以我将快速列出一些关于情态动词的重要事项。</p><h2 id="c2e0" class="mu lt iq bd lu oa ob dn ly oc od dp mc ko oe of me ks og oh mg kw oi oj mi ok bi translated">角色和属性</h2><p id="f790" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">模态应该包含以下属性。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="e274" class="mu lt iq mq b gy mv mw l mx my">&lt;div role="dialog"<br/>     aria-modal="true"<br/>     aria-labelledby="dialog1_label"&gt;</span></pre><p id="dc92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在Gatsby中，如果我们想将门户仅用于模态，我们可以更新portal.js并将这些行添加到构造函数中，在那里我们创建div。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="05cb" class="mu lt iq mq b gy mv mw l mx my">this.el.setAttribute("role", "dialog");<br/>this.el.setAttribute("aria-modal", "true");</span></pre><h2 id="6faf" class="mu lt iq bd lu oa ob dn ly oc od dp mc ko oe of me ks og oh mg kw oi oj mi ok bi translated">“退出”时关闭模式</h2><p id="3b99" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">其中一种方法是像这样使用useEffect() hook。</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="1bcd" class="mu lt iq mq b gy mv mw l mx my">useEffect(() =&gt; {<br/>    const close = e =&gt; {<br/>        if (e.keyCode === 27) {<br/>            handleClose();<br/>        }<br/>    }<br/>    window.addEventListener('keydown', close)<br/>    return () =&gt; window.removeEventListener('keydown', close)<br/>  }, []);</span></pre><p id="602e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了退出按钮，我们应该考虑使用Tab和Shift + Tab在屏幕上移动。我们把重点放在哪里很重要，但这也取决于你如何组织你的内容。也就是说，我将在这里留下一些与可访问性相关的链接:</p><ul class=""><li id="7acf" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated"><a class="ae lr" href="https://www.gatsbyjs.com/docs/conceptual/making-your-site-accessible/" rel="noopener ugc nofollow" target="_blank">盖茨比——让你的网站变得可访问</a></li><li id="67d4" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><a class="ae lr" href="https://www.w3.org/TR/wai-aria-practices-1.1/examples/dialog-modal/dialog.html" rel="noopener ugc nofollow" target="_blank"> WAI-ARIA练习对话模式</a></li><li id="4ba1" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated">反应— <a class="ae lr" href="https://reactjs.org/docs/accessibility.html#programmatically-managing-focus" rel="noopener ugc nofollow" target="_blank">程序化管理焦点</a></li><li id="9ac2" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><a class="ae lr" href="https://github.com/davidtheclark/react-aria-modal" rel="noopener ugc nofollow" target="_blank">反应-咏叹调-调式</a></li></ul></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="4c9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">其他参考文献:</strong></p><ul class=""><li id="9445" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated"><a class="ae lr" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank"> React门户</a></li><li id="e05d" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><a class="ae lr" href="https://www.gatsbyjs.com/plugins/gatsby-plugin-portal/?=gatsby-plugin-portal" rel="noopener ugc nofollow" target="_blank">盖茨比插件门户</a></li><li id="c037" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><a class="ae lr" href="https://www.youtube.com/watch?v=SmMZqh1xdB4&amp;feature=emb_err_woyt" rel="noopener ugc nofollow" target="_blank"> Youtube视频</a> —使用React挂钩、引用和创建门户来反应模态组件</li><li id="9669" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><a class="ae lr" href="https://www.telerik.com/blogs/better-modals-in-react" rel="noopener ugc nofollow" target="_blank">反应更好的模态</a></li></ul><p id="7693" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢谢大家！</p></div></div>    
</body>
</html>