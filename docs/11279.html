<html>
<head>
<title>Manage a history of domain model changes with Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Spring管理领域模型变更的历史</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/manage-a-history-of-domain-model-changes-with-spring-609d2613fc7d?source=collection_archive---------0-----------------------#2022-03-04">https://levelup.gitconnected.com/manage-a-history-of-domain-model-changes-with-spring-609d2613fc7d?source=collection_archive---------0-----------------------#2022-03-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5a28ba74715365e60cf8b6a11140864c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9jc9rwJkneBCoA9P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@iammrcup?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cup先生/杨奇煜·巴拉</a>拍摄的照片</figcaption></figure><p id="7922" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您是否有在您的系统中跟踪所有域转换事件的实践:什么被改变了，什么时候被改变了，谁发起了这个改变？</p><p id="89cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可能在项目生命周期的开始，产品管理团队对它没什么兴趣，但是在事件调查期间，它变成了一个非常大的可观察性问题。</p><p id="1300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果第一天不支持，最终可以添加支持。我调查了几个与Spring Boot生态系统相关的选项。</p><h1 id="c632" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Hibernate审计支持</h1><p id="a01b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae kc" href="https://hibernate.org/orm/envers/" rel="noopener ugc nofollow" target="_blank"> Envers </a>是Hibernate家族的一个库，为数据库实体提供审计和版本控制支持。Spring通过为Spring Data project "<strong class="kf ir">org . Spring framework . Data:Spring-Data-en vers</strong>"库提供额外的扩展来简化审计的采用。</p><h2 id="735e" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">步骤:</h2><ul class=""><li id="fd41" class="mq mr iq kf b kg lz kk ma ko ms ks mt kw mu la mv mw mx my bi translated">添加“<strong class="kf ir">org . spring framework . data:spring-data-en vers</strong>”库</li><li id="6ad7" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">用<em class="ne"> @Audited </em>注释来修饰实体类(如果只需要一个子集，则注释特定的字段)。</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="6b3c" class="mq mr iq kf b kg kh kk kl ko nl ks nm kw nn la mv mw mx my bi translated">扩展JPA配置以支持审计</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="b820" class="mq mr iq kf b kg kh kk kl ko nl ks nm kw nn la mv mw mx my bi translated">使用附加接口扩展实体存储库</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="bebb" class="mq mr iq kf b kg kh kk kl ko nl ks nm kw nn la mv mw mx my bi translated">注册Luquibase启动脚本以创建附加表来存储修订</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="b0a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。</p><p id="2796" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这个选项被选为最简单的一个。每次用户更新特定实体时，带有附加元数据的修订信息会自动存储在相应的表中。</p><p id="6879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，我们还扩展了实体存储库来管理修订，因此我们可以扩展GET API来包含对搜索到的实体的修订，然后在查看其详细信息时将其显示为附加信息。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/093157a4a3697cab39c0d7737680322b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bt66RbZny7a_3EfJEMmXlA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">查看人员时显示修订</figcaption></figure><p id="5725" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的主要缺点(在我看来)是缺乏灵活性和配置选项来覆盖更复杂的情况。所有的魔法都发生在引擎盖下，暴露出足够低的扩展点来改变一些行为。</p><p id="7fe6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在大多数情况下，我只需要在单个表中保存所有实体类型的所有变更的历史记录，包括该变更的发起者，以便使用单独的数据存储库轻松地操作这些数据。</p><h2 id="5a2e" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">监听JPA实体事件</h2><p id="3885" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">第二种方法——引入一些简单的机制来监听我们感兴趣的所有JPA实体的所有变更事件。这就引入了一个拥有自己职责的域实体—跟踪、聚合、过滤域事件的历史。</p><p id="c273" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的好处是添加了单独的独立垂直切片，因此我们可以控制这种跟踪的许多方面——要跟踪的实体列表、数据预处理、变更启动程序等。</p><p id="7d6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤:</strong></p><ul class=""><li id="995d" class="mq mr iq kf b kg kh kk kl ko nl ks nm kw nn la mv mw mx my bi translated">声明审计模型和围绕它的所有管理服务集(控制器、存储库等)。类定义可以类似于:</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="53c0" class="mq mr iq kf b kg kh kk kl ko nl ks nm kw nn la mv mw mx my bi translated">将所需的实体注释为可审计的，并在侦听器中捕获所需的事件，并存储为审计日志</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="900b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以用额外元信息扩展审计日志，比如这个变更的发起者。这为保留足够用于事件调查的相关审核日志定义提供了更大的灵活性。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/8af2ab05af7176a2227cbe0db36fd327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iWKQF9jYr9-DUalIe0WZtQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">审计日志</figcaption></figure><p id="4220" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的显著缺点:</p><ul class=""><li id="971b" class="mq mr iq kf b kg kh kk kl ko nl ks nm kw nn la mv mw mx my bi translated">侦听器被集成到实体生命周期中，因此会影响整体处理性能。一些减轻性能下降的异步模式需要更复杂的包装器</li><li id="7ca9" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">JPA本身支持事件监听器，但不是通过Spring，所以在这里不能轻易使用Spring依赖注入功能。这需要一些额外的工作来注入额外的模块和额外的支持成本。</li></ul><h2 id="afc9" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">听取JPA实体事件，修订解决方案</h2><p id="0462" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">简单并不总是有效的。如果回顾以前的两种解决方案，我们可以争论是否有必要使用全部的<a class="ae kc" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID </a>能力来存储实体事件。</p><p id="dd60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不是审计日志更接近这里的<a class="ae kc" href="https://en.wikipedia.org/wiki/Eventual_consistency" rel="noopener ugc nofollow" target="_blank">基</a>范式吗？对于这种类型的实体，引用完整性和事务成本如何？保留策略呢？我们真的需要无限期地保存日志或者执行一些清理工作吗？如何使用全文搜索和更复杂的数据聚合来检查特定的数据窗口而不是事件本身？从性能角度以及额外的支持工作来看，成本太高？</p><p id="81be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个解决方案只是对现有事件侦听器解决方案的一个小升级。唯一的变化是——我们没有围绕这个特性引入任何额外的域实体，而是将事件作为日志发布，并将它们发送到集中的Elasticsearch服务器:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cc58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们得到了许多有用的好处:</p><ul class=""><li id="3af0" class="mq mr iq kf b kg kh kk kl ko nl ks nm kw nn la mv mw mx my bi translated">实体管理操作没有性能开销—发布单个日志条目是唯一需要的额外工作</li><li id="6b4b" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">非Spring侦听器中不再有Spring DI挑战</li><li id="d019" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">Kibana查询语言vs SQL来操作文本数据——此处不再赘述</li><li id="8f19" class="mq mr iq kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated">针对自制SQL作业的Kibana索引保留策略—此处不再赘述</li></ul><p id="389d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果对数据一致性和数据丢失容忍度的要求不严格，这是一个很好的解决方案(万一服务中断，日志没有被发送到集中服务，一些实体事件可能会在“日志收集器间隔”时间窗口内丢失)。</p><p id="f3d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将应用程序日志与审计日志完全分开，我们可以配置我们单独的日志回溯配置，然后直接写入另一个日志目的地，只需正确初始化日志记录器:<code class="fe nq nr ns nt b">Logger log = LoggerFactory.getLogger("audit-logs")</code></p><p id="d077" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果需要更强的一致性保证，我们可以实现自己的数据存储库，将Elasticsearch作为数据源。</p><p id="25d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要包含<code class="fe nq nr ns nt b">spring-boot-starter-data-elasticsearch</code>，Spring starter将完成所需的大部分功能。一些额外的附加步骤在这里很好的解释了<a class="ae kc" href="https://www.baeldung.com/spring-data-elasticsearch-tutorial" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe nq nr ns nt b">ElasticsearchRepository</code>来继承获得所有需要的API来管理Elasticsearch中的数据。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3596" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，每个事件都可以单独处理，并通过使用专门的数据存储库和预先配置的方案(搜索索引将自动创建)添加到Elasticsearch中。稍后，可以通过创建相应的索引模式在Kibana中检查这些数据。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/0cab4230404d4c83a7fa4e49a40988f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79NFuHqil88tH_sB9n5rZg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">审计索引</figcaption></figure><p id="bac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者将数据从Elasticsearch加载到客户端，作为对添加的新域实体的完全支持(仅使用专用存储)</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/1c90d88bd3428e07ffe6485dbb1bd519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6fHR7e2atCdsPdQC-jo2g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">审计</figcaption></figure><p id="8727" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这个解决方案仍然使用来自父执行器的事务上下文，所以会影响性能，因为需要完成两个操作。跳过这个上下文—这个流程可以通过实现发布/订阅模式进行一点扩展。更改不会立即持久化，而是作为ApplicationContext事件发布，然后由特定的使用者持久化它。因此，我们不仅可以跳过事务边界，还可以使用另一个线程进行更改处理。但是像往常一样，依赖于强烈的一致性要求。</p><h2 id="10ef" class="me lc iq bd ld mf mg dn lh mh mi dp ll ko mj mk lp ks ml mm lt kw mn mo lx mp bi translated">疾病控制中心和事件流</h2><p id="edc4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">CDC(变更数据捕获)可以被认为是将实际数据管理环境与历史事件管理分离的解决方案。CDC建立在RDS发布/订阅本地支持之上，允许监听确切的表更改，并将这些更改作为事件流正确传输到另一个存储以供进一步处理。</p><p id="3ee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得对跟踪历史数据的支持对于被观察系统来说是完全透明的，在业务和数据层面上没有变化。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/d33b1dc87a313dd021858bbd29f32aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BXfqswE5Ni679D08cpBsw.png"/></div></div></figure><p id="a79f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正确配置后，sinkDB将从sourceDB收集所有变更事件，以供进一步分析。这使我们可以根据我们需要的数据聚合工作的类型，自由选择分析存储的类型。</p><p id="c5c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从我的角度来看，当需要关注点分离时，这个解决方案是最可靠的:数据管理和分析(报告)。这种方法不会因为复杂的分析处理而影响数据管理性能，因为数据和历史存储在不同的区域。</p></div></div>    
</body>
</html>