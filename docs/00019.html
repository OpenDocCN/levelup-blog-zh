<html>
<head>
<title>SVG React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SVG反应组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/svg-react-components-82cc08c67920?source=collection_archive---------0-----------------------#2017-10-05">https://levelup.gitconnected.com/svg-react-components-82cc08c67920?source=collection_archive---------0-----------------------#2017-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9e88d0d716901b781f8df887b35ad818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MXKjOowRetuCWCM9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ferenc Almasi </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d120" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了准备我将要从事的项目，我决定看一看SVG库。我偶然听到一个叫Dmitry Baranovskiy的坏脾气家伙的演讲，叫做<a class="ae kc" href="https://youtu.be/SeLOt_BRAqc" rel="noopener ugc nofollow" target="_blank">你不知道SVG </a>。除了了解到他真的不喜欢潮人，我还发现他是Raphael的创造者，Raphael是用于SVG的最流行的javascript库。几年前，他创建了一个名为<a class="ae kc" href="http://snapsvg.io/about/" rel="noopener ugc nofollow" target="_blank"> Snap </a>的新图书馆，以<code class="fe lb lc ld le b">snapsvg-cjs</code>的名字托管在NPM。这是我用来在react中创建项目的包。</p><h1 id="dc8a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">入门指南</h1><p id="3a58" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果你想继续编码，首先确保你已经配置了<a class="ae kc" href="https://www.codecademy.com/articles/react-setup-i" rel="noopener ugc nofollow" target="_blank">react</a>。我正在使用一个叫做<code class="fe lb lc ld le b">create-react-app</code>的<a class="ae kc" href="https://github.com/facebookincubator/create-react-app" rel="noopener ugc nofollow" target="_blank">快捷方式</a>，它将更快地构建我的项目。在终端中运行<code class="fe lb lc ld le b">create-react-app</code>,后跟你的项目名称。<code class="fe lb lc ld le b">cd</code>进入文件夹然后运行<code class="fe lb lc ld le b">npm install snapsvg-cjs</code>。现在运行<code class="fe lb lc ld le b">npm start</code>开始在浏览器中运行react应用程序。希望此时你能看到react的标志。</p><p id="9595" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将使用Snap.svg库制作一个自定义滑块。下面是一个代码笔概述了预期的结果。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="649e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Snap提供的主要功能有:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="47f6" class="ms lg iq le b gy mt mu l mv mw">Snap(...) <br/>//Identifies or creates a new svg element to work with as a snap object</span><span id="ea58" class="ms lg iq le b gy mx mu l mv mw">Paper.circle( x, y, r )<br/>//Creates a circle object which can be appended to the snap object<br/>//The x and y coordinates are relative to the parent element.</span><span id="ef78" class="ms lg iq le b gy mx mu l mv mw">Paper.line( x1, y1, x2, y2 )<br/>//Create a line from the first to second (x,y) coordinates relative to the parent container</span><span id="e54a" class="ms lg iq le b gy mx mu l mv mw">Element.attr(...) <br/>//Sets attributes for any elements within the snap object. This function takes in an argument of an object with key value pairs corresponding to the different attributes you can apply to any given element.</span><span id="829d" class="ms lg iq le b gy mx mu l mv mw">Element.limitDrag() is a custom function which is probably not the nicest implementation of this code, but it works.</span><span id="4ddf" class="ms lg iq le b gy mx mu l mv mw">Element.drag(onmove, onstart, onend, [mcontext], [scontext], [econtext]) <br/>//This is called inside of the Element.limitDrag() function in the code pen above. It takes three callback functions that are required.</span></pre><p id="9fb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于如何为Element.drag()编写回调函数的更详细的例子，请看这个演示。对于这个特定的滑块，我必须向Snap中的Element.prototype添加另一个函数来停止滑块。幸运的是，我能够在快照文档中找到一些限制拖拽的代码。</p><h1 id="e7bc" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建组件</h1><p id="e8ab" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在名为<code class="fe lb lc ld le b">src</code>的文件夹中，我创建了另一个名为<code class="fe lb lc ld le b">animations</code>的文件夹。在这里，我将把我所有的单个SVG组件从。</p><p id="0a0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的动画文件夹中，我创建了一个名为<code class="fe lb lc ld le b">Slider.js</code>的新文件，在这里我将创建我的组件。首先我导入React和Snap:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="eb34" class="ms lg iq le b gy mt mu l mv mw">import React from 'react';<br/>import Snap from 'snapsvg-cjs';</span></pre><p id="a8da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我为这个滑块创建一个智能组件。起初，我试图为这个滑块创建一个哑组件，因为我不需要对它的状态做任何事情，但我稍后将回到为什么我选择使用智能组件。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="9bb2" class="ms lg iq le b gy mt mu l mv mw">import React from 'react';<br/>import Snap from 'snapsvg-cjs';</span><span id="1844" class="ms lg iq le b gy mx mu l mv mw">class Slider extends React.Component{</span><span id="e137" class="ms lg iq le b gy mx mu l mv mw">  let s = Snap('#svg')</span><span id="76f6" class="ms lg iq le b gy mx mu l mv mw">  render () {<br/>    return(<br/>      &lt;svg id='svg'/&gt;<br/>    )<br/>}<br/>export default Slider</span></pre><p id="d5b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，Snap()函数的工作方式是通过id找到一个SVG元素或者创建一个新的元素。一旦找到元素，它就创建一个snap对象，可以引用该对象来更改SVG元素。最初我试着只返回' s ',但是React总是给我一个错误，说组件不能返回一个对象。相反，我决定返回一个SVG。我遇到的下一个问题是，当我试图将元素应用于' s '时，React一直告诉我' s '未定义。结果是我的Snap相关代码在React组件呈现之前就已经运行了。</p><p id="a902" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我在React的生命周期方法<code class="fe lb lc ld le b">componentDidMount()</code>中包装了所有的Snap元素。这将阻止在此方法中运行代码，直到组件呈现出来并可以使用。现在，在Snap试图找到所述SVG之前，页面上有一个具有正确id的SVG。</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="014b" class="ms lg iq le b gy mt mu l mv mw">import React from 'react';<br/>import Snap from 'snapsvg-cjs';</span><span id="cbf0" class="ms lg iq le b gy mx mu l mv mw">//insert Element.prototype.limitDrag function here</span><span id="b9bb" class="ms lg iq le b gy mx mu l mv mw">class Slider extends React.Component{</span><span id="a625" class="ms lg iq le b gy mx mu l mv mw">  componentDidMount() {<br/>    var s = Snap("#svg" + this.props.keyId.toString())</span><span id="c0da" class="ms lg iq le b gy mx mu l mv mw">    s.line(30, 30, this.props.width-30, 30).attr({stroke: '#000'})</span><span id="2eca" class="ms lg iq le b gy mx mu l mv mw">    var myCircle2 = s.circle(30,30,20)</span><span id="e2ec" class="ms lg iq le b gy mx mu l mv mw">    myCircle.attr({ stroke: '#123456', 'strokeWidth': 3,<br/>       fill: this.props.fill, 'opacity': 0.2 })</span><span id="11c5" class="ms lg iq le b gy mx mu l mv mw">    myCircle2.limitDrag({ x: 0, y: 0, minx: 0, miny: 0,<br/>       maxx: this.props.width-20, maxy: 0 })<br/>   }</span><span id="eaf7" class="ms lg iq le b gy mx mu l mv mw">render () {<br/>     const idKey = "svg" + this.props.keyId.toString()<br/>    return (<br/>      &lt;svg style={this.props.style} <br/>            width={this.props.width} height="60" id={idKey}/&gt;<br/>    )<br/>  }<br/>}</span><span id="6f64" class="ms lg iq le b gy mx mu l mv mw">export default Slider</span></pre><p id="e9ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个组件，我在文件的顶部导入了Snap库，以便该类可以使用它。我认为这个决定是有意义的，因为这个库的使用是特定于这个组件的。为了保持这个组件的灵活性，我添加了一些可以在调用时传递给它的道具。让我们看看应用程序容器:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="6c73" class="ms lg iq le b gy mt mu l mv mw">import React, { Component } from 'react';<br/>import Slider from './animations/Slider'</span><span id="9133" class="ms lg iq le b gy mx mu l mv mw">class App extends Component {</span><span id="460f" class="ms lg iq le b gy mx mu l mv mw">render() {<br/>    return (<br/>        &lt;div&gt;<br/>          &lt;Slider keyId={1} width={400} fill={'green'}/&gt;<br/>          &lt;Slider keyId={2} width={400} fill={'red'}/&gt;<br/>          &lt;Slider keyId={3} width={400} fill={'yellow'}/&gt;<br/>        &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="da40" class="ms lg iq le b gy mx mu l mv mw">export default App;</span></pre><p id="deeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会注意到在顶部，我从我的动画文件夹中导入滑块。当slider组件被调用时，我传递给它三个对每个Slider来说是唯一的道具。您还会注意到，每个滑块都有一个唯一的keyId属性。这用于唯一地标识由组件呈现的SCG，以便Snap()知道在哪里放置每个元素。</p><h1 id="6230" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">滑的开心！</h1><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="my mn l"/></div></figure></div></div>    
</body>
</html>