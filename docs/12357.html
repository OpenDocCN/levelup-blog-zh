<html>
<head>
<title>Bean injection using custom annotation (BeanPostProcessor)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用定制注释的Bean注入(BeanPostProcessor)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bean-injection-using-custom-annotation-beanpostprocessor-d8e886576484?source=collection_archive---------3-----------------------#2022-06-04">https://levelup.gitconnected.com/bean-injection-using-custom-annotation-beanpostprocessor-d8e886576484?source=collection_archive---------3-----------------------#2022-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3637" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注释用于向程序要使用的类/字段/方法提供一条附加信息。自定义注释现在对我们的开发人员来说已经不是什么新鲜事了，你会发现很多关于它的文章。说到这里，在这篇文章中，我试图分享我们如何通过使用自定义注释来为您的接口注入特定的实现。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f057f26e1d2bacc01d5b4d000604ba5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OoLaOisAI6qeC2y3.jpg"/></div></div></figure><h1 id="00eb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是BeanPostProcessor？</h1><p id="5682" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">它是一个接口，我们可以在实例化bean时实现它来放置一些自定义逻辑。它利用了bean创建生命周期，并为我们提供了围绕它定制任何逻辑的灵活性。</p><p id="f26b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它有两个方法可以在任何bean创建生命周期中调用:</p><ol class=""><li id="4905" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><strong class="jp ir">postProcessAfterInitialization()</strong></code>它在bean创建后被调用。</li><li id="5d9f" class="ma mb iq jp b jq mn ju mo jy mp kc mq kg mr kk mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><strong class="jp ir">postProcessBeforeInitialization()</strong></code>它在bean创建之前被调用。因此，如果您需要为给定的接口注入特定的bean。这里是您的自定义逻辑。</li></ol><p id="8fe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为字段创建自定义注释需要几个步骤。让我们逐一了解。</p><h2 id="c78f" class="ms ky iq bd kz mt mu dn ld mv mw dp lh jy mx my ll kc mz na lp kg nb nc lt nd bi translated">[步骤1]创建一个文件来定义您的自定义注释。</h2><pre class="km kn ko kp gt ne mm nf ng aw nh bi"><span id="03d5" class="ms ky iq mm b gy ni nj l nk nl">@Documented<br/>@Target({ElementType.TYPE,ElementType.FIELD})<br/>@Retention(RetentionPolicy.RUNTIME)<br/>public @interface CustomMock {<br/>}</span></pre><h2 id="5dbf" class="ms ky iq bd kz mt mu dn ld mv mw dp lh jy mx my ll kc mz na lp kg nb nc lt nd bi translated">[步骤2]创建一个类(必须是spring bean)来覆盖bean创建生命周期。</h2><p id="a98b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">它使用一个字段回调类来放置一个使用反射的自定义逻辑。</p><pre class="km kn ko kp gt ne mm nf ng aw nh bi"><span id="33f0" class="ms ky iq mm b gy ni nj l nk nl">@Component<br/>public class CustomMockBeanPostProcessor implements BeanPostProcessor {<br/>    @Autowired<br/>    private ConfigurableListableBeanFactory configurableBeanFactory;<br/><br/>    @Override<br/>    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<br/>        return bean;<br/>    }<br/><br/>    @Override<br/>    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<br/>        if (bean.getClass().isAnnotationPresent(RunWith.class)) {<br/>            ReflectionUtils.doWithFields(bean.getClass(), new CustomMockFieldCallBack(configurableBeanFactory, bean));<br/>        }<br/>        return bean;<br/>    }<br/>}</span></pre><p id="e8f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的实现需要理解一些非常重要的东西。我们没有向<code class="fe mj mk ml mm b">afterInitialization()</code>添加任何定制逻辑，因为一旦bean被创建或返回，我们不打算修改任何东西。然而，<code class="fe mj mk ml mm b">beforeInitialization()</code>有定制的逻辑，因为每当一个字段用<code class="fe mj mk ml mm b">@CustomMock</code>注释时，我们必须返回我们自己的假bean。</p><blockquote class="nm nn no"><p id="4496" class="jn jo np jp b jq jr js jt ju jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj kk ij bi translated">我们的应用程序中的每个bean都会调用这个实现。因此，在将定制逻辑应用于任何bean之前，我们不可避免地要进行适当的验证/约束。</p></blockquote><p id="4e19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们有一个只对用<code class="fe mj mk ml mm b">@RunWith</code>注释标注的类的字段有效的验证。对于其他类，所有的beans都将使用默认的流来创建。</p><h2 id="4fff" class="ms ky iq bd kz mt mu dn ld mv mw dp lh jy mx my ll kc mz na lp kg nb nc lt nd bi translated">[步骤3]为实际定制逻辑所在的定制模拟字段回调创建一个类。</h2><pre class="km kn ko kp gt ne mm nf ng aw nh bi"><span id="6e9d" class="ms ky iq mm b gy ni nj l nk nl">public class CustomMockFieldCallBack implements ReflectionUtils.FieldCallback {<br/><br/>  private ConfigurableListableBeanFactory configurableBeanFactory;<br/>  private Object bean;<br/><br/>  public CustomWiredFieldCallBack(ConfigurableListableBeanFactory configurableBeanFactory, Object bean) {<br/>      this.configurableBeanFactory = configurableBeanFactory;<br/>      this.bean = bean;<br/>  }<br/><br/>  @Override<br/>  public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {<br/>      if (field.isAnnotationPresent(CustomMock.class)) {<br/>          Class&lt;?&gt; interface = field.getType();<br/>          ReflectionUtils.makeAccessible(field);<br/>          Object mockImplementation = getBeanInstance(InterfaceMockBeanMapper.getMockBeanName(interface), interface);<br/>          field.set(bean, mockImplementation);<br/>      }<br/><br/>  }<br/><br/>  public Object getBeanInstance(String beanName, Class interface) {<br/>      Object mockImplementation = null;<br/>      if (!configurableBeanFactory.containsBean(beanName)) {<br/>          Object newInstance = null;<br/>          try {<br/>              Constructor&lt;?&gt; ctr = interface.getConstructor();<br/>              newInstance = ctr.newInstance();<br/>          } catch (Exception e) {<br/>              throw new RuntimeException(e);<br/>          }<br/><br/>          mockImplementation = configurableBeanFactory.initializeBean(newInstance, beanName);<br/>          configurableBeanFactory.autowireBeanProperties(mockImplementation, AutowireCapableBeanFactory.AUTOWIRE_BY_NAME, true);<br/>          configurableBeanFactory.registerSingleton(beanName, mockImplementation);<br/>      } else {<br/>          mockImplementation = configurableBeanFactory.getBean(beanName);<br/>      }<br/>      return mockImplementation;<br/>  }<br/>}</span></pre><ol class=""><li id="9913" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">上面的类利用Java反射来访问类的私有字段，并将目标bean分配给它。</li><li id="78dc" class="ma mb iq jp b jq mn ju mo jy mp kc mq kg mr kk mf mg mh mi bi translated">它还对字段进行了验证，即字段必须使用<code class="fe mj mk ml mm b">@CustomMock</code>注释才能工作。</li><li id="64a2" class="ma mb iq jp b jq mn ju mo jy mp kc mq kg mr kk mf mg mh mi bi translated"><strong class="jp ir"> InterfaceMockBeanMapper </strong>用于获取给定接口的模拟bean名称。基于bean名称，如果给定的bean不存在，将从<code class="fe mj mk ml mm b">getBeanInstance()</code>返回一个bean，然后创建并返回一个具有给定名称的新bean。</li></ol><h2 id="14c3" class="ms ky iq bd kz mt mu dn ld mv mw dp lh jy mx my ll kc mz na lp kg nb nc lt nd bi translated">如何在我们的代码中使用<code class="fe mj mk ml mm b">@CustomMock</code>？</h2><pre class="km kn ko kp gt ne mm nf ng aw nh bi"><span id="d89a" class="ms ky iq mm b gy ni nj l nk nl">@RunWith(SpringRunner.class)</span><span id="067d" class="ms ky iq mm b gy nt nj l nk nl">public FeatureTestClass {</span><span id="a0fb" class="ms ky iq mm b gy nt nj l nk nl">   @CustomMock</span><span id="5a10" class="ms ky iq mm b gy nt nj l nk nl">   private Interface1 bean1;</span><span id="7a94" class="ms ky iq mm b gy nt nj l nk nl">   @CustomMock</span><span id="368f" class="ms ky iq mm b gy nt nj l nk nl">   private Interface2 bean2;</span><span id="1c2f" class="ms ky iq mm b gy nt nj l nk nl">   @Test</span><span id="e954" class="ms ky iq mm b gy nt nj l nk nl">   public void testFeatureClassMethod() {</span><span id="cc96" class="ms ky iq mm b gy nt nj l nk nl">        FeatureClass featureClass = new FeatureClass(bean1, bean2);</span><span id="b888" class="ms ky iq mm b gy nt nj l nk nl">        featureClass.method();</span><span id="171d" class="ms ky iq mm b gy nt nj l nk nl">        ...</span><span id="3a89" class="ms ky iq mm b gy nt nj l nk nl">        //assert</span><span id="7d5f" class="ms ky iq mm b gy nt nj l nk nl">   }</span><span id="b8d7" class="ms ky iq mm b gy nt nj l nk nl">}</span></pre><p id="1bbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！！</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="43c3" class="kx ky iq bd kz la ob lc ld le oc lg lh li od lk ll lm oe lo lp lq of ls lt lu bi translated">分级编码</h1><p id="b362" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="7f72" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk og mg mh mi bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="d838" class="ma mb iq jp b jq mn ju mo jy mp kc mq kg mr kk og mg mh mi bi translated">📰查看<a class="ae oh" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">关卡升级编码</a>中的更多内容</li><li id="51ad" class="ma mb iq jp b jq mn ju mo jy mp kc mq kg mr kk og mg mh mi bi translated">🔔关注我们:<a class="ae oh" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank"> Twitter </a> | <a class="ae oh" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></li><li id="bca5" class="ma mb iq jp b jq mn ju mo jy mp kc mq kg mr kk og mg mh mi bi translated">🚀👉<a class="ae oh" href="https://jobs.levelup.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">软件工程师的顶级工作</strong> </a></li></ul></div></div>    
</body>
</html>