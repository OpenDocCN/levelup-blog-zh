<html>
<head>
<title>Flutter Hook widgets over Stateful widgets for better app performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为了更好的应用性能，在有状态窗口小部件上摆动钩子窗口小部件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-hook-widgets-over-stateful-widgets-for-better-app-performance-938861d5ea94?source=collection_archive---------2-----------------------#2022-07-06">https://levelup.gitconnected.com/flutter-hook-widgets-over-stateful-widgets-for-better-app-performance-938861d5ea94?source=collection_archive---------2-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/2950cdbe287cfb489179da5c1611cf31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*n-mt2T04ywygGUcxQINwfg.png"/></div></figure><p id="da3a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Flutter中的一切都是由小部件组成的。在本文中，我们将探索不同类型的窗口小部件<em class="ks">(无状态和有状态)</em>，还将研究<em class="ks">钩子窗口小部件</em>，它是无状态窗口小部件的扩展。我们还将探究其中的差异，看看如何在有状态窗口小部件上使用钩子窗口小部件来提高应用程序的性能。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="48f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="ks">什么是颤振中的widget？</em> </strong></p><blockquote class="la lb lc"><p id="0c4b" class="ju jv ks jw b jx jy jz ka kb kc kd ke ld kg kh ki le kk kl km lf ko kp kq kr ij bi translated">Flutter widgets是使用现代框架构建的，其灵感来自于<a class="ae lg" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>。中心思想是用小部件构建用户界面。小部件描述了在给定当前配置和状态的情况下，它们的视图应该是什么样子。</p></blockquote><p id="14e3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果UI上的任何操作需要重新构建小部件，那么这就是您应该使用有状态小部件的地方。但是如果小部件只显示数据，UI上的任何动作都不需要重新构建小部件，那么可以使用无状态小部件。</p><p id="a229" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> <em class="ks">无状态窗口小部件</em> </strong>是易于使用的窗口小部件，在添加逻辑方面你真的不能对它们做太多，因为顾名思义，它们是无状态的。一旦构建了UI，UI中的任何操作都不能触发小部件的重新构建。</p><p id="3b12" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是当我们谈论<strong class="jw ir"> <em class="ks">有状态小部件</em> </strong>时，有很多事情在幕后发生，UI中的任何变化都会触发小部件的重建。</p><p id="97ef" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们考虑计数器应用程序的例子，</p><h2 id="819b" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">1.使用有状态小部件的计数器应用程序</h2><p id="a3a4" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">在这个应用程序中，我可以通过点击“-”和“+”按钮来更改计数器值。每次点击都会改变UI并重新构建小部件来更新计数器的值。我将存储计数器的值，并在UI中的两个地方显示它</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/44be9f32fe107841c52ae6b7f97407dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*0gIvGEegUfnmB0JArgH6WQ.gif"/></div></figure><p id="6f04" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面屏幕的代码是</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="82bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，我在更新计数器值的任何地方都大量使用了setState。这是因为我通知小部件更新变量的值，并用更新后的值重新构建小部件。</p><p id="2523" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我不包含setState，那么计数器值将得到更新，但UI不会被重新构建，结果是UI根本不会改变，您将只能在UI中看到旧的计数器值。</p><p id="0ef3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然这是一种管理状态的简单技术，但在构建复杂的小部件时，有状态小部件可能不是最佳选择。这是因为持续重建小部件会降低应用程序的性能，并导致应用程序在重建期间消耗大量资源。</p><p id="83e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这时你应该考虑使用钩子小部件，它是无状态小部件的扩展。</p><h2 id="72a6" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">2.使用挂钩小工具的计数器应用程序</h2><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/bfc804270a5d31859a219db7dfe663e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*MBKItGu9YcaYl0BQw9twPg.jpeg"/></div></figure><blockquote class="la lb lc"><p id="4c70" class="ju jv ks jw b jx jy jz ka kb kc kd ke ld kg kh ki le kk kl km lf ko kp kq kr ij bi translated">钩子是一种管理<code class="fe mn mo mp mq b">Widget</code>生命周期的新型对象。它们的存在只有一个原因:通过删除重复项来增加小部件之间的代码共享<em class="iq">。</em></p></blockquote><p id="aa1f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当使用钩子时，我们只使用一个类，这使得维护代码变得容易。<a class="ae lg" href="https://pub.dev/packages/flutter_hooks" rel="noopener ugc nofollow" target="_blank"> flutter_hooks </a>为我们提供了可重用钩子的列表，其中包括:</p><ul class=""><li id="89e8" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated"><a class="ae lg" href="https://pub.dartlang.org/documentation/flutter_hooks/latest/flutter_hooks/useEffect.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">使用效果</strong> </a> <strong class="jw ir"> — </strong> <em class="ks">对副作用有用，可选择取消副作用。</em></li><li id="02e9" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated"><a class="ae lg" href="https://pub.dartlang.org/documentation/flutter_hooks/latest/flutter_hooks/useState.html" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">useState</strong></a><strong class="jw ir">—</strong><em class="ks">创建一个变量并订阅它。</em></li><li id="6916" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated"><a class="ae lg" href="https://pub.dartlang.org/documentation/flutter_hooks/latest/flutter_hooks/useMemoized.html" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir"/></a><strong class="jw ir">—</strong><em class="ks">缓存复杂对象的实例。</em></li><li id="b628" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated"><a class="ae lg" href="https://pub.dartlang.org/documentation/flutter_hooks/latest/flutter_hooks/useAnimationController.html" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">use animation controller</strong></a><strong class="jw ir">—</strong><em class="ks">创建一个</em> <code class="fe mn mo mp mq b"><em class="ks">AnimationController</em></code> <em class="ks">，它将被自动处理。</em></li><li id="c1a2" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated"><a class="ae lg" href="https://pub.dev/documentation/flutter_hooks/latest/flutter_hooks/useTextEditingController-constant.html" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">useTextEditingController</strong></a><strong class="jw ir">—</strong><em class="ks">创建一个</em> <code class="fe mn mo mp mq b"><em class="ks">TextEditingController</em></code> <em class="ks">。</em></li><li id="2f9f" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated"><a class="ae lg" href="https://pub.dartlang.org/documentation/flutter_hooks/latest/flutter_hooks/useTabController.html" rel="noopener ugc nofollow" target="_blank"><strong class="jw ir">usetab controller</strong></a><strong class="jw ir">—</strong><em class="ks">创建并处置一个</em> <code class="fe mn mo mp mq b"><em class="ks">TabController</em></code> <em class="ks">。</em></li></ul><p id="0b00" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于同一个反例，当我们使用钩子时，应用程序以同样的方式运行。然而，主要的区别是我们将对计数器变量使用<code class="fe mn mo mp mq b">useState</code> <em class="ks"> </em>钩子，以确保UI中的任何变化都会被通知。</p><pre class="mg mh mi mj gt nf mq ng nh aw ni bi"><span id="d05e" class="lh li iq mq b gy nj nk l nl nm">final count = useState(0);</span></pre><ul class=""><li id="dfe6" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated"><strong class="jw ir"> count </strong>变量是<strong class="jw ir"> ValueNotifier </strong>的实例。</li><li id="bbd3" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated"><strong class="jw ir">使用状态</strong> —挂钩</li><li id="bd85" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">0——<code class="fe mn mo mp mq b">initialData</code></li></ul><p id="341d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">要访问变量count的值，使用<code class="fe mn mo mp mq b">count.value</code></p><blockquote class="la lb lc"><p id="1e33" class="ju jv ks jw b jx jy jz ka kb kc kd ke ld kg kh ki le kk kl km lf ko kp kq kr ij bi translated">每当<strong class="jw ir"> ValueNotifier.value </strong>更新时，它会将调用者HookWidget标记为需要构建。在第一次调用时，它将<a class="ae lg" href="https://api.flutter.dev/flutter/foundation/ValueNotifier-class.html" rel="noopener ugc nofollow" target="_blank">值通知器</a>初始化为<code class="fe mn mo mp mq b">initialData</code>。<code class="fe mn mo mp mq b">initialData</code>在后续通话中被忽略。</p></blockquote><p id="da5d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当钩子小工具第一次呈现时，ValueNotifier被设置为<code class="fe mn mo mp mq b">initialData</code>，随着值的变化，后续调用将使用更新后的值。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/0366eb0dacb5be817a0b0e6853b736c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*tqS7qLnqTIyMgC2ejAPaEw.gif"/></div></figure><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="38ac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的小部件中，计数值最初被设置为0，它来自于在初始化钩子时设置的<code class="fe mn mo mp mq b">initialData</code>。随着计数器不断更新，value notifier . value<strong class="jw ir">(count)</strong>发生变化，小部件重新构建。</p><blockquote class="la lb lc"><p id="334d" class="ju jv ks jw b jx jy jz ka kb kc kd ke ld kg kh ki le kk kl km lf ko kp kq kr ij bi translated">在重建期间，性能的影响可以忽略不计，因为钩子允许您消除对initState、dispose和setState的需要，因为与状态相关的所有内容都是用build方法中的钩子函数初始化的。</p></blockquote><h2 id="53fc" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">useEffect()</h2><p id="09c4" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">为了在小部件的initState期间加载数据，或者处理数据，我们使用useEffect()钩子。</p><p id="fe49" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就像initState和dispose一样，<strong class="jw ir"> <em class="ks"> useEffect() </em> </strong>将被</p><ul class=""><li id="9a34" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">在小部件的生命周期中只调用一次，</li><li id="37e7" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">return语句将在小部件被释放时执行，</li><li id="8187" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">const []意味着在小部件没有被释放之前，不要调用效果。可以有一个参数列表，当其中一个参数改变时，useEffect会再次调用回调。</li></ul><p id="e1b9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是带挂钩的计时器小部件的代码:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c16f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是带有状态小部件的计时器的代码:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="f0e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">钩子是维护简单逻辑的一种简单方法，我在大多数项目中都使用过它。它避免了复杂的逻辑，促进了更好的应用程序性能。如果你想了解更多关于钩子的知识，Flutter docs在https://pub.dev/packages/flutter_hooks提供了大量的资源</p><p id="a065" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你觉得有帮助的话，欢迎留下评论和分享！</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="37d9" class="nn li iq bd lj no np nq lm nr ns nt lp nu nv nw ls nx ny nz lv oa ob oc ly od bi translated">分级编码</h1><p id="2212" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="9b6a" class="mr ms iq jw b jx jy kb kc kf mt kj mu kn mv kr mw mx my mz bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="daf9" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">📰查看<a class="ae lg" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="9d57" class="mr ms iq jw b jx na kb nb kf nc kj nd kn ne kr mw mx my mz bi translated">🔔关注我们:<a class="ae lg" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae lg" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lg" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="ea52" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">🚀👉<a class="ae lg" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>