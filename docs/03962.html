<html>
<head>
<title>How to Write a Simple Data Processing Application With Akka Actors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Akka Actors编写一个简单的数据处理应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-a-simple-data-processing-application-with-akka-actors-7373371096ea?source=collection_archive---------14-----------------------#2020-06-03">https://levelup.gitconnected.com/how-to-write-a-simple-data-processing-application-with-akka-actors-7373371096ea?source=collection_archive---------14-----------------------#2020-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2e90edf4a5d007513c62d9f424c2db60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iBTLD82Va6JCSKL6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【https://edward-huang.com】最初发表于<a class="ae kd" href="https://edward-huang.com/akka/scala/programming/functional-programming/reactive/2020/05/30/how-to-write-a-simple-data-processing-application-with-akka-actors/" rel="noopener ugc nofollow" target="_blank"><em class="kc"/></a><em class="kc">。</em></figcaption></figure><p id="f660" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当我们谈到数据处理或进行大数据ETL时，首先想到的是使用Hadoop(或Spark)。今天，我将展示使用Actor系统创建数据处理的另一种方式。我将使用经典的Akka演员。</p><p id="bacc" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">注:本文就不说一个演员系统了，介绍一下Akka中的一个演员系统。不过我会再写一篇文章解释一下Akka演员的介绍，或者你也可以看一下Akka这边的<a class="ae kd" href="https://doc.akka.io/docs/akka/current/actors.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="50a7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么要用演员制？</h1><p id="7bea" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">需求苛刻的现代分布式系统遇到了传统面向对象编程(OOP)模型无法解决的挑战。</p><p id="43d5" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">OOP在创建分布式系统中的一个后备例子包括封装的挑战。如果你用Java写一个常规的线程模型，封装不会在你的应用程序中封装多个线程。封装仅在单线程模型中有效。为了封装的线程安全，您需要做<code class="fe mf mg mh mi b">synchronized</code>。其他回落可以在Akka <a class="ae kd" href="https://doc.akka.io/docs/akka/current/typed/guide/actors-motivation.html" rel="noopener ugc nofollow" target="_blank">侧</a>看到。</p><h1 id="df35" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">目标</h1><p id="e40c" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">我将创建一个从log <code class="fe mf mg mh mi b">CSV</code>文件中获取数据的应用程序，并使用主从模式处理每条消息。</p><p id="a003" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">目标是聚合和统计日志文件中所有出现的Http状态代码，并将其写入<code class="fe mf mg mh mi b">out.txt</code>文件。</p><h1 id="b865" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">参与者层次结构</h1><p id="a53a" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">由于从源文件获取数据、分割工作和聚合数据涉及到多个组件，所以让我们来研究一下这个应用程序中不同参与者的角色。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/bd6d52fb0a7a587d5ad2064adc4243d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n9WBrQcQk0aLJ04z.png"/></div></div></figure><p id="bd4e" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">演员有四种:监督演员、摄取演员、师傅演员、工人演员。</p><p id="44cd" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">监督演员监督，产卵，并停止摄取演员。监督执行元将处理摄取执行元中的任何类型的事件失败。</p><p id="0953" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">摄取执行元从源读取日志文件，初始化主执行元。它将日志文件分成每一行，并将每一行发送给主参与者。最后，它将从主参与者接收聚合值，并将该值写入<code class="fe mf mg mh mi b">out.txt</code>文件。</p><p id="af80" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">主执行元在创建工作执行元和将任务委派给工作执行元时发挥作用。它还聚合结果并将它们发送回摄取参与者。</p><p id="b3ab" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">工人演员将在过程中制造所有的重物。</p><p id="00c6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们将读取的数据是一个日志文件，它将包含IP、时间、URL、状态:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="c5a4" class="ms ld iq mi b gy mt mu l mv mw">10.128.2.1,[29/Nov/2017:06:58:55,GET /login.php HTTP/1.1,200</span></pre><p id="2ed9" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">然而，数据并不总是按正确的顺序排列，我们需要做一个过滤器来处理数据。</p><p id="0a60" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在本文中，我将介绍主管角色和摄取角色的代码流程。主演员和工人演员将在第二部分。</p><p id="0a44" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们勇往直前去征服。</p><h1 id="d14f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">主要的</h1><p id="73ca" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">在浏览应用程序中的所有代码之前，这里是调用数据处理应用程序的主要函数:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="0ca4" class="ms ld iq mi b gy mt mu l mv mw">object Main extends App {<br/>  val system = ActorSystem("DataProcessingAkka")<br/>  val supervisorActor = system.actorOf(Supervisor.props(100), "supervisor")<br/><br/>  supervisorActor ! Supervisor.Start<br/><br/>}</span></pre><p id="4556" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">它创建了一个actor系统，并创建了一个具有100个工人参数的监督actor来处理数据。然后，它向主管演员发送<code class="fe mf mg mh mi b">Supervisor.start</code>消息。</p><h1 id="6426" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">主管演员</h1><p id="88b3" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">Akka提供了容错机制来处理参与者内部的错误，或者监视那些参与者，如果遇到任何失败，就执行某种行为。</p><p id="4b25" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当一个actor失败时，它会挂起其子actor，并向其父actor发送一条特殊消息。然后，父母可以启动或停止他们的孩子。</p><p id="4c3f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">然而，在本文中，我不会使用主管角色和Akka中存在的各种路由策略。</p><p id="9943" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这将是一个简单的主管演员，将开始和停止应用程序一旦完成。</p><p id="ec04" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们看看主管演员的代码:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="3f5f" class="ms ld iq mi b gy mt mu l mv mw">class Supervisor(nWorker: Int) extends Actor with ActorLogging {<br/>  override def receive: Receive = {<br/>    case Start =&gt;<br/>      val ingestion = context.actorOf(Props[Ingestion], "ingestion")<br/>      ingestion ! Ingestion.StartIngestion(nWorker)<br/>    case Stop =&gt;<br/>      log.info("[Supervisor] All things are done, stopping the system")<br/>      context.system.terminate()<br/>  }<br/>}</span></pre><p id="7fd2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">主管伙伴对象:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="523b" class="ms ld iq mi b gy mt mu l mv mw">object Supervisor {<br/>  case object Start<br/>  case object Stop<br/><br/>  <em class="mx">// good way pass create an actor</em><br/>  def props(parallelism: Int) = Props(new Supervisor(parallelism))<br/>}</span></pre><p id="301d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这里需要注意的一点是——创建演员的思维过程很像思考演员在收到消息时应该如何<em class="mx">反应</em>。</p><p id="0aa8" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果Supervisor Actor接收到一个<code class="fe mf mg mh mi b">Start</code>消息，它将做一些工作。如果Supervisor Actor收到一个Stop消息，它将关闭Actor系统来释放它所分配的线程。</p><h1 id="74fb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摄入因素</h1><p id="3b04" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">摄取角色将初始化主角色，获取主角色的所有文件，收集结果并将其写入<code class="fe mf mg mh mi b">out.txt</code>。</p><p id="916d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们来看看摄取执行元的代码:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="8423" class="ms ld iq mi b gy mt mu l mv mw">class Ingestion extends Actor with ActorLogging with IngestionHandler {<br/>  import Ingestion._<br/>  val inputStream = openInputStream<br/>  var masterNode: ActorRef = context.actorOf(Master.props(context.self), "masterNode")<br/>  override def receive: Receive = {<br/>    case StartIngestion(nWorker) =&gt;<br/>      log.info("[Ingestion] Initializing Worker ...")<br/>      masterNode ! Master.InitializeWorker(nWorker)<br/>    case Master.WorkerInitialized =&gt;<br/>      log.info("[Ingestion] worker is initialized. Getting lines from source and send to masterNode ...")<br/>      Source.fromInputStream(inputStream).getLines().toList.filter(isValidIp).foreach(masterNode ! Data(_))<br/>      inputStream.close()<br/>    case Aggregate(result) =&gt;<br/>      log.info(s"[Ingestion] total status Code: ${result.keys.map(k =&gt; s"$k -&gt; ${result(k).length}").toString()}")<br/>      val lines = result.keys.map { key =&gt;<br/>        s"Status : ${key} has a total of ${result(key).length} amount}"<br/>      }<br/><br/>      writeToOutputFile(lines)<br/>      context.parent ! Supervisor.Stop<br/>  }<br/><br/>}</span></pre><p id="07be" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">摄取伴随对象:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="a36a" class="ms ld iq mi b gy mt mu l mv mw">object Ingestion {<br/>  case class StartIngestion(nWorker: Int)<br/>  case class Data(logString: String)<br/>}</span></pre><p id="4141" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一旦主管执行元创建了摄取执行元，它将自动获取源值作为输入流，并创建一个主执行元。</p><p id="80e1" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当摄取执行元收到StartIngestion消息时，它会向主执行元发送一条消息，告诉主执行元初始化它的所有子执行元。</p><p id="e2ce" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一旦主执行元被初始化，接收将假定主执行元将发送一条确认消息，让接收开始将每个文本行发送给主执行元进行处理。摄取角色将从文件中获取每一行，过滤掉没有有效IP的行，并将有效的行发送给主角色。</p><p id="8191" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最后，<code class="fe mf mg mh mi b">Aggregate(result)</code>是主角色将结果发送回摄取角色的时候。摄取执行元将对结果做一些处理，并将结果写入输出文件。一旦将结果写入输出文件，它将向监督执行元发送一条消息来关闭应用程序。</p><p id="cee1" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当在Actors内部处理大量数据时，一个最佳实践是将逻辑分离到一个处理程序特征中。一旦将逻辑从处理程序特征中分离出来，就可以快速测试处理程序特征的特定功能。</p><p id="f1e2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们看一下摄取处理程序特征，它包含摄取执行元的所有数据处理功能:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="1f32" class="ms ld iq mi b gy mt mu l mv mw">trait IngestionHandler {<br/><br/>  def isValidIp(line: String): Boolean = {<br/>    val ipRegex: Regex = """.*?(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3}).*""".r<br/>    ipRegex.pattern.matcher(line.split(",")(0)).matches()<br/>  }<br/><br/>  def openInputStream: InputStream = getClass.getResourceAsStream("/weblog.csv")<br/><br/>  def writeToOutputFile(lines: Iterable[String]) = {<br/>    val path = getClass.getResource("/out.txt").getPath<br/>    File(path).createIfNotExists().clear().appendLines(lines.mkString(","))<br/>  }<br/>}</span></pre><p id="64ba" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">处理程序特征包括读取文件、写入文件和检查有效地址的功能。</p><h1 id="e1e1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">主工人演员的流程</h1><p id="9205" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">在我们进入主参与者和工人参与者之前，有两种不同的方法来设计系统的流程:</p><p id="e6b5" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">第一种方法——参与者向其工作人员发送执行消息。然后，主参与者将再次向其工作人员发送确认消息。汇总所有结果并发送回摄取执行元。</p><p id="e723" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">第二种方法是将状态保存在主actor中，因为无论如何主actor都需要聚集所有的resultMap。因此，一旦完成当前流程任务，Worker actor将把结果发送回Master actor，并从邮箱中获取下一个作业。</p><p id="e9c9" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">您不需要在Worker actor中保存任何状态，Master也不需要再次向Worker发送通知消息——询问结果。</p><p id="4a9f" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们将在本文中实现方法2。</p><h1 id="88e1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">主要演员</h1><p id="ec0c" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">主参与者是这个应用程序中最难的部分，因为它是一个编排角色。</p><p id="a58d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">概括地说，主参与者将初始化所有工作参与者，将任务委托给它的工作参与者，并聚合来自每个工作参与者的结果。</p><p id="bcb8" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为了便于说明，我们将使用简单的循环技术来分配任务。但是，如果你想变得花哨和高效，你可以使用支持各种路由逻辑的Akka路由。</p><p id="3d19" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们来看看《为主演员》的代码:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="e107" class="ms ld iq mi b gy mt mu l mv mw">class Master(parent: ActorRef) extends Actor with ActorLogging {<br/><br/>  override def receive: Receive = preInitialize<br/><br/>  def preInitialize: Receive = {<br/>    case InitializeWorker(nWorker) =&gt;<br/>      log.info(s"[Master] Initializing $nWorker worker(s)...")<br/>      val workers = (0 to nWorker).toVector.map(id =&gt; context.actorOf(Props[Worker], s"${id}-worker"))<br/>      sender() ! WorkerInitialized<br/>      context.become(<br/>        workerInitialized(<br/>          currentWorkerId = 0,<br/>          currentTaskId = 0,<br/>          workers = workers,<br/>          Set.empty[Int],<br/>          resultMap = Map.empty[String, List[Log]]<br/>        )<br/>      )<br/>  }<br/><br/>  def workerInitialized(<br/>    currentWorkerId: Int,<br/>    currentTaskId: Int,<br/>    workers: Vector[ActorRef],<br/>    taskIdSet: Set[Int],<br/>    resultMap: Map[String, List[Log]]<br/>  ): Receive = {<br/>    case Data(logString) =&gt;<br/>      log.info(s"[Master] received $logString assigning taskId $currentTaskId to worker $currentWorkerId")<br/>      val currentWorker = workers(currentWorkerId)<br/>      val newTaskIdSet = taskIdSet + currentTaskId<br/><br/>      currentWorker ! Execute(currentTaskId, logString, context.self)<br/><br/>      val newTaskId = currentTaskId + 1<br/>      val newWorkerId = (currentWorkerId + 1) % workers.length<br/><br/>      context.become(workerInitialized(newWorkerId, newTaskId, workers, newTaskIdSet, resultMap))<br/><br/>    case Worker.Result(id, result) =&gt;<br/>      log.info(s"[Master] Received result $result from taskId $id")<br/>      val newTaskIdSet = taskIdSet - id<br/><br/>      val newResultMap = result match {<br/>        case log @ Log(_, _, _, status) =&gt;<br/>          val logList = resultMap.getOrElse(status, List.empty[Log])<br/>          resultMap + (status -&gt; (log :: logList))<br/>      }<br/><br/>      if (newTaskIdSet.isEmpty) {<br/>        log.info(s"[Master] All task is done, sending result back to ${parent.path}")<br/>        parent ! Aggregate(newResultMap)<br/>      } else {<br/>        log.info(s"[Master] Task is not yet all done, waiting for other workers to send back results")<br/>        context.become(workerInitialized(currentWorkerId, currentTaskId, workers, newTaskIdSet, newResultMap))<br/>      }<br/>  }<br/>}</span></pre><p id="3ae5" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">主伴随对象:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="7033" class="ms ld iq mi b gy mt mu l mv mw">object Master {<br/>  case class InitializeWorker(nWorker: Int)<br/>  case object WorkerInitialized <em class="mx">// send back to the ingestion</em><br/>  case class Aggregate(numberOfStatus: Map[String, List[Log]]) <em class="mx">// get all the aggregated result from worker (status code -&gt; number)</em><br/><br/>  def props(parent: ActorRef): Props = Props(new Master(parent))<br/>}</span></pre><p id="8883" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">首先，主参与者收到一个<code class="fe mf mg mh mi b">InitializeWorker(nWorker)</code>,其中包含要初始化的工作线程数量。</p><p id="7d85" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一旦Worker被初始化，主actor将把<code class="fe mf mg mh mi b">WorkerInitialized</code>消息发送回摄取actor，并将其状态切换到<code class="fe mf mg mh mi b">workerInitialized</code>。</p><p id="15a6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在<code class="fe mf mg mh mi b">workerInitialized</code>状态下，主参与者从摄取参与者接收日志字符串<code class="fe mf mg mh mi b">Data(logString)</code>，并以循环逻辑将任务委托给其工作器。</p><p id="f661" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我给每个任务分配了一个<code class="fe mf mg mh mi b">taskId</code>，并在集合中跟踪这个<code class="fe mf mg mh mi b">taskId</code>。每次主机将作业发送给工人时，它都会将新的<code class="fe mf mg mh mi b">taskId</code>添加到<code class="fe mf mg mh mi b">taskId</code>集合中。每次当工作者完成运行<code class="fe mf mg mh mi b">taskId</code>并将结果发送回主演员时，主演员将从<code class="fe mf mg mh mi b">taskId</code>集合中移除<code class="fe mf mg mh mi b">taskId</code>。</p><p id="dffa" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">主演员何时知道将结果发送回摄取演员？</p><p id="d1f1" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当所有的<code class="fe mf mg mh mi b">taskId</code>设定为空时，所有的工人都加工完了所有的<code class="fe mf mg mh mi b">task</code>。主演员将结果发送回摄取。</p><p id="ec92" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果您愿意，可以重构actor中的每个预定义状态，并将其转换为有限状态机<a class="ae kd" href="https://doc.akka.io/docs/akka/current/fsm.html" rel="noopener ugc nofollow" target="_blank"> FSM </a>。</p><p id="c8f1" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">拥有不同的状态也有助于理解参与者在应用程序流程的每个状态下采取什么操作。</p><h1 id="6e4e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">工人演员</h1><p id="4e61" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">我们来看看工人演员:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="0e62" class="ms ld iq mi b gy mt mu l mv mw">class Worker extends Actor with WorkerHandler {<br/>  override def receive: Receive = {<br/>    case Execute(id, task, sender) =&gt;<br/>      sender ! Result(id, convertToLog(task))<br/>  }<br/>}</span></pre><p id="bda5" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们来看看Worker Companion对象:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="090f" class="ms ld iq mi b gy mt mu l mv mw">object Worker {<br/>  case class Log(ip: String, time: Date, url: String, status: String)<br/>  case class Date(year: Int, month: String, date: Int, time: String)<br/>  case class Execute(taskId: Int, task: String, replyTo: ActorRef) <em class="mx">// received Execute Task</em><br/>  case class Result(workerId: Int, result: Log) <em class="mx">// Send Result</em><br/>}</span></pre><p id="d2f3" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们来看看工作处理程序:</p><pre class="mk ml mm mn gt mo mi mp mq aw mr bi"><span id="5ed2" class="ms ld iq mi b gy mt mu l mv mw">trait WorkerHandler {<br/><br/>  def convertToLog(line: String): Log = line.split(",").toList match {<br/>    case ip :: time :: url :: status :: _ =&gt;<br/>      Log(ip, convertToDate(time), url, status)<br/>  }<br/><br/>  def convertToDate(time: String): Date = time.substring(1).split("/").toList match {<br/>    case date :: month :: yearAndTime :: _ =&gt;<br/>      yearAndTime.split(":").toList match {<br/>        case year :: rest =&gt; Date(year.toInt, month, date.toInt, rest.mkString(":"))<br/>      }<br/>  }<br/><br/>}</span></pre><p id="32a3" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一旦Worker收到了<code class="fe mf mg mh mi b">Execute(line)</code>消息，它会将字符串转换成一个<code class="fe mf mg mh mi b">Log</code> case类。然后，它会将结果发送回主演员。</p><h1 id="6864" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="e4b6" class="pw-post-body-paragraph ke kf iq kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">在本系列中，我介绍了一个带有Actor系统的简单数据处理应用程序。我还解释了为什么在创建分布式系统时使用Actor系统。</p><p id="0543" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最后，我解释了我设计角色层次的思维过程，并深入探讨了在应用程序中创建角色时反应性思维的思维过程。</p><p id="0f0c" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我希望您对如何实现和设计Actor系统有所了解。</p><p id="ba87" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">所有来源都是<a class="ae kd" href="https://github.com/edwardGunawan/Data-Processing/tree/master/dataprocessingakka/src/main/scala/com/notetoself" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="a4f8" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这篇文章的灵感来自亚历山大。是我在学Akka演员的时候看到的一个帖子。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="08e4" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="kg ir">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae kd" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="kg ir"/></a><strong class="kg ir">以获得关于科技职业的文章、有趣的链接和内容的通知！</strong></p><p id="0784" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">你可以关注我，也可以在<a class="ae kd" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p></div></div>    
</body>
</html>