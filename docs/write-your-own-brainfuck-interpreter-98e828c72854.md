# 写你自己的脑残解释器

> 原文：<https://levelup.gitconnected.com/write-your-own-brainfuck-interpreter-98e828c72854>

![](img/df1e2b3511ed285c3b79ced18d59a430.png)

Bret Kavanaugh 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

这个短语与[同义，它是你用一种你以前没用过的编程语言编写的第一个程序](http://helloworldcollection.de/)。但是如果这是你写的语言的第一个输出呢？

如果你从来没有停下来思考你最喜欢的语言的复杂语法最终是如何满足你的要求的，也许现在是时候了。这可能比你想象的要简单。几乎任何语言都有相同的工具包，并且可以在小得多的范围内为各种其他东西创建简单的语法。

让我们从把你搞糊涂开始，然后从那里往回查…

```
++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.> — -.+++++++..+++.>>.<-.<.+++. — — — . — — — — .>>+.>++.
```

# **脑残**

是的，[这是一种真正的语言](https://en.wikipedia.org/wiki/Brainfuck)，它从 1993 年就存在了。最初由 Urban Müller 创建，它并不意味着用于实际目的，人们认为他的初衷是为编程语言创建尽可能最小的编译器。很多编译器都写的小于 200 字节，至少有一个编译器小于 100 字节！

Brainfuck 的工作原理是修改和遍历内存中的字节。它可以使用任何数量的字节，足以满足你运行程序的需要。Is 仅由 8 个符号组成，每个符号都是一个字符:

*   `<`和`>`分别向左和向右移动当前字节的位置。
*   `+`和`-`增加和减少当前字节的值。
*   `.`将打印当前字节(作为字符)
*   `,`将允许输入一个字节到当前位置。我们不会在示例中实现这一点，但是修改源代码来实现这一点是非常容易的。
*   `[`和`]`用作循环。当前字节为 0 时，循环退出。循环可以嵌套，这使得稍后演示 AST 树非常完美。

# **即将发生的事情**

事实证明，这种看似有趣的语言其实还有另一种很酷的用法；演示如何创建一个端到端的语言解释器。即使对于最复杂的语言来说，它们也可以分为 4 个阶段，我将在本文中一一介绍。

1.  **lexer** 将源代码分割成一串不可分割的片段，称为*令牌*。
2.  令牌通过一个**解析器**运行，该解析器概述了令牌的预期顺序规则，并生成一个 *AST* 。
3.  AST 是现在可以被遍历的源代码的物理(通常是层次化的)表示。
4.  遍历由**编译器**完成以生成最终产品，或者由**解释器**立即运行，就像这种情况。

无论您使用哪种宿主语言(这是您编写解析器生成器的语言)，这 4 个步骤都将保持不变，甚至大部分复杂性也将保持不变。我将使用 Python，因为它非常容易阅读和理解。

语言解析器有不同的算法，每种算法都有各自的优点、缺点和性能问题。在这篇文章中，我不会深入探讨这个问题的细节。我将使用 [PLY](http://www.dabeaz.com/ply/) ，它是一个 [LR 解析器](https://en.wikipedia.org/wiki/LR_parser)。就本文的目的而言，您不需要知道更多。

# **1。莱克斯**

这是最容易的阶段，也是最不可能随时间改变的阶段。简而言之，lexer 使用正则表达式将源代码分成*个标记*。以下是一些标记及其各自的正则表达式:

```
KEYWORD_VAR = "var"
INTEGER = "\-?[0-9]+"
IDENTIFIER = "[a-zA-Z0-9]+"
OP_PLUS = "\+"
OP_COLON = ";"
OP_ASSIGN = "="
```

使用上述标记解析以下 JavaScript:

```
var a = 3 + 2;
```

会生成令牌:

`KEYWORD_VAR``IDENTIFIER``OP_ASSIGN``INTEGER``OP_PLUS``INTEGER`

我们不仅需要令牌类型，还需要原始令牌的值。因此 INTEGERtoken 还必须包含匹配的字符。比如 3。您将使用的解析器生成器将会为您处理这个问题。

以下是我们所有令牌的定义:

```
tokens = (
    'INCREMENT',
    'DECREMENT',
    'SHIFT_LEFT',
    'SHIFT_RIGHT',
    'OUTPUT',
    'INPUT',
    'OPEN_LOOP',
    'CLOSE_LOOP',
)t_INCREMENT   = r'\+'
t_DECREMENT   = r'-'
t_SHIFT_LEFT  = r'<'
t_SHIFT_RIGHT = r'>'
t_OUTPUT      = r'\.'
t_INPUT       = r','
t_OPEN_LOOP   = r'\['
t_CLOSE_LOOP  = r'\]'
```

这是一个纯粹意义上的词法分析器，如果你选择在词法分析时翻译标记或它们的值，规则会变得更复杂，但这通常是为了处理正则表达式可能相互冲突或你需要翻译内部标记类型的边缘情况。

具有附加逻辑的令牌的一个例子是换行符。这允许您在发生错误时报告行号。PLY 定义了一个函数，其中第一行表示正则表达式，随后是任何自定义代码，这样就可以很容易地将令牌与任意代码连接起来:

```
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)
```

lexer 会期望每个字符都完美地符合一个连续的正则表达式字符串。如果没有出现这种情况，将会抛出一个错误，包括空格。在每个标记中加入空格是很痛苦的，所以我们可以使用 t _ ignoreto 来指定任何将被忽略的字符。

```
t_ignore = ‘ \t’
```

Brainfuck 真的应该忽略任何不是上面指定的 8 个字符之一的字符，但为了演示，我将忽略空格。注意不要忽略换行符，因为 t_newlinetoken 需要使用它。

最后，如果所有这些都失败了，我们需要一个错误处理器:

```
def t_error(t):
    print("Illegal character '%s'" % t.value[0])
    t.lexer.skip(1)
```

# **2。解析器**

解析器是我们定义语言实际语法的地方。我们使用 lexer 中指定的标记以下列形式概述每个规则的顺序:

```
rule_name : token1 token2 ...
```

例如，要在 JavaScript 中定义变量，您可以使用:

```
define_variable : KEYWORD_VAR IDENTIFIER COLON
```

注意，标记是大写的，但是解析器规则是小写的。一些解析器再生器强制这样做(如 PLY ),而一些解析器再生器不这样做。但不管怎样，这是个好主意，因为在更复杂的语言中，当你混合记号和其他规则时，阅读起来会更清晰。

你也可以说 JavaScript 中的变量可以用默认值定义(让我们暂时假设 JavaScript 只有整数):

```
define_variable : KEYWORD_VAR IDENTIFIER OP_ASSIGN INTEGER COLON
```

我们实际上对同一规则的不同版本进行了分类，因此可以通过使用`|`操作符来表示 and 或，从而将其折叠在一起:

```
define_variable : KEYWORD_VAR IDENTIFIER COLON
                | KEYWORD_VAR IDENTIFIER OP_ASSIGN INTEGER COLON
```

大多数解析器都非常简单，所以你不能把|当作逻辑操作符。它只是允许单独的线性记号序列匹配相同的解析器规则。

所有解析器规则都是在解析器开始运行之前定义的。就像自定义标记如何表示为函数一样，解析器规则也是如此。一旦规则匹配，它将调用该规则的函数。第一个参数包含匹配规则的令牌数组。如果您使用`|`来知道哪个规则实际匹配，这一点尤其重要。

一个`command`将代表一个动作，它不仅仅是一个单字符命令，也是一个循环。因此`+[<>]-`将是三个命令，因为整个`[<>]`将被循环规则接收:

在处理层次语法时，保持状态(实际上是返回)极其重要。我们使用索引为 0 的标记作为返回值，而不是直接从函数返回。例如，对于以下规则:

```
define_variable : KEYWORD_VAR IDENTIFIER COLON
```

`token[0]`为空，`token[1]`为`KEYWORD_VAR`，`token[2]`为`IDENTIFIER`，以此类推。令牌总数包括第 0 个令牌，因此即使规则由 3 个令牌组成，但`len(p)`是 4。

循环规则看起来像:

`commands`规则(不要与`command`规则混淆)匹配一个或多个命令。因为所有的规则都是线性的记号序列，所以它们不能重复。这是表示一次或多次命令列表的一种方式。最初它是令人困惑的，用一个例子来解释是最容易的。假设我们有以下令牌:

`+` `+` `>` `-`

减少了:

1.  `commands``command`->(`+``+``>`) `-`
2.  (`commands``command`)`command`->(`+``+`)`>`)`-`
3.  ((`command``command`)`command`)`command`->((`+`)`+`)`>`)`-`

这种类型的解析对于操作符优先级特别有用……这超出了本文的范围。

这似乎与直觉相反，但解析器实际上是自下而上工作的(首先是大多数嵌套元素，这意味着它从上面的第三条规则开始)，所以我们使用`len(p) == 2`来检查匹配的规则是否是命令(因为 len(p)将比令牌的实际数量大 1)，并创建基本实例命令并添加第一条命令。进一步的规则将能够把命令附加到原始的 Commandsinstance，并继续通过`p[0]`传递该实例，以供下一层拾取。

就像 lexer 一样，如果解析器遇到一系列与任何规则都不匹配的标记，它会有一个默认的错误处理程序。由您决定解析器是应该尝试恢复还是简单地用一条消息中止:

```
def p_error(p):
    print("Syntax error in input!")
```

# **3。AST**

抽象语法树是源代码(程序)结构的代码表示。也就是说，如果你在 JavaScript 中有如下表达式:

```
2 * 3 + 4 * 5
```

使用正确的运算符优先级将生成嵌套实例的组合，如下所示:

```
new Add(new Multiply(2, 3), new Mutliply(4, 5))
```

对于 Brainfuck，我们只需要 3 个类来表示应用程序的结构:

1.  `Commands`保存一个`Command`的数组。
2.  `Command`是单个角色动作，或者是`Loop`实例。
3.  一个`Loop`保存一个对包含在循环中的动作的`Commands`的引用。

因为`Loop`包含了对`Commands`的引用，所以生成的 AST 可以根据每个嵌套循环的需要进行深度嵌套。

您可能会注意到，AST 类非常类似于它们的解析器规则。这很常见，尽管单个解析器规则可以输出或改变任何类型的对象。

每个 AST 类都包含一个`__str__`方法，这意味着您可以将整个程序还原为一个连续的字符串。如果空格和其他字符被忽略，它们将不会出现在输出中。

# **4。编译器或解释器**

解释器现在可以任意遍历 AST 实例，当然这取决于您的应用程序逻辑。在进行到这个阶段之前，尝试并充分利用解析器是一个好主意，比如涵盖错误条件、边缘情况和特殊语法。

在更复杂的解析器中，AST 类只是表示源代码，而不包含其他逻辑。在这个例子中，我使用了相同的类来实际运行它们自己，因为所有的命令只是改变了应用程序的内存字节。

最后一个类通过 lexer 和解析器运行源代码，创建模拟 RAM(全部 20 个字节)，将起始位置设置为 0(第一个字节)，并最终调用 AST 实例本身上的动作链，从而将所有内容组合在一起:

现在我们可以调用运行程序:

使用本要点中的[完整程序，您现在可以运行它了！](https://gist.github.com/elliotchance/820a20821a1b5ee09ae6)

```
$ python brainfuck.py
Hello World!
```

*原载于 2016 年 1 月 24 日*[*http://Elliot . land*](http://elliot.land/post/write-your-own-brainfuck-interpreter)*。*