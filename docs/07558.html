<html>
<head>
<title>Proxy Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代理设计模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/proxy-design-pattern-f040a6561bfb?source=collection_archive---------27-----------------------#2021-02-23">https://levelup.gitconnected.com/proxy-design-pattern-f040a6561bfb?source=collection_archive---------27-----------------------#2021-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a742" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将讨论<code class="fe kl km kn ko b">Proxy</code>设计模式和一个如何使用它的简单例子，在这个例子中，在iOS应用程序中以一种有效和干净的方式来防止保留周期。</p><h1 id="fe18" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是代理设计模式？</h1><p id="3bfd" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">在Gamma、Johnson、Vlissides、Helm和合作者的著作<a class="ae ls" href="https://www.goodreads.com/book/show/85009.Design_Patterns" rel="noopener ugc nofollow" target="_blank"> Design Patterns </a>中，代理设计模式被定义为:</p><blockquote class="lt lu lv"><p id="2f7d" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated"><em class="iq">为另一个对象提供代理或占位符，以控制对它的访问。它让消费者相信他们在和真正的实现对话。</em></p></blockquote><p id="2246" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它的图表是这样的:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/9e39056b393818c8072d1bab34514e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qr39dnBxQBTBdNyH6rhtWw.png"/></div></div></figure><p id="e900" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lw">图来自</em> <a class="ae ls" href="https://en.wikipedia.org/wiki/Proxy_pattern#/media/File:Proxy_pattern_diagram.svg" rel="noopener ugc nofollow" target="_blank"> <em class="lw">维基百科</em> </a></p><p id="e7ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这是你第一次听说这种设计模式，可能会有点困惑，它们的比例可能一点也不清楚。但是让我给你一个例子来解释在哪里可以使用这种设计模式。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="d7ad" class="kp kq iq bd kr ks mt ku kv kw mu ky kz la mv lc ld le mw lg lh li mx lk ll lm bi translated">在MVP UI设计模式中使用代理</h1><p id="e171" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">当我们在iOS应用中使用像MVP这样的UI设计模式时，我们注意到如果我们不削弱视图控制器T21，就会产生一个保留循环，因为在T1和T2之间有一个双向的通信通道。让我们看看图表:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi my"><img src="../Images/cee46e021c3a1fcf98c0034c4496e6cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*Z8C412sOqAg9TM79oddfmg.png"/></div></figure><p id="fb7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如:</p><pre class="mb mc md me gt mz ko na nb aw nc bi"><span id="8b09" class="nd kq iq ko b gy ne nf l ng nh"><em class="lw">// MARK: - UI </em><br/><br/>class ViewController: UIViewController, View {<br/>    var presenter: Presenter?<br/><br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        view.backgroundColor = .systemBackground<br/>        presenter?.didRequestMessage()<br/>    }<br/><br/>    func display(_ viewModel: ViewModel) {<br/>        print(viewModel.message)<br/>    }<br/>}<br/><br/><em class="lw">// MARK: - Presenter</em><br/><br/>struct ViewModel {<br/>    let message: String<br/>}<br/><br/>protocol View {<br/>    func display(_ viewModel: ViewModel)<br/>}<br/><br/>class Presenter {<br/>    private let fetcher: FetchMessage<br/>    private let view: View<br/><br/>    init(fetcher: FetchMessage, view: View) {<br/>        self.fetcher = fetcher<br/>        self.view = view<br/>    }<br/><br/>    func didRequestMessage() {<br/>        fetcher.get { [weak self] message in<br/>            self?.view.display(ViewModel(message: message))<br/>        }<br/>    }<br/>}<br/><br/><em class="lw">// MARK: - Business logic</em><br/><br/>class FetchMessage {<br/>    func get(completion: @escaping (String) -&gt; Void) {<br/>        completion("Hello, World!")<br/>    }<br/>}</span></pre><p id="ca8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所见，由于双向通信，我们需要小心<code class="fe kl km kn ko b">Presenter</code>和<code class="fe kl km kn ko b">Controller</code>之间的连接。解决问题的一个方法是使<code class="fe kl km kn ko b">weak</code>成为演示者和控制器之间的参考。</p><pre class="mb mc md me gt mz ko na nb aw nc bi"><span id="7ce0" class="nd kq iq ko b gy ne nf l ng nh">private weak var view: View?</span></pre><p id="72ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这样做会产生以下编译器错误:</p><blockquote class="lt lu lv"><p id="2eed" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated"><em class="iq">“弱”不能应用于非类绑定的“视图”；考虑添加一个具有类绑定的协议一致性</em></p></blockquote><p id="37da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以很容易地解决这个编译错误，就是使协议只针对类(使用<code class="fe kl km kn ko b">class</code>关键字使协议只针对类)。该约束定义为<code class="fe kl km kn ko b">The protocol to which all classes implicitly conform.</code>，如下所示:</p><pre class="mb mc md me gt mz ko na nb aw nc bi"><span id="205d" class="nd kq iq ko b gy ne nf l ng nh">protocol View: class {<br/>    func display(_ viewModel: ViewModel)<br/>}</span></pre><p id="1212" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这解决了我们的问题，但是这样做我们暴露了presenter中的内存管理。理想情况下，我们需要在复合根中处理它。直到现在，我们的作文根看起来是这样的:</p><pre class="mb mc md me gt mz ko na nb aw nc bi"><span id="4f14" class="nd kq iq ko b gy ne nf l ng nh">class SceneDelegate: UIResponder, UIWindowSceneDelegate {<br/>    var window: UIWindow?<br/><br/>    func scene(_ scene: UIScene, willConnectTo _: UISceneSession, options _: UIScene.ConnectionOptions) {<br/>        guard let scene = (scene as? UIWindowScene) else { return }<br/>        window = UIWindow(windowScene: scene)<br/>        window?.rootViewController = Composer.composeWith(fetcher: FetchMessage())<br/>        window?.makeKeyAndVisible()<br/>    }<br/>}<br/><br/>class Composer {<br/>    static func composeWith(fetcher: FetchMessage) -&gt; ViewController {<br/>        let controller = ViewController()<br/>        let presenter = Presenter(fetcher: fetcher, view: controller)<br/>        controller.presenter = presenter<br/>        return controller<br/>    }<br/>}</span></pre><p id="c715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了将内存管理从<code class="fe kl km kn ko b">Presenter</code>转移到<code class="fe kl km kn ko b">CompositionRoot</code>，我们可以创建一个代理，在这里我们可以<em class="lw">让消费者相信他们正在与真正的实现</em>对话。那么，代理实现看起来怎么样呢？</p><pre class="mb mc md me gt mz ko na nb aw nc bi"><span id="80e8" class="nd kq iq ko b gy ne nf l ng nh">class WeakRefProxy: View {<br/>    weak var view: (View &amp; AnyObject)?<br/><br/>    init(_ view: View &amp; AnyObject) {<br/>        self.view = view<br/>    }<br/><br/>    func display(_ viewModel: ViewModel) {<br/>        view?.display(viewModel)<br/>    }<br/>}</span></pre><p id="30f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还删除了<code class="fe kl km kn ko b">View</code>协议中的class only约束，并再次让我们的<code class="fe kl km kn ko b">view: View</code>变量let:</p><pre class="mb mc md me gt mz ko na nb aw nc bi"><span id="6ee9" class="nd kq iq ko b gy ne nf l ng nh">protocol View { <em class="lw">// Remove class constraint</em><br/>    func display(_ viewModel: ViewModel)<br/>}<br/><br/>class Presenter {<br/>    private let fetcher: FetchMessage<br/>    private let view: View <em class="lw">// Restore to a let</em><br/><br/>    init(fetcher: FetchMessage, view: View) {<br/>        self.fetcher = fetcher<br/>        self.view = view<br/>    }<br/><br/>    func didRequestMessage() {<br/>        fetcher.get { [weak self] message in<br/>            self?.view.display(ViewModel(message: message))<br/>        }<br/>    }<br/>}</span></pre><p id="b831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="lw">代理设计模式</em>中，我们有一个主题接口，在这种情况下是我们的<code class="fe kl km kn ko b">View</code>协议。我们还需要一个<code class="fe kl km kn ko b">RealSubject</code>和<code class="fe kl km kn ko b">Proxy</code>，在这种情况下，我们的<em class="lw">真实主体</em>是<code class="fe kl km kn ko b">ViewController</code>类，我们的<em class="lw">代理</em>当然是<code class="fe kl km kn ko b">WeakRefProxy</code>类。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/caab8631e0aaa719ab06e37616cbbf03.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/0*qP_CPioxoakjPWXi.png"/></div></figure><p id="d015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kl km kn ko b">WeakRefProxy</code>中，我们用一个<code class="fe kl km kn ko b">weak</code>引用来替代真实的实现，这就是我们想要避免的保留周期。而现在我们的<code class="fe kl km kn ko b">Composition Root</code>长这样:</p><pre class="mb mc md me gt mz ko na nb aw nc bi"><span id="1ac9" class="nd kq iq ko b gy ne nf l ng nh">class SceneDelegate: UIResponder, UIWindowSceneDelegate {<br/>    var window: UIWindow?<br/><br/>    func scene(_ scene: UIScene, willConnectTo _: UISceneSession, options _: UIScene.ConnectionOptions) {<br/>        guard let scene = (scene as? UIWindowScene) else { return }<br/>        window = UIWindow(windowScene: scene)<br/>        window?.rootViewController = Composer.composeWith(fetcher: FetchMessage())<br/>        window?.makeKeyAndVisible()<br/>    }<br/>}<br/><br/>class Composer {<br/>    static func composeWith(fetcher: FetchMessage) -&gt; ViewController {<br/>        let controller = ViewController()<br/>        let presenter = Presenter(fetcher: fetcher, view: WeakRefProxy(controller))<br/>        controller.presenter = presenter<br/>        return controller<br/>    }<br/>}</span></pre><p id="6519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将内存管理从<code class="fe kl km kn ko b">Presenter</code>移到了<code class="fe kl km kn ko b">CompositionRoot</code>，这样做，我们就不需要覆盖将所有视图协议约束为MVP中的类的需求，也不会泄漏presenter实现中的组合细节。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="6087" class="kp kq iq bd kr ks mt ku kv kw mu ky kz la mv lc ld le mw lg lh li mx lk ll lm bi translated">让generic成为我们的WeakRef代理</h1><p id="2a5f" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">当然，创建一个<code class="fe kl km kn ko b">WeakRefProxy</code>可能会非常繁琐，所以我们可以创建一个泛型并将<code class="fe kl km kn ko b">View</code>方法实现到一个扩展中，就像这样:</p><pre class="mb mc md me gt mz ko na nb aw nc bi"><span id="78d2" class="nd kq iq ko b gy ne nf l ng nh">class WeakRefProxy&lt;T: AnyObject&gt; {<br/>    weak var object: T?<br/><br/>    init(_ object: T) {<br/>        self.object = object<br/>    }<br/>}</span><span id="b0e7" class="nd kq iq ko b gy nj nf l ng nh">extension WeakRefProxy: View where T: View {<br/>    func display(_ viewModel: ViewModel) {<br/>        object?.display(viewModel)<br/>    }<br/>}</span></pre><p id="99e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在github上找到示例源代码:<a class="ae ls" href="https://github.com/alfredohdzdev/WeakRef" rel="noopener ugc nofollow" target="_blank">https://github.com/alfredohdzdev/WeakRef</a></p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="b01b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">还有一件事</strong> : <br/>这项技术被应用和学习是因为<a class="ae ls" href="https://essentialdeveloper.com" rel="noopener ugc nofollow" target="_blank">essentialdeveloper.com</a>的伟大工作。让我们来看看他们伟大而有价值的内容。</p></div></div>    
</body>
</html>