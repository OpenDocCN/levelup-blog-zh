<html>
<head>
<title>Don’t bind methods in Angular!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要在Angular中绑定方法！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-dont-use-functions-in-templates-f33d67db18da?source=collection_archive---------1-----------------------#2022-05-28">https://levelup.gitconnected.com/angular-dont-use-functions-in-templates-f33d67db18da?source=collection_archive---------1-----------------------#2022-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="88f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇简短的博文中，我将向您展示Angular的一个核心概念，每个Angular开发人员都应该牢记这一概念，以便生成良好的高性能代码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/070f7a1e019a8c108ccc5509f8b10471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*esjfquIGQGNw3Y5-"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">罗斯·芬登在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="db3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您刚开始使用Angular，并且还不太熟悉变化检测等概念，您的代码可能看起来有点像这样:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="2f64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你已经发现这段代码的问题了吗？它是模板中的函数。尽管它们没有任何副作用并且非常简单，但是它们仍然是不好的，仅仅因为它们被用在了模板中。其原因被称为<strong class="js iu">变化检测</strong>。</p><h2 id="0e3e" class="lh li it bd lj lk ll dn lm ln lo dp lp kb lq lr ls kf lt lu lv kj lw lx ly lz bi translated">变化检测</h2><blockquote class="ma mb mc"><p id="936a" class="jq jr md js b jt ju jv jw jx jy jz ka me kc kd ke mf kg kh ki mg kk kl km kn im bi translated">角度变化检测是一个内置的框架特性，它可以确保组件数据与其HTML模板视图之间的自动同步。</p></blockquote><p id="3755" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，换句话说，变化检测是一种机制，它决定组件的模板是否必须重新呈现，因为某些东西发生了变化。这可能是鼠标事件、HTTP请求或应用程序中任何其他类型的状态变化。因此，变化检测是一件神圣的事情，它允许我们绑定数据，并在组件中发生变化时自动更新模板中的数据。</p><p id="129a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是要注意一个陷阱:<strong class="js iu">函数</strong>。</p><p id="ee7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，Angular中的函数不是纯函数，因此每当触发变化检测时，变化检测必须检查函数输出是否发生了变化。这意味着，如果您更改了根组件中的一个值，实际上并不会影响子组件——并且在该子组件中有一个函数绑定——更改检测仍然会检查该函数。如果你经常绑定到一个函数或者只是做了很多修改，那显然会导致性能的大幅下降。</p><h2 id="43d4" class="lh li it bd lj lk ll dn lm ln lo dp lp kb lq lr ls kf lt lu lv kj lw lx ly lz bi translated">重构</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="db41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从重构<em class="md"> getSomeText() </em>函数开始。当然，我们可以直接绑定到变量<em class="md"> someText </em>上，但是我们必须以某种方式追加额外的文本。这是一个使用<strong class="js iu">纯管道</strong>的好场景。这个管道将转换<em class="md"> someText </em>，但是只有当<em class="md"> someText </em>实际上被改变时，因为Angular知道这个管道只依赖于它的输入，因此如果输入相同，它将总是产生相同的输出(这基本上就是纯函数的意思)。注意，在管道装饰器中指定<em class="md"> pure: true </em>参数很重要。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="eb41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个重构:<em class="md"> getCurrentTime() </em>。这太简单了。只需移除函数，直接绑定到变量即可。</p><p id="2539" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但我所做的有点不同，因为我想得更远。我为<em class="md"> currentTime </em>创建了一个<em class="md"> getter/setter </em>，并在setter中调用了<em class="md"> getClass() </em>函数，该函数仅在currentTime被设置时确定div的类。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="f974" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，您也可以实现<em class="md"> ngOnChanges() </em>函数，但我是setter函数的拥护者，因为我相信它们更干净，因为您不会最终编写一个真正大的<em class="md"> ngOnChanges() </em>函数。</p><h2 id="09b3" class="lh li it bd lj lk ll dn lm ln lo dp lp kb lq lr ls kf lt lu lv kj lw lx ly lz bi translated">结论</h2><p id="482a" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">只是不要在你的模板中使用函数——没有一个用例是好的。如果可能的话，只使用变量，如果你有一个更复杂的场景，我相信你可以使用RxJs和管道来实现。您可以在我的GitHub上找到完整的样本:</p><p id="c282" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://github.com/HaasStefan/Angular_Refactoring_Change_Detection" rel="noopener ugc nofollow" target="_blank">https://github . com/HaasStefan/Angular _ Refactoring _ Change _ Detection</a></p></div></div>    
</body>
</html>