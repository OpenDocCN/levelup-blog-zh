<html>
<head>
<title>How to build a service in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Golang中构建服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-service-in-golang-9af2b7ed92a7?source=collection_archive---------0-----------------------#2022-05-01">https://levelup.gitconnected.com/how-to-build-a-service-in-golang-9af2b7ed92a7?source=collection_archive---------0-----------------------#2022-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/843548e42abf725393b79ba689dcce25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4jjaoGNtmOGDAgdNih-pw.jpeg"/></div></div></figure><p id="abd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们开始研究Go时，我们发现了许多如何构建新的web服务器或完成特定任务的例子，然而，找到一种可以启动所有过程、保持并优雅地完成所有事情的服务结构可能是一种挑战。本文的目的是构建一个服务的基本结构。<a class="ae kw" href="https://github.com/gbeletti/service-golang" rel="noopener ugc nofollow" target="_blank">完整代码可从github </a>获得。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="b225" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是服务？</h1><p id="976f" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">在计算系统中，服务是执行特定任务以响应事件或请求的程序，例如:</p><ul class=""><li id="7cac" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated">HTTP请求</li><li id="fb49" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">来自消息代理的消息或流</li><li id="544b" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">时间事件(每小时、每5分钟等)</li></ul><p id="7dfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务被设计成永远运行，就像所有好的东西最终都会消亡一样，它必须准备好在时机到来时稳健而明智地停止。</p><blockquote class="mv mw mx"><p id="5d1f" class="jy jz my ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">在服务停止之前，必须完成所有任务，关闭所有连接，并且没有运行任何goroutines。</p></blockquote></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e34c" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构建web服务器</h1><p id="9c45" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">例如，让我们创建一个响应HTTP请求的服务。首先，我们创建一个包含启动和关闭web服务器功能的包。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="8f17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe ni nj nk nl b">Start()</code>函数创建了一个goroutine来接收和处理外部请求。这个包负责创建和完成这个goroutine。</p><p id="3bdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时,<code class="fe ni nj nk nl b">Shutdown()</code>函数异步且优雅地完成服务器，允许服务在等待所有请求完成时停止其他进程。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="01ba" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">启动服务</h1><p id="4dc6" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">现在我们可以回到最初的文件，例如<code class="fe ni nj nk nl b">main.go</code>，我们从创建一个<code class="fe ni nj nk nl b">start()</code>函数开始。在这里，我们必须启动服务正常工作所需的一切，比如打开数据库连接、监听来自消息代理的流事件、构建缓存等。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c49a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，这里创建了一个带有cancel的上下文。目的是在这个函数中启动的所有进程共享相同的上下文，所以当函数<code class="fe ni nj nk nl b">cancel()</code>被调用时，每个人都会得到通知，可以停止他们正在做的事情。此外，任何函数都不应该阻塞线程，每个内部进程都应该对自己的线程负责，就像上面的web服务器一样。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e541" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">等待不可避免的事情</h1><p id="caab" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">既然服务已经启动，我们不能让主线程死亡。我们可以创建一个频道，等待一个永远不会到来的消息。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="aa3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上述代码将无限期运行，直到操作系统终止该进程。这种突然死亡对系统来说是危险的，可能会导致几个问题，比如在数据库上生成不一致的数据，或者保持与消息代理的连接打开。这就产生了一个不稳定的系统，很难找到错误。</p><p id="e382" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须为系统关闭做好准备，优雅而稳健地停止所有处理。所以让我们创建一个包<code class="fe ni nj nk nl b">servicemanager</code>并创建一个函数<code class="fe ni nj nk nl b">WaitShutdown</code>。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5ac9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ni nj nk nl b">signal.Notify</code>功能会将操作系统的所有结束信号发送到<code class="fe ni nj nk nl b">sigc</code>通道。现在我们可以等待<code class="fe ni nj nk nl b">s := &lt;-sigc</code>的信号来阻塞主线程。</p><p id="5bbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe ni nj nk nl b">main.go</code>现在启动一切，等待操作系统说该关机了。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e839" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正在关闭服务</h1><p id="b74e" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">既然我们知道服务何时会终止，我们可以创建一个<code class="fe ni nj nk nl b">shutdown()</code>函数来停止所有的内部进程。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ef83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用命令<code class="fe ni nj nk nl b">&lt;-doneHTTP</code>，主线程将在终止服务之前等待所有请求完成。这里的问题是，操作系统不会永远等待，过一会儿就会终止一个进程，突然停止一切。因此，最好等待一段时间，如果超时就强制关机。</p><p id="df4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个概念在服务中很常见，所以我们可以在我们的<code class="fe ni nj nk nl b">servicemanager</code>包中创建一个新函数。</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="24a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe ni nj nk nl b">shutdown()</code>现在已经完成:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c862" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ni nj nk nl b">cancel()</code>允许共享上下文的内部进程完成它们的杂务，警告它们服务正在关闭。同时，创建一个新的超时上下文来等待进程停止或时间用完。</p><p id="4226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe ni nj nk nl b">main()</code>功能非常简单和简短:</p><figure class="nc nd ne nf gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="ff0d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="11e5" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">创建一个新的服务可能看起来很简单，但是理解它可能非常复杂，需要对并发性和并行性有很好的了解。这个例子的完整代码可以在<a class="ae kw" href="https://github.com/gbeletti/service-golang" rel="noopener ugc nofollow" target="_blank"> github </a>找到。</p><p id="90c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这篇教程有用。如果您有建议或疑问，请在下面的部分留下评论。</p></div></div>    
</body>
</html>