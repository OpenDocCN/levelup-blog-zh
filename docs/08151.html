<html>
<head>
<title>That code deployed serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">该代码无服务器部署</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/that-code-deployed-serverless-8c1a455c5b98?source=collection_archive---------12-----------------------#2021-04-05">https://levelup.gitconnected.com/that-code-deployed-serverless-8c1a455c5b98?source=collection_archive---------12-----------------------#2021-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/eb76df606a157daa26a562059f587f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uDJRlZnSln9eBxiz"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">保罗·花冈在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><div class=""><h2 id="da7e" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">Nimbella如何向Flutter应用程序发送升级</h2></div><p id="dc5b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每一个移动应用程序在某一点上都需要升级，必须向用户交付<strong class="kx jh">错误修复</strong>和<strong class="kx jh">新功能</strong>。我最近意识到，使用无服务器升级现有应用程序是多么简单。</p><p id="0564" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.redhat.com/en/topics/cloud-native-apps/what-is-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="kx jh">无服务器</strong> </a>是一种<a class="ae jd" href="https://www.redhat.com/en/topics/cloud-native-apps" rel="noopener ugc nofollow" target="_blank">云原生</a>开发模式，允许开发人员构建和运行应用程序，而无需管理服务器。</p><p id="3035" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦部署完毕，无服务器应用就会响应，并且<a class="ae jd" href="https://www.redhat.com/en/topics/automation" rel="noopener ugc nofollow" target="_blank">会根据需要自动</a> <strong class="kx jh">放大</strong>和<strong class="kx jh">缩小</strong>。最后，当无服务器功能闲置时，它不会产生任何成本。</p><p id="b60b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将讨论一个无服务器<strong class="kx jh">函数</strong>的例子，它可以应答用Flutter编写的移动应用程序的呼叫。</p><h2 id="6f04" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">摆动</h2><p id="11ad" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我认为<strong class="kx jh"> Flutter </strong>是开发移动应用程序的框架(顺便说一下，它是最近一次大升级的主角<a class="ae jd" href="https://medium.com/flutter/whats-new-in-flutter-2-0-fe8e95ecc65" rel="noopener">，它也可以用于桌面应用程序)。</a></p><p id="4453" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论如何，下一节中的<strong class="kx jh">无服务器考虑</strong>是不可知的，它们可以<a class="ae jd" href="https://filippovalle.medium.com/i-upgraded-my-app-to-universal-binary-cd969719c33e" rel="noopener">很容易地应用到其他<strong class="kx jh">框架</strong> </a>。</p><div class="ip iq gp gr ir mp"><a href="https://flutter.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jh gy z fp mu fr fs mv fu fw jf bi translated">颤振-美丽的原生应用程序在创纪录的时间</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">借助状态热重新加载，在数毫秒内将您的应用描绘得栩栩如生。使用一组丰富的完全可定制的小部件来构建…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">颤振. dev</p></div></div><div class="my l"><div class="mz l na nb nc my nd ix mp"/></div></div></a></div><h2 id="08f8" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">宁贝拉</h2><p id="1b89" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了与移动应用程序进行交互，需要一个服务器来提供有关当前版本和文件的信息，以执行升级。这可以通过多种方式实现，使用无服务器功能的一个好处是，它们只在真正需要的时候才在线。它们可以轻松扩展，而且通常比标准服务器便宜。</p><div class="ip iq gp gr ir mp"><a href="https://nimbella.com" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd jh gy z fp mu fr fs mv fu fw jf bi translated">宁贝拉</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">copy他们平台的前瞻性云不可知论性质给我留下了深刻的印象，尤其是因为它可以…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">nimbella.com</p></div></div><div class="my l"><div class="ne l na nb nc my nd ix mp"/></div></div></a></div><p id="fede" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">部署无服务器功能有许多方法，其中之一是<strong class="kx jh"> Nimbella </strong>。</p><p id="0b8a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Nimbella提供了一个有一些限制的免费服务，但足以开始使用它。此外，部署到Nimbella非常<strong class="kx jh">容易</strong>和<strong class="kx jh">快速</strong>。一个人只需要写一个带有主函数的代码，当服务器被<strong class="kx jh">调用</strong>时<strong class="kx jh">回答</strong>。</p><h2 id="1675" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">文件树</h2><p id="6cd6" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">宁贝拉项目的一个例子如下。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="ba54" class="lr ls jg nk b gy no np l nq nr">serverlessApp<br/>|____packages<br/>| |____project.yaml<br/>| |____myApp<br/>| | |____getVersion<br/>| | | |____.gitignore<br/>| | | |____appcast.xml<br/>| | | |______main__.py</span></pre><p id="51a7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个<strong class="kx jh">文件夹</strong> <em class="ns"> serverlessApp </em>包含一个<strong class="kx jh">包</strong> <em class="ns"> myApp </em>带有一个<strong class="kx jh">函数</strong> <em class="ns"> getVersion </em>。getVersion包含<em class="ns"> __main__。py </em>与本系统的<strong class="kx jh">主功能</strong>。</p><h2 id="e656" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">项目文件</h2><p id="2215" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">项目的所有规范都在一个<em class="ns"> project.yaml </em>文件中。<strong class="kx jh">运行时</strong>是<em class="ns"> python3 </em>并且<em class="ns"> web key </em>被设置为<strong class="kx jh"> false </strong>:我们不打算部署web app。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="697d" class="lr ls jg nk b gy no np l nq nr">bucket:  <br/>strip: 1<br/>packages:  <br/>- name: myApp    <br/>  web: false    <br/>  actions:      <br/>    - name: getVersion        <br/>      runtime: python:3<br/>      limits:          timeout: 60000</span></pre><h2 id="3f38" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">__main__。巴拉圭</h2><p id="3a48" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这个系统的核心如果是<strong class="kx jh">功能</strong>主。它读取一个文件并返回一个带有<strong class="kx jh">头</strong>的HTTP <strong class="kx jh">主体</strong>。<em class="ns"> Content-Type </em>头被设置为<em class="ns"> application/rss+xml </em>，因为该函数应该广播rss提要。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="d099" class="lr ls jg nk b gy no np l nq nr">def main(params): <br/>  with open("appcast.xml") as file:  <br/>    appcast = file.read()  <br/>  return {"body":appcast,      <br/>          "headers":{"Content-Type":"application/rss+xml"}<br/>         }</span></pre><p id="a37f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> <em class="ns"> appcast.xml </em> </strong>是一个包含更新后的应用程序规格的文件。根据Flutter文档，它遵循<a class="ae jd" href="https://sparkle-project.org/documentation/publishing/" rel="noopener ugc nofollow" target="_blank"> sparkle </a>模式。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="be2f" class="lr ls jg nk b gy no np l nq nr">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;rss version="2.0" xmlns:sparkle="https://.nimbella.io/api/MyApp/getVersion"&gt;    &lt;channel&gt;        <br/>&lt;title&gt;MyApp - Appcast&lt;/title&gt;        <br/>&lt;item&gt;<br/>&lt;title&gt;Version 2.0.0&lt;/title&gt;            <br/>&lt;description&gt;New awesome version&lt;/description&gt;            &lt;pubDate&gt;Thu, 11 Mar 2020 12:00:00 +0000&lt;/pubDate&gt;            &lt;enclosure url="https://url/to/app/file" sparkle:version="2.0.0" sparkle:os="android" /&gt;        <br/>&lt;/item&gt;    <br/>&lt;/channel&gt;<br/>&lt;/rss&gt;</span></pre><h2 id="0f35" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">部署无服务器</h2><p id="3a3a" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当目录中的所有文件都在正确的位置时，运行<code class="fe nt nu nv nk b">nim project deploy serverlessApp</code>就足够了，几秒钟后，该项目将部署到Nimbella基础架构，并准备好由安装在不同手机上的应用程序进行查询。</p><p id="0bad" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">额外收获:基础设施会根据请求的数量自动<strong class="kx jh">缩放</strong>，无论<strong class="kx jh">一个</strong>还是<strong class="kx jh">几千个</strong>手机都会查询它，它总能正确回答。</p><p id="1d50" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要刚刚部署的服务的url，这可以通过命令<code class="fe nt nu nv nk b">nim action get myApp/getVersion --url</code>获得</p><h2 id="91b4" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">升级程序包</h2><p id="5081" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">来自flutter的<a class="ae jd" href="https://pub.dev/packages/upgrader" rel="noopener ugc nofollow" target="_blank">升级包</a>提供了所有必要的东西来检查新的更新，并最终下载我们应用程序的<strong class="kx jh">升级版</strong>。</p><p id="75f8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有必要创建一个带有Nimbella url的<em class="ns"> AppCastConfiguration </em>。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="b272" class="lr ls jg nk b gy no np l nq nr">final appcastURL = ‘https://.nimbella.io/api/myApp/getVersion'; final cfg = AppcastConfiguration(url: appcastURL, supportedOS: [‘android’]);</span></pre><p id="c2fb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后在<strong class="kx jh">构建</strong>我们的<strong class="kx jh">主</strong>接口的过程中，将现有代码封装到一个<em class="ns"> UpgradeAlert </em>小部件中就足够了。</p><pre class="nf ng nh ni gt nj nk nl nm aw nn bi"><span id="3527" class="lr ls jg nk b gy no np l nq nr">UpgradeAlert( appcastConfig: cfg, <br/>              debugLogging: true, <br/>              child: YourWidget())</span></pre><h2 id="0e30" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">结论</h2><p id="6ae8" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">就这样，从现在开始，只需更新<em class="ns"> appcast.xml </em>文件并将新项目部署到Nimbella et voilà，每台设备都将由新更新<strong class="kx jh">触发</strong>。</p></div></div>    
</body>
</html>