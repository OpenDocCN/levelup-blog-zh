<html>
<head>
<title>Use React to Display Images in a Grid Like Google and Flickr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React在类似Google和Flickr的网格中显示图像</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-display-images-in-a-grid-like-google-and-flickr-c9c38a923884?source=collection_archive---------2-----------------------#2019-09-17">https://levelup.gitconnected.com/how-to-display-images-in-a-grid-like-google-and-flickr-c9c38a923884?source=collection_archive---------2-----------------------#2019-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d8cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你使用像谷歌图片搜索或Flickr这样的图片搜索网站，你会注意到它们的图片显示在一个看起来像砖墙的网格中。这些图像高度不均匀，但宽度相等。这被称为砖石效应，因为它看起来像一堵砖墙。</p><p id="7800" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了实现砖石效果，我们必须将图像的宽度设置为与屏幕宽度成比例，并将图像的高度设置为与图像的纵横比成比例。</p><p id="95ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在没有任何库的情况下完成，这是一件痛苦的事情，所以人们制作了库来创造这种效果。</p><p id="af9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将构建一个照片应用程序，允许用户搜索图像并在砖石网格中显示图像。图像网格将无限滚动，以获得更多的图像。我们将使用React和React砖石组件库来构建它。对于无限滚动，我们将使用React无限滚动库。我们将把React Infinite Scroller包装在React砖石组件之外，以便在显示图像时获得砖石效果的无限滚动。</p><p id="a95d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的应用程序将显示来自Pixabay API的图像。你可以在<a class="ae ko" href="https://pixabay.com/api/docs/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/api/docs/</a>查看API文档并注册一个密钥</p><p id="dd22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们运行Create React App来创建应用程序。运行<code class="fe kp kq kr ks b">npx create-react-app photo-app</code>为应用程序创建初始代码。</p><p id="1cf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们安装自己的库。我们需要React Infinite Scroller、React Masonry组件、用于样式化的Bootstrap、用于发出HTTP请求的Axios、用于表单值数据绑定和表单验证的Formik和Yup，以及用于将URL路由到页面的React Router。</p><p id="2e68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要安装所有软件包，请运行:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="b4f6" class="lb lc it ks b gy ld le l lf lg">npm i axios bootstrap formik react-bootstrap react-infinite-scroller react-masonry-component react-router-dom yup</span></pre><p id="721b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装所有的软件包。</p><p id="9d37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装好所有的包后，我们就可以开始构建应用程序了。首先将<code class="fe kp kq kr ks b">App.js</code>中的代码替换为:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="185c" class="lb lc it ks b gy ld le l lf lg">import React from "react";<br/>import { Router, Route } from "react-router-dom";<br/>import HomePage from "./HomePage";<br/>import { createBrowserHistory as createHistory } from "history";<br/>import TopBar from "./TopBar";<br/>import ImageSearchPage from "./ImageSearchPage";<br/>import "./App.css";<br/>const history = createHistory();</span><span id="9d0b" class="lb lc it ks b gy lh le l lf lg">function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Router history={history}&gt;<br/>        &lt;TopBar /&gt;<br/>        &lt;Route path="/" exact component={HomePage} /&gt;<br/>        &lt;Route path="/imagesearch" exact component={ImageSearchPage} /&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="b449" class="lb lc it ks b gy lh le l lf lg">export default App;</span></pre><p id="6c6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将应用程序的顶部栏和路线添加到应用程序的入口点。</p><p id="e4c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来删除<code class="fe kp kq kr ks b">App.css</code>中的所有代码，并添加:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="7582" class="lb lc it ks b gy ld le l lf lg">.page {<br/>  padding: 20px;<br/>}</span></pre><p id="2e08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给我们的页面添加填充。</p><p id="f987" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们通过在<code class="fe kp kq kr ks b">src</code>文件夹中创建一个<code class="fe kp kq kr ks b">exports.js</code>来设置React砖石组件选项，并添加:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="c33a" class="lb lc it ks b gy ld le l lf lg">export const masonryOptions = {<br/>  fitWidth: true,<br/>  columnWidth: 300,<br/>  gutter: 5<br/>};</span></pre><p id="65c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这些选项非常重要。</strong>我们需要将<code class="fe kp kq kr ks b">fitWidth</code>设置为<code class="fe kp kq kr ks b">true</code>来居中网格。<code class="fe kp kq kr ks b">columnWidth</code>必须是一个数字才能获得恒定宽度。它将根据屏幕大小缩放，但宽度不变。<code class="fe kp kq kr ks b">gutter</code>值是项目之间的边距。</p><p id="b019" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">选项的完整列表在<a class="ae ko" href="https://masonry.desandro.com/options.html" rel="noopener ugc nofollow" target="_blank">https://masonry.desandro.com/options.html</a></p><p id="3f65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们通过在<code class="fe kp kq kr ks b">src</code>文件夹中创建<code class="fe kp kq kr ks b">HomePage.js</code>来创建应用程序的主页，并添加:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="6cd0" class="lb lc it ks b gy ld le l lf lg">import React from "react";<br/>import { getImages } from "./request";<br/>import InfiniteScroll from "react-infinite-scroller";<br/>import Masonry from "react-masonry-component";<br/>import "./HomePage.css";<br/>import { masonryOptions } from "./exports";</span><span id="5709" class="lb lc it ks b gy lh le l lf lg">function HomePage() {<br/>  const [images, setImages] = React.useState([]);<br/>  const [page, setPage] = React.useState(1);<br/>  const [total, setTotal] = React.useState(0);<br/>  const [initialized, setInitialized] = React.useState(false);</span><span id="7a61" class="lb lc it ks b gy lh le l lf lg">  const getAllImages = async (pg = 1) =&gt; {<br/>    const response = await getImages(page);<br/>    let imgs = images.concat(response.data.hits);<br/>    setImages(imgs);<br/>    setTotal(response.data.total);<br/>    pg++;<br/>    setPage(pg);<br/>  };</span><span id="591b" class="lb lc it ks b gy lh le l lf lg">  React.useEffect(() =&gt; {<br/>    if (!initialized) {<br/>      getAllImages();<br/>      setInitialized(true);<br/>    }<br/>  });</span><span id="7853" class="lb lc it ks b gy lh le l lf lg">  return (<br/>    &lt;div className="page"&gt;<br/>      &lt;h1 className="text-center"&gt;Home&lt;/h1&gt;<br/>      &lt;InfiniteScroll<br/>        pageStart={1}<br/>        loadMore={getAllImages}<br/>        hasMore={total &gt; images.length}<br/>      &gt;<br/>        &lt;Masonry<br/>          className={"grid"}<br/>          elementType={"div"}<br/>          options={masonryOptions}<br/>          disableImagesLoaded={false}<br/>          updateOnEachImageLoad={false}<br/>        &gt;<br/>          {images.map((img, i) =&gt; {<br/>            return (<br/>              &lt;div key={i}&gt;<br/>                &lt;img src={img.previewURL} style={{ width: 300 }} /&gt;<br/>              &lt;/div&gt;<br/>            );<br/>          })}<br/>        &lt;/Masonry&gt;<br/>      &lt;/InfiniteScroll&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>export default HomePage;</span></pre><p id="e427" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在主页中，我们只是在页面加载时获取图像。当用户向下滚动时，我们通过在当前的<code class="fe kp kq kr ks b">page</code>值上加1来加载更多的图像，并获取带有页码的图像。</p><p id="972f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将React Infinite Scroll提供的<code class="fe kp kq kr ks b">InfiniteScroll</code>组件包装在React Masonry组件提供的<code class="fe kp kq kr ks b">Masonry</code>组件之外，我们在一个网格中显示我们的图像，并且当用户向下滚动直到<code class="fe kp kq kr ks b">images</code>数组的<code class="fe kp kq kr ks b">length</code>大于或等于来自Pixabay API结果给出的<code class="fe kp kq kr ks b">total</code>字段的<code class="fe kp kq kr ks b">total</code>时，还会显示更多。</p><p id="b794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当页面加载时，我们通过检查<code class="fe kp kq kr ks b">initialized</code>标志是否为<code class="fe kp kq kr ks b">true</code>来加载图像，只有当<code class="fe kp kq kr ks b">initialized</code>为<code class="fe kp kq kr ks b">false</code>时，我们才在页面加载时加载图像，并且当请求第一次被发送到API并成功时，我们将<code class="fe kp kq kr ks b">initialized</code>标志设置为<code class="fe kp kq kr ks b">true</code>以停止每次渲染时的请求。</p><p id="80ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们通过创建<code class="fe kp kq kr ks b">ImageSearchPage.js</code>文件并添加以下内容来创建图像搜索页面:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="8c34" class="lb lc it ks b gy ld le l lf lg">import React from "react";<br/>import { Formik } from "formik";<br/>import Form from "react-bootstrap/Form";<br/>import Col from "react-bootstrap/Col";<br/>import Button from "react-bootstrap/Button";<br/>import * as yup from "yup";<br/>import InfiniteScroll from "react-infinite-scroller";<br/>import Masonry from "react-masonry-component";<br/>import { masonryOptions } from "./exports";<br/>import { searchImages } from "./request";</span><span id="03e4" class="lb lc it ks b gy lh le l lf lg">const schema = yup.object({<br/>  keyword: yup.string().required("Keyword is required")<br/>});</span><span id="c4fa" class="lb lc it ks b gy lh le l lf lg">function ImageSearchPage() {<br/>  const [images, setImages] = React.useState([]);<br/>  const [keyword, setKeyword] = React.useState([]);<br/>  const [page, setPage] = React.useState(1);<br/>  const [total, setTotal] = React.useState(0);<br/>  const [searching, setSearching] = React.useState(false);</span><span id="fc57" class="lb lc it ks b gy lh le l lf lg">  const handleSubmit = async evt =&gt; {<br/>    const isValid = await schema.validate(evt);<br/>    if (!isValid) {<br/>      return;<br/>    }<br/>    setKeyword(evt.keyword);<br/>    searchAllImages(evt.keyword, 1);<br/>  };</span><span id="98c9" class="lb lc it ks b gy lh le l lf lg">  const searchAllImages = async (keyword, pg = 1) =&gt; {<br/>    setSearching(true);</span><span id="0860" class="lb lc it ks b gy lh le l lf lg">  const response = await searchImages(keyword, page);<br/>    let imgs = response.data.hits;<br/>    setImages(imgs);<br/>    setTotal(response.data.total);<br/>    setPage(pg);<br/>  };</span><span id="62e7" class="lb lc it ks b gy lh le l lf lg">  const getMoreImages = async () =&gt; {<br/>    let pg = page;<br/>    pg++;<br/>    const response = await searchImages(keyword, pg);<br/>    const imgs = images.concat(response.data.hits);<br/>    setImages(imgs);<br/>    setTotal(response.data.total);<br/>    setPage(pg);<br/>  };</span><span id="85c4" class="lb lc it ks b gy lh le l lf lg">  React.useEffect(() =&gt; {});</span><span id="3f17" class="lb lc it ks b gy lh le l lf lg">  return (<br/>    &lt;div className="page"&gt;<br/>      &lt;h1 className="text-center"&gt;Search&lt;/h1&gt;<br/>      &lt;Formik validationSchema={schema} onSubmit={handleSubmit}&gt;<br/>        {({<br/>          handleSubmit,<br/>          handleChange,<br/>          handleBlur,<br/>          values,<br/>          touched,<br/>          isInvalid,<br/>          errors<br/>        }) =&gt; (<br/>          &lt;Form noValidate onSubmit={handleSubmit}&gt;<br/>            &lt;Form.Row&gt;<br/>              &lt;Form.Group as={Col} md="12" controlId="keyword"&gt;<br/>                &lt;Form.Label&gt;Keyword&lt;/Form.Label&gt;<br/>                &lt;Form.Control<br/>                  type="text"<br/>                  name="keyword"<br/>                  placeholder="Keyword"<br/>                  value={values.keyword || ""}<br/>                  onChange={handleChange}<br/>                  isInvalid={touched.keyword &amp;&amp; errors.keyword}<br/>                /&gt;<br/>                &lt;Form.Control.Feedback type="invalid"&gt;<br/>                  {errors.keyword}<br/>                &lt;/Form.Control.Feedback&gt;<br/>              &lt;/Form.Group&gt;<br/>            &lt;/Form.Row&gt;<br/>            &lt;Button type="submit" style={{ marginRight: "10px" }}&gt;<br/>              Search<br/>            &lt;/Button&gt;<br/>          &lt;/Form&gt;<br/>        )}<br/>      &lt;/Formik&gt;<br/>      &lt;br /&gt;<br/>      &lt;InfiniteScroll<br/>        pageStart={1}<br/>        loadMore={getMoreImages}<br/>        hasMore={searching &amp;&amp; total &gt; images.length}<br/>      &gt;<br/>        &lt;Masonry<br/>          className={"grid"}<br/>          elementType={"div"}<br/>          options={masonryOptions}<br/>          disableImagesLoaded={false}<br/>          updateOnEachImageLoad={false}<br/>        &gt;<br/>          {images.map((img, i) =&gt; {<br/>            return (<br/>              &lt;div key={i}&gt;<br/>                &lt;img src={img.previewURL} style={{ width: 300 }} /&gt;<br/>              &lt;/div&gt;<br/>            );<br/>          })}<br/>        &lt;/Masonry&gt;<br/>      &lt;/InfiniteScroll&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>export default ImageSearchPage;</span></pre><p id="b736" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不会在第一次加载时加载图像。相反，用户在表单中输入一个搜索词，当用户点击搜索按钮时，就会调用<code class="fe kp kq kr ks b">handleSubmit</code>。<code class="fe kp kq kr ks b">evt</code>对象具有表单值，由<code class="fe kp kq kr ks b">Formik</code>组件更新。Yup为表单验证对象提供了<code class="fe kp kq kr ks b">schema</code>对象，我们只需检查<code class="fe kp kq kr ks b">keyword</code>是否是必需的。</p><p id="cf39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe kp kq kr ks b">handlesubmit</code>函数中，我们得到了<code class="fe kp kq kr ks b">evt</code>对象，我们通过调用返回承诺的<code class="fe kp kq kr ks b">schema.validate</code>来验证这个对象。如果承诺返回真实的东西，那么我们继续用搜索关键字和页码向Pixabay API发出请求。</p><p id="774b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有相同的设置作为主页的无限滚动和砖石效果图像网格。唯一的区别是我们调用了与<code class="fe kp kq kr ks b">getAllImages</code>函数逻辑相似的<code class="fe kp kq kr ks b">searchAllImages</code>函数，除了页面参数之外，我们还传入了<code class="fe kp kq kr ks b">keyword</code>参数。我们将<code class="fe kp kq kr ks b">imgs</code>变量设置为从Pixabay API返回的数组，并通过调用<code class="fe kp kq kr ks b">setImages</code>设置<code class="fe kp kq kr ks b">images</code>。我们还通过调用<code class="fe kp kq kr ks b">setPage</code>来设置页面。</p><p id="3cbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当用户向下滚动足够远以至于内容用尽时，当<code class="fe kp kq kr ks b">images.length</code>小于<code class="fe kp kq kr ks b">total</code>时，调用<code class="fe kp kq kr ks b">getMoreImages</code>函数。通过从API获取<code class="fe kp kq kr ks b">total</code>字段来设置<code class="fe kp kq kr ks b">total</code>。</p><p id="f79e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<code class="fe kp kq kr ks b">exports.js</code>中的<code class="fe kp kq kr ks b">masonryOptions</code>，就像在主页中一样，并以同样的方式显示图像。</p><p id="1391" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来在<code class="fe kp kq kr ks b">src</code>文件夹中创建<code class="fe kp kq kr ks b">request.js</code>,添加向后端发出HTTP请求的代码，如下所示:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="324d" class="lb lc it ks b gy ld le l lf lg">const axios = require("axios");<br/>const APIURL = "<a class="ae ko" href="https://pixabay.com/api" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/api</a>";</span><span id="0126" class="lb lc it ks b gy lh le l lf lg">export const getImages = (page = 1) =&gt;<br/>  axios.get(`${APIURL}/?page=${page}&amp;key=${process.env.REACT_APP_APIKEY}`);</span><span id="436d" class="lb lc it ks b gy lh le l lf lg">export const searchImages = (keyword, page = 1) =&gt;<br/>  axios.get(<br/>    `${APIURL}/?page=${page}&amp;key=${process.env.REACT_APP_APIKEY}&amp;q=${keyword}`<br/>  );</span></pre><p id="cd30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有仅用于获取图像的<code class="fe kp kq kr ks b">getImages</code>和将搜索词发送给API的<code class="fe kp kq kr ks b">searchImages</code>。<code class="fe kp kq kr ks b">process.env.REACT_APP_APIKEY</code>来自于设置项目根文件夹中<code class="fe kp kq kr ks b">.env</code>文件中的<code class="fe kp kq kr ks b">REACT_APP_APIKEY</code>变量。</p><p id="66b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来在<code class="fe kp kq kr ks b">src</code>文件夹中创建<code class="fe kp kq kr ks b">TopBar.js</code>，并添加:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="5045" class="lb lc it ks b gy ld le l lf lg">import React from "react";<br/>import Navbar from "react-bootstrap/Navbar";<br/>import Nav from "react-bootstrap/Nav";<br/>import { withRouter } from "react-router-dom";</span><span id="f295" class="lb lc it ks b gy lh le l lf lg">function TopBar({ location }) {<br/>  React.useEffect(() =&gt; {});</span><span id="288c" class="lb lc it ks b gy lh le l lf lg">  return (<br/>    &lt;Navbar bg="primary" expand="lg" variant="dark"&gt;<br/>      &lt;Navbar.Brand href="#home"&gt;Photo App&lt;/Navbar.Brand&gt;<br/>      &lt;Navbar.Toggle aria-controls="basic-navbar-nav" /&gt;<br/>      &lt;Navbar.Collapse id="basic-navbar-nav"&gt;<br/>        &lt;Nav className="mr-auto"&gt;<br/>          &lt;Nav.Link href="/" active={location.pathname == "/"}&gt;<br/>            Home<br/>          &lt;/Nav.Link&gt;<br/>          &lt;Nav.Link<br/>            href="/imagesearch"<br/>            active={location.pathname == "/imagesearch"}<br/>          &gt;<br/>            Search<br/>          &lt;/Nav.Link&gt;<br/>        &lt;/Nav&gt;<br/>      &lt;/Navbar.Collapse&gt;<br/>    &lt;/Navbar&gt;<br/>  );<br/>}<br/>export default withRouter(TopBar);</span></pre><p id="8aa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这包含React引导程序<code class="fe kp kq kr ks b">Navbar</code>来显示一个带有主页链接和应用程序名称的顶栏。我们通过设置<code class="fe kp kq kr ks b">active</code>属性来检查<code class="fe kp kq kr ks b">location.pathname</code>以突出显示正确的链接，其中<code class="fe kp kq kr ks b">location</code>属性由React Router通过将<code class="fe kp kq kr ks b">withRouter</code>函数包装在<code class="fe kp kq kr ks b">TopBar</code>组件之外来提供。</p><p id="66d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，在<code class="fe kp kq kr ks b">index.js</code>中，我们将现有代码替换为:</p><pre class="kt ku kv kw gt kx ks ky kz aw la bi"><span id="e3be" class="lb lc it ks b gy ld le l lf lg">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" /&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;<br/>    &lt;meta name="theme-color" content="#000000" /&gt;<br/>    &lt;meta<br/>      name="description"<br/>      content="Web site created using create-react-app"<br/>    /&gt;<br/>    &lt;link rel="apple-touch-icon" href="logo192.png" /&gt;<br/>    &lt;!--<br/>      manifest.json provides metadata used when your web app is installed on a<br/>      user's mobile device or desktop. See <a class="ae ko" href="https://developers.google.com/web/fundamentals/web-app-manifest/" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/web/fundamentals/web-app-manifest/</a><br/>    --&gt;<br/>    &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt;<br/>    &lt;!--<br/>      Notice the use of %PUBLIC_URL% in the tags above.<br/>      It will be replaced with the URL of the `public` folder during the build.<br/>      Only files inside the `public` folder can be referenced from the HTML.</span><span id="b26d" class="lb lc it ks b gy lh le l lf lg">Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will<br/>      work correctly both with client-side routing and a non-root public URL.<br/>      Learn how to configure a non-root public URL by running `npm run build`.<br/>    --&gt;<br/>    &lt;title&gt;Photo App&lt;/title&gt;<br/>    &lt;link<br/>      rel="stylesheet"<br/>      href="<a class="ae ko" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css</a>"<br/>      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"<br/>      crossorigin="anonymous"<br/>    /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>    &lt;!--<br/>      This HTML file is a template.<br/>      If you open it directly in the browser, you will see an empty page.</span><span id="91a0" class="lb lc it ks b gy lh le l lf lg">You can add webfonts, meta tags, or analytics to this file.<br/>      The build step will place the bundled scripts into the &lt;body&gt; tag.</span><span id="ee73" class="lb lc it ks b gy lh le l lf lg">To begin the development, run `npm start` or `yarn start`.<br/>      To create a production bundle, use `npm run build` or `yarn build`.<br/>    --&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7d00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加引导CSS并更改标题。</p><p id="e0e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在运行<code class="fe kp kq kr ks b">npm start</code>，然后你会得到:</p><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi li"><img src="../Images/d5482bcf12cb0039780bcaa983db013a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3dQOeDverKjoiL_Q65Inw.png"/></div></div></figure><figure class="kt ku kv kw gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lq"><img src="../Images/6aa147328cd4fdc29c704256084f0c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhDSICE5laxPi8_m3f_zug.png"/></div></div></figure></div></div>    
</body>
</html>