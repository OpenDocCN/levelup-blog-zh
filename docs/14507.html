<html>
<head>
<title>JavaScript Callback Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript回调函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-callback-functions-89cc315aa5be?source=collection_archive---------2-----------------------#2022-12-03">https://levelup.gitconnected.com/javascript-callback-functions-89cc315aa5be?source=collection_archive---------2-----------------------#2022-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e9e53640bdaba2221359f55b38e4cd35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSxjHwFjC3ycYn8-pWh-sg.png"/></div></div></figure><p id="e21d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管不知道什么是回调函数，但很可能你已经在不知不觉中使用了它。像<code class="fe kw kx ky kz b">.map()</code>、<code class="fe kw kx ky kz b">.filter()</code>和<code class="fe kw kx ky kz b">.reduce()</code>这样的方法都使用回调函数。</p><p id="2218" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管回调可能会令人困惑，但是您仍然需要彻底地学习它们，因为它们构成了JavaScript中的一个关键概念。不了解回调，你就走不了多远。</p><p id="4dba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，您将了解什么是回调，为什么它们很重要，以及如何使用它们。</p><h1 id="1be3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是回调函数？</h1><p id="377b" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在Javascript中，每个函数都是一个对象。这允许我们使用一个函数作为另一个函数的参数，这是回调函数的基本思想。</p><p id="de63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回调函数是作为一个参数传递给另一个函数的函数，并且期望在稍后的时间点被<em class="md">回调</em>。</p><p id="a788" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接受其他函数作为参数的函数称为<em class="md">高阶函数。</em></p><p id="b7b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了说明回调是如何工作的，让我们看一个简单的例子。</p><pre class="me mf mg mh gt mi kz mj bn mk ml bi"><span id="c622" class="mm lb iq kz b be mn mo l mp mq">function createGreeting(name, callback){ <br/>  const greeting = `Hello ${name}!!`;<br/>  callback(greeting); <br/>}<br/><br/>function logGreeting(greeting){<br/>  console.log(greeting);<br/>}<br/><br/>createGreeting("James", logGreeting); <br/>// Hello James!!</span></pre><p id="a9fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，<code class="fe kw kx ky kz b">createGreeting</code>是高阶函数，它接受两个参数，名称和回调函数。我们使用<code class="fe kw kx ky kz b">logGreeting</code>作为我们的回调函数。当我们执行<code class="fe kw kx ky kz b">createGreeting</code>函数时，请注意，当我们将其作为参数传入时，<em class="md">没有将</em>括号附加到<code class="fe kw kx ky kz b">logGreeting</code>上。这是因为我们不想马上执行回调函数，我们只想将函数定义传递给更高阶的函数，以便稍后执行。</p><h1 id="6207" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么要使用回调函数？</h1><p id="e5ab" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">回调以两种不同的方式使用——在<em class="md">同步函数</em>和<em class="md">异步函数</em>中。</p><h2 id="695d" class="mr lb iq bd lc ms mt dn lg mu mv dp lk kj mw mx lo kn my mz ls kr na nb lw nc bi translated">同步函数中的回调</h2><p id="93a0" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">如果你的函数是从上到下执行的，并且在执行下一行之前等待上一行被执行，那么你的函数是同步的。</p><p id="db48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在同步代码中使用回调的目的是我们可以很容易地将代码的一部分与另一部分交换。</p><p id="1f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看下面的例子，我们可以简单地通过交换回调函数，轻松地重用<code class="fe kw kx ky kz b">filter</code>函数来获得偶数和奇数。</p><pre class="me mf mg mh gt mi kz mj bn mk ml bi"><span id="6f4a" class="mm lb iq kz b be mn mo l mp mq">const numbers = [3, 4, 10, 20]<br/>const getOddNums = num =&gt; num % 2 !== 0<br/>const getEvenNums = num =&gt; num % 2 === 0<br/><br/>// Passing getOddNums function into filter<br/>const oddNums = numbers.filter(getOddNums)<br/><br/>// Passing getEvenNums function into filter<br/>const evenNums = numbers.filter(getEvenNums)</span></pre><p id="d1b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你知道了为什么我们在同步函数中使用回调，让我们继续看为什么我们在异步函数中使用回调。</p><h2 id="7866" class="mr lb iq bd lc ms mt dn lg mu mv dp lk kj mw mx lo kn my mz ls kr na nb lw nc bi translated">异步函数中的回调</h2><p id="2a80" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">异步意味着，如果JavaScript需要等待某件事情完成，它会在等待的同时开始完成其他任务。</p><p id="7c1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个非常常见的异步函数的例子是<code class="fe kw kx ky kz b">setTimeout</code>。稍后需要一个回调函数来执行它。</p><pre class="me mf mg mh gt mi kz mj bn mk ml bi"><span id="c326" class="mm lb iq kz b be mn mo l mp mq">// Calls the callback after 1 second<br/>setTimeout(callback, 1000)</span></pre><p id="a152" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看<code class="fe kw kx ky kz b">setTimeout</code>如何工作，如果你让JavaScript完成其他任务的话:</p><pre class="me mf mg mh gt mi kz mj bn mk ml bi"><span id="c06f" class="mm lb iq kz b be mn mo l mp mq">const fiveSecondsLater = () =&gt; console.log('5 seconds passed!')<br/><br/>setTimeout(fiveSecondsLater, 5000)<br/>console.log('Start!')<br/>console.log('Doing other tasks')</span></pre><p id="fb76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，JavaScript执行<code class="fe kw kx ky kz b">setTimeout</code>。然后，它等待五秒钟，并记录“5秒钟过去了！”。</p><p id="c155" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同时，在等待<code class="fe kw kx ky kz b">setTimeout</code>完成它的5秒钟时，JavaScript继续执行<code class="fe kw kx ky kz b">console.log("Start!")</code>和<code class="fe kw kx ky kz b">console.log("Doing other tasks")</code>。</p><p id="3133" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，这是您将看到的上述代码的输出:</p><pre class="me mf mg mh gt mi kz mj bn mk ml bi"><span id="0195" class="mm lb iq kz b be mn mo l mp mq">// Start! (almost immediately)<br/>// Doing other tasks (almost immediately after the first log)<br/>// 5seconds passed! (after five seconds)</span></pre><p id="38cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，对于异步函数中的回调，我们提前给出了任务完成时该做什么的指令。</p><p id="abf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回调的一些常见用例告诉JavaScript该做什么</p><ol class=""><li id="9d3b" class="nd ne iq ka b kb kc kf kg kj nf kn ng kr nh kv ni nj nk nl bi translated">当事件触发时(例如，键盘按键被按下)。</li><li id="002a" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">完成一个API调用。</li><li id="af39" class="nd ne iq ka b kb nm kf nn kj no kn np kr nq kv ni nj nk nl bi translated">在读取/写入文件后。</li></ol><p id="a3b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这能让你明白为什么回调是有用的，以及如何使用它们。</p><p id="2d77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们结束之前，让我们看一看人们在使用回调时经常遇到的一个常见问题。</p><h1 id="0f3c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">回调地狱</h1><p id="1816" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">回调地狱是多个回调一个接一个嵌套的现象。每次回调都依赖/等待前一次回调完成，从而形成一个难以阅读和维护的金字塔结构。</p><p id="04cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们来看一个回调地狱的例子。</p><pre class="me mf mg mh gt mi kz mj bn mk ml bi"><span id="af86" class="mm lb iq kz b be mn mo l mp mq">read('first.js', function(error, script) {<br/>  if (error) {<br/>    handleError(error);<br/>  } else {<br/>    // ...<br/>    read('second.js', function(error, script) {<br/>      if (error) {<br/>        handleError(error);<br/>      } else {<br/>        // ...<br/>        read('third.js', function(error, script) {<br/>          if (error) {<br/>            handleError(error);<br/>          } else {<br/>            // ....<br/>          }<br/>        });<br/><br/>      }<br/>    });<br/>  }<br/>});</span></pre><p id="0c10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">似乎很难遵循这些准则，不是吗？</p><p id="1a8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">避免回调地狱的一个解决方案是将代码分成更小的函数以避免嵌套结构。</p><pre class="me mf mg mh gt mi kz mj bn mk ml bi"><span id="78b1" class="mm lb iq kz b be mn mo l mp mq">read('first.js', step1);<br/><br/>function step1(error, script) {<br/>  if (error) {<br/>    handleError(error);<br/>  } else {<br/>    // ...<br/>    read('second.js', step2);<br/>  }<br/>}<br/><br/>function step2(error, script) {<br/>  if (error) {<br/>    handleError(error);<br/>  } else {<br/>    // ...<br/>    read('third.js', step3);<br/>  }<br/>}<br/><br/>function step3(error, script) {<br/>  if (error) {<br/>    handleError(error);<br/>  } else {<br/>    // ....<br/>  }<br/>}</span></pre><p id="6248" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个看起来比上一个可读性更强，对吧？</p><p id="e083" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有其他解决回调问题的方法，比如promises和async/await。我们将在以后的文章中尝试研究它们。</p><h1 id="54e3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包扎</h1><p id="e8dc" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">今天，你学习了什么是回调，为什么回调在JavaScript中如此重要，以及如何使用回调。您还了解了回调地狱以及解决它的方法。希望现在回调不再让你困惑。</p><p id="00e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于复试你还有什么问题吗？如果你愿意，请在下面留下你的评论，我会尽快回复你。</p><p id="f9c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="md">如果你喜欢这个，请看看我的其他作品</em></strong><a class="ae nr" href="https://tahajiru.start.page/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="md"/></strong></a><strong class="ka ir"><em class="md">。</em> </strong></p></div></div>    
</body>
</html>