<html>
<head>
<title>Designing Idempotent APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计幂等API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/idempotency-in-api-design-bc4ea812a881?source=collection_archive---------2-----------------------#2021-05-14">https://levelup.gitconnected.com/idempotency-in-api-design-bc4ea812a881?source=collection_archive---------2-----------------------#2021-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="caaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网络故障！超时、中断和路由问题随时都会发生。它向我们提出了挑战，要求我们设计在处理故障和确保一致性方面健壮的API和客户机。</p><p id="95c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将我们的API和系统设计成<em class="kl">等幂</em>，这意味着它们可以被调用任意次，同时保证副作用只发生一次。让我们更深入地了解为什么引入幂等性是必要的，它是如何工作的，以及如何实现它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/add0a78186df502c041a9f6eb569d3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QHrldW_pnQWRi3H8"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://unsplash.com/@lysanderyuen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">吕山德元</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="ade7" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为什么幂等性在后端应用中至关重要？</h1><p id="705f" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">考虑像Instagram这样的社交网站的设计，用户可以在那里与所有关注者分享帖子。让我们假设我们在两台不同的机器上托管应用服务器和数据库服务器，以获得更好的性能和可伸缩性。此外，我们使用PostgreSQL来存储数据。帖子和创建帖子将具有以下模型:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="183a" class="ml le iq mh b gy mm mn l mo mp">CREATE TABLE public.posts <em class="kl">(<br/>   </em>id int(11)<em class="kl"> </em>PRIMARY KEY,<br/>   user_id int(11) REFERENCES users,<br/>   image_id int(11) REFERENCES images NULL,<br/>   content character varying<em class="kl">(</em>2048<em class="kl">) </em>COLLATE pg_catalog."default",<br/>   create_timestamp timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP<br/><em class="kl">)</em>;</span></pre><h2 id="7dc5" class="ml le iq bd lf mq mr dn lj ms mt dp ln jy mu mv lr kc mw mx lv kg my mz lz na bi translated">失败和重试次数</h2><p id="6419" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如果我们将数据库放在与应用服务器不同的服务器上，有时会因为网络问题而导致发布失败。可能存在以下问题:</p><ul class=""><li id="ce0e" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated">当应用服务器尝试连接到数据库服务器时，初始连接可能会失败。</li><li id="c224" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">当应用服务器正在完成操作时，调用可能会中途失败，从而使工作处于不稳定状态。</li><li id="3618" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">调用可能会成功，但是在数据库服务器能够告诉应用程序服务器之前，连接就中断了。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi np"><img src="../Images/f3691b36956a6a2be72ab7d910904bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtfaDxb3P6Ut-rznIwy78g.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">重试</figcaption></figure><p id="9e6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用重试逻辑来解决这个问题，但是很难怀疑网络故障的真正原因。因此，这可能会导致这样一种情况，即已经在数据库中输入了帖子，但是它无法向应用服务器发送ACK。在这里，应用服务器不知不觉地不断重试和创建重复的帖子。这最终会导致商业损失。还有许多其他关键系统，如支付、购物网站，其中幂等系统非常重要。</p><h2 id="ece2" class="ml le iq bd lf mq mr dn lj ms mt dp ln jy mu mv lr kc mw mx lv kg my mz lz na bi translated">解决办法</h2><p id="62ac" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">对此的解决方案是重试，但使操作幂等。如果一个操作是等幂的，那么应用服务器可以重复进行相同的调用，同时产生相同的结果。</p><p id="b97f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的设计中，我们可以使用通用的唯一标识符。我们的应用服务器会给每个帖子一个自己的UUID。我们可以改变我们的模型，使其具有唯一的键约束。</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="7f41" class="ml le iq mh b gy mm mn l mo mp"><br/>CREATE TABLE public.posts (<br/>   id uuid PRIMARY KEY,<br/>   user_id uuid REFERENCES users,<br/>   image_id uuid REFERENCES images NULL,<br/>   content character varying(2048) COLLATE pg_catalog."default",<br/>   create_timestamp timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP<br/>);</span><span id="a39d" class="ml le iq mh b gy nq mn l mo mp">INSERT INTO posts (id, user_id, image_id, content)<br/>VALUES ("DC2FB40E-058F-4208-B9A3-EB1790C532C8", "20C5ADC5-D1A5-4A1F-800F-1AADD1E4E954", "3CC32CAE-B6AC-4C53-97EC-25EB49F2E7F3", "Hello-world") RETURNING id ON CONFLICT DO NOTHING;</span></pre><p id="ae13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们的应用服务器想要创建一个post时，它将生成UUID，并重试Insert语句，直到从数据库服务器获得成功的响应。我们需要更改我们的系统来处理违反约束的情况，并返回现有的帖子。因此，总会恰好创建一个帖子。</p><h1 id="952a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">HTTP中的幂等性</h1><p id="3c53" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">HTTP的一个重要方面是一些方法是幂等的概念。以GET为例，无论你调用多少次GET方法，结果都是一样的。另一方面，<strong class="jp ir"> POST不应该是一个幂等方法</strong>，多次调用它可能会导致不正确的更新。</p><p id="2b23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安全的方法不会改变服务器中资源的表示，例如GET方法不应该改变你正在访问的页面的内容。它们是只读方法，而PUT方法将更新页面，但本质上是幂等的。为了幂等，只考虑服务器的实际后端状态，每个请求返回的状态码可能不同:第一次调用一个<code class="fe nr ns nt mh b"><a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE" rel="noopener ugc nofollow" target="_blank">DELETE</a></code>可能会返回一个<code class="fe nr ns nt mh b"><a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200" rel="noopener ugc nofollow" target="_blank">200</a></code>，而后续调用可能会返回一个<code class="fe nr ns nt mh b"><a class="ae lc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404" rel="noopener ugc nofollow" target="_blank">404</a></code>。</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="83f2" class="ml le iq mh b gy mm mn l mo mp">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists<br/>DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted<br/>DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span></pre><ul class=""><li id="c0b9" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated">GET既安全又幂等。</li><li id="9be4" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">HEAD也是既安全又幂等的。</li><li id="ecf3" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">OPTIONS也是安全的和幂等的。</li><li id="9a45" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">PUT不是安全的，而是幂等的。</li><li id="945f" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">删除不安全但是幂等的。</li><li id="6c55" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">POST既不安全也不幂等。</li><li id="6cf0" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">PATCH也既不安全也不幂等。</li></ul><p id="20b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP规范将某些方法定义为幂等的，但是实际实现它取决于服务器。例如，发送带有UUID的request-id标头，服务器使用该标头对PUT请求进行重复数据消除。如果您正在服务一个GET请求，我们不应该改变服务器端数据。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="6d78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设计等幂系统对于构建弹性微服务架构非常重要。这有助于解决由于网络固有的损耗而导致的许多问题。通过利用Kafka等幂等队列，它可以确保在长时间停机的情况下可以重试您的操作。这有助于您设计不会丢失数据的系统，任何丢失的数据都可以通过重放消息队列来调整。如果所有的操作都是幂等的，那么不管消息被处理多少次，都会产生相同的状态。</p></div></div>    
</body>
</html>