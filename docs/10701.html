<html>
<head>
<title>Build an accessible modal (dialog) window with React.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React构建一个可访问的模态(对话框)窗口。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-an-accessible-modal-dialog-window-with-react-35f6938e58c4?source=collection_archive---------12-----------------------#2022-01-03">https://levelup.gitconnected.com/build-an-accessible-modal-dialog-window-with-react-35f6938e58c4?source=collection_archive---------12-----------------------#2022-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/021219ebc804375072cf1d8ca5b32a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-9iVfqlYPGYKuBakMgH4g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">展示了一个模态对话框在浏览器上的外观。</figcaption></figure><p id="14b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi la translated">对话窗口通常用于将用户的注意力引导到预先定义的动作闭环上。窗口存在于web应用程序上下文中的一个单独的层上。对话框的图层作为区分前景活跃元素和惰性背景界面的焦点。对话框之外的内容应该被遮蔽，以便在视觉上辨别新的用户流。</p><p id="f78e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不幸的是，模态经常与黑暗的用户界面(UI)模式联系在一起。我们都有过这样的经历:浏览网站时，定时弹出窗口会打断我们的阅读，并几乎本能地拒绝它们。虽然，知名网站不会过度使用它们，但鉴于它们吸引注意力的性质，它们是不可避免的。它们最终应该谨慎使用，因为不是所有的用户操作都保证中断。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="b110" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">要求</h1><p id="5f71" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">对话框的实现可以根据用户的感知和交互方式而变化。例如，警报(成功、警告、错误)消息是对话的子集。然而，从操作上来说，它会短暂地显示一条重要的消息，并在不中断用户流程的情况下自行丢弃。</p><p id="d12c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将主要关注需要显式触发来预览和卸载的窗口。</p><h2 id="95a0" class="mt lr iq bd ls mu mv dn lw mw mx dp ma kn my mz me kr na nb mi kv nc nd mm ne bi translated">解剖</h2><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/4af004eace84d56fa085c32293d8be6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEeVNY9N4Bhnl-35fwgPww.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">源自谷歌<a class="ae nk" href="https://material.io/components/dialogs#anatomy" rel="noopener ugc nofollow" target="_blank">材质设计</a>的对话图。</figcaption></figure><p id="f3c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">出于本文的目的，我们修改了材料设计团队提出的命名方案，以更好地反映底层的<em class="nl"> className </em>基础设施。这种差异本质上纯粹是语言上的。</p><ol class=""><li id="480b" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated">窗口(Window)——在我们的模式中，围绕所有可交互元素的主容器。理想情况下，我们需要在这个容器中“捕获”键盘焦点，直到模态被处理。</li><li id="73db" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir">标题</strong> —包含一个简短的标题，可选地辅以更长的描述。此外，它还可以包含一个带有“X”图标的“关闭”按钮。</li><li id="89e2" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir"> Body </strong> —表单元素和所有与对话框核心用法相关的东西都应该包含在主体中。</li><li id="ee7c" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir">页脚</strong> —大多数可用的动作按钮应该放在页脚，为对话框的目的提供一个清晰的结论。</li><li id="8c43" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir">遮罩</strong> —我们通过用遮罩模糊其余内容来表达对对话的专注。理想情况下，该掩码包含与不同的“取消”或“关闭”按钮相同的关闭事件处理程序。</li></ol><h2 id="8d48" class="mt lr iq bd ls mu mv dn lw mw mx dp ma kn my mz me kr na nb mi kv nc nd mm ne bi translated">键盘</h2><p id="aa67" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">在追求可访问的模态对话框的过程中，我们有四个核心方面需要解决。</p><ol class=""><li id="7ef0" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated"><strong class="ke ir">捕获焦点</strong> —当对话框挂载时，焦点应该放在我们窗口的容器内。由于动态对话内容，这种方法可能不容易维护。建议使用<strong class="ke ir"> tabIndex={-1} </strong>，最初关注<em class="nl">窗口</em>容器。通过这样做，我们使屏幕阅读器能够宣布与我们的对话框相关联的标题和描述。</li><li id="961f" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir"> Tab </strong> —所有可以获得焦点的元素都应该是可被发现的，并且当Tab以旋转的方式被按下时获得焦点。当我们把焦点放在最后一个键盘可访问元素上时，如果再次按下tab键，我们将旋转回到tab键顺序中的第一个元素。</li><li id="1f48" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir"> Shift </strong> + <strong class="ke ir"> Tab </strong> —类似于<strong class="ke ir"> Tab </strong>我们以循环方式锁定焦点。只是这一次我们将tab焦点旋转到DOM定义的位置的相反方向。如果第一个键盘辅助元素有焦点，并且我们按下shift+tab，我们必须将焦点放在tab键顺序中的最后一个元素上。</li><li id="fbb6" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir"> Escape </strong> —在我们的模态对话框流程中的任何一点，如果用户按下Escape键，我们应该立即放弃窗口，焦点应该放在最初触发挂载的元素上。自然，模式的每个触发器都应该是选项卡可访问的。</li></ol></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="a021" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">履行</h1><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/31f544a45e2c97c20d7dbe2556abfd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Jd4KXA6dOixVTEBJXLnH4g.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">展示了实现到模式对话框的所有可访问的需求。</figcaption></figure><p id="274a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">模态的位置应该在主要内容区域的层次结构之外。React预构建了<a class="ae nk" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">门户</a>，使我们能够在父组件位置之外呈现一个DOM节点。我们可以很容易地定义一个名为<strong class="ke ir"> renderPortal </strong>的可重用函数，以自动化在其层次结构之外呈现HTMLElement的过程。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="2119" class="mt lr iq bd ls mu mv dn lw mw mx dp ma kn my mz me kr na nb mi kv nc nd mm ne bi translated">键盘事件</h2><p id="8f88" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">首先我们需要解决获得圆形<strong class="ke ir">标签</strong>和<strong class="ke ir">移动</strong> + <strong class="ke ir">标签</strong>焦点的问题。使用健壮的选择器对于找到所有可以接受焦点的DOM元素是必不可少的。有七种常用的HTML元素可以获得焦点，如下所示。额外的修改需要插入一些特性。<strong class="ke ir">按钮</strong>和<strong class="ke ir">输入</strong>只有在<em class="nl">未禁用</em>或<em class="nl">只读</em>时才能选择。最后，我们不应该选择任何有负的tabindex的元素。我们可以利用CSS <strong class="ke ir"> :not() </strong>选择器轻松选择这些组件。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="97bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦我们有了所有键盘可访问的元素，我们就可以检查焦点当前是放在第一个还是最后一个元素上。根据按下的组合键，我们可以循环移动。</p><p id="e08f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Event.key </strong>应该用来确定一个键是否被按下。然而，当组合键时，<strong class="ke ir"> event.key </strong>将转发最后触发的事件。幸运的是，我们不必为<strong class="ke ir"> shift </strong> + <strong class="ke ir"> tab </strong>的情况定义复杂的逻辑。我们可以简单的使用目前所有浏览器都支持的<a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/shiftKey" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> event.shiftKey </strong> </a>。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f47d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您会注意到，当按下<strong class="ke ir"> Escape </strong>键时，会调用<strong class="ke ir"> onClose() </strong>函数，而不会将焦点移动到trigger元素。相反，我们将该逻辑移到了<strong class="ke ir"> componentWillUnmount() </strong>生命周期方法中。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="f922" class="mt lr iq bd ls mu mv dn lw mw mx dp ma kn my mz me kr na nb mi kv nc nd mm ne bi translated">式样</h2><p id="45c9" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">我们已经用<strong class="ke ir"> px </strong>值的四舍五入近似值替换了所有相对单位。请避免在css实现中使用硬编码像素。如您所见，我们正在利用<em class="nl">。SCSS </em>轻松连接类名。</p><p id="f259" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尺寸定义直接引用自<a class="ae nk" href="https://primer.style/css/support/breakpoints" rel="noopener ugc nofollow" target="_blank"> Github的初级</a>设计系统。更具体地说，我们使用相同的断点来调整维度。虽然，这里没有实现移动友好代码，但是可以根据你自己的断点推断出来。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="5550" class="mt lr iq bd ls mu mv dn lw mw mx dp ma kn my mz me kr na nb mi kv nc nd mm ne bi translated">情态的</h2><p id="90f6" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">下面可以看到完整的模态植入。</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="e7d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们决定使用<strong class="ke ir"> this.props.children </strong>来呈现对话框中的内容。这简化了我们的代码库，然而，根据开发人员的使用情况，它可能会引入副作用。我们建议您使用函数，而不是直接传递子级，以便更好地控制实现。</p><p id="f084" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，我们正在使用所有相关的aria属性使对话框可访问，从而满足上述要求。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="2572" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="65a3" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">我们已经探索了窗口对话框及其含义的多个方面。从键盘可访问性到实现细节等等。要时刻注意使用模态，因为它们会对用户流造成干扰。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="fcf4" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">参考</h1><ul class=""><li id="7ffb" class="nm nn iq ke b kf mo kj mp kn od kr oe kv of kz og ns nt nu bi translated"><a class="ae nk" href="https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal" rel="noopener ugc nofollow" target="_blank"> WAI-ARIA创作实践1.1 </a></li><li id="da25" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz og ns nt nu bi translated"><a class="ae nk" href="https://material.io/components/dialogs#anatomy" rel="noopener ugc nofollow" target="_blank">对话框解剖-材料设计</a></li><li id="ad79" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz og ns nt nu bi translated"><a class="ae nk" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">门户—反应</a></li><li id="276e" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz og ns nt nu bi translated"><a class="ae nk" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/shiftKey" rel="noopener ugc nofollow" target="_blank">keyboard event . shift key—Web API | MDN</a></li><li id="6db7" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz og ns nt nu bi translated"><a class="ae nk" href="https://primer.style/css/support/breakpoints" rel="noopener ugc nofollow" target="_blank">断点—初级CSS </a></li></ul></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="2b7f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae nk" href="http://www.linkedin.com/in/george-argyrousis" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">George Argyrousis</strong></a>——<em class="nl">高级软件工程师，沟通前端工程和UI/UX设计。高度专注于基于JavaScript的网络应用。</em></p></div></div>    
</body>
</html>