<html>
<head>
<title>Puzzling in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的困惑</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/puzzling-in-go-be2b51039cda?source=collection_archive---------11-----------------------#2020-03-19">https://levelup.gitconnected.com/puzzling-in-go-be2b51039cda?source=collection_archive---------11-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a7395e32f711360b20b3e9f13e10dd14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kju8hXNQtomwye0r1v-qDQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">标志归功于golang.org</figcaption></figure><div class=""/><p id="c528" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用Go通过回溯解决一个难题。</p><p id="6090" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最近给女儿买了个拼图。这不是一个普通的谜题，它被称为<a class="ae ld" href="https://www.amazon.com/Triazzle-Brain-Teaser-Puzzle-Pollinators/dp/B07D4MZK62" rel="noopener ugc nofollow" target="_blank"> Triazzle </a>，其特点是三角形的碎片平铺在三角形的板上。有趣的是，拼图图像是蜜蜂和蝴蝶的图案，因此在任何三角形的边缘，它都以标准的方式将生物分开。例如，一个三角形的边上有一只大蜜蜂飞出，另一个边上有一只小蜜蜂进入，这样这两个边就很匹配。结果是所有的边缘图案必须匹配以“解决”该难题。我们做了一次，然后我们对有多少实际解(和无解)感到好奇。让我们弄清楚。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c24653ed351b01e81cd352fd449c1190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcbQ5W_tb3CpmQfObjhthw.png"/></div></div></figure><p id="eae8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在高层次上，有16个三角形的棋子可以放在棋盘上的16个位置。所以，重温一下你的数学技能，这里有16种阶乘排列。每个棋子可以旋转到3个不同的方向(它们是等边三角形)，这意味着每个位置的棋子有3个⁶方向。这是*巨大的* 16！是20，922，789，888，000，3 ⁶是43，046，721。将两者相乘，你就得到了<strong class="kh jj"> 9.006574988503573e20 </strong>棋盘的可能配置。</p><h1 id="1af8" class="li lj ji bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">抓住问题</h1><p id="a0d7" class="pw-post-body-paragraph kf kg ji kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">我们将从拼图建模开始；我们需要以数字方式捕获数据结构中的难题，这样我们就可以有计划地对其采取行动。我们将首先定义一些有助于我们命名结构的术语。</p><p id="cf82" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj">谜题</strong>有如下内容:</p><ul class=""><li id="fe98" class="ml mm ji kh b ki kj km kn kq mn ku mo ky mp lc mq mr ms mt bi translated">十六个三角形<strong class="kh jj">件。</strong></li><li id="7287" class="ml mm ji kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">一个<strong class="kh jj">棋盘</strong>由十六个<strong class="kh jj">棋子</strong>组成，一个棋子是棋盘上放置棋子的位置。</li><li id="2e56" class="ml mm ji kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">板子有三十个<strong class="kh jj">边，每个边有两个<strong class="kh jj">边</strong>。每个瓷砖有3条边，其中一条边位于瓷砖片的内部。</strong></li><li id="25d8" class="ml mm ji kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">十二条边形成拼图<strong class="kh jj">边框。</strong></li></ul><p id="d6c1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将对组件进行任意编号，这样我们就可以在代码中捕获几何图形。</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/1f22e03b0178193d7931b8d3e726ed4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORuUr_lqOXOyIpVHG32WTw.png"/></div></div></figure><p id="7125" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这为我们如何构建数据结构提供了蓝图。首先，让我们确定需要匹配的不同模式。因为每一个都被一条边分开，所以我们在瓷砖上有一半。我对这些模式的简单描述是:</p><p id="d8a7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">左右大蜜蜂，前后大蜜蜂，小蜜蜂，条纹蝴蝶，蓝蝴蝶，粉蝴蝶。六种不同的独特模式，每一种都分成两半，所以我们只对它们使用一组常量。</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="6cf4" class="nf lj ji nb b gy ng nh l ni nj">package main</span><span id="106a" class="nf lj ji nb b gy nk nh l ni nj">import (<br/>    "fmt"<br/>    "math"<br/>    "time"<br/>)</span><span id="e022" class="nf lj ji nb b gy nk nh l ni nj">//Unique patterns to match, each bisected side<br/>const (<br/>    lBigBee     = iota //Left of Big Bee<br/>    rBigBee            //Right of Big Bee<br/>    fBigBee            //Front of Big Bee<br/>    bBigBee            //Back of Big Bee<br/>    fLittleBees        //Front of Little Bees<br/>    bLittleBees        //Back of Little Bees<br/>    fStripeBfly        //Front of Stripe Butterfly<br/>    bStripeBfly        //Back of Stripe Butterfly<br/>    lBlueBfly          //Left of Blue Butterfly<br/>    rBlueBfly          //Right of Blue Butterfly<br/>    fPinkBfly          //Front of Pink Butterfly<br/>    bPinkBfly          //Back of Pink Butterfly<br/>)</span></pre><p id="f9e3" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们考虑一下，我们想问程序和数据结构什么问题。立刻，一个重要的问题浮现在脑海:我们所有的边都匹配吗？我们可以将其分解为“边缘匹配吗？”我们需要一个数据结构来捕捉边上的两边，这样我们就可以确定匹配。我们需要问的另一个问题是:所有作品的位置和方向是什么？我们所说的位置是指每个棋子在棋盘上的位置，有16种不同的位置。所谓方向，我们指的是它们是如何旋转的，因为每一个三角形都可以被定位在三个不同的位置。因此，每个瓷砖可以包含一块与位置和方向，我们必须能够比较每个边缘。</p><p id="64bc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的数据结构(和数据)看起来像:</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="b9f9" class="nf lj ji nb b gy ng nh l ni nj">//Each pattern can extend onto the border<br/>//so need to initialize the outside puzzle border<br/>var border = [12]int{bBigBee, bStripeBfly, fLittleBees, bStripeBfly, lBlueBfly, lBigBee, fPinkBfly, bLittleBees, bPinkBfly, rBlueBfly, fBigBee, fPinkBfly}</span><span id="975b" class="nf lj ji nb b gy nk nh l ni nj">//Traingular puzzle pieces<br/>var pieces = [16][3]int{<br/>    {fLittleBees, fPinkBfly, lBlueBfly},     //0<br/>    {fBigBee, lBlueBfly, bPinkBfly},         //1<br/>    {bPinkBfly, fBigBee, lBigBee},           //2<br/>    {bBigBee, fPinkBfly, rBigBee},           //3<br/>    {bStripeBfly, bStripeBfly, rBigBee},     //4<br/>    {fBigBee, bPinkBfly, bPinkBfly},         //5<br/>    {fStripeBfly, rBigBee, bBigBee},         //6<br/>    {lBlueBfly, rBlueBfly, lBigBee},         //7<br/>    {fStripeBfly, rBlueBfly, lBigBee},       //8<br/>    {bPinkBfly, fPinkBfly, lBlueBfly},       //9<br/>    {fStripeBfly, rBlueBfly, lBlueBfly},     //10<br/>    {fStripeBfly, fStripeBfly, rBlueBfly},   //11<br/>    {rBigBee, bLittleBees, rBlueBfly},       //12<br/>    {fPinkBfly, bPinkBfly, fLittleBees},     //13<br/>    {fPinkBfly, bBigBee, fLittleBees},       //14<br/>    {bLittleBees, bLittleBees, bStripeBfly}, //15<br/>}</span><span id="a69f" class="nf lj ji nb b gy nk nh l ni nj">//Each edge of a tile refers to the edge list<br/>//and identifies which side faces inward to the tile<br/>type Tile struct {<br/>    edgeRef [3]int<br/>    sideRef [3]int<br/>}</span><span id="20aa" class="nf lj ji nb b gy nk nh l ni nj">var board = [16]Tile{<br/>    {[3]int{11, 0, 12}, [3]int{1, 1, 1}},  //0<br/>    {[3]int{10, 13, 15}, [3]int{1, 0, 1}}, //1<br/>    {[3]int{13, 12, 14}, [3]int{1, 0, 1}}, //2<br/>    {[3]int{14, 1, 16}, [3]int{0, 1, 1}},  //3<br/>    {[3]int{9, 17, 21}, [3]int{1, 0, 1}},  //4<br/>    {[3]int{17, 15, 18}, [3]int{1, 0, 1}}, //5<br/>    {[3]int{18, 19, 22}, [3]int{0, 1, 1}}, //6<br/>    {[3]int{19, 16, 20}, [3]int{0, 0, 1}}, //7<br/>    {[3]int{20, 2, 23}, [3]int{0, 1, 1}},  //8<br/>    {[3]int{8, 24, 7}, [3]int{1, 0, 1}},   //9<br/>    {[3]int{24, 21, 25}, [3]int{1, 0, 1}}, //10<br/>    {[3]int{25, 26, 6}, [3]int{0, 1, 1}},  //11<br/>    {[3]int{26, 22, 27}, [3]int{0, 0, 1}}, //12<br/>    {[3]int{27, 28, 5}, [3]int{0, 1, 1}},  //13<br/>    {[3]int{28, 23, 29}, [3]int{0, 0, 1}}, //14<br/>    {[3]int{29, 3, 4}, [3]int{0, 1, 1}},   //15<br/>}</span><span id="aafc" class="nf lj ji nb b gy nk nh l ni nj">//Keep track of pieces as they are used<br/>type PieceStatus struct {<br/>    tileRef int<br/>}</span><span id="d0d8" class="nf lj ji nb b gy nk nh l ni nj">var pieceStatus [16]PieceStatus</span><span id="7f67" class="nf lj ji nb b gy nk nh l ni nj">//Keep track of tiles as they are used<br/>type TileStatus struct {<br/>    pieceRef int<br/>    rotation int<br/>}</span><span id="c987" class="nf lj ji nb b gy nk nh l ni nj">var tileStatus [16]TileStatus</span><span id="3c3b" class="nf lj ji nb b gy nk nh l ni nj">//Keep track of edges as they are used<br/>type Edge struct {<br/>    side [2]int<br/>}</span><span id="265f" class="nf lj ji nb b gy nk nh l ni nj">var edgeStatus [30]Edge</span></pre><h1 id="ea44" class="li lj ji bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">蛮力</h1><p id="321d" class="pw-post-body-paragraph kf kg ji kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">强力解决方案适用于小问题，通常也是最简单的方法，但是问题很快就会变得不可行。我们的搜索空间9.0e20非常大，因此在我们花大量时间研究这种方法之前，我们将确定暴力解决方案是否有任何意义。我们需要一些基本的螺母和螺栓功能来解决这个问题。然后，我们将设置所有瓷砖的一个位置，经历4300万次旋转并计时。</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="5ada" class="nf lj ji nb b gy ng nh l ni nj">//=== Helper functions ===</span><span id="8990" class="nf lj ji nb b gy nk nh l ni nj">//Clear all status, and set the border<br/>func initBoard() {<br/>    fmt.Println("Initialize Board")<br/>    for i, _ := range edgeStatus {<br/>        edgeStatus[i].side[0] = -1<br/>        edgeStatus[i].side[1] = -1<br/>    }<br/>    for i, _ := range tileStatus {<br/>        tileStatus[i].pieceRef = -1<br/>        tileStatus[i].rotation = -1<br/>    }<br/>    for i, _ := range pieceStatus {<br/>        pieceStatus[i].tileRef = -1<br/>    }<br/>    for i, _ := range border {<br/>        edgeStatus[i].side[0] = border[i]<br/>    }<br/>}</span><span id="1186" class="nf lj ji nb b gy nk nh l ni nj">//Print current tiles on the board<br/>func printBoard() {<br/>    fmt.Println("======================")<br/>    fmt.Println("Board: ")<br/>    for i, v := range tileStatus {<br/>        if v.pieceRef == -1 {<br/>            fmt.Printf("Tile: %d: No Tile\n", i)<br/>        } else {<br/>            fmt.Printf("Tile: %d: = piece: %d\n", i, v.pieceRef)<br/>        }<br/>    }<br/>    fmt.Println("======================")<br/>}</span><span id="f344" class="nf lj ji nb b gy nk nh l ni nj">//Check 2 edges for a bisected match of same pattern<br/>func edgeMatch(edge1, edge2 int) bool {<br/>    if ((edge1 / 2) == (edge2 / 2)) &amp;&amp; (edge1 != edge2) {<br/>        return true<br/>    }<br/>    return false<br/>}</span><span id="807c" class="nf lj ji nb b gy nk nh l ni nj">//Check if all edges match (solution)<br/>func allEdgesMatch() bool {<br/>    for i, _ := range edgeStatus {</span><span id="068e" class="nf lj ji nb b gy nk nh l ni nj">if ((edgeStatus[i].side[0] == -1) || (edgeStatus[i].side[1] == -1)) || !edgeMatch(edgeStatus[i].side[0], edgeStatus[i].side[1]) {<br/>            return false<br/>        }<br/>    }<br/>    return true<br/>}</span><span id="4903" class="nf lj ji nb b gy nk nh l ni nj">//Place a rotated piece at tile location, update appropriate status<br/>func placePiece(piece int, tile int, rot int) {<br/>    // fmt.Println("Placing piece: ", piece, " on tile: ", tile, "rot: ", rot)<br/>    tileStatus[tile].pieceRef = piece<br/>    tileStatus[tile].rotation = rot<br/>    pieceStatus[piece].tileRef = tile<br/>    rotPiece := rotate(pieces[piece][0:], rot)<br/>    for i, v := range rotPiece {<br/>        edgeStatus[board[tile].edgeRef[i]].side[board[tile].sideRef[i]] = v<br/>    }<br/>}</span><span id="d7cf" class="nf lj ji nb b gy nk nh l ni nj">//Remove a piece from board, clear appropriate status<br/>func removePiece(tile int) {<br/>    // fmt.Println("&gt;&gt;Removing ", tile)<br/>    for i := 0; i &lt; 3; i++ {<br/>        edgeStatus[board[tile].edgeRef[i]].side[board[tile].sideRef[i]] = -1<br/>    }<br/>    pieceStatus[tileStatus[tile].pieceRef].tileRef = -1<br/>    tileStatus[tile].pieceRef = -1<br/>    tileStatus[tile].rotation = -1<br/>}</span><span id="98f0" class="nf lj ji nb b gy nk nh l ni nj">//Rotate a piece that is already placed on the board<br/>func rotatePiece(tile int) {<br/>    if tileStatus[tile].pieceRef == -1 {<br/>        return<br/>    }<br/>    tileStatus[tile].rotation = (tileStatus[tile].rotation + 1) % 3<br/>    for i, v := range pieces[tileStatus[tile].pieceRef] {<br/>        offset := (i + tileStatus[tile].rotation) % 3<br/>        edgeStatus[board[tile].edgeRef[offset]].side[board[tile].sideRef[offset]] = v<br/>    }<br/>}</span><span id="660a" class="nf lj ji nb b gy nk nh l ni nj">//Tests a piece for a match at a tile location in all 3 rotations<br/>//Returns rot &gt;=0 if match or -1 if no match<br/>func checkMatch(piece int, tile int) int {<br/>    for rot := 0; rot &lt; 3; rot++ {<br/>        match := true<br/>        rotPiece := rotate(pieces[piece][0:], rot)<br/>        for edge := 0; edge &lt; 3; edge++ {<br/>            adj := tileEdgeAdjacent(tile, edge)<br/>            if (adj != -1) &amp;&amp; (!edgeMatch(rotPiece[edge], adj)) {<br/>                match = false<br/>                break<br/>            }<br/>        }<br/>        if match {<br/>            return rot<br/>        }<br/>    }<br/>    return -1<br/>}</span><span id="e5d3" class="nf lj ji nb b gy nk nh l ni nj">//Return the edge pattern on the outside ede of a tile<br/>func tileEdgeAdjacent(tile int, edge int) int {<br/>    otherSide := (board[tile].sideRef[edge] + 1) % 2<br/>    return edgeStatus[board[tile].edgeRef[edge]].side[otherSide]<br/>}</span><span id="ba02" class="nf lj ji nb b gy nk nh l ni nj">//Return factorial of a number<br/>func factorial(n uint64) (result uint64) {<br/>    if n &gt; 0 {<br/>        result = n * factorial(n-1)<br/>        return result<br/>    }<br/>    return 1<br/>}</span><span id="66f0" class="nf lj ji nb b gy nk nh l ni nj">//Return rotated slice of ints<br/>func rotate(nums []int, k int) []int {<br/>    if k &lt; 0 || len(nums) == 0 {<br/>        return nums<br/>    }<br/>    r := len(nums) - k%len(nums)<br/>    nums = append(nums[r:], nums[:r]...)<br/>    return nums<br/>}</span><span id="e8da" class="nf lj ji nb b gy nk nh l ni nj">//=== Brute Force (one) ===</span><span id="c135" class="nf lj ji nb b gy nk nh l ni nj">//Place all tiles on the board and then permute all rotations<br/>//for a time check of one placement (not full brute force)<br/>func bruteForceOne() {<br/>    //Just one placement to do a time check on the rotations (n! more to go)<br/>    fmt.Println("One tile placement")<br/>    for i, _ := range pieces {<br/>        placePiece(i, i, 0)<br/>    }<br/>    permuteRot()<br/>}</span><span id="872a" class="nf lj ji nb b gy nk nh l ni nj">//perform all 3^16 rotations of the tiles in one placement, checking each board for full match<br/>func permuteRot() {<br/>    count := int64(math.Pow(3, 16))<br/>    fmt.Println("Checking ", count, " permutations")<br/>    for i := int64(0); i &lt; count; i++ {<br/>        carry := true<br/>        for k := 0; k &lt; 16; k++ {<br/>            if carry {<br/>                tileStatus[k].rotation++<br/>                if tileStatus[k].rotation == 3 {<br/>                    tileStatus[k].rotation = 0<br/>                    rotatePiece(k)<br/>                } else {<br/>                    carry = false<br/>                }<br/>            } else {<br/>                break<br/>            }<br/>        }<br/>        if allEdgesMatch() {<br/>            fmt.Println("&gt;&gt;SOLUTION&lt;&lt;")<br/>            printBoard()<br/>        }<br/>    }<br/>}</span><span id="2787" class="nf lj ji nb b gy nk nh l ni nj">func main() {<br/> fmt.Println("==================PUZZLE: Brute Force (one) ==================")<br/> start := time.Now()<br/> initBoard()<br/> bruteForceOne()<br/> end := time.Now()<br/> scaledDuration := int64(end.Sub(start) / time.Millisecond)<br/> fmt.Printf("Calculation finished in %d milliseconds\n", scaledDuration)<br/> f := factorial(16)<br/> years := (float64(f) * float64(scaledDuration)) / (1000.0 * 60 * 60 * 24 * 365)<br/> fmt.Printf("Doing that 16! times would take: %.0f years\n\n", years)<br/>}</span></pre><p id="8ae7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在准备在一个位置上进行第一次强力运行，作为时间检查。</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="903b" class="nf lj ji nb b gy ng nh l ni nj">&gt;puzzle<br/>==================PUZZLE: Brute Force (one) ==================<br/>Initialize Board<br/>One tile placement<br/>Checking  43046721  permutations<br/>Calculation finished in 891 milliseconds<br/>Doing that 16! times would take: 591140 years</span></pre><p id="c82a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">哇哦。一次放置和随后的旋转需要891毫秒。再次召唤你的数学技能:每次放置0.891秒乘以16！位置将带我们:16！* 0.891 / (60秒/分* 60分/小时* 24小时/天* 365天/年)= 591，140年。嗯，那不行..很确定这台mac活不了那么久。我们需要一个新的策略，或者量子计算机。</p><h1 id="79fa" class="li lj ji bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">递归回溯</h1><p id="07c0" class="pw-post-body-paragraph kf kg ji kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">人类实际上是如何解决这个难题的？我们解决这个问题的方法是，首先对所有的碎片进行排序，找出哪些碎片会进入三角形的各个点，因为这些点是两条边相交时最受约束的地方。事实证明，实际上只有三个片段可以进入点位置(图中的0，9，15 ),这很好。如果第一个图块位置只有三块，则原始搜索空间减少了12 * 15！，或15692092416000配售。根据我们之前的蛮力一次放置时间测量，我们的蛮力cpu运行时间缩短了443，355年。现在，我们有进展了。</p><p id="a6fd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">事实证明，人类的行为很像经典的CS算法，回溯算法。我们寻找一个有约束的位置，帮助我们减少搜索空间，放置那个片段，并在其上进行构建。如果我们走进一个死胡同，我们不能再往前走了，那么我们就拿走最后一块，尝试一块新的..回溯。回溯对于这一点是很好的，因为它自然地分支切割，允许大部分潜在的解决方案空间被避免。这种解法几乎是在乞求递归，不是吗？</p><p id="6b7f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">递归回溯的一般模式是:</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="8db8" class="nf lj ji nb b gy ng nh l ni nj">func backtrack(item) {<br/>    if item &lt; 0 {<br/>        printSolution()<br/>        return<br/>    }<br/>    for choice := len(choices) -1; choice &gt;=0; choice-- {<br/>        if goodChoice(choices[choice]) {<br/>            saveItemToSolution(items[item])<br/>            bactrack(item - 1)<br/>            deleteItemFromSolution(items[item])<br/>        }<br/>    }<br/>}</span></pre><p id="4747" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们的谜题中，这意味着:</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="1ce1" class="nf lj ji nb b gy ng nh l ni nj">func backtrack(tile int) {<br/>    if tile &lt; 0 {<br/>        fmt.Println("&gt;&gt;SOLUTION&lt;&lt;")<br/>        printBoard()<br/>        return<br/>    }<br/>    for piece := len(pieces) - 1; piece &gt;= 0; piece-- {<br/>        if pieceStatus[piece].tileRef != -1 {<br/>            continue<br/>        }<br/>        rot := checkMatch(piece, tile)<br/>        if rot &gt;= 0 { //goodChoice<br/>            placePiece(piece, tile, rot)<br/>            backtrack(tile - 1)<br/>            removePiece(tile)<br/>        }<br/>    }<br/>}</span><span id="fc3d" class="nf lj ji nb b gy nk nh l ni nj">func main() {<br/>    fmt.Println("==================PUZZLE: Recursive Backtrack ==================")<br/>    start := time.Now()<br/>    initBoard()<br/>    backtrack(15)<br/>    end := time.Now()<br/>    scaledDuration := int64(end.Sub(start) / time.Microsecond)<br/>    fmt.Printf("Calculation finished in %d microseconds\n\n", scaledDuration)<br/>}</span></pre><p id="2b69" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们运行它。</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="7b11" class="nf lj ji nb b gy ng nh l ni nj">==================PUZZLE: Recursive Backtrack ==================<br/>Initialize Board<br/>&gt;&gt;SOLUTION&lt;&lt;<br/>======================<br/>Board:<br/>Tile: 0: = piece: 1<br/>Tile: 1: = piece: 14<br/>Tile: 2: = piece: 12<br/>Tile: 3: = piece: 8<br/>Tile: 4: = piece: 7<br/>Tile: 5: = piece: 9<br/>Tile: 6: = piece: 5<br/>Tile: 7: = piece: 0<br/>Tile: 8: = piece: 15<br/>Tile: 9: = piece: 13<br/>Tile: 10: = piece: 3<br/>Tile: 11: = piece: 2<br/>Tile: 12: = piece: 6<br/>Tile: 13: = piece: 4<br/>Tile: 14: = piece: 11<br/>Tile: 15: = piece: 10<br/>======================<br/>Calculation finished in 199 microseconds</span></pre><p id="504b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在有了一个在199微秒内运行的解决方案——比我们的蛮力快9.36e16倍。我们也找到了最初问题的答案——这个难题只有一个解决方案。</p><p id="61e9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们能做得更好吗？为了优化性能或内存，人们通常喜欢将递归代码转换为非递归代码。现在让我们做一个非递归版本。</p><h1 id="b92c" class="li lj ji bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">非递归回溯</h1><p id="168d" class="pw-post-body-paragraph kf kg ji kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">幸运的是，我们的tileStatus结构有点像一个自然的堆栈，因为它保存了我们在递减计数时测试的最后一个块id。因此，如果我们只是创建一个指向当前图块的堆栈指针，我们可以手动管理我们自己的堆栈，并使用上面递归算法的基本模式。</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="df7f" class="nf lj ji nb b gy ng nh l ni nj">//=== Non-Recursive Backtrack ===</span><span id="5bd0" class="nf lj ji nb b gy nk nh l ni nj">func nrBacktrack(tile int) {<br/>    for stackPtr := tile; ; {<br/>        if stackPtr &lt; 0 {<br/>            fmt.Println("&gt;&gt;SOLUTION&lt;&lt;")<br/>            printBoard()<br/>        }<br/>        for piece := len(pieces) - 1; ; piece-- {<br/>            if piece &lt; 0 {<br/>                stackPtr++           //pop stack<br/>                if stackPtr &gt; tile { //all done<br/>                    return<br/>                }<br/>                piece = tileStatus[stackPtr].pieceRef<br/>                removePiece(stackPtr)<br/>                continue<br/>            }<br/>            if pieceStatus[piece].tileRef != -1 {<br/>                continue<br/>            }<br/>            rot := checkMatch(piece, stackPtr)<br/>            if rot &gt;= 0 { //goodChoice<br/>                placePiece(piece, stackPtr, rot) //push stack<br/>                stackPtr--<br/>                break<br/>            }<br/>        }<br/>    }<br/>}</span><span id="b5df" class="nf lj ji nb b gy nk nh l ni nj">func main() {<br/>    fmt.Println("==================PUZZLE: Non-Recursive Backtrack ==================")<br/>    start := time.Now()<br/>    initBoard()<br/>    nrBacktrack(15)<br/>    end := time.Now()<br/>    scaledDuration := int64(end.Sub(start) / time.Microsecond)<br/>    fmt.Printf("Calculation finished in %d microseconds\n", scaledDuration)<br/>}</span></pre><p id="9ec9" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们运行这个版本。</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="72ee" class="nf lj ji nb b gy ng nh l ni nj">==================PUZZLE: Non-Recursive Backtrack ==================<br/>Initialize Board<br/>&gt;&gt;SOLUTION&lt;&lt;<br/>======================<br/>Board:<br/>Tile: 0: = piece: 1<br/>Tile: 1: = piece: 14<br/>Tile: 2: = piece: 12<br/>Tile: 3: = piece: 8<br/>Tile: 4: = piece: 7<br/>Tile: 5: = piece: 9<br/>Tile: 6: = piece: 5<br/>Tile: 7: = piece: 0<br/>Tile: 8: = piece: 15<br/>Tile: 9: = piece: 13<br/>Tile: 10: = piece: 3<br/>Tile: 11: = piece: 2<br/>Tile: 12: = piece: 6<br/>Tile: 13: = piece: 4<br/>Tile: 14: = piece: 11<br/>Tile: 15: = piece: 10<br/>======================<br/>Calculation finished in 166 microseconds</span></pre><p id="a5a2" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">稍微快一点，但是在误差范围内，事实上后续运行可能会以两种方法都更快而告终。</p><p id="9da1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">获取所有代码:</p><pre class="le lf lg lh gt na nb nc nd aw ne bi"><span id="73f4" class="nf lj ji nb b gy ng nh l ni nj">go get github.com/exyzzy/puzzle</span></pre><p id="f0a3" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">【https://github.com/exyzzy/puzzle T2】号</p><p id="2d66" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们学会了如何将现实世界的问题捕获到数据和数据结构中，以便通过计算对其进行处理。为了解决我们的问题，我们探索了两种回溯方法。勇往直前，征服生活的困惑！</p></div></div>    
</body>
</html>