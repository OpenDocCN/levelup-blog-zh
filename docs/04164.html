<html>
<head>
<title>Getting Started with Server Side Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器端Kotlin入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-server-side-kotlin-cc207fda255e?source=collection_archive---------6-----------------------#2020-06-12">https://levelup.gitconnected.com/getting-started-with-server-side-kotlin-cc207fda255e?source=collection_archive---------6-----------------------#2020-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="cc75" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">初学者指南</h2><div class=""/><div class=""><h2 id="5c0f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用JetBrain的Ktor框架</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/70b79cf22663240d381e239eeceeabb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNxCDPtVOGtnMReCpe-_5Q.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由大卫·伊斯坎德尔在Unsplash上拍摄</figcaption></figure><p id="e7ee" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi md translated">otlin的第一个稳定版本1.0于2016年发布，从那时起我们见证了它给游戏带来的简单性和有效性。谷歌宣布支持Kotlin作为Android平台上Java的替代方案，从那以后，Kotlin近年来吸引了很多关注。</p><p id="6ec2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">与Java类似，Kotlin编译成字节码，并且与JVM兼容，所以它可以像Java一样执行。它具有面向对象和函数式编程结构，并且完全可以与Java互操作。</p><p id="a9e3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，与其谈论代码可以有多干净和简洁，不如让我们看看它的实际应用。下面是Java和Kotlin中同一个类的对比</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mm"><img src="../Images/7d876dc8198becdbbcdd612a4aee5511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6zfl-J151iCagFCJwX3cQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">左边是Java类，右边是Kotlin数据类</figcaption></figure><p id="7ed6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这就是我们真正看到Kotlin潜力的地方，可以消除的无用代码的数量。</p><h1 id="332b" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">服务器端开发</h1><blockquote class="nf"><p id="dd4e" class="ng nh it bd ni nj nk nl nm nn no mc dk translated">Kotlin非常适合开发服务器端应用程序，它允许您编写简洁而富于表现力的代码，同时保持与现有的基于Java的技术堆栈的完全兼容性，以及平滑的学习曲线</p></blockquote><p id="6978" class="pw-post-body-paragraph lh li it lj b lk np kd lm ln nq kg lp lq nr ls lt lu ns lw lx ly nt ma mb mc im bi translated">有多个<a class="ae nu" href="https://kotlinlang.org/docs/reference/server-overview.html#frameworks-for-server-side-development-with-kotlin" rel="noopener ugc nofollow" target="_blank">框架</a>支持使用Kotlin进行服务器端开发。在本文中，我们将使用<a class="ae nu" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jd"> Ktor </strong> </a>作为服务器端框架。Ktor使我们能够创建可以运行和面向多个平台的客户端和服务器端应用程序。</p><h1 id="2b51" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">目标</h1><p id="26d7" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">到本文结束时，我们将为CRUD操作创建一些基本的RESTful APIs，并使用Ktor使用一个名为Netty的嵌入式服务器在本地托管它。</p><p id="7f75" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">需要一些Kotlin的基础知识，因为我们不会在本文中讨论Kotlin的基础知识。如果您有Java背景，这个GitHub页面提供了Java到Kotlin转换的备忘单</p><div class="oa ob gp gr oc od"><a href="https://github.com/MindorksOpenSource/from-java-to-kotlin" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jd gy z fp oi fr fs oj fu fw jc bi translated">MindorksOpenSource/从java到kotlin</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">从Java到Kotlin——Java到kot Lin的备忘单</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or lb od"/></div></div></a></div><h1 id="657d" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">入门指南</h1><p id="897a" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">让我们开始设置用于开发的智能集成开发环境</p><ol class=""><li id="a5fa" class="os ot it lj b lk ll ln lo lq ou lu ov ly ow mc ox oy oz pa bi translated">从<a class="ae nu" href="https://www.jetbrains.com/idea/download/" rel="noopener ugc nofollow" target="_blank">这里</a>下载并安装IntelliJ</li><li id="6bc2" class="os ot it lj b lk pb ln pc lq pd lu pe ly pf mc ox oy oz pa bi translated">打开IntelliJ，点击<em class="pg">配置</em>并选择<em class="pg">插件</em></li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/12d8e771721c2172447b41893a4cbcc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTr6nEAPLtR7GkUtxURCTA.png"/></div></div></figure><p id="8144" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">3.转到<em class="pg"> Marketplace </em>，搜索插件- <em class="pg"> Ktor </em>，安装，重启IDE。</p><p id="2330" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">4.继续并选择<em class="pg">创建新项目。</em></p><p id="c06b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">5.在下一个屏幕中，选择<em class="pg"> ApacheHttpClientEngine </em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/49d6081d27cd858b287e65a3b594d9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fa3Rf9iJwa7MEIJRZDRI5Q.png"/></div></div></figure><p id="e3dc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">6.单击Next并填写所有其他细节，如包名和项目位置，以完成项目的创建。</p><h1 id="bc06" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">“你好世界！”</h1><p id="8e92" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">Ktor中的“Hello World”应用程序如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="1742" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，我们创建了一个嵌入式服务器的实例，<a class="ae nu" href="https://netty.io/" rel="noopener ugc nofollow" target="_blank"> Netty </a>，并监听端口8080。</p><p id="df98" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe pl pm pn po b">routing</code>是在Ktor中安装路由的高阶函数。您可以检查实现以了解更多信息</p><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="e567" class="pt mo it po b gy pu pv l pw px"><em class="pg">/**<br/> * Gets or installs a [Routing] feature for the this [Application] and runs a [configuration] script on it<br/> */<br/></em>@ContextDsl<br/>fun Application.routing(configuration: Routing.() -&gt; Unit): Routing =<br/>    <em class="pg">featureOrNull</em>(Routing)?.<em class="pg">apply</em>(configuration) ?: <em class="pg">install</em>(Routing, configuration)</span></pre><p id="043b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<code class="fe pl pm pn po b">routing</code>块中，我们定义了一个路由来响应请求。因此，如果您在浏览器上访问LocalHost，服务器应该发送<strong class="lj jd"> Hello World！</strong>以纯文本形式。</p><p id="8655" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">继续在<em class="pg"> src下的<em class="pg"> Application.kt </em>文件中进行这些更改，然后</em>运行应用程序。现在，通过在浏览器中输入<a class="ae nu" href="http://127.0.0.1:8080/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8080/ </a>来点击localhost。</p><p id="d689" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这就是你在Ktor中创建第一个应用程序的方法！</p><h1 id="0384" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">构建应用程序</h1><p id="7e7c" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">最终，我们的应用程序中会有许多端点，虽然我们可以在<code class="fe pl pm pn po b">routing</code>块中添加多个函数，但为了更好的可读性，我们需要根据这些函数的目的对它们进行分组。</p><p id="fd2d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Ktor为我们提供了定义和组织路线的灵活性。我们可以创建文件夹，然后将每个端点放在自己的文件中，甚至按功能分组。</p><p id="3f88" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">多亏了Kotlin，我们还可以为<em class="pg"> Route </em>类创建扩展函数，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pj pk l"/></div></figure><h1 id="d6dd" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">路线层次结构</h1><p id="10ae" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">我们可以定义路由层次结构，每个路由本身定义一个新的URL</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="245d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这种情况下，访问URL将是<a class="ae nu" href="http://127.0.0.1:8080/customer/1" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/customer/1</a><br/>，其中“1”是“customerId”</p><p id="6088" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，我们使用<code class="fe pl pm pn po b">call.parameters</code>属性访问路由参数。</p><p id="b3fb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要访问查询字段，我们可以使用以下命令:</p><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="0c6d" class="pt mo it po b gy pu pv l pw px">call.respondText(call.request.queryParameters[“customerId”].toString())</span></pre><h1 id="75ca" class="mn mo it bd mp mq mr ms mt mu mv mw mx ki my kj mz kl na km nb ko nc kp nd ne bi translated">执行CRUD操作</h1><p id="77e8" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">考虑一个带有<em class="pg">客户</em>模型的示例应用程序。数据类如下所示:</p><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="2955" class="pt mo it po b gy pu pv l pw px">data class Customer(<br/>    val id: Int,<br/>    val firstName: String,<br/>    val lastName: String<br/>)</span></pre><p id="90d4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了简单起见，我们将在一个可变列表上执行所有的CRUD操作，该列表在下面提到的<em class="pg"> CustomerRepo </em>类中定义</p><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="181f" class="pt mo it po b gy pu pv l pw px">class CustomerRepo {<br/>    val customerList = <em class="pg">mutableListOf</em>&lt;Customer&gt;()<br/>}</span></pre><p id="f2eb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们在一个单独的文件中定义属于<em class="pg">客户路线</em>的所有路线，如下所述</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="f350" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，我们正在返回一个<em class="pg">响应</em>对象。响应对象是一个简单的数据类</p><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="e1fe" class="pt mo it po b gy pu pv l pw px">data class Response(<br/>    val message: String<br/>)</span></pre><p id="3116" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，我们通过在<em class="pg"> build.gradle </em>文件中添加以下依赖项，使用‘Gson’来处理应用程序中的JSON内容</p><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="3a2d" class="pt mo it po b gy pu pv l pw px">implementation "io.ktor:ktor-gson:$ktor_version"</span></pre><p id="1beb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该功能是一个<a class="ae nu" href="https://ktor.io/servers/features/content-negotiation.html" rel="noopener ugc nofollow" target="_blank">内容协商</a>转换器，可以通过以下方式安装</p><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="2656" class="pt mo it po b gy pu pv l pw px">fun main() {<br/>    val server = <em class="pg">embeddedServer</em>(Netty, port = 8080) <strong class="po jd">{<br/>        </strong><em class="pg">install</em>(ContentNegotiation) <strong class="po jd">{<br/>            </strong><em class="pg">gson </em><strong class="po jd">{<br/>                </strong>setPrettyPrinting()<br/>            <strong class="po jd">}<br/>        }<br/>        </strong>routing <strong class="po jd">{<br/>            </strong><em class="pg">customer</em>(customerRepo = CustomerRepo())<br/>        <strong class="po jd">}<br/>    }<br/>    </strong>server.start(wait = true)<br/>}</span></pre><p id="02a4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，如果您运行该应用程序，您应该能够通过使用<a class="ae nu" href="http://127.0.0.1:8080/customer" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/customer</a>作为基本URL，后跟您想要执行的操作的路径，来执行在<em class="pg"> CustomerRoute </em>中定义的所有操作。您可以通过任何可用的客户端访问这些端点，比如<a class="ae nu" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>。</p><p id="0376" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">以下是我们在<em class="pg"> CustomerRoute </em> </strong>中定义的所有URL的列表</p><ol class=""><li id="172d" class="os ot it lj b lk ll ln lo lq ou lu ov ly ow mc ox oy oz pa bi translated">获取所有记录-GET-<a class="ae nu" href="http://127.0.0.1:8080/customer" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/customer</a></li><li id="4e14" class="os ot it lj b lk pb ln pc lq pd lu pe ly pf mc ox oy oz pa bi translated">具体记录—获取—<a class="ae nu" href="http://127.0.0.1:8080/customer/1" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/customer/1</a><br/>其中customerId: 1</li><li id="08ee" class="os ot it lj b lk pb ln pc lq pd lu pe ly pf mc ox oy oz pa bi translated">创建新记录—发布—<a class="ae nu" href="http://127.0.0.1:8080/customer/create" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/customer/create</a></li></ol><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="db64" class="pt mo it po b gy pu pv l pw px">Post body: <br/> {<br/>  "id":"1",<br/>  "firstName":"Name",<br/>  "lastName":"Surname"<br/> }</span></pre><p id="5dbe" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">4.删除记录-删除-<a class="ae nu" href="http://127.0.0.1:8080/customer/delete/1" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/customer/DELETE/1</a><br/>其中customerId: 1</p><p id="d647" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">5.更新记录—上传—<a class="ae nu" href="http://127.0.0.1:8080/customer/update/1" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8080/customer/update/1</a><br/>其中customerId: 1</p><pre class="ks kt ku kv gt pp po pq pr aw ps bi"><span id="76f0" class="pt mo it po b gy pu pv l pw px">Put body: <br/> {<br/>  "id":"1",<br/>  "firstName":"Name",<br/>  "lastName":"Surname"<br/> }</span></pre></div><div class="ab cl py pz hx qa" role="separator"><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd"/></div><div class="im in io ip iq"><p id="e1a6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这就是本文的全部内容。在下一篇文章中，我们将探索如何使用协程并在Ktor中实现架构设计。敬请期待！</p><p id="32e0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可以在GitHub上找到示例存储库</p><div class="oa ob gp gr oc od"><a href="https://github.com/KunalChaubal/KtorCrudSample" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jd gy z fp oi fr fs oj fu fw jc bi translated">KunalChaubal/KtorCrudSample</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在GitHub上创建一个帐户，为KunalChaubal/KtorCrudSample的开发做出贡献。</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="qf l oo op oq om or lb od"/></div></div></a></div><p id="ca96" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">随意叉它/贡献它</p><p id="5ed2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">编码快乐！</p></div></div>    
</body>
</html>