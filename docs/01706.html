<html>
<head>
<title>TypeScript Indexable Type — Introduction to TypeScript Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript可索引类型—TypeScript接口简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-typescript-interfaces-indexable-types-d66958523518?source=collection_archive---------6-----------------------#2020-01-23">https://levelup.gitconnected.com/introduction-to-typescript-interfaces-indexable-types-d66958523518?source=collection_archive---------6-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/588cca6fb8089a52086ccdcea654bb0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HwKQsk1b3Py9kMR2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@samuelsngx?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> samuel sng </a>拍摄的照片</figcaption></figure><p id="2575" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与普通JavaScript相比，TypeScript的最大优势在于，它通过添加确保程序对象类型安全的功能来扩展JavaScript的特性。它通过检查对象所呈现的值的形状来做到这一点。</p><p id="2718" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查形状被称为鸭分型或结构分型。接口是在TypeScript中填充角色命名数据类型的一种方式。这对于在TypeScript程序的代码中定义契约非常有用。在上一篇文章中，我们研究了如何定义一个TypeScript接口，并向它添加必需的和可选的属性。在本文中，我们将继续研究TypeScript接口的其他属性，如可索引类型。</p><h1 id="b1f7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可索引类型</h1><p id="1d5f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以为数组这样的数据定义可索引类型。任何使用括号符号的对象，如数组和动态对象类型，都可以用可索引类型来指定。可索引类型有一个索引签名，它描述了我们可以用作对象索引的类型，以及对应索引的返回类型。这对于指定动态对象的类型非常方便。例如，我们可以设计一个只接受字符串的数组，如下面的代码所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="70fd" class="mq lf it mm b gy mr ms l mt mu">interface NameArray {<br/>    [index: number]: string;<br/>}</span><span id="90ff" class="mq lf it mm b gy mv ms l mt mu">let nameArray: NameArray = ["John", "Jane"];<br/>const john = nameArray[0];<br/>console.log(john);</span></pre><p id="4966" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们定义了<code class="fe mw mx my mm b">NameArray</code>接口，该接口接收类型为<code class="fe mw mx my mm b">number</code>的<code class="fe mw mx my mm b">index</code>作为索引签名，对应的索引签名的返回类型是字符串。然后，当我们指定一个类型为<code class="fe mw mx my mm b">NameArray</code>的变量时，我们可以使用索引来获取数组的条目。然而，对于这段代码，数组方法和操作符是不可用的，因为我们只有<code class="fe mw mx my mm b">[index: number]</code>索引签名，什么也没有，所以TypeScript编译器不知道它是一个数组，即使它看起来像一个人的眼睛。</p><p id="1c76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">索引签名支持两种类型。它们可以是字符串或数字。支持这两种类型的索引是可能的，但是从数字索引器返回的类型必须是字符串索引返回的类型的子类型。这是因为当JavaScript试图访问带有数字属性的条目或属性时，它会将数字索引转换为字符串。这确保了对于同一个索引可以返回不同的结果。</p><p id="2b39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面的代码会从TypeScript编译器中给我们一个错误:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8c40" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  name: string = '';<br/>}</span><span id="b254" class="mq lf it mm b gy mv ms l mt mu">class Cat extends Animal {<br/>  breed: string = '';<br/>}</span><span id="ed8e" class="mq lf it mm b gy mv ms l mt mu">interface Zoo {<br/>    [x: number]: Animal;<br/>    [x: string]: Cat;<br/>}</span></pre><p id="abda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们尝试编译上面的代码，我们会得到“数字索引类型‘Animal’不可分配给字符串索引类型‘Cat’”。(2413)".这是因为我们将<code class="fe mw mx my mm b">Cat</code>作为字符串索引的返回类型，它是<code class="fe mw mx my mm b">Animal</code>的子类型。我们不能这样做，因为如果我们有两个不同类型的索引签名，那么父类型必须是字符串类型的索引签名的返回类型，而数字类型的索引签名必须具有字符串索引签名返回的的子类型。这意味着如果我们翻转返回类型，那么代码将被编译并运行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4f2d" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  name: string = '';<br/>}</span><span id="a0bd" class="mq lf it mm b gy mv ms l mt mu">class Cat extends Animal {<br/>  breed: string = '';<br/>}</span><span id="3f26" class="mq lf it mm b gy mv ms l mt mu">interface Zoo {<br/>    [x: number]: Cat;<br/>    [x: string]: Animal;<br/>}</span></pre><p id="1caf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe mw mx my mm b">Animal</code>是<code class="fe mw mx my mm b">Cat</code>的超类型，我们必须将<code class="fe mw mx my mm b">Animal</code>作为字符串索引签名的返回类型，将<code class="fe mw mx my mm b">Cat</code>类型作为数字索引签名的返回类型。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/b148c271d5d19c51bb474f38edff1566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bQR7TcQ5XfLjWRfO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@nathalie_spehner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Nathalie SPEHNER </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ba12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">索引签名强制所有普通属性匹配它们的返回类型，除了那些被括号符号访问的属性，因为在JavaScript中<code class="fe mw mx my mm b">obj.prop</code>和<code class="fe mw mx my mm b">obj['prop']</code>是相同的。这意味着如果我们有以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6718" class="mq lf it mm b gy mr ms l mt mu">interface Dictionary {    <br/>  [x: string]: string;<br/>}</span><span id="f11b" class="mq lf it mm b gy mv ms l mt mu">let dict: Dictionary = {};<br/>dict.prop = 1;</span></pre><p id="98fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会得到错误“类型‘1’不可赋给类型‘string’。(2322)"因为我们指定所有属性都是类型为<code class="fe mw mx my mm b">Dictionary</code>的变量中的字符串。如果我们想在对象的属性中接受其他类型，我们必须使用联合类型。例如，我们可以编写以下接口，让具有给定类型的对象的属性接受字符串和数字作为值:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f55e" class="mq lf it mm b gy mr ms l mt mu">interface Dictionary {    <br/>  [x: string]: string | number;<br/>  num: number;<br/>}</span><span id="a31b" class="mq lf it mm b gy mv ms l mt mu">let dict: Dictionary = { num: 0 };</span></pre><p id="e029" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们接受<code class="fe mw mx my mm b">string</code>和<code class="fe mw mx my mm b">number</code>作为两种类型的值。因此，我们添加了一个类型为<code class="fe mw mx my mm b">number</code>的属性，而TypeScript编译器不会因错误而拒绝代码。因此，在上面代码的最后一行，我们可以向值为0的对象添加一个<code class="fe mw mx my mm b">num</code>属性。</p><p id="2477" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以创建一个索引签名<code class="fe mw mx my mm b">readonly</code>，这样我们就可以防止给它们的索引赋值。例如，我们可以使用以下代码将索引签名标记为只读:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6b1b" class="mq lf it mm b gy mr ms l mt mu">interface Dictionary {    <br/>  readonly [x: string]: string;  <br/>}</span><span id="feb2" class="mq lf it mm b gy mv ms l mt mu">let dict: Dictionary = {'foo': 'foo'};</span></pre><p id="92e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们试图给<code class="fe mw mx my mm b">dict['foo']</code>赋另一个值时，如下面的代码所示，TypeScript编译器将拒绝该代码，并且不会编译它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f4db" class="mq lf it mm b gy mr ms l mt mu">interface Dictionary {    <br/>  readonly [x: string]: string;  <br/>}</span><span id="7b31" class="mq lf it mm b gy mv ms l mt mu">let dict: Dictionary = {'foo': 'foo'};<br/>dict['foo'] = 'foo';</span></pre><p id="31d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们尝试编译上面的代码，我们会得到错误“类型‘Dictionary’中的索引签名只允许读取。(2542)".这意味着我们只能在初始化对象时设置只读属性的属性和值，但是后续的赋值将会失败。</p><h1 id="4229" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="287b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">可索引类型对于定义动态对象属性的返回值非常方便。它利用了这样一个事实，即我们可以通过使用括号符号来访问JavaScript属性。这对于那些名字无效的属性来说是很方便的，如果定义的时候没有括号符号或者任何我们希望能够通过括号符号访问的东西，我们希望对那些属性或者条目进行类型检查。对于可索引类型，我们确保由括号符号分配和设置的属性具有指定的类型。</p><p id="6edf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，这也适用于常规属性，因为括号符号与访问属性的点符号相同。此外，我们可以将索引签名指定为<code class="fe mw mx my mm b">readonly</code>,这样，当带有可索引类型的对象被初始化时，就可以写入索引签名，而不是在此之后。如果我们既有数字索引签名又有字符串索引签名，那么字符串索引签名的返回类型必须是数字索引签名的返回类型的超类型，这样我们在访问属性时就可以获得一致的对象类型。</p></div></div>    
</body>
</html>