<html>
<head>
<title>Design Code for Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试设计规范</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/art-of-unit-testing-with-swift-40bac64c1d9b?source=collection_archive---------8-----------------------#2021-11-22">https://levelup.gitconnected.com/art-of-unit-testing-with-swift-40bac64c1d9b?source=collection_archive---------8-----------------------#2021-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7313474e50a3f5f460af62eaff690a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZq7mjQ_p-RUROnFVVIWNA.png"/></div></div></figure><p id="c411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">单元测试</strong>是一种自动化测试，旨在验证一小部分孤立的代码(所谓的“单元”)是否如开发人员预期的那样运行。一个单独的单元测试被称为“<strong class="ka ir">测试用例</strong>”——由一段代码组成，这段代码以某种方式运行产品代码，然后验证结果是否与预期相符。</p><h1 id="f104" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么要进行单元测试？</h1><ul class=""><li id="9672" class="lu lv iq ka b kb lw kf lx kj ly kn lz kr ma kv mb mc md me bi translated">单元测试有助于在开发周期的早期修复错误并节省成本。</li><li id="b31a" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">降低脆弱性——对现有代码进行更改会破坏代码或流程的另一个工作部分，这可以在开发阶段使用适当的单元测试来降低和识别。</li><li id="8ea5" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">好的单元测试就像项目文档，测试中的代码片段更多地解释了如何使用类或函数，而不是一段文档。</li><li id="56ac" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">单元测试有助于代码重用。将代码和测试都迁移到新项目中。调整代码，直到测试再次运行。</li></ul><h1 id="d825" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">写作考试小技巧</h1><p id="b9c9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">在Swift中编写测试时，我通常遵循3个技巧。</p><ol class=""><li id="5040" class="lu lv iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mc md me bi translated">设计可测试的代码</li><li id="f19c" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mq mc md me bi translated">清晰的API边界</li><li id="6ae3" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mq mc md me bi translated">避免被实现细节所束缚</li></ol><p id="0fef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mr">注意:例子我使用过swift，但它不是特定于swift的，它更多的是关于为单元测试设计&amp;编码的函数式编程技巧。</em></p><h1 id="218c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设计可测试的代码</h1><p id="4dc2" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><code class="fe ms mt mu mv b">What makes a code easy to test?</code></p><p id="6914" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">据我所知，当我们不做大量的模拟或黑客攻击或复杂的设置来测试一个API行为时，测试就很容易了。比如你给ActivitiesPayloadResponse结构给ActivitiesViewModel，并从中获取视图数据，它可以是activities总计数测试用例或未读活动标题。</p><p id="953c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，我们没有像给出输入数据和验证输出那样简单的每个类或函数，有些地方我们需要做模拟和设置，但是让我们尽量保持它最小化。另一方面，想一想有人在回顾我们的测试，他不应该花超过30秒来理解它。</p><p id="96f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">设计可测试性代码的3个核心原则</strong></p><blockquote class="mw mx my"><p id="ecd4" class="jy jz mr ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">统一输入和统一输出</p></blockquote><p id="9767" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在函数式编程的世界里，有一个术语叫做纯函数，纯函数是一个接受输入并返回一个没有副作用的输出的函数，相同的输入每次都应该产生相同的预期输出，不管你调用它多少次。</p><blockquote class="mw mx my"><p id="3f28" class="jy jz mr ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">保持州的地方性</p></blockquote><p id="e743" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们倾向于在大多数地方使用singleton，因为它易于使用，苹果自己也在许多地方使用它，singleton可以很好地共享API和方便，但它也导致了共享状态的危险模式。</p><blockquote class="mw mx my"><p id="0068" class="jy jz mr ka b kb kc kd ke kf kg kh ki mz kk kl km na ko kp kq nb ks kt ku kv ij bi translated">依赖注射</p></blockquote><p id="99b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总是尝试注入在我们的类函数中使用的依赖对象，这意味着我们希望避免在我们的实现中作为共享实例访问那些对象，或者创建和访问本地实例。</p><p id="bff9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理论到此为止，让我们实际一点，我不能不做实验就推销这个话题。</p><p id="287c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用一个名为FileLoader的示例类来看看上述所有原则，感谢John Sundell从他的一次演讲中挑选了这些直观的例子。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/dd5a8fa6e6a04921c229576534cd808c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vzBYO8_9HFq1Qt9GKA1wQ.png"/></div></div></figure><p id="a2d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个相当不错的类，如果exist else抛出一个错误，它从主包中加载给定文件名的文件，并且缓存文件，这实际上很好，所以我们不用每次都从主包中加载。现在让我们将<code class="fe ms mt mu mv b"><strong class="ka ir">Code for Testability</strong></code>的设计应用到上面的类中，并检查它是否适合单元测试。</p><p id="292e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">统一输入/输出</strong></p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/b9378c64426dc3a1928e38d56abc0ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcNB5pMZoshGpkIcVe_srA.png"/></div></div></figure><p id="8fcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ms mt mu mv b">FileLoader</code>将filename作为输入，如果带有fileName的文件存在于主包中，则返回<code class="fe ms mt mu mv b">File</code>，否则抛出。但是如果你看到实现，这个函数有3种可能的结果。</p><ul class=""><li id="3631" class="lu lv iq ka b kb kc kf kg kj mn kn mo kr mp kv mb mc md me bi translated">一个文件存在的情况下，返回文件加载它或从缓存。</li><li id="e733" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">将文件转换为数据时，如果文件损坏，将引发foundationKit错误</li><li id="df76" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">如果文件不包含主包，我们抛出NSError。</li></ul><p id="af0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">肯定的是，这里的输出不统一，这不符合<code class="fe ms mt mu mv b"><strong class="ka ir">Unified Input/ Output</strong></code>原理</p><p id="1d0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">保持本地状态</strong></p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/9cc400d4b80abf025c5446e6a24ea0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wn0b8WEUYk_MeuTzGsD9xg.png"/></div></div></figure><p id="36dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ms mt mu mv b">FileLoader</code>包含共享实例或单例依赖，正如你所看到的Bundle.main和共享文件加载器，我们没有保持状态为本地。很明显，该函数不遵守<code class="fe ms mt mu mv b"><strong class="ka ir">Keep the State Local</strong></code>原理。</p><p id="bdf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖注入</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/805b300e33904a593ae924d88b1d6f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hz7xkmXupqOsbxNTsoRFCw.png"/></div></div></figure><p id="2b50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的<code class="fe ms mt mu mv b">FileLoader</code>依赖于两个对象，一个是缓存，另一个是捆绑包，正如你所看到的，它们都不是作为依赖注入的，而是本地访问或者使用单例访问，这让我们很难测试。</p><p id="2856" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很有趣，我们体面的<code class="fe ms mt mu mv b">FileLoader</code>类对于单元测试来说不再体面，所以让我们看看如何让它服从<code class="fe ms mt mu mv b"><strong class="ka ir">Code for Testability</strong></code></p><h1 id="5f86" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">应用可测试性原则的代码</h1><p id="dbd5" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">让我们一个一个来看，将努力使文件加载器遵守<code class="fe ms mt mu mv b">Unified Input/Output</code>原则。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/5d92fa1636aea0d204e5c77a872257d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwdVqvAJxRQzfmzfSUAY7w.png"/></div></div></figure><p id="dac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里你可以看到，<code class="fe ms mt mu mv b">FileLoader</code>有一个专用的错误类型，对于无效的文件名错误，它返回<code class="fe ms mt mu mv b">FileLoaderError.invalidFileName</code>，对于损坏的文件数据，它返回<code class="fe ms mt mu mv b">FileLoaderError.invalidFileData</code>，而以前我们是返回NSError，或者错误是从try数据(contentURL:)中抛出的，这种方式修改了代码，采用了统一的<code class="fe ms mt mu mv b">Input (FileName String)</code>和统一的<code class="fe ms mt mu mv b">Output (File or FileLoaderError)</code>。</p><p id="ad39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来让我们试着移除共享实例，我们真的需要<br/> <code class="fe ms mt mu mv b">static let shared = FileLoader()</code>吗</p><p id="2bae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多时候，我们使用它是因为它易于访问和使用，如果我们认为，我们可能不需要这里的单例，而是每个需要它的类都可以创建和获取文件加载操作，或者它可以作为引用传递给需要它的类。</p><p id="5df6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个是<code class="fe ms mt mu mv b">Dependancy Injection</code>，正如前面指出的，我们有2个依赖对象(缓存和绑定)供FileLoader使用。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/e7b3292f18dfbb6322abcd3cedced1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mixbO9DJDVLtkxmdJucXoA.png"/></div></div></figure><p id="08ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着这一变化，我们将依赖对象作为初始参数传递，因此这在我们为其编写单元测试时将非常有帮助，这不必是对象本身，如果需要，它可以是2个协议，而且由于我们支持默认参数，除了单元测试之外，FileLoader的用户不必担心注入的参数，他们仍然可以像FileLoader()一样创建。</p><p id="0bde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对代码做了很小的改动，现在文件加载器的种类已经从<code class="fe ms mt mu mv b"><strong class="ka ir">Hard to Test</strong></code> <strong class="ka ir"> → </strong> <code class="fe ms mt mu mv b"><strong class="ka ir">Easy to Test</strong></code>。既然我说测试很容易，你们相信我吗？不需要让我们为FileLoader写一些测试，看看它是否真的容易测试。</p><p id="6de5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将尝试测试我们想到的几个理想行为的缓存行为</p><ul class=""><li id="e09b" class="lu lv iq ka b kb kc kf kg kj mn kn mo kr mp kv mb mc md me bi translated">首次从捆绑包加载文件时，将文件保存到缓存中</li><li id="78f0" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">当文件已经存在于缓存中时，从缓存中检索文件。</li></ul><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/74ae43f50f7e8483cd30bf773fb1cb2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-R49QPJxKObT5LSeWuXR2Q.png"/></div></div></figure><p id="4613" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以有很多情况，只是挑选这些来解释与缓存的依赖注入相关的东西。</p><ul class=""><li id="47f1" class="lu lv iq ka b kb kc kf kg kj mn kn mo kr mp kv mb mc md me bi translated">第一个测试用例是对FileLoader加载的文件是否保存到缓存中进行单元测试。因为我们的文件加载器的一个很酷的特性是，它可以缓存从主包中加载的文件。</li><li id="e31b" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">第二个测试用例是单元测试，如果FileLoader访问的文件是从缓存中检索的，假设我们已经有包含相同文件的依赖缓存并注入到FileLoader中，现在如果FileLoader访问文件，它应该从缓存中返回文件，而不是从主包中加载。</li></ul><h1 id="6c07" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">清晰的API边界</h1><p id="b1ae" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">当我们通常编写测试时，我们倾向于编写两种类型，1是单元测试，我们验证API是否正确工作，根据给定的输入验证输出，另一个测试是我们实际集成模块并进行集成测试。</p><p id="563a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多时候，很难确定单元测试和集成测试之间的明确界限。如果我们看看<strong class="ka ir">迈克尔·费哲</strong>(<code class="fe ms mt mu mv b">Working Effectively with Legacy Code</code>的作者)对单元测试的定义。</p><p id="a4bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下列情况下，测试不是单元测试:</p><ul class=""><li id="e1ad" class="lu lv iq ka b kb kc kf kg kj mn kn mo kr mp kv mb mc md me bi translated"><em class="mr">它与数据库对话</em></li><li id="b0f8" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><em class="mr">它通过网络进行通信</em></li><li id="4ced" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><em class="mr">它触及文件系统</em></li><li id="a509" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><em class="mr">它不能与你的任何其他单元测试同时运行</em></li><li id="4a62" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated"><em class="mr">你必须对你的环境做一些特殊的事情(比如编辑配置文件)来运行它</em></li></ul><p id="52e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，好吧，那很好，但是为什么呢？</p><p id="7e38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是他的解释。</p><p id="6876" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一，<strong class="ka ir">速度</strong>。当谈到单元测试最佳实践时，速度是其中最重要的。依赖数据库或网络会降低测试速度。</p><p id="8fe1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们有<strong class="ka ir">决定论</strong>。单元测试必须是确定性的。也就是说，如果它失败了，它必须继续失败，直到有人修改了测试中的代码。反过来也是正确的:如果一个测试正在通过，它不应该在没有修改它测试的代码的情况下开始失败。如果一个测试依赖于其他测试或者外部依赖，那么它可能会因为除了被测系统中的代码变化之外的原因而改变它的状态。</p><p id="99db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们有反馈的<strong class="ka ir">范围。一个理想的单元测试覆盖特定的一小部分代码。当测试失败时，几乎可以肯定问题发生在代码的特定部分。也就是说，适当的单元测试是获得超级精确反馈的极好工具。</strong></p><p id="1b75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，如果一个测试依赖于数据库、文件系统和另一个测试，那么问题可能出在其中的任何一个地方。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/0df2c492d7313fd389b9bffcf3890b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIV4yojCQJjCCyXJwus8yw.png"/></div></div></figure><p id="355d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上图所示，有两个模块<code class="fe ms mt mu mv b">User Profile Module</code>(与用户配置文件相关的用户界面)和<code class="fe ms mt mu mv b">User DB Repo</code>(数据库模块)，分别使用输入进行测试，并使用断言进行验证。</p><p id="9717" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们对UserProfile模块进行单元测试时，我们肯定不会使用userdbreo，而是在UserProfile模块和单元测试中模拟userdbreo接口，这样我们就不会进行DB或文件系统调用。<br/>再次，当单元测试userdbreo模块时，我们将注入内存中的模拟DBHandle，它处理DB CRUD操作，使用它我们可以单元测试userdbreo接口的所有可能的API。</p><p id="cdff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但当使用UserDBRepo测试UserProfile模块时，这通常不是单元测试，而是集成测试，并不是说我们不应该编写这些测试，编写这些测试是很好的，但通常这些测试很慢，不可靠，当项目增长时，这些集成测试将花费大量时间来构建和运行整个测试套件，有时如果测试失败，我们不确定是哪个模块导致了失败。</p><h1 id="4934" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">避免被实现细节所束缚</h1><p id="cb10" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">测试行为意味着测试<strong class="ka ir">什么代码做了</strong>。测试实现意味着测试<strong class="ka ir">代码如何工作</strong>。那么我们应该测试哪一个呢？</p><p id="4eea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ms mt mu mv b">Testing Behaviour</code>或<code class="fe ms mt mu mv b">Testing Implementation</code></p><h1 id="73df" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">行为的单元测试</h1><p id="d7b8" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">当您编写行为测试时，您可以在不破坏测试的情况下秘密地重构您的代码(实现),只有当行为发生变化时，测试才会中断(无意中——这意味着您引入了一个bug，或者有意地代码发生了新的变化，这意味着测试需要更新以适应新的行为)。这些类型的测试非常有价值，因为一个失败的测试意味着你的代码失败了。<br/>测试行为<strong class="ka ir">保证</strong>你的代码按预期工作(对于你已经测试过的行为)。</p><h1 id="4967" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">关于实现的单元测试</h1><p id="62fb" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">当您为实现编写测试时，当您更改代码时，测试会中断，即使行为没有改变。这些类型的测试不是很有价值，因为一个失败的测试并不意味着你的代码失败了，一个通过的测试也不意味着你的代码像预期的那样工作。</p><p id="f1df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试实现只能保证你的代码在被测试的时候被编写。</p><h1 id="2892" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">对函数/类的行为而不是实现进行单元测试。</h1><p id="4ae0" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">让我们看一个例子，让我们考虑简单的类ImageViewController</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/600f74b8a2e8b3e59b20351eb3ecd94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDN4w8D6WmgYUsYV_Py4Ww.png"/></div></div></figure><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/ecfe7ba9ab1deb6a3bac19f58d8205b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zbQSuCJt8fk47njIUNyNfw.png"/></div></div></figure><p id="1a22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们的ImageViewController，它有一个相关的ImageLoader来加载远程web图像，ImageViewController将下载的图像设置为它的imageView。<br/>现在我们来看看实现步骤是什么样子的</p><ul class=""><li id="2976" class="lu lv iq ka b kb kc kf kg kj mn kn mo kr mp kv mb mc md me bi translated">步骤1图像视图控制器创建</li><li id="1873" class="lu lv iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">第二步通过<code class="fe ms mt mu mv b">reloadImageView</code>从图像加载器调用<code class="fe ms mt mu mv b">loadRemoteImage</code>，从远程网址下载图像。</li></ul><p id="5df1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们为上面的实现步骤编写测试呢？</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/269b9e54a215a9aaab0dd59e6bb3f3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLVzvGL__FM4LErd8cOKYQ.png"/></div></div></figure><p id="7126" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，我们已经模拟了<code class="fe ms mt mu mv b">MockedImageLoader</code>的图像加载器，是的，因为我们从网络调用加载图像，所以可以理解。我们现在将同样的内容注入ImageViewController并调用reloadImageView，稍后我们检查给予MockedImageLoader的mockImage是否被加载到loadedImages集合中。这是公平的，这正是已经实施的。</p><p id="11b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这看起来像是一个单元测试，但是我们真的在测试ImageViewController应该做什么吗？哦！不要！ImageViewController假定从远程URL加载图像并在imageView中显示它。但是我们更倾向于单元测试ImageLoader的逻辑是否加载给定的图像，这是因为我们在编写测试时考虑了实现细节，这就是为什么我们结束了对ImageLoader而不是ImageViewController本身的测试。</p><p id="2042" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们试着为imageview controller reload imageview行为编写一个测试。让我们稍微调整一下ImageLoader，以便为ImageViewController行为编写单元测试。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/f2cb4a0538401be77312d8ebcd37c6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5nKrCGx9_VRBIF9s9bx8Q.png"/></div></div></figure><p id="2dca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在将看到验证ImageViewController的reloadImageView行为的单元测试。</p><figure class="nd ne nf ng gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/d22d317ea0b7a994a302a133932a2d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfNHpDVXtdkNy4aY6aJv-A.png"/></div></div></figure><p id="1115" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣吧？</p><p id="67e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们没有模仿ImageLoader，是的，我们不需要，我们正在验证reloadImageView的结果，它检查ImageView.image是否是通过mockImage发送的，还有一个优点是我们不需要更新单元测试，即使我们修改了ImageViewController和ImageLoader的实现，直到ImageViewController的行为reloadImageView是相同的。</p><p id="bbbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个针对类/函数行为而不是实现编写单元测试的非常简单的例子。</p></div></div>    
</body>
</html>