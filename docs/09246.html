<html>
<head>
<title>Top algorithm problems to evaluate candidates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">评估候选人的顶级算法问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/top-algorithm-problems-to-evaluate-candidates-d0d36031a?source=collection_archive---------8-----------------------#2021-07-20">https://levelup.gitconnected.com/top-algorithm-problems-to-evaluate-candidates-d0d36031a?source=collection_archive---------8-----------------------#2021-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/abef6aa614c3ec376d3a0779bb09aed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e1uxmHg2DNCUf7xo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@cytonn_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cytonn摄影</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="0bcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都会时不时地去参加工作面试，有时我们会看到任务，然后我们会问——这是我在这份工作中要做的吗？。<br/>测试算法知识的愿望是可以理解的，但有时面试官会给出一个问题，为了解决这个问题，你需要知道一些非常具体的算法。</p><h1 id="21fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#9000.最小生成树</h1><blockquote class="lz ma mb"><p id="05e4" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">给定一个加权无向图。最小生成树(MST)是将所有顶点无圈连接在一起的边的子集，并且具有最小可能的总边权重。</p><p id="e896" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">在给定图的MST中找到所有的<strong class="kf ir">关键</strong>和<strong class="kf ir">伪关键边</strong>。如果一条MST边从图中删除会导致MST权重增加，则这条边称为临界边。另一方面，伪临界边缘可以出现在一些MST中，但不是所有MST中。</p></blockquote><p id="a0fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个任务是通过Prim的算法或者Kruskal的算法来解决的，这些算法在日常工作任务中相当少见，但在需求中可以很容易地googled出来。如果面试的目的是淘汰尽可能多的候选人，这是一项伟大的任务。但是如果你一年没有收到300万份简历，那么我就不会那样浪费时间和候选人。</p><p id="cf8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在此找到解决方案:</p><div class="mg mh gp gr mi mj"><a href="https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/discuss/855731/Simple-Java-Solution-or-Kruskal-Algo" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">简单的Java解决方案| Kruskal Algo - LeetCode讨论</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">leetcode.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx jw mj"/></div></div></a></div><h1 id="4839" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#2.两个数的和</h1><blockquote class="lz ma mb"><p id="1b1f" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated">给定一个排序的整数数组。找出数字，使它们加起来等于给定的数字。</p></blockquote><p id="5f9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过几个算法问题，你可以与候选人进行大量交流，让他找到更好的解决方案。</p><p id="72b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个简单的任务，但仍然有评估候选人的空间。有许多解决方案，您可以从简单走向复杂:</p><ol class=""><li id="c80c" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">使用嵌套循环的暴力。O(n)时间，O(1)内存。</li><li id="8058" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">二分搜索法。O(nlogn)时间，O(1)内存。</li><li id="cbf1" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">散列表。O(n)时间，O(n)内存。</li><li id="c161" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">两个指针:从开始和从结束。O(n)时间，O(1)内存。</li></ol><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">双指针算法</figcaption></figure><h1 id="0227" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#1.限速器</h1><blockquote class="lz ma mb"><p id="1670" class="kd ke mc kf b kg kh ki kj kk kl km kn md kp kq kr me kt ku kv mf kx ky kz la ij bi translated"><em class="iq">给定一个接口和整数</em> <code class="fe ns nt nu nv b"><em class="iq">N &gt; 0</em></code> <em class="iq">。编写一个实现，将对此方法的调用限制为每秒N次调用。</em></p></blockquote><pre class="nm nn no np gt nw nv nx ny aw nz bi"><span id="0c6c" class="oa lc iq nv b gy ob oc l od oe">public interface Service {<br/>    void doSomething();<br/>}</span></pre><p id="f29a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这项任务的美妙之处主要在于它很可能是项目的工作任务之一。例如，如果您向客户销售API，其中每个价格计划都有自己的单位时间内允许调用的次数。</p><p id="1d0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还有一个应用设计模式的空间。如果候选人已经猜到使用装饰，这已经是一个好的迹象。如果他提到AOP(针对Spring中的Java程序员)，那也是一个很好的加分项。</p><p id="3510" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务本身有两个阶段。</p><h2 id="926a" class="oa lc iq bd ld of og dn lh oh oi dp ll ko oj ok lp ks ol om lt kw on oo lx op bi translated">需要精确计数</h2><p id="3b0b" class="pw-post-body-paragraph kd ke iq kf b kg oq ki kj kk or km kn ko os kq kr ks ot ku kv kw ou ky kz la ij bi translated">这里的标准解决方案是使用LinkedList (O(n)时间和内存)。想法是保存所有新呼叫尝试的列表:</p><ol class=""><li id="e0aa" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">从头部删除传出的请求</li><li id="2747" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">检查列表大小</li><li id="09c2" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">在尾部插入一个新值</li></ol><p id="31b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个循环缓冲解(O(1)时间，O(n)内存)，但是面试的时候比较难想出来，通常情况下，LinkedList解就够了。</p><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">圆形限速器</figcaption></figure><h2 id="32fc" class="oa lc iq bd ld of og dn lh oh oi dp ll ko oj ok lp ks ol om lt kw on oo lx op bi translated">с计算误差是可以接受的</h2><p id="ffb3" class="pw-post-body-paragraph kd ke iq kf b kg oq ki kj kk or km kn ko os kq kr ks ot ku kv kw ou ky kz la ij bi translated">在现实生活中，我们通常愿意牺牲完美的准确性来显著提高复杂度(O(1)时间，O(1)内存)。因此，访问的第二阶段是实现允许1%假阳性误差的服务(即，在最坏的情况下，用户可以每秒进行10100次呼叫)。</p><p id="f08e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的解决方案是在LinkedList中存储的不是调用时间，而是存储桶、时间间隔开始的内容以及对它的调用次数。根据新的请求，我们将:</p><ol class=""><li id="1350" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">从列表中删除旧的存储桶</li><li id="796b" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">检查列表中当前的请求数</li><li id="8abc" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">向最后一个时段添加请求，或者创建一个新的时段</li></ol><figure class="nm nn no np gt jr"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">1%假阳性误差的速率限制器</figcaption></figure><p id="ae5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在现实生活中，解决方案必须是线程安全的，并且很可能有每个用户的限制，但是这超出了工作面试问题的范围。</p><h1 id="a393" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="dc99" class="pw-post-body-paragraph kd ke iq kf b kg oq ki kj kk or km kn ko os kq kr ks ot ku kv kw ou ky kz la ij bi translated">在工作面试中解决现实生活中的问题总是比单纯的算法问题更有趣。算法仍然有用武之地，但是你也可以测试架构模式的知识。<br/>如果你不是Google，基于对一些稀有算法的无知，不太可能有这么多候选人筛选出来，所以筛选过程应该更高效。</p></div></div>    
</body>
</html>