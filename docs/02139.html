<html>
<head>
<title>The Fastest Semantic Version in the West!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">西方最快的语义版！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-fastest-semantic-version-in-the-west-1dda2d1f39b1?source=collection_archive---------18-----------------------#2020-02-20">https://levelup.gitconnected.com/the-fastest-semantic-version-in-the-west-1dda2d1f39b1?source=collection_archive---------18-----------------------#2020-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/872d4663281c3e1ead05164c2c261d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vh1Y8Lp6S_2Bwnci"/></div></div></figure><p id="7ded" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">语义版本化，通常简称为'<strong class="ka ir">SEM ver【T1]'，是一种以用户友好的方式对发布版本进行版本化的方法。当正确应用时，它有助于确保依赖关系不会“失去同步”,并有助于减轻向后兼容性问题带来的复杂性。</strong></p><p id="c485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们都曾在某个时候看到过3个数字表示一个应用程序的版本，而这个应用程序很可能正在实现语义版本化。版本系统由3个数字组成，表示应用于应用程序的不同级别的更改。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="c868" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">这意味着什么呢？</h1><p id="88bf" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">首先，我们应该花点时间首先理解版本化系统的不同组件的含义，以及它们之间的关系和它们所版本化的代码。</p><p id="8fa4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重大</strong>——<em class="mg">突破性的改动已经发布，应用不再向后兼容</em>。这通常发生在应用程序的下一个迭代即将发布时，或者有必要将向后不兼容的更改引入现有应用程序时。</p><p id="3c7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">次要</strong> —这些变化是典型的<em class="mg">新特性，并以向后兼容的方式引入</em>。它们不会减损或修改现有的功能。对于所有的意图和目的，最终用户可能甚至不需要知道这个变化已经实现，除非他们特别要求使用新实现的特性。</p><p id="b01d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">补丁</strong> —这通常被认为是专门针对<em class="mg">漏洞修复</em>。纠正一些不完整的代码，并确保它按照最初的意图工作。这是用于添加功能的<em class="mg">而不是</em>。这也不应该修改任何现有的功能，应该是向后兼容的。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="0ad9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">于是我们有了<strong class="ka ir">大调</strong>、<strong class="ka ir">小调</strong>、<strong class="ka ir"> </strong>和<strong class="ka ir">补丁</strong>的版本，这些被表示为我们经常看到的3个数字。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cce3" class="mq le iq mm b gy mr ms l mt mu">// Major . Minor . Patch<br/>version 1.4.11</span></pre><p id="17e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的示例版本中，我们看到假设的应用程序目前在主版本1上，这也被认为是它的第一个“发布”。</p><p id="86c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">次要版本是4，这意味着4个新功能或功能集已经以向后兼容的方式实现，以确保现有用户在使用该应用程序时不会出现问题。</p><p id="9594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还看到代码中发现了11个错误，这些错误已经用一些新代码进行了修补，并以确保向后兼容性的方式发布。</p><p id="1637" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重要的是要注意，每当我们增加任何版本时，前面的版本号都应该被重置为零。这意味着如果我们向应用程序引入一些新的和向后兼容的变更(微小的变更)，我们将不得不增加<code class="fe mv mw mx mm b">minor</code>版本并将<code class="fe mv mw mx mm b">patch</code>版本重置为零。</p><p id="7e73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说→ <code class="fe mv mw mx mm b">1.4.6</code>有一个小“凸起”会变成<code class="fe mv mw mx mm b">1.5.0</code>和<em class="mg">而不是</em> <code class="fe mv mw mx mm b">1.5.6</code>，因为新的次要版本还没有发布任何错误修复。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/b47614d8581eb4eb96b51e54f2bf3771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*npaBm8BeB_CzLJtt"/></div></div></figure><p id="76b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们如何在代码中实现它呢？典型地，一个项目将从版本<code class="fe mv mw mx mm b">0.1.0</code>开始它的生命，并且将保持“未发布”状态，直到应用程序稳定，并且处于满足所有最低要求的状态，并且能够交付给客户或任何人。</p><p id="dfe9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该记住，虽然在数字前面加上前缀“v”可能会向用户表明该数字表示版本——根据<strong class="ka ir"> semver </strong>指南，官方版本应该只是相关的数字。即<code class="fe mv mw mx mm b">1.2.3</code>而不是<code class="fe mv mw mx mm b">v1.2.3</code></p><p id="d6bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，虽然我们可以在一些版本控制系统(VCS)中使用“v”来标记提交，但真正的版本应该保持为没有修改的数字。</p><p id="6974" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，对于GitHub中的TypeScript项目，我们的最新版本可能会被标记为<code class="fe mv mw mx mm b">v1.0.3</code>，但是在我们的<code class="fe mv mw mx mm b">package.json</code>中，我们不应该在<code class="fe mv mw mx mm b">version</code>前面加上“v”。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/ca743a27bdc6728ebf7c0da38fd576aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*EXlr0LhHrHZ06JLMl8_VcQ.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">版本前缀为“v”的GitHub标签示例</figcaption></figure><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/febd0e5b97e9648d5e3ad143dc652e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:302/format:webp/1*YVpm-Lb_EPsMgZKDivb2yQ.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">package.json中的语义版本示例</figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="8f8a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">那么这对我们有什么帮助呢？</h1><p id="732f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">嗯，我马上想到的是…</p><ol class=""><li id="dd62" class="nf ng iq ka b kb kc kf kg kj nh kn ni kr nj kv nk nl nm nn bi translated">我们可以确保每次都为我们的应用程序安装相同版本的依赖库。从而减轻由于不匹配的依赖关系或未知的改变被发布到库而引起的问题。</li><li id="b2ab" class="nf ng iq ka b kb no kf np kj nq kn nr kr ns kv nk nl nm nn bi translated">我们可以根据增加的版本来确定更新到依赖项的最新版本是否安全。</li></ol><p id="f705" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管语义版本化在指明一个库或应用程序的变更包括什么方面走了很长的路，但理想情况下，我们也应该为我们的代码保持一个最新的、干净的变更日志。这显然可以用来与语义版本化协作，来确定依赖关系的最新版本是否适合我们的应用程序。</p><p id="bea3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一点怎么强调都不为过，一致的版本控制和记录更改的内容非常重要。不仅仅是公共库、项目或应用程序，私有或个人库也是如此。它<em class="mg">最终会</em>得到回报。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/5e523e4617e65d09f634bb6f15ab06cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GLRTteDPPqtyOMkw"/></div></div></figure><h1 id="b4f7" class="ld le iq bd lf lg nu li lj lk nv lm ln lo nw lq lr ls nx lu lv lw ny ly lz ma bi translated">我们到了吗？</h1><p id="9b8a" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">是啊！我们在那里！我们已经完成了，并准备开始对我们的应用程序和库实现语义版本控制！总会有额外的阅读点来澄清任何问题或困惑，我决定在下面列出其中的几个。</p><p id="5422" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nz" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本2.0.0 </a> <br/> <a class="ae nz" href="https://docs.npmjs.com/about-semantic-versioning" rel="noopener ugc nofollow" target="_blank">关于语义版本</a></p><p id="4eea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢你阅读这篇文章，我希望你学到了一些新的东西。如果你有任何意见，请随意写在下面的评论区！</p><p id="2252" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再见了。</p></div></div>    
</body>
</html>