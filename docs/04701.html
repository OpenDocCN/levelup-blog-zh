<html>
<head>
<title>Canary Deployment of Web Apps with CloudFront, S3, Lambda and Cookies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CloudFront、S3、Lambda和Cookies部署Web应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/gradual-deployment-of-web-apps-with-cloudfront-s3-lambda-and-cookies-ce17473afabe?source=collection_archive---------5-----------------------#2020-07-10">https://levelup.gitconnected.com/gradual-deployment-of-web-apps-with-cloudfront-s3-lambda-and-cookies-ce17473afabe?source=collection_archive---------5-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7f31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在AWS上托管应用，有托管服务帮助你逐步发布变更，避免危险的“大爆炸”部署。对于无服务器应用程序，您可以使用<a class="ae kl" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/automating-updates-to-serverless-apps.html" rel="noopener ugc nofollow" target="_blank"> lambda版本别名</a>实现金丝雀关系，对于ECS/EC2/Beanstalk，您可以使用<a class="ae kl" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/blue-green.html" rel="noopener ugc nofollow" target="_blank"> CodeDeploy </a>实现蓝绿色部署。</p><p id="46e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这些工具只能解决后端部署。<br/>如果你想在<strong class="jp ir"> S3 </strong>上发布<strong class="jp ir">静态网站</strong>会怎么样？以下是实现这一目标的秘诀！</p><h1 id="b6ad" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">成分:</h1><ul class=""><li id="52de" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated">1 CloudFront分布</li><li id="eb49" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">2个Lambda函数(请求+响应)</li><li id="dac3" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">2个S3桶(当前版本+下一版本)</li><li id="70f9" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">1块饼干</li></ul><p id="97af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终结果看起来会很美味:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/b8d15b0ade46dafd9c2caf3001b38a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DSGHIh7T615Vd-WJ4cVxA.png"/></div></div></figure><p id="dfd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一开始看起来可能很复杂，但这只是用Cloudformation创建的一些资源。事实上，您只需点击下面的按钮，就可以在您的AWS帐户中设置此基础架构:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><a href="https://console.aws.amazon.com/cloudformation/home?region=us-east-1#/stacks/new?stackName=myteststack&amp;templateURL=https://s3.amazonaws.com/medium-templates/gradual-deployment.yaml"><div class="gh gi mm"><img src="../Images/041e2bb303b11c98a9ae4c877b418cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*Z2PO_ioDZEow7eb3SD6rsg.png"/></div></a></figure><p id="1fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CF模板有两个参数:</p><ul class=""><li id="48b5" class="lk ll iq jp b jq jr ju jv jy mn kc mo kg mp kk lr ls lt lu bi translated"><strong class="jp ir">发布名称</strong>。我们当前发布的版本的唯一标识符，例如“v2”</li><li id="4598" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><strong class="jp ir">释放重量</strong>。介于1和100之间的数字，指定我们要向多少百分比的用户推出当前版本。这些用户将被随机选择，用户版本状态将保存在cookie中。</li></ul></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="e726" class="km kn iq bd ko kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj bi translated">方向</h1><p id="f016" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">在一个简单直接的web设置中，CloudFront发行版将一个S3 bucket配置为origin。这是我们的起点。</p><p id="0e22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们在Lambda@Edge中实现我们的魔术。与“通常的”lambdas不同，这些功能被复制到所有AWS边缘位置，这允许与CloudFront事件集成。<br/>如果我们决定用户应该获得新版本的应用程序，我们将以下lambda附加到origin请求事件，并将Origin重写到我们的第二个存储桶。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2d09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将决策的结果保存在一个cookie中。由于我们无法从上面的请求lambda访问响应对象，我们需要创建一个额外的lambda并将其附加到原始响应事件。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="3f83" class="km kn iq bd ko kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj bi translated">品尝</h1><p id="25c1" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">要查看结果，将2个不同的index.html文件上传到buckets并导航到CloudFront域。使用开发工具检查cookies。有50%的可能性会是这样的:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nh"><img src="../Images/3761db4a01c1aa89f6b439279ebd7ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yN8Bekj8o1FZ8j-sRX-oPg.png"/></div></div></figure><p id="4b16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试刷新页面几次。您应该始终看到相同的版本，cookie值应该保持不变。<br/>接下来，清除你的cookies，刷新页面。您有50%的机会看到第二个版本，cookie值现在将是999:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ni"><img src="../Images/7463cc9c7333c6e83977c1008753a44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tn7cMJRaHoC8rAveozODug.png"/></div></div></figure><p id="db4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们增加v2用户组。用新的权重值75更新堆栈，并在cookie值为50时刷新页面。cookie要么切换到75，您将继续使用旧版本，要么切换到999，您将看到新版本。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="b51b" class="km kn iq bd ko kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj bi translated">通过部署管道提供服务</h1><p id="df39" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy nc ka kb kc nd ke kf kg ne ki kj kk ij bi translated">如何使用这种方法取决于你，但假设我们希望我们所有的发布都是渐进的，我们希望每小时增加10%的权重，直到达到100%。显然，这个过程需要自动化。在这种情况下，我们需要在部署流程中实施以下逻辑:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nj"><img src="../Images/253ac2e6effa09072cc49e6b24568e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3gzsXzPWM4g9zro3ae7Ww.png"/></div></div></figure><p id="3497" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，当引入一个新版本时，你需要做的就是推一个新的<strong class="jp ir"> ReleaseName </strong>并将<strong class="jp ir"> ReleaseWeight </strong>设置为0。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="6194" class="km kn iq bd ko kp mx kr ks kt my kv kw kx mz kz la lb na ld le lf nb lh li lj bi translated"><strong class="ak">重要注意事项</strong></h1><ul class=""><li id="5753" class="lk ll iq jp b jq lm ju ln jy lo kc lp kg lq kk lr ls lt lu bi translated"><strong class="jp ir">缓存<br/> </strong>在这个例子中，我们完全禁用了CloudFront的缓存。只是为了简单起见。您需要决定什么适合您的用例。如果您正在构建一个现代的(React/Angular/VueJs)单页面应用程序，您可能有一个引用唯一命名的JS/CSS文件的HTML文件。在这种情况下，明智的做法是将这些资产放在其他地方，甚至可能放在另一个域下，并积极地缓存它们。这样，我们的lambdas将只处理对index.html的请求，我们不需要担心缓存</li><li id="ad39" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><strong class="jp ir">该解决方案并非100%准确<br/> </strong>因为该解决方案基于cookies和实际用户行为(他们返回您网站的频率、高峰交通时段等)。)您无法保证按预期路由的流量的确切百分比。</li><li id="43fd" class="lk ll iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><strong class="jp ir">路由53加权路由作为替代方案<br/> </strong>如果您的解决方案不需要“粘性”，即您不介意用户被随机从新版本切换回旧版本，这可能是一种更简单的方法。您为两个版本创建了两个独立的堆栈，并使用Route53在DNS级别分配权重。但是要注意以下限制:多个CloudFront发行版不能监听同一个域。然后可以监听重叠的别名，比如*.example.com和app.example.com，但还有一个问题:重叠只可能发生在同一个AWS帐户中。如果你有一个分布在另一个帐户听sales.example.com这个选项将不会工作。此外，DNS的传播速度也不是100%可靠。</li></ul><p id="5705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的所有代码都已经过成功测试，并在我们的所有web应用程序上愉快地运行了一年多，网址是https://eatella.app 。</p><p id="35a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你好运，造出令人惊叹的东西并超级安全地发布它！</p></div></div>    
</body>
</html>