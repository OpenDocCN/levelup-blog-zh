<html>
<head>
<title>Simple Recursive Navigation in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的简单递归导航</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-recursive-navigation-in-react-511d0a013ae4?source=collection_archive---------14-----------------------#2020-05-04">https://levelup.gitconnected.com/simple-recursive-navigation-in-react-511d0a013ae4?source=collection_archive---------14-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/611c0b882a0b73ebdb126e90538e400b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3bf5j3-2Id0n0zC_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="403a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在你创建的任何网站中，导航可能是你最常看到的东西(否则你的用户如何在网站中导航？).此外，如果你的导航结构有一个层次结构，很明显递归可能是你的解决方案。</p><p id="dcf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，什么是递归？*<em class="le">JavaScript中的Googles递归* </em></p><blockquote class="lf lg lh"><p id="cb40" class="kg kh le ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">递归函数是一个<a class="ae kf" href="https://www.javascripttutorial.net/javascript-function/" rel="noopener ugc nofollow" target="_blank">函数</a>，它调用自己直到它不调用为止。这种技术叫做递归。<br/><a class="ae kf" href="https://www.javascripttutorial.net/javascript-recursive-function/" rel="noopener ugc nofollow" target="_blank">https://www . JavaScript tutorial . net/JavaScript-recursive-function/</a></p></blockquote></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h2 id="1ef7" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">源代码可以在这里查看<a class="ae kf" href="https://github.com/bautistaaa/react-recursive-nav" rel="noopener ugc nofollow" target="_blank"/></h2><p id="d011" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">很好，现在这个问题已经解决了，让我们来看看我们的导航数据可能是什么样子，它可能会受益于递归。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://github.com/bautistaaa/react-recursive-nav" rel="noopener ugc nofollow" target="_blank">https://github.com/bautistaaa/react-recursive-nav</a></figcaption></figure><p id="3ec1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<code class="fe mw mx my mz b">links</code>数组中物体的形状。我们称每个对象为<code class="fe mw mx my mz b">link</code>。</p><p id="cbb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe mw mx my mz b">link</code>可以有两种形状:</p><ul class=""><li id="45f7" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><code class="fe mw mx my mz b">label</code>和<code class="fe mw mx my mz b">path</code>——这意味着它应该被呈现为一个锚标记</li><li id="cd1d" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mw mx my mz b">label</code>和<code class="fe mw mx my mz b">children</code>——意味着标签可以呈现为文本，子标签将呈现为子菜单中的链接</li></ul><p id="9dc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe mw mx my mz b">children</code>的级别可以无限增长，所以在这里使用递归是有意义的。</p><p id="831b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何在组件中使用这个<code class="fe mw mx my mz b">links</code>数组来递归地呈现子元素。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://github.com/bautistaaa/react-recursive-nav" rel="noopener ugc nofollow" target="_blank">https://github.com/bautistaaa/react-recursive-nav</a></figcaption></figure><p id="2b50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们暂时忽略<code class="fe mw mx my mz b">handleMenuSelection</code>函数，分解我们在JSX中看到的。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://github.com/bautistaaa/react-recursive-nav" rel="noopener ugc nofollow" target="_blank">https://github.com/bautistaaa/react-recursive-nav</a></figcaption></figure><p id="374f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这部分很简单。我们简单地循环所有的<code class="fe mw mx my mz b">link</code>对象，并为每个对象渲染一个<code class="fe mw mx my mz b">SidebarItem</code>。但是，请注意我们正在传递的道具:</p><ul class=""><li id="7f78" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><code class="fe mw mx my mz b">handleMenuSelection</code> —每当我们悬停/选择导航中有子导航的部分时，就会调用这个函数</li><li id="6499" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mw mx my mz b">selectedMenus</code> —这将跟踪当前活动的菜单，以便我们知道哪些菜单应该对用户隐藏/显示</li></ul><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://github.com/bautistaaa/react-recursive-nav" rel="noopener ugc nofollow" target="_blank">https://github.com/bautistaaa/react-recursive-nav</a></figcaption></figure><p id="f392" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mz b">SidebarItem</code>部分更有趣一些。这里基本上有两条逻辑路径。</p><ul class=""><li id="b7b9" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated">如果<code class="fe mw mx my mz b">link</code>对象有<code class="fe mw mx my mz b">children</code>,我们就呈现文本和一个孩子的列表。</li><li id="d34e" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated">如果<code class="fe mw mx my mz b">link</code>对象没有<code class="fe mw mx my mz b">children</code>,我们渲染一个锚标签</li></ul><p id="5045" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从高层次来看，逻辑相当简单。现在，最后一部分是简单地管理哪些当前菜单是活动的，并控制哪些菜单对用户呈现/隐藏。这就是<code class="fe mw mx my mz b">handleMenuSelection</code>函数和<code class="fe mw mx my mz b">selectedMenus</code>一起发挥作用的地方，我们通过<code class="fe mw mx my mz b">useState</code>保持状态。</p><p id="82e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你看看上面的<code class="fe mw mx my mz b">SidebarItem</code>要点，你会注意到当我们将鼠标悬停在<code class="fe mw mx my mz b">label</code>或<code class="fe mw mx my mz b">anchor</code>标签上时，我们正在调用<code class="fe mw mx my mz b">handleMenuSelection </code>。对于<code class="fe mw mx my mz b">label</code>场景，我们用一个<code class="fe mw mx my mz b">label</code>来调用<code class="fe mw mx my mz b">handleMenuSelection</code>，表示当前链接对象的文本，用<code class="fe mw mx my mz b">depth</code>来表示我们所在的子层。否则，如果我们悬停在一个没有子标签的<code class="fe mw mx my mz b">anchor</code>标签上，我们会清除当前<code class="fe mw mx my mz b">depth</code>处的标签。让我们仔细看看<code class="fe mw mx my mz b">handleMenuSelect</code>功能。</p><pre class="mq mr ms mt gt no mz np nq aw nr bi"><span id="16a2" class="ls lt it mz b gy ns nt l nu nv">const handleMenuSelection = (label, depth) =&gt; {<br/>    setSelectedMenus((selectedMenus) =&gt; {<br/>      const newSelectedMenus = [...selectedMenus];<br/>      // trim any menus after the depth<br/>      newSelectedMenus.length = depth;<br/>      if (label !== '') {<br/>        newSelectedMenus[depth] = label;<br/>      }<br/>      return newSelectedMenus;<br/>    });<br/>  };</span></pre><p id="2a4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将获取深度并将其赋给数组的<code class="fe mw mx my mz b">length</code>属性。这允许我们修剪当前显示的任何菜单，这些菜单是当前所选菜单的子菜单。为了更好地形象化这一点，如果我有显示3层深度的菜单<code class="fe mw mx my mz b">['Parent', 'Child with Children', 'GrandChild 2']</code>，这里是<code class="fe mw mx my mz b">selectedMenus</code>的样子。这是用户看到的样子。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/e49b74358c9c66ae8dea9cb19e5a693a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWGyJBuRvWwKxT-AW3lHmw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://github.com/bautistaaa/react-recursive-nav" rel="noopener ugc nofollow" target="_blank">https://github.com/bautistaaa/react-recursive-nav</a></figcaption></figure><p id="16e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么深度在这里是如何发挥作用的呢？本质上只是指示标签在数组中显示的索引。如果我们再次查看这个数组<code class="fe mw mx my mz b">['Parent', 'Child with Children', 'GrandChild 2']</code>，我们会看到<code class="fe mw mx my mz b">Parent</code>的<code class="fe mw mx my mz b">depth</code>为0，<code class="fe mw mx my mz b">Child with Children</code>的<code class="fe mw mx my mz b">depth</code>为1，等等..有道理吗？因此，如果我们将<code class="fe mw mx my mz b">Parent2</code>悬停在上面的图像中，我们的<code class="fe mw mx my mz b">selectedMenus</code>将变为<code class="fe mw mx my mz b">['Parent2']</code>并截断数组的其余部分。</p><p id="c413" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们如何控制出现的内容？</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c956" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mz b">selectedMenus[depth] === label</code>将检查特定索引(<code class="fe mw mx my mz b">depth</code>)处的数组，如果匹配，将显示下拉列表。</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/4dfb5f9d7eb54b4f9114317aba39e251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*T1_8j3WXa6HkahyEa8GEnA.gif"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://github.com/bautistaaa/react-recursive-nav" rel="noopener ugc nofollow" target="_blank">https://github.com/bautistaaa/react-recursive-nav</a></figcaption></figure><p id="ac34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，这是<strong class="ki iu"> <em class="le">完成这样一项任务的多种方式中的一种</em> </strong>。此外，请注意，这个例子是面向导航的，但实际上它可以应用于任何可以用递归解决的问题。</p><p id="bea1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有其他方法来完成这个，请在下面留下评论！我很想去看看。</p><p id="3119" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">源代码可查看@<a class="ae kf" href="https://github.com/bautistaaa/react-recursive-nav" rel="noopener ugc nofollow" target="_blank">https://github.com/bautistaaa/react-recursive-nav</a></p></div></div>    
</body>
</html>