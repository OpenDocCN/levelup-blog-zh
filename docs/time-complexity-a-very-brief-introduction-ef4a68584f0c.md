# 时间复杂性|非常简短的介绍

> 原文：<https://levelup.gitconnected.com/time-complexity-a-very-brief-introduction-ef4a68584f0c>

![](img/5e636a54f4d6b0a0c732b1e980c051ca.png)

瑞安·斯通在 [Unsplash](https://unsplash.com/s/photos/stopwatch?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

时间复杂性是计算机科学中的一个重要概念，指的是算法运行所需的时间。理解时间复杂性可以帮助你做出明智的决定，在不同的情况下使用哪些算法，这是软件工程工作的技术面试中的一个常见话题。

从较高的层面来看，算法的时间复杂度取决于运行算法所需的时间量如何随着输入大小的增加而增加。例如，如果一个算法在输入是两倍大的情况下运行时间是两倍，我们说该算法的时间复杂度为 *O(n)* ，其中 n 是输入的大小。换句话说，运行算法所需的时间与输入的大小成线性比例。

## 测量时间复杂度和大 O 符号

有几种不同的方法来衡量时间复杂度，但最常用的是*大 O 符号*。通过观察算法的运行时间如何随着输入大小的增加而增加，这种表示法提供了对算法时间复杂性的粗略估计。

例如，如果一个算法的时间复杂度为 *O(1)* ，也称为常数时间，这意味着无论输入的大小如何，该算法都需要相同的时间来运行。这被认为是非常高效的，因为运行时间不会随着输入大小的增加而增加。

另一方面，时间复杂度为 *O(n)* 的算法意味着运行时间随着输入的大小线性增长。这仍然被认为是相对高效的，因为运行时间只与输入的大小成比例增长。

时间复杂度为 *O(n )* 的算法意味着运行时间随着输入大小的平方而增长。这被认为效率较低，因为随着输入大小的增加，运行时间增长得更快。

大 O 符号表示算法*根据输入*的大小执行的基本运算的粗略计数。最好给出一个实际的时间，例如，以秒或分钟为单位，因为大 O 提供了一个效率的度量，不管计算能力如何，它在计算机之间都是可比较的。

# 常见的时间复杂性

下面是一些在面试中可能会被问到的大 O 符号的常见例子。在下文中，提到的 *n* 指的是输入的大小。例如，在长度为 10 的数组要被排序的情况下，我们有 *n=* 10。

## O(1) —常数时间

这是一个常数时间算法的时间复杂度。换句话说，一个具有时间复杂度 *O(1)* 的算法将花费大致相同的时间来运行，而不管输入的大小。这方面的一个例子是在一个按升序排序的数组中寻找最小值；只需返回第一个元素。这里，不管这个输入数组有多长，我们都知道只返回第一个元素，所以，执行时间是常数，不依赖于输入数组。

## *O(对数 n) —对数时间*

对数时间算法被认为是非常有效的，因为输入大小在每个时间步长都以常数因子减小。字典搜索很好地说明了这一点。假设您正在字典中查找一个单词。到字典的中间，检查你的单词按字母顺序是在字典中间的单词之前还是之后。如果是 before (after ),你现在知道你要找的单词在字典的前半部分，你现在已经把你的搜索空间缩小了一半。

在字典示例中，我们每次都将搜索空间缩小到原来的 1/2，表示对数基数为 2。然而，当讨论时间复杂度时，日志的基数是无关紧要的。因此，如果我们每次将搜索空间缩小 10 倍(一个更有效的算法)，我们仍然说它是 *O(log n)* 。

## O(n) —线性时间

线性时间算法要求输入的每个元素至少被访问恒定的次数。例如，对一个数组中的所有元素求和将是 *O(n)* ，因为我们必须遍历输入数组中的每个元素，以将其添加到总和中。

因此，给定大小为 *n* 的输入，通过输入的完整循环至少指示 *O(n)* 。但是这里值得提醒自己的是，如果我们有两个连续的循环通过输入，时间复杂度仍然会是 *O(n)* ！*连续*(不嵌套)是这里的关键词。两个连续的循环可以被认为是 *O(2n)* ，但是当处理大 O 符号时，我们丢弃了常数，复杂度仍然是 *O(n)* 。

## O(n logᵏ n) —准线性/对数线性时间

这种形式的时间复杂度通常与排序算法有关，并且通常是运行对数时间算法 *n* 次的结果。

## O(n ) —二次时间

二次时间算法通常与一个*嵌套*循环相关联。使用二次时间算法，我们可以遍历输入中的每一对元素。如果我们必须将输入数组中的每个元素与其他元素进行比较，这可能会很有用。

我们可以将二次时间推广到多项式时间— *O(n* ᵏ *)。*例如，三个嵌套循环将是立方时间， *O(n )* ，并允许输入中的每个三元组在*上迭代。如前所述，重要的是不要混淆嵌套循环和连续循环，后者速度更快。*

## O(2ⁿ) —指数时间

具有时间复合 *O(2ⁿ)* 的算法允许在输入(幂集)中元素的每个可能组合上迭代。例如，给定输入数组[5，7，1]，我们可以迭代子数组 *[]* ，*【5】*，*【7】*，*【1】*，*【5，7】*，*【5，1】*，*【7，1】*，*【5，7，1】*。

## O(n！)—阶乘时间

阶乘时间比指数时间更进一步。正如我们所说，在指数时间内，我们可以迭代所有可能的元素组合。然而，在阶乘时间中，我们可以以所有可能的顺序迭代所有可能的元素组合。因此，例如，使用与之前相同的示例，我们现在将*【5，7】*和*【7，5】*作为要迭代的独立子数组，因为尽管包含相同的元素，但它们的顺序不同。

# 结论

总之，时间复杂度是一个重要的概念，它指的是算法运行所需的时间。理解时间复杂性可以帮助你做出明智的决定，在不同的情况下使用哪些算法，这是软件工程工作的技术面试中的一个常见话题。通过熟悉上面提到的不同算法的时间复杂性，您可以确保您的程序尽可能快速有效地运行。

在结束之前，在计算时间复杂度时，需要记住两件重要的事情:

*   如果一个算法由连续的阶段组成，那么总时间复杂度是任何一个阶段的最大时间复杂度。例如，如果你的代码有一个循环，后面是一个三重嵌套循环，那么时间复杂度将是 *O(n )* ，而不是 *O(n+n )* 。
*   时间复杂度考虑最坏的情况。所以在排序算法的情况下，我们假设数组是真正混乱的，例如，不仅仅需要交换一个元素。