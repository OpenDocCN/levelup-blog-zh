<html>
<head>
<title>Dependency Injection in Go using Receiver Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用接收函数在Go中进行依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-in-go-using-receiver-functions-d76b7e541ecd?source=collection_archive---------5-----------------------#2020-05-26">https://levelup.gitconnected.com/dependency-injection-in-go-using-receiver-functions-d76b7e541ecd?source=collection_archive---------5-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1bf3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在golang中实现依赖注入的简单而强大的技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63773156eff78ad1cd04b4e7d300162b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RFI9ibT1varnCNOv"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="5391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入是分离代码的伟大技术，使它更加稳定、可测试和健壮。该技术包括设计您的代码来接收依赖项。在面向对象的语言中，我们通常使用类构造函数来实现。所以当有人创建你的对象的实例时，所有的依赖关系都会被注入其中。这非常有意义，因为依赖关系不应该是接口签名的一部分，否则所有的实现都必须接收依赖关系作为完成工作的参数。但是每个实现基于它们所做的事情可以有不同的依赖关系。你明白问题所在，对吧？</p><p id="4f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了，所以在一个面向对象的世界里，你只需要设计你的代码来接收对构造函数的依赖，你就有了一个非常解耦的代码，可以用mocks等工具进行测试。那交易是什么？</p><p id="4308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go没有类，只有structs，不支持构造函数。那么在这种情况下，我们如何使用依赖注入呢？</p><p id="350f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种技术是利用接收器功能来实现。</p><h2 id="34a9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">接收器功能/方法</h2><p id="4205" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接收器函数也称为方法，是绑定到类型的一种特殊类型的函数。您可以识别它们，因为它们在关键字<code class="fe mt mu mv mw b">func</code>之后、函数名之前包含接收者。例如:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="7e16" class="lv lw it mw b gy nb nc l nd ne">type text string</span><span id="ccf6" class="lv lw it mw b gy nf nc l nd ne">func <strong class="mw iu">(t text)</strong> print() {<br/>   fmt.Println(t)<br/>}</span></pre><p id="35e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你想调用这个方法时，你可以调用<code class="fe mt mu mv mw b">variable.method()</code></p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="f49b" class="lv lw it mw b gy nb nc l nd ne">func main() {<br/>   var t text<br/>   t = "a"<br/>   t.print()<br/>}</span></pre><p id="e3e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单，这看起来就像在Java和C#等语言中调用方法一样。</p><p id="e2dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果我的函数有任何依赖关系，我可以创建一个包含所有依赖关系的结构，并通过这个结构注入它们。这样我就不必更改任何接口签名或类似的东西。这非常类似于通过构造函数注入依赖关系。在一些场景中，函数的签名必须非常具体，这种模式被证明非常有用。我将展示其中的两个。</p><h2 id="0541" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Web服务器处理程序</h2><p id="ec40" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">处理函数必须是<code class="fe mt mu mv mw b">func(ResponseWriter, *Request)</code>类型，所以我们不能传递更多的参数给它。这里有一个如何使用接收器函数注入这些内容的快速示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="85f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个虚拟的例子，但是它展示了如何注入依赖来完成<code class="fe mt mu mv mw b">HandleRequest</code>功能。我们只需要从我们的<code class="fe mt mu mv mw b">dependencies</code>结构中填充<code class="fe mt mu mv mw b">externalService</code>(第25行)。我们实际上可以为模拟<code class="fe mt mu mv mw b">externalService</code>的<code class="fe mt mu mv mw b">HandleRequests</code>函数编写单元测试，以准确返回我们测试所需的数据。</p><h2 id="089b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">AWS函数</h2><p id="7757" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">同样的模式也适用于aws lambda函数。根据aws <a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/golang-handler.html" rel="noopener ugc nofollow" target="_blank">文档</a>，函数的签名需要匹配以下之一:</p><ul class=""><li id="5b90" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe mt mu mv mw b">func ()</code></li><li id="1f4d" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mt mu mv mw b">func () error</code></li><li id="7331" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mt mu mv mw b">func (TIn), error</code></li><li id="a13b" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mt mu mv mw b">func () (TOut, error)</code></li><li id="a00e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mt mu mv mw b">func (context.Context) error</code></li><li id="2647" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mt mu mv mw b">func (context.Context, TIn) error</code></li><li id="729e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mt mu mv mw b">func (context.Context) (TOut, error)</code></li><li id="c257" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe mt mu mv mw b">func (context.Context, TIn) (TOut, error)</code></li></ul><p id="9035" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从SSM获得一些配置，或者从Dynamo DB获取一些东西，以及许多其他情况，您经常需要在lambda中与其他AWS解决方案进行交互。你可以像上面的例子一样注入它们。AWS为您可能需要的服务提供了接口。这意味着，如果你依赖于它们而不是它们的实际实现，你可以很容易地出于测试目的而模仿它们。利用这一点。值了。让我们创建一个例子来描述Lambda函数中DynamoDB上的一个表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到与之前完全相同的模式。这一次我们创建一个lambda，它为<strong class="lb iu"> DynamoDB </strong>中的一个表名返回<strong class="lb iu"> ARN </strong>(亚马逊资源名)。重要的是我们在<code class="fe mt mu mv mw b">main</code>函数上注入了<code class="fe mt mu mv mw b">DynamoDB</code>服务。在我们的<code class="fe mt mu mv mw b">dependencies</code>结构上，我们也依赖于一个接口，在本例中是由AWS提供的，但是我们实际上可以创建自己的接口，只定义我们正在使用的方法。这样我们可以很容易地为<code class="fe mt mu mv mw b">HandleRequest</code>函数编写单元测试。这是另一个要点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="522c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们正在创建<code class="fe mt mu mv mw b">mockDynamoDBAPI</code>结构(在第12行)并且只实现我们想要模仿的方法<code class="fe mt mu mv mw b">DescribeTable</code>(在第16行)。然后我们可以创建一个简单的测试用例，在<code class="fe mt mu mv mw b">DescribeTable</code>方法返回错误时测试<code class="fe mt mu mv mw b">HandleRequest</code>函数。我们都完成了！</p><h2 id="af9f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="345c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果使用得当，依赖注入是一项伟大的技术。在go中实现它的方式与面向对象语言略有不同，但这仍然是可能的，而且非常简单。</p></div></div>    
</body>
</html>