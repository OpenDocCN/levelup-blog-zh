<html>
<head>
<title>How Does A Hash Table Work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希表是如何工作的？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-a-hash-table-in-javascript-29aca1edfe2b?source=collection_archive---------4-----------------------#2020-02-28">https://levelup.gitconnected.com/implementing-a-hash-table-in-javascript-29aca1edfe2b?source=collection_archive---------4-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/19db0af98301bed54e12008ec55074ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k88CNDUcMzSPfss7ZuXkMw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@pisitheng?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">皮斯特亨</a>在<a class="ae jg" href="https://unsplash.com/s/photos/dictionary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="4289" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过自己设计和建造来学习。教程</p><h1 id="919d" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是哈希表？</h1><p id="0984" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">数据结构用于存储可以在固定时间内访问的键值对(大多数情况下)。</p><h2 id="0894" class="mh lf jj bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">为什么要使用哈希表？</h2><p id="f83f" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">哈希表可以用来解决需要跟踪不同变量而不需要显式编写它们的问题。</p><p id="ec36" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来举个例子。假设您有以下字符串，“abgcddcccfmlk”</p><p id="b043" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在假设要求您确保字符串中没有任何重复超过3次的字母。</p><h2 id="82b8" class="mh lf jj bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">你会怎么做？</h2><p id="8ed3" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">天真的答案是使用<strong class="ki jk">两个嵌套循环</strong>将每个字母与其余的<strong class="ki jk">逐个进行比较</strong>，并确保该字母不会重复超过3次。</p><p id="8b77" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这种解决方案可行，但它需要<strong class="ki jk"> n </strong>次操作才能完成，其中<strong class="ki jk"> n等于数组的大小。</strong>我们可以看到这种解决方案会变得非常低效。</p><p id="f644" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在假设我们有一个散列表来记录每个字母重复的次数。</p><h2 id="71b8" class="mh lf jj bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">我们的哈希表应该是这样的</h2><blockquote class="mt"><p id="d2fd" class="mu mv jj bd mw mx my mz na nb nc ld dk translated">[答:1 ]</p></blockquote><p id="2529" class="pw-post-body-paragraph kg kh jj ki b kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated">当我们遍历字符串时，我们将更新找到的所有值，并在遍历过程中给它们各自的计数加1。在字符串的一次迭代之后，我们的哈希表在遍历数组中的最后一个“c”之前应该是这样的。</p><blockquote class="mt"><p id="f6f0" class="mu mv jj bd mw mx my mz na nb nc ld dk translated">[甲:1，乙:1，庚:1，丙:3，丁:2]</p></blockquote><p id="5f29" class="pw-post-body-paragraph kg kh jj ki b kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz nh lb lc ld im bi translated">我们可以看到，如果我们给<strong class="ki jk"> <em class="ni"> c </em> </strong>加1，它将变成<strong class="ki jk"> 4 </strong>，从而使我们的字符串“无效”。我们可以简单地在这里停止并返回false，而不查看数组的其余部分，因为我们知道我们的字符串已经无效，因为<strong class="ki jk">“c”重复超过3次</strong>。这最多需要<strong class="ki jk"> n次操作</strong>，这比我们之前的解决方案好得多。</p><p id="6106" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望您现在能明白为什么散列表对这类问题如此有用，以及它所有可能的用例。</p><p id="cd94" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们对哈希表在实践中是如何工作的有了更好的理解，让我们开始用JavaScript/TypeScript实现它。</p><blockquote class="nj nk nl"><p id="2587" class="kg kh ni ki b kj kk kl km kn ko kp kq nm ks kt ku nn kw kx ky no la lb lc ld im bi translated">注意:TypeScript和JavaScript之间唯一的区别是变量类型的声明。在下面的代码片段中，代码是用TypeScript编写的，但是通过删除类型定义，可以很容易地将其转换成javascript。</p></blockquote><p id="6ed4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如</p><pre class="np nq nr ns gt nt nu nv nw aw nx bi"><span id="c9e7" class="mh lf jj nu b gy ny nz l oa ob"><strong class="nu jk">//in typescript</strong><br/>var addOne(num: number): number {<br/>     return num++;<br/>}</span><span id="21b6" class="mh lf jj nu b gy oc nz l oa ob"><strong class="nu jk">//in javascript</strong><br/>var addOne(num) {<br/>     return num++;<br/>}</span></pre><p id="4e15" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不是说我们已经得到了我们的方式，让我们挖掘！</p><h1 id="5643" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为我们的哈希表创建一个类</h1><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="8321" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们可以看到我们的类有两个属性。尺寸和桌子。我们的哈希表只是一个常规数组，大小是它的长度。稍后会详细介绍</p><h1 id="e98e" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">决定哈希表的大小</h1><p id="6bd8" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于特定的输入，散列函数应该总是返回相同的输出。我们的结果不应该是随机的。</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5cef" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们遍历字符串，将每个字符转换成它的ASCII码* 100。之后，我们使用<em class="ni">模数运算符(%) </em>使生成的id适合我们的范围(数组的大小)；</p><blockquote class="nj nk nl"><p id="0744" class="kg kh ni ki b kj kk kl km kn ko kp kq nm ks kt ku nn kw kx ky no la lb lc ld im bi translated">这意味着我们生成的任何id，都将是一个从0到我们指定的大小值的数；</p></blockquote><h1 id="9362" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在哈希表中插入和检索值</h1><p id="cf4d" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了插入一个值，我们简单地散列我们的键，并使用<strong class="ki jk"> id </strong>作为索引将它的值保存在表中。</p><p id="d918" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了检索键值，我们可以简单地散列我们想要找到的键，并使用<strong class="ki jk"> id </strong>作为索引来访问数组。</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="c112" class="mh lf jj bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">等等，如果两个不同的键产生相同的id会发生什么？</h2><p id="3ac7" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">比如说我们的尺寸= 2；</p><p id="7b5a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很有可能我们的哈希函数会返回1，或者2。</p><p id="8f58" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们用键“cat”保存一个值，用键“dog”保存另一个值，我们的值可能会被覆盖，因为我们的数组中只有两个空格。</p><blockquote class="mt"><p id="2a81" class="mu mv jj bd mw mx my mz na nb nc ld dk translated">当散列两个不同的密钥产生相同的id时。我们称之为碰撞。</p></blockquote><h1 id="fec5" class="le lf jj bd lg lh li lj lk ll lm ln lo lp of lr ls lt og lv lw lx oh lz ma mb bi translated">那么，我们该如何解决这个问题呢？</h1><p id="41f8" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有各种方法可以解决这个问题，但是我们将使用一个<strong class="ki jk">链表</strong>来解决我们的“小”问题。</p><p id="20b7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现这一点，我们需要在构造函数中的数组的每个索引中压缩一个链表。我们还必须更新我们的<em class="ni"> insert() </em>和<em class="ni"> get() </em>方法，所以</p><div class="is it gp gr iu oi"><a href="https://medium.com/javascript-in-plain-english/implementing-a-linked-list-in-javascript-717d2ab5d9a9" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jk gy z fp on fr fs oo fu fw ji bi translated">用Javascript实现一个链表</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">今天我们将创建我们自己的二叉查找树实现，但是在我们写一行代码之前，它…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ja oi"/></div></div></a></div><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f7eb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在已经成功地实现了一个哈希表，它使用一个链表来处理冲突。</p><div class="is it gp gr iu oi"><a href="https://medium.com/everything-javascript/binary-search-tree-in-javascript-635cc8a3eecf" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jk gy z fp on fr fs oo fu fw ji bi translated">了解二分搜索法树(第一部分)</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">到目前为止，我们已经介绍了链表和散列表，但是是时候通过学习二叉树来更进一步了…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ja oi"/></div></div></a></div><p id="5ad5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">这是最终结果</strong></p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="58e3" class="mh lf jj bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated"><strong class="ak">以及用于该实现的链表</strong></h2><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f8b8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:如果我们的哈希表太小或者哈希函数不够好，我们的哈希表可能会降低两个非常大的链表的性能，这将降低从一开始使用一个链表所获得的整体性能优势。</p><p id="90f2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着O(1)的存取时间可以降低到0(n)；</p><p id="5884" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢这个教程，不要忘了关注我，将来会有更多关于数据结构和算法的内容。</p><p id="5456" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天到此为止。</p></div><div class="ab cl oy oz hx pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="im in io ip iq"><h1 id="6705" class="le lf jj bd lg lh pf lj lk ll pg ln lo lp ph lr ls lt pi lv lw lx pj lz ma mb bi translated">分级编码</h1><p id="0e77" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="fdbb" class="pk pl jj ki b kj kk kn ko kr pm kv pn kz po ld pp pq pr ps bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="4a35" class="pk pl jj ki b kj pt kn pu kr pv kv pw kz px ld pp pq pr ps bi translated">📰查看<a class="ae jg" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="840b" class="pk pl jj ki b kj pt kn pu kr pv kv pw kz px ld pp pq pr ps bi translated">🔔关注我们:<a class="ae jg" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae jg" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae jg" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="f017" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🚀👉<a class="ae jg" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ki jk">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>