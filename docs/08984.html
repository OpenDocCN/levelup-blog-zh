<html>
<head>
<title>Stacked Directories — A directory/file watcher for static website generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆叠目录—静态网站生成器的目录/文件监视器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stacked-directories-a-directory-file-watcher-for-static-website-generators-1b0d2daf3cfb?source=collection_archive---------9-----------------------#2021-06-24">https://levelup.gitconnected.com/stacked-directories-a-directory-file-watcher-for-static-website-generators-1b0d2daf3cfb?source=collection_archive---------9-----------------------#2021-06-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="f67a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">当一个静态网站生成器可以自动观察源文件，自动重建任何改变的页面，自动更新浏览器标签时，这是非常方便的。让网页自动重建几乎和所见即所得编辑器一样好。一些静态生成的网站项目需要复杂的目录配置。从AkashaCMS项目中分离出来的一个新的Node.js包旨在支持这种复杂的目录关系，同时自动监视这些目录中的文件，并发出可以驱动自动重建已更改或添加的文件的事件。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/10f26920d59b5eaf21d8fc3abf6ce2ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*myrdnctOdpx0jVM-.jpg"/></div></div></figure><p id="1496" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我在2013年开始开发AkashaCMS】，目标是在低端共享主机上支持高流量网站，同时使用现代JavaScript和CSS技术。长长的功能列表中缺少的是自动重建页面以获得完整预览和早期检测错误的能力。实现该功能导致了对AkashaCMS的重大重写，其核心是一个新的独立模块，可以由任何静态网站生成器使用。</p><p id="4eae" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">该模块<em class="lc">堆叠目录</em>，处理复杂的目录层次关系，覆盖文件的能力，以及自动扫描目录层次中的变化(添加、更改和删除)。在使用中，应用程序提供了一个要查看的目录列表，以及它们与<em class="lc">渲染输出目录</em>中的位置的关系。</p><p id="2e8a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lc">堆栈目录</em>模块的范围是</p><ul class=""><li id="1f1b" class="ld le iu jt b ju jv jy jz kc lf kg lg kk lh ko li lj lk ll bi translated">配置了一个或多个要监视其文件的目录</li><li id="ff35" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated">目录之间的优先顺序，例如给定文件可以存在于多个目录中，要使用的文件位于优先级最高的目录中</li><li id="cc15" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated">在虚拟文件系统空间中定位目录</li><li id="8a9a" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated">检测对文件的更改、新文件的添加和现有文件的删除，发出相应的事件</li></ul><p id="f550" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们所说的<em class="lc">虚拟文件系统空间</em>是指一个静态生成的网站被构建到的目录。一些这样的项目需要聚集来自多个源目录的内容，其中一些是为了呈现到网站的子目录中</p><p id="6984" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个包不支持将内容呈现到HTML/CSS/etc中，也不包含在页面重建后自动重新加载浏览器的特性。相反，它意味着将<em class="lc">堆叠目录</em>构建到一个更大的系统中，该系统具有这些和其他特性。在<em class="lc">堆栈目录</em>存储库中有一个示例静态网站生成器，名为SimpleCMS，它展示了一种使用这个包来支持自动重建网站内容的方法。</p><h1 id="7016" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">重写静态网站项目配置中的任何文件</h1><p id="2fb2" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">上图展示了<em class="lc">堆叠目录</em>的一个核心特性。它来自AkashaCMS的一个核心原则，即每个文件都可以被覆盖。但是，这意味着什么呢？</p><p id="6ee1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">考虑一个在网站中实现博客的模块。博客的一个特点是按时间倒序排列的索引(博客的<em class="lc">新闻河</em>)。这意味着博客模块将包括模板，以协助格式化博客文章内容，新闻河流和其他博客工具。问题是，静态网站生成器如何支持定制那些模板？主题包可能需要定制这些模板，网站所有者也是如此。</p><p id="7811" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这就是文件覆盖发挥作用的地方。</p><p id="07f0" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在AkashaCMS中有四个目录栈:a) <em class="lc">文档</em>是文档文件所在的地方，b) <em class="lc">资产</em>是像图像或CSS或JavaScript这样的文件，它们被简单地复制到输出目录中，c) <em class="lc">布局</em>是覆盖整个页面的模板，d) <em class="lc">片段</em>是用于格式化特定元素的模板。刚刚描述的主题化任务由<em class="lc">部分模板</em>处理。</p><p id="37b3" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">上图描述了<em class="lc">部分</em>目录堆栈和一个文件<code class="fe mu mv mw mx b">news-river.html.njk</code>的作用。这个模板是使用Nunjucks语法编写的，并且与格式化一条<em class="lc">新闻河</em>有关。在该图中，每个框是<em class="lc">部分</em>目录堆栈中的一个目录。这张图片中最上面的方框可能是网站本身。第二个盒子可以是打包的主题，提供由其他插件提供的模板的特定主题实现。第四个盒子可能是博客模块。该模块提供了默认的<code class="fe mu mv mw mx b">news-river.html.njk</code>模板，而主题模块和网站都用自己的实现覆盖了它。</p><p id="cb24" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">报告给应用程序的是堆栈中最顶层的文件。</p><p id="ad09" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是一个用例，覆盖文件以支持可定制性。</p><h1 id="8fa2" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">从多个来源组合静态网站内容</h1><p id="bcad" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">另一个用例是从几个来源收集内容。营销团队、技术出版团队、支持团队都有内容要在网站上展示。但是每个团队都有自己的管理，自己的时间表，并且可能有自己的Git存储库来存储内容文件。这些想法引出了另一个概念:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/18df52c3729592bbcec1087054c85361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*23XYlqzHv5cDfgIp.jpg"/></div></div></figure><p id="fe4f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">静态生成的网站将被渲染到输出目录中。我们将该目录视为一个<em class="lc">虚拟</em>路径层次结构，不同的源目录实际上被<em class="lc">挂载</em>到这个虚拟层次结构中的一个位置。例如，<code class="fe mu mv mw mx b">/news</code>的源目录不需要命名为<code class="fe mu mv mw mx b">news</code>，可以有任何名称。渲染系统应该安排渲染文件进入渲染输出目录的<code class="fe mu mv mw mx b">news</code>目录。</p><p id="1af4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">一个相关的例子是网站上使用的前端框架。例如，Bootstrap框架反过来需要PopperJS，您可能希望使用像Font Awesome这样的图标库。每个框架都有自己的发行版，需要放在像<code class="fe mu mv mw mx b">/vendor/bootstrap</code>或<code class="fe mu mv mw mx b">/vendor/fontawesome</code>这样的目录中。</p><p id="8291" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">要考虑的最后一个特性是监视文件，自动重建任何发生变化的内容，并使用重建的内容自动更新web浏览器选项卡。显然，这样一个功能需要浏览各种相关的目录，在渲染时将文件映射到正确的位置，以闪电般的速度做一切事情，因为现代人非常不耐烦，想要马上得到一切。</p><p id="ce77" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">AkashaCMS的子项目Stacked Directories旨在处理跟踪文件以支持刚才描述的需求。它是为在AkashaCMS中使用而设计的，但是可以被任何其他项目使用。见鬼，除了静态网站生成器之外，它甚至对其他应用程序也很有用。</p><h1 id="fbc8" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">安装堆叠目录包</h1><p id="699b" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated"><em class="lc">堆叠目录</em>包只通过<em class="lc"> npm </em>库发布。因此，在Node.js项目中的安装是:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="61fb" class="nc ls iu mx b gz nd ne l nf ng">$ npm install @akashacms/stacked-dirs</span></pre><p id="e5ff" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">请随意将该命令音译为您喜欢的包管理器，如Yarn。</p><p id="1fdf" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">源代码在:<a class="ae lb" href="https://github.com/akashacms/stacked-directories" rel="noopener ugc nofollow" target="_blank">https://github.com/akashacms/stacked-directories</a></p><p id="0f8d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">项目文件:<a class="ae lb" href="https://akashacms.github.io/stacked-directories/" rel="noopener ugc nofollow" target="_blank">https://akashacms.github.io/stacked-directories/</a></p><p id="525e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">现在我们已经将它安装在一个项目目录中，让我们看看如何使用Stacked Directories模块。</p><p id="3d90" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">首先，在Node.js源代码中:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="5918" class="nc ls iu mx b gz nd ne l nf ng">import { DirsWatcher } from '@akashacms/stacked-dirs'; <br/>...<br/>const docsWatcher = new DirsWatcher('documents');</span></pre><p id="8d96" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">DirsWatcher</code>是一个包含代码的类，它在幕后管理一个<em class="lc"> Chokidar </em>实例。您可以根据应用程序的需要创建尽可能多的该类的实例。例如，AkashaCMS使用四个实例，一个跟踪文档文件，另一个跟踪资产，另一个跟踪页面布局模板，最后一个跟踪部分模板。传递给构造函数的字符串，在本例中是<code class="fe mu mv mw mx b">documents</code>，用作这个DirsWatcher实例的名称。这个类对名字不做任何事情，所以你可以用任何你喜欢的方式使用它。</p><p id="f0ec" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">DirsWatcher实例本身不做任何事情。这意味着它不会开始监视任何目录，直到它被告知要监视哪些目录，我们还没有做到这一点。一旦你提供了一个目录列表，它将开始扫描这些目录，并发出事件。我们将在下一节回顾这些事件。</p><p id="e297" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">必须遵循的结构是:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="2acd" class="nc ls iu mx b gz nd ne l nf ng">import { DirsWatcher } from '@akashacms/stacked-dirs';<br/>... <br/>const docsWatcher = new DirsWatcher('documents');</span><span id="fd9e" class="nc ls iu mx b gz nh ne l nf ng">// Configure event listeners -- see next section</span><span id="7339" class="nc ls iu mx b gz nh ne l nf ng">docsWatcher.watch([<br/>    <!-- -->// list of directory descriptors<br/>]);</span></pre><p id="0123" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<em class="lc"> watch </em>方法中，我们提供了要监视的目录列表。为了捕捉所有事件，有必要在调用<em class="lc"> watch </em>之前设置事件监听器。</p><p id="657f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">每个目录描述符都是一个具有以下部分或全部字段的对象:</p><ul class=""><li id="bf5f" class="ld le iu jt b ju jv jy jz kc lf kg lg kk lh ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">mounted</code> -要引用的文件系统目录</li><li id="5729" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">mountPoint</code> -虚拟文件空间内的位置</li><li id="6e5b" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">ignore</code> -一个或多个“全局”模式，指示要忽略的文件</li></ul><p id="1fff" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">例如:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="5744" class="nc ls iu mx b gz nd ne l nf ng">assetsWatcher.watch([<br/>{<br/>      mounted: 'assets', mountPoint: '/',<br/>     ignore: [<br/>         '**/.DS_Store',<br/>         '**/.placeholder'<br/>     ]<br/>},<br/>{<br/>   mounted: 'node_modules/bootstrap/dist',<br/>   mountPoint: 'vendor/bootstrap'<br/>},<br/>{<br/>   mounted: 'node_modules/jquery/dist',<br/>   mountPoint: 'vendor/jquery'<br/>},<br/>{<br/>   mounted: 'node_modules/popper.js/dist',<br/>   mountPoint: 'vendor/popper.js' <br/>}<br/>]);</span></pre><p id="9b65" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这有四个条目，显示了每个字段的用法。</p><ul class=""><li id="5318" class="ld le iu jt b ju jv jy jz kc lf kg lg kk lh ko li lj lk ll bi translated"><em class="lc">挂载的</em>字段是文件系统中的一个位置，可以是相对的也可以是绝对的。</li><li id="6288" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><em class="lc">挂载点</em>字段是虚拟文件空间内的一个位置</li><li id="b6bf" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">/</code>的<em class="lc">挂载点</em>值意味着该目录被<em class="lc">挂载到虚拟空间的根目录</em>。</li><li id="b3c1" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><em class="lc">忽略</em>字段列出了要忽略的文件的“全局”模式。这种类型的模式在许多工具中使用，关于精确的格式，请查看Node.js的Minimatch包。</li></ul><p id="220c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">此示例演示了如何将目录装入虚拟空间。但是它没有明确演示目录堆栈。考虑一下如果这些文件存在会发生什么:</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj ni"><img src="../Images/1a38ce389549ca0354848ba82dd4a762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQsldcqCfiTd9q8n3tm0kw.png"/></div></div></figure><p id="3f9b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是我们列表中的两个目录，包含具有相同虚拟路径的文件。虚拟路径是通过将<em class="lc">挂载点</em>值连接到目录中的路径来计算的。但是，你可能想知道什么是虚拟路径？</p><p id="90ed" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lc">虚拟路径</em>不是文件系统中源目录的路径。相反，它是<em class="lc">渲染输出目录</em>中的路径。呈现的输出目录是最终将部署到服务器的内容。在<em class="lc">堆栈目录</em>中有一个虚拟路径的方面<strong class="jt iv">而不是</strong>被处理，这就是在渲染文件时发生的文件名转换。例如，降价文件的扩展名为<code class="fe mu mv mw mx b">.md</code>，但被渲染为扩展名为<code class="fe mu mv mw mx b">.html</code>的文件。但是它被认为超出了<em class="lc">堆栈目录</em>了解转换算法的范围，因为它不渲染文件。</p><p id="8971" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">堆叠目录要做的是找到所有具有相同虚拟路径的文件，并一起报告它们。我们将在后面讨论的对象将第一个匹配的文件显示为主要结果，在其他地方它列出了所有匹配的文件。</p><p id="14e6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在这个例子中，<code class="fe mu mv mw mx b">assets</code>中的文件可以说是<em class="lc">隐藏</em>或<em class="lc">覆盖<code class="fe mu mv mw mx b">node_modules/bootstrap/dist</code>中的文件。</em></p><p id="9c53" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">更明确的目录堆叠演示包括将以下内容放在上述数组的前面:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="d91c" class="nc ls iu mx b gz nd ne l nf ng">{<br/>     mounted: 'assets-overlay', mountPoint: '/',<br/>     ignore: [<br/>         '**/.DS_Store',<br/>         '**/.placeholder'<br/>     ]<br/>}</span></pre><p id="0a9c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在这种情况下，您在同一个挂载点上有两个目录。因为<code class="fe mu mv mw mx b">assets-overlay</code>目录在<code class="fe mu mv mw mx b">assets</code>前面，所以它的文件会隐藏<code class="fe mu mv mw mx b">assets</code>中任何对应的文件。</p><h1 id="7d28" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">由DirsWatcher实例发出的事件</h1><p id="3cfc" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">现在我们已经看到了如何配置堆叠目录，让我们来讨论一下从DirsWatcher实例发出的事件。</p><p id="005b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">DirsWatcher类是EventEmitter的子类。这意味着它有所有熟悉的方法来发出事件，并让应用程序订阅这些事件。</p><p id="d91b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">完整的推荐应用程序结构是:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="3ca4" class="nc ls iu mx b gz nd ne l nf ng">const watcher = new DirsWatcher('watcher-name');</span><span id="3502" class="nc ls iu mx b gz nh ne l nf ng">watcher.on('change', (name, vpinfo) =&gt; { ... });<br/>watcher.on('add', (name, vpinfo) =&gt; { ... });<br/>watcher.on('unlink', (name, vpinfo) =&gt; { ... });<br/>watcher.on('ready', (name) =&gt; { ... });</span><span id="9585" class="nc ls iu mx b gz nh ne l nf ng">await watcher.watch([ ... ]);</span></pre><p id="08a3" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">换句话说，目前有四个事件:</p><ul class=""><li id="4b10" class="ld le iu jt b ju jv jy jz kc lf kg lg kk lh ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">add</code> - DirsWatcher在关注的目录中发现了一个新添加的文件</li><li id="ddf7" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">change</code> - DirsWatcher发现被监视目录中的现有文件发生了变化</li><li id="9908" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">unlink</code> - DirsWatcher检测到一个现有文件不再存在</li><li id="7c82" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">ready</code> - DirsWatcher已完成对监视目录的初始扫描</li></ul><p id="f16e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">第一次启动DirsWatcher实例时会发生<em class="lc">初始扫描</em>。它扫描目录，并为找到的每个文件发出<code class="fe mu mv mw mx b">add</code>事件。一旦扫描完所有文件，它就会发出一个<code class="fe mu mv mw mx b">ready</code>事件。之后，只有在添加新文件、更改或删除现有文件时，它才会发出事件。</p><p id="5837" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">vpinfo</code>对象包含一个描述给定文件的文件堆栈的简化数据对象。这里有一个例子:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="c9d1" class="nc ls iu mx b gz nd ne l nf ng">{<br/>   fspath: 'documents-overlay/affiliate.html.md',<br/>   vpath: 'affiliate.html.md',<br/>   mime: 'text/markdown',<br/>   mounted: 'documents-overlay',<br/>   mountPoint: '/',<br/>   pathInMounted: 'affiliate.html.md',<br/>   stack: [<br/>     {<br/>       fspath: 'documents-overlay/affiliate.html.md',<br/>       vpath: 'affiliate.html.md',<br/>       mime: 'text/markdown',<br/>       mounted: 'documents-overlay',<br/>       mountPoint: '/',<br/>       pathInMounted: 'affiliate.html.md'<br/>     },<br/>     {<br/>       fspath: 'documents-example/affiliate.html.md',<br/>       vpath: 'affiliate.html.md',<br/>       mime: 'text/markdown',<br/>       mounted: 'documents-example',<br/>       mountPoint: '/',<br/>       pathInMounted: 'affiliate.html.md'<br/>     }<br/>   ]<br/>}</span></pre><p id="700d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在这种情况下，文件<code class="fe mu mv mw mx b">affiliate.html.md</code>出现在堆栈中的两个目录中。顶层元素描述了堆栈的最前面的条目。<code class="fe mu mv mw mx b">stack</code>字段包含栈中每个文件的描述。</p><p id="2cf4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这些字段的含义是:</p><ul class=""><li id="67da" class="ld le iu jt b ju jv jy jz kc lf kg lg kk lh ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">fspath</code> -这是主机文件系统中的路径名</li><li id="49bf" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">vpath</code> -虚拟文件系统中的路径</li><li id="b7fb" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">mime</code> -文件的MIME类型</li><li id="6f38" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">mounted</code>-<em class="lc">安装了该文件所在目录条目的</em>字段。</li><li id="b881" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">mountPoint</code>-<em class="lc">挂载</em>的虚拟文件系统位置</li><li id="c49b" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">pathInMounted</code> -相对于<code class="fe mu mv mw mx b">mounted</code>目录的文件名</li><li id="4223" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko li lj lk ll bi translated"><code class="fe mu mv mw mx b">stack</code> -所有目录中具有相同<code class="fe mu mv mw mx b">vpath</code>值的文件的完整列表</li></ul><p id="ab98" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">前面我们说过DirsWatcher不计算渲染的虚拟路径。该计算必须在应用程序中处理。在AkashaCMS中，接收DirsWatcher事件的类计算呈现的虚拟路径，将其添加为<code class="fe mu mv mw mx b">renderedPath</code>字段。</p><h1 id="1d57" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">simple CMS——一个简单的静态网站生成器，使用DirsWatcher在几个小时内完成</h1><p id="87de" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">最后，让我们看看如何在应用程序中使用DirsWatcher。它正在AkashaCMS的核心AkashaRender中使用，但是那里有太多的代码来制作一个有效的例子。相反，在Github资源库中，你会发现<em class="lc"> SimpleCMS </em>，这是一个超精简的静态网站生成器。这个例子是在几个小时内构建的，作为DirsWatcher的临时测试工具。</p><p id="367f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在存储库中，您可以找到一个名为<code class="fe mu mv mw mx b">test</code>的目录，以及另一个名为<code class="fe mu mv mw mx b">example</code>的目录。<code class="fe mu mv mw mx b">test</code>目录下有一个普通的单元测试套件，其中包含一些样本文件的目录。<code class="fe mu mv mw mx b">example</code>目录包含<code class="fe mu mv mw mx b">simplecms</code>和<code class="fe mu mv mw mx b">project</code>，前者是SimpleCMS的实现，后者是我们可以使用SimpleCMS呈现的部分项目。</p><p id="e856" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">example/simplecms/index.mjs</code>中找到以下代码:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="2f23" class="nc ls iu mx b gz nd ne l nf ng">import { DirsWatcher } from '@akashacms/stacked-dirs';<br/>// import { DirsWatcher } from '../../lib/watcher.mjs';<br/>import path from 'path'; import { promises as fs } from 'fs';<br/>import { render, renderedPath } from './render.mjs';<br/>import yaml from 'js-yaml';</span></pre><p id="ec0d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这将导入所需的包和函数。您会注意到有两行用于导入<em class="lc"> DirsWatcher </em>。在实际的示例代码中，您会找到第二个，但是在常规应用程序中，您会找到第一个。</p><p id="982b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">有一个模块我们不会在本文中讨论，<code class="fe mu mv mw mx b">render.mjs</code>，它包含一个简单的渲染引擎。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="9a3e" class="nc ls iu mx b gz nd ne l nf ng">// Read the configuration from a YAML file</span><span id="d587" class="nc ls iu mx b gz nh ne l nf ng">if (process.argv.length &lt; 2 || !process.argv[2]) {<br/>     console.error('USAGE: node index.mjs config.yaml');<br/>     process.exit(1); <br/>}  </span><span id="7579" class="nc ls iu mx b gz nh ne l nf ng">let ymltxt = await fs.readFile(process.argv[2], 'utf8'); <br/>let cfg = yaml.load(ymltxt);  <br/>let batchmode = cfg.batchmode;  <br/>const docsDirectories = cfg.dirs.documents;  <br/>export const renderedOutput = cfg.dirs.output; <br/>export const layoutsDir = cfg.dirs.layout; <br/>export const partialsDir = cfg.dirs.partial;  </span><span id="8e70" class="nc ls iu mx b gz nh ne l nf ng">// Do initializations in the Render module <br/>import { init } from './render.mjs'; <br/>init(layoutsDir, partialsDir);  </span><span id="1b28" class="nc ls iu mx b gz nh ne l nf ng">////////////// END OF CONFIGURATION SECTION</span></pre><p id="d99f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这将读取一个YAML文件，该文件必须在命令行中命名，它将包含配置设置。这个部分通过调用<code class="fe mu mv mw mx b">render.mjs</code>中的<code class="fe mu mv mw mx b">init</code>函数结束。该模块包含用于呈现文件的代码。因为本文关注的是使用DirsWatcher，所以我们不会展示该文件中的内容。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="ba23" class="nc ls iu mx b gz nd ne l nf ng">const docsWatcher = new DirsWatcher('documents');</span><span id="1cb2" class="nc ls iu mx b gz nh ne l nf ng">docsWatcher.on('ready', async (name) =&gt; {<br/>     console.log(`documents ready ${name}`);<br/>     if (batchmode) await close(); <br/>}) <br/>.on('change', async (name, info) =&gt; {<br/>     console.log(`documents change ${name} ${info.vpath}`, info);<br/>     try {<br/>         await render(info);<br/>     } catch (err) {<br/>         console.error(`documents change ERROR `, err.stack);<br/>     } <br/>}) <br/>.on('add', async (name, info) =&gt; {<br/>     console.log(`documents add ${name} ${info.vpath}`, info);<br/>     try {<br/>         await render(info);<br/>     } catch (err) {<br/>         console.error(`documents add ERROR `, err.stack);<br/>     } <br/>}) <br/>.on('unlink', async (name, info) =&gt; {<br/>     console.log(`documents unlink ${name} ${info.vpath}`, info);<br/>     try {<br/>         await fs.unlink(<br/>             path.join(renderedOutput, renderedPath(info.vpath)));<br/>     } catch (err) {<br/>         console.error(`documents unlink ERROR `, err.stack);<br/>     } <br/>});  </span><span id="ccbc" class="nc ls iu mx b gz nh ne l nf ng">docsWatcher.watch(docsDirectories);  </span><span id="83c5" class="nc ls iu mx b gz nh ne l nf ng">async function close() {<br/>     await docsWatcher.close(); <br/>}</span></pre><p id="2acf" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是我们配置和使用DirsWatcher实例的地方。</p><p id="5c6c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">SimpleCMS对世界的看法非常简单，因为只有一个DirsWatcher实例。该实例用于跟踪文档文件。对于页面布局模板和其他模板，它们是在<code class="fe mu mv mw mx b">layoutsDir</code>和<code class="fe mu mv mw mx b">partialsDir</code>变量中命名的单个目录。</p><p id="93ce" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">接下来要注意的是对事件的响应。对于<em class="lc">添加</em>和<em class="lc">更改</em>事件，它只是调用<code class="fe mu mv mw mx b">render</code>函数。但是，对于<em class="lc"> unlink </em>事件，它会从渲染输出目录中删除相应的文件。最后，对于<em class="lc">就绪</em>事件，如果处于<em class="lc">批处理</em>模式，它会关闭DirsWatcher，其副作用是导致脚本退出。</p><p id="72fe" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在一个功能更全的CMS中，你可能会以不同的方式处理这个问题。例如，将数据保存到索引中是很有用的，一个目的是允许呈现一个页面引用存储在另一个页面中的数据。此外，不是简单地调用<code class="fe mu mv mw mx b">render</code>函数，而是应该使用一个<em class="lc">工作队列</em>来确保同时工作的数量不会淹没系统。</p><p id="774b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lc"> add </em>和<em class="lc"> change </em>事件意味着要么有一个新的内容文件，要么有一个已更改的内容文件，我们必须将其渲染到输出目录中的一个文件中。</p><p id="3be5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在DirsWatcher中，并不是每次添加或更改都会触发这些事件。相反，只有当添加或更改是针对目录堆栈中最前面的文件时，才会触发它们。考虑前面显示的<code class="fe mu mv mw mx b">affiliate.html.md</code>例子。<code class="fe mu mv mw mx b">documents-overlay</code>中的文件是堆栈中最前面的文件。有四个有趣的场景:</p><ol class=""><li id="2b0c" class="ld le iu jt b ju jv jy jz kc lf kg lg kk lh ko nj lj lk ll bi translated">文件<code class="fe mu mv mw mx b">documents-overlay/affiliate.html.md</code>改变，触发<em class="lc">改变</em>事件。</li><li id="b9ce" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko nj lj lk ll bi translated">堆栈中有一个比<code class="fe mu mv mw mx b">documents-overlay</code>优先级高的目录，其中添加了一个名为<code class="fe mu mv mw mx b">affiliate.html.md</code>的文件。在这种情况下，会触发<em class="lc">添加</em>事件。</li><li id="d25c" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko nj lj lk ll bi translated">文件<code class="fe mu mv mw mx b">documents-example/affiliate.html.md</code>被更改。在这种情况下，它不是堆栈中最前面的文件，因此不会触发任何事件。</li><li id="326c" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko nj lj lk ll bi translated">另一个目录在堆栈中的优先级低于<code class="fe mu mv mw mx b">documents-overlay</code>，其中添加了一个名为<code class="fe mu mv mw mx b">affiliate.html.md</code>的文件。在这种情况下，不会触发任何事件，因为新文件不是堆栈中最前面的文件。</li></ol><p id="5417" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">render</code>功能主要是将一个文件(比如Markdown文件)转换成一种对网站有用的格式。它支持两种Markdown文件，呈现为HTML，可选的布局模板。它还支持将更少的文件编译成CSS。<code class="fe mu mv mw mx b">render</code>函数还支持简单地将文件复制到渲染输出目录中，因为不是所有的文件类型都需要转换。</p><p id="3396" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lc"> unlink </em>事件需要一些更深入的思考。假设您的目录栈对于给定的虚拟路径有两个文件，就像前面显示的<code class="fe mu mv mw mx b">affiliate.html.md</code>例子一样。有三种情况需要考虑:</p><ol class=""><li id="4045" class="ld le iu jt b ju jv jy jz kc lf kg lg kk lh ko nj lj lk ll bi translated">文件<code class="fe mu mv mw mx b">documents-overlay/affiliate.html.md</code>被删除。在这种情况下，文件<code class="fe mu mv mw mx b">documents-example/affiliate.html.md</code>现在是堆栈中最前面的文件。你可以说这个文件已经被揭开或取消隐藏。结果是触发了一个<em class="lc">变更</em>事件，显示<code class="fe mu mv mw mx b">documents-example/affiliate.html.md</code>为主要文件。</li><li id="85f2" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko nj lj lk ll bi translated">文件<code class="fe mu mv mw mx b">documents-example/affiliate.html.md</code>被删除。在这种情况下，它不是堆栈中最前面的文件，也不会触发任何事件。</li><li id="e3c9" class="ld le iu jt b ju lm jy ln kc lo kg lp kk lq ko nj lj lk ll bi translated">如果堆栈中只有一个文件，并且该文件被删除。在这种情况下，没有其他文件具有相同的虚拟路径，因此触发了<em class="lc"> unlink </em>事件。</li></ol><p id="1a23" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们在unlink处理程序中看到一个函数<code class="fe mu mv mw mx b">renderedPath</code>被调用。该函数获取一个虚拟路径名(<code class="fe mu mv mw mx b">vpath</code>)，并将其转换为输出目录中该文件的路径名。例如,<code class="fe mu mv mw mx b">epub/chap5/b/chap5b.html.md</code>中的<code class="fe mu mv mw mx b">vpath</code>必须成为输出目录中的<code class="fe mu mv mw mx b">epub/chap5/b/chap5b.html</code>。具体来说，此函数使用以下算法重写路径的基本名称部分(最后一个斜杠之后的部分):</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/f3ae7631b510c4225ddc122d9dd07529.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*2qea32ngFjVB5CwwZ6nyGw.png"/></div></figure><p id="1973" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">双扩展名模式(<code class="fe mu mv mw mx b">.html.md</code>)是因为这是AkashaCMS中使用的文件名模式。想法是在文件名中记录文件的格式和输出格式。</p><p id="627a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">最后要讨论的事件是<em class="lc">就绪</em>。如前所述，该事件在初始文件扫描完成时触发。结果是为堆栈中每个目录中的每个文件发送了一个<em class="lc"> add </em>事件。</p><p id="bb5a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果应用程序的目标是不断地监视要重建的文件，那么DirsWatcher实例应该继续运行。但是，如果目标只是简单地建立网站然后退出，那么<em class="lc"> ready </em>活动是考虑退出的好时机。使用SimpleCMS，所有文件都调用了<em class="lc"> render </em>函数，因此所有文件都被渲染或复制到输出目录中。</p><p id="acf7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">该实现调用<code class="fe mu mv mw mx b">DirsWatcher.close</code>，其作用是关闭监视文件更改的模块(Chokidar)。只要有活动的事件侦听器，Node.js进程就会继续执行。这意味着一旦所有对<code class="fe mu mv mw mx b">render</code>的调用执行完毕，将不再有事件监听器，Node.js将退出。</p><h1 id="c2a2" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">运行简单的SimpleCMS示例</h1><p id="2311" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">在堆栈目录库中，有几个测试文件的目录。在<code class="fe mu mv mw mx b">example/simplecms</code>目录中，我们有一个配置文件，列出了作为输入目录的那些测试目录。即:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="de1f" class="nc ls iu mx b gz nd ne l nf ng"># batchmode: false   # For continuous execution <br/>batchmode: true  </span><span id="d007" class="nc ls iu mx b gz nh ne l nf ng">dirs:<br/>     documents:<br/>         - mounted: '../project/documents-overlay'              <br/>           mountPoint: '/'<br/>         - mounted: '../../test/documents-example'           <br/>           mountPoint: '/'<br/>         - mounted: '../../test/documents-epub-skeleton'<br/>           mountPoint: 'epub'<br/>     output: ../project/out<br/>     layout: ../project/layouts<br/>     partial: ../../test/partials-base</span></pre><p id="de54" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个配置对象直接对应于前面显示的代码。</p><p id="44bc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">example/simplecms/package.json</code>中，你会发现这个<code class="fe mu mv mw mx b">scripts</code>部分:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="219a" class="nc ls iu mx b gz nd ne l nf ng">"scripts": {<br/>     "start": "node index.mjs" <br/>},</span></pre><p id="c926" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这样，我们可以通过运行<code class="fe mu mv mw mx b">npm start</code>来运行SimpleCMS，但是我们必须这样做以避免它崩溃:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="ebf5" class="nc ls iu mx b gz nd ne l nf ng">$ npm start -- cfg.yaml</span></pre><p id="132c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">使用npm，<code class="fe mu mv mw mx b">--</code>之后的任何内容都会附加到执行的命令行中。因此，这相当于运行<code class="fe mu mv mw mx b">node index.mjs cfg.yaml</code>，好处是<code class="fe mu mv mw mx b">package.json</code>为您记住了命令字符串。</p><p id="cf5f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在这种配置下，文档文件来自指定的目录。<code class="fe mu mv mw mx b">documents-overlay</code>目录是为了让我们试验叠加文件，以了解这是如何工作的。<code class="fe mu mv mw mx b">documents-epub-skeleton</code>目录显示挂载到一个子目录中。</p><p id="0bad" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">渲染将输出到<code class="fe mu mv mw mx b">project/out</code>，<code class="fe mu mv mw mx b">project/layouts</code>目录包含布局模板。<code class="fe mu mv mw mx b">test</code>目录的各种子目录包含针对AkashaCMS项目格式化的文件，它们不会直接用于SimpleCMS。</p><p id="5b43" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">最后，因为<code class="fe mu mv mw mx b">batchmode</code>被设置为<code class="fe mu mv mw mx b">true</code>，该命令将读取所有文件，渲染它们，然后退出。</p><p id="1994" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果您运行一次，您将看到一个显示<em class="lc"> Add </em>事件的跟踪，随后是对<em class="lc"> renderMarkdown </em>的调用。每个文件都会发生这种情况，然后很快就结束了，你就在命令行了。新创建的<code class="fe mu mv mw mx b">out</code>目录包含<code class="fe mu mv mw mx b">.html</code>文件，检查这些文件会有所帮助。将模板和内容文件与输出文件进行比较非常有用。</p><p id="ef32" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">例如，研究<code class="fe mu mv mw mx b">test/documents-example/markdown.html.md</code>。最上面是这个:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="26a3" class="nc ls iu mx b gz nd ne l nf ng">--- <br/>layout: default.html.ejs <br/>title: Markdown example <br/>tags: Markdown <br/>---</span></pre><p id="fb25" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个<em class="lc"> Frontmatter </em>是一个YAML格式的块，使用灰质包进行解析。标签声明使用哪个布局模板。其他行作为元数据结束，在呈现布局模板时提供。目前SimpleCMS支持EJS或Nunjucks模板。</p><p id="6dba" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个文件的主体是一个标准的Markdown测试文档，它实现了Markdown的大部分功能。你将在<code class="fe mu mv mw mx b">project/out/markdown.html</code>中找到生成的模板，你可以将它与<code class="fe mu mv mw mx b">default.html.ejs</code>模板进行比较，看看它们是如何组合在一起的。</p><p id="09bb" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">要切换到连续渲染模式，在<code class="fe mu mv mw mx b">cfg.yaml</code>中进行以下更改:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="bdad" class="nc ls iu mx b gz nd ne l nf ng">batchmode: false   # For continuous execution <br/># batchmode: true</span></pre><p id="a6a1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这改变了对<em class="lc">就绪</em>事件的响应，使得DirsWatcher实例不被关闭。这会导致SimpleCMS不退出，并继续响应DirsWatcher事件，如上所述。</p><p id="0037" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">先说文件<code class="fe mu mv mw mx b">example/project/documents-overlay/affiliate.html.md</code>。这将覆盖另一个文件<code class="fe mu mv mw mx b">test/documents-example/affiliate.html.md</code>。</p><p id="8c42" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对该文件进行任何更改都会导致以下响应:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="bcea" class="nc ls iu mx b gz nd ne l nf ng">documents change documents affiliate.html.md {<br/>   fspath: '../project/documents-overlay/affiliate.html.md',<br/>   vpath: 'affiliate.html.md',<br/>   mime: 'text/markdown',<br/>   mounted: '../project/documents-overlay',<br/>   mountPoint: '/',<br/>   pathInMounted: 'affiliate.html.md',<br/>   stack: [<br/>     {<br/>       fspath: '../project/documents-overlay/affiliate.html.md',<br/>       vpath: 'affiliate.html.md',<br/>       mime: 'text/markdown',<br/>       mounted: '../project/documents-overlay',<br/>       mountPoint: '/',<br/>       pathInMounted: 'affiliate.html.md'<br/>     },<br/>     {<br/>       fspath: '../../test/documents-example/affiliate.html.md',<br/>       vpath: 'affiliate.html.md',<br/>       mime: 'text/markdown',<br/>       mounted: '../../test/documents-example',<br/>       mountPoint: '/',<br/>       pathInMounted: 'affiliate.html.md'<br/>     }<br/>   ]<br/>} <br/>renderedPath affiliate.html.md ==&gt; affiliate.html <br/>renderMarkdown affiliate.html.md ==&gt; ../project/out/affiliate.html</span></pre><p id="3c4a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们看到一个<em class="lc"> Change </em>事件，带有预期的<em class="lc"> vpinfo </em>对象，描述堆栈中的两个文件。然后它计算<em class="lc"> renderedPath </em>，最后呈现Markdown。</p><p id="5368" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">将其名称更改为<code class="fe mu mv mw mx b">example/project/documents-overlay/affiliate-foo.html.md</code>会导致以下事件:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="fe1a" class="nc ls iu mx b gz nd ne l nf ng">documents change documents affiliate.html.md {<br/>   fspath: '../../test/documents-example/affiliate.html.md',<br/>   vpath: 'affiliate.html.md',<br/>   mime: 'text/markdown',<br/>   mounted: '../../test/documents-example',<br/>   mountPoint: '/',<br/>   pathInMounted: 'affiliate.html.md',<br/>   stack: [<br/>     {<br/>       fspath: '../../test/documents-example/affiliate.html.md',<br/>       vpath: 'affiliate.html.md',<br/>       mime: 'text/markdown',<br/>       mounted: '../../test/documents-example',<br/>       mountPoint: '/',<br/>       pathInMounted: 'affiliate.html.md'<br/>     }<br/>   ]<br/>} <br/>renderedPath affiliate.html.md ==&gt; affiliate.html <br/>renderMarkdown affiliate.html.md ==&gt; ../project/out/affiliate.html<br/> documents add documents affiliate-foo.html.md {<br/>   fspath: '../project/documents-overlay/affiliate-foo.html.md',<br/>   vpath: 'affiliate-foo.html.md',<br/>   mime: 'text/markdown',<br/>   mounted: '../project/documents-overlay',<br/>   mountPoint: '/',<br/>   pathInMounted: 'affiliate-foo.html.md',<br/>   stack: [<br/>     {<br/>       fspath: '../project/documents-overlay/affiliate-foo.html.md',<br/>       vpath: 'affiliate-foo.html.md',<br/>       mime: 'text/markdown',<br/>       mounted: '../project/documents-overlay',<br/>       mountPoint: '/',<br/>       pathInMounted: 'affiliate-foo.html.md'<br/>     }<br/>   ] <br/>} <br/>renderedPath affiliate-foo.html.md ==&gt; affiliate-foo.html <br/>renderMarkdown affiliate-foo.html.md ==&gt; ../project/out/affiliate-foo.html</span></pre><p id="ce6b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们首先得到一个<em class="lc">更改</em>事件，接着是一个<em class="lc">添加</em>事件。<em class="lc">变更</em>事件将<code class="fe mu mv mw mx b">affiliate.html.md</code>最前面的文件描述为<code class="fe mu mv mw mx b">test/documents-example/affiliate.html.md</code>。换句话说，该文件不再被<code class="fe mu mv mw mx b">documents-overlay</code>中的文件隐藏。</p><p id="0442" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lc">添加</em>事件是因为原来的<code class="fe mu mv mw mx b">documents-overlay/affiliate.html.md</code>文件现在被命名为<code class="fe mu mv mw mx b">documents-overlay/affiliate-foo.html.md</code>。换句话说，DirsWatcher认为这是一个新添加的文件。</p><p id="431d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对于SimpleCMS来说，这看起来像是删除了<code class="fe mu mv mw mx b">documents-overlay/affiliate.html.md</code>，显示了<code class="fe mu mv mw mx b">test/documents-example/affiliate.html.md</code>，然后添加了<code class="fe mu mv mw mx b">documents-overlay/affiliate-foo.html.md</code>。</p><p id="350e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们已经演示了前面描述的部分事件，那么如果我们简单地添加一个新文件会发生什么呢？</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="a437" class="nc ls iu mx b gz nd ne l nf ng">documents add documents new-file.md {<br/>   fspath: '../project/documents-overlay/new-file.md',<br/>   vpath: 'new-file.md',   mime: 'text/markdown',<br/>   mounted: '../project/documents-overlay',<br/>   mountPoint: '/',<br/>   pathInMounted: 'new-file.md',<br/>   stack: [<br/>     {<br/>       fspath: '../project/documents-overlay/new-file.md',<br/>       vpath: 'new-file.md',<br/>       mime: 'text/markdown',<br/>       mounted: '../project/documents-overlay',<br/>       mountPoint: '/',<br/>       pathInMounted: 'new-file.md'<br/>     }<br/>   ] <br/>} <br/>renderedPath new-file.md ==&gt; new-file.html <br/>renderMarkdown new-file.md ==&gt; ../project/out/new-file.html</span></pre><p id="9f3e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这是一个新创建的文件，您可以在<code class="fe mu mv mw mx b">project/out</code>目录中查看结果。正如所料，一个<em class="lc">添加</em>事件被触发，随后是呈现文件的<code class="fe mu mv mw mx b">renderMarkdown</code>调用。</p><p id="9fdf" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">然后，如果我们简单地删除这个文件:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="e237" class="nc ls iu mx b gz nd ne l nf ng">documents unlink documents new-file.md {<br/>   fspath: '../project/documents-overlay/new-file.md',<br/>   vpath: 'new-file.md',<br/>   mime: 'text/markdown',<br/>   mounted: '../project/documents-overlay',<br/>   mountPoint: '/',<br/>   pathInMounted: 'new-file.md'<br/>} <br/>renderedPath new-file.md ==&gt; new-file.html</span></pre><p id="79fc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">触发了一个<em class="lc"> Unlink </em>事件，请注意<em class="lc"> vpinfo </em>对象没有<code class="fe mu mv mw mx b">stack</code>字段。在目录堆栈中找不到匹配的文件，因为该文件已被删除。这样做的结果是计算渲染文件的文件名，并调用<code class="fe mu mv mw mx b">fs.unlink</code>删除渲染文件。而且，确实，<code class="fe mu mv mw mx b">project/out/new-file.html</code>就要没了。</p><h1 id="9fb8" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">摘要</h1><p id="649d" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">DirsWatcher类很容易成为自定义静态网站生成器应用程序的基础。SimpleCMS的例子离一个有用的系统不远了。</p><p id="1511" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">DirsWatcher已经准备好出发，看起来相当稳定。它是几年来为AkashaCMS开发代码的结果，并且已经使用AkashaCMS模块进行了深入测试。</p></div><div class="ab cl nl nm hy nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="in io ip iq ir"><p id="34fb" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lc">原载于</em><a class="ae lb" href="https://akashacms.com/news/2021/06/stacked-dirs.html" rel="noopener ugc nofollow" target="_blank"><em class="lc">https://akashacms.com</em></a><em class="lc">。</em></p></div></div>    
</body>
</html>