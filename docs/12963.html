<html>
<head>
<title>Building an IoT Application Using an HTTP API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用HTTP API构建物联网应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-an-iot-application-using-an-http-api-d60d42ac2599?source=collection_archive---------14-----------------------#2022-07-26">https://levelup.gitconnected.com/building-an-iot-application-using-an-http-api-d60d42ac2599?source=collection_archive---------14-----------------------#2022-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/84f939b6df355ef5e57b3e3b7b526df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6crEmES9Ks_wo5ogQfY-dQ.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@kwan_fvng?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">关峰</a>在<a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="1fac" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">咖啡店里的编码</h2><div class=""/><div class=""><h2 id="0cb7" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">M5Stack、纽约市MTA和Gravitee设计师</h2></div><p id="8939" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">多年来，世界上一直充斥着物联网设备。这些设备从显示当前天气的闹钟到显示附近食品价格的冰箱。无论具体情况如何，这些设备都依赖API与数据源进行通信。但是，我们究竟如何连接消息、数据和设备呢？</p><p id="f104" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本帖中，我们将向您展示如何为物联网设备设计和建模数据的示例。我们将使用<a class="ae jg" href="https://m5stack.com" rel="noopener ugc nofollow" target="_blank">M5 stack</a>——一种带有显示屏的小型模块化物联网设备——并连接到纽约市大都会运输管理局(MTA纽约市)的<a class="ae jg" href="https://new.mta.info/developers" rel="noopener ugc nofollow" target="_blank"> API，以呈现各个车站的最新地铁时间。</a></p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div class="gh gi md"><img src="../Images/62972bba091db35bb18e796bc36dbf27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*4zCm1Wny_HFH5Z8zbMdU0Q.jpeg"/></div></figure><p id="54d2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然我们将重点关注M5Stack，但我们将讨论的概念将适用于跨各种设备设计物联网应用。</p><p id="f7cd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">所以让我们开始吧！</p><h1 id="4a81" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">先决条件</h1><p id="4ce0" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">在本教程中，我们将围绕如何从API请求数据来关注更大的概念。<em class="nf">一些</em>编程知识会很有帮助。虽然你不需要一个M5Stack，但是如果你<em class="nf">有一个</em>的话，那么你可以跟着做，把完成的项目上传到你自己的设备上。</p><p id="2aae" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">记住这一点，你可以下载<a class="ae jg" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank"> VS代码IDE </a>和<a class="ae jg" href="https://marketplace.visualstudio.com/items?itemName=curdeveryday.vscode-m5stack-mpy" rel="noopener ugc nofollow" target="_blank">M5 stack插件</a>。如果你以前从未启动过M5Stack，<a class="ae jg" href="https://m5stack.github.io/UIFlow_doc/en/en/base/Setting_WIFI.html" rel="noopener ugc nofollow" target="_blank">按照他们的指导</a>来设置WiFi和必要的固件。对于这个项目，我们将使用<a class="ae jg" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python 3 </a>，这是M5Stack使用的主要编程语言。</p><p id="1176" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你需要<a class="ae jg" href="https://api.mta.info/#/landing" rel="noopener ugc nofollow" target="_blank">注册一个纽约MTA开发者账户</a>，获得一个免费的开发者API密匙来访问他们的实时地铁数据。</p><p id="f263" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，您应该注册一个免费的Gravitee帐户来使用<a class="ae jg" href="https://www.gravitee.io/platform/api-designer?hsLang=en" rel="noopener ugc nofollow" target="_blank"> API设计器</a>，这将使您更容易可视化和理解API调用中的数据流！</p><p id="6870" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个项目原始资料是受<a class="ae jg" href="https://github.com/neoterix/nyc-mta-arrival-notify" rel="noopener ugc nofollow" target="_blank">这个开源项目</a>的启发，所以如果有帮助的话，就开始创建这个库吧。</p><h1 id="d0e1" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">设计API交互</h1><p id="bd4f" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">在写一行代码之前，让我们后退一步，考虑一下完成这个项目需要什么样的信息:</p><ul class=""><li id="51f3" class="ng nh jj lj b lk ll ln lo lq ni lu nj ly nk mc nl nm nn no bi translated">相关地铁站的信息</li><li id="3788" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">哪趟列车经过那些车站</li><li id="d208" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">关于那些火车的最新实时数据</li></ul><p id="73d2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">根据文档，API分为<a class="ae jg" href="http://web.mta.info/developers/developer-data-terms.html#data" rel="noopener ugc nofollow" target="_blank">静态数据馈送</a>和<a class="ae jg" href="https://api.mta.info/#/subwayRealTimeFeeds" rel="noopener ugc nofollow" target="_blank">实时数据馈送</a>。</p><p id="d092" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">静态数据馈送保存有关电台的信息。有了这些信息，我们就可以从实时数据馈送API获得实际的实时训练数据。MTA提供的数据采用以下CSV格式:</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="76ca" class="nz mj jj nv b gy oa ob l oc od">stop_id,stop_code,stop_name,stop_desc,stop_lat,stop_lon,zone_id,stop_url,location_type,parent_station</span></pre><p id="f623" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因为我们需要的唯一静态信息是电台ID，所以我们可以简单地选取一个随机的电台ID，并将其用于实时提要。在这种情况下，我选择<a class="ae jg" href="https://en.wikipedia.org/wiki/Hoyt%E2%80%93Schermerhorn_Streets_station" rel="noopener ugc nofollow" target="_blank">Hoyt–Schermerhorn站</a>是因为它相对复杂:两列独立的火车通过它(A和C)。车站也通过它们是北行还是南行来识别。</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="f5e4" class="nz mj jj nv b gy oa ob l oc od">A42,,Hoyt-Schermerhorn Sts,,40.688484,-73.985001,,,1,<br/>A42N,,Hoyt-Schermerhorn Sts,,40.688484,-73.985001,,,0,A42<br/>A42S,,Hoyt-Schermerhorn Sts,,40.688484,-73.985001,,,0,A42</span></pre><p id="8457" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从这些行中，我们需要的只是父站点ID (A42)来标识通过该站的列车，包括北行(A42N)和南行(A42S)。</p><p id="6bd7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">实时信息以谷歌的GTFS格式表示，该格式基于协议缓冲区。虽然纽约MTA没有记录在案的具体信息来源，但GTFS却有。从GTFS的文档中，我们可以知道如何以protobuf格式获得最新列车到达特定车站的时间。</p><p id="306d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是一个来自GTFS端点的响应示例，为了便于可视化，它被转换成了JSON:</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="1ad0" class="nz mj jj nv b gy oa ob l oc od">{<br/>  "trip":{<br/>     "trip_id":"120700_A..N",<br/>     "start_time":"20:07:00",<br/>     "start_date":"20220531",<br/>     "route_id":"A"<br/>  },<br/>  "stop_time_update":[<br/>     {<br/>        "arrival":{<br/>           "time":1654042672<br/>        },<br/>        "departure":{<br/>           "time":1654042672<br/>        },<br/>        "stop_id":"H06N"<br/>     },</span><span id="e4d3" class="nz mj jj nv b gy oe ob l oc od">//…more stops…</span><span id="46f4" class="nz mj jj nv b gy oe ob l oc od">{<br/>        "arrival":{<br/>           "time":1654044957<br/>        },<br/>        "departure":{<br/>           "time":1654044957<br/>        },<br/>        "stop_id":"A42N"<br/>     }<br/>  ]<br/>}</span></pre><p id="eced" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于纽约市MTA API会向您提供大量信息，因此使用Gravitee API设计器对API返回的内容进行建模、绘制和可视化数据会非常有帮助。这是我们的API设计者思维导图的快照:</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/394b160b056cee24ff9e59d825a94dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xYG2lFI4arwXyeDl"/></div></div></figure><p id="898b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">API设计器帮助您识别API的所有资源(端点),以及与我们的资源相关的数据属性。这些属性将包括端点需要的输入和它提供的输出。</p><p id="9f1d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们的地图中，我们有一个路径为<code class="fe og oh oi nv b">/gtfs/</code>的资源。我们可以根据需要附加任意多的属性，并且可以用数据类型来注释这些属性。通过查看我们的地图，我们可以绘制一条从终点到右下角标识的到达和离开时间的直接路径。</p><p id="0612" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，为了表示我们需要的数据，我们需要:</p><ul class=""><li id="a2bf" class="ng nh jj lj b lk ll ln lo lq ni lu nj ly nk mc nl nm nn no bi translated">识别我们要获取列车信息的车站的ID</li><li id="cbd7" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">针对我们感兴趣的火车线路，向纽约市MTA的GTFS feed发出HTTP请求</li><li id="6d62" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">迭代结果，将响应数组中的stop_id与我们的站id进行比较</li><li id="c20a" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">然后，我们可以根据特定车站和列车的时间信息采取行动</li></ul><p id="15b4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这代表了几个移动的部分，但它不应该是我们不能处理的任何事情！</p><h1 id="9cbd" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">编码它</h1><p id="6997" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">在我们的M5Stack上运行任何东西之前，让我们首先确保我们的代码在本地工作。我们将安装几个Python包来使我们的项目更容易构建。</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="8317" class="nz mj jj nv b gy oa ob l oc od">pip3 install - upgrade gtfs-realtime-bindings<br/>pip3 install protobuf3_to_dict<br/>pip3 install requests</span></pre><p id="edc9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">前两个包将协议缓冲区转换成Python字典(或散列)，这使得数据模型更容易使用。最后一个包使得从Python发出HTTP请求变得更加容易。</p><p id="52d4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将从导入Python包开始我们的程序:</p><p id="54d5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从google.transit导入gtfs_realtime_pb2 <br/>导入请求<br/>导入时间</p><p id="3d09" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们将向纽约MTA GTFS提要发出HTTP请求:</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="12a4" class="nz mj jj nv b gy oa ob l oc od">api_key = "YOUR_API_KEY"</span><span id="a792" class="nz mj jj nv b gy oe ob l oc od"># Requests subway status data feed from the NYC MTA API<br/>headers = {'x-api-key': api_key}<br/>feed = gtfs_realtime_pb2.FeedMessage()<br/>response = requests.get(<br/>    '<a class="ae jg" href="https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-ace'" rel="noopener ugc nofollow" target="_blank">https://api-endpoint.mta.info/Dataservice/mtagtfsfeeds/nyct%2Fgtfs-ace'</a>,<br/>    headers=headers)<br/>feed.ParseFromString(response.content)</span></pre><p id="d9df" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">到目前为止，一切顺利。我们在这里使用的GTFS端点是用于A/C/E列车的端点，我们可以通过URL上的后缀<code class="fe og oh oi nv b">-ace</code>来识别它。(除此之外，对于这个demo，我们不关心E火车——对不起，E火车！)</p><p id="1421" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们将GTFS协议缓冲响应转换成一个字典:</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="ba32" class="nz mj jj nv b gy oa ob l oc od">from protobuf_to_dict import protobuf_to_dict<br/>subway_feed = protobuf_to_dict(feed)  # converts MTA data feed to a dictionary<br/>realtime_data = subway_feed['entity']</span></pre><p id="e0a2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此时，我强烈建议发出print(realtime_data ),这样我们就可以看到实际的数据结构是什么样子。如果这是一个真实的项目，这样的分析可能会帮助您确定需要迭代字典中的哪些键和值——但是由于这是一个教程，我们已经讨论过了。</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="4c9c" class="nz mj jj nv b gy oa ob l oc od">def station_time_lookup(train_data, station):<br/>   for trains in train_data:<br/>       if trains.__contains__('trip_update'):<br/>           unique_train_schedule = trains['trip_update']<br/>           if unique_train_schedule.__contains__('stop_time_update'):<br/>             unique_arrival_times = unique_train_schedule['stop_time_update']<br/>             for scheduled_arrivals in unique_arrival_times:<br/>                 stop_id = scheduled_arrivals.get('stop_id', False)<br/>                 if stop_id == f'{station}N':<br/>                     time_data = scheduled_arrivals['arrival']<br/>                     unique_time = time_data['time']<br/>                     if unique_time != None:<br/>                         northbound_times.append(unique_time)<br/>                 elif stop_id == f'{station}S':<br/>                     time_data = scheduled_arrivals['arrival']<br/>                     unique_time = time_data['time']<br/>                     if unique_time != None:<br/>                         southbound_times.append(unique_time)</span><span id="8bda" class="nz mj jj nv b gy oe ob l oc od"># Keep a global list to collect various train times<br/>northbound_times = []<br/>southbound_times = []</span><span id="7539" class="nz mj jj nv b gy oe ob l oc od"># Run the above function for the station ID for Hoyt-Schermerhorn<br/>station_time_lookup(realtime_data, 'A42')</span></pre><p id="4606" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">突然我们有了很多代码！但是不要担心——我们正在做的事情并不复杂:</p><ul class=""><li id="5bbf" class="ng nh jj lj b lk ll ln lo lq ni lu nj ly nk mc nl nm nn no bi translated">我们迭代A/C线的列车信息数组。</li><li id="cbce" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">对于每个数组条目，我们验证我们拥有所有需要的键的值。这是防御性编码，因为我们不能100%确定这个第三方服务在我们需要的时候有我们需要的东西！</li><li id="a798" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">之后，我们迭代所有的车站信息，并在到达北向和南向列车都需要的父ID(<code class="fe og oh oi nv b">A42</code>)时停止。</li><li id="8a11" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">最后，我们在两个单独的全局变量中保存了即将到来的火车到达时间的列表。</li></ul><p id="c17e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，让我们展示这些信息:</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="988e" class="nz mj jj nv b gy oa ob l oc od"># Sort collected times in chronological order<br/>northbound_times.sort()<br/>southbound_times.sort()</span><span id="022f" class="nz mj jj nv b gy oe ob l oc od"># Pop off the earliest and second earliest arrival times from the list<br/>nearest_northbound_arrival_time = northbound_times[0]<br/>second_northbound_arrival_time = northbound_times[1]</span><span id="aece" class="nz mj jj nv b gy oe ob l oc od">nearest_southbound_arrival_time = southbound_times[0]<br/>second_southbound_arrival_time = southbound_times[1]</span><span id="55db" class="nz mj jj nv b gy oe ob l oc od">### UI FOR M5STACK SHOULD GO HERE ###</span><span id="46fd" class="nz mj jj nv b gy oe ob l oc od">def print_train_arrivals(<br/>        direction,<br/>        time_until_train,<br/>        nearest_arrival_time,<br/>        second_arrival_time):<br/>    if time_until_train &lt;= 0:<br/>        next_arrival_time = second_arrival_time<br/>    else nearest_arrival_time:<br/>        next_arrival_time_s = time.strftime(<br/>            "%I:%M %p",<br/>            time.localtime(next_arrival_time))<br/>    print(f"The next {direction} train will arrive at {next_arrival_time_s}")</span><span id="bf2e" class="nz mj jj nv b gy oe ob l oc od"># Grab the current time so that you can find out the minutes to arrival<br/>current_time = int(time.time())<br/>time_until_northbound_train = int(<br/>    ((nearest_northbound_arrival_time - current_time) / 60))<br/>time_until_southbound_train = int(<br/>    ((nearest_southbound_arrival_time - current_time) / 60))<br/>current_time_s = time.strftime("%I:%M %p")<br/>print(f"It's currently {current_time_s}")</span><span id="3087" class="nz mj jj nv b gy oe ob l oc od">print_train_arrivals(<br/>    "northbound",<br/>    time_until_northbound_train,<br/>    nearest_northbound_arrival_time,<br/>    second_northbound_arrival_time)<br/>print_train_arrivals(<br/>    "southbound",<br/>    time_until_southbound_train,<br/>    nearest_southbound_arrival_time,<br/>    time_until_southbound_train)</span></pre><p id="483d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们上面做的大部分是数据格式化。关键步骤如下:</p><ul class=""><li id="ac78" class="ng nh jj lj b lk ll ln lo lq ni lu nj ly nk mc nl nm nn no bi translated">我们在车站对北上和南下列车的到达时间进行排序。</li><li id="c643" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">我们乘坐前两次(到达的“最快”列车)。</li><li id="31fb" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">我们将这些时间与当前时间进行比较，以获得火车到达的分钟距离。我们将这些火车到达时间传递给print_train_arrivals。</li><li id="9316" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">如果下一班火车不到一分钟就要到达，我们会显示第<em class="nf">秒</em>到达时间——恐怕你赶不上那班火车了！否则，我们将显示最近的到达时间。</li></ul><p id="582f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您在终端上运行这个脚本，那么您应该会看到类似如下的消息:</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="8581" class="nz mj jj nv b gy oa ob l oc od">It's currently 05:59 PM<br/>The next northbound train will arrive at 06:00 PM<br/>The next southbound train will arrive at 06:02 PM</span></pre><h1 id="282c" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">部署到M5堆栈</h1><p id="6c73" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">既然我们已经在本地测试了我们的Python代码可以与纽约MTA API通信，那么是时候让这段代码在我们的M5Stack上运行了。对M5Stack编程最简单的方法是通过免费的UI Flow IDE 进行<a class="ae jg" href="https://flow.m5stack.com" rel="noopener ugc nofollow" target="_blank">，这只是一个通过WiFi与您的设备进行通信的网页。您可以通过</a><a class="ae jg" href="https://docs.m5stack.com/en/quick_start/core2/uiflow" rel="noopener ugc nofollow" target="_blank">他们的文档</a>了解有关如何配置您的设备进行WiFi访问的更多信息。</p><p id="c1cb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然M5Stack可以通过WYSIWYG UI元素进行编程，但它也可以接受(并运行)Python代码。然而，WYSIWYG元素的主要优点是它使得在屏幕上绘制的文本更加容易可视化:</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/40a49bcb2a69d2d231e09082bffc06d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZYmSd7f2NdOjufwU"/></div></div></figure><p id="3e6b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个GIF中，我在示例M5Stack屏幕上用默认字符串“Text”创建了一个标签。当我切换到Python时，我们看到标签是一个名为M5TextBox的对象的实例化。当拖动标签时，其X和Y坐标(构造函数中的前两个参数)在Python中会发生变化。这使得很容易看到你的程序将如何显示。您还可以通过单击标签本身来更改Python代码中使用的变量(以及其他属性):</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/3e5ec540a09704e754f5698f3d9f5cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/0*bwxmagS2e3Njxoqt"/></div></figure><p id="35e4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在大多数情况下，我们编写的Python脚本可以在M5Stack上使用，只需稍加修改。我们可以从本地机器复制Python代码，并将其粘贴到UI流IDE的Python选项卡中。</p><p id="3391" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们的代码中，我们找到了<code class="fe og oh oi nv b">### UI FOR M5STACK SHOULD GO HERE ###</code>注释并用下面的代码替换它下面的所有内容:</p><pre class="me mf mg mh gt nu nv nw nx aw ny bi"><span id="1235" class="nz mj jj nv b gy oa ob l oc od">time_label = M5TextBox(146, 27, "", lcd.FONT_Default, 0xFFFFFF, rotate=0)<br/>northbound_label = M5TextBox(146, 95, "", lcd.FONT_Default, 0xFFFFFF, rotate=0)<br/>southbound_label = M5TextBox(146, 163, "", lcd.FONT_Default, 0xFFFFFF, rotate=0)</span><span id="1399" class="nz mj jj nv b gy oe ob l oc od">def print_train_arrivals(<br/>        direction,<br/>        label,<br/>        time_until_train,<br/>        nearest_arrival_time,<br/>        second_arrival_time):<br/>    if time_until_train &lt;= 0:<br/>        next_arrival_time = second_arrival_time<br/>    else nearest_arrival_time:<br/>        next_arrival_time_s = time.strftime(<br/>            "%I:%M %p",<br/>            time.localtime(next_arrival_time))<br/>    label.setText(f"The next {direction} train will arrive at {next_arrival_time_s}")</span><span id="5f99" class="nz mj jj nv b gy oe ob l oc od">while True:<br/>    # Grab the current time so that you can find out the minutes to arrival<br/>    current_time = int(time.time())<br/>    time_until_northbound_train = int(<br/>        ((nearest_northbound_arrival_time - current_time) / 60))<br/>    time_until_southbound_train = int(<br/>        ((nearest_southbound_arrival_time - current_time) / 60))<br/>    current_time_s = time.strftime("%I:%M %p")<br/>    time_label.setText(f"It's currently {current_time_s}")</span><span id="c252" class="nz mj jj nv b gy oe ob l oc od">print_train_arrivals(<br/>        "northbound",<br/>        northbound_label,<br/>        time_until_northbound_train,<br/>        nearest_northbound_arrival_time,<br/>        second_northbound_arrival_time)<br/>    print_train_arrivals(<br/>        "southbound",<br/>        southbound_label,<br/>        time_until_southbound_train,<br/>        nearest_southbound_arrival_time,<br/>        time_until_southbound_train)<br/>  <br/>    sleep 5</span></pre><p id="570a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这其中的大部分应该看起来很熟悉！要让这段代码在M5Stack上运行，有两个主要的修改。</p><p id="e196" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我们创建了标签，作为时间和训练数据的占位符:</p><ul class=""><li id="844a" class="ng nh jj lj b lk ll ln lo lq ni lu nj ly nk mc nl nm nn no bi translated"><code class="fe og oh oi nv b">time_label</code></li><li id="c6cf" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated"><code class="fe og oh oi nv b">northbound_label</code></li><li id="07c5" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated"><code class="fe og oh oi nv b">southbound_label</code></li></ul><p id="ae30" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第二，我们把所有东西都放在了一个<code class="fe og oh oi nv b">while</code>循环中，这个循环将获取当前时间并设置标签文本。循环将休眠五秒钟，然后重新开始该过程。</p><p id="54ed" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">就是这样！当我们点击<strong class="lj jt"> Run </strong>按钮时，我们应该看到我们的火车字符串每五秒更新一次最新的路线数据。</p><h1 id="fb40" class="mi mj jj bd mk ml mm mn mo mp mq mr ms ky mt kz mu lb mv lc mw le mx lf my mz bi translated">结论</h1><p id="dd4d" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">就是这样！爱好者经常使用物联网设备，但如果你继续从事这个项目，有几个现实世界的考虑因素。一个考虑是速率限制，确保您从MTA API以有效的方式请求数据。另一个考虑是连接性。如果您的设备暂时失去WiFi访问，它将如何重新建立连接以获取所需的信息？</p><p id="cbca" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一旦您开始考虑这些生产级的问题，或者如果您想要跨多个设备扩展您的项目，您还需要考虑API管理。我在本文前面提到过Gravitee Designer，它在设计阶段非常有用。Gravitee拥有其他API管理工具，如API网关、监控和实时分析、部署。</p><p id="7eff" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于习惯于为传统服务器和web浏览器编写代码的开发人员来说，物联网应用开发似乎令人望而生畏。然而，向物联网设备的飞跃实际上相当小。今天的设备，凭借其对流行语言和框架的内置支持，使物联网成为构建或集成API和应用程序的有趣和创新的方式。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><h1 id="b7dc" class="mi mj jj bd mk ml os mn mo mp ot mr ms ky ou kz mu lb ov lc mw le ow lf my mz bi translated">分级编码</h1><p id="1939" class="pw-post-body-paragraph lh li jj lj b lk na kt lm ln nb kw lp lq nc ls lt lu nd lw lx ly ne ma mb mc im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="933c" class="ng nh jj lj b lk ll ln lo lq ni lu nj ly nk mc nl nm nn no bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="a247" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">📰查看<a class="ae jg" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="a31a" class="ng nh jj lj b lk np ln nq lq nr lu ns ly nt mc nl nm nn no bi translated">🔔关注我们:<a class="ae jg" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae jg" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae jg" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="db44" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">🚀👉<a class="ae jg" href="https://jobs.levelup.dev/jobs?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">软件工程师的热门职位</strong> </a></p></div></div>    
</body>
</html>