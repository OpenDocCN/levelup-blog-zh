<html>
<head>
<title>Stop Using Setters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用Setters</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stop-using-setters-785670f4bf8?source=collection_archive---------3-----------------------#2020-05-14">https://levelup.gitconnected.com/stop-using-setters-785670f4bf8?source=collection_archive---------3-----------------------#2020-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="15eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Setters-pattern是众多编程语言中最流行的一种。工程师们已经用了这么长时间，这种方法已经变得很明显了。甚至IDE现在只需点击几个热键就能为你生成setters。我认为在任何情况下都应该避免使用setters。该条目包含Java上的代码片段，但是这些规则可以应用于任何其他语言。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6c6ccb7a5d54c97084f963b19d8f7780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoBWeoxisnw0r1KjKiLIgQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/users/PublicDomainPictures-14/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=73326" rel="noopener ugc nofollow" target="_blank"> PublicDomainPictures </a>来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=73326" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="3aa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我打赌每个人都见过类似的东西。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://gist.github.com/SimonHarmonicMinor/26fcadcc0670f1c8efe9639d8922ba46" rel="noopener ugc nofollow" target="_blank">Java中Setters用法示例</a></figcaption></figure><p id="f5a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法看起来很优雅，但是让我们考虑一下。首先，我们实例化一个空对象，里面什么都没有。之后，我们一步一步地分配所需的值。如果我们忘记指定名字或年龄会怎样？这意味着未来的执行将处理一个不完整的对象。不仅如此，setters的存在意味着对象是可变的，可以被任何人在任何时候修改。让我们看另一个例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://gist.github.com/SimonHarmonicMinor/0984d13e9569a8cad788125885970077" rel="noopener ugc nofollow" target="_blank">将一个可变实体传递给另一个方法</a></figcaption></figure><p id="0b17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过调用<code class="fe lh li lj lk b">findAllSubordinates</code>并不期望<code class="fe lh li lj lk b">manager</code>上有任何突变，但是我们怎么知道呢？在这种情况下，<code class="fe lh li lj lk b">humanResources</code>可以只是一个接口。我们不知道它到底是如何工作的。所以，我们不知道<code class="fe lh li lj lk b">manager</code>的未来状态，因为它的公共API包含可以被调用的变异方法。</p><p id="ff5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许这一论点还不够有说服力。让我们看另一个例子。假设我们有一张员工及其支付率的地图。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://gist.github.com/SimonHarmonicMinor/3fe35f06c4468b3c0e92df84c49b16ab" rel="noopener ugc nofollow" target="_blank">意外的地图损坏</a></figcaption></figure><p id="89e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出是</p><pre class="kp kq kr ks gt ll lk lm ln aw lo bi"><span id="982f" class="lp lq it lk b gy lr ls l lt lu">Map: {[name=Jack, age=23]=35, [name=Julia, age=35]=65}<br/>Corrupted map: {[name=Jack, age=55]=35, [name=Julia, age=35]=65}<br/>Jack's rate: null<br/>Julia's rate: 65</span></pre><p id="c9ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">发生这种情况是因为新杰克的散列码不等于地图上包含的散列码。因此，这些键被认为是不同的。有一个黑客可以修复这种情况，但它值得另一个故事。</p><blockquote class="lv lw lx"><p id="c1e4" class="jq jr ly js b jt ju jv jw jx jy jz ka lz kc kd ke ma kg kh ki mb kk kl km kn im bi translated">编辑:<code class="fe lh li lj lk b">Person</code>必须实现<code class="fe lh li lj lk b">equals</code>和<code class="fe lh li lj lk b">hashCode</code>方法。否则，Jack的rate应该是35，因为默认的<code class="fe lh li lj lk b">hashCode</code>实现返回相同的值，即使您更改了一些字段值。感谢<a class="ae le" href="https://github.com/tw-abhi" rel="noopener ugc nofollow" target="_blank"> tw-abhi </a>指点！</p></blockquote><p id="44ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一下，我也见过有人在Spring这样的框架中使用带有依赖注入的setters。看看这个。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://gist.github.com/SimonHarmonicMinor/1e93c249e70ea7202c81ea59899eb3a1" rel="noopener ugc nofollow" target="_blank">带setter的Spring依赖注入</a></figcaption></figure><p id="73d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有人预料到<code class="fe lh li lj lk b">ParentService</code>的依赖性会突然消失。但是正如你所看到的，即使没有<a class="ae le" href="https://www.baeldung.com/java-reflection" rel="noopener ugc nofollow" target="_blank">反射API </a>，这也很容易做到。我的观点是，如果你的类有可以改变其状态的方法，这可能会导致不愉快的后果。</p><p id="5fe3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不管怎样，我们能做些什么呢？嗯，最简单的事情就是将所有需要的值传递给构造函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://gist.github.com/SimonHarmonicMinor/fea86121a61e8050bfefb74a26b17857" rel="noopener ugc nofollow" target="_blank">用构造函数实例化不可变对象</a></figcaption></figure><p id="791a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你看到现在所有属性都是<code class="fe lh li lj lk b">final</code>了吗？这很重要。这意味着值只能在构造函数范围内赋值一次。不变性向我们保证对象的恒定状态。我们可以把它传递给任何方法。我们甚至可以从多个线程安全地访问它。</p><p id="f275" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">"但是如果需要缺省值呢？"。好吧，Java不支持默认参数值，但是我们可以定义多个构造函数，省略一些参数。或者我们可以使用<a class="ae le" href="https://refactoring.guru/design-patterns/builder" rel="noopener ugc nofollow" target="_blank">构建器模式</a>。我们可以自己实现，但是我更喜欢使用<a class="ae le" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Lombok </a>库。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://gist.github.com/SimonHarmonicMinor/267897a0044cd6e75e7f28fa593057e6" rel="noopener ugc nofollow" target="_blank">使用构建器以替换默认参数值</a></figcaption></figure><p id="30da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在很明显哪个参数被赋值了。这种方法可能看起来类似于setters的用法，但是有很大的不同。在<code class="fe lh li lj lk b">build</code>方法调用之前，我们不会实例化一个对象。但是一旦它被创造了，它是不可改变的。</p><p id="4dce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时候开发人员用构造器来代替大的构造器。这似乎很有用，因为它使代码更干净、更直观，但是您应该注意这种情况。让我们看一看。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://gist.github.com/SimonHarmonicMinor/f61680f4f5222d7ab1609234e255f14d" rel="noopener ugc nofollow" target="_blank">用builder代替大型构造器</a></figcaption></figure><p id="bfe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，第二种方法明显更容易理解，但也很容易忘记一些论点。这种情况经常发生，尤其是当一个类用新参数增强时。有时候可以接受，有时候不行。不要忘记Builder-pattern的最初目的是实现默认参数值，而不是替换大型构造函数。如果你的类有很多依赖项，并且所有的依赖项都是必需的，那么最好把类分成几个。</p><h1 id="23e6" class="mc lq it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">结论</h1><p id="f1f7" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">我希望我使您相信setters的使用不是一个好的实践。有些情况下我们必须使用setters。例如，如果一个库为我们提供了这样的API。但是不要在你的项目中使用它们。不值得。感谢您的阅读！</p><h1 id="0693" class="mc lq it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">资源</h1><ul class=""><li id="f456" class="ne nf it js b jt mz jx na kb ng kf nh kj ni kn nj nk nl nm bi translated"><a class="ae le" href="https://www.baeldung.com/java-reflection" rel="noopener ugc nofollow" target="_blank">反射API </a></li><li id="4d68" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><a class="ae le" href="https://refactoring.guru/design-patterns/builder" rel="noopener ugc nofollow" target="_blank">建造者模式</a></li><li id="fb89" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated"><a class="ae le" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank">龙目岛</a></li></ul></div></div>    
</body>
</html>