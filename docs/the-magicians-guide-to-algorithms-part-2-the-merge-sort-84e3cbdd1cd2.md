# 魔术师算法指南，第 2 部分:合并排序

> 原文：<https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-2-the-merge-sort-84e3cbdd1cd2>

![](img/85a83f3f613da22e7f81b6f712a1f640.png)

上周，我们在帮助斯内普收集坩埚时，讨论了气泡分类。本周我们将跳到布莱克比尔，帮助昆汀·科尔德沃特整理他的扑克牌。这不会是完美的，昆汀知道这一点。你看，魔术是一件棘手的事情，不会总是给我们想要的结果。但是合并排序将使我们更接近于整理昆廷的混乱，所以我们将尝试一下。

**合并排序**

咒语是这样的:

或者说，这是咒语。合并排序(据我的研究显示)将总是需要两个函数来成功地排序 Quentin 的卡片组。原因是:您需要一个函数来递归地将列表分割成越来越小的列表，直到每个列表只包含一个条目，并且您需要另一个合并函数来将排序后的列表重新组合在一起。

`mergeSort`函数很容易解释。因为我们是优秀的魔术师(而且懒于此),如果列表只有一个项目，我们不希望函数过早返回，因为一个项目的列表总是排序的。

然后，长度超过一个条目的列表必须一分为二，首先找到中点，然后将列表分割成两个不同的变量。

最后，我们在另一个带两个参数的`merge`函数中递归调用`mergeSort`函数，这两个参数位于列表的左侧和右侧。

**合并功能**

merge 函数稍微复杂一点，但只是一点点。

`merge`函数的作用是将分离的列表按照从少到多的顺序合并在一起。这需要一个`while`循环，首先检查左侧和右侧列表的长度。如果一方没有，就没有必要排序。我们还可以假设剩余的边已经被排序了，因为 mergeSort 被递归地调用了。

当两个列表都有长度时，我们检查左边的第一项是否小于右边的。如果是这样，我们`shift`从左边的列表中取出第一个项目，并将其压入结果数组。我们可以这样做，因为`list.shift()`返回从数组开始移除的项目。

如果左边的元素比右边的大，我们做相反的事情。

最后，两个列表的剩余部分连接在一起。这样做的原因很简单，因为我们知道如果一个列表已经被清空，并且两个列表都已经被排序，那么剩余的元素就比结果数组中已经存在的元素要多。

**结论**

就这样，我们学会了如何给昆汀的卡片分类。

不相信我？取上面的代码，插入下面的代码:

`mergeSort([4, 2, 3, 5, 1, 7, 8, 10, 9, 6])`

分类了吗？我想是的。昆廷想学习更好、更强大的法术，以帮助他解决排序问题。下一次我们将报道[二分搜索法](https://medium.com/gitconnected/the-magicians-guide-to-algorithms-part-3-the-binary-search-20ced57ba929)，现在我们已经把昆汀的卡片整理好了。