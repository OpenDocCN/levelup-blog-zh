<html>
<head>
<title>Detecting memory leaks using Unit Tests in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用单元测试检测内存泄漏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/detecting-memory-leaks-using-unit-tests-in-swift-c37533e8ee4a?source=collection_archive---------3-----------------------#2021-02-26">https://levelup.gitconnected.com/detecting-memory-leaks-using-unit-tests-in-swift-c37533e8ee4a?source=collection_archive---------3-----------------------#2021-02-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内存管理是我们每次写代码都需要处理的话题。幸运的是，Swift帮助我们完成了<em class="kl">自动引用计数</em> (ARC)。但是人为错误仍然存在，正如我们在<a class="ae km" href="https://alfredohdz.medium.com/proxy-design-pattern-f040a6561bfb" rel="noopener">最后一个条目</a>中看到的，我们犯的一个常见错误是<em class="kl">保留周期。</em></p><p id="5ac3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个<strong class="jp ir">对象A </strong>保留另一个<strong class="jp ir">对象B </strong>并且<strong class="jp ir">对象B </strong>保留<strong class="jp ir">对象A</strong>时，产生一个保留周期。让我们看一个例子:</p><p id="c6e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有两个对象<code class="fe kn ko kp kq b">Parent</code>和<code class="fe kn ko kp kq b">Child</code> <em class="kl">、</em>，并创建了对它的两个引用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/cb1d44160cbb9aa712e059c0e01ae82d.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*ALalyzonqp2-Rn9ZewVffg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">这里我们有两个对两个对象的不同引用</figcaption></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="947f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，这两个变量都是可选的，然后我们将它们的属性赋给另一个对象(A赋给B and B，A赋给A)。分配<code class="fe kn ko kp kq b">john.parent</code>和<code class="fe kn ko kp kq b">mom.child</code>后，弧看起来是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/11d809b3de87eb458c0aa8a3b1e43334.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*736oml1o4pP3-LvIi6jOUg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">电弧从A作用到B</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/201aed01743b1b2845dab3514ea942b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*c5cicJGb2dMb9fDY3vNsPA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">从B到A作用的弧</figcaption></figure><p id="50b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果我们失去了来自<code class="fe kn ko kp kq b">mom</code>和<code class="fe kn ko kp kq b">john</code>变量的引用会怎么样呢？答案是我们<strong class="jp ir">生成一个保留周期</strong>。通过将两个变量都设为<code class="fe kn ko kp kq b">nil</code>，我们失去了引用，但它们仍然相互保留。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/85601570c69e53cf6ee01238bdf21d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*Fy7XAqgwpSV94qKIXRAqBA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">共同保持循环的方法</figcaption></figure><h2 id="42d3" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">检测内存泄漏的古老方法:</h2><p id="919e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">如果我们有内存泄漏，一个简单的“检测”方法是在反初始化器中添加一个简单的<code class="fe kn ko kp kq b">print</code>消息来验证<code class="fe kn ko kp kq b">deinit</code>从未被调用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将打印消息添加到定义块中</figcaption></figure><p id="8fbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行你的代码，你会发现<code class="fe kn ko kp kq b">deinit</code>永远不会被调用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi md"><img src="../Images/02786144ed824187fd9ff2cbd16e7436.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*8L7gaLbUCdmKKiIolc8Q4w.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">这就是Instruments tool显示内存泄漏的方式</figcaption></figure><h2 id="152e" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">用单元测试检测内存泄漏:</h2><p id="e4a2" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">为了检测内存泄漏，我们可以在每个测试中添加一个断言，在测试结束后验证我们的对象是否不同于<code class="fe kn ko kp kq b">nil</code>。但是<a class="ae km" href="https://developer.apple.com/documentation/xctest" rel="noopener ugc nofollow" target="_blank"> XCTest框架</a>为我们提供了一个<code class="fe kn ko kp kq b">tearDown</code>模块来在每次测试结束后添加行为。所以让我们利用这个特性。</p><p id="e65a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们给<code class="fe kn ko kp kq b"><strong class="jp ir">child</strong></code>添加一个名为<em class="kl"> sayHello() </em>的函数，它只返回一个“Hello！”字符串，并编写如下测试:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">父母和孩子的测试用例</figcaption></figure><p id="e938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我们在测试的末尾添加了一个<code class="fe kn ko kp kq b"><strong class="jp ir">tearDown</strong></code>块，在这里我们断言<code class="fe kn ko kp kq b"><strong class="jp ir">parent</strong></code>和<code class="fe kn ko kp kq b"><strong class="jp ir">child</strong></code>是否为零。</p><blockquote class="me mf mg"><p id="b948" class="jn jo kl jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">注意，我们需要在"<strong class="jp ir"><em class="iq">【weakify】</em></strong><code class="fe kn ko kp kq b"><strong class="jp ir">parent</strong></code>和<code class="fe kn ko kp kq b"><strong class="jp ir">child</strong></code> <strong class="jp ir"> </strong> <em class="iq">里面拆掉块</em></p></blockquote><p id="254f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过运行该测试，我们将看到以下断言错误:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ca4f3ed79ab540c52bd5fcaaffa316aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*7yRVutRW5rARfsMd0BAQxA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">断言失败表明内存泄漏</figcaption></figure><p id="8dd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样，我们已经从单元测试中很容易地发现了内存泄漏！</p><h2 id="c7d9" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">改进内存泄漏跟踪:</h2><p id="e1f1" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">当然，为了跟踪内存泄漏，我们需要在每个测试中添加断言，但这可能会更好。您可以创建一个XCTestCase助手。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="2b3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在我们的测试类中，我们可以创建一个<code class="fe kn ko kp kq b">makeSUT</code>助手来创建我们的<a class="ae km" href="https://en.wikipedia.org/wiki/System_under_test" rel="noopener ugc nofollow" target="_blank"> <em class="kl">被测系统</em> </a> <em class="kl"> </em>并添加内存泄漏跟踪。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="1507" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用这个<code class="fe kn ko kp kq b">makeSUT</code>工厂助手，您可以跟踪每个测试的内存泄漏，并避免重复代码，代码也更干净。</p><p id="496c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在我的github资源库中看到更多如何使用该助手的示例:</p><div class="ml mm gp gr mn mo"><a href="https://github.com/AlfredoHernandez/HackrNews/tree/develop/HackrNewsTests" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">AlfredoHernandez/HackrNews</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">Y Combinator的黑客新闻的一款iOS阅读应用。-阿尔弗雷多·埃尔南德斯/哈克新闻</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div></div></a></div><h2 id="b696" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">内存泄露怎么解决？</h2><p id="50a4" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">默认情况下，Swift中对类的引用是强类型(强引用)，因此只要父类还活着，每个子类都将保持“活着”。如果父类死亡，那么子类也会死亡。</p><p id="6127" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回想一下，当它们“死亡”时，父类和子类的引用计数器都减1。</p><p id="81a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打破保持循环很简单，只需创建弱eather <code class="fe kn ko kp kq b">child.parent</code>或<code class="fe kn ko kp kq b">parent.child</code>变量。这取决于我们的用例。在这种情况下，我们让<code class="fe kn ko kp kq b">weak</code>成为孩子的父母。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/08539fb2bc8118578646e5ab0905aa7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*Voxfa3fRl7zClUrLjYjr5A.png"/></div></figure><p id="b1b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kn ko kp kq b">weak var parent: Parent?</code></p><p id="f3ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并再次运行测试，测试将通过。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/676777d3cc7195ce3c6f77980a8a2a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ec4Zde_w27mbam1SA2WCoQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">通过测试</figcaption></figure><p id="5a9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么ARC现在怎么样了？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/57a02d29ce652bc3efae54bc2aaf696a.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*OTEotWsKypCChGF0zUMaKA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">打破保留周期</figcaption></figure><p id="5ad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住:<code class="fe kn ko kp kq b">weak</code>和<code class="fe kn ko kp kq b">unowned</code>变量不会增加圆弧。</p><p id="d511" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有关ARC如何处理弱引用和无主引用的更多信息，请访问swift官方文档:</p><div class="ml mm gp gr mn mo"><a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">自动引用计数-Swift编程语言(Swift 5.4)</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">Swift使用自动引用计数(ARC)来跟踪和管理您的应用程序的内存使用情况。在大多数情况下，这意味着…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">docs.swift.org</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni kx mo"/></div></div></a></div><p id="f558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">还有一件事</strong> : <br/>这项技术因为<a class="ae km" href="https://www.essentialdeveloper.com/articles/the-minimum-you-should-do-to-prevent-memory-leaks-in-swift?rq=memory%20leaks" rel="noopener ugc nofollow" target="_blank">essentialdeveloper.com</a>的伟大工作而被应用和学习。让我们来看看他们伟大而有价值的内容。<br/><a class="ae km" href="https://www.essentialdeveloper.com" rel="noopener ugc nofollow" target="_blank">https://www.essentialdeveloper.com</a></p></div></div>    
</body>
</html>