<html>
<head>
<title>Programming a hacker-kind test-task for Senior Web-Engineer vacancy at Oracle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为甲骨文公司的高级网络工程师职位空缺编写一个类似黑客的测试任务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/programming-a-hacker-kind-test-task-for-senior-web-engineer-vacancy-at-oracle-aa4f119308b0?source=collection_archive---------33-----------------------#2022-11-28">https://levelup.gitconnected.com/programming-a-hacker-kind-test-task-for-senior-web-engineer-vacancy-at-oracle-aa4f119308b0?source=collection_archive---------33-----------------------#2022-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f655" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2021年春天，我一直在想有没有空房。引起我注意的是甲骨文公司远程高级网络工程师的职位空缺。在寄出我的简历后，我收到了许多可供选择的测试任务。更进一步，我设法完成了它，并得到了一份工作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e93ab4adbae7e7a1be73cf795d4a5960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftcYJfQ_2WIt85yK6Dp1kg.png"/></div></div></figure><p id="c21f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个特别有趣的测试任务是实现四种从后端接收网页数据的方法，而不使用任何类型的AJAX及其XMLHttpRequestObject。让我们回顾一下这四个想法。</p><h2 id="c8e0" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">IFrame注射液</h2><p id="17ed" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">第一个是在页面上创建一个iframe元素。Iframe标签允许在现有网页中打开一个新的网页。在该页面中，我们可以找到需要从服务器接收的数据。DOM包含iframe元素的事件，该事件允许通过<em class="lv"> textContent </em>属性读取其内容。</p><p id="b2b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码如下所示:</p><pre class="km kn ko kp gt lw lx ly bn lz ma bi"><span id="23d3" class="mb ky iq lx b be mc md l me mf">    let iframeEl = document.createElement("iframe");<br/>    iframeEl.style.display = "none";<br/>    iframeEl.setAttribute("src", "/iframe-data.txt");<br/><br/>    let getContent = () =&gt; <br/>                iframeEl.contentWindow.document.body.textContent;<br/><br/>    iframeEl.onload = () =&gt; <br/>                console.log('Iframe tag injection: ' + getContent());<br/><br/>    document.body.appendChild(iframeEl);</span></pre><h2 id="f080" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">脚本标签注入</h2><p id="c930" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">下一步是添加一个额外的脚本标记。标签用于从外部文件运行JavaScript代码。因此，在这些脚本文件中，我们可以找到一个普通JS代码，其中包含JSON对象和onload事件后被访问的已知变量。代码如下:</p><pre class="km kn ko kp gt lw lx ly bn lz ma bi"><span id="6c0b" class="mb ky iq lx b be mc md l me mf">    let srcTag = document.createElement("script");<br/>    srcTag.setAttribute("src", " /data.txt");<br/><br/>    srcTag.onload = () =&gt; <br/>                console.log("Script tag injection: " + dataList.sample);<br/><br/>    document.body.appendChild(srcTag);</span></pre><p id="ab44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<em class="lv"> data.txt </em>包含</p><pre class="km kn ko kp gt lw lx ly bn lz ma bi"><span id="9a99" class="mb ky iq lx b be mc md l me mf">let dataList = {<br/>    "sample": "data from data.txt file"<br/>};</span></pre><h2 id="e621" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">链接标签注入</h2><p id="b92a" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">CSS链接标签呢？它能用来接收数据和脚本标签吗？答案是肯定的。可以延迟加载外部CSS样式表文件，通过<em class="lv">内容</em>属性将数据注入网页标签。</p><pre class="km kn ko kp gt lw lx ly bn lz ma bi"><span id="a7db" class="mb ky iq lx b be mc md l me mf">p.s3fc-hidden::after {<br/>    content: "{cssJson: 'cssJsonValues'}";<br/>}</span></pre><p id="217c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是它的加载方式:</p><pre class="km kn ko kp gt lw lx ly bn lz ma bi"><span id="9fa2" class="mb ky iq lx b be mc md l me mf">    let linkTag = document.createElement("link");<br/>    linkTag.setAttribute("rel", " stylesheet");<br/>    linkTag.setAttribute("href", " /style.css");<br/><br/>    let getContent = () =&gt; document.styleSheets[document.styleSheets.length - 1]<br/>                            .cssRules[0]<br/>                            .styleMap.get("content");<br/><br/>    linkTag.onload = () =&gt; <br/>                console.log("Link tag injection: " + getContent());<br/><br/>    document.body.appendChild(linkTag);</span></pre><h2 id="4933" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">对象标签注入</h2><p id="9220" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">其中一个有趣的想法是使用图像从其内容中接收数据。唯一的问题是格式，因为大多数图像都是以某种二进制形式表示的。例外情况是SVG图像文件，它们是以文本格式表示的格式良好的XML文件。</p><pre class="km kn ko kp gt lw lx ly bn lz ma bi"><span id="5bc0" class="mb ky iq lx b be mc md l me mf">&lt;svg version="1.1"<br/>     baseProfile="full"<br/>     width="300" height="200"<br/>     &gt;<br/>  &lt;text x="0" y="15" fill="white"&gt;{vectorSample: "data"}&lt;/text&gt;<br/>&lt;/svg&gt;</span></pre><p id="71ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和前面的例子一样，为了加载文件，我们需要创建适当的标记(<em class="lv"> &lt;对象&gt; </em>，在本例中为<em class="lv"> ) </em>，并使用其<em class="lv"> onload </em>事件:</p><pre class="km kn ko kp gt lw lx ly bn lz ma bi"><span id="11ce" class="mb ky iq lx b be mc md l me mf">    let objectTag = document.createElement("object");<br/>    objectTag.setAttribute("data", "/vector.svg");<br/>    objectTag.setAttribute("width", "0");<br/>    objectTag.setAttribute("height", "0");<br/><br/>    let getContent = () =&gt; <br/>                objectTag.contentDocument.firstChild.textContent;<br/><br/>    objectTag.onload = () =&gt;  <br/>        console.log("Object tag injection " + getContent());<br/>    <br/>    document.body.appendChild(objectTag);</span></pre><h2 id="ab15" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">总结</h2><p id="03b7" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">表示四种接收数据的方式不会在浏览器检查器的网络选项卡中显示为AJAX服务器调用。这是完成测试任务的一个目标。测试任务的完整工作代码可以从GIT资源库下载:</p><div class="mg mh gp gr mi mj"><a href="https://github.com/sergiiriabokon/simple-jsonp" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">GitHub-sergiiriabokon/simple-jsonp:不使用XHR调用发出AJAX请求的四种方法</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kv mj"/></div></div></a></div></div></div>    
</body>
</html>