<html>
<head>
<title>Use case of Singleton with Axios and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Axios和TypeScript的单例用例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-case-of-singleton-with-axios-and-typescript-da564e76296?source=collection_archive---------0-----------------------#2020-11-11">https://levelup.gitconnected.com/use-case-of-singleton-with-axios-and-typescript-da564e76296?source=collection_archive---------0-----------------------#2020-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在TypeScript中使用singleton的真实用例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a6f9321622302e8867d77c743a600a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-agfbcGrjSPaTqV-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你好世界！今天我要告诉你关于<code class="fe lv lw lx ly b">axios</code>和<code class="fe lv lw lx ly b">singleton</code>的事情。作为一个基础，我会拿我以前的关于这个话题的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/enhance-your-http-request-with-axios-and-typescript-f52a6c6c2c8e">。因此，如果您遗漏了代码的某个部分，或者有什么不清楚的地方，请检查第一部分</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0a1b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">介绍</h1><p id="51cf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">从上一篇文章或者从你的背景中，你可能知道<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank">axios</a></code>是最受欢迎的HTTP请求库之一。它可以在客户端和服务器端使用。它提供了一些工具来减少代码量，使其清晰易读。创建实例的工具之一是<code class="fe lv lw lx ly b">axios.create</code>。它可以帮助你定义一些常见的人员:基本的网址，标题等。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fef7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">目前我们知道些什么？</h1><p id="e111" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">前一篇文章描述了我们如何遵循DRY原则并扩展一个标准的<code class="fe lv lw lx ly b">axios-instance</code>来得到更强大的东西。</p><p id="07bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长话短说，我们有以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="206b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个抽象类，包含了关于我们的<code class="fe lv lw lx ly b">axios-instance</code>以及错误和成功响应处理程序的逻辑。</p><p id="cad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界中，它可能看起来像:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="acef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在是时候提升我们的档次了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="10df" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">问题是</h1><p id="bcc9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当前的实现存在问题。如果我们需要在项目的不同地方使用我们的类，我们有几种方法来处理它。</p><ul class=""><li id="de3b" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">第一种(从我的角度来看也是最正确的)是在<code class="fe lv lw lx ly b">main</code>函数中初始化类，并将其传递给其他类的构造函数，这里可能需要<code class="fe lv lw lx ly b">HttpModule</code>。这是一个非常明显的解决方案，但是只有当你用面向对象的方法开发服务器时，它才可能起作用。如果你开发一个客户端应用程序，这种方法不能使用。</li><li id="a21d" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">第二种方法是在需要的时候导入我们的类，每次在每个模块/函数中创建一个实例。这种方法同时适用于服务器和客户端应用程序。你可能会问“既然它在任何地方都有效，为什么我们不使用它呢？”。答案在下面。</li></ul><p id="b348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，当我们使用<code class="fe lv lw lx ly b">axios-instance</code>时，我们可以防止<code class="fe lv lw lx ly b">axios</code>在每次发出请求时创建不必要的实例。我们做一次就一直用。但是如果我们创建不同的<code class="fe lv lw lx ly b">HttpModule</code>实例，这和使用<code class="fe lv lw lx ly b">axios.request</code>是一样的。唯一的区别是我们的包装。关键的解决方案是<code class="fe lv lw lx ly b">singleton</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="597d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一个</h1><p id="f895" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">Singleton</a></code>是一种只允许使用一个类“实例”的模式。单一实例正是我们要找的，不是吗？实际上，这种模式是一个颇有争议的话题。此外，有人说这种模式是反模式。好吧，随它去吧。用不用完全是你自己的决定，但是我想让你知道有这样一种做法，可以让我们接受。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5ffa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">履行</h1><p id="f095" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，我们必须将<code class="fe lv lw lx ly b">constructor</code>访问修饰符改为<code class="fe lv lw lx ly b">private</code>。此步骤将阻止创建实例的能力:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cdf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们需要一个属性来缓存我们的单个实例。应该是<code class="fe lv lw lx ly b">private</code>(所以我们不能在类外获取)和<code class="fe lv lw lx ly b">static</code>(不用创建实例就可以使用):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="097e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是创建方法，该方法返回实例(<code class="fe lv lw lx ly b">static</code>和<code class="fe lv lw lx ly b">public</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f8c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的<code class="fe lv lw lx ly b">MainApi</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们已经更新了类，所以我们可以在项目的不同模块中使用它，并且不用担心我们会创建不必要的实例:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="287d" class="nx mh it ly b gy ny nz l oa ob">import MainApi from '@/api/main';</span><span id="8405" class="nx mh it ly b gy oc nz l oa ob">const mainApi = MainApi.getInstance();</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cfef" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="5503" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我相信你发现了新的东西或者至少巩固了你的知识。我不提倡您使用<code class="fe lv lw lx ly b">singleton</code>或将其视为反模式。在我看来，<code class="fe lv lw lx ly b">singleton</code>和<code class="fe lv lw lx ly b">HttpClient</code>只是你自己“工具箱”里的好东西。</p></div></div>    
</body>
</html>