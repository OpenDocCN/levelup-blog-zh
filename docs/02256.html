<html>
<head>
<title>JavaScript Clean Code — Function Parameters and Side Effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码—函数参数和副作用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-function-parameters-and-side-effects-d5d7365e5105?source=collection_archive---------1-----------------------#2020-03-01">https://levelup.gitconnected.com/javascript-clean-code-function-parameters-and-side-effects-d5d7365e5105?source=collection_archive---------1-----------------------#2020-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d5e46d3bf5f7efe6343304ea3592071d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yUWxXdcIuysonfBx"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@cdc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">疾控中心</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="f586" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数是JavaScript程序的重要组成部分。它们用于将代码分成可重用的块。因此，为了有清晰的JavaScript代码，我们需要有易于理解的函数。</p><p id="b116" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看到好函数的更多属性，包括标志参数、二元和三元函数以及副作用。</p><h1 id="9598" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">标志参数</h1><p id="4c44" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">布尔参数应该尽量少用。它使得函数签名更加复杂，并且它告诉我们函数不止做一件事(有多条路径)。</p><h1 id="8d63" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">二元函数</h1><p id="0b5a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">二元函数比参数较少的函数更难理解。然而，有时它们是有意义的。例如，如果我们有一个包含笛卡尔坐标的对象，那么它应该有两个参数。</p><p id="302e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以有一个带有两个参数的构造函数的类，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9f64" class="mq lf it mm b gy mr ms l mt mu">class Point {<br/>  constructor(x, y) {<br/>    this.x = x;<br/>    this.y = y;<br/>  }<br/>}</span><span id="460e" class="mq lf it mm b gy mv ms l mt mu">const point = new Point(1, 2);</span></pre><p id="5e8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几乎不可能用其他方式来定义它。</p><p id="e6e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们必须意识到，与参数较少的函数相比，它需要更多的时间和脑力。</p><h1 id="3ab1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">三元函数</h1><p id="446b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有三个参数的函数需要花费大量的时间和脑力来理解有两个参数的函数。</p><p id="ece6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有两个或更少的论点，就要考虑更多的论点组合。</p><h1 id="6cbf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将参数组合成对象</h1><p id="903a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果一个函数有许多参数，我们应该考虑将它们组合成对象。</p><p id="6a0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果他们有血缘关系，那就更是如此。例如，以下函数有许多参数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dc31" class="mq lf it mm b gy mr ms l mt mu">const describeFruit = (color, name, size, price, numSeeds, type) =&gt; {<br/>  return `${fruitName} is ${fruitColor}. It's ${fruitSize}. It costs ${price}. It has ${numSeeds}. The type if ${type}`;<br/>}</span></pre><p id="26dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">6个参数可能太多了。我们可以通过传入一个对象来解决这个问题:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="42a6" class="mq lf it mm b gy mr ms l mt mu">const describeFruit = (fruit) =&gt; {<br/>  return `${fruit.name} is ${fruit.color}. It's ${fruit.size}. It costs ${fruit.price}. It has ${fruit.numSeeds}. The type if ${fruit.type}`;<br/>}</span></pre><p id="be77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如我们所见，它干净多了。我们不必担心传入许多参数。</p><p id="df6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也更适合屏幕，因为它更短。</p><p id="3b0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5个参数可能是函数中应该有的最大值。</p><h1 id="399c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">动词和关键词</h1><p id="eb7c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们的函数名中包含动词和关键字是一个好主意，因为它们做一些事情，这意味着名称中的动作词是合理的。</p><p id="d259" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们需要知道我们要对哪些事物应用动作。这意味着我们必须添加一些关键字来做到这一点。</p><p id="827e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，符合这条规则的好的函数定义应该是这样的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a131" class="mq lf it mm b gy mr ms l mt mu">const copyArray = (array) =&gt; [...array];</span></pre><p id="1634" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">名称让我们知道我们的函数复制了一个数组。</p><p id="f59b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也让我们知道我们传递给函数的是什么，这显然是一个数组。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1708b8b9563f88673bba867b9948aee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A8ZkS27v5HfFZ3o6"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@ataheri?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Autri Taheri </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unplash</a>上拍摄的照片</figcaption></figure><h1 id="e0c1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">无副作用</h1><p id="eef9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">副作用是函数中的代码，它对函数之外的东西进行更改。</p><p id="834c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是很好，因为它对函数之外的东西进行了隐藏的更改。</p><p id="fcf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该尽可能地避免这种情况，因为它会做一些意想不到的事情，而且会让测试变得更加困难，因为除了接受参数、做事情和返回结果之外，它还会对我们必须考虑的函数之外的东西进行更改。</p><p id="87dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们必须在函数返回的内容之外进行测试。</p><p id="a287" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7ebf" class="mq lf it mm b gy mr ms l mt mu">let numFruits = 1;<br/>const addFruit = () =&gt; {<br/>  numFruits++;<br/>}</span><span id="3f6d" class="mq lf it mm b gy mv ms l mt mu">const removeFruit = () =&gt; {<br/>  numFruits--;<br/>}</span></pre><p id="29ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有两个有副作用的函数，因为它们都改变了每个函数之外的<code class="fe mw mx my mm b">numFruits</code>变量。</p><p id="dcb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">写这些函数的更好方法是把它们写成纯函数。纯函数是在传入相同参数的情况下返回相同结果的函数。而且，它没有副作用。</p><p id="1f17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正因为如此，纯函数更容易测试，它们的行为也是可以预测的。</p><p id="fc17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写如下代码来重写上面的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="60aa" class="mq lf it mm b gy mr ms l mt mu">let numFruits = 1;<br/>const addFruit = (numberOfFruits) =&gt; numberOfFruits + 1;<br/>const removeFruit = (numberOfFruits) =&gt; numberOfFruits - 1;</span><span id="ce65" class="mq lf it mm b gy mv ms l mt mu">numFruits = addFruit(numFruits);<br/>numFruits = removeFruit(numFruits);</span></pre><p id="f948" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在有两个函数，分别接受一个<code class="fe mw mx my mm b">numFruits</code>参数并返回一个更大或更小的数字。</p><p id="96f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以使用它们来改变函数之外的<code class="fe mw mx my mm b">numFruits</code>变量。</p><p id="9695" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，它们对<code class="fe mw mx my mm b">numFruits</code>没有任何作用，而是分别返回<code class="fe mw mx my mm b">numberOfFruits</code>参数加1或减1。</p><p id="1b13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们为它们编写测试，那么我们可以通过传入输入并检查输出是否是我们想要的来轻松测试它们。这比将副作用提交给测试代码可能使用的变量要好得多。</p><h1 id="f6bb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="d10e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">标志参数应该最小化。他们告诉我们，函数可以做不止一件事，它是函数签名中的另一个参数。</p><p id="ec95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接受较少参数的函数比接受较多参数的函数更好。如果需要很多参数，考虑将它们组合成一个对象。</p><p id="01ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，如果可能的话，应该避免副作用。有副作用的函数会做一些隐藏的事情，并且很难测试。纯函数更具可测试性和可预测性，因为它们不会产生副作用。</p></div></div>    
</body>
</html>