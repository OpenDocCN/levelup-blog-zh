<html>
<head>
<title>Unit Test with Kotlin Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin流的单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-test-with-kotlin-flow-7e6f675e5b14?source=collection_archive---------3-----------------------#2022-04-03">https://levelup.gitconnected.com/unit-test-with-kotlin-flow-7e6f675e5b14?source=collection_archive---------3-----------------------#2022-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5a1cb00648cfd214d118595eb5b108c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDtWztw1uTYMZlmeYE0ksQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@lazycreekimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克尔·泽兹奇</a>在<a class="ae kc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0c7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们开发一个特性时，我们需要为功能的每个部分编写单元测试。这是发展的一个巨大而必要的部分。这保证了代码在未来的更改/重构中的正确运行。</p><p id="8a29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">科特林流也不例外。在我们的Android应用程序中，我们使用了Kotlin Flow，我们必须测试这些流的功能。<strong class="kf ir">虽然这个主题总结了它的应用，但是我们真的很高兴编写流的单元测试是如此简单。</strong></p><h2 id="4217" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">一个测试案例🛠</h2><p id="9fec" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">假设我们有一个获取三个延迟字符串的流程:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/2e8f7b6a08459c2ddf4ab31f3518c98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiAPItdWLKBS66EX9w_UlA.png"/></div></div></figure><p id="5fb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在收集时，我们可以假设使用<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html" rel="noopener ugc nofollow" target="_blank">collect</a></code>和<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html" rel="noopener ugc nofollow" target="_blank">catch</a></code>运算符:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/b864f97f3ee7e1da4642530a8b85f88a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*286GWlq8cbDsmi4sxXCnGQ.png"/></div></div></figure><p id="e0fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在，我们需要测试这个流程的正确功能。我所说的正常运行是指测试以下情况:</p><ul class=""><li id="7c66" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">我们应该收集三样东西。</li><li id="c14f" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated"><em class="mx">你好玉。</em>“应该是第一项。</li><li id="a959" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">我们应该收藏"<em class="mx">你好玉。</em>“，”<em class="mx">就今天。</em>、<em class="mx">生日快乐！</em>”，准确地说。</li><li id="3c81" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">该流程应该无一例外地完成。</li><li id="4a48" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">该流应该处理意外的异常。</li></ul><p id="488f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，还有其他案例，但这些案例足以展示如何对Kotlin流进行单元测试。</p><h2 id="39e1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">工具📚</h2><p id="f6bd" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将提供三个依赖关系的例子，使测试变得轻松、简洁和可读:</p><ul class=""><li id="5b6c" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">为了运行我们的测试，我们将使用<a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/index.html" rel="noopener ugc nofollow" target="_blank">kot linx-coroutines-test</a>，专门针对<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" rel="noopener ugc nofollow" target="_blank">delays</a></code>。<code class="fe me mf mg mh b">runTest</code>将允许我们运行测试，自动跳过延迟并处理未捕获的异常。</li><li id="844e" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">断言将通过<a class="ae kc" href="https://github.com/MarkusAmshove/Kluent" rel="noopener ugc nofollow" target="_blank"> Kluent </a>来完成。这是一个在经典JUnit断言之上专门为Kotlin编写的“流畅断言”库。我们将称之为<code class="fe me mf mg mh b">shouldEqual</code>、<code class="fe me mf mg mh b">shouldNotBeNull</code>和<code class="fe me mf mg mh b">shouldBeNull</code>，它们的名字很明显。</li><li id="0d00" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated"><a class="ae kc" href="https://github.com/mockk/mockk" rel="noopener ugc nofollow" target="_blank">mock</a>将被应用于模拟类并定义函数的行为。此处仅用于模拟流收集中的异常。</li></ul><p id="f3c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将会看到如何为Kotlin流创建单元测试。我们不会查看嘲讽行为或断言的细节，以保持这篇文章的基本性，并提供一个简单明了的解释。</p><p id="798e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们看看如何统一测试我们的流程<code class="fe me mf mg mh b">fetchSentences()</code>。</p><h2 id="baa7" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">测试流量🥊</h2><p id="00d2" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">根据<a class="ae kc" href="https://developer.android.com/kotlin/flow/test" rel="noopener ugc nofollow" target="_blank">谷歌Android的文档</a>:</p><blockquote class="my"><p id="8919" class="mz na iq bd nb nc nd ne nf ng nh la dk translated">如果被测试的主体公开了一个流，那么测试需要对数据流的元素做出断言。</p></blockquote><p id="79ad" class="pw-post-body-paragraph kd ke iq kf b kg ni ki kj kk nj km kn ko nk kq kr ks nl ku kv kw nm ky kz la ij bi translated">为此，我们只需使用已经可用的操作符(如<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/drop.html" rel="noopener ugc nofollow" target="_blank">drop</a></code>、<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html" rel="noopener ugc nofollow" target="_blank">take</a></code>、<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html" rel="noopener ugc nofollow" target="_blank">map</a></code>)来使用<code class="fe me mf mg mh b">Flow</code> API，并收集流，以使用<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html" rel="noopener ugc nofollow" target="_blank">single</a></code>、<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html" rel="noopener ugc nofollow" target="_blank">toList</a></code>等终端操作符来检查收到的项目。它使写作变得简单和直观，因为它就像真正的执行。</p><p id="a31a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设<code class="fe me mf mg mh b">fetchSentences()</code>在一个名为<code class="fe me mf mg mh b">SentenceService</code>的类下，第一个测试是用<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/count.html" rel="noopener ugc nofollow" target="_blank">count</a></code>操作符进行的，它应该正好返回三个项目:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/9ee7d2614198bc368918c2085cf9e874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvKsgTCY4A0yaH10ExVncA.png"/></div></div></figure><p id="a084" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">验证第一项的下一个测试由<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html" rel="noopener ugc nofollow" target="_blank">first</a></code>操作员完成:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/d44d3135839d8cc47d6534580a47de2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLnMAYugm6L9sGITfdyH1w.png"/></div></div></figure><p id="1e65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过与<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html" rel="noopener ugc nofollow" target="_blank">toList</a></code>的列表比较，检查项目排序和相等性；</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/c7c77f050bceb7782710557ed2b696f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJEXX6m5fnmSq1QYwecDzg.png"/></div></div></figure><p id="ab2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如何测试正确完成没有任何异常？通过确认<code class="fe me mf mg mh b">cause</code>到<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html" rel="noopener ugc nofollow" target="_blank">onCompletion</a></code>操作符的可空性:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/76b76dedf84814062d29f22e3e1c5618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLsnDqSXghmQRKM89j5NrQ.png"/></div></div></figure><p id="f6a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，当我们模拟和修改流的响应时，可以测试意外的异常。所以我们必须创建一个新的流，并在其中抛出一个异常。然后用<code class="fe me mf mg mh b">catch</code>操作员检查:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/40fd0600e370ee71ad3dc65ebbddfd93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ym9zRzbsJowtM-9CxP5JGQ.png"/></div></div></figure><p id="a2a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单，不是吗？</p><p id="ce1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们第一次实现这些案例时，我们惊讶地发现用<code class="fe me mf mg mh b">Flow</code> API进行测试是如此容易。然而，我们不太习惯在测试中直接调用像<code class="fe me mf mg mh b">onCompletion</code>或<code class="fe me mf mg mh b">catch</code>这样的“真正的”操作符。</p><p id="0e23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是<a class="ae kc" href="https://github.com/cashapp/turbine" rel="noopener ugc nofollow" target="_blank">涡轮</a>就位的地方。</p><h2 id="350b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">进入涡轮👀</h2><p id="fb61" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们决定重写我们的测试并使用Turbine——一个小而强大的Kotlin流测试库。</p><p id="9781" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它允许我们编写简洁的测试，不需要像前一章那样的操作符。我们只需要调用流的扩展<code class="fe me mf mg mh b">test</code>并查看其中的条目或错误。这个光库让我们很好地处理流量接收、完成或取消。<a class="ae kc" href="https://www.geev.com" rel="noopener ugc nofollow" target="_blank"> @Geev </a>，我们发现这个库比官方的方式要好。</p><p id="0742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是延迟使用它似乎很痛苦。由于Turbine忽略了当前的调度程序，<code class="fe me mf mg mh b">delay()</code>实际上延迟了流程，<code class="fe me mf mg mh b">test</code>的块实际上在测试调度程序中运行，这意味着超时不起作用。(<a class="ae kc" href="https://github.com/cashapp/turbine/issues/42#issuecomment-868681072" rel="noopener ugc nofollow" target="_blank"> #42 </a>)</p><p id="5b24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了正确运行测试，我们可以:</p><ul class=""><li id="a4da" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">用<code class="fe me mf mg mh b">runBlocking</code>代替<code class="fe me mf mg mh b">runTest</code>。但是，我们将不得不等待两个真正的秒来完成完整的测试！想象一下更高的延迟…</li><li id="3f9b" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">多亏了<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html" rel="noopener ugc nofollow" target="_blank">withContext</a></code>，将执行测试包在一个特定的调度程序中。</li><li id="1988" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">创建<a class="ae kc" href="https://github.com/cashapp/turbine/issues/42#issuecomment-1000317026" rel="noopener ugc nofollow" target="_blank">一个</a>T5的同级扩展，用<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html" rel="noopener ugc nofollow" target="_blank">flowOn</a></code>操作符改变流的上下文。</li></ul><p id="4be4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用了最后的感谢<a class="ae kc" href="https://github.com/PaulWoitaschek" rel="noopener ugc nofollow" target="_blank"> PaulWoitaschek </a>:</p><pre class="ma mb mc md gt np mh nq nr aw ns bi"><span id="5ca1" class="lb lc iq mh b gy nt nu l nv nw">suspend fun &lt;T&gt; Flow&lt;T&gt;.<strong class="mh ir">testWithScheduler</strong>(<br/>    timeoutMs: Long = 1000,<br/>    validate: suspend FlowTurbine&lt;T&gt;.() -&gt; Unit<br/>  ) {<br/>    val testScheduler = coroutineContext[<strong class="mh ir">TestCoroutineScheduler</strong>]<br/>    return if (testScheduler == null) {<br/>      test(timeoutMs, validate)<br/>    } else {<br/>      <strong class="mh ir">flowOn(UnconfinedTestDispatcher(testScheduler))<br/>        .test(timeoutMs, validate)</strong><br/>    }<br/>  }</span></pre><h2 id="d8b1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">启动涡轮🦾</h2><p id="f16c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">实际上，涡轮试验可以用三种方法恢复。</p><p id="cec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查收到的句子数量，我们会用<code class="fe me mf mg mh b">awaitItem</code>捕捉流中的项，并在最后调用<code class="fe me mf mg mh b">awaitComplete</code>来验证流是在三项之后完成的。这也将测试流的正确完成，没有任何异常。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/76ee0b9987427d7f9781568a176a0724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D24T1zmQsrGVhoeIZNxzpQ.png"/></div></div></figure><p id="0a3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，我们使用<code class="fe me mf mg mh b">runTest</code>来触发<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-delay-controller/advance-time-by.html" rel="noopener ugc nofollow" target="_blank">advanceTimeBy</a></code>并控制测试的虚拟时钟，传递流延迟。我们应用<code class="fe me mf mg mh b">testWithScheduler</code>来正确处理它。</p><p id="4ba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，代替<code class="fe me mf mg mh b"><a class="ae kc" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html" rel="noopener ugc nofollow" target="_blank">first</a></code>操作符，我们等待带有<code class="fe me mf mg mh b">awaitItem</code>的第一项，并通过忽略其他事件来取消流程:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/28756ea8a719439d28031fbd42d99a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2-Lzz25DzjZtqxoz0OWlw.png"/></div></div></figure><p id="fbf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以通过使用<code class="fe me mf mg mh b">awaitError</code>比较如下收到的异常，来验证流在模拟服务时可以处理意外的异常:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/9cba1c28c0013e32225bf10934438d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7I9B9gVSENrAS4FG2XA3pA.png"/></div></div></figure><p id="50eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！不需要更多的测试。我们认为Turbine确实简化了我们的测试用例。</p><h2 id="145b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">使用科特林流量🧞‍♂️进行单元测试</h2><p id="9cbe" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">正如我们所看到的，编写流单元测试非常简单。<strong class="kf ir">我们使用</strong> <code class="fe me mf mg mh b"><strong class="kf ir">Flow</strong></code> <strong class="kf ir"> API本身或者依赖于轻量级的库Turbine——两者都提供了一种简单而直观的方式来创建单元测试。</strong>使用很少的操作符(<code class="fe me mf mg mh b">first</code>、<code class="fe me mf mg mh b">toList</code>)或者很少的暂停函数(<code class="fe me mf mg mh b">awaitItem</code>、<code class="fe me mf mg mh b">awaitComplete</code>)，我们能够很容易地创建我们的测试。</p><p id="85be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你觉得这篇文章有帮助，请鼓掌！👏感谢阅读。</p></div></div>    
</body>
</html>