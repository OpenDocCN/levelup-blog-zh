<html>
<head>
<title>Building a Scalable and Modular Architecture for React-TS Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为React-TS应用构建可扩展的模块化架构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-scalable-and-modular-architecture-for-react-ts-applications-e1d917250e04?source=collection_archive---------2-----------------------#2022-03-05">https://levelup.gitconnected.com/building-a-scalable-and-modular-architecture-for-react-ts-applications-e1d917250e04?source=collection_archive---------2-----------------------#2022-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="5e39" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="3322" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">React.js在很大程度上是非个人化的，除了一些在使用钩子时被推荐和强制的设计模式。因此，没有官方推荐来组织你的项目，这通常会导致组件的架构困境。</p><p id="b803" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在我们目前的公司尝试了几种不同的模式和架构后，我们最终采用了一种<strong class="kn ir"> <em class="lo">模块化</em> </strong>架构，这使我们能够毫不费力地扩展我们的项目。</p><h1 id="5ec9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">核心原则</h1><h2 id="5d76" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated">模块隔离</h2><p id="c287" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">每个模块都需要用它自己的依赖项来隔离，并且应该知道它需要的所有依赖项以及它所有API的入口点。</p><h2 id="de98" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated">非循环依赖</h2><p id="3b4d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">模块不应该相互导入，因为这违反了<a class="ae mb" href="https://en.wikipedia.org/wiki/Acyclic_dependencies_principle#:~:text=The%20acyclic%20dependencies%20principle%20(ADP,form%20a%20directed%20acyclic%20graph." rel="noopener ugc nofollow" target="_blank">非循环依赖原则</a>。</p><h2 id="62a1" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated">模块间的差异</h2><p id="842c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lo">从属模块与独立模块</em>。除了应用程序中的公共模块之外，独立模块与其他模块的耦合并不紧密，这使得我们可以将其外包给外部库。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/6e8d4637e9aae398775cc72b8506ab65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8eRI6PjUdn2q4tTEZ_MVQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">React应用程序的模块化架构</figcaption></figure><h1 id="9626" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">从属模块</h1><p id="bc77" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">模块化架构图代表了一个简单的可扩展的模块化架构，它符合我们的核心原则。</p><blockquote class="ms mt mu"><p id="017f" class="kl km lo kn b ko lj kq kr ks lk ku kv mv ll ky kz mw lm lc ld mx ln lg lh li ij bi translated"><strong class="kn ir"> <em class="iq">注</em> </strong>:上图<strong class="kn ir"> </strong>中的每个<strong class="kn ir">箭头</strong>代表一条导入语句。</p></blockquote><h2 id="a056" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated">应用</h2><p id="35af" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">应用程序/根模块只是容器的集合/组合(也称为智能组件)。它负责用<strong class="kn ir"><em class="lo">react-suspension</em></strong><em class="lo">，</em><strong class="kn ir"><em class="lo">error-boundaries</em></strong>和任何顶级<strong class="kn ir"> <em class="lo">提供者</em> </strong>来引导应用程序。一般来说，它应该包含尽可能少的代码。</p><h2 id="a665" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated"><strong class="ak">容器</strong></h2><p id="fc27" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">容器模块是通过钩子连接到状态的智能组件的集合。正如你所看到的，容器模块只导入<em class="lo">公共、组件和钩子</em>模块，它根本不涉及状态模块。这有助于我们在不影响状态的情况下扩展钩子模块。</p><h2 id="6f06" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated"><strong class="ak">挂钩</strong></h2><p id="e3f3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">钩子模块通过状态向容器提供数据，并根据用户与容器组件的交互来更新状态。</p><h2 id="1ba5" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated"><em class="my">状态</em></h2><p id="7cbe" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">状态模块负责使用服务和公共模块填充客户端状态。这使我们能够避免服务API污染容器和挂钩。</p><h1 id="b972" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">独立模块(可能)</h1><p id="3f4b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">独立模块只耦合到<em class="lo">公共模块</em>，尽管这并不像我们希望的那样独立，但将其外包给外部库仍然更容易。</p><h2 id="20fe" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated">成分</h2><p id="bbeb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">组件模块只是不关心应用程序状态的纯功能组件的集合。</p><p id="eb7d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">尽管这可能像外部库一样完全独立，但您可能仍然会最终构建与公共模块的数据类型非常相似的<strong class="kn ir"><em class="lo"/></strong>应用程序特定的组件。因此，隔离/标记<em class="lo">通用</em>和<em class="lo">特定</em>组件通常很有帮助。<em class="lo">通用</em>组件不使用公共模块中的任何类型，从而使我们能够将它们移动到外部组件库中。</p><h2 id="a6ff" class="lp jo iq bd jp lq lr dn jt ls lt dp jx kw lu lv kb la lw lx kf le ly lz kj ma bi translated">服务</h2><p id="29f8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">服务模块构成了与后端交互的API的集合，产生的响应应该与公共模块中的核心数据类型保持一致。</p><h1 id="9410" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="6fa7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">图中表示的每个模块都可以是react-project中自己的一个文件夹，有一个入口点<em class="lo">(例如:index.ts)。</em></p><p id="64c3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果操作正确，每个泡泡都可以在不影响其他泡泡的情况下变大。 </p><p id="0fc2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你喜欢这篇文章，请留下掌声。请在评论中告诉我你的想法。</p></div></div>    
</body>
</html>