<html>
<head>
<title>Build an Express API with Sequelize CLI and Express Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用序列CLI和快速路由器构建快速API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-an-express-api-with-sequelize-cli-and-express-router-963b6e274561?source=collection_archive---------4-----------------------#2020-04-16">https://levelup.gitconnected.com/build-an-express-api-with-sequelize-cli-and-express-router-963b6e274561?source=collection_archive---------4-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/021463944331716371fec71e4ce6afef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fygqfizATFjt6ALek2W1jg.png"/></div></div></figure><p id="bb92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用用于对象关系映射的Sequelize和作为服务器框架的Express，可以相当容易地构建一个成熟的node . js API——Express的Router类是一个以模块化、有组织的方式处理应用程序路线的有用工具。</p><p id="4207" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本演练中，我们将构建一个Sequelize项目，包括关联和种子数据，然后使用Express Router为我们的服务器定义路由。最后，我们将把我们的应用程序部署到Heroku来创建一个可公开访问的API。</p><h1 id="99cb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建顺序化应用程序</h1><p id="9093" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将尽快完成我们的序列设置，以便开始使用路由器，但我们会为那些想了解更多有关使用序列CLI或定义序列关联的人提供一些注意事项。</p><p id="71c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从安装Postgres、Sequelize和<a class="ae kw" href="https://github.com/sequelize/cli" rel="noopener ugc nofollow" target="_blank"> Sequelize CLI </a>开始，在一个新的项目文件夹中，我们称之为<code class="fe ma mb mc md b">express-api-using-router</code>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2ff2" class="mm ky iq md b gy mn mo l mp mq">mkdir express-api-using-router<br/>cd express-api-using-router<br/>git init<br/>npm init -y<br/>npm install sequelize pg &amp;&amp; npm install --save-dev sequelize-cli</span></pre><p id="4298" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一个<code class="fe ma mb mc md b">.gitignore</code>文件，以便于以后的部署:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="fbf1" class="mm ky iq md b gy mn mo l mp mq">echo "<br/>/node_modules<br/>.DS_Store<br/>.env" &gt;&gt; .gitignore</span></pre><p id="76a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将初始化一个Sequelize项目，然后在代码编辑器中打开目录:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="97ec" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli init<br/>code .</span></pre><blockquote class="mr ms mt"><p id="727b" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解有关以下序列化CLI命令的更多信息，请参见:<br/> <a class="ae kw" href="https://medium.com/@brunopgalvao/getting-started-with-sequelize-cli-c33c797f05c6" rel="noopener"> <strong class="ka ir">序列化CLI入门</strong> </a></p></blockquote><p id="773e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们配置我们的Sequelize项目来使用Postgres数据库。在<code class="fe ma mb mc md b">/config</code>目录中找到<code class="fe ma mb mc md b">config.json</code>，并修改代码，如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="dc75" class="mm ky iq md b gy mn mo l mp mq">{<br/>  "development": {<br/>    "database": "projects_api_development",<br/>    "dialect": "postgres"<br/>  },<br/>  "test": {<br/>    "database": "projects_api_test",<br/>    "dialect": "postgres"<br/>  },<br/>  "production": {<br/>    "use_env_variable": "DATABASE_URL",<br/>    "dialect": "postgres",<br/>    "dialectOptions": {<br/>      "ssl": {<br/>        "rejectUnauthorized": false<br/>      }<br/>    }<br/>  }<br/>}</span></pre><blockquote class="mr ms mt"><p id="197a" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">注:对于<code class="fe ma mb mc md b">production</code>，我们使用<code class="fe ma mb mc md b">use_env_variable</code>和<code class="fe ma mb mc md b">DATABASE_URL</code>。我们将把这个应用程序部署到<a class="ae kw" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>。Heroku很聪明，他用生产数据库代替了<code class="fe ma mb mc md b">DATABASE_URL</code>，我们将在稍后的<em class="iq"> r. </em>中看到这一点</p></blockquote><p id="1326" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以告诉Sequelize CLI创建Postgres数据库:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="848f" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli db:create</span></pre><h1 id="7818" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">定义模型和添加种子数据</h1><p id="4b79" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们的演示应用程序将用户与某些项目相关联。让我们从使用Sequelize CLI创建一个<code class="fe ma mb mc md b">User</code>模型开始:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="71a0" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string,password:string</span></pre><p id="7967" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe ma mb mc md b">model:generate</code>会自动创建一个模型文件和一个带有我们指定属性的迁移。现在我们可以执行迁移，在数据库中创建<code class="fe ma mb mc md b">Users</code>表:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ddde" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli db:migrate</span></pre><p id="c9f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建一个种子文件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f863" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli seed:generate --name users</span></pre><p id="a58b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在<code class="fe ma mb mc md b">/seeders</code>目录中看到一个新文件。在该文件中，粘贴以下代码，这将在您的数据库中为三个用户创建条目:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="d6a3" class="mm ky iq md b gy mn mo l mp mq">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkInsert('Users', [{<br/>      firstName: 'John',<br/>      lastName: 'Doe',<br/>      email: 'john@doe.com',<br/>      password: '123456789',<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      firstName: 'John',<br/>      lastName: 'Smith',<br/>      email: 'john@smith.com',<br/>      password: '123456789',<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      firstName: 'John',<br/>      lastName: 'Stone',<br/>      email: 'john@stone.com',<br/>      password: '123456789',<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    }], {});<br/>  },</span><span id="3505" class="mm ky iq md b gy my mo l mp mq">  down: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkDelete('Users', null, {});<br/>  }<br/>};</span></pre><p id="3982" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会注意到我们把三个用户都命名为“John”…只是因为。现在让我们添加一个<code class="fe ma mb mc md b">Project</code>模型，这样我们可以给这些约翰一些事情做:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6b90" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli model:generate --name Project --attributes title:string,imageUrl:string,description:text,userId:integer</span></pre><p id="a894" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将创建两个模型之间的关联。</p><blockquote class="mr ms mt"><p id="a011" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解有关创建序列关联的更多信息，请参阅:<br/> <a class="ae kw" href="https://medium.com/@brunopgalvao/creating-sequelize-associations-with-the-sequelize-cli-tool-d83caa902233" rel="noopener"> <strong class="ka ir">使用序列CLI创建序列关联</strong> </a></p></blockquote><p id="cad5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，在<code class="fe ma mb mc md b">/models</code>子目录中找到<code class="fe ma mb mc md b">user.js</code>，将代码替换为:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="017f" class="mm ky iq md b gy mn mo l mp mq">module.exports = (sequelize, DataTypes) =&gt; {<br/>  const Project = sequelize.define('Project', {<br/>    title: DataTypes.STRING,<br/>    imageUrl: DataTypes.STRING,<br/>    description: DataTypes.TEXT,<br/>    userId: DataTypes.INTEGER<br/>  }, {});<br/>  Project.associate = function (models) {<br/>    // associations can be defined here<br/>    Project.belongsTo(models.User, {<br/>      foreignKey: 'userId',<br/>      onDelete: 'CASCADE'<br/>    })<br/>  };<br/>  return Project;<br/>};</span></pre><p id="5e44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在同一个目录中找到<code class="fe ma mb mc md b">project.js</code>,将代码替换为:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2eb0" class="mm ky iq md b gy mn mo l mp mq">module.exports = (sequelize, DataTypes) =&gt; {<br/>  const User = sequelize.define('User', {<br/>    firstName: DataTypes.STRING,<br/>    lastName: DataTypes.STRING,<br/>    email: DataTypes.STRING,<br/>    password: DataTypes.STRING<br/>  }, {});<br/>  User.associate = function (models) {<br/>    // associations can be defined here<br/>    User.hasMany(models.Project, {<br/>      foreignKey: 'userId'<br/>    })<br/>  };<br/>  return User;<br/>};</span></pre><p id="b78e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将把外键添加到最新的迁移文件中。您应该会在您的<code class="fe ma mb mc md b">/migrations</code>子目录中看到两个文件。查找以<code class="fe ma mb mc md b">create-project.js</code>结尾的文件名，并将里面的代码改为如下:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6af1" class="mm ky iq md b gy mn mo l mp mq">'use strict';<br/>module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.createTable('Projects', {<br/>      id: {<br/>        allowNull: false,<br/>        autoIncrement: true,<br/>        primaryKey: true,<br/>        type: Sequelize.INTEGER<br/>      },<br/>      title: {<br/>        type: Sequelize.STRING<br/>      },<br/>      imageUrl: {<br/>        type: Sequelize.STRING<br/>      },<br/>      description: {<br/>        type: Sequelize.TEXT<br/>      },<br/>      userId: {<br/>        type: Sequelize.INTEGER,<br/>        onDelete: 'CASCADE',<br/>        references: {<br/>          model: 'Users',<br/>          key: 'id',<br/>          as: 'userId',<br/>        }<br/>      },<br/>      createdAt: {<br/>        allowNull: false,<br/>        type: Sequelize.DATE<br/>      },<br/>      updatedAt: {<br/>        allowNull: false,<br/>        type: Sequelize.DATE<br/>      }<br/>    });<br/>  },<br/>  down: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.dropTable('Projects');<br/>  }<br/>};</span></pre><p id="8428" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行迁移以在Postgres数据库中创建项目表:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6985" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli db:migrate</span></pre><p id="d7b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们为项目创建一个种子文件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3bf7" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli seed:generate --name projects</span></pre><p id="a7d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在您的<code class="fe ma mb mc md b">/seeders</code>子目录中看到一个以<code class="fe ma mb mc md b">projects.js</code>结尾的新文件。将该文件中的代码更改为以下内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5878" class="mm ky iq md b gy mn mo l mp mq">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkInsert('Projects', [{<br/>      title: 'Project 1',<br/>      imageUrl: 'https://upload.wikimedia.org/wikipedia/commons/6/6a/JavaScript-logo.png',<br/>      description: 'This project was built using Vanilla JavaScript, HTML, and CSS',<br/>      userId: 1,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      title: 'Project 2',<br/>      imageUrl: 'https://www.stickpng.com/assets/images/584830f5cef1014c0b5e4aa1.png',<br/>      description: 'This project was built using React &amp; a 3rd-party API.',<br/>      userId: 3,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      title: 'Project 3',<br/>      imageUrl: 'https://expressjs.com/images/express-facebook-share.png',<br/>      description: 'This project was built using Express &amp; React.',<br/>      userId: 2,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      title: 'Project 4',<br/>      imageUrl: 'https://upload.wikimedia.org/wikipedia/commons/1/16/Ruby_on_Rails-logo.png',<br/>      description: 'This project was built using Rails &amp; React.',<br/>      userId: 1,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    }], {});<br/>  },</span><span id="0a19" class="mm ky iq md b gy my mo l mp mq">  down: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkDelete('Projects', null, {});<br/>  }<br/>};</span></pre><p id="dd02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将运行两个种子文件，将我们的用户和项目添加到数据库中:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6a3c" class="mm ky iq md b gy mn mo l mp mq">npx sequelize-cli db:seed:all</span></pre><p id="4791" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们进入<code class="fe ma mb mc md b">psql</code>来确保数据存在于数据库中:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="d07f" class="mm ky iq md b gy mn mo l mp mq">psql projects_api_development<br/>SELECT * FROM "Users" JOIN "Projects" ON "Users".id = "Projects"."userId";</span></pre><h1 id="d624" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置Express</h1><p id="6033" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">太好了，我们的项目已经准备好了。现在，我们可以合并Express并设置路由来服务我们的数据。首先，让我们安装Express，连同<a class="ae kw" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank"> nodemon </a>来监控我们文件中的变化，以及<a class="ae kw" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank"> body-parser </a>来处理来自用户请求的信息:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="05f6" class="mm ky iq md b gy mn mo l mp mq">npm install express --save<br/>npm install nodemon -D<br/>npm install body-parser</span></pre><p id="e757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们通过创建两个新目录和三个新文件来设置体系结构:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6a30" class="mm ky iq md b gy mn mo l mp mq">mkdir routes controllers<br/>touch server.js  routes/index.js controllers/index.js</span></pre><p id="ab99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将修改<code class="fe ma mb mc md b">package.json</code>文件以支持nodemon。此外，我们可以通过创建一个新命令来促进开发:<code class="fe ma mb mc md b">npm db:reset</code>。我们将设置删除数据库、创建数据库、运行迁移，并在需要时重新播种！</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e0f7" class="mm ky iq md b gy mn mo l mp mq">....<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "start": "nodemon server.js",<br/>    "db:reset": "npx sequelize-cli db:drop &amp;&amp; npx sequelize-cli db:create &amp;&amp; npx sequelize-cli db:migrate &amp;&amp; npx sequelize-cli db:seed:all"<br/>  },<br/>....</span></pre><p id="b23d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们开始构建我们的Express应用程序。在<code class="fe ma mb mc md b">server.js</code>文件中，添加以下内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9cab" class="mm ky iq md b gy mn mo l mp mq">const express = require('express');<br/>const routes = require('./routes');<br/>const bodyParser = require('body-parser')</span><span id="5726" class="mm ky iq md b gy my mo l mp mq">const PORT = process.env.PORT || 3000;</span><span id="7344" class="mm ky iq md b gy my mo l mp mq">const app = express();</span><span id="dc20" class="mm ky iq md b gy my mo l mp mq">app.use(bodyParser.json())</span><span id="cfab" class="mm ky iq md b gy my mo l mp mq">app.use('/api', routes);</span><span id="5194" class="mm ky iq md b gy my mo l mp mq">app.listen(PORT, () =&gt; console.log(`Listening on port: ${PORT}`))</span></pre><p id="514d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们创建了一个基本的Express服务器集来监听端口3000。但是我们没有在这个文件中定义路由，而是添加了<code class="fe ma mb mc md b">app.use('/api', routes)</code>来引用任何以<code class="fe ma mb mc md b">api</code>开头的请求到我们的<code class="fe ma mb mc md b">/routes</code>子目录中的<code class="fe ma mb mc md b">index.js</code>文件。</p><blockquote class="mr ms mt"><p id="7e60" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解更多关于序列的基本Express设置，请参见:<br/> <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/sequelize-cli-and-express-fb3ddefb9786"> <strong class="ka ir">序列CLI和Express </strong> </a></p></blockquote><h1 id="5cae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用带控制器的快速路由器</h1><p id="e759" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将从设置根路由开始。打开<code class="fe ma mb mc md b">./routes/index.js</code>文件，添加以下代码:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b1f9" class="mm ky iq md b gy mn mo l mp mq">const { Router } = require('express');<br/>const controllers = require('../controllers');<br/>const router = Router();</span><span id="c18a" class="mm ky iq md b gy my mo l mp mq">router.get('/', (req, res) =&gt; res.send('This is root!'))</span><span id="d128" class="mm ky iq md b gy my mo l mp mq">module.exports = router</span></pre><p id="1dcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试路线:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5a9f" class="mm ky iq md b gy mn mo l mp mq">npm start</span></pre><p id="9cec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在浏览器中打开根端点:<a class="ae kw" href="http://localhost:3000/api/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/</a></p><p id="e8ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，我们的Express应用程序可以工作，但现在我们需要让它从Sequelize中传递数据。我们将通过创建一个控制器来处理我们所有的逻辑——我们创建新用户和项目、更新用户等的途径。</p><p id="fe20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<code class="fe ma mb mc md b">./controllers/index.js</code>并添加以下内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="931d" class="mm ky iq md b gy mn mo l mp mq">const { User } = require('../models');</span><span id="09f3" class="mm ky iq md b gy my mo l mp mq">const createUser = async (req, res) =&gt; {<br/>    try {<br/>        const user = await User.create(req.body);<br/>        return res.status(201).json({<br/>            user,<br/>        });<br/>    } catch (error) {<br/>        return res.status(500).json({ error: error.message })<br/>    }<br/>}</span><span id="29e5" class="mm ky iq md b gy my mo l mp mq">module.exports = {<br/>    createUser<br/>}</span></pre><p id="2252" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们结合了Sequelize中定义的<code class="fe ma mb mc md b">User</code>模型，根据API请求中的信息创建一个新的数据库条目。为了实现这一点，我们将在服务器上创建一个路由来连接请求和控制器:</p><p id="9d18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ma mb mc md b">./routes/index.js</code>中，在您的“这是root！”之后添加一个新行路线:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c5a8" class="mm ky iq md b gy mn mo l mp mq">router.post('/users', controllers.createUser)</span></pre><p id="8992" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将<code class="fe ma mb mc md b">/api/users</code>处的<code class="fe ma mb mc md b">POST</code>请求导向我们控制器中的<code class="fe ma mb mc md b">createUser</code>功能。为了测试它，你需要使用一个REST客户端(比如<a class="ae kw" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>或者<a class="ae kw" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠</a>)。使用<code class="fe ma mb mc md b">POST</code>方法将下面的JSON主体发送到<a class="ae kw" href="http://localhost:3000/api/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/users</a>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a712" class="mm ky iq md b gy mn mo l mp mq">{<br/>  "firstName": "Jane",<br/>  "lastName": "Smith",<br/>  "email": "jane@smith.com",<br/>  "password": "123456789"<br/>}</span></pre><p id="e099" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们终于有一个不叫约翰的用户了！更重要的是，我们使用路由器和控制器将Sequelize中的数据传递给API用户。我们可以使用相同的策略将任何顺序查询连接到一个Express端点。</p><blockquote class="mr ms mt"><p id="4b82" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解有关自定义序列查询的更多信息，请参见:<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/using-the-sequelize-cli-and-querying-4ba8d0ac4314"> <strong class="ka ir">使用序列CLI和查询</strong> </a></p></blockquote><p id="0d4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建另一个控制器方法，从数据库中获取所有用户及其相关项目。对<code class="fe ma mb mc md b">./controllers/index.js</code>进行以下更改:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c494" class="mm ky iq md b gy mn mo l mp mq">const { User, Project } = require('../models');</span><span id="a3aa" class="mm ky iq md b gy my mo l mp mq">const createUser = async (req, res) =&gt; {<br/>    try {<br/>        const user = await User.create(req.body);<br/>        return res.status(201).json({<br/>            user,<br/>        });<br/>    } catch (error) {<br/>        return res.status(500).json({ error: error.message })<br/>    }<br/>}</span><span id="d14d" class="mm ky iq md b gy my mo l mp mq">const getAllUsers = async (req, res) =&gt; {<br/>    try {<br/>        const users = await User.findAll({<br/>            include: [<br/>                {<br/>                    model: Project<br/>                }<br/>            ]<br/>        });<br/>        return res.status(200).json({ users });<br/>    } catch (error) {<br/>        return res.status(500).send(error.message);<br/>    }<br/>}</span><span id="3f79" class="mm ky iq md b gy my mo l mp mq">module.exports = {<br/>    createUser,<br/>    getAllUsers<br/>}</span></pre><p id="21ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会注意到我们已经在顶部的需求中添加了<code class="fe ma mb mc md b">Project</code>模型，新的<code class="fe ma mb mc md b">getAllUsers</code>函数指定应该包含用户的项目。我们也给<code class="fe ma mb mc md b">module.exports</code>增加了新的功能。现在，我们只需在<code class="fe ma mb mc md b">./routes/index.js</code>添加一条路线，将交通导向该功能:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="12b6" class="mm ky iq md b gy mn mo l mp mq">router.get('/users', controllers.getAllUsers)</span></pre><p id="bfea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在浏览器中打开<a class="ae kw" href="http://localhost:3000/api/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/users</a>或在Postman中执行<code class="fe ma mb mc md b">GET</code>请求来测试路由。</p><p id="1f07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好。现在让我们添加查找特定用户及其相关项目的功能。在<code class="fe ma mb mc md b">./controllers/index.js</code>中增加以下功能:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5874" class="mm ky iq md b gy mn mo l mp mq">const getUserById = async (req, res) =&gt; {<br/>    try {<br/>        const { id } = req.params;<br/>        const user = await User.findOne({<br/>            where: { id: id },<br/>            include: [<br/>                {<br/>                    model: Project<br/>                }<br/>            ]<br/>        });<br/>        if (user) {<br/>            return res.status(200).json({ user });<br/>        }<br/>        return res.status(404).send('User with the specified ID does not exists');<br/>    } catch (error) {<br/>        return res.status(500).send(error.message);<br/>    }<br/>}</span></pre><p id="6f41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记在导出中添加<code class="fe ma mb mc md b">getUserById</code>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="cf3a" class="mm ky iq md b gy mn mo l mp mq">module.exports = {<br/>    createUser,<br/>    getAllUsers,<br/>    getUserById<br/>}</span></pre><p id="cdc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将使用新功能在<code class="fe ma mb mc md b">./routes/index.js</code>中创建一条新路线:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="910e" class="mm ky iq md b gy mn mo l mp mq">router.get('/users/:id', controllers.getUserById)</span></pre><p id="37ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们添加了一个路由参数<code class="fe ma mb mc md b">:id</code>。我们的控制器函数从<code class="fe ma mb mc md b">req.params</code>中提取这些信息来找到一个特定的用户。我们在<a class="ae kw" href="http://localhost:3000/api/users/2" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/users/2</a>测试一下吧！</p><p id="63b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们现在可以创建用户、显示所有用户以及显示特定用户。更新一个用户，删除一个用户怎么样？让我们在<code class="fe ma mb mc md b">./controllers/index.js</code>中为每个函数添加一个新函数:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1511" class="mm ky iq md b gy mn mo l mp mq">const updateUser = async (req, res) =&gt; {<br/>    try {<br/>        const { id } = req.params;<br/>        const [updated] = await User.update(req.body, {<br/>            where: { id: id }<br/>        });<br/>        if (updated) {<br/>            const updatedUser = await User.findOne({ where: { id: id } });<br/>            return res.status(200).json({ user: updatedUser });<br/>        }<br/>        throw new Error('User not found');<br/>    } catch (error) {<br/>        return res.status(500).send(error.message);<br/>    }<br/>};</span><span id="6743" class="mm ky iq md b gy my mo l mp mq">const deleteUser = async (req, res) =&gt; {<br/>    try {<br/>        const { id } = req.params;<br/>        const deleted = await User.destroy({<br/>            where: { id: id }<br/>        });<br/>        if (deleted) {<br/>            return res.status(204).send("User deleted");<br/>        }<br/>        throw new Error("User not found");<br/>    } catch (error) {<br/>        return res.status(500).send(error.message);<br/>    }<br/>};</span></pre><p id="b9d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保您的导出已更新:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f2fc" class="mm ky iq md b gy mn mo l mp mq">module.exports = {<br/>    createUser,<br/>    getAllUsers,<br/>    getUserById,<br/>    updateUser,<br/>    deleteUser<br/>}</span></pre><p id="5293" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在<code class="fe ma mb mc md b">./routes/index.js</code>中添加路线:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="7c78" class="mm ky iq md b gy mn mo l mp mq">router.put('/users/:id', controllers.updateUser)<br/>router.delete('/users/:id', controllers.deleteUser)</span></pre><p id="e9df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们通过在<a class="ae kw" href="http://localhost:3000/api/users/3" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/users/3</a>的Postman中发出一个<code class="fe ma mb mc md b">PUT</code>请求来测试更新路由。请求正文应该如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="fa53" class="mm ky iq md b gy mn mo l mp mq">{<br/>    "firstName": "John",<br/>    "lastName": "Smith",<br/>    "email": "john.smith@smith.com",<br/>    "password": "superPass1"<br/>}</span></pre><p id="714a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在同一个URL上用一个<code class="fe ma mb mc md b">DEL</code>请求测试delete。</p><p id="3ba8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们只剩下<em class="mu">两名</em>约翰了！更重要的是，我们刚刚使用Express Router在Express、Sequelize和Postgres中构建了一个完整的CRUD JSON API！</p><h1 id="459d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">记录</h1><p id="323b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是集成更好的日志记录的好时机。现在，如果我们在点击<a class="ae kw" href="http://localhost:3000/api/users/2" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/users/2</a>端点时检查我们的终端，我们将看到被执行的原始SQL。出于调试目的和更好的日志记录，让我们安装一个名为<a class="ae kw" href="https://www.npmjs.com/package/morgan" rel="noopener ugc nofollow" target="_blank"> morgan </a>的快速中间件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e6a2" class="mm ky iq md b gy mn mo l mp mq">npm install morgan</span></pre><p id="82a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容添加到您的<code class="fe ma mb mc md b">server.js</code>文件中:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2c29" class="mm ky iq md b gy mn mo l mp mq">const logger = require('morgan');<br/>app.use(logger('dev'))</span></pre><p id="5310" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看结果:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b206" class="mm ky iq md b gy mn mo l mp mq">npm start<br/>open <a class="ae kw" href="http://localhost:3000/api/users/2" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/users/2</a></span></pre><p id="5107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您应该在终端中看到类似这样的内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5f5b" class="mm ky iq md b gy mn mo l mp mq">GET /api/users/2 304 104.273 ms</span></pre><p id="454c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那是摩根。</p><h1 id="6080" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">部署到Heroku</h1><p id="bc25" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在，让我们将我们的应用程序部署到Heroku来创建一个公共可访问的API。</p><p id="db60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Heroku将使用<code class="fe ma mb mc md b">package.json</code>从Git存储库构建我们的应用程序，因此我们需要如下更新该文件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="cf6b" class="mm ky iq md b gy mn mo l mp mq">...<br/>"scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "start": "node server.js",<br/>    "dev": "nodemon server.js",<br/>    "db:reset": "npx sequelize-cli db:drop &amp;&amp; npx sequelize-cli db:create &amp;&amp; npx sequelize-cli db:migrate &amp;&amp; npx sequelize-cli db:seed:all"<br/>  },<br/>...</span></pre><p id="2917" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当Heroku用<code class="fe ma mb mc md b">npm start</code>脚本启动您的远程服务器时，它将在标准节点中运行您的代码。(我们仍然可以通过运行<code class="fe ma mb mc md b">npm run dev</code>在本地使用nodemon。)</p><blockquote class="mr ms mt"><p id="b2bb" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">您需要在您的终端中安装Heroku CLI来执行以下步骤。<a class="ae kw" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">在这里一探究竟。</strong>T24】</a></p></blockquote><p id="fd9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们使用Heroku CLI设置一个新的应用程序。用您喜欢的任何名称替换下面代码中的两个<code class="fe ma mb mc md b">your-heroku-app-name</code>实例，然后在您的终端中运行这三个命令:</p><ol class=""><li id="099c" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><code class="fe ma mb mc md b">heroku create <em class="mu">your-heroku-app-name</em></code></li><li id="268a" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe ma mb mc md b">heroku buildpacks:set heroku/nodejs</code></li><li id="af18" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe ma mb mc md b">heroku addons:create heroku-postgresql:hobby-dev --app=<em class="mu">your-heroku-app-name</em></code></li></ol><p id="67d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在Heroku准备用PostgreSQL数据库构建Node.js应用。让我们将代码提交给Git(确保您在<code class="fe ma mb mc md b">master</code>分支上！)并将存储库上传到Heroku:</p><ol class=""><li id="ec39" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><code class="fe ma mb mc md b">git status</code></li><li id="cae2" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe ma mb mc md b">git commit -am "add any pending changes"</code></li><li id="9bb1" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe ma mb mc md b">git push heroku master</code></li></ol><p id="8c40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Heroku将为我们在本地环境中运行的应用开发一个产品版本。现在我们只需要告诉Heroku执行我们的迁移和种子文件:</p><ol class=""><li id="eaf5" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><code class="fe ma mb mc md b">heroku run npx sequelize-cli db:migrate</code></li><li id="0370" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe ma mb mc md b">heroku run npx sequelize-cli db:seed:all</code></li></ol><blockquote class="mr ms mt"><p id="e2e8" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">有问题吗？使用Heroku命令<code class="fe ma mb mc md b">heroku logs --tail</code>进行调试，看看Heroku服务器上发生了什么。</p></blockquote><p id="fee1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您可以在远程服务器上测试端点，方法是将下面的“your-heroku-app-name”替换为您之前使用的任何名称:</p><ul class=""><li id="b737" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv nn nf ng nh bi translated">https://your-heroku-app-name.herokuapp.com/api/users</li><li id="a789" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated">https://your-heroku-app-name.herokuapp.com/api/users/1</li></ul><p id="9cea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">又是那三个嫖客！尝试使用Postman来创建、更新和删除用户，就像我们上面做的一样。</p><p id="2143" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了。现在，您可以从地球上的任何地方访问新的Express API。接下来，尝试<a class="ae kw" href="https://medium.com/@brunopgalvao/creating-sequelize-associations-with-the-sequelize-cli-tool-d83caa902233" rel="noopener">定义你自己的序列关联</a>，进行<a class="ae kw" href="https://medium.com/@brunopgalvao/using-the-sequelize-cli-and-querying-4ba8d0ac4314" rel="noopener">定制序列查询</a>，并添加<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/getting-started-with-sequelize-cli-using-faker-824b3f4c4cfe">更健壮的种子数据</a>——或者通过<a class="ae kw" href="https://medium.com/@brunopgalvao/building-an-express-api-with-sequelize-cli-and-unit-testing-882c6875ed59" rel="noopener"> <strong class="ka ir">构建一个带有单元测试</strong> </a>的Express API来确保你的应用的可靠性！</p><blockquote class="mr ms mt"><p id="fcd0" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">本文是与纽约市的软件工程师、编辑和作家杰里米·罗斯(Jeremy Rose)合著的。</p></blockquote><h1 id="a471" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">有关Sequelize CLI和Express的更多信息:</h1><ul class=""><li id="8dc1" class="mz na iq ka b kb lv kf lw kj no kn np kr nq kv nn nf ng nh bi translated">【Sequelize CLI入门</li><li id="a3bb" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated"><a class="ae kw" href="https://medium.com/@brunopgalvao/using-the-sequelize-cli-and-querying-4ba8d0ac4314" rel="noopener">使用顺序CLI并查询</a></li><li id="2b97" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated"><a class="ae kw" href="https://medium.com/@brunopgalvao/creating-sequelize-associations-with-the-sequelize-cli-tool-d83caa902233" rel="noopener">使用序列CLI创建序列关联</a></li><li id="d3e6" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/getting-started-with-sequelize-cli-using-faker-824b3f4c4cfe">使用Faker开始Sequelize CLI</a></li><li id="fa92" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated">将CLI和Express排序</li><li id="4e0e" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated">使用序列CLI和单元测试构建Express API！</li></ul></div></div>    
</body>
</html>