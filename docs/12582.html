<html>
<head>
<title>How to Implement Concurrency and Parallelism in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中实现并发和并行</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-concurrency-and-parallelism-in-go-83c9c453dd2?source=collection_archive---------0-----------------------#2022-06-21">https://levelup.gitconnected.com/how-to-implement-concurrency-and-parallelism-in-go-83c9c453dd2?source=collection_archive---------0-----------------------#2022-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/688d156ac2ee1c08b1ef0ba05a1c28b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hF6_2HIr7pRuKWPJGBAdFA.png"/></div></div></figure><h1 id="eac8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="16f4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在深入实际主题之前，熟悉以下术语非常重要。</p><h1 id="74f1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是处理器？</h1><p id="394b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">核心或处理器是CPU中的复杂逻辑，它可以执行一组称为程序的指令。处理器是运行实际<code class="fe lu lv lw lx b">Process</code>的硬件实体。</p><h1 id="ae2e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是过程？</h1><p id="4bca" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">实际上，我们不会直接在CPU内核上运行程序。这个责任就交给了操作系统。操作系统通过一个叫做<code class="fe lu lv lw lx b">Process</code>的东西把你的程序指令写到内核或者处理器上。</p><p id="b1b0" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">一个<code class="fe lu lv lw lx b">Process</code>是由操作系统管理的程序的逻辑实例。操作系统会根据程序的优先级调度成千上万个进程。不考虑内核或处理器数量，一个操作系统可以有任意数量的<code class="fe lu lv lw lx b">logical processes</code>，但在任何时间点，每个处理器只能执行一条<code class="fe lu lv lw lx b">process</code>指令。</p><h1 id="7092" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是线程？</h1><p id="914b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">线程是进程中的执行路径。一个进程可以包含多个线程。所有程序都至少有一个线程是在程序启动时创建的，但是一个程序可以启动多个线程来并行执行工作。</p><h1 id="78b2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是并发？</h1><p id="771d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">并发是一种通过有效利用可用资源同时处理多个任务的方法。尽管它同时处理多个任务，但在任何时候它只能执行一个非阻塞任务(执行状态)。剩余任务或者处于阻塞状态、尚未开始、已完成、保持或任何其他状态。</p><p id="1406" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">正如您在下面的快照中看到的，看起来我们正在同时执行多个任务，但事实是我们正在按等待时间或阻塞状态取消任务的优先级。这样程序就可以在同一时间执行其他重要的任务，并在得到响应后回到它离开的地方。这就是所谓的并发。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/a00b5d5a45a8fe2280d556818a3c1608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sqy7nBgC9FV-tr-NE75eQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">并发</figcaption></figure><p id="b674" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">假设您已经用您最喜欢的编程语言创建了一个支持并发的程序。以及这个程序有3个任意的任务。最初，所有任务都处于默认状态(尚未开始)。</p><p id="91f3" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">假设这3个任务都涉及到一些预处理和网络调用，因此从外部系统获得响应需要花费任意的时间。</p><p id="3d25" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">运行程序后，您会看到task 1处于执行状态，因为它涉及到一些预处理。我们还知道它涉及网络调用，所以它在等待(阻塞状态)来自外部系统的响应。同时，任务2开始执行其预处理层，并由于网络调用而再次进入等待状态。现在有2个任务处于阻塞状态，所以你的程序开始执行任务3和它的预处理层。现在，甚至任务3也进入了阻塞状态。一旦任何先前被阻塞的状态得到响应，那么它各自的任务就完成了。</p><p id="ac03" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">出于某种原因，如果两个或更多处于阻塞状态的任务同时得到响应，那么你的程序会随机选择任务并一个接一个地完成它。</p><h1 id="b7f2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是并行？</h1><p id="3e19" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">并行就是在同一给定时间独立并行执行多个作业。与并发不同，它不关心任务状态，所以它同时并行执行所有任务。为了执行这些独立的动作，它消耗额外的资源。</p><p id="afea" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">正如您在下面的快照中看到的，所有3个任务同时开始执行、等待和完成各自的任务。但是总的来说，与并发相比，它花费的时间更少。就资源使用而言，当所有任务都处于空闲状态时，它仍然有带宽来容纳其他任务。借助并行技术，我们能够更快地完成工作，但却无法更好地利用资源。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/d29b8898efbf2fbfacd13dcbbcc9f496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3scxOd4szSVjxO4etcFyeg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">平行</figcaption></figure><p id="ecc6" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">如果您有一个多核系统，那么您肯定可以利用并行性。</p><h1 id="6966" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是Goroutine？</h1><p id="b69d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">goroutine是由Go运行时管理的轻量级线程。由于计算强度较低，一个线程可能有数千个goroutines。goroutine和thread之间的主要区别是Goroutine没有本地存储，因此，go routine的实现比thread便宜，所以go routine在启动时间方面要快得多。</p><p id="da94" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">如果你是goroutines的新手，那么点击下面的卡片以获得更深入的理解。</p><div class="mn mo gp gr mp mq"><a rel="noopener  ugc nofollow" target="_blank" href="/what-is-a-goroutine-find-the-right-way-to-implement-goroutines-f6ef15d1c32b"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">什么是Goroutine？找到实现goroutines的正确方法</h2><div class="mx l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd jw mq"/></div></div></a></div><h1 id="9995" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在Go中实现并行</h1><p id="cb2e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请参考下面的代码片段。</p><p id="e81b" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">它有一个名为<code class="fe lu lv lw lx b">threadProfile</code>的变量，用于跟踪运行时创建的线程数量。在Go中，线程是实现并行的方式。</p><p id="3cc9" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated"><code class="fe lu lv lw lx b">runtime.GOMAXPROCS(runtime.NumCPU())</code>用于设置您的应用程序可以使用的内核数量。如果默认情况下没有设置这个变量，它会使用所有可用的内核。通常，它是用<code class="fe lu lv lw lx b">init</code>方法定义的。</p><p id="4c54" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated"><code class="fe lu lv lw lx b">runtime.LockOSThread()</code>将调用此函数，通过锁定和解锁线程来防止goroutines重用现有线程。这是一个观察并行性的技巧，因为Go scheduler默认重用处于非阻塞状态的线程。</p><p id="f920" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">我们添加了<code class="fe lu lv lw lx b">log statements</code>来查看执行前后的线程数。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="488d" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">您可以使用<code class="fe lu lv lw lx b">go run parallelism.go</code>命令执行上面的代码片段。您将得到如下类似的输出。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/683c383111cfd7f3778ec0653c1978ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*owVA6XSWTZtDIBU6ZCQoPA.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">并行度-输出</figcaption></figure><p id="89a7" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">对于<code class="fe lu lv lw lx b">count := 10</code>，我们可以看到大约有10个新线程被创建。它清楚地表明，这个程序是通过锁定线程并行执行的。出于演示目的，我们锁定了线程来强制实现这一点。</p><h1 id="accb" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在Go中实现并发</h1><p id="9a2a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请参考下面的代码片段。</p><p id="438a" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">它具有与上面定义的几乎相似的变量和功能。唯一的主要变化是我们移除了<code class="fe lu lv lw lx b">lock</code>方法，因为我们希望看到goroutines的默认行为。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5e3f" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">您可以使用<code class="fe lu lv lw lx b">go run concurrency.go</code>命令执行上面的代码片段。如果您得到如下类似的输出，那么您已经成功地在并发模式下执行了程序。从输出中您可以理解，即使对于<code class="fe lu lv lw lx b">count:=10</code>，所有10个goroutines都容纳在相同数量的可用线程中，甚至没有创建一个新线程。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/642fd8b149f3a58dfa4a01a43a8b2a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lcR-zfjseQmyNXjDQ7Y0A.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">并发输出1</figcaption></figure><p id="a0a0" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">现在您已经看到了并发的实际应用，但是您知道Go会自动动态地创建所需数量的线程吗？。</p><p id="ab8d" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">让我们通过更新<code class="fe lu lv lw lx b">count:=1000</code> (1000个goroutines)来看看并发性和并行性的作用。您将得到如下类似的输出。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/12336c34d438d4541896f0c2c137cd46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47kfLLZn7F3gGsWKB5T8GA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">并发性-并行性-输出</figcaption></figure><p id="a911" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">如果仔细观察输出，您会发现根据需求创建了一个新线程。</p><h1 id="1c95" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h1><p id="11db" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了获得开箱即用的最佳性能，建议在您选择的任何语言中结合并发性和并行性。在Go中，它是在内部处理的，但在其他语言中，你需要显式地定义细节(node.js-clusters和async await，python-gunicorn和async await(FastAPI))。</p><p id="18ba" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">如果你喜欢这篇文章，那么你肯定也会喜欢学习Go中的高级Singleton设计模式实现。更多详情请参考下面的卡片。</p><div class="mn mo gp gr mp mq"><a href="https://medium.com/@rahul-yr/how-to-implement-singleton-design-pattern-in-go-2ca060d478e5" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">如何在Go中实现Singleton设计模式？🔥</h2><div class="nj l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">介绍</h3></div><div class="mx l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="my l"><div class="nk l na nb nc my nd jw mq"/></div></div></a></div><p id="cb13" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">可怕的🔥，您已经成功完成了本教程。我会💝听听你的反馈和意见，看看你能用它做些什么。如果你突然想到什么地方，请随意评论。我随时都有空。</p><p id="6e4c" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">如果你觉得这篇文章对其他人有帮助，那么请考虑点赞。</p><p id="9b97" class="pw-post-body-paragraph kw kx iq ky b kz ly lb lc ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt ij bi translated">请在<a class="ae nl" href="https://github.com/rahul-yr/learn-go-concepts.git" rel="noopener ugc nofollow" target="_blank"> github </a>找到完整的代码</p></div></div>    
</body>
</html>