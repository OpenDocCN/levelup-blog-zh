<html>
<head>
<title>React Tips — Scroll to Element, Load Fonts, Run setState in Sequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示-滚动到元素，加载字体，按顺序运行设置状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-tips-scroll-to-element-load-fonts-run-setstate-in-sequence-2d73c9f02ae1?source=collection_archive---------4-----------------------#2020-07-22">https://levelup.gitconnected.com/react-tips-scroll-to-element-load-fonts-run-setstate-in-sequence-2d73c9f02ae1?source=collection_archive---------4-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/02e417d1fc28a0d94b88386c8ff43236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YyGksragYHr8rkQd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@arbayne?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">兰迪·拜恩</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f2a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解一些编写更好的反应应用程序的技巧。</p><h1 id="9c5e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在反应中从外部访问组件方法</h1><p id="7b2c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们给组件分配一个引用，我们可以从外部访问组件方法。</p><p id="0e97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们对组件进行分类，我们可以编写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="635f" class="mq lf it mm b gy mr ms l mt mu">const ref = React.createRef()</span><span id="8417" class="mq lf it mm b gy mv ms l mt mu">const parent = (&lt;div&gt;<br/>  &lt;Child ref={ref} /&gt; <br/>  &lt;button onClick={e =&gt; console.log(ref.current)}&gt;click me&lt;/button&gt;<br/>&lt;/div&gt;)</span></pre><p id="4893" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mw mx my mm b">React.createRef</code>方法创建参考。</p><p id="e6b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将引用传递给<code class="fe mw mx my mm b">Child</code>组件。</p><p id="6a52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以像在<code class="fe mw mx my mm b">onClick</code>回调中那样得到具有<code class="fe mw mx my mm b">ref.current</code>属性的组件。</p><h1 id="d959" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">滚动到反应组件中的元素</h1><p id="b8fd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用带有参考的<code class="fe mw mx my mm b">window.scrollTo</code>方法滚动到反应组件中的一个元素。</p><p id="0aa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，在函数组件中，我们可以编写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6928" class="mq lf it mm b gy mr ms l mt mu">import React, { useRef } from 'react'</span><span id="3d42" class="mq lf it mm b gy mv ms l mt mu">const scrollToRef = (ref) =&gt; window.scrollTo(0, ref.current.offsetTop);</span><span id="474b" class="mq lf it mm b gy mv ms l mt mu">const App = () =&gt; {<br/>  const myRef = useRef(null)<br/>  const scrollTo = () =&gt; scrollToRef(myRef)<br/>  return (<br/>    &lt;&gt; <br/>      &lt;div ref={myRef}&gt;scroll to me&lt;/div&gt; <br/>      &lt;button onClick={scrollTo}&gt;click me to scroll&lt;/button&gt; <br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="1ce6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建<code class="fe mw mx my mm b">scrollToRef</code>函数来调用<code class="fe mw mx my mm b">scrollTo</code>。</p><p id="712d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们想滚动到元素的顶部，所以获取<code class="fe mw mx my mm b">ref.current.offsetTop</code>来获取它，并将其作为第二个参数。</p><p id="833e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mw mx my mm b">App</code>中，我们调用<code class="fe mw mx my mm b">useRef</code>钩子来创建我们的参考。</p><p id="f324" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以把我们的引用传递给div来分配它。</p><p id="2c0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们这样做了，我们添加<code class="fe mw mx my mm b">scrollTo</code>方法来滚动到分配给我们的参考的div。</p><p id="8c46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了类组件，我们可以做同样的事情。</p><p id="2f13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="502c" class="mq lf it mm b gy mr ms l mt mu">class App extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.myRef = React.createRef()  <br/>  }</span><span id="0ab1" class="mq lf it mm b gy mv ms l mt mu">  render() {<br/>    return &lt;div ref={this.myRef}&gt;&lt;/div&gt; <br/>  }</span><span id="9ed2" class="mq lf it mm b gy mv ms l mt mu">  scrollToRef = () =&gt; window.scrollTo(0, this.myRef.current.offsetTop)   <br/>}</span></pre><p id="a282" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mw mx my mm b">React.createRef</code>创建我们的参考，然后用<code class="fe mw mx my mm b">scrollToRef</code>方法滚动到它。</p><p id="3d4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了具有<code class="fe mw mx my mm b">current</code>属性的元素。</p><p id="9a55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">滚动逻辑是相同的。</p><p id="0a05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用ref回调来分配我们的ref，那么我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5f4f" class="mq lf it mm b gy mr ms l mt mu">class App extends Component {</span><span id="7eed" class="mq lf it mm b gy mv ms l mt mu">  render() {<br/>    return &lt;div ref={(ref) =&gt; this.myRef = ref}&gt;&lt;/div&gt;<br/>  }</span><span id="9d7e" class="mq lf it mm b gy mv ms l mt mu">  scrollToMyRef = () =&gt; window.scrollTo(0, this.myRef.offsetTop)<br/>}</span></pre><p id="6313" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将回调传递给<code class="fe mw mx my mm b">ref</code>道具，而不是使用<code class="fe mw mx my mm b">createRef</code>来创建我们的参考。</p><p id="7327" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到分配给引用的元素，而没有<code class="fe mw mx my mm b">current</code>属性。</p><h1 id="6fb3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在setState完成更新后运行一个函数</h1><p id="91f9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过将回调传入<code class="fe mw mx my mm b">setState</code>的第二个参数，在<code class="fe mw mx my mm b">setState</code>完成更新后运行一个函数。</p><p id="5d01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="89fa" class="mq lf it mm b gy mr ms l mt mu">const promiseState = async state =&gt; new Promise(resolve =&gt; this.setState(state, resolve));</span></pre><p id="333b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mw mx my mm b">async</code>函数创建了一个承诺，该函数以<code class="fe mw mx my mm b">resolve</code>作为第二个参数。</p><p id="2c05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e176" class="mq lf it mm b gy mr ms l mt mu">promiseState({...})<br/>  .then(() =&gt; promiseState({<br/>    //...<br/>  })<br/>  .then(() =&gt; {<br/>    //...<br/>    return promiseState({<br/>      //...<br/>    });<br/>  })<br/>  .then(() =&gt; {<br/>    //...<br/>  });</span></pre><p id="d1c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们就可以想打多少次<code class="fe mw mx my mm b">setState</code>就打多少次。</p><h1 id="1812" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">向基于create-react-app的项目添加字体</h1><p id="80cc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要将字体添加到create-react-app项目中，我们可以将其放入CSS代码中。</p><p id="1701" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8b6d" class="mq lf it mm b gy mr ms l mt mu">@font-face {<br/>  font-family: 'SomeFont';<br/>  src: local('SomeFont'), url(./fonts/SomeFont.woff) format('woff');<br/>}</span></pre><p id="e34b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mw mx my mm b">index.css</code>里。</p><p id="1b36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过编写以下内容来导入它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5978" class="mq lf it mm b gy mr ms l mt mu">import './index.css';</span></pre><p id="9a3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mw mx my mm b">font-face</code>规则定义了一种新字体。</p><p id="cc08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">src</code>有字体的位置。</p><p id="c9df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">font-family</code>有字体名。</p><p id="720e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像用Webpack导入模块一样导入CSS。</p><p id="8eab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以把字体放在<code class="fe mw mx my mm b">index.html</code>里。</p><p id="a9b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="459b" class="mq lf it mm b gy mr ms l mt mu">&lt;link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet"&gt;</span></pre><p id="8a58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="13d8" class="mq lf it mm b gy mr ms l mt mu">&lt;style&gt;<br/>    @import url('https://fonts.googleapis.com/css?family=Montserrat');<br/>&lt;/style&gt;</span></pre><p id="2832" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个解决方案是使用webfontloader包。</p><p id="e0b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要安装它，我们运行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7564" class="mq lf it mm b gy mr ms l mt mu">yarn add webfontloader</span></pre><p id="01c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b4ec" class="mq lf it mm b gy mr ms l mt mu">npm install webfontloader --save</span></pre><p id="a7b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c3d6" class="mq lf it mm b gy mr ms l mt mu">import WebFont from 'webfontloader';</span><span id="9035" class="mq lf it mm b gy mv ms l mt mu">WebFont.load({<br/>   google: {<br/>     families: ['Open Sans:300,400,700', 'sans-serif']<br/>   }<br/>});</span></pre><p id="1a85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来加载我们想要的字体。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1f31975009aabb9318b28cce1e4aacad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YPHMBvhT2XYlo9RU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@yogendras31?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yogendra Singh </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="80d9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b391" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有多种方法可以将字体加载到我们的create-react-app项目中。</p><p id="8be4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过给组件分配一个ref来从组件外部访问组件方法，然后我们可以调用这些方法。</p><p id="6662" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这适用于类组件。</p><p id="ea8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有多种方法可以滚动到一个元素。</p><p id="c393" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将一个函数传递给它的第二个参数，我们可以按顺序运行<code class="fe mw mx my mm b">setState</code>。</p></div></div>    
</body>
</html>