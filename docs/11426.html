<html>
<head>
<title>Applying Graph Theory concepts in basic data manipulation problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在基本数据操作问题中应用图论概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graph-theory-in-everyday-coding-problems-d4a5cbe1db15?source=collection_archive---------7-----------------------#2022-03-15">https://levelup.gitconnected.com/graph-theory-in-everyday-coding-problems-d4a5cbe1db15?source=collection_archive---------7-----------------------#2022-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5efc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在常见的数据操作问题中检测和应用图论概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49dc8f81c53f92f9f01e66d501afbd73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqUw5FXXkIFYtG3w9KEflw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我自己的照片，摄于巴塞罗那的马斯努</figcaption></figure><p id="12db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解一些<a class="ae ky" href="https://en.wikipedia.org/wiki/Graph_theory#:~:text=In%20mathematics%2C%20graph%20theory%20is,also%20called%20links%20or%20lines)." rel="noopener ugc nofollow" target="_blank">图论</a>的基础知识的一个有趣的方面是，我经常发现自己将领域中的基本问题转化为日常的编码问题。这不仅是一个迷人的领域，而且在掌握了一些基本知识和经验之后，你可以将它应用于更一般的问题。</p><p id="bcac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我想展示一些我发现自己过去的案例，我们利用图论的概念极大地简化了我正在处理的问题。还从我自己回答的堆栈溢出问题中摘录了一些例子，我认为也可以作为很好的用例。</p><p id="e539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这些例子可能看起来有点做作，但它们是我看到的实际的具体问题，可能会帮助您看到我们可以利用图论分析的想法的不同方式。</p><h2 id="2cb2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">#示例1</h2><p id="450a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我想到的最明显的例子，可能与我正在从事的一个金融相关项目有关，在这个项目中，我必须将一些遗留代码迁移到<em class="mt"> python </em>上，如果可能的话，还要优化其实现和性能。在前面的实现中，有一个特别低效的部分，其中包含一个嵌套的for循环。为了更好地理解，让我们将下面的数据帧作为一个玩具示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/38564f59dc0174becef0f3defa70d3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*nQObcBbp1VmcL62wrN0msg.png"/></div></figure><p id="d7cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据集包含来自某个客户端的<a class="ae ky" href="https://en.wikipedia.org/wiki/Enterprise_resource_planning" rel="noopener ugc nofollow" target="_blank"> ERP </a>的交易数据，以及与其他客户端一起执行的操作(用<strong class="lb iu"> id </strong>标识)和两个名为<strong class="lb iu"> rel1 </strong>和<strong class="lb iu"> rel2 </strong>的字段。这两列将事务相互链接，表明它们是与同一产品相关的操作。举例来说，我们可以把每一项操作看作是债务的分期付款。</p><p id="7371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使算法工作，第一步是识别所有与<strong class="lb iu">链接的</strong>行，即在最后两列中具有公共值的行。例如，在第一行中，我们有一个为10的<strong class="lb iu"> rel1 </strong>，它将链接到最后一行，其<strong class="lb iu"> rel2 </strong>为10。</p><p id="3d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何着手为这些相关的组生成一个标识符呢？</p><h2 id="107a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">连接的组件</h2><p id="8788" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这被证明是一个常见图论问题的完美用例:找到<a class="ae ky" href="https://en.wikipedia.org/wiki/Connected_component" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">连接的组件</strong> </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/1676555ed0f6d859c07af8514932eb09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KVeR37TBS4vkYTF_.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图来自<a class="ae ky" href="https://stackoverflow.com/questions/53886120/combine-lists-with-common-elements/53886179#53886179" rel="noopener ugc nofollow" target="_blank">我自己的回答</a>在SO</figcaption></figure><p id="ea23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图是一个由3个部分组成的示例图。您可能已经猜到，一个组件是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Connected_graph" rel="noopener ugc nofollow" target="_blank">连接的</a> <a class="ae ky" href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#subgraph" rel="noopener ugc nofollow" target="_blank">子图</a>，它不是任何更大的连接子图的一部分。在这种情况下，由Simon、John和Sayyed构成的左侧部分构成了图的连通部分之一。这3个节点都没有连接到图中其他组件的任何其他节点。</p><p id="a33f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个库可以用来解决图论问题。最常见的，也是我最喜欢的，是python的<a class="ae ky" href="https://networkx.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> NetworkX </strong> </a>。</p><p id="068d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，回到手头的问题，<strong class="lb iu"> rel1 </strong>和<strong class="lb iu"> rel2 </strong>将表示图中的边，即两个节点之间的链接。为了找到这些边形成的连通分量，我们可以使用NetworkX的<code class="fe mw mx my mz b"><a class="ae ky" href="https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.connected_components.html" rel="noopener ugc nofollow" target="_blank">nx.connected_components</a></code>。首先，我们需要用两列形成的边创建一个列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">形成<em class="mt">边列表</em>后，我们现在可以找到连接的组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="12f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在已经确定了组件，将每一行分配给其中一个就是将其中一列中的每个节点映射到一个组件，例如，<strong class="lb iu"> rel1 </strong>。</p><p id="fcbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到行<code class="fe mw mx my mz b">1</code>和<code class="fe mw mx my mz b">2</code>是如何连接的，因为它们共享节点<code class="fe mw mx my mz b">46</code>。如你所见，只需几行代码，这个问题就能以比生产中更有效的方式解决，减少计算时间和相关成本。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="0e07" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">#示例2</h2><p id="64c0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下一个例子直接取自<a class="ae ky" href="https://stackoverflow.com/questions/62307239/obtain-path-from-unordered-list-of-edges/62307352#62307352" rel="noopener ugc nofollow" target="_blank">我自己回答的堆栈溢出</a>中的一个问题，代表了图论算法的一个有趣的用例。要解决的问题是从无序的元组列表<code class="fe mw mx my mz b">(origin, destination)</code>中找到完整的路线。问题中的位置是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="aa40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这里我们有一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Vertex_(graph_theory)" rel="noopener ugc nofollow" target="_blank">节点</a>之间的连接列表，我们希望找到这些节点生成的完整路径。</p><p id="2396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以为了解决这个问题，我们想要的是连接所有这些边的<a class="ae ky" href="https://en.wikipedia.org/wiki/Path_(graph_theory)" rel="noopener ugc nofollow" target="_blank">路径</a>，这也是图中最长的可能路径<a class="ae ky" href="https://en.wikipedia.org/wiki/Longest_path_problem" rel="noopener ugc nofollow" target="_blank">。在这种情况下，它恰好是连接图中仅有的两个极端的路径，但是实现</a><a class="ae ky" href="https://en.wikipedia.org/wiki/Longest_path_problem#:~:text=In%20graph%20theory%20and%20theoretical,length%20in%20a%20given%20graph." rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">最长路径</strong>算法</a>将是解决这个问题的简单方法。为此，我们可以使用NetworkX的<code class="fe mw mx my mz b">nx.dag_longest_path</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6e20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们可以使用上述函数轻松获得元组列表的有序版本，并找到路径的开始和结束节点，<code class="fe mw mx my mz b">Madrid</code>和<code class="fe mw mx my mz b">New York JFK</code>。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h2 id="121f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">#示例3</h2><p id="bdf1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是本文的第三个也是最后一个例子。我认为这个很有趣，因为它也展示了NetworkX可视化图形的潜力。<a class="ae ky" href="https://stackoverflow.com/questions/61870686/construct-a-tree-out-of-list-of-strings/61876102#61876102" rel="noopener ugc nofollow" target="_blank">这是问题的链接</a>。总而言之，最初的发帖人碰巧处理了一个包含嵌套列表的问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5939c15fcb0b5327664ea5bdfa0f9589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*N-b-qnx4xH1EbWLlztrSJg.png"/></div></figure><p id="70de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在的问题是如何生成一个树状的有向图，以及如何将它可视化。这将是查看这些字符串序列所遵循的所有可能组合或<a class="ae ky" href="https://en.wikipedia.org/wiki/Path_(graph_theory)" rel="noopener ugc nofollow" target="_blank">路径</a>的简单方法。</p><p id="9907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们只需要从嵌套列表中创建一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Directed_graph" rel="noopener ugc nofollow" target="_blank">有向图</a>，并将每个列表添加为图的<a class="ae ky" href="https://en.wikipedia.org/wiki/Path_(graph_theory)" rel="noopener ugc nofollow" target="_blank">路径</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里开始，利用库支持的多种布局，我们可以用<code class="fe mw mx my mz b"><a class="ae ky" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_agraph.graphviz_layout.html" rel="noopener ugc nofollow" target="_blank">graphviz_layout</a></code> <a class="ae ky" href="https://networkx.org/documentation/stable/reference/generated/networkx.drawing.nx_agraph.graphviz_layout.html" rel="noopener ugc nofollow" target="_blank"> </a>以树状结构表示图形:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="792e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它产生:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/69984b2ce272da176337d1f0ed2c519f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kNAlGwmxhYATmFXf.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">生成自<a class="ae ky" href="https://stackoverflow.com/questions/61870686/construct-a-tree-out-of-list-of-strings/61876102#61876102" rel="noopener ugc nofollow" target="_blank">我自己的答案在SO </a></figcaption></figure><p id="7c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，为了清楚起见，之前已经添加了级别<em class="mt"> n </em>后缀。通过这个例子，我们可以看到这个库对于表示这样的问题是多么的有用。</p><p id="e8d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。我希望您觉得它有用，如果您有兴趣了解更多关于这个库或其他用例的信息，请告诉我！</p><p id="d04a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好，lex</p></div></div>    
</body>
</html>