<html>
<head>
<title>Why I Switched From Rust to Go on the Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我从Rust转向后端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-i-switched-from-rust-to-go-on-the-backend-28bda21dbee9?source=collection_archive---------0-----------------------#2022-11-10">https://levelup.gitconnected.com/why-i-switched-from-rust-to-go-on-the-backend-28bda21dbee9?source=collection_archive---------0-----------------------#2022-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9f2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个单后端开发者的冷门故事。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25cbde339ee4b8f390a3093339348bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrtWmdX_AS5E-91Hx6YXhQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我两个最好的朋友。</figcaption></figure><p id="fec2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请放下干草叉！你一点击这篇文章，我就感觉到了你的愤怒。我不反对Rust——我更喜欢它的各种使用情况。所有的编程语言都是达到目的的手段。在我的例子中，Rust根本没有删除它，我不得不删除这个项目并用Golang重写它。</p><p id="857b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该项目是一个简单的后端webhook服务。如果您不熟悉Hasura，它是一个Postgres数据库的包装器，为您提供了一个即时的GraphQL API。对于像我这样独自开发激情项目的人来说，这非常方便:写出每个REST端点或GQL解析器需要大量时间，而且在每个模型上几乎都是相同的CRUD操作。当您需要一些更复杂的逻辑时，这种方法就失效了——为此，Hasura允许您将一个GQL请求映射到一个定制的webhook。举几个例子，我用这个来上传S3文件或者认证。</p><h2 id="e580" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">问题一:依赖注入的困境</h2><p id="42cc" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Rust依赖注入的故事很有趣。一旦你要求一个具体的类型，即</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="983e" class="lu lv it mt b gy mx my l mz na">fn do_stuff(db: &amp;Database) {  <br/>    db.create(Stuff);  <br/>    db.read(Stuff);<br/>}</span></pre><p id="6cfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你必须将一个<code class="fe nb nc nd mt b">Database</code>的实例传递给<code class="fe nb nc nd mt b">do_stuff</code>；没有例外！<code class="fe nb nc nd mt b">Database</code>你不能“子类化”(子类在Rust中字面上不是一个概念)。所以，如果你是一个不测试他们代码的程序员，那么这完全没问题；实际上，您真的会有一个数据库的实现，所以没有理由让这个函数采用除了<code class="fe nb nc nd mt b">Database</code>之外的任何东西。</p><p id="0bee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而我们测试者呢？我们必须重写函数签名。<code class="fe nb nc nd mt b">Database</code>需要成为一个特征，然后我们获取这个特征，并在我们的模拟对象上实现它。好吧，那也没<em class="ne">那么</em>糟糕。事实上，我在Golang做着同样的事情。那么，这实际上是从哪里开始瓦解的呢？</p><h2 id="e295" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">问题二:异步特征</h2><p id="db89" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在Rust中，你有简单的异步，你有简单的特征，但是有异步特征有点困难。我在Rust of async traits中发现的大多数例子都使用了<code class="fe nb nc nd mt b">async_trait</code>宏。这是非常有用的，我正在使用它，是一个快乐的露营者。</p><p id="253c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是我迄今为止的旅程总结:</p><ol class=""><li id="07bc" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">编写一个结构；开心点。</li><li id="ddba" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">写一个测试；意识到你不能依赖注入。伤心吧。</li><li id="5645" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">将该结构转换为特征；开心点。</li><li id="1d93" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">依赖注入我的心田。</li><li id="1b85" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">使用<code class="fe nb nc nd mt b">mockall</code>板条箱自动生成模型。要非常非常开心！</li><li id="ec2e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">我需要进行一个异步http调用。</li><li id="80e0" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">实现异步特征需要一个特殊的宏。</li><li id="df24" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">意识到宏不能很好地与Mockall一起工作。</li><li id="9fff" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">伤心吧:/。</li></ol><p id="d7a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事后看来，这个<a class="ae nt" href="https://docs.rs/mockall/latest/mockall/#async-traits" rel="noopener ugc nofollow" target="_blank">问题有了解决方案</a>。也许在我决定离开之前，我应该再试一次，但是此时我已经有点沮丧了…到下一点。</p><h2 id="2921" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">问题三:棺材(容器)里的钉子(编译时间)</h2><p id="1e90" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">废话废话铁锈有糟糕的编译时间。我们已经听过一千遍了；你不可能有一种无所不能又没有缺点的语言。这是不可能的——Rust的缺点是很难理解它的寿命和编译时间。</p><p id="ab8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有一台漂亮、结实的笔记本电脑——M1 Mac是一台老爷车。在我的Mac上编译rust绝对没有问题。通常，当我编写服务器时，我在本地开发，并确保每次我做出更改时，在我提交真正的单元测试之前，我会快速地重新加载本地服务器并测试特性。这需要在两次试验之间进行大量的编译；这很好。同样，在我的Mac上编译Rust没有问题。</p><p id="0905" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在一个容器里？别提了。</p><p id="2df2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对我来说，最简单的方法是移植许多本地服务，而不必担心在每个服务中运行<code class="fe nb nc nd mt b">npm run</code>( Hasura，web hooks，mock s3，mock oauth server..)就是有一个<code class="fe nb nc nd mt b">docker-compose.yaml</code>来运行所有这些东西。这意味着，通常，它是一个<code class="fe nb nc nd mt b">docker-compose.dev.yaml</code>，因为我实际上并不使用docker compose来部署。只能在当地发展。不过，这也有副作用，我的Rust代码需要在容器中编译——因为:</p><ol class=""><li id="e008" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">关于自动热重装没有商量余地。</li><li id="d936" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">在容器内开发是没有商量余地的。</li></ol><p id="4739" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有两个选择:要么通过旋转一个巨大的图像让Rust编译来节流我的整个计算机，要么处理3分钟以上的编译时间。我的开发周期停滞不前，我感到难以置信的低效。我试图改变我的工作流程，在手动测试之前编写代码和测试，或者不使用自动热重装，但是我感觉受到了束缚。我就是做不到。</p><p id="83fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我终于咬紧牙关，改走了。我们会想念你的，Rust:我非常喜欢写Rust代码。我觉得它美丽而富有表现力，实用而优雅。</p><p id="14e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我正在编写本地助手库、性能敏感代码、任何我不需要在容器中运行的后端服务…铁锈是第一选择。尤其是在我不需要说服别人使用它的情况下。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="4f98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有人对我的问题有任何解决方法，尤其是最后一个，请告诉我。我很想让Rust回到这个项目中，并愿意回到旧版本，使它达到同等水平。</p><p id="9495" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="a128" class="ob lv it bd lw oc od oe lz of og oh mc jz oi ka mf kc oj kd mi kf ok kg ml ol bi translated">分级编码</h1><p id="5a5c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="7a78" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt om nl nm nn bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="9cf8" class="nf ng it la b lb no le np lh nq ll nr lp ns lt om nl nm nn bi translated">📰查看<a class="ae nt" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="195c" class="nf ng it la b lb no le np lh nq ll nr lp ns lt om nl nm nn bi translated">🔔关注我们:<a class="ae nt" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae nt" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae nt" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="3233" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">🚀👉<a class="ae nt" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>