<html>
<head>
<title>Everybody Needs Backups - A Lesson Learned The Hard Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个人都需要备份——这是一个惨痛的教训</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/everybody-needs-backups-a-lesson-learned-the-hard-way-b4b720afaa3a?source=collection_archive---------20-----------------------#2021-11-30">https://levelup.gitconnected.com/everybody-needs-backups-a-lesson-learned-the-hard-way-b4b720afaa3a?source=collection_archive---------20-----------------------#2021-11-30</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="5c79" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">我的Docker Swarm中的一个大事件以及事件发生后我开发的解决方案。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/2be63d63a7ffaed5ee035e88b986d8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19i77Y8PejSEkGRytmU_Bw.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由来自<a class="ae kz" href="https://www.pexels.com/photo/man-showing-distress-3777572/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/@olly?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">安德里亚·皮亚卡迪奥</a>拍摄</figcaption></figure><h1 id="13aa" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">该事件</h1><p id="c683" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">这是几天前我艰难地学到的一课。目前，我在一家软件公司做顾问。在我为不同公司远程工作期间，我把我所有投入的时间都记录在我的个人时间追踪软件中，这个软件非常好用。最棒的是我的时间跟踪软件在docker环境中的本地机器上运行！这太酷了！</p><p id="a29d" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">在过去的几周里，我在Docker Swarm上工作，建立我个人的Swarm环境。一切都结束后，我决定将我的时间跟踪软件移到集群中。因为它已经是一个docker容器，我可以轻松地备份MySQL数据，并将所有内容放入我的Swarm。它运行平稳。一切正常！</p><p id="fd5f" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">几天后，我决定在我的swarm中创建另一个docker容器。所以我写了<code class="fe mt mu mv mw b">docker-compose.yml</code>并部署了它。我在和我的蜂群一起工作。增加了许多服务(Gitlab、邮件服务器、Portainer等)。</p><p id="7c8d" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">然后有一天，当我完成工作并想记录我的工作时间时，时间跟踪软件却不可用了。</p><p id="e6ea" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">于是我开始研究</strong>:到底是怎么回事？为什么我无法访问该网站？我检查了蜂群。每个服务都正确部署并运行。之后，我查了日志…在软件中，我看到一条消息，说数据库不存在。但它应该在那里？？</p><p id="8899" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我在我的MySQL容器中。然后我就看到了。<strong class="lu iv">再也没有DB了！</strong>这是怎么回事？和<code class="fe mt mu mv mw b">docker stack ps timetracking</code>一起，我检查了每个集装箱。经过一番研究，我看到一个容器被杀，另一个被部署。通常这不是一个真正的问题。<strong class="lu iv">但是后来… </strong>我发现它被部署到了我的集群中的另一个节点上。这很糟糕，因为我知道那个节点上没有卷。</p><p id="f4fb" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我很高兴，因为我认为我可以很容易地改变它。我打开了<code class="fe mt mu mv mw b">docker-compose.yml</code>并添加了一个约束，即服务应该一直部署在同一个节点上:</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="bcd9" class="nb lb iu mw b gz nc nd l ne nf">deploy:<br/>      placement:<br/>        constraints:<br/>          - node.hostname == *****</span></pre><p id="6164" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">我知道这会导致在我的集群中的特定节点上进行部署</strong>。现在数据库不会丢失，它应该使用旧卷！</p><p id="a88a" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">然后容器重启后，整个卷被销毁。它再也打不开了。</strong></p><p id="fbfa" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><em class="ng">幸运的是，几天前当我从本地docker env迁移到swarm时，我创建了一个数据库备份。我很高兴我没有损失整整一个月的工作时间……</em></p><h1 id="6aa7" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">备份脚本</h1><p id="95f7" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">这件事之后，我唯一想做的事情就是为我的docker env开发一个简单的备份功能。首先，我<code class="fe mt mu mv mw b">exec</code>进入每个容器并保存数据库以确保万无一失。下一步真的很简单。我搜索了docker备份功能，发现了一些非常有趣的文章和教程，内容是用加密和.....</p><p id="c052" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">这太难了，因为我需要一个非常简单的解决方案。我只想将我的数据库从每个docker容器复制到一个安全的地方。我决定创建一个小脚本来完成这个任务。然后每天都会执行这个脚本。</p><p id="b2d1" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">经过几个小时的bash脚本研究，我开发了一个名为<code class="fe mt mu mv mw b">full-db-backup.sh</code>的简单文件，稍后我会解释这个文件</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">一个非常简单的脚本来备份MySQL和MariaDB容器。</figcaption></figure><p id="f99a" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第1行:</strong> <br/>添加<strong class="lu iv"> <em class="ng"> #！/bin/bash </em> </strong>作为脚本的第一行，告诉操作系统调用指定的shell来执行脚本中的命令。</p><p id="bb8b" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第2行:</strong> <br/>创建一个名为<code class="fe mt mu mv mw b">containers</code>的变量，并在<code class="fe mt mu mv mw b">$( )</code>内填入命令内容。该命令列出了所有正在运行的docker进程，然后将结果(通过<code class="fe mt mu mv mw b">|</code>转发给<code class="fe mt mu mv mw b">grep</code>，后者根据两种模式对它们进行过滤(<code class="fe mt mu mv mw b">myql </code>或<code class="fe mt mu mv mw b">maria</code>)。这些结果将被转发给awk，它只打印前面列出的行中的最后一项。因此，将有一个包含每个容器名称的数组。</p><p id="172a" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第4–5行:</strong> <br/>开始一个for循环，遍历每个容器名。</p><p id="4f34" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第6行:</strong> <br/>用<code class="fe mt mu mv mw b">.</code>拆分的容器名创建一个数组。通常docker容器名称是这样创建的:<code class="fe mt mu mv mw b">service-name.replica.some-hash</code></p><p id="da4a" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第8–9行:</strong> <br/>开始一个for循环，遍历字符串数组的每一部分</p><p id="8d76" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第10–11行:</strong> <br/>保存变量<code class="fe mt mu mv mw b">simpleName</code>中的第一个值(服务名),然后中断循环</p><p id="6824" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第12行:</strong> <br/>为循环结束参数</p><p id="fb18" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第14行:</strong> <br/>保存变量内的实际时间戳</p><p id="29b5" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第15行:</strong> <br/>连接到名为<code class="fe mt mu mv mw b">$container</code>(数组<code class="fe mt mu mv mw b">$containers</code>的一部分)的docker容器，执行<code class="fe mt mu mv mw b">myqsldump</code>保存每个数据库。作为密码，它使用一个ENV变量(<code class="fe mt mu mv mw b">$MYSL_ROOT_PASSWORD</code>)，这个变量几乎用于我环境中的每个MySQL/MariaDB docker卷。在转储之后，文件被保存在/root/backups中，使用从容器<code class="fe mt mu mv mw b">simpleName</code>中创建的名称和实际的时间戳</p><p id="7dfd" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated"><strong class="lu iv">第16行:</strong>为循环结束参数</p><h1 id="d896" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">执行备份</h1><p id="d1dc" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">我测试了脚本，它像预期的那样工作。它每次都会创建一个包含整个数据库备份的新文件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nj"><img src="../Images/5c9b134afd1e6cbe7885d81bf65722b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*zxQJl3m1BAFnHHWGsogl6g.jpeg"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@greysonjoralemon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Greyson Joralemon </a>在<a class="ae kz" href="https://unsplash.com/s/photos/party?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7947" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">但是我不得不在间隔中执行脚本<strong class="lu iv">，这样数据库中的更新也会被保存。</strong></p><p id="81f4" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我不想太复杂，所以我决定在每个docker群节点上只使用一个简单的cronjob。这不是最好的东西，但它的工作。这就是我现在想要的。</p><p id="0ce4" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我用<code class="fe mt mu mv mw b">crontab</code>创建了一个新的cronjob。使用下面的命令，我打开了机器上的cronjob列表。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="6384" class="nb lb iu mw b gz nc nd l ne nf">$&gt; crontab -e</span></pre><p id="87c0" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">我添加了一个cron作业，该作业将在每天凌晨1点执行，它将只执行我开发的脚本，该脚本在我的根文件夹中创建备份。</p><pre class="kk kl km kn gu mx mw my mz aw na bi"><span id="2328" class="nb lb iu mw b gz nc nd l ne nf">0 1 * * * /bin/sh /root/cronjobs/full-db-backup.sh</span></pre><p id="8136" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">最后，我将脚本复制到集群中的每个节点，并向其中添加相同的cronjob。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/4d221d7c3c6bdf311727753ea3120fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*nABFnopb51wzkB2O5nEYdg.jpeg"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">使用Imgflip <a class="ae kz" href="https://imgflip.com/memegenerator" rel="noopener ugc nofollow" target="_blank"> Meme生成器</a>创建</figcaption></figure><h1 id="d5af" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">结束语</h1><p id="7885" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">我知道这不是最好的解决方案，但目前这种快速的方法已经足够了。现在我可以开始学习一些关于ANSIBLE的知识，以及如何在剧本中自动化这个脚本。此外，我会创建一些将我的转储上传到亚马逊。并在上传前加密。但是现在我有时间做这个<strong class="lu iv">因为我很安全</strong>！</p><p id="e128" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">尽管如此，我希望这篇文章对您有所帮助！如果你也有一个有趣的备份策略可以分享，欢迎在这里发表评论。<strong class="lu iv">快乐备份！</strong></p></div><div class="ab cl nl nm hy nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="in io ip iq ir"><h1 id="1603" class="la lb iu bd lc ld ns lf lg lh nt lj lk ka nu kb lm kd nv ke lo kg nw kh lq lr bi translated">这篇博客到此结束。我很想听听你的想法和想法🤗请把它们记在下面👇👇👇</h1><h1 id="437e" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">✍️作者</h1><h1 id="5b34" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">保罗·克努特</h1><p id="4bcc" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi">👨🏻‍💻🤓🏋️‍🏸🎾🚀</p><p id="4872" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">丈夫，两个孩子的父亲，极客，终身学习者，技术爱好者和软件工程师</p><p id="ad1c" class="pw-post-body-paragraph ls lt iu lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn in bi translated">与此稍有不同的版本最初发表在<a class="ae kz" href="https://www.paulsblog.dev/everybody-needs-backups-a-lesson-learned-the-hard-way/" rel="noopener ugc nofollow" target="_blank">https://www . paulsblog . dev/every one-needs-backups-a-lesson-learned-the-hard-way/</a></p><h1 id="482d" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">打招呼🙌开启:</h1><p id="1b0f" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated"><a class="ae kz" href="https://www.twitter.com/paulknulst" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae kz" href="https://www.linkedin.com/in/paulknulst/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>，<a class="ae kz" href="https://github.com/paulknulst" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，<a class="ae kz" href="https://blog.knulst.de/" rel="noopener ugc nofollow" target="_blank">个人博客</a></p></div></div>    
</body>
</html>