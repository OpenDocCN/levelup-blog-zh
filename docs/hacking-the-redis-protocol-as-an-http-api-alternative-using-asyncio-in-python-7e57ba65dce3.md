# 用 Python 中的 Asyncio 破解 Redis 协议，作为 HTTP API 的替代。

> 原文：<https://levelup.gitconnected.com/hacking-the-redis-protocol-as-an-http-api-alternative-using-asyncio-in-python-7e57ba65dce3>

![](img/6b0eac64fdfe9c10bb98fa1bfe3d6957.png)

通常当你想到 API 的时候，你会直接想到 HTTP。虽然该协议占主导地位是有充分理由的，但它主要是为 web 构建的，并且可能不适用于服务器到服务器的 API，在这种 API 中，长期的和经过身份验证的连接是常见的。HTTP2 解决了多路复用、报头压缩等一些问题，但是这些增加的功能使协议变得笨拙。至少应该考虑一个替代方案。

## 为什么是 Redis 协议？

很难找到像 Redis 一样用这么多种语言编写的请求-响应协议。几乎每种语言都有一个客户端，无论是否得到官方支持，协议非常简单，一个基本的客户端可以在一个小时内编写完成。使用 RESP 作为 API 的一些潜在好处包括:

*   长期的联系。
*   不需要对每个请求进行重新认证。这包括发送头和检查存储或处理 jwt 中的 API 键。
*   客户端已经过实战测试，专为高性能而编写，并且支持大多数语言。
*   客户端内置了授权和 SSL。
*   简单协议。HTTP2 的协议非常复杂，涉及到状态机，并且实现起来杂乱无章。RESP 很简单，可以在网上直接阅读原文。
*   对于生产中使用的最多产的存储器之一来说已经足够好了。

# 构建服务器

[Redis 协议](https://redis.io/topics/protocol)由 5 种类型组成。这些类型以一个字节为前缀，表示后续字节所代表的内容。Redis 文档简洁地描述了对象的头字节。

*   对于简单的字符串，回复的第一个字节是“+”
*   对于**错误**，回复的第一个字节是“-”
*   对于整数**回复的第一个字节是“:”**
*   对于**批量字符串**，回复的第一个字节是“$”
*   对于**数组**，回复的第一个字节是“*”

这种简单性使得 Redis 响应很容易用字节格式构造，如:`b"-ERROR %b\r\n" % err_text`(这是一个序列化错误)。

我们的紧凑服务器是通过一个简单的技巧实现的:由于 Redis 命令被编码为数组，客户端可以接收数组作为响应，因此客户端的解析器与服务器的解析器完全相同。

实现`QUIT`命令的最小 Redis 服务器如下所示:

## 我们 API 服务器的亮点

Python 不建议您直接使用 StreamReader，而是使用`loop.start_server`。然而，aioredis 实现了自己的 StreamReader，直接解析来自套接字的 redis 对象。为了使用它，复制了部分`[start_server](https://github.com/python/cpython/blob/master/Lib/asyncio/streams.py#L58)`函数并注入了 aioredis 的 StreamReader。

这是连接的主循环。它无限循环地解析一个 Redis 对象，并为每个对服务器的调用调用`process_command`。

我们的业务逻辑被隔离到`process_command`功能。循环需要返回的唯一信息是是否中断和关闭连接。

## 实施命令

Redis 命令以二进制字符串数组的形式出现。您可以使用 JSON 轻松地编码和解码您的参数，以生成提供丰富功能的命令:

我们可以通过启动 Redis 客户机并手动执行它们来使用这些命令。将这些命令包装在一个客户端类中可以清理和划分事物。

# 最后的想法

由于我们使用 Redis 客户端解析器，如果我们安装`hiredis-py`，我们的服务器将自动开始使用用 c 编写的更快的解析器。另一个性能改进是使用 [msgpack](https://msgpack.org/index.html) 进行序列化，以获得额外的性能优势。因为 Redis 客户端通常支持 TLS，所以我们可以尝试将它放在一个带有 SSL 的负载平衡器后面，看看这个实现的生产就绪程度如何。还应该考虑解析器的安全性，以确保不可能通过发送大字符串来实例化 DDOS 攻击。

性能应该很不错。所有的代码都是相当低级的，对象是直接从网络上解析的。如果能以 uvicorn 或其他 HTTP 框架为基准进行测试，那就太好了。

总的来说，asyncio 提供的紧凑实现给我留下了非常深刻的印象，它只用 50 行代码就创建了一个非常健壮的服务器。这种创建 API 的方法看起来很有前途，我期待着进一步研究它。