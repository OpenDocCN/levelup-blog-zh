<html>
<head>
<title>Set Up End-to-End Tests with Puppeteer and Mocha</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用木偶师和摩卡建立端到端的测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/set-up-end-to-end-tests-with-puppeteer-and-mocha-4bb0c24b563a?source=collection_archive---------2-----------------------#2019-02-13">https://levelup.gitconnected.com/set-up-end-to-end-tests-with-puppeteer-and-mocha-4bb0c24b563a?source=collection_archive---------2-----------------------#2019-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6cba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在主测试套件之前登录，并在并行浏览器实例中运行几个套件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca145f5b23554f2d143ba4bd36eb9d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUeR3Qmj8UEvOKUAQsfi6g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/UAOJ9MlbnL8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="de5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我设法在我们的项目中设置了对<strong class="lb iu">木偶师</strong>和<strong class="lb iu">摩卡</strong>的端到端测试，我想谈谈使用这些工具时的一般过程和技术。</p><blockquote class="lv lw lx"><p id="498d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">我所说的端到端(<strong class="lb iu"> e2e </strong>在本文的其余部分)测试指的是自动脚本，它会检查你的应用程序，检查界面元素、网络请求和应用系统的其他部分的工作。它可以是复杂的场景，如登录和创建比萨饼订单，但也可以是更简单的应用程序栏导航或使用过滤工具的情况。</p></blockquote><p id="6295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">木偶师</a>是一个非常受欢迎的库，<a class="ae ky" href="https://jestjs.io/docs/en/puppeteer" rel="noopener ugc nofollow" target="_blank">它与Jest </a>的结合使用在例子中最常见。然而，在某种程度上，我们面临着不太方便的Jest方面:由于超时和复杂的依赖关系管理，当更新一个库时，异步测试失败。Jest的普遍性和它为我们做出的决定有时也会成为一个障碍，至于e2e测试，我们希望对它们的执行有更细粒度的控制。(我承认，大约六个月前我曾为此尝试过Jest，可能从那以后安装和调试变得容易多了。)</p><blockquote class="lv lw lx"><p id="62d9" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">注意:我的例子反映了一个相当具体的设置，但是我希望对这个使用Puppeteer的特殊案例的描述将有助于您的工作和实验。这篇文章并不想成为编写e2e测试的通用方法的概括或例子。</p></blockquote><p id="aa90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在Github上的沙盒项目中创建了<a class="ae ky" href="https://github.com/ainalain/sandbox/tree/puppeteer-and-mocha-boilerplate" rel="noopener ugc nofollow" target="_blank">分支，以共享带有基本示例的测试设置的样板代码。请注意，这里既没有业务逻辑，也没有真正的组件，它只是用作一个方法演示。然而，我认为<code class="fe mc md me mf b">main.puppeteer.ts</code>文件的基本框架可能对那些正在与类似问题作斗争的人有所帮助。我非常希望如此。</a></p><h2 id="51a4" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">测试设置和分组</h2><p id="c1ba" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这是我们项目的初始状态，需要e2e测试。这是一个基于Typescript和React的web应用程序，为具有不同权限和角色的用户提供不同级别的访问。除了两个传统的“用户”和“管理员”之外，还有更多角色。根据用户的身份，会呈现特定的界面和完全不同的场景，因此身份验证对于我们的测试脚本正确工作是必要的。</p><p id="1284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们假设，在未来，单一的应用程序可以被分解，潜在地，交付给特定类型用户的每一种最终类型的应用程序都可以成为这样的一部分。如果应用程序的不同部分可以映射到不同的用户类型，那么测试也可以做到这一点。<br/>因此，我想到了这个方案:我们有一个共同的输入点，为所有可用的脚本启动流程(它是<code class="fe mc md me mf b">main.puppeteer.ts</code>)，以及对应于每种类型用户的测试文件夹:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/ffd7b029b9cb5e0200f45ff5e0ba832f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKAs9X8FgK0VjYFKdWcYVA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">测试按用户类型分组</figcaption></figure><p id="4677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们决定为不同的用户类型编写独立的测试套件。在我的例子中，我们在公共的<code class="fe mc md me mf b">E2eTests</code>文件夹中有3个目录:用于<em class="ly">医生</em>、<em class="ly">父母</em>和<em class="ly">管理</em>用户类型。此外，我们将有一个带有认证助手功能和一些测试数据的<code class="fe mc md me mf b">testUtils</code>文件夹。</p><p id="02a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，主要切入点呢？</p><p id="9dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想做一个简短的main函数，为三个用户启动三个浏览器实例，用Mocha运行所有测试，然后成功退出/出错。</p><p id="a719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有尝试很多方法来并行运行几个浏览器实例:在谷歌搜索问题时，你可以找到各种库或代码片段。我尝试的第一个解决方案效果很好，所以目前是<a class="ae ky" href="https://www.npmjs.com/package/generic-pool" rel="noopener ugc nofollow" target="_blank">泛型池</a>库为我们的Chromium实例创建工厂，我使用<a class="ae ky" href="https://github.com/GoogleChrome/puppeteer/issues/1873#issuecomment-446787045" rel="noopener ugc nofollow" target="_blank">这个来自一个木偶问题的答案</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/e9d1e4ecb805fe66c489524057b0789b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUp-nwUiv4N2tEp04dgSFw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建浏览器实例池</figcaption></figure><p id="0387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们需要一个函数来创建一个Mocha实例。我非常喜欢Mocha的这个特性:<a class="ae ky" href="https://github.com/mochajs/mocha/wiki/Using-mocha-programmatically" rel="noopener ugc nofollow" target="_blank">您可以从代码</a>开始运行您的测试，使用一些在npm脚本中不可能或不那么简单的条件选项。因此，在我们的主设置中，我们创建了3个Mocha实例，并给每个实例一个文件夹，其中包含针对具体用户的测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/9ec53d0c437617c5164e2151e99f2ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqoIp3uqBcUuF_2Yig9EvA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建Mocha实例，并给它适当的文件</figcaption></figure><p id="9188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们打算在配置项中使用这些测试，所以我希望在其中一个测试失败时得到失败消息。我决定使用<code class="fe mc md me mf b">Promise.all</code>机制来控制所有的测试套件:<code class="fe mc md me mf b">main</code>函数为3种用户类型创建3个承诺，并等待<code class="fe mc md me mf b">resolve/reject</code>结果；</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/19f02f61b400d3c3bad54893e56aa033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Hqw9n7jsh7yx9LyqewYQA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建成套承诺的主要功能的一部分</figcaption></figure><p id="54e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个创建承诺的功能，它采用准备好的早期浏览器和Mocha实例，并通过用户类型引用结果来运行测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/2d1687f0d880e2cb361425e65dc54977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RA3Xe1MU8FrRn1Gjow7eAg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行测试套件并解决。拒绝承诺</figcaption></figure><p id="eff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">粉笔对着色结果很有用:我们使用Gitlab控制台，在那里更容易阅读彩色日志。</p><p id="9c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，我没有展示测试代码本身的任何例子。这是因为围绕木偶师教程有大量干净有用的测试示例。repo中有<a class="ae ky" href="https://github.com/ainalain/sandbox/tree/puppeteer-and-mocha-boilerplate/src/E2eTests" rel="noopener ugc nofollow" target="_blank">个测试用例</a>的基本例子。与此同时，有一个非常重要的测试对于运行所有的rest suites至关重要:<code class="fe mc md me mf b">authentication.helper.ts</code>。该脚本在应用程序界面中使用标准登录表单，并在身份验证成功时解析承诺。在 <strong class="lb iu">之前的<strong class="lb iu">都是套房的</strong>，所以是套房承诺的一部分:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/5992d7ea70c73d088390907b856e0007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ntHcogFCan9lTT5CpbuPLA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">“登录”助手功能</figcaption></figure><p id="ecb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们的<code class="fe mc md me mf b">main</code>函数看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/a5b6ab395c8251b2a076d56b1362606b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyflQNBu0_ELTtPyVLIwAg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将在配置项脚本中启动的主要功能</figcaption></figure><p id="48e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总有改进的空间，但这一基本配置足以涵盖我们的应用程序与简单的e2e测试。</p><h2 id="a0a9" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">额外收获:为运行e2e测试配置Gitlab CI</h2><p id="b480" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我提到过我们使用<a class="ae ky" href="https://docs.gitlab.com/ee/ci" rel="noopener ugc nofollow" target="_blank"> Gitlab CI </a>，所以我将添加一个为我们的测试配置作业的<code class="fe mc md me mf b">.gitlab-ci.yml</code>示例。这是配置的简化版本，没有缓存和其他阶段，也没有可能在您的CI中运行的作业。</p><p id="9bb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Gitlab runner中运行Chromium时，有一件事是你应该注意的:浏览器需要一堆Chromium依赖项来启动。可以通过在运行测试的机器上安装所有必要的包或Chromium本身来预先准备它们。在我们的示例中，我们在脚本之前安装依赖关系:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/aa416f0082f721faa956f64b59f9c488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScjMJ_nvAMUnFUmPxbLyBw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">的简单版本。gitlab-ci.yml文件</figcaption></figure><p id="6c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们测试结果的日志如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/efbbbcc846d6980904c73fb3d6f789f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_l_hePo_bg6ZzBT3TVwzxA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">终端/Gitlab控制台中的测试结果日志</figcaption></figure><p id="de3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！我意识到这个故事似乎描述了一个特定的情况，这个认证的解决方案可能有点奇怪。然而，目前，这种设置适合我们的项目需求，我认为它可以很好地与您分享。有时你会发现自己在谷歌上搜索一个非常具体的问题，或者在无限的Github问题中挖掘😞。也许这篇文章会帮助你🌷。感谢您的时间和关注。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nt"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="nu nv gp gr nw nx"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">18大TypeScript教程-免费学习TypeScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">gitconnected.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>