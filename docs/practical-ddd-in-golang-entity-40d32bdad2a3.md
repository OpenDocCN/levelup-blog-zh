# 戈朗的实用 DDD:实体

> 原文：<https://levelup.gitconnected.com/practical-ddd-in-golang-entity-40d32bdad2a3>

## 领域驱动设计

## 围棋中关于 DDD 的故事继续呈现了一个最常见的积木——实体。

![](img/c661a0ecec01e59189e2085f9a3b9fe1.png)

乔治·普伦查斯在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 的照片

在[的上一篇文章](/practical-ddd-in-golang-value-object-4fc97bcad70)中，我试图给出一些关于价值对象设计模式的见解，以及我们应该如何在 Go 中使用它。在这一个中，故事继续着一个叫做实体的设计模式。

许多开发人员听说过实体上千次，即使他们从未使用过 DDD 的方法。一些例子在 PHP [框架](https://symfony.com/doc/3.3/doctrine.html#creating-an-entity-class)中，一些在 [Java](https://docs.oracle.com/javaee/6/tutorial/doc/bnbqa.html) 中。虽然看起来一样，但它在 DDD 的目的是不同的。

了解它在 DDD 的目的对我来说是一种突破。这看起来有点奇怪，特别是对于有 PHP MVC 框架背景的人来说，但是今天 DDD 的方法似乎更符合逻辑。

# 它不是 ORM 的一部分。

正如我们在 PHP 和 Java 框架的例子中看到的，实体扮演了许多构建模块的角色，从[行数据网关](https://www.martinfowler.com/eaaCatalog/rowDataGateway.html)到[活动记录](https://www.martinfowler.com/eaaCatalog/activeRecord.html)。由于这个事实，导致了实体模式的误用。

实体的目的不是反映表方案，而是保持基本的业务逻辑。每当我在某个应用程序上工作时，我的实体并不镜像数据库。

说到实现，首先，我总是提供域层。在那里，我想把完整的业务逻辑耦合在一起，用实体、值对象和服务来构造。

一旦我完成了业务逻辑并覆盖了单元测试，我就开始为基础设施层提供技术细节，比如到数据库的连接。

就像你在下面的例子中看到的，我们将实体从它在数据库中的表示中分离出来。镜像数据库模式的对象是独立的，它们更尊重[数据传输对象](https://www.martinfowler.com/eaaCatalog/dataTransferObject.html)。

实体与数据库分离的示例

上面的例子是我们可以提供的许多变化之一。尽管实体和 DTO 的结构可以不同，这取决于我们想要的商业案例(比如每个`BankAccount`有更多的`Wallets`),但想法总是相同的。

我们总是在领域层保留[存储库](https://www.martinfowler.com/eaaCatalog/repository.html)接口。在这一层(我使用的分层架构中的底层)，一些域服务可能依赖于它们。所以，他们至少应该意识到自己的存在。

存储库提供了一个契约，保证我们将从我们的领域层处理实体对象，至少在外部。在 Repository 中，我们可以处理任何我们想要的东西，只要我们提供准确的结果。

有了这种结构，我总是设法将我的业务逻辑从下面的存储中分离出来。只要我需要对数据库进行一些更改，就必须更改映射方法，该方法将 d to 转换为实体，反之亦然。

实体的一些例子

有时候，实体会反映复杂的业务逻辑，数据来自多个地方，比如数据库、和一些外部 API。特别是在那些情况下，将业务层从技术细节中分离出来的想法是非常值得的。

# 身份

与值对象的主要区别是身份。实体有身份。身份是实体的唯一属性，可以定义每个实体的唯一性。

两个实体在其一个或多个领域中可能只有一个微小的差异。如果他们有相同的身份，那么我们谈论的是同一个实体。为此，当我们检查它们的相等性时，我们只检查它们的身份。

有三种身份。它们可以是应用程序生成的。这意味着，在将它们发送到存储设备进行创建之前，我们会为它们创建一个新的身份。在这种情况下，我使用[uuid](https://duo.com/labs/tech-notes/breaking-down-uuids)。

第二种可能是使用自然身份。每当我们想与现实世界中具有某种独特属性的人或物打交道时，我们都可以操纵他们的生物标识符。例如，这可以是社会安全号码。

第三，最常见的方式是数据库生成的身份。即使当我处于实施前两种解决方案的位置时，我也采用这种方法。

不同类型的身份

对于索引和查询，我喜欢只用数字。在许多情况下，当处理应用程序生成的键或自然键时，我们应该处理文本或找到某种方法将这些文本正确地映射到数据库中的数值。

由于同一性是实体和价值对象之间的主要区别，你可能会猜测这条分界线我们可以很容易地抹去。事实上，根据[有界上下文](https://martinfowler.com/bliki/BoundedContext.html)，一个对象可以很容易地从实体切换到值对象。

相同的目标但有两个目的

就像上面的例子一样，`Currency`可以在一个有界的上下文中扮演中心实体的角色。那可以是一个`Transaction Service`或者`Exchange Service`。但是，在我们需要在 UI 中格式化的地方，`Currency`可以作为一个简单的值对象使用。

# 确认

与值对象相反，实体可以在其生命周期内改变其状态。这意味着每当我们想要改变一个实体时，它需要不断的验证检查。

简单验证示例

是的，我知道。在上面的例子中，我们可以直接访问`Wallet`，并通过避免方法`Add`来改变它。我不太喜欢围棋里的[getter 和 setter](https://www.freecodecamp.org/news/java-getters-and-setters/)。我发现让许多函数返回或设置值是不可维护的。

在这些情况下，我更依赖所有工程师的理智来认识到如果方法已经存在，他们应该如何改变实体的状态。

不过，这是我留给每个开发人员自己决定的话题。使用带有私有字段的 getters 和 setters 也是成功的解决方案。

# 推动行为

DDD 的全部目的是尽可能地反映业务流程。正因为如此，当我们看到许多方法是我们领域层的一部分时，我们不会感到惊讶。

这些方法可以属于不同的对象。由于实体将最复杂的状态保留在所有其他代码块之外，因此它们也可能拥有最多的函数来表示其丰富的行为。

在某些情况下，我们可能会注意到实体中的几个字段经常相互作用。每当我们在一个业务不变量中使用其中一个时，我们可能也需要另一个。

在这些情况下，我们总是可以将这样的字段组合成一个单独的值对象，并将其交给实体来处理。我们需要小心地这样做，以避免实体和值对象之间的关注点分离不清楚的情况。

逻辑分离不清晰

在上面的例子中，我们可以检查从`Wallet`值对象中承担更多责任的`BankAccount`实体。当我们问`BankAccount`是否被锁定时，这部分是清楚的。但是，检查`Currency`是否相等以及`Wallet`中是否有足够的数量是一种代码气味。

在这些情况下，我将完整的演绎逻辑转移到值对象，当然，除了检查`BankAccount`是否被锁定。就像这样，Wallet 得到它的那部分代码来验证和扣除金额。

实体与价值对象之间逻辑的适当分离

像这样，`Wallet`值对象可以属于任何其他实体或值对象，它仍然可以支持演绎，这取决于它的内部状态。另一方面，`BankAccount`可以为锁定帐户提供额外的金额扣除方法，而无需复制相同的逻辑。

一个实体可以将其行为推送到其他构建模块，如[域服务](http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/)(将在下一篇文章中介绍)。我在两种情况下将这些方法转移到服务中。

第一种情况是当行为过于复杂时。它可能需要使用[规范](https://en.wikipedia.org/wiki/Specification_pattern)、[策略](https://www.codeproject.com/Tips/1175911/Domain-Policy-for-Domain-Driven-Design)或其他实体和值对象。它可能依赖于来自存储库或其他服务的结果。

第二种情况是不太复杂的行为，但是仍然不清楚逻辑属于哪里。它可能属于一个实体，也可能属于另一个实体，或者某个值对象。

对单个实体来说责任太大

在上面的例子中，`Currency`实体拥有方法`Exchange`。此方法已经接受了太多的参数。问题是这个方法在这里是属于`Wallet`值对象还是`ExchangeRate`实体。

更不用说，由于政治纠纷或经济原因，可能会暂时禁止兑换特定货币。这样，我们将为`Currency`实体带来更多的业务不变量。

引入可以处理复杂逻辑的领域服务

当业务逻辑太大时，我总是将它转移到一个单独的域服务中，就像上面例子中的`ExchangeRatesService`。使用这种方法，我总是能够通过提供新的域策略来调整我的域层。

有时候将行为推给其他构建模块看起来是一件很自然的事情。然而，我们应该非常小心地处理它。将太多的行为从实体转移到域服务会导致另一种代码味道，即[贫血的域模型](https://martinfowler.com/bliki/AnemicDomainModel.html)。

贫血域模型

上面的例子显示了`TransactionService`域服务。该服务从`BankAccount`实体那里接管责任。如果我们不需要检查复杂的业务不变量，这种行为就不属于领域服务。

为特定行为找到合适的位置更像是一项练习，在乞求时可能看起来很复杂，但随着时间的推移，它会变得更加直观。即使在今天，我有时仍然很难找到合适的地方。但是，更多的时候，我可以按照它应该的样子构造代码。

# 结论

尽管我们在许多框架中使用它们，但它们的用法并不总是正确的。它们应该代表我们的状态和行为，而不是镜像数据库模式。

实体给了我们额外的机会来描述现实世界中的有状态对象。在许多情况下，它们是我们应用程序的主要目的，或者至少我们的业务逻辑没有它们就无法工作。

# 有用的资源:

*   [https://martinfowler.com/](https://martinfowler.com/)
*   [https://www.domainlanguage.com/](https://www.domainlanguage.com/)