<html>
<head>
<title>The Serverless Framework — Streamlined</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器框架—简化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-serverless-framework-streamlined-1bfebe3c67a9?source=collection_archive---------11-----------------------#2022-04-12">https://levelup.gitconnected.com/the-serverless-framework-streamlined-1bfebe3c67a9?source=collection_archive---------11-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e02c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我是如何为部署在AWS上的Typescript应用程序消除了这些年来我在无服务器框架方面遇到的棘手问题的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/8a60adae519ae3708cc01755971c67a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uF59OFg270TaJiz7AmKe6Q.png"/></div></div></figure><p id="1458" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器框架是构建无服务器应用程序的绝佳工具。它抽象了很多复杂性，让我可以将更多的时间放在应用程序的业务逻辑上，这通常是编写lambda函数。但是正如我在<a class="ae kx" rel="noopener ugc nofollow" target="_blank" href="/my-journey-with-pulumi-and-the-serverless-framework-2b1398ee581a">之前的一篇文章</a>中提到的，我发现它有一些不太理想的地方。</p><p id="8ac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将向您介绍我是如何构建我的最新应用程序的，以便提高我的基础设施代码的质量。更具体地说，我将讨论如何</p><ul class=""><li id="b0b8" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">创建可重用的基础结构块，以减少需要编写的代码量，并提高应用程序的可维护性</li><li id="be07" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">隐藏讨厌的云形成函数(如<code class="fe lm ln lo lp b">Ref</code>、<code class="fe lm ln lo lp b">Fn::GetAtt</code>等)以提高可读性</li><li id="9717" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">将您的资源组织成逻辑代码块</li></ul><p id="4392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文中找到的所有代码都来自于<a class="ae kx" href="https://github.com/louislatreille/serverlessStreamlined" rel="noopener ugc nofollow" target="_blank">资源库</a>，可以有效地用作模板，帮助kickstart任何用Typescript编写的无服务器应用程序，并部署到AWS。</p><h1 id="9c5f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">基线设置</h1><p id="2d25" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">要开始使用无服务器框架，您应该做的第一件事就是使用Typescript进行配置。我以前说过，并将继续说下去。不知何故，它在YAML并没有太多的宣传，但是这在我使用这个框架的过程中带来了巨大的改进。这将为您提供一个更好的环境来编写IaC，也将作为本文中我将向您展示的所有其他内容的基线。您甚至可以在编写IaC时，直接在配置中使用类型来帮助捕捉一些错误。在这里看看所有可用的类型<a class="ae kx" href="https://github.com/serverless/typescript/blob/master/index.d.ts" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2986" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我强烈推荐使用<a class="ae kx" href="https://github.com/AnomalyInnovations/serverless-bundle" rel="noopener ugc nofollow" target="_blank">无服务器捆绑插件</a>。安装非常简单，这将消除<em class="mv">大量</em>来自正确打包Typescript Lambda函数的认知负荷。不再需要考虑配置Webpack、Babel、ESLint等。插件会给你一些合理的缺省值，你会得到很小的，非常快的函数，只包含他们需要的东西(比如正确的树摇动)。</p><p id="028c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我还建议您使用<a class="ae kx" href="https://middy.js.org/" rel="noopener ugc nofollow" target="_blank"> MiddyJS </a>(我不会详细介绍它是如何工作的；你可以在他们的网站上阅读。这个模块提供了一系列中间件来增强Lambda函数的功能，比如为CORS提供适当的头，验证HTTP端点的输入和输出模式，自动反序列化JSON和其他内容类型，适当的HTTP错误等等。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="126b" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">可重复使用的基础设施</h1><p id="1450" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">你会发现自己在应用程序中反复添加的主要内容可能是Lambda函数，所以我们在这里将重点讨论它。但是，这个原则可以应用于任何其他要复制的资源块或配置，比如IAM角色、SQS队列等。使用这种模式，您将能够拥有如下所示的<em class="mv">功能</em>部分:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="977f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，此时我们只获得了我们需要的信息。函数名及其依赖项。</p><p id="f6ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">深入研究<em class="mv"> postMessage </em>函数，我们会发现:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bf4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">特定于<em class="mv"> postMessage </em>功能的更多信息，例如端点路径、策略和环境变量。</p><p id="21a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，泛型<em class="mv"> createFunctionHandler </em>包含所有Lambda函数共有的所有配置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7d49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之，3个抽象层次，每个层次都有你需要的细节。<em class="mv"> createFunctionHandler </em>函数是唯一需要修改的代码，它会影响所有的Lambda函数。如果您需要关于<em class="mv"> postMessage </em> Lambda函数的具体细节，您可以在它自己的文件中找到它。然后，您可以清楚地看到您的<em class="mv"> serverless.ts </em>中概述的Lambda函数的依赖关系。</p><h1 id="f7a7" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">隐藏讨厌的云形成功能</h1><p id="6981" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">由于无服务器框架支持CloudFormation模板，如果您想在框架为您处理的资源之外创建资源，这通常是一个好方法。</p><p id="b1f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CloudFormation支持非常好，因为您可以使用AWS为每个服务的API提供的所有文档，并轻松地向您的应用程序添加新资源。但是如果你需要资源之间的链接，你需要使用像<code class="fe lm ln lo lp b">Ref</code>和<code class="fe lm ln lo lp b">Fn::GetAtt</code>这样的云形成函数。我总是发现云形成函数很大，不透明，是代码块，这使得很难理解发生了什么。</p><p id="c1e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么我喜欢把它们藏起来，靠近它们所属的资源。正如你在上面看到的，我的Lambda函数的依赖项是很好的、命名良好的变量。如果我必须使用CF函数，它看起来会像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="132e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来可读性差得多。在我的<em class="mv"> serverless.ts </em>中，我希望能够快速看到我的不同资源之间的依赖关系，而CF函数让这变得更加困难。</p><p id="047b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不过，在它们所属的资源附近，它们确实更有意义。这就是为什么我把它们放在定义资源的函数中。这是创建我的DynamoDB表的函数的样子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3e7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的DynamoDB表函数的内部，我可以看到arn是使用一个<code class="fe lm ln lo lp b">Fn::GetAtt</code>函数检索的，但是外界不需要关心这些。他们只是在调用函数后使用<code class="fe lm ln lo lp b">arn</code>变量。</p><p id="5b3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想知道<em class="mv"> varToString </em>函数是什么，它只是将我的变量名输出为一个字符串(即上面代码中的<code class="fe lm ln lo lp b">“mainTable”</code>)。好奇的话看这里<a class="ae kx" href="https://github.com/louislatreille/serverlessStreamlined/blob/92f7d59d697c0a9404ea6e2e1e929fa9154ecd39/resources/utilities.ts#L3" rel="noopener ugc nofollow" target="_blank">的代码</a>。因为我需要在CF函数中使用变量名，所以这个函数通过重命名我的变量但忘记改变CF函数中的字符串来消除引入错误的可能性。通过使用<em class="mv"> varToString </em>，编译器会通知我这个错误。</p><h1 id="88be" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">将您的资源组织成逻辑代码块</h1><p id="9bb0" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">我将向您展示的最后一个模式将允许您的<em class="mv"> serverless.ts </em>在应用程序变大时保持可读。通常，随着时间的推移，你的配置中的<em class="mv">资源</em>部分会变得很大，以至于你不得不滚动浏览它。这种情况经常发生，因为当您需要添加一个东西时，比如说为您的应用程序添加一个Cognito用户池，您不是创建一个，而是创建大量的AWS资源。</p><p id="9c8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再说一次，我喜欢保持我的<em class="mv"> serverless.ts </em>干净，并把它放在我可以很容易看到我的资源之间的链接的地方。然后，我将把我的资源块的内部隐藏到单独的函数中。</p><p id="9919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是创建我的Cognito用户池的函数的样子(在这里查看完整的<a class="ae kx" href="https://github.com/louislatreille/serverlessStreamlined/blob/main/resources/cognitoUserPool.ts" rel="noopener ugc nofollow" target="_blank"/>):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="45cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有需要的资源都在那里定义，每当我需要了解用户池的细节时，我都可以在那里找到它们。需要注意的一点是，我返回一个包含所有要创建的资源的<em class="mv"> resources </em>对象。这样，我就可以在我的<em class="mv"> serverless.ts. </em>中使用JavaScript良好的对象析构特性</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2822" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">啊，看起来真不错！一行代码表明我在该应用程序中有一个Cognito用户池。不需要滚动数百行云信息资源定义，也不需要试图弄清楚每个单独的资源属于什么！</p><h1 id="2b78" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="01ae" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">你有它！部署在AWS上的Typescript无服务器函数的模板！请随意浏览Github库,因为那里有一些其他更小的东西，让我的编程生活变得更容易。</p><p id="ff13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有任何问题，请提出来！如果你有自己的一套实践来帮助你在无服务器框架下保持高效，请在评论中分享它们！我一直在寻找改进的方法！</p><p id="768c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码快乐！</p></div></div>    
</body>
</html>