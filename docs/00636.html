<html>
<head>
<title>Set up a Nginx Load balancer for a dockerized Node.js Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为dockerized Node.js应用程序设置一个Nginx负载平衡器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/set-up-a-nginx-load-balancer-for-a-dockerized-node-js-application-6bff1a54655a?source=collection_archive---------1-----------------------#2019-06-14">https://levelup.gitconnected.com/set-up-a-nginx-load-balancer-for-a-dockerized-node-js-application-6bff1a54655a?source=collection_archive---------1-----------------------#2019-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e451" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在这里，那么您可能知道在您的应用程序中使用docker的优势。总结一下，docker容器加快了您的部署，使您的应用程序可移植到任何平台，映像是轻量级的，简化了维护，并且高度可伸缩。</p><p id="62e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">负载平衡器的工作是在一组后端服务器(称为服务器池)之间高效地分配传入流量。负载平衡器充当后端服务器前面的“交通警察”，在所有能够处理这些请求的服务器之间路由客户端请求，以最大化速度并确保没有服务器超负荷工作，从而降低性能。</p><p id="e68c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">必备:<br/> </strong> Docker基础知识</p><p id="8849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">概述:<br/> </strong>在这篇博客中，我们将看到如何对一个简单的Node.js应用程序进行docker化，并在Ubuntu服务器的不同端口上部署该应用程序的两个docker容器，然后配置Nginx作为两个docker容器前面的负载平衡器来运行，以提高性能和响应能力。这只是一个演示，涵盖了一般概念，并且该示例可以跨多个服务器(“节点”)扩展到数百个容器</p><p id="1fed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大概是这样的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/47bbca5491d5bbce69ac6bdec08c7793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*diDDMGTnbnfVn1uqnqWf4w.png"/></div></figure><p id="cee6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将总共设置3个容器，2个用于Node.js，1个用于Nginx。Node.js容器将在主机端口5001和5002上运行，这两个端口将分别映射到容器端口5000。</p><p id="7325" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kt">好了，我们开始吧</em> </strong></p></div><div class="ab cl ku kv hu kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ij ik il im in"><p id="044d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们的app.js的样子。它用一个简单的Hello“Name”作为响应，这个名称可以作为环境变量传递给它，同时从图像创建容器，以便我们可以区分两个容器，并确保我们的负载平衡器正常工作。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="1575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不熟悉docker，我强烈建议你查看一下这个，了解一下docker是如何工作的。<br/>让我们创建一个docker文件来为这个应用程序构建一个图像，这将非常简单，如下所示</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d3bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要转到保存app.js和docker文件的目录，打开shell，然后运行“docker build-t custom imagename:tag”从docker文件构建图像。</p><p id="932f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行:<code class="fe le lf lg lh b">docker build -t nodeapp:001 .</code></p><p id="568e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦建立了映像，您就可以使用<code class="fe le lf lg lh b">docker images</code>命令来查看它</p><p id="14a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后使用-publish(-p)选项在不同的主机端口上启动来自映像的容器，并使用-e选项传递环境变量“name ”,以区分两个容器。</p><ul class=""><li id="5155" class="li lj iq jp b jq jr ju jv jy lk kc ll kg lm kk ln lo lp lq bi translated"><code class="fe le lf lg lh b">docker container run -p 5001:5000 --name helloworld -d nodeapp:001</code></li><li id="621c" class="li lj iq jp b jq lr ju ls jy lt kc lu kg lv kk ln lo lp lq bi translated"><code class="fe le lf lg lh b">docker container run -p 5002:5000 --name customized -e "name=aagam" -d nodeapp:001</code></li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/54235d57682548a645a77cc43ecea3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImVChveeldf_Kz4nkczIUQ.jpeg"/></div></div></figure><p id="d58c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查您的<a class="ae ld" href="http://ip:port" rel="noopener ugc nofollow" target="_blank"> http://ip:port </a>的浏览器，并验证容器是否已成功部署。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mb"><img src="../Images/a1826ed6daca0106ba6d78a6cf75868a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*te515exkd3bzZpPhsloWng.png"/></div></div></figure><p id="c149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们可以看到一个容器在主机端口5001上运行，另一个在主机端口5002上运行。好像不错！</p></div><div class="ab cl ku kv hu kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ij ik il im in"><p id="bbee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经成功部署了两个Node.js容器，现在我们需要在它前面添加一个Nginx负载平衡器。要设置一个nginx容器，我们需要编写一个Nginx配置文件和一个单独的Dockerfile，所以移到一个新的文件夹，创建两个名为nginx.conf和Dockerfile的文件，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a8da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们刚刚输入了什么？我们使用upstream在nginx.conf中设置了一个代理，并添加了两个需要进行负载平衡的服务器地址，我们将负载平衡算法设置为least_connection，而不是默认的循环调度。<br/>要了解更多关于nginx负载均衡的信息，你可以参考<a class="ae ld" href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/" rel="noopener ugc nofollow" target="_blank">这篇</a></p><p id="3687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置好这些文件后，我们可以使用<br/> <code class="fe le lf lg lh b">docker build -t nginxbalancer:001 .</code>来构建一个图像</p><p id="61ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在任何主机端口上启动容器，我们将使用端口5000</p><p id="773c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe le lf lg lh b">docker container run -p 5000:80 -d nginxbalancer:001</code></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/1884bb4eb2a8447ec037b24503d63cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*sTCJ4hh-dwGkGeJTxTljZQ.png"/></div></figure><p id="57ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果事情对你来说是正确的，就像我希望的那样😆，您应该在浏览器上访问您的IP:5000并点击refresh multiple来查看同一个地址上的两个输出，这意味着nginx正在将我们的http请求重定向到两个容器并平衡整体负载。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi md"><img src="../Images/b6fd793b4a4af85adbeff9a76cb84c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHX-6uyYx9h8o3n19jrOWA.png"/></div></div></figure><p id="8d82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干得好！<br/>我们刚刚使用2个容器为dockerized节点应用程序设置了一个Nginx负载平衡器，如前所述，这个概念可以根据需要进行扩展。</p><p id="7f61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kt">感谢阅读！如果你喜欢你所读的，那么留下一个👏然后跟着走。</em>T12】</strong></p></div></div>    
</body>
</html>