<html>
<head>
<title>Connecting a service in Golang to a RabbitMQ server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Golang中的服务连接到RabbitMQ服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/connecting-a-service-in-golang-to-a-rabbitmq-server-835294d8c914?source=collection_archive---------6-----------------------#2022-05-24">https://levelup.gitconnected.com/connecting-a-service-in-golang-to-a-rabbitmq-server-835294d8c914?source=collection_archive---------6-----------------------#2022-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/165887a28b6efd0a011d3383176a712a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*flrn2Vtx4SDgEI1_8va3nQ.png"/></div></figure><p id="6331" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上一篇文章中，我们在Go 中构建了一个服务，这样它就可以启动和完成内部流程。现在我们有了一个工作的服务，让我们创建一个RabbitMQ客户端来处理其中的所有RabbitMQ进程。我们将使用<a class="ae ks" href="https://github.com/rabbitmq/amqp091-go" rel="noopener ugc nofollow" target="_blank"> rabbitmq/amqp091-go </a>库来连接、消费和发布消息。跟我一起踏上这段旅程吧！</p><p id="8554" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，熟悉一些基本的RabbitMQ概念很重要，比如队列、交换、通道等等。如果您对此一无所知，我建议您在继续之前阅读此<a class="ae ks" href="https://www.rabbitmq.com/getstarted.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="8f38" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在哪里设置RabbitMQ客户端？</h1><p id="70b4" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">我通常说Go是面向包的，所以组织服务的一个好方法是将特性和职责分割成包，这样我们就可以将所有RabbitMQ相关的代码放在一个包中，并且有一个明确的名字，比如<code class="fe md me mf mg b">queuerabbit</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/f3c0c05209bb42b0e4ed69e6ecb81e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*a3oV3qcHEOIduQjc2Jd5aQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">包装结构示例</figcaption></figure><p id="b215" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设有一个错误导致消息从未到达您的服务。如果你有上面的结构，你会从哪里开始寻找bug？当然是通过包<code class="fe md me mf mg b">queuerabbit</code>，它结合了<code class="fe md me mf mg b">queue</code>和<code class="fe md me mf mg b">rabbit </code>两个词，引用了RabbitMQ。</p><blockquote class="mq mr ms"><p id="f874" class="ju jv mt jw b jx jy jz ka kb kc kd ke mu kg kh ki mv kk kl km mw ko kp kq kr ij bi translated">确定这个包的职责非常简单，因为它建立并保持与RabbitMQ的连接，还处理消息。</p></blockquote></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="819c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">连接到RabbitMQ</h1><p id="5cc4" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">首先要做的是建立联系。快速浏览文档，您会发现函数<code class="fe md me mf mg b">conn, err = amqp.Dial(uri)</code>。所以你创建了通道，它准备好了，你的连接就完成了，对吗？对吗？</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/393144be0ebe26052f5fcc74cfb2ec66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmMJKJZdTRIPHo0ZsfLXVA.jpeg"/></div></div></figure><p id="8e96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果网络有问题，连接关闭了会怎么样？为最坏的情况做准备是一个好习惯。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c42b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">函数<code class="fe md me mf mg b">Start(ctx context.Context)</code>创建一个goroutine，它将总是尝试连接到服务器，如果它由于任何原因断开连接，当问题解决时，服务将在没有人工干预的情况下恢复在线。</p><blockquote class="mq mr ms"><p id="abb9" class="ju jv mt jw b jx jy jz ka kb kc kd ke mu kg kh ki mv kk kl km mw ko kp kq kr ij bi translated">传递给<code class="fe md me mf mg b">Start</code>的上下文必须有CancelFunc，这一点很重要，这样，当服务关闭时，上下文可以被取消，负责保持连接的goroutine可以停止运行。</p></blockquote><p id="a3c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建服务时的一个主要关注点是资源的使用。我们没有无限的CPU和内存，所以参数<code class="fe md me mf mg b">prefetchCount</code>非常重要，它告诉我们从队列中读取了多少条消息。如果该值为0，则有可能一次从队列中读取所有消息，这可能会突破服务内存限制。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="2748" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">消费邮件</h1><p id="2b70" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">rabbitmq/amqp091-go库的结构非常好。当您调用函数<code class="fe md me mf mg b">channel.Consume()</code>时，它会返回一个通道，消息将通过这个通道到达，这对于goroutine无限期地读取消息来说是完美的。</p><p id="77ee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">面临的挑战是在避免数据丢失的同时，使消息读取与服务关闭同步。这个难题的一个关键部分是函数<code class="fe md me mf mg b">channel.Cancel</code>，它停止接收新消息。它允许在关闭与服务器的连接之前处理最后收到的消息。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fb76" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于每个消费者和每条消息，我们从<code class="fe md me mf mg b">sync.WaitGroup</code>调用函数<code class="fe md me mf mg b">wg.Add(1)</code>和<code class="fe md me mf mg b">wg.Done()</code>，这允许我们在服务关闭时关闭连接之前调用<code class="fe md me mf mg b">wg.Wait()</code>，因此我们可以成功地读取和处理来自所有活动消费者的所有消息。</p><p id="4972" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">消费消息的goroutine也通过停止读取新消息并允许处理最后的消息来对取消的上下文信号做出反应。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="89b5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">发布消息</h1><p id="c7ef" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">发布很简单。让我们使用与消费者相同的<code class="fe md me mf mg b">sync.WaitGroup</code>，这样当服务停止时，它将等待消息被发送。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3112" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">唯一可能发生的问题是循环引用。换句话说，从队列包中，您可以调用另一个包中的函数，反过来，从队列包内部调用发布函数。为了避免这个问题，您可以创建一个发布者接口和一个实现该接口的结构。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="fe34" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">关闭连接</h1><p id="98fa" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">现在服务正在运行并处理消息，是时候终止它了。我们从调用在服务初始化时创建的函数<code class="fe md me mf mg b">cancel()</code>开始，因此保持连接打开的goroutine可以结束，所有正在使用消息的go routine停止处理新消息，处理剩余的消息，并顺利完成。完成所有工作后，我们可以关闭通道并关闭与服务器的连接。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c8a1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe md me mf mg b">Close(ctx context.Context)</code>中创建的第一个goroutine的目的是等待所有的消息被相应地处理。第二个等待来自第一个或上下文超时的信号，然后关闭通道和连接。该函数返回一个通道来通知一切都已完成。这样，主线程可以完成其他进程，并等待一切都成功完成的信号。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="bfa3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">简化服务的结构</h1><p id="a482" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">即使有了所有这些解释和代码，仍然很难将所有内容整合到一个包中。这就是为什么我创建了一个连接、消费、发布和关闭连接的库，使得创建新包变得非常简单。<a class="ae ks" href="https://github.com/gbeletti/rabbitmq" rel="noopener ugc nofollow" target="_blank">点击这里</a>，github上什么都能找到。</p><p id="88d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我还使用这个库创建了一个示例服务，<a class="ae ks" href="https://github.com/gbeletti/service-golang" rel="noopener ugc nofollow" target="_blank">它也在github </a>上。</p><h1 id="a6c6" class="la lb iq bd lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx bi translated">结论</h1><p id="2853" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">RabbitMQ是一个非常强大的工具，用于微服务之间的异步通信，构建一个与之交互的包是非常具有挑战性的。重要的是要记住，你必须知道如何完成你开始的每一件事，以避免丢失信息。这给系统带来了一致性和健壮性。</p><p id="d3b2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">希望这篇教程有用。在下面的部分留下评论。</p></div></div>    
</body>
</html>