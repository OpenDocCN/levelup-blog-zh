<html>
<head>
<title>Understanding the Object_id Method in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Ruby中的Object_id方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-the-object-id-method-in-ruby-f61bb3888113?source=collection_archive---------6-----------------------#2021-02-11">https://levelup.gitconnected.com/understanding-the-object-id-method-in-ruby-f61bb3888113?source=collection_archive---------6-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0e99b1511d074be42b009c8cd1614d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bwUk4TpuQfCsEA_eUXyWw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/@mali?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马里·梅德尔</a>从<a class="ae kf" href="https://www.pexels.com/photo/short-fur-white-and-black-cat-225406/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</figcaption></figure><p id="fe1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Ruby和许多编程语言一样可以创建对象，我们可以用这些对象来存储属性、方法并对它们执行操作。在Ruby中，一切都是对象、字符串、整数、布尔、散列、数组和类的实例。</p><p id="942d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个对象都有一堆我们可以使用的公共方法。在本文中，我们将主要关注一种方法— <strong class="ki iu"> <em class="le">对象Id。</em> </strong></p><p id="cecf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每个对象，Ruby都提供了一个名为<strong class="ki iu"> <em class="le"> object_id的方法。</em> </strong>你猜对了，这代表了特定对象的一个随机id。这个值是对象存储在内存中的地址的参考。</p><p id="9532" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个对象都有一个唯一的对象id，该id在对象的整个生命周期中不会改变。</p><p id="5843" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一些Ruby中数据类型的例子:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="5129" class="lo lp it lk b gy lq lr l ls lt">name = "Paul"<br/>name2 = "Paul"<br/>name.object_id == name2.object_id # false<br/>name2 = name<br/>name.object_id == name2.object_id # true</span></pre><p id="1aac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们声明了两个string类型的变量，并赋予了相同的值。然后我们比较每个变量的<strong class="ki iu"> <em class="le"> object_id </em> </strong>看它们是否相同，我们得到false。</p><p id="6cef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样做的原因是因为每个变量在声明的时候都在内存中获得不同的位置来存储它们的值，所以即使我们分配了相同的字符串，它们在内存中也不共享相同的地址位置，因此它们的对象id是不同的。</p><p id="b31e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，当我们将<strong class="ki iu"> <em class="le"> name </em> </strong>的值赋给变量<strong class="ki iu"> <em class="le"> name2 </em> </strong>并再次比较它们的id时，会发生什么呢？</p><p id="22ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这次发生的情况是，变量<strong class="ki iu"> <em class="le"> name </em> </strong>与变量<strong class="ki iu"> <em class="le"> name2 </em> </strong>在内存中共享同一个地址。因此，当我们重新分配变量<strong class="ki iu"> <em class="le"> name2 </em> </strong>时，我们并没有在内存中创建新的地址，而是共享了<strong class="ki iu"> <em class="le"> name </em> </strong>拥有的相同地址。</p><p id="bbbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为这个原因，我们在第二个比较中得到真实。</p><p id="1f46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我提到的，ruby中的所有对象都有一个<em class="le"> object_id </em>。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8fb8" class="lo lp it lk b gy lq lr l ls lt">num = 23<br/>num.object_id # 47<br/>users = {"carl": [1,2,3], "paul": [3,4,5]}<br/>users.object_id # 70342844770580<br/>numbers = (0..10).to_a<br/>numbers.object_id  # 70342856985540<br/>person = Person.new("person1")<br/>person.object_id  # 70342819709960</span></pre><p id="3dde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你试验并声明布尔、整数或nil变量，你会注意到它们在over上得到相同的<strong class="ki iu"> <em class="le"> object_id </em> </strong>。你可以在这里阅读更多关于为什么会发生这种情况<a class="ae kf" href="https://stackoverflow.com/questions/3430280/how-does-object-id-assignment-work" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="21fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想你明白了，这个方法只是给你的对象一个id。但是我们如何使用它，让它更有用呢？。坚持住！！我们会找到答案的。</p><p id="f2ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看下面的例子。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="1ffa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们有一个用户类，它在initialize函数中接受名称和颜色数组。</p><p id="6e05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在这种情况下，让我们说颜色数组将只在类的范围内可用，不公开，所以我们可以使用一个类变量来存储颜色。</p><p id="6aa7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们初始化一个类变量等于一个空散列。然后在初始化函数中，我们使用<strong class="ki iu"> <em class="le"> object_id </em> </strong>作为关键字，并将颜色数组存储为符号。</p><p id="5be6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于类变量将保存一个对所有用这个类创建的实例的引用，我们可以确保我们在类中使用<strong class="ki iu"> <em class="le"> object_id </em> </strong>存储的数据不会被GC(垃圾收集)。</p><p id="b657" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后color_mapping方法只取我们设置给hash中的<strong class="ki iu"> <em class="le"> object_id </em> </strong>键的值，并给每种颜色分配一个随机数。</p><h1 id="39b9" class="lw lp it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论</h1><p id="b02b" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">这基本上就是Ruby中的<strong class="ki iu"> <em class="le"> object_id </em> </strong>方法，一个对象的随机标识符。如果你对如何使用这种方法有更多的建议，请在下面留下评论。</p><p id="a006" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！</p><p id="caaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能会觉得这很有趣。</p><div class="my mz gp gr na nb"><a rel="noopener  ugc nofollow" target="_blank" href="/postgresql-views-with-ruby-on-rails-78260cd6f021"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">使用Ruby on Rails的PostgreSQL视图</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">利用视图的力量封装复杂的查询。</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jz nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://medium.com/swlh/what-are-solid-principles-in-software-development-world-a5ec98637c01" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">在软件开发世界中，什么是坚实的原则？</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">用Ruby编程语言实现</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np jz nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://medium.com/swlh/deploy-rails-app-to-digital-ocean-f1aeb0991470" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">将Rails应用程序部署到数字海洋</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">铁路，数字海洋，市场</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nr l nm nn no nk np jz nb"/></div></div></a></div></div></div>    
</body>
</html>