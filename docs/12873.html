<html>
<head>
<title>Docker for frontend developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向前端开发人员的Docker</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-for-frontend-developers-4eeaedf10dc7?source=collection_archive---------3-----------------------#2022-07-18">https://levelup.gitconnected.com/docker-for-frontend-developers-4eeaedf10dc7?source=collection_archive---------3-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/807a9ed7546ad96ecff70663dc4ddb51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KT_6lvXaOKLfjfR7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Philippe Oursel 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6bae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个新的开发人员进来时，他面临着启动开发环境的任务。直到最近，它经常变得像用手鼓跳舞。安装10个不同版本的包，结果你自己的宠物项目需要不同的版本，甚至可能是同一作品中的另一个项目。每次专家都以他自己的方式摆脱了这种情况，但是除了在这种配置上花费的时间之外，主要的问题仍然是不能保证从开发人员到开发人员或运行人员的性能。</p><p id="3ddb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是——这个问题在现代世界的发展中得到了解决，即使没有完全解决，也在更大程度上解决了。码头工人来救我们了。<br/> <br/>这篇文章是为不熟悉Docker的前端开发人员做的。我们将分析一些与优化发布流量相关的问题，并触及一些安全问题。</p><h2 id="e83f" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">安装Docker</h2><p id="e953" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Docker安装非常简单，在<a class="ae kc" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中有详细描述。<br/> <br/>我们工作也需要docker-compose，比如对于MacOS，安装Docker Desktop的时候也会自动安装，但是在linux系统上就要单独安装<a class="ae kc" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="f748" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Docker桌面包括什么</h2><p id="9e80" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Docker是作为模块化架构开发的，所以当你安装Docker Desktop的时候，你一次就可以得到几个程序。</p><h2 id="16dd" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">码头引擎</h2><p id="10ab" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Docker引擎包括容器构建工具、容器注册表、编排工具、运行时等等。它是一个用Go编写的开源项目。它作为一个守护进程运行，为执行命令提供RESTful API。</p><h2 id="af8e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Docker CLI客户端</h2><p id="2f90" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Docker引擎API的控制台客户端。</p><h2 id="d9b4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Docker撰写</h2><p id="3193" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">描述和运行多容器应用程序的工具。开发中极其有用的东西。</p><p id="73d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">docker和docker-compose支持root和命令的- help标志:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="bc58" class="lb lc iq me b gy mi mj l mk ml">docker --help<br/>docker ps --help<br/>docker-compose --help<br/>docker-compose up --help</span></pre><h2 id="ba77" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">面向前端开发者的Docker词典</h2><p id="2935" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在给前端开发者一些松散的类比，说明这个工具和我们作为前端开发者所熟悉的东西有很多共同点，比如Node.js和NPM。<br/> <code class="fe mm mn mo me b"><em class="mp">Docker Image</em></code> <em class="mp"> <br/> </em>我们可以在某个地方发布，比如DockerHub。我们也可以发布NPM套餐。<br/> <code class="fe mm mn mo me b">Dockerfile</code> <br/>采集图像的配方。我们没有菜谱，但是我们有一个包/应用程序清单——package . JSON .<br/><code class="fe mm mn mo me b">docker build<br/></code>构建docker映像。我们正在前端npm运行构建中构建我们的应用程序。</p><p id="6726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mm mn mo me b">DockerHub</code></p><p id="3cfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要与另一个受欢迎的枢纽混淆。这是docker图像注册表。我们有自己的登记处——NPM登记处。<br/> <code class="fe mm mn mo me b">docker run<br/></code>启动容器的控制台命令。与前端世界最相似的是npm start命令。</p><h2 id="b280" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">简单的例子</h2><p id="28d7" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这里以<a class="ae kc" href="https://github.com/evgeniykravtsov/docker-example" rel="noopener ugc nofollow" target="_blank">为例</a>的代码。</p><p id="9f46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用react项目的常用模板- create-react-app。</p><p id="7337" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我添加了4个新文件。分别是Dockerfile，docker-compose.dev.yml，docker-compose.yml，nginx.conf。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e7e12fc67efed129bc7590ae165a58b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*-ROMvsDTN8fsWjTX9CD2Ew.png"/></div></figure><h2 id="abdc" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">发展模式</h2><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6f73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">docker-compose.dev.yml -这个文件足够开发了。第一步:我们声明“web”服务。选择将要构建的映像:node:16.10-alpine3.11最好详细说明所使用的版本，值得让它们与生产构建版本完全相同。<br/> <br/>第二步:我们选择端口，这些端口将反映我们的主机系统中正在运行的容器的端口。<br/> <br/>第3步:我们把当前目录下的所有东西挂载到容器中。这是必要的，以便本地更改立即调用重建</p><p id="cb3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四步:“环境”允许你设置你感兴趣的环境变量。<br/> <br/>第5步:‘working _ dir’指定容器内的工作目录，后续命令将针对该目录执行。<br/> <br/> 6步骤:安装依赖项，开始开发。<br/> <br/>用命令开始开发:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6241" class="lb lc iq me b gy mi mj l mk ml">docker-compose -f docker-compose.dev.yml up</span></pre><h2 id="a1e0" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">生产模式</h2><p id="7c59" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">docker-compose.yml配置与开发版有什么不同？</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="25f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—从Dockerfile指定构建，而不是使用映像</p><p id="24b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">— NODE_ENV环境变量已更改:开发-&gt;生产</p><p id="ba3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">—没有命令部分，因为静态将由nginx提供。</p><p id="6f1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">nginx配置尽可能简单，不会增加提供文件的过程的负担，也不会在他们试图获取一些不存在的文件时退回到/index.html。最有趣的是Dockerfile:多阶段构建，用于减少产生的伪像。</p><h2 id="1122" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Dockerfile文件</h2><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="bc05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一阶段是建造</p><p id="1ca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1行。为此，我们将用于开发FROM node: 16.10-alpine3.11的同一个源映像指定为build Important！我们将该阶段命名为build，以便在接下来的阶段中，将通过其名称而不是其索引来调用它，如果我们包含其他阶段，索引可能会改变。</p><p id="2ee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2线。指定工作目录/应用程序</p><p id="61fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3-5行。这里我们讲的更详细:<br/>问题:为什么我们首先只复制package.json并安装？<br/>答案(不会让自己等待太久):第一次运行时，差异不会明显，但在下一次构建尝试中，差异会很明显。<br/> <br/>如果“package.json”没有变化，那么docker构建的层将不会改变，这些步骤将简单地从缓存中取出。这将大大加快进程，并将网络负载降低数倍。我们只是需要这个。<br/> <br/>第六行。复制剩余的文件并运行build。</p><p id="099d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二阶段是一件艺术品的形成。在我们的例子中，工件的核心是一个具有静态的nginx容器。<br/> 8线。我们指定nginx图像作为基础。<br/>第九行。我们将第一阶段的文件复制到我们将从中分发静态数据的文件夹中。<br/> 10行。将nginx配置文件复制到工件<br/>中<br/>您可以像这样运行工件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="97a4" class="lb lc iq me b gy mi mj l mk ml"> docker-compose up</span></pre><h2 id="7976" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="1702" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">毫无疑问，集装箱化的主题是非常广泛的，我们只涉及了很小的一部分，但我们已经涵盖了必要的基础开始。如果这篇文章成为Docker中FE开发的起点，我会很高兴。</p></div></div>    
</body>
</html>