<html>
<head>
<title>Python Flask: Asynchronous Upload to AWS S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Flask:异步上传到AWS S3</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-flask-asynchronous-upload-to-aws-s3-ad0841358e6f?source=collection_archive---------3-----------------------#2022-06-12">https://levelup.gitconnected.com/python-flask-asynchronous-upload-to-aws-s3-ad0841358e6f?source=collection_archive---------3-----------------------#2022-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6524" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用threading和Celery将文件上传到AWS S3时实现亚秒级响应</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e735dad3c6a0b4dfd27c99929e4c467a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5pnDVyRnLUu-92_q"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@bluewaterglobe?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞典蓝水</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="055b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时，您的客户要求您想办法上传一个相对较大的文件，但尽管您不能立即知道上传过程的结果，但仍然相对较快。</p><p id="e536" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再看另一个场景，有时您可能需要对存储在CSV或Excel文件中的文件或数据进行预处理，在它们到达您的数据湖或数据库之前，需要完成几个步骤。</p><p id="8634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，上传(或额外处理)数据需要时间，我很确定用户等待这个过程完成是很奇怪的。如果是这样的话，那么异步上传会给你带来很多好处。</p><p id="605d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将研究几种同步和异步上传文件的方法。让我们直入主题吧！</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="397d" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">准备</h1><p id="6266" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">在进一步编写代码之前，让我们先准备好启动项目所需的所有东西。</p><p id="1b6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，确保您有AWS访问密钥和秘密访问密钥。因为这是上传我们的文件到S3桶的关键。</p><p id="1a93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们需要创建一个S3桶。到你的AWS控制台，搜索S3，然后点击“创建桶”。现在，您可以填写存储桶名称(它必须是唯一的名称)和区域(让您和您的用户知道)，出于本教程的考虑，我们将授予公众对我们的S3存储桶的读取权限。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mm"><img src="../Images/8c7e6257776590e892cee4dcca4e6b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8aIzJHbKjS5j5PcfaQLAg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">作者形象</figcaption></figure><p id="9ec1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，转到您新创建的bucket，并转到Permissions选项卡。然后，使用以下JSON添加/编辑存储桶策略:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="6f45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记得把<code class="fe mp mq mr ms b">BUCKET_NAME</code>改成自己的桶名。</p><p id="ea0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了存储敏感数据，我们将使用<code class="fe mp mq mr ms b">.env</code>。因此，在项目的根目录下创建<code class="fe mp mq mr ms b">.env</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="00bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将您的AWS访问密钥和秘密访问密钥放在那里，同时附上S3存储桶名称和S3存储桶基本URL。通常，您的S3存储桶基本URL会是这样的格式:<code class="fe mp mq mr ms b">https://&lt;BUCKET_NAME&gt;.s3.&lt;REGION&gt;.amazonaws.com</code>，例如<code class="fe mp mq mr ms b"><a class="ae lb" href="https://flaskasyncbucket.s3.ap-southeast-1.amazonaws.com" rel="noopener ugc nofollow" target="_blank">https://mybucket.s3.ap-southeast-1.amazonaws.com</a></code>。</p><p id="6494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，为了确保我们可以在本地机器上运行Celery，我们需要Docker和docker-compose。如果你没有安装这些，那么你可以按照这个文件<a class="ae lb" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/install/</a></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="acea" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">编码时间</h1><p id="0205" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">在上一节中，我们创建了S3存储桶，并授予了公共读取权限。还确保我们安装了Docker引擎和docker-compose，以及AWS访问密钥和秘密访问密钥。</p><p id="e22a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一节中，我们将通过首先创建一个虚拟环境来开始构建我们的项目。运行以下命令创建一个虚拟环境:</p><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="e768" class="mx lk iq ms b gy my mz l na nb">python -m venv venv</span></pre><p id="05a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后通过运行以下命令激活虚拟环境:</p><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="2d09" class="mx lk iq ms b gy my mz l na nb"># Mac OS / Linux<br/>source venv/bin/activate</span><span id="e471" class="mx lk iq ms b gy nc mz l na nb"># Windows<br/>venv\Scripts\activate</span></pre><p id="3c24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，安装所需的依赖项:</p><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="cd35" class="mx lk iq ms b gy my mz l na nb">pip install flask Flask-SQLAlchemy boto3 celery</span></pre><p id="603b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于配置，让我们创建一个名为<code class="fe mp mq mr ms b">config.py</code>的文件，并将代码放在那里:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5b3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们创建了一个Config类来存储所有必需的信息(包括敏感数据)，并创建了一个Celery实例来定义Celery的任务。</p><p id="7d2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们实际上是将文件上传到S3存储桶，并且我们需要知道这些文件存储在哪里，因此我们需要一个数据库来存储目标文件的URL。为此，创建一个名为<code class="fe mp mq mr ms b">models.py</code>的文件，内容如下:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="be05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们定义了一个名为File的模型实体，带有字段<code class="fe mp mq mr ms b">id</code>、<code class="fe mp mq mr ms b">name</code>、<code class="fe mp mq mr ms b">url</code>和<code class="fe mp mq mr ms b">upload_status</code>。对于上传状态，它是一个枚举，所以它只能在四个值之间，<code class="fe mp mq mr ms b">PENDING</code>、<code class="fe mp mq mr ms b">PROCESSING</code>、<code class="fe mp mq mr ms b">COMPLETE</code>和<code class="fe mp mq mr ms b">ERROR</code>。这个状态很重要，因为我们将异步上传我们的文件，所以用户不需要等到上传过程完成，但他/她可以立即检查上传状态。</p><p id="9aa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是上传功能。创建<code class="fe mp mq mr ms b">file.py</code>并将它放在那里:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="49cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对上述代码片段的解释:</p><ul class=""><li id="24ba" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">我们总共有四个功能，与上传文件相关。第一个是<code class="fe mp mq mr ms b">rename_file</code>，顾名思义，这个函数会通过结合原始文件名和当前时间戳来重命名我们想要上传的文件，同时也保证一个用户在第一时间提供正确的文件名。</li><li id="867d" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">对于<code class="fe mp mq mr ms b">process_file_to_stream</code>，我们需要这个函数将文件类型对象转换成字节流，因为我们不能直接将文件类型对象的参数给线程或Celery任务中的可调用函数。实际上，还有另一种方法可以做到这一点，即临时存储该文件，然后将其上传到S3存储桶。还要注意有一个参数<code class="fe mp mq mr ms b">to_utf8</code>，如果我们想要使用Celery上传文件，就会用到这个参数，因为不可能向Celery的任务发送字节(基本上是因为发送到Celery的任务的所有数据都必须是JSON可序列化的)。</li><li id="3906" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated"><code class="fe mp mq mr ms b">upload_file</code>是将文件上传到S3桶的正常同步方式。我们不需要将其转换成字节流，我们可以使用<code class="fe mp mq mr ms b">boto3</code>的<code class="fe mp mq mr ms b">upload_fileobj</code>函数直接上传。</li><li id="18cd" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated">在<code class="fe mp mq mr ms b">upload_file_from_stream</code>中，我们将字节或utf8字符串转换成一个文件类型的对象。然后我们就可以用<code class="fe mp mq mr ms b">upload_fileobj</code>正常上传了。</li></ul><p id="7f3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始测试我们的项目之前，我们需要通过端点打开所有定义的函数。让我们创建一个名为<code class="fe mp mq mr ms b">routes.py</code>的Python文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="f0bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对上述代码片段的解释:</p><ul class=""><li id="d6a2" class="nd ne iq jp b jq jr ju jv jy nf kc ng kg nh kk ni nj nk nl bi translated">这是不言自明的，对吗？😊</li><li id="70fc" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated"><code class="fe mp mq mr ms b">normal_upload</code>:此端点使用同步上传功能。因此用户需要等到上传过程完成。</li><li id="0f31" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated"><code class="fe mp mq mr ms b">async_upload</code>:这个端点使用线程来处理上传过程。因此，该函数将立即返回，而不必等到进程完成。注意，在第51行，我们创建了一个线程实例，并为它提供了一个可调用函数，以及运行该可调用函数所需的参数。在<code class="fe mp mq mr ms b">__async_upload</code>定义中，我们使用应用程序上下文，因此我们可以与应用程序或数据库交互。</li><li id="a199" class="nd ne iq jp b jq nm ju nn jy no kc np kg nq kk ni nj nk nl bi translated"><code class="fe mp mq mr ms b">celery_upload</code>:该端点需要定义Celery的任务。我们现在就去做。</li></ul><p id="b98c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们定义一下在<code class="fe mp mq mr ms b">celery_upload</code>中使用的芹菜的任务:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a45e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单，对吧？首先，使用<code class="fe mp mq mr ms b">file_id</code>获取一个文件实体，并使用<code class="fe mp mq mr ms b">upload_file_from_stream</code>上传文件(以包含字节流、文件名、内容类型等的文件字典的形式)。然后，如果一切正常，提交完成状态，如果发生异常，提交错误状态。</p><p id="5545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在<code class="fe mp mq mr ms b">app.py</code>中组合所有这些代码。这是我们项目的切入点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="fb7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切就绪后，现在我们可以测试我们的项目了。但是首先，如果我们想测试芹菜上传端点，我们需要Dockerfile和docker-compose。</p><p id="6fb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建<code class="fe mp mq mr ms b">Dockerfile</code>和<code class="fe mp mq mr ms b">docker-compose.yaml</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="c8f8" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">健全性检查</h1><p id="e2a4" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">让我们通过运行来运行我们的项目:</p><pre class="km kn ko kp gt mt ms mu mv aw mw bi"><span id="9ab4" class="mx lk iq ms b gy my mz l na nb">docker-compose up</span></pre><p id="0eb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个命令将创建三个容器，应用程序、Redis实例和celery worker。</p><p id="2445" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入<a class="ae lb" href="http://localhost:5000/normal_upload" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/normal _ upload</a>测试正常上传。为表单数据提供键<code class="fe mp mq mr ms b">file</code>和要上传的文件的值。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/7670d75e6a7289c7c9871c88e02e037e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BgGbe8gGGjOHVH9idL5w6A.png"/></div></div></figure><p id="f3ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以对<code class="fe mp mq mr ms b">/async_upload</code>和<code class="fe mp mq mr ms b">/celery_upload</code>做同样的事情。</p><p id="4e88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成上传请求需要多长时间？在我的情况下，如果没有非常快的互联网连接，使用普通上传需要5秒钟上传一个10MB的PDF文件，使用异步上传不到100毫秒，使用芹菜上传需要100-200毫秒。你呢？</p><p id="c283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">免责声明，上述数字肯定不是基准测试的具体证据。因此，要做出这样的声明，最好进行负载测试。如果您对负载测试感兴趣，我可以为您提供很好的资源:</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/nerd-for-tech/load-testing-using-locust-io-f3e6e247c74e" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">使用Locust.io进行负载测试</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">在我们的应用程序或服务运行后，有一段时间我们想知道性能和负载…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kv nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/load-testing-with-k6-48488c7946bb"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">使用k6进行负载测试</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">仅使用一种工具的一系列负载测试功能</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj kv nv"/></div></div></a></div><h1 id="bb10" class="lj lk iq bd ll lm ol lo lp lq om ls lt lu on lw lx ly oo ma mb mc op me mf mg bi translated">结论</h1><p id="aea0" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">我们已经看到了如何使用几种方法将文件上传到AWS S3 bucket，普通上传、使用线程上传和使用Celery上传。一般来说，我们可以根据需要暂停线程和作业队列的使用，在这种情况下，当用户上传文件时实现亚秒级响应。</p><p id="1294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想要预处理上传的文件，也可以使用此场景，例如为图像制作不同大小的多个副本，以及为您的数据科学项目清理数据点。</p><p id="bff0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是本文的编码材料:</p><div class="ns nt gp gr nu nv"><a href="https://github.com/agusrichard/flask-workbook/tree/master/async-upload-to-s3" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">flask-workbook/async-upload-to-S3 at master agusrichard/flask-workbook</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">用Flask学习Web开发项目。为agusrichard/flask-workbook开发做出贡献，创建一个…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="oq l og oh oi oe oj kv nv"/></div></div></a></div><p id="761c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>