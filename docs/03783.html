<html>
<head>
<title>JavaScript Best Practices — This and Class Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践— This和Class字符串</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-this-and-class-strings-da996622ca3b?source=collection_archive---------26-----------------------#2020-05-26">https://levelup.gitconnected.com/javascript-best-practices-this-and-class-strings-da996622ca3b?source=collection_archive---------26-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ae2788efab53a671dbe7fef1736fb124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QgE2vEqjT8gv3yCC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@alexleegdp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">李东旻</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6de4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="25ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何返回<code class="fe le lf lg lh b">this</code>来让我们将类方法链接在一起，并编写一个<code class="fe le lf lg lh b">toString</code>方法来确保我们的类正常工作并且不会产生副作用。</p><h1 id="b946" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">方法可以返回<code class="fe le lf lg lh b">this</code>来帮助方法链接</h1><p id="bb87" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在我们的JavaScript类中，我们可以在方法中返回<code class="fe le lf lg lh b">this</code>，这样我们就可以用修改后的<code class="fe le lf lg lh b">this</code>值链接我们的方法。</p><p id="54b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个返回<code class="fe le lf lg lh b">this</code>的方法中，我们可以修改<code class="fe le lf lg lh b">this</code>的值，这样我们就可以编写代码将这些方法链接在一起，并在这些方法被一起调用时获得我们想要的结果。</p><p id="50be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写如下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="49bb" class="mt lj it lh b gy mu mv l mw mx">class Box {<br/>  setHeight(height) {<br/>    this.height = height;<br/>    return this;<br/>  }</span><span id="53e5" class="mt lj it lh b gy my mv l mw mx">  setWidth(width) {<br/>    this.width = width;<br/>    return this;<br/>  }<br/>}</span></pre><p id="2661" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有带有<code class="fe le lf lg lh b">setHeight</code>和<code class="fe le lf lg lh b">setWidth</code>方法的<code class="fe le lf lg lh b">Box</code>类。</p><p id="95a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个方法中，我们用作为每个方法的参数传入的值来更改<code class="fe le lf lg lh b">this</code>的一个属性。</p><p id="5233" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以如下链接我们的<code class="fe le lf lg lh b">Box</code>实例方法调用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9bb6" class="mt lj it lh b gy mu mv l mw mx">new Box().setHeight(10).setWidth(15);</span></pre><p id="2d6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在我们的控制台日志中，如果我们记录上面的方法链表达式的返回值，我们会得到以下输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8bc0" class="mt lj it lh b gy mu mv l mw mx">Box {height: 10, width: 15}</span></pre><p id="3687" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，<code class="fe le lf lg lh b">height</code>和<code class="fe le lf lg lh b">width</code>属性是由上面的方法调用链设置的。</p><h1 id="a93f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在我们的类中编写一个<code class="fe le lf lg lh b">toString()</code>方法，以确保它能够成功工作</h1><p id="8b67" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以在JavaScript类中编写自己的<code class="fe le lf lg lh b">toString</code>方法，这样我们就可以看到它成功地工作了。在方法中，我们可以返回类成员的值，这样我们就知道它们设置正确。</p><p id="92b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码向我们的类添加一个<code class="fe le lf lg lh b">toString</code>方法:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5a50" class="mt lj it lh b gy mu mv l mw mx">class Box {<br/>  setHeight(height) {<br/>    this.height = height;<br/>    return this;<br/>  }</span><span id="5299" class="mt lj it lh b gy my mv l mw mx">  setWidth(width) {<br/>    this.width = width;<br/>    return this;<br/>  }</span><span id="b648" class="mt lj it lh b gy my mv l mw mx">  toString() {<br/>    return `height: ${this.height}, width: ${this.width}`;<br/>  }<br/>}</span></pre><p id="e21c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个<code class="fe le lf lg lh b">toString</code>方法，它返回一个值为<code class="fe le lf lg lh b">this.height</code>和<code class="fe le lf lg lh b">this.width</code>的字符串，它们是我们的<code class="fe le lf lg lh b">Box</code>实例的成员。</p><p id="32cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们调用下面的方法链时:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="16b9" class="mt lj it lh b gy mu mv l mw mx">new Box().setHeight(10).setWidth(15).toString();</span></pre><p id="50d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到从<code class="fe le lf lg lh b">toString</code>返回的值是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d2f6" class="mt lj it lh b gy mu mv l mw mx">height: 10, width: 15</span></pre><p id="c598" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们确认成员设置正确。</p><h1 id="30fc" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">空的构造函数或者只是委托给父类的函数是不必要的</h1><p id="3fd6" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，我们不必为每个类提供一个构造函数。如果我们只是用与父类相同的参数调用父类构造函数，我们也不需要从子类调用父类构造函数。</p><p id="527d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不是编写下面的代码来添加空的构造函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4ae8" class="mt lj it lh b gy mu mv l mw mx">class Foo {<br/>  constructor() {}<br/>}</span></pre><p id="b37f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以跳过<code class="fe le lf lg lh b">Foo</code>类中的<code class="fe le lf lg lh b">constructor</code>方法，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b344" class="mt lj it lh b gy mu mv l mw mx">class Foo {}</span></pre><p id="14e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都做同样的事情，所以我们不需要额外的空<code class="fe le lf lg lh b">constructor</code>方法。</p><p id="649c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不需要在子构造函数中编写只调用父构造函数的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fa17" class="mt lj it lh b gy mu mv l mw mx">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="3044" class="mt lj it lh b gy my mv l mw mx">class Cat extends Animal {<br/>  constructor(...args) {<br/>    super(...args);<br/>  }<br/>}</span></pre><p id="5308" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe le lf lg lh b">Cat</code>中有一个<code class="fe le lf lg lh b">super</code>调用，它用我们传入的任何内容调用父<code class="fe le lf lg lh b">Animal</code>构造函数。</p><p id="32bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们如下创建一个<code class="fe le lf lg lh b">Cat</code>实例时:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="57d7" class="mt lj it lh b gy mu mv l mw mx">const cat = new Cat('jane');</span></pre><p id="559f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从控制台日志中获得值<code class="fe le lf lg lh b">Cat {name: “jane”}</code>。</p><p id="319b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们可以省略构造函数。因此，我们可以这样写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="370d" class="mt lj it lh b gy mu mv l mw mx">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="f24d" class="mt lj it lh b gy my mv l mw mx">class Cat extends Animal {}</span></pre><p id="b957" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有了<code class="fe le lf lg lh b">Cat</code>中的构造函数，我们得到的结果和上一个例子一样，所以我们应该把它去掉。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/d72dff891db799273d30404e008aadd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VA88ATtnk5HZL0t2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">亚历山大·席默克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="342c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="62b2" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在被我们的方法修改后，我们的类方法可以返回<code class="fe le lf lg lh b">this</code>来返回<code class="fe le lf lg lh b">this</code>的值。</p><p id="4de2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在父类中有一个空的构造函数，或者在子类中有一个用与父构造函数相同的参数调用<code class="fe le lf lg lh b">super</code>的构造函数，我们可以从代码中删除它们。</p><p id="f7fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用一个<code class="fe le lf lg lh b">toString</code>方法返回一个包含类成员的字符串，以确保它们设置正确。</p></div></div>    
</body>
</html>