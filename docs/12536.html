<html>
<head>
<title>Calculating time-weighted interest with SQL and the Newton-Raphson method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL和Newton-Raphson方法计算时间加权利息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/calculating-time-weighted-interest-with-sql-and-the-newton-rhapson-method-fe5ed044cf14?source=collection_archive---------4-----------------------#2022-06-18">https://levelup.gitconnected.com/calculating-time-weighted-interest-with-sql-and-the-newton-rhapson-method-fe5ed044cf14?source=collection_archive---------4-----------------------#2022-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="59a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程将使用SQLite和Python。你只需要运行本地安装的Python3。最后，您应该能够运行Python脚本，并在命令行中获得正确的输出。</p><p id="6f18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想拼凑一个简短的教程，展示一点高等数学如何真正有助于数据分析。如果你没有完全理解实现背后的数学原理，那也没关系。见鬼，我也不是专家。</p><p id="d889" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很多年前，我的父亲给我看了这个，我想写一下，因为我觉得这很酷，而且这是父亲节。</p><p id="6b53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望计算潜在的数百万个银行账户和每个账户中的数百笔交易，给定一年期间每个账户余额的所有活动，回报率(利息)是多少。</p><p id="89f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回报率的简单实现只需要:</p><p id="2d66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">((year_end_balance — beginning_balance) / year_end_balance) * 100</code></p><p id="5948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是全年的增长率，但这是有限的。它没有考虑影响全年收支平衡的流入和流出。计算这个公式的简单(嗯，不那么简单)方法很麻烦，以至于investopedia关于这个问题的文章建议你只使用在线计算器来计算，而不是尝试手工计算。</p><p id="7528" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，有一个聪明的方法我们可以使用<a class="ae kp" href="http://www.sosmath.com/calculus/diff/der07/der07.html" rel="noopener ugc nofollow" target="_blank"> Netwon Raphson方法</a>来实现二次收敛。</p><p id="3cfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们创建一个Python文件来进行分析。</p><p id="e169" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从CLI运行:</p><p id="f19d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">touch interest_calc.py</code>并在您首选的IDE中打开文件。</p><p id="7269" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们的第一步就是添加夹具数据生成功能。在本教程中，这些代码片段的github直接链接是定期提供的，如果你想在我们学习的过程中复制和粘贴代码。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/11164302ca99ca72fe62b28bec939d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*g9veaMI4XmzMted4tWnuCA.png"/></div></figure><p id="fbbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kp" href="https://github.com/bfemiano/newton-rahpson-interest-analytic/blob/main/interest_calc.py#L22" rel="noopener ugc nofollow" target="_blank">直接github链接</a>为<code class="fe kl km kn ko b">get_data</code>。</p><p id="b8d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了本教程的清晰起见，只有一个唯一的帐户id = <code class="fe kl km kn ko b">1</code>,但是我们构建的代码可以处理任意数量的帐户id。然后，我们将特定日期的余额值相加。我把数据按日期排序，只是为了更容易阅读，但我们很快就会发现这并不重要。</p><p id="202f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们启动我们的<code class="fe kl km kn ko b">calc_time_weighted_interest</code>函数来创建数据库并插入数据，以便我们可以对其进行查询:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ky"><img src="../Images/e3faf4fd809a519648dee18452c43362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eboe6oWS6rE30oVBGCmPhw.png"/></div></div></figure><p id="76c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们建立一个到内存中瞬态数据库的连接。这意味着数据将在我们的Python脚本执行后消失。然后，我们创建一个表<code class="fe kl km kn ko b">account_balance</code>，其中包含字段<code class="fe kl km kn ko b">account_id</code>、<code class="fe kl km kn ko b">date</code>和<code class="fe kl km kn ko b">balance</code>的列。最后，让我们将假数据插入表中。这只是函数的前半部分。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ld"><img src="../Images/c76ad807fd2f266e68850233b8e695e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkHrZXrNuoKEGAIvdsL5iA.png"/></div></div></figure><p id="7489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们设置一个名为TIME_WEIGHTED_INTEREST的自定义函数，并给它一个指向在别处定义的<code class="fe kl km kn ko b">time_weighted_interest</code>函数的指针。我们一会儿就会谈到这一点。</p><p id="e92f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一行，我们使用从<code class="fe kl km kn ko b">get_query()</code>返回的内容用光标执行一个查询，这是我们开始写出SQL的地方。我们下一步会谈到这个。</p><p id="c16f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">游标fetchall()将返回所有结果。如果结果长度为零，则引发一个错误。每个结果都应该被分解成两个变量<code class="fe kl km kn ko b">account_id</code>和<code class="fe kl km kn ko b">interest</code>。我们在fixture数据中只有一个帐户id，所以只返回第一个利息结果。最后，让我们关闭连接。</p><p id="457f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kp" href="https://github.com/bfemiano/newton-rahpson-interest-analytic/blob/main/interest_calc.py#L163" rel="noopener ugc nofollow" target="_blank">为<code class="fe kl km kn ko b">calc_time_weighted_interest</code>直接github链接</a>。</p><p id="99f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备开始编写查询。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi le"><img src="../Images/2fba6397ed6098424f030c427dd116d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NtNP-e_IpBSwWLXNL1yoA.png"/></div></div></figure><p id="e610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开始功能<code class="fe kl km kn ko b">get_query</code>，让我们开始我们的CTE链。</p><p id="a2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们要将之前的余额添加到每个记录中。我们可以用一个窗口函数来实现。通过<code class="fe kl km kn ko b">account_id</code>对数据进行分区，并在每个分区中按照<code class="fe kl km kn ko b">date</code>的排序顺序查看行。我们可以使用<code class="fe kl km kn ko b">LAG(balance,1)</code>将窗口中的先前余额添加到每一行。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lf"><img src="../Images/5596b668ab5b44874cc5c5b8a8bf57ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlPbmh1UQTS1qZSHLu5J6A.png"/></div></div></figure><p id="31b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一个CTE中，我们将使用<code class="fe kl km kn ko b">prior_balance</code>将每个<code class="fe kl km kn ko b">balance</code>转换为来自先前记录的调整增量。在年初第一笔余额的情况下，之前的余额将为空，所以我们只需设置<code class="fe kl km kn ko b">adjustment = balance</code>。否则我们设置<code class="fe kl km kn ko b">adjustment</code> = <code class="fe kl km kn ko b">balance — prior_balance</code>。</p><p id="ca49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以如果我们从举例开始</p><pre class="kr ks kt ku gt lg ko lh li aw lj bi"><span id="f077" class="lk ll iq ko b gy lm ln l lo lp">date       balance  prior_balance<br/>2013-01-01   500      NULL<br/>2013-04-11   550      500</span></pre><p id="ab42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不，我们以</p><pre class="kr ks kt ku gt lg ko lh li aw lj bi"><span id="1a18" class="lk ll iq ko b gy lm ln l lo lp">date         adjustment<br/>2013-01-01     500<br/>2013-04-11     50</span></pre><p id="768b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们做另一个转换:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lq"><img src="../Images/a647f0519de176d75348024204fb5380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCfjtVW7OuiOIFB48S5uEQ.png"/></div></div></figure><p id="a104" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一个CTE中，我们将日期转换为一年剩余时间的百分比。这成为0.0和1.0之间的值。其中0.0 = 12月31日，1.0 = 1月1日。</p><p id="af39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将一年中的某一天作为一个整数，从365中减去它，然后将结果除以365。四舍五入到最接近的两位小数。</p><p id="4e5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，2013年4月11日是一年中的第100天。</p><p id="30c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以<code class="fe kl km kn ko b">(365-100)/365</code> = 0.73</p><p id="a891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们认为这是一年中剩余的百分比，给定一年中的某一天。</p><p id="301e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简单起见，让我们将<code class="fe kl km kn ko b">adjustment</code>四舍五入到最接近的两位小数。</p><p id="cc12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在按照我们的例子，这个CTE的输出将是:</p><pre class="kr ks kt ku gt lg ko lh li aw lj bi"><span id="4df0" class="lk ll iq ko b gy lm ln l lo lp">adjustment    perc_year_remaining    <br/>500.00              1.00                       <br/>50.00               0.73</span></pre><p id="99b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们做另一个转换:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lr"><img src="../Images/6faafe484fc66523f44e78714716676e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ed5ZZVdK2lRuMWYmAxCQqQ.png"/></div></div></figure><p id="f4af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个CTE中，让我们按<code class="fe kl km kn ko b">account id</code>排序，在每个<code class="fe kl km kn ko b">account_id</code>中，按<code class="fe kl km kn ko b">perc_year_remaining</code>升序排序(按年份的逆时间顺序)。例如，对于每个帐户id，今年的最后一次调整将首先出现，然后是第二次到最后一次，依此类推。</p><p id="9d6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为这个转换的一部分，我们通过管道<code class="fe kl km kn ko b">|</code>将<code class="fe kl km kn ko b">perc_year_remaining</code>和<code class="fe kl km kn ko b">adjustment</code>连接起来。</p><p id="8a1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">||</code>是用于字符串连接的SQLite语法。</p><p id="15b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，按照我们的例子，我们的行变成:</p><pre class="kr ks kt ku gt lg ko lh li aw lj bi"><span id="af7a" class="lk ll iq ko b gy lm ln l lo lp">perc_adj_pair    <br/>0.73|50.00<br/>1.00|500.00</span></pre><p id="adf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逆时间排序的输出顺序对于下一个CTE步骤非常重要。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ls"><img src="../Images/91b88a7ca8585def2a6c0089d03928a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7aKverT04Xg-G8AO2WPMg.png"/></div></div></figure><p id="a14c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们按<code class="fe kl km kn ko b">account_id</code>分组，并将每个管道分隔的<code class="fe kl km kn ko b">(adjustment, perc_year_remaining)</code>对连接成一个帐户id字符串。每对都被<code class="fe kl km kn ko b">;</code>分开。我们必须使用字符串将数据编码为列表，因为不幸的是SQLite没有列表/数组复杂值类型。</p><p id="4ad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果是每<code class="fe kl km kn ko b">account_id</code>一行，所有的调整对以时间顺序相反的顺序连接在一起。</p><p id="556f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在我们有了account_id = 1</p><pre class="kr ks kt ku gt lg ko lh li aw lj bi"><span id="86b9" class="lk ll iq ko b gy lm ln l lo lp">adjustments<br/>0.73|50;1.00|500</span></pre><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lt"><img src="../Images/8d6a688e51cec3b1273c48a80b21cca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8AS95Zqjx4mgaoD4sHxdgw.png"/></div></div></figure><p id="2e31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们终于可以调用我们的自定义函数来计算一年中所有账户id的时间加权利息了。</p><p id="a5b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kp" href="https://github.com/bfemiano/newton-rahpson-interest-analytic/blob/main/interest_calc.py#L114" rel="noopener ugc nofollow" target="_blank">直接github链接</a>用于<code class="fe kl km kn ko b">get_query</code></p><p id="6d90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在运行SQL之前，我们必须实现<code class="fe kl km kn ko b">time_weighted_interest_function</code></p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lu"><img src="../Images/2d306dc80a50eb714b8fc0596765979b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOWSuCMYT1phfaWJDYG5AA.png"/></div></div></figure><p id="a5f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的函数中，我们必须首先将字符串解包回到一个<code class="fe kl km kn ko b">(perc_year_remaining, adjustment)</code>对列表中。然后我们将两者转换回浮点值。我们可以把<code class="fe kl km kn ko b">investments</code>变量看作是<code class="fe kl km kn ko b">(perc_year_remaining, adjustment)</code>对的列表。</p><p id="ac53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们要计算账户在年底的余额。我们可以通过对所有调整求和来做到这一点。由于我们在年初将余额作为一项调整包括在内，因此这是可行的。我们还删除了最终调整，因为它不需要收敛于真实的时间加权利率。</p><p id="1651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们的功能还没有完成。接下来是有趣的部分。收敛函数。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lv"><img src="../Images/047dba144be09f0b1d4bad56076473b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdySQjfFjgxifa1ZFDjURg.png"/></div></div></figure><p id="f0d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们对投资最多运行25次收敛函数，看看我们是否收敛到低于<code class="fe kl km kn ko b">time_weighted_interest</code>的&lt;  【T0】  . If so we can break out of the retry loop and return the  【T1】 as the interest rate. This is where we need the investments to be in reverse chronological order.</p><p id="0ec1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kp" href="https://github.com/bfemiano/newton-rahpson-interest-analytic/blob/main/interest_calc.py#L80" rel="noopener ugc nofollow" target="_blank"> Direct github link </a>的误差</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lw"><img src="../Images/619db9ed1b028a0cbaf1c74a67778d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTTtInZHBXBQff1O0TQBXQ.png"/></div></div></figure><p id="d072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来让我们调用我们的基本函数<code class="fe kl km kn ko b">calc_time_weighted_interest</code>来启动并打印结果。</p><p id="08f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样在脚本的顶部，我们应该添加一些导入。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lx"><img src="../Images/2b10387730610c73213727bc002ac690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JV8UVrlMcppwGuG-w4OaEw.png"/></div></div></figure><p id="4971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在准备从CLI运行Python脚本。</p><p id="fdbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">python calc_interest.py</code></p><p id="0933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该大致看到:<code class="fe kl km kn ko b">9.4%</code>作为我们fixture测试数据中单一账户的时间加权利率。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="8bf5" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">分级编码</h1><p id="5e60" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae kp" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae kp" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae kp" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae kp" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="jp ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae kp" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>