<html>
<head>
<title>Python Trick: Lazy Module Loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python技巧:延迟模块加载</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-trick-lazy-module-loading-df9b9dc111af?source=collection_archive---------6-----------------------#2020-02-10">https://levelup.gitconnected.com/python-trick-lazy-module-loading-df9b9dc111af?source=collection_archive---------6-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d1053ded74272866a857e0cad506f8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCH_Ywolwq2QFBQ2jcZCGw.jpeg"/></div></div></figure><h1 id="dd3f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="d2eb" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我大量参与了用于微控制器的神经网络推理库<code class="fe lx ly lz ma b"><a class="ae mb" href="https://github.com/uTensor/uTensor" rel="noopener ugc nofollow" target="_blank">uTensor</a></code>的CLI工具<code class="fe lx ly lz ma b"><a class="ae mb" href="https://github.com/uTensor/utensor_cgen" rel="noopener ugc nofollow" target="_blank">utensor_cgen</a></code>的开发。</p><p id="5755" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">在我们在这篇文章中深入探讨这个技巧之前，读者最好先了解一下这个问题的背景。</p><p id="2e18" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">简而言之，<code class="fe lx ly lz ma b"><a class="ae mb" href="https://github.com/uTensor/utensor_cgen" rel="noopener ugc nofollow" target="_blank">utensor_cgen</a></code>可以获取一个预先训练好的模型文件，比如使用<code class="fe lx ly lz ma b">Tensorflow</code>训练的protobuff模型文件，并在<code class="fe lx ly lz ma b">uTensor</code>运行时将其转换为等价的实现，即一堆C++源文件和头文件。因此，当CLI启动并运行时，我需要导入库，如<code class="fe lx ly lz ma b">Tensorflow</code>。</p><p id="2733" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">然而，加载<code class="fe lx ly lz ma b">Tensorflow</code>需要很长时间。具体来说，将它加载到我的机器上大约需要3秒钟:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/a9407e3d3ffe22a642ca15067862adca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*on9qcohPlzcPWJhp2itrbw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">优化前的加载时间</figcaption></figure><p id="c855" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">我使用<code class="fe lx ly lz ma b">time</code>来获取cli的加载时间。</p><p id="65ac" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">正如您在<code class="fe lx ly lz ma b">real</code>部分看到的，我花了3.5秒加载cli并打印帮助消息。</p><p id="874d" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">当我检查程序时，我意识到我的程序花了很多时间加载<code class="fe lx ly lz ma b">Tensorflow</code>。所以才慢。非常感谢<code class="fe lx ly lz ma b">Tensorflow</code>，你真的毁了我的表演。</p><p id="001b" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">初看起来，3秒钟似乎没有什么害处，但当你不得不每天一遍又一遍地使用这个命令行界面时，情况会变得更糟。没有人愿意等待3秒钟的求助信息。幸运的是，我没花多长时间就想出了如何修复它。</p><p id="37c9" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">想法很简单:咱们不要进口<code class="fe lx ly lz ma b">Tensorflow</code>！</p><p id="60d9" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">这不公平。我的意思是不要马上导入<code class="fe lx ly lz ma b">Tensorflow</code>，而是只在需要的时候导入。</p><p id="cf19" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">但是怎么做呢？你可能会问。</p><p id="f239" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">由于python是一种解释型语言，您可以这样做:</p><pre class="mi mj mk ml gt mq ma mr ms aw mt bi"><span id="324b" class="mu kc it ma b gy mv mw l mx my">def my_func():<br/>    import tensorflow as tf<br/>    # do stuff with tf</span></pre><p id="4dad" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">或者</p><pre class="mi mj mk ml gt mq ma mr ms aw mt bi"><span id="d118" class="mu kc it ma b gy mv mw l mx my">class MyClass:<br/>    def magic(self):<br/>        import tensorflow as tf<br/>        # do stuff with tf</span></pre><p id="d71f" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">在这两种情况下，只有在调用函数/方法时，才会执行导入语句。</p><p id="3493" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">然而，这不是一个好主意，因为<code class="fe lx ly lz ma b">Tensorflow</code>是CLI如此重要的一部分。它在多个地方被引用，所以我们必须到处复制和粘贴import语句，这样不好维护。</p><p id="8a65" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">到目前为止，要求是明确的:</p><ol class=""><li id="fe23" class="mz na it lb b lc mc lg md lk nb lo nc ls nd lw ne nf ng nh bi translated">对<code class="fe lx ly lz ma b">Tensorflow</code>的单一引用，就像在我的每一个python脚本的顶部的<code class="fe lx ly lz ma b">import tensorflow as tf</code>，所以脚本中的所有成员可以共享对<code class="fe lx ly lz ma b">Tensorflow</code>的相同引用。</li><li id="63bd" class="mz na it lb b lc ni lg nj lk nk lo nl ls nm lw ne nf ng nh bi translated">只有当<code class="fe lx ly lz ma b">tf</code>的属性被访问时，才执行导入语句。</li></ol><h1 id="c690" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">惰性模块加载</h1><p id="356b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">是的，让我们的模块变懒吧！</p><p id="4dfd" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">计划是写一个类，它以一个库/包名为字符串，并带有自定义的属性访问，即实现<code class="fe lx ly lz ma b">__getattrib__</code>方法。在<code class="fe lx ly lz ma b">__getattrib__</code>的主体中，它将检查目标库/包是否被加载。如果没有加载，我们用<code class="fe lx ly lz ma b">importlib.import_module</code>加载库/包，然后得到我们需要的属性。</p><p id="2f6e" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">一个简化的实现可能如下所示:</p><pre class="mi mj mk ml gt mq ma mr ms aw mt bi"><span id="4033" class="mu kc it ma b gy mv mw l mx my">import importlib</span><span id="f4bb" class="mu kc it ma b gy nn mw l mx my">class LazyLoader:<br/>    def __init__(self, lib_name):<br/>        self.lib_name = lib_name<br/>        self._mod = None</span><span id="69bc" class="mu kc it ma b gy nn mw l mx my">    def __getattrib__(self, name):<br/>        if self._mod is None:<br/>            self._mod = importlib.import_module(self.lib_name)<br/>        return getattr(self._mod, name)</span></pre><p id="7ac5" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">它的工作原理如下:</p><ol class=""><li id="05fd" class="mz na it lb b lc mc lg md lk nb lo nc ls nd lw ne nf ng nh bi translated">最初，模块<code class="fe lx ly lz ma b">self._mod</code>被设置为<code class="fe lx ly lz ma b">None</code>，目标模块名以字符串的形式给出为<code class="fe lx ly lz ma b">lib_name</code></li><li id="0ef6" class="mz na it lb b lc ni lg nj lk nk lo nl ls nm lw ne nf ng nh bi translated">当对该对象进行任何属性查找时，即<code class="fe lx ly lz ma b">__getattrib__</code>被调用时，我们检查<code class="fe lx ly lz ma b">self._mod</code>是否仍然是<code class="fe lx ly lz ma b">None</code>，如果模块丢失，则使用<code class="fe lx ly lz ma b">importlib.import_module</code>加载库。</li><li id="521f" class="mz na it lb b lc ni lg nj lk nk lo nl ls nm lw ne nf ng nh bi translated">用<code class="fe lx ly lz ma b">getattr</code>将属性查找委托给<code class="fe lx ly lz ma b">self._mod</code>。</li></ol><p id="fbbd" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">因此，这个惰性加载器对象将像一个普通的模块一样工作，除了它不会加载模块，直到需要它的属性。</p><p id="5a3e" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">有了这个<code class="fe lx ly lz ma b">LazyLoader</code>，我们只需将所有的<code class="fe lx ly lz ma b">import tensorflow as tf</code>替换为<code class="fe lx ly lz ma b">tf = LazyLoader('tensorflow')</code>即可，以下是最终的加载时间:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/e6b15e442c6fadfc302d8128e0c2bd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HnvSqkaDjR1O_pgIeh7EaQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">延迟模块加载的加载时间</figcaption></figure><p id="462d" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">Boooom，加载时间下降到不到0.5秒！巨大的提升。</p><p id="3f4d" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">当然，这一招并不是<code class="fe lx ly lz ma b">Tensorflow</code>的专属。您可以将它应用于python脚本中任何您认为比较慢的import语句。你可以在这里找到我实现的<a class="ae mb" href="https://github.com/uTensor/utensor_cgen/blob/develop/utensor_cgen/utils.py#L23-L44" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a>。</p><p id="a5d5" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">也就是说，我的实现可能不会涵盖所有用例。例如，我没有在我的懒惰加载器中正确处理<code class="fe lx ly lz ma b">from ... import ...</code>语句。</p><p id="aee8" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">对于需要这个的人，我建议你看一下<code class="fe lx ly lz ma b">importlib</code> <a class="ae mb" href="https://docs.python.org/3/library/importlib.html#importlib.import_module" rel="noopener ugc nofollow" target="_blank">文档</a>看看怎么做。</p><p id="d56c" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">希望你会喜欢这一招，喜欢python编程！</p><p id="9d62" class="pw-post-body-paragraph kz la it lb b lc mc le lf lg md li lj lk me lm ln lo mf lq lr ls mg lu lv lw im bi translated">下一次，我们将讨论如何为<code class="fe lx ly lz ma b"><a class="ae mb" href="https://github.com/uTensor/utensor_cgen" rel="noopener ugc nofollow" target="_blank">utensor_cgen</a></code>编写插件，这样我们就可以为CLI注入一个新的后端。</p></div></div>    
</body>
</html>