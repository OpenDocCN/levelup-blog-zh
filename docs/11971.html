<html>
<head>
<title>C++ Virtual Methods: An Overview And Some Things You Might Not Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++虚方法:概述和一些你可能不知道的事情</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-virtual-methods-an-overview-and-some-things-you-might-not-know-33feb5a71813?source=collection_archive---------7-----------------------#2022-05-03">https://levelup.gitconnected.com/c-virtual-methods-an-overview-and-some-things-you-might-not-know-33feb5a71813?source=collection_archive---------7-----------------------#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">带有例子的C++虚方法的通俗易懂的解释。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/386641677b00cbf6e401ee134762331d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*LGwqa2twIok2ZFVsxd2Yjw.png"/></div></figure><h1 id="167a" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是虚拟方法？</h1><p id="e870" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当一个方法用虚拟关键字修饰时，它允许它的行为在一个派生的对象中被重写。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="33bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看上面的代码。</p><p id="b5e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ly">达</em>凌驾于<em class="ly">之上的行为从<em class="ly">基地</em>发言</em>。当<em class="ly"> DA </em>的实例被创建时，它调用这个新行为，而不是在<em class="ly"> Base </em>中实现的行为。这显示在第34行。</p><p id="e8d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要覆盖一个方法，基方法应该标记为<em class="ly">虚</em>，派生方法应该具有相同的:</p><ul class=""><li id="f7b8" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">名字</li><li id="0d39" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">参数类型列表(不同的名称是可以的，但不推荐)</li><li id="8055" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">返回类型(或协变)</li><li id="2dcd" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">cv鉴定器</li><li id="6201" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">参考限定符</li></ul><p id="f37b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果派生类是使用基类处理的，那么对重写的虚方法的调用将调用派生类中实现的行为。这显示在第37和40行。</p><p id="b761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对任何不使用限定名查找的虚函数的调用称为虚调用。执行覆盖方法中的行为。即使是33号线也是虚呼。</p><p id="e0ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果使用限定名查找调用方法，则取消虚拟调用。这显示在第42–44行。这就是所谓的直接呼叫。</p><h1 id="8db9" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">覆盖标识符</h1><p id="49ab" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">让我们看一下第18行，这里从<em class="ly">基</em>说话的<em class="ly">的行为被覆盖。</em></p><p id="40c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要重写虚方法，不需要显式使用重写标识符。但是，出于以下原因使用它会有所帮助:</p><ul class=""><li id="b472" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">对于阅读代码的人来说，显而易见的是，虚方法被覆盖了。没有猜测工作。</li><li id="2d19" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">编译器知道一个方法是否可以被覆盖，但是通过使用覆盖标识符，编译器可以检查你是否试图覆盖不可覆盖的东西。</li></ul><h2 id="04ac" class="mn ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">Override是标识符，不是关键字</h2><p id="8046" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><em class="ly"> override </em>在声明成员方法后使用时有特殊含义。但是，除此之外，它不像关键字那样保留。例如，下面的代码完全有效:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="03fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这样说的时候，<em class="ly">覆盖</em>仍然应该被视为保留，以避免读者混淆。</p><h1 id="9d68" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">重写私有虚拟成员</h1><p id="352c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">基成员方法不需要可访问才能被重写。它可以被声明为私有，或者可以使用私有继承来继承基类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，即使<em class="ly">基</em>中的<em class="ly">哈欠</em>是私有的，它仍然能够被<em class="ly"> DA </em>覆盖。</p><p id="1d01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们用基类处理<em class="ly"> DA </em>的实例，我们就不能再调用<em class="ly">哈欠</em>，因为它不再可访问。而是可以通过一个名为<em class="ly">do _哈欠</em>的公共方法来调用。</p><p id="2ebf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，即使使用限定名称查找，对<em class="ly">的虚拟调用也不会被抑制。参见第57–59行，<em class="ly">do _哈欠</em>调用<em class="ly">哈欠</em>的<em class="ly"> DA </em>实现，而不是<em class="ly">基</em>实现。虚拟调用只被抑制到第一个被调用的方法，之后任何覆盖行为仍然被使用。第57-59行的调用树是<em class="ly">Base::do _哈欠→ DA::哈欠</em>。</em></p><p id="f44c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于将虚方法标记为私有的有很多相互矛盾的信息，我还没有深入研究过这个问题来决定我认为什么是最好的。也许将来我会写一篇关于私有虚拟方法的最佳实践的文章。</p><h1 id="c498" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最终标识符</h1><p id="2bf3" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最终标识符(不是保留关键字，如override)指定不能在派生类中重写虚方法，或者不能继承类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1290" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们做了<em class="ly"> Base::speak final </em>。它不能被覆盖。这样做之后，在<em class="ly"> DA </em>中会出现一个错误，其中<em class="ly"> speak </em>当前被覆盖，表示<em class="ly"> Base::speak </em>不能被覆盖，因为它被标记为<em class="ly"> final </em>。</p><h1 id="ac5b" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最终否决者</h1><p id="1eaf" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如果没有其他方法覆盖虚拟成员方法，那么该方法就是最终的覆盖方法。最终覆盖符是虚拟方法，通过虚拟调用来执行。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="5899" class="mn ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">含糊</h2><p id="7b02" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当一个方法有不止一个<em class="ly"> final overrider </em>时，就会产生歧义。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="9fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，没有办法知道<em class="ly"> d.speak() </em>应该调用哪个方法，因为在<em class="ly"> B </em>和<em class="ly"> C </em>中都有继承的实现。这种由多重继承引起的模糊性被称为钻石问题。</p><h1 id="b1f3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">无意中隐藏了虚方法</h1><p id="120e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如果方法试图用不同的参数类型列表重写基类中的方法，它不会重写该方法。相反，它定义了一个单独的新方法，并隐藏了从基类继承的方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ly"> DA </em>无法覆盖<em class="ly"> Base::jump </em>，而是隐藏它并定义一个单独的<em class="ly"> jump </em>方法。为了让<em class="ly"> DA </em>访问<em class="ly"> Base::jump </em>它必须使用限定名查找来调用它(第40行)。</p><h1 id="9fdd" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">还有更多要讨论的</h1><p id="fed7" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这绝不是对C++中虚方法的彻底忽视。在以后的文章中，我的目标是讨论:</p><ul class=""><li id="d211" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">虚拟析构函数</li><li id="1e39" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">构造和破坏期间的虚拟方法</li><li id="1080" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">协变返回类型</li><li id="5ed9" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">纯虚拟方法</li></ul><p id="5b30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦完成，我会把上面的链接到这里。</p><h1 id="2ec7" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">参考</h1><p id="3ed7" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这篇文章的目的是提供一个对C++虚拟方法的更友好的观察，这些方法在下面的文档中有概述。</p><p id="2f0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mz" href="https://en.cppreference.com/w/cpp/language/final" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/final</a><br/>T3】https://en.cppreference.com/w/cpp/language/overrideT5<a class="ae mz" href="https://en.cppreference.com/w/cpp/language/virtual" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/virtual</a></p></div></div>    
</body>
</html>