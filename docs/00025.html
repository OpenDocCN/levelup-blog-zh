<html>
<head>
<title>The Magician’s Guide to Algorithms, part 3: The Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">魔术师算法指南，第3部分:二分搜索法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-3-the-binary-search-20ced57ba929?source=collection_archive---------0-----------------------#2017-10-23">https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-3-the-binary-search-20ced57ba929?source=collection_archive---------0-----------------------#2017-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq"><div class="bz fp l di"><div class="jr js l"/></div></figure><p id="d3a9" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">既然我们已经把昆汀·科尔德沃特的扑克牌整理好了，让我们来搜索一下。</p><p id="57c8" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated"><strong class="jv ir">二分搜索法</strong></p><p id="7113" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">这是你的咒语:</p><figure class="ks kt ku kv gt jq"><div class="bz fp l di"><div class="kw js l"/></div></figure><p id="9099" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">二分搜索法的概念非常简单。这就是所谓的电话簿方法。这意味着每当你查找一个电话号码时，你很可能从书的中间开始，把它分成两部分。一旦你把它分开，你就要看看你要找的名字是在那一页上，还是在后一页或前一页上。如果它在后面的一页上，你就翻到书的后半部分，再把它分成几份，这样一直到你找到你想要的名字的那一页。在二分搜索法也是一样。</p><p id="cbd3" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">首先，我们检查列表是否有长度。这很有用，因为我们递归地调用这个函数。如果我们找到了列表的最后一项，仍然找不到我们想要的特定项，我们希望它返回null。</p><p id="864c" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">如果我们的列表通过了第一个测试，那么我们就将<code class="fe kx ky kz la b">i</code>分配给<code class="fe kx ky kz la b">items.length/2</code>，实际上是将它一分为二。请记住，<code class="fe kx ky kz la b">Math.floor</code>只是为了让我们的指数保持在一个整数。</p><p id="201c" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">之后，我们用<code class="fe kx ky kz la b">list[i]</code>的元素测试我们的<code class="fe kx ky kz la b">item</code>，首先看看它们是否相等。如果是这样，我们简单地在<code class="fe kx ky kz la b">list[i]</code>返回元素。</p><p id="1d88" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">然后我们测试看<code class="fe kx ky kz la b">item</code>是否大于<code class="fe kx ky kz la b">list[i]</code>处的元素。这将告诉我们，我们正在搜索的元素可能在列表的后半部分，这就是为什么我们这次返回对<code class="fe kx ky kz la b">binarySearch()</code>的递归调用，只将列表的后半部分作为第一个参数，将<code class="fe kx ky kz la b">item</code>作为第二个参数。</p><p id="383e" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">如果<code class="fe kx ky kz la b">item</code>小于<code class="fe kx ky kz la b">list[i]</code>，我们可以递归检查列表的前半部分。</p><p id="abc0" class="pw-post-body-paragraph jt ju iq jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated"><strong class="jv ir">结论</strong> <br/>好了！昆汀·科尔德沃特现在也可以整理和搜索他的卡片了。一切都不费吹灰之力。下次见！</p><figure class="ks kt ku kv gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi lb"><img src="../Images/5c22f877e3667d57e16c52b36d1bf139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MLMarJf9vjgLOxD6"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">马库斯·温克勒在<a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div></div>    
</body>
</html>