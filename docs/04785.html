<html>
<head>
<title>Build a Custom URL Shortener Using Azure Functions and Cosmos DB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure函数和Cosmos DB构建一个定制的URL缩短器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-custom-url-shortener-using-azure-functions-and-cosmos-db-c20e59261375?source=collection_archive---------5-----------------------#2020-07-15">https://levelup.gitconnected.com/build-a-custom-url-shortener-using-azure-functions-and-cosmos-db-c20e59261375?source=collection_archive---------5-----------------------#2020-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/50a01af5eb05bb58db51f86fa2bc63f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4Ebfz9hExLKD75tOqxVpA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@maxdelsid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马克斯·德尔西德</a>在<a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="d7b8" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="398d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">本文描述了如何使用带有Azure函数和Cosmos DB的Azure无服务器平台构建自定义URL shortener服务。我在最近阅读了<a class="ae kf" href="https://jussiroine.com/2020/07/building-a-custom-url-shortener-service-using-azure-and-a-serverless-approach/" rel="noopener ugc nofollow" target="_blank"> Jussi Roine的文章</a>后有了这个想法，他在文章中使用无服务器的Azure方法构建了一个URL shortener服务(如<a class="ae kf" href="https://bitly.com/" rel="noopener ugc nofollow" target="_blank"> bit.ly </a>),这是一种由他领导的使用<a class="ae kf" href="https://azure.microsoft.com/en-us/services/logic-apps/" rel="noopener ugc nofollow" target="_blank"> Azure Logic Apps </a>和一个定制web应用程序的方法。当我在读他的文章时，我意识到用<a class="ae kf" href="https://azure.microsoft.com/en-us/services/functions/" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>和正确使用输入和输出绑定来构建相同的解决方案，可以产生一个非常优雅的解决方案。因此，我踏上了一段旅程，想看看这样的解决方案到底有多聪明。</p><p id="b2cf" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我还希望该解决方案具有高度可伸缩性，并在响应查询时实现非常低的延迟，因此我选择使用<a class="ae kf" href="https://azure.microsoft.com/en-us/services/cosmos-db/" rel="noopener ugc nofollow" target="_blank"> Azure Cosmos DB </a>作为存储解决方案。Cosmos DB是微软专有的全球分布式多模型数据库服务。Cosmos DB保证在第99百分位的读写延迟小于10ms，所以这是一个自然的选择。</p><h1 id="880f" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">要求</h1><p id="fe40" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">URL缩写服务应该有两个端点:</p><ol class=""><li id="61c2" class="mh mi it lg b lh mc ll md lp mj lt mk lx ml mb mm mn mo mp bi translated">一个URL注册端点，它允许客户端向它们的重定向目标注册缩短的URL(通常称为虚URL)。</li><li id="3928" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">URL重定向端点，web浏览器可以在这里使用虚荣心域发出<code class="fe mv mw mx my b">GET</code>请求，并接收到重定向到目标URL的请求。</li></ol><p id="de15" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">此外，如上所述，服务应该具有以下运行时质量:</p><ol class=""><li id="514d" class="mh mi it lg b lh mc ll md lp mj lt mk lx ml mb mm mn mo mp bi translated">响应重定向请求的延迟非常低。</li><li id="8b34" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">在请求吞吐量和地理可扩展性方面具有超高的可扩展性。</li><li id="48b8" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">运营成本相对较低，成本与请求吞吐量成比例。</li></ol><h1 id="82b2" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">解决方案</h1><p id="ab3d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了回答上面的需求，我决定采用下面的解决方案架构。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/b68b31dedeba7805cca638a0bdf93adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYefb3uqOE2D_AIgfUoszw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">URL缩写体系结构</figcaption></figure><p id="defd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">除了满足功能需求之外，这种架构还与期望的运行时质量保持一致。</p><ol class=""><li id="7e1f" class="mh mi it lg b lh mc ll md lp mj lt mk lx ml mb mm mn mo mp bi translated">Cosmos DB <a class="ae kf" href="https://docs.microsoft.com/en-us/azure/cosmos-db/introduction#guaranteed-low-latency-at-99th-percentile-worldwide" rel="noopener ugc nofollow" target="_blank">保证第99百分位的读取(索引)和写入的延迟</a>小于10ms，同时允许几乎无限的吞吐量(通过适当的扩展)。唯一可以改善这种延迟的机制是内存缓存，如<a class="ae kf" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>(或<a class="ae kf" href="https://azure.microsoft.com/en-us/services/cache/" rel="noopener ugc nofollow" target="_blank"> Azure Cache for Redis </a>)。然而，这确实需要额外的工作，因为仅靠Redis无法提供所需的持久性一致性。我们可以将Redis作为缓存机制和Cosmos DB作为持久性结合起来，从而两全其美；然而，这超出了本文的范围。</li><li id="91f6" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">只需点击一个按钮，我们就可以在<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/cosmos-db/how-to-multi-master" rel="noopener ugc nofollow" target="_blank">多个地区</a>快速部署Cosmos DB，在全球范围内扩展我们的数据。</li><li id="dc41" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">Azure Functions是一个轻量级的解决方案，开销很小。Azure Functions(以及几乎所有无服务器平台)唯一的缺点是<a class="ae kf" href="https://azure.microsoft.com/en-us/blog/understanding-serverless-cold-start/" rel="noopener ugc nofollow" target="_blank">冷启动时间</a>，这可能会很长。然而，高级和专用托管计划解决了Azure上的这个问题(以增加财务费用为代价)。</li><li id="1bd4" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">Cosmos DB和Azure函数都可以从低成本开始，随着所需吞吐量的增加而增加支出。</li></ol><h1 id="46f1" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">宇宙数据库</h1><p id="00d7" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要使用Cosmos DB，您可以使用<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/cosmos-db/local-emulator" rel="noopener ugc nofollow" target="_blank"> Cosmos DB模拟器</a>(仅在Windows上)或<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/cosmos-db/create-cosmosdb-resources-portal" rel="noopener ugc nofollow" target="_blank">在Azure </a>上创建一个Cosmos DB帐户。Cosmos DB提供了一个免费层，适合我们的网址缩写。无论您选择哪种方式，请注意Cosmos DB连接字符串，因为您将需要它来配置我们即将实现的Azure功能。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/915ac2ce67579940ad38e1b0fc3d5bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tKjqAXXVqwwk7hM-rP2rQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Cosmos DB仿真器</figcaption></figure><h1 id="f037" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Azure函数</h1><h2 id="0aac" class="nf kh it bd ki ng nh dn km ni nj dp kq lp nk nl ku lt nm nn ky lx no np lc nq bi translated">创建函数应用程序</h2><p id="580a" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">创建Azure Functions App的方法有很多，支持的语言有多种<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages" rel="noopener ugc nofollow" target="_blank"/>。对于我的实现，我选择使用Node.js和使用Visual Studio代码的JavaScript。要引导应用程序，您可以遵循方便的<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-function-vs-code?pivots=programming-language-javascript" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>。我使用以下输入来响应VSCode扩展提示:</p><ul class=""><li id="4818" class="mh mi it lg b lh mc ll md lp mj lt mk lx ml mb nr mn mo mp bi translated">语言:<em class="ns"> JavaScript </em></li><li id="1fdb" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb nr mn mo mp bi translated">模板:<em class="ns"> HTTP触发器</em></li><li id="0fac" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb nr mn mo mp bi translated">函数名:<em class="ns">寄存器</em></li><li id="a3e1" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb nr mn mo mp bi translated">授权级别:<em class="ns">匿名</em>(这对于演示来说很好，但是对于生产来说，你可以使用<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook-trigger?tabs=csharp#authorization-keys" rel="noopener ugc nofollow" target="_blank">功能键</a>或者<a class="ae kf" href="https://docs.microsoft.com/en-us/azure/app-service/overview-authentication-authorization" rel="noopener ugc nofollow" target="_blank"> EasyAuth </a></li></ul><p id="26fd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">该扩展现在应该创建一个名为“注册”的基本“Hello World”风格的功能应用程序您可以通过按F5调试应用程序或从终端窗口启动<code class="fe mv mw mx my b">npm start</code>来启动应用程序。这两个选项都应该启动Azure Functions运行时，并允许您测试您的应用程序。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/8c8bd1ee6eb50e7d19c8e522c7fa8a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fio6rMh2tAOhGZWGaCde4A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">初始工作空间与代码工作空间</figcaption></figure><p id="0a82" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">您可以通过从工作区的根文件夹执行以下命令来测试该函数是否正常运行:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="84fd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一旦一切正常，就可以删除<code class="fe mv mw mx my b">sample.dat</code>文件了。</p><h2 id="eb5d" class="nf kh it bd ki ng nh dn km ni nj dp kq lp nk nl ku lt nm nn ky lx no np lc nq bi translated">配置Cosmos数据库</h2><p id="3ab9" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要配置Cosmos DB，编辑<code class="fe mv mw mx my b">local.settings.json</code>文件并添加以下连接字符串:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ed31" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">代码片段中的连接字符串对应于Cosmos DB模拟器。如果您在Azure中创建了一个Cosmos DB帐户，那么您应该将连接字符串替换为您创建的Cosmos DB实例上的门户中可用的连接字符串。</p><h2 id="758b" class="nf kh it bd ki ng nh dn km ni nj dp kq lp nk nl ku lt nm nn ky lx no np lc nq bi translated">自定义路由前缀</h2><p id="9ac6" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">默认情况下，Azure Functions运行时会给所有HTTP触发路由加上前缀<code class="fe mv mw mx my b">/api</code>。因为我们想保持URL的简短(这是一个URL <strong class="lg iu"> shortener </strong>服务…)，我们需要删除这个前缀。</p><p id="232a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">幸运的是，可以通过编辑<code class="fe mv mw mx my b">host.json</code>文件并添加以下配置来定制前缀。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="aa46" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">此配置将默认路由前缀设置为空字符串，实际上是将其删除。</p><h2 id="0a92" class="nf kh it bd ki ng nh dn km ni nj dp kq lp nk nl ku lt nm nn ky lx no np lc nq bi translated">创作URL注册端点</h2><p id="24c3" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先，我们将配置<code class="fe mv mw mx my b">function.json</code>文件中的函数绑定，如下所示:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="65fd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们将这个定义分解成几个部分:</p><ol class=""><li id="5e30" class="mh mi it lg b lh mc ll md lp mj lt mk lx ml mb mm mn mo mp bi translated">第4–9行定义了HTTP触发器。我们正在定义一个将<code class="fe mv mw mx my b">POST</code>请求匹配到<code class="fe mv mw mx my b">/register</code>端点的路由。然后，该请求在<code class="fe mv mw mx my b">req</code>对象上可用。</li><li id="0425" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">第12–14行定义了HTTP响应输出，由返回对象的属性<code class="fe mv mw mx my b">res</code>分配。</li><li id="45be" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">第17–25行是有趣的地方。这些行定义了一个输出绑定，它将返回对象的属性<code class="fe mv mw mx my b">registration</code>绑定到Cosmos DB数据库集合中的一个文档。因此，我们的函数分配给<code class="fe mv mw mx my b">registration</code>属性的任何对象都被自动放置到DB中，而无需编写任何与Cosmos DB相关的代码。我们稍后将使用这个文档来重定向传入的请求。此外，绑定定义了如果数据库或集合不存在，将为我们自动创建它们。相当整洁！</li></ol><p id="0f3a" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一旦所有绑定就绪，函数本身就非常简单:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="845c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们期待一个带有两个字符串属性的请求体— <code class="fe mv mw mx my b">url</code>和<code class="fe mv mw mx my b">vanity</code>。如果这些属性存在，我们将返回一个注册对象(通过绑定输出到数据库)和一个成功的HTTP响应。否则，返回一个<code class="fe mv mw mx my b">400 bad request</code>响应。</p><h2 id="15a6" class="nf kh it bd ki ng nh dn km ni nj dp kq lp nk nl ku lt nm nn ky lx no np lc nq bi translated">添加URL重定向端点</h2><p id="fd8f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">一旦我们在数据库中注册了虚荣心URL，最后一件事就是编写重定向逻辑本身。首先，让我们看看函数绑定。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ol class=""><li id="bedd" class="mh mi it lg b lh mc ll md lp mj lt mk lx ml mb mm mn mo mp bi translated">第4–9行定义了HTTP触发器。我们正在设置一个通配符路由，它将<code class="fe mv mw mx my b">GET</code>请求匹配到函数应用程序域中的任意<strong class="lg iu">端点。我们还在一个名为<code class="fe mv mw mx my b">vanity</code>的变量中捕获了路由路径，我们稍后会用到它。这部分是魔术发生的地方。</strong></li><li id="4bac" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">第12-21行是魔法继续的地方。这些行定义了一个Cosmos DB输入绑定，对于每个请求，它自动获取id为<code class="fe mv mw mx my b">vanity</code>的文档。您还记得，这是从请求路径中提取的一个变量，它与<code class="fe mv mw mx my b">register</code>函数中的输出绑定所使用的标识符相匹配。因此，用虚拟URL <code class="fe mv mw mx my b">myvanity</code>注册生成一个id为<code class="fe mv mw mx my b">myvanity</code>的文档，该文档被输出到数据库中。当通过在<code class="fe mv mw mx my b">http://domain/myvanity</code>上执行<code class="fe mv mw mx my b">GET </code>请求重定向时，从DB中获取相同的文档，并且该函数可以重定向到它。甜美优雅，在我看来。</li><li id="226d" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb mm mn mo mp bi translated">第24–26行简单地定义了HTTP输出属性名。</li></ol><p id="6853" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">一旦绑定就绪，代码本身也很简单:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="948e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">如果在数据库中找到匹配的文档，则发送重定向。否则，返回一个<code class="fe mv mw mx my b">404 Not Found</code>错误。</p><h1 id="184f" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">测试解决方案</h1><p id="345a" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">要测试注册过程，您可以发出以下命令:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="31fb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">确保你注册后得到一个成功的<code class="fe mv mw mx my b">204 No Content</code>响应，和一个<code class="fe mv mw mx my b">302 Found</code>响应虚荣心URL请求。</p><h1 id="05fb" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="e6ca" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">无服务器平台提供了一种舒适的机制，以一种简单、经济的方式实现简单的API。聪明地使用Azure函数绑定允许我们实现高度的复杂性，同时保持我们需要编写的绑定特定代码最少。Cosmos DB作为一个易于使用但功能强大的文档数据库平台完善了解决方案。总之，我们看到了如何利用这些平台来优雅地实现一个定制的URL shortener服务。</p><p id="985b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">感谢您花时间阅读这篇文章。请在下面给我留言。非常感谢您的反馈。</p><h1 id="df55" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">资源</h1><p id="783c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">以下是附加资源:</p><ul class=""><li id="6a64" class="mh mi it lg b lh mc ll md lp mj lt mk lx ml mb nr mn mo mp bi translated"><a class="ae kf" href="https://github.com/estiller/azure-functions-url-shortener" rel="noopener ugc nofollow" target="_blank">样本源代码</a></li><li id="a8ea" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb nr mn mo mp bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-node" rel="noopener ugc nofollow" target="_blank"> Azure Functions JavaScript开发者指南</a></li><li id="ecd1" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb nr mn mo mp bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-function-vs-code" rel="noopener ugc nofollow" target="_blank">快速入门:使用Visual Studio代码在Azure中创建一个函数</a></li><li id="59af" class="mh mi it lg b lh mq ll mr lp ms lt mt lx mu mb nr mn mo mp bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings" rel="noopener ugc nofollow" target="_blank"> Azure函数触发器和绑定概念</a></li></ul></div></div>    
</body>
</html>