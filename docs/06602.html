<html>
<head>
<title>Build an Xbox Controller Abstraction Layer in Python Using XInput API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用XInput API在Python中构建一个Xbox控制器抽象层</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-an-xbox-controller-abstraction-layer-in-python-using-xinput-api-e971fe4adce8?source=collection_archive---------11-----------------------#2020-12-10">https://levelup.gitconnected.com/build-an-xbox-controller-abstraction-layer-in-python-using-xinput-api-e971fe4adce8?source=collection_archive---------11-----------------------#2020-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c521" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者:如何用夸张的代码量实现简单的目标—第3部分</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f8b9df5c853a1a5b404f110f27a4980f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CrJFJsOxQPRVL5F1"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">马尔科·布拉泽维奇在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e94a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/build-an-xbox-controller-abstraction-layer-in-python-using-xinput-api-f6d0c716adf">教程的最后一部分</a>。您将学习如何:</p><ul class=""><li id="6485" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">检测输入。</li><li id="2b2b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">获取触发器和thumbs原始值和规范化值。</li><li id="1144" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">处理振动。</li></ul><p id="451c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然前面的部分目前可能很平凡，但这一部分几乎完全是代码。让我们看看我们有什么。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="1ce8" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">手柄按钮</h1><p id="21d3" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">要检查按钮是否被按下，您必须引用控制器状态。这里只有一个方法:</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="05d6" class="nf ly iq nb b gy ng nh l ni nj">def is_button_press(self, button):<br/>    if button not in self.BUTTONS:<br/>        raise Exception('Invalid button. Got: "{}"'.format(button))<br/>    return bool(self.BUTTONS[button] &amp; self.gamepad.wButtons)</span></pre><ul class=""><li id="c9a2" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">如果收到的参数不是按钮，则引发异常。</li><li id="2295" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">使用按位<a class="ae lb" href="https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations" rel="noopener ugc nofollow" target="_blank">和</a>操作检查按钮是否被按下，并相应地返回一个响应。</li></ul><p id="fd02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你第一次使用位运算，请注意。<code class="fe nk nl nm nb b">XInputGamepad</code>字段的<code class="fe nk nl nm nb b">wButtons</code>是一个<a class="ae lb" href="https://en.wikipedia.org/wiki/Bitmap" rel="noopener ugc nofollow" target="_blank">位图</a>，包含所有被按下(和未被按下)的按钮。假设游戏手柄上只有<strong class="jp ir"> X </strong>、<strong class="jp ir"> Y </strong>、<strong class="jp ir"> A </strong>和<strong class="jp ir"> B </strong>按钮。你<em class="nn">把它们打包成4位，每一位代表按钮状态。假设<code class="fe nk nl nm nb b">wButtons</code>值被设置为<code class="fe nk nl nm nb b">0011</code>。显示<strong class="jp ir"> A </strong>和<strong class="jp ir"> B </strong>按钮被按下，而<strong class="jp ir"> X </strong>和<strong class="jp ir"> Y </strong>没有被按下。想象一下<strong class="jp ir"> A </strong>按钮用二进制数<code class="fe nk nl nm nb b">0001</code>来表示，在十进制中就是<code class="fe nk nl nm nb b">1</code>。<a class="ae lb" href="https://en.wikipedia.org/wiki/Bitwise_operation#AND" rel="noopener ugc nofollow" target="_blank">和</a>操作检查是否是图案的一部分(<code class="fe nk nl nm nb b">0011</code>)。因为两者的<a class="ae lb" href="https://en.wikipedia.org/wiki/Bit_numbering#Least_significant_bit" rel="noopener ugc nofollow" target="_blank">最低有效位</a>的值都是<code class="fe nk nl nm nb b">1</code>，所以<code class="fe nk nl nm nb b">is_button_press</code>方法会返回<code class="fe nk nl nm nb b">True</code>(任何不为零的整数被强制转换为<code class="fe nk nl nm nb b">bool</code>就是<code class="fe nk nl nm nb b">True</code>)。</em></p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="3039" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">手柄轴</h1><p id="ac95" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">拇指和扳机的行为非常相似。这主要是语义上的——你按下扳机，但移动拇指。</p><h2 id="3586" class="nf ly iq bd lz no np dn md nq nr dp mh jy ns nt ml kc nu nv mp kg nw nx mt ny bi translated">获取轴值</h2><p id="9665" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">由于您将触发器和拇指都视为轴，因此很容易获取它们的状态:</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="5c7f" class="nf ly iq nb b gy ng nh l ni nj">def get_axis_value(self, axis):<br/>    if axis not in self.AXES:<br/>        raise Exception('Invalid axis, Got: {}'.format(axis))<br/>    return getattr(self.gamepad, self.AXES[axis])</span></pre><ul class=""><li id="be6e" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">使用<code class="fe nk nl nm nb b">self.AXES</code>映射获得一个可由<code class="fe nk nl nm nb b">XInputGamepad</code>结构识别的键。</li><li id="d3ca" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">使用<a class="ae lb" href="https://docs.python.org/3/library/functions.html#getattr" rel="noopener ugc nofollow" target="_blank">反射</a>来确定要获取哪个值。</li></ul><p id="b1e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单，但是有一个细节需要注意。触发器返回值的范围是从<code class="fe nk nl nm nb b">-128</code>到<code class="fe nk nl nm nb b">127</code>，不方便。这也是不对的。根据<a class="ae lb" href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/ns-xinput-xinput_gamepad" rel="noopener ugc nofollow" target="_blank">文件</a>，触发器应在<code class="fe nk nl nm nb b">0 - 255</code>范围内运行。让我们编写一些额外的方法来解决这个问题:</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="c55b" class="nf ly iq nb b gy ng nh l ni nj">def get_trigger_value(self, trigger):<br/>    return self.get_axis_value(trigger) &amp; 0xFF<br/><br/>def get_thumb_value(self, thumb):<br/>    return self.get_axis_value(thumb)</span></pre><ul class=""><li id="0eb9" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">对于触发器，使用按位AND运算。十六进制的<code class="fe nk nl nm nb b">0xFF</code>就是十进制的<code class="fe nk nl nm nb b">255</code>。这样，你就摆脱了消极的价值观。</li><li id="02d2" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">保持获取拇指值不变。这很重要，因为负值会产生关于方向的重要信息。</li></ul><h2 id="c946" class="nf ly iq bd lz no np dn md nq nr dp mh jy ns nt ml kc nu nv mp kg nw nx mt ny bi translated">获取标准化值</h2><p id="0341" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">我最初编写脚本是为了将鼠标和键盘事件映射到游戏手柄。它迫使我引入一些规范化。我不能操作成千上万个单元。我需要更接近<code class="fe nk nl nm nb b">default.ini</code>中指定的灵敏度范围的东西。我想到了以下方法(和一些助手):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7653" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此处的助手:</p><ul class=""><li id="298e" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe nk nl nm nb b">get_magnitude</code>简单读取包含轴大小的类变量。</li><li id="83d6" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><code class="fe nk nl nm nb b">get_sensitivity</code>从<code class="fe nk nl nm nb b">default.ini</code>获取作为参数提供的轴的轴灵敏度。</li></ul><p id="d1d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是标准化:</p><ul class=""><li id="99c2" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">如果提供了无效的轴，则引发异常。</li><li id="37bf" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">轴字符串为<code class="fe nk nl nm nb b">LEFT-OR-RIGHT_AXIS-TYPE_OPTIONAL-DIRECTION</code>格式。例如，如果你提供<code class="fe nk nl nm nb b">LEFT_THUMB_X</code>作为参数，在<code class="fe nk nl nm nb b">_</code>上分割后，你会得到一个<code class="fe nk nl nm nb b">['LEFT', 'THUMB', 'X']</code>列表。轴类型将始终是索引为1的列表元素。</li><li id="d751" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">这就是事情变得有点棘手的地方。使用<code class="fe nk nl nm nb b">axis_type</code>，您可以引用<code class="fe nk nl nm nb b">get_trigger_value</code>或<code class="fe nk nl nm nb b">get_thumb_value</code>方法。然后调用它，提供原始的轴参数。</li><li id="d552" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">返回标准化值。</li></ul><h2 id="91a8" class="nf ly iq bd lz no np dn md nq nr dp mh jy ns nt ml kc nu nv mp kg nw nx mt ny bi translated">检测变化</h2><p id="0fc9" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">关于轴的最后一件事是检测偏差。因为它对标准化值进行操作，所以您可以在配置中设置百分比死区，这很方便:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7d96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">助手:</p><ul class=""><li id="2150" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">这里没什么——只有死亡地带。</li></ul><p id="ef3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变化检测:</p><ul class=""><li id="3812" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">如果提供了无效的轴，则引发异常。</li><li id="430b" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">得到规范化<code class="fe nk nl nm nb b">axis_value</code>。现在，你需要确定方向是否正确。如果您提供了<code class="fe nk nl nm nb b">-X</code>或<code class="fe nk nl nm nb b">-Y</code>轴，则<code class="fe nk nl nm nb b">axis_value</code>必须为负。这样你<em class="nn">事实上</em>把一个轴当作两个独立的轴——一个代表正值，一个代表负值。这样你就可以将一个动作映射到每个主要的拇指方向。</li><li id="4d01" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">比较<code class="fe nk nl nm nb b">axis_value</code>和<code class="fe nk nl nm nb b">dead_zone</code>。如果它大于死区，这意味着已经检测到移动。</li></ul><p id="36d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些，您可以添加专用函数，只是为了保持API的一致性:</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="2163" class="nf ly iq nb b gy ng nh l ni nj">def is_thumb_move(self, thumb):<br/>    return self.is_axis_change(thumb)<br/><br/>def is_trigger_press(self, trigger):<br/>    return self.is_axis_change(trigger)</span></pre></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="7b0a" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">震动</h1><p id="aa14" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">有两种振动变量可以设置:</p><ul class=""><li id="d653" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">手动—切换模式。电机无限期启动，必须手动停止。</li><li id="fbda" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/debounce-in-javascript-improve-your-applications-performance-5b01855e086">去抖</a> —直到发出信号，电机才会停止。API负责阻止它们。</li></ul><p id="ddc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能只需要这些方法中的一种，但我会介绍这两种方法，以防万一。</p><h2 id="a17a" class="nf ly iq bd lz no np dn md nq nr dp mh jy ns nt ml kc nu nv mp kg nw nx mt ny bi translated">手动振动</h2><p id="6a71" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">您需要利用<a class="ae lb" href="https://docs.microsoft.com/en-us/windows/win32/api/xinput/nf-xinput-xinputsetstate" rel="noopener ugc nofollow" target="_blank"> XInputSetState </a>函数和您在教程的第一部分中创建的XInputVibration结构:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nz oa l"/></div></figure><ul class=""><li id="f5a9" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">健全检查。电机速度必须用百分比表示。这是一种正常化的方式。</li><li id="b55e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">使用标准化电机速度创建<code class="fe nk nl nm nb b">XInputVibration</code>结构。</li><li id="c3e7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">为给定的游戏手柄设置振动。</li></ul><p id="022e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你现在启动马达，你会发现它们不会停止，除非你拔掉控制器。你需要一种方法来引入一些持续时间:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nz oa l"/></div></figure><ul class=""><li id="c567" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">在给定的时间内睡眠。</li><li id="e187" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">将电机速度设置为<code class="fe nk nl nm nb b">0</code>，有效禁用电机。</li><li id="d39d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">关闭<code class="fe nk nl nm nb b">vibration_process</code>。在手动模式下这是多余的，但在去抖模式下将是至关重要的。</li></ul><p id="c84d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好多了。但是，如果您关闭了脚本，却忘记了触发<code class="fe nk nl nm nb b">disable_vibration</code>方法，该怎么办呢？没什么，因为你已经定义了一个析构函数:</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="e833" class="nf ly iq nb b gy ng nh l ni nj">def __del__(self):<br/>    self.disable_vibration()</span></pre><ul class=""><li id="131a" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe nk nl nm nb b">disable_vibration</code>方法在没有参数的情况下被调用，这意味着<code class="fe nk nl nm nb b">duration</code>参数默认为<code class="fe nk nl nm nb b">0</code>，这将立即停止电机。</li></ul><h2 id="8a61" class="nf ly iq bd lz no np dn md nq nr dp mh jy ns nt ml kc nu nv mp kg nw nx mt ny bi translated">去抖振动</h2><p id="281f" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果我错了，请纠正我，但是根据我的观察，去抖动函数在Python中并不是一种常见的模式。由于它们的性质，它们在JavaScript社区中更受欢迎。有几种方法可以实现这种行为。我选择了基于过程的方法:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nz oa l"/></div></figure><ul class=""><li id="4971" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">像平常一样设置振动。</li><li id="a554" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">终止一个活动的<code class="fe nk nl nm nb b">vibration_process</code>——如果它已经产生。它负责去抖。</li><li id="2849" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">在单独的进程中运行<code class="fe nk nl nm nb b">disable_vibration</code>方法。</li></ul></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="e59c" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">把所有的放在一起</h1><p id="6d1a" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">API完成了。最后一个合乎逻辑的步骤是测试脚本。让我们来处理它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nz oa l"/></div></figure><ul class=""><li id="18a7" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">初始化<code class="fe nk nl nm nb b">XInput</code>类。</li><li id="a435" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">如果没有检测到变化，打印先前的状态，等待200毫秒，然后<code class="fe nk nl nm nb b">cls</code>控制台。</li><li id="213d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">如果检测到拇指或触发器移动，更新<code class="fe nk nl nm nb b">output</code>字典中的条目。如果没有，就归零。</li><li id="7b7f" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">按钮几乎是一样的，但是你设置了一个短时间的振动。</li><li id="cddd" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">打印<code class="fe nk nl nm nb b">output</code>。</li></ul><p id="74c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">蚂蚁就是这样！检查是否一切顺利:</p><pre class="km kn ko kp gt na nb nc nd aw ne bi"><span id="c2fd" class="nf ly iq nb b gy ng nh l ni nj">python xinput.py</span></pre><p id="559a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该得到以下输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/7567df7ae7ce21e836de8a3934f54680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BV0TOlgAjBhrwGCA7Ii9-Q.png"/></div></div></figure><p id="e181" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按下<code class="fe nk nl nm nb b">Ctrl + C</code>关闭脚本。恭喜你！</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="bb4d" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">最后的话</h1><p id="5d86" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">感谢阅读！</p><p id="f7f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在我的<a class="ae lb" href="https://github.com/izdwuut/xbox-mapper-tutorial/tree/main" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的代码。</p></div></div>    
</body>
</html>