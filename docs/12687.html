<html>
<head>
<title>Pointers Made Easy In C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C语言中使指针变得容易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pointers-in-c-made-easy-dd26c7427f1d?source=collection_archive---------6-----------------------#2022-06-30">https://levelup.gitconnected.com/pointers-in-c-made-easy-dd26c7427f1d?source=collection_archive---------6-----------------------#2022-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9f2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">先从学习电脑内存开始吧。</p><h1 id="cc65" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">记忆基础</h1><p id="31ec" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当程序运行时，计算机需要保留一块内存。</p><p id="4a30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">计算机的操作系统完成这项任务，它在RAM中为程序分配一些临时内存。</p><ol class=""><li id="ab45" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">内存的基本单位是一个<strong class="js iu">字节</strong>。</li><li id="b499" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">每个字节都有一个与之相关的地址。<br/>这用以0x开始的十六进制表示，即0xacfe24</li><li id="556b" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">不同类型的变量占用不同的内存大小。</li></ol><ul class=""><li id="6e6c" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn mf lx ly lz bi translated">字符:1字节</li><li id="d2c5" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">int: 4个字节</li><li id="d2c4" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">浮点型:4字节</li><li id="5d40" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">double: 8字节</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/f54c66425e6219d56369a3c5349667b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nfWpZo-Y8JvSCqrD"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">杰里米·贝赞格在<a class="ae mw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="808f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">程序存储器的结构</h1><p id="864d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">程序存储器分为3个部分:</p><ol class=""><li id="3701" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">栈存储器</li><li id="0efb" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">堆内存</li><li id="cb46" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">存储器的代码部分</li></ol><h2 id="7d32" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">栈存储器</h2><ul class=""><li id="930f" class="lr ls it js b jt lm jx ln kb nj kf nk kj nl kn mf lx ly lz bi translated">它遵循<strong class="js iu">费罗原则</strong>(先进后出；首先存储的元素将在最后被访问)</li><li id="0ca2" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">它是高度有序的</li><li id="efdc" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">它临时存储由函数创建的变量。</li><li id="4a20" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">当一个变量被创建时，它被存储在堆栈中。一旦函数执行结束，这个内存空间就会被释放。</li><li id="d0a7" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">这是由编译器在编译期间(即运行时之前)执行的。这叫做<strong class="js iu">编译期/ </strong> <strong class="js iu">静态内存分配</strong>。</li></ul><h2 id="0b72" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">堆内存</h2><ul class=""><li id="3601" class="lr ls it js b jt lm jx ln kb nj kf nk kj nl kn mf lx ly lz bi translated">它是比堆栈更少的有序内存空间</li><li id="52f3" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">它可以由程序员在程序执行时分配。这叫做<strong class="js iu">运行时/动态堆分配</strong>。</li><li id="aed6" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">堆中分配的内存不会自动释放，程序员必须显式地这样做，以避免<strong class="js iu">内存泄漏</strong>。</li><li id="a523" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn mf lx ly lz bi translated">C语言中的<code class="fe nm nn no np b">stdlib</code>库提供了以下函数来与堆内存交互:</li></ul><ol class=""><li id="fefc" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated"><code class="fe nm nn no np b">malloc()</code>:用于在堆内存中分配特定的字节数</li><li id="faf4" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated"><code class="fe nm nn no np b">calloc()</code>:根据不同数据类型的变量数量来分配堆内存</li><li id="b9d7" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated"><code class="fe nm nn no np b">realloc()</code>:用于收缩或扩展之前用<code class="fe nm nn no np b">malloc()</code>或<code class="fe nm nn no np b">calloc()</code>分配的内存</li><li id="fa33" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated"><code class="fe nm nn no np b">free()</code>:用于释放之前分配的内存</li></ol><h2 id="813c" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">代码部分</h2><p id="2b35" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">程序执行指令存储在存储器的这一部分。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nq"><img src="../Images/2a4bf0f140fd621006fdd5b9eb845b12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nYMq0WQqx1vBt84P"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">照片由<a class="ae mw" href="https://unsplash.com/@amandagraphc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿曼达·琼斯</a>在<a class="ae mw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="8d43" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">什么是指针？</h1><p id="2629" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">指针是一种特殊类型的整数变量。它存储一个变量的内存地址(指针所指向的)。</p><p id="19d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在C语言中，指针可以帮助你直接操作内存。</p><p id="57e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在Python和Javascript这样的高级语言中是不可能的。</p><h1 id="88fe" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">定义指针</h1><p id="b612" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当一个变量被定义时，一个连续的内存块被保留给它。</p><p id="2811" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个指针可以指向这个内存块的第一个字节。</p><p id="1b8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以使用以下语法定义指针:</p><blockquote class="nr ns nt"><p id="4bdb" class="jq jr nu js b jt ju jv jw jx jy jz ka nv kc kd ke nw kg kh ki nx kk kl km kn im bi translated">数据类型*指针名称</p></blockquote><p id="27d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者</p><blockquote class="nr ns nt"><p id="1826" class="jq jr nu js b jt ju jv jw jx jy jz ka nv kc kd ke nw kg kh ki nx kk kl km kn im bi translated">数据类型*指针名称</p></blockquote><p id="a25f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举个例子，</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="9d52" class="mx kp it np b gy oc od l oe of">char* myPointer;</span></pre><p id="1b50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个名为<code class="fe nm nn no np b">myPointer</code>(初始化为<code class="fe nm nn no np b">null</code>)的指针，指向一个字符。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi og"><img src="../Images/311ef9a53417fed604524f1d774e05bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pbw2XYSZnmF9AKRH"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">丹尼尔·塔纳塞<a class="ae mw" href="https://unsplash.com/@danielvtanase?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae mw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7da8" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">给指针分配地址</h1><p id="b88b" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了给指针分配一个内存地址，我们使用了<strong class="js iu">引用操作符(&amp;)。</strong></p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="49c6" class="mx kp it np b gy oc od l oe of">char favoriteLetter = 'a';</span><span id="56a2" class="mx kp it np b gy oh od l oe of">char* myPointer = <strong class="np iu">&amp;</strong>favoriteLetter; //Assigns address of 'favoriteLetter' to 'myPointer'</span></pre><p id="7d66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nm nn no np b"><strong class="js iu">&amp;</strong>favoriteLetter</code>告知变量<code class="fe nm nn no np b">favoriteLetter</code>的内存地址</p><h2 id="53ed" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">注意事项</h2><ol class=""><li id="6a68" class="lr ls it js b jt lm jx ln kb nj kf nk kj nl kn lw lx ly lz bi translated">指针中分配的地址不是常数。</li><li id="f3c2" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">只要变量的数据类型相同，指针就可以被重新分配给另一个变量地址。</li></ol><h1 id="4947" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">打印指针的值</h1><p id="9c29" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">指针的地址可以打印如下:</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="81e2" class="mx kp it np b gy oc od l oe of">printf("%p", myPointer);</span><span id="6345" class="mx kp it np b gy oh od l oe of">//This will print a hexadecimal address</span></pre><h1 id="0b9f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">访问指针指向的数据</h1><p id="12f3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这可以通过使用以下语法使用<strong class="js iu">解引用操作符(*) </strong>来完成:</p><blockquote class="nr ns nt"><p id="f910" class="jq jr nu js b jt ju jv jw jx jy jz ka nv kc kd ke nw kg kh ki nx kk kl km kn im bi translated">*指针名称</p></blockquote><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="de30" class="mx kp it np b gy oc od l oe of">printf("%p", *myPointer);</span><span id="15f8" class="mx kp it np b gy oh od l oe of">//Prints the data pointed by 'myPointer'</span></pre><h1 id="15e7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">重新分配指针地址</h1><p id="c098" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们将创建另一个名为<code class="fe nm nn no np b">firstLetter</code>的变量，并使用<strong class="js iu">引用操作符(&amp; ) </strong>重新分配我们的指针指向这个变量的内存地址。</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="2495" class="mx kp it np b gy oc od l oe of">char firstLetter = 'x';</span><span id="36ba" class="mx kp it np b gy oh od l oe of">myPointer = &amp;firstLetter;</span><span id="88a5" class="mx kp it np b gy oh od l oe of">printf("%p", myPointer); //Prints the memory address to variable 'firstLetter'</span></pre><h1 id="064e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">重新分配指针指向的值</h1><p id="63fb" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">这可以通过以下方式完成:</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="bdf7" class="mx kp it np b gy oc od l oe of">*myPointer = 'c';</span><span id="c0d3" class="mx kp it np b gy oh od l oe of">//Reassigns the memory address's value to 'c'</span></pre><p id="c137" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将使<code class="fe nm nn no np b">firstLetter</code>的值变为<code class="fe nm nn no np b">'c'</code>。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oi"><img src="../Images/c8377e50b712dfa2875cc87dfc9d8466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x8EUby0rlInX7rFB"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">照片由<a class="ae mw" href="https://unsplash.com/@jantined?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jantine Doornbos </a>在<a class="ae mw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="54e6" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">指针上的算术运算</h1><p id="c7a3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">整数的加减可以在指针上完成。</p><blockquote class="nr ns nt"><p id="1272" class="jq jr nu js b jt ju jv jw jx jy jz ka nv kc kd ke nw kg kh ki nx kk kl km kn im bi translated">注意:两个指针不能相加或相减。</p></blockquote><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="a16e" class="mx kp it np b gy oc od l oe of">myPointer += 1; //Valid<br/>myPointer -= 4; //Valid<br/>myPointer *= 3; //Invalid<br/>myPointer /= 2; //Invalid</span><span id="be8a" class="mx kp it np b gy oh od l oe of">myPointer += myPointer //Invalid<br/>myPointer -= myPointer //Invalid<br/>myPointer *= myPointer //Invalid<br/>myPointer /= myPointer //Invalid</span></pre><h2 id="1406" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">指向注释</h2><p id="8a82" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">将整数<code class="fe nm nn no np b">n</code>加到指针上会将指针的地址值移动一段距离:<code class="fe nm nn no np b">n</code> *(指针所指向的数据类型的大小，以字节为单位)</p><p id="bef9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果一个整数<code class="fe nm nn no np b">2</code>被加到一个指向双精度的指针上，在地址<strong class="js iu"> 100 </strong>，指针的新地址将是:<code class="fe nm nn no np b">2</code> *字节大小<code class="fe nm nn no np b">double</code>，即8。</p><p id="0eca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相加后的新值将是<strong class="js iu"> 116 </strong>。</p><h1 id="9681" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">对数组使用指针</h1><p id="4bcd" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">指针可以指向数组中的值。</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="60e5" class="mx kp it np b gy oc od l oe of">int my_array[3] = {0,1,2};</span></pre><p id="cec5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了初始化一个指向索引<code class="fe nm nn no np b">1</code>的指针，我们可以使用下面的语法:</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="7da7" class="mx kp it np b gy oc od l oe of">int* array_pointer = &amp;my_array[1];</span></pre><h1 id="8132" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">在循环中使用指针</h1><p id="ca58" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">数组的值可以用指针更新，如下所示:</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="2982" class="mx kp it np b gy oc od l oe of">int my_array[5] = {0,1,2,3,4};</span><span id="ba34" class="mx kp it np b gy oh od l oe of">int* array_pointer = &amp;my_array[0]; //Setting the pointer to index 0 of 'my_array'</span><span id="84a4" class="mx kp it np b gy oh od l oe of">for(int i=0; i &lt;= 5; i++){<br/>    *array_pointer = 0;<br/>    array_pointer++;<br/>}; //Setting all values in the array to be 0</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oj"><img src="../Images/bc329565d8b49060029ee80ab3409797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1qH0ikrLLWPVcvcw"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">照片由<a class="ae mw" href="https://unsplash.com/@onderortel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德·奥尔特尔</a>在<a class="ae mw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8f14" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">在函数中使用指针</h1><p id="a462" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">指针可以作为参数传递给函数，如下所示:</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="d0a2" class="mx kp it np b gy oc od l oe of">void doubleNumber(int* numPointer){<br/>    *num = *num * 2;<br/>    printf("The value of a is %i", a);<br/>};</span><span id="7230" class="mx kp it np b gy oh od l oe of">int main(void){    <br/>    int num = 2;<br/>    int* numPointer = &amp;num; //Assigns a pointer to 'num' memory location<br/>    doubleNumber(numPointer);<br/>}; //Prints : The value of a is 4</span></pre><h2 id="a9d2" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">指向注释</h2><p id="8b53" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果将整数参数作为参数传递给函数，原始变量的值不会改变。</p><p id="f834" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为函数会复制参数值并将其存储在参数变量中，而不是改变原始变量。</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="9a18" class="mx kp it np b gy oc od l oe of">void doubleNumber(int num){<br/>    num = num * 2;<br/>    printf("The value of a is %i", a);<br/>};</span><span id="6f91" class="mx kp it np b gy oh od l oe of">int main(void){    <br/>    int num = 2;<br/>    <br/>    doubleNumber(num); //Prints: The value of a is 4</span><span id="6915" class="mx kp it np b gy oh od l oe of">    printf("The value of a is %i", a); //Prints: The value of a is 2<br/>};</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ok"><img src="../Images/ad57562b1c9ba3d3e30fe1c4d5cf8228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lBEN0inoJWLfQW_t"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">照片由<a class="ae mw" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">替代代码</a>在<a class="ae mw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8470" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">对结构使用指针</h1><p id="9644" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">“Struct”是C中的一种特殊数据类型，它可以包含不同数据类型的不同变量(称为<strong class="js iu">成员</strong>)。</p><p id="e5e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们定义一个结构<code class="fe nm nn no np b">Car</code>:</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="4a06" class="mx kp it np b gy oc od l oe of">struct Car{<br/>    char name[10];<br/>    char brand[10];<br/>    double topSpeed;<br/>};</span></pre><p id="4f1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们使用上面的定义初始化一个结构<code class="fe nm nn no np b">car1</code>。</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="196f" class="mx kp it np b gy oc od l oe of">struct Car car1 = {<br/>    .name = "Model A",<br/>    .brand = "Tesla",<br/>    .topSpeed = 32.1<br/>};</span></pre><p id="6b6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以为这个结构创建一个指针<code class="fe nm nn no np b">car1_pointer</code>。</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="a1e3" class="mx kp it np b gy oc od l oe of">struct Car* car1_pointer = &amp;car1;</span></pre><p id="4f7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要访问结构中的变量，我们可以使用以下语法:</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="4902" class="mx kp it np b gy oc od l oe of">(*car1_pointer).name;<br/>(*car1_pointer).brand;<br/>(*car1_pointer).topSpeed;</span></pre><p id="9b65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者</p><pre class="mh mi mj mk gt ny np nz oa aw ob bi"><span id="20e9" class="mx kp it np b gy oc od l oe of">car1_pointer-&gt;name;<br/>car1_pointer-&gt;brand;<br/>car1_pointer-&gt;topSpeed;</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ol"><img src="../Images/5a102eae032a8e932235882948883a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vH-ZXZeDVJZ1Udl2"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">照片由<a class="ae mw" href="https://unsplash.com/@sejadisruptivo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> DISRUPTIVO </a>在<a class="ae mw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d005" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您阅读这篇文章！:)</p><p id="a33c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了支持我在Medium上的工作，请鼓掌，关注我并订阅我的邮件列表。干杯！</p></div></div>    
</body>
</html>