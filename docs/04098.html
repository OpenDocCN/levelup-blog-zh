<html>
<head>
<title>SOLID Principles — Simplified with Illustrations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实的原则—用插图简化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solid-principles-simplified-with-illustrations-fe5265f68ec6?source=collection_archive---------0-----------------------#2020-06-09">https://levelup.gitconnected.com/solid-principles-simplified-with-illustrations-fe5265f68ec6?source=collection_archive---------0-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0f17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">神盾局原则的重要性</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a55b79b407b600b7a30b16ac42d92676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dj9sRrRDSiqCgC34IoJe-g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> S.O.L.I.D原则</strong></figcaption></figure><h1 id="e556" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">简介</strong></h1><p id="f00f" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">作为开发人员，我们总是与遗留代码库打交道。大多数遗留代码库都有紧密耦合的类、冗余代码和较少的测试覆盖率。这使得开发人员在快速浏览代码时很难理解代码库的功能。</p><p id="33d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一下，为了修复一个bug而遍历一个类中无穷无尽的代码行是多么痛苦。开发人员可能最终读的代码比写的代码多。此外，修复一个流可能会导致破坏另一个流。这让我想起了下面这个著名的迷因。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mh"><img src="../Images/8b8c43ee72ce94e19aff4a17c5852ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCzEkGFZApLwZLmGuIDAOw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">修复一个bug &amp;你还有10个准备好了</strong></figcaption></figure><p id="d4cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于在遗留软件中没有积极的开发，这使得开发人员和管理人员进退两难。然后，团队考虑重写整个服务，放弃旧的服务。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/59f791cabb42095493596c4f8f26e4f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQ2-pQabm1QglrUgqOXiPg.png"/></div></div></figure><h1 id="bdba" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">为什么是软件设计原则？</strong></h1><p id="a26a" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在当今不断发展的世界中，客户需求以前所未有的速度不断变化。对于软件团队来说，适应新的需求并快速发布变更变得至关重要。为了实现这一点，有必要减少软件开发和测试时间。</p><p id="baef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，每隔一年推出新技术。通过替换现有技术来试验更优化、更高效的技术是很常见的。因此，编写的代码必须灵活和松散耦合，以引入任何变化。</p><p id="5672" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">写得好的代码容易掌握。一个新的开发人员不必花更多的时间阅读代码，只需修改其中的一部分。维护良好的软件因此提高了开发人员和团队的生产力。此外，高测试覆盖率增加了部署新变更的信心。</p><p id="17c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">南O.L.I.D是Michael Feathers创造的首字母缩略词，是Robert Martin(鲍勃大叔)发表的原则子集。我们将详细介绍这五项原则，并逐一进行说明。</p><h1 id="f5d1" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak"> S —单一责任原则</strong></h1><p id="c2e6" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这是最容易理解的原则之一。它声明“一个类只能有一个改变的理由”。很多时候，你可能会发现一个类执行了比它应该做的更多的功能。</p><p id="50a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们假设你正在为银行软件写代码。该功能是为给定用户显示一条语句。该代码从数据库中获取数据，并以用户选择的格式显示数据。你最终会写出下面的代码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mj"><img src="../Images/2cc2d7a8998eea66d6c35a530e2d5cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4B2GPDeg5JPGR5pzJhc-A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">银行声明管理器</strong></figcaption></figure><p id="691f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的代码片段可以看出，类'<strong class="js iu"><em class="mk">BankStatementMgr</em></strong>'正在同时执行多项任务。它从数据库获取数据，解析结果，然后以用户指定的格式显示。您可以观察到以下缺陷:</p><ul class=""><li id="62db" class="ml mm it js b jt ju jx jy kb mn kf mo kj mp kn mq mr ms mt bi translated">没有责任分离。如果引入了新的格式或添加了新的数据库列，这个类将需要更改</li><li id="0c7b" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">该类与数据库驱动程序紧密耦合。DB驱动程序或SQL查询中的任何更改都将导致该类的修改</li><li id="fcc6" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">不能孤立地测试事务的格式，因为它不是由<em class="mk"> BankStatementMgr </em>公开的</li><li id="6f2d" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">代码不是模块化的，因为多个功能交织在一起</li></ul><p id="d955" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述缺点可以通过以下方法来克服</p><ul class=""><li id="7494" class="ml mm it js b jt ju jx jy kb mn kf mo kj mp kn mq mr ms mt bi translated">定义一个单独的格式化程序，其职责是格式化事务</li><li id="a64b" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">添加一个数据库访问对象或DAO，它将封装数据库驱动程序并完成所有繁重的查询工作</li><li id="f613" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><em class="mk"> BankStatementMgr </em>将请求委托给DAO获取数据，然后将响应传递给格式化程序进行修饰</li><li id="3605" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">通过这种方式，我们可以隔离测试DAO和Formatter，并实现松耦合。因此，通过分离责任，它将使代码模块化</li></ul><p id="afc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我们修改后的代码:-</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/6d9511fa2b0117be127b37a47265a7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGHNqYlujjdYlC0l_E2m3g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">银行声明经理</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/eda6d88de4a3a4b59fc3465f8759a1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rM6WvUJhVaTFbsYgohI3Zw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">语句格式化程序</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/816f47c7dd13ec014bc57eef20146854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4hrQ9oPFfOnbEoNIoY3dHg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">交易道</strong></figcaption></figure><p id="8de7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仍然有很大的改进空间，我们将在接下来的章节中看到我们如何重构并做得更好。</p><h1 id="b415" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak"> O —开闭原理</strong></h1><p id="b17b" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这个原则规定代码应该对扩展开放，对修改关闭。如果需要添加新的功能，必须扩展该类。此外，为了使系统可扩展，它的行为应该被隔离。</p><p id="3650" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将通过一个例子来理解这一点。假设你是一个接受不同模式付款的电子商务商家。你整合了Paypal、Wepay、Google Pay等不同模式，开发了支付处理器。你想出了下面的代码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/ad05dae3bafdc747e4ae2fb1fe57b7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0mADKGNwWMQTL9cr1H8nQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">支付处理器</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nd"><img src="../Images/7322ca2cc99ea83b91bcc490efa37429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qz63vgbX5syK216XxfBa4w.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">支付处理员</strong></figcaption></figure><p id="c584" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mk">支付处理程序</em> </strong>处理支付请求。<strong class="js iu"><em class="mk">payment processor</em></strong>确定模式并将其委派给正确的操作。该代码违反了开闭原则，因为任何功能都需要修改<em class="mk"> PaymentProcessor </em>和<em class="mk"> PaymentHandler。此设计不可扩展，因为每个新的支付模式都会在switch语句中引入一个新的case块。</em></p><p id="04ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使代码可扩展，我们可以使<em class="mk"> PaymentHandler </em>抽象并定义一个处理支付的方法。为了处理新的支付模式，我们可以扩展这个基类并覆盖它的handlePayment方法。下面是新代码。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ne"><img src="../Images/3c2ba9e06b1e7905988efbda536c26c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06hlzBZyy12m2pUVCMYibQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">摘要支付处理程序</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/fd28d8349abc921bfe2305f4ec598d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2B0EjspTxJUDlyw5tqOqg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">谷歌支付处理程序</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/38e15e78217207b4482aac7d752b7d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYDg7bS5f8u2I_-Iy_Xp2Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> CardPaymentHandler </strong></figcaption></figure><p id="f4d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将创建一个工厂类，它将负责存储特定的处理程序并根据模式返回它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nh"><img src="../Images/9968976953c478e4ca54397b90c11e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08unVCi61YMjnLFTRtUPwg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">支付工厂</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ni"><img src="../Images/c6029d07edb53a412aa49b520a939214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxXYboveAL3NMlIO2GyuYg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">支付处理器</strong></figcaption></figure><p id="5d74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的新代码现在符合开闭原则。要添加新的行为，我们只需要扩展我们的抽象类<em class="mk"> PaymentHandler </em>，并在工厂中进行相同的配置。没有必要修改PaymentProcessor。</p><h1 id="850a" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak"> L —利斯科夫替代原理</strong></h1><p id="0282" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">乍一看，这个名字听起来很吓人。该原则指出，同一超类的对象应该能够在不破坏现有代码的情况下相互替换。</p><p id="4817" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将以开发电影的scrapper为例。scrapper提供了一个按电影名或演员搜索电影的界面。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/f18c58b58ec96ab339806744eac6ee14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KSnIrsCPgLHJGaytBZSBQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">电影搜索</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/ad18eabe3a64e4545086b2f821f89c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiCJ6lSPT_7ot_9Ns895Yw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> IMDB搜索</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nl"><img src="../Images/3e3dba9fecacf179abae8faa85cf355f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-GfI3gpx8PRnlgDrvjFt8w.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">烂番茄搜索</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/0eab0bb1b9ce61fb5fd58cfc5f396a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsroqTpS6adtmluGw8cBPQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">使用电影搜索接口的客户端代码</strong></figcaption></figure><p id="bbdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有两种不同的实现。一个是烂番茄，另一个是IMDB。它们都是可替换的，可以使用相同的界面访问。</p><p id="6ddd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果派生类中的方法没有实现，则违反了该原则。以下是违反利斯科夫原则的一个例子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/fee7a4f3a4e804873f1a25b294f96348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0XFSx7vgWj7EflFHQ59pA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">all movie search</strong></figcaption></figure><p id="3d8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们不能用所有电影替换其他派生类，如IMDB和烂番茄。它没有实现方法<em class="mk">searchbymovinename</em>，因此不会在客户端代码中产生一致的行为。</p><h1 id="2e79" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak"> I —界面分离</strong></h1><p id="7fc5" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">根据这个原则，客户机不应该实现它不需要的方法。如果您定义了客户机不使用的方法，那么接口会变得太大并且被污染。</p><p id="34bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一个混合功能的接口变得太大，将它分离成多个较小的接口是有意义的。让我们看一个投资组合服务的例子，它允许客户订购股票、ETF、期权等</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi no"><img src="../Images/b53b9abbd67e5ee9733225b2b94796ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hWpJchGmcTGODDXzCisLlw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">界面组合</strong></figcaption></figure><p id="31aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们已经定义了一个接口<strong class="js iu"> <em class="mk">投资组合、</em> </strong>，允许客户订购股票、ETF以及两者的组合。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/ce97c5cc1c6bf8a98a7bf30298f658f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SwRiXaTGVw-RR3sFDew-Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> ETFOrderService </strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/a8e402f5f12c61813a34efd93676d715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhrPD32DH9N4_601SS0Z2w.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> StockOrderService </strong></figcaption></figure><p id="7c54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们有两个不同的<strong class="js iu"> <em class="mk">组合</em> </strong>服务实现。观察到<strong class="js iu"><em class="mk">StockOrderService</em></strong>没有实现<em class="mk"> orderETF </em>和<em class="mk">orderstocandetfs</em>方法。这同样适用于<strong class="js iu"><em class="mk">ETFOrderService</em></strong>，它只实现<em class="mk"> orderETF </em>方法。</p><p id="1f08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们决定在订购股票时将价格作为一个参数。它需要修改<em class="mk"> orderStocks </em>方法来接受价格作为参数。此外，这种变化将不得不由<strong class="js iu"> <em class="mk"> ETFOrderService、</em> </strong>来合并，即使它不支持<em class="mk"> orderStocks </em>方法。</p><p id="f678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了克服这一点，我们可以将界面分成两个部分——a)股票投资组合b)ETF投资组合</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/420c5b1e7b5f7cb73477e6f82b808d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLF7eC5nx6U9v3GKWgYteg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> <em class="ns">股票组合</em> </strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/5269845c875d4a7ed2ffae1fe02d7392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOkZn0ReeDXdb3AoYfLVoA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> ETFPortfolio </strong></figcaption></figure><p id="cc65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了新的接口，StockOrderService不需要处理ETF的订购。这同样适用于ETFOrderService。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nu"><img src="../Images/d0d1f9d5e815c60bbc4ab96a452e6b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thSJDyjrtxJk13tly7gEzA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> ETFOrderService </strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nv"><img src="../Images/60c37001b241728b74e9b72023e6db37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8as1nQtsz6gATJoXmqGdw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> StockOrderService </strong></figcaption></figure><p id="c31b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">界面分离与单一责任和利斯科夫替代原理有一些相似之处。</p><p id="b449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面这个庞大接口的例子中，我们在StockOrderService中抛出了一个异常。这违反了利斯科夫替代原理。在这种情况下，派生类没有扩展功能。</p><p id="7a30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在接口中定义了不相关的方法，那么该类将有多种理由进行更改。这违反了单一责任原则。</p><h1 id="aa08" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak"> D —依赖性反转</strong></h1><p id="d672" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">根据依赖倒置，程序中的高级模块不能与低级模块紧密耦合。两个模块都必须依赖于抽象。这个原则提供了一种机制来构建松散耦合的软件模块。</p><p id="e445" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看下面的例子。在这个例子中，类<em class="mk"> OrderHistory </em>从PostgreSQL数据存储中获取数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nw"><img src="../Images/a1788b15cbe82a306e2c5098e621785a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3DLLxmldatpcBT5cNMFEGA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">订单历史</strong></figcaption></figure><p id="a32b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="mk"> OrderHistory </em> </strong>类必须知道PostgresDB依赖的实现细节。如果我们决定使用不同的数据库驱动程序，我们需要用新的依赖关系替换所有的<strong class="js iu"> <em class="mk"> PostgresDB </em> </strong>的实例。</p><p id="bad5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，数据库驱动程序的一个功能是什么？还需要修改调用DB驱动方法的<strong class="js iu"><em class="mk">order history</em></strong><em class="mk"/>类。</p><p id="3934" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种耦合可以通过声明接口<strong class="js iu"><em class="mk">DataStore</em></strong><em class="mk">来移除。</em>该接口将公开消费者将调用的API。我们可以有多个<strong class="js iu"> <em class="mk">数据存储</em></strong>——a)Postgres数据存储b) MySQL数据存储c) S3，等等</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/926bb7b40466455d723e45a03dddb55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7j9r-WrHfCp0fLfNgKroxQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">数据存储</strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/191d3948ac2170df4fda11b8efd09c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vW-JwwgPmzg5b3ugXbqeA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le"> PostgresDataStore </strong></figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/05c38bb29acb48314b905b0e7052b19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v73kFdpAzVHH34bj5i0pEw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">订单历史</strong></figcaption></figure><p id="42b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的消费者类现在不必处理正在使用的数据存储的底层细节。高级模块<strong class="js iu"> <em class="mk">订单历史</em> </strong>依靠接口数据存储来访问数据。下级<strong class="js iu"> <em class="mk"> DataStore </em> </strong>实现中的任何变化对<strong class="js iu"><em class="mk">order history</em></strong><em class="mk">没有任何影响。</em></p><p id="ae24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，由于这些模块是松散耦合的，它们可以被独立测试。使用依赖注入，可以很容易地在高级模块中注入新的实现。</p><h1 id="56e8" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">结论</strong></h1><p id="87e6" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">以上五个原则构成了软件工程中遵循的最佳实践的基石。在日常工作中实践上述原则有助于提高软件的可读性、模块化、可扩展性和可测试性。</p><p id="c7a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终，它有助于构建易于理解的维护良好的软件。遵循上述实践有助于提高开发人员的生产力和工程团队的敏捷性。</p><h1 id="1ae0" class="lf lg it bd le lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="e171" class="ml mm it js b jt mc jx md kb nz kf oa kj ob kn mq mr ms mt bi translated"><a class="ae oc" href="https://proandroiddev.com/exploring-s-o-l-i-d-principle-in-android-a90947f57cf0" rel="noopener ugc nofollow" target="_blank">Android中的坚实原理</a></li><li id="c280" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><a class="ae oc" href="https://itnext.io/solid-principles-explanation-and-examples-715b975dcad4" rel="noopener ugc nofollow" target="_blank">固体原理简化版</a></li><li id="245a" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><a class="ae oc" href="https://dev.to/erikwhiting88/liskov-substitution-principle-in-3-minutes-2dc6" rel="noopener ugc nofollow" target="_blank">利斯科夫替代原理</a></li><li id="f943" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><a class="ae oc" href="https://www.youtube.com/watch?v=rtmFCcjEgEw" rel="noopener ugc nofollow" target="_blank">通过应用坚实的原则成为更好的开发人员</a></li><li id="2f02" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><a class="ae oc" href="https://medium.com/swlh/s-o-l-i-d-principles-explained-in-five-minutes-8d36b1da4f6b" rel="noopener">五分钟扎实原理</a></li><li id="6b02" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated"><a class="ae oc" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.pinterest.com%2Fpin%2F393220611216597358%2F&amp;psig=AOvVaw1wiqQHCovfFQCcWfgVQYc1&amp;ust=1591728875201000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCNiTpO7z8ukCFQAAAAAdAAAAABAF" rel="noopener ugc nofollow" target="_blank">封面照片</a></li></ul></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt ok"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">编写面试问题</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">技术开发</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ky ok"/></div></div></a></div></div></div>    
</body>
</html>