# 固体软件体系结构中的“L”——利斯科夫替代原则

> 原文：<https://levelup.gitconnected.com/the-l-in-solid-software-architecture-liskov-substitution-principle-54cc9abb67f9>

## “L”代表 Liskov 替换原则，鼓励允许在不破坏事物的情况下用基类替换子类的架构。

继承在软件架构中是一个强大的特性，尤其是在能够覆盖基类行为的情况下。如果你愿意，你可以扩展一个基本类并完全改变它的行为。

![](img/a3b97135e1dfbcff6e123f12af9c9c50.png)

遗产有点像俄罗斯洋娃娃(照片由 [Iza Gawrych](https://unsplash.com/@ilmatar?utm_source=medium&utm_medium=referral) 拍摄)。

这就引出了什么时候应该真正使用继承的问题。为什么不用构图来代替呢？如何知道应该通过扩展已经存在的东西并修改其行为来实现一个新特性，还是选择一个完全不同的模式呢？

芭芭拉·利斯科夫在[1987 年的主题演讲](https://dl.acm.org/doi/10.1145/62139.62141)中回答了这个问题，后来[在 1994 年的另一篇论文](https://dl.acm.org/doi/10.1145/197320.197383)中正式提出了这个问题:

> 子类型要求*:设****【ϕ(x】****为关于类型* ***T*** *的对象* ***x*** *的可证属性。那么****【ϕ(y】****对于类型****s****s****的对象****y*****s****应该是***的子类型。*******

*这种说法现在被称为“利斯科夫替代原理”，可以用稍微不太正式的措辞来表达:*

*当使用基类 **T** 时，人们应该能够将这个基类 **T** 与任何子类 **S** (继承自 **T** )交换，并期望相同的行为 **ϕ** 。*

*让我们考虑一个简单的例子，我们想为一个给定的事件发送一封通知邮件。我们希望能够发送一封普通的电子邮件或一封包含关于订阅的附加信息的订阅用户的电子邮件。目前，我们总是发送普通电子邮件:*

*如你所见，我们有一个`EmailBroadcaster`和一个从前者继承而来的`SubscriptionEmailBroadcaster`——他做的事情基本上是一样的，但更多一点，所以这需要继承，对吗？*

*嗯，假设现在我们想从使用基本的`EmailBroadcaster`切换到新的`SubscriptionEmailBroadcaster`。按照上面的逻辑，我们应该可以用`SubscriptionEmailBroadcaster`替换旧的`EmailBroadcaster`，因为它继承了它。它适用于父类，所以它也应该适用于子类。毕竟，“它做同样的事情，但更多一点”，对不对？*

*如果你想改变它，你会发现它实际上不起作用，因为编译失败了。在`onAccountCreated`中，我们将`User`或`SubscribedUser`(后者可能是前者的子类)传递给广播方法。但是，新的`SubscriptionEmailBroadcaster`T13 只有带一个`SubscribedUser`。*

*通过以这种方式建模我们的架构，我们打破了 Liskov 替换原则，更具体地说，是为了避免类似问题而应该满足的以下要求中的第一个:*

***1。不要在子类中加强前置条件。***

***子类方法的参数类型应该匹配基类方法的参数类型，或者比基类方法的参数类型更抽象。**在我们的例子中，`SubscribedUser`是`User`的一个子类型——因为我们需要一个更具体的(而不是抽象的)类型，所以我们加强了前置条件。*

*例如，在一个更简单的例子中，这个规则将被打破，在子类方法中只期望正数，而被重写的基类方法同时接受正数和负数。*

*子类在接受什么方面应该总是更自由，而不是更严格。*

***2。不要弱化子类中的后置条件。***

***子类方法的返回类型应该匹配基类方法的返回类型或者是基类方法的返回类型的子类型。这也适用于异常:子类方法抛出的异常应该匹配或者是基类方法抛出的异常的子类型。这是为了避免引入依赖基类的代码无法捕捉的异常。***

*子类应该总是更严格地返回或抛出什么，而不是更自由。*

*那么，我们如何修正我们的例子呢？基本上有两种方法:反转我们的继承结构或者使用复合。*

*第一个选项意味着`SubscriptionEmailBroadcaster`成为基类而`EmailBroadcaster`继承自它。人们可以将`SubscriptionEmailBroadcaster`重命名为`EmailBroadcaster`，将之前的`EmailBroadcaster`重命名为`AnonymousEmailBroadcaster`，以反映它不需要订阅:*

*当从`EmailBroadcaster`开始时，我们现在可以毫无问题地把它换成`AnonymousEmailBroadcaster`，因为它实际上反映了继承的行为——子类可以做它的基类可以做的任何事情(根据它的契约)。*

*使用组合而不是继承的第二种选择可以通过使用独立广播公司遵循的一个接口来实现:*

*在这种情况下，如果我们只是用`SubscriptionEmailBroadcaster`替换`AnonymousEmailBroadcaster`，编译器也会抱怨(因为构造函数不同)。然而，这并不是什么大问题，因为我们并不期望新类能够正常工作——毕竟，除了实现相同的接口之外，它与其他类没有任何关系。*

*Liskov 替换原则在理论上非常容易理解:只要确保你可以将你的基类替换为它们的子类，而不会遇到问题。*

*然而，我个人觉得在实践中很难发现。我的猜测是，这是由于直觉地将“继承”一词解释为“修改使用共同的行为”。*

*为了更容易发现违规，我建议将“继承”解释为“扩展使用共同行为”。*

*通过这种方式，我们总是记住子类是建立在基类的行为之上的，并不试图改变最初的行为。*

*这篇文章写起来特别有趣，因为它需要一些时间来按照[单一责任](https://medium.com/@richartkeil/the-s-in-solid-5a6e0d778cbc)和[打开关闭原则](https://medium.com/@richartkeil/ccdb25bbecd2)帖子的事件通知示例的思路提出一个合适的示例。*

*通过在我的博客上注册[来获得关于新帖子的电子邮件通知。](http://blog.richartkeil.com)*