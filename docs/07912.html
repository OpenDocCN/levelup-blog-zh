<html>
<head>
<title>Spring Boot and Java 16 Records</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot和爪哇16项记录</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/spring-boot-and-java-16-records-3b3356345ac8?source=collection_archive---------5-----------------------#2021-03-21">https://levelup.gitconnected.com/spring-boot-and-java-16-records-3b3356345ac8?source=collection_archive---------5-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2701" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我们将讨论Java 16的最新特性——记录。然后，我们将应用这些知识，并将其与Spring Boot应用程序结合使用。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1130db834a8fc5619283ad2e6cf63937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Iq1xsF98-64c6oWn"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">简·kopřiva在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="128b" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h2><p id="35a8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">2021年3月16日Java 16 was。在这个新版本中，添加了大量令人兴奋的新功能。查看<a class="ae kv" href="https://jdk.java.net/16/release-notes" rel="noopener ugc nofollow" target="_blank">发布说明</a>以了解更多关于这些变化的细节。这篇文章的焦点是Java记录，它是由<a class="ae kv" href="https://openjdk.java.net/jeps/395" rel="noopener ugc nofollow" target="_blank"> JEP 395 </a>提供的。记录首次在JDK 14中引入，作为由JEP 359提出的预览功能，在JDK 15中，它们在JEP 384中保持预览。然而，随着JDK 16，记录不再是预览。</p><p id="0fb8" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">根据Java冠军Mala Gupta的Twitter投票，我选择记录是因为它们绝对是Java 16中最受欢迎的新增特性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">关于最受欢迎的Java 16特性的Twitter投票</figcaption></figure><p id="7426" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我也进行了一次类似的调查，但是它主要针对Java 8以后的特性。这个结果并不出人意料，因为Java 8仍然被广泛使用。然而，非常不幸的是，大量的新特性和改进被添加到了新的Java版本中。但是就特性而言，从开发者的角度来看，Java 8绝对是游戏规则的改变者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">关于Java 8以后最受欢迎的特性的Twitter投票</figcaption></figure><p id="57da" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">想了解更多Java和技术相关的东西，请关注我的推特</p><p id="a34c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">所以我们来讨论一下Java记录有什么大惊小怪的。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="38fa" class="mz kx iq bd ky na nb nc lb nd ne nf le jw ng jx li jz nh ka lm kc ni kd lq nj bi translated">什么是记录？</h1><p id="55c8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">根据JEP 395:</p><blockquote class="nk nl nm"><p id="44fe" class="ls lt nn lu b lv ml jr lx ly mm ju ma no mn mc md np mo mf mg nq mp mi mj mk ij bi translated"><em class="iq">记录是Java语言中一种新的类。它们充当不可变数据的透明载体，比普通类更简单。记录可以被认为是名义上的元组。</em></p></blockquote><p id="dd7a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">《JEP》的另一段引文清楚地解释了开发人员在编写典型的数据载体类时的沮丧。</p><blockquote class="nk nl nm"><p id="8a5f" class="ls lt nn lu b lv ml jr lx ly mm ju ma no mn mc md np mo mf mg nq mp mi mj mk ij bi translated">正确地编写这样一个数据载体类需要大量低价值、重复、易错的代码:构造函数、访问器、equals、hashCode、toString等等。例如，一个携带x和y坐标的类不可避免地会这样结束:</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mr l"/></div></figure><p id="5ab4" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们开发人员最常使用的另一个选项是将样板文件的处理留给IDE。例如，使用Intellij，您可以生成构造函数、getters、setters、equals、hashCode和toString等。，只需按Command + N快捷键。但是样板代码仍然存在。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f8ca341dd17cfd3d924df7c35ebaf423.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/0*AMMpAI54HfHqVyTo"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用IntelliJ自动生成代码</figcaption></figure><p id="cf8c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对于Java 16记录，它只是一行代码。很酷，不是吗？</p><p id="ec5c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><code class="fe nt nu nv nw b">record Point(int x, int y) { }</code></p><p id="f9ad" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这里，记录类声明由名称、可选的类型参数、头部和主体组成。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="a724" class="mz kx iq bd ky na nb nc lb nd ne nf le jw ng jx li jz nh ka lm kc ni kd lq nj bi translated">揭秘记录</h1><p id="e70e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">Java record类的内部可以使用IntelliJ IDE附带的反编译器来检查，也可以使用<code class="fe nt nu nv nw b">javap</code>命令行实用程序。为了理解内部机制，我们创建了下面的记录类。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="3445" class="kw kx iq nw b gy ob oc l od oe">public record State(String name, String capital) {}</span></pre><p id="2163" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">下面是反编译的Java记录类。我已经使用了<code class="fe nt nu nv nw b">javap</code>命令行工具来检查类文件内部。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="95c3" class="kw kx iq nw b gy ob oc l od oe">$ javap State.class</span></pre><p id="aff0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">以下是输出。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="9d4d" class="kw kx iq nw b gy ob oc l od oe">Compiled from "State.java"<br/>public final class com.example.indianstates.State extends java.lang.Record {<br/>  public com.example.indianstates.State(java.lang.String, java.lang.String);<br/>  public final java.lang.String toString();<br/>  public final int hashCode();<br/>  public final boolean equals(java.lang.Object);<br/>  public java.lang.String name();<br/>  public java.lang.String capital();<br/>}</span></pre><p id="b9b5" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">您可以从上面的输出中得出以下结论。</p><ol class=""><li id="5214" class="of og iq lu b lv ml ly mm lf oh lj oi ln oj mk ok ol om on bi translated">状态记录类是对<code class="fe nt nu nv nw b">java.lang.Record</code>抽象类的扩展。</li><li id="b23d" class="of og iq lu b lv oo ly op lf oq lj or ln os mk ok ol om on bi translated">State record类被声明为final，不能使用extends关键字进一步扩展。</li><li id="fb61" class="of og iq lu b lv oo ly op lf oq lj or ln os mk ok ol om on bi translated">hashCode()、equals()、toString()和一个规范的构造函数是为我们隐式生成的。</li><li id="f386" class="of og iq lu b lv oo ly op lf oq lj or ln os mk ok ol om on bi translated">没有setters或getters，只有accessors。</li><li id="25b9" class="of og iq lu b lv oo ly op lf oq lj or ln os mk ok ol om on bi translated">在类声明中没有setters和final，表明您不能更改状态，因此记录是不可变的。</li></ol><p id="a8c2" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">您还可以通过编写测试来进一步验证这些观点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mr l"/></div></figure><p id="1f94" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">与普通类相比，记录类的声明有一些限制。查看<a class="ae kv" href="https://openjdk.java.net/jeps/395" rel="noopener ugc nofollow" target="_blank"> JEP 395 </a>这样的限制。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="10b7" class="mz kx iq bd ky na nb nc lb nd ne nf le jw ng jx li jz nh ka lm kc ni kd lq nj bi translated">龙目岛和记录，朋友还是敌人？。</h1><p id="5fdd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">您可能已经在使用<a class="ae kv" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Lombok </a>注释，比如@ <a class="ae kv" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank"> Value </a>，这是最接近Java记录的注释。然后你可以摆脱一个依赖和那些注释的圣诞树。我可能把事情过于简化了，在某些情况下用Lombok代替可能是有意义的。但是您可能会将Lombok用于其他功能，而不仅仅是它提供的一个注释。相信我，虽然Java记录是Java爱好者欢迎的特性，但它不会取代Lombok，至少现在不会。你不相信我？看看Brain Goetz在StackOverflow上的这个<a class="ae kv" href="https://stackoverflow.com/a/61325018/1472027" rel="noopener ugc nofollow" target="_blank">回答</a>。</p><p id="58ec" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">并且要小心你添加到项目中的依赖项，因为作为依赖项一部分的问题也会成为你的问题。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="0549" class="mz kx iq bd ky na nb nc lb nd ne nf le jw ng jx li jz nh ka lm kc ni kd lq nj bi translated">Spring Boot和爪哇记录</h1><p id="f7fe" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">从版本2.5.0-M1开始，Spring Boot为Java 16提供了初步的<a class="ae kv" href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5.0-M1-Release-Notes#java-16-support" rel="noopener ugc nofollow" target="_blank">支持</a>。我有一个工作的Spring Boot应用程序，我将用它来演示Java记录。源代码可在<a class="ae kv" href="https://github.com/yrashish/indian-states/tree/develop" rel="noopener ugc nofollow" target="_blank">这里</a>获得。这是一个简单的Spring Boot应用程序，当通过/states或/state访问时。name=statename REST endpoint显示所有或特定的印度各州及其首府。该应用程序使用内存中的H2数据库，该数据库在应用程序的开头插入行。</p><p id="917c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">和往常一样，您可以使用<a class="ae kv" href="http://start.spring.io" rel="noopener ugc nofollow" target="_blank"> start.spring.io </a>为您的Spring Boot应用程序生成存根，并且如前所述，确保您选择了2.5.x里程碑版本。</p><p id="f59f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">下面是REST控制器类的样子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mr l"/></div></figure><p id="052a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我们可以关注getAllStates()方法，它返回状态记录类对象的列表。我们已经看到了国家记录类。这一点没有改变。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="6231" class="kw kx iq nw b gy ob oc l od oe">public record State(String name, String capital) {}</span></pre><p id="be9f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">下面是由<code class="fe nt nu nv nw b">StateService</code>类实现的<code class="fe nt nu nv nw b">StateRepository</code>接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mr l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr mr l"/></div></figure><p id="3fa0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated"><code class="fe nt nu nv nw b">StateService</code>是使用<code class="fe nt nu nv nw b">Controller</code>类的构造函数自动连接的。它有一个名为findAll()的方法，该方法使用Spring JdbcTemplate进行查询，并从内存中的H2数据库返回一个<code class="fe nt nu nv nw b">State</code>记录类列表。如您所见，我们已经使用了<code class="fe nt nu nv nw b">RowMapper</code>函数接口，JdbcTemplate使用它来逐行映射ResultSet的行，并且它返回当前行的row对象。我们还使用了<code class="fe nt nu nv nw b">new</code>关键字来初始化记录类，这意味着我们可以像普通的Java类一样初始化记录类。我还使用了Java 15 <a class="ae kv" href="https://openjdk.java.net/jeps/378" rel="noopener ugc nofollow" target="_blank">文本块</a>特性，这有助于提高SQL查询JSON字符串值的可读性。</p><p id="0ffe" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">然而，当我开始在这个应用程序中使用记录时，出现了一些问题。之前我使用了<code class="fe nt nu nv nw b">BeanPropertyRowMapper,</code>，当我禁用Lombok并使用Records代替<code class="fe nt nu nv nw b">State</code>类时，导致了下面的异常。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="8a26" class="kw kx iq nw b gy ob oc l od oe">2021-03-19 02:01:55.434 ERROR 66059 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.example.indianstates.State]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.example.indianstates.State.&lt;init&gt;()] with root cause</span></pre><p id="0a5a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">从异常和<code class="fe nt nu nv nw b">BeanPropertyRowMapper</code> <a class="ae kv" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/BeanPropertyRowMapper.html" rel="noopener ugc nofollow" target="_blank">文档</a>中，很明显我们必须在<code class="fe nt nu nv nw b">State</code> records类中声明一个默认或无参数构造函数，这导致了一些关于Java中records类的有趣发现。为了解决这个错误，我天真地给<code class="fe nt nu nv nw b">State</code>记录类添加了一个无参数构造函数。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="8ff0" class="kw kx iq nw b gy ob oc l od oe">public record State(String name, String capital) { <br/>public State() {} <br/>}</span></pre><p id="5f0a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">但是，这导致了以下编译错误。</p><blockquote class="nk nl nm"><p id="aa98" class="ls lt nn lu b lv ml jr lx ly mm ju ma no mn mc md np mo mf mg nq mp mi mj mk ij bi translated"><em class="iq">非规范记录构造函数必须委托给另一个构造函数</em></p></blockquote><p id="90d8" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">为了解决这个编译问题，我添加了下面的构造函数，但这会使响应的值。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="1878" class="kw kx iq nw b gy ob oc l od oe">public record State(String name, String capital) {<br/>    public State() {<br/>        this(null,null);<br/>    }<br/>}</span></pre><p id="12c6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">然后，我借助IntelliJ特性为这个记录类生成构造函数。它为我提供了以下选择。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/9364133143fc7ea4fe10caa6b8789da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/0*jAK-Qo1Nc0rju-lm"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">通用记录构造函数</figcaption></figure><p id="3935" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">我尝试了这些选项，但得到了相同的结果。我已经知道这些选项不起作用，但我试了试我的运气，这让我想知道如何使用记录与<code class="fe nt nu nv nw b">BeanPropertyRowMapper.</code>我现在没有答案，但我会进一步挖掘。如果你看到任何问题的代码或有更好的答案，然后让我知道。</p><p id="dde8" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">更新:-我把这些例外张贴到Spring Boot·吉特聊天，得到了这个答案。</p><blockquote class="nk nl nm"><p id="4cc9" class="ls lt nn lu b lv ml jr lx ly mm ju ma no mn mc md np mo mf mg nq mp mi mj mk ij bi translated"><em class="iq"> BeanPropertyRowMapper不能与记录一起使用，因为它包括用其无参数构造函数创建一个Java Bean实例，然后调用其setters来填充该Bean。但是记录没有无参数构造函数，并且是不可变的，因此没有设置器。所以，要么使用传统的Java Bean，要么使用记录，但不要使用BeanPropertyRowMapper。</em></p></blockquote><p id="a6be" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">很公平。所以很明显<code class="fe nt nu nv nw b">BeanPropertyRowMapper</code>不能和记录一起使用。现在已经结束了。快乐编码。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="fd1c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h2><p id="6566" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在本文中，您已经了解到记录是不可变的数据载体类，它减少了我们习惯编写的大量样板代码。然后我们查看了Record类的内部，发现hashCode()、equals()、toString()和构造函数是由编译器隐式生成的。然后我们了解到，你不应该真的用Lombok这样的外部库来比较或替换记录，因为两者是针对不同事物的不同工具。</p><p id="4772" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在上一节中，我们发现记录适用于从数据库(或一些外部服务)获取数据的情况，例如Spring Boot应用程序。我们在使用<code class="fe nt nu nv nw b">BeanPropertyRowMapper,</code>时也发现了一些问题，并得出结论，我们不能将它与记录一起使用。</p><h2 id="f6dc" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">请支持我</h2><p id="3b8f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">如果你喜欢你刚刚读到的，那么你可以点击下图中的链接给我买杯咖啡:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.buymeacoffee.com/meashish"><div class="gh gi ou"><img src="../Images/c52b815e7fc09f3a5905813247816750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/0*_j0gSiIf2YE7dAfh"/></div></a></figure></div></div>    
</body>
</html>