<html>
<head>
<title>How to Take Screenshots in a Chrome Extension</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Chrome扩展中截图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-take-screenshots-in-chrome-extension-534f0f07a354?source=collection_archive---------28-----------------------#2021-06-07">https://levelup.gitconnected.com/how-to-take-screenshots-in-chrome-extension-534f0f07a354?source=collection_archive---------28-----------------------#2021-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/470d707635b12c49f404db4efc75b365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9RLj-NuwUdCrspQQKrZd-A.jpeg"/></div></div></figure><p id="464a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本文原载于</em> <a class="ae kx" href="https://blog.shahednasser.com/how-to-take-screenshots-in-chrome-extension/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">我的个人博客</em> </a> <em class="kw">。</em></p><p id="4246" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将介绍如何在Chrome扩展中截图并保存在用户的机器上。本教程需要一些Javascript初学者技能。</p><p id="a846" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建一个扩展，允许用户只需点击工具栏的图标就可以截图。用户可以选择截取整个屏幕、一个窗口或当前标签的屏幕截图。</p><p id="45c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，这个扩展将使用清单V3。在整个教程中，我会提供一些关于V3和V2之间差异的提示，但是如果你想知道更多关于这两个版本之间的差异，你可以查看本教程。</p><p id="4ed2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在GitHub库上找到本教程的代码。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="4f83" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">创建扩展</h2><p id="4aa5" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">我们不会详细讨论如何创建一个Chrome扩展，因为这不是我们的目的。如果你需要了解更多的细节，你可以看看这个教程。</p><p id="90bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的扩展目录的根目录下创建<code class="fe md me mf mg b">manifest.json</code>,内容如下:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="7477" class="lf lg iq mg b gy mp mq l mr ms">{<br/>    "name": "Screenshots",<br/>    "version": "0.0.1",<br/>    "description": "Take screenshots",<br/>    "manifest_version": 3,<br/>    "action": {<br/>        "default_title": "Take a Screenshot"<br/>    },<br/>    "icons": {<br/>        "16": "/assets/icon-16.png",<br/>        "32": "/assets/icon-32.png",<br/>        "48": "/assets/icon-48.png",<br/>        "128": "/assets/icon-128.png"<br/>    }<br/>}</span></pre><p id="8cfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这个扩展中使用的图标是由<a class="ae kx" href="https://iconscout.com/" rel="noopener ugc nofollow" target="_blank"> Iconscout </a>上的BZZRICON工作室制作的。</p><p id="6758" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于清单V2，确保<code class="fe md me mf mg b">manifest_version</code>设置为2:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="4934" class="lf lg iq mg b gy mp mq l mr ms">"manifest_version": 2</span></pre><p id="51cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并确保将<code class="fe md me mf mg b">action</code>替换为<code class="fe md me mf mg b">browser_action</code>:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="2c4a" class="lf lg iq mg b gy mp mq l mr ms">"browser_action": {<br/>	"default_title": "Take a Screenshot"<br/>}</span></pre><p id="9df7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，创建一个zip文件，进入chrome://extensions，如果没有启用开发者模式，从右上方启用它，从左侧的按钮中点击“Load Unpacked ”,选择扩展的目录。我们的扩展将被成功添加。</p><h2 id="ff00" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">添加服务人员(或后台脚本)</h2><p id="c560" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">为了检测用户何时点击扩展的图标，我们需要给<code class="fe md me mf mg b">chrome.action.onClicked</code>附加一个事件监听器。为此，我们需要添加一个服务人员(或V2的后台脚本)。</p><p id="1661" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要添加服务人员，在<code class="fe md me mf mg b">manifest.json</code>中添加以下内容:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="c5f2" class="lf lg iq mg b gy mp mq l mr ms">"background": {<br/>	"service_worker": "background.js"<br/>},</span></pre><p id="a4d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者下面的V2:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="244a" class="lf lg iq mg b gy mp mq l mr ms">"background": {<br/>	"scripts": ["background.js"],<br/>	"persistent": false<br/>},</span></pre><p id="8286" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在扩展的根中创建<code class="fe md me mf mg b">background.js</code>,内容如下:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="9d69" class="lf lg iq mg b gy mp mq l mr ms">chrome.action.onClicked.addListener(function (tab) {<br/>    <br/>})</span></pre><p id="3dc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对V2来说，应该是这样的:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="d00a" class="lf lg iq mg b gy mp mq l mr ms">chrome.browserAction.onClicked.addListener(function (tab) {<br/>    <br/>})</span></pre><p id="c79b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，如果您在<code class="fe md me mf mg b">manifest.json</code>中没有<code class="fe md me mf mg b">action</code>键，您将无法向<code class="fe md me mf mg b">onClicked</code>添加监听器。</p><p id="b322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将开始“截图”过程。为此，我们将使用<a class="ae kx" href="https://developer.chrome.com/docs/extensions/reference/desktopCapture/" rel="noopener ugc nofollow" target="_blank">桌面捕获API </a>。具体来说，我们将使用带3个参数的方法<code class="fe md me mf mg b">chrome.desktopCapture.chooseDesktopMedia</code>:第一个是捕获源的字符串数组，可以是“屏幕”、“窗口”、“标签”和“音频”。第二个参数是可选的目标标签，但是，在某些情况下，如果目标标签没有被传递，Chrome就会崩溃。第三个参数是一个回调函数，它返回流id，我们稍后将使用它来获取屏幕截图。</p><p id="e52e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在侦听器中添加以下内容:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="793b" class="lf lg iq mg b gy mp mq l mr ms">chrome.desktopCapture.chooseDesktopMedia([<br/>        "screen",<br/>        "window",<br/>        "tab"<br/>    ], tab, (streamId) =&gt; {<br/>        //check whether the user canceled the request or not<br/>        if (streamId &amp;&amp; streamId.length) {<br/>            <br/>        }<br/>    })</span></pre><p id="8bc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们传入了第一个参数“screen”、“window”和“tab”作为允许的源类型。第二个参数是传递给监听器的<code class="fe md me mf mg b">tab</code>参数，第三个是回调函数。我们正在检查<code class="fe md me mf mg b">streamId</code>是否不为空，因为如果用户取消请求，它将为<code class="fe md me mf mg b">empty</code>。</p><p id="af33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们使用它之前，我们需要在<code class="fe md me mf mg b">manifest.json</code>中添加一些权限。权限允许用户理解扩展正在做什么，并在将它安装到他们的浏览器之前同意它。</p><p id="7ca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容添加到<code class="fe md me mf mg b">manifest.json</code>:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="c57e" class="lf lg iq mg b gy mp mq l mr ms">"permissions":["desktopCapture","tabs"],</span></pre><p id="e91c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要<code class="fe md me mf mg b">tabs</code>权限的原因是，如果我们没有该权限，传递给<code class="fe md me mf mg b">onClicked</code>事件监听器的<code class="fe md me mf mg b">tab</code>对象将没有<code class="fe md me mf mg b">url</code>参数，而在将该选项卡作为参数传递时<code class="fe md me mf mg b">chooseDesktopMedia</code>需要该参数。</p><p id="e8c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果你现在重新加载扩展并按下图标，你会看到它会问你你想录制什么屏幕，就是这样。接下来，我们需要使用<code class="fe md me mf mg b">streamId</code>来获取截图。</p><h2 id="7f33" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">添加内容脚本</h2><p id="947f" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">为了从<code class="fe md me mf mg b">streamId</code>获取流，我们需要使用<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia" rel="noopener ugc nofollow" target="_blank"> getUserMedia </a>。然而，这在服务人员中是不可用的。因此，我们需要创建一个内容脚本，它接收来自服务工作者的带有流id的消息，然后从流中获取屏幕截图。</p><p id="89b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要添加内容脚本，请将以下内容添加到<code class="fe md me mf mg b">manifest.json</code>:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="09f0" class="lf lg iq mg b gy mp mq l mr ms">"content_scripts": [<br/>    {<br/>    	"matches": ["&lt;all_urls&gt;"],<br/>    	"js": ["content_script.js"]<br/>    }<br/>]</span></pre><p id="552c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在扩展的根中创建<code class="fe md me mf mg b">content_script.js</code>,内容如下:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="bd83" class="lf lg iq mg b gy mp mq l mr ms">chrome.runtime.onMessage.addListener((message, sender, senderResponse) =&gt; {<br/>    if (message.name === 'stream' &amp;&amp; message.streamId) {<br/>        <br/>    }<br/>});</span></pre><p id="e805" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码监听“onMessage”事件，并检查收到的<code class="fe md me mf mg b">message</code>是否有一个等于<code class="fe md me mf mg b">stream</code>的<code class="fe md me mf mg b">name</code>属性和一个<code class="fe md me mf mg b">streamId</code>属性，然后我们将获取流并对其进行截图。</p><p id="fad7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在if中，我们将使用<code class="fe md me mf mg b">getUserMedia</code>，它返回一个解析为<a class="ae kx" href="/p/f406e09d-a9cc-48a6-94b2-5ab3b4495ccd/MediaStream" rel="noopener ugc nofollow" target="_blank"> MediaStream </a>的承诺:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="928f" class="lf lg iq mg b gy mp mq l mr ms">let track, canvas<br/>navigator.mediaDevices.getUserMedia({<br/>    video: {<br/>        mandatory: {<br/>            chromeMediaSource: 'desktop',<br/>            chromeMediaSourceId: message.streamId<br/>        },<br/>    }<br/>}).then((stream) =&gt; {<br/>    <br/>})</span></pre><p id="b244" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们传递给<code class="fe md me mf mg b">getUserMedia</code>的参数接受了一个选项对象。我们正在传递等于<code class="fe md me mf mg b">desktop</code>的<code class="fe md me mf mg b">chromeMediaSource</code>和等于我们收到的流Id的<code class="fe md me mf mg b">chromeMediaSourceId</code>。</p><p id="e5f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在已解析承诺的回调函数中，我们将获取<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack" rel="noopener ugc nofollow" target="_blank"> MediaStreamTrack </a>，然后使用<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/API/ImageCapture" rel="noopener ugc nofollow" target="_blank"> ImageCapture </a> API从其中捕获一个屏幕截图:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="7380" class="lf lg iq mg b gy mp mq l mr ms">track = stream.getVideoTracks()[0]<br/>const imageCapture = new ImageCapture(track)<br/>return imageCapture.grabFrame()</span></pre><p id="1bca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们将返回<code class="fe md me mf mg b">imageCapture.grabFrame</code>的值，该值返回一个解析为ImageBitmap的承诺。注意，我们没有使用<code class="fe md me mf mg b">ImageCapture</code> API的<code class="fe md me mf mg b">takePhoto</code>方法。背后的原因是，已知有使用它抛出DOMException的情况，这是它的一个<a class="ae kx" href="https://github.com/GoogleChromeLabs/imagecapture-polyfill/issues/15" rel="noopener ugc nofollow" target="_blank">变通方法</a>。</p><p id="c907" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将附加另一个<code class="fe md me mf mg b">then</code>方法来处理从<code class="fe md me mf mg b">imageCapture.grabFrame</code>返回的承诺。回调函数将停止流，创建一个画布并在其中绘制ImageBitmap，然后获取画布的数据Url:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="164a" class="lf lg iq mg b gy mp mq l mr ms">.then((bitmap) =&gt; {<br/>    track.stop();<br/>    canvas = document.createElement('canvas');<br/>    canvas.width = bitmap.width;<br/>    canvas.height = bitmap.height;<br/>    let context = canvas.getContext('2d');<br/>    context.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height);<br/>    return canvas.toDataURL();<br/>})</span></pre><p id="b134" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，将画布的宽度和高度设置为等于<code class="fe md me mf mg b">bitmap</code>的宽度和高度是很重要的。如果我们不这样做，画布的高度和宽度将默认为<code class="fe md me mf mg b">200px</code>，如果位图的宽度或高度大于这个值，屏幕截图将被裁剪。</p><p id="7053" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，我们将返回<code class="fe md me mf mg b">canvas.toDataUrl</code>。我们将附加最后一个<code class="fe md me mf mg b">then</code>方法，该方法将返回的URL作为参数。此URL将用于在用户设备上下载图像:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="798a" class="lf lg iq mg b gy mp mq l mr ms">.then((url) =&gt; {<br/>    //TODO download the image from the URL<br/>}).catch((err) =&gt; {<br/>    alert("Could not take screenshot")<br/>    senderResponse({success: false, message: err})<br/>})</span></pre><p id="00ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们还添加了<code class="fe md me mf mg b">catch</code>来捕捉任何错误。正如你在<code class="fe md me mf mg b">catch</code>回调中看到的，我们正在调用函数<code class="fe md me mf mg b">senderResponse</code>。这个函数是我们将在发送消息时从服务工作者或后台脚本传递给内容脚本的函数。</p><p id="ba73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe md me mf mg b">if</code>模块的末尾，我们将添加以下内容:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="e959" class="lf lg iq mg b gy mp mq l mr ms">return true;</span></pre><p id="3cfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe md me mf mg b">onMessage</code>事件监听器中，如果监听器返回true，这意味着我们稍后将使用发送消息时传递的回调函数向发送方返回响应。</p><h2 id="af6a" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">下载截图</h2><p id="3649" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">为了下载截图，我们将使用<a class="ae kx" href="https://developer.chrome.com/docs/extensions/reference/downloads" rel="noopener ugc nofollow" target="_blank">下载</a> API。它提供了很多方法来管理下载，比如搜索、打开、删除等等。</p><p id="ba25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用任何方法之前，我们需要将<code class="fe md me mf mg b">downloads</code>权限添加到<code class="fe md me mf mg b">manifest.json</code>中的<code class="fe md me mf mg b">permissions</code>数组:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="1fef" class="lf lg iq mg b gy mp mq l mr ms">"permissions": [<br/>    "desktopCapture",<br/>    "tabs",<br/>    "downloads"<br/>],</span></pre><p id="e456" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以使用下载API的方法。我们将使用方法<code class="fe md me mf mg b">chrome.downloads.download</code>，它将一个选项数组作为第一个参数，将一个回调函数作为第二个参数。</p><p id="d96e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，不能从内容脚本中调用此方法。我们需要从服务人员/后台脚本中调用它。因此，当我们前面到达代码中的<code class="fe md me mf mg b">TODO</code>部分时，我们需要向服务人员发送一条消息，其中包含我们想要下载的URL。</p><p id="4dda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在扩展中发送消息，我们使用了<code class="fe md me mf mg b">chrome.runtime.sendMessage</code>，它把要发送的消息(可以是任何类型)作为第一个参数，把可选的回调函数作为第二个参数，这个函数是消息的接收者应该调用来传递响应的函数。</p><p id="5c8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加以下代码代替<code class="fe md me mf mg b">TODO</code>注释:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="fbd7" class="lf lg iq mg b gy mp mq l mr ms">.then((url) =&gt; {<br/>    chrome.runtime.sendMessage({name: 'download', url}, (response) =&gt; {<br/>        if (response.success) {<br/>            alert("Screenshot saved");<br/>        } else {<br/>            alert("Could not save screenshot")<br/>        }<br/>        canvas.remove()<br/>        senderResponse({success: true})<br/>    })<br/>})</span></pre><p id="4c91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们正在向接收者发送消息<code class="fe md me mf mg b">{name: 'download', url}</code>。由于消息被发送给扩展中的每个侦听器，所以在发送的消息中包含一个消息属性以便能够处理不同的消息是很好的。我们还发送了下载图片的网址。</p><p id="5005" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们回到我们的服务人员。首先，让我们从前面做的<code class="fe md me mf mg b">chooseDesktopMedia</code>回调函数向内容脚本发送一条消息:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="b165" class="lf lg iq mg b gy mp mq l mr ms">//check whether the user canceled the request or not<br/>if (streamId &amp;&amp; streamId.length) {<br/>    setTimeout(() =&gt; {<br/>        chrome.tabs.sendMessage(tab.id, {name: "stream", streamId}, (response) =&gt; console.log(response))<br/>    }, 200)<br/>}</span></pre><p id="49f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，为了向内容脚本发送消息，我们使用了<code class="fe md me mf mg b">chrome.tabs.sendMessage</code>。这个与<code class="fe md me mf mg b">chrome.runtime.sendMessage</code>的区别在于，前者将消息发送给特定选项卡中的内容脚本，而第一个将消息发送给扩展中监听<code class="fe md me mf mg b">onMessage</code>处理程序的所有脚本。</p><p id="b0d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将向<code class="fe md me mf mg b">onMessage</code>事件添加一个监听器来接收<code class="fe md me mf mg b">download</code>消息，并将文件下载到用户的机器上:</p><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="e124" class="lf lg iq mg b gy mp mq l mr ms">chrome.runtime.onMessage.addListener((message, sender, senderResponse) =&gt; {<br/>    if (message.name === 'download' &amp;&amp; message.url) {<br/>        chrome.downloads.download({<br/>            filename: 'screenshot.png',<br/>            url: message.url<br/>        }, (downloadId) =&gt; {<br/>            senderResponse({success: true})<br/>        })<br/><br/>        return true;<br/>    }<br/>})</span></pre><p id="9a49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们检查消息的<code class="fe md me mf mg b">name</code>属性是否等于<code class="fe md me mf mg b">download</code>，以确保收到的消息是正确的。然后，我们使用<code class="fe md me mf mg b">chrome.downloads.download</code>下载文件，传递给它options对象，这里有两个选项:<code class="fe md me mf mg b">filename</code>是要下载的文件的名称，<code class="fe md me mf mg b">url</code>是要下载的URL。在<code class="fe md me mf mg b">downloads</code>方法的回调中，我们调用发送者传递的回调函数。</p><p id="2373" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的扩展现在准备好了。再次进入chrome://extensions，重新加载扩展。然后，转到任何页面，单击扩展的图标。系统会提示您选择整个屏幕、一个窗口或一个选项卡。一旦你选择，屏幕截图将被拍摄并保存在你的机器上。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="6842" class="lf lg iq bd lh li lj dn lk ll lm dp ln kj lo lp lq kn lr ls lt kr lu lv lw lx bi translated">结论</h2><p id="1e9e" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在本教程中，我们学习了如何截图和一些chrome扩展的概念。如果你想了解更多关于Chrome扩展的知识，一定要看看我关于浏览器扩展的教程。</p><p id="bdec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">如果您想联系并讨论更多关于本文或编程的内容，您可以在我的Twitter帐户上找到我</em><a class="ae kx" href="https://twitter.com/shahednasserr" rel="noopener ugc nofollow" target="_blank"><em class="kw">@ shahednasserr</em></a></p></div></div>    
</body>
</html>