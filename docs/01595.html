<html>
<head>
<title>TypeScript Advanced Types — `this` Type and Dynamic Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript高级类型—“this”类型和动态类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-advanced-types-this-type-and-dynamic-types-ecb99c4ec275?source=collection_archive---------2-----------------------#2020-01-15">https://levelup.gitconnected.com/typescript-advanced-types-this-type-and-dynamic-types-ecb99c4ec275?source=collection_archive---------2-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3db8f0694af50f906d976bdfa8a7576b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GsYgRHBP751AzSk8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jfbrou?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jf博鲁</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="82dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript具有许多高级类型功能，这使得编写动态类型代码变得很容易。它还有助于采用现有的JavaScript代码，因为它允许我们在使用TypeScript的类型检查功能的同时保留JavaScript的动态功能。TypeScript中有很多种高级类型，如交集类型、联合类型、类型保护、可空类型和类型别名等等。在本文中，我们将研究<code class="fe le lf lg lh b">this</code>类型，并使用索引签名和映射类型创建动态类型。</p><h1 id="61cf" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">这种类型</h1><p id="0772" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在TypeScript中，我们可以使用<code class="fe le lf lg lh b">this</code>作为类型。它表示包含类或接口的子类型。我们可以使用它轻松地创建流畅的接口，因为我们知道类中的每个方法都将返回类的实例。</p><p id="12df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用它来定义一个具有可链接方法的类，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="116c" class="mt lj it lh b gy mu mv l mw mx">class StringAdder {<br/>  value: string = '';<br/>  getValue(): string {<br/>    return this.value;<br/>  }</span><span id="3ce0" class="mt lj it lh b gy my mv l mw mx">  addFoo(): this {<br/>    this.value += 'foo';<br/>    return this;<br/>  }</span><span id="2248" class="mt lj it lh b gy my mv l mw mx">  addBar(): this {<br/>    this.value += 'bar';<br/>    return this;<br/>  }</span><span id="bae2" class="mt lj it lh b gy my mv l mw mx">  addGreeting(name: string): this {<br/>    this.value += `Hi ${name}`;<br/>    return this;<br/>  }<br/>}</span><span id="0654" class="mt lj it lh b gy my mv l mw mx">const stringAdder: StringAdder = new StringAdder();<br/>const str = stringAdder<br/>  .addFoo()<br/>  .addBar()<br/>  .addGreeting('Jane')<br/>  .getValue();<br/>console.log(str);</span></pre><p id="ee63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe le lf lg lh b">addFoo</code>、<code class="fe le lf lg lh b">addBar</code>和<code class="fe le lf lg lh b">addGreeting</code>方法都返回了<code class="fe le lf lg lh b">StringAdder</code>类的实例，一旦实例被实例化，我们就可以将实例的更多方法调用链接到它。链接是通过我们在每个方法中拥有的<code class="fe le lf lg lh b">this</code>返回类型实现的。</p><h1 id="f435" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">索引类型</h1><p id="2bb1" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">要让TypeScript编译器用动态属性名检查代码，我们可以使用索引类型。我们可以使用<code class="fe le lf lg lh b">extends keyof</code>关键字组合来表示该类型具有另一种类型的属性名。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f35b" class="mt lj it lh b gy mu mv l mw mx">function choose&lt;U, K extends keyof U&gt;(o: U, propNames: K[]): U[K][] {<br/>  return propNames.map(n =&gt; o[n]);<br/>}</span></pre><p id="a0c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用下面代码中的<code class="fe le lf lg lh b">choose</code>函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="06e1" class="mt lj it lh b gy mu mv l mw mx">function choose&lt;U, K extends keyof U&gt;(o: U, propNames: K[]): U[K][] {<br/>  return propNames.map(n =&gt; o[n]);<br/>}</span><span id="a7c9" class="mt lj it lh b gy my mv l mw mx">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}<br/>choose(obj, ['a', 'b'])</span></pre><p id="de26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="db5e" class="mt lj it lh b gy mu mv l mw mx">[1, 2]</span></pre><p id="9cf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们记录<code class="fe le lf lg lh b">choose</code>函数的结果。如果我们将一个不存在于<code class="fe le lf lg lh b">obj</code>对象中的属性名传递到第二个<code class="fe le lf lg lh b">choose</code>函数的数组中，那么我们会从TypeScript编译器得到一个错误。因此，如果我们编写如下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c45e" class="mt lj it lh b gy mu mv l mw mx">function choose&lt;U, K extends keyof U&gt;(o: U, propNames: K[]): U[K][] {<br/>  return propNames.map(n =&gt; o[n]);<br/>}</span><span id="c269" class="mt lj it lh b gy my mv l mw mx">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}<br/>const arr = choose(obj, ['d']);</span></pre><p id="9cc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3c63" class="mt lj it lh b gy mu mv l mw mx">Type 'string' is not assignable to type '"a" | "b" | "c"'.(2322)</span></pre><p id="c7d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，<code class="fe le lf lg lh b">keyof U</code>与字符串文字类型<code class="fe le lf lg lh b">“a” | “b” | “c”</code>相同，因为我们传入了泛型<code class="fe le lf lg lh b">U</code>类型标记的类型，其中实际类型是从我们传入第一个参数的对象中推断出来的。<code class="fe le lf lg lh b">K extends keyof U</code>部分意味着第二个参数必须有传递给第一个参数的部分或全部键名的数组，我们用泛型<code class="fe le lf lg lh b">U</code>类型表示。然后，我们将返回类型定义为一个值数组，我们通过循环传递给第一个参数的对象来获得该数组，因此我们有了<code class="fe le lf lg lh b">U[K][]</code>类型。<code class="fe le lf lg lh b">U[K][]</code>也叫索引访问操作符。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/139f3003181bbaddf608ec93157a19de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*obshuiUdOxRYofvF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@marjan_blan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">марьянблан| @ marjanblan</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="013b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">索引类型和索引签名</h1><p id="806d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">索引签名是一个参数，它在TypeScript接口中必须是字符串或数字类型。我们可以用它来表示动态对象的属性。例如，我们可以像在下面的代码中一样使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="790f" class="mt lj it lh b gy mu mv l mw mx">interface DynamicObject&lt;T&gt; {<br/>  [key: string]: T;<br/>}<br/>let obj: DynamicObject&lt;number&gt; = {<br/>  foo: 1,<br/>  bar: 2<br/>};<br/>let key: keyof DynamicObject&lt;number&gt; = 'foo';<br/>let value: DynamicObject&lt;number&gt;['foo'] = obj[key];</span></pre><p id="b5bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们定义了一个<code class="fe le lf lg lh b">DynamicObject&lt;T&gt;</code>接口，它的成员采用动态类型。我们有一个名为<code class="fe le lf lg lh b">key</code>的索引签名，它是一个字符串。也可以是数字。动态成员的类型由通用类型标记符<code class="fe le lf lg lh b">T</code>表示。这意味着我们可以向它传递任何数据类型。</p><p id="ff31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们定义了类型为<code class="fe le lf lg lh b">DyanmicObject&lt;number&gt;</code>的<code class="fe le lf lg lh b">obj</code>对象。这利用了我们之前创建的<code class="fe le lf lg lh b">DynamicObject</code>接口。然后我们定义了类型为<code class="fe le lf lg lh b">keyof DynamicObject&lt;number&gt;</code>的<code class="fe le lf lg lh b">key</code>变量，这意味着它必须是一个字符串或数字。这意味着<code class="fe le lf lg lh b">key</code>变量必须有一个属性名作为值。然后我们定义了<code class="fe le lf lg lh b">value</code>变量，它必须有一个<code class="fe le lf lg lh b">DynamicObject</code>类型的对象的值。</p><p id="d594" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着除了字符串或数字之外，我们不能给<code class="fe le lf lg lh b">key</code>变量赋值。所以如果写下这样的话:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2bf5" class="mt lj it lh b gy mu mv l mw mx">let key: keyof DynamicObject&lt;number&gt; = false;</span></pre><p id="4f94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们从TypeScript编译器得到以下错误消息:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7bda" class="mt lj it lh b gy mu mv l mw mx">Type 'false' is not assignable to type 'string | number'.(2322)</span></pre><h1 id="41c5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">映射类型</h1><p id="b4da" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以通过将现有类型的成员映射到新类型来创建新类型。这称为映射类型。</p><p id="262d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像在下面的代码中那样创建映射类型:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="79df" class="mt lj it lh b gy mu mv l mw mx">interface Person {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="fd61" class="mt lj it lh b gy my mv l mw mx">type ReadOnly&lt;T&gt; = {<br/>  readonly [P in keyof T]: T[P];<br/>}</span><span id="b299" class="mt lj it lh b gy my mv l mw mx">type PartialType&lt;T&gt; = {<br/>  [P in keyof T]?: T[P];<br/>}</span><span id="3d27" class="mt lj it lh b gy my mv l mw mx">type ReadOnlyPerson = ReadOnly&lt;Person&gt;;<br/>type PartialPerson = PartialType&lt;Person&gt;;</span><span id="e9bc" class="mt lj it lh b gy my mv l mw mx">let readOnlyPerson: ReadOnlyPerson = {<br/>  name: 'Jane',<br/>  age: 20<br/>}</span><span id="6aa9" class="mt lj it lh b gy my mv l mw mx">readOnlyPerson.name = 'Joe';<br/>readOnlyPerson.age = 20;</span></pre><p id="0653" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了<code class="fe le lf lg lh b">ReadOnly</code>类型别名，让我们通过将类型的每个成员设置为<code class="fe le lf lg lh b">readonly</code>来将现有类型的成员映射到新类型。这本身并不是一个新类型，因为我们需要将一个类型传递给泛型类型标记<code class="fe le lf lg lh b">T</code>。然后，我们为我们定义的类型创建一个别名，方法是将<code class="fe le lf lg lh b">Person</code>类型分别传入<code class="fe le lf lg lh b">ReadOnly</code>别名和<code class="fe le lf lg lh b">Partial</code>别名。</p><p id="eeb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们用设置的<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">age</code>属性定义了一个<code class="fe le lf lg lh b">ReadOnlyPerson</code>对象。然后，当我们再次尝试设置这些值时，会出现以下错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b7d0" class="mt lj it lh b gy mu mv l mw mx">Cannot assign to 'name' because it is a read-only property.(2540)</span><span id="f048" class="mt lj it lh b gy my mv l mw mx">Cannot assign to 'age' because it is a read-only property.(2540)</span></pre><p id="52ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着来自<code class="fe le lf lg lh b">ReadOnly</code>类型别名的<code class="fe le lf lg lh b">readonly</code>属性正在被执行。同样，我们可以对<code class="fe le lf lg lh b">PartialType</code>类型别名做同样的事情。我们通过将<code class="fe le lf lg lh b">Person</code>类型的成员映射到具有<code class="fe le lf lg lh b">PartialPerson</code>类型的<code class="fe le lf lg lh b">PartialPerson</code>类型来定义<code class="fe le lf lg lh b">PartialPerson</code>类型。然后我们可以像下面的代码一样定义一个<code class="fe le lf lg lh b">PartialPerson</code>对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f7bb" class="mt lj it lh b gy mu mv l mw mx">let partialPerson: PartialPerson = {};</span></pre><p id="09f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，我们可以根据需要省略<code class="fe le lf lg lh b">partialPerson</code>对象的属性。</p><p id="b069" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过从映射的类型别名创建一个交集类型来向它添加新成员。因为我们使用了<code class="fe le lf lg lh b">type</code>关键字来定义映射的类型，所以它们实际上是类型。它们实际上是类型别名。这意味着我们不能把成员直接放在里面，即使它们看起来像接口。</p><p id="035a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要添加成员，我们可以编写如下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0f9d" class="mt lj it lh b gy mu mv l mw mx">interface Person {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="c9b2" class="mt lj it lh b gy my mv l mw mx">type ReadOnly&lt;T&gt; = {<br/>  readonly [P in keyof T]: T[P];<br/>}</span><span id="240d" class="mt lj it lh b gy my mv l mw mx">type ReadOnlyEmployee = ReadOnly&lt;Person&gt; &amp; {<br/>  employeeCode: string;<br/>};</span><span id="0478" class="mt lj it lh b gy my mv l mw mx">let readOnlyPerson: ReadOnlyEmployee = {<br/>  name: 'Jane',<br/>  age: 20,<br/>  employeeCode: '123'<br/>}</span></pre><p id="001e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Readonly&lt;T&gt;</code>和<code class="fe le lf lg lh b">Partial&lt;T&gt;</code>包含在TypeScript标准库中。<code class="fe le lf lg lh b">Readonly</code>将我们传递给泛型类型占位符的类型成员映射到只读成员。关键字<code class="fe le lf lg lh b">Partial</code>让我们将一个类型的成员映射为可空成员。</p><h1 id="70d2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="51cc" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在TypeScript中，我们可以使用<code class="fe le lf lg lh b">this</code>作为类型。它表示包含类或接口的子类型。我们可以使用它轻松地创建流畅的接口，因为我们知道类中的每个方法都将返回类的实例。索引签名是一个参数，它在TypeScript接口中必须是字符串或数字类型。</p><p id="8479" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它来表示动态对象的属性。要转换某个类型的成员以向其添加一些属性，我们可以将现有类型的成员映射到新类型中，以便向具有映射类型的接口添加属性。</p></div></div>    
</body>
</html>