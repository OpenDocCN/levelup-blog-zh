<html>
<head>
<title>Use Modules to Better Organize your Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模块更好地组织您的Python代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-modules-to-better-organize-your-python-code-75690ba6b6e?source=collection_archive---------9-----------------------#2022-04-03">https://levelup.gitconnected.com/use-modules-to-better-organize-your-python-code-75690ba6b6e?source=collection_archive---------9-----------------------#2022-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0b91" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解Python模块以及如何使用它们来更好地组织您不断增长的代码库。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/61e8ef0d52eb1b373496603b81a45028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yH3htbUWmM0Xp2kW"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@lastnameeaster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> La-Rel复活节</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6fb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何有编写Python代码经验的人都应该熟悉像<code class="fe ls lt lu lv b">import x</code>这样的语句或它的一些变体。这是Python让其用户使用额外功能的方式，这些功能以<em class="lw">模块</em>和<em class="lw">函数</em>的形式出现。在本帖中，我们将尝试理解Python <em class="lw">模块</em>。</p><p id="f186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将要讨论的内容:</p><ol class=""><li id="13f8" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">什么和为什么？<br/> —什么是模块？<br/> —为什么使用模块是有用的<br/> —理解<em class="lw">名称空间</em></li><li id="3c86" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">如何使用一个模块？<br/> —导入模块及其组件的不同方式<br/> —演示模块的用途<br/> —如何检查模块的组件</li><li id="dde9" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">内置模块</li><li id="45af" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">后续步骤</li></ol><h1 id="7765" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">什么和为什么？</h1><p id="f420" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">很快你开始编码，你会发现你的代码有增长的趋势。管理不断增长的代码库的有效方法是将代码分解成更小的、可管理的块。这样这些模块不仅可以单独运行，还可以作为更大项目的一部分一起工作。模块是我们组织独立代码块的一种方式。</p><blockquote class="ni"><p id="521c" class="nj nk iq bd nl nm nn no np nq nr lr dk translated">模块是一个包含Python定义和语句的文件—来源: <a class="ae kv" href="https://docs.python.org/3/tutorial/modules.html" rel="noopener ugc nofollow" target="_blank"> <em class="ns"> Python教程</em> </a></p></blockquote><p id="8d8e" class="pw-post-body-paragraph kw kx iq ky b kz nt jr lb lc nu ju le lf nv lh li lj nw ll lm ln nx lp lq lr ij bi translated">例如，让我们假设您已经创建了在不同项目中经常使用的可重用函数。使用它们的非模块化方式可能是，</p><ul class=""><li id="3f0d" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr ny md me mf bi translated">直接复制和粘贴每个项目中的函数，或者</li><li id="7738" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr ny md me mf bi translated">将它们保存在脚本中，并在项目期间运行脚本。例如，可以使用神奇的命令<code class="fe ls lt lu lv b">%run</code>来执行这样的脚本。</li></ul><p id="d6f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种选择有重复工作的明显限制。而第二种选择是一个更好的主意，但是具有以下限制:</p><ul class=""><li id="688d" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr ny md me mf bi translated">通过执行脚本，您实际上创建了脚本中所有可用的变量和函数。因此，您可以用该脚本的所有组件加载您的工作区，即使您只需要选择几个组件。</li><li id="8e64" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr ny md me mf bi translated">此外，创建的对象将占用<em class="lw">名称空间</em>，并可能导致名称冲突或意想不到的后果。稍后将详细介绍名称空间。</li><li id="5b90" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr ny md me mf bi translated">第三，在极端情况下，它可能会使您面临风险，尤其是当您正在处理一个开放的项目或使用别人的脚本时。如果您盲目地执行这样的脚本，您可能最终会运行一些恶意代码，从而暴露您的恶意意图。</li></ul><p id="2074" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用模块给了我们一种克服这些限制的方法。我们将在下一节中演示使用模块如何帮助我们克服这些限制，同时我们将讨论如何使用模块。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="ea61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">💡关于名称空间的说明</strong></p><p id="83cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们讨论了术语— <em class="lw">名称空间</em>。简单来说，名称空间是在计算机中分配的内存空间，其中存在对象名称。在命名空间内，名称在命名空间内是唯一的。如果我们把名称空间看作组，那么不同的组可能有同名的成员，但是在一个组中不会有任何重名。使用模块是保持名称空间独立和干净的好方法。</p><blockquote class="og oh oi"><p id="736e" class="kw kx lw ky b kz la jr lb lc ld ju le oj lg lh li ok lk ll lm ol lo lp lq lr ij bi translated"><em class="iq">当一个模块被正确使用时，Python使得来自该模块的所有名字都可用，但是不使它们对代码的名称空间可用。</em></p></blockquote><p id="fe6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一节中的演示小节应该会说明这一点。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="e406" class="ml mm iq bd mn mo om mq mr ms on mu mv jw oo jx mx jz op ka mz kc oq kd nb nc bi translated">如何使用一个模块？</h1><p id="145e" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">让我们首先创建一个名为<code class="fe ls lt lu lv b">messingAround.py</code>的Python脚本，并将其保存在我们将运行Python程序的同一个目录中。这将是我们函数和变量的家。首先，让我们在<code class="fe ls lt lu lv b">messingAround.py</code>中定义一个变量<code class="fe ls lt lu lv b">pi = 6.38</code>和一个函数<code class="fe ls lt lu lv b">makeHalf()</code>。因此，该脚本将如下所示:</p><pre class="kg kh ki kj gt or lv os ot aw ou bi"><span id="65d8" class="ov mm iq lv b gy ow ox l oy oz"># messingAround module<br/>pi = 6.38</span><span id="9153" class="ov mm iq lv b gy pa ox l oy oz">def makeHalf(val):<br/>    return val/2</span></pre><h2 id="f990" class="ov mm iq bd mn pb pc dn mr pd pe dp mv lf pf pg mx lj ph pi mz ln pj pk nb pl bi translated">导入方式</h2><p id="032f" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">要使一个模块可用，我们必须使用关键字<code class="fe ls lt lu lv b">import</code>导入它。导入模块有不同的方法。以<code class="fe ls lt lu lv b">messingAround</code>为例，我们将看到导入模块的不同方式:</p><ul class=""><li id="8c8f" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr ny md me mf bi translated">我们可以通过简单地调用<code class="fe ls lt lu lv b">import messingAround</code>来导入整个模块。<br/> —这将使模块的所有组件可供调用。但是不会将它们作为Python对象加载。<br/> —我们也可以像<code class="fe ls lt lu lv b">import &lt;module01&gt; &lt;module02&gt;</code>一样在一行中调用多个模块。</li><li id="2f42" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr ny md me mf bi translated">我们可以从一个模块中导入特定组件。在我们的例子中，我们可以通过调用<code class="fe ls lt lu lv b">from messingAround import pi</code>从<code class="fe ls lt lu lv b">messingAround</code>模块加载<code class="fe ls lt lu lv b">pi</code>。<br/> —我们也可以通过添加由逗号分隔的组件名称:<code class="fe ls lt lu lv b">from module01 import component01, component02</code>使用单行从同一个模块导入多个组件。</li><li id="d762" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr ny md me mf bi translated">我们可以在导入模块或组件时给它们起别名:<br/>——将<code class="fe ls lt lu lv b">messingAround</code>导入为<code class="fe ls lt lu lv b">ma</code> : <code class="fe ls lt lu lv b">import messingAround as ma</code>。<br/> —导入组件01作为c01，组件02作为c02: <code class="fe ls lt lu lv b">from module01 import component01 as c01, component02 as c02</code>。<br/> —🚨请记住，如果您在导入时给出了别名，您将不得不通过别名来调用它们。用他们的真名称呼他们不再管用了。</li><li id="2740" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr ny md me mf bi translated">我们可以通过调用<code class="fe ls lt lu lv b">from messingAround import *</code>从一个模块中加载任何东西。<br/> —🚨在任何情况下，你都不可能想那么做。这与执行脚本本质上是一样的，并且带有我们前面讨论过的所有限制。</li></ul><h2 id="601c" class="ov mm iq bd mn pb pc dn mr pd pe dp mv lf pf pg mx lj ph pi mz ln pj pk nb pl bi translated">演示</h2><p id="b7d8" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">出于演示目的，我们将使用一个名为<code class="fe ls lt lu lv b">math</code>的内置Python模块以及我们的练习模块<code class="fe ls lt lu lv b">messingAround</code>。这些演示将展示如何使用模块，以及它们如何帮助我们避免命名空间的复杂性。</p><p id="3cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">导入模块并使用其组件</strong></p><pre class="kg kh ki kj gt or lv os ot aw ou bi"><span id="37da" class="ov mm iq lv b gy ow ox l oy oz">import messingAround as ma<br/>import math as m</span><span id="e52b" class="ov mm iq lv b gy pa ox l oy oz">pi = m.pi * 3</span><span id="d0aa" class="ov mm iq lv b gy pa ox l oy oz">print("My pi value = {} \nmessingAround's pi value = {} \nMath module's pi value = {}".format(pi, ma.pi, m.pi))</span><span id="3d87" class="ov mm iq lv b gy pa ox l oy oz">My pi value = 9.42477796076938 <br/>messingAround's pi value = 6.28 <br/>Math module's pi value = 3.141592653589793</span></pre><p id="09d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Math</code>模块带有一个名为<code class="fe ls lt lu lv b">pi</code>的变量，其中包含π的值。我们的模块中还有一个同名但值不同的变量。在此基础上，我们使用来自<code class="fe ls lt lu lv b">math</code>模块的<code class="fe ls lt lu lv b">pi</code>变量创建了一个定制的<code class="fe ls lt lu lv b">pi</code>变量。</p><p id="8a3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们是如何使用点符号调用模块中的<code class="fe ls lt lu lv b">pi</code>变量和我们的自定义<code class="fe ls lt lu lv b">pi</code>变量的，并且没有在名称空间冲突/混淆中结束- <code class="fe ls lt lu lv b">pi</code>来自不同来源的变量保留了它们的值。</p><p id="6a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">使用魔法命令并导入* </strong></p><p id="ebec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，考虑下面的例子。</p><pre class="kg kh ki kj gt or lv os ot aw ou bi"><span id="4b4e" class="ov mm iq lv b gy ow ox l oy oz"># import *<br/>from messingAround import *<br/>import math as m<br/>print("pi value = {} \nMath module's pi value = {}".format(pi, m.pi))</span><span id="64d3" class="ov mm iq lv b gy pa ox l oy oz">print()<br/>pi = m.pi * 3<br/>print("pi value = {} \nMath module's pi value = {}".format(pi, m.pi))</span><span id="1e5f" class="ov mm iq lv b gy pa ox l oy oz">pi value = 6.28 <br/>Math module's pi value = 3.141592653589793</span><span id="909d" class="ov mm iq lv b gy pa ox l oy oz">pi value = 9.42477796076938 <br/>Math module's pi value = 3.141592653589793</span></pre><p id="cfde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，<code class="fe ls lt lu lv b">pi</code>的值是如何不断变化的！</p><ul class=""><li id="8093" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr ny md me mf bi translated">当我们从<code class="fe ls lt lu lv b">messingAround</code>模块加载所有内容时，一个名为<code class="fe ls lt lu lv b">pi</code>的变量在我们的工作空间中被创建——检查打印出的值6.28。</li><li id="73cb" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr ny md me mf bi translated">但是一旦我们创建了一个新变量并给它起了同样的名字— <code class="fe ls lt lu lv b">pi</code>，从<code class="fe ls lt lu lv b">messingAround</code>模块加载的原始变量就被这个新变量替换了。检查<code class="fe ls lt lu lv b">pi</code>的值后来是如何变化的。</li><li id="e3d5" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr ny md me mf bi translated">同时注意来自<code class="fe ls lt lu lv b">math</code>模块的<code class="fe ls lt lu lv b">pi</code>变量的值保持不变。</li></ul><p id="ad1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑用<code class="fe ls lt lu lv b">%run -i messingAround.py</code>代替了这一行<code class="fe ls lt lu lv b">from messingAround import *</code>。结果一样吗？想想“为什么”？</p><h2 id="5d05" class="ov mm iq bd mn pb pc dn mr pd pe dp mv lf pf pg mx lj ph pi mz ln pj pk nb pl bi translated">偷窥模块内部</h2><p id="0c59" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">当模块变得更大时，我们可能希望在导入模块后立即检查模块内部的内容。<code class="fe ls lt lu lv b">dir()</code>允许我们这样做。<code class="fe ls lt lu lv b">dir(&lt;module name/alias&gt;)</code>按字母顺序打印组件。</p><pre class="kg kh ki kj gt or lv os ot aw ou bi"><span id="e597" class="ov mm iq lv b gy ow ox l oy oz">dir(ma)</span><span id="5a31" class="ov mm iq lv b gy pa ox l oy oz">['__builtins__',<br/> '__cached__',<br/> '__doc__',<br/> '__file__',<br/> '__loader__',<br/> '__name__',<br/> '__package__',<br/> '__spec__',<br/> 'makeHalf',<br/> 'pi']</span></pre><p id="5ff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，输出列出了我们的两个组件<code class="fe ls lt lu lv b">makeHalf</code>和<code class="fe ls lt lu lv b">pi</code>。现在，忽略带有下划线的组件。当我们讨论构建Python包时，我们会谈到这些。</p><h1 id="0af0" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">内置模块和Python模块索引</h1><p id="1a76" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">当我们安装Python时，我们得到了一堆模块。如果你把Python看作一辆汽车，那么Python程序本身就像是基本模型，所有的模块都像是插件/升级。所有这些模块和内置函数被称为<a class="ae kv" href="https://docs.python.org/3/library/index.html" rel="noopener ugc nofollow" target="_blank"> Python标准库</a>。</p><p id="4ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要找到Python模块的详细列表，你可以查看官方的<a class="ae kv" href="https://docs.python.org/3/py-modindex.html" rel="noopener ugc nofollow" target="_blank"> Python模块索引</a>网站。不过，提醒一句，</p><blockquote class="og oh oi"><p id="9734" class="kw kx lw ky b kz la jr lb lc ld ju le oj lg lh li ok lk ll lm ol lo lp lq lr ij bi translated">不要被模块的数量淹没。选择与您的目标相关的内容，即数据科学与应用程序开发，并只关注它们。</p></blockquote><h1 id="2a70" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">下一步是什么？</h1><p id="5568" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">理解模块是理解Python <em class="lw">包</em>的第一步。包实际上是模块的集合。在这篇文章中，我们学习了模块，使用模块的好处，以及如何使用它们。在后续的文章中，我们将学习如何在一个包中组织我们的模块。</p><p id="680f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">更新:</strong>查看下一篇帖子，了解如何从模块中获得包:</p><div class="pm pn gp gr po pp"><a href="https://towardsdatascience.com/from-functions-to-python-package-f8a3bba8bb6b" rel="noopener follow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd ir gy z fp pu fr fs pv fu fw ip bi translated">从函数到Python包</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">从头开始学习如何将函数转换成包并分发</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">towardsdatascience.com</p></div></div><div class="py l"><div class="pz l qa qb qc py qd kp pp"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="92f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢你阅读这篇文章。如果你喜欢这篇文章，请点击这里查看我的Python系列面向对象编程:<a class="ae kv" href="https://medium.com/@curious-joe" rel="noopener">https://medium.com/@curious-joe</a>。</p></div></div>    
</body>
</html>