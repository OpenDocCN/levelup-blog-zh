<html>
<head>
<title>Extending glidex.forms on Android to load a placeholder for images that fail to load</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展Android上的glidex.forms，为加载失败的图片加载一个占位符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/extending-glidex-forms-on-android-to-load-a-placeholder-for-images-that-fail-to-load-6d16c1d22e03?source=collection_archive---------11-----------------------#2021-03-26">https://levelup.gitconnected.com/extending-glidex-forms-on-android-to-load-a-placeholder-for-images-that-fail-to-load-6d16c1d22e03?source=collection_archive---------11-----------------------#2021-03-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f1a0f2140223f3fd09b2f01233f6cedb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LDujzqRtYmhBUNQb.png"/></div></div></figure><h2 id="49d0" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是glidex.forms？</h2><p id="74f8" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><code class="fe lp lq lr ls b">glidex.forms</code>库是<a class="ae lt" href="https://github.com/bumptech/glide" rel="noopener ugc nofollow" target="_blank"> Glide </a>的<code class="fe lp lq lr ls b">Xamarin.Forms</code>实现，是Android上成像的准标准之一(甚至是Google推荐的)。幸运的是，来自微软的Jonathan Peppers热情地想要改善T2，而T3也从中获益匪浅。他制作了<code class="fe lp lq lr ls b">Xamarin.Android</code>绑定库以及<code class="fe lp lq lr ls b">Xamarin.Forms</code>实现。<a class="ae lt" href="https://msicc.net/extending-xamarin-forms-nuke-to-load-a-placeholder-for-images-that-fail-to-load/" rel="noopener ugc nofollow" target="_blank">像以前一样用Xamarin。Forms.Nuke </a>，我了解了这个库，因为我用Akavache替换了我以前的图像缓存解决方案。</p><h2 id="386c" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">为什么我们需要扩建图书馆？</h2><p id="7f2a" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">如果你想加载一个存储在你的Android项目资源中的占位符——没有必要。你可以在<code class="fe lp lq lr ls b">glidex.forms</code>的<code class="fe lp lq lr ls b">GlideExtensions</code>类中实现一个定制的钩子(我也将展示给你看)。但是如果你想从一个<code class="fe lp lq lr ls b">Xamarin.Forms</code>资源或者一个字体中加载一个图像，我们需要稍微扩展一下<code class="fe lp lq lr ls b">GlideExtensions</code>类。</p><p id="2170" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">顺便说一下，我试图使用现有的机制来实现这些目的的<code class="fe lp lq lr ls b">IGlideHandler </code>，但是由于时间问题，我从来没有能够加载这些类型的占位符，我通过扩展<code class="fe lp lq lr ls b">GlideExtensions</code>类继续前进。</p><h2 id="6e06" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">给我看看代码！</h2><p id="b64b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><em class="lz">使用安卓资源</em></p><p id="ea90" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">我们先来看看如何加载一个Android资源作为占位符(因为这是最简单的方法)。为此，我们只需要在Android项目中创建一个<code class="fe lp lq lr ls b">IGlideHandler</code>的自定义实现，然后由<code class="fe lp lq lr ls b">GlideExtensions</code>实现调用:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="a28d" class="jy jz iq ls b gy mi mj l mk ml">public class GlideWithAndroidResourcePlaceholder : IGlideHandler<br/>{<br/>    public GlideWithAndroidResourcePlaceholder()<br/>    {<br/>    }<br/><br/>    public bool Build(ImageView imageView, ImageSource source, RequestBuilder builder, CancellationToken token)<br/>    {<br/>        if (builder != null)<br/>        {<br/>            //easiest way - add the image to Android resources ....<br/>            //general placeholder:<br/>            //builder.Placeholder(Resource.Drawable.MSicc_Logo_Base_Blue_1024px_pad25).Into(imageView);<br/><br/>            //error placeholder:<br/>            builder.Error(Resource.Drawable.MSicc_Logo_Base_Blue_1024px_pad25).Into(imageView);<br/><br/>            return true;<br/>        }<br/>        else<br/>            return false;<br/>    }<br/>}</span></pre><p id="ac64" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">如您所见，<code class="fe lp lq lr ls b">RequestBuilder</code>已经有了一个占位符机制。我们只是把它钩进去。如果您想要一个通用占位符(在下载过程中也显示图像)，请使用<code class="fe lp lq lr ls b">Placeholder</code>方法。仅对于加载失败的图像，使用<code class="fe lp lq lr ls b">Error </code>方法。就是这样。</p><p id="0fa7" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated"><em class="lz">使用Xamarin。表单资源/FontImageSource </em></p><p id="22e6" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">然而，由于我们希望能够加载<code class="fe lp lq lr ls b">FontImageSource</code>和<code class="fe lp lq lr ls b">Xamarin.Forms</code>资源，我们需要走另一条路线。像我们在iOS上做的一样，我们需要给<code class="fe lp lq lr ls b">Forms</code>类添加一个占位符属性:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="159a" class="jy jz iq ls b gy mi mj l mk ml">public static ImageSource? PlaceholderImageSource { get; private set; }</span></pre><p id="a631" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">要用<code class="fe lp lq lr ls b">Xamarin.Forms</code>资源或<code class="fe lp lq lr ls b">FontImageSource</code>填充我们的<code class="fe lp lq lr ls b">ImageSource</code>，也要添加这两个方法:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="7b45" class="jy jz iq ls b gy mi mj l mk ml">public static void PlaceholderFromResource (string resourceName, Assembly assembly) =&gt;<br/>    PlaceholderImageSource = ImageSource.FromResource (resourceName, assembly);<br/><br/>public static void PlaceholderFromFontImageSource (FontImageSource fontImageSource) =&gt;<br/>    PlaceholderImageSource = fontImageSource;</span></pre><p id="4435" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">现在我们已经有了<code class="fe lp lq lr ls b">PlaceholderImageSource</code>，我们需要扩展<code class="fe lp lq lr ls b">GlideExtensions</code>类。首先，我们为<code class="fe lp lq lr ls b">FontImageSource</code>实现一个处理程序。<code class="fe lp lq lr ls b">FontImageSource</code>的<code class="fe lp lq lr ls b">Xamarin.Forms</code>处理程序为我们提供了一个位图，我们将用它作为占位符。我只在使用<code class="fe lp lq lr ls b">AsDrawable</code>方法时得到了这个，因为<code class="fe lp lq lr ls b">AsBitmap</code>方法不能将<code class="fe lp lq lr ls b">Bitmap</code>转换为<code class="fe lp lq lr ls b">Drawable</code>，所以它总是抛出一个异常(我没有做进一步的调查)。</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="2db5" class="jy jz iq ls b gy mi mj l mk ml">private static async Task&lt;RequestBuilder?&gt; HandleFontImageSource (RequestManager request, Context? context, FontImageSource fontImageSource, CancellationToken token, Func&lt;bool&gt; cancelled)<br/>{<br/>    if (context == null)<br/>        return null;<br/><br/>    var defaultHandler = new Xamarin.Forms.Platform.Android.FontImageSourceHandler ();<br/><br/>    var bitmap = await defaultHandler.LoadImageAsync (fontImageSource, context, token);<br/><br/>    if (token.IsCancellationRequested || cancelled())<br/>        return null;<br/><br/>    if (bitmap == null)<br/>        return null;<br/><br/>    return request.AsDrawable().Load (bitmap);<br/>}</span></pre><p id="df88" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">至于<code class="fe lp lq lr ls b">HandleFontImageSource</code>方法，我还需要更改<code class="fe lp lq lr ls b">HandleStreamImageSource</code>方法的返回值以使用<code class="fe lp lq lr ls b">AsDrawable</code>方法，否则我们将得到与<code class="fe lp lq lr ls b">FontImageSource</code>相同的异常:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="f375" class="jy jz iq ls b gy mi mj l mk ml">static async Task&lt;RequestBuilder?&gt; HandleStreamImageSource (RequestManager request, StreamImageSource source, CancellationToken token, Func&lt;bool&gt; cancelled) { //code omitted for readability return request.AsDrawable().Load (memoryStream.ToArray ()); }</span></pre><p id="17b7" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">使其全部工作的最后步骤在<code class="fe lp lq lr ls b">LoadViaGlide</code>方法中完成。首先，添加另一个<code class="fe lp lq lr ls b">RequestBuilder?</code>变量，并将其命名为<code class="fe lp lq lr ls b">errorBuilder</code>:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="543c" class="jy jz iq ls b gy mi mj l mk ml">RequestBuilder? errorBuilder = null;</span></pre><p id="22c4" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">在处理<code class="fe lp lq lr ls b">source</code>参数的开关之后，添加以下几行代码:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="ef64" class="jy jz iq ls b gy mi mj l mk ml">switch(Forms.PlaceholderImageSource) { case StreamImageSource streamSource: errorBuilder = await HandleStreamImageSource (request, streamSource, token, () =&gt; !IsActivityAlive (imageView, Forms.PlaceholderImageSource)); break; case FontImageSource fontImageSource: errorBuilder = await HandleFontImageSource(request, imageView.Context, fontImageSource, token, () =&gt; !IsActivityAlive (imageView, Forms.PlaceholderImageSource)); break; default: errorBuilder = null; break; } if (errorBuilder != null) builder?.Error (errorBuilder);</span></pre><p id="bfa3" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">我们处理我们的<code class="fe lp lq lr ls b">PlaceholderImageSource</code>就像我们处理我们想要加载的<code class="fe lp lq lr ls b">ImageSource</code>一样。如果我们有一个有效的<code class="fe lp lq lr ls b">errorBuilder</code>，我们把它传递给整个过程。至此，我们已经万事俱备。让我们看看如何在您的应用程序中使用它。</p><h2 id="6f49" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">如何在您的Xamarin中使用它。表单— Android项目</h2><p id="2077" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">转到您的Android项目中的<code class="fe lp lq lr ls b">MainActivity</code>类，并添加以下方法:</p><pre class="ma mb mc md gt me ls mf mg aw mh bi"><span id="9c90" class="jy jz iq ls b gy mi mj l mk ml">private void AttachGlide() { Android.Glide.Forms.Init(this, null, false); //recommended way of loading resource images=&gt; //Android.Glide.Forms.Init(this, new GlideWithAndroidResourcePlaceholder(), false); //Xamarin Forms resource image //Android.Glide.Forms.PlaceholderFromResource("CachedImageTest.MSicc_Logo_Base_Blue_1024px_pad25.png", Assembly.GetAssembly(typeof(MainViewModel))); //FontImageSource Android.Glide.Forms.PlaceholderFromFontImageSource(new FontImageSource { Glyph = XfNativeCachedImages.Resources.MaterialDesignIcons.ImageBroken, FontFamily = "MaterialDesignIcons", Color = Xamarin.Forms.Color.Red }); }</span></pre><p id="ff08" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">Glide库需要初始化。根据您使用的方法，有不同的方法可以实现。上面的方法展示了它们，你只需要修改注释的代码，就可以在示例中使用它了。这个机制就像我在iOS和Nuke包中使用的一样。</p><p id="1728" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">如果您继续操作(或下载示例)，您应该会看到与此类似的结果:</p><h2 id="0633" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h2><p id="be75" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">正如我们在iOS上所做的那样，我们现在也在Android上使用原生缓存和图像处理。我花了相当长的时间让它运行起来，但这是值得的努力。该示例将超过500个远程图像加载到一个<code class="fe lp lq lr ls b">CollectionView</code>中。检查滚动有多平滑(即使有数据绑定！).</p><p id="56b4" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated">你可以在Github的这里<a class="ae lt" href="https://github.com/MSicc/XFNativeCachedImages" rel="noopener ugc nofollow" target="_blank">找到样例，而</a><a class="ae lt" href="https://github.com/MSiccDev/glidex" rel="noopener ugc nofollow" target="_blank">glide x . forms的修改版可以在</a>这里找到。一如既往，我希望这篇文章对你们中的一些人有所帮助。</p><h2 id="5a2c" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">直到下一个帖子，大家编码快乐！</h2></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="b491" class="pw-post-body-paragraph ku kv iq kw b kx lu kz la lb lv ld le kh lw lg lh kl lx lj lk kp ly lm ln lo ij bi translated"><em class="lz">原载于2021年3月26日</em><a class="ae lt" href="https://msicc.net/extending-glidex-forms-on-android-to-load-a-placeholder-for-images-that-fail-to-load/" rel="noopener ugc nofollow" target="_blank"><em class="lz"/></a><em class="lz">。</em></p></div></div>    
</body>
</html>