<html>
<head>
<title>Understanding Hashing and Equality in Python with __hash__ and __eq__</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用__hash__和__eq__了解Python中的哈希和等式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-hashing-and-equality-in-python-with-hash-and-eq-12f6da79e8ad?source=collection_archive---------1-----------------------#2022-10-15">https://levelup.gitconnected.com/understanding-hashing-and-equality-in-python-with-hash-and-eq-12f6da79e8ad?source=collection_archive---------1-----------------------#2022-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6182" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">计算机编程语言</h2><div class=""/><div class=""><h2 id="c175" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解它们是如何工作的，你应该如何使用它们，以及你绝对不应该做什么。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f4e230c214f64e437d848f615a8854df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-cMgXY-yct789M12k4SrQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://medium.com/@dreamferus" rel="noopener"> Jacob Ferus </a>使用Midjourney生成的图像。</figcaption></figure><p id="9c2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python中的<em class="me">内置</em>类型的相等比较和散列很简单，你真的不需要考虑太多，它就是有意义。但是如果你打算创建你自己的定制类，你需要注意你在做什么。很可能，默认行为是<em class="me">而不是</em>您想要的。在本文中，我将介绍这些操作符的内部工作原理，并解释将它们正确应用到您自己的类并避免重大错误的必要细节。让我们开始吧。</p><h1 id="4d28" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">等号“__eq__”运算符和“is”</h1><p id="9441" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">Python中的<code class="fe nc nd ne nf b">__eq__</code>操作符是一种重载默认<code class="fe nc nd ne nf b">==</code>操作符的方法，即定义两个对象是否<em class="me">等于</em>。它是这样补充的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0032" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当你认为两个对象相等时，你通常会根据它们的<em class="me">值</em>来考虑相等。让我给你举个例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e483" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然<code class="fe nc nd ne nf b">a</code>和<code class="fe nc nd ne nf b">b</code>有相同的值，反过来，它们应该相等是有道理的，对吗？但这并不总是正确的，我一会儿会再回到这一点。首先，让我们谈谈另一个叫做<code class="fe nc nd ne nf b">is</code>的运营商。如果你检查两个对象是否“是”彼此，即<code class="fe nc nd ne nf b">a is b</code>，那么只有当它们是完全相同的对象时才成立。例如:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="fe4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在是关键。如果你创建了一个自定义类而没有添加一个<code class="fe nc nd ne nf b">__eq__</code>方法，那么使用<code class="fe nc nd ne nf b">is</code>和<code class="fe nc nd ne nf b">==</code> <strong class="lk jd">将会和</strong><strong class="lk jd"/>一样。也就是说，相等运算符只检查对象是否相同，它不关心类的属性。因此，如果您想通过值来比较您的自定义类，您需要自己定义操作符。</p><p id="1763" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不过，对于内置对象，正如在前面的代码片段中所看到的，基于值的等式有明确的定义。一个例外是可能存在浮点错误的浮点。</p><p id="bfce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看一个例子来巩固你刚刚读到的内容:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5a8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧，那么<code class="fe nc nd ne nf b">__hash__</code>呢？</p><h1 id="2718" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">__hash__运算符</h1><p id="03db" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">先说一下什么是通用的<em class="me">哈希函数</em>。哈希函数是一种获取潜在可变长度的数据并将其转换为固定大小表示的值的函数。散列函数有不同的应用，这些应用使用不同种类的散列函数。例如:</p><h2 id="5970" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">存储和比较密码</h2><p id="3b16" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">以纯文本形式存储密码存在安全风险。为什么？因为如果存在安全漏洞，黑客能够从数据库中读取密码，黑客就可以用它来登录。其次，它还能够记住用户使用的密码，并有可能在用户使用相同密码的其他地方登录(尽管在多个帐户上使用相同的密码并不是一个好主意)。第三，你和其他开发者也可以看到密码。</p><p id="0e70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哈希函数如何解决这个问题？不是直接存储密码，而是将密码转化为哈希值，然后存储。然后，下一次用户想要登录并输入密码时，该密码将与之前的哈希值进行哈希运算<em class="me">和</em>。</p><p id="4431" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，不会存储任何密码。现在，如果有人发现<em class="me">哈希</em>密码，他们就不能使用它。原因是用于密码散列的散列函数是单向函数，即，给定输出散列，实际上不可能找到输入。因此，有效地防止了所有前述问题。这里非常重要的一点是，所谓的<em class="me">哈希冲突</em>，即当两个不同的输入返回相同的哈希时，是极其罕见的(实际上是不可能的)。否则，您可以使用不同的密码作为用户登录。</p><p id="8c28" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是<strong class="lk jd">密码术</strong>的一个应用，其中散列函数被广泛使用。另一个应用是加密货币。</p><h2 id="3db2" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">哈希映射/哈希表</h2><p id="ad4e" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated"><em class="me">哈希映射</em>是一种数据结构，用于存储值以便快速访问。它有一个键到值的关系，根据每个键的哈希值将数据分组到<em class="me">桶</em>中。这个过程背后的思想是，通过首先快速找到一个桶，通常包含很少的元素(或者只有1个)，相等比较的次数会大大减少。例如，假设你在一个列表中有一百万个元素，你想看看其中是否存在一个元素。然后，如果列表没有排序，我们将不得不一个接一个地检查元素，并比较每个元素是否相等。相反，如果我们有一个包含500000个桶的散列表，我们只需要散列键，找到桶，然后平均进行两次相等比较。速度差异是巨大的。</p><p id="0854" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，每个桶没有必要只有一个值，即每个关键字有一个唯一的散列。如果有哈希冲突，我们将简单地遍历桶的值，检查是否相等，直到找到正确的值。但理想情况下，碰撞是非常罕见的。与加密的用例相反，这里更重要的是散列函数比零冲突更快。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="b67d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，Python <em class="me">中的<strong class="lk jd">字典</strong>就是</em>一个散列图，简单明了。<strong class="lk jd">集合</strong>或<strong class="lk jd"> frozenset </strong>也是使用哈希映射实现的。Python中的<code class="fe nc nd ne nf b">__hash__</code>用例只是作为散列函数，用于散列散列表(即集合和字典)中的键。因此，如前所述，它不应该是在密码学中使用的慢散列函数，冲突是容许的。</p><p id="4752" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就像<code class="fe nc nd ne nf b">__eq__</code>，<code class="fe nc nd ne nf b">__hash__</code>是一个可以添加到类中的方法。方法的值可以使用<code class="fe nc nd ne nf b">hash(object)</code>返回:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="63ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里有一些关于<code class="fe nc nd ne nf b">__hash__</code>的规则:</p><ul class=""><li id="ed9e" class="oa ob it lk b ll lm lo lp lr oc lv od lz oe md of og oh oi bi translated"><code class="fe nc nd ne nf b">__hash__</code>的返回固定大小表示应该是整数。如果不这样做，将会抛出一个错误。</li><li id="d0b9" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">一个对象的<code class="fe nc nd ne nf b">__hash__</code>应该是<strong class="lk jd">不可变的</strong>，也就是说，在它的生命周期中不应该改变。这样做的原因是，如果你把一个对象放在一个集合中，然后改变散列，下次你寻找它时，你将找不到它，因为散列是不同的。</li><li id="e0fb" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">如果两个对象“相等”，即<code class="fe nc nd ne nf b">__eq__</code>返回相等，则它们应该具有相同的<code class="fe nc nd ne nf b">__hash__</code>值(但反之不一定成立，即在碰撞过程中)。</li><li id="13ad" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">如果你定义了<code class="fe nc nd ne nf b">__eq__</code>而没有定义<code class="fe nc nd ne nf b">__hash__</code>，这个对象将变得不可散列，如果你试图散列它，将会抛出一个错误。这样做的原因是，如果您定义了<code class="fe nc nd ne nf b">__eq__</code>，唯一有效的原因应该是默认的<code class="fe nc nd ne nf b">is</code>不再合适，因此，默认散列也不再合适(因为默认情况下它具有旨在与“is”-equality一起使用的属性)。</li><li id="75f2" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">如果<code class="fe nc nd ne nf b">__eq__</code>方法使用可变属性，那么您也不应该定义<code class="fe nc nd ne nf b">__hash__</code>函数。这是因为散列应该是不可变的，并且两个相等的对象应该具有相同的散列。如果你改变一个对象，那么其他对象的<code class="fe nc nd ne nf b">__eq__</code>也应该改变，反过来，<code class="fe nc nd ne nf b">__hash__</code>也应该改变，因此它不再是不可变的。这个异常可能是一个常量<code class="fe nc nd ne nf b">__hash__</code>，但是它没有用。</li></ul><p id="822b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，并非所有这些属性都是强制的。因此，你可以在实践中偏离这些规则，但这是一个坏主意。</p><p id="5d93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看一些例子。</p><h2 id="a2d5" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated"><strong class="ak">非整数返回类型导致错误:</strong></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="1134" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated"><strong class="ak">保留不可变哈希值的原因:</strong></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e336" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意集合中的对象是同一个对象，它们在引用和值上都是相等的。但是因为散列已经改变，我们再也找不到它。可以看出，这不是强制的，即没有抛出错误。</p><h2 id="c7de" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated"><strong class="ak">如果相等，它们应该有相同的哈希值</strong></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="182a" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">添加__eq__而不添加__hash__会使对象不可修复</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="cbfe" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">常量哈希呢？</h2><p id="d1d8" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">常量哈希意味着哈希表中只有一个桶，因为只有冲突。下面是一个速度比较，首先是一个常量哈希:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="de35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在有了一个唯一的散列:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c0bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">具有唯一散列的那个要快1742倍，并且随着更多的条目被添加到字典/散列表中，它只会增长。使用常量散列，单个桶中的项目会循环，并比较它们的相等性，直到找到匹配为止，这实际上消除了散列表的全部好处。同样，插入也会变慢。</p><h2 id="065b" class="ni mg it bd mh nj nk dn ml nl nm dp mp lr nn no mr lv np nq mt lz nr ns mv iz bi translated">最后一个问题</h2><p id="c98c" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在我结束这篇文章之前，我给你最后一个问题:下面的代码片段将返回什么？</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="aede" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我会把答案放在评论区。如果您对更多关于Python中的字典和集合的文章感兴趣，我已经分别写了一篇:</p><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/the-ultimate-guide-to-sets-in-python-c7556402726c"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd jd gy z fp ow fr fs ox fu fw jc bi translated">Python集合的终极指南</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">你需要知道的一切。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf lb or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://medium.com/@dreamferus/python-dictionary-operations-you-should-know-bb91a77bd97a" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd jd gy z fp ow fr fs ox fu fw jc bi translated">你应该知道的Python字典操作</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">dictionary/dict是Python中的基本数据结构之一。它确实是Python的核心，并被用于…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf lb or"/></div></div></a></div></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="d279" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你喜欢这篇文章，并想阅读我未来的作品，你可以在Medium上关注我。如果你有兴趣成为中级会员，你可以使用我的<a class="ae lh" href="https://medium.com/@dreamferus/membership" rel="noopener">推荐链接</a>。祝你有愉快的一天。</p></div></div>    
</body>
</html>