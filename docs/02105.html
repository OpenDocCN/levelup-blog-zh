<html>
<head>
<title>New to JavaScript? You’re going to face this issue if not already</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不熟悉JavaScript？你将面临这个问题，如果不是已经</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adding-click-event-listeners-in-a-loop-in-javascript-cd034031c452?source=collection_archive---------16-----------------------#2020-02-18">https://levelup.gitconnected.com/adding-click-event-listeners-in-a-loop-in-javascript-cd034031c452?source=collection_archive---------16-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="334b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在循环中添加点击事件侦听器可能是一个谜</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/426d9e1c74b7d4ccaf6d7e2a17b787db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iG623764_HHmv4iO.png"/></div></div></figure><p id="7db9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您将多个click事件附加到<strong class="kw iu">元素</strong>时，如<strong class="kw iu">循环</strong>中的按钮，click事件将始终为我们提供<strong class="kw iu">最后一个</strong> <strong class="kw iu">索引</strong>值，而不管按下的是什么按钮。</p><p id="b781" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是开发人员开始学习JavaScript时面临的常见问题之一。</p><p id="599a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文结束时，您将知道是什么导致了这个问题，以及解决它的一些方法。</p><ul class=""><li id="9212" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><a class="ae lz" href="https://softauthor.com/javascript-add-click-event-listener-in-a-loop#what-is-hoisting" rel="noopener ugc nofollow" target="_blank">为什么我需要知道<strong class="kw iu">吊装</strong>？</a></li><li id="80e2" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://softauthor.com/javascript-add-click-event-listener-in-a-loop#i-variable-always-get-the-last-index-in-a-loop" rel="noopener ugc nofollow" target="_blank">为什么<strong class="kw iu"> i </strong>变量总是得到循环中的最后一个索引？</a></li><li id="c6ec" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://softauthor.com/javascript-add-click-event-listener-in-a-loop#variable-scope-issue" rel="noopener ugc nofollow" target="_blank">可变范围问题</a></li><li id="d351" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://softauthor.com/javascript-add-click-event-listener-in-a-loop#what-is-closure-iife" rel="noopener ugc nofollow" target="_blank">解决方案#1:终结(生命)</a></li><li id="a5b3" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://softauthor.com/javascript-add-click-event-listener-in-a-loop#closure-outer-function-returns-inner-function" rel="noopener ugc nofollow" target="_blank">解决方案#2:闭包外部函数返回内部函数</a></li><li id="c210" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://softauthor.com/javascript-add-click-event-listener-in-a-loop#use-foreach-instead-of-for" rel="noopener ugc nofollow" target="_blank">解决方案# 3:</a>使用<strong class="kw iu"> forEach </strong>代替<strong class="kw iu"/></li><li id="a50f" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://softauthor.com/javascript-add-click-event-listener-in-a-loop#use-let-instead-of-var" rel="noopener ugc nofollow" target="_blank">解决方案#4:用<strong class="kw iu"> let </strong>代替<strong class="kw iu">var</strong>T38】</a></li><li id="fd92" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><a class="ae lz" href="https://softauthor.com/javascript-add-click-event-listener-in-a-loop#declare-callback-function-outside-of-the-loop" rel="noopener ugc nofollow" target="_blank">奖励:在循环外声明回调函数</a></li></ul><h1 id="9193" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">导致问题的代码片段</h1><p id="3b76" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">正如您所看到的，HTML页面有一个带有名为<code class="fe nc nd ne nf b">buttonsContainer</code>的<code class="fe nc nd ne nf b">id</code>的<code class="fe nc nd ne nf b">div</code>元素。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="0eb0" class="nk mg it nf b gy nl nm l nn no">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="utf-8"&gt;<br/>  &lt;meta name="viewport" content="width=device-width"&gt;<br/>  &lt;title&gt;JS Bin&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;div id="buttonsContainer"&gt;&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="554d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我在下面的javascript代码中使用<code class="fe nc nd ne nf b">for</code>循环动态添加五个按钮的地方。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="b132" class="nk mg it nf b gy nl nm l nn no">const buttonsContainer = document.getElementById("buttonsContainer");<br/>for (var i = 0; i &lt; 5; i++) {<br/>  const button = document.createElement("button");<br/>  button.innerText = i;<br/>  button.addEventListener("click", function() {<br/>    console.log(i)<br/>  })<br/>  buttonsContainer.appendChild(button);<br/>}</span></pre><p id="8a44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还将一个点击事件附加到一个按钮元素上，并在每次迭代中将其附加到<code class="fe nc nd ne nf b">buttonContainer</code>元素上。</p><p id="d5c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我在这个阶段运行这段代码，无论按下什么按钮，我都将得到值5。</p><p id="7ff7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在了解这里发生了什么之前…我们需要知道…什么是提升。</p><h1 id="77b6" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">提升</h1><p id="0b3c" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">默认情况下，用<code class="fe nc nd ne nf b">var</code>关键字声明的变量是<strong class="kw iu">函数范围的</strong>，而不是块范围的。</p><p id="baa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在函数中声明的任何变量，不管它有多深，都将被移到顶部，并且可以在函数中的任何地方访问。</p><p id="a6e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，如果一个变量在函数之外声明，它将成为一个全局变量，我们可以在应用程序的任何地方访问它，因为它属于窗口对象(仅限浏览器)。</p><p id="0996" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那种行为叫做<strong class="kw iu">吊装</strong>。</p><h1 id="eedd" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">变量<code class="fe nc nd ne nf b">i</code>总是有最后一个索引</h1><p id="e01f" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">现在让我们看看上面的代码会发生什么。</p><p id="5f0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用<code class="fe nc nd ne nf b">var</code>关键字声明的<code class="fe nc nd ne nf b">i</code>变量将被自动移动到页面顶部，因为它没有在函数中声明，所以由于提升，它变成了一个全局变量。</p><p id="2a19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此<code class="fe nc nd ne nf b">i</code>变量显然没有被限定在<code class="fe nc nd ne nf b">for</code>循环的范围内，而是被限定在全局范围内，并且在每次迭代中被绑定到回调函数之外的同一个变量。</p><p id="f87c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe nc nd ne nf b">for</code>循环到达最后一次迭代时，<code class="fe nc nd ne nf b">i</code>变量将保存最后一个索引值。这就是为什么输出总是最后一个索引，在我的例子中是5。</p><h1 id="bad3" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><code class="fe nc nd ne nf b">i</code>是一个全局变量</h1><p id="9f8f" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">我将在for循环之外控制台日志I变量</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="a04f" class="nk mg it nf b gy nl nm l nn no">} // end of for loop<br/>console.log(i);</span></pre><p id="4b53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码一执行完，您就会在浏览器控制台中看到5，甚至不需要单击任何按钮。</p><p id="86ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这证明了变量I是全局范围的。</p><p id="6f4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们知道了罪魁祸首，它是用<code class="fe nc nd ne nf b">var</code>关键字声明的<code class="fe nc nd ne nf b">i</code>变量。</p><p id="4165" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看几个解决方案。</p><h1 id="6df9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">解决方案01:关闭</h1><p id="d619" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">闭包是为了拯救，我们可以使用闭包来改变<code class="fe nc nd ne nf b">i</code>变量的范围，使函数拥有私有变量成为可能。</p><p id="e3c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用闭包，我们可以唯一地保存每个回调函数的循环索引。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="5729" class="nk mg it nf b gy nl nm l nn no">for (var i = 0; i &lt; 5; i++) {<br/>  var button = document.createElement("button");<br/>  button.innerText = i;<br/>  (function(index){<br/>    button.addEventListener("click", function() {<br/>      console.log(index)<br/>    })<br/>  })(i)<br/>  buttonsContainer.appendChild(button);<br/>}<br/>console.log(i);</span></pre><p id="e0b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看实际情况。</p><p id="2c46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，在<code class="fe nc nd ne nf b">for</code>循环中使用<code class="fe nc nd ne nf b">()</code>左括号和右括号定义一个闭包。</p><p id="a62e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，声明一个接受索引参数的匿名函数。</p><p id="1224" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，用最后一组()将全局变量<code class="fe nc nd ne nf b">i</code>传递给闭包，这将在每次迭代中调用闭包一次。</p><p id="b000" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也被称为<strong class="kw iu">立即调用函数表达式(life)</strong>，这是声明<strong class="kw iu">闭包</strong>的一种方式。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="cb7a" class="nk mg it nf b gy nl nm l nn no">(function(){ })()</span></pre><p id="2a04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，上面的代码在每次迭代中捕获一个<code class="fe nc nd ne nf b">i</code>变量的值，并将其传递给创建局部范围的函数的一个参数。</p><p id="cedf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，每个函数都有自己的索引变量版本，当在循环中创建函数时，这个版本不会改变。</p><p id="6b96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个闭包函数为每个事件处理程序唯一地保存了<code class="fe nc nd ne nf b">i</code>(私有变量)的值，因此它们都可以访问自己的值。</p><p id="ba16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您在for循环结束后单击任何按钮时，将使用正确的索引值执行适当的回调函数。</p><p id="e347" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这有意义。</p><h1 id="d1b1" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">解决方案2:闭包外部函数返回内部函数</h1><p id="48a5" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">或者，您可以返回闭包回调函数内部的函数。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4429" class="nk mg it nf b gy nl nm l nn no">button.addEventListener("click", function(index) {<br/>      return function(){<br/>        console.log(index)<br/>      }<br/>    }(i))</span></pre><p id="af13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在前面的示例中，整个按钮单击事件侦听器代码都用闭包包装起来。</p><p id="7e07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个例子中，只有按钮点击回调函数用闭包包装。</p><p id="f980" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">外部函数将在每次迭代中执行，并且<code class="fe nc nd ne nf b">i </code>变量(全局)作为一个参数传递给外部函数的调用者，就像这样(I)。</p><p id="a67b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">内部函数将在每次迭代中返回，并附加到具有唯一索引值的click事件。</p><p id="801e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在闭包中，内部函数可以访问在它外部声明的变量，即使在外部函数返回之后。</p><h1 id="d5b6" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">解决方案3:用<code class="fe nc nd ne nf b">forEach</code>代替<code class="fe nc nd ne nf b">for</code></h1><p id="1e84" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">如果您有一个项目数组，并且您可以简单地对其运行<code class="fe nc nd ne nf b">forEach()</code>方法，这将是非常好的，但是当每次迭代都发生异步操作时，不推荐这样做。</p><p id="8f0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下,<code class="fe nc nd ne nf b">forEach</code>循环提供了一种干净自然的方式来在每次迭代中获得不同的回调闭包函数。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="4c8d" class="nk mg it nf b gy nl nm l nn no">const num = [0, 1, 2, 3, 4];<br/>num.forEach(i =&gt; {<br/>  var button = document.createElement("button");<br/>  button.innerText = i;<br/>  <br/>  button.addEventListener("click", function() {<br/>    console.log(i)<br/>  })<br/>  buttonsContainer.appendChild(button);<br/>})</span></pre><p id="2959" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它不需要添加任何额外的包装函数，比前面的例子更干净！</p><h1 id="a978" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">解决方案4:用<code class="fe nc nd ne nf b">let</code>代替<code class="fe nc nd ne nf b">var</code></h1><p id="45d1" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在ES6中，我们有<code class="fe nc nd ne nf b">let</code>和<code class="fe nc nd ne nf b">const</code>关键字，它们是<strong class="kw iu">块范围的</strong>,而不是<code class="fe nc nd ne nf b">var</code>函数范围的。换句话说，<code class="fe nc nd ne nf b">let</code>和<code class="fe nc nd ne nf b">const</code>没有被吊起。</p><p id="b82f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，使用<code class="fe nc nd ne nf b">let</code>关键字在每次迭代中用一个索引值绑定一个新的回调函数，而不是一次又一次地使用同一个引用。</p><p id="578d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要解决这个问题，将原始代码中的<code class="fe nc nd ne nf b">var</code>改为<code class="fe nc nd ne nf b">let</code>就可以了。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="0547" class="nk mg it nf b gy nl nm l nn no">for (let i = 0; i &lt; 5; i++) {<br/>  const button = document.createElement("button");<br/>  button.innerText = i;<br/>  button.addEventListener("click", function() {<br/>    console.log(i)<br/>  })<br/>  buttonsContainer.appendChild(button);<br/>}</span></pre><p id="a363" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是修复循环中的click事件问题的最快方法。</p><p id="dfa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，这种方法的一个问题是要小心浏览器的向后兼容性，因为它是ES6特性的一部分。</p><h1 id="3e13" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">在循环外声明回调函数</h1><p id="bc54" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">有时，我们希望用名称单独声明一个回调函数，而不是在addEventListener构造函数中使用内联匿名函数。</p><p id="dd59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以声明一个名为buttonClicked() function的回调函数，在addEventListener构造函数内部调用它，不带任何括号。</p><p id="6426" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，<code class="fe nc nd ne nf b">event</code>对象被传递给buttonClicked()函数。</p><p id="1407" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我可以使用一个<code class="fe nc nd ne nf b">event</code>对象轻松地访问关于所选元素的任何信息。</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="923c" class="nk mg it nf b gy nl nm l nn no">for (let i = 0; i &lt; 5; i++) {<br/>  const button = document.createElement("button");<br/>  button.innerText = i;<br/>  button.id = 'button-' + i;<br/>  button.setAttribute('index', i);<br/>  button.addEventListener("click", buttonClicked)<br/>  buttonsContainer.appendChild(button);<br/>}<br/>function buttonClicked(e) {<br/>  console.log(e.target.id)<br/>  console.log(e.target.getAttribute('index'));<br/>}</span></pre><p id="28a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我想把一个值作为参数直接传递给回调函数呢？</p><pre class="kj kk kl km gt ng nf nh ni aw nj bi"><span id="1094" class="nk mg it nf b gy nl nm l nn no">for (let i = 0; i &lt; 5; i++) {<br/>  const button = document.createElement("button");<br/>  button.innerText = i;<br/>  button.id = 'button-' + i;<br/>  button.setAttribute('index', i);<br/>  button.addEventListener("click", buttonClicked(i))<br/>  buttonsContainer.appendChild(button);<br/>}<br/>function buttonClicked(index) {  <br/>  return function() {<br/>    console.log(index)<br/>  }<br/>}</span></pre><p id="9ec4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与解决方案2非常相似。</p><p id="4941" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们向<code class="fe nc nd ne nf b">buttonClicked</code>传递一个值时，它变成了一个闭包(IIFE ),这是一个外部函数，在每次迭代中运行。</p><p id="a888" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">内部函数将在每次迭代中返回，并与索引值一起附加到click事件。</p><p id="a5eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且……那会有魔力的！</p><h1 id="567f" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结论</h1><p id="9fb5" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在本文中，您已经学习了如何以几种方式解决在<code class="fe nc nd ne nf b">for</code>循环中附加click事件时出现的问题。</p><p id="a5e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript中的作用域是一个大话题，我仍在学习JavaScript中的闭包和其他概念。</p><p id="7d88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您有任何建议、反馈或本文中有任何不清楚的地方，请在下面留言联系我。</p><p id="b4cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我期待着你的来信和快乐的编码！</p></div></div>    
</body>
</html>