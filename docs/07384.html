<html>
<head>
<title>An Overview of Asymptotic Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">渐近符号概述</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-overview-of-asymptotic-notation-2086cef60172?source=collection_archive---------1-----------------------#2021-02-14">https://levelup.gitconnected.com/an-overview-of-asymptotic-notation-2086cef60172?source=collection_archive---------1-----------------------#2021-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="8c22" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">绪论和词源学</h1><p id="1bc6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">渐近表示法根据算法输入大小的增加来描述算法的运行时间。渐近符号在计算机科学中很重要，因为它帮助工程师衡量他们编写的算法的效率。为了清楚地了解<em class="lj">渐近符号，</em>这两个词的词源可以看下面。(你可以使用etymonline.com的<a class="ae lk" href="http://etymonline.com" rel="noopener ugc nofollow" target="_blank">工具来挖掘单词的历史)。</a></p><p id="fcd9" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><a class="ae lk" href="https://www.etymonline.com/word/asymptotic" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">渐近线</strong></a>——“具有渐近线特征的”，17世纪70年代，见<em class="lj">渐近线</em>。</p><p id="288e" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><a class="ae lk" href="https://www.etymonline.com/word/asymptote" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">渐近线</strong></a>——“直线不断逼近却从不与曲线相遇”，17世纪50年代，来源于希腊语<em class="lj">渐近线</em>“不倒在一起”。(<a class="ae lk" href="https://en.wikipedia.org/wiki/Asymptote" rel="noopener ugc nofollow" target="_blank">维基百科定义</a> : <em class="lj">曲线的渐近线是一条线，使得当x或y坐标中的一个或两个趋于无穷大时，曲线与该线之间的距离趋近于零</em>)。</p><p id="6ea5" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><a class="ae lk" href="https://www.etymonline.com/word/notation" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">符号</strong></a>——“一个术语的解释”，1560s(这个术语被认为是过时的，但它实际上在这里非常适用——因为<em class="lj">渐近符号</em>是一个算法运行时的解释)。“用符号或记号表示数字或数量的系统”，1706年(你会看到，这是更字面的——渐近符号描述了使用符号的算法的运行时间)。</p><p id="595b" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">渐近符号是一个有趣的术语。通过检查这两个词的词源，更容易理解这个符号<strong class="kn ir">描述了当输入趋向于特定值或无穷大</strong> *时算法的限制行为。*当考虑算法的运行时，重要的是考虑并确定算法需要多长时间，以及函数随着输入大小增长的速度。</p><p id="5744" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">渐近表示法关注算法的增长率，通过去除不太重要的因素，将函数简化为最重要的部分。这意味着渐近表示法去掉了系数、常数和低阶项，它们会降低运行时的增长率。它只关注算法中影响增长率的部分，具体来说就是<em class="lj"> n </em>的增长——或者说是函数的输入。</p><p id="003a" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">那么实际上如何应用渐近符号呢？渐近记数法有三种主要形式，在本文中都有涉及:</p><ul class=""><li id="f159" class="lq lr iq kn b ko ll ks lm kw ls la lt le lu li lv lw lx ly bi translated">大θ符号(θ)</li><li id="b77e" class="lq lr iq kn b ko lz ks ma kw mb la mc le md li lv lw lx ly bi translated">大O符号(哦)</li><li id="b065" class="lq lr iq kn b ko lz ks ma kw mb la mc le md li lv lw lx ly bi translated">大ω符号(ω)</li></ul><p id="c167" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">下面还介绍了不同类型的函数增长率。</p><h1 id="6019" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">三巨头</h1><p id="8af7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir">大θ符号</strong></p><p id="b002" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">Big-Theta、Big-Theta或简称Theta通过将算法或函数限制在上限和下限之间来测量其运行时间。</p><p id="13c4" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">当说一个函数的运行时间是<em class="lj">θ(n)</em>时，意思是一旦<em class="lj"> n </em>变得足够大，运行时间至少是<em class="lj"> k1 * n </em>最多是<em class="lj"> k2 * n </em>。一旦<em class="lj"> n </em>变得足够大，则<em class="lj"> n </em>必须被限制在该下限值和上限值之间。</p><p id="2336" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">当一个函数使用Big-Theta符号时，它被称为<strong class="kn ir">渐近紧界</strong>。这意味着它关注于<em class="lj"> n </em>的大输入，并且运行时间被限制在一个较低和较高的值内。</p><p id="f191" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir">大O符号</strong></p><p id="46f0" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">Big-O通过用上限来限制算法或函数的运行时间来度量它。这就像说，“运行时最多增长<em class="lj">这么多</em>，但是它可以增长得更慢。”</p><p id="f316" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">当说运行时a函数是<em class="lj"> O(n) </em>时，意思是一旦<em class="lj"> n </em>变得足够大，运行时间对于某个常数<em class="lj"> k </em>来说最多是<em class="lj"> k </em> * <em class="lj"> f(n) </em>。</p><p id="4cd9" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">Big-O符号用于<strong class="kn ir">渐近上限</strong>，因为它从上面限制了运行时的增长。</p><p id="ffab" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir">大欧米伽符号</strong></p><p id="d605" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">Big-Omega、Big-ω或简单的Omega通过用一个下限来限制一个算法或函数的运行时间。这就像说，“运行时至少是T37这么多。”</p><p id="235e" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">当说一个函数的运行时间是<em class="lj">ω(n)</em>时，意思是一旦<em class="lj"> n </em>变得足够大，那么对于某个常数<em class="lj"> k </em>，运行时间至少是<em class="lj"> k </em> * <em class="lj"> f(n) </em>。</p><p id="e659" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">Big-Omega用于<strong class="kn ir">渐近下限</strong>，因为它从下面限制运行时的增长。</p><h1 id="69ee" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">比较函数增长</h1><p id="aa0f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">功能以不同的速度增长，为了构建高效的软件系统，知道如何区分这些速度是很重要的。这里涵盖的四种不同增长率分别是<strong class="kn ir">常数</strong>、<strong class="kn ir">线性</strong>、<strong class="kn ir">多项式</strong>和<strong class="kn ir">指数。</strong></p><p id="ac74" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir">常数</strong>:如果一个函数的输出不随其输入而变化，则该函数具有<em class="lj">常数</em>增长。您可以识别常量函数，因为它们的表达式中没有<em class="lj"> n </em>。</p><p id="261c" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><em class="lj">如5和5000 </em></p><p id="d55e" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir">线性</strong>:如果一个函数的输出随着其输入的大小线性增加，那么这个函数具有<em class="lj">线性</em>增长。线性函数是那些<em class="lj"> n </em>永远不会增加到幂，或者用作幂的函数。<em class="lj"> n没问题。</em></p><p id="77c2" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><em class="lj">例如5n和(5/3)n </em></p><p id="c514" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir">多项式</strong>:如果一个函数的输出按照一个<a class="ae lk" href="https://en.wikipedia.org/wiki/Polynomial" rel="noopener ugc nofollow" target="_blank">多项式表达式</a>增长，则该函数具有<em class="lj">多项式</em>增长。多项式函数是指<em class="lj"> n </em>的某个常数幂。</p><p id="90ea" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><em class="lj">例如5n和5n </em></p><p id="453d" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated"><strong class="kn ir">指数</strong>:如果一个函数的输出按照<a class="ae lk" href="https://www.astro.princeton.edu/~gk/.PRE-ALG-EM-FALL09/class8.pdf" rel="noopener ugc nofollow" target="_blank">指数表达式</a>增长，那么它就有<em class="lj">指数</em>增长。指数函数是那些常数被提升到涉及<em class="lj"> n </em>的表达式的函数。</p><p id="0c52" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">例如5^n和5/2)^n</p><p id="a9ce" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">在分析和编写算法时，请记住渐近符号。它可以看做是一个指导工程师编写高效代码的框架，我们都知道编写高效代码是多么令人满意。要了解更多关于渐近符号、算法和计算机科学的知识，请查看<a class="ae lk" href="https://www.khanacademy.org/computing/computer-science/algorithms" rel="noopener ugc nofollow" target="_blank">汗学院的计算机科学课程</a>。</p><p id="d1f8" class="pw-post-body-paragraph kl km iq kn b ko ll kq kr ks lm ku kv kw ln ky kz la lo lc ld le lp lg lh li ij bi translated">你可以在我的<a class="ae lk" href="https://rustynailsoftware.com/blog" rel="noopener ugc nofollow" target="_blank">博客</a>上阅读<a class="ae lk" href="https://rustynailsoftware.com/blog/an-overview-of-asymptotic-notation" rel="noopener ugc nofollow" target="_blank">这篇文章</a>以及更多内容。</p></div></div>    
</body>
</html>