<html>
<head>
<title>How to Get Rid of If-Else Ladder</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何摆脱If-Else阶梯</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-get-rid-of-if-else-ladder-b70f36cd834d?source=collection_archive---------11-----------------------#2020-07-10">https://levelup.gitconnected.com/how-to-get-rid-of-if-else-ladder-b70f36cd834d?source=collection_archive---------11-----------------------#2020-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c015" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">干净的代码</h2><div class=""/><div class=""><h2 id="7905" class="pw-subtitle-paragraph ka jc it bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">使用高阶函数和HashMaps编写干净代码的简单方法</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/6ace5ac78e51fe15e1927cbfe84684ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eh3z_Jlz_FKw22bn"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://unsplash.com/@l42y?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">表谢</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="78a2" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我将从一个著名的问题开始，这个问题被称为反向波兰符号。你们很多人可能听说过这个问题，这个问题很容易解决。但是本文的重点是理解我们如何通过使用Hashmaps和高阶函数去掉if-else阶梯来编写干净的代码。</p><p id="972e" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">什么是反向波兰符号:</p><p id="d0d7" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><em class="mf">在逆波兰记法中，运算符跟在它们的操作数后面；例如，要将3和4相加，可以写成</em> <code class="fe mg mh mi mj b"><em class="mf">3 4 +</em></code> <em class="mf">，而不是</em> <code class="fe mg mh mi mj b"><em class="mf">3 + 4</em></code> <em class="mf">。如果有多个操作，操作符在第二个操作数后立即给出；因此，在常规符号中，表达式被写成</em> <code class="fe mg mh mi mj b"><em class="mf">3 − 4 + 5</em></code> <em class="mf">，而在反波兰符号中，表达式被写成</em> <code class="fe mg mh mi mj b"><em class="mf">3 4 − 5 +</em></code> <em class="mf">:首先从3中减去4，然后再加上5。</em></p><p id="32e4" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个问题的解决方案也很简单。我们需要使用一个堆栈，并不断推动元素，直到我们找到任何运营商<code class="fe mg mh mi mj b">(+, –, *, /)</code>。一旦我们找到一个运算符，我们就从堆栈中弹出这两个数并执行运算(加法、除法等)。)在他们身上。</p><p id="78a1" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，对于输入<code class="fe mg mh mi mj b">3 4 +</code>，我们将按下3，然后按下4，当我们遇到<code class="fe mg mh mi mj b">+</code>时，我们将弹出<code class="fe mg mh mi mj b">3</code>和<code class="fe mg mh mi mj b">4</code>并将它们相加。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="83c5" class="mr ms it bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">天真的解决方案</h1><p id="6f3c" class="pw-post-body-paragraph lj lk it ll b lm nj ke lo lp nk kh lr ls nl lu lv lw nm ly lz ma nn mc md me im bi translated">一个简单的Java解决方案应该是这样的。我们有一个方法<code class="fe mg mh mi mj b">evaluate</code>，它接受输入，使用<code class="fe mg mh mi mj b">“ ”</code>分割它。迭代char数组，将数字压入堆栈，并根据使用switch-case遇到的操作符应用操作。</p><pre class="kt ku kv kw gt no mj np nq aw nr bi"><span id="b1f7" class="ns ms it mj b gy nt nu l nv nw">import java.util.Stack;<br/><br/>class ReversePolishNotation {<br/>    public static void main(String[] args)<br/>    {<br/>        System.out.println(evaluate("5 1 2 + 4 * + 3 -"));<br/>    }<br/>    public static double evaluate(String expr)<br/>    {<br/>        String[] digitString = expr . split (" ");<br/>        Stack&lt;Float&gt; stack = new Stack&lt;Float&gt;();<br/>        for (String s : digitString) <strong class="mj jd">{<br/>        </strong>switch(s) <strong class="mj jd">{<br/>            </strong>case "+": <strong class="mj jd">{<br/>            </strong>float numberOne = stack . pop ();<br/>            float numberTwo = stack . pop ();<br/>            stack.push(numberOne + numberTwo);<br/>            break;<br/>        <strong class="mj jd">}<br/>            </strong>case "-": <strong class="mj jd">{<br/>            </strong>float numberOne = stack . pop ();<br/>            float numberTwo = stack . pop ();<br/>            stack.push(numberTwo - numberOne);<br/>            break;<br/>        <strong class="mj jd">}<br/>            </strong>case "*": <strong class="mj jd">{<br/>            </strong>float numberOne = stack . pop ();<br/>            float numberTwo = stack . pop ();<br/>            stack.push(numberOne * numberTwo);<br/>            break;<br/>        <strong class="mj jd">}<br/>            </strong>case "/": <strong class="mj jd">{<br/>            </strong>float numberOne = stack . pop ();<br/>            float numberTwo = stack . pop ();<br/>            stack.push(numberTwo / numberOne);<br/>            break;<br/>        <strong class="mj jd">}<br/>            </strong>default: <strong class="mj jd">{<br/>            </strong>stack.push(Float.parseFloat(s));<br/>            break;<br/>        <strong class="mj jd">}<br/>        }<br/>    }<br/>        </strong>return stack.pop();<br/>    }<br/>}</span></pre><p id="85cc" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这是按预期工作的解决方案的第一次迭代。现在，让我们想一个更好的解决方案。如果你看看每一个案例，我们会发现很多重复。</p><pre class="kt ku kv kw gt no mj np nq aw nr bi"><span id="001e" class="ns ms it mj b gy nt nu l nv nw">float numberOne = stack.pop();<br/>float numberTwo = stack.pop();<br/>stack.push(numberOne + numberTwo);</span></pre><p id="82c9" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">上面代码中常见的部分是堆栈操作。唯一的变化是我们执行的操作。如果我们可以将操作参数化为函数，我们应该能够重用代码。让我们看看我们能做些什么。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="fba7" class="mr ms it bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">使用双函数(高阶函数)</h1><p id="d49d" class="pw-post-body-paragraph lj lk it ll b lm nj ke lo lp nk kh lr ls nl lu lv lw nm ly lz ma nn mc md me im bi translated"><code class="fe mg mh mi mj b"><a class="ae li" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html" rel="noopener ugc nofollow" target="_blank">BiFunction</a></code>是接受2个参数的<code class="fe mg mh mi mj b"><a class="ae li" href="https://learnjava.co.in/java-8-function-interface-example/" rel="noopener ugc nofollow" target="_blank">Function</a></code>接口的专门化。就像一个<code class="fe mg mh mi mj b">Function</code>，它提供了一个叫做<code class="fe mg mh mi mj b">apply</code>的方法。该方法接受任何数据类型的两个参数，并返回一个结果。正是我们进行手术所需要的。我们的add函数接受两个参数并返回结果！</p><p id="31c2" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">因此，我们可以将加法、减法、乘法和除法函数作为双函数来传递。</p><pre class="kt ku kv kw gt no mj np nq aw nr bi"><span id="bb07" class="ns ms it mj b gy nt nu l nv nw">import java.util.Stack;<br/>import java.util.function.BiFunction;<br/><br/>class ReversePolishNotation {<br/><br/>    public static void main(String[] args)<br/>    {<br/>        System.out.println(evaluate("4 2 /"));<br/>    }<br/><br/>    public static double evaluate(String expr)<br/>    {<br/>        String[] digitString = expr . split (" ");<br/>        Stack&lt;Float&gt; stack = new Stack&lt;Float&gt;();<br/>        for (String s : digitString) <strong class="mj jd">{<br/>        </strong>switch(s) <strong class="mj jd">{<br/>            </strong>case "+": <strong class="mj jd">{<br/>            </strong>stack.push(operate((a, b) -&gt; a+b, stack));<br/>            break;<br/>        <strong class="mj jd">}<br/>            </strong>case "-": <strong class="mj jd">{<br/>            </strong>stack.push(operate((a, b) -&gt; a-b, stack));<br/>            break;<br/>        <strong class="mj jd">}<br/>            </strong>case "*": <strong class="mj jd">{<br/>            </strong>stack.push(operate((a, b) -&gt; a * b, stack));<br/>            break;<br/>        <strong class="mj jd">}<br/>            </strong>case "/": <strong class="mj jd">{<br/>            </strong>stack.push(operate((a, b) -&gt; a / b, stack));<br/>            break;<br/>        <strong class="mj jd">}<br/>            </strong>default: <strong class="mj jd">{<br/>            </strong>stack.push(Float.parseFloat(s));<br/>            break;<br/>        <strong class="mj jd">}<br/>        }<br/>    }<br/>        </strong>return stack.pop();<br/>    }<br/><br/>    public static Float operate(BiFunction&lt;Float, Float, Float&gt; function, Stack&lt;Float&gt; stack)<br/>    {<br/>        float numberOne = stack . pop ();<br/>        float numberTwo = stack . pop ();<br/>        return function.apply(numberTwo, numberOne);<br/>    }<br/>}</span></pre><p id="7d32" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上面的代码中，双功能是:</p><pre class="kt ku kv kw gt no mj np nq aw nr bi"><span id="1083" class="ns ms it mj b gy nt nu l nv nw">(a, b) -&gt; a + b</span></pre><p id="de8d" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们的方法<code class="fe mg mh mi mj b">operate</code>接受双函数作为输入。</p><p id="b241" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在，我们通过从中提取一个函数并让它接受我们的操作作为函数来消除重复。</p><p id="ea35" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是仍然有那个开关情况阶梯，它负责计算出我们应该使用哪个操作。如果我们能摆脱它呢？</p><p id="d423" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们考虑一下。只有当我们能够进行<code class="fe mg mh mi mj b">operator</code>查找时，我们才能够移除这个阶梯。</p><p id="35c2" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">什么可以用来查找呢？</p><p id="065a" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">确实是散列表！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="328d" class="mr ms it bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">拆卸开关盒</h1><p id="e182" class="pw-post-body-paragraph lj lk it ll b lm nj ke lo lp nk kh lr ls nl lu lv lw nm ly lz ma nn mc md me im bi translated">我们用函数映射我们的操作符，然后当我们在字符串上迭代时，如果我们找到一个操作符就取函数，否则我们就把这个数推到堆栈中。</p><pre class="kt ku kv kw gt no mj np nq aw nr bi"><span id="b016" class="ns ms it mj b gy nt nu l nv nw">import java.util.HashMap;<br/>import java.util.Stack;<br/>import java.util.function.BiFunction;<br/><br/>class ReversePolishNotation {<br/><br/>    public static void main(String[] args)<br/>    {<br/>        System.out.println(evaluate("4 2 /"));<br/>    }<br/><br/>    public static double evaluate(String expr)<br/>    {<br/>        String[] digitString = expr . split (" ");<br/><br/>        Stack&lt;Float&gt; stack = new Stack&lt;&gt;();<br/>        HashMap&lt;String, BiFunction&lt;Float, Float, Float&gt;&gt; map = constructMapForOperator ();<br/><br/>        for (String s : digitString) <strong class="mj jd">{<br/>        </strong>if (map.containsKey(s)) {<br/>            stack.push(operate(map.get(s), stack));<br/>        } else {<br/>            stack.push(Float.parseFloat(s));<br/>        }<br/>    <strong class="mj jd">}<br/>        </strong>return stack.pop();<br/>    }<br/><br/>    private static HashMap&lt;String, BiFunction&lt;Float, Float, Float&gt;&gt; constructMapForOperator()<br/>    {<br/>        HashMap&lt;String, BiFunction&lt;Float, Float, Float&gt;&gt; map = new HashMap();<br/>        map.put("+", (a, b) -&gt; a+b));<br/>        map.put("-", (a, b) -&gt; a-b);<br/>        map.put("*", (a, b) -&gt; a * b);<br/>        map.put("/", (a, b) -&gt; a / b);<br/>        return map;<br/>    }<br/><br/>    public static Float operate(BiFunction&lt;Float, Float, Float&gt; function, Stack&lt;Float&gt; stack)<br/>    {<br/>        float numberOne = stack . pop ();<br/>        float numberTwo = stack . pop ();<br/>        return function.apply(numberTwo, numberOne);<br/>    }<br/>}</span></pre><p id="9577" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这种方法可以用在所有你看到if-else或switch-case梯形的地方。这几乎在任何地方都有效。你只需要仔细考虑你需要创建的高阶函数。</p><p id="417c" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">对于科特林爱好者来说，这里有一个相同的解决方案。</p><pre class="kt ku kv kw gt no mj np nq aw nr bi"><span id="beaf" class="ns ms it mj b gy nt nu l nv nw">import java.util.*<br/><br/>fun main() {<br/>    <em class="mf">println</em>(<em class="mf">evaluate</em>("4 2 /"))<br/>}<br/><br/>fun evaluate(expr: String): Float {<br/>    val chars = expr.<em class="mf">split</em>(" ")<br/>    val stack = Stack&lt;Float&gt;()<br/>    val operator = <em class="mf">operationForOperator</em>()<br/>    for (c in chars) {<br/>        operator[c]?.<em class="mf">let </em><strong class="mj jd">{ </strong>stack.push(<em class="mf">operate</em>(<strong class="mj jd">it</strong>, stack)) <strong class="mj jd">} </strong>?: stack.push(c.<em class="mf">toFloat</em>())<br/>    }<br/>    return stack.pop()<br/>}<br/><br/>fun operationForOperator(): Map&lt;String, (Float, Float) -&gt; Float&gt; {<br/>    return <em class="mf">mapOf</em>(<br/>        "+" <em class="mf">to </em><strong class="mj jd">{ </strong>a, b <strong class="mj jd">-&gt; </strong>a + b <strong class="mj jd">}</strong>,<br/>        "-" <em class="mf">to </em><strong class="mj jd">{ </strong>a, b <strong class="mj jd">-&gt; </strong>a - b <strong class="mj jd">}</strong>,<br/>        "*" <em class="mf">to </em><strong class="mj jd">{ </strong>a, b <strong class="mj jd">-&gt; </strong>a * b <strong class="mj jd">}</strong>,<br/>        "/" <em class="mf">to </em><strong class="mj jd">{ </strong>a, b <strong class="mj jd">-&gt; </strong>a / b <strong class="mj jd">}<br/>    </strong>)<br/>}<br/><br/>fun operate(function: (a: Float, b: Float) -&gt; Float, stack: Stack&lt;Float&gt;): Float {<br/>    val numberOne = stack.pop()<br/>    val numberTwo = stack.pop()<br/>    return function(numberTwo, numberOne)<br/>}</span></pre><p id="c45a" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果你注意到了，我们在这里不需要像在顶部的for循环中那样的if-else。我们可以利用<strong class="ll jd">科特林的猫王算子(？:)</strong>如果map中没有匹配的键，将自动执行最后一部分。我们从50行代码开始，使用Kotlin达到了30行代码。</p><p id="076e" class="pw-post-body-paragraph lj lk it ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可能有兴趣阅读关于开发人员生产力的其他文章。</p><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/5-mindsets-of-unsuccessful-developers-5d9bd5e4f700"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">不成功开发者的5种心态</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">#3学习只发生在工作中</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo lc oa"/></div></div></a></div></div></div>    
</body>
</html>