<html>
<head>
<title>How to combine C++, Cmake, Googletest, CircleCi, Docker, and WHY</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何结合C++，Cmake，Googletest，CircleCi，Docker，为什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-combine-c-cmake-googletest-circleci-docker-and-why-e02d76c060a3?source=collection_archive---------2-----------------------#2020-07-14">https://levelup.gitconnected.com/how-to-combine-c-cmake-googletest-circleci-docker-and-why-e02d76c060a3?source=collection_archive---------2-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4349" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将运行这些工具的完整设置，我将向您展示为什么它们值得花时间；)我将提供配置文件，并对我们为什么进行这些配置提供一些见解。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/295b5095b6753bd0d95d554507238da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lm2hq-Zh6jauugvICiZcg.jpeg"/></div></div></figure><h1 id="5b38" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="ce16" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">有许多文章解释了标题中提到的一些工具的组合。我最近浏览了我的旧项目的源代码，发现了一个我已经很久没看的C++项目。它是以经典的裸C++项目方式建立的:</p><ul class=""><li id="9a99" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">很久以前的自述</li><li id="f952" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">一些。h和。cpp文件</li><li id="8cc7" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">一个CmakeLists文件，它只有使Boost集成工作所需的代码，并且污染了主文件夹</li><li id="630a" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">到处散落着古老的建筑文物</li></ul><p id="43a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最近一篇关于Medium.com的帖子中，我谈到了将你参与过的每个项目都存入Github账户作为备份的想法，所以我考虑先这么做。但后来我感到有点惭愧，因为我意识到这个项目是多么糟糕。尽管这个项目在Github上应该是私有的，但我想保留一个正常状态的版本历史，所以我必须先清理它。这个项目有许多明显的问题，我开始一个接一个地解决它们，把这个项目转变成一个可以接受的状态。</p><p id="731e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在运行本文中列出的命令行指令时遇到任何问题，请尝试通过调用</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="7593" class="mt ky iq mp b gy mu mv l mw mx">apt-get update<br/>apt-get install git cmake build-essential tar curl g++ gcc-9 clang-10</span></pre><p id="8119" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在我的系统上运行Ubuntu 20.04。例如，如果您没有gcc-9，请使用旧版本，或者直接使用默认提供的版本(用<em class="my"> gcc </em>替换<em class="my"> gcc-9 </em>)。如果你使用低于9的编译器版本，记住Cxx20对你来说是不可用的，你应该用C++14或C++17替换C++20，在你的<em class="my"> CMakeLists.txt </em>中。</p><h1 id="2787" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">CMake</h1><p id="66d1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">大多数C++项目从一个好的CmakeLists文件开始。由于C++是一种独立于平台的语言，每个平台都必须提供构建工具(又名。编译器、连接器等。).如果这种语言要有未来，就必须想办法简化这个过程，这就是<em class="my"> make </em>的用武之地。make是一个构建自动化工具，主要是调用命令并为它们设置参数。有些人仍然为<em class="my"> make </em>(又名。makefile)本身，但是大多数开发人员已经转移到了<em class="my"> cmake </em>上，这反过来自动配置makefile。CMake最好的特性是，它可以检测系统上的库和编译器，并自动为您配置它们。</p><p id="60e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在我的项目中，我想加入Boost库，它是最大的C++库之一。Cmake提供了检测它是否被安装以及自动告诉编译器它在哪里的可能性。另一个很好的特性是，Cmake只使用一个配置文件(或者层叠文件，如果您想单独配置子项目的话)。因为它非常紧凑，而且是C++世界的绝对标准，所以IDE集成也很棒。</p><p id="5617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为第一步，我清理了项目中的文件夹结构，创建了以下文件夹:</p><ul class=""><li id="c788" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">src:这个文件夹将包含。h和。包含项目功能的cpp文件。这里可以引入更多的结构，但我不想在这里过多介绍。许多项目只包含10个或更少的文件，一个文件夹就足够了。如果你选择进一步细分这个，下面的步骤会完全一样。</li><li id="4b5f" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">main:在这个文件夹中，我放置了独立执行项目的入口点。基于这个文件，主二进制文件将被构建。</li><li id="1378" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">测试:这个文件夹将包含带有单元测试的c++文件。添加<em class="my"> gtest </em>将在稍后进行，但我马上创建了这个文件夹。</li><li id="2534" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">third_party:此文件夹将包含外部依赖项。在我的情况下，这只会是谷歌测试。如果Boost更小，它也可以放在这里，但由于它非常大，不应该作为我的项目的一部分来构建，我决定将它安装在操作系统级别。</li></ul><p id="97ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了这4个文件夹，我们可以开始填充它们了。<em class="my"> Main </em>应该包含main.cpp和主二进制代码。src应该包含一些头(。h)和源文件(。cpp)包含实际的功能。测试现在可以保持为空，稍后我们将填充第三方。目前，我们不需要googletest，也不使用Boost，所以我们可以开始用cmake配置构建。我建议的CMakeLists.txt如下所示:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="2b02" class="mt ky iq mp b gy mu mv l mw mx">cmake_minimum_required(VERSION 3.0)<br/>project(MyProject)<br/>set(CMAKE_EXPORT_COMPILE_COMMANDS ON)<br/>set(CMAKE_CXX_STANDARD 20)<br/>set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fopenmp -o3")<br/>add_library(Core src/file1.cpp src/file2.cpp)<br/>add_executable(Main main/main.cpp)<br/>target_link_libraries(Main Core)</span></pre><p id="e0a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一行和第二行是cmake基础。我推荐你使用cmake 3，因为它适用于每一个平台，项目只需简单地命名你的项目。接下来，我们执行set(变量值)5次来指定关于构建的细节。第一个是最具体的一个:CMAKE_EXPORT_COMPILE_COMMANDS使CMAKE生成一个名为compile_commands.json的文件，只有在您将Clang用作编译器或IDE中的实用程序时才需要这一行。就个人而言，我使用clang是为了在VSCode中更好地进行代码自省，如果你没有理由不这样做，我建议你也这样做。有时有点慢，但我认为值得等待。</p><p id="896b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CMAKE_CXX_STANDARD在下一行设置为20，指定我要用2020版本的C++。我的代码使用了C++20中的<em class="my"> std::set </em>，它接收了一个有用的<em class="my"> contains() </em>方法，我只想尽可能使用最新版本。这并不是真正需要的，但是如果你的系统上有<em class="my"> gcc-9 </em>或<em class="my"> clang-10 </em>(运行gcc-version找出答案)为什么不使用最好的C++呢？</p><p id="ea35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我为编译器添加了两个C++标志，分别是- <em class="my"> fopenmp </em>和- <em class="my"> o3 </em>。第一个使OpenMP可用，另一个使编译器在代码上运行一些基本的优化。在这里介绍OpenMP是不可能的，因为要说的内容太多了，但是，我可以帮助您决定是否值得研究:如果您曾经有过一个长时间运行的循环，执行某项任务，即使循环的各个运行是独立的，您也要让它并行运行，因为您的计算机有不止一个内核，那么您应该研究OpenMP。您可以简单地在for循环前添加<em class="my"> #pragma omp parallel for </em>，它将使您的系统支持的尽可能多的进程并行运行。这两个命令只会影响代码的性能，如果不需要的话可以删除。</p><p id="6129" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后三行是CMake做一些实际工作的代码:<em class="my">Add _ library(Libname lib files…)</em>声明一个库。库是一个可以在包含特定功能的其他代码中使用的模块。我们编译src目录中的所有文件，所以我们所有的功能都放在一个名为Core的库中。在库的名称之后，您只需写下您的。cpp文件和任何单一的。h文件。我的模式总是包含来自源文件的头文件。所以<em class="my"> a.cpp </em>里面有一个include<em class="my">a . h</em>。另外，我通常有包含类型声明和常量值的文件<em class="my"> constants.h </em>和<em class="my"> types.h </em>。既然这些都没有对应的。cpp文件，我也在这里添加它们。</p><p id="743e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">库本身只声明了一些功能，但并不执行它，所以我们需要一个可执行文件。为此，我们有main.cpp，它包含一个静态的void main()方法，声明应用程序的入口点。为了让cmake从中构建一个可执行文件，我们用<em class="my">add _ executable(binary name main/main . CPP)</em>声明它。这表明应该编译包含main.cpp代码的二进制文件。</p><p id="4bc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二进制文件很可能无法独立工作。它会有一些<em class="my"> #include”../src/someHeader.h" </em>引用src目录中的代码，因此我们必须为其提供该功能，该功能现在包含在核心库中。为此，我们在最后一个命令中将它们链接在一起，这意味着所谓的链接器将告诉可执行文件在哪里可以找到它从外部源文件中包含的功能。这个功能包含在核心库中，所以我们把它传递给链接器。</p><p id="c8e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为关于这个主题的最后一点评论，我推荐“源外”构建。这意味着您将所有Makefiles、二进制文件和库放在一个单独的文件夹中。这可以通过在不同于包含您的<em class="my"> CMakeLists.txt </em>的文件夹中运行cmake来实现。如前所述，cmake只编写Makefiles，所以在运行Cmake之后，我们仍然需要调用make来执行我们已经配置的实际操作。将命令提示符导航到项目的根文件夹，只需调用</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="a756" class="mt ky iq mp b gy mu mv l mw mx">mkdir build<br/>cd build<br/>cmake ..<br/>make</span></pre><p id="39f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们通过调用<em class="my"> mkdir </em>创建一个构建目录。然后我们进入并运行<em class="my"> cmake </em>。<em class="my"> cmake </em>后面的两个点表示“在父目录中运行cmake”make将开始编译所有内容。在这些命令之后，您将在您的构建文件夹中找到一些CMake-junk和所有其他的构建文件。git)忽略。</p><p id="5e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经配置了一个构建，如果您只更改了源文件的一些内容，您只需调用make来重新编译它们。这些生成的Makefiles的一个很好的特性是，它们包含了关于可以并行执行的步骤的所有信息。因此，您可以调用make -j4来并行执行4个进程，这会大大加快进程。您也可以使用更多或更少的进程，这取决于您的计算机可以处理的内容。但是，不要使用超过可用内核数量的内核。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="2fc3" class="kx ky iq bd kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq nk ls lt lu bi translated">饭桶</h1><p id="3ff7" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们已经对项目进行了一点清理，或者，如果您从一个干净的工作区开始，我们现在有了一个基本的结构，可以开始版本控制。在我们项目的根目录中，我们调用git init。为了确保我们不会提交二进制文件或其他文件，它们不应该是存储库的一部分，我们创建了这个文件。gitignore，它告诉git要忽略哪些文件。我建议从这个文件开始:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="1354" class="mt ky iq mp b gy mu mv l mw mx">*.com<br/>*.class<br/>*.dll<br/>*.exe<br/>*.a<br/>*.o<br/>*.so<br/>*.7z<br/>*.dmg<br/>*.gz<br/>*.iso<br/>*.jar<br/>*.rar<br/>*.tar<br/>*.zip<br/>*.cbp<br/>*.log<br/>*.sql<br/>*.sqlite<br/> .DS_Store<br/>.DS_Store?<br/>._*<br/>.Spotlight-V100<br/>.Trashes<br/>ehthumbs.db<br/>Thumbs.db <br/>*.vtk<br/>*.eps<br/>*.gpl<br/>*.1<br/>*.cmake<br/>Makefile<br/>CMakeFiles/<br/>CMakeCache.txt<br/>.cproject<br/>.settings/<br/>.idea/<br/>build/<br/>.vscode/<br/>*.pc<br/>.clangd/</span></pre><p id="5c4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有点长，但是它包含了很多你不想在你的VCS中出现的类型，比如二进制输出。exe，。一个，还有。o)以及IDE配置。现在，我们可以创建一个GitHub repo。它将为您提供一个克隆URL，您可以使用它来设置您的本地存储库。</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="84b2" class="mt ky iq mp b gy mu mv l mw mx">git init<br/>git add --all<br/>git commit -m "Initiali commit."<br/>git remote add origin YourURLHere<br/>git push -u origin master</span></pre><p id="789e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这会将所有文件添加到初始版本中，这些文件在。gitignore文件。在push-command之后，您还应该在GitHub界面中看到在线文件。接下来，我们将开始测试我们的代码！</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="71a3" class="kx ky iq bd kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq nk ls lt lu bi translated">Gtest</h1><p id="0926" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">googletest框架是我测试C++代码时的goto框架。同样，完整的介绍会超出一篇文章的范围，但是让我们创建文件unit_tests/SomeTest.cpp并添加一个简单的测试用例:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="b373" class="mt ky iq mp b gy mu mv l mw mx">#include "gtest/gtest.h"<br/>#include "../src/someHeader.h"</span><span id="a02f" class="mt ky iq mp b gy nl mv l mw mx">TEST(SomeTestSuite, SomeTest) {<br/>  MyType obj = new MyType();<br/>  obj-&gt;set_the_value(5);<br/>  ASSERT_EQ(obj-&gt;get_the_value(), 5);<br/>}</span></pre><p id="dbb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一行中，我们引用了Googletest，这样我们就可以使用它的功能。接下来，我们加载我们想要测试的代码的一些部分。测试宏声明一个测试用例。每一个测试用例都属于一个套件(SomeTestSuite)，都有自己的名字(SomeTest)。这些值没有在其他地方定义，您只需将它们传递给测试宏，它就会使用它们。这创建了一个测试用例，所以现在，我们只需要实现那个测试实际上是什么，我们在接下来的3行中做。我们从库中的某个部分创建了一个对象。我们对它执行一些操作，然后使用另一个Googletest宏:ASSERT_EQ(即“assert equals”)宏意味着，如果第一个和第二个参数具有相同的值，测试将会成功。你可以在这里找到完整的断言列表。</p><p id="5bf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，我们希望将整个googletest项目放入第三方文件夹中。第一种方法是简单地将文件复制到那里。那样的话，你会给自己制造很多问题:</p><ul class=""><li id="e03b" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">你的回购规模会增长很多，因为googletest很大。</li><li id="6d72" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">如果发布了新版本的googletest，您必须手动更新代码。</li></ul><p id="d028" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为替代，我们可以使用git子模块功能。这样，您可以将另一个存储库作为子存储库集成到您的存储库中，然后git将能够获取它的更新并从您的存储库中排除文件。在像<a class="ae nm" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>这样的网络用户界面中，当你试图查看文件夹时，它甚至会链接到包含项目的资源库。您必须执行的命令很简单:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="d279" class="mt ky iq mp b gy mu mv l mw mx">cd third_party<br/>git submodule add <a class="ae nm" href="https://github.com/google/googletest.git" rel="noopener ugc nofollow" target="_blank">https://github.com/google/googletest.git</a><br/>git submodule init<br/>git submodule update</span></pre><p id="54d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进入第三方目录后，通过指定位置来添加git子模块。本质上，这将执行存储库的git克隆，并将主文件夹标记为子模块。接下来，告诉git将其初始化为git子模块，并更新其配置。这些步骤只需执行一次。要在以后更新googletest的版本，只需执行git子模块更新—远程。现在你会在你的GitHub账户中看到这个(在你下一次提交和推送之后):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/1059eda02feb5a671db49fe34c5bf7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/0*Hx8vL3eJBFNT_Ik9.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">googletest现在是一个git子模块，而不是一个文件夹，所以输入它会将您重定向到googletest存储库。</figcaption></figure><p id="ae95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重要的一点是:如果您想要克隆您的repo，只需在clone命令中添加— recurse-submodules。这将告诉git也克隆googletest子模块。接下来，我们将更新CMake来做两件事:</p><ul class=""><li id="a4bf" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">编译我们的测试用例:我们已经编写了使用googletest宏的测试用例。我们希望编译这些测试，以便能够执行它们。我们必须将测试可执行文件与googletest链接起来，以使其功能可用。由于我们只包含了googletest项目的源代码，我们还需要</li><li id="ad3d" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">编译googletest。我们通过将整个项目放入third_party/googletest文件夹中，将googletest直接包含在我们的项目中。仅仅说我们需要它作为依赖是不够的，我们还必须构建它。还有一个选项是在系统范围内安装googletest并运行cmakes自动检测。这种方法在大多数情况下都是可行的，但是要求你的所有项目都使用相同版本的googletest，而这个版本又是你的操作系统的包库中的版本，可能是旧的。</li></ul><p id="57d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将下面几行添加到之前的文件中:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="8500" class="mt ky iq mp b gy mu mv l mw mx">set (gtest_force_shared_crt ON CACHE BOOL "MSVC defaults to shared CRT" FORCE)<br/>add_subdirectory(third_party/googletest)<br/>target_compile_definitions(gtest<br/>  PUBLIC<br/>    GTEST_LANG_CXX20<br/>    GTEST_HAS_TR1_TUPLE=0<br/>)<br/>add_executable(tests)<br/>target_sources(tests<br/>  PRIVATE<br/>    unit_tests/SomeTests.cpp<br/>)<br/>set_target_properties(tests PROPERTIES COMPILE_FLAGS "${cxx_strict}")<br/>target_link_libraries(tests gtest gtest_main Core)</span></pre><p id="a99e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一行应该简单地复制。它缓解了Windows系统上关于编译选项不兼容的一些问题。这迫使googletest的默认行为与您自己项目的默认行为兼容。接下来，我们将包含googletest的子目录添加到我们的项目中。因为这个文件夹包含一个CMakeLists.txt，它将在那个项目上运行CMake，从而为我们设置它。googletest中的CMakeLists.txt定义了一个名为googletest的目标，我们现在对其进行配置以满足我们的需求:我们指定它应该是公共的，这意味着我们将能够使用它并根据它链接我们的测试二进制文件。我们还指定googletest应该使用最新的C++标准(GTEST_LANG_CXX20是C++ 2020)。GTEST_HAS_TR_TUPLE=0禁用对某些STL元组类的支持，这些类在某些Windows环境中会抛出错误，所以只需复制这个命令。Add_executable声明我们的测试-binary。执行这个二进制文件将为我们运行测试。到目前为止，它是一个没有编译任何源文件的空壳。在下一行中，我们声明目标测试应该从文件<em class="my">unit _ tests/somests . CPP</em>中构建，这个文件是我们之前创建的。</p><p id="5f98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">倒数第二行只需要设置一些与googletest兼容所需的属性，最后一行声明包含我们的测试的二进制文件应该链接到googletest以及我们自己的库Core。在我们的项目上调用make之后，我们可以通过执行<em class="my">来运行我们的测试。/tests </em>，或者更详细地说:通过调用cd build导航到build文件夹。致电<em class="my"> cmake..</em>后接<em class="my">使</em>。现在，您将在该文件夹中看到一堆文件:</p><ul class=""><li id="0e32" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">Main:这是正常执行代码的二进制文件，即从main.cpp中的int main()开始。</li><li id="e16f" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">测试:这个二进制文件为您执行googletests，并写出输出。注意:这个二进制文件包含的功能远不止你写的测试用例。比如可以调用<em class="my">。/tests-help</em>要获得如何使用它的帮助，您可以指定只运行某个测试，并且可以传递参数<em class="my"> — gtest_output=XML </em>来告诉googletest编写一个CI系统可以读取的测试输出文件。奔跑的<em class="my">。/tests </em>应该会给出类似这样的输出:</li></ul><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="5fbe" class="mt ky iq mp b gy mu mv l mw mx">[==========] Running 4 tests from 2 test suites.<br/>[----------] Global test environment set-up.<br/>[----------] 3 tests from PaperTests<br/>[ RUN      ] PaperTests.OccuringWordsBase<br/>[       OK ] PaperTests.OccuringWordsBase (0 ms)<br/>[ RUN      ] PaperTests.IllegalChar<br/>[       OK ] PaperTests.IllegalChar (0 ms)<br/>[ RUN      ] PaperTests.OccuringWordsExtended<br/>[       OK ] PaperTests.OccuringWordsExtended (0 ms)<br/>[----------] 3 tests from PaperTests (1 ms total)<br/>[----------] 1 test from HistogramTests<br/>[ RUN      ] HistogramTests.BasicHistogramTests<br/>[       OK ] HistogramTests.BasicHistogramTests (0 ms)<br/>[----------] 1 test from HistogramTests (0 ms total)<br/>[----------] Global test environment tear-down<br/>[==========] 4 tests from 2 test suites ran. (1 ms total)<br/>[  PASSED  ] 4 tests.</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="d2a4" class="kx ky iq bd kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq nk ls lt lu bi translated">到目前为止我们所做的</h1><p id="3009" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">喝杯咖啡吧，你真的赚到了！:)</p><p id="79ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为到目前为止我们所做工作的简短概述，我们首先创建了一个基本的C++项目。接下来，我们通过构建一个文件夹结构添加了一些结构，并为该项目配置了CMake。这使我们能够在不调用编译器的情况下编译项目。然后我们引入了googletest来为我们的代码编写测试。我们将googletest包含到项目中，指定了如何构建它，并定义了执行测试的测试二进制文件。我们有一个分离主构建的设置，它创建产品二进制文件、我们想要创建的程序，以及我们编写的确保它工作的测试。</p><p id="be48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该项目由git管理，包含作为子模块的googletst。我们在GitHub上有一个备份，我们指定了运行主函数和测试用例的方法。</p><p id="d5ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在接下来的步骤中，我们将添加CircleCi，以便在我们向GitHub推送内容时为我们运行测试。这将为我们提供一个更加现代化的工作环境，因为我们现在能够在平台上进行开发，而我们甚至不能在这些平台上构建或运行测试。测试的优势在于，我们不再需要运行整个项目来检查小功能是否有效。启用CI后，我们甚至不需要在本地运行测试——我们可以将更改提交到repo，并在线查看测试是否有效。</p><p id="8ad8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们不再在本地运行测试，我们需要指定在哪里运行它们。为此，我们使用docker。Docker在所谓的容器中提供操作系统映像。我们将创建一个容器映像，其中包含项目所需的所有功能，并设置CircleCi使用该容器来运行我们的测试。然后，它将检索测试结果，并使它们在web界面中可用，并作为一个标记，显示在我们的GitHub存储库页面中。</p><p id="794e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CircleCi提供了用各种语言建立项目的蓝图——遗憾的是C++目前不在其中。因为我们需要一个容器来使CircleCi运行我们的代码，我们将从创建Docker容器开始，然后在CircleCi中设置它。</p><h1 id="4ee8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">码头工人</h1><p id="8869" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Docker已经成为一个庞大的复杂功能生态系统，其核心是操作系统映像的管理。创建这种图像的默认方式称为Dockerfile。这是我们将使用的一个:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="39c6" class="mt ky iq mp b gy mu mv l mw mx">FROM ubuntu:focal</span><span id="98b8" class="mt ky iq mp b gy nl mv l mw mx">LABEL maintainer="Pascal Kraft" \<br/>      description="Basic C++ stuff for CircleCi repo." \<br/>      version="0.1.0"</span><span id="a8a5" class="mt ky iq mp b gy nl mv l mw mx">ARG DEBIAN_FRONTEND=noninteractive<br/>ENV TZ=Europe/Berlin<br/>RUN apt-get update -y &amp;&amp; \<br/>    apt-get install -y tzdata</span><span id="f5fa" class="mt ky iq mp b gy nl mv l mw mx">RUN apt-get install -y --no-install-recommends\<br/>                    git \<br/>                    curl \<br/>                    gcc-9 \<br/>                    g++ \<br/>                    clang-10 \<br/>                    build-essential \<br/>                    cmake \<br/>                    unzip \<br/>                    tar \<br/>                    ca-certificates &amp;&amp; \<br/>    apt-get autoclean &amp;&amp; \<br/>    apt-get autoremove &amp;&amp; \<br/>    apt-get clean &amp;&amp; \<br/>    rm -rf /var/lib/apt/lists/*</span></pre><p id="3194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一行是至关重要的:这个docker文件使用另一个作为基础，然后只配置系统。ubuntu:focal的意思是，我们想从Ubuntu 20.04开始。然后，我们指定一些关于我们正在创建的Docker映像的元信息，比如它的版本、它的用途以及谁在维护它。ARG和ENV行在系统中设置属性。第一条说所有的命令都应该在没有输入设备的情况下运行，也就是说，脚本应该在没有我们干预的情况下运行，所以任何程序都不应该在控制台上询问任何问题。我们将依赖包<em class="my"> tzdata </em>，它包含关于时区的信息。它的默认行为是在安装过程中询问计算机的位置。为了避免这一点，我们提供了变量TZ作为环境(EV)的一部分，<em class="my"> tzdata </em>将使用它而不是询问。</p><p id="4905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成初始设置后，我们可以使用Docker RUN语法运行简单的命令行命令。在第一个运行块中，我们从软件包源代码中加载软件包源代码，以便我们可以在以后执行安装。然后我们安装<em class="my"> tzdata </em>。我把它变成了一个单独的块，因为它经常失败，所以我想先执行这一步。</p><p id="1437" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们在映像中安装项目的所有基本依赖项。-y告诉apt不要问我们任何问题，只需安装软件包。—no-install-建议将已安装的软件包保持在最少，并将生成的映像保持得稍小一些。此选项可以删除。显然，我们安装的包包含git、GCC-9和Clang、CMake以及其他一些有用的工具。安装Ca-certificates是因为它使我们能够存储工件，否则，我们将会看到未被授权上传工件的错误，这是因为无法建立https连接。之后，我们通过执行<em class="my"> apt-get autoremove </em>、<em class="my"> apt-get clean、</em>和<em class="my"> apt-get autoclean </em>删除所有不必要的数据，并通过调用<em class="my">RM-RF/var/lib/apt/lists/*</em>删除下载的包源代码。这些步骤只是减少了docker图像的大小，从而减少了加载图像的时间。</p><p id="333d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们的docker文件准备好了，我们就创建一个新的GitHub库，只包含这个文件。你可以称之为DockerfileRepositoryForCpp。它应该只包含必须命名为Dockerfile的Dockerfile(没有文件结尾)。然后继续前进到<a class="ae nm" href="http://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>。如果您还没有帐户，请创建一个帐户，并验证您的电子邮件地址。我建议注册你的GitHub账户。登录后，选择顶部的<em class="my">仓库</em>，点击右上角的<em class="my">创建仓库</em>。提供名称和描述，将其公开，并滚动到底部。您应该会看到一个部分<em class="my">构建设置</em>和一个Github图标。点击它，将您的GitHub帐户连接到Docker帐户。帐户连接后，您应该会在Create repository页面上的Github图标下看到绿色的单词connected。现在单击Github图标应该会打开两个输入字段:一个用于组织，您可以在其中选择GitHub帐户，另一个用于存储库，您可以在其中选择DockerfileRepositoryForCpp存储库。接下来，点击<em class="my">创建&amp;构建</em>。</p><p id="50ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个过程需要一段时间才能完成，因为现在，Docker将下载我们在第一行中指定的基本映像，执行我们在Docker文件中记录的配置，然后提供最终操作系统的映像。还有其他方法来设置Docker映像，例如，您可以在本地机器上使用Docker CLI工具，并在本地执行Docker构建。之后，您可以将完成的映像推送到存储库。这样做的缺点是需要从你的机器上传完整的图片到Docker，如果你的网络连接是不对称的(通常是这样)，这将花费很长时间。我上面描述的方法有一个优点，GitHub和Docker服务器只交换Docker文件，其他事情都发生在Docker服务器上，所以不需要上传。它还向Dockerfile引入了版本管理，这在某些时候会派上用场。</p><h1 id="865a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">切尔莱西</h1><p id="521f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们现在已经完成了代码库，可以在GitHub中使用，我们已经进行了测试，我们已经配置了CMake，我们有一个Docker映像来运行所有这些步骤。我们现在需要的是为CircleCi设置一个管道，让它执行必要的步骤。</p><p id="950e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为第一步，我们使用我们的GitHub帐户登录<a class="ae nm" href="https://circleci.com/vcs-authorize/" rel="noopener ugc nofollow" target="_blank"> CircleCi </a>。接下来，我们添加一个项目，并选择包含我们在GitHub上的代码和测试的项目。目前，CircleCi还没有C++项目的模板，所以你可以选择CircleCi会向你推荐的HelloWorld蓝图。点击<em class="my">添加配置</em>。CircleCi将创建项目，并在您的存储库中添加一个名为<em class="my"> circleci-project-setup </em>的分支。它包含一个具有一个新文件的提交。包含ci管道设置的circleci/config.yml。将来，CircleCi将被告知所有针对该存储库的提交，并将始终执行config.yml文件中列出的步骤。因此，通过更改这个文件，您可以更改CircleCi为您执行的步骤。我建议使用这个config.yml:</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="c856" class="mt ky iq mp b gy mu mv l mw mx">version: 2.1<br/>executors:<br/>  exectr:<br/>    docker:<br/>      - image: YourGitHubName/YourDockerRepoName:latest</span><span id="5464" class="mt ky iq mp b gy nl mv l mw mx">jobs:<br/>  build:<br/>    executor: exectr<br/>    steps:<br/>      - checkout<br/>      - run:<br/>          name: Setup gtest child repo<br/>          command: |<br/>            cd third_party<br/>            git submodule init<br/>            git submodule update <br/>      - run:<br/>          name: Setup cmake and build artifacts<br/>          command: |<br/>            mkdir build<br/>            cd build<br/>            cmake ..<br/>            make<br/>      - persist_to_workspace:<br/>          root: .<br/>          paths: build</span><span id="e7d6" class="mt ky iq mp b gy nl mv l mw mx">  test:<br/>    executor: exectr<br/>    steps:<br/>      - attach_workspace:<br/>          at: .<br/>      - run:<br/>          name: Execute Tests<br/>          command: |<br/>            cd build<br/>            ./tests --gtest_output=XML<br/>      - store_test_results:<br/>          path: build</span><span id="641b" class="mt ky iq mp b gy nl mv l mw mx">workflows:<br/>  version: 2<br/>  build-and-test:<br/>    jobs:<br/>      - build<br/>      - test:<br/>          requires:<br/>            - build</span></pre><p id="7184" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解释这个文件，我们从底部开始:它声明了一个工作流。该工作流称为构建和测试，包含两个作业:构建和测试，其中测试依赖于构建。现在，我们需要做的就是声明构建和测试的步骤实际上是什么。</p><p id="d77f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第8行，我们开始定义我们的构建工作。它包含要执行的步骤列表。签出步骤将准备我们的代码(因为CircleCi知道它应该使用哪个repo，所以我们不需要在这里指定存储库)。然而，它不加载子模块，所以我们在签出后立即手动加载。步骤语法非常直观:每一步都由一个名称和一个要在shell中执行的命令组成。命令块开头的管道符号(|)意味着将有几个命令应该依次执行。我们进入第三方文件夹，如上所述加载googletest存储库。</p><p id="925b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们创建一个构建目录，输入它，用<em class="my"> cmake配置我们的代码库..</em>并开始编译用<em class="my">制作</em>。我们可以在这个或随后的命令块中立即运行我们的测试，但是这将有一个主要的缺点:在我们的项目中有两个失败点:代码库不能再编译或者测试不能再工作。如果我们将CircleCi管道分成两个作业，我们将有优势，我们将能够在CircleCi仪表板上看到哪些作业工作，哪些工作不工作，这将使诊断问题更快。</p><p id="9546" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，一旦构建完成，我们就将构建目录的内容保存到我们的工作区，这样我们就可以很容易地在任何其他作业中使用它们。在测试作业中，我们首先加载该工作区，现在又处于构建作业结束时的状态。我们只运行一个命令块，它进入构建目录并运行。/tests-gt est _ output = XML。除了控制台上的测试结果，googletest现在还将生成一个XML文件，其中包含所有运行的测试及其结果。如果我们添加一个add_test_results步骤，并使用包含此类XML文件的文件夹的路径，CircleCi可以从文件夹中抓取此类结果。</p><p id="d6a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的工作中，我们都指定了一个执行人。这是运行管道的系统的简称。我们在配置文件的最开始定义了这个执行器。我们定义了一个名为exectr的执行器，它使用了我们之前创建的Docker映像。要找到您应该放在这里的URL，请转到DockerHub 中的<a class="ae nm" href="https://hub.docker.com/repositories" rel="noopener ugc nofollow" target="_blank">您的存储库列表。您将看到类似这样的内容</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/8eb2b4e49c7448de948a063d79384366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lvBCTelbMAA43W7A.png"/></div></div></figure><p id="8693" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，silverlinings 89/CPP _ build _ environment将是您正在寻找的。要指定应该使用存储库的哪个状态，在名称后面添加【T2:最新的。所以在我的例子中，我会写<em class="my">—image:silver linings 89/CPP _ build _ environment:latest</em></p><p id="3791" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在将这个文件应用到您的项目之后，将它提交到您的存储库，并将提交推送到GitHub。CircleCi管道应该立即启动您的管道，构建您的项目，执行测试，并向您显示每个作业的状态。您应该会看到类似这样的内容:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/1e5eda8f872427ede56dc0ed44f3b9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WO5I-LzmvhZkumG4.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">CircleCi的成功构建和测试运行</figcaption></figure><p id="1a48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，这两项工作都是gree，即已经完成，因此构建是成功的。您可以单击测试作业查看更多详细信息:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/322640f09e03b51efb2292fc247c5ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cY42tezBs1tTgZZ5.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">UI列出了每个作业中的步骤，您还可以在这里查看控制台输出。</figcaption></figure><p id="a834" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个视图列出了各个步骤，您可以在中间看到一个标签TESTS [4]，它列出了我们上传的文件中解析的测试结果。如果你点击测试，你会看到</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/35f1c9b94312f4f9e1dc9b35abefa5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/0*1gYsDIZeugsmOUXk.png"/></div></figure><p id="6381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个设置中，我有4个测试，它们都是绿色的。测试结果可视化不是最理想的，您可以采取一些步骤来增加测试结果的可读性，但是现在，这个基本的设置应该足以让您的项目继续进行。每当您将提交推送到GitHub时，这个管道就会运行，并在CircleCi仪表板中显示您的存储库的每个分支的当前状态的管道结果。还有一个更吸引人的地方，可以用来在GitHub中集成存储库的状态(无论构建是否通过),并使其可以快速访问:</p><h1 id="f3a0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">README.md</h1><p id="10b1" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">将Readme.md添加到您的存储库中总是一个不错的步骤，因为GitHub很好地将它可视化，并且它给了从事代码工作的人一个开始的地方。如果你不熟悉语法，GitHub 上有一个很好的<a class="ae nm" href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" rel="noopener ugc nofollow" target="_blank">备忘单。在</a><a class="ae nm" href="https://circleci.com/docs/2.0/status-badges/" rel="noopener ugc nofollow" target="_blank">这一页</a>上，您将看到为您的Readme.md创建徽章的介绍，这些徽章可直观显示您的渠道状态。它将显示绿色的通过徽章或红色的失败徽章。它的代号是<br/>！[&lt;ORG _ NAME&gt;](https://circle ci . com/&lt;VCS&gt;/&lt;ORG _ NAME&gt;/&lt;PROJECT _ NAME&gt;。svg？style=svg)]( &lt;链接&gt;)</p><p id="a52a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的项目中</p><pre class="km kn ko kp gt mo mp mq mr aw ms bi"><span id="558f" class="mt ky iq mp b gy mu mv l mw mx">[![SilverLinings89](https://circleci.com/gh/SilverLinings89/HallmarksSearchTools.svg?style=svg)](https://app.circleci.com/pipelines/github/SilverLinings89)</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="41ad" class="kx ky iq bd kz la ng lc ld le nh lg lh li ni lk ll lm nj lo lp lq nk ls lt lu bi translated">结束语</h1><p id="ef5e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">再来一杯咖啡，这是你应得的！</p><p id="0fea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这对你有指导意义，并且我可以帮助你在你的项目中获得一些结构和自动化。我试图解释为什么这些步骤是必要的。如果你觉得这篇文章很有用，请与其他可能会感兴趣的人分享，如果有任何问题，请给我留言。另外，谢谢你<a class="ae nm" href="https://www.pexels.com/de-de/@padrinan?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">米盖尔·Á。padrián</a>在<a class="ae nm" href="https://www.pexels.com/de-de/foto/industrie-technologie-fabrik-kreis-3785927/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄专题图片。</p></div></div>    
</body>
</html>