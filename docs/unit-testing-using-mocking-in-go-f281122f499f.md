# åœ¨ Go ä¸­ä½¿ç”¨æ¨¡æ‹Ÿçš„å•å…ƒæµ‹è¯•

> åŸæ–‡ï¼š<https://levelup.gitconnected.com/unit-testing-using-mocking-in-go-f281122f499f>

![](img/8b85cac14dc41f7e7e5f8e724e661d8d.png)

# æ¦‚å¿µæ¦‚è¿°

(å¦‚æœä½ çŸ¥é“ä»€ä¹ˆæ˜¯å•å…ƒæµ‹è¯•å’Œæ¨¡æ‹Ÿï¼Œåªæ˜¯æƒ³çœ‹çœ‹å®ƒæ˜¯å¦‚ä½•åœ¨ä»£ç å±‚é¢ä¸Šå®Œæˆçš„ï¼Œå¯ä»¥è·³è¿‡è¿™ä¸€èŠ‚ğŸ™‚)

***å•å…ƒæµ‹è¯•*** åœ¨ Go æˆ–è€…ä¸€èˆ¬çš„å•å…ƒæµ‹è¯•ä¸­ï¼Œå°±æ˜¯ç®€å•çš„å¯¹æˆ‘ä»¬ä»£ç ä¸­çš„ä¸€ä¸ªå•å…ƒè¿›è¡Œæµ‹è¯•ã€‚å•å…ƒæ˜¯ç³»ç»Ÿä¸­å¯ä»¥é€»è¾‘éš”ç¦»çš„æœ€å°ä»£ç ç‰‡æ®µã€‚åœ¨å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå®ƒæ˜¯ä¸€ä¸ªå‡½æ•°ã€å­ä¾‹ç¨‹æˆ–å±æ€§ã€‚å•å…ƒæµ‹è¯•çš„ç›®çš„æ˜¯éªŒè¯ä»£ç ä¸­çš„æ¯ä¸ªå•å…ƒéƒ½æŒ‰ç…§è®¾è®¡æ‰§è¡Œã€‚

ç°åœ¨ï¼Œåœ¨ä¸€ä¸ªå·¥ä¸šçº§ä»£ç ä¸­ï¼Œæˆ‘ä»¬æƒ³è¦æµ‹è¯•çš„æ¯ä¸€ä¸ªå•å…ƒï¼Œå¯èƒ½æœ‰ä¹Ÿå¯èƒ½æ²¡æœ‰å¯¹å…¶ä»–å•å…ƒ/æ–¹æ³•/åŠŸèƒ½çš„å¤–éƒ¨ä¾èµ–ã€‚åœ¨æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€äº›å¤–éƒ¨ä¾èµ–çš„æ¦‚å¿µï¼Œ ***å˜²è®½*** å‘æŒ¥ä½œç”¨ã€‚

***å˜²è®½*** æ˜¯å½“è¢«æµ‹å•å…ƒå­˜åœ¨å¤–éƒ¨ä¾èµ–æ—¶ï¼Œåœ¨å•å…ƒæµ‹è¯•ä¸­ä½¿ç”¨çš„è¿‡ç¨‹ã€‚æ¨¡ä»¿çš„ç›®çš„æ˜¯éš”ç¦»å¹¶å…³æ³¨è¢«æµ‹è¯•çš„ä»£ç ï¼Œè€Œä¸æ˜¯å¤–éƒ¨ä¾èµ–çš„è¡Œä¸ºæˆ–çŠ¶æ€ã€‚åœ¨ mocking ä¸­ï¼Œä¾èµ–å…³ç³»è¢«æ¨¡æ‹ŸçœŸå®å¯¹è±¡è¡Œä¸ºçš„ä¸¥å¯†æ§åˆ¶çš„æ›¿æ¢å¯¹è±¡æ‰€å–ä»£ã€‚æ›¿æ¢å¯¹è±¡å¯ä»¥æœ‰ä¸‰ç§ç±»å‹:*å‡è´§ã€å­˜æ ¹*å’Œ*ä»¿åˆ¶å“ã€‚*

ä¸€ä¸ª ***å‡çš„*** æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒå°†é€šè¿‡å®ç°ç›¸åŒçš„æ¥å£æ¥æ›¿æ¢å®é™…çš„ä»£ç ï¼Œä½†ä¸ä¸å…¶ä»–å¯¹è±¡äº¤äº’ã€‚é€šå¸¸å‡çš„æ˜¯ç¡¬ç¼–ç è¿”å›å›ºå®šçš„ç»“æœã€‚

ä¸€ä¸ª ***Stub*** æ˜¯ä¸€ä¸ªåŸºäºä¸€ç»„ç‰¹å®šè¾“å…¥è¿”å›ç‰¹å®šç»“æœçš„å¯¹è±¡ï¼Œé€šå¸¸ä¸ä¼šå¯¹æµ‹è¯•ç¼–ç¨‹ä¹‹å¤–çš„ä»»ä½•äº‹æƒ…åšå‡ºå“åº”ã€‚

ä¸€ä¸ª ***Mock*** æ˜¯ä¸€ä¸ªæ›´åŠ å¤æ‚çš„å­˜æ ¹ç‰ˆæœ¬ã€‚å®ƒä»ç„¶ä¼šåƒå­˜æ ¹ä¸€æ ·è¿”å›å€¼ï¼Œä½†æ˜¯å®ƒä¹Ÿå¯ä»¥æ ¹æ®æ¯ä¸ªæ–¹æ³•åº”è¯¥è¢«è°ƒç”¨å¤šå°‘æ¬¡ã€ä»¥ä»€ä¹ˆé¡ºåºå’Œç”¨ä»€ä¹ˆæ•°æ®æ¥ç¼–ç¨‹ã€‚

æœ€åˆï¼Œæ¨¡ä»¿å¯èƒ½å¬èµ·æ¥æœ‰ç‚¹ä¹å‘³å’Œè€—æ—¶ï¼Œä½†æ˜¯åœ¨ç°æœ‰æ¨¡ä»¿æ¡†æ¶çš„å¸®åŠ©ä¸‹å¯ä»¥å¾ˆå®¹æ˜“åœ°å®ç°ã€‚åœ¨æˆ‘ä¸‹é¢æä¾›çš„ä¾‹å­ä¸­ï¼Œæˆ‘åœ¨ golang ä¸­ä½¿ç”¨äº† ***go-mock*** æ¡†æ¶ï¼Œåªç”¨ä¸€è¡Œå‘½ä»¤å°±ç”Ÿæˆäº†æ•´ä¸ªæ¥å£çš„æ¨¡æ‹Ÿå¯¹è±¡ã€‚

é‚£ä¹ˆï¼Œç°åœ¨ä½ å¯¹ä»€ä¹ˆæ˜¯å•å…ƒæµ‹è¯•ä»¥åŠå¦‚ä½•ä½¿ç”¨ mocking æ¥å®Œæˆå•å…ƒæµ‹è¯•æœ‰äº†ä¸€ä¸ªåŸºæœ¬çš„æ¦‚å¿µï¼Œè®©æˆ‘ä»¬åœ¨ç¼–ç æ•™ç¨‹çš„å¸®åŠ©ä¸‹å°†è¿™äº›æ¦‚å¿µå½¢è±¡åŒ–ã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œåœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘å·²ç»ä¸ºé‚£äº›ä½œä¸ºæ¥å£ä¸€éƒ¨åˆ†çš„å‡½æ•°ç¼–å†™äº†æµ‹è¯•ç”¨ä¾‹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¨¡æ‹Ÿç”Ÿæˆå˜å¾—å¾ˆå®¹æ˜“ã€‚å› æ­¤ï¼Œå°†å‡½æ•°åŒ…è£…åœ¨ä¸€ä¸ªæ¥å£ä¸­æ€»æ˜¯ä¸€ä¸ªå¥½çš„é€‰æ‹©ã€‚

# å®‰è£…æŒ‡å—

é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç›´æ¥ä¸ºæ‚¨çš„ go å‡½æ•°å®‰è£…ä¸€ä¸ªåƒæ ·çš„æ¨¡æ‹Ÿç”Ÿæˆå™¨ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ ***mockgen*** ä»£ç ç”Ÿæˆå·¥å…·è¿›è¡ŒåŒæ ·çš„æ“ä½œã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ ***gomock*** åŒ…ä½œä¸ºç¼–å†™å•å…ƒæµ‹è¯•ç”¨ä¾‹çš„è¾…åŠ©å·¥å…·ã€‚

è¿™ä¸¤ä¸ªéƒ½å¯ä»¥ä½¿ç”¨ *go get* è¿›è¡Œå®‰è£…:

*   å»æ‰¾ github.com/golang/mock/gomock
*   å»æ‰¾ github.com/golang/mock/mockgen

è¦æ£€æŸ¥ mockgen äºŒè¿›åˆ¶æ–‡ä»¶æ˜¯å¦å®‰è£…æ­£ç¡®ï¼Œåªéœ€è¿è¡Œä»¥ä¸‹å‘½ä»¤:

*   $GOPATH/bin/mockgen

*æ³¨æ„:å¦‚æœæ‚¨è¿˜æ²¡æœ‰å°†$GOPATH/bin æ·»åŠ åˆ°æ‚¨çš„$PATH os ç¯å¢ƒå˜é‡ä¸­ï¼Œè¯·æ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚å¦åˆ™ï¼Œåœ¨ä½¿ç”¨è¿™ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶æ—¶ï¼Œä½ å¿…é¡»æ€»æ˜¯æåˆ°å®ƒçš„å®Œæ•´è·¯å¾„ã€‚*

# ç¼–ç æ•™ç¨‹

ç”±äºè¿™åªæ˜¯ä¸€ä¸ªæ•™ç¨‹ï¼Œè®©æˆ‘ä»¬ä¿æŒç®€å•ã€‚è®©æˆ‘ä»¬å‡è®¾ä¸€è¾†æ¥å£è½¦:

```
type CAR interface { Start(*gin.Context, string, CAR) bool EngineCheck(*gin.Context, CAR) bool}type CARSTRUCT struct {
}func (car CARSTRUCT) Start(context *gin.Context, key string, carInterface CAR) bool { if carInterface.EngineCheck(context,carInterface) {
      if key == "carkey" {
         fmt.Println("Let's start the car!")
         return *true* } else {
         fmt.Println("You don't have the right key!")
         return *false* }
   } else {
      return *false* }
}func (car CARSTRUCT) EngineCheck(context *gin.Context, carInterface CAR) bool {
   return *true* }
```

é¦–å…ˆè®©æˆ‘ä»¬ä½¿ç”¨ mockgen ç”Ÿæˆè¿™ä¸ªæ¥å£çš„æ¨¡æ‹Ÿã€‚åªéœ€è¿è¡Œä»¥ä¸‹å‘½ä»¤:

***mock gen-destination = Mocks/mock _ car . go-package = Mocks-source = cars . go***

ç¡®ä¿ä½ åˆ›å»ºäº†ä¸€ä¸ªç›®å½•æ¥å­˜å‚¨ä½ çš„æ¨¡æ‹Ÿæ–‡ä»¶(*æ¨¡æ‹Ÿ*)ã€‚ *destination* æ˜¯è¿™ä¸ªç›®å½•(Mocks/mock_car.go)çš„ä½ç½®ï¼Œ *package* æ˜¯ç”Ÿæˆçš„æ¨¡æ‹Ÿæ–‡ä»¶çš„åŒ…åï¼Œ *source* æ˜¯ä½ å¸Œæœ›æ¨¡æ‹Ÿçš„æ¥å£æ‰€åœ¨çš„æ–‡ä»¶çš„ä½ç½®ã€‚

ç”Ÿæˆçš„æ¨¡æ‹Ÿæ–‡ä»¶å¦‚ä¸‹æ‰€ç¤º:

```
// Code generated by MockGen. DO NOT EDIT.
// Source: cars.go
// Package Mocks is a generated GoMock package.
package Mocks
import (
   gin "github.com/gin-gonic/gin"
   gomock "github.com/golang/mock/gomock"
   testing "middleware/middleware/testing"
   reflect "reflect"
)
// MockCAR is a mock of CAR interface
type MockCAR struct {
   ctrl *gomock.Controller
   recorder *MockCARMockRecorder
}
// MockCARMockRecorder is the mock recorder for MockCAR
type MockCARMockRecorder struct {
   mock *MockCAR
}
// NewMockCAR creates a new mock instance
func NewMockCAR(ctrl *gomock.Controller) *MockCAR {
   mock := &MockCAR{ctrl: ctrl}
   mock.recorder = &MockCARMockRecorder{mock}
   return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCAR) EXPECT() *MockCARMockRecorder {
   return m.recorder
}
// Start mocks base method
func (m *MockCAR) Start(arg0 *gin.Context, arg1 string, arg2 testing.CAR) bool {
   m.ctrl.T.Helper()
   ret := m.ctrl.Call(m, "Start", arg0, arg1, arg2)
   ret0, _ := ret[0].(bool)
   return ret0
}
// Start indicates an expected call of Start
func (mr *MockCARMockRecorder) Start(arg0, arg1, arg2 interface{}) *gomock.Call {
   mr.mock.ctrl.T.Helper()
   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockCAR)(nil).Start), arg0, arg1, arg2)
}
// EngineCheck mocks base method
func (m *MockCAR) EngineCheck(arg0 *gin.Context, arg1 testing.CAR) bool {
   m.ctrl.T.Helper()
   ret := m.ctrl.Call(m, "EngineCheck", arg0, arg1)
   ret0, _ := ret[0].(bool)
   return ret0
}
// EngineCheck indicates an expected call of EngineCheck
func (mr *MockCARMockRecorder) EngineCheck(arg0, arg1 interface{}) *gomock.Call {
   mr.mock.ctrl.T.Helper()
   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EngineCheck", reflect.TypeOf((*MockCAR)(nil).EngineCheck), arg0, arg1)
}
```

ç°åœ¨æˆ‘ä»¬æœ‰äº†æ¨¡æ‹Ÿï¼Œè®©æˆ‘ä»¬å¼€å§‹ç¼–å†™æµ‹è¯•ç”¨ä¾‹ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ *gomock* åŒ…æ¥ç¼–å†™æˆ‘ä»¬çš„å•å…ƒæµ‹è¯•ç”¨ä¾‹ï¼Œä¸‹é¢æ˜¯æˆ‘ä»¬åœ¨ç¼–å†™æµ‹è¯•ç”¨ä¾‹æ—¶å°†éµå¾ªçš„æ•´ä¸ªå·¥ä½œæµç¨‹:

1.  åœ¨æˆ‘ä»¬çš„æµ‹è¯•ä¸­ï¼Œé¦–å…ˆåˆ›å»ºä¸€ä¸ª *gomock çš„å®ä¾‹ã€‚æ§åˆ¶å™¨*å¹¶å°†å…¶ä¼ é€’ç»™æ¨¡æ‹Ÿå¯¹è±¡çš„æ„é€ å‡½æ•°ä»¥è·å¾—æ¨¡æ‹Ÿå¯¹è±¡ã€‚
2.  åœ¨æ‚¨çš„æ¨¡æ‹Ÿä¸Šè°ƒç”¨ **Expect()** æ¥è®¾ç½®å®ƒä»¬çš„æœŸæœ›å€¼å’Œè¿”å›å€¼ã€‚å¦‚æœæ‰€è€ƒè™‘çš„å‡½æ•°æœ‰å¯¹å…¶ä»–å‡½æ•°çš„å¤–éƒ¨è°ƒç”¨ï¼Œè¿™æ˜¯å¿…éœ€çš„ã€‚
3.  è°ƒç”¨ main å‡½æ•°(æˆ‘ä»¬æ­£åœ¨ä¸ºå…¶ç¼–å†™æµ‹è¯•ç”¨ä¾‹çš„å‡½æ•°)æ¥è§¦å‘ä»£ç æµé€šè¿‡å‚æ•°ä¸­çš„æ¨¡æ‹Ÿæ¥å£ï¼Œè€Œä¸æ˜¯çœŸæ­£çš„æ¥å£ã€‚
4.  åœ¨æ¨¡æ‹Ÿæ§åˆ¶å™¨ä¸Šè°ƒç”¨ **Finish()** ï¼Œç„¶åæ–­è¨€æ¨¡æ‹Ÿçš„æœŸæœ›ã€‚
5.  æœ€åï¼Œæ–­è¨€è¢«è°ƒç”¨çš„ä¸»å‡½æ•°çš„é¢„æœŸæœ€ç»ˆç»“æœã€‚

è®©æˆ‘ä»¬çœ‹çœ‹ **Start()** å‡½æ•°çš„å•å…ƒæµ‹è¯•ç”¨ä¾‹æ˜¯ä»€ä¹ˆæ ·å­çš„:

```
func TestCARSTRUCT_Start(t *testing.T) { controller := gomock.NewController(t) defer controller.Finish() MockInterface := Mocks.NewMockCAR(controller) var ctx *gin.Context
   MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(*true*) result := CARSTRUCT{}.Start(ctx,"carkey",MockInterface) assert.Equal(t,*true*,result)
}
```

æœ€åˆçš„å‡ ä¸ªæ­¥éª¤éå¸¸ç®€å•ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª gomock æ§åˆ¶å™¨ï¼Œç„¶åç”¨å®ƒæ¥åˆ›å»ºæˆ‘ä»¬ç•Œé¢çš„æ¨¡æ‹Ÿç‰ˆæœ¬ã€‚

ç°åœ¨ï¼Œæ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ï¼Œæœ‰ä¸€ä¸ªå¯¹å‡½æ•° *EngineCheck()ï¼Œ*çš„å¤–éƒ¨è°ƒç”¨ï¼Œå› æ­¤æœ‰ä¸€ä¸ªå¯¹è¯¥å‡½æ•°çš„æœŸæœ›æ£€æŸ¥ã€‚

```
MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(*true*)
```

è¿™ç§æœŸæœ›æ£€æŸ¥åšçš„æ¯”çœ‹èµ·æ¥è¦å¤šï¼Œæˆ‘ä»¬ä¼ é€’çš„å‚æ•°å€¼æ˜¯é’ˆå¯¹è¿è¡Œæ—¶æ¥æ”¶çš„å€¼æ–­è¨€çš„(åœ¨æˆ‘ä»¬çš„æµ‹è¯•ç”¨ä¾‹ä¸­ï¼Œåœ¨æˆ‘ä»¬è°ƒç”¨ *Start()* ä¹‹åï¼Œå®é™…ä¸Šè°ƒç”¨äº† *EngineCheck()* )ã€‚æˆ‘ä»¬è¿˜æåˆ°äº†ä¸€ä¸ªè¿”å›å€¼ï¼Œå®ƒå°†åœ¨æœŸæœ›è°ƒç”¨åŒ¹é…æ—¶è¿”å›ã€‚

æœ€åï¼Œæˆ‘ä»¬è°ƒç”¨å®é™…çš„ *Start()* å‡½æ•°æ¥è§¦å‘æˆ‘ä»¬çš„æµ‹è¯•æµç¨‹ï¼Œå¹¶æ–­è¨€æˆ‘ä»¬çš„é¢„æœŸè¿”å›å€¼ã€‚

# å‚æ•°æ¯”è¾ƒå™¨

æˆ‘ä»¬å¯èƒ½å…³å¿ƒä¹Ÿå¯èƒ½ä¸å…³å¿ƒè°ƒç”¨æ¨¡æ‹Ÿæ—¶ä½¿ç”¨çš„å‚æ•°å€¼ã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œå‚æ•°æ¯”è¾ƒå™¨å¯ç”¨äºæ–­è¨€æˆ–å¿½ç•¥æ¨¡æ‹Ÿæ–¹æ³•çš„ç‰¹å®šå‚æ•°å€¼:

*   *gomockã€‚Any():åŒ¹é…ä»»ä½•å€¼(ä»»ä½•ç±»å‹)*
*   *gomockã€‚Eq(x):ç”¨äºåŒ¹é…æ·±åº¦ç­‰äº x çš„å€¼*
*   *gomockã€‚Nil():åŒ¹é… nil*
*   *gomockã€‚Not(x):åŒ¹é…æ·±åº¦ä¸ç­‰äº x çš„å€¼*

ä¸€ä¸ªå‚æ•°å¯ä»¥æœ‰ä¸€ä¸ªå›ºå®šçš„å€¼(é€šè¿‡åœ¨é¢„æœŸçš„è°ƒç”¨ä¸­æŒ‡å®šå€¼ï¼Œå°±åƒæˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢æ‰€åšçš„é‚£æ ·),æˆ–è€…å¯ä»¥ä½¿ç”¨è¿™äº›æ¯”è¾ƒå™¨è¿›è¡Œæ¯”è¾ƒã€‚ä¾‹å¦‚ï¼Œåœ¨å¯¹ *EngineCheck()* è¿›è¡ŒæœŸæœ›è°ƒç”¨æ—¶ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦å¿½ç•¥ç¬¬äºŒä¸ªå‚æ•°å€¼ï¼Œå°†æŒ‰å¦‚ä¸‹æ–¹å¼è¿›è¡Œ:

```
MockInterface.EXPECT().EngineCheck(ctx, gomock.Any()).Return(true)
```

# éªŒè¯å‘¼å«è®¢å•

å‡è®¾æˆ‘ä»¬åœ¨ä¸»å‡½æ•°ä¸­å¤šæ¬¡è°ƒç”¨å¤–éƒ¨å‡½æ•°ï¼Œé€šå¸¸è¿™äº›è°ƒç”¨çš„é¡ºåºä¹Ÿå¾ˆé‡è¦ã€‚æ‰€ä»¥è¿˜æœ‰ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ gomock çš„ ***After()*** æ–¹æ³•æ¥æ–­è¨€è°ƒç”¨é¡ºåºã€‚ä¸¾ä¸ªä¾‹å­ï¼Œ

```
FirstCall := MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(true)callA :=  MockInterface.EXPECT().MethodA(ctx,MockInterface).After(FirstCall)callB := MockInterface.EXPECT().MethodB(ctx,MockInterface).After(callA)
```

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ–­è¨€å¯¹ MethodA çš„è°ƒç”¨æ˜¯åœ¨å¯¹ EngineCheck çš„è°ƒç”¨ä¹‹åè¿›è¡Œçš„ï¼Œå¯¹ MethodB çš„è°ƒç”¨æ˜¯åœ¨å¯¹ MethodA çš„è°ƒç”¨ä¹‹åè¿›è¡Œçš„ã€‚

# ä½¿ç”¨é€šé“å’ŒæŒ‡å®šæ¨¡æ‹ŸåŠ¨ä½œ

åœ¨ go ä¸­ä½¿ç”¨é€šé“å’Œ goroutines æ—¶ï¼Œå•å…ƒæµ‹è¯•å˜å¾—æœ‰ç‚¹æ£˜æ‰‹ã€‚è®©æˆ‘ä»¬ä¿®æ”¹æˆ‘ä»¬çš„ *Start()* å‡½æ•°ï¼Œå¹¶ä¸ºæˆ‘ä»¬çš„æ±½è½¦ç•Œé¢æ·»åŠ æ›´å¤šçš„å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤º:

```
type CAR interface {
   Start(*gin.Context, string, CAR) bool
   EngineCheck(*gin.Context, CAR) bool
   SuspensionCheck(*gin.Context, CAR, chan bool)
   BrakesCheck(*gin.Context, CAR, chan bool)
}type CARSTRUCT struct {
}func (car CARSTRUCT) Start(context *gin.Context, key string, carInterface CAR) bool { if carInterface.EngineCheck(context, carInterface) { if key == "carkey" { fmt.Println("Let's start the car!")

         var brakes = make(chan bool)

         var suspension = make(chan bool)

         go carInterface.BrakesCheck(context,carInterface,brakes) go        carInterface.SuspensionCheck(context,carInterface,suspension)

         if <-brakes && <-suspension {
            return *true* } else {
            return *false* }
      } else {
         fmt.Println("You don't have the right key!")
         return *false* }
   } else {
      return *false* }
}func (car CARSTRUCT) EngineCheck(context *gin.Context, carInterface CAR) bool {
   return *true* }func (car CARSTRUCT) SuspensionCheck(context *gin.Context, carInterface CAR, result chan bool) {
   result <- *true* }func (car CARSTRUCT) BrakesCheck(context *gin.Context, carInterface CAR, result chan bool) {
   result <- *true* }
```

ç°åœ¨ï¼Œæˆ‘ä»¬åœ¨ Start()æ–¹æ³•ä¸­æœ‰äº†å¯¹å‡½æ•° SuspensionCheck()å’Œ BrakesCheck()çš„ä¸¤ä¸ª goroutine è°ƒç”¨ï¼Œä»¥åŠæ¥æ”¶è¿™äº›å¼‚æ­¥è°ƒç”¨è¾“å‡ºçš„å¸ƒå°”é€šé“ã€‚æˆ‘ä»¬è¿˜å¿…é¡»ä½¿ç”¨ä¸Šé¢æåˆ°çš„ mockgen å‘½ä»¤é‡æ–°ç”Ÿæˆæˆ‘ä»¬çš„æ¨¡æ‹Ÿã€‚

å‡½æ•° *SuspensionCheck()* å’Œ*brake check()*åœ¨å…¶è¾“å‡ºé€šé“ä¸­å†™å…¥çœŸå¸ƒå°”å€¼ã€‚å› æ­¤ï¼Œå½“æœŸæœ›è°ƒç”¨ç›¸åŒçš„åŒ¹é…æ—¶ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡æ¨¡æ‹Ÿå‡½æ•°æ¥æ¨¡æ‹Ÿè¿™ç§è¡Œä¸ºã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ï¼Œå› ä¸ºè¢«æ¨¡ä»¿çš„å¯¹è±¡åªä¼šåœ¨é€‚å½“çš„æ—¶å€™æä¾›æ‰«æå“åº”ï¼Œå¹¶è®°å½•å®ƒä»¬çš„å‘¼å«ã€‚ä½†è¿™å¯ä»¥é€šè¿‡ gomock çš„ ***Do()*** æˆ–***DoAndReturn()***æ–¹æ³•æ¥å®Œæˆï¼Œè¿™äº›æ–¹æ³•ç”¨äºæŒ‡å®šæ¨¡æ‹ŸåŠ¨ä½œã€‚è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬çš„æµ‹è¯•ç”¨ä¾‹ç°åœ¨æ˜¯ä»€ä¹ˆæ ·å­:

```
func TestCARSTRUCT_Start(t *testing.T) {

   controller := gomock.NewController(t)

   defer controller.Finish()

   MockInterface := Mocks.NewMockCAR(controller)

   var ctx *gin.Context

   MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(*true*)

   MockInterface.EXPECT().BrakesCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){
      arg2.(chan bool) <- *true* })

   MockInterface.EXPECT().SuspensionCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){
      arg2.(chan bool) <- *true* })

   result := testing2.CARSTRUCT{}.Start(ctx,"carkey",MockInterface)

   assert.Equal(t,*true*,result)

}
```

è®©æˆ‘ä»¬çœ‹çœ‹å¯¹ *BrakesCheck()* çš„æœŸæœ›æ£€æŸ¥:

```
MockInterface.EXPECT().BrakesCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){
   arg2.(chan bool) <- *true* })
```

æˆ‘ä»¬æ‰€åšçš„æ˜¯ï¼Œå½“æœŸæœ›åŒ¹é…æ—¶ï¼Œå³ä½¿ç”¨æ‰€æåˆ°çš„å‚æ•°å€¼è°ƒç”¨äº†æ¨¡æ‹Ÿçš„*brake check()*ï¼Œé‚£ä¹ˆå°†æ‰§è¡Œ DoAndReturn()ä¸­çš„å‡½æ•°( *func()* )ã€‚

```
func(arg0, arg1, arg2 interface{}){
   arg2.(chan bool) <- *true* }
```

å› æ­¤ï¼Œå½“å¯¹ *BrakesCheck()* çš„è°ƒç”¨åŒ¹é…æ—¶ï¼Œ *func()* è¢«æ‰§è¡Œï¼Œå¸ƒå°”å€¼ true è¢«å†™å…¥ç»“æœé€šé“ã€‚è¿™æ­£æ˜¯éœ€è¦æ¨¡ä»¿çš„è¡Œä¸ºã€‚

*æ³¨æ„:Do()æˆ– DoAndReturn()ä¸­çš„å‡½æ•°å°†å…·æœ‰ä¸æˆ‘ä»¬æ­£åœ¨æ¨¡æ‹Ÿçš„å‡½æ•°çš„æœŸæœ›æ–¹æ³•ç›¸åŒçš„å‚æ•°ç­¾åï¼Œ*

```
// BrakesCheck indicates an expected call of BrakesCheck
func (mr *MockCARMockRecorder) BrakesCheck(arg0, arg1, arg2 interface{}) *gomock.Call {
   mr.mock.ctrl.T.Helper()
   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BrakesCheck", reflect.TypeOf((*MockCAR)(nil).BrakesCheck), arg0, arg1, arg2)
}
```

*åŒæ ·ï¼Œè¿™äº›è‡ªå˜é‡ä¸­çš„æ¯ä¸€ä¸ª(arg0ï¼Œ1ï¼Œ3..)å¯¹åº”äºåœ¨æœŸæœ›è°ƒç”¨åŒ¹é…åè°ƒç”¨æ¨¡æ‹Ÿå‡½æ•°æ‰€ç”¨çš„å®é™…å‚æ•°ã€‚å°±åƒåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œfunc()æ­£å¥½æœ‰ 3 ä¸ªç±»å‹æ¥å£çš„å‚æ•° arg0ã€arg1 å’Œ arg2ï¼Œè¿™ä¸æˆ‘ä»¬çš„ BrakesCheck()å‡½æ•°çš„æœŸæœ›æ–¹æ³•ç›¸åŒï¼Œarg0 å¯¹åº”äºä¸Šä¸‹æ–‡(*ginã€‚ä¸Šä¸‹æ–‡)ï¼Œarg1 æ˜¯ MockInterfaceï¼Œarg2 å¯¹åº”äºç»“æœ bool é€šé“ã€‚*

*è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå½“æœŸæœ›è°ƒç”¨åŒ¹é…æ—¶ï¼Œæˆ‘ä»¬çŸ¥é“ç»“æœé€šé“åœ¨ç¬¬ä¸‰ä¸ªå‚æ•°ä½ç½®æˆ– arg2 è¢«ä¼ é€’ï¼Œæ‰€ä»¥æˆ‘ä»¬ç®€å•åœ°å°† arg2 ç±»å‹è½¬æ¢ä¸º bool é€šé“ï¼Œå¹¶åœ¨å…¶ä¸­å†™å…¥å€¼ trueï¼Œä»¥é€šè¿‡å®ƒçš„ mock æ¨¡æ‹Ÿ BrakesCheck()çš„å®é™…è¡Œä¸ºï¼Œ*

```
arg2.(chan bool) <- *true*
```