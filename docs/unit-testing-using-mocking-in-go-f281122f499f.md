# 在 Go 中使用模拟的单元测试

> 原文：<https://levelup.gitconnected.com/unit-testing-using-mocking-in-go-f281122f499f>

![](img/8b85cac14dc41f7e7e5f8e724e661d8d.png)

# 概念概述

(如果你知道什么是单元测试和模拟，只是想看看它是如何在代码层面上完成的，可以跳过这一节🙂)

***单元测试*** 在 Go 或者一般的单元测试中，就是简单的对我们代码中的一个单元进行测试。单元是系统中可以逻辑隔离的最小代码片段。在大多数编程语言中，它是一个函数、子例程或属性。单元测试的目的是验证代码中的每个单元都按照设计执行。

现在，在一个工业级代码中，我们想要测试的每一个单元，可能有也可能没有对其他单元/方法/功能的外部依赖。在案例中，我们有一些外部依赖的概念， ***嘲讽*** 发挥作用。

***嘲讽*** 是当被测单元存在外部依赖时，在单元测试中使用的过程。模仿的目的是隔离并关注被测试的代码，而不是外部依赖的行为或状态。在 mocking 中，依赖关系被模拟真实对象行为的严密控制的替换对象所取代。替换对象可以有三种类型:*假货、存根*和*仿制品。*

一个 ***假的*** 是一个对象，它将通过实现相同的接口来替换实际的代码，但不与其他对象交互。通常假的是硬编码返回固定的结果。

一个 ***Stub*** 是一个基于一组特定输入返回特定结果的对象，通常不会对测试编程之外的任何事情做出响应。

一个 ***Mock*** 是一个更加复杂的存根版本。它仍然会像存根一样返回值，但是它也可以根据每个方法应该被调用多少次、以什么顺序和用什么数据来编程。

最初，模仿可能听起来有点乏味和耗时，但是在现有模仿框架的帮助下可以很容易地实现。在我下面提供的例子中，我在 golang 中使用了 ***go-mock*** 框架，只用一行命令就生成了整个接口的模拟对象。

那么，现在你对什么是单元测试以及如何使用 mocking 来完成单元测试有了一个基本的概念，让我们在编码教程的帮助下将这些概念形象化。这里需要注意的一点是，在下面的例子中，我已经为那些作为接口一部分的函数编写了测试用例。在这种情况下，模拟生成变得很容易。因此，将函数包装在一个接口中总是一个好的选择。

# 安装指南

首先，让我们直接为您的 go 函数安装一个像样的模拟生成器。我们将使用 ***mockgen*** 代码生成工具进行同样的操作。此外，我们将使用 ***gomock*** 包作为编写单元测试用例的辅助工具。

这两个都可以使用 *go get* 进行安装:

*   去找 github.com/golang/mock/gomock
*   去找 github.com/golang/mock/mockgen

要检查 mockgen 二进制文件是否安装正确，只需运行以下命令:

*   $GOPATH/bin/mockgen

*注意:如果您还没有将$GOPATH/bin 添加到您的$PATH os 环境变量中，请执行相同的操作。否则，在使用这个二进制文件时，你必须总是提到它的完整路径。*

# 编码教程

由于这只是一个教程，让我们保持简单。让我们假设一辆接口车:

```
type CAR interface { Start(*gin.Context, string, CAR) bool EngineCheck(*gin.Context, CAR) bool}type CARSTRUCT struct {
}func (car CARSTRUCT) Start(context *gin.Context, key string, carInterface CAR) bool { if carInterface.EngineCheck(context,carInterface) {
      if key == "carkey" {
         fmt.Println("Let's start the car!")
         return *true* } else {
         fmt.Println("You don't have the right key!")
         return *false* }
   } else {
      return *false* }
}func (car CARSTRUCT) EngineCheck(context *gin.Context, carInterface CAR) bool {
   return *true* }
```

首先让我们使用 mockgen 生成这个接口的模拟。只需运行以下命令:

***mock gen-destination = Mocks/mock _ car . go-package = Mocks-source = cars . go***

确保你创建了一个目录来存储你的模拟文件(*模拟*)。 *destination* 是这个目录(Mocks/mock_car.go)的位置， *package* 是生成的模拟文件的包名， *source* 是你希望模拟的接口所在的文件的位置。

生成的模拟文件如下所示:

```
// Code generated by MockGen. DO NOT EDIT.
// Source: cars.go
// Package Mocks is a generated GoMock package.
package Mocks
import (
   gin "github.com/gin-gonic/gin"
   gomock "github.com/golang/mock/gomock"
   testing "middleware/middleware/testing"
   reflect "reflect"
)
// MockCAR is a mock of CAR interface
type MockCAR struct {
   ctrl *gomock.Controller
   recorder *MockCARMockRecorder
}
// MockCARMockRecorder is the mock recorder for MockCAR
type MockCARMockRecorder struct {
   mock *MockCAR
}
// NewMockCAR creates a new mock instance
func NewMockCAR(ctrl *gomock.Controller) *MockCAR {
   mock := &MockCAR{ctrl: ctrl}
   mock.recorder = &MockCARMockRecorder{mock}
   return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCAR) EXPECT() *MockCARMockRecorder {
   return m.recorder
}
// Start mocks base method
func (m *MockCAR) Start(arg0 *gin.Context, arg1 string, arg2 testing.CAR) bool {
   m.ctrl.T.Helper()
   ret := m.ctrl.Call(m, "Start", arg0, arg1, arg2)
   ret0, _ := ret[0].(bool)
   return ret0
}
// Start indicates an expected call of Start
func (mr *MockCARMockRecorder) Start(arg0, arg1, arg2 interface{}) *gomock.Call {
   mr.mock.ctrl.T.Helper()
   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockCAR)(nil).Start), arg0, arg1, arg2)
}
// EngineCheck mocks base method
func (m *MockCAR) EngineCheck(arg0 *gin.Context, arg1 testing.CAR) bool {
   m.ctrl.T.Helper()
   ret := m.ctrl.Call(m, "EngineCheck", arg0, arg1)
   ret0, _ := ret[0].(bool)
   return ret0
}
// EngineCheck indicates an expected call of EngineCheck
func (mr *MockCARMockRecorder) EngineCheck(arg0, arg1 interface{}) *gomock.Call {
   mr.mock.ctrl.T.Helper()
   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EngineCheck", reflect.TypeOf((*MockCAR)(nil).EngineCheck), arg0, arg1)
}
```

现在我们有了模拟，让我们开始编写测试用例。我们将使用 *gomock* 包来编写我们的单元测试用例，下面是我们在编写测试用例时将遵循的整个工作流程:

1.  在我们的测试中，首先创建一个 *gomock 的实例。控制器*并将其传递给模拟对象的构造函数以获得模拟对象。
2.  在您的模拟上调用 **Expect()** 来设置它们的期望值和返回值。如果所考虑的函数有对其他函数的外部调用，这是必需的。
3.  调用 main 函数(我们正在为其编写测试用例的函数)来触发代码流通过参数中的模拟接口，而不是真正的接口。
4.  在模拟控制器上调用 **Finish()** ，然后断言模拟的期望。
5.  最后，断言被调用的主函数的预期最终结果。

让我们看看 **Start()** 函数的单元测试用例是什么样子的:

```
func TestCARSTRUCT_Start(t *testing.T) { controller := gomock.NewController(t) defer controller.Finish() MockInterface := Mocks.NewMockCAR(controller) var ctx *gin.Context
   MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(*true*) result := CARSTRUCT{}.Start(ctx,"carkey",MockInterface) assert.Equal(t,*true*,result)
}
```

最初的几个步骤非常简单，我们创建了一个 gomock 控制器，然后用它来创建我们界面的模拟版本。

现在，正如我们所看到的，有一个对函数 *EngineCheck()，*的外部调用，因此有一个对该函数的期望检查。

```
MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(*true*)
```

这种期望检查做的比看起来要多，我们传递的参数值是针对运行时接收的值断言的(在我们的测试用例中，在我们调用 *Start()* 之后，实际上调用了 *EngineCheck()* )。我们还提到了一个返回值，它将在期望调用匹配时返回。

最后，我们调用实际的 *Start()* 函数来触发我们的测试流程，并断言我们的预期返回值。

# 参数比较器

我们可能关心也可能不关心调用模拟时使用的参数值。在这两种情况下，参数比较器可用于断言或忽略模拟方法的特定参数值:

*   *gomock。Any():匹配任何值(任何类型)*
*   *gomock。Eq(x):用于匹配深度等于 x 的值*
*   *gomock。Nil():匹配 nil*
*   *gomock。Not(x):匹配深度不等于 x 的值*

一个参数可以有一个固定的值(通过在预期的调用中指定值，就像我们到目前为止所做的那样),或者可以使用这些比较器进行比较。例如，在对 *EngineCheck()* 进行期望调用时，如果我们想要忽略第二个参数值，将按如下方式进行:

```
MockInterface.EXPECT().EngineCheck(ctx, gomock.Any()).Return(true)
```

# 验证呼叫订单

假设我们在主函数中多次调用外部函数，通常这些调用的顺序也很重要。所以还有一种方法是使用 gomock 的 ***After()*** 方法来断言调用顺序。举个例子，

```
FirstCall := MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(true)callA :=  MockInterface.EXPECT().MethodA(ctx,MockInterface).After(FirstCall)callB := MockInterface.EXPECT().MethodB(ctx,MockInterface).After(callA)
```

在这种情况下，我们断言对 MethodA 的调用是在对 EngineCheck 的调用之后进行的，对 MethodB 的调用是在对 MethodA 的调用之后进行的。

# 使用通道和指定模拟动作

在 go 中使用通道和 goroutines 时，单元测试变得有点棘手。让我们修改我们的 *Start()* 函数，并为我们的汽车界面添加更多的函数，如下所示:

```
type CAR interface {
   Start(*gin.Context, string, CAR) bool
   EngineCheck(*gin.Context, CAR) bool
   SuspensionCheck(*gin.Context, CAR, chan bool)
   BrakesCheck(*gin.Context, CAR, chan bool)
}type CARSTRUCT struct {
}func (car CARSTRUCT) Start(context *gin.Context, key string, carInterface CAR) bool { if carInterface.EngineCheck(context, carInterface) { if key == "carkey" { fmt.Println("Let's start the car!")

         var brakes = make(chan bool)

         var suspension = make(chan bool)

         go carInterface.BrakesCheck(context,carInterface,brakes) go        carInterface.SuspensionCheck(context,carInterface,suspension)

         if <-brakes && <-suspension {
            return *true* } else {
            return *false* }
      } else {
         fmt.Println("You don't have the right key!")
         return *false* }
   } else {
      return *false* }
}func (car CARSTRUCT) EngineCheck(context *gin.Context, carInterface CAR) bool {
   return *true* }func (car CARSTRUCT) SuspensionCheck(context *gin.Context, carInterface CAR, result chan bool) {
   result <- *true* }func (car CARSTRUCT) BrakesCheck(context *gin.Context, carInterface CAR, result chan bool) {
   result <- *true* }
```

现在，我们在 Start()方法中有了对函数 SuspensionCheck()和 BrakesCheck()的两个 goroutine 调用，以及接收这些异步调用输出的布尔通道。我们还必须使用上面提到的 mockgen 命令重新生成我们的模拟。

函数 *SuspensionCheck()* 和*brake check()*在其输出通道中写入真布尔值。因此，当期望调用相同的匹配时，我们需要通过模拟函数来模拟这种行为。通常情况下，这是不可能的，因为被模仿的对象只会在适当的时候提供扫描响应，并记录它们的呼叫。但这可以通过 gomock 的 ***Do()*** 或***DoAndReturn()***方法来完成，这些方法用于指定模拟动作。让我们看看我们的测试用例现在是什么样子:

```
func TestCARSTRUCT_Start(t *testing.T) {

   controller := gomock.NewController(t)

   defer controller.Finish()

   MockInterface := Mocks.NewMockCAR(controller)

   var ctx *gin.Context

   MockInterface.EXPECT().EngineCheck(ctx,MockInterface).Return(*true*)

   MockInterface.EXPECT().BrakesCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){
      arg2.(chan bool) <- *true* })

   MockInterface.EXPECT().SuspensionCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){
      arg2.(chan bool) <- *true* })

   result := testing2.CARSTRUCT{}.Start(ctx,"carkey",MockInterface)

   assert.Equal(t,*true*,result)

}
```

让我们看看对 *BrakesCheck()* 的期望检查:

```
MockInterface.EXPECT().BrakesCheck(ctx,MockInterface,gomock.Any()).DoAndReturn(func(arg0, arg1, arg2 interface{}){
   arg2.(chan bool) <- *true* })
```

我们所做的是，当期望匹配时，即使用所提到的参数值调用了模拟的*brake check()*，那么将执行 DoAndReturn()中的函数( *func()* )。

```
func(arg0, arg1, arg2 interface{}){
   arg2.(chan bool) <- *true* }
```

因此，当对 *BrakesCheck()* 的调用匹配时， *func()* 被执行，布尔值 true 被写入结果通道。这正是需要模仿的行为。

*注意:Do()或 DoAndReturn()中的函数将具有与我们正在模拟的函数的期望方法相同的参数签名，*

```
// BrakesCheck indicates an expected call of BrakesCheck
func (mr *MockCARMockRecorder) BrakesCheck(arg0, arg1, arg2 interface{}) *gomock.Call {
   mr.mock.ctrl.T.Helper()
   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BrakesCheck", reflect.TypeOf((*MockCAR)(nil).BrakesCheck), arg0, arg1, arg2)
}
```

*同样，这些自变量中的每一个(arg0，1，3..)对应于在期望调用匹配后调用模拟函数所用的实际参数。就像在我们的例子中，func()正好有 3 个类型接口的参数 arg0、arg1 和 arg2，这与我们的 BrakesCheck()函数的期望方法相同，arg0 对应于上下文(*gin。上下文)，arg1 是 MockInterface，arg2 对应于结果 bool 通道。*

*这就是为什么当期望调用匹配时，我们知道结果通道在第三个参数位置或 arg2 被传递，所以我们简单地将 arg2 类型转换为 bool 通道，并在其中写入值 true，以通过它的 mock 模拟 BrakesCheck()的实际行为，*

```
arg2.(chan bool) <- *true*
```