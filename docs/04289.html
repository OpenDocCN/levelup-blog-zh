<html>
<head>
<title>Don’t Fall Into the NaN Trap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要落入南的陷阱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dont-fall-into-the-nan-trap-d2fbc5536e50?source=collection_archive---------13-----------------------#2020-06-18">https://levelup.gitconnected.com/dont-fall-into-the-nan-trap-d2fbc5536e50?source=collection_archive---------13-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c19d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">那天我的单元测试验证了一千个错误的计算</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d677e97b328ce06d14828fc1230eb769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cvmHahjMXBQnJ-pU"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@crismiron?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Miron Cristina </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="4c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我很尴尬。我以为我做的一切都是对的。我写了一些代码来执行一些复杂的浮点计算。像一个优秀的开发人员应该做的那样，我编写了单元测试，将结果与期望值进行比较。一切都很顺利。</p><p id="622f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至少我是这么认为的。几天后，我开始将据称有效的JavaScript代码移植到Python。Python版本在尝试访问不存在的属性时崩溃。</p><p id="c48e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我被难倒了，因为我在从JavaScript到Python的翻译中找不到任何错误。两种算法做的是完全相同的事情。当Python中存在如此明显的问题时，我精心制作的单元测试怎么能说JavaScript一切正常呢？</p><p id="7340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">凭直觉，我使用调试器来调试JavaScript代码，并观察它是如何工作的。这时候我的下巴掉了下来。</p><h2 id="9edf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">JavaScript中的NaN陷阱</h2><p id="930a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我将用更简单的代码来说明发生了什么。这是为一个名为<code class="fe mt mu mv mw b">Polar</code>的函数设计的单元测试。第5行的<code class="fe mt mu mv mw b">if</code>语句应该验证将向量(3，4)转换为极坐标会产生非常接近5的距离。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="90c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过从计算的距离中减去期望的距离，我们得到一个叫做<code class="fe mt mu mv mw b">diff</code>的误差值，它的绝对值永远不应该超过万亿分之一(<code class="fe mt mu mv mw b">1.0e-12</code>)。当我运行测试时，它通过了:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="9820" class="lv lw it mw b gy nd ne l nf ng">$ <strong class="mw iu">node oops.js</strong> <br/>PASS</span></pre><p id="73de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有什么大不了的？一切似乎都很好，对吗？如果我告诉你这整个测试是假的，因为财产名称<code class="fe mt mu mv mw b">distance</code>是错误的。看看<code class="fe mt mu mv mw b">Polar</code>功能实际上是做什么的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="328c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数返回的对象甚至不包含一个<code class="fe mt mu mv mw b">distance</code>属性！单元测试应该检查<code class="fe mt mu mv mw b">radius</code>属性。<code class="fe mt mu mv mw b">Polar</code>函数计算并存储在<code class="fe mt mu mv mw b">radius</code>中的是什么荒谬的值并不重要，因为单元测试从不看那个值。</p><p id="0be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么为什么这个拙劣的测试认为答案是正确的呢？让我们进入Node.js命令行，看看发生了什么。</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="646d" class="lv lw it mw b gy nd ne l nf ng">$ <strong class="mw iu">node</strong><br/>&gt; <strong class="mw iu">const polar = {};</strong><br/>undefined<br/>&gt; <strong class="mw iu">const diff = polar.distance - 5.0;</strong><br/>undefined<br/>&gt; <strong class="mw iu">diff</strong><br/>NaN</span></pre><p id="80b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行是关键。在JavaScript中，从<code class="fe mt mu mv mw b">undefined</code>中减去一个数字会得到<code class="fe mt mu mv mw b">NaN</code>，这个值意味着“不是一个数字”。</p><p id="a684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">NaN</code>有些怪癖:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="31f5" class="lv lw it mw b gy nd ne l nf ng">&gt; <strong class="mw iu">diff &gt; 3.0</strong><br/>false<br/>&gt; <strong class="mw iu">diff &lt; 3.0</strong><br/>false<br/>&gt; <strong class="mw iu">diff === 3.0</strong><br/>false</span></pre><p id="51c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面看到的，如果你问<code class="fe mt mu mv mw b">NaN</code>是大于、小于还是等于某个数值，答案总是否定的(<code class="fe mt mu mv mw b">false</code>)。</p><p id="1e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当我询问<code class="fe mt mu mv mw b">diff</code>的值是否过大时，单元测试没有进入<code class="fe mt mu mv mw b">if</code>语句，单元测试“通过”</p><h2 id="bd3d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">不仅仅是JavaScript的问题</h2><p id="01a6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我知道你们有些人在想什么。<em class="nh">哈哈，这就是你使用没有静态类型分析的语言的结果。你说得有道理。这个特别的问题，轻率地访问一个不存在的属性，不会发生在具有编译时类型检查的语言中。在C或Java中，编译器会注意到这个未定义的符号，并且会失败并显示一条错误消息。</em></p><p id="9c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但也不要太自鸣得意。<code class="fe mt mu mv mw b">NaN</code>能用严格类型的语言咬你一口。考虑下面的C代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我编译并运行这个C程序时发生的情况。</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="f128" class="lv lw it mw b gy nd ne l nf ng">$ <strong class="mw iu">gcc -lm -o bogus bogus.c</strong><br/>$ <strong class="mw iu">./bogus</strong><br/>diff = nan<br/>PASS</span></pre><p id="7e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦不，我们的带有静态类型检查的编译语言并没有给我们太多帮助，不是吗？我们有另一个单元测试，它在应该失败的时候通过了。</p><h2 id="6c29" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">南的成因</h2><p id="b619" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在上面的C程序中，<code class="fe mt mu mv mw b">NaN</code>是试图求一个负数的平方根的结果。以下是计算产生<code class="fe mt mu mv mw b">NaN</code>的一些其他方式:</p><ul class=""><li id="c1c5" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">将0除以0。</li><li id="d006" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">0的0次方。比如在C: <code class="fe mt mu mv mw b">pow(0, 0)</code>中。</li><li id="60e9" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">将范围[-1，+1]之外的值传递给反三角函数，如<code class="fe mt mu mv mw b">acos</code>。这被称为<em class="nh">域错误</em>。</li><li id="1165" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">任何包含<code class="fe mt mu mv mw b">NaN</code>的计算都会产生<code class="fe mt mu mv mw b">NaN</code>。比如<code class="fe mt mu mv mw b">x</code>是<code class="fe mt mu mv mw b">NaN</code>，那么<code class="fe mt mu mv mw b">sqrt(x*x + 1)</code>也会是<code class="fe mt mu mv mw b">NaN</code>。</li></ul><h2 id="a7b9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">避开陷阱</h2><p id="d593" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">既然我们已经意识到了<code class="fe mt mu mv mw b">NaN</code>的问题，那么我们如何防范与之相关的bug呢？</p><p id="2861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，人们可能想用一个简单的比较来检查一个数值是否是<code class="fe mt mu mv mw b">NaN</code>。例如，回到JavaScript，我们可以问一个变量是否等于<code class="fe mt mu mv mw b">NaN</code>。大概是这样的:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="62b8" class="lv lw it mw b gy nd ne l nf ng">&gt; <strong class="mw iu">let x = 0/0;</strong><br/>undefined<br/>&gt; <strong class="mw iu">x</strong><br/>NaN<br/>&gt; <strong class="mw iu">x === NaN</strong><br/>false</span></pre><p id="2a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哎呀。那没用。这是因为无论何时你问<code class="fe mt mu mv mw b">NaN</code>是否等于任何东西，甚至是另一个<code class="fe mt mu mv mw b">NaN</code>，答案都是否定的。一些程序员通过将一个变量与<em class="nh">本身</em>进行比较，利用这种行为来检测<code class="fe mt mu mv mw b">NaN</code>:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="643a" class="lv lw it mw b gy nd ne l nf ng">&gt; <strong class="mw iu">x === x</strong><br/>false<br/>&gt; <strong class="mw iu">x !== x</strong><br/>true<br/>&gt; <strong class="mw iu">if (x !== x) console.log('Not a number!')</strong><br/>Not a number!</span></pre><p id="6ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来很奇怪，但很有效。问一个变量是否不等于它本身，如果答案是肯定的，那它就不是一个数。</p><p id="6a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有更好的方法。如果你关心这个可怜的懒汉，他以后必须维护代码，你可以写一些不那么神秘和怪异的东西。大多数支持浮点计算的编程语言都提供了检查<code class="fe mt mu mv mw b">NaN</code>值的函数。例如，在JavaScript中，您可以像这样使用函数<code class="fe mt mu mv mw b">isNaN</code>:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="fb08" class="lv lw it mw b gy nd ne l nf ng">&gt; <strong class="mw iu">isNaN(Math.sqrt(-1))</strong><br/>true</span></pre><p id="6ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一张关于如何在一些流行的编程语言中检查某个值<code class="fe mt mu mv mw b">x</code>是否为<code class="fe mt mu mv mw b">NaN</code>的备忘单:</p><ul class=""><li id="f413" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">JavaScript: <code class="fe mt mu mv mw b">isNaN(x)</code></li><li id="0e82" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">C: <code class="fe mt mu mv mw b">isnan(x)</code>(必须<code class="fe mt mu mv mw b">#include &lt;math.h&gt;</code>)</li><li id="93f4" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">C#: <code class="fe mt mu mv mw b">double.IsNaN(x)</code></li><li id="b277" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">Python: <code class="fe mt mu mv mw b">math.isnan(x)</code></li></ul><p id="38ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一句，在Python中很难意外地创建一个<code class="fe mt mu mv mw b">NaN</code>值，因为它往往会引发异常:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="95f9" class="lv lw it mw b gy nd ne l nf ng">&gt;&gt;&gt; <strong class="mw iu">0.0 / 0.0</strong><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>ZeroDivisionError: float division by zero<br/>&gt;&gt;&gt; <strong class="mw iu">import math</strong><br/>&gt;&gt;&gt; <strong class="mw iu">math.sqrt(-3.0)</strong><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>ValueError: math domain error</span></pre><p id="83e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Python在其标准数学包中包含了一个显式的<code class="fe mt mu mv mw b">NaN</code>值:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="eb07" class="lv lw it mw b gy nd ne l nf ng">&gt;&gt;&gt; <strong class="mw iu">math.nan == math.nan</strong><br/>False<br/>&gt;&gt;&gt; <strong class="mw iu">math.sqrt(math.nan + 7)</strong><br/>nan</span></pre><h2 id="71f9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我如何改变我的单元测试</h2><p id="75a2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">被虚假的单元测试愚弄的经历真的让我思考。在我的<a class="ae ky" href="https://github.com/cosinekitty/astronomy" rel="noopener ugc nofollow" target="_blank">天文引擎</a>开源项目中，我有许多单元测试将误差与阈值进行比较。我在所有四种受支持的编程语言中都这样做:C、C#、Python和JavaScript。每一次阈值检查都让我面临出现<code class="fe mt mu mv mw b">NaN</code>问题的风险。</p><p id="3e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不想再次被烧伤。我从JavaScript版本中的一个简单函数<code class="fe mt mu mv mw b">v</code>开始。如果它的参数是<code class="fe mt mu mv mw b">NaN</code>，或者甚至不是一个数字，它抛出一个异常。该异常会立即导致单元测试失败。否则，它将返回值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我进行风险阈值检查的几乎每一个案例中，我都使用<code class="fe mt mu mv mw b">Math.abs</code>来获取计算值和期望值之间的差值的绝对值。我围绕<code class="fe mt mu mv mw b">Math.abs</code>写了一个包装函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d0c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我改变了我所有的阈值测试，用<code class="fe mt mu mv mw b">abs</code>代替<code class="fe mt mu mv mw b">Math.abs</code>。我为其他数学函数编写了类似的包装器，以验证参数和/或返回值永远不会是<code class="fe mt mu mv mw b">NaN</code>。</p><h2 id="2eb8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">正负不定式</h2><p id="b106" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">另外值得一提的是，浮点计算会产生两种不同的无穷大值:<code class="fe mt mu mv mw b">+Infinity</code>和<code class="fe mt mu mv mw b">-Infinity</code>。这些特殊的无限值表现得比<code class="fe mt mu mv mw b">NaN</code>更直观。例如，在Node.js解释器中:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="914a" class="lv lw it mw b gy nd ne l nf ng">&gt; <strong class="mw iu">let z = -1 / 0;</strong><br/>undefined<br/>&gt; <strong class="mw iu">z</strong><br/>-Infinity<br/>&gt; <strong class="mw iu">z &lt; 0</strong><br/>true<br/>&gt; <strong class="mw iu">z &gt; 0</strong><br/>false<br/>&gt; <strong class="mw iu">Math.abs(z)</strong><br/>Infinity<br/>&gt; <strong class="mw iu">Math.abs(z - 5) &gt; 1.0e-12</strong><br/>true</span></pre><p id="c389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上一个表达式中可以看出，无限的结果肯定会导致我的单元测试失败。因此，我没有必要像处理<code class="fe mt mu mv mw b">NaN</code>一样，将<code class="fe mt mu mv mw b">Infinity</code>作为特例处理。但是，您至少应该考虑一下，如果浮点代码中的某个值变成无穷大，会发生什么。</p><h2 id="6741" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">最后的想法</h2><p id="868d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">除了将<code class="fe mt mu mv mw b">NaN</code>作为一个特定的问题来处理之外，这个经历告诉我，我需要更加怀疑我的单元测试。使用调试器并在第一次逐步通过单元测试并观察发生了什么是一个好主意。</p><p id="6a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要有耐心和好奇心。看变量的值。确保一切都有意义。不要等一个bug出现；第一次运行新代码时使用调试器。</p><p id="8c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来需要额外的时间，但是不管你的代码是否正确，避免虚假的单元测试是值得的！</p><h2 id="6819" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">资源</h2><ol class=""><li id="0a58" class="ni nj it lb b lc mo lf mp li nw lm nx lq ny lu nz no np nq bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/NaN" rel="noopener ugc nofollow" target="_blank">南在维基百科上的文章</a></li><li id="0459" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nz no np nq bi translated">维基百科上的IEEE 754文章:关于浮点数在大多数现代计算机上表示方式的更多细节。</li><li id="c296" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nz no np nq bi translated"><a class="ae ky" href="https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf" rel="noopener ugc nofollow" target="_blank">每个计算机科学家都应该知道的浮点知识</a>:这是一篇优秀的文章，涵盖了高级浮点计算的细微差别。</li></ol></div></div>    
</body>
</html>