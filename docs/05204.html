<html>
<head>
<title>Understanding Callable in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python中的Callable</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-callable-in-python-3dd6e4fd38e?source=collection_archive---------6-----------------------#2020-08-11">https://levelup.gitconnected.com/understanding-callable-in-python-3dd6e4fd38e?source=collection_archive---------6-----------------------#2020-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a12dbaecce803ad2a989a4bec32d0552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iq0tcJLSF3SbNAUtR4ikrw.jpeg"/></div></div></figure><p id="8e09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数和类是我们日常开发中最常用的东西。我们召唤它们，传递它们，却从未想过是什么让它们如此神奇。简短的回答是<strong class="kd iu">可调用协议；</strong>长答案继续看！</p><h2 id="ec67" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">定义📢</h2><p id="74ca" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">定义<code class="fe lx ly lz ma b">__call__</code>方法的对象被称为可调用的。或者基本上callable是任何你可以用括号<code class="fe lx ly lz ma b">()</code>调用并传递参数给它的东西。是的，我基本上是在说一个函数。</p><h2 id="d605" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated"><strong class="ak">__调用_ _方法🤙</strong></h2><p id="4920" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated"><code class="fe lx ly lz ma b">__call__</code>是Python中最有趣的dunder方法之一。这是大多数内置函数所利用的。如果我们窥视这些内置函数的<code class="fe lx ly lz ma b">type</code>，那么我们经常会看到结果是一个<code class="fe lx ly lz ma b">class</code>。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="3117" class="kz la it ma b gy mj mk l ml mm">&gt;&gt;&gt; range<br/>&lt;class 'range'&gt;</span><span id="a59e" class="kz la it ma b gy mn mk l ml mm">&gt;&gt;&gt; zip <br/>&lt;class 'zip'&gt;</span><span id="3f91" class="kz la it ma b gy mn mk l ml mm">&gt;&gt;&gt; int<br/>&lt;class 'int'&gt;</span></pre><p id="7b3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你知道要点了。但是一个类是如何作为一个函数的呢？我的意思是你可以直接<code class="fe lx ly lz ma b">zip(iterable1, iterable2)</code>得到你的结果，而不需要进一步调用这个类的任何其他方法。</p><p id="3ba4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想象一下使用 <code class="fe lx ly lz ma b"><strong class="kd iu">zip</strong></code> <strong class="kd iu">就像是一个普通的类。</strong></p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="38e6" class="kz la it ma b gy mj mk l ml mm">processor = ['Intel', 'Ryzen', 'Apple Silicon']<br/>year = [2018, 2019, 2020]</span><span id="87c7" class="kz la it ma b gy mn mk l ml mm">zipped = zip(processor, year)<br/>zipped.start()</span></pre><p id="ef26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这绝对不是直观的工作。那么它是如何工作的呢？</p><h2 id="337f" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">使用__call__方法🔨</h2><p id="c97e" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">在幕后，这是因为<code class="fe lx ly lz ma b">__call__</code>方法。如果我们希望类的<strong class="kd iu">实例是可调用的，那么在类中使用这个方法。</strong></p><p id="e425" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我这么说是什么意思？让我们以一个打印数字平方的类为例。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="11ad" class="kz la it ma b gy mj mk l ml mm">class Square:<br/>    <br/>    def __call__(self, num):<br/>            print(num * num)</span><span id="7fd0" class="kz la it ma b gy mn mk l ml mm">&gt;&gt;&gt; sq = Square() # create an instance <br/>&gt;&gt;&gt; sq(5) # invoke<br/>25</span></pre><p id="a53d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这类似于执行:</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="578f" class="kz la it ma b gy mj mk l ml mm">&gt;&gt;&gt; sq = Square()<br/>&gt;&gt;&gt; sq.__call__(5)<br/>25</span></pre><p id="3a88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是有了邓德方法，我们就不必这么做了。我们可以像普通函数一样直接调用实例。</p><blockquote class="mo mp mq"><p id="fad9" class="kb kc mr kd b ke kf kg kh ki kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx ky im bi translated">您可能已经注意到，我们不需要使用<code class="fe lx ly lz ma b">__init__</code>构造函数来传递值。因为类实例的行为类似于函数，所以它可以像函数一样接受参数，而不需要构造函数。</p></blockquote><h2 id="b349" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">测试可调用👨‍🔬</h2><p id="75cc" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">默认情况下，类或函数是可调用的；但是实例只能用<code class="fe lx ly lz ma b">__call__</code> dunder方法调用。我们可以通过使用<code class="fe lx ly lz ma b">callable()</code>功能对此进行检查。</p><p id="3e79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以一个没有<code class="fe lx ly lz ma b">__call__</code>方法的类为例。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="20f5" class="kz la it ma b gy mj mk l ml mm">class Random:<br/>    pass</span><span id="1772" class="kz la it ma b gy mn mk l ml mm">&gt;&gt;&gt; callable(Random)<br/>True</span><span id="9a2a" class="kz la it ma b gy mn mk l ml mm">&gt;&gt;&gt; r = Random()<br/>&gt;&gt;&gt; callable(r)<br/>False</span></pre><p id="70c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">相反，让我们看看前面例子中的<code class="fe lx ly lz ma b">Square</code>类。</p><pre class="mb mc md me gt mf ma mg mh aw mi bi"><span id="17c3" class="kz la it ma b gy mj mk l ml mm">&gt;&gt;&gt; callable(Square)<br/>True</span><span id="71cb" class="kz la it ma b gy mn mk l ml mm">&gt;&gt;&gt; callable(sq)<br/>True</span></pre><h2 id="cba9" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">结论🚀</h2><p id="8952" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">下次当你为某个东西创建一个类的时候，它需要立即返回一个值；您可以使用<code class="fe lx ly lz ma b">__call__</code>方法。</p><p id="80ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇博客有助于理解函数和类所包含的基本概念。如果你有任何疑问或建议，让我们在评论区讨论。</p></div></div>    
</body>
</html>