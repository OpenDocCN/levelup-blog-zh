<html>
<head>
<title>Introduction to TypeScript Functions: Anonymous Functions and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript函数简介:匿名函数等等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-typescript-functions-anonymous-functions-and-more-7b7e93922f0d?source=collection_archive---------3-----------------------#2020-01-03">https://levelup.gitconnected.com/introduction-to-typescript-functions-anonymous-functions-and-more-7b7e93922f0d?source=collection_archive---------3-----------------------#2020-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/948f0d8c70a8c639c43579f5ba6aad75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gJKnZbNseOj4ZiyJ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Benoit Gauzere 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="aa2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数是一些小的代码块，接受一些输入，可能返回一些输出或者有副作用。副作用意味着它修改了函数之外的一些变量。</p><p id="ce5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要函数将代码组织成可重用的小块。</p><p id="554f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有函数，如果我们想重新运行一段代码，我们必须在不同的地方复制它。函数对于任何类型脚本程序都是至关重要的。</p><p id="79cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们继续研究TypeScript函数的不同部分，包括传入可变数量的参数、递归、函数嵌套以及在对象中定义函数。</p><h1 id="c8b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">调用参数多于参数的函数</h1><p id="56ac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在TypeScript中，我们可以调用实参多于形参的函数。如果我们只是传递它们，而不从<code class="fe mh mi mj mk b">argument</code>对象访问它们，它们将被忽略。您可以用<code class="fe mh mi mj mk b">argument</code>对象获得并使用参数中没有的额外参数。argument对象有带数字键的参数，就像数组的索引一样。访问额外参数的另一种方式是通过rest参数。</p><p id="1b54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们调用带有额外参数的<code class="fe mh mi mj mk b">add</code>函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="dcb4" class="mt lf it mk b gy mu mv l mw mx">function add(a: number, b: number, ...rest: any){<br/>  console.log(arguments);<br/>  return a + b;<br/>}<br/>add(1, 2, 3);</span></pre><p id="ad8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">签名的<code class="fe mh mi mj mk b">...rest</code>部分捕获了我们不希望传入的参数。我们使用rest运算符，它由单词<code class="fe mh mi mj mk b">rest</code>前的3个句点表示，表示在<code class="fe mh mi mj mk b">b</code>后的末尾可能会有更多的参数。我们在TypeScript中需要这样做，这样我们就不会得到传入的参数数量和实参数量之间的不匹配。在普通的JavaScript中，<code class="fe mh mi mj mk b">...rest</code>是可选的。</p><p id="0242" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">console.log</code>调用中，我们应该得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="aa4f" class="mt lf it mk b gy mu mv l mw mx">0: 1<br/>1: 2<br/>2: 3</span></pre><h1 id="6aee" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数中的可变范围</h1><p id="4c76" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">除非是全局变量，否则函数内部的函数不应该在函数外部被访问。我们应该尽可能避免定义全局变量，以防止错误和难以追踪的错误，因为它们可以在程序的任何地方被访问。为了防止定义全局变量，我们应该用<code class="fe mh mi mj mk b">let</code>定义变量，用<code class="fe mh mi mj mk b">const</code>定义常量。例如，我们应该这样定义函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c1d0" class="mt lf it mk b gy mu mv l mw mx">function add(a: number, b: number){<br/>  let sum = a + b;<br/>  return sum;<br/>}</span></pre><p id="6a7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们有<code class="fe mh mi mj mk b">sum</code>，它只能在函数中访问，因为它是用<code class="fe mh mi mj mk b">let</code>关键字定义的。</p><h1 id="3084" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">匿名函数</h1><p id="1d5d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">匿名是没有名字的函数。因为它们没有名字，所以在任何地方都不能被引用。它们通常作为回调函数传递给其他函数，当函数被传递给参数时会调用回调函数。但是，您可以将匿名函数赋给一个变量，这样它就成为一个命名函数。</p><p id="b7bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们也可以自动执行。这意味着你可以定义函数并让它立即运行。例如，如果我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e767" class="mt lf it mk b gy mu mv l mw mx">const sum = (function(a: number, b: number){<br/>  return a + b;<br/>})(1, 2);console.log(sum) // log 3</span></pre><p id="e05e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们之所以记录3，是因为我们定义了一个函数来将2个数字相加，然后将1和2作为参数直接传入，方法是将函数放在括号中，然后将参数传递给它。</p><h1 id="1ddd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">递归</h1><p id="a031" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以在TypeScript中从函数内部调用同一个函数。这叫做递归。所有的递归函数都必须有一个终止条件，这个终止条件被称为基例，这样它就知道什么时候停止执行。否则，你会得到一个被无限次调用的函数，这会使浏览器崩溃。</p><p id="1192" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要编写递归函数，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2ec3" class="mt lf it mk b gy mu mv l mw mx">function sumOfSquares(num: number): number {<br/>  let sum: number = Math.pow(num, 2);<br/>  if (num == 1) {<br/>    return 1<br/>  } else {<br/>    return sum + sumOfSquares(num - 1)<br/>  }  <br/>}</span></pre><p id="b25f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们编写了一个函数来计算给定数字的平方和。我们计算<code class="fe mh mi mj mk b">num</code>的平方，然后如果<code class="fe mh mi mj mk b">num</code>等于1，那么我们返回1。否则，我们返回<code class="fe mh mi mj mk b">sum</code>加上在<code class="fe mh mi mj mk b">num — 1</code>上调用<code class="fe mh mi mj mk b">sumOfSquares</code>的结果之和。我们不断减少<code class="fe mh mi mj mk b">num</code>，这样我们就可以达到我们的基本情况1，在这样做的同时将结果相加。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/bdf42b82027db4d661693379ca836f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BDvNRuZ4emOKXSwE"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@roi_dimor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Roi Dimor </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="6526" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">嵌套函数</h1><p id="9464" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数可以相互嵌套。这意味着我们可以在一个函数中定义另一个函数。例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f11c" class="mt lf it mk b gy mu mv l mw mx">function convertToChicken(name: string){<br/>  function getChickenName(name: string){<br/>    return `Chicken ${name}`;<br/>  }<br/>  return getChickenName(name)<br/>}</span></pre><p id="ca01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们在<code class="fe mh mi mj mk b">convertToChicken</code>调用中调用了<code class="fe mh mi mj mk b">getChickeName</code>。所以如果我们写<code class="fe mh mi mj mk b">convertToChicken('chicken')</code>，那么我们得到<code class="fe mh mi mj mk b">'Chicken chicken'</code>，因为我们调用了get <code class="fe mh mi mj mk b">getChickeName</code>并返回了结果。变量的作用域就是名字。<code class="fe mh mi mj mk b">let</code>和<code class="fe mh mi mj mk b">const</code>是块范围的，所以它们不能在定义的原始函数之外被访问，但是它们在嵌套函数中是可用的，所以如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e81d" class="mt lf it mk b gy mu mv l mw mx">function convertToChicken(name: string) {<br/>  let originalName = name;  function getChickenName(newName: string) {<br/>    console.log(originalName)<br/>    return `Chicken ${newName}`;<br/>  }<br/>  return getChickenName(name)<br/>}</span></pre><p id="5712" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">originalName</code>仍将在<code class="fe mh mi mj mk b">console.log</code>中定义。</p><h1 id="323b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在对象中定义函数</h1><p id="bb9f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用几种方法在对象中定义一个函数。我们可以像往常一样使用<code class="fe mh mi mj mk b">function</code>关键字或arrow函数，但是我们也可以用<code class="fe mh mi mj mk b">function</code>关键字的简写来写。例如，如果我们有一个<code class="fe mh mi mj mk b">bird</code>对象，我们想定义<code class="fe mh mi mj mk b">chirp</code>函数，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="89ff" class="mt lf it mk b gy mu mv l mw mx">const bird = {<br/> chirp: function(){<br/>   console.log('chirp', this)<br/>  }<br/>}</span></pre><p id="fc49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者使用下面的简写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5a2c" class="mt lf it mk b gy mu mv l mw mx">const bird = {<br/> chirp(){<br/>   console.log('chirp', this)<br/>  }<br/>}</span></pre><p id="7cc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个是相同的，因为<code class="fe mh mi mj mk b">chirp</code>函数将把<code class="fe mh mi mj mk b">bird</code>对象作为<code class="fe mh mi mj mk b">this</code>的值。</p><p id="6307" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果使用箭头函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="229a" class="mt lf it mk b gy mu mv l mw mx">const bird = {<br/> chirp: () =&gt; {<br/>   console.log('chirp', this)<br/>  }<br/>}</span></pre><p id="c355" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将从TypeScript编译器得到一个错误，因为<code class="fe mh mi mj mk b">this</code>的值是<code class="fe mh mi mj mk b">globalThis</code>的值，这是Typescript编译器不允许的。我们得到错误“包含的箭头函数捕获了‘this’的全局值。(7041)“当我们试图编译上面的代码时。</p><p id="bbc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript函数允许我们将代码组织成可以重用的小部分。有很多方法来定义一个函数，但是坚持通常推荐的方法，比如使用箭头函数，不要过多地使用<code class="fe mh mi mj mk b">arguments</code>。</p></div></div>    
</body>
</html>