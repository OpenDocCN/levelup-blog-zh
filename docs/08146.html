<html>
<head>
<title>Javascript generators with a concrete example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有具体示例的Javascript生成器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-generators-with-a-concrete-example-d91324706090?source=collection_archive---------7-----------------------#2021-04-05">https://levelup.gitconnected.com/javascript-generators-with-a-concrete-example-d91324706090?source=collection_archive---------7-----------------------#2021-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们通过一个简化的真实例子来深入了解发电机是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ea2e56fa1e62720863374ef4af74f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UROfn26fkxqT6Bk_jGOw1w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/boy-in-white-t-shirt-sitting-on-chair-in-front-of-computer-4709285/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> cottonbro </a>拍摄</figcaption></figure><p id="1d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">从我的经验来看，<strong class="lb iu">生成器</strong>并不是<strong class="lb iu"> Javascript </strong>中最常用的工具。它们看起来很复杂，吓到了一些开发人员。但是它们实际上对你的代码是一个巨大的改进！</p><p id="0078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你真的了解发电机，那要么是因为你在用<strong class="lb iu"> Redux Saga </strong>使用它们，要么是因为你的公司做出了使用它们的(伟大)选择，要么是因为你很好奇！对我来说，这是第三种选择。</p><h1 id="ac6d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">但是什么是真正的发电机呢</h1><p id="9478" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">与普通函数相比，生成器是一个声明稍有不同的函数。发电机的原型如下:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="803d" class="ng mf it nc b gy nh ni l nj nk">function* myGenerator(){}</span></pre><p id="6c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这颗小星星让一切变得不同。那还有一个特定的关键词:<strong class="lb iu"> yield。</strong></p><p id="0ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Yield在您的生成器中被用作一个<strong class="lb iu">断点</strong>，并允许您将值返回到生成器执行的位置。这样做的最大好处是，你可以在函数的工作完成之前从函数<strong class="lb iu">中获取数据，并且你可以通过在你想要的任何地方添加一个yield来轻松完成。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/292a1a531be04716b71a8d635091d296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X46BNlLJojYJcnC12T_GJw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">发电机如何工作的完整示例</figcaption></figure><p id="0a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在这里分析这个例子。首先，我选择使用<strong class="lb iu"> PascalCase </strong>作为生成器的名称。原因是调用这个函数实际上是要<strong class="lb iu">实例化</strong>它而不是执行它。</p><blockquote class="nm nn no"><p id="4998" class="kz la np lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">如果您将console.log放在生成器的第一行，那么在调用<code class="fe nt nu nv nc b">gen.next()</code>之前不会打印。</p></blockquote><p id="dc19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在实例化您的生成器之后。要开始运行它，您将在实例中调用方法<code class="fe nt nu nv nc b">next</code>。Next将执行您的生成器<strong class="lb iu">，直到它找到另一个yield，或者直到函数返回</strong>。Yield的工作方式与return完全相同，但它是一个过早的return。在我们的例子中，我们生成两个值。中间(来自于收益)和最终(来自于回报)。每次返回值的时候，对象的格式都会是<code class="fe nt nu nv nc b">{ value: any, done: boolean }</code></p><ul class=""><li id="eb93" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated"><strong class="lb iu">值</strong>:yield/return返回的值。它可以是你选择的任何东西。</li><li id="2d12" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><strong class="lb iu"> done </strong>:一个布尔值，如果yield 返回该值，则为<strong class="lb iu"> false，如果return关键字</strong>返回该值，则为<strong class="lb iu"> true。它显示发电机是否完成了它的工作。</strong></li></ul><h1 id="dc89" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">一个具体的例子:从两个不同的API加载数据</h1><h2 id="7aa9" class="ng mf it bd mg ok ol dn mk om on dp mo li oo op mq lm oq or ms lq os ot mu ou bi translated">语境</h2><p id="ddf5" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我们的应用程序显示了联系人列表。每个联系人由一个<strong class="lb iu">名</strong>、一个<strong class="lb iu">姓</strong>、一个<strong class="lb iu">用户Id </strong>以及一个<strong class="lb iu">电子邮件</strong>和一个<strong class="lb iu">电话号码</strong>组成。</p><p id="bf96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们的后端使用微服务架构(假设)，所以我们决定使用两个不同的数据库，一个存储用户基本信息(名、姓、密码、登录)，另一个存储<strong class="lb iu">附加信息</strong>，如电话号码或电子邮件地址。</p><p id="c6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这一决定，对第二个数据库的访问比第一个慢，因为每个信息需要逐个用户地挑选。</p><p id="a900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了使我们的前端更流畅，我们希望尽快显示名字和姓氏的列表，并第二次加载其余部分。然而，我们希望在同一个函数上实现所有这些，因为我们将使用用户id来获取额外的信息。</p><blockquote class="nm nn no"><p id="422d" class="kz la np lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">请记住，这种背景纯粹是为了文章。后端可以以更好的方式实现，前端不必自己从两个不同的服务获取数据。</p></blockquote><h2 id="a2fe" class="ng mf it bd mg ok ol dn mk om on dp mo li oo op mq lm oq or ms lq os ot mu ou bi translated">设置</h2><p id="ae49" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">为了尽可能地说明这一点，我们将使用React和ES6 Javascript创建一个小型web应用程序。通过运行以下命令创建一个新的应用程序(如果需要的话):</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3a96" class="ng mf it nc b gy nh ni l nj nk">npx create-react-app myApp</span></pre><p id="203d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个提示可能会问你是否想安装create-react-app，只需键入Y并回车即可。一旦完成，跳转到您的React项目并使用<code class="fe nt nu nv nc b">npm start</code>启动它</p><p id="814d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的应用程序现在运行在<strong class="lb iu"> localhost:3000 </strong>上！现在我们开始编码吧！</p><h2 id="34bb" class="ng mf it bd mg ok ol dn mk om on dp mo li oo op mq lm oq or ms lq os ot mu ou bi translated">创建两个假端点</h2><p id="db98" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">对于我们的示例，我们将创建两个假端点来模拟对API的调用。这两个函数将返回一个承诺，第二个函数将比另一个函数花费更多的时间来执行(在我们需要更多数据之前)</p><p id="abab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe nt nu nv nc b">src</code>文件夹中创建一个名为<code class="fe nt nu nv nc b">API.js</code>的文件，并在其中添加两个端点。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="cae1" class="ng mf it nc b gy nh ni l nj nk">// API.js<br/>export function getUsers() {<br/>  return new <strong class="nc iu"><em class="np">Promise</em></strong>(resolve =&gt; {<br/>    resolve([<br/>      {userId: 1, firstName: "John", lastName: "Doe"},<br/>      {userId: 2, firstName: "Jane", lastName: "Foster"}<br/>    ])<br/>  })<br/>}<br/><br/>// This function is taking more time to resolve as the backend is doing some complex queries<br/>export function getUsersAdditionalDetails(ids) {<br/>  return new <strong class="nc iu"><em class="np">Promise</em></strong>(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve([<br/>        {userId: 1, phoneNumber: "06456785343", emailAddress: "john.doe@gmail.com"},<br/>        {userId: 2, phoneNumber: "04576549698", emailAddress: "jane.foster@gmail.com"}<br/>      ])<br/>    }, 3000)<br/>  })<br/>}</span></pre><p id="1855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个函数将只获取用户的基本信息，这是一个快速执行的函数，并立即返回。</p><p id="e2cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个在后端执行一些“复杂”的查询，需要3秒钟来执行。它将id作为参数，因为后端需要处理一个id列表</p><h2 id="d1bc" class="ng mf it bd mg ok ol dn mk om on dp mo li oo op mq lm oq or ms lq os ot mu ou bi translated">使用经典函数显示数据</h2><p id="f500" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在您的<code class="fe nt nu nv nc b">App.js</code>文件中，我们将创建一个名为<code class="fe nt nu nv nc b"><strong class="lb iu">getFullUsersInfo</strong></code>的新函数，该函数将调用两个端点并将数据合并在一起。我们还将创建一个新组件来显示每个用户，并删除由create-react-app cli创建的样板内容。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ba93" class="ng mf it nc b gy nh ni l nj nk">import {getUsersAdditionalDetails, getUsers} from "./API";<br/>import {useEffect, useState} from "react";<br/><br/>async function getFullUsersInfo() {<br/>  const basicUsers = await getUsers();<br/>  const ids = basicUsers.map(basicUser =&gt; basicUser.userId);<br/>  const advancedUsers = await getUsersAdditionalDetails(ids);<br/>  return advancedUsers.map(advancedUser =&gt; ({...advancedUser, ...basicUsers.find((basicUser) =&gt; basicUser.userId === advancedUser.userId)}))<br/>}<br/><br/>const User = ({firstName, lastName, phoneNumber, emailAddress}) =&gt; {<br/>  return &lt;div style={{display: "flex", flexDirection: "column", marginTop: "20px"}}&gt;<br/>    &lt;div style={{display: "flex", flexDirection: "row"}}&gt;<br/>      {`${firstName} ${lastName}`}<br/>    &lt;/div&gt;<br/>    &lt;span&gt;{phoneNumber}&lt;/span&gt;<br/>    &lt;span&gt;{emailAddress}&lt;/span&gt;<br/>  &lt;/div&gt;<br/>}<br/><br/>function App() {<br/>  const [users, setUsers] = useState([]);<br/><br/>  useEffect(() =&gt; {<br/>    getFullUsersInfo().then(res =&gt; {<br/>      setUsers(res);<br/>    })<br/>  }, [])<br/><br/>  return (<br/>    &lt;div style={{display: "flex", flexDirection: "column"}}&gt;<br/>      {users.map(user =&gt; &lt;User key={user.userId} phoneNumber={user.phoneNumber} emailAddress={user.emailAddress} firstName={user.firstName} lastName={user.lastName}/&gt;)}<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="d9b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们新的App.js文件。从上到下，我们首先实现函数<strong class="lb iu"> getFullUsersInfo </strong>，它获取我们所有用户的信息。它调用两个端点(包括一个耗时3秒的端点)，处理一些数据(提取id以发送给第二个请求)，最后合并所有内容以返回具有更完整对象的相同数组。</p><p id="656b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有了<strong class="lb iu">用户</strong>组件。它将我们想要显示的信息作为参数，这些信息是<strong class="lb iu">名</strong>、<strong class="lb iu">姓</strong>、<strong class="lb iu">电话号码</strong>和<strong class="lb iu">电子邮件地址</strong>。为了更好地阅读，我们在组件中添加了一些样式。</p><p id="bc88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，主<strong class="lb iu">应用程序组件</strong>在挂载时获取数据(useEffect使用空括号)并将它们存储在一个状态中。<br/>然后，我们使用map函数提取值，并使用用户组件显示。</p><blockquote class="nm nn no"><p id="99e2" class="kz la np lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">出于本文的目的，我选择将所有内容放在一个文件中。根据不同文件的目的，总是尽量将你的代码分离在不同的文件中，以保持你的项目尽可能的干净和集中</p><p id="0455" class="kz la np lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">请注意，当调用用户对象时，我使用用户Id作为键，而不是其他东西，甚至不是索引。这是因为react团队不建议使用索引，而且，使用userId，我们可以确保每个条目都有一个唯一的值。</p></blockquote><p id="b085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您保存并刷新您的页面，您将看到两个用户出现。然而，在显示某些东西之前需要3秒钟。对用户体验非常不好！</p><blockquote class="ov"><p id="4cef" class="ow ox it bd oy oz pa pb pc pd pe lu dk translated">请记住，如果加载时间超过3秒，超过50%的用户会离开你的应用程序</p></blockquote><h2 id="29b5" class="ng mf it bd mg ok pf dn mk om pg dp mo li ph op mq lm pi or ms lq pj ot mu ou bi translated">重构以使用生成器</h2><p id="e564" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">生成器的伟大之处在于，从一个经典函数创建它们非常容易。首先，我们需要知道在哪里放置我们的产量，然后我们必须执行函数。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="9443" class="ng mf it nc b gy nh ni l nj nk">async function* GetFullUsersInfo() {<br/>  const basicUsers = await getUsers();<br/>  yield basicUsers<br/>  const ids = basicUsers.map(basicUser =&gt; basicUser.userId);<br/>  const advancedUsers = await getUsersAdditionalDetails(ids);<br/>  return advancedUsers.map(advancedUser =&gt; ({...advancedUser, ...basicUsers.find((basicUser) =&gt; basicUser.userId === advancedUser.userId)}))<br/>}</span></pre><p id="6449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的新功能。唯一的区别是关键字function后面的星号(*)，yield和我选择将函数重命名为PascalCase，因为我们现在实例化了它(这是可选的)。就是这样！您的函数现在可以使用了！我们现在必须编辑我们的useEffect来处理生成器。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="445c" class="ng mf it nc b gy nh ni l nj nk">useEffect(() =&gt; {<br/>  (async () =&gt; {<br/>    const gen = GetFullUsersInfo();<br/>    const basicInfo = await gen.next();<br/>    setUsers(basicInfo.value);<br/>    const completeInfo = await gen.next();<br/>    setUsers(completeInfo.value);<br/>  })()<br/>}, [])</span></pre><blockquote class="nm nn no"><p id="7ce3" class="kz la np lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">注意我是如何选择在这里使用一个<strong class="lb iu">自执行箭头函数</strong>的。这是因为<strong class="lb iu">你不能在useEffect </strong>中直接使用async/await。这样做允许您在useEffect中执行异步代码，而不必声明新函数。</p></blockquote><p id="c123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个useEffect中，我们首先通过执行它来实例化生成器。然后我们让我们的基本用户使用gen <strong class="lb iu">。接下来()，因为生成器是异步的，所以我们使用await </strong>。我们设置用户状态，之后，我们再次调用next来继续我们的生成器。一旦完成，我们可以删除状态，因为对象是兼容的。</p><p id="80c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在刷新您的页面，看看名字和姓氏是如何立即出现的，三秒钟后，您可以注意到附加信息！如果需要，您甚至可以选择放置一个微调器来向用户显示正在加载更多的数据！</p><p id="a698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，你的用户会有一种快速加载的感觉，因为部分数据已经可以直接看到了。没有人喜欢一个空屏幕，拥有部分数据会让更多用户留在你的网站上。当然，如果加载如此简单的数据需要三秒钟，那么下一步可能是在后端进行一些重构:)</p></div><div class="ab cl pk pl hx pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="im in io ip iq"><h1 id="9c6f" class="me mf it bd mg mh pr mj mk ml ps mn mo jz pt ka mq kc pu kd ms kf pv kg mu mv bi translated">结论</h1><p id="9071" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在Javascript中，生成器可以用于很多目的，但两次加载是其中之一。它使用户体验更加流畅，而没有给代码增加太多的复杂性。</p><p id="eb31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，像每个工具一样，您应该对它进行基准测试，并确保它是正确的选择，因为您正在为代码增加一层复杂性！即使这一层很薄。</p><p id="51f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的github 上找到最终代码<a class="ae ky" href="https://github.com/psyycker-medium/generators-article" rel="noopener ugc nofollow" target="_blank">如果你想有一个整体的看法！</a></p><p id="b4a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢读这篇文章，就像我喜欢写它一样！</p><p id="bf94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见！</p><p id="8fc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">雷米</p></div></div>    
</body>
</html>