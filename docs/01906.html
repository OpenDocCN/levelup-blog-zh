<html>
<head>
<title>Obfuscation in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的混淆</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/android-obfuscation-e608f79f0d09?source=collection_archive---------6-----------------------#2020-02-05">https://levelup.gitconnected.com/android-obfuscation-e608f79f0d09?source=collection_archive---------6-----------------------#2020-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/78943efeb6dcbb7d332b40b5f3a9410f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lLYMPVhe8F2ID5urCehOQ.jpeg"/></div></div></figure><h1 id="d44b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是混淆？</h1><p id="9216" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi lu translated">根据牛津词典，混淆指的是使某事变得模糊、不清楚或难以理解的行为。在软件中，代码的<strong class="ky ir">混淆</strong>是修改可执行文件的过程，这样它对未授权方(如黑客)不再有用，但仍保持完整的功能。但是只要花费足够的时间和精力，几乎所有的代码都可以被逆向工程。然而，大多数平台包括Android、iOS、JAVA和。NET有自己的反编译器，它可以用来从可执行文件和库反向工程源代码，而不需要花费更多的时间和精力。本文主要讨论混淆技术以及如何在Android应用程序中编写混淆代码。</p><h1 id="e582" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">混淆的重要性</h1><p id="36d6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当可执行文件(例如在Android → APK中)被反编译时，任何有编程知识的人都可以很容易地捕捉到源代码的全貌。虽然，通过混淆过程，我们可以给源代码增加额外的安全性，使人类，尤其是黑客，很难理解代码。为了保护商业秘密，可以使用模糊处理来进行流程、未授权访问、漏洞发现和绕过许可或其他控制。</p><p id="8fb2" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">混淆不同于加密。加密的主要目的是转换数据和信息，使其对外界保密。实际的混淆是为了让人类难以理解。加密的代码在执行之前必须被解密，但是执行它们不需要模糊处理，例如去模糊处理。</p><h1 id="f27d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">混淆技术</h1><p id="acb5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">很少有技术可以在编程中执行混淆。这些如下。</p><p id="4486" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir"> [1]重命名混淆</strong></p><p id="1c00" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">许多混淆器(如Android、iOS和Java)都使用这种基本转换。这是通过重命名变量和方法名来完成的。它使用新的字符串、字母、数字、不可打印字符和不可见字符进行转换。</p><p id="1a87" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir">【2】字符串加密</strong></p><p id="b7ab" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">所有字符串在托管可执行文件中都是可发现和可读的。即使方法和变量被重命名，也可以通过在二进制文件中查找字符串引用来使用字符串导航关键代码段。例如，显示给用户的消息(错误消息)可以通过攻击对用户产生重大影响。因此，字符串加密可用于隐藏可执行文件中的字符串。例如，<a class="ae mi" href="http://practicalcryptography.com/ciphers/caesar-cipher/" rel="noopener ugc nofollow" target="_blank"> Caesor密码算法[1] </a>可用于执行字符串文字混淆作为基本混淆。</p><p id="7ae6" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir"> [3]控制流混淆</strong></p><p id="a0ee" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">这使得反编译的代码看起来更像是混合逻辑，黑客很难理解。换句话说，控制流模糊综合了产生有效可执行文件的条件、分支和迭代构造。这些技术可以应用于方法<a class="ae mi" href="https://www.sciencedirect.com/science/article/pii/S0167404816300529" rel="noopener ugc nofollow" target="_blank">【2】</a>的运行时性能。</p><p id="2304" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir">【4】指令模式转换</strong></p><p id="93f5" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">指令模式可用于将编译器创建的常见指令转换为其他不太明显的结构。这些是复杂的合法机器语言指令，可能无法清晰地映射到高级语言，如C#或Java。</p><p id="1034" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir"> [5]虚拟代码插入</strong></p><p id="e0fd" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">在可执行文件中插入不影响主程序逻辑的代码段。但通过反编译或逆向工程破解代码变得越来越难，也很难分析。</p><p id="83f9" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir"> [6]移除未使用的代码和元数据</strong></p><p id="0394" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">从应用程序中移除包括日志、不必要的元数据和使用的代码段在内的调试信息变得更小，并且减少了暴露给攻击者的信息。这些方法可能会影响性能的提高。</p><p id="6c7b" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir">【7】二进制链接和合并</strong></p><p id="ff82" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">这种技术将多个输入可执行文件和库组合成一个或多个输出二进制文件。链接可以使应用程序变得更小。这将有助于简化部署场景，并可能减少黑客的信息。</p><p id="d2ad" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir"> [8]不透明谓词插入</strong></p><p id="16b2" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">此方法用于通过添加条件分支来进行模糊处理，这些条件分支总是评估为无法通过静态分析确定的已知结果。这是引入潜在不正确代码的方式，这些代码实际上永远不会被执行，但是对于试图理解反编译输出的攻击者来说是令人困惑的。</p><p id="d8bb" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir">【9】防篡改</strong></p><p id="9311" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">混淆器可以将应用程序自我保护注入到我们的代码中，以验证我们的应用程序没有以任何方式被篡改。如果检测到篡改，它可以关闭应用程序，限制功能，调用随机崩溃(以掩盖崩溃的原因)，或执行任何其他自定义操作。它还可能向服务发送一条消息，提供有关检测到的篡改的详细信息。</p><p id="7153" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir">【10】反调试</strong></p><p id="e3e1" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">当黑客试图盗版或假冒您的应用程序、窃取您的数据或改变基础架构软件的关键部分的行为时，他们几乎肯定会从逆向工程开始，并使用调试器逐步调试您的应用程序。混淆器可以通过注入代码来检测您的生产应用程序是否正在调试器中执行，从而实现应用程序的自我保护。如果使用调试器，它可能会破坏敏感数据(防止数据被盗)、引发随机崩溃或执行任何其他自定义操作。它还可能向服务发送消息以提供警告信号。</p><h1 id="a401" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">模糊处理的利弊</h1><p id="915f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">安全性(优点)</p><p id="59ef" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">可维护性(缺点)</p><p id="4f24" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">优化代码(优点)</p><p id="2910" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">错误(缺点)</p><p id="4b84" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">追踪非法拷贝(优点)</p><h1 id="efd3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">混淆工具。</h1><p id="30d9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Android Studio相关的工具有<strong class="ky ir">progguard</strong>和<strong class="ky ir"> DexGuard </strong>等。ProGuard是一个免费工具，包含在Android Studio中，DexGuard是ProGuard的商业版本。它可从https://www.guardsquare.com/en.<a class="ae mi" href="https://www.guardsquare.com/en." rel="noopener ugc nofollow" target="_blank">获得</a>当ProGuard使用时，它已被重命名为变量，但我们仍然可以看到代码结构。但是DexGuard不只是重命名变量，它执行更强的控制和预防性混淆。</p><p id="9e8e" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated"><strong class="ky ir">。NET开发者</strong>可以使用<a class="ae mi" href="https://www.armdot.com/docs/armdot/tutorial.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> ArmDot </strong> </a>商业版。ArmDot使用几种方法进行混淆:混淆名称、控制流混淆和虚拟化。虚拟化是一种将原始代码转换为特定虚拟机的指令的方法，这些指令由虚拟机执行，因此原始代码无法恢复或修改。一些混淆工具如下。</p><ol class=""><li id="1f2a" class="mj mk iq ky b kz md ld me lh ml ll mm lp mn lt mo mp mq mr bi translated">。NET:<a class="ae mi" href="http://www.preemptive.com/products/dotfuscator/overview" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Dotfuscator</strong></a><strong class="ky ir">，</strong><a class="ae mi" href="http://www.vgrsoft.com/en/products/ilprotector" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">il protector</strong></a><strong class="ky ir">，</strong> <a class="ae mi" href="https://www.armdot.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> ArmDot </strong> </a></li><li id="f42b" class="mj mk iq ky b kz ms ld mt lh mu ll mv lp mw lt mo mp mq mr bi translated">JavaScript:<a class="ae mi" href="https://javascriptobfuscator.com/Javascript-Obfuscator.aspx" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">JavaScript混淆器</strong> </a> <strong class="ky ir">，</strong><a class="ae mi" href="https://jscrambler.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">js crambler</strong></a></li><li id="b4f8" class="mj mk iq ky b kz ms ld mt lh mu ll mv lp mw lt mo mp mq mr bi translated">Android:<a class="ae mi" href="https://www.guardsquare.com/en/products/proguard" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">progguard</strong></a><strong class="ky ir">，</strong> <a class="ae mi" href="https://www.guardsquare.com/en" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> DexGuard </strong> </a></li></ol><h1 id="bba0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">如何在Android中混淆代码？</h1><p id="3ffa" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先，我们需要在Android Studio的app级Gradle文件中启用<strong class="ky ir"><em class="mx">minify enabled true</em></strong>。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/530e975080b0b7ea8045fd8e22b283dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*Gp-Jw8y-zBjBfUYQXm6ubQ.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">在应用程序级梯度文件中启用ProGuard</figcaption></figure><p id="cdb4" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">如果您正在添加自己的ProGuard规则，您可以按如下方式修改代码。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/8ea08c19236c21e6653fe00832d2a085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LI14B-w4lWfsEDQEGnUGhg.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">在应用程序级梯度文件中添加自定义程序文件</figcaption></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="8603" class="pw-post-body-paragraph kw kx iq ky b kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp mh lr ls lt ij bi translated">关于ProGuard示例的更多细节，请点击链接，你可以从这篇文章中获得关于ProGuard规则以及如何在android混淆中使用ProGuard的更多信息。</p></div></div>    
</body>
</html>