<html>
<head>
<title>Simple Pub-Sub Pattern Using Windows Custom Event | JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Windows自定义事件| JavaScript的简单发布-订阅模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-pub-sub-pattern-using-windows-custom-event-219b2883069?source=collection_archive---------20-----------------------#2022-05-23">https://levelup.gitconnected.com/simple-pub-sub-pattern-using-windows-custom-event-219b2883069?source=collection_archive---------20-----------------------#2022-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ca5347067d92414d9816ac07281c74d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWP-5DVR78KrEYd6u4X-rg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://www.pinterest.com/pin/572872015086305665/" rel="noopener ugc nofollow" target="_blank">https://www.pinterest.com/pin/572872015086305665/</a></figcaption></figure><div class=""/><p id="6a34" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开发Web应用程序时，您可能会遇到这样的情况:您确实需要一个<strong class="ki jk">发布-订阅</strong>设计模式来发送和接收消息。你总是可以使用一些外部模块。然而，在这篇博客中，我将分享如何使用简单的JavaScript在几行代码中快速构建<strong class="ki jk">发布-订阅</strong>设计模式。</p><p id="3a3f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能会想，当我可以简单地使用<strong class="ki jk"> window.addEventListener </strong>注册一个函数时，为什么我需要阅读这篇文章。是的，你是正确的。如果您有一个很少自定义事件的小应用程序，那么您根本不需要阅读这篇文章。本文将帮助您构建一个小型的可重用模块，该模块定义了一种清晰简洁的方法来注册和注销事件侦听器。</p><h1 id="6211" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak"> 1。创建一个模块</strong></h1><p id="4b78" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以用一些导出的方法创建一个简单的文件。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7661" class="mq lf jj mm b gy mr ms l mt mu">// src/EventManager.js</span><span id="ba3a" class="mq lf jj mm b gy mv ms l mt mu">const register = (type, fn) =&gt; {};</span><span id="b593" class="mq lf jj mm b gy mv ms l mt mu">const unregister = (id) =&gt; {};</span><span id="66ac" class="mq lf jj mm b gy mv ms l mt mu">const emit = (type, detail) =&gt; {};</span><span id="2b4b" class="mq lf jj mm b gy mv ms l mt mu">const unregisterAll = () =&gt; {};</span><span id="8475" class="mq lf jj mm b gy mv ms l mt mu">export { emit, register, unregister, unregisterAll };</span></pre><h1 id="254c" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2.实现Register方法</h1><p id="fa92" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><strong class="ki jk">寄存器</strong>方法将非常简单。需要注册事件的<strong class="ki jk">类型</strong>，并调用相应的<strong class="ki jk">函数</strong>。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3903" class="mq lf jj mm b gy mr ms l mt mu">const functionMapper = new Map();</span><span id="210b" class="mq lf jj mm b gy mv ms l mt mu">const register = (type, fn) =&gt; {<br/>  const id = `${type}__${Date.now()}__${Math.floor(Math.random() * 1000)}`;<br/>  functionMapper.set(id, { type, fn });<br/>  window.addEventListener(type, fn);<br/>};</span></pre><p id="9878" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面这里，我添加了一个带有<strong class="ki jk">类型</strong>和<strong class="ki jk">功能</strong>的窗口事件监听器。如果你注意到了，我正在生成一个唯一的id。这对于查找未注册的方法非常有用。我还在<strong class="ki jk">函数映射器</strong>中保存了id到函数的映射。</p><h1 id="b37c" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.实现取消注册方法</h1><p id="de01" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><strong class="ki jk"> unregister </strong>方法将获取一个id，即已注册方法的Id。首先，它将使用<strong class="ki jk">window . removeeventlistener</strong>删除事件监听器。稍后，它将从<strong class="ki jk"> functionMapper中删除函数到id的映射。</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c275" class="mq lf jj mm b gy mr ms l mt mu">const unregister = (id) =&gt; {<br/>  if (functionMapper.has(id)) {<br/>    const { type, fn } = functionMapper.get(id);<br/>    window.removeEventListener(type, fn);<br/>    functionMapper.delete(id);<br/>  }<br/>};</span></pre><p id="8765" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，既然我们有了<strong class="ki jk">注销</strong>的方法。我们也可以在注册函数时返回unregister。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fdce" class="mq lf jj mm b gy mr ms l mt mu">const register = (type, fn) =&gt; {<br/>  // ...<br/>  window.addEventListener(type, fn);<br/>  <strong class="mm jk">return unregister.bind(this, id);</strong><br/>};</span></pre><h1 id="d55f" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">4.实现发出方法</h1><p id="d4b9" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在emit方法中，它将使用<strong class="ki jk"> CustomEvent </strong>创建一个自定义事件，并使用<strong class="ki jk"> window.dispatchEvent </strong>调度它。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ab05" class="mq lf jj mm b gy mr ms l mt mu">const emit = (type, detail) =&gt; {<br/>  window.dispatchEvent(new CustomEvent(type, { detail }));<br/>};</span></pre><h1 id="5054" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">5.最后一试</h1><p id="9273" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为我们有所有需要的方法。我们可以在基本的HTML上试试。为此，让我们创建一个基本的HTML</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dcf5" class="mq lf jj mm b gy mr ms l mt mu">&lt;!-- // index.html --&gt;</span><span id="da76" class="mq lf jj mm b gy mv ms l mt mu">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Parcel Sandbox&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div class="log"&gt;&lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="5da7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们创建<strong class="ki jk"> index.js </strong>来测试我们的库</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="94e4" class="mq lf jj mm b gy mr ms l mt mu">//index.js</span><span id="7025" class="mq lf jj mm b gy mv ms l mt mu">import { emit, register } from "./EventManager";<br/>const log = (message) =&gt; {<br/>  document.querySelector(".log").innerHTML = `${document.querySelector(".log").innerHTML}&lt;span&gt;${JSON.stringify(<br/>    message<br/>  )}&lt;/span&gt;&lt;br/&gt;`;<br/>};<br/>const timePrintUnsubscribe = register("time", () =&gt; {<br/>  log(`Time: ${new Date()}`);<br/>});</span><span id="b6ee" class="mq lf jj mm b gy mv ms l mt mu">register("stop-emit", () =&gt; {<br/>  timePrintUnsubscribe();<br/>});</span><span id="fb74" class="mq lf jj mm b gy mv ms l mt mu">setInterval(() =&gt; {<br/>  emit("time");<br/>}, 100);</span><span id="d190" class="mq lf jj mm b gy mv ms l mt mu">setTimeout(() =&gt; {<br/>  emit("stop-emit");<br/>}, 1000);</span></pre><p id="bc35" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">输出:</strong></p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="09ea" class="mq lf jj mm b gy mr ms l mt mu">"Time: Fri May 20 2022 22:48:15 GMT+0800 (Singapore Standard Time)"<br/>"Time: Fri May 20 2022 22:48:15 GMT+0800 (Singapore Standard Time)"<br/>"Time: Fri May 20 2022 22:48:15 GMT+0800 (Singapore Standard Time)"<br/>"Time: Fri May 20 2022 22:48:15 GMT+0800 (Singapore Standard Time)"<br/>"Time: Fri May 20 2022 22:48:15 GMT+0800 (Singapore Standard Time)"<br/>"Time: Fri May 20 2022 22:48:15 GMT+0800 (Singapore Standard Time)"<br/>"Time: Fri May 20 2022 22:48:15 GMT+0800 (Singapore Standard Time)"<br/>"Time: Fri May 20 2022 22:48:16 GMT+0800 (Singapore Standard Time)"<br/>"Time: Fri May 20 2022 22:48:16 GMT+0800 (Singapore Standard Time)"</span></pre><p id="fb7f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你注意到，事件“时间”将在100英里的间隔触发。这将在DOM上记录一条消息。1000英里后，将发出另一个超时<strong class="ki jk">，将触发“停止发射”</strong>，并取消注册<strong class="ki jk">“时间”</strong>事件回调。</p><p id="71b4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong> Log只是一个在DOM上打印日志的基本实用函数。</p><h1 id="e4fa" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">6.结论</h1><p id="71a7" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正如你所看到的，使用<strong class="ki jk"> timePrintUnsubscribe </strong>方法可以方便地取消注册<strong class="ki jk">“time”</strong>事件回调。调用<strong class="ki jk">寄存器</strong>方法返回。只需添加一个地图就可以解决携带方法引用的问题。作为奖励，你还可以创建一个<strong class="ki jk"> unregisterAll </strong>方法。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7bcc" class="mq lf jj mm b gy mr ms l mt mu">const unregisterAll = (filter = () =&gt; true) =&gt; {<br/>  for (let [id, data] of functionMapper) {<br/>    if (filter(data)) {<br/>      window.removeEventListener(data.type, data.fn);<br/>      functionMapper.delete(id);<br/>    }<br/>  }<br/>};</span></pre><p id="e31e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以通过filter函数取消注册所有方法。默认情况下，它将删除所有寄存器功能。</p><h2 id="69b2" class="mq lf jj bd lg mw mx dn lk my mz dp lo kr na nb ls kv nc nd lw kz ne nf ma ng bi translated">源代码:</h2><p id="3ddc" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">完整的解决方案可以在<strong class="ki jk"> codesandbox </strong>找到。</p><figure class="mh mi mj mk gt iv"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div></div>    
</body>
</html>