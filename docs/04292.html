<html>
<head>
<title>Getting Started with Kubernetes and Container Orchestration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes和容器编排入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-kubernetes-and-container-orchestration-8a579232e40b?source=collection_archive---------16-----------------------#2020-06-18">https://levelup.gitconnected.com/getting-started-with-kubernetes-and-container-orchestration-8a579232e40b?source=collection_archive---------16-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="8db3" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是Kubernetes</h1><p id="5304" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated">ubernetes或俗称的K8s是一个流行的容器编排工具，它运行在我们的容器上(在任何容器引擎上创建，如Docker、Podman、CRI-O等。)并管理容器化应用程序的自动化部署、扩展和管理。<br/> Kubernetes集群可以跨越本地、公共、私有或混合云的主机。因此，Kubernetes是托管需要快速扩展的云原生应用程序的理想平台，比如通过Apache Kafka的实时数据流。</p><h1 id="1a03" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Kubernetes的优势:</h1><p id="146f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">除了我们已经看到的之外，Kubernetes还提供了大量的其他工具，这使得它成为一个广泛使用的强大的容器编排工具。其中一些是:</p><h2 id="507e" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated"><a class="ae mh" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank"> 1。服务发现和负载平衡</a></h2><p id="94a9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">无需修改您的应用程序来使用不熟悉的服务发现机制。Kubernetes为一组Pods提供它们自己的IP地址和一个DNS名称，并且可以在它们之间进行负载平衡。</p><h2 id="7247" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated"><a class="ae mh" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank"> 2。自动推出和回滚</a></h2><p id="ddb3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Kubernetes逐步推出对您的应用程序或其配置的更改，同时监控应用程序的健康状况，以确保它不会同时杀死您的所有实例。如果出现问题，Kubernetes将为您回滚更改。利用不断增长的部署解决方案生态系统。</p><h2 id="7127" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated"><a class="ae mh" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#how-a-replicationcontroller-works" rel="noopener ugc nofollow" target="_blank"> 3。自愈</a></h2><p id="5df6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">重新启动失败的容器，在节点失效时替换和重新安排容器，终止不响应用户定义的运行状况检查的容器，并且在它们准备好提供服务之前不向客户端通告它们。</p><h2 id="d050" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated"><a class="ae mh" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" rel="noopener ugc nofollow" target="_blank"> 4。自动装箱</a></h2><p id="b08b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">根据资源需求和其他限制自动放置容器，同时不牺牲可用性。混合关键工作负载和尽力而为工作负载，以提高利用率并节省更多资源。</p><h2 id="ee92" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated"><a class="ae mh" href="https://medium.com/swlh/fault-tolerance-in-kubernetes-clusters-f5d707bc8b5c" rel="noopener"> 5。容错</a></h2><p id="ffe4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Kubernetes提供了高可用性和强大的容错能力。它检查容纳从我们的集装箱引擎发射的集装箱的吊舱的健康状况，并知道吊舱何时面临停机时间或不能正常工作，管理和修复吊舱或以几乎零停机时间运行另一个吊舱。</p><h1 id="077b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">必需的Kubernetes词汇:</h1><p id="c278" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="kq iu">控制平面:</strong>控制Kubernetes节点的流程集合。这是所有任务分配的起点。</p><p id="06ad" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated"><strong class="kq iu">节点:</strong>这些机器执行控制平面分配的请求任务。</p><p id="3a93" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated"><strong class="kq iu"> Pod: </strong>部署到单个节点的一组一个或多个容器。pod中的所有容器共享一个IP地址、IPC、主机名和其他资源。Pods从底层容器中抽象出网络和存储。这使您可以更容易地在集群中移动容器。</p><p id="e638" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated"><strong class="kq iu">复制控制器:</strong>它控制集群中某个地方应该运行多少个相同的pod副本。</p><p id="85a7" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated"><strong class="kq iu">服务:</strong>这将工作定义从pod中分离出来。Kubernetes服务代理自动将服务请求发送到正确的pod——无论它在集群中的位置如何，甚至是否被替换。</p><p id="c7f5" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated"><strong class="kq iu"> Kubelet: </strong>该服务在节点上运行，读取容器清单，并确保已定义的容器已启动并正在运行。</p><p id="fff4" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated"><strong class="kq iu">ku bectl:</strong>Kubernetes的命令行配置工具。</p><h1 id="2c25" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">让我们到引擎盖下…</h1><p id="c58f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在，我们已经了解了kubernetes的基础知识，让我们看看编排引擎实际上是如何工作的</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/36c2e4a1e073ab081376ecbe9b72fa51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*uKEK9baqpXa9-we_gtzlQw.png"/></div></figure><p id="adda" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi lm translated">Kubernetes架构主要由两部分组成，即控制器(控制平面)和计算机器(通常称为节点)。</p><p id="5fe0" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">每个节点都有自己的环境，可以是运行裸机操作系统的物理机，也可以是虚拟机。每个节点运行几个pod，这些pod通常由在其中运行的容器组合而成。</p><p id="1bdc" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">控制平面负责维护所需的群集状态，例如哪些应用程序正在运行，以及它们使用哪些容器映像。计算机器实际上运行应用程序和工作负载。<br/>这种移交与多种服务一起工作，以自动决定哪个节点最适合该任务。然后，它分配资源并指派该节点中的pod来完成所请求的工作。</p><h2 id="d483" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated">理想的状态</h2><p id="656d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Kubernetes集群的理想状态定义了应该运行哪些应用程序或其他工作负载，以及它们使用哪些映像，应该为它们提供哪些资源，以及其他类似的配置细节。它包含由架构师提供的关于给定时间点运行的期望pod数量、期望多少副本等的管理要求的信息。</p><p id="abf5" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">从基础设施的角度来看，管理容器的方式没有什么变化。您对容器的控制只是发生在一个更高的层次，让您更好地控制，而不需要微观管理每个单独的容器或节点。</p><p id="7922" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">您的工作包括配置Kubernetes和定义节点、pod以及其中的容器。Kubernetes负责编排容器。在哪里经营Kubernetes由你决定。这可以在裸机服务器、虚拟机、公共云提供商、私有云以及混合云环境中进行。Kubernetes的主要优势之一是它可以在许多不同类型的基础设施上工作。</p><h1 id="cab8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">让我们自己旋转一些集群…</h1><p id="280c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要运行一个集群，有一些先决条件。我们必须在我们的机器上安装一个minikube以及一个用于运行和管理集群的kubectl程序。</p><blockquote class="mv mw mx"><p id="617f" class="ko kp my kq b kr mi kt ku kv mj kx ky mz mk lb lc na ml lf lg nb mm lj lk ll im bi translated">安装Minikube:<br/><a class="ae mh" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/tasks/tools/install-minikube/</a></p><p id="c8b3" class="ko kp my kq b kr mi kt ku kv mj kx ky mz mk lb lc na ml lf lg nb mm lj lk ll im bi translated">安装库贝克特尔:<br/>【https://kubernetes.io/docs/tasks/tools/install-kubectl/ T4】</p></blockquote><h2 id="4f80" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated">启动minikube服务</h2><p id="93ed" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Minikube用于在我们的机器中设置一些集群编排环境，因为它在我们的虚拟机中启动一个预配置的环境。<br/>运行minikube:</p><blockquote class="mv mw mx"><p id="6d2d" class="ko kp my kq b kr mi kt ku kv mj kx ky mz mk lb lc na ml lf lg nb mm lj lk ll im bi translated">minikube启动</p></blockquote><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/d10e44f07fa86a9bfb0ceed76820fd6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwmh37-KKP-bFD5uTv19tQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">minikube开始命令工作</figcaption></figure><p id="8a93" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">该命令将在虚拟箱(默认为minikube使用的虚拟环境)中启动一个正在运行的minikube实例。你可以看到一个名为minikube的环境在你的虚拟盒子的后台运行</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nl"><img src="../Images/2591a85ec6197eeb66f33e8d992aae6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v56vLG5GTGrX0wGJbqyKfg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">minikube在虚拟盒子中推出</figcaption></figure><h2 id="5afd" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated">凭证…</h2><p id="cc7a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">默认情况下，虚拟机的凭据设置为:</p><blockquote class="mv mw mx"><p id="8849" class="ko kp my kq b kr mi kt ku kv mj kx ky mz mk lb lc na ml lf lg nb mm lj lk ll im bi translated">用户名:docker <br/>密码:tcuser</p></blockquote><p id="2ff4" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">现在我们已经成功启动了minikube环境，现在我们可以尝试一些kubernetes命令，我们可以使用kubernetes的kubectl命令创建、管理和编排容器和pod。</p><h2 id="4873" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated">发射舱</h2><blockquote class="mv mw mx"><p id="7982" class="ko kp my kq b kr mi kt ku kv mj kx ky mz mk lb lc na ml lf lg nb mm lj lk ll im bi translated">kubectl get pods: <br/>这个命令用于获取所有正在运行的pods。</p><p id="fd40" class="ko kp my kq b kr mi kt ku kv mj kx ky mz mk lb lc na ml lf lg nb mm lj lk ll im bi translated">ku bectl create deployment<imagename>—image = container _ image _ location:<br/>该命令用于在流程编排的pod中部署一个新容器</imagename></p></blockquote><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nm"><img src="../Images/993a80b14d7b13b41c10730921338ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ddRHpPX-cDRmTNSL7mWoQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">nginx容器在mynewpod中启动</figcaption></figure><p id="ec1e" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">上面的命令显示了一个成功运行的pod (mynewpod ),它包含一个运行Nginx映像的容器。<br/>现在，正如我们所说，Kubernetes是一个非常智能的容器编排工具，可以管理在pod内运行的容器的健康状况，因此，如果由于某些原因pod可能会死亡或停止正常工作，它会在几秒钟内启动另一个具有相同映像的pod。</p><h2 id="203a" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated">让我们破坏发射的吊舱，并实际体验Kubernetes的力量…</h2><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nn"><img src="../Images/bc9edf316847178b3141b17597bcb161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0ihZX9UtBuXudpaH9Iluw.png"/></div></div></figure><p id="3c08" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">正如我们所见，原始pod已被销毁，当我们在后台检查正在运行的pod时，Kubernetes立即启动了另一个具有不同名称的新pod容器，从而确保尽可能减少停机时间。因为容器引擎本身很快，因此将应用程序的停机时间减少到几秒钟。</p><p id="4076" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi lm translated">我们看到了kubernetes的自我修复和容错能力，但是Kubernetes的复制部分呢</p><p id="8fd2" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">为了检查kubernetes提供的复制控制器的能力，让我们将pod的副本增加到3个，看看会发生什么</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi no"><img src="../Images/899c2524779f81eba5a2d2ea56f41374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-TxhzrXktdXsJw6y0ulYg.png"/></div></div></figure><p id="e2ed" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">当我们告诉我们的kubernetes启动我们刚刚创建的pod的3个副本时，它的复制控制器立即启动3个容器，这些容器是我们向kubernetes展示的愿望的一部分。kubernetes现在将管理所有3个吊舱，并将确保我们的愿望始终得到满足，即它将确保在未来的任何时间点，我们必须有3个内部装有nginx容器的健康运行吊舱</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2f8b0f4b626f9684489e8c6b4cce2b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*7gd5-r6q9G4b0RzNsbmuhw.png"/></div></figure><p id="4889" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi translated">一旦我们销毁或删除了所有的豆荚，正如我们的愿望中提到的，kubernetes立即推出另一套豆荚，以便我们的愿望中提到的配置总是得到满足。</p><p id="ecaa" class="pw-post-body-paragraph ko kp it kq b kr mi kt ku kv mj kx ky kz mk lb lc ld ml lf lg lh mm lj lk ll im bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di">至此，我们都更加熟悉kubernetes的词汇和它所拥有的力量，以及它的重要性和用例。</span></p><h2 id="1981" class="lv jr it bd js lw lx dn jw ly lz dp ka kz ma mb ke ld mc md ki lh me mf km mg bi translated">接下来<a class="ae mh" href="https://medium.com/@dimrisaurabh06/creating-k8s-scripts-deep-dive-to-cluster-orchestration-f0ca70c02c63" rel="noopener">创建K8s脚本—深入K8s </a></h2><blockquote class="nq"><p id="ccda" class="nr ns it bd nt nu nv nw nx ny nz ll dk">………………………………………………………………………………</p><p id="76b6" class="nr ns it bd nt nu nv nw nx ny nz ll dk translated">“软件就像熵:很难把握，没有重量，遵守热力学第二定律；也就是说，它总是增加。”<br/> <em class="oa"> —诺曼·奥古斯丁</em></p></blockquote></div></div>    
</body>
</html>