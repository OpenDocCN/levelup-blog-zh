<html>
<head>
<title>The Law of Demeter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">德米特里定律</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-law-of-demeter-4bd40aa21cbe?source=collection_archive---------9-----------------------#2020-04-28">https://levelup.gitconnected.com/the-law-of-demeter-4bd40aa21cbe?source=collection_archive---------9-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它经常被遗忘或忽视😔</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bee1cd67e65732048991979735595693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q2hIGRJoa-s-CNx9KpZPeQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">德米特里定律</figcaption></figure><p id="f954" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">德米特法则，被称为LoD或最少知识原则。这个所谓的法律有如下三个核心思想。</p><ul class=""><li id="12bd" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">每个单元应该只对其他单元有有限的了解:只有与当前单元“密切”相关的单元。</li><li id="825b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">每个单位应该只和自己的朋友说话；不要和陌生人说话。</li><li id="2541" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">只和你最亲近的朋友说话。</li></ul><p id="7c68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，这个上下文中的单元是一个特别编码的抽象，比如可能是一个函数、一个模块或者一个类。而这里说的是接口，比如调用另一个模块的代码或者让那个模块调用你的代码。</p><p id="4a16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是非常有用的学习和应用到您的程序，但它是可悲的😔它经常被遗忘或忽视。这条法则更多的是一条指导方针，而不是帮助减少组件间耦合的原则。</p><p id="324d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们都见过像这样的长长的函数链。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="fe53" class="mn mo it mj b gy mp mq l mr ms">obj.getX()<br/>      .getY()<br/>        .getZ()<br/>          .doSomething();</span></pre><p id="bce4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们问了又问，然后才说。对doSomething()的调用向外传播，直到到达z。这些长长的查询链违反了所谓的Demeter法则。像下面这样不是更好看吗？</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="0506" class="mn mo it mj b gy mp mq l mr ms">obj.doSomething();</span></pre><p id="c4db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，我们可以这样理解这个规律:一个对象应该只调用这几类对象的方法，如下:<code class="fe mt mu mv mj b">itself, its parameters, any objects it creates, its direct component objects, objects of the same type</code>。</p><p id="defd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，让我们举一些定义<code class="fe mt mu mv mj b">Customer</code>和<code class="fe mt mu mv mj b">CustomerWallet</code>类的简单例子。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="dfaf" class="mn mo it mj b gy mp mq l mr ms">public class Customer {<br/>    <br/>    ...<br/><br/>}</span><span id="4905" class="mn mo it mj b gy mw mq l mr ms">public class CustomerWallet {<br/><br/>    private float amount = 0;<br/><br/>    ...<br/><br/>}</span></pre><p id="048a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">调用自身及其参数。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="7907" class="mn mo it mj b gy mp mq l mr ms">public class CustomerWallet {<br/><br/>    ...<br/><br/>    public void addMoney(float deposit) {<br/>        this.amount += deposit;<br/>    }</span><span id="9a24" class="mn mo it mj b gy mw mq l mr ms">    public void takeMoney(float debit) {<br/>       this.amount -= debit;<br/>    }<br/>}</span></pre><p id="efd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们创建的任何对象或任何直接持有的组件对象上调用方法是没问题的。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="8bb7" class="mn mo it mj b gy mp mq l mr ms">public class Customer {<br/>    <br/>    private CustomerWallet wallet;<br/>    public Customer() {<br/>        this.wallet = new CustomerWallet();<br/>    }<br/><br/>}</span></pre><p id="d121" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看得更远。我们以店主和顾客之间的互动的简化版本为例，可能会出现如下问题。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="3476" class="mn mo it mj b gy mp mq l mr ms">public class ShopKeeper {<br/>    public void processPurchase(Product product, Customer customer){<br/>        static price = product.price();<br/>        customer.wallet.takeMoney(price);<br/>        ...<br/>      }<br/><br/>}</span></pre><p id="9879" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这违反了德米特里的法律。我们尝试考虑这种相互作用的一个真实案例。店主从顾客的口袋中取出钱包，然后打开钱包，取出所需的金额，而不以任何方式直接与顾客互动。</p><p id="b194" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显而易见，在现实生活中，这永远不会是一种合适的社交互动。在这种情况下，店主做出的假设超出了他们的职权范围。顾客可能希望使用不同的机制支付，或者甚至可能没有钱包。</p><p id="c311" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的店主不应该知道顾客的钱包，所以不应该和它说话。所以，我们应该重写我们的程序如下。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="d4e3" class="mn mo it mj b gy mp mq l mr ms">public class ShopKeeper {<br/>    public void processPurchase(Product product, Customer customer){<br/>        static float price = product.price();<br/>        customer.requestPayment(price);<br/>        ...<br/>    }<br/><br/>}</span><span id="8ef0" class="mn mo it mj b gy mw mq l mr ms">public class Customer {<br/>    <br/>    ...<br/>    public requestPayment(float price) {<br/>        ...<br/>    }<br/><br/>}</span></pre><p id="603e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mt mu mv mj b">ShopKeeper</code>现在正直接与<code class="fe mt mu mv mj b">Customer</code>对话。客户还将与他们的<code class="fe mt mu mv mj b">CustomerWallet</code>实例对话，检索所需的金额，然后将其交给店主。</p><p id="33f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很简单，对吧？</p></div></div>    
</body>
</html>