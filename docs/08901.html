<html>
<head>
<title>Functors in Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程中的函子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functors-in-functional-programming-dfaba4cfb2ed?source=collection_archive---------8-----------------------#2021-06-16">https://levelup.gitconnected.com/functors-in-functional-programming-dfaba4cfb2ed?source=collection_archive---------8-----------------------#2021-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/fb3e49e1ff8afec10e485022ab468364.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*6QaP5p0-_6rhf6q7.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://www.scalawithcats.com/" rel="noopener ugc nofollow" target="_blank">斯卡拉与猫</a></figcaption></figure><h1 id="ab54" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">1.概观</h1><p id="a6bc" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在本教程中，我们将看看<a class="ae jy" href="https://typelevel.org/cats/typeclasses/functor.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">仿子</em> </a>类中的<a class="ae jy" href="https://typelevel.org/cats/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">猫</em> </a>。<em class="lv">函子</em>的思想是“可以映射的东西”，我们将会看到实际映射了什么以及如何映射。在函数式编程中，当我们将类型或值包装在上下文或容器中时，<strong class="kz ir"> <em class="lv">函子</em>开始发挥作用。我们不需要知道那些上下文或容器本身的任何实现细节。</strong></p><h1 id="cb69" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">2.SBT属地</h1><p id="cd26" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">首先，让我们将Cats库添加到我们的依赖项中:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5b9b" class="mf ka iq mb b gy mg mh l mi mj">libraryDependencies += "org.typelevel" %% "cats-core" % "2.2.0"</span></pre><p id="ad15" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">这里我们使用的是Cats库的2.2.0版本。</p><h1 id="e40f" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">3.什么是函子？</h1><p id="22b8" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">就函数式编程而言，<strong class="kz ir"> a <em class="lv"> Functor </em>是一种可以被函数映射的容器。</strong>它基本上是一个抽象，允许我们编写通用代码，可用于<em class="lv">期货</em>、<em class="lv">期权</em>、<em class="lv">列表</em>、<em class="lv">、</em>或任何其他可映射类型。</p><p id="7de2" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">简单来说，<strong class="kz ir">任何定义了映射函数的类型，最好是“恒等函数”，都是<em class="lv">函子</em>。</strong></p><p id="c457" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">标准库没有本地基本特征/类型来表示这一点，所以我们可以写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cd23" class="mf ka iq mb b gy mg mh l mi mj">def calcBudget(orders: List[LineItem]) = orders.map(...) </span><span id="2298" class="mf ka iq mb b gy mp mh l mi mj">def calcBudget(maybeOrder: Option[LineItem]) = maybeOrder.map(...) </span><span id="cda5" class="mf ka iq mb b gy mp mh l mi mj">def calcBudget(eventualOrder: Future[LineItem]) = eventualOrder.map(...)</span></pre><p id="966c" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">但是我们不能笼统地这样写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1dbd" class="mf ka iq mb b gy mg mh l mi mj">def calcBudget(order: Functor[LineItem]) = order.map(...)</span></pre><h1 id="915b" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">4.Cats仿函数类型类</h1><p id="55c4" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">然而，使用cats的<em class="lv">仿函数</em>类型类，我们可以编写一个通用代码，用于<em class="lv">期货</em>、<em class="lv">选项</em>、<em class="lv">列表</em>、<em class="lv">或者</em>或者任何其他可映射类型。</p><p id="9e8a" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">但在此之前，让我们看看<em class="lv">函子</em>类型类的定义。用映射操作<em class="lv"> (A = &gt; B) = &gt; F[B] </em>将<em class="lv">仿函数</em>定义为<em class="lv"> F[A] </em>:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="653c" class="mf ka iq mb b gy mg mh l mi mj">package cats trait Functor[F[_]] { <br/>  def map[A, B](fa: F[A])(f: A =&gt; B): F[B] <br/>}</span></pre><p id="76b6" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">现在让我们使用<em class="lv">仿函数</em>重写<em class="lv">计算预算</em>:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ded4" class="mf ka iq mb b gy mg mh l mi mj">import cats.Functor </span><span id="1d91" class="mf ka iq mb b gy mp mh l mi mj">case class LineItem(price: Double) </span><span id="c988" class="mf ka iq mb b gy mp mh l mi mj">def calcBudget[F[_]](order: F[LineItem])(implicit functorEvidence: Functor[F]): F[LineItem] = { <br/>  Functor[F].map(order)(o =&gt; o.copy(price = o.price * 1.2))<br/>}</span></pre><p id="a92d" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">让我们解码这个方法签名。</p><p id="8d51" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated"><em class="lv"> calcBudget </em>方法基于<em class="lv"> F[_] </em>的类型进行参数化。这里的<em class="lv"> F[_] </em>表示任何可映射的类型，例如<em class="lv">选项</em>、<em class="lv">列表</em>、<em class="lv">未来</em>等。参数<em class="lv">订单</em>本身属于类型<em class="lv">F【LineItem】</em>，即包装<em class="lv"> LineItem </em>的任何类型。</p><p id="64a4" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">隐式参数<em class="lv">Functor evidence:Functor[F]</em>意味着我们必须有一个<em class="lv">类型的类实现</em>，它允许我们将<em class="lv"> F </em>视为<em class="lv"> Functor </em>。</p><p id="63c5" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">在方法体中，我们称<em class="lv">为函子[F]。map() </em>即我们使用隐式证据<em class="lv"> functorEvidence </em>为<em class="lv"> F </em>创建一个函子，并将其称为<em class="lv"> map </em>方法。</p><h1 id="0679" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">5.函子定律</h1><p id="b7d0" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">如果我们正在创建自己的<em class="lv">函子</em>，那么那些<em class="lv">函子</em>必须遵守一些规则，叫做<em class="lv">函子定律</em>:</p><h2 id="b142" class="mf ka iq bd kb mq mr dn kf ms mt dp kj li mu mv kn lm mw mx kr lq my mz kv na bi translated">5.1.同一律</h2><p id="ea95" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当一个<em class="lv">函子</em>被identity函数(返回其参数不变的函数)映射时，那么我们必须取回原来的<em class="lv">函子</em>(容器及其内容保持不变)。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7942" class="mf ka iq mb b gy mg mh l mi mj">Functor[X].map(x =&gt; identity(x)) == Functor[X]</span></pre><h2 id="173f" class="mf ka iq bd kb mq mr dn kf ms mt dp kj li mu mv kn lm mw mx kr lq my mz kv na bi translated">5.2.合成定律</h2><p id="0363" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">当一个<em class="lv">函子</em>映射到两个函数的组合上时，那么它应该与一个函数映射到另一个函数上是一样的。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5280" class="mf ka iq mb b gy mg mh l mi mj">Functor[X].map(f).map(g) == Functor[X].map(x =&gt; g(f(x))</span></pre><h1 id="8b9f" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">6.Scala中函子的例子</h1><p id="8cd5" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在Scala中，我们知道<em class="lv">仿函数的</em> <em class="lv">映射</em>函数来处理效果。<strong class="kz ir"> Cats为<em class="lv">函子</em> </strong>提供了各种类型类实现，对于预定义的类型如<em class="lv">列表</em>、<em class="lv">期货</em>、<em class="lv">选项</em>、<em class="lv">要么</em>等。</p><h2 id="b5e3" class="mf ka iq bd kb mq mr dn kf ms mt dp kj li mu mv kn lm mw mx kr lq my mz kv na bi translated">6.1.列为函子</h2><p id="916d" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在，让我们看看<em class="lv">列表</em>如何充当<em class="lv">仿函数</em>:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/dc26aee947947745b6c4aefa07498aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/0*BQ6uVyeytldGBaOG.jpeg"/></div></figure><p id="4967" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated"><em class="lv">列表</em>被认为是<em class="lv">仿函数</em>，因为它有一个<em class="lv">映射</em>方法。当使用<em class="lv">映射</em>方法迭代<em class="lv">列表</em>时，我们应该认为它是一次性转换列表中的所有值，而不改变<em class="lv">列表</em>的结构。</p><p id="d057" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">我们可以使用以下示例来实现上述概念:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1730" class="mf ka iq mb b gy mg mh l mi mj">import cats.Functor </span><span id="5e7c" class="mf ka iq mb b gy mp mh l mi mj">object ListFunctor { <br/>  def transformList(list: List[Int]): List[Int] = { <br/>    Functor[List].map(list)(_ * 2) <br/>  } <br/>} </span><span id="201a" class="mf ka iq mb b gy mp mh l mi mj">val list: List[Int] = List(1, 2, 3, 4, 5) <br/>val transformedList = List(2, 4, 6, 8, 10) <br/>assert(ListFunctor.transformList(list) == transformedList)</span></pre><h2 id="f9ec" class="mf ka iq bd kb mq mr dn kf ms mt dp kj li mu mv kn lm mw mx kr lq my mz kv na bi translated">6.2.作为函子的选项</h2><p id="d4fc" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在，让我们看看<em class="lv">选项</em>如何充当<em class="lv">仿函数</em>:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c61177e3c8575bbf0b3d287a75f44bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*nkpcnsCaQBrYlflK.png"/></div></figure><p id="fca0" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated"><em class="lv">选项</em>也被认为是<em class="lv">仿函数</em>，因为它也有一个<em class="lv">映射</em>方法。当我们映射一个<em class="lv">选项</em>时，我们转换了内容，但保留了<em class="lv">的一些</em>或<em class="lv">无</em>上下文不变。</p><p id="e91e" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">我们可以使用以下示例来实现上述概念:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="964d" class="mf ka iq mb b gy mg mh l mi mj">import cats.Functor </span><span id="3f23" class="mf ka iq mb b gy mp mh l mi mj">object OptionFunctor { <br/>  def transformOption(option: Option[Int]): Option[String] = { <br/>    Functor[Option].map(option)(_.toString) <br/>  } <br/>} </span><span id="7f2f" class="mf ka iq mb b gy mp mh l mi mj">val option: Option[Int] = Some(10) <br/>val transformedOption = Some("10")<br/>assert(OptionFunctor.transformOption(option) == transformedOption)</span></pre><h2 id="03fb" class="mf ka iq bd kb mq mr dn kf ms mt dp kj li mu mv kn lm mw mx kr lq my mz kv na bi translated">6.3.要么作为函子</h2><p id="4f61" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在，让我们看看<em class="lv">或者</em>如何充当<em class="lv">仿函数</em>:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d794d9ed72595c17400fcd319aafff18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/0*zNHJt6eRsQsCbXvn.png"/></div></figure><p id="06c1" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated"><em class="lv">任一</em>也被认为是<em class="lv">函子</em>，因为它也有一个<em class="lv">映射</em>方法。当我们映射一个<em class="lv">或者</em>时，我们转换了内容，但是保持<em class="lv">左</em>或者<em class="lv">右</em>上下文不变。</p><p id="1fa3" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">我们可以使用以下示例来实现上述概念:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="727d" class="mf ka iq mb b gy mg mh l mi mj">import cats.Functor </span><span id="f703" class="mf ka iq mb b gy mp mh l mi mj">object EitherFunctor { <br/>  def transformEither(either: Either[Int, String]): Either[Int, Int] = { <br/>    Functor[Either].left.map(either)(_.size) <br/>  } <br/>} </span><span id="c15c" class="mf ka iq mb b gy mp mh l mi mj">val either: Either[Int, String] = Left("Baeldung") <br/>val transformedEither = Left(8)<br/>assert(EitherFunctor.transformedEither(either) == transformedEither)</span></pre><h2 id="4aed" class="mf ka iq bd kb mq mr dn kf ms mt dp kj li mu mv kn lm mw mx kr lq my mz kv na bi translated">6.4.作为函子的未来</h2><p id="6a10" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">现在，让我们看看<em class="lv">未来</em>如何充当<em class="lv">仿子</em>:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7f18fa258b9537b9217fc0e95290bc64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/0*PF5YYdMemnWqnVM9.png"/></div></figure><p id="75ff" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated"><em class="lv"> Future </em>是一个<em class="lv">函子</em>，它通过对异步计算进行排队，并在它们的前任完成时应用它们，从而对异步计算进行排序。它的<em class="lv"> map </em>方法的类型签名与上面的签名具有相同的形状。然而，行为是非常不同的。<strong class="kz ir">在<em class="lv">未来</em>的情况下，打包的计算可能正在进行、已完成或被拒绝。</strong>如果<em class="lv">未来</em>完成，我们的映射函数可以立即调用。如果没有，一些底层线程池将函数调用排队，稍后再返回。我们不知道我们的函数什么时候被调用，但是我们知道它们被调用的顺序。这样，<strong class="kz ir"> <em class="lv"> Future </em>提供了与<em class="lv">列表</em>、<em class="lv">选项</em>、<em class="lv">任一</em> </strong>相同的排序行为。</p><p id="fe85" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">我们可以使用以下示例来实现上述概念:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="a5f3" class="mf ka iq mb b gy mg mh l mi mj">import cats.Functor </span><span id="5aea" class="mf ka iq mb b gy mp mh l mi mj">object FutureFunctor { <br/>  def transformFuture(future: Future[Int]): Future[Int] = { <br/>    Functor[Future].map(future)(_ + 1) <br/>  } <br/>} </span><span id="78bd" class="mf ka iq mb b gy mp mh l mi mj">val future: Future[Int] = Future{10} <br/>val transformedFutureResult = 11<br/>FutureFunctor.transformFuture(future).map(result =&gt; assert(result == transformedFutureResult))</span></pre><h1 id="7c4a" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">7.函子的重要性</h1><p id="cd88" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">通过使用函子，我们不局限于标准库中的类型，因此我们可以抽象任何可映射的东西。通过使用<em class="lv">语法</em>或<em class="lv">扩展</em>方法的概念，我们可以定义一个映射方法到我们自己的类型。这个概念允许我们写<em class="lv"> order.map(…) </em>而不是<em class="lv">Functor【F】。地图(顺序)(…) </em>。我们还可以通过指定type <em class="lv"> F[_] </em>是一个<em class="lv">仿函数</em>来删除隐式证据参数:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="9e81" class="mf ka iq mb b gy mg mh l mi mj">import cats.syntax.functor._ //for map </span><span id="b004" class="mf ka iq mb b gy mp mh l mi mj">def calcBudget[F[_]: Functor](order: F[LineItem]): F[LineItem] = {<br/>  order.map(o =&gt; o.copy(price = o.price * 1.2)) <br/>}</span></pre><p id="b748" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">但是我们也可以构建一个高阶函数，它可以处理任何类型并执行任何映射操作:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0005" class="mf ka iq mb b gy mg mh l mi mj">def withFunctor[A, B, F[_]](item: F[A], op: A =&gt; B)(implicit functorEvidence: Functor[F]): F[_] = {<br/>  Functor[F].map(item)(op) <br/>}</span><span id="45c8" class="mf ka iq mb b gy mp mh l mi mj">val lineItemsList = List(LineItem(10.0), LineItem(20.0)) <br/>val result = FunctorSyntax.withFunctor(lineItemsList, calcBudget) <br/>assert(result == List(LineItem(10.0), LineItem(20.0)))</span></pre><p id="8cad" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">在上面的例子中，<em class="lv"> A </em>，<em class="lv"> B </em> &amp; <em class="lv"> F </em>可以是任何东西，只要方法的调用者:</p><ul class=""><li id="3e7c" class="nf ng iq kz b la mk le ml li nh lm ni lq nj lu nk nl nm nn bi translated">提供证据证明<em class="lv"> F </em>是<em class="lv">函子</em></li><li id="4c85" class="nf ng iq kz b la no le np li nq lm nr lq ns lu nk nl nm nn bi translated">知道如何从<em class="lv"> A </em>映射到<em class="lv"> B </em></li></ul><h1 id="8b16" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">8.摘要</h1><p id="f1b1" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">在本文中，我们已经研究了Scala的Cats库提供的<em class="lv">函子</em>。<em class="lv">函子</em>是一种提供映射函数来表示排序行为的容器。我们讨论了什么是<em class="lv">函子</em>的需求，以及如何定义它们。然后我们学习了两个<em class="lv">函子</em>必须遵守的定律。然后我们看到，我们可以为Scala生态系统<em class="lv">中存在的所有<em class="lv">可映射</em>类型编写<em class="lv">仿函数</em>类型类实现，比如</em> <em class="lv">期货</em>、<em class="lv">选项</em>、<em class="lv">列表、</em>等等。我们不局限于标准库中的类型。我们也可以通过使用<em class="lv">语法</em>或<em class="lv">扩展</em>方法的概念来定义<em class="lv">映射</em>方法到我们自己的类型。</p><p id="e072" class="pw-post-body-paragraph kx ky iq kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ij bi translated">所有的代码实现都可以在GitHub 的<a class="ae jy" href="https://github.com/mansi7babbar/functors-in-functional-programming" rel="noopener ugc nofollow" target="_blank">上获得。</a></p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="569d" class="jz ka iq bd kb kc oa ke kf kg ob ki kj kk oc km kn ko od kq kr ks oe ku kv kw bi translated">类似文章-</h1><p id="2d5e" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">你也可以看看我关于<em class="lv"> Scala Cats </em>系列的其他文章</p><ul class=""><li id="22f6" class="nf ng iq kz b la mk le ml li nh lm ni lq nj lu nk nl nm nn bi translated">【Scala猫入门</li><li id="3a68" class="nf ng iq kz b la no le np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae jy" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-semigroups-732ef2432042">潜入Scala猫—半群</a></li><li id="f0b2" class="nf ng iq kz b la no le np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae jy" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-monoids-82e744b9e518">潜入Scala猫——幺半群</a></li><li id="13c6" class="nf ng iq kz b la no le np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae jy" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-functors-c957285d7009">深入Scala猫——函子</a></li></ul></div></div>    
</body>
</html>