<html>
<head>
<title>How we stay up to date with our dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何与我们的依赖关系保持同步</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-we-stay-up-to-date-with-our-dependencies-7365528a3ec8?source=collection_archive---------15-----------------------#2020-06-30">https://levelup.gitconnected.com/how-we-stay-up-to-date-with-our-dependencies-7365528a3ec8?source=collection_archive---------15-----------------------#2020-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fbf43d6820a52712eb1f0767256f2f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4NkwltdYJdy-WZ7EAiiiGw.jpeg"/></div></div></figure><p id="39bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想我们都知道如何添加对Gradle的依赖，对吗？我的意思是，这基本上是一句话:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0296" class="lf lg iq lb b gy lh li l lj lk">dependencies {<br/>  implementation("x.y.z:abc:1.0-alpha01")<br/>}</span></pre><p id="10dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我们来说没什么新鲜的，对吧？</p><p id="9460" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果有一个新版本的依赖项可用，那么这一行代码会怎么样呢？也许作者实现了一个新特性，或者更好，修复了一个bug！</p><p id="0bec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，如果你像我或我所知道的大多数人一样，会发生以下情况:<strong class="ka ir">没事</strong>。或者至少只要你不需要那个新特性或者一个bug破坏了你的东西，什么都不会发生。</p><p id="55e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样做没有错。只要你对某个特定版本感到满意，保持这个版本是完全没问题的(而且发现的bug与你的业务无关)。但是，如果有东西能提醒你定期更新，那岂不是很酷？不是说你<strong class="ka ir">必须</strong>更新而是说有<strong class="ka ir">能力</strong>更新？</p><p id="6f12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近我和我的团队写了我们自己的<code class="fe ll lm ln lb b"><strong class="ka ir">DependencyBumper</strong></code>。这个工具定期查找我们的依赖项的更新，并在找到一个时创建一个拉请求。</p><p id="1142" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我详述之前。是的，我们知道<a class="ae lo" href="https://dependabot.com/" rel="noopener ugc nofollow" target="_blank">dependent bot</a>及其兄弟工具。但他们中的大多数只适用于“标准梯度设置”(不管那是什么意思)。由于我们没有这样的设置(也不会改变)，我们决定自己构建一些东西。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h2 id="ad99" class="lf lg iq bd lw lx ly dn lz ma mb dp mc kj md me mf kn mg mh mi kr mj mk ml mm bi translated">我们当前的设置是什么样的？</h2><p id="e34b" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">我们有一个名为<code class="fe ll lm ln lb b">versions.gradle</code>的文件，在这里我们定义了一个<code class="fe ll lm ln lb b">Map</code>，以“依赖项的名称”为关键字，以Gradle字符串依赖符号为值。我们将整个地图放到<code class="fe ll lm ln lb b"><a class="ae lo" href="https://docs.gradle.org/6.5/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html" rel="noopener ugc nofollow" target="_blank">ExtraPropertiesExtension</a></code>中，使其在所有其他构建脚本中可用。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7616" class="lf lg iq lb b gy lh li l lj lk">ext {<br/>  deps = [:]<br/>  deps.kotlinjdk = "org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.3.72"<br/>}</span></pre><p id="e492" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需要在构建脚本中应用这个脚本就可以访问依赖项。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e14b" class="lf lg iq lb b gy lh li l lj lk">apply from: 'versions.gradle'</span><span id="5845" class="lf lg iq lb b gy ms li l lj lk">dependencies {<br/>  implementation deps.kotlinjdk<br/>}</span></pre><h2 id="2ee4" class="lf lg iq bd lw lx ly dn lz ma mb dp mc kj md me mf kn mg mh mi kr mj mk ml mm bi translated">如何在该文件中更新依赖关系？</h2><p id="bb0a" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">我们利用<a class="ae lo" href="https://github.com/ben-manes/gradle-versions-plugin" rel="noopener ugc nofollow" target="_blank">升级版本插件</a>来检查更新。所提供的名为<code class="fe ll lm ln lb b">dependencyUpdates</code>的任务将生成一个<code class="fe ll lm ln lb b">JSON</code>文件，其中包含有更新的依赖项。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/763a469b6afbce38c54bf165310141b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*6IkPpsTAn2NzOawgeW_7qQ.png"/></div></figure><p id="d6bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们运行一个定制的<code class="fe ll lm ln lb b"><a class="ae lo" href="https://docs.gradle.org/6.5/dsl/org.gradle.api.tasks.JavaExec.html" rel="noopener ugc nofollow" target="_blank">JavaExec</a></code>任务，它将执行我们的<code class="fe ll lm ln lb b">DependencyBumper</code>。该代码随后执行以下操作:</p><ul class=""><li id="ef8c" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">解析<code class="fe ll lm ln lb b">JSON</code>文件，为每次更新创建一个<code class="fe ll lm ln lb b">Map</code></li><li id="e23c" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">为<code class="fe ll lm ln lb b">Map</code>中的每个条目创建一个新的<code class="fe ll lm ln lb b">branch</code></li><li id="9982" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">检查<code class="fe ll lm ln lb b">origin</code>和<strong class="ka ir">处的<code class="fe ll lm ln lb b">branch</code>名称是否已经存在，如果是，跳过</strong>此条目</li><li id="3634" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">用<em class="ni">新版本</em>替换<code class="fe ll lm ln lb b">versions.gradle</code>中的<em class="ni">当前版本</em>(用<a class="ae lo" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank"> Regex </a>的魔力)。</li><li id="5ea8" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">将<code class="fe ll lm ln lb b">branch</code>推到<code class="fe ll lm ln lb b">origin</code></li><li id="93ab" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">创建一个从这个<code class="fe ll lm ln lb b">branch</code>到我们的基础分支<code class="fe ll lm ln lb b">develop</code>的拉请求</li></ul><p id="54be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过检查<strong class="ka ir">如果</strong>在<code class="fe ll lm ln lb b">origin</code>已经有一个<code class="fe ll lm ln lb b">branch</code>，我们可以简单地关闭拉请求—如果我们对这个更新不感兴趣—但是不要删除分支。下次<code class="fe ll lm ln lb b">DependencyBumper</code>运行时，它将检测到<code class="fe ll lm ln lb b">branch</code>已经可用，并跳过它创建拉取请求的部分。</p><p id="4198" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们仍然面临的一个挑战是一起更新属于一起的依赖关系。正如您在上面的<code class="fe ll lm ln lb b">JSON</code>示例中看到的，<code class="fe ll lm ln lb b">dagger</code>和<code class="fe ll lm ln lb b">dagger-compiler</code>依赖项应该一起更新。在单一代码库中为<code class="fe ll lm ln lb b">dagger</code>提供版本<code class="fe ll lm ln lb b">2.23</code>而为<code class="fe ll lm ln lb b">dagger-compiler</code>提供版本<code class="fe ll lm ln lb b">2.24</code>是没有任何意义的。目前，我们的工具为每个依赖项创建一个拉请求——这毫无意义。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="1a98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本就是这样。但是——老实说——当这个话题第一次提出时，我完全反对。我担心，只要我们的配置项是绿色的，它就会迫使我们盲目地合并这些拉请求。而不看变更日志或发行说明。令人惊讶的是，在第一轮更新后(有<strong class="ka ir">很多</strong>)我注意到了完全相反的情况。我们查找了每个依赖项的所有更改，并对pull请求中值得一提的更改进行了注释！这使得整个团队都可以看到变更，如果在开发新功能或修复bug时更新了依赖项，就不会出现这种情况。</p></div></div>    
</body>
</html>