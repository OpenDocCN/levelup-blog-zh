<html>
<head>
<title>A Go Interface Tip Until Generics…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个Go接口提示，直到泛型…</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-go-interface-tip-until-generics-7da75ba25352?source=collection_archive---------3-----------------------#2021-11-20">https://levelup.gitconnected.com/a-go-interface-tip-until-generics-7da75ba25352?source=collection_archive---------3-----------------------#2021-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/954a3be9e7e9625f43d840b2dc6dab88.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*mWU0yD57BQ4RyHUnqLQLkA.jpeg"/></div></figure><p id="98ed" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们进入Go中的泛型之前，我有一个关于接口的技巧可以分享。不要给一个接口添加方法，这些方法只需要接口本身来完成它们的工作。这看起来有点神秘，所以让我们看一个例子。假设你想让你系统中的东西变得<em class="kv">可定价</em>。这意味着他们需要能够提供一个价格，包括费用和税率。所以你写道:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="f01b" class="lf lg it lb b gy lh li l lj lk">type Priceable interface {<br/> Price() float64<br/> Fees() float64<br/> TaxRate() float64<br/>}</span></pre><p id="c13a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这对你有用，但是你发现自己在重复写:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="805a" class="lf lg it lb b gy lh li l lj lk">extendedPrice := pricable.Price() * priceable.TaxRate() + priceaable.Fees()</span></pre><p id="b49a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你决定所有可定价的东西<em class="kv"/>都应该有一个<code class="fe ll lm ln lb b">ExtendedPrice()</code>，于是毫不犹豫地把它添加到界面上:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e4a4" class="lf lg it lb b gy lh li l lj lk">type Priceable interface {<br/> Price() float64<br/> Fees() float64<br/> TaxRate() float64<br/> ExtendedPrice() float64<br/>}</span></pre><p id="22e9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">不要！现在你已经迫使世界将<code class="fe ll lm ln lb b">ExtendedPrice()</code>添加到所有实现<em class="kv"> Priceable的东西中！</em>由于<code class="fe ll lm ln lb b">ExtendedPrice()</code>只依赖于<em class="kv"> Priceable </em>接口本身，因此将其作为一个函数添加，并将<em class="kv"> Priceable </em>作为一个参数:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7743" class="lf lg it lb b gy lh li l lj lk">type Priceable interface {<br/> Price() float64<br/> Fees() float64<br/> TaxRate() float64<br/>}</span><span id="add8" class="lf lg it lb b gy lo li l lj lk">func ExtendedPrice(p Priceable) float64 {<br/> return p.Price() * p.TaxRate() + p.Fees()<br/>}</span></pre><p id="224c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">也许这看起来很尴尬，因为部分<em class="kv">可定价的</em>是方法，部分是函数。或者你可能会说<em class="kv"> duh </em> <em class="kv">当然！</em>不管怎样，即使在优秀的人的代码中，我也会周期性地遇到这个错误，迫使我一遍又一遍地添加相同的该死的实现来使用给定的接口。</p></div></div>    
</body>
</html>