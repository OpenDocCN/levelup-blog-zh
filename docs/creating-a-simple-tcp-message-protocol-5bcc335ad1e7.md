# 创建简单的 TCP 消息协议

> 原文：<https://levelup.gitconnected.com/creating-a-simple-tcp-message-protocol-5bcc335ad1e7>

## 在 TCP 之上构建消息协议，以避免原始 TCP 连接的一些问题

![](img/5ab5479c7ce753db3e2fe65a9736b5d0.png)

照片由[丹尼·米勒](https://unsplash.com/@redaquamedia?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

TCP(传输控制协议)是大多数现代互联网背后的基本协议。例如，这个网站是通过 TCP 连接发送给您的。但是，在使用 TCP 套接字时，您应该了解它们的一些方面。

大多数 TCP 套接字教程会告诉你，你可以用`send()`发送数据，用`recv()`接收数据，他们通常会发送一些文本作为例子。因为您很可能是在本地网络上测试您的代码，并且它没有很多数据，所以一切都很好。然而，在现实世界中，当通过 TCP 发送数据时，有许多陷阱。

TCP 套接字保证发送的所有数据都会到达，并且会以正确的顺序传递。然而，它不能保证你在单个`send()`呼叫中发送的数据可以在单个`recv()`呼叫中被接收，当你呼叫`recv()`时只有部分消息到达，或者在单个`recv()`呼叫中返回多个消息时，这可能会导致一系列问题。

# 一个例子

为了更好地理解 TCP 的一些问题，让我们看一个简单的例子:

这可能是一个多人游戏的例子，其中 Peter 登录，更新他的位置，并从商店购买物品。这是 3 个不同的动作，服务器应该自己处理每条消息，所以我们发送 3 条消息。如果我们看看客户端的输出，它看起来像这样:

```
31 bytes sent
40 bytes sent
48 bytes sent
```

我们正在发送 3 条不同的消息，正如预期的那样，我们可以看到已经发送了 3 条不同的消息。

但是，让我们看看服务器的输出:

```
119 bytes received
data: Hello Server! My name is Peter.Hey, Peter here. My position is 100,250.Hey, Peter again. I would like to buy something.
```

即使客户机已经发送了三条消息，在服务器上，这三条消息都在对`recv()`的一次调用中被返回。现在，我们不知道最初的信息是什么，也不知道彼得想做什么。

这是 TCP 的问题之一。虽然我们保证会收到按正确顺序发送的所有邮件，但我们不能保证收到的邮件与发送的邮件形式相同。在这种情况下，虽然有 3 个`send()`呼叫，但我们在一个`recv()`呼叫中收到了所有内容。同样，我们也可以发送一个大消息，当我们调用`recv()`时，到目前为止只有一半的消息被传输，所以我们只能得到一半的消息返回。

# 解决方法

如果我们希望接收的消息与发送的消息形式相同，我们需要在 TCP 之上创建一个简单的协议来发送和接收消息。为此，我们有三种不同的选择:

## 1.固定长度消息

第一种选择是总是发送大小完全相同的消息。这样我们就知道每条消息中有多少字节，并且我们可以将收到的所有内容分割成大小正好相同的块。然而，在大多数情况下，这是一个相当浪费的解决方案，我们将发送一大堆什么也没有，浪费了宝贵的吞吐量。如果每个消息的长度必须是 1024 字节，但是我们只有 42 字节的实际有效载荷数据，我们仍然需要发送整个 1024 字节。

## 2.信息结束指示器

第二个选项是总是用分隔符结束每条消息。这可能类似于`###endofmessage###`。这是许多协议中的常用方法。我个人不太喜欢它，因为我总是担心消息定界符的结尾可能出现在我的有效载荷数据中。发生这种情况的可能性当然非常小，但是您必须始终注意选择一个不会在您的数据中出现的合理的分隔符。

## 3.报文标题

第三种方法是总是在每条消息前添加一个固定长度的报头。在最简单的形式中，这可以是包含消息总长度的单个 int (4 字节)。因此，当我们接收到任何数据时，我们从读取消息长度开始，然后在开始解析下一条消息之前只获取该数量的数据。

# 一个简单的消息协议实现

让我们使用消息头方法在 C++中创建一个简单的消息协议。首先，我们需要为我们的消息创建一个类。这很简单。我们只是获取消息的大小，将其复制到一个缓冲区中，然后在它后面复制消息本身。

如果我们把前面的例子转换成新的消息类，发送消息看起来还是一样的:

然而，在服务器端，我们需要更多一点的代码来处理 TCP 套接字可能发生的不同场景。对`recv()`的一次调用可以给我们一条消息，一次多条消息，或者一条消息的不完整片段。因此，我们将收到的所有内容复制到一个缓冲区中，然后检查我们是否至少有`sizeof(int)`个字节可以计算出下一条消息有多大。如果我们有超过这个数量的可用字节，我们也可以解析消息，然后从接收缓冲区中删除它。因为我们有可能一次收到多条消息，所以我们只是这样做，直到我们没有足够的数据来解析另一条消息。

如果我们现在查看服务器的输出，我们可以看到，尽管我们仍然只对`recv()`进行了一次调用，但是我们可以将我们的数据拆分成由客户端发送的 3 条单独的消息。然后，我们可以单独对它们中的每一个做出反应，这比以前好得多，也容易得多。

```
onRecvRaw > 131 bytes received
nextMessageLength: 35
msg: Hello Server! My name is Peter.
nextMessageLength: 44
msg: Hey, Peter here. My position is 100,250.
nextMessageLength: 52
msg: Hey, Peter again. I would like to buy something.
```

# 现实世界

当开发任何涉及网络的应用程序时，我们通常在开发过程中在本地网络上测试它们，很多时候甚至是在同一台机器上。但我们必须记住，这是一个完美的场景，因为我们不必担心通过互联网发送数据带来的所有问题。正因为如此，你的程序甚至可以在不使用任何 TCP 协议的情况下运行。然而，一旦你试图在因特网上发送数据，延迟和丢失的数据包会破坏连接，你绝对需要一个更好的通过 TCP 发送和接收数据的系统。

虽然这可能是一个相对简单的例子，但许多 TCP 消息协议都是这样构建的，并且包含一个带有消息大小编码的报头。

如您所见，在 TCP 套接字连接之上构建简单的消息协议相对容易。像这样的协议有许多不同的用例。事实上，如果没有 HTTP(HTTPS ),我们的现代互联网就无法工作，它有一个`Content-Length`报头字段来做这件事。它告诉接收者预期有多少数据，因此他可以等到完整的消息到达后再解析它。如果您正在实现自己的套接字，请确保避免 TCP 连接的陷阱，并在其上创建一个协议。

你喜欢这样的内容吗？[通过加入 Medium](https://pingpoli.medium.com/membership) ，可以无限制访问所有故事并支持我和其他作者。如果你通过此链接注册，你的一部分会员费将归我所有。