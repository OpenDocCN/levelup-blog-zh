<html>
<head>
<title>REST APIs using go-swagger, Lambda functions, and the API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST APIs使用go-swagger、Lambda函数和API网关</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rest-apis-using-go-swagger-lambda-functions-and-the-api-gateway-b9c0b8c5712b?source=collection_archive---------15-----------------------#2021-01-11">https://levelup.gitconnected.com/rest-apis-using-go-swagger-lambda-functions-and-the-api-gateway-b9c0b8c5712b?source=collection_archive---------15-----------------------#2021-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9687539ca682076be1a6af197ff527c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QlkPPjYDSfAw8q5R"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@hearten_jit?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郑崔浩</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ea7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">AWS提供对<a class="ae kc" href="https://swagger.io/docs/specification/about/" rel="noopener ugc nofollow" target="_blank"> Swagger/OpenAPI </a>定义的REST APIs以及<a class="ae kc" href="https://docs.aws.amazon.com/lambda/latest/dg/golang-handler.html" rel="noopener ugc nofollow" target="_blank"> go运行时</a>的支持；然而，还不完全清楚如何最好地使用它们，特别是如果你习惯于在非AWS环境中使用go-REST API的<a class="ae kc" href="https://github.com/go-swagger/go-swagger" rel="noopener ugc nofollow" target="_blank"> go-swagger </a>。在这里，我描述了<a class="ae kc" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> API网关</a>、go <a class="ae kc" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda </a>函数和go-swagger模块如何协同工作。这里涉及两个具体问题:</p><ul class=""><li id="d64e" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">如何在从API网关调用的Lambda函数中使用go-swagger</li><li id="2f20" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">从API网关的角度和go-swagger的角度来看，请求验证是如何执行的。</li></ul><p id="ae20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">github repo 中提供了一个简单的例子，说明如何将这些技术结合使用。</p><p id="c068" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">上下文</strong></p><p id="2985" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Swagger/OpenAPI已经成为用高级工具为许多语言和平台定义API的标准方法。在go上下文中，go-swagger是广泛使用的Swagger/OpenAPI标准v2.0的成熟实现，它支持REST API的数据验证和封送，并提供从API定义派生的go数据模型。类似地，AWS API网关支持创建在Swagger/OpenAPI文件(2.0版和3.0版)中定义的REST APIs:以这种方式创建API将在API网关中创建适当的端点和数据模型。当然，仍然有必要将它链接到API实现——在本例中是Lambda函数。</p><p id="dbb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Glue:链接API网关、Lambda函数和go-swagger </strong></p><p id="0f9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Lambda函数中使用go-swagger的基本变体非常简单，与非Lambda函数的上下文非常相似。API端点、参数和模型在Swagger文件中定义，服务器REST API的代码由go-swagger工具生成；这就需要绑定到实际的实现中。</p><p id="71a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lambda函数的特殊之处在于，入口点现在是一个特定的处理程序，它将一个<code class="fe lp lq lr ls b">APIGatewayProxyRequest</code>作为输入并返回一个<code class="fe lp lq lr ls b">APIGatewayProxyResponse.</code> AWS在其<a class="ae kc" href="https://github.com/awslabs/aws-lambda-go-api-proxy" rel="noopener ugc nofollow" target="_blank"> aws-lambda-go-api-proxy </a>工具中提供了一个<code class="fe lp lq lr ls b">httpadaptor</code>模块，该模块可以将这些AWS特定的数据类型映射到任何标准go HTTP服务器所期望的通用HTTP请求。这是支持go-swagger集成所必需的粘合剂。</p><p id="3c0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面显示了一个简化的变体，稍微复杂一点的示例在<a class="ae kc" href="https://github.com/seanrmurphy/lambda-swagger-test" rel="noopener ugc nofollow" target="_blank"> github repo </a>中提供。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="32aa" class="mb mc iq ls b gy md me l mf mg">package main</span><span id="c1b8" class="mb mc iq ls b gy mh me l mf mg">import (<br/>...snip...<br/>)</span><span id="663d" class="mb mc iq ls b gy mh me l mf mg">var httpAdapter *httpadapter.HandlerAdapter</span><span id="45b7" class="mb mc iq ls b gy mh me l mf mg">func init() {<br/>    swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON,     restapi.FlatSwaggerJSON)<br/>    if err != nil {<br/>        panic(err)<br/>     }</span><span id="33fe" class="mb mc iq ls b gy mh me l mf mg">    api := operations.NewLambdaGoSwaggerTestAPIAPI(swaggerSpec)<br/>    api.OpenGetAPIIdentifierHandler =     open.GetAPIIdentifierHandlerFunc(handlers.GetApiIdentifier)<br/>    server := restapi.NewServer(api)<br/>    server.ConfigureAPI()</span><span id="cc37" class="mb mc iq ls b gy mh me l mf mg">    httpAdapter = httpadapter.New(server.GetHandler())<br/>}</span><span id="a86a" class="mb mc iq ls b gy mh me l mf mg">// Handler handles API requests<br/>func Handler(req events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {<br/>    return httpAdapter.Proxy(req)<br/>}</span><span id="8439" class="mb mc iq ls b gy mh me l mf mg">func main() {<br/>    lambda.Start(Handler)<br/>}</span></pre><p id="b1c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，只有一个端点——<code class="fe lp lq lr ls b">GetAPIIdentifier</code>——这与它在<code class="fe lp lq lr ls b">handlers.GetApiIdentifier()</code>(不包括在上面)中的实现绑定在一起；这个绑定是通过设置<code class="fe lp lq lr ls b">api.OpenGetAPIIndentifierHandler</code>变量来完成的。</p><p id="e07e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与非Lambda函数的情况一样，<code class="fe lp lq lr ls b">swagger.yaml</code> REST API端点和Go handler函数之间的链接是通过<code class="fe lp lq lr ls b">operationId</code>指定的，从下面的swagger定义片段中可以看出:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="2eeb" class="mb mc iq ls b gy md me l mf mg">paths:<br/>  /:<br/>    get:<br/>      tags:<br/>      - open<br/>      summary: API Identifier endpoint<br/>      <strong class="ls ir">operationId: getApiIdentifier</strong><br/>      description:<br/>        Endpoint which returns the API version and the running backend version</span></pre><p id="eb45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">go-swagger执行一些命名转换，以确保名称与go的典型camelcase命名兼容。</p><p id="cd6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，创建REST API的工作流是使用go-swagger生成代码存根，并将它们绑定到实现API逻辑的函数，类似于上面所示；这就创建了将作为Lambda函数上传的可执行文件。API网关配置和到Lambda函数的链接可以使用<a class="ae kc" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank"> SAM </a>工具来完成，如<a class="ae kc" href="https://github.com/seanrmurphy/lambda-swagger-test" rel="noopener ugc nofollow" target="_blank"> github repo </a>中所示——这提供了一种链接API定义(在Swagger文件中)、API网关配置和Lambda函数的直接方式。当然，基于例如<a class="ae kc" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank">云形成</a>的其他解决方案也可以用于此。</p><p id="7949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">请求验证</strong></p><p id="bcc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以这种方式使用这些技术导致了一些功能重复的问题:go-swagger自动生成的代码和API网关都执行请求验证。在go-swagger的情况下，当将数据映射到已定义的数据模型时，总是执行请求验证，如果请求不符合预期，就会产生错误；在API网关的情况下，它是可以启用的可选功能。</p><p id="4607" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API网关请求验证提供了两个基本功能:参数验证(主要确保查询参数存在)和请求主体验证(可用于确保HTTP请求的主体与特定的数据模型一致)；在Swagger上下文中，这个数据模型通常在Swagger文件中定义。这种验证可以通过AWS对Swagger文件的特定扩展来触发，如下面的代码片段所示。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="3be4" class="mb mc iq ls b gy md me l mf mg">swagger: '2.0'<br/># define two validators - basic and params-only<br/><strong class="ls ir">x-amazon-apigateway-request-validators:<br/>  basic:<br/>    validateRequestBody: true<br/>    validateRequestParameters: true<br/>  params-only:<br/>    validateRequestBody: false<br/>    validateRequestParameters: true<br/># default is no validation<br/>x-amazon-apigateway-request-validator: NONE</strong></span><span id="b67e" class="mb mc iq ls b gy mh me l mf mg">paths:<br/>  /query-param/simple-response:<br/>    get:<br/>      produces:<br/>      - application/json<br/>      <strong class="ls ir">x-amazon-apigateway-request-validator: params-only</strong><br/>      parameters:<br/>      - in: query<br/>        name: query-param<br/>        type: integer<br/>        required: true</span><span id="9cd5" class="mb mc iq ls b gy mh me l mf mg">  /body-param/simple-response:<br/>    post:<br/>      produces:<br/>      - application/json<br/>      consumes:<br/>      - application/json<br/><strong class="ls ir">      x-amazon-apigateway-request-validator: basic</strong><br/>      parameters:<br/>      - in: body<br/>        name: bodyParam<br/>        schema:<br/>          $ref: '#/definitions/InputObject'<br/>        required: true</span></pre><p id="304b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，默认情况下没有验证——<code class="fe lp lq lr ls b">NONE</code>验证器，但是可以执行<code class="fe lp lq lr ls b">params-only </code>或<code class="fe lp lq lr ls b">body</code>验证，前者验证请求查询参数，后者验证主体内容。</p><p id="a7b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用API网关的请求验证功能的好处是，它可以减少Lambda函数调用的数量，因为无效的REST API调用可以被API网关本身阻止；最终，这可以降低成本。还值得注意的是，在API网关中发生的请求验证过程与go-swagger中的这种验证之间存在一些小的差异:go-swagger中失败的验证返回一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422" rel="noopener ugc nofollow" target="_blank"> HTTP 422(不可处理的实体)</a>，而API网关生成的验证返回<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400" rel="noopener ugc nofollow" target="_blank"> HTTP 400(错误请求)</a>；此外，API Gateway执行更轻量级的参数验证，只检查它们是否存在，而go-swagger执行适当的基于类型的验证。</p><p id="3552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多细节请见本<a class="ae kc" href="https://github.com/seanrmurphy/lambda-swagger-test" rel="noopener ugc nofollow" target="_blank"> github repo </a>。</p></div></div>    
</body>
</html>