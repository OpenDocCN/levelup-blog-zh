<html>
<head>
<title>Flutter: Dart Immutable Objects and Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter: Dart不可变对象和值</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-dart-immutable-objects-and-values-5e321c4c654e?source=collection_archive---------3-----------------------#2020-06-11">https://levelup.gitconnected.com/flutter-dart-immutable-objects-and-values-5e321c4c654e?source=collection_archive---------3-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0e078701c90299c9dc27ee1a0da6a262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hr_vDm8q18wSdYzJs6_AGA.png"/></div></div></figure><div class=""/><p id="e5df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开始开发Flutter apps的时候，我也是人生第一次遇到Dart语言。我非常惊讶地注意到，Flutter团队选择了一种开箱即用的不支持不变性的语言。我仍然认为这很奇怪，特别是如果你将它与深深植根于值类型的Swift UI相比较。</p><p id="e491" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们探索我们的替代方案。</p><h2 id="879e" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">天真的不变性</h2><p id="91b0" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">首先，让我们看看Dart(当前版本是2.8)提供了哪些现成的东西。</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><ul class=""><li id="ac6a" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae mn" href="https://api.flutter.dev/flutter/meta/immutable-constant.html" rel="noopener ugc nofollow" target="_blank">@immutable</a></code> <a class="ae mn" href="https://api.flutter.dev/flutter/meta/immutable-constant.html" rel="noopener ugc nofollow" target="_blank">标注</a>说<code class="fe mj mk ml mm b">Person</code>(及其子类)里面的每个字段都必须是<code class="fe mj mk ml mm b">final</code>。否则，Dart编译器会抛出一个警告，但<strong class="ka jc">不会</strong>出错。</li><li id="ef41" class="ma mb jb ka b kb mo kf mp kj mq kn mr kr ms kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae mn" href="https://dart.dev/guides/language/language-tour#final-and-const" rel="noopener ugc nofollow" target="_blank">final</a></code> <a class="ae mn" href="https://dart.dev/guides/language/language-tour#final-and-const" rel="noopener ugc nofollow" target="_blank">关键字</a>表示您不能在属性初始化后为其赋值。否则，Dart编译器将发出错误。</li><li id="4c4d" class="ma mb jb ka b kb mo kf mp kj mq kn mr kr ms kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b"><a class="ae mn" href="https://api.dart.dev/stable/2.8.4/dart-collection/UnmodifiableListView-class.html" rel="noopener ugc nofollow" target="_blank">UnmodifiableListView</a></code>是一个<code class="fe mj mk ml mm b">List</code>包装器，禁止修改(例如:添加或删除项目)。它公开了像<code class="fe mj mk ml mm b">add()</code>或<code class="fe mj mk ml mm b">addAll()</code>这样的方法，但是它们在运行时抛出异常。</li></ul><p id="ab99" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，但是它完全没有满足编译时的安全需求，并且你没有任何你期望从<a class="ae mn" href="https://kotlinlang.org/docs/reference/data-classes.html" rel="noopener ugc nofollow" target="_blank">数据类</a>中得到的方法(比如相等、散列和克隆)。</p><h2 id="e971" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">源生成</h2><p id="0bf2" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">谷歌自己提出了一个帮助:它被称为<code class="fe mj mk ml mm b"><a class="ae mn" href="https://github.com/google/built_value.dart" rel="noopener ugc nofollow" target="_blank">built_value</a></code>。您定义一个类描述，然后源生成器在一个成对的文件中创建缺少的部分。</p><p id="fa23" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样的想法被另一个Dart包<code class="fe mj mk ml mm b"><a class="ae mn" href="https://github.com/rrousselGit/freezed" rel="noopener ugc nofollow" target="_blank">freezed</a></code>借用，它使用更现代的语法来实现类似的结果。通过在<code class="fe mj mk ml mm b">pubspec.yaml</code>文件中插入一个依赖项来安装它:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="1156" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用的是<code class="fe mj mk ml mm b">any</code>版本，因为这个包没有公开一个可能随时间变化的功能，所以保持最新版本是可以的。</p><p id="cf5e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您可以打开一个终端窗口，并且可以执行:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="7cd5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">build_runner</code>会观察文件系统，每次保存定义时都会生成正确的代码。</p><h2 id="b3b3" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">基本用法</h2><p id="ae8f" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">让我们把<code class="fe mj mk ml mm b">Person</code>转换成<code class="fe mj mk ml mm b">freezed</code>:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><ul class=""><li id="fd96" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">第一行对<code class="fe mj mk ml mm b">build_runner</code>说配对文件是<code class="fe mj mk ml mm b">person.freezed.dart</code>。此名称无法更改。</li><li id="e2ce" class="ma mb jb ka b kb mo kf mp kj mq kn mr kr ms kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b">@freezed</code>注释告诉我们，下面的数据类声明必须由库合成。</li><li id="b56a" class="ma mb jb ka b kb mo kf mp kj mq kn mr kr ms kv mf mg mh mi bi translated">工厂初始值设定项还指定了由该值类型声明的属性。</li><li id="f19c" class="ma mb jb ka b kb mo kf mp kj mq kn mr kr ms kv mf mg mh mi bi translated">请注意<code class="fe mj mk ml mm b">freezed</code>已经准备好管理即将发布的Dart 2.9中引入的可空类型。此时，它只在运行时检查空值。在这种情况下，只有<code class="fe mj mk ml mm b">jobTitle</code>属性是可空的。</li><li id="992b" class="ma mb jb ka b kb mo kf mp kj mq kn mr kr ms kv mf mg mh mi bi translated">如果您需要为非必需的属性提供默认值，您必须使用<code class="fe mj mk ml mm b">@Default</code>注释。</li></ul><p id="d878" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你免费得到了什么？</p><ul class=""><li id="9dbf" class="ma mb jb ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b">toString</code>被覆盖以提供要打印的对象的漂亮描述。</li><li id="375a" class="ma mb jb ka b kb mo kf mp kj mq kn mr kr ms kv mf mg mh mi bi translated"><code class="fe mj mk ml mm b">==</code>运算符逐个属性地比较对象。</li></ul><h2 id="a478" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">复印</h2><p id="c78e" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated"><code class="fe mj mk ml mm b">copyWith</code>方法返回具有更新属性的新实例:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9056" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果要复制嵌套层次结构，可以使用简单的链式语法:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0d26" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以如果<code class="fe mj mk ml mm b">p1</code>有一个最好的朋友，那么<code class="fe mj mk ml mm b">p2</code>将包含一个带有新的最好的朋友的父亲名字和姓氏的<code class="fe mj mk ml mm b">p1</code>的副本。</p><h2 id="45b2" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">自定义方法和属性</h2><p id="39f9" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">如果需要添加自定义方法，就不能再使用简化的mixin语法了:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0d77" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还可以添加自定义getters，甚至用<code class="fe mj mk ml mm b">@late</code>注释，相当于Swift的<code class="fe mj mk ml mm b">lazy</code>或者Kotlin的<code class="fe mj mk ml mm b">lateinit</code>:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated"><code class="fe mj mk ml mm b">`late`</code>将很快成为官方Dart关键词。</figcaption></figure><h2 id="865c" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">密封类</h2><p id="171e" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在Swift和Kotlin世界中，强大的枚举很受欢迎，我非常想念它们。你可以这样写美女:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="aa91" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然你不能用<code class="fe mj mk ml mm b">switch</code>执行模式匹配，但是有像<code class="fe mj mk ml mm b">when</code>或<code class="fe mj mk ml mm b">maybeWhen</code>这样的方法，<code class="fe mj mk ml mm b">freezed</code>会为你合成:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="e282" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">不可变集合</h2><p id="a3f2" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">集合的编译时安全性如何？<code class="fe mj mk ml mm b">freezed</code>没有缓解这个问题，而<code class="fe mj mk ml mm b">built_value</code>有一个名为<code class="fe mj mk ml mm b">build_collection</code>的孪生包，它公开了不可变列表、字典和集合。这些符合<code class="fe mj mk ml mm b">Iterable</code>，所以它们与官方Dart系列非常兼容。</p><p id="5290" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我想再大胆一点用<code class="fe mj mk ml mm b"><a class="ae mn" href="https://github.com/passsy/kt.dart" rel="noopener ugc nofollow" target="_blank">kt_dart</a></code> <a class="ae mn" href="https://github.com/passsy/kt.dart" rel="noopener ugc nofollow" target="_blank">包</a>，一个包含不可变集合和其他好处的<code class="fe mj mk ml mm b">kotlin-stdlib</code>端口，像列表的深度比较和没有外来名字的<code class="fe mj mk ml mm b">map</code> / <code class="fe mj mk ml mm b">filter</code> / <code class="fe mj mk ml mm b">reduce</code>。通过在<code class="fe mj mk ml mm b">pubspec.yaml</code>中插入一个新的依赖项来安装它:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5260" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以修改<code class="fe mj mk ml mm b">Person</code>数据类只是改变类型:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="addb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，<code class="fe mj mk ml mm b">friends</code>列表现在是不可变的。列表的创建比以前更容易:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="2221" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您想创建一个方法来生成一个新的不可变的人和一个新朋友，这很简单:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0b8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只是注意:由于<code class="fe mj mk ml mm b">KtList</code>不符合<code class="fe mj mk ml mm b">Iterable</code>，所以不能直接使用<em class="mx">进行</em>循环，而应该在之前取迭代器:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="bd22" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">VS代码集成</h2><p id="802e" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">由于样板代码可能会很乏味，很难记住，也许通过选择<em class="mx">首选项:在VS代码启动中配置用户片段</em>，然后选择<em class="mx"> Dart </em>语言来设置一些用户片段会很方便。现在，您可以复制并粘贴以下代码片段:</p><figure class="lu lv lw lx gt is"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0100" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以从<em class="mx">浏览器</em>选项卡中排除生成的文件。为此，打开<em class="mx">设置</em>并搜索<em class="mx">文件:排除</em>首选项。然后，您可以将此模式添加到列表中:<code class="fe mj mk ml mm b">**/*.freezed.dart</code>。</p><h2 id="e3c0" class="kw kx jb bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">JSON序列化和反序列化</h2><p id="c5a7" class="pw-post-body-paragraph jy jz jb ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated"><code class="fe mj mk ml mm b">freezed</code>通过设计与<code class="fe mj mk ml mm b">json_serializable</code>包集成，但使用<code class="fe mj mk ml mm b">kt_dart</code>会有一些不明显的挑战:我在后续的<a class="ae mn" href="https://medium.com/@muccy/flutter-dart-immutable-objects-json-serialization-and-deserialization-dff917b1af2" rel="noopener">中深入讨论了这个话题。</a></p></div></div>    
</body>
</html>