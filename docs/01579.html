<html>
<head>
<title>JavaScript has a Reduce Method. You Should Use It.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript有一个Reduce方法。你应该使用它。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-has-a-reduce-method-you-should-use-it-ff4dd29d6c9d?source=collection_archive---------4-----------------------#2020-01-14">https://levelup.gitconnected.com/javascript-has-a-reduce-method-you-should-use-it-ff4dd29d6c9d?source=collection_archive---------4-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fb4e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习基础知识，然后跳过它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2d85e992ccd0acca3f57d6161e05b107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlQb2zNSkYebG-mcpTxD3g.png"/></div></div></figure><p id="50a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个人都喜欢JavaScript的<code class="fe lq lr ls lt b">.map</code>、<code class="fe lq lr ls lt b">.forEach</code>、<code class="fe lq lr ls lt b">.filter</code>迭代方法，但是经常被忽略的<code class="fe lq lr ls lt b">.reduce</code>呢？我认为人们从来没有真正适应过它，所以他们忽略了它。先说说它到底是怎么运作的，然后用它做点有趣的事情。</p><h1 id="97b9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">减少一组值</h1><p id="c985" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">之所以称之为reduce，是因为它将把一个包含多个值的数组简化为一个值。</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="3960" class="mv lv it lt b gy mw mx l my mz"><strong class="lt iu">total</strong>([1,2,3,4]); // 10</span></pre><p id="b24b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们<em class="na">能不能</em>只和<code class="fe lq lr ls lt b">.forEach</code>循环一次就完事了:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="c8eb" class="mv lv it lt b gy mw mx l my mz"><em class="na">const</em> <strong class="lt iu">total</strong> = (<strong class="lt iu">arr</strong>) =&gt; {<br/>  <em class="na">let</em> <strong class="lt iu">result</strong> = 0;<br/>  <strong class="lt iu">arr</strong>.forEach(<strong class="lt iu">num</strong> =&gt; { <strong class="lt iu">result</strong> += <strong class="lt iu">num </strong>});<br/>  <em class="na">return</em> <strong class="lt iu">result</strong>;<br/>};</span></pre><p id="609f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这似乎有点多，对不对？我们正在创建一个值，操作它，然后立即返回它。所有这些动作都阻止我们使用arrow函数的隐式返回值。让我们<em class="na">减少</em>的步骤:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="0874" class="mv lv it lt b gy mw mx l my mz"><em class="na">const</em> <strong class="lt iu">total</strong> = (<strong class="lt iu">arr</strong>) =&gt; <strong class="lt iu">arr</strong>.reduce((<strong class="lt iu">result</strong>, <strong class="lt iu">num</strong>) =&gt; <strong class="lt iu">result</strong> + <strong class="lt iu">num</strong>, 0);</span></pre><p id="9df2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p><h1 id="1cbc" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">崩溃了。减少</h1><p id="d42e" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated"><code class="fe lq lr ls lt b">reduce</code>方法本身有两个参数，即<code class="fe lq lr ls lt b">callback</code>和<code class="fe lq lr ls lt b">startingValue</code>。那个<code class="fe lq lr ls lt b">callback</code>有两个主要参数，即<code class="fe lq lr ls lt b">accumulator</code>和<code class="fe lq lr ls lt b">nextValue</code>:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="2903" class="mv lv it lt b gy mw mx l my mz">// reduce's arguments<br/>.reduce(<strong class="lt iu">reducerCallback</strong>, <strong class="lt iu">startingValue</strong>)</span><span id="4d71" class="mv lv it lt b gy nb mx l my mz">// callback's arguments<br/>reducerCallback(<strong class="lt iu">accumulator</strong>, <strong class="lt iu">nextValue</strong>)</span></pre><p id="5a18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是前一个单独回调的例子:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="feb5" class="mv lv it lt b gy mw mx l my mz"><em class="na">const</em> <strong class="lt iu">reducerCallback </strong>= (<strong class="lt iu">accumulator</strong>, <strong class="lt iu">nextValue</strong>) =&gt; {<br/>   <em class="na">return</em> <strong class="lt iu">accumulator</strong> + <strong class="lt iu">nextValue;</strong><br/>};<br/><em class="na">const</em> <strong class="lt iu">total</strong> = (<strong class="lt iu">arr</strong>) =&gt; <strong class="lt iu">arr</strong>.reduce(<strong class="lt iu">reducerCallback</strong>, 0);</span></pre><h1 id="a429" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">了解回拨</h1><p id="6166" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">基本上，它将<code class="fe lq lr ls lt b">accumulator</code>设置为给定的<code class="fe lq lr ls lt b">startingValue</code>，然后遍历数组，索引处的每个<strong class="kw iu">值</strong>成为<code class="fe lq lr ls lt b">nextValue</code>参数。无论回调函数返回什么，都将成为下一次迭代开始的<code class="fe lq lr ls lt b">accumulator</code>。在数组完全运行之后，<code class="fe lq lr ls lt b">reduce</code>方法返回最终的<code class="fe lq lr ls lt b">accumulator</code>值。</p><p id="b722" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="na">有可能</em>不给<code class="fe lq lr ls lt b">startingValue</code>给<code class="fe lq lr ls lt b">reduce</code>；它将简单地使用数组中的第一个值作为<code class="fe lq lr ls lt b">accumulator</code>(第二个值作为第一个<code class="fe lq lr ls lt b">nextValue</code>)。然而，如果给定一个空数组，给一个起始值可以防止<code class="fe lq lr ls lt b">reduce</code>抛出错误。文档很好地说明了所有这些值(并告诉你另外两个可选参数)。</p><h1 id="4f77" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">有趣的是</h1><p id="9505" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">没有说我们必须用数字。当我们遍历一个数组时，<code class="fe lq lr ls lt b">reduce</code>所做的就是给我们一个连续的值来操作。<strong class="kw iu"> <em class="na">这就是</em> </strong>这个方法的威力来自哪里。那么，如果起始值是<code class="fe lq lr ls lt b">{}</code>呢？</p><h1 id="6c2c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">制作我们自己的计数函数</h1><p id="83c0" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">有时您想要计算列表中出现的所有次数:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="06e2" class="mv lv it lt b gy mw mx l my mz">const <strong class="lt iu">arr</strong> = ['x', 'y', 'z', 'z'];<br/>// I want: { x: 1, y: 1, z: 2 };</span></pre><p id="6ccb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同<code class="fe lq lr ls lt b">forEach</code>:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="fee8" class="mv lv it lt b gy mw mx l my mz"><em class="na">const</em> <strong class="lt iu">counts</strong> = (<strong class="lt iu">arr</strong>) =&gt; {<br/>  <em class="na">const</em> <strong class="lt iu">result</strong> = {};<br/>  <strong class="lt iu">arr</strong>.forEach((<strong class="lt iu">item</strong>) =&gt; {<br/>    <strong class="lt iu">result</strong>[<strong class="lt iu">item</strong>] ? <strong class="lt iu">result</strong>[item]++ : <strong class="lt iu">result</strong>[item] = 1;<br/>  });<br/>  <em class="na">return</em> <strong class="lt iu">result</strong>;<br/>};</span></pre><p id="03ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们正在做的是检查我们的字母的键是否有值。如果是这样，那么我们对那个值加1。如果不是，那么我们保存值为1的键。但是，这与前面的模式相同:<em class="na">创建</em>对象，<em class="na">操作</em>对象，<em class="na">返回</em>对象。请留意这种模式，因为<code class="fe lq lr ls lt b">reduce</code>运行得非常完美:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="fa34" class="mv lv it lt b gy mw mx l my mz"><em class="na">const</em> <strong class="lt iu">counts</strong> = (<strong class="lt iu">arr</strong>) =&gt; <strong class="lt iu">arr</strong>.reduce((<strong class="lt iu">result</strong>, <strong class="lt iu">item</strong>) =&gt; {<br/>  <strong class="lt iu">result</strong>[<strong class="lt iu">item</strong>] ? <strong class="lt iu">result</strong>[<strong class="lt iu">item</strong>] += 1 : <strong class="lt iu">result</strong>[<strong class="lt iu">item</strong>] = 1<br/>  <em class="na">return</em> <strong class="lt iu">result</strong>;<br/>}, {} )</span></pre><h1 id="df24" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">分解我们的计数函数</h1><p id="0dbd" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">事情并没有像他们简化的那样改变太多。我们使用相同的<a class="ae nc" href="https://itnext.io/whats-a-javascript-ternary-5edf4415a09d" rel="noopener ugc nofollow" target="_blank">三元组</a>来填充我们的<code class="fe lq lr ls lt b">result</code>对象，但是这次我们不需要浪费空间来声明变量，因为我们有累加器参数。然后，我们只需返回我们的累加器<code class="fe lq lr ls lt b">result</code>对象。我们<em class="na">总是</em>必须返回对象，因为<strong class="kw iu">回调的返回值是在下一次调用中赋予累加器的值。</strong></p><p id="6ea4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的是，看看这个<a class="ae nc" href="https://en.wikipedia.org/wiki/Code_golf" rel="noopener ugc nofollow" target="_blank"> code golf </a>片段，它在一行中完成了所有工作:</p><pre class="kj kk kl km gt mr lt ms mt aw mu bi"><span id="e696" class="mv lv it lt b gy mw mx l my mz"><em class="na">const</em> <strong class="lt iu">count</strong> = (<strong class="lt iu">arr</strong>) =&gt; <strong class="lt iu">arr</strong>.reduce((<strong class="lt iu">acc</strong>, <strong class="lt iu">val</strong>) =&gt; {<br/>  <em class="na">return</em> { ...<strong class="lt iu">acc</strong>, [<strong class="lt iu">val</strong>]: <strong class="lt iu">acc</strong>[<strong class="lt iu">val</strong>] ? <strong class="lt iu">acc</strong>[<strong class="lt iu">val</strong>] + 1 : 1 };<br/>}, {})</span></pre><h1 id="5441" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">Reduce是一个有用的工具</h1><p id="d55f" class="pw-post-body-paragraph ku kv it kw b kx mm ju kz la mn jx lc ld mo lf lg lh mp lj lk ll mq ln lo lp im bi translated">使用循环或者其他迭代器没有错，我的观点是，<code class="fe lq lr ls lt b">reduce</code>不值得被忽略。如果你需要找一个总数，它是量身定做的。如果你发现<strong class="kw iu"> <em class="na">创造、操纵、返回</em> </strong>模式，这可能是展示<code class="fe lq lr ls lt b">reduce</code>如何足智多谋的绝佳机会。</p><p id="5266" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="598a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>