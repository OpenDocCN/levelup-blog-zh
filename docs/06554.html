<html>
<head>
<title>The Beginners Guide to Elasticsearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性研究初学者指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-beginners-guide-to-elasticsearch-8fc237fc3209?source=collection_archive---------4-----------------------#2020-12-06">https://levelup.gitconnected.com/the-beginners-guide-to-elasticsearch-8fc237fc3209?source=collection_archive---------4-----------------------#2020-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a03" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个强大的分析型搜索引擎的概念分解。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/341a8a94c131f88dcf5b59dcc172a606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a75ztDiDQX1fhNKE"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elasticsearch是一个分布式、可扩展的分析搜索引擎，支持非结构化数据的复杂聚合。</p><p id="1c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">与NoSQL数据商店类似，Elasticsearch旨在处理非结构化数据格式，并动态确定字段的数据类型。</strong>它的主要数据格式是JSON <em class="lv"> (Javascript对象表示法)</em>文档。JSON的无模式格式允许灵活的数据存储，并且无需管理或创建关系就能轻松添加数据。</p><p id="8ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Elasticsearch不一定能与NoSQL数据库互换。<strong class="lb iu"> Elasticsearch不同于NoSQL数据库，有其自身的局限性。</strong>比如Elasticsearch分布式系统，在执行交易时增加了一层复杂性。尽管进行分布式事务并非不可能，但如果可能的话，最好避免分布式事务，以简化流程。</p><p id="627b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elasticsearch还假设为其实例提供了足够的内存。因此，它不太热衷于处理内存错误。</p><p id="9ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Elasticsearch通常与其他类型的数据库一起作为辅助工具使用。<strong class="lb iu">记住弹性搜索是为速度而生的，这一点很重要。它非常适合搜索和过滤文档。</strong></p><h2 id="3eb2" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">节点和集群。</h2><p id="dc9d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><strong class="lb iu"> Elasticsearch由多个节点<em class="lv">(也称为Elasticsearch实例)</em>组成，一组连接的节点称为一个集群。</strong>集群中的所有节点都知道同一集群中的其他节点。集群中的每个节点都可以通过HTTP请求执行CRUD操作<em class="lv"> (POST、GET、PUT、DELETE) </em>。该模型允许节点将客户端请求转移到能够满足请求的其他节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/f9ac7e329fa9adeb75945ee06a349be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s51gp1IMLoTpsDHfGUimGg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">1个集群，3个节点(es实例)，5个碎片</figcaption></figure><h2 id="fc9d" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">索引和碎片</h2><p id="cdbe" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">索引有时被误解为关系数据库索引。然而，理解其中的区别是至关重要的。<strong class="lb iu">弹性搜索索引是碎片的集合，文档均匀分布在碎片中。</strong>如果没有指定，那么默认情况下，在Elasticsearch v.7.0之前，Elasticsearch为每个索引分配五个主碎片。该模型如上图所示。<strong class="lb iu">但是在Elasticsearch v.7.0+中，默认为每个索引创建一个碎片。</strong></p><p id="71ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以将<code class="fe mv mw mx my b">products</code>定义为一个索引。在该索引中，存在不同的产品文档，如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="4b32" class="lw lx it my b gy nd ne l nf ng">[{<br/> "title": "Apple MacBook Pro 13-Inch 'Core i7' 2.4",<br/> "price": "$2559",<br/> "sku": "123SampleBLK20",<br/> "itemCondition": "New",<br/> "availability": "IN_STOCK",<br/>},<br/>{<br/> "title": "Apple iPad Pro 12.9 (Wi-Fi Only - 4th Gen) 128GB",<br/> "price": "$699",<br/> "sku": "123SampleBLK21",<br/> "itemCondition": "Used",<br/> "availability": "IN_STOCK",<br/>},<br/>{<br/> "title": "Samsung Galaxy S20 - 128GB",<br/> "price": "$1199",<br/> "sku": "123SampleBLK22",<br/> "itemCondition": "New",<br/> "availability": "OUT_OF_STOCK",<br/>}]</span></pre><p id="6641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当文档被添加到索引中时，Elasticsearch将决定哪个碎片将保存该文档。<strong class="lb iu">碎片均匀分布在集群中的节点上。</strong>如果新的节点被添加到系统中，Elasticsearch将在集群内均匀地重新分配碎片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/e589347c3be1055fccb5b9f653e4d2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOQTNHjwiqe7KYj1IZ5cYw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">请注意，集群中添加了一个额外的节点，现在碎片均匀地重新分布。</figcaption></figure><h2 id="ea86" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">复制品</h2><p id="14ef" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">副本是碎片的一种，只是它们用于提高搜索性能，并作为主碎片的备份。<strong class="lb iu">每个索引都有一个副本。</strong></p><p id="72d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">副本碎片是一种可靠的故障转移，因为它们从不与它们正在复制的碎片分配在同一个节点上。如果你熟悉RAID <em class="lv">(独立磁盘冗余阵列)</em>，那么副本碎片听起来应该有些相似。数据被镜像到一个冗余磁盘上，或者在这种情况下，被镜像到shard上。因为碎片在一个单独的节点上，如果包含主碎片的节点出现故障，那么副本仍然可用。并且具有副本和主碎片的节点同时发生故障的风险相对较低。</p><h2 id="a09e" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">澄清“关系数据库”的类比</h2><p id="ae32" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">Elasticsearch理解起来可能有点复杂。这种混乱主要是由于Elasticsearch团队用来描述这些概念的不准确的类比。此后，Elasticsearch团队试图纠正这一误解。</p><p id="9e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">互联网上的大多数资源都将索引与一个单独的关系数据库相比较。现在，您可能会想，<em class="lv">“索引不是更像一个表而不是一个数据库吗？”</em></p><p id="b9d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你说得对。它确实看起来像一张桌子。然而，在Elasticsearch v.6之前，曾经有过映射<strong class="lb iu">类型</strong>的概念。类型表示索引中文档的类型。例如，如果"<em class="lv"> twitter" </em>是一个索引，那么可以描述两种类型的<em class="lv"> "twitter" </em>文档:"<em class="lv">tweet "</em><strong class="lb iu"><em class="lv"/></strong>和<em class="lv">"用户。"类型有很多问题，我不会在本文中深入探讨，但本质上，类型模拟关系数据库表。</em></p><p id="6ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的建议是不要与关系数据库建立联系。它会迷惑你，就像它迷惑我一样。</p><h1 id="c475" class="nh lx it bd ly ni nj nk mb nl nm nn me jz no ka mh kc np kd mk kf nq kg mn nr bi translated">安装和入门。</h1><p id="0acd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated"><strong class="lb iu">如前所述，与Elasticsearch交互的主要方式是通过HTTP请求(RESTFUL APIs)。</strong>在这一节中，我们将回顾一些索引到Elasticsearch实例的基本方法，以帮助您入门。</p><p id="1dab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始使用Elasticsearch，安装Docker并创建一个目录<code class="fe mv mw mx my b">data/elasticsearch</code>。然后运行下面的docker命令下载Elasticsearch Docker映像并启动容器。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="cb46" class="lw lx it my b gy nd ne l nf ng">docker run --restart=always -d --name elasticsearch \\<br/>    -e "discovery.type=single-node"  \\<br/>    -v ~/data/elasticsearch:/usr/share/elasticsearch/data \\<br/>    -p 9200:9200 \\<br/>    -p 9300:9300 \\<br/>    docker.elastic.co/elasticsearch/elasticsearch:7.9.2</span></pre><p id="2850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以通过<code class="fe mv mw mx my b"><a class="ae ky" href="http://localhost:9200" rel="noopener ugc nofollow" target="_blank">http://localhost:9200</a></code>访问所有的Elasticsearch API</p><h2 id="3ff9" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">创建新索引</h2><p id="6747" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">您可以通过两种方式之一创建文档，通过PUT请求或POST请求。由于我将使用Elasticsearch v.7，我将避免类型的话题。我们将坚持使用Elasticsearch默认类型<code class="fe mv mw mx my b">_doc</code>。并处理索引和文档。</p><p id="18e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个空索引，如下所示:</p><p id="f37e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">PUT <a class="ae ky" href="http://localhost:9200" rel="noopener ugc nofollow" target="_blank">http://localhost:9200</a>/products</code></p><p id="2d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以通过在所需的索引名称下插入文档来创建索引，如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="5f6e" class="lw lx it my b gy nd ne l nf ng">POST: <a class="ae ky" href="http://localhost:9200/product/_doc/" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/product/_doc/</a></span><span id="b19c" class="lw lx it my b gy ns ne l nf ng">{<br/> "title": "Apple MacBook Pro 13-Inch 'Core i7' 2.4",<br/> "price": "$2559",<br/> "sku": "123SampleBLK20",<br/> "itemCondition": "New",<br/> "availability": "IN_STOCK",<br/>}</span></pre><p id="549b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述请求将产生以下响应:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="d41b" class="lw lx it my b gy nd ne l nf ng">{</span><span id="c2e3" class="lw lx it my b gy ns ne l nf ng">  "_index": "product",<br/>  "_type": "_doc",<br/>  "_id": "xUs3MHYBPq6LuxBgrCHN",<br/>  "_version": 1,<br/>  "result": "created",<br/>  "_shards": {<br/>    "total": 2,<br/>    "successful": 1,<br/>    "failed": 0<br/>},<br/>  "_seq_no": 6,<br/>  "_primary_term": 1<br/>}</span></pre><p id="1628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的响应为插入的文档随机生成一个标识符<code class="fe mv mw mx my b">_id</code>。但是，如果要指定标识符，请将POST请求更改为PUT请求，并将标识符添加到请求的末尾，如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="5679" class="lw lx it my b gy nd ne l nf ng">PUT: <a class="ae ky" href="http://localhost:9200/product/_doc/" rel="noopener ugc nofollow" target="_blank">http://localhost:9200/product/_doc/</a>1</span></pre><p id="9933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到响应，注意总共有两个片段，其中一个成功了。这个响应告诉我们，数据是从总共两个活动碎片<em class="lv">(其中一个是副本碎片)</em>中的一个碎片获取的。</p><p id="c119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过执行CAT <em class="lv">(压缩和对齐文本)</em> API调用来验证碎片的数量，如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="be39" class="lw lx it my b gy nd ne l nf ng">GET http://localhost:9200/_cat/shards/product</span></pre><p id="0f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卡特彼勒API请求是关于我们的Elasticsearch集群的统计查询。我们可以查询节点、分片、索引、模板和其他弹性搜索功能。</p><p id="cb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述请求的结果产生了以下内容:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="6beb" class="lw lx it my b gy nd ne l nf ng">product 0 p STARTED    4 7kb 1xx.xx.x.x a6ffefa157e8<br/>product 0 r UNASSIGNED</span></pre><p id="0b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个响应告诉我们，在索引<code class="fe mv mw mx my b">product</code>处，被标识的碎片<em class="lv">(在本例中，它们都被标记为0) </em>要么是副本<em class="lv"> r </em>要么是主<em class="lv"> p，</em>，并且它的状态为<em class="lv">开始</em>或<em class="lv">未分配。</em>它还告诉我们碎片中的文档数量、磁盘大小、IP地址和节点id。</p><p id="8846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得卡特彼勒API请求的完整列表，我们可以发出以下请求:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="61fb" class="lw lx it my b gy nd ne l nf ng">GET http://localhost:9200/_cat/</span></pre><p id="9eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议把这个请求放在身边。在你学习的时候很方便。</p><h2 id="3d85" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">搜索索引</h2><p id="9db7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">Elasticsearch庞大的搜索能力是不可能用几段话概括的。我将提供两个基础知识来帮助您入门:<em class="lv"> </em> <strong class="lb iu">获取索引中的所有文档，并按其标识符获取文档。我将在另一篇文章中讨论更复杂和有趣的搜索查询。</strong></p><p id="3bef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过以下请求来请求索引中的所有文档:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="aec1" class="lw lx it my b gy nd ne l nf ng">GET http://localhost:9200/product/_search</span></pre><p id="e186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，默认情况下，Elasticsearch一次只会返回10个文档。但是我们可以通过指定查询字符串<code class="fe mv mw mx my b">size</code>来增加这个限制，如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="7fc3" class="lw lx it my b gy nd ne l nf ng">GET http://localhost:9200/product/_search?size=100</span></pre><p id="6d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过标识符获取单个文档与添加文档一样简单，只是我们将POST请求改为GET请求，如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="42d6" class="lw lx it my b gy nd ne l nf ng">GET http://localhost:9200/product_entity/_doc/1</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h2 id="5fee" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">最后的想法</h2><p id="fa9e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">Elasticsearch是一个强大的分析搜索引擎。然而，操作起来可能非常复杂。</p><p id="d8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我介绍了一些基本概念，以帮助您入门。尽管如此，我还是强烈推荐浏览一下<a class="ae ky" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.9/index.html" rel="noopener ugc nofollow" target="_blank"> Elasticsearch v.7.9或更高版本的文档</a>和<a class="ae ky" href="https://www.elastic.co/blog/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch博客</a>来扩展你的理解。</p></div></div>    
</body>
</html>