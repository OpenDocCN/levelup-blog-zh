<html>
<head>
<title>Generics in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/generics-in-c-e650ccc8551c?source=collection_archive---------10-----------------------#2022-02-24">https://levelup.gitconnected.com/generics-in-c-e650ccc8551c?source=collection_archive---------10-----------------------#2022-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="308c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过创建一个泛型API类来学习泛型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7cf361e270bde2f689fa4b0381995b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jY6N695Qfifu__1owpW1EA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">卡里·谢伊在<a class="ae ky" href="https://unsplash.com/photos/1SAnrIxw5OY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="6a9a" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">问题是</h2><p id="c6ed" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">假设我们正在构建微服务，我们已经创建了一个共享文件夹，因此我们可以为所有现有的微服务创建一个API类，当我们想要在不同的服务之间进行通信时，可以调用该类。请查看下面的示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="55ae" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk lp mz mm mn lt na mp mq lx nb ms mt mu im bi translated">这些可能是每个微服务将拥有的基本API，我们并不真正关心特定于任务的API，因为它们将是特定于微服务的。</p><p id="bf8f" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk lp mz mm mn lt na mp mq lx nb ms mt mu im bi translated">那么如果我们有20个或者更多的微服务会怎么样呢？我们需要编写25-30行代码，唯一的区别是进出的有效负载，以及路由中服务的名称。那种打破干(不重复自己)原则背后的想法。</p><div class="nc nd gp gr ne nf"><a href="https://medium.com/codex/become-a-better-programmer-with-these-software-engineering-principles-204fa93e8094" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">用这些软件工程原则成为更好的程序员</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">干，吻，YAGNI解释道</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="a8c3" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">系统。目标解决方案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f2e9" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk lp mz mm mn lt na mp mq lx nb ms mt mu im bi translated">我们能想到的第一个解决方案是使用C#中的Object类，并想办法使路线中的“客户”动态化。但是我们不会这么做，因为系统。对象在这里不是最优解。它所做的是装箱一个值类型，将它放入一个对象中，并存储在托管堆中。然而，这会导致一些性能问题，并使泛型更快更好地使用，所以让我们看看如何用它们来解决我们的问题。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="7262" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是泛型</h2><p id="9c30" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated"><em class="nu"> Generic </em> <strong class="me iu"> <em class="nu"> </em> </strong>是一个允许用户用占位符定义类和方法的类。使用泛型背后的思想是允许类型作为方法、类和接口的参数。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="e84b" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用泛型的解决方案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9638" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk lp mz mm mn lt na mp mq lx nb ms mt mu im bi translated">这就是我们的<em class="nu"> BaseApi </em>类的样子，我们现在需要做的就是重构我们的<em class="nu"> CustomerAPI </em>来实现我们的新类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="55be" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk lp mz mm mn lt na mp mq lx nb ms mt mu im bi translated">正如你在第一行看到的，我们正在指定我们想要被传递的类型，它们对于你拥有的其他服务可以是不同的(OrderPayload，AddressPayload等)。).在构造函数中，我们还传递控制器名称，这样我们就知道我们调用的是哪个微服务，我们可以删除以前在<em class="nu"> CustomerApi中的所有CRUD APIs。</em></p><p id="0d9d" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk lp mz mm mn lt na mp mq lx nb ms mt mu im bi translated">现在，我们可以调用任何我们想要的微服务，并简单地调用我们的<em class="nu"> BaseApi </em>中的任何函数，而不必编写许多行可重复的代码。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="3a81" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h2><p id="fa74" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">泛型是C#中最强大的特性之一。它们允许您定义类型安全的数据结构。这将带来更好性能和更高的代码质量，因为它有助于重用代码。它们也比<em class="nu">系统要好。Object </em>选项，因为它们不会给我们带来性能损失，而且是. NET开发人员必须了解。</p></div></div>    
</body>
</html>