<html>
<head>
<title>Understanding Dependency Injection in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Android中的依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-dependency-injection-in-android-af1bb2b7984e?source=collection_archive---------2-----------------------#2019-11-05">https://levelup.gitconnected.com/understanding-dependency-injection-in-android-af1bb2b7984e?source=collection_archive---------2-----------------------#2019-11-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6e2d1c49bfaaf3d33ee04fbf33b6a6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D74TxQG6QL8DAKWTlNCWIw.png"/></div></div></figure><p id="02e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果不提到Dagger，就很难谈论依赖注入。Dagger在Android开发者中越来越受欢迎，但是让我们退一步，讨论一下依赖注入的定义:</p><blockquote class="kw kx ky"><p id="b6ed" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">依赖注入</strong>是一种一个对象提供另一个对象的依赖的技术。</p></blockquote><p id="4536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最简单的方法是通过构造函数注入对象的所有依赖项:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="59b0" class="lm ln iq li b gy lo lp l lq lr">class Car(private val engine: Engine) {<br/><br/>    fun start() {<br/>        engine.turnOn()<br/>    }<br/><br/>    fun stop() {<br/>        engine.turnOff()<br/>    }<br/><br/>    fun isStarted() = engine.isTurnedOn()<br/>}</span></pre><p id="d459" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过这样做，我们将<code class="fe ls lt lu li b">Engine</code>对象的实例化委托给了另一个对象，而不是<code class="fe ls lt lu li b">Car</code>。如果我们改变了<code class="fe ls lt lu li b">Engine</code>类中的<code class="fe ls lt lu li b">turnOn</code>或<code class="fe ls lt lu li b">turnOff</code>方法的实现，我们将改变<code class="fe ls lt lu li b">Car</code>的行为而不改变它的实现。</p><p id="71ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<code class="fe ls lt lu li b">Engine</code>是一个接口，我们甚至可以有完全不同的实现，比如利用多态性的<code class="fe ls lt lu li b">GasEngine</code>或<code class="fe ls lt lu li b">ElectricEngine</code>。它还增强了可测试性，因为可以创建一个<code class="fe ls lt lu li b">FakeEngine</code>实现来测试<code class="fe ls lt lu li b">Car</code>。</p><h1 id="ed98" class="lv ln iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">安卓怎么样？</h1><p id="591e" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">在Android世界中，依赖注入有其局限性。由于Android操作系统控制着<code class="fe ls lt lu li b">Activity</code>、<code class="fe ls lt lu li b">BroadcastReceiver</code>、<code class="fe ls lt lu li b">Service</code>、<code class="fe ls lt lu li b">ContentProvider</code>和<code class="fe ls lt lu li b">Application</code>类的实例化，开发人员无法访问Android组件的构造函数。</p><blockquote class="kw kx ky"><p id="f28f" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated">背后的想法是允许第三方应用程序和系统与您的应用程序<strong class="ka ir">选择导出的Android组件进行交互。</strong></p></blockquote><p id="e1ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个想法伴随着一个开销:进程间通信(IPC)。<code class="fe ls lt lu li b">Binder</code>和<code class="fe ls lt lu li b">Parcel</code>类是为了减轻IPC的负担而创建的，在调用系统服务(如<code class="fe ls lt lu li b">WifiManager</code>或<code class="fe ls lt lu li b">PackageManager</code>)时使用，甚至在您自己的应用程序中与<code class="fe ls lt lu li b">Intents</code>通信时使用。</p><p id="7110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户点击设备主屏幕上的图标时，一个<code class="fe ls lt lu li b">Intent</code>会被发送到相应应用程序的启动器<code class="fe ls lt lu li b">Activity</code>。如果没有正在运行的进程，则创建一个新进程，实例化<code class="fe ls lt lu li b">Application</code>类，调用<code class="fe ls lt lu li b">onCreate</code> <em class="kz"> </em>方法<strong class="ka ir">。之后，启动程序<code class="fe ls lt lu li b">Activity</code>被实例化，它的<code class="fe ls lt lu li b">onCreate</code>方法被调用。对于<code class="fe ls lt lu li b">onReceive</code> <strong class="ka ir"> <em class="kz"> </em> </strong>方法中的<code class="fe ls lt lu li b">BroadcastReceiver</code>、<code class="fe ls lt lu li b">onCreate</code>方法中的<code class="fe ls lt lu li b">Service</code>以及<code class="fe ls lt lu li b">onCreate</code>方法中的<code class="fe ls lt lu li b">ContentProvider</code>，流程相同。</strong></p><p id="9d5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">*有一个与content provider<em class="kz">onCreate</em>方法相关的<a class="ae mx" href="https://issuetracker.google.com/issues/36917845" rel="noopener ugc nofollow" target="_blank">问题在应用程序<em class="kz"> onCreate </em>方法之前被调用。</a><a class="ae mx" href="https://stackoverflow.com/questions/9873669/how-do-i-catch-content-provider-initialize" rel="noopener ugc nofollow" target="_blank">这里的</a>是它的一个变通方法。</p><blockquote class="kw kx ky"><p id="9039" class="jy jz kz ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq"/><code class="fe ls lt lu li b">Application onCreate</code><em class="iq">方法是Android应用程序的入口点，同理</em> <code class="fe ls lt lu li b">static main</code> <em class="iq">方法是Java应用程序的入口点。</em></p></blockquote><h1 id="1ddb" class="lv ln iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">视图状态x模型状态</h1><p id="cdc4" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">假设我们想要使用一个<code class="fe ls lt lu li b">Activity</code>来呈现我们的<code class="fe ls lt lu li b">Car</code>:</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="1a82" class="lm ln iq li b gy lo lp l lq lr">class CarActivity: AppCompatActivity() {<br/><br/>    private lateinit var car: Car<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.<em class="kz">activity_car</em>)<br/>        car = Car(ElectricEngine())<br/>    }<br/>}</span></pre><p id="1457" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<code class="fe ls lt lu li b">CarActivity</code> <strong class="ka ir"> </strong>依赖于<code class="fe ls lt lu li b">Car</code>，但是不能被它的构造函数注入。而是在<code class="fe ls lt lu li b">CarActivity</code> <code class="fe ls lt lu li b">onCreate</code>方法中实例化。</p><p id="1ca7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们不能访问<code class="fe ls lt lu li b">CarActivity</code>的构造函数，我们如何注入<code class="fe ls lt lu li b">Car</code>？</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="f2f5" class="lm ln iq li b gy lo lp l lq lr">class CarApplication: Application() {<br/><br/>    val car: Car by <em class="kz">lazy </em><strong class="li ir">{<br/>        </strong>Car(ElectricEngine())<br/>    <strong class="li ir">}<br/></strong>}</span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><pre class="lh li lj lk aw ll bi"><span id="78bf" class="lm ln iq li b gy nf ng nh ni nj lp l lq lr">class CarActivity: AppCompatActivity() {<br/><br/>    private val car: Car by <em class="kz">lazy </em><strong class="li ir">{<br/>        </strong>(<em class="kz">applicationContext </em>as CarApplication).car<br/>    <strong class="li ir">}<br/></strong>}</span></pre><p id="7621" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将<code class="fe ls lt lu li b">Car</code>实例与<code class="fe ls lt lu li b">Application</code>相关联，它变得独立于<code class="fe ls lt lu li b">CarActivity</code>的生命周期。汽车的状态:发动机是开着还是关着，汽油的水平等等，将在设备配置改变时保持。由于<code class="fe ls lt lu li b">Activity</code>实例被销毁和重新创建，设备配置可能会在运行时发生变化(比如屏幕方向、键盘可用性和语言)。</p><p id="952d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">区分<em class="kz">视图</em>层的状态和<em class="kz">模型</em>层的状态是很重要的。<strong class="ka ir">车</strong>属于<em class="kz">型</em>车<strong class="ka ir">活动度</strong>属于<em class="kz">视图</em>。</p><p id="d86c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设<code class="fe ls lt lu li b">CarActivity</code>显示<code class="fe ls lt lu li b">Car</code>开始状态(无论是开启还是关闭),允许用户改变它。另外，还有一个确认操作的按钮。这是Android应用程序设置屏幕的常见场景。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0f543cae9cc55ae69755f6ccd5f64196.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*JPUBPtV-u5DoZwu36zDwgA.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">卡拉活动</figcaption></figure><p id="4e6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户将引擎状态更改为“开”并旋转屏幕，保持视图状态是<code class="fe ls lt lu li b">CarActivity</code>的责任。<code class="fe ls lt lu li b">Car</code>只有在按下确认按钮时才会被告知更改。一旦发生，即使<code class="fe ls lt lu li b">CarActivity</code>被破坏，状态也会保存在内存中。</p><p id="6c4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前面的例子中，在XML中，id被提供给开关，以便在第一次创建<code class="fe ls lt lu li b">CarActivity</code> <strong class="ka ir"> </strong>时基于<code class="fe ls lt lu li b">Car</code>状态来改变所选择的值。Android会自动保存包中带有<code class="fe ls lt lu li b">id</code>的视图的状态。因此，当<code class="fe ls lt lu li b">CarActivity</code> <strong class="ka ir"> </strong>被重新创建时，开关状态被适当地恢复。有些情况下不会自动发生，应该使用<strong class="ka ir">包</strong>手动保存和恢复视图状态。</p><h1 id="7159" class="lv ln iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">活动到服务通信</h1><p id="d4ea" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">现在假设一个<code class="fe ls lt lu li b">CarService</code>不时更新<code class="fe ls lt lu li b">Car</code>状态。同样，由于Android的架构，我们无法访问<code class="fe ls lt lu li b">CarService</code>构造函数<strong class="ka ir"> </strong>，因此我们应该从<code class="fe ls lt lu li b">CarApplication</code>获取<code class="fe ls lt lu li b">Car</code>实例。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="0f82" class="lm ln iq li b gy lo lp l lq lr">class CarService : Service() {<br/><br/>    override fun onBind(intent: Intent?): IBinder? = null<br/><br/>    private val car: Car by <em class="kz">lazy </em><strong class="li ir">{<br/>        </strong>(<em class="kz">applicationContext </em>as CarApplication).car<br/>    <strong class="li ir">}<br/><br/>    </strong>private val timer by <em class="kz">lazy </em><strong class="li ir">{<br/>        </strong>Timer()<br/>    <strong class="li ir">}<br/><br/>    </strong>private val startStopTask by <em class="kz">lazy </em><strong class="li ir">{<br/>        </strong>object : TimerTask() {<br/>            override fun run() {<br/>                if (car.isStarted()) {<br/>                    car.stop()<br/>                } else {<br/>                    car.start()<br/>                }<br/>            }<br/>        }<br/>    <strong class="li ir">}<br/><br/>    </strong>override fun onCreate() {<br/>        super.onCreate()<br/>        timer.schedule(startStopTask, 0, 15000)<br/>    }<br/><br/>    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {<br/>        return <em class="kz">START_STICKY<br/>    </em>}<br/><br/>    override fun onDestroy() {<br/>        timer.cancel()<br/>        super.onDestroy()<br/>    }<br/>}</span></pre><p id="498e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样在上面的例子中，一个<code class="fe ls lt lu li b">Timer</code>用于创建一个<code class="fe ls lt lu li b">TimerTask</code>来每15秒启动或停止一次汽车。最后，<code class="fe ls lt lu li b">CarService</code>开始于<code class="fe ls lt lu li b">onCreate</code>方法中的<code class="fe ls lt lu li b">CarApplication</code>。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="26f0" class="lm ln iq li b gy lo lp l lq lr">class CarApplication: Application() {<br/><br/>    val car: Car by <em class="kz">lazy </em><strong class="li ir">{<br/>        </strong>Car(ElectricEngine())<br/>    <strong class="li ir">}<br/><br/>    </strong>override fun onCreate() {<br/>        super.onCreate()<br/>        startService(Intent(<em class="kz">applicationContext</em>, CarService::class.<em class="kz">java</em>))<br/>    }<br/>}</span></pre><p id="ca0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<code class="fe ls lt lu li b">Car</code>的状态定期改变，我们可以使用<strong class="ka ir">可观察的</strong>模式来更新通知任何想要对改变做出反应的人。我是RxJava 的忠实粉丝，但是为了简单起见，下面的例子使用Java <strong class="ka ir"> Observable </strong>类。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="dfbf" class="lm ln iq li b gy lo lp l lq lr">class Car(private val engine: Engine): Observable() {<br/><br/>    fun start() {<br/>        engine.turnOn()<br/>        setChanged()<br/>        notifyObservers()<br/>    }<br/><br/>    fun stop() {<br/>        engine.turnOff()<br/>        setChanged()<br/>        notifyObservers()<br/>    }<br/><br/>    fun isStarted() = engine.isTurnedOn()<br/>}</span></pre><p id="6012" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，<code class="fe ls lt lu li b">CarActivity</code>可以观察到<code class="fe ls lt lu li b">Car</code>并相应地更新视图。</p><pre class="ld le lf lg gt lh li lj lk aw ll bi"><span id="8d27" class="lm ln iq li b gy lo lp l lq lr">class CarActivity : AppCompatActivity() {<br/><br/>    private val car: Car by <em class="kz">lazy </em><strong class="li ir">{<br/>        </strong>(<em class="kz">applicationContext </em>as CarApplication).car<br/>    <strong class="li ir">}<br/><br/>    </strong>private val carObserver by <em class="kz">lazy </em><strong class="li ir">{<br/>        </strong><em class="kz">Observer </em><strong class="li ir">{ </strong>_, _ <strong class="li ir">-&gt;<br/>            </strong>runOnUiThread <strong class="li ir">{<br/>                </strong>updateView()<br/>            <strong class="li ir">}<br/>        }<br/>    }<br/><br/>    </strong>override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.<em class="kz">activity_car</em>)<br/>        car.addObserver(carObserver)<br/>        saveButton.setOnClickListener <strong class="li ir">{<br/>            </strong>if (car.isStarted()) {<br/>                car.stop()<br/>            } else {<br/>                car.start()<br/>            }<br/>        <strong class="li ir">}<br/>    </strong>}<br/><br/>    override fun onDestroy() {<br/>        saveButton.setOnClickListener(null)<br/>        car.deleteObserver(carObserver)<br/>        super.onDestroy()<br/>    }<br/><br/>    private fun updateView() {<br/>        startedSwitch.<em class="kz">isChecked </em>= car.isStarted()<br/>    }<br/>}</span></pre><p id="bd21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">Activity</strong>to<strong class="ka ir">Service</strong>一直被视为Android开发中的一个复杂问题，但是通过理解依赖注入和Android架构如何工作，它可以变得相当简单。</p><p id="7e72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样的模式也适用于<code class="fe ls lt lu li b">BroadcastReceiver</code>。<code class="fe ls lt lu li b">Car</code> <strong class="ka ir"> </strong>可能因系统或其他应用程序广播的外部事件而改变。</p><h1 id="7faf" class="lv ln iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">它是如何扩展的？</h1><p id="0add" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">随着时间的推移，应用程序变得越来越大，类的数量和复杂性也在增加。为了使应用程序易于维护和扩展，采用像MVP、MVC或MVVM这样的架构来标准化类之间的关联方式是一个很好的实践。</p><p id="18ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们示例中的<em class="kz">模型</em>层非常简单，只有一个类，没有<em class="kz">持久性</em>或<em class="kz">网络</em>类。通过添加这些类，用另一个类(可能是<code class="fe ls lt lu li b">CarManager</code> <strong class="ka ir"> </strong>或<code class="fe ls lt lu li b"><a class="ae mx" href="https://medium.com/@marcelorbenites/managing-state-in-android-f4d042646521" rel="noopener">CarStateMachine</a></code>)抽象它们与<code class="fe ls lt lu li b">Car</code>的关系是一个很好的实践。Android组件将与<code class="fe ls lt lu li b">CarStateMachine</code> <strong class="ka ir"> </strong>交互，而不是直接与<code class="fe ls lt lu li b">Car</code>交互。<code class="fe ls lt lu li b">CarStateMachine</code> <strong class="ka ir"> </strong>会与<code class="fe ls lt lu li b">Application</code> <strong class="ka ir"> </strong>实例相关联，就像<code class="fe ls lt lu li b">Car</code> <strong class="ka ir"> </strong>那样保持其状态独立于Android组件的生命周期。</p><p id="784a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖注入最终将需要使用创建模式来帮助配置和控制保存在内存中的对象的生命周期。一些著名的创建模式有<strong class="ka ir">工厂</strong>、<strong class="ka ir">生成器</strong>和<strong class="ka ir">对象池</strong>。</p><p id="6d70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe ls lt lu li b">Car</code> <strong class="ka ir"> </strong>对象作为<strong class="ka ir">单例对象</strong>工作，因为我们在应用程序的整个生命周期中保留了它的单个实例。<code class="fe ls lt lu li b">Car</code> <strong class="ka ir"> </strong>实例是<strong class="ka ir">惰性加载的</strong>，因此它是按需实例化的。也可以根据一些业务逻辑创建一个新的<code class="fe ls lt lu li b"><strong class="ka ir">Car</strong></code> <strong class="ka ir"> </strong>实例。</p><p id="2528" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中一些模式可以被依赖注入框架(如Dagger)所取代，这将使我们免于一些与之相关的样板代码，特别是关于对象的生命周期</p><h1 id="2520" class="lv ln iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">警告</h1><p id="7355" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">大多数情况下，Android应用程序将在单个进程中运行，但在某些情况下，一个组件可能需要在单独的进程中运行。多个流程意味着多个<code class="fe ls lt lu li b">Application</code>实例，并且不可能在不同流程的组件之间共享对象。在这种情况下，我倾向于使用Binder和IPC在进程之间进行通信。此外，可以使用数据库作为流程之间的桥梁，但是我强烈建议不要采用这种方法，因为它会隐式地耦合实现细节和业务逻辑。</p><h1 id="b5ce" class="lv ln iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="4ebe" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">Android Jetpack提供了新的选项来帮助查看状态x模型状态管理。另外，Dagger是依赖注入的一种常见解决方案。尽管有现成的库可用，但了解如何在没有任何外部依赖的情况下解决这些问题是很重要的，因此作为工程师，我们可以选择最佳的实现。</p><h1 id="1167" class="lv ln iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">参考</h1><ul class=""><li id="b748" class="np nq iq ka b kb ms kf mt kj nr kn ns kr nt kv nu nv nw nx bi translated"><a class="ae mx" href="https://github.com/marcelorbenites/mode-vs-view-state" rel="noopener ugc nofollow" target="_blank">查看国家x模型国家GitHub示例由Marcelo Benites </a></li><li id="37e7" class="np nq iq ka b kb ny kf nz kj oa kn ob kr oc kv nu nv nw nx bi translated"><a class="ae mx" href="https://github.com/marcelorbenites/android-testing-strategy/tree/master/app/src/main/java/com/droidcon" rel="noopener ugc nofollow" target="_blank">Marcelo Benites的状态机GitHub示例</a></li><li id="787f" class="np nq iq ka b kb ny kf nz kj oa kn ob kr oc kv nu nv nw nx bi translated"><a class="ae mx" href="https://engineering.talkdesk.com/android-testing-strategy-73269539c13d" rel="noopener ugc nofollow" target="_blank">Marcelo Benites的Android测试策略</a></li></ul></div></div>    
</body>
</html>