<html>
<head>
<title>Building an API in C++ With Pistache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Pistache在C++中构建API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-an-api-in-c-with-pistache-413247535fd3?source=collection_archive---------2-----------------------#2022-01-31">https://levelup.gitconnected.com/building-an-api-in-c-with-pistache-413247535fd3?source=collection_archive---------2-----------------------#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8ca576ef27435878f396b6c6ac853294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f8CXRA9g9CIGzIDE"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Theo Crazzolara 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="165b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据RapidAPI的博客文章<a class="ae kf" href="https://rapidapi.com/blog/programming-languages/" rel="noopener ugc nofollow" target="_blank">的说法，用于构建API的最流行的语言/框架是PHP、NodeJS和Python(相当多)。像C++这样的语言并不经常用于这种目的，因为这超出了它们的范围。当我构建一个web前端来运行我之前构建的C++模拟时，我自己就经历过这种情况，这是一个车轮交易算法的重新实现。在这种情况下，我使用NodeJS构建一个API，可以从web前端调用该API，然后web前端使用一个库通过终端调用来执行C++代码。这是非常低效的，并且比用C++处理所有事情更容易出错。正因为如此，我决定找出用C++服务API端点需要什么，并发现</a><a class="ae kf" href="http://pistache.io/" rel="noopener ugc nofollow" target="_blank">pische . io</a>是一种非常简单有效的方法。在这篇文章中，我将演示如何在C++中建立一个API，方法是用Pistache构造一个非常基本的GET请求和一个非常基本的post请求。</p><p id="c923" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始之前，我将提到几个用例，因为如果你计划构建一个基于web的应用程序，最好坚持使用现代web技术(NodeJS、PHP、Python等)。)为API。我认为使用C++/pische的两个主要原因是:I)您已经有一个希望通过web前端运行的C++应用程序，ii)您有一个希望通过Docker或其他容器化形式与其他应用程序混合的c++应用程序。无论哪种情况，建立易于访问的API端点可能是最好的解决方案。</p><h1 id="7a93" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">皮斯托切</h1><p id="ea8d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">根据他们的网站，pische ch是“一个优雅的C++ REST框架”。该框架非常易于使用，提供了许多功能，包括多线程HTTP服务器、轻松向C++函数发送请求的HTTP路由器以及请求API的异步HTTP客户端。这个库很容易安装在大多数系统上(我在我的服务器上运行的是<a class="ae kf" href="https://medium.com/swlh/building-an-affordable-home-server-with-old-server-hardware-600-4670f685ad45" rel="noopener">Debian 10</a>和其他基于Debian的系统】,因为它有一个官方的PPA。安装说明可以在他们的<a class="ae kf" href="http://pistache.io/docs/" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>中找到。</p><p id="248e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管我发现这个框架很容易使用，但要开始使用还是需要一点努力。项目的文档很好，但是还有一些需要改进的地方。我发现阅读GitHub 上示例的<a class="ae kf" href="https://github.com/pistacheio/pistache/tree/master/examples" rel="noopener ugc nofollow" target="_blank">代码非常有帮助，并为这篇简短的帖子提供了大部分见解，特别是</a><a class="ae kf" href="https://github.com/pistacheio/pistache/blob/master/examples/rest_server.cc" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> rest_server.cc </em>示例</a>。安装Pistache后，可以通过<em class="mh"> -lpistache </em>标志<em class="mh">将库包含在<em class="mh"> g++ </em>中。下面是一个基本的Makefile，用名为<em class="mh"> main.cpp </em>的文件中的代码为服务器构建可执行文件。</em></p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5b8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个Makefile说明了Pistache的一个潜在缺点，即需要C++17。我认为在大多数情况下，这不应该是一个问题，因为该标准现在已经有5年的历史了，但它可能会成为你的一个障碍。</p><h1 id="17d4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置</h1><p id="d0c6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">安装并包含Pistache之后，需要在C++项目中包含一些头文件来使用这个框架。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0657" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还使用了<a class="ae kf" href="https://rapidjson.org/" rel="noopener ugc nofollow" target="_blank"> RapidJSON </a>来解析POST请求的请求体，因此也需要包含它。<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/parsing-json-in-c-with-rapidjson-6d6d3e505e12">我之前写过关于在C++中使用RapidJSON库处理JSON的文章</a>，任何感兴趣的读者都应该看看这篇文章。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a869" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，为了让事情变得简单一点，我们将使用<em class="mh"> Pistache </em>名称空间。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="74a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们需要在用于运行服务器的主函数中定义一些变量。我没有详细描述它们，而是在代码中添加了一些解释性注释。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="88d5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">获取请求</h1><h2 id="9e4f" class="mo lf it bd lg mp mq dn lk mr ms dp lo kr mt mu ls kv mv mw lw kz mx my ma mz bi translated">没有参数</h2><p id="70f0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们将定义一个非常基本的get请求端点，它不接受任何参数并发回一些响应。我能想到的最简单的办法就是回应“世界！”在“你好”端点。回调函数看起来像这样</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b79d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相当简单！注意，用Pistache构建的REST API的所有回调都有相同的签名，但函数名不同。现在，我们将此路由添加到路由器中。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5c48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面，我已经将路由“/hello”添加到先前定义的路由器中。我在这里包含了整个main函数，以展示这一切是如何适应的，但是接下来我将包含更少的代码，以强调实际正在进行的更改(这样它们就不会在周围的代码中丢失)。现在通过上面的Makefile和<em class="mh">编译并运行它。/server </em>(如果使用Linux系统并像我一样制作)应该在</p><blockquote class="na nb nc"><p id="c40f" class="kg kh mh ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">http://本地主机:9900/hello</p></blockquote><p id="4432" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在web浏览器中导航到此URL(或通过其他方式提交GET请求，例如通过邮递员)将返回以下响应</p><blockquote class="na nb nc"><p id="03eb" class="kg kh mh ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">世界！</p></blockquote><p id="8e49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有比这更简单的了。</p><h2 id="94eb" class="mo lf it bd lg mp mq dn lk mr ms dp lo kr mt mu ls kv mv mw lw kz mx my ma mz bi translated">带(可选)参数</h2><p id="d763" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">接下来，我们将看看如何发出GET请求，但现在使用URL参数。GET请求中的参数通过URL传递。在Pistache中，它们可以标记为可选或必需。为了进行演示，创建了一个端点，它接受一个(可选的)参数，并将其回显给用户，这个端点被称为“/echo_get”，参数被命名为“text”使端点“/echo_get/:text？”。请注意“？”参数名后面的(":text ")表示该参数是可选的。如果删除了该参数，则该参数必须是URL的一部分，否则将会出现错误，提示路由不存在。下面是“/echo_get”的回调</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5fd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这条新路由需要添加到路由器中</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="582d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提交此请求有两种方式，即带参数和不带参数。后者看起来像这样(确保您的服务器正在运行)</p><blockquote class="na nb nc"><p id="7fa1" class="kg kh mh ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated"><a class="ae kf" href="http://localhost:9900/echo_get" rel="noopener ugc nofollow" target="_blank">http://localhost:9900/echo _ get</a></p></blockquote><p id="479c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回响应</p><blockquote class="na nb nc"><p id="b754" class="kg kh mh ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">未提供参数。</p></blockquote><p id="2b80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不出所料。前者(带有参数)可能如下所示</p><blockquote class="na nb nc"><p id="830a" class="kg kh mh ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated"><a class="ae kf" href="http://localhost:9900/echo_get/hello!" rel="noopener ugc nofollow" target="_blank">http://localhost:9900/echo _ get/hello！</a></p></blockquote><p id="e8f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它回显文本</p><blockquote class="na nb nc"><p id="8e39" class="kg kh mh ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">你好！</p></blockquote><p id="7e05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多个参数可以以类似和直观的方式处理。</p><h1 id="8e1f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">发布请求</h1><p id="c33b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果您已经使用浏览器提交GET请求，那么转到POST请求将需要不同的方法。这是由于在请求中处理参数的方式使得处理敏感数据更加安全和理想。我使用Postman来测试我的端点，但是您可以使用任何其他允许您提交请求的软件(使用<em class="mh"> requests </em>库在Python中测试端点也非常容易)。</p><p id="f09f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开始回调的定义</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2af8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个回调将检查一个“文本”参数，如果它是可用的，就将它回显给用户。如果它不可用，将会有一条消息来说明这一点。注意这里我们使用RapidJSON来处理请求体(JSON格式)，<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/parsing-json-in-c-with-rapidjson-6d6d3e505e12">我还有一篇关于使用这个C++库来处理JSON </a>的文章，如果你是这种处理的新手，这可能会有帮助。(对于那些想知道我为什么使用RapidJSON而不是JsonCpp的人，我在2021年初的一些合同工作中使用了两者，当解析大约10年的OHLC数据时，JsonCpp用了大约20分钟，而RapidJSON只用了几秒钟，也就是说，两者各有利弊。)</p><p id="ff6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在需要将该路由添加到路由器中</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3fbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着服务器的运行，请求可以提交到URL</p><blockquote class="na nb nc"><p id="a8d8" class="kg kh mh ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated"><a class="ae kf" href="http://localhost:9900/echo" rel="noopener ugc nofollow" target="_blank">http://localhost:9900/echo</a></p></blockquote><p id="e88b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发送到服务器的JSON中有或没有“text”参数。下面是Postman的截图，展示了参数是如何提供的</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/e81d5e33102382e27e0d7b4efbdb73a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ID0ufnwOaD-2aeGu4-yi6g.png"/></div></div></figure><p id="bfa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我在我的服务器上提供这个API，它的网络名称是<em class="mh"> navier，</em>如果在你的本地机器上运行，请求应该使用<em class="mh"> localhost </em>而不是<em class="mh"> navier </em>。</p><p id="b19e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发送此请求将返回如下响应，如预期的那样，</p><blockquote class="na nb nc"><p id="447f" class="kg kh mh ki b kj kk kl km kn ko kp kq nd ks kt ku ne kw kx ky nf la lb lc ld im bi translated">你好世界！</p></blockquote><p id="58f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，这个逻辑可以扩展到处理多个参数。我在这里的目标是展示实现自己的API时(或多或少)需要的大部分功能。</p><h1 id="869e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="2267" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这篇文章中，我讨论了如何设置一些基本的API端点，并通过Pistache框架在C++中为它们提供服务。该框架易于使用，许多C++程序员应该通过使他们的应用程序更容易被观众访问的方式打开许多大门。下面是这个API的完整代码，你可以随意使用和修改。</p><h1 id="4ec1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">完整代码</h1><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>