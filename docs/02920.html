<html>
<head>
<title>Learning C++: The STL and the vector Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL和vector类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-the-stl-and-the-vector-class-beead0ac745f?source=collection_archive---------11-----------------------#2020-04-10">https://levelup.gitconnected.com/learning-c-the-stl-and-the-vector-class-beead0ac745f?source=collection_archive---------11-----------------------#2020-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/4ff7c27ba58a42e7fa80670230d482b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*ONNKxJ1iV17x4bKWSvwnxw.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图片由mathinsight.org提供</figcaption></figure><p id="7d6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">标准模板库中最流行的容器是<code class="fe kz la lb lc b">vector</code>类。当需要对数据进行顺序排序时，vector很快成为所有C++程序的首选容器。大多数C++编程专家(以及C++教科书作者)都认识到，向量比原始数组具有更好的灵活性，并且对于大多数应用程序来说，向量足够高效，但对于大多数数据密集型场景来说则不然。</p><p id="aea0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将讨论如何使用<code class="fe kz la lb lc b">vector</code>类进行顺序数据存储。</p><h1 id="bb12" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">数组的问题</h1><p id="16b8" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">使用原语(我使用原语是指数组是内置的，不是库的一部分)数组有两个主要问题。首先，数组的大小是固定的，所以您必须预先知道在程序的整个生命周期中有多少元素将存储在数组中。另一个问题是，当您将数组传递给函数时，您必须将数组的大小也传递给函数，这使得函数定义和函数调用比它们需要的更复杂。解决这两个问题的一个好方法是使用<code class="fe kz la lb lc b">vector</code>类。</p><h1 id="abf6" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">创建向量</h1><p id="5b33" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">创建vector之前的第一步是将<code class="fe kz la lb lc b">vector</code>类导入到程序中，如下所示:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="3f16" class="mo le it lc b gy mp mq l mr ms">#include &lt;vector&gt;</span></pre><p id="2cf1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一步是声明一个新的vector实例。<code class="fe kz la lb lc b">vector</code>类是一个模板化的类，所以你必须至少在尖括号内提供vector的数据类型。这里有几个例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="58d9" class="mo le it lc b gy mp mq l mr ms">vector&lt;int&gt; numbers;<br/>vector&lt;string&gt; names;<br/>vector&lt;bool&gt; flags;</span></pre><p id="7915" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还可以声明一个新的vector实例，其初始容量为<em class="mt"/>。我需要花一点时间来解释容量的含义。当您声明vector实例时，初始容量为0。当你把一个元素加到vector上，容量就变成了1。当您添加第二个元素时，容量变为2。当您添加第三个元素时，容量变为4。当您添加第五个元素时(我跳过了第四个元素)，容量变为8。以使得每当向量变满时容量翻倍。</p><p id="9d47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种容量分配需要一点点开销，所以您可能希望指定一个初始容量来避免早期分配，即使它们很小。以下是您的操作方法:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="ca33" class="mo le it lc b gy mp mq l mr ms">vector&lt;int&gt; numbers(32);<br/>vector&lt;string&gt; names(16);</span></pre><p id="9049" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，您可以声明一个新的向量，并使用初始化列表用数据初始化它。这里有两个例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="dc00" class="mo le it lc b gy mp mq l mr ms">vector&lt;int&gt; grades = {88, 91, 77, 84, 100};<br/>vector&lt;string&gt; beatles = {"John", "Paul", "George", "Ringo"};</span></pre><h1 id="980a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">向向量添加数据</h1><p id="2205" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">向向量添加数据的标准方法是<code class="fe kz la lb lc b">push_back</code>函数。这个函数在向量的后面放置一个新的数据元素。这里有一个例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="286c" class="mo le it lc b gy mp mq l mr ms">vector&lt;int&gt; numbers;<br/>for (int i = 1; i &lt;= 20; i++) {<br/>  numbers.push_back(i);<br/>}</span></pre><p id="f8d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果向量已经被分配，可以使用下标符号将数据添加到向量中:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="0414" class="mo le it lc b gy mp mq l mr ms">vector&lt;int&gt; numbers(20);<br/>for (int i = 0; i &lt; 20; i++) {<br/>  numbers[i] = i+1;<br/>}</span></pre><p id="e106" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不过，通常情况下，您应该使用<code class="fe kz la lb lc b">push_back</code>函数来添加数据。</p><h1 id="d768" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">访问矢量数据</h1><p id="f265" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">有几种方法可以访问向量中的数据。一种方法是使用<code class="fe kz la lb lc b">at</code>函数。<code class="fe kz la lb lc b">at</code>函数将一个索引位置作为参数，并返回该位置的元素。下面是一个使用<code class="fe kz la lb lc b">at</code>功能的例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="f166" class="mo le it lc b gy mp mq l mr ms">int main()<br/>{<br/>  vector&lt;int&gt; numbers(20);<br/>  for (int i = 0; i &lt; 20; i++) {<br/>    numbers[i] = i+1;<br/>  }<br/>  for (unsigned i = 0; i &lt; numbers.size(); i++) {<br/>    cout &lt;&lt; numbers.at(i) &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="d2a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您也可以像处理数组一样使用下标操作符<code class="fe kz la lb lc b">[]</code>:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="bb68" class="mo le it lc b gy mp mq l mr ms">for (unsigned i = 0; i &lt; numbers.size(); i++) {<br/>  cout &lt;&lt; numbers[i] &lt;&lt; " ";<br/>}</span></pre><p id="a8ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以使用迭代器来遍历一个向量。我之前已经写了关于迭代器的文章，所以我将在这里演示如何使用它:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="eab9" class="mo le it lc b gy mp mq l mr ms">for (auto iter = numbers.begin(); iter != numbers.end(); iter++) {<br/>  cout &lt;&lt; *iter &lt;&lt; " ";<br/>}</span></pre><p id="f4ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，如果你想访问vector的每个元素，你可以使用一个range <code class="fe kz la lb lc b">for</code>循环:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="39ea" class="mo le it lc b gy mp mq l mr ms">for (int n : numbers) {<br/>  cout &lt;&lt; n &lt;&lt;  " ";<br/>}</span></pre><h1 id="9294" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">尺寸函数</h1><p id="9e84" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">您可能会注意到，在上面的访问示例中，我添加了一个新函数— <code class="fe kz la lb lc b">size</code>。该函数返回向量中当前元素的数量，并为程序员提供了在不完全了解向量大小的情况下安全遍历向量的能力。</p><p id="9800" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">size</code>函数的一个真正优势是当你在函数中访问一个向量时。对于数组，您必须将大小和数组一起传递给函数，但是对于向量，您不必传递向量中元素的数量。这里有一个例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="1d0c" class="mo le it lc b gy mp mq l mr ms">double compAvg(vector&lt;int&gt; vec) {<br/>  int total = 0;<br/>  for (unsigned i = 0; i &lt; vec.size(); i++) {<br/>    total += vec[i];<br/>  }<br/>  return static_cast&lt;double&gt;(total) / vec.size();<br/>}</span><span id="e16a" class="mo le it lc b gy mv mq l mr ms">int main()<br/>{<br/>  vector&lt;int&gt; grades = {81, 77, 91, 100, 83};<br/>  double avgGrade = compAvg(grades);<br/>  cout &lt;&lt; "The average grade is: " &lt;&lt; avgGrade &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="2906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我可以在函数中使用一个range <code class="fe kz la lb lc b">for</code>循环来避免超出数组范围的可能性，如下所示:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="1baa" class="mo le it lc b gy mp mq l mr ms">double compAvg(vector&lt;int&gt; vec) {<br/>  int total = 0;<br/>  for (int n : vec) {<br/>    total += n;<br/>  }<br/>  return static_cast&lt;double&gt;(total) / vec.size();<br/>}<br/></span></pre><p id="ae7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个例子展示了数组和向量之间的另一个重要区别。不能在传递给函数的数组上使用range <code class="fe kz la lb lc b">for</code>循环，因为编译器无法在内存中找到该数组的起始点。</p><h1 id="70b7" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">作为函数参数和返回值的向量</h1><p id="95a6" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">向量通过值传递给函数。这意味着如果你想修改一个函数中向量的内容，你必须通过引用传递这个向量。这里有一个例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="1d23" class="mo le it lc b gy mp mq l mr ms">void curveGrades(vector&lt;int&gt; &amp;vec, int amount) {<br/>  for (unsigned i = 0; i &lt; vec.size(); i++) {<br/>    vec[i] += amount;<br/>  }<br/>}</span><span id="709b" class="mo le it lc b gy mv mq l mr ms">void printVec(vector&lt;int&gt; vec) {<br/>  for (int n : vec) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="75bb" class="mo le it lc b gy mv mq l mr ms">int main()<br/>{<br/>  vector&lt;int&gt; grades = {81, 77, 91, 100, 83};<br/>  printVec(grades); // displays 81 77 91 100 83<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  curveGrades(grades, 5);<br/>  printVec(grades); // displays 86 82 96 105 88<br/>  return 0;<br/>}</span></pre><p id="eda5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你也可以从函数中返回一个向量。下面是一个将随机数赋给向量并将其返回给调用程序的函数:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="bc72" class="mo le it lc b gy mp mq l mr ms">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="ad89" class="mo le it lc b gy mv mq l mr ms">vector&lt;int&gt; initVec(int numElements) {<br/>  srand(time(0));<br/>  vector&lt;int&gt; vec;<br/>  for (unsigned i = 1; i &lt;= numElements; i++) {<br/>    vec.push_back(rand() % 1000 + 1);<br/>  }<br/>  return vec;<br/>}</span><span id="1f63" class="mo le it lc b gy mv mq l mr ms">void printVec(vector&lt;int&gt; vec) {<br/>  for (int n : vec) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="03e1" class="mo le it lc b gy mv mq l mr ms">int main()<br/>{<br/>  vector&lt;int&gt; numbers = initVec(20);<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><h1 id="7af3" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">插入向量和从向量中移除</h1><p id="f4cb" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">将元素插入向量需要使用迭代器。要使用的函数是insert，函数有几个重载版本。这里我将演示最常见的一个——<em class="mt">insert(position，element) </em>。该模板指示元素参数被插入到第一个参数中给定的迭代器位置之前的位置。下面的例子演示了如何将一个数字插入到一个排序的向量中(在这个例子中，你可以免费看到一个关于排序算法如何工作的例子):</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="1dc3" class="mo le it lc b gy mp mq l mr ms">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>using namespace std;</span><span id="e3d8" class="mo le it lc b gy mv mq l mr ms">void printVec(vector&lt;int&gt; vec) {<br/>  for (int n : vec) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="145e" class="mo le it lc b gy mv mq l mr ms">int main()<br/>{<br/>  vector&lt;int&gt; grades = {82, 71, 89, 77, 91, 75};<br/>  sort(grades.begin(), grades.end());<br/>  printVec(grades); // displays 71 75 77 82 89 91<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int grade = 86;<br/>  auto iter = grades.begin();<br/>  while (*iter &lt; grade) {<br/>    iter++;<br/>  }<br/>  grades.insert(iter, grade);<br/>  printVec(grades); // displays 71 75 77 82 86 89 91<br/>  return 0;<br/>}</span></pre><p id="1783" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">while</code>循环遍历矢量，直到它到达一个比我们想要插入的坡度更大的坡度。这是插入点，因此我们调用insert函数将新的等级放在适当的位置。</p><p id="aeab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">移除元素也涉及迭代器。<code class="fe kz la lb lc b">erase</code>函数删除作为参数给出的迭代器位置的元素。首先，这里是擦除函数的模板:<em class="mt">擦除(位置)</em>。现在让我们看一个例子:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="8860" class="mo le it lc b gy mp mq l mr ms">void printVec(vector&lt;string&gt; vec) {<br/>  for (string s : vec) {<br/>    cout &lt;&lt; s &lt;&lt; " ";<br/>  }<br/>}</span><span id="49f3" class="mo le it lc b gy mv mq l mr ms">int main()<br/>{<br/>  vector&lt;string&gt; beatles = {"John", "Paul", "George", "Pete",    <br/>                            Ringo"};<br/>  string fifthBeatle = "Pete";<br/>  auto iter = beatles.begin();<br/>  while (*iter != fifthBeatle) {<br/>    iter++;<br/>  }<br/>  beatles.erase(iter);<br/>  printVec(beatles); // displays John Paul George Ringo<br/>  return 0;<br/>}</span></pre><h1 id="9964" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">两个效用函数</h1><p id="e160" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">vector类中有几个实用函数。这里我要提到的两个是<code class="fe kz la lb lc b">empty</code>和<code class="fe kz la lb lc b">clear</code>。<code class="fe kz la lb lc b">empty</code>函数是一个布尔函数，如果该函数为空，则返回true，否则返回false。<code class="fe kz la lb lc b">clear </code>功能将删除一个矢量的所有元素。以下是如何使用它们的示例:</p><pre class="mg mh mi mj gt mk lc ml mm aw mn bi"><span id="ad29" class="mo le it lc b gy mp mq l mr ms">int main()<br/>{<br/>  vector&lt;int&gt; numbers = {1,2,3,4,5};<br/>  if (!numbers.empty()) {<br/>    numbers.clear();<br/>  }<br/>  cout &lt;&lt; "Number of elements: " &lt;&lt; numbers.size() &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="8c14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个程序中，如果<code class="fe kz la lb lc b">numbers</code>向量不为空，它将被清除。</p><h1 id="0df9" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">向量是新的数组</h1><p id="63ab" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">如果你阅读过去二十年或更多年的任何编程教科书，讨论的第一个数据结构是数组。对于C++(以及所有语言)来说，这应该会改变。vector是一个更加灵活的容器，具有非常好的性能，并且更容易被初级程序员成功使用。如果您没有使用vector(或其他语言中类似的容器类型)作为您的首选容器类型，现在是时候改变您的做法了。</p><p id="ca2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/cc28fc8ea8bb70b81958696a5a6d62cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UDIIQP7sAoF_AVTS"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">由<a class="ae mu" href="https://unsplash.com/@tamanna_rumee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tamanna Rumee </a>在<a class="ae mu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div></div>    
</body>
</html>