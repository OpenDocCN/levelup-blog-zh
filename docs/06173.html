<html>
<head>
<title>Create Redis Sets With Member Expiration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建成员过期的Redis集</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-redis-sets-with-member-expiration-6471e560f89f?source=collection_archive---------6-----------------------#2020-10-31">https://levelup.gitconnected.com/create-redis-sets-with-member-expiration-6471e560f89f?source=collection_archive---------6-----------------------#2020-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f6894d645f03b7c883b7fafbdc14bbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ToeLlBJ4RAOnUzQ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Unsplash上@aronvisuals的照片</figcaption></figure><p id="9d0f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Redis是一个很好的内存中键值数据存储，支持多种类型的值。<a class="ae ld" href="https://redis.io/topics/data-types-intro#sorted-sets" rel="noopener ugc nofollow" target="_blank">有序集合</a>就是其中之一。根据文献记载<code class="fe le lf lg lh b">sorted sets</code>是:</p><blockquote class="li lj lk"><p id="51dd" class="kf kg ll kh b ki kj kk kl km kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lc im bi translated"><em class="it">排序集合，类似于集合，但其中每个字符串元素都与一个称为score的浮点数值相关联。元素总是按照它们的分数排序，因此与集合不同，可以检索一系列元素(例如，您可能会问:给我前10名，或后10名)。</em></p></blockquote><p id="c153" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">关于<code class="fe le lf lg lh b">sorted sets</code>他们没有说的是<code class="fe le lf lg lh b">sets members</code>的到期时间无法确定，至少在这篇博文发表之前是如此。为什么我们需要定义<code class="fe le lf lg lh b">sets members</code>到期？</p><p id="8ca2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我的例子中，我需要创建一个电话服务，它可以生成并验证发送给有特定限制的用户的OTP。之前的设计使用的是<a class="ae ld" href="https://godoc.org/golang.org/x/time/rate" rel="noopener ugc nofollow" target="_blank"> Golang速率限制</a>，我认为它不能水平扩展。这就是为什么我想在这个案例中使用Redis。生成OTP的要求只有这样:</p><p id="ceab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这就是为什么我想出了<code class="fe le lf lg lh b">Redis sets</code>但<code class="fe le lf lg lh b">sets members</code>不能有自己的到期时间。然后我在谷歌上搜索，直到我找到了<a class="ae ld" href="https://github.com/redis/redis/issues/135#issuecomment-2361996" rel="noopener ugc nofollow" target="_blank">这个问题的评论</a>作者是<a class="ae ld" href="https://github.com/pietern" rel="noopener ugc nofollow" target="_blank"> @pietern </a>。这是一个相当不明智的举动，但至少是可行的。这就是为什么我试图实现它。Github上的评论又一次拯救了我的工作。</p><p id="d327" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个想法很简单，使用有序集合上的分数作为到期时间。获取分数在<code class="fe le lf lg lh b">current millis</code>和<code class="fe le lf lg lh b">current millis + Y minutes</code>之间的有效成员，删除分数在0和<code class="fe le lf lg lh b">current millis</code>之间的过期成员。所以最小的伪代码应该是这样的:</p><pre class="lp lq lr ls gt lt lh lu lv aw lw bi"><span id="ebc1" class="lx ly it lh b gy lz ma l mb mc"># define variables<br/>timeLimit := Y<br/>requestLimit := X<br/>key := +6212312341234<br/>otp := randomString(6)<br/>now := currentMillis()<br/>exp := now + timeLimit</span><span id="e0fe" class="lx ly it lh b gy md ma l mb mc"># get total of generated phone number in key<br/>validOTPs := redisQuery("ZRANGEBYSCORE $key $now $exp")</span><span id="4108" class="lx ly it lh b gy md ma l mb mc"># Limitting request<br/>if count(validOTPs) &gt;= requestLimit<br/>then exit</span><span id="8ffb" class="lx ly it lh b gy md ma l mb mc"># Add members to key<br/>redisQuery("ZADD $key $exp $otp")</span></pre><p id="bc7f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我觉得这个方法已经足够好了，也是实现起来最简单的一个。您可以添加可选操作，如<code class="fe le lf lg lh b">adding expiration to the key</code>或<code class="fe le lf lg lh b">removing members that are no longer valid</code>。但是这个操作足以给<code class="fe le lf lg lh b">sets member</code>加上有效期。您还可以使用这种方法来限制OTP验证，以避免暴力破解。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="2afd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ll">原发布于</em><a class="ae ld" href="https://clavinjune.dev/en/blogs/create-redis-sets-with-member-expiration/" rel="noopener ugc nofollow" target="_blank"><em class="ll">https://clavinjune . dev</em></a><em class="ll">。</em></p></div></div>    
</body>
</html>