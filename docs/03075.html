<html>
<head>
<title>Graphs 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图表101</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphs-101-67581c17178d?source=collection_archive---------1-----------------------#2020-04-18">https://levelup.gitconnected.com/graphs-101-67581c17178d?source=collection_archive---------1-----------------------#2020-04-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d614" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用Python实现</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/6c368fe607b30b0ef7c750365d290f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ps4KlEODqLbgYt9u5Li7w.png"/></div></div></figure><p id="03b0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">图是节点和连接的集合。如果我们为这些节点和它们的连接定义一些属性，我们就可以模拟许多现实世界的问题。图形对于表示网络特别有用。社交网络、电话线和路线图是现实世界网络的几个例子，它们的问题可以通过图形建模和解决。</p><p id="541f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在图形词典中，节点和连接分别被称为<strong class="kx iv">顶点</strong>和<strong class="kx iv">边</strong>。接下来，我将使用这两个术语，而不是节点和连接。下面，我举例说明了一个简单的图表。圆是顶点，线是边。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj lr"><img src="../Images/7078633ddb1cd9619a476556c154d6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*2sVa0bVvjoXbtfsBFjxq9w.png"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">一般图形的一个例子</figcaption></figure><h2 id="d19e" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">图表类型:</h2><p id="9c0c" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">通过定义顶点和边的规则，我们可以创建不同类型的图形。例如，如果您为边定义了一个方向，您可以创建一种新类型的图，称为<strong class="kx iv">有向图</strong>。另一个例子是自行车。一般来说，循环可以出现在一个图中，但是如果你强加一个规则，你的图不能有循环，那么你可以创建一个新类型的图，称为<strong class="kx iv">非循环图</strong>。将两者结合起来，我们可以得到另一种类型的图，称为<strong class="kx iv">有向无环图(DAGs) </strong>。除了方向，我们还可以给边赋予权重，并创建<strong class="kx iv">加权图</strong>。</p><p id="7ca8" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这些不同的图形类型对于模拟真实世界网络中的不同行为是有用的。比如在社交网络中，<strong class="kx iv"> <em class="mu">友情</em> </strong>用无向图建模，而 之后的<strong class="kx iv"> <em class="mu">用有向图建模。</em></strong></p><h2 id="1625" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">内存中的图形表示:</h2><p id="a258" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">一个图有两种常见的内存表示。一个是<strong class="kx iv">邻接矩阵</strong>，一个是<strong class="kx iv">邻接表</strong>。我试着用下图所示的例子来解释这两个问题。在这个上下文中，邻接意味着直接连接。例如，在示例图中，<code class="fe mv mw mx my b">V₁</code>和<code class="fe mv mw mx my b">V₅</code>的两个顶点是<code class="fe mv mw mx my b">V₀</code>的相邻顶点，因为从<code class="fe mv mw mx my b">V₀</code>到它们有一条直接路径。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mz"><img src="../Images/c55446405ab672fa71aaf089c9e05533.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*d_YlGYR55VPfW7YQtyUuEw.png"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">示例图表</figcaption></figure><p id="8d0b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">邻接矩阵:</strong></p><p id="bdc3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这是在内存中表示图形的最简单的方法。但是它占用了很多空间。如果你有<strong class="kx iv"> V </strong>个顶点，它会占用<strong class="kx iv"> O(V ) </strong>个空间，只有当你更接近一个全连通图时，它才会变得有效。在实际应用中，大多数矩阵是<strong class="kx iv">稀疏的</strong>(即空的)，并且这种实现不是空间有效的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj na"><img src="../Images/58faf1c8a2aac98c60a7d3d2ecc3aec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*LECyJnHIBjonU_zRY4eyHA.png"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">邻接矩阵</figcaption></figure><p id="834a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">邻接表:</strong></p><p id="b311" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这是邻接矩阵的节省空间的替代方案。这也是表示中大型图表的首选方式。</p><p id="ae07" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如下图所示，在邻接表中，我们创建了一个包含图形对象中所有顶点的主列表，图形对象中的每一项都连接到一个包含相邻顶点和边权重的顶点对象。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nb"><img src="../Images/01e0247f8efb6cd1d5a9e437f1d1d834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KM0D8yy4dSaQ4bqn"/></div></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">邻接表</figcaption></figure><h2 id="99b4" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">Python中的图形实现:</h2><p id="e986" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">下面是一个简单的邻接表图的实现。这种实现可以针对不同的图形问题进行定制。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><h2 id="34af" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">图形遍历:</h2><p id="6ce8" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">图遍历指的是我们可以在网络中导航和访问每个顶点的方法。有两种常见的遍历图的方法:</p><ul class=""><li id="7338" class="ne nf iu kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated"><strong class="kx iv">广度优先搜索(BFS): </strong>逐层导航一个图形(或者有层次时逐层导航)。换句话说，从一个节点开始。拜访<strong class="kx iv">所有</strong>它的孩子。然后移动到孙辈，继续这个过程，直到没有未访问的顶点。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nn"><img src="../Images/6daf399d1c506f284d18722a7ddd1be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/1*on5z7UjsKdnc7Ujn4aqRHQ.gif"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">动画BFS(来源:维基百科)</figcaption></figure><p id="d77e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这种搜索方法需要一个<strong class="kx iv">队列</strong>数据结构来实现。使用队列保证了我们将在移动到其他层之前探索顶点的宽度。这种行为保证了两个顶点之间的第一条路径是它们之间的最短路径。</p><ul class=""><li id="ddee" class="ne nf iu kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated"><strong class="kx iv">深度优先搜索(DFS): </strong>通过深入挖掘从起点分支的路径来导航一个图，直到它到达一个点，在该点处不再有向前的边或者遇到先前访问过的顶点。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj no"><img src="../Images/b6261df8913a556aeccdb784c2324a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*RpdBKU1tgb1ew4wj_062WQ.gif"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">动画DFS(来源:维基百科)</figcaption></figure><p id="2d53" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个搜索方法需要一个<strong class="kx iv">栈</strong>数据结构来实现。您可以以迭代的方式显式使用stack，或者使用隐式使用stack的<strong class="kx iv">递归</strong>。</p><p id="c581" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> BFS实施代码:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><p id="3ef9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> DFS实现代码:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><h1 id="1708" class="np lx iu bd ly nq nr ns mb nt nu nv me ka nw kb mh kd nx ke mk kg ny kh mn nz bi translated">图形世界中的常见问题:</h1><p id="fea7" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">随着时间的推移，计算机科学家已经为一小组图形问题找到了一些有趣的解决方案。这里我试着讨论其中的一些。在现实世界中，网络问题很复杂，听起来也很复杂，但我们的工作是找出如何重新构建问题，使其与现有的解决方案相匹配。与其说是科学，不如说是艺术。</p><ol class=""><li id="b784" class="ne nf iu kx b ky kz lb lc le ng li nh lm ni lq oa nk nl nm bi translated">寻找两个顶点之间的最短路径</li><li id="fe93" class="ne nf iu kx b ky ob lb oc le od li oe lm of lq oa nk nl nm bi translated">检测图中的循环</li><li id="dd73" class="ne nf iu kx b ky ob lb oc le od li oe lm of lq oa nk nl nm bi translated">最小生成树</li><li id="3fe5" class="ne nf iu kx b ky ob lb oc le od li oe lm of lq oa nk nl nm bi translated">拓扑排序</li></ol><h2 id="52fb" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated"><strong class="ak"> 1。寻找两个顶点之间的最短路径:</strong></h2><p id="e084" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">只有当我们有一个加权图时，这个问题才具有挑战性。对于未加权的图，BFS毫不费力地给了我们答案。对于一个加权无向图，我们可以使用<strong class="kx iv"> Dijkstra算法</strong>来寻找两个顶点之间的最短路径。Dijkstra是BFS的一个更聪明的版本。一个很好的详细介绍Dijkstra算法的是<a class="ae og" href="https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e" rel="noopener">这里</a>。Dijkstra算法的另一个可视化来源可以在<a class="ae og" href="https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。在本节的最后，我提供了Dijkstra在我们的玩具示例上测试的代码。Dijkstra的时间复杂度大致为<strong class="kx iv"> O(V)。</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oh"><img src="../Images/37ddff76084695ec7c019880c0ed83be.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/1*15KkonMRnHdbzGhFw0PXCA.gif"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">Dijkstra算法动画(来源:维基百科)</figcaption></figure><p id="455c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用Dijkstra算法时，需要考虑两件重要的事情:1 .它不能处理负权重，2 .它是单源最短路径算法。</p><p id="b2fa" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">当我们有负权重边缘和负周期的可能性时，替代方案是<strong class="kx iv">贝尔曼-福特算法</strong>。当图内部出现负循环时，最短路径是没有意义的，算法唯一的工作就是检测它并报告给用户。就是这样。<strong class="kx iv"> </strong>贝尔曼-福特的优势在于它有一个内部机制，允许检测到负循环并报告给用户。这种额外的能力是以更高的时间复杂度为代价的。贝尔曼-福特的时间复杂度为<strong class="kx iv"> O(VE) </strong>，高于Dijkstra。</p><p id="7fa7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">贝尔曼-福特算法并不是那么直观，如果你想对算法有一个直观的理解，不如一步一步解决一个简单的问题。为此一个不错的短视频就是<a class="ae og" href="https://www.youtube.com/watch?v=obWXjtg0L64" rel="noopener ugc nofollow" target="_blank">这里</a>。在本节的最后，我在我们的玩具示例中提供了Bellman-Ford的代码。</p><p id="15af" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">当我们对所有对最短路径感兴趣时，一种方法是对所有顶点重复Dijkstra算法。然而，更聪明的方法是使用<strong class="kx iv"> Floyd-Warshall算法</strong>，它利用了邻接矩阵的强大功能和简单性。</p><p id="2a97" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Floyed-warshall算法非常简单明了。它由三个循环组成。两个循环用于扫描邻接矩阵，另一个循环用于检查是否有另一个顶点可以放在两个顶点之间，使它们的间接路径更短。由于这三个循环，算法的时间复杂度为<strong class="kx iv"> O(V ) </strong>。在本节的最后，我在我们的玩具示例中提供了Floyd-Warshall的代码。算法的输入和输出如下所示。该算法以距离矩阵作为输入开始，然后在上述三个循环中对其进行更新，并提供具有所有对最短路径距离的输出距离矩阵。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/a92a6c7a4ea641d19cfe78da238b8450.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*DvlLhuoBf2--jdtm1rLWaA.png"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">距离矩阵作为Floyd-Warshall算法的输入</figcaption></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oj"><img src="../Images/34c4d9e82a41eb32ae7d5d8fc0184781.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*R7CRn1y8AJ8uDee6f9I32A.png"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">Floyd-Warshall输出，所有对最短路径</figcaption></figure><p id="be47" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">我们玩具的Dijkstra代码示例:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><p id="7f09" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">玩具示例的贝尔曼-福特代码:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><p id="8b81" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> Floyd-Warshall代码为我们的玩具示例:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><h2 id="fc62" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated"><strong class="ak"> 2。检测图形中的循环:</strong></h2><p id="be5c" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">检测周期的一个简单方法是使用DFS。跟踪访问过的顶点，如果你看到它们两次，那么一定有一个循环。另一种方法是使用联合查找算法。用友比较好的视频教程是<a class="ae og" href="https://www.youtube.com/watch?v=0jNmHPfA_yE&amp;t=119s" rel="noopener ugc nofollow" target="_blank">这里</a>(把视频播放速度改成1.5x)。你可以在后面我讲解克鲁斯卡尔算法的时候找到用友的实现。</p><p id="7c4f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">针对我们的玩具示例，通过DFS代码进行循环检测:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><h2 id="9372" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">3.最小生成树:</h2><p id="c20f" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">生成树是加权无向图中连接所有顶点而没有任何圈的边的子集。最小生成树(MST)是具有最小总边权重的生成树。请记住，它之所以被称为树，是因为它没有循环。</p><p id="9c3c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">有两种主要的算法来解决这个问题。普里姆和克鲁斯卡尔算法。我尝试简单地解释它们并提供代码。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ok"><img src="../Images/514abe8b069846ea4f3e6b3c8e9c96ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*71hR914pPQmJc5v2MLNNaw.png"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">MST示例(来源:维基百科)</figcaption></figure><h2 id="9af3" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated"><strong class="ak">普里姆的算法:</strong></h2><p id="05cf" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">这是一个简单的贪婪算法。它随机地从一个顶点开始，并试图通过将具有最低权重的边附加到树上来构建MST树，直到它到达所有顶点。树边数为<code class="fe mv mw mx my b">|V|-1</code>。</p><p id="efe0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> MST使用Prim的算法为我们的玩具举例:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><h2 id="dc86" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated"><strong class="ak">克鲁斯卡尔的算法:</strong></h2><p id="0adc" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">这个算法在概念上非常简单。您可以按权重对边进行排序，并从最短到最长逐一检查以构建MST。如果每条边没有与树的现有边形成一个循环，那么将它们包含在MST中；否则，丢弃。继续操作，直到MST中有<code class="fe mv mw mx my b">|V|-1</code>条边。就这么简单。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ol"><img src="../Images/a3d854136d74ed77cc8aebba724522b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/1*Kd0pOSPj2wLtfpqrGIIqXQ.gif"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">克鲁斯卡尔算法的一个简单例子(来源:维基百科)</figcaption></figure><p id="4850" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个算法最重要的一步是检测一个周期。有几种算法来检测周期。最简单的一个就是我前面提到的使用DFS。然而，为了使用DFS，我们必须为每个MST创建一个图，这并不方便。因此，常见的替代方法是Union-Find算法，它可以用更少的代码行完成这项工作。</p><p id="da24" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> MST使用克鲁斯卡尔算法为我们的玩具举例:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><h2 id="2827" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">4.拓扑排序</h2><p id="91b9" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">这是一种排序形式，仅与Dag相关。简而言之，它是顶点的线性排序，对于每个有向边<code class="fe mv mw mx my b">uv</code>，<code class="fe mv mw mx my b">u</code>在排序中必须在<code class="fe mv mw mx my b">v </code>之前。</p><p id="add3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">求解拓扑排序有两种常用算法，一种是基于DFS的递归算法。另一种是被称为卡恩算法的迭代方法。</p><p id="bcb6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在递归方法中，对于所有顶点，该算法深入搜索以找到叶顶点，并将它们推送到堆栈。</p><p id="d0c8" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Kahn方法建立在关于DAG的已知事实上，即<strong class="kx iv">一个DAG至少有一个顶点没有输入边(输入度= 0)和一个顶点没有输出边(输出度= 0) </strong>。该算法首先计算所有顶点的入度，然后根据它们的入度值对它们进行排队。时间复杂度为<strong class="kx iv"> O(V+E) </strong>。</p><p id="d72a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我提供了这两种方法的代码。因为，我们的玩具例子不是一只狗。所以，我在下图中测试了我的代码。这个图有多个拓扑排序解。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj om"><img src="../Images/a5b9f320eeb703a253bf4bce3edf4dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*FFrae16sG9nUKWpmjpKfLA.jpeg"/></div><figcaption class="ls lt gk gi gj lu lv bd b be z dk translated">DAG示例</figcaption></figure><p id="4492" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">使用DFS的拓扑排序对于我们的示例:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><p id="8ea8" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">在我们的例子中使用Kahn算法的拓扑排序:</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nc nd l"/></div></figure><h2 id="1e0a" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">可视化源</h2><p id="90eb" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">图形问题可以通过可视化更好地学习。在这里，我将向您介绍两个最流行的可视化资源。一个是旧金山大学的CS page ( <a class="ae og" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" rel="noopener ugc nofollow" target="_blank">这里是</a>)，它为CS数据结构和算法提供了许多漂亮而直观的可视化。另一个是<a class="ae og" href="https://visualgo.net/en" rel="noopener ugc nofollow" target="_blank"> VisuAlgo </a>(这里)，它是为CS的复杂算法提供良好的可视化而构建的。</p></div><div class="ab cl on oo hy op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="in io ip iq ir"><h2 id="a05b" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">第1页.树</h2><p id="5567" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">树是图形的一种形式，具有以下属性:</p><ul class=""><li id="aa0f" class="ne nf iu kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated">顶点数和边数的固定关系:顶点数为<code class="fe mv mw mx my b">N</code>的树有<code class="fe mv mw mx my b">N-1</code>条边。</li><li id="4319" class="ne nf iu kx b ky ob lb oc le od li oe lm of lq nj nk nl nm bi translated">所有子节点都可以从根节点到达。</li><li id="2792" class="ne nf iu kx b ky ob lb oc le od li oe lm of lq nj nk nl nm bi translated">无循环(只允许一条从根到节点的路径)</li></ul><h2 id="b702" class="lw lx iu bd ly lz ma dn mb mc md dp me le mf mg mh li mi mj mk lm ml mm mn mo bi translated">P.S.2. Dijkstra对Bellman-Ford</h2><p id="0781" class="pw-post-body-paragraph kv kw iu kx b ky mp jv la lb mq jy ld le mr lg lh li ms lk ll lm mt lo lp lq in bi translated">学习这两种算法内部机制的直观方法是将它们与BFS和DFS联系起来。Dijkstra与BFS的工作方式有一些相似之处。这是一个贪婪的算法。另一方面，Bellman-Ford使用自下而上的方法，类似于动态编程和DFS的递归风格。</p></div><div class="ab cl on oo hy op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="in io ip iq ir"><p id="19e0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，考虑注册<a class="ae og" href="https://medium.com/@smohajer85/membership" rel="noopener">成为一名媒体成员</a>。每月只需5美元，你就可以无限制地使用Medium。</p></div></div>    
</body>
</html>