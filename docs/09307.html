<html>
<head>
<title>Extend the Android Jetpack Navigation Component: Telephone &amp; Web URLs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展Android Jetpack导航组件:电话和网络URL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/extend-the-android-jetpack-navigation-component-part-i-telephone-web-urls-29bc410a6948?source=collection_archive---------14-----------------------#2021-07-25">https://levelup.gitconnected.com/extend-the-android-jetpack-navigation-component-part-i-telephone-web-urls-29bc410a6948?source=collection_archive---------14-----------------------#2021-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8838" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将Jetpack推向新的高度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6b016c4f3f711686b9c5eeea1d51fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FO3jkz3Z76VTqGH89QiGwA.jpeg"/></div></div></figure><p id="671b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Android Jetpack导航组件革新并标准化了Android上的路由方式。然而，随着每一次演进，都有一个学习曲线来使现有的约定适应新的实现。让我们看看如何修改这个库来将用户路由到电话号码和web URLs。</p><h1 id="4bd8" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">电话处理员</h1><p id="40ac" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我在同一篇文章中将电话和web URLs的处理程序分组在一起，因为它们是相似的。然而，首先，我将只关注电话和<code class="fe mn mo mp mq b">tel:</code>协议的实现。</p><h2 id="7c8c" class="mr lr it bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">期望</h2><p id="b3f2" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我想这个分机接受和路由到任何电话号码交给它。这样，如果我的应用程序能够路由到几个电话号码，我只需要导航图中的一个节点就可以处理所有的电话号码。</p><p id="a00f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就代码而言，我希望导航图是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">提议的电话导航模式</figcaption></figure><p id="d886" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到此目的地的路由应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">使用导航图路由到电话号码的示例代码</figcaption></figure><p id="fc44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">期望一定程度的容错也是合理的。具体来说，从没有电话拨号器的设备(如平板电脑)拨打电话不应该无声无息地失败，当然也不应该导致应用程序崩溃。在这个场景中，我想向用户显示这个号码，这样他或她就可以用座机打电话了。</p><p id="8819" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然期望已经设定，我们就可以开始实现了。</p><h2 id="8018" class="mr lr it bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">构建骨架</h2><p id="d902" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">每个自定义导航器都有一个基本框架，我们必须在深入研究之前实现它。我们的导航器的基础是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">电话导航仪骨架</figcaption></figure><p id="3693" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请允许我分解相关部分:</p><ul class=""><li id="2be4" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><code class="fe mn mo mp mq b">@Navigator.Name("telephone")</code> -将出现在导航图的XML文件中的节点名称。在这种情况下，我会使用<code class="fe mn mo mp mq b">&lt;telephone /&gt;</code>来创建这种目的地。</li><li id="d521" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><code class="fe mn mo mp mq b">Navigator&lt;&gt;</code> -所有的自定义导航器都必须继承这个类。</li><li id="10a2" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><code class="fe mn mo mp mq b">popBackStack() = true</code> -由于拨号器很可能是一个外部应用程序，您的图形不负责外部后台堆栈。因此，每当拨号器完成自身并返回到您的应用程序时，该目的地已经弹出，导航器指示<code class="fe mn mo mp mq b">true</code>移除成功。</li><li id="012f" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><code class="fe mn mo mp mq b">@NavDestination.ClassType(Activity::class)</code> -不是严格要求，但我喜欢给导航图一个这个目的地将会是什么样的视图的概念。由于Android的拨号器应用程序几乎肯定在你的应用程序之外，我认为它是某种通用的<code class="fe mn mo mp mq b">Activity</code>。</li><li id="9cc2" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">在这种情况下并不令人兴奋。这个类通常映射并获取从XML传递到Kotlin(或Java)代码的定制属性，以便进行后续处理。然而，由于我选择通过参数动态传递我的属性，所以我不需要在这里指定任何静态参数属性。</li></ul><h2 id="98b5" class="mr lr it bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">简单的实现</h2><p id="ae95" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">对于我们工作的第一次迭代，让我们忽略边缘情况，并假设当给定一个电话号码时，总有一个操作系统可以用来打电话的处理程序。按照预期，我们已经完成了<code class="fe mn mo mp mq b">createDestination()</code>和<code class="fe mn mo mp mq b">popBackStack()</code>方法的必要工作。剩下的就是<code class="fe mn mo mp mq b">navigate()</code>方法了。</p><p id="843e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您还记得我上面的XML示例，我希望名为<code class="fe mn mo mp mq b">phoneNumber</code>的<code class="fe mn mo mp mq b">&lt;argument /&gt;</code>提供数据，我需要正确地处理路由。该信息通过<code class="fe mn mo mp mq b">navigate()</code>功能上的<code class="fe mn mo mp mq b">args</code>参数获得。获取信息的方式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">简单的导航实现</figcaption></figure><p id="7e10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意方法末尾的<code class="fe mn mo mp mq b">return null</code>。这与<code class="fe mn mo mp mq b">popBackStack() = true</code>的原因相同。如果我返回了<code class="fe mn mo mp mq b">destination</code>，这将把这个导航器添加到当前应用程序的后台堆栈，并路由到外部拨号器。在这种情况下，我通过返回<code class="fe mn mo mp mq b">null</code>来离开我的后台堆栈的状态。不必管理另一个后台堆栈，这让我的工作变得更加轻松。</p><h2 id="6898" class="mr lr it bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">错误处理</h2><p id="5b39" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我在上面的实现中看到了三个突出的问题:</p><ol class=""><li id="5469" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp nx np nq nr bi translated">如果给定的电话号码为空或空白怎么办？</li><li id="63c8" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp nx np nq nr bi translated">号码无效怎么办？</li><li id="25f0" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp nx np nq nr bi translated">如果设备没有<code class="fe mn mo mp mq b">tel:</code>协议的处理程序(即没有拨号器应用程序)，该怎么办？</li></ol><p id="eead" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个和最后一个问题很容易解决。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">更强大的导航方法，具有错误处理功能</figcaption></figure><p id="dce1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个问题是一个相当大的滑坡。有几个为Android开发的库可以达到这个目的。分别是<a class="ae ny" href="https://go.oliverspryn.com/phonenumberutils" rel="noopener ugc nofollow" target="_blank"> PhoneNumberUtils </a>和<a class="ae ny" href="https://go.oliverspryn.com/libphonenumber" rel="noopener ugc nofollow" target="_blank"> libphonenumber </a>。然而，根据我的研究，每个库都有大量的陷阱，这些陷阱要么没有很好的理由，要么期望一个格式略有不同的数字，即使它仍然有效。我的建议是在导航器中放弃这种验证。在我开发的所有应用程序中，提供的电话号码都是预先确定的，要么是硬编码的，要么来自我们公司维护的数据库。的确，如果我们分发的是畸形的电话号码，我们要处理的问题比让它们从我们的电话导航仪中溜走更大。</p><h2 id="0953" class="mr lr it bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">使用</h2><p id="a34c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在我们开始使用新的导航器之前，导航主机必须意识到它的存在。这是通过将我们的导航器添加到现有支持的导航器列表中来实现的。</p><p id="b1da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，创建一个名为<code class="fe mn mo mp mq b">CustomNavHostFragment</code>的新导航主机，并像这样实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">支持电话导航器的导航主机片段</figcaption></figure><p id="2d9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，打开包含导航主机的活动的布局文件，将<code class="fe mn mo mp mq b">android:name</code>属性替换为您刚刚创建的导航主机的全限定类名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">实现自定义导航主机的片段容器视图</figcaption></figure><p id="bf25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，您可以自由地路由到新的目的地类型，就像本文开头所描述的那样。让我们将这个新的目的地添加到我们的<code class="fe mn mo mp mq b">nav_graph.xml</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">简化的导航图，显示使用中的电话目的地</figcaption></figure><p id="198a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这里，我们可以随心所欲地选择路线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">使用导航图路由到电话号码的示例代码</figcaption></figure><h1 id="674e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">Web URL处理程序</h1><p id="bf36" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">对于那些有web背景的人来说，知道HTTP处理程序和电话处理程序之间的唯一区别是协议可能并不奇怪。网页链接使用<code class="fe mn mo mp mq b">http:</code>或<code class="fe mn mo mp mq b">https:</code>，而电话使用<code class="fe mn mo mp mq b">tel:</code>。本节将介绍这种导航目的地在实现和预期方面的差异。</p><h2 id="22da" class="mr lr it bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">期望</h2><p id="d19e" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我希望这个目的地能够处理通过类似电话处理程序的参数传递给它的任何URL。它在导航图上的签名应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">建议的web URL/HTTP导航模式</figcaption></figure><p id="c016" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到此目的地的路由应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">使用导航图路由到URL的示例代码</figcaption></figure><p id="6fd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你已经开发了一个被成千上万人使用的应用，你已经习惯了思考边缘情况。只要设备上没有HTTP处理程序，这个处理程序就应该能够恢复。是的。它发生了。我的Web URL处理程序的第一次迭代没有考虑到这种情况，最终会在没有Web浏览器的设备上崩溃。这是一个疯狂的世界。</p><h2 id="bf17" class="mr lr it bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">实施</h2><p id="8e3f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">首先，复制<code class="fe mn mo mp mq b">TelephoneNavigator</code>的整个实现，并如下所示进行调整。在这种情况下，由于代码非常相似，我将只包括不同之处，以便您可以更改相关部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">HTTP navigator只强调它与电话导航器之间的区别</figcaption></figure><h2 id="f417" class="mr lr it bd ls ms mt dn lw mu mv dp ma ld mw mx mc lh my mz me ll na nb mg nc bi translated">使用</h2><p id="d8e3" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">再一次，这一部分是电话导航器使用的清洗、漂洗和重复，尽管使用了<code class="fe mn mo mp mq b">&lt;http /&gt;</code>标签而不是<code class="fe mn mo mp mq b">&lt;telephone /&gt;</code>。请记住，您可以向<code class="fe mn mo mp mq b">CustomNavHostFragment</code>添加任意数量的自定义导航器。因此，如果你的应用程序需要这两种导航器，把它们添加到列表中并使用它们。</p><h1 id="5e25" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="dd6b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我希望您喜欢我在这个系列中的第一篇文章。希望它让您很好地理解了向导航工具集添加自定义附件的基本技术。由于它们的相似性，这两个是我期望分组的唯一扩展。即将到来的导航库的改编将提供更多的洞察力，让我们作为工程师能够更好地利用这个工具。</p><p id="6e26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是一些我用来帮助我收集想法和构建这种导航器的资源:</p><ul class=""><li id="2cb7" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated"><a class="ae ny" href="https://go.oliverspryn.com/getting-started-with-the-navigation-component" rel="noopener ugc nofollow" target="_blank">安卓导航组件文档</a></li><li id="0b95" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><a class="ae ny" href="https://go.oliverspryn.com/dialog-navigator" rel="noopener ugc nofollow" target="_blank">自定义对话框导航器</a></li><li id="faa9" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated"><a class="ae ny" href="https://go.oliverspryn.com/jetpack-navigation-with-custom-views" rel="noopener ugc nofollow" target="_blank">带有自定义视图的Jetpack导航</a></li></ul><h1 id="09ca" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">喜欢你读的东西吗？</h1><p id="1607" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">媒体上还有成千上万篇类似的文章。我是这个网站的付费会员，我完全认为这项投资是值得的。<a class="ae ny" href="https://go.oliverspryn.com/medium-membership" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">点击此处加入</strong> </a>，你将以你的一部分会员身份支持我的工作。</p><p id="ba6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文最初发表于<a class="ae ny" href="https://go.oliverspryn.com/extend-the-android-jetpack-navigation-component-telephone-and-web-urls" rel="noopener ugc nofollow" target="_blank">https://oliverspryn.com/</a>。<a class="ae ny" href="https://go.oliverspryn.com/medium-subscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">加入我的邮件列表。</strong> </a></p></div></div>    
</body>
</html>