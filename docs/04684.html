<html>
<head>
<title>Understanding Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解身份验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-authentication-fa0f0893c302?source=collection_archive---------13-----------------------#2020-07-09">https://levelup.gitconnected.com/understanding-authentication-fa0f0893c302?source=collection_archive---------13-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e289" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Python的散列函数简介</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="ccc6" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">问题是</h2><p id="acf3" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">当你登录到任何网站，你发送你的用户名和密码。然后网站接收它们，寻找用户名，检查密码是否一致，然后让你进入。</p><p id="4e73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单？哈！</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/b47de996108dcfd2e77be55d3dba6907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqbzIKtxah82KprrxE6dRg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">资料来源:kindpng.com</figcaption></figure><p id="9bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果数据库存储了你所有的密码，那么它有多安全？如果有人可以访问它，比如说数据库管理员，那么他或她就可以访问任何用户的所有数据。</p><p id="d879" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如说，你在谷歌工作，你和安全部门有关系。你能得到任何一个谷歌用户的密码吗？当然不是。</p><p id="cfd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果密码没有存储在数据库中，那么当用户登录时，如何检查密码呢？</p><p id="9c63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要以某种方式加密密码。</p><blockquote class="mj mk ml"><p id="f72a" class="jq jr mm js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">我们在数据库中存储了一个加密的密码。当用户输入密码时，系统也会对其进行加密，然后检查加密后的密码是否与数据库中存储的密码一致。</p></blockquote><p id="2977" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果加密的密码在数据库里，为什么我们不能简单地解密它？因为我们用单向函数加密。</p><p id="e0b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，给定一个加密函数<code class="fe mq mr ms mt b">f</code>，计算<code class="fe mq mr ms mt b">f(x)=y</code>很快也很容易，但是现在，给定<code class="fe mq mr ms mt b">y</code>，计算这样一个<code class="fe mq mr ms mt b">x</code>，那个<code class="fe mq mr ms mt b">f(x)=y</code>，就变得极其困难。通常(这并不总是正确的)使用强力算法。也就是说，我们遍历所有密码组合，计算<code class="fe mq mr ms mt b">f(x)</code>，并检查结果是否与我们想要解码的给定加密密码一致。</p><p id="ef8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着，即使你有加密的单词，也很难恢复原始文本。这是如何实现的。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="98ab" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">哈希函数</h2><p id="45ad" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">哈希函数是单向函数的特例。不同之处在于它的输出是固定长度的。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mu"><img src="../Images/4cba0461e05d3dd92cd57510f37fe33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6WpitMMpfrlNQVgkp9Vjw.png"/></div></div></figure><p id="0bab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么它是如何工作的呢？有数百万种不同的散列函数，但我们使用Python制作了自己的散列函数。这个很简单。</p><pre class="lu lv lw lx gt mv mt mw mx aw my bi"><span id="8474" class="kv kw it mt b gy mz na l nb nc">def hash(text):<br/>  a = ["abc","ghg","qwe","fks","slp"]<br/>  return a[len(text) % 5]</span><span id="b71d" class="kv kw it mt b gy nd na l nb nc">print("Hash", hash("Password"))<br/>print("Hash", hash("Milk"))<br/>print("Hash", hash("a long password"))<br/>print("Hash", hash("anything"))</span></pre><p id="4a30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出是这样的:</p><pre class="lu lv lw lx gt mv mt mw mx aw my bi"><span id="1d5e" class="kv kw it mt b gy mz na l nb nc">Hash fks<br/>Hash slp<br/>Hash abc<br/>Hash fks</span></pre><p id="0e37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，“任何东西”和“密码”的散列是相同的。但现实中，这种情况也有可能发生。如果你有一个很长的字母、数字和符号的组合，可能会出现一些由5个字母组成的非常简单的密码有相同的散列码。为什么？因为如果你有一个返回128位的散列函数，那么“只有”2的128次方个散列组合。因此，一些密码必须共享相同的哈希代码。</p><p id="0b39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，由于散列是“fks ”,所以您永远无法恢复原始文本。首先，因为“原文”有几百万条。当然，你可以启动你的强力算法，在不到1秒钟的时间里，它会给你1000个符合这个散列的密码。</p><p id="0355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，我们的杂凑没那么好，但还是杂凑。让我们来看一个更好的散列函数。</p><pre class="lu lv lw lx gt mv mt mw mx aw my bi"><span id="3338" class="kv kw it mt b gy mz na l nb nc">import math</span><span id="60e0" class="kv kw it mt b gy nd na l nb nc">def hash(text):<br/>  a = "abcdefghijklmnopqrstuvwxyz"<br/>  sum = 0<br/>  the_hash = ""<br/>  for s in text:<br/>    sum += int(math.sin(ord(s))*500)<br/>  for i in range(5):<br/>    the_hash += a[(sum*ord(text[i%len(text)]))%len(a)]<br/>  return the_hash</span><span id="b2f0" class="kv kw it mt b gy nd na l nb nc">print("Hash", hash("Password"))<br/>print("Hash", hash("Passwork"))<br/>print("Hash", hash("Milk"))<br/>print("Hash", hash("a long password"))<br/>print("Hash", hash("anything"))</span></pre><p id="0b9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在的输出是:</p><pre class="lu lv lw lx gt mv mt mw mx aw my bi"><span id="f376" class="kv kw it mt b gy mz na l nb nc">Hash gfhht<br/>Hash uiggu<br/>Hash dxord<br/>Hash cckyc<br/>Hash uuwoa</span></pre><p id="b03c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你现在可以看到，即使单词“Password”和“Passwork”中的一个字母不同，它们的哈希值也是绝对不同的！</p><p id="54b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们的散列函数根据给定的输入返回5个符号。是的，给定一个哈希值，现在很难恢复原始文本。但是用5个符号会非常快。这就是为什么通常使用128和256位散列函数(对应于16和32字节)。</p><p id="c5f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，有些函数很受欢迎，几乎在任何系统中都可以使用。</p><p id="ec39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最受欢迎的功能有:</p><ul class=""><li id="2c7b" class="ne nf it js b jt ju jx jy kb ng kf nh kj ni kn nj nk nl nm bi translated">具有160、256和512位输出的SHA1、SHA256和SHA512(安全哈希算法)。</li><li id="7b9d" class="ne nf it js b jt nn jx no kb np kf nq kj nr kn nj nk nl nm bi translated">具有128位输出的MD5(消息摘要)。</li></ul></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="0d48" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">数字签名</h2><p id="b21c" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">那么什么是数字签名呢？</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ns"><img src="../Images/97afd35afd8a48a1905c8e5c67869646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGNv5CVAXTYRA2uLkvOnZA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">资料来源:oneflow.com</figcaption></figure><p id="2714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比方说，你在一份文件上签名，然后在上面签名。为什么别人不能用？别人怎么能确定是你签的字呢？</p><p id="e91c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于数字签名，应该有一个验证器，它拥有每个用户的密钥。这些密钥有时被称为证书。</p><p id="f2c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，有了这个密钥和一个文档，就可以对附加了密钥的文档运行散列函数。这已经是签名了。当需要验证时，验证者会将您的密钥再次添加到已签名的文档中，计算散列值，并检查它是否匹配。</p><p id="07cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，就是这么简单。</p><p id="b52c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果文档发生变化，哈希也会完全改变。而且只有你可以在哈希之前附加密钥，所以只有你可以在文档上签名。</p><p id="3ec5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个简单的例子:</p><pre class="lu lv lw lx gt mv mt mw mx aw my bi"><span id="b430" class="kv kw it mt b gy mz na l nb nc">key = "Key1"<br/>wrong_key = "Key2"<br/>document = "I will play football"<br/>wrong_document = "I will not play football"<br/>print("Correct: ", hash(document+key))<br/>print("Incorrect document: ", hash(wrong_document+key))<br/>print("Incorrect key: ", hash(document+wrong_key))</span></pre><p id="3816" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你是安全专家，是这方面的专业人士，你可能会说这都不是真的，我们需要一个共享密钥和一个私有密钥，但是拜托，保持简单:)</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="e02e" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">蜂窝网络认证</h2><p id="6ca2" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">现在，当你知道如何签署文件时，你就可以很容易地理解你的SIM卡如何保护你的手机。</p><p id="20df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，它让一些人感到惊讶，但SIM卡是一台计算机。它有自己的处理器(故意非常慢)和内存(RAM用于你的联系人，ROM用于256位密钥和一些软件)。</p><p id="5392" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">密钥是随机的，只有您的提供商和您的SIM卡知道。甚至你的手机也没有。</p><p id="b4a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你打开手机时，最近的手机发射塔会发送一个随机数字，并要求签名。你的手机不能做到这一点，所以它把这个号码传输到SIM卡。SIM用它的密钥对它进行签名，并返回到电话(只有签名，没有密钥)。最后，您的手机会将签名发送给提供商。</p><p id="8c30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以黑吗？当然可以:)</p><p id="d300" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">黑客建造假的移动电话站，询问你的手机进行认证。他们发送一些数字并要求签名，每次都拒绝签名。所以如果你用走路的速度路过，可以签100个左右的号。并存储。如果你每天在上班的路上经过它，他们会在一个月内收集很多签名。</p><p id="c4f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，黑客没有密钥，但他们有一个带有正确签名的数字表！然后，他们充当一部手机，如果他们幸运的话，提供商要求在他们的名单上签一个号码，他们就能做到。</p><p id="f3b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么SIM卡处理器故意变慢？如果它足够快，它可以被暴力破解。因此，手里有一张SIM卡，人们可以在短时间内查询一百万个不同的签名。这也使得SIM卡无法复制。</p></div></div>    
</body>
</html>