<html>
<head>
<title>How I Implemented Realtime Search In React Using Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用钩子在React中实现实时搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-implemented-realtime-search-in-react-using-hooks-3c28121f8ed9?source=collection_archive---------6-----------------------#2021-06-24">https://levelup.gitconnected.com/how-i-implemented-realtime-search-in-react-using-hooks-3c28121f8ed9?source=collection_archive---------6-----------------------#2021-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5634" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">经典去抖实现的替代方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aa3c53fca9d8c15fe4e83ed3ad1b7e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DaHg1fyymuG-37YzfZbhFw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markuswinkler" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>在<a class="ae ky" href="https://unsplash.com/photos/afW1hht0NSs" rel="noopener ugc nofollow" target="_blank"> unsplash </a>上制作的基础图像</figcaption></figure><p id="3ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实时搜索是一种功能，用户可以键入他们的搜索查询并获得结果，而不必按下任何按钮来实际启动搜索。这是现代网络浏览器中非常流行的功能。</p><p id="f04f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的一个例子是google.com的搜索建议功能。当您键入查询时，建议列表会实时变化。在这里，我们将看看这种类型的搜索会出现的常见问题。我们还将尝试使用钩子来解决这些问题，而不是通常用来解决这个问题的常规方法。</p><p id="5837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示问题和解决方案，我们将致力于创建一个应用程序，用户将能够输入他们的名字，应用程序将尝试猜测他们的年龄。幸运的是，有一个API是由<a class="ae ky" href="https://agify.io/" rel="noopener ugc nofollow" target="_blank"> agify.io </a>提供的。我们的最终目标是创造出这样的东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/31f8366cd7f824c62eccbec86b82da86.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/1*NGijpEB_NsQ4NFTqNW_4jA.gif"/></div></figure><p id="61d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看一个实现这一功能的简单解决方案。</p><h2 id="74ba" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">简单的解决办法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="74ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去吧！运行上面的代码笔，在文本字段中键入您的姓名。你有没有注意到任何奇怪的行为，除了可能弄错了你的年龄？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/7e8dec35b9551d1ade2c61bd2174b6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/1*3U-KBFzk9ajw0KwVAcX7bA.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">每次击键时更新年龄和姓名</figcaption></figure><p id="1e11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题是每次击键时文本都会更新。有很多闪烁，并且用户不知道名叫<code class="fe mr ms mt mu b">cl</code>或<code class="fe mr ms mt mu b">pet</code>或<code class="fe mr ms mt mu b">bruc</code>的人的年龄；你明白了。就用户体验而言，这并不好，因为用户可能很难理解正在发生的事情。</p><p id="19a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也导致了对API的一堆不需要的请求。如果你去看看devtools，你会看到大量不必要的请求。</p><p id="037c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这是一个按请求数量收费的API，那么你最终可能会收到比你想要的更多的账单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/e9688122c8734bcc31e34ef63a00eb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*3ZBI0qrlq5lrG-LD1927SA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们不需要的过多的API请求</figcaption></figure><p id="2164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经典解法</strong></p><p id="8dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这类问题的经典解决方案是使用去抖。这种技术已经存在了很长时间，并在类似的情况下使用。然而，这将导致它自己的问题。我们先来看看什么是去抖。</p><ul class=""><li id="ba78" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">每当调用去抖功能时，就会开始倒计时。只有在倒计时达到0后，才会执行该功能。递减计数的值可以由开发人员设置。</li><li id="4421" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">如果在倒计时结束前再次调用该函数，则倒计时将重新开始。</li></ul><p id="6b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码演示了这种行为。请注意，我们正在使用lodash库中的<a class="ae ky" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank">去抖函数，而不是自己编写。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建一个<code class="fe mr ms mt mu b">myFn</code>的“去抖版本”，延迟3000ms (3秒)。然后，我们调用这个函数一次，并在1000毫秒(1秒)的额外延迟后再次调用它。最后，<code class="fe mr ms mt mu b">myFn</code>应该在不到4000毫秒的时间内运行，并打印运行后的时间。</p><p id="1313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到结果中显示的延迟可能大于4000毫秒。这仅仅是因为JavaScript的核心机制之一，称为事件循环。</p><p id="099e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件循环超出了本文的范围。如果你想了解更多关于它和其他JavaScript的内部知识(这对任何JavaScript开发者来说都是巨大的帮助),那么请查看Uday Hiwarale的这篇文章。虽然很长，但很值得。</p><div class="nm nn gp gr no np"><a href="https://medium.com/jspoint/how-javascript-works-in-browser-and-node-ab7d0d09ac2f" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">JavaScript和JavaScript引擎在浏览器和节点中是如何工作的？</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">JavaScript的调用栈、事件循环、任务队列和其他各种组成JavaScript的部分。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><p id="88ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看看如何利用去抖来解决这个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e5e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这解决了我们每次击键更新年龄的问题。但是，该名称仍然会在每次击键时更新。看下面的gif。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/4f1ed32a27d19066160ae4ee4ae1c979.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/1*npVclU29JzGc57M9-9I95Q.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用户键入姓名时出现不一致</figcaption></figure><p id="70c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在用户发出的第一个查询中，它说年龄无法猜测。此外，当用户开始键入另一个名字时，文本会将前一个人的年龄显示为当前人的年龄。</p><p id="bbd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看更新文本的代码来解决问题:</p><pre class="kj kk kl km gt oe mu of og aw oh bi"><span id="e505" class="lw lx it mu b gy oi oj l ok ol">function AgeText({ name, age, loading }) {<br/>  if (!name) return "";<br/>  if (loading) return `Hello ${name}! Your age is ...`;<br/>  if (typeof age === "number") {<br/>    return `Hello ${name}! Your age is ${age}`;<br/>  } else {<br/>    return `Sorry ${name}! I could not guess your age!`;<br/>  }<br/>}</span></pre><p id="bf98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当用户键入名字时，<code class="fe mr ms mt mu b">loading = false</code>因为只有当去抖功能实际运行时，加载才被设置为<code class="fe mr ms mt mu b">true</code>。这是在<code class="fe mr ms mt mu b">600ms</code>之后，如果用户停止输入的话。因此，在输入过程中，<code class="fe mr ms mt mu b">AgeText</code>将总是绕过<code class="fe mr ms mt mu b">if (loading)</code>检查并显示与最后一个请求相关的<code class="fe mr ms mt mu b">age</code>。</p><p id="e081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，最简单的方法是在<code class="fe mr ms mt mu b">useEffect</code>内部将loading设置为true，而不是在请求之前。但是这将意味着<code class="fe mr ms mt mu b">setLoading(true)</code>和<code class="fe mr ms mt mu b">setLoading(false)</code>被设置在完全不同的地方。这可能会给维护代码带来一些困难。它也不能解决用户输入时名称更新的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/96f5379ee2ea52d328885bbf2b16e7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/1*GLS8nHaTTnOMnbAuR6ogVw.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">去抖+ setLoading(true)在useEffect内部</figcaption></figure><p id="d3e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，为了解决这个问题，您可能会引入第二个状态，<code class="fe mr ms mt mu b">searchedName</code>并在搜索结束后更新<code class="fe mr ms mt mu b">searchedName</code>。如果你把<code class="fe mr ms mt mu b">searchedName</code>传给<code class="fe mr ms mt mu b">AgeText</code>，而不是把<code class="fe mr ms mt mu b">name</code>传给<code class="fe mr ms mt mu b">AgeText</code>，问题就解决了。</p><p id="2231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是使用此方法的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于去抖解决方案，最让我困扰的是<code class="fe mr ms mt mu b">useMemo</code>调用。我们不能在组件外准备去抖函数，因为这个函数需要访问组件范围内的函数，如<code class="fe mr ms mt mu b">setLoading</code>和<code class="fe mr ms mt mu b">setGuessedAge</code>。</p><p id="64c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在这里不使用<code class="fe mr ms mt mu b">useMemo</code>，那么去抖功能将无法工作。这是因为每次重新渲染组件时都会重新创建去抖功能。每当用户在输入字段中键入内容时，都会发生这种重新呈现。如果你想看到它的运行，那么我欢迎你从上面的codepen中移除<code class="fe mr ms mt mu b">useMemo</code>并尝试一下。</p><p id="7d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着找到一个更简单的解决方法。</p><h2 id="3223" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">自定义挂钩解决方案</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案使用了一个名为<code class="fe mr ms mt mu b">useDelayedValue</code>的定制钩子。</p><pre class="kj kk kl km gt oe mu of og aw oh bi"><span id="8225" class="lw lx it mu b gy oi oj l ok ol">function useDelayedValue (srcValue, delay = 0) {<br/>  const [value, setValue] = useState(srcValue);<br/>  useEffect(() =&gt; {<br/>    const timer = setTimeout(<br/>      () =&gt; setValue(srcValue),<br/>      delay<br/>    );<br/>    return () =&gt; clearTimeout(timer);<br/>  }, [srcValue, delay]);<br/>  return value;<br/>}</span></pre><p id="63df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它所做的就是接受一个值(<code class="fe mr ms mt mu b">srcValue</code>)，并返回另一个与<code class="fe mr ms mt mu b">srcValue</code>相关的值。但是，它只会在经过<code class="fe mr ms mt mu b">delay</code>毫秒后返回更新值。如果延迟尚未结束，它将返回旧值。这意味着在开发人员定义的一些最小延迟之后，<code class="fe mr ms mt mu b">return value</code>将总是最终等于<code class="fe mr ms mt mu b">srcValue</code>。</p><p id="9b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，这有点类似于函数的反跳，但这里的优点是它不必像函数反跳那样担心作用域和其他绑定。</p><p id="809d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以将这个延迟值用于实际的搜索和显示，并使用原始值绑定到输入字段。</p><p id="d25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在逻辑上也说得通。您需要原始的<code class="fe mr ms mt mu b">inputName</code>以便将值绑定到<code class="fe mr ms mt mu b">input</code>字段。您需要<code class="fe mr ms mt mu b">nameToRequest</code>来执行实际的请求。这是两个独立的用例。它们之间唯一的关系是用于请求的值(<code class="fe mr ms mt mu b">nameToRequest</code>)来自用户输入的值(<code class="fe mr ms mt mu b">inputName</code>)。</p><p id="6af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个钩子使得我们的主<code class="fe mr ms mt mu b">App</code>组件的逻辑更加简单。在渲染过程中，不需要借助使用<code class="fe mr ms mt mu b">useMemo</code>来创建去抖动功能。代码现在比使用去抖动时简单多了，并且<code class="fe mr ms mt mu b">useDelayedValue</code>的“稍微复杂”的实现隐藏/抽象在另一个函数中。</p><h2 id="3597" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">最后的想法</h2><p id="e8fc" class="pw-post-body-paragraph kz la it lb b lc om ju le lf on jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">实时搜索是一个常见的功能，但它也有一些缺陷。一个请求优化问题来自不需要的API请求，一个一致性问题来自反应式组件中的绑定。去抖动通常用于处理请求优化问题。然而，处理一致性问题需要其他解决方案。然而，React中功能组件和钩子的流行为解决这两个问题的其他解决方案铺平了道路。</p></div></div>    
</body>
</html>