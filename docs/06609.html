<html>
<head>
<title>JavaScript Table Sorting (Part 2 of 2) — Enhancement!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript表格排序(第2部分，共2部分)—增强！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-table-sorting-part-2-of-2-enhancement-18fe607842b6?source=collection_archive---------3-----------------------#2020-12-11">https://levelup.gitconnected.com/javascript-table-sorting-part-2-of-2-enhancement-18fe607842b6?source=collection_archive---------3-----------------------#2020-12-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1608" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还没有读过，请务必阅读第1部分。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/8becf93ff80d0999a94594bc5bb2c1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WEBDoBZTyfvhGKD0"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">乔治·德西普里斯在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8389" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第1部分中，我展示了如何采用其他人的简单示例<a class="ae ko" href="https://medium.com/javascript-in-plain-english/easy-table-sorting-with-javascript-370d8d97cad8" rel="noopener">并对其稍加修改，将代码大小几乎减半。因为它已经很小了，所以现在我们有空间用更多的功能来增强它。</a></p><p id="92fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特别是使用包含我们的排序类型和数据收集方法的两个对象，为轻松添加更多类型的排序奠定了基础。</p><h1 id="7cf0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">新标题和标题标记</h1><p id="1f83" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了展示我们的新过滤器，我们需要一个包含新数据的新表。</p><p id="80f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">表格标题/表头是大部分更改发生的地方:</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="9e4d" class="mn lg it mj b gy mo mp l mq mr">&lt;table&gt;<br/>  &lt;caption data-tablesort-reset&gt;Regex, DateTime, Input sorting&lt;/caption&gt;<br/>  &lt;thead&gt;<br/>    &lt;tr&gt;<br/>      &lt;th<br/>        scope="col"<br/>        data-tablesort="text"<br/>       &gt;Name&lt;/th&gt;<br/>      &lt;th<br/>        scope="col"<br/>        data-tablesort="number"<br/>        data-tablesort-rxmatch="^\s*([0-9]+)"<br/>      &gt;Place&lt;/th&gt;<br/>      &lt;th<br/>        scope="col"<br/>        data-tablesort="date"<br/>      &gt;When&lt;/th&gt;<br/>      &lt;th<br/>        scope="col"<br/>        data-tablesort="valueText"<br/>      &gt;Designation&lt;/th&gt;<br/>     &lt;/tr&gt;<br/>  &lt;/thead&gt;</span></pre><p id="ba28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据属性用于以下内容:</p><h2 id="bf28" class="mn lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated"><strong class="ak">数据表排序复位</strong></h2><p id="870b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果出现在标题上，这个属性将告诉我们的JS制作一个按钮，将表格顺序重置为页面加载时的顺序。您不需要为此设置值，只要它的存在就足以触发。</p><h2 id="3900" class="mn lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">数据表排序</h2><p id="9709" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">列的排序类型。上一篇文章中“<strong class="js iu">日期</strong>”、“<strong class="js iu">编号</strong>”和“<strong class="js iu">文本</strong>”的现有值仍然存在，但是我们在这里添加了一些新值。</p><p id="6a00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“<strong class="js iu"> valueText </strong>”和“<strong class="js iu"> valueNumber </strong>”将深入表格单元格，查找第一个<code class="fe nd ne nf mj b">INPUT</code>、<code class="fe nd ne nf mj b">SELECT</code>、<code class="fe nd ne nf mj b">TEXTAREA</code>或<code class="fe nd ne nf mj b">BUTTON</code>并提取其值，而不是<code class="fe nd ne nf mj b">th.textContent</code>。如果没有找到这样的标签，将使用单元格的文本内容。</p><h2 id="ad1b" class="mn lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">数据表排序-rxmatch</h2><p id="e9b7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">一个正则表达式，输入到脚本端的<code class="fe nd ne nf mj b">new regExp()</code>中，检索到的内容将根据该表达式进行过滤。例如，我们将有一个“位置”列</p><h1 id="b40b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">新示例表格单元格</h1><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="993b" class="mn lg it mj b gy mo mp l mq mr">&lt;tr&gt;<br/>  &lt;th scope="row"&gt;Luke&lt;/th&gt;<br/>  &lt;td&gt;33rd&lt;/td&gt;<br/>  &lt;td&gt;&lt;time datetime="1978-05-25T17:00:00-05:00"&gt;A New Hope&lt;/time&lt;/td&gt;<br/>  &lt;td&gt;&lt;input value="Red Five" readonly&gt;&lt;/td&gt;<br/>&lt;/tr&gt;&lt;tr&gt;<br/>  &lt;th scope="row"&gt;Mara&lt;/th&gt;<br/>  &lt;td&gt;54th&lt;/td&gt;<br/>  &lt;td&gt;&lt;time datetime="1991-08-07T17:00:00-05:00"&gt;Heir to the Empire&lt;/time&lt;/td&gt;<br/>  &lt;td&gt;&lt;input value="Mother" readonly&gt;&lt;/td&gt;<br/>&lt;/tr&gt;&lt;!-- etc, etc --&gt;</span></pre><p id="7783" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，因为我们的“place”列有多位数，所以我们希望按数字排序，但那里有文本。标题<code class="fe nd ne nf mj b">^\s*([0–9]+)</code>中的正则表达式可以干净地提取它，把“st”、“nd”和“rd”留在剪辑室的地板上。</p><p id="1c98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“when”包括一个<code class="fe nd ne nf mj b">&lt;time&gt;</code>标签，其中的文本提供了一个描述，但是datetime具有我们想要排序的实际值。因为它被设置为<code class="fe nd ne nf mj b">data-tablesort=”date”</code>，我们的新脚本将被设置为提取<code class="fe nd ne nf mj b">datetime</code>，而不是文本。</p><h1 id="3d75" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">脚本</h1><p id="b4ac" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">对基础脚本进行了更多的修改，以进一步完善内容。许多更复杂的循环被“for/of”所抛弃，以减少代码量。实际上，速度差虽然存在，但在这里可以忽略不计。特别是比较功能:</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="7e10" class="mn lg it mj b gy mo mp l mq mr">comps = {<br/>  number : function(a, b) {<br/>    return a.value - b.value;<br/>  },<br/>  text : function(a, b) {<br/>    return a.value &gt; b.value ? 1 : a.value &lt; b.value ? -1 : 0;<br/>  }<br/>},</span></pre><p id="9f6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进行了重构，这样我们就不需要额外的包装匿名来从排序对象中提取“值”。</p><h2 id="7f21" class="mn lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">RegExp内容过滤</h2><p id="a2b1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这里我们首先需要的是一种将正则表达式传递给数据提取方法的方法。我廉价地使用了一个<code class="fe nd ne nf mj b">rxMatch </code>变量，我把它应用到生活中。我知道有些人会说把它作为一个参数来传递，但这是我们不需要的。尤其是因为处于会减慢速度的循环中。不要在循环中做任何不必要的事情。<br/>它在我们的排序事件处理程序中获得一个值。首先，我们制作正则表达式本身:</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="376c" class="mn lg it mj b gy mo mp l mq mr">regex = (<br/>  th.dataset.tablesortRxmatch ?<br/>  new RegExp(th.dataset.tablesortRxmatch) :<br/>  false<br/>),</span></pre><p id="a625" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们创建实际的匹配函数本身。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="d86c" class="mn lg it mj b gy mo mp l mq mr">rxMatch = (<br/>  regex ?<br/>  function(text) {<br/>    var result = text.match(regex);<br/>    return result == null ? "" : result[0];<br/>  } :<br/>  function(text) { return text; }<br/>);</span></pre><p id="14a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf mj b">rxMatch </code>又一次被限定为生命，而不是<code class="fe nd ne nf mj b">tablesort </code>函数。<br/> <code class="fe nd ne nf mj b">rxMatch </code>如果没有有效的regex将简单地返回文本。与在每个该死的数据提取器中编写一个“if”语句相比，只调用一个除了盲返回之外什么也不做的函数更容易、更简单、更快。<br/>这导致我们的提取器让它们的各种文本通过我们的过滤器，因此:</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="2fbf" class="mn lg it mj b gy mo mp l mq mr">text : {<br/>  get : function(cell) {<br/>    return rxMatch(cell.textContent);<br/>  },<br/>  sort : comps.text<br/>},</span></pre><h2 id="bead" class="mn lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">“日期”和<time>标签</time></h2><p id="7e5d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当我们说按日期排序时，如果有时间标签，就向上拉。不难熬。我们只是修改了现有“日期”提取器:</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="cd2c" class="mn lg it mj b gy mo mp l mq mr">date : {<br/>  get : function(cell) {<br/>    var time = cell.querySelector("time");<br/>    if (time) {<br/>      var datetime = time.getAttribute("datetime");<br/>      return Date.parse(datetime || rxMatch(time.textContent));<br/>    }<br/>    return Date.parse(rxMatch(cell.textContent));<br/>  },<br/>  sort : comps.number<br/>},</span></pre><p id="6702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们找到第一个时间标签，如果存在，我们看看它是否有日期时间。如果是的话，我们就把它用于我们的<code class="fe nd ne nf mj b">Date.parse</code>，否则就给它一个<code class="fe nd ne nf mj b">rxMatch</code>标签的内容。如果两者都没有找到，则用<code class="fe nd ne nf mj b">rxMatch</code>代替<code class="fe nd ne nf mj b">cell.textContent</code>。</p><h2 id="b8f0" class="mn lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">表单元素值</h2><p id="53df" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这些例程类似于时间/日期时间代码。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="813d" class="mn lg it mj b gy mo mp l mq mr">valueText : {<br/>  get : function(cell) {<br/>    var formElement = cell.querySelector(<br/>      "input, select, textarea, button"<br/>    );<br/>    return rxMatch(<br/>      formElement ? formElement.value : cell.textContent<br/>    );<br/>  },<br/>  sort : comps.text<br/>}</span></pre><p id="7608" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用querySelector获取单元格中的第一个表单元素，然后rxmatch该元素的值，如果没有找到表单元素，则rx match该单元格的textcontent。</p><p id="ae64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单的柠檬榨汁机</p><h2 id="c51e" class="mn lg it bd lh ms mt dn ll mu mv dp lp kb mw mx lt kf my mz lx kj na nb mb nc bi translated">重置表单</h2><p id="050a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">要添加我们的重置按钮，我们只需拉动所有具有我们想要的数据属性的<code class="fe nd ne nf mj b">&lt;caption&gt;</code>。</p><p id="2700" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在它们中的每一个上，我们都需要一种方法来存储它们的原始位置。如果HTML元素有某种存储数据的地方就好了…哦，等等，我们有数据属性！我们能用那个吗？</p><p id="b544" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ng">种……</em></p><p id="d872" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf mj b">Element.dataset</code>属性只允许您在页面加载时设置在标记中声明的数据属性的值。您不能通过数据集创建新的。我们能做的是使用<code class="fe nd ne nf mj b">setAttribute</code>和<code class="fe nd ne nf mj b">getAttribute</code>来设置这样的值。这些<code class="fe nd ne nf mj b">dataset</code>见不到它们，但大不了鸣笛！</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="419c" class="mn lg it mj b gy mo mp l mq mr">for (var caption of d.querySelectorAll("caption[data-tablesort-reset]")) {<br/>  var i = 0;<br/>  for (var tr of caption.parentNode.querySelectorAll("tbody tr")) {<br/>    tr.setAttribute("data-tablesortKey", i++);<br/>  }<br/>  makeButton("Reset Sort", tableReset, caption);<br/>}</span></pre><p id="8de7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nd ne nf mj b">makeButton</code>是我创建的一个新函数，因为我们的页面解析循环都有很多按钮。现在很多人痴迷于将所有东西分解成不同的功能，不管你是否需要。我发誓，除非每一行代码都有一个函数，否则他们是不会满意的，而那些令人费解的“箭头函数”在这方面一点帮助都没有。</p><p id="9ce9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的思维模式是，如果你在两个不同的地方不止一次地做一件事，那么就做函数。否则就别想了，gimboid！</p><p id="00e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…如果创建一个功能有意义，就让它具有一些额外的功能，以便将来在其他地方使用。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="2dd9" class="mn lg it mj b gy mo mp l mq mr">function makeButton(text, click, parent, replace) {<br/>  var e = d.createElement("button");<br/>  e.type = "button";<br/>  if (text) e.textContent = text;<br/>  if (click) e.onclick = click;<br/>  if (parent) {<br/>   if (replace) parent.textContent = "";<br/>   parent.appendChild(e);<br/>  }<br/>  return e;<br/> }</span></pre><p id="f83d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建按钮标签，将类型设置为“button ”,因为默认值是“submit ”,我们不想用<code class="fe nd ne nf mj b">Event.preventDefault();</code>来瞎搞，如果我们传递了文本，则将它作为内容应用，如果我们传递了单击，将它作为我们的处理程序应用——同样，因为我们刚刚创建了它，所以我们可以只使用<code class="fe nd ne nf mj b">onclick</code>而不是<code class="fe nd ne nf mj b">addEventListener</code> —如果我们想要替换，如果有父检查，则删除内容。否则追加。最后，如果我们在未来需要添加其他属性到我们的新按钮，返回它。</p><p id="444e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数给了我们一个类似的添加排序执行器的重构。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="25d7" class="mn lg it mj b gy mo mp l mq mr">for (var th of d.querySelectorAll("th[data-tablesort]")) {<br/>  if (!sorts[th.dataset.tablesort]) continue;<br/>  makeButton(th.textContent, tableSort, th, true);<br/>}</span></pre><p id="f085" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比我们在第1部分中所做的要简单得多。</p><p id="869d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在重置回调本身:</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="a660" class="mn lg it mj b gy mo mp l mq mr">function tableReset(event) {</span><span id="b4a3" class="mn lg it mj b gy nh mp l mq mr">  var<br/>    table = event.currentTarget.parentNode.parentNode,<br/>    e = table.tHead.firstElementChild.firstElementChild;</span><span id="5104" class="mn lg it mj b gy nh mp l mq mr">  if (e) do {<br/>    if (e.firstElementChild.tagName == "BUTTON") {<br/>      e.firstElementChild.value = "";<br/>    }<br/>  } while (e = e.nextElementSibling);</span><span id="89ac" class="mn lg it mj b gy nh mp l mq mr">  sortAndSet(<br/>   table.tBodies[0],<br/>   comps.number,<br/>   function(row) {<br/>     return +row.getAttribute("data-tablesortKey");<br/>   });</span><span id="1154" class="mn lg it mj b gy nh mp l mq mr">} // tableReset</span></pre><p id="5bf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常简单。我们必须走着离开餐桌和第一次约会。我们循环查找thead中的按钮，并清空它们的值，说它们没有被排序，并触发CSS删除升序/降序指示符。我们称之为一个新函数<code class="fe nd ne nf mj b">sortAndSet</code>，它和<code class="fe nd ne nf mj b">makeButton</code>非常相似，我们也为普通的排序做同样的事情。</p><p id="12cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个参数是要排序的TBODY，第二个是比较函数，第三个是我们的数据提取器。</p><p id="b44b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这导致我们的表排序例程也被重构以使用这个新函数。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="ee05" class="mn lg it mj b gy mo mp l mq mr">function tableSort(event) {</span><span id="a517" class="mn lg it mj b gy nh mp l mq mr">  var<br/>    button = event.currentTarget,<br/>    th = button.parentNode,<br/>    type = sorts[th.dataset.tablesort],<br/>    regex = (<br/>      th.dataset.tablesortRxmatch ?<br/>      new RegExp(th.dataset.tablesortRxmatch) :<br/>      false<br/>    ),<br/>    e = th;</span><span id="46dd" class="mn lg it mj b gy nh mp l mq mr">  while (e = e.previousElementSibling) e.firstElementChild.value = "";<br/>  e = th;<br/>  while (e = e.nextElementSibling) e.firstElementChild.value = "";</span><span id="4e55" class="mn lg it mj b gy nh mp l mq mr">  rxMatch = (<br/>    regex ?<br/>    function(text) {<br/>     var result = text.match(regex);<br/>     return result == null ? "" : result[0];<br/>    } :<br/>    function(text) { return text; }<br/>  );</span><span id="90f4" class="mn lg it mj b gy nh mp l mq mr">  sortAndSet(<br/>    th.parentNode.parentNode.parentNode.tBodies[0],<br/>    (<br/>      (button.value = button.value == 1 ? 0 : 1) ?<br/>      type.sort :<br/>      function(a, b) { return type.sort(b, a); }<br/>    ),<br/>    function(row) {<br/>      return type.get(row.cells[th.cellIndex]);<br/>    }<br/>  );</span><span id="e7a0" class="mn lg it mj b gy nh mp l mq mr">} // tablesort</span></pre><p id="b7e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和以前一样，我们不需要遍历来引用表上的各种元素。您可以在添加regex和rxMatch声明的地方看到它们，最后是sortAndSet。</p><p id="7e58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们将回调传递给sortAndSet，所以我们可以根据需要将各种经过评估的匿名函数放入其中。</p><p id="7d20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们的附加功能。</p><h1 id="6ba5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">现场演示</h1><div class="ni nj gp gr nk nl"><a href="https://cutcodedown.com/for_others/medium_articles/tableSort/robust/tableSort.html" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">使用JavaScript的高级表格排序</h2><div class="ns l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">cutcodedown.com</p></div></div></div></a></div><p id="d174" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同我所有的例子目录:<br/><a class="ae ko" href="https://cutcodedown.com/for_others/medium_articles/tableSort/robust/" rel="noopener ugc nofollow" target="_blank">https://cutcodedown . com/for _ others/medium _ articles/table sort/robust/</a></p><p id="ea15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是开放的，可以很容易地接触到后备箱里的垃圾，里面有一个完整的文件。</p><p id="0eda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于那些喜欢钢笔的人，给你！</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="6f6f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="d69e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们有将近4k的代码，但是它有很多额外的用处。最棒的是，对标记的侵入仅限于数据属性，这意味着您添加的任何页面也不会违反任何可访问性担忧。</p></div></div>    
</body>
</html>