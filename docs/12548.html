<html>
<head>
<title>How To Implement Method Chaining in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在C++中实现方法链</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-method-chaining-in-c-3ec9f255972a?source=collection_archive---------10-----------------------#2022-06-19">https://levelup.gitconnected.com/how-to-implement-method-chaining-in-c-3ec9f255972a?source=collection_archive---------10-----------------------#2022-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b75f" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">C++基础</h2><div class=""/><div class=""><h2 id="9d10" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">🖇Chain🖇Your🖇Methods🖇</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/96c949be0d84f0b49a0b5141acfaa56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O-J265neUsYZczDm"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@hush52?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hush Naidoo Jade摄影</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4dd7" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">介绍</h1><p id="bec3" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><strong class="lz ja">方法链接</strong>是使用OOPs原理设计软件的众多优点之一。这是一种一次性调用多个函数而不是分别调用它们的做法。也被称为<strong class="lz ja">参数习语</strong>。如果方法链接实现得当，它会使代码看起来更优雅，更容易阅读。本文关注的是C++，但是方法链接可以在任何基于OOPs的编程语言中实现。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="6814" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">如前所述，方法链是一种一次性调用多个函数的实践。在我们继续下一步之前，让我们深入了解类和对象的基础知识。假设有一个<code class="fe nf ng nh ni b"><strong class="lz ja">class List</strong></code>，它有两个功能<code class="fe nf ng nh ni b"><strong class="lz ja">append</strong></code> <strong class="lz ja"> </strong>和<code class="fe nf ng nh ni b"><strong class="lz ja">print</strong></code> <strong class="lz ja"> </strong>。所以要调用这些函数，我们首先需要创建一个<em class="nj"> List </em>类的对象。没有这个类的引用，我们将无法访问这些函数。</p><p id="f5c2" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">下面给出的代码片段展示了使用对象调用类方法的传统方式。</p><pre class="kp kq kr ks gt nk ni nl nm aw nn bi"><span id="f7a1" class="no lg iq ni b gy np nq l nr ns">List obj;<br/>obj.append(10);<br/>obj.append(20);<br/>obj.print();</span></pre><p id="ab29" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">下面给出的代码片段是我们的最终目标。</p><pre class="kp kq kr ks gt nk ni nl nm aw nn bi"><span id="b8b3" class="no lg iq ni b gy np nq l nr ns">List obj;<br/>obj.append(10).append(20).print();</span></pre><h2 id="ee04" class="no lg iq bd lh nt nu dn ll nv nw dp lp mg nx ny lr mk nz oa lt mo ob oc lv iw bi translated">先决条件:</h2><p id="d876" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">为了理解这篇文章，读者应该熟悉以下主题。</p><ul class=""><li id="99f6" class="od oe iq lz b ma na md nb mg of mk og mo oh ms oi oj ok ol bi translated">类别和对象</li><li id="b3cb" class="od oe iq lz b ma om md on mg oo mk op mo oq ms oi oj ok ol bi translated">遗产</li><li id="6000" class="od oe iq lz b ma om md on mg oo mk op mo oq ms oi oj ok ol bi translated"><strong class="lz ja">c++中的这个</strong>关键字(是指向当前对象实例的指针)</li><li id="64e8" class="od oe iq lz b ma om md on mg oo mk op mo oq ms oi oj ok ol bi translated">构造器</li><li id="8656" class="od oe iq lz b ma om md on mg oo mk op mo oq ms oi oj ok ol bi translated">模板</li><li id="e793" class="od oe iq lz b ma om md on mg oo mk op mo oq ms oi oj ok ol bi translated">铅字铸造</li></ul></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="ca26" class="lf lg iq bd lh li or lk ll lm os lo lp kf ot kg lr ki ou kj lt kl ov km lv lw bi translated">如果没有遗产</h1><p id="5ad3" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在这种情况下，实现方法链接非常简单。如前所述，要访问成员函数，我们需要一个该类的对象。所以如果我们从成员函数返回<strong class="lz ja">*这个</strong>，我们就实现了方法链接。</p><p id="99f1" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">在下面给出的例子中，有一个单独的类(<code class="fe nf ng nh ni b"><strong class="lz ja">class Employee</strong></code>)。在类<em class="nj"> Employee </em>、<strong class="lz ja">*的每个函数中都返回这个</strong>指针。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">不涉及继承时的方法链接。</figcaption></figure><p id="7f69" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">当运行上述代码片段时，获得的输出<strong class="lz ja"> </strong>为:</p><pre class="kp kq kr ks gt nk ni nl nm aw nn bi"><span id="e5f7" class="no lg iq ni b gy np nq l nr ns">ABC logged in<br/>ABC taking a break<br/>ABC logged out</span></pre><p id="abf4" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">如果我们<strong class="lz ja">不</strong>返回<strong class="lz ja"> *this，</strong>编译器会抛出下面的错误。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oy"><img src="../Images/b2794bd80ef3bebc0bbedf7ea7947696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jdG75dWjtqlF-q027VP9A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">当函数返回<strong class="bd lh">而不是</strong> *this执行方法链接时，编译器发出的错误消息。</figcaption></figure><h1 id="ccdd" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">在多级遗传的情况下</h1><p id="1067" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">当涉及到遗传时，事情就变得棘手了。假设我们有两个类:<code class="fe nf ng nh ni b">class Employee</code>和<code class="fe nf ng nh ni b">class Developer</code>，其中<em class="nj">开发者</em>派生自<em class="nj">雇员</em>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="fb98" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">现在，如果我们遵循前面的方法(return <strong class="lz ja"> *this </strong>)，编译器将抛出下面的错误消息。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oz"><img src="../Images/650be8847bb4d9d8f0b8c115d843bb96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwj8kBL4N-tfB4ziZdPxOQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">当类的函数返回<strong class="bd lh"> *this </strong>时编译器给出的错误信息。</figcaption></figure><p id="aede" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">这里的主要问题是返回类型。<code class="fe nf ng nh ni b">class Employee</code>的<code class="fe nf ng nh ni b">login</code>函数返回一个<code class="fe nf ng nh ni b">Employee</code>类型的引用，它没有任何名为work的成员函数。为了链接函数<code class="fe nf ng nh ni b">work</code>，我们需要类型<code class="fe nf ng nh ni b">Developer</code>的引用。</p><p id="53ee" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">为了解决这个问题，我们引入了<strong class="lz ja">模板</strong>。这里的想法是使基类成为泛型类，派生类在继承基类的同时使用自己作为模板参数。请参阅代码片段以获得更好的理解。</p><pre class="kp kq kr ks gt nk ni nl nm aw nn bi"><span id="837c" class="no lg iq ni b gy np nq l nr ns">template &lt;class BaseImpl&gt;<br/>class Base {};</span><span id="c79b" class="no lg iq ni b gy pa nq l nr ns">class Derived : public Base&lt;Derived&gt; {};</span></pre><p id="c66d" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">但是工作并没有在这里完成。在基类的方法中，我们需要将引用<code class="fe nf ng nh ni b">using static_cast</code>转换为派生类的类型，以毫不费力地链接这些方法。</p><blockquote class="pb pc pd"><p id="9d15" class="lx ly nj lz b ma na ka mc md nb kd mf pe nc mi mj pf nd mm mn pg ne mq mr ms ij bi translated">static_cast可以在指向相关类的指针之间执行转换，不仅是从派生类到其基类，还可以从基类到其派生类。</p></blockquote><pre class="kp kq kr ks gt nk ni nl nm aw nn bi"><span id="a1ca" class="no lg iq ni b gy np nq l nr ns">template &lt;class BaseImpl&gt;<br/>class Base {<br/>  public:<br/>  BaseImpl &amp;funcBase() {<br/>    // do your stuff<br/>    return static_cast&lt;BaseImpl&amp;&gt;(*this);<br/>  }<br/>};</span><span id="6643" class="no lg iq ni b gy pa nq l nr ns">class Derived : public Base &lt;Derived&gt; {<br/>  public:<br/>  Derived &amp;funcDerived() {<br/>    // do your stuff<br/>    return *this;<br/>  }<br/>};</span></pre><p id="af74" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">在下面给出的这个例子中，有3个类:<code class="fe nf ng nh ni b"><strong class="lz ja">class Employee</strong></code>、<code class="fe nf ng nh ni b"><strong class="lz ja">class Developer</strong></code>和<code class="fe nf ng nh ni b"><strong class="lz ja">class HR</strong></code>、<strong class="lz ja">、</strong>。</p><ul class=""><li id="ca4e" class="od oe iq lz b ma na md nb mg of mk og mo oh ms oi oj ok ol bi translated"><code class="fe nf ng nh ni b">class Employee</code>是通用基类。</li><li id="bf4c" class="od oe iq lz b ma om md on mg oo mk op mo oq ms oi oj ok ol bi translated"><code class="fe nf ng nh ni b">class Developer</code>和<code class="fe nf ng nh ni b">class HR</code>都将从<em class="nj">雇员</em>继承，并将自己作为模板参数<em class="nj">传递。</em></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">具有继承的方法链接</figcaption></figure><p id="7127" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">以上代码的输出:</p><pre class="kp kq kr ks gt nk ni nl nm aw nn bi"><span id="5520" class="no lg iq ni b gy np nq l nr ns">Name 1 logged in<br/>Name 1 writing code<br/>Name 1 taking a break<br/>Name 1 writing code<br/>Name 1 logged out</span><span id="f744" class="no lg iq ni b gy pa nq l nr ns">Name 2 logged in<br/>Name 2 organizing hiring drive<br/>Name 2 organizing company event<br/>Name 2 logged out</span></pre><p id="a56e" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated"><strong class="lz ja">第51行</strong>也可以写成:</p><pre class="kp kq kr ks gt nk ni nl nm aw nn bi"><span id="c469" class="no lg iq ni b gy np nq l nr ns">Developer dev("Name 1");<br/>dev.login().work().takeBreak().work().logout();</span></pre><p id="65a4" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">在具有3个或更多类的多级继承的情况下:</p><pre class="kp kq kr ks gt nk ni nl nm aw nn bi"><span id="601b" class="no lg iq ni b gy np nq l nr ns">template &lt;class Base1Impl&gt;<br/>class Base1 {<br/>  Base1Impl &amp;fun1() {<br/>    return static_cast&lt;Base1Impl&amp;&gt;(*this);<br/>  }<br/>};</span><span id="8393" class="no lg iq ni b gy pa nq l nr ns">template &lt;class Base2Impl&gt;<br/>class Base2 : public Base1 &lt;Base2Impl&gt; {<br/>  Base2Impl &amp;fun2() {<br/>    return static_cast&lt;Base2Impl&amp;&gt;(*this);<br/>  }<br/>};</span><span id="3e89" class="no lg iq ni b gy pa nq l nr ns">class Derived : public Base2 &lt;Derived&gt; {<br/>  Base2Impl &amp;fun3() {<br/>    return *this;<br/>  }<br/>};</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="8d77" class="pw-post-body-paragraph lx ly iq lz b ma na ka mc md nb kd mf mg nc mi mj mk nd mm mn mo ne mq mr ms ij bi translated">感谢您阅读这篇文章。希望这对你有帮助。在<a class="ae le" href="https://www.linkedin.com/in/ashish-yoel-585a6116a/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上和我联系。干杯🤜。</p><h2 id="771d" class="no lg iq bd lh nt nu dn ll nv nw dp lp mg nx ny lr mk nz oa lt mo ob oc lv iw bi translated">阅读更多</h2><div class="ph pi gp gr pj pk"><a href="https://en.wikipedia.org/wiki/Method_chaining" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd ja gy z fp pp fr fs pq fu fw iz bi translated">方法链接-维基百科</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">方法链，也称为命名参数习语，是调用多个方法调用的常用语法</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">en.wikipedia.org</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ky pk"/></div></div></a></div><div class="ph pi gp gr pj pk"><a href="https://www.geeksforgeeks.org/this-pointer-in-c/" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd ja gy z fp pp fr fs pq fu fw iz bi translated">C++中的this指针</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">要理解“this”指针，了解对象如何看待类的函数和数据成员是很重要的。每个…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="pt l"><div class="pz l pv pw px pt py ky pk"/></div></div></a></div><div class="ph pi gp gr pj pk"><a href="https://www.geeksforgeeks.org/static_cast-in-c-type-casting-operators/" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd ja gy z fp pp fr fs pq fu fw iz bi translated">C++中的static _ cast |类型转换运算符- GeeksforGeeks</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">转换运算符是一元运算符，它强制将一种数据类型转换为另一种数据类型。C++支持…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="pt l"><div class="qa l pv pw px pt py ky pk"/></div></div></a></div></div></div>    
</body>
</html>