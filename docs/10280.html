<html>
<head>
<title>NodeJS: Modify Running Server Behaviour From Outside</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS:从外部修改正在运行的服务器行为</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nodejs-modify-running-server-behaviour-from-outside-445cee1f02b7?source=collection_archive---------8-----------------------#2021-11-17">https://levelup.gitconnected.com/nodejs-modify-running-server-behaviour-from-outside-445cee1f02b7?source=collection_archive---------8-----------------------#2021-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你听说过Chrome DevTools协议吗？！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7c249d797f8984acf950ea333a138d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WewaZjfHc_PNt-r8.jpg"/></div></div></figure><h1 id="e8ec" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">开发工具</h1><p id="c6df" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我认识的每个工程师在职业生涯中都至少使用过一次DevTools。DevTools是一个非常有用的工具，它可以使调试NodeJS应用程序变得更加容易，当然，前提是你知道如何正确使用它。</p><p id="1f46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们大多数人认为这个工具是理所当然的，只需点击一下鼠标，我们就可以打开DevTools窗口并开始变魔术，但是我们如何在浏览器内部调试本地NodeJS进程呢？是如何实现的？主要问题是:我们如何实现我们的定制调试器？</p><p id="6bcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回答这些问题会给我们达到目标的力量。👀</p><h1 id="f413" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">目标</h1><p id="38cc" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">想象一下，我们有一个运行在本地机器上的Express服务器，在某个时刻，我们决定放弃所有传入的补丁请求，当然，我们可以停止我们的服务器→更改代码→再次运行服务器。但是我们能在不重启/停止服务器的情况下做到这一点吗？让我们看看</p><h1 id="cf5f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Chrome开发工具协议(CDP)</h1><blockquote class="ma mb mc"><p id="5804" class="jn jo md jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated"><strong class="jp ir"> Chrome DevTools协议</strong>允许工具对Chrome、Chrome和其他基于Blink的浏览器进行检测、检查、调试和分析。许多现有项目目前使用该协议。Chrome DevTools 使用这个协议，团队维护它的API。</p></blockquote><p id="0cc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，CDP是一种帮助我们连接应用并调试它们的协议。CDP就像我们日常使用的任何其他协议一样，所以因为我们是工程师，所以我们可以用它来构建/做任何事情。</p><p id="8922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CDP有写得相当好的<a class="ae mh" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank">文档</a>，许多有用和流行的工具在幕后使用它。比如:<a class="ae mh" href="https://github.com/puppeteer/puppeteer" rel="noopener ugc nofollow" target="_blank">popputer</a>、<a class="ae mh" href="https://github.com/GoogleChrome/lighthouse" rel="noopener ugc nofollow" target="_blank"> lighthous </a>、<a class="ae mh" href="https://github.com/Microsoft/vscode-chrome-debug/" rel="noopener ugc nofollow" target="_blank"> vs-code调试器</a>、<a class="ae mh" href="https://github.com/microsoft/playwright" rel="noopener ugc nofollow" target="_blank">剧作家</a>等等。</p><h1 id="7897" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">履行</h1><p id="8b08" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">首先，让我们用ExpressJS引导一个简单的Hello World应用程序，并记录传入请求的方法</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="656d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mk ml mm mn b">node app.js</code>, simple express服务器将启动并监听<code class="fe mk ml mm mn b">3000</code>端口。让我们向它抛出一些请求来证明它是有效的。</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="813a" class="ms ky iq mn b gy mt mu l mv mw">Input<br/>---&gt;<br/>curl -s  --request PATCH '<a class="ae mh" href="http://localhost:3000/'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/'</a><br/>curl -s  --request GET '<a class="ae mh" href="http://localhost:3000/'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/'</a><br/>---&gt;</span><span id="2fb2" class="ms ky iq mn b gy mx mu l mv mw">Server Output<br/>---&gt;<br/>Example app listening at <a class="ae mh" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a><br/>PATCH<br/>GET <br/>---&gt;</span></pre><p id="25f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">启动后，我们需要告诉NodeJS应用程序监听调试客户端(换句话说就是CDP连接)。为此，我们可以用<code class="fe mk ml mm mn b">--inspect</code>开关启动我们的应用程序，或者我们可以发送<code class="fe mk ml mm mn b">SIGUSR1</code>信号，节点将自动处理它。</p><p id="36e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们不想停止我们的服务器，为了向进程发送信号，我们需要一个PID，我们可以用<code class="fe mk ml mm mn b">lsof -i :3000</code>命令得到它，之后执行<code class="fe mk ml mm mn b">kill -SIGUSR1 {PID}</code>将启用调试模式，我们的应用程序现在看起来像这样:</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="2a5e" class="ms ky iq mn b gy mt mu l mv mw">---&gt;<br/>Example app listening at <a class="ae mh" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a><br/>Debugger listening on ws://127.0.0.1:9229/a58914a2-86d7-4990-bdf9-53a43e5cb47d<br/>For help, see: <a class="ae mh" href="https://nodejs.org/en/docs/inspector" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/docs/inspector</a><br/>---&gt;</span></pre><p id="c7b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个正在运行的服务器，在9229端口(NodeJS默认的CDP端口)等待CDP连接，剩下唯一要做的就是写客户端部分。</p><p id="6241" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们将逐行讨论的CDP客户端代码→</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h2 id="3b99" class="ms ky iq bd kz my mz dn ld na nb dp lh jy nc nd ll kc ne nf lp kg ng nh lt ni bi translated">#1连接到过程→</h2><p id="447e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在<code class="fe mk ml mm mn b">NODE_DEFAULT_DEBUGGER_PORT</code>创建CDP连接</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="7ec4" class="ms ky iq mn b gy mt mu l mv mw">const cdp = <em class="md">await</em> CDP({ port: 9229 });</span></pre><h2 id="b50e" class="ms ky iq bd kz my mz dn ld na nb dp lh jy nc nd ll kc ne nf lp kg ng nh lt ni bi translated">#2启用运行时评估→</h2><p id="e287" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">启用通过远程评估和镜像对象公开JavaScript运行时的运行时域</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="0e19" class="ms ky iq mn b gy mt mu l mv mw"><em class="md">await</em> cdp.Runtime.enable();</span></pre><h2 id="2762" class="ms ky iq bd kz my mz dn ld na nb dp lh jy nc nd ll kc ne nf lp kg ng nh lt ni bi translated">#3获取HTTP服务器的原型→</h2><p id="06fb" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">使用<code class="fe mk ml mm mn b">cdp.Runtime</code>域，我们可以查询任何JS运行时对象，结果作为镜像对象返回，该对象公开了对象类型、字符串表示和唯一标识符，可用于进一步的对象引用。</p><p id="56ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Express应用程序都使用<code class="fe mk ml mm mn b">http</code> API，<code class="fe mk ml mm mn b">app.listen</code>调用<code class="fe mk ml mm mn b">require(‘http’).createServer</code>创建新的<code class="fe mk ml mm mn b">http.Server</code>实例。既然每个物体都有它的原型，那就让我们开始着手<code class="fe mk ml mm mn b">http.Server.prototype</code></p><p id="b188" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何做到这一点？幸运的是，有了<code class="fe mk ml mm mn b">Runtime.evaluate</code>，我们可以在我们所连接的进程中评估任何代码，所以让我们来寻找我们的原型</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="e63b" class="ms ky iq mn b gy mt mu l mv mw">const prototype = <em class="md">await</em> cdp.Runtime.evaluate({<br/>    // specify which prototype we want<br/>    expression: "require('http').Server.prototype",</span><span id="2a91" class="ms ky iq mn b gy mx mu l mv mw">    // this is required for "require" to work<br/>    includeCommandLineAPI: true, <br/>    <br/>    // True we need a pointer to the prototype of <!-- -->http.Server<!-- --> in the <br/>    // process heap, otherwise it would return JSON object.<br/>    returnByValue: false,<br/>});</span></pre><h2 id="0dfb" class="ms ky iq bd kz my mz dn ld na nb dp lh jy nc nd ll kc ne nf lp kg ng nh lt ni bi translated">#4获取对象指针→</h2><p id="4aae" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们有一个指向<code class="fe mk ml mm mn b">http.Server</code>原型的指针，现在是时候用这个原型获得实际的对象镜像了，<code class="fe mk ml mm mn b">Runtime.queryObjects</code>返回一个指向数组的指针。该数组包含以<code class="fe mk ml mm mn b">http.Server.prototype</code>为原型的对象列表。</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="c1de" class="ms ky iq mn b gy mt mu l mv mw">const listOfObjects = <em class="md">await</em> cdp.Runtime.queryObjects({<br/>    // specify prototype for objects<br/>    prototypeObjectId: prototype.result.objectId,<br/>});</span></pre><h2 id="7ed1" class="ms ky iq bd kz my mz dn ld na nb dp lh jy nc nd ll kc ne nf lp kg ng nh lt ni bi translated">#5获取服务器实例→</h2><p id="e2e4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们用<code class="fe mk ml mm mn b">http.Server.prototype</code>获取了所有对象指针，现在我们需要JS运行时中该对象的实际实例，它们在我们的流程中被初始化。<code class="fe mk ml mm mn b">Runtime.getProperties</code>返回包含实际实例的指针列表的数组。</p><p id="dc3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们只有一个http服务器在运行，返回的数组将只包含一个元素。现在我们在<code class="fe mk ml mm mn b">result[0].value.objectId</code>有了我们想要的实例</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="4769" class="ms ky iq mn b gy mt mu l mv mw">const listOfInstances = <em class="md">await</em> cdp.Runtime.getProperties({<br/>    // specify objectId<br/>    objectId: listOfObjects.objects.objectId,<br/>});</span><span id="74d5" class="ms ky iq mn b gy mx mu l mv mw">// select first instance from result array<br/>const serverInstance = listOfInstances.result[0].value.objectId;</span></pre><h2 id="931e" class="ms ky iq bd kz my mz dn ld na nb dp lh jy nc nd ll kc ne nf lp kg ng nh lt ni bi translated">#6有趣的部分开始了！→</h2><p id="bf3e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们的目标是覆盖<code class="fe mk ml mm mn b">http.Server</code>的监听器，为此我们需要编写一些函数，从实例中移除监听器，将它们封装在其他神奇的函数中，这些函数会丢弃补丁请求，然后再添加回去。</p><p id="6c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在其他<code class="fe mk ml mm mn b">cool_code.js</code>文件中定义了这个函数，否则我不得不在普通字符串中实现它，这是我比调试CSS更讨厌的事情。我们将在完成<code class="fe mk ml mm mn b">inject.js</code>后通过<code class="fe mk ml mm mn b">cool_code</code>。我们希望在流程中评估的代码是:</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="56de" class="ms ky iq mn b gy mt mu l mv mw">var overRideListeners = require(`./injectable`).overRideListeners</span></pre><p id="2b77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这定义了一个全局函数<code class="fe mk ml mm mn b">overRideListeners</code>(稍后实现)，它将负责拦截HTTP请求。</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="e0b2" class="ms ky iq mn b gy mt mu l mv mw"><em class="md">await</em> cdp.Runtime.evaluate({<br/>    expression:<br/>            `var overRideListeners = require('./cool_code')<br/>                                               .overRideListeners`, <br/>    includeCommandLineAPI: true,<br/>    returnByValue: false,<br/>});</span></pre><h2 id="af73" class="ms ky iq bd kz my mz dn ld na nb dp lh jy nc nd ll kc ne nf lp kg ng nh lt ni bi translated">#7压倒一切！→</h2><p id="8751" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">因此，我们在流程内部声明了一个神奇的函数，为了达到我们的目标，现在我们需要在http实例上调用这个函数。我们之前收购的服务器。令人惊讶的是<code class="fe mk ml mm mn b">Runtime</code>提供了一个方法<code class="fe mk ml mm mn b">callFunctionOn</code>，它确实做到了这一点。</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="d67f" class="ms ky iq mn b gy mt mu l mv mw"><em class="md">await</em> cdp.Runtime.callFunctionOn({<br/>    objectId: serverInstance,<br/>    functionDeclaration: "function() { overRideListeners(this) }",</span><span id="398b" class="ms ky iq mn b gy mx mu l mv mw">    returnByValue: true,<br/>});</span></pre><h2 id="5ee8" class="ms ky iq bd kz my mz dn ld na nb dp lh jy nc nd ll kc ne nf lp kg ng nh lt ni bi translated">#8清理→</h2><p id="7fe2" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在这一点上，如果我们做的一切都是正确的(剧透:我们做到了)，我们的Express应用程序应该不会处理来自网络的补丁请求。</p><p id="cb17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一剩下的事情就是看到<code class="fe mk ml mm mn b">cool_code</code>的实现。</p><p id="a832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同时，让我们成为优秀的工程师，关闭打开的连接+释放我们获得的指针。</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="fc0f" class="ms ky iq mn b gy mt mu l mv mw"><em class="md">await</em> cdp.Runtime.releaseObject({ objectId: serverInstance });<br/><em class="md">await</em> cdp.close();</span></pre><h1 id="404b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">酷代码</h1><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="412d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了覆盖<code class="fe mk ml mm mn b">http.Server</code>监听器，我们需要<code class="fe mk ml mm mn b">Shimmer</code>，一个npm库，它做了大量必要的工作，将其他方法包装在您提供的包装器中。</p><p id="be28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mk ml mm mn b">overRideListener</code>循序渐进:</p><ul class=""><li id="4d22" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated">首先，我们检索<code class="fe mk ml mm mn b">request</code>事件的所有监听器并保存它们</li><li id="7c2a" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">删除当前侦听器</li><li id="a388" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">用<code class="fe mk ml mm mn b">Shimmer</code>覆盖它们</li><li id="9a07" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">放弃任何状态代码为405的修补程序请求</li><li id="841e" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">在<code class="fe mk ml mm mn b">request</code>事件上注册已修改的监听器</li></ul><p id="5135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是所有<code class="fe mk ml mm mn b">overRideListener</code>做的，是的，我知道这并不酷。</p><h1 id="592e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">行动</h1><p id="fbfc" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在本文的第一部分，我们向我们的进程发送了<code class="fe mk ml mm mn b">SIGUSR1</code>信号，这意味着它仍在等待CDP连接，我们有一个准备好的客户端，让我们让它发生</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="1400" class="ms ky iq mn b gy mt mu l mv mw">node inject.js // activate injection script</span></pre><p id="19c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此消息应该出现在服务器的日志中</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="fb3d" class="ms ky iq mn b gy mt mu l mv mw">Debugger attached.</span></pre><p id="1e03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着也许我们做的一切都是对的，是时候再次向我们的服务器抛出一些请求了</p><pre class="km kn ko kp gt mo mn mp mq aw mr bi"><span id="2785" class="ms ky iq mn b gy mt mu l mv mw">Input<br/>---&gt;<br/>curl -s  --request PATCH '<a class="ae mh" href="http://localhost:3000/'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/'</a><br/>curl -s  --request PATCH '<a class="ae mh" href="http://localhost:3000/'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/'</a><br/>curl -s  --request GET '<a class="ae mh" href="http://localhost:3000/'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/'</a><br/>---&gt;</span><span id="e7fe" class="ms ky iq mn b gy mx mu l mv mw">Server Output<br/>---&gt;<br/>Example app listening at <a class="ae mh" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a><br/>GET <br/>---&gt;</span></pre><h1 id="2621" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="8c4d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">正如您所看到的，在执行inject.js之后，我们的进程丢弃了来自网络的每个传入补丁请求，但是像以前一样响应GET请求，这意味着我们在不停止/重新启动进程的情况下改变了运行NodeJS应用程序的行为——任务完成。</p><p id="9c83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CDP是一个非常酷的工具，可以使开发变得更加容易。它有多个域，可以通过舒适的、记录良好的API进行访问。在本文中，我们只使用了运行时域，但是CDP还有更多。其中之一是网络域，它暴露了关于HTTP、文件、数据和其他请求和响应的信息，它们的头、主体、时间等。</p><p id="8990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我在寻找一种以特定格式收集本地服务器内存使用情况的方法时，我来到了CDP，Chrome内置的DevTool对此没有提供任何东西，经过一些研究后，我来到了CDP，并有了拥有自己的调试器+分析器的想法。</p><p id="0997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这很有趣。</p><p id="5d1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有任何问题→ <a class="ae mh" href="https://twitter.com/dudupopkhadze" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="1cf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐编码。</p></div></div>    
</body>
</html>