<html>
<head>
<title>TypeScript Compiler and Compiler API (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript编译器和编译器API(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-compiler-and-compiler-api-part-1-4bb0d24a565e?source=collection_archive---------8-----------------------#2021-11-02">https://levelup.gitconnected.com/typescript-compiler-and-compiler-api-part-1-4bb0d24a565e?source=collection_archive---------8-----------------------#2021-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bae5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释了TypeScript编译器的内部</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/862dae8c2e3791244012315ffd7615b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XnkUtnNuFNmGVaKPBEQYfg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@walkator?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">步行者</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="173f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用TypeScript几年后，我觉得我对这种语言有了很好的理解，只是我不知道编译器内部是如何工作的。</p><p id="b040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我有机会深入了解这个我知之甚少的领域，并想与你分享我所学到的东西。</p><p id="8d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解TypeScript编译器和API的内部机制可能对你的日常工作没有直接的帮助。然而，如果您需要改进构建管道，或者开发定制工具，这将是非常有价值的。</p><p id="bfec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为关于TypeScript编译器的两篇文章的第1部分，我们将讨论TypeScript编译器的内部过程。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="01a6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">编译器流程概述</h2><p id="f230" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">TypeScript编译器将源代码转换成JavaScript文件。以下是该过程的概述。</p><ol class=""><li id="6a43" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">TypeScript scanner扫描源代码并将其转换为令牌流。</li><li id="c2c3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">解析器解析令牌流得到AST ( <a class="ae ky" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a>)；</li><li id="874b" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">Binder遍历AST并生成一系列符号，并将这些符号连接到相应的节点。</li><li id="b779" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">Checker执行类型检查。这一步需要大部分时间。</li><li id="5012" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">Emitter生成最终输出:基于AST的JavaScript文件。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/0ed169d878a06a6c7973e514e910134d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJsDsdxws17NpW5RDSAuxg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">编译过程</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6e3f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">关键组件</h2><p id="e10d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">以下是编译器源代码的关键部分</p><ul class=""><li id="cfbe" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu np ng nh ni bi translated">程序:它是编译器的核心。它在<a class="ae ky" href="https://github.com/Microsoft/TypeScript/blob/main/src/compiler/program.ts" rel="noopener ugc nofollow" target="_blank"> program.ts </a>中定义。它由源文件和编译器选项组成。</li><li id="f9d8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu np ng nh ni bi translated">编译器主机:它被程序用来与系统交互</li><li id="aac5" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu np ng nh ni bi translated">系统:编译器用来与操作系统交互的接口。</li><li id="9b2b" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu np ng nh ni bi translated">其他子组件:扫描器(<code class="fe nq nr ns nt b"><a class="ae ky" href="https://github.com/Microsoft/TypeScript/blob/main/src/compiler/scanner.ts" rel="noopener ugc nofollow" target="_blank">scanner.ts</a></code>)、解析器(<code class="fe nq nr ns nt b"><a class="ae ky" href="https://github.com/gcanti/parser-ts" rel="noopener ugc nofollow" target="_blank">parser.ts</a></code>)、绑定器(<code class="fe nq nr ns nt b"><a class="ae ky" href="https://github.com/microsoft/TypeScript/blob/master/src/compiler/binder.ts" rel="noopener ugc nofollow" target="_blank">binder.ts</a></code>)、检查器(<code class="fe nq nr ns nt b"><a class="ae ky" href="https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts" rel="noopener ugc nofollow" target="_blank">checker.ts</a></code>)、发射器(<code class="fe nq nr ns nt b"><a class="ae ky" href="https://github.com/Microsoft/TypeScript/blob/master/src/compiler/emitter.ts" rel="noopener ugc nofollow" target="_blank">emitter.ts</a></code>)</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="c01d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">扫描仪</h2><p id="19a7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">编译的第一步是<a class="ae ky" href="https://en.wikipedia.org/wiki/Lexical_analysis" rel="noopener ugc nofollow" target="_blank">词法分析</a>。就是把源代码转换成一系列的令牌，并对每个令牌进行分类。</p><p id="3371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扫描器的目的是执行词法分析，识别标记以及它们在源文件中的位置。扫描器的主要逻辑是读取输入字符，并在<a class="ae ky" href="https://github.com/Microsoft/TypeScript/blob/94b4f8b79e370020cb31995e8fb0b78f9ba94349/src/compiler/scanner.ts#L1237" rel="noopener ugc nofollow" target="_blank">扫描</a>方法中模拟<a class="ae ky" href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton" rel="noopener ugc nofollow" target="_blank"> DFA </a>(确定性有限自动机)。TypeScript扫描仪源代码是<a class="ae ky" href="https://github.com/Microsoft/TypeScript/blob/94b4f8b79e370020cb31995e8fb0b78f9ba94349/src/compiler/scanner.ts" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="54d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在CompilerHost的驱动下，Parser初始化一个singleton Scanner实例，并使用它来获取令牌流。它使用它的解析器函数根据扫描器的输出创建AST。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2aa0" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">大西洋时间</h2><p id="0b77" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如上图“编译流程”所示，流程的关键是</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="7ff7" class="mc md it nt b gy ny nz l oa ob">Source =&gt; tokens =&gt; AST =&gt; symbols =&gt; Type checking =&gt; JavaScript</span></pre><p id="348b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AST是整个过程的核心。AST就像一棵源代码语法树。这棵树有许多节点。节点包含相关源代码中节点的类型、构造和位置。</p><p id="c3fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解AST，我们可以使用<a class="ae ky" href="https://ts-ast-viewer.com/" rel="noopener ugc nofollow" target="_blank"> AST查看器</a>。对于如下的简单函数</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="89e6" class="mc md it nt b gy ny nz l oa ob">function add(a: number, b: number) {<br/>   return a + b;<br/>}</span></pre><p id="2d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AST树看起来像这样</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/80d5a603fff1e0f49210a87ac90100af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BCFgAMWF_eKQ5oH4uQqew.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">AST及其根节点</figcaption></figure><p id="ff01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的右侧部分是这个AST的根节点。它表示源文件。根包含两个子节点:一个<code class="fe nq nr ns nt b">FunctionDeclaration </code>和代表源文件结尾的<code class="fe nq nr ns nt b">EndOfFileToken</code>。<code class="fe nq nr ns nt b">FunctionDeclaration</code>包括两个<code class="fe nq nr ns nt b">parameter </code>节点和一个<code class="fe nq nr ns nt b">Block </code>节点。在Block节点内部，有一个包含一个<code class="fe nq nr ns nt b">BinaryExpression</code>的<code class="fe nq nr ns nt b">ReturnStatement </code>。</p><p id="64d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查器如何基于AST执行类型检查？要回答这个问题，我们首先需要了解binder是如何工作的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="693d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">活页夹和检查器</h2><p id="79a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/microsoft/TypeScript/blob/main/src/compiler/binder.ts" rel="noopener ugc nofollow" target="_blank"> <em class="od">绑定器</em> </a>横向绑定一个AST，并为每个节点创建一个符号。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="d72d" class="mc md it nt b gy ny nz l oa ob">AST =&gt; Binder =&gt; Symbols+AST =&gt; Checker =&gt; Type checking</span></pre><p id="d459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">符号是语义系统的基石。它是命名声明，将AST中的声明节点连接到构成同一实体的其他声明。</p><p id="cbb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">符号有两个重要属性:</p><ul class=""><li id="abc9" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu np ng nh ni bi translated"><code class="fe nq nr ns nt b">members</code>:类、接口或文字实例成员</li><li id="e864" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu np ng nh ni bi translated"><code class="fe nq nr ns nt b">exports</code>:模块导出</li></ul><p id="9de6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了来自<code class="fe nq nr ns nt b">members </code>和<code class="fe nq nr ns nt b">exports</code>的信息，我们将能够用它的符号识别一个类实例或模块。</p><p id="02ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Binder创建符号后，检查器使用符号和AST来检查给定代码的语义。</p><p id="011f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">checker是一个有20，000多行代码的程序。这表明处理类型检查有多复杂。毫不奇怪，类型检查是整个过程中最耗时的步骤。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a971" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">发射器</h2><p id="7108" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">发射器可以发出JavaScript文件或类型定义文件。当被<code class="fe nq nr ns nt b">Program</code>调用时，最终输出(很可能是JavaScript文件)由<code class="fe nq nr ns nt b">emit </code>函数生成。</p><pre class="kj kk kl km gt nu nt nv nw aw nx bi"><span id="46d6" class="mc md it nt b gy ny nz l oa ob">AST + Checker =&gt; emitter =&gt; JS</span></pre><p id="5238" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上概述只是触及了TypeScript编译器的皮毛。如果你有兴趣了解更多，我推荐你读一读《打字稿深潜》这本书。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="276f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">摘要</h2><p id="5724" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们对TypeScript编译器的内部过程有了基本的了解。</p><p id="b552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器内部的知识是有用的。我们可以在AST之上开发一个定制的linter，或者静态分析工具。这类工具的一个很好的例子是VSCode使用的语言服务器。</p><p id="4e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript提供的另一个强大工具是编译器API。它公开了一个丰富的API，允许我们与TypeScript交互。如果需要的话，我们可以用它来构建一个定制的编译器。</p><p id="8b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二部分中，我们将讨论语言服务器，以及如何利用TypeScript编译器API。</p></div></div>    
</body>
</html>