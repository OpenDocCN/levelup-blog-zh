<html>
<head>
<title>JavaScript Unit Testing for .NET Developers — Part 2 Testing and Mocking with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript单元测试。NET开发人员—第2部分用Jest测试和嘲弄</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-unit-testing-for-net-developers-part-2-testing-and-mocking-with-jest-1c2d44828c26?source=collection_archive---------0-----------------------#2019-08-17">https://levelup.gitconnected.com/javascript-unit-testing-for-net-developers-part-2-testing-and-mocking-with-jest-1c2d44828c26?source=collection_archive---------0-----------------------#2019-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/560fd6adc73ddcb987e77fe638cb7c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlwlXm3jm62534Q3jEyzFg.jpeg"/></div></div></figure><h1 id="a37f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="e6a4" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在第一部分中，我们概述了本系列的目标以及我们的工具设置。在第二部分中，我们将开始讨论在ES6中使用Jest对JavaScript进行单元测试，以及在Visual Studio和测试C#等经典OOP语言中相似之处的开始和结束。</p><p id="d1e5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在这一部分，我们将涉及:</p><ul class=""><li id="27d5" class="mc md it lb b lc lx lg ly lk me lo mf ls mg lw mh mi mj mk bi translated">JavaScript中的公共和私有</li><li id="6257" class="mc md it lb b lc ml lg mm lk mn lo mo ls mp lw mh mi mj mk bi translated">依赖性和让自己的测试更容易</li><li id="9a60" class="mc md it lb b lc ml lg mm lk mn lo mo ls mp lw mh mi mj mk bi translated">JavaScript用Jest模仿并创造了它们</li><li id="e234" class="mc md it lb b lc ml lg mm lk mn lo mo ls mp lw mh mi mj mk bi translated">测试功能和副作用</li></ul><h1 id="0a1a" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">JavaScript中的公共和私有</h1><p id="937d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当从. Net语言开始学习全新的JavaScript时，我们想知道的第一件事就是封装。从单元测试的角度来看，通过将一些东西变成公共的，而将另一些变成私有的，你就在类上建立了一个“这些是它能做的事情”的契约，并且通过扩展，公共的东西是你测试被测系统的方法。私有的东西是实现细节，只有类知道，你和下一个开发者可以看到公共的东西是如何实现的。</p><p id="5b98" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">显而易见，JavaScript中没有公共和私有关键字。我们在JavaScript中拥有的是作用域，以及在其他作用域中可用和可见的内容。</p><p id="96b0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为了证明这一点，让我们看看在ES6之前这是如何实现的。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e407" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里我们创建了一个相当于类的东西。我们创建了私有变量和函数以及公共属性和函数。我们创建了一个新的Foo对象并访问了public方法两次，一次从public属性中给它一个字符串，另一次强制它使用私有字符串变量。</p><p id="d1b8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在，让我们看看如何使用ES6实现相同的行为。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8af5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">上面的类可以像ES5版本一样使用。但是看看我们的私有变量和函数发生了什么，它们不再在类体内声明。这肯定会使私有变量和函数对所有东西都可用吗？</p><p id="cc44" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">不，ES6代码依赖于从JavaScript文件导入和导出的内容。要使用Foo类，您需要另一个JavaScript文件，如下所示:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d56f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">掌握export关键字，理解什么是以及如何使用从JavaScript文件导出的内容，是JavaScript测试和开发中的一个重要概念。在ES5中，我们只关心范围，尽管这是可行的，但在大型应用程序开发中会变得不实用。在ES6中，事情更加模块化，我们仍然有作用域，并且<code class="fe mw mx my mz b">const</code>和<code class="fe mw mx my mz b">let</code>单词允许我们创建变量，这些变量的工作方式与我们在中预期的一样。Net但是导出有点不一样。</p><p id="6353" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">你可以把一个JavaScript文件看作一个类，你可以在其中创建私有变量和函数，并且只导出你想要的类，如上所示。导出是灵活的，它允许你导出任何东西，如果你想用函数式风格开发，你可以把一个JavaScript文件当作一个没有任何类的函数库，只导出函数。您也可以只导出变量来创建可共享的常量值。</p><p id="5cc2" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">从根本上说，从JavaScript文件中导出的内容是公共的。然而，该文件的用户可以选择导入所有内容或选择性地选择他们想要的内容，这与使用. Net中的类或接口不同。参见<a class="ae na" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/web/JavaScript/reference/statements/export</a></p><h1 id="9fe6" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">依赖性和让你自己的测试更容易。</h1><p id="e1e4" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们已经建立了至少相当于。Net世界让我们来谈谈依赖。</p><p id="2ff5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们建立了public(或<code class="fe mw mx my mz b">export</code>)我们说这是我的类将做的东西，这是行为和可用的数据，到目前为止都是好东西。</p><p id="86a3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">不幸的是，从测试的角度来看，这不是很好。这不是很好的原因是因为你现在为自己的类或函数使用的<code class="fe mw mx my mz b">import</code>相当于C#中的<code class="fe mw mx my mz b">using</code>,你可以从命名空间中新建一个类。你可能听说过“哪里有新，哪里就有胶水”这句话。也就是说，您刚刚将您的代码耦合并硬绑定到您刚刚导入的代码。</p><p id="77f0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在solid中，依赖性反转原理声明:</p><ul class=""><li id="fca0" class="mc md it lb b lc lx lg ly lk me lo mf ls mg lw mh mi mj mk bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。</li><li id="5d18" class="mc md it lb b lc ml lg mm lk mn lo mo ls mp lw mh mi mj mk bi translated">抽象不应该依赖于细节。细节(具体实现)应该依赖于抽象</li></ul><p id="f7ff" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这两句话本质上可以总结为“你不应该依赖和新建包含实现细节的类，相反，你应该依赖和使用你的类实现的接口或抽象类，并且可以用多态来代替”。</p><p id="8d26" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">通过不依赖抽象，你的代码变成了耦合的。想象一下，您正在编写一个API，作为该API的一部分，您有一个控制器，它有一个服务类，本质上是系统内组件的包装器，如持久性和将数据保存到数据库。您的类和依赖项如下所示:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/0a4e9595365cff49298fed9011d26c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*i2heHFj5g7L3f22eZJJIKA.png"/></div></figure><p id="b2fc" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果您决定测试控制器或服务类，您别无选择，只能称之为集成测试。没有较低级别的组件，您无法独立测试单个组件。相反，DI原则教导我们的和我们通常做的。Net就是有一些看起来更像这样的东西:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2331ed7dd70d6c801e7297e695b8c0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*ye9sthnTD7C8CAXKk6wrNw.png"/></div></figure><p id="0b8b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里我们颠倒了控制流程。当然，我们有更多的东西，但是在测试控制器时，我可以通过创建一个stub或mock <code class="fe mw mx my mz b">IService</code>来独立于服务类测试它。在测试控制器时，我创建并使用了假对象，这样我也可以更好地控制我的预期输出。</p><p id="477a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这对我们已经习惯的东西来说很好，但是我们现在在JavaScript领域，JavaScript没有接口。这是否意味着我们被困在依赖低级细节中？</p><p id="d240" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">不，一点也不。Jest有内置的方法来获得与在中使用Moq相同的功能。Net，它只是以一种你意想不到的方式工作，我们接下来会谈到这一点。但在我们这样做之前，我希望我已经明白了，通过进口和直接使用出口的东西，你是在把自己耦合到它上面，而不是使用Jest中的一些技巧。</p><p id="9666" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如前所述，JavaScript没有接口。它确实有鸭子类型，这意味着如果你有一个对象有一个名为<code class="fe mw mx my mz b">doStuff</code>的方法，而你有另一个对象也有一个名为<code class="fe mw mx my mz b">doStuff</code>的方法，这些对象和方法是可以互换的，JavaScript不会抱怨它们是不同的类。例如:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6853" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在上面的代码片段中，两个记录器都是可互换的，并且<code class="fe mw mx my mz b">MyImportantClass</code>并不关心它得到哪个类，只是它将使用具有log方法的东西。这是JavaScript的依赖注入。</p><p id="f3e1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">将依赖项注入到类中比在JavaScript文件中导入和使用组件要好得多。这些依赖关系当然需要被导入到某个地方，并且它们需要以某种方式进入到将要使用它们的类中。如果你正在使用React，你已经在以一种模块化的方式思考，并且应该考虑分离和组件化你的组件。为此，你应该考虑非可视容器组件和可视组件。</p><p id="4367" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您的容器组件本质上是您的复合根。这些是导入所有依赖项并将它们注入到可视化组件中的组件。强烈推荐你阅读<a class="ae na" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">https://medium . com/@ Dan _ abra mov/smart-and-dumb-components-7 ca 2 f 9 a 7 c 7d 0</a>。如果你同时使用React和Redux，你可以使用像<code class="fe mw mx my mz b">mapStateToProps</code>和<code class="fe mw mx my mz b">mapDispatchToProps</code>这样的方法，它们允许你将依赖注入到组件的props中。</p><p id="ee8b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">重要的是要意识到你导入和使用的越多，你以后需要做的就越多。这未必是一件坏事，毕竟Jest可以很容易地为您注入这些依赖项，但在我看来，使用duck typing和手工创建您自己的模拟来注入它们作为依赖项比单独使用Jest更容易。你必须保持务实，意识到这种来自进口的耦合是有好处的。</p><h1 id="00c8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">JavaScript用Jest模仿并创造了它们</h1><p id="b403" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在我们开始用Jest模拟之前，让我们快速看一下测试套件和单元测试。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="32b7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">上面我们有一个单一的测试套件和一个单一的测试，这是你用Jest设置一个测试的最低要求。你可以从NUnit so <code class="fe mw mx my mz b">beforeEach</code>、<code class="fe mw mx my mz b">afterEach</code>等中得到相同的设置和拆卸方法(关于expect<a class="ae na" href="https://jestjs.io/docs/en/expect" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/en/expect</a>的断言，参见<a class="ae na" href="https://jestjs.io/docs/en/setup-teardown.html" rel="noopener ugc nofollow" target="_blank">https://jestjs.io/docs/en/setup-teardown.html</a></p><p id="e066" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在让我们来看一个实际的例子。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3f18" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">上面是一个redux reducer的例子，用于改变redux应用程序中的区域设置，但这并不重要。重要的是，我们的文件中有两个依赖项，一个用于<code class="fe mw mx my mz b">defaultLocalProvider</code>，另一个用于<code class="fe mw mx my mz b">localActionTypes</code>。我不太关心<code class="fe mw mx my mz b">localeActionTypes</code>，但我更关心<code class="fe mw mx my mz b">defaultLocaleProvider</code>。它有一些实现细节，这些细节依赖于获取浏览器的语言环境并将其解析为一种格式，这种格式可以在以后用于识别正确的本地化文件。与我们的减速器无关。</p><p id="3d0c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们想要的是我们的<code class="fe mw mx my mz b">defaultLocaleProvider</code>的模拟实现，以返回我们可以测试的东西，一些我们可以在测试中预期的可靠的东西。</p><p id="4e89" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们需要做的是告诉jest在运行测试时寻找<code class="fe mw mx my mz b">defaultLocaleProvider</code>的模拟实现:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="cb01" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">上面我们已经导入了<code class="fe mw mx my mz b">localeReducer</code>，这是我们正在测试的系统。但是在那下面，我们有一个新的系列<code class="fe mw mx my mz b">jest.mock</code>。这指示Jest在<code class="fe mw mx my mz b">defaultLocaleProvider</code>依赖于我们的测试系统时，寻找<code class="fe mw mx my mz b">defaultLocaleProvider</code>(T4在自己的文件中导入了它)的模拟实现。</p><p id="97d8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe mw mx my mz b">defaultLocaleProvider</code>的模拟看起来像这样:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="68ea" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如您所见，这是一个简单的函数，只返回“fakeLocale”字符串。当我们的reducer在我们的测试中第一次运行时，它将从这个函数中获取它的初始状态(locale ),将locale设置为“fakeLocale ”,因此我们可以在我们的测试中对此进行测试。</p><p id="ea4a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为了让它工作，我们需要一个新的文件夹，我们的解决方案中的<code class="fe mw mx my mz b">defaultLocaleProvider</code>就在这个文件夹中，这个文件夹叫做<code class="fe mw mx my mz b">__mocks__</code>，在这个文件夹中，我们必须有另一个文件，它的名字和我们模仿的文件一样，就像这样:</p><figure class="mq mr ms mt gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/81ea9dcc3aaaed272b89fbef9d971a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*g62SHIaUH9HafFxarv93wQ.png"/></div></figure><p id="33d5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这个mocks文件夹是一个特殊的文件夹，Jest在查找mock实现时会查看这个文件夹。通常，您在模拟模块时执行这种类型的模拟。</p><p id="f252" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe mw mx my mz b">jest.mock</code>有一个优点，因为它自动将模块的所有导出设置为模拟函数，允许您稍后覆盖它们。</p><p id="ce3d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们看看<code class="fe mw mx my mz b">jest.SpyOn</code>中<code class="fe mw mx my mz b">jest.mock</code>的替代方案。</p><p id="a72f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将尝试并测试这段简单的代码:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3e08" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在这里，我们可以看到，没有依赖关系，而只是一个函数与导航对象。然后，它尝试从导航器中检索一种语言，如果没有找到，它将返回“en”。</p><p id="a087" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在使用<code class="fe mw mx my mz b">jest.spyOn</code>时，我们不需要在同一个目录中模拟实现。相反，我们可以这样做:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2722" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里我们导入了被测系统<code class="fe mw mx my mz b">navigatorLocale</code>。我们利用<code class="fe mw mx my mz b">beforeAll</code>将<code class="fe mw mx my mz b">langaugesMock</code>设置为模拟，然后<code class="fe mw mx my mz b">beforeEach</code>将返回值重置为空。</p><p id="de76" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在第一个测试中，我们没有模拟，我们正在测试默认值返回(“en”)。在第二个例子中，我们将返回值设置为一个数组，正如我们从代码中知道的，languages数组的第一个元素应该被返回，在我们的例子中是“ja”。</p><p id="82f9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果有一个关于<code class="fe mw mx my mz b">jest.mock</code>和<code class="fe mw mx my mz b">jest.spyOn</code>的经验法则，我可能会建议在需要跨多个文件(模拟模块)的模拟时使用<code class="fe mw mx my mz b">jest.mock</code>,在单个案例中需要时使用<code class="fe mw mx my mz b">jest.spyOn</code>。</p><h1 id="8002" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">测试功能和副作用</h1><p id="666f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">可能是上面的<code class="fe mw mx my mz b">jest.mock</code>和<code class="fe mw mx my mz b">jest.spyOn</code>对你的需要来说太重了，或者它们可能不完全适合你想要测试的副作用，功能使用或变异的东西，你可能有也可能没有。</p><p id="4e88" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">想象一下，您正在编写一个React组件，它封装了一个HTML按钮，如下所示:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="79d5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在这个简单的例子中，您希望确保在单击按钮时调用了<code class="fe mw mx my mz b">onClick</code>函数。这是事件发生的副作用。</p><p id="2844" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">使用<code class="fe mw mx my mz b">jest.spyOn</code>和<code class="fe mw mx my mz b">Jest.fn</code>都可以做到这一点。<code class="fe mw mx my mz b">jest.spyOn</code>的另一个用途是，你不必替换被调用函数的实现细节，而只需让Jest观察函数，这样你就可以稍后测试它是否被调用。</p><p id="ff62" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><code class="fe mw mx my mz b">jest.fn</code>不允许恢复被模仿函数的原始细节，但是知道这一点是有好处的，因为<code class="fe mw mx my mz b">jest.spyOn</code>是使用<code class="fe mw mx my mz b">jest.fn</code>的语法糖。</p><p id="3e04" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">回到上面的例子，我们可以这样测试这个组件:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7c30" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里我们使用特定于测试React组件的方法，但是这里需要注意的最重要的事情是我们注入了一个名为<code class="fe mw mx my mz b">mockOnClick</code>的模拟函数。然后，我们模拟了组件上的点击。最后，我们期望已经调用了<code class="fe mw mx my mz b">mockOnClick</code>函数。我也可以测试这个函数被调用的次数。</p><p id="34c9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">要向<code class="fe mw mx my mz b">jest.spyOn</code>添加一个模拟实现，您必须像这样使用<code class="fe mw mx my mz b">mockImplementation</code>属性:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="73dd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">将您的函数作为参数添加到函数中，但使用<code class="fe mw mx my mz b">jest.fn</code>创建函数时，您可以在创建时将其作为第一个参数添加:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8034" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">使用哪一个将取决于你和测试的环境。</p><h1 id="69ff" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="3207" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在第二部分中，我们介绍了JavaScript封装及其重要性，我们还讨论了依赖倒置原则以及我们通常如何在。Net以及用JavaScript和ES6做同样的事情的困难，以获得对我们的依赖性的认识。</p><p id="56b8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">最后，我们讨论了创建三种类型的Jest mocks，以及何时使用每种类型以及如何测试它们。</p><p id="1d8c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在下一部分，我们将讨论测试react组件。</p></div></div>    
</body>
</html>