# Go:函数名和泛型

> 原文：<https://levelup.gitconnected.com/go-function-names-and-generics-c4a2cd6eefc7>

![](img/39216bc30ae0c2897d3c9abfc3816524.png)

使用 Go，您会立即了解到函数[签名](https://en.wikipedia.org/wiki/Type_signature#Signature)不包含类型信息。所以，*不像很多语言*，你不能有:

```
func Max(a, b int)
func Max(a, b float)
```

您需要在函数名中明确包含类型信息，以区分它们:

```
func MaxInt(a, b int)
func MaxFloat(a, b float)
```

很烦，但问题不大。

## 当…时，事情变得有点混乱

当你开始写结构“方法”(我把方法放在引号中，因为我更喜欢结构函数)，事情变得更加混乱。它们变得更加混乱，因为在结构函数中，类型信息*被*隐式包含:

```
func (f *Foo) String() string
func (b *Bar) String() string
```

以上是好的和正确的，并且它是必需的，没有这个东西像*接口*就不会工作。在一种情况下，类型信息本质上不是函数签名的一部分，而在另一种情况下却是。有原因，有逻辑，但还是有点乱。你会熬过去的。您将学习何时使用结构函数，何时使用传统函数，以及每种函数的命名要求。

## 然后我们有了仿制药

我喜欢在 Go 中加入泛型。我立即开始和他们一起工作。特别是，我看了 Kotlin 的*序列*和*地图*并实现了一个 Go 包 [genfuncs](https://github.com/nwillc/genfuncs) 很大程度上是受他们的启发。

很快我就能够将 Go 的泛型应用到它的*切片*和*映射*中，创建了一个 *GSlice* 和 *GMap* ，给人一种与 Kotlin 非常相似的感觉，我发现使用它是一种享受。

## 但是我忘了那些乱七八糟的东西

使用泛型，提供类型作为参数，让它**只** **工作**让我暂时忘记了那些乱七八糟的东西。我写了我的 *GSlice* 和 *GMap* ，它们很好地利用了参数化类型。太棒了。我在这两个平台上都写了类似于 *ForEach* 的东西，它做了正确的事情。我又回到了泛型的老路，实现了越来越多的泛型。然后…

## 它变得更加混乱

Go 的泛型不允许在结构函数上添加或细化类型。符合逻辑，符合语言，但是烦人。假设您有一个泛型 *GSlice* 并且您想要提供一个 *Map* 函数，该函数通过用函数转换元素来返回一个新的 *GSlice* 类型的 *any* 。除了，在 Go 的泛型中，你不能。不能在结构函数中引入或细化新的类型参数。好的，没问题，用一个传统函数:

```
*func* Map[T, R any](s GSlice[T], fn func(t T) R) GSlice[R]
```

那很好。不过后来我又去给一个 *GMap* 写了相应的 *Map* 函数。失败。我已经使用了函数名*地图*。怎么办？我可以将 *GSlice* 和 *GMap* 移到单独的包中，或者我可以用类型重命名 *Map* ，比如 *MapGSlice* 和 *MapGMap* 。两者都不是优雅的选择，但都行得通*【1】*。

## 总而言之

Go 在这方面的限制不是无法忍受的，但是它们很烦人，导致代码不够优雅。

我希望函数签名中包含类型。

我希望你能在泛型的结构函数上提炼/添加类型参数。

但我会克服的。我只需要记住围棋的限制。

**脚注:**

[1]虽然 Go 要求函数名是唯一的，并且通常您想要区分它们的只是类型信息，但是它并没有统一的模式。看看像 *math* 和 *strconv* 这样的软件包，你会发现一个混合的命名模式包。