<html>
<head>
<title>Inter process communication between Node.js and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js和Python之间的进程间通信</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/inter-process-communication-between-node-js-and-python-2e9c4fda928d?source=collection_archive---------5-----------------------#2021-02-15">https://levelup.gitconnected.com/inter-process-communication-between-node-js-and-python-2e9c4fda928d?source=collection_archive---------5-----------------------#2021-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">带有命名管道的IPC</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c741c0bf71d334afcc852b0e89a586dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDDXZkhbMIoVAcCrzuUR6A.jpeg"/></div></div></figure><p id="aeef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我遇到了一个用例，涉及运行PyTorch模型进行实时推理，以及处理I/O的Node.js服务器，在最初尝试使用torch.js失败后，我们决定使用Tensorflow.js (tfjs)。然而，<a class="ae kx" href="https://www.tensorflow.org/js/guide/models_and_layers" rel="noopener ugc nofollow" target="_blank">层模型</a>是一个同步且阻塞的进程，它强制使用工作线程(这条路线将在另一篇文章中详述)。这种方法有其自身的困难:(1)tfjs特定工作线程需要单独运行。(2)通过WebGL后端使用GPU并不简单。</p><p id="2aa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PyTorch便于AI开发，具有使用Python的易用性。此外，PyTorch提供了一个很好的<a class="ae kx" href="https://pytorch.org/tutorials/advanced/cpp_frontend.html" rel="noopener ugc nofollow" target="_blank"> C++前端</a>，这对低延迟系统特别有吸引力。对于上面的用例，我们决定继续使用PyTorch。Node.js处理输入和输出，而Python/PyTorch将处理AI模型推理。这两个系统将使用命名管道进行通信。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h2 id="2ee2" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">命名管道</h2><blockquote class="ly lz ma"><p id="ef20" class="jn jo mb jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated">“管道”是Linux的一个基本特性，它允许不同的进程相互通信和传递数据。命名管道(使用文件系统)是可以由两个不相关的进程访问的文件；一个是读者，另一个是作家。更多细节可以在<a class="ae kx" href="https://www.linuxjournal.com/article/2156" rel="noopener ugc nofollow" target="_blank">这里</a>找到。命名管道有时被称为FIFOs:先进先出，因为字节顺序(进入和出来)是保留的。</p></blockquote><h1 id="ace1" class="mf lg iq bd lh mg mh mi lk mj mk ml ln mm mn mo lq mp mq mr lt ms mt mu lw mv bi translated">简化问题陈述…</h1><p id="8075" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">目标是使用命名管道进行通信。</p><ol class=""><li id="a195" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated">Node.js进程将一些数据写入管道(A)</li><li id="5ed0" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">Python进程从管道(A)读取数据并操作数据</li><li id="66f3" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">然后，上面的python进程将数据写入管道(B)</li><li id="d412" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">Node.js从管道(B)中读取</li></ol><h2 id="e95f" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">Python:读取、处理和写入</h2><p id="08f2" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">首先，让我们创建一个简单的Python进程，它从命名管道A读取数据，处理数据，然后将其写入命名管道B(为了简单起见，这里的<code class="fe np nq nr ns b">process_msg()</code>函数返回读取的数据)。该脚本首先使用<code class="fe np nq nr ns b">os.mkfifo()</code>命令创建命名管道A。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="6f3f" class="lf lg iq bd lh li lj dn lk ll lm dp ln jy lo lp lq kc lr ls lt kg lu lv lw lx bi translated">Node.js:写和读</h2><p id="f659" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">接下来，让我们编写一个简单的Node.js程序来写入管道。有几个包可以做到这一点:<a class="ae kx" href="https://www.npmjs.com/package/named-pipe" rel="noopener ugc nofollow" target="_blank">命名管道</a>，<a class="ae kx" href="https://github.com/raksooo/fifo-js" rel="noopener ugc nofollow" target="_blank"> fifo-js </a>。但是，node提供了一些功能，可以方便地使用管道设置IPC。下面的脚本每1秒钟将数据写入管道A(发送数据)，并从管道B读取数据(从Python接收处理后的数据)。为简单起见，这里的数据是字符串形式的当前时间。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="95e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，虽然<code class="fe np nq nr ns b">createReadStream</code>和<code class="fe np nq nr ns b">createWriteStream</code>看起来有同步接口，但它们是异步操作:当操作完成时，它们不返回承诺或接受回调来进行通信。更多细节可以在<a class="ae kx" href="https://stackoverflow.com/a/30386838/3449335" rel="noopener ugc nofollow" target="_blank">这个stackoverflow回答</a>中找到。</p><p id="6de2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mb">接下来</em>，启动两个终端，一个用于Python，另一个用于Node.js，流水线增加了大约1ms的延迟。</p><h1 id="e77e" class="mf lg iq bd lh mg mh mi lk mj mk ml ln mm mn mo lq mp mq mr lt ms mt mu lw mv bi translated">结论</h1><p id="0c0f" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">命名管道为进程间的通信提供了一种便捷的方式。我介绍了一种简单的方法，将数据从Node.js线程传递到可以进行数据操作的Python进程。对于较慢的任务，Python中可以使用多线程分别读写。</p><p id="14ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>