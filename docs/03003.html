<html>
<head>
<title>Learning C++: Using Sets and Multisets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:使用集合和多重集合</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-using-sets-and-multisets-288946de097a?source=collection_archive---------19-----------------------#2020-04-14">https://levelup.gitconnected.com/learning-c-using-sets-and-multisets-288946de097a?source=collection_archive---------19-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0f32b7dd094e76e88d7b4d347517ca95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E3idzlvmzw6Sq3fw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@bright?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Karen Vardazaryan </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4f1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时候，您需要一个容器来保存按照某种标准排序的唯一值。标准模板库的<code class="fe le lf lg lh b">set</code>类具有这些特性。如果您的需求允许容器保存重复的有序值，那么<code class="fe le lf lg lh b">multiset</code>类就是您想要使用的容器。在本文中，我将讨论如何使用这两个类，以及如何修改这些容器中数据的排序方式。我将首先介绍<code class="fe le lf lg lh b">set </code>类，然后讨论当您使用<code class="fe le lf lg lh b">multiset</code>类时的区别。</p><h1 id="e727" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建集合</h1><p id="ff94" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">集合类通过以下头文件导入到您的程序中:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="02f7" class="mt lj it lh b gy mu mv l mw mx">#include &lt;set&gt;</span></pre><p id="c8d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该类是一个模板类，因此当声明一个集合时，必须提供一个数据类型。集合可以是根据排序标准可比较的任何数据类型。这意味着您可以拥有一个用户定义类型的集合，如果为该类型定义了某种类型的排序函数。</p><p id="2797" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">集合声明必须包括集合元素的数据类型:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fb85" class="mt lj it lh b gy mu mv l mw mx">set&lt;string&gt; names;<br/>set&lt;int&gt; grades;</span></pre><p id="72a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以在声明中声明一个排序标准作为第二个模板参数。我将在本文后面演示这是如何工作的。</p><p id="e2f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以通过提供一个初始化列表来声明一个带有初始数据的集合。列表不必排序，因为它插入到集合中会自动排序。例如:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0cc6" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  set&lt;int&gt; numbers = {3,1,2};<br/>  for (const int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " "; // displays 1 2 3<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="64c7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">向集合中添加数据</h1><p id="fef7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">向集合中添加数据的主要方法是<code class="fe le lf lg lh b">insert</code>函数。此函数将元素放入集合中适当的位置:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7ab3" class="mt lj it lh b gy mu mv l mw mx">set&lt;int&gt; numbers;<br/>numbers.insert(3);<br/>numbers.insert(1);<br/>numbers.insert(2);</span></pre><p id="4291" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数返回元素插入的位置，对于集合，还返回插入是否成功。这个返回值是一个<code class="fe le lf lg lh b">pair</code>结构，其中<code class="fe le lf lg lh b">first</code>字段是插入位置，而<code class="fe le lf lg lh b">second</code>字段是一个布尔值，显示插入的成功或失败。</p><p id="09c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个如何处理<code class="fe le lf lg lh b">insert</code>函数返回值的例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d4f9" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  set&lt;int&gt; numbers;<br/>  pair&lt;set&lt;int&gt;::iterator, bool&gt; success;<br/>  success = numbers.insert(3);<br/>  if (success.second) {<br/>    cout &lt;&lt; "3 was inserted at position "<br/>         &lt;&lt; *success.first &lt;&lt; "." &lt;&lt; endl;<br/>  }<br/>  success = numbers.insert(1);<br/>  if (success.second) {<br/>    cout &lt;&lt; "1 was inserted at position "<br/>         &lt;&lt; *success.first &lt;&lt; "." &lt;&lt; endl;<br/>  }<br/>  success = numbers.insert(2);<br/>  if (success.second) {<br/>    cout &lt;&lt; "2 was inserted at position "<br/>         &lt;&lt; *success.first &lt;&lt; "." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="773f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="aa6d" class="mt lj it lh b gy mu mv l mw mx">3 was inserted at position 3.<br/>1 was inserted at position 1.<br/>2 was inserted at position 2.</span></pre><p id="071a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他版本的<code class="fe le lf lg lh b">insert </code>功能。您可以为函数提供一个建议的插入点，以加快插入速度。这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d22a" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  set&lt;int&gt; numbers = {8, 1, 2, 4, 5, 7, 3};<br/>  int value = 6;<br/>  auto iter = numbers.begin();<br/>  while (*iter &lt; value) {<br/>    ++iter;<br/>  }<br/>  numbers.insert(iter, value);<br/>  for (const int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " "; // 1 2 3 4 5 6 7 8<br/>  }<br/>  return 0;<br/>}</span></pre><p id="42a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">程序在集合中循环，直到到达小于要插入的值的最后一个值。插入发生在该点。</p><p id="a096" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以将元素列表插入到集合中，如下面的程序所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b5cc" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  set&lt;int&gt; numbers = {2,4,6};<br/>  numbers.insert({1,3,5});<br/>  for (const int n : numbers){<br/>    cout &lt;&lt; n &lt;&lt; " "; // 1 2 3 4 5 6<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="f3e5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">从集合中移除元素</h1><p id="4e11" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用<code class="fe le lf lg lh b">erase</code>功能从集合中删除元素。此函数的第一个版本删除一个特定值，并返回删除的元素数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8bb9" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  set&lt;int&gt; numbers = {1,3,2,5,4};<br/>  int removed = 3;<br/>  int count = numbers.erase(removed);<br/>  cout &lt;&lt; count &lt;&lt; " element was removed." &lt;&lt; endl &lt;&lt; endl;<br/>  for (const int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " "; // displays 1 2 4 5<br/>  }<br/>  return 0;<br/>}</span></pre><p id="db3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个版本的<code class="fe le lf lg lh b">erase</code>通过指向集合中某个位置的迭代器移除元素。它的返回值是移除元素后的位置。在下面的例子中，我忽略了返回值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1167" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  set&lt;int&gt; numbers = {1,3,2,5,4};<br/>  int removed = 3;<br/>  auto iter = numbers.begin();<br/>  while (*iter != removed) {<br/>    iter++;<br/>  }<br/>  numbers.erase(iter);<br/>  for (const int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " "; // 1 2 4 5<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="460c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">搜索集合</h1><p id="4ed7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在<code class="fe le lf lg lh b"> set </code>类中有几个成员函数用于搜索。搜索的主要功能是<code class="fe le lf lg lh b">find</code>。该函数将一个值作为参数，并在集合中搜索该值。如果找到该值，该函数将返回一个指向该值的迭代器。如果没有找到值，函数返回<code class="fe le lf lg lh b">end()</code>，或者集合中最后一个元素之后的位置。</p><p id="cbcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示find函数如何工作的程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e0d2" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;set&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="bddb" class="mt lj it lh b gy my mv l mw mx">void buildSet(set&lt;int&gt; &amp;st) {<br/>  srand(time(0));<br/>  for (int i = 1; i &lt;= 25; i++) {<br/>    st.insert(rand() % 100 + 1);<br/>  }<br/>}</span><span id="0e5f" class="mt lj it lh b gy my mv l mw mx">void printSet(const set&lt;int&gt; &amp;st) {<br/>  for (const int n : st) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="f39b" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  set&lt;int&gt; numbers;<br/>  buildSet(numbers);<br/>  printSet(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int value;<br/>  cout &lt;&lt; "Enter a value to find: ";<br/>  cin &gt;&gt; value;<br/>  auto found = numbers.find(value);<br/>  if (found != numbers.end()) {<br/>    cout &lt;&lt; "Found " &lt;&lt; value &lt;&lt; "." &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; value &lt;&lt; " was not found in the set. " &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="5539" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该程序两次运行的输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7035" class="mt lj it lh b gy mu mv l mw mx">14 21 24 27 35 38 42 44 52 57 58 60 68 71 80 84 86 89 92 96<br/>Enter a value to find: 57<br/>Found 57.</span><span id="a80a" class="mt lj it lh b gy my mv l mw mx">7 10 11 15 22 23 34 36 40 53 56 60 62 63 65 72 76 79 84 93 94 96 97<br/>Enter a value to find: 77<br/>77 was not found in the set.</span></pre><h1 id="0403" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">更改排序顺序</h1><p id="f612" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">正如我前面提到的，集合的主要排序标准是<code class="fe le lf lg lh b">less&lt;&gt;</code>。您可以通过在声明新集合时指定不同的标准来更改这一点。如果您不熟悉C++中不同的排序标准，这里的<a class="ae kf" href="https://www.cplusplus.com/reference/functional/less/" rel="noopener ugc nofollow" target="_blank">是您的参考指南。</a></p><p id="5e1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示如何更改排序标准，我将创建一个使用<code class="fe le lf lg lh b">greater&lt;int&gt;</code>标准排序的新集合。程序如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e526" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;set&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="fa1e" class="mt lj it lh b gy my mv l mw mx">void buildSet(set&lt;int, greater&lt;int&gt;&gt; &amp;st) {<br/>  srand(time(0));<br/>  for (int i = 1; i &lt;= 25; i++) {<br/>    st.insert(rand() % 100 + 1);<br/>  }<br/>}</span><span id="b928" class="mt lj it lh b gy my mv l mw mx">void printSet(const set&lt;int, greater&lt;int&gt;&gt; st) {<br/>  for (const int n : st) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="7843" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  set&lt;int, greater&lt;int&gt;&gt; numbers;<br/>  buildSet(numbers);<br/>  printSet(numbers);<br/>  return 0;<br/>}</span></pre><p id="bc11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6d18" class="mt lj it lh b gy mu mv l mw mx">90 87 85 77 65 62 50 40 39 38 31 29 26 25 24 21 20 19 15 14 8 6 1</span></pre><p id="07f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我必须在所有函数参数中指定第二个参数。模板函数将解决这个问题，我将在以后的文章中解决这个问题。</p><h1 id="c409" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用multiset类</h1><p id="499a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果你需要一个集合的排序特性，但是你想在容器中允许重复，你应该使用<code class="fe le lf lg lh b">multiset</code>类。我们用于集合的函数也适用于多重集合。</p><p id="7fe8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您仍然可以在预处理器指令中引用<code class="fe le lf lg lh b">set </code>类来使用多重集。下面的程序创建一个新的多重集并显示容器中的值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="707d" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;set&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="2443" class="mt lj it lh b gy my mv l mw mx">void buildSet(multiset&lt;int&gt; &amp;st) {<br/>  srand(time(0));<br/>  for (int i = 1; i &lt;= 25; i++) {<br/>    st.insert(rand() % 100 + 1);<br/>  }<br/>}</span><span id="357a" class="mt lj it lh b gy my mv l mw mx">void printSet(const multiset&lt;int&gt; st) {<br/>  for (const int n : st) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="8bdb" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  multiset&lt;int&gt; numbers;<br/>  buildSet(numbers);<br/>  printSet(numbers);<br/>  return 0;<br/>}</span></pre><p id="af11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f268" class="mt lj it lh b gy mu mv l mw mx">9 11 15 18 18 28 45 46 54 63 64 67 68 68 71 77 79 79 84 84 87 88 91 93 95</span></pre><p id="8a28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，有重复的18、68和84。</p><p id="6a9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我前面用集合演示的所有函数都适用于多重集合。一个可以有效地与multisets一起使用的函数是<code class="fe le lf lg lh b">count</code>函数，它计算集合中指定值的个数。我没有用<code class="fe le lf lg lh b">set</code>实例演示这一点，因为众所周知一个集合中只存储一个值。</p><p id="42fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个计算多重集中的值的数量的程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8928" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  multiset&lt;int&gt; numbers;<br/>  buildSet(numbers);<br/>  printSet(numbers);<br/>  int value;<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Enter a value to count: ";<br/>  cin &gt;&gt; value;<br/>  auto found = numbers.find(value);<br/>  if (found != numbers.end()) {<br/>    int numVals = numbers.count(value);<br/>    cout &lt;&lt; "Found " &lt;&lt; numVals &lt;&lt; " " &lt;&lt; value<br/>         &lt;&lt; "s in the set." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="c4a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是该程序的一次运行:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b2b6" class="mt lj it lh b gy mu mv l mw mx">5 20 21 21 22 22 25 29 30 33 33 50 57 66 70 70 73 77 81 82 82 89 89 93 94</span><span id="8d18" class="mt lj it lh b gy my mv l mw mx">Enter a value to count: 70<br/>Found 2 70s in the set.</span></pre><h1 id="8075" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">何时使用集合和多重集合</h1><p id="9839" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用集合或多重集合的主要原因是当您需要按排序顺序保存数据时。集合和多重集合的底层数据结构是平衡二叉树，这意味着保持数据有序非常有效。然而，使用二叉树也会产生一个问题，因为你不能改变元素的值，因为这样做会使排序无效。因此，进行更改需要从容器中移除一个元素，然后插入一个新元素。这比在另一个容器中这样做效率更低，所以如果您需要对应用程序中的数据进行大量更改，您将需要选择不同的容器。</p><p id="3416" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>