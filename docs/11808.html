<html>
<head>
<title>SQL Querying for Beginners: INNER and RIGHT JOINs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的SQL查询:内部和右连接</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sql-querying-for-beginners-inner-and-right-joins-d51125071b16?source=collection_archive---------13-----------------------#2022-04-18">https://levelup.gitconnected.com/sql-querying-for-beginners-inner-and-right-joins-d51125071b16?source=collection_archive---------13-----------------------#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f8788b0d2bbff84c3a2aa9c816d9d8f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pcT2EuJ7kp18UG1P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@sunder_2k25?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sunder Muthukumaran </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄。谢谢，桑德！</figcaption></figure><h1 id="9a5b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="2186" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">连接是数据科学家和数据分析师在SQL中最常用的操作之一。当被误用时，它们也是最具破坏性的。错误的连接选择会导致大量的重复、相关记录的丢失以及明显不正确的数据。</p><p id="c651" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在本系列的第一篇文章中，我们讨论了左连接。基本面的快速回顾:</p><ol class=""><li id="8a37" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly mj mk ml mm bi translated">联接是将两个或多个表合并成一个表的方式。</li><li id="ba1b" class="me mf iq ld b le mn li mo lm mp lq mq lu mr ly mj mk ml mm bi translated">联接通过识别表之间的共同点来工作。他们使用主键和外键来实现这一点。</li><li id="cb42" class="me mf iq ld b le mn li mo lm mp lq mq lu mr ly mj mk ml mm bi translated">主键是表中每条记录的唯一标识符<strong class="ld ir">。任何两条记录都不能有相同的主键值。主键不能为空。</strong></li><li id="93f0" class="me mf iq ld b le mn li mo lm mp lq mq lu mr ly mj mk ml mm bi translated">一个表中的外键是另一个表中的主键。外键不受与主键相同的限制(例如，重复值和空值)。</li><li id="829e" class="me mf iq ld b le mn li mo lm mp lq mq lu mr ly mj mk ml mm bi translated">左连接将数据从“右边”的表带入“左边”的表。<strong class="ld ir">保留左侧表格中的所有记录。</strong>只有在关键字上找到匹配项时，才会显示右表中的记录。</li></ol><p id="493a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">以上要点并不意味着是全面的定义，而是对上一篇文章中探索的概念的提醒。如果它们没有意义，先回去读一读！</p><h1 id="7b44" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">内部联接</h1><p id="2782" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">大多数情况下，当使用连接时，要么使用左连接，要么使用内连接。尽管它们都执行类似的任务(组合不同表中的数据)，但它们的结果略有不同。</p><p id="ed1a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">左连接从“右”表中带来数据，留下根据关键字在左表中没有找到匹配的任何记录，<strong class="ld ir"> <em class="ms">内连接留下从</em>两个<em class="ms">表中没有找到匹配的记录。</em> </strong></p><p id="1dea" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们使用上一篇文章示例中的相同表格:<code class="fe mt mu mv mw b">employees</code>和<code class="fe mt mu mv mw b">offices</code>。</p><ul class=""><li id="ae16" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly mx mk ml mm bi translated"><code class="fe mt mu mv mw b">employees</code>表包含一家虚构公司的五名不同员工的数据。</li><li id="cd08" class="me mf iq ld b le mn li mo lm mp lq mq lu mr ly mx mk ml mm bi translated"><code class="fe mt mu mv mw b">offices</code>表包含虚构公司的四个办公室的数据。</li></ul><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="aaad" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">用于左连接这些表的代码:</p><pre class="my mz na nb gt ne mw nf ng aw nh bi"><span id="6af3" class="ni ke iq mw b gy nj nk l nl nm">SELECT *<br/>FROM employees<br/>LEFT JOIN offices<br/>ON employees.office_code = offices.code<br/>;</span></pre><p id="95a0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">因为表格的顺序决定了表格是在左边还是右边，所以上面的代码声明<code class="fe mt mu mv mw b">employees</code>表格是“左边”的表格。当我们离开连接这些表时，<code class="fe mt mu mv mw b">employees</code>表中的每条记录都会保留下来。另一方面，来自<code class="fe mt mu mv mw b">offices</code>表的数据将被带到<em class="ms">office . code</em>=<em class="ms">employees . office _ code</em>的任何地方。</p><p id="b02d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">结果是所有雇员的列表以及每个人工作的办公室的可用信息:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4d33" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在让我们重新检查连接前的表。如果您仔细观察，您会注意到没有一个雇员的<em class="ms"> office_code </em> = 4。这个代码对应于芝加哥办公室，但是因为在那个键上没有匹配，所以LEFT JOIN的结果没有带来任何与芝加哥办公室相关的数据。</p><p id="8470" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">您可能还注意到在<code class="fe mt mu mv mw b">employees</code>表中，Paola Ferrante记录在<em class="ms"> office_code </em>字段中没有包含值。但是，Paola的记录仍然在左连接结果中，因为她的数据在左表中。</p><p id="3fbd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在内部连接中，两个表都没有这种特权。<strong class="ld ir"> <em class="ms">对于要在内部连接中返回的记录，关键字之间必须匹配。</em> </strong></p><p id="0d98" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在我们的例子中，键是<em class="ms"> employees.office_code </em>和<em class="ms">office . code</em>。如果某个员工遗漏了一个办公室代码，他们将不会出现在最终结果中。类似地，如果<code class="fe mt mu mv mw b">employees</code>表中缺少一个办公室代码——比如芝加哥办公室的情况——那么来自该办公室的数据也不会出现在最终结果中。</p><p id="b47d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">内部连接的代码类似于左连接。区别只有一个字:</p><pre class="my mz na nb gt ne mw nf ng aw nh bi"><span id="9e1e" class="ni ke iq mw b gy nj nk l nl nm">SELECT *<br/>FROM employees<br/>INNER JOIN offices<br/>ON employees.office_code = offices.code<br/>;</span></pre><p id="fe97" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">由于上述原因，生成的表格不包括Paola Ferrante的记录，也不包含芝加哥办事处的数据:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0bca" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">另外，对于内部连接，表的顺序并不重要。 结果只与关键字匹配的记录相匹配，所以“右”和“左”没有区别。唯一的区别是列的顺序被交换了，这一点显然很重要:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="cbf7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但是数据在其他方面是相同的。</p><p id="d911" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">继续之前的简短说明:</p><p id="8c1e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在<code class="fe mt mu mv mw b">offices</code>表中，西雅图办公室的<em class="ms">电话号码</em>字段中没有值(<em class="ms">代码</em> = 2)。这个缺失值(也称为空值)对连接没有影响。定义键的ON语句没有告诉JOIN考虑<em class="ms">office . phone _ number</em>。它只说在<em class="ms">offices . code =</em><em class="ms">employees . offices _ code</em>上查找匹配，它确实找到了。</p><h2 id="2927" class="ni ke iq bd kf nn no dn kj np nq dp kn lm nr ns kr lq nt nu kv lu nv nw kz nx bi translated">何时在左连接上使用内连接？</h2><p id="a421" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们的<code class="fe mt mu mv mw b">employees</code>和<code class="fe mt mu mv mw b">offices</code>表背后的底层模式在逻辑上适合左连接而不是内连接。这是因为<code class="fe mt mu mv mw b">offices</code>表本质上是一个细节表(有时也称为维度表)。<code class="fe mt mu mv mw b">offices</code>表的主要用途是带来与公司员工相关的详细信息(其他数据)。</p><p id="51d5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">那么什么时候应该在左连接上使用内连接呢？</p><p id="ccb1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">一般来说，答案是:任何时候，只要记录与指定的键匹配。但对我来说，这回避了一个问题:你为什么想要这样？</p><p id="d48b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对此有许多答案，但现在我只提供一个例子。理解单个用例背后的推理比试图记住无数依赖于上下文的场景更重要。</p><p id="16d9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">想象一下，我们的<code class="fe mt mu mv mw b">employees</code>和<code class="fe mt mu mv mw b">offices</code>桌子要大得多。不是5个员工，而是5000个。不是4个办公室，而是400个——有些已经开业，有些还没有，有些可以说正在筹建中。也许管理层知道他们将在迪拜开设一个办事处，但仍然在几个不同的地方之间做出决定。</p><p id="5a67" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">想象一下，有成百上千的员工，像Paolo Ferrante一样，没有<em class="ms"> office_code。他们在家工作。</em></p><p id="f02e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果你被要求提供一份目前在其中一个办公室工作的员工名单，你会怎么做？你不能把JOIN <code class="fe mt mu mv mw b">offices</code>放在<code class="fe mt mu mv mw b">employees</code>上——那会给你一个所有员工的列表，不管他们在哪里工作。(您可以引入一个WHERE语句来过滤掉在家工作的员工，但是这样就多加了一行。<strong class="ld ir"> <em class="ms">简洁是代码的清晰</em>。</strong>)</p><p id="6c8a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">同样，你不能把<code class="fe mt mu mv mw b">employees</code>左连接到<code class="fe mt mu mv mw b">offices</code>上。这必然会返回所有的办公室，包括那些目前不在运营的办公室。</p><p id="f77f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">最简单的解决方案是使用内部连接。通过这样做，您排除了任何没有<em class="ms"> office_code </em>的雇员和任何没有雇员的办公室。</p><p id="5b70" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们在前面的内部连接中已经这样做了。Paola Ferrante可能在家工作，不在调查结果中。而芝加哥办公室——根据我们的数据，它很可能是一个有工作电话的空房间——也被排除在外。</p><h1 id="69a3" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">右连接</h1><h2 id="b5f1" class="ni ke iq bd kf nn no dn kj np nq dp kn lm nr ns kr lq nt nu kv lu nv nw kz nx bi translated">有争议的加入</h2><p id="36bf" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我不确定是否要写右连接。它们可能会引起争议，正因为如此，往往会令人困惑。但我认为它们值得一提。</p><p id="0b8b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">首先，右连接在概念上并不比左连接更难。第二，重要的是要理解，像任何其他语言一样，SQL有标准的约定，这些约定通常被合理地视为法律。</p><p id="5616" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">右连接本质上是左连接的镜像。 如果左连接将数据带入左边的表，同时保留该表中的所有记录，则右连接将数据带入右边的表，同时保留<em class="ms">该</em>表中的所有记录。</p><p id="d7d0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">(重要的是要记住，哪个表是“在左边”还是“在右边”是由连接的顺序决定的。提醒一下:查询中紧跟FROM的第一个表是左边的表。JOIN后面的第二个表是右边的表。)</p><p id="530d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们使用<code class="fe mt mu mv mw b">employees</code>和<code class="fe mt mu mv mw b">offices</code>表来看一个右连接。注意，在代码中，我交换了表格的顺序，所以<code class="fe mt mu mv mw b">employees</code>在右边。像以前一样，我希望所有员工的记录都在结果中。</p><pre class="my mz na nb gt ne mw nf ng aw nh bi"><span id="1692" class="ni ke iq mw b gy nj nk l nl nm">SELECT *<br/>FROM offices<br/>RIGHT JOIN employees<br/>ON employees.office_code = offices.code<br/>;</span></pre><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3519" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">乍一看，这张桌子可能看起来像是我们还没见过的东西。但是，如果我只是改变SELECT语句中列的顺序(不对连接做任何事情)，它看起来会更熟悉:</p><pre class="my mz na nb gt ne mw nf ng aw nh bi"><span id="017a" class="ni ke iq mw b gy nj nk l nl nm">SELECT employees.*, offices.*<br/>FROM offices<br/>RIGHT JOIN employees<br/>ON employees.office_code = offices.code<br/>;</span></pre><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="29d7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这与我们最初的左连接创建的表的结果相同。任何左连接都可以重写为右连接，反之亦然。表格的顺序(以及列，如果你想让它看起来完全一样的话)只需要反过来。</p><h2 id="9bb0" class="ni ke iq bd kf nn no dn kj np nq dp kn lm nr ns kr lq nt nu kv lu nv nw kz nx bi translated">那么…我应该使用左连接还是右连接？</h2><p id="007c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">简短且有些不尽人意的回答是:视情况而定。在英语世界中，公司的最佳实践通常会<em class="ms">规定，为了可读性，你应该使用左连接而不是右连接。(例外情况是涉及许多连接的长查询，在这种情况下，快速简单的右连接可能比在代码中重写整个FROM语句更好。)</em></p><p id="15d1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">部分原因是我们的思维方式。例如，说英语的人倾向于从左向右处理信息。作为一个说英语的人，我更喜欢我们的<code class="fe mt mu mv mw b">employees</code>和<code class="fe mt mu mv mw b">offices</code>表的左连接，而不是镜像的右连接，因为在后一种情况下，我必须切换列的顺序才能理解我所看到的内容——因为我是从左到右处理的。</p><p id="60d0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这种偏好的普遍存在(同样，特别是在英语世界中)导致人们相信右连接一定是糟糕的实践，或者充其量是混乱的语法，而事实上它们在功能上与左连接没有什么不同。然而，可读性是有争议的——如果你的代码对你的同事或队友来说是不必要的混乱，那么某些东西被误解和误用的可能性就更大。</p><p id="f048" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我的看法？了解你的受众。如果您不确定，但想继续使用右连接，可以考虑在代码中添加注释，指出并解释您的推理。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/84d2acb9fb8075b11e570b0455d3d799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BnzZ4ANoP32ReCw3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@rutmiit?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">鲁特MIIT </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="1a86" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">左连接和内连接是作为数据分析师或科学家进行查询时最常用的两种连接。我希望这篇文章和上一篇文章有助于更好地理解它们是如何工作的。</p><p id="9faf" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">感谢<a class="ae kc" href="https://www.linkedin.com/in/jrahmlow/" rel="noopener ugc nofollow" target="_blank"> Jeanique Rahmlow </a>提供的编辑帮助，感谢<a class="ae kc" href="https://www.dataxp.ai/" rel="noopener ugc nofollow" target="_blank"> Dataxp Discord社区</a>支持热情的数据专业人员的发展。</p><p id="0f31" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于接下来我应该解释什么SQL主题，您有什么建议吗？留在评论里吧！一如既往，欢迎在LinkedIn上与我联系。</p><p id="d106" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="ms">在SQL中，您实际上会在输出中看到单词NULL。由于SQL将空格算作字符，所以看起来为空的值很可能包含空格。因此，空值应该被认为是真正的空。</em></p></div></div>    
</body>
</html>