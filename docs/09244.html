<html>
<head>
<title>URQL the highly customizable and versatile GraphQL client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高度可定制和多功能的GraphQL客户端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/urql-the-highly-customizable-and-versatile-graphql-client-69e4e3406904?source=collection_archive---------6-----------------------#2021-07-20">https://levelup.gitconnected.com/urql-the-highly-customizable-and-versatile-graphql-client-69e4e3406904?source=collection_archive---------6-----------------------#2021-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/43975a8f229967c09f4bd01aeaa1b8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9XAMFQNw328QW3CIgxuEeg.png"/></div></div></figure><p id="9cc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在过去的十年中，REST架构已经成为web应用程序的行业标准，因为REST提供了一种无状态的服务器和结构化的方式来访问后端资源。但是随着时间的推移，为了适应不断变化的需求，REST变得越来越麻烦。脸书引入了Graphql来避免REST架构的问题。</p><ul class=""><li id="fa0d" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">提取过量/不足</li><li id="5bec" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">适应快速变化的前端</li><li id="36aa" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">一个应用程序的多个端点</li></ul><p id="e181" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Graphql遵循一个规范，所以客户机和服务器都将支持<a class="ae ln" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">模式格式</a>和<a class="ae ln" href="https://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank">查询格式</a>，支持一些高级特性，如兑现和乐观变异。所以Graphql在开发人员中流行的原因显而易见。尽管脸书引入了graphql，但是是开源社区给它带来了生机。目前，在构建Grpahql应用程序服务器和客户机时，有许多选择。一些著名的客户端有<a class="ae ln" href="https://formidable.com/open-source/urql/" rel="noopener ugc nofollow" target="_blank"> URQL </a>、<a class="ae ln" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">阿波罗客户端</a>和<a class="ae ln" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank">中继</a>。这些客户端提供了与其他客户端不同的功能，如Axios或fetch。<a class="ae ln" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo客户端</a>和<a class="ae ln" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank"> Relay </a>是最常用的客户端库，但是人们转向了其他的替代库，比如<a class="ae ln" href="https://formidable.com/open-source/urql/" rel="noopener ugc nofollow" target="_blank"> URQL </a>、<a class="ae ln" href="https://react-query.tanstack.com/" rel="noopener ugc nofollow" target="_blank"> react-query </a>，甚至<a class="ae ln" href="https://docs.amplify.aws/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify </a>。</p><p id="d689" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，让我们来看看graphql客户端库，它值得graphql社区中称为<a class="ae ln" href="https://formidable.com/open-source/urql/" rel="noopener ugc nofollow" target="_blank"> URQL </a>的关注。</p><h1 id="8153" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么是URQL</h1><p id="e9b4" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">URQL是React的一个轻量级、可扩展的GraphQL客户端。<a class="ae ln" href="https://formidable.com/" rel="noopener ugc nofollow" target="_blank">威猛</a>2019年推出<a class="ae ln" href="https://formidable.com/open-source/urql/" rel="noopener ugc nofollow" target="_blank"> URQL </a>作为<a class="ae ln" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">阿波罗客户端</a>的替代。<a class="ae ln" href="https://formidable.com/open-source/urql/" rel="noopener ugc nofollow" target="_blank"> URQL </a>看起来有点类似<a class="ae ln" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank">阿波罗客户端</a>。尽管如此，它还提供了额外的功能，并有更好的文档，易于配置，并支持离线模式，文件上传和认证等功能。</p><h1 id="3451" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">URQL与阿波罗和其他人有何不同</h1><p id="d8f6" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">Apollo是react社区中最著名的graphql客户端库，您将能够看到<a class="ae ln" href="https://formidable.com/open-source/urql/" rel="noopener ugc nofollow" target="_blank"> URQL </a>中的一些特性与<a class="ae ln" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo客户端</a>非常相似。与<a class="ae ln" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo客户端</a>不同的是，<a class="ae ln" href="https://formidable.com/open-source/urql/" rel="noopener ugc nofollow" target="_blank"> URQL </a>带有一个单独的包，而Apollo需要几个包来实现额外的功能。这些库的文件大小可以被认为是一个显著的差异，因为Apollo的文件大小超过100kb(其他库如apollo-boost + react-apollo)，而urql的文件大小为21.5kB。URQL 是轻量级的、可扩展的，并且有开源社区的支持，这使得URQL能够解决<a class="ae ln" href="https://github.com/FormidableLabs/urql/issues/196" rel="noopener ugc nofollow" target="_blank">持久化查询</a>。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/8101b7e19855cdaa84c32dd5ffc91d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XzsNX1vK3QphiRjxuH4fLw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">urql vs阿波罗vs接力</figcaption></figure><h1 id="c59f" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">为什么您应该搬到URQL</h1><p id="a512" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">URQL是由于Apollo日益复杂而引入的</p><ul class=""><li id="ed11" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">易于使用</li><li id="3635" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">性能和功能</li><li id="7026" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">逻辑默认行为和缓存</li><li id="f265" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">易于扩展</li></ul><h1 id="3ca1" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">URQL体系结构</h1><p id="d8ec" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">Uqrl采用包含电池的方法，其架构依赖于非个人化交换机(插件)，允许即插即用的功能。默认情况下，URQL将提供创建graphql应用程序所需的足够数量的特性，您可以根据需要通过交换添加更多特性。这种即插即用的架构是URQL成为高度可定制和灵活的GraphQL客户端的原因。</p><h1 id="3d6c" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Graphcache</h1><p id="6601" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">URQL中的缓存完全可以通过交换(插件)来定制。URQL提供了两种不同的兑现机制</p><ul class=""><li id="2fb4" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu">文档缓存</strong> <br/>文档缓存的行为类似于浏览器缓存，它通过缓存每个查询的结果来帮助最大限度地减少向GraphQL API重复发送相同的请求。默认情况下，URQL将提供文档缓存。</li><li id="dc17" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><strong class="kd iu">规范化缓存<br/> </strong>随着时间的推移，应用程序将会增长，增加URQL管理的数据和状态的复杂性。规范化缓存通过将JSON数据反规范化回关系数据结构来帮助避免这种复杂性，关系数据结构通过可以直接查找的键来存储所有实体。要启用规范化缓存，您必须安装<a class="ae ln" href="https://www.npmjs.com/package/@urql/exchange-graphcache" rel="noopener ugc nofollow" target="_blank">@ urql/exchange-graph cache</a>，并将它们包含在您的URQL配置中。</li></ul><h1 id="353b" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">URQL入门</h1><p id="407b" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在这一节中，让我们看看如何用Graphql创建一个React应用程序</p><h2 id="4dcc" class="na lp it bd lq nb nc dn lu nd ne dp ly km nf ng mc kq nh ni mg ku nj nk mk nl bi translated">步骤01:安装</h2><p id="2b78" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">让我们通过下面的命令在React应用程序上安装URQL。这些命令将安装所有必需的</p><pre class="ms mt mu mv gt nm nn no np aw nq bi"><span id="996b" class="na lp it nn b gy nr ns l nt nu">npx create-react-app urql-pokemons<br/>cd urql-pokemons<br/>yarn add <strong class="nn iu">urql</strong> <strong class="nn iu">graphql</strong> antd</span></pre><h2 id="bdb0" class="na lp it bd lq nb nc dn lu nd ne dp ly km nf ng mc kq nh ni mg ku nj nk mk nl bi translated">步骤02:配置URQL</h2><p id="5d37" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">配置URQL很简单，配置可以在React应用程序的index.js文件中完成。在这个配置中，您需要通过参数<strong class="kd iu"> url </strong>指定您订阅的graphql服务的端点。可以通过fetchOptions部分配置任何其他选项，如附加头。配置完客户端后，您需要通过<strong class="kd iu"> value </strong> prop将它传递给提供者的高级组件，该组件包装了整个应用程序，使您能够在整个应用程序中访问graphql客户端。</p><pre class="ms mt mu mv gt nm nn no np aw nq bi"><span id="6724" class="na lp it nn b gy nr ns l nt nu">import { <strong class="nn iu">createClient</strong>, <strong class="nn iu">Provider </strong>} from 'urql';</span><span id="eb60" class="na lp it nn b gy nv ns l nt nu">const <strong class="nn iu">client </strong>= <strong class="nn iu">createClient</strong>({<br/> <strong class="nn iu">url</strong>: process.env.REACT_APP_HASURA_URL,<br/> <strong class="nn iu">fetchOptions</strong>: () =&gt; {<br/>  return {<br/>   headers: {<br/>     'content-type': 'application/json',<br/>     'x-hasura-admin-secret': process.env.REACT_APP_HASURA_SECRET<br/>   },<br/> };<br/>},<br/>});</span><span id="8764" class="na lp it nn b gy nv ns l nt nu">ReactDOM.render(<br/> &lt;Provider <strong class="nn iu">value</strong>={<strong class="nn iu">client</strong>}&gt;<br/>  &lt;App /&gt;<br/>&lt;/Provider&gt;,<br/>document.getElementById('root')<br/>);</span></pre><h2 id="fdc8" class="na lp it bd lq nb nc dn lu nd ne dp ly km nf ng mc kq nh ni mg ku nj nk mk nl bi translated">步骤03:使用URQL查询</h2><p id="4360" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">通过URQL客户端查询或调用查询和变异非常简单。URQL API提供了两个钩子来执行一个查询和一个变异。两个钩子都提供了一个状态来标识查询的状态(获取、错误)。</p><pre class="ms mt mu mv gt nm nn no np aw nq bi"><span id="08d0" class="na lp it nn b gy nr ns l nt nu">import { useQuery, useMutation } from 'urql';</span><span id="976b" class="na lp it nn b gy nv ns l nt nu">const <strong class="nn iu">PokemonsQuery </strong>= `<br/>  query {<br/>   Pokemons_Pokemon {<br/>      id<br/>      name<br/>      power<br/>      description<br/>   }<br/>  }<br/>`;</span><span id="a7ed" class="na lp it nn b gy nv ns l nt nu">const createPokemon = `<br/> mutation CreatePokemon($name:  String!,$power:String!,$description:String!) {<br/>insert_Pokemons_Pokemon(objects: { name: $name, power: $power, description: $description }) {<br/>  returning {<br/>   description<br/>   id<br/>   name<br/>   power<br/>  }<br/> }<br/>}`</span><span id="b933" class="na lp it nn b gy nv ns l nt nu">const [{ data, fetching, error }] = useQuery({<br/>  query: <strong class="nn iu">PokemonsQuery</strong>,<br/>});</span><span id="6fae" class="na lp it nn b gy nv ns l nt nu">const [{ fetching, error }, <strong class="nn iu">executeMutation</strong>] = <strong class="nn iu">useMutation</strong>(createPokemon)</span></pre><h2 id="e41c" class="na lp it bd lq nb nc dn lu nd ne dp ly km nf ng mc kq nh ni mg ku nj nk mk nl bi translated">步骤URQL的插件(交换)</h2><p id="1a04" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">可扩展性是URQL的主要焦点。是通过交流实现的。像所有Grahql客户端一样，URQL是基于流的，它接受请求、查询或变异，并给出适当的响应(缓存值、来自API的响应或错误)。交换只是一个插件，允许您检查和修改传入和传出的流。URQL中最常用的交换是</p><ul class=""><li id="7525" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">重复数据交换</li><li id="8e96" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">cacheExchange</li><li id="0899" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">fetchExchange</li></ul><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/e7303420512d71c5778062656b7a3dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cW6sLFuXRGGIBVBWHQu15g.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">默认交易所</figcaption></figure><p id="1b12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上图显示了urql请求如何通过交换进行优化。您可以在您的应用程序中包含任意数量的交换，只要它们是未订阅的。</p><pre class="ms mt mu mv gt nm nn no np aw nq bi"><span id="eb27" class="na lp it nn b gy nr ns l nt nu">import { createClient, Provider } from 'urql';</span><span id="9fb7" class="na lp it nn b gy nv ns l nt nu">const client = createClient({<br/> url: process.env.REACT_APP_HASURA_URL,<br/> exchanges:{<br/>  <strong class="nn iu">dedupExchage</strong>,<br/>  <strong class="nn iu">cacheExchange</strong>,<br/>  <strong class="nn iu">fetchExchange</strong><br/> },<br/> fetchOptions: () =&gt; {<br/>  return {<br/>   headers: {<br/>     'content-type': 'application/json',<br/>     'x-hasura-admin-secret': process.env.REACT_APP_HASURA_SECRET<br/>   },<br/> };<br/>},<br/>});</span></pre><h1 id="6ef7" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="f152" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">总之，URQL是目前最轻的Graphql客户机之一。它还提供了通过插件扩展其功能的灵活性，以增强开发体验。该库的简单性也使它成为使用React的Graphql初学者的一个很好的选择。要了解更多信息，您可以浏览URQL 的<a class="ae ln" href="https://formidable.com/open-source/urql/docs/" rel="noopener ugc nofollow" target="_blank">文档。最后，感谢您花时间阅读本文。我想看看你下面的问题和评论。</a></p><p id="ccfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">干杯！</p><h1 id="5ede" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">了解更多信息</h1><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/jotai-atom-based-state-management-for-react-1ce8fd380296"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">jotai:React的基于原子的状态管理</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">在过去的几年里，国家管理有了很大的发展。有很多库和方法可以让你…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo jz oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/build-your-own-self-hosted-ci-cd-workflow-with-github-actions-ec9ee1dcd800"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">使用GitHub操作构建您自己的自托管CI/CD工作流</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">GitHub引入了GitHub Actions，使开发人员能够直接从他们的GitHub库自动化工作流…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo jz oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/hookstate-the-simplest-state-management-tool-b02f7d3b01a4"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">最简单的状态管理工具</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">小型、最小、简洁、可扩展、基于钩子的状态管理库</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo jz oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://medium.com/swlh/intro-to-recoil-d689a77c5f04" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">反冲介绍</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">反冲是一个反应的状态管理库，是由脸书的实验和开放源码…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="or l ol om on oj oo jz oa"/></div></div></a></div></div></div>    
</body>
</html>