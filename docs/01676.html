<html>
<head>
<title>Kubernetes Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes认证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-authentication-36c4870b2fab?source=collection_archive---------11-----------------------#2020-01-21">https://levelup.gitconnected.com/kubernetes-authentication-36c4870b2fab?source=collection_archive---------11-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="868b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文最初发表于https://www.magalix.com/blog/kubernetes-authentication</em><a class="ae kp" href="https://www.magalix.com/blog/kubernetes-authentication" rel="noopener ugc nofollow" target="_blank"/></p><p id="0c55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes认证意味着验证发出请求的人或物的<em class="ko">身份</em>。例如，如果您想通过SSH访问Linux机器，SSH <a class="ae kp" href="https://www.magalix.com/blog/kubernetes-daemonsets-101" rel="noopener ugc nofollow" target="_blank">守护进程</a>必须验证您用于登录的用户名和密码与/etc/passwd和/etc/shadow文件中的帐户相匹配。为了将它们组合在一起，这些文件代表Linux的认证数据库。另一方面，<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-authorization" rel="noopener ugc nofollow" target="_blank">授权</a>指的是一旦获得访问权限，你被允许做什么。因此，回到我们的Linux示例，用户可以通过提供有效的凭证来访问操作系统，但是他们不能查看或修改敏感文件(如/etc/shadow)的内容。只有根用户或具有根权限的人可以这样做。</p><p id="1dbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Kubernetes中，API服务器需要验证它收到的每个请求。请求可能来自人类用户或程序(例如Pod)。目前，人类用户帐户需要通过一种受支持的<a class="ae kp" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authentication-strategies" rel="noopener ugc nofollow" target="_blank">身份验证策略</a>在集群之外进行管理。请注意，用户帐户是<em class="ko">而不是</em>命名空间，这意味着它在集群范围内必须是唯一的。但通常情况下，您还需要使程序能够获得认证并向API服务器发送请求。对于能够向API服务器进行身份验证的资源，它需要拥有一个服务帐户。</p><h1 id="7a15" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">服务帐户</h1><p id="8727" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">服务帐户是另一个Kubernetes资源(如<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-pods-101-the-cluster-sailors" rel="noopener ugc nofollow" target="_blank"> pods </a>、<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank"> deployments </a>等)。).与用户帐户不同，服务帐户是命名空间的，因此您可以创建多个同名的服务帐户，只要它们位于不同的命名空间中。</p><p id="91e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下，服务帐户凭证通过一个<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-secrets-101" rel="noopener ugc nofollow" target="_blank">密码</a>安装到pod。让我们举个简单的例子:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c5d1" class="mc kr it ly b gy md me l mf mg">$ kubectl run -it --rm testpod --restart=Never --image=alpine -- sh<br/>If you don't see a command prompt, try pressing enter.<br/>/ # ls -l /var/run/secrets/kubernetes.io/serviceaccount/<br/>total 0<br/>lrwxrwxrwx    1 root     root            13 Nov  8 11:45 ca.crt -&gt; ..data/ca.crt<br/>lrwxrwxrwx    1 root     root            16 Nov  8 11:45 namespace -&gt; ..data/namespace<br/>lrwxrwxrwx    1 root     root            12 Nov  8 11:45 token -&gt; ..data/token</span></pre><p id="74f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个一次性的豆荚，拥有阿尔卑斯山的图像。打开容器的外壳，我们可以很容易地查看从/data挂载点下的外部秘密挂载到pod的文件。身份验证过程是通过令牌文件完成的。让我们看看这个文件的内容:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3f90" class="mc kr it ly b gy md me l mf mg">/ # cat /var/run/secrets/kubernetes.io/serviceaccount/token &amp;&amp; echo<br/>eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tcHh6ZjciLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImUzMzFmNTU1LTAxOTktMTFlYS1hYTVhLTQyMDEwYTgwMDBhYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.I3jFqRd7ANj4BidzoW-v_YO1N_z2p33Ex1biaz_J97QK9CRlIFmK2KC1k0RbQux3zo72xsLhbPjNH40pBzqr2TzVjZKFD7T8-ihDj1Og5L_BAud-CtT4e-0zcvC5rTKcWzkUn5a64TUSwF5Q6I3KjeaE3pmDFwG4I6XLuODCVOwRkfn0V_LzjqLy3nXfUK8FpIkeBrRd9QN68PG9YFH9lKMgGZLvuG_m6K6EFxqBpVMec8SPsG77GGRezC9Mjsyxp2Wie-j8vUVb5et2o4ShKa8sp-Nqum4bpBxGQ9NBo3qlefuqYGYivGZBnL8dienBLFbO5swSHUL6vxTgaRg2kA<br/>/ #</span></pre><p id="6b3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">令牌的内容是<a class="ae kp" href="https://en.wikipedia.org/wiki/JSON_Web_Token" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌(JWT) </a>格式。可以使用<a class="ae kp" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt </a>命令行工具或者在jwt.io网站上在线解码。下面是web上解码操作的输出，同样也是在命令行上:</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mh"><img src="../Images/6521aab0227172065993da0d40c12d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AKl1SYyNBY3-z-_A.png"/></div></div></figure><p id="1037" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在命令行上:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="bf4f" class="mc kr it ly b gy md me l mf mg">$ jwt eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tcHh6ZjciLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImUzMzFmNTU1LTAxOTktMTFlYS1hYTVhLTQyMDEwYTgwMDBhYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.I3jFqRd7ANj4BidzoW-v_YO1N_z2p33Ex1biaz_J97QK9CRlIFmK2KC1k0RbQux3zo72xsLhbPjNH40pBzqr2TzVjZKFD7T8-ihDj1Og5L_BAud-CtT4e-0zcvC5rTKcWzkUn5a64TUSwF5Q6I3KjeaE3pmDFwG4I6XLuODCVOwRkfn0V_LzjqLy3nXfUK8FpIkeBrRd9QN68PG9YFH9lKMgGZLvuG_m6K6EFxqBpVMec8SPsG77GGRezC9Mjsyxp2Wie-j8vUVb5et2o4ShKa8sp-Nqum4bpBxGQ9NBo3qlefuqYGYivGZBnL8dienBLFbO5swSHUL6vxTgaRg2kA</span><span id="8ec5" class="mc kr it ly b gy mp me l mf mg">To verify on jwt.io:</span><span id="94ad" class="mc kr it ly b gy mp me l mf mg"><a class="ae kp" href="https://jwt.io/#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tcHh6ZjciLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImUzMzFmNTU1LTAxOTktMTFlYS1hYTVhLTQyMDEwYTgwMDBhYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.I3jFqRd7ANj4BidzoW-v_YO1N_z2p33Ex1biaz_J97QK9CRlIFmK2KC1k0RbQux3zo72xsLhbPjNH40pBzqr2TzVjZKFD7T8-ihDj1Og5L_BAud-CtT4e-0zcvC5rTKcWzkUn5a64TUSwF5Q6I3KjeaE3pmDFwG4I6XLuODCVOwRkfn0V_LzjqLy3nXfUK8FpIkeBrRd9QN68PG9YFH9lKMgGZLvuG_m6K6EFxqBpVMec8SPsG77GGRezC9Mjsyxp2Wie-j8vUVb5et2o4ShKa8sp-Nqum4bpBxGQ9NBo3qlefuqYGYivGZBnL8dienBLFbO5swSHUL6vxTgaRg2kA" rel="noopener ugc nofollow" target="_blank">https://jwt.io/#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tcHh6ZjciLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImUzMzFmNTU1LTAxOTktMTFlYS1hYTVhLTQyMDEwYTgwMDBhYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.I3jFqRd7ANj4BidzoW-v_YO1N_z2p33Ex1biaz_J97QK9CRlIFmK2KC1k0RbQux3zo72xsLhbPjNH40pBzqr2TzVjZKFD7T8-ihDj1Og5L_BAud-CtT4e-0zcvC5rTKcWzkUn5a64TUSwF5Q6I3KjeaE3pmDFwG4I6XLuODCVOwRkfn0V_LzjqLy3nXfUK8FpIkeBrRd9QN68PG9YFH9lKMgGZLvuG_m6K6EFxqBpVMec8SPsG77GGRezC9Mjsyxp2Wie-j8vUVb5et2o4ShKa8sp-Nqum4bpBxGQ9NBo3qlefuqYGYivGZBnL8dienBLFbO5swSHUL6vxTgaRg2kA</a></span><span id="75d2" class="mc kr it ly b gy mp me l mf mg">✻ Header<br/>{<br/>  "alg": "RS256",<br/>  "kid": ""<br/>}</span><span id="0262" class="mc kr it ly b gy mp me l mf mg">✻ Payload<br/>{<br/>  "iss": "kubernetes/serviceaccount",<br/>  "kubernetes.io/serviceaccount/namespace": "default",<br/>  "kubernetes.io/serviceaccount/secret.name": "default-token-pxzf7",<br/>  "kubernetes.io/serviceaccount/service-account.name": "default",<br/>  "kubernetes.io/serviceaccount/service-account.uid": "e331f555-0199-11ea-aa5a-42010a8000aa",<br/>  "sub": "system:serviceaccount:default:default"<br/>}</span><span id="54f2" class="mc kr it ly b gy mp me l mf mg">✻ Signature I3jFqRd7ANj4BidzoW-v_YO1N_z2p33Ex1biaz_J97QK9CRlIFmK2KC1k0RbQux3zo72xsLhbPjNH40pBzqr2TzVjZKFD7T8-ihDj1Og5L_BAud-CtT4e-0zcvC5rTKcWzkUn5a64TUSwF5Q6I3KjeaE3pmDFwG4I6XLuODCVOwRkfn0V_LzjqLy3nXfUK8FpIkeBrRd9QN68PG9YFH9lKMgGZLvuG_m6K6EFxqBpVMec8SPsG77GGRezC9Mjsyxp2Wie-j8vUVb5et2o4ShKa8sp-Nqum4bpBxGQ9NBo3qlefuqYGYivGZBnL8dienBLFbO5swSHUL6vxTgaRg2kA</span></pre><p id="14b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出中有趣的部分是有效载荷。如您所见，我们将service-account.name设置为“default”。这是在初始化时自动创建并装载到每个pod的默认服务帐户。在大多数情况下，当您需要授予pod更多权限时，您不应该使用默认帐户。让我们创建一个服务帐户，并将其分配给一个pod:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="9546" class="mc kr it ly b gy md me l mf mg">$ kubectl create serviceaccount testsa                                                                                                             <br/>serviceaccount/testsa created</span></pre><p id="338b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们在这里没有指定名称空间，所以我们的testsa服务帐户是在默认名称空间中创建的。如果我们看一下这个名称空间中的秘密，我们会发现两个秘密:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ad23" class="mc kr it ly b gy md me l mf mg">$ kubectl get secrets<br/>NAME                  TYPE                                  DATA   AGE<br/>default-token-pxzf7   kubernetes.io/service-account-token   3      16h<br/>testsa-token-zwhvm    kubernetes.io/service-account-token   3      11s</span></pre><p id="a109" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个秘密是为我们前面检查过的默认服务帐户创建的。第二个包含我们刚刚创建的testsa帐户的凭证。</p><p id="9dab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经准备好了服务帐户，让我们将它附加到一个pod。以下定义创建了一个使用testsa作为服务帐户的pod:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b54c" class="mc kr it ly b gy md me l mf mg">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: testpod<br/>spec:<br/>  serviceAccountName: testsa<br/>  containers:<br/>    - name: mycontainer<br/>      image: alpine:latest<br/>      command:<br/>        - "sh"<br/>        - "-c"<br/>        - "sleep 1000"</span></pre><p id="8f74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许这个定义中有趣的部分在第6行，我们在那里指定了serviceAccountName参数。容器本身运行Alpine映像，我们指示它休眠1000秒，这足以让我们在进程退出之前检查容器内容。现在，如果您将此定义应用到您的集群，您可以使用如下命令登录到pod:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="04fb" class="mc kr it ly b gy md me l mf mg">kubectl exec -it testpod -- sh</span></pre><p id="8239" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您检查/var/run/secrets/kubernetes . io/service account/的内容，您会看到一个令牌文件，但是(使用jwt工具解密时)包含不同的服务帐户名和凭证。</p><h1 id="3d47" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">Kubernetes认证方法</h1><p id="214f" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在本文的开始，我们以Linux为例说明了认证是如何发生的。Linux使用/etc/shadow和/etc/passwd来存储用户凭证。虽然您可以在Linux上使用其他身份验证方法，比如LDAP，但是您没有太多其他选择。另一方面，<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-101-concepts-and-why-it-matters" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>的设计者希望在选择如何认证用户时给予管理员更多的灵活性。可以通过插件启用/禁用不同的身份验证方法。让我们来看看它们:</p><ul class=""><li id="562e" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><strong class="js iu">静态密码或令牌:</strong>这是最简单(但最不灵活)的方法。您的每个用户都有一个固定的密码或令牌。API服务器通过HTTP基本身份验证对用户进行身份验证，其中用户名和密码通过HTTP请求的授权头传递。比如<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-authorization" rel="noopener ugc nofollow" target="_blank">授权</a>基本bXl1c2VyOm15cGFzc3dvcmQK。请注意，身份验证类型(basic)后面的字符集是myuser:mypassword的base64编码版本。基本HTTP身份验证还支持基于令牌的凭据，用户只需提供令牌即可获得身份验证。在这种情况下，HTTP请求的授权头如下所示:</li></ul><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5143" class="mc kr it ly b gy md me l mf mg">Authorization Bearer: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.2Jy0uRBfQC3EIo-_iv3QE0qQMDKYLvBpkK82_7J6q0M</span></pre><ul class=""><li id="92d5" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">不用说，这两种认证都必须通过HTTPS发送。否则，你在锁门的同时把钥匙交给了入侵者。这种方法要求您为每个用户维护一个包含其凭据的静态文件。它还需要直接访问API服务器，这使得它非常不灵活。它应该只在不太关心身份验证的测试/开发环境中使用。</li><li id="1bc6" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu"> X.509证书:</strong>您可以使用证书对API服务器进行认证。工作流程如下:您创建一个证书请求，通过证书颁发机构(CA)对其进行签名，并在身份验证阶段将其提交给API服务器。API服务器咨询CA服务器以验证证书，并相应地批准或拒绝请求。请注意，这种机制与浏览器在需要通过HTTPS联系网站时使用的传统工作流有相似之处。</li><li id="ef10" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">使用OpenID Connect单点登录:</strong>您可以使用OAuth 2.0提供商之一，如Google、Azure Active Directory等。向API服务器验证自己的身份。在这个场景中，用户需要首先登录Google(如果我们决定使用Google作为OIDC提供者),一旦通过身份验证，他们就会发送一个包含身份信息的不记名令牌。发送这个令牌意味着用户已经被提供者成功地认证。不记名令牌是一个包含用户信息的<a class="ae kp" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌</a>(前面已经讨论过了)。API服务器需要以下标志:</li></ul><p id="6610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> — oidc-issuer-url </strong>:认证提供者提供的发现url，没有路径。例如，如果发现网址是https://accounts.google.com/.的<a class="ae kp" href="https://accounts.google.com/.well-known/openid-configuration," rel="noopener ugc nofollow" target="_blank">知名/openid-configuration，</a>的值应该是https://accounts.google.com<a class="ae kp" href="https://accounts.google.com." rel="noopener ugc nofollow" target="_blank">。</a>注意，只接受使用https的URL。</p><p id="6bbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> — oidc-client-id: </strong>将为其颁发令牌的客户端id。比如kubernetes。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c7ca688a8b7dfcaa90a33ee1ed2c1975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/0*dHd95J3DdkGq38v8.png"/></div></figure><p id="1867" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，web证书具有用于显示网站名称(用于身份验证)的<a class="ae kp" href="https://en.wikipedia.org/wiki/Common_name" rel="noopener ugc nofollow" target="_blank">通用名称</a>和用于存储与资源位置相关的信息的<a class="ae kp" href="https://en.wikipedia.org/wiki/X.509" rel="noopener ugc nofollow" target="_blank">主题</a>，如国家、城市、部门等。Kubernetes使用common name字段作为用户名，并使用subject来添加该用户所属的任何名称空间。在这种身份验证方法中，集群操作员/管理员负责在用户之间创建和分发证书。此外，监控证书到期和撤销也是工作流的一部分。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/cf68e4629f071f512ac059cfb70a77e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*uo1u2Wabcdyu2KBA.png"/></div></figure><p id="a09a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种身份验证方法需要上述标志才能工作。然而，您可以提供其他的<a class="ae kp" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#configuring-the-api-server" rel="noopener ugc nofollow" target="_blank">可选标志</a>来根据您的喜好定制认证过程。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ng"><img src="../Images/585ed8092366699953b6bd92dde33798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sSk0sKBOq8vetMt9.png"/></div></div></figure><p id="842f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上策略都是现成的。但是，您可能需要将API身份验证过程与现有的LDAP或Kerberos身份验证提供程序联系起来。Kubernetes提供了两种与外部身份验证提供者集成的方法:</p><p id="a4d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您选择X-Remote-User作为包含用户名的头，X-Remote-Group用于指定用户组(或名称空间),任何以X-Remote-Extra- prefix开头的头用于可能包含用户额外信息的其他头。现在，API服务器可以使用以下标志来启用此配置:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="53b4" class="mc kr it ly b gy md me l mf mg">--requestheader-username-headers=X-Remote-User<br/>--requestheader-group-headers=X-Remote-Group<br/>--requestheader-extra-headers-prefix=X-Remote-Extra-</span></pre><p id="e224" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">保存所需信息的典型HTTP请求如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="b877" class="mc kr it ly b gy md me l mf mg">GET / HTTP/1.1<br/>X-Remote-User: fido<br/>X-Remote-Group: dogs<br/>X-Remote-Group: dachshunds<br/>X-Remote-Extra-Acme.com%2Fproject: some-project<br/>X-Remote-Extra-Scopes: openid<br/>X-Remote-Extra-Scopes: profile</span></pre><p id="e315" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，没有什么可以阻止攻击者通过使用合法用户的名字和名称空间来冒充合法用户。因此，API代理使用认证机构来验证请求。API服务器选项中添加了以下标志:<br/>—request header-client-ca-file，这是一个PEM编码的证书包。任何请求都必须有一个有效的证书，API服务器首先根据证书颁发机构对该证书进行验证。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="563f" class="mc kr it ly b gy md me l mf mg"># Kubernetes API version<br/>apiVersion: v1<br/># kind of the API object<br/>kind: Config<br/># clusters refers to the remote service.<br/>clusters:<br/>  - name: name-of-remote-authn-service<br/>    cluster:<br/>      certificate-authority: /path/to/ca.pem         # CA for verifying the remote service.<br/>      server: <a class="ae kp" href="https://authn.example.com/authenticate" rel="noopener ugc nofollow" target="_blank">https://authn.example.com/authenticate</a> # URL of remote service to query. Must use 'https'.</span><span id="7c41" class="mc kr it ly b gy mp me l mf mg"># users refers to the API server's webhook configuration.<br/>users:<br/>  - name: name-of-api-server<br/>    user:<br/>      client-certificate: /path/to/cert.pem # cert for the webhook plugin to use<br/>      client-key: /path/to/key.pem          # key matching the cert</span><span id="af1b" class="mc kr it ly b gy mp me l mf mg"># kubeconfig files require a context. Provide one for the API server.<br/>current-context: webhook<br/>contexts:<br/>- context:<br/>    cluster: name-of-remote-authn-service<br/>    user: name-of-api-sever<br/>  name: webhook</span></pre><p id="35d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">—authentic ation-token-web hook-cache-TTL:在要求用户重新提供令牌之前，API服务器授予用户的宽限期(就像您第一次使用sudo，然后继续使用一段时间，而不需要提供您的密码)。默认值是两分钟。</p><h1 id="d6cb" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="a906" class="mq mr it js b jt lo jx lp kb nh kf ni kj nj kn mv mw mx my bi translated">身份验证是指验证试图访问资源的用户或服务的身份。</li><li id="e0d7" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">Kubernetes非常灵活，允许您选择适合您和您的组织的身份验证机制。</li><li id="4348" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">最简单的身份验证方法是使用包含用户密码或令牌的静态文件。不建议在生产环境中使用这种方法，因为您需要为每个用户或服务维护一个文件，并且需要访问API服务器。</li><li id="6529" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">X.509方法是一种流行的身份验证机制，在这种机制中，您为每个用户创建一个包含用户名和每个用户所属组的证书。您需要部署一个证书颁发机构，并维护证书的生成、撤销和过期。然而，它仍然比静态文件方法好。</li><li id="d5e1" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">使用任何支持OIDC (OpenID Connect)的平台，比如Google，您可以配置API服务器来接受用户通过成功认证OIDC服务而获得的不记名令牌。</li><li id="0428" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">如果您有自己的认证服务，比如LDAP服务器或基于Kerberos的机制，您仍然可以将其与Kubernetes集成，通过它们来认证用户。Kubernetes在这些场景中使用身份验证代理和Webhook令牌身份验证。</li><li id="378d" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">身份验证代理允许您在HTTP请求中选择特定的头，以提取所需的身份验证信息，如用户名和名称空间。</li><li id="a4a1" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">Webhook身份验证允许您的用户通过外部服务(例如GitHub)生成和使用他们自己的令牌，并在向API服务器进行身份验证时使用它们。</li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="dd75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2020年1月21日https://www.magalix.com</em><a class="ae kp" href="https://www.magalix.com/blog/kubernetes-authentication" rel="noopener ugc nofollow" target="_blank"><em class="ko"/></a><em class="ko">。</em></p></div></div>    
</body>
</html>