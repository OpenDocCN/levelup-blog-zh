<html>
<head>
<title>How to Create Pages Dynamically in Gatsby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在盖茨比中动态创建页面</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-pages-dynamically-in-gatsby-ab7b73af3790?source=collection_archive---------4-----------------------#2020-06-17">https://levelup.gitconnected.com/how-to-create-pages-dynamically-in-gatsby-ab7b73af3790?source=collection_archive---------4-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/56d75d8e2ea552a1dbcd8170abfc7b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThADtdOJwvv0MsrmoVr39w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kadh" rel="noopener ugc nofollow" target="_blank"> Kira auf der Heide </a>拍摄</figcaption></figure><p id="ec82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将探讨如何从Gatsby中的数据(markdown文件)以编程方式创建页面。</p><p id="4741" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了从markdown动态创建这些页面，我们将研究Gatsby的Node <code class="fe le lf lg lh b">createPages</code> API。</p><p id="e6c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在我们这样做之前，我们需要安装几个插件来获取和转换markdown文件，以便Gatsby能够理解markdown文件的路径及其内容，并能够创建这些页面。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="37f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建页面，我们需要做以下3个步骤，使其动态发生。</p><h1 id="3285" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">装置</h1><p id="de20" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">通过安装以下插件</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="2e5e" class="na lq it lh b gy nb nc l nd ne">npm install --save gatsby-source-filesystem gatsby-transformer-remark</span></pre><h2 id="e22a" class="na lq it bd lr nf ng dn lv nh ni dp lz kr nj nk md kv nl nm mh kz nn no ml np bi translated">1.读取降价文件并转换它们</h2><p id="202f" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们将通过传递一个包含变量和文件路径的options对象来告诉Gatsby我们的文件系统中的内容路径。</p><p id="a83d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用<code class="fe le lf lg lh b">gatsby-transformer-remark</code>将这些markdown文件内容转换为HTML，将frontmatter元数据转换为frontmatter，这将把这些文件转换为包含MarkdownRemark节点类型的边，并将每个frontmatter字段转换为GraphQL字段，我们可以稍后在页面/组件中查询这些字段，并在构建时映射它们。</p><h1 id="8c1c" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">引导程序</h1><p id="5a56" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">为了读取markdown文件路径并将它们转换成GraphQL字段，我们需要在安装两个插件后将下面的配置添加到我们的<code class="fe le lf lg lh b">gatsby-config.js</code>中。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="abe4" class="na lq it lh b gy nb nc l nd ne">//gatsby-config.js<br/> `gatsby-transformer-remark`,<br/>{<br/>      resolve: `gatsby-source-filesystem`,<br/>      options: {<br/>        name: `posts`,<br/>        path: `${__dirname}/content/posts`, // for the path you can change it based on your preferred folder structure<br/>      },<br/>},</span></pre><h2 id="d8db" class="na lq it bd lr nf ng dn lv nh ni dp lz kr nj nk md kv nl nm mh kz nn no ml np bi translated">2.为降价文件创建页面组件(模板)</h2><p id="fef1" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们需要创建一个页面模板组件，该组件将在构建时使用GraphQL与数据(可用的graphql字段，这些字段通过gatsby-transformer-remark进行了转换)进行映射，以动态创建这些页面。</p><p id="5102" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的内容中，你可以看到我为博客文章使用的文章模板的一个简化的例子。<strong class="ki iu">注意:您可以创建任意多的模板</strong></p><h1 id="487b" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">例子</h1><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="4c44" class="na lq it lh b gy nb nc l nd ne">import React from 'react';<br/>import { graphql } from 'gatsby';<br/><br/>const Post = ({ data }) =&gt; {<br/>  const { markdownRemark } = data;<br/>  const { title, date } = markdownRemark.frontmatter;<br/>  const { html, timeToRead } = markdownRemark;<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div className="post-wrapper"&gt;<br/>        &lt;Title&gt;{title}&lt;/Title&gt;<br/>        &lt;div&gt;<br/>          &lt;p&gt;{date}.&lt;/p&gt;<br/>          &lt;p&gt;{timeToRead} min read.&lt;/p&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="blogpost" dangerouslySetInnerHTML={{ __html: html }} /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="774a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们可以看到特定的数据(GraphQL字段)正在被提取，并在上面的模板组件中使用现成的GraphQL查询。</p><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="9158" class="na lq it lh b gy nb nc l nd ne">export const query = graphql`<br/>  query($pathSlug: String!) {<br/>    markdownRemark(frontmatter: { path: { eq: $pathSlug } }) {<br/>      html<br/>      frontmatter {<br/>        title<br/>        date<br/>      }<br/>      timeToRead<br/>    }<br/>  }<br/>`;</span></pre><h2 id="55d4" class="na lq it bd lr nf ng dn lv nh ni dp lz kr nj nk md kv nl nm mh kz nn no ml np bi translated">3.使用gatsby的节点<code class="fe le lf lg lh b">createPages</code> API以编程方式创建页面</h2><p id="5384" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">要创建新页面，我们需要执行以下步骤</p><ul class=""><li id="f855" class="nq nr it ki b kj kk kn ko kr ns kv nt kz nu ld nv nw nx ny bi translated">使用createPages API为页面生成slug(路径)</li><li id="73d4" class="nq nr it ki b kj nz kn oa kr ob kv oc kz od ld nv nw nx ny bi translated">通过将内容(转换后的降价文件)映射到页面组件模板来创建页面</li></ul><p id="7a51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">gatsby-node.js</code>中，我们导出createPages API并传递给它两个参数，<code class="fe le lf lg lh b">graphql</code>用于查找文件，<code class="fe le lf lg lh b">actions</code>其中createPages是它的一个属性。</p><p id="f3fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于文件创建的异步性质，createPages函数将返回给我们一个新的承诺(或者，您可以按照gatsby docs中的示例使用回调)。</p><p id="80b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注意:为了创建这些页面，我们需要使用“path.resolve”访问页面模板。</strong></p><p id="0558" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要将promise的状态更改为fulfilled，我们需要通过调用graphql来解决这个问题，并向它传递我们对allmarkdownremark的查询，其中包含我们希望帖子所在位置的路径字段。(这个路径字段是我们在markdown frontmatter元数据中设置的)。</p><p id="fa53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们将一个函数传递给<code class="fe le lf lg lh b">.then</code>,一旦状态变为“已完成”,这个函数将被调用，我们将结果值传递给这个函数。结果将包含一个与我们的查询匹配的数据对象，正如您在屏幕截图中看到的那样。</p><p id="130b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数体中，我们将使用foreach迭代每个文件节点(边是指向文件系统节点的路径)，以提取frontmatter中那些节点的路径。</p><p id="2824" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过控制台日志节点参数，查看查询中每个markdown文件返回的值，该值类似于下面的屏幕截图，显示了我们可以从节点内容中得到的结果。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e919bde9104de0b3d3b0f3c5563b0ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*7rhI4SY6TKCd-f2wrvzCSQ.png"/></div></figure><p id="8467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了可用的路径值，现在我们可以调用“createPage”操作，该操作接受3个参数:页面url的路径、要呈现的组件(页面模板组件)和将作为属性对页面组件可用的上下文对象。<br/>当我们将上下文对象传递给模板组件时，我们希望模板知道名为pathslug的文件的路径，因为path是保留关键字，pathSlug的值将是节点frontmatter提供的字段。在createPage调用之后，我们将解析promise，如下例所示。</p><h1 id="a023" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">配置</h1><pre class="ms mt mu mv gt mw lh mx my aw mz bi"><span id="be58" class="na lq it lh b gy nb nc l nd ne">exports.createPages = ({ graphql, actions }) =&gt; {<br/>  const { createPage } = actions;<br/>  return new Promise((resolve, reject) =&gt; {<br/>    // to create the page we need access to the blog post template<br/>    const postTemplate = path.resolve('src/templates/postTemplate.js');<br/>    resolve(<br/>      graphql(<br/>        `<br/>          {<br/>            allMarkdownRemark {<br/>              edges {<br/>                node {<br/>                  frontmatter {<br/>                    path<br/>                  }<br/>                }<br/>              }<br/>            }<br/>          }<br/>        `<br/>      ).then(result =&gt; {<br/>        if (result.errors) {<br/>          console.log(result.errors);<br/>          reject(result.errors);<br/>        }<br/>        result.data.allMarkdownRemark.edges.forEach(({ node }) =&gt; {<br/>          // you can see node value in the screenshot<br/>          const path = node.frontmatter.path;<br/><br/>          createPage({<br/>            path,<br/>            component: postTemplate,<br/>            context: {<br/>              /*<br/>              the value passed in the context will be available for you to use in your page queries as a GraphQL variable, as per the template snippet */<br/>              pathSlug: path,<br/>            },<br/>          });<br/>          resolve();<br/>        });<br/>      })<br/>    );<br/>  });<br/>};</span></pre><p id="8144" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的graphql中运行时，您可以在上面的代码片段中看到graph QL查询的结果</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/3f76a4f8290cf6d5cdc37202f24b67d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OniBgH_58Vr_BqaG2ng6KQ.png"/></div></div></figure><h1 id="6673" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">如果你觉得这篇文章有帮助</h1><p id="6b2a" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">您可能会喜欢这些其他文章:</p><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-create-pages-dynamically-in-gatsby-using-mdx-66faa175944e"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何使用MDX在Gatsby中动态创建页面</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">在本帖中，我们将探讨如何在Gatsby中使用MDX以编程方式创建页面。</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox jz oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/syntax-highlighting-in-gatsby-mdx-f0187ce51f4f"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">Gatsby MDX中的语法高亮</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">这篇文章展示了如何使用prism-react-renderer为Gatsby MDX文件启用语法高亮显示</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox jz oj"/></div></div></a></div></div></div>    
</body>
</html>