<html>
<head>
<title>Modular Event Tracker in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的模块化事件跟踪器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/modular-event-tracker-with-swift-ce8425a06f64?source=collection_archive---------10-----------------------#2020-07-19">https://levelup.gitconnected.com/modular-event-tracker-with-swift-ce8425a06f64?source=collection_archive---------10-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d0c81f823c0074b0001067e5d6874ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pT8Nnb0S4xQhrbPa3ZJ-Ow.png"/></div></div></figure><p id="e64a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了非常小的爱好项目，几乎每个iOS应用程序都有一个跟踪器架构来测量和跟踪分析事件。有时实施第三方解决方案或内部跟踪解决方案就足够了，有时您应该同时支持这两种解决方案。除了实现它们之外，为了项目的缘故，您还想保持跟踪机制的整洁。</p><p id="ee6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于Trendyol iOS应用程序是土耳其电子商务类别中最受欢迎的iOS应用程序之一，我们使用各种第三方解决方案和内部解决方案来跟踪事件。事实上，我们有一个跟踪机制，直到上个季度一直表现良好，但是我们注意到，随着应用程序的增长，它的规模不够大，还会出现一些问题。首先看看我们要改变的以前的跟踪解决方案，看看这里有什么问题。</p><p id="e59b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">先说跟踪服务；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">跟踪服务</figcaption></figure><p id="58d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> TrackingService </strong>是一个包含跟踪选项的基本enum。如你所见，它由一些流行的第三方解决方案和一个名为<strong class="kd iu"> AwesomeTracking </strong>的内部解决方案组成。</p><blockquote class="lj lk ll"><p id="726d" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">我们使用的内部解决方案的实际名称不是<strong class="kd iu"> awesomeTracking </strong>，但是出于隐私原因，我们现在就这样命名吧。</p></blockquote><p id="b0ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了跟踪服务之外，还有一个<strong class="kd iu">可跟踪</strong>协议，每个 事件都要符合这个<strong class="kd iu"><em class="lm">；</em></strong></p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="9468" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">可追踪</strong>协议是追踪机制的核心。正如您所看到的，协议有一个名为<strong class="kd iu"> <em class="lm"> services </em> </strong>的必需变量(上面已经解释过了)，以及一个<strong class="kd iu"> <em class="lm"> track() </em> </strong>方法，它的默认实现在可跟踪扩展中提供。</p><p id="e565" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在track方法中，每个事件都是通过其关联的实例发送的(大多数都是单例对象)。其对内部跟踪机制有效，此说法对<strong class="kd iu"><em class="lm">AwesomeTracking</em></strong>也成立。所有肮脏的事件和网络的东西都藏在那里。</p><p id="e4e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解它在基本级别是如何工作的，让我们实现一个名为<strong class="kd iu"> SupplierInfoEvent，</strong>的基本事件，因为每个事件都应该符合可跟踪协议，所以它的实现可以编码为；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="67d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，当你符合<strong class="kd iu"> <em class="lm">可跟踪</em> </strong>协议时，你应该实现<strong class="kd iu"> <em class="lm">服务</em> </strong>数组，其中包含跟踪服务的引用。在上面的特定示例事件中，firebase被赋予Trackable。</p><p id="bc2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只要写一行代码，你就可以把这个事件发送到任何你想发送的地方；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><blockquote class="lj lk ll"><p id="722a" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">注意，每个事件都符合Trackable，作为Tracker 的<strong class="kd iu">扩展实现，这只是为了在编写Tracker.xxx时清楚地看到哪些事件是可用的</strong></p></blockquote><p id="dfd0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，这里的问题是什么？为什么我们需要改变它？</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="303b" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">我们在以前的设计中遇到的问题</h1><h2 id="7b6d" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">原因1(模块化)</h2><p id="9402" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">由于Trendyol iOS应用程序的功能越来越多，我们决定让它更加模块化，由许多框架、包等组成。除了大规模的功能，Trendyol的目标是成为一个超级应用程序，包含几乎独立的应用程序规模的功能，如<strong class="kd iu"> Dolap Lite </strong> ( <em class="lm">在线二手时尚</em>)和<strong class="kd iu"> Trendyol Go </strong> ( <em class="lm">快速在线杂货店购物</em>)。由于当时Trendyol iOS应用程序是一个完整的整体应用程序，因此在实现这种跟踪机制时没有考虑模块化。</p><h2 id="1963" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">原因#2(可测试性)</h2><p id="860e" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">由于每个事件结构都符合跟踪协议，并且事件是通过结构本身发送的(没有依赖注入)，所以很难测试当前的机制。</p><p id="65da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果在编写像"<em class="lm">这样的单元测试时模仿事件结构就太好了，如果在产品细节屏幕上调用这个方法，那么这两个事件方法也应该被调用</em></p><h2 id="5a1a" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">原因3(灵活性)</h2><p id="9942" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">特别是对于内部解决方案(如上面的<em class="lm"> AwesomeTracking </em>所述)，实际的事件发送者类和跟踪服务是紧密耦合的。除此之外，使用具体类型代替协议类型。例如，每个<strong class="kd iu"> AwesomeTracking </strong>事件都发送了大量的默认参数，这些默认参数是在实际的事件发送器类中处理的(当前情况下为<strong class="kd iu"><em class="lm">AwesomeTracking . shared</em></strong>实例)。考虑到我们将在<strong class="kd iu">Trendyol本身和Dolap Lite </strong>中使用AwesomeTracking，然而一些默认参数<strong class="kd iu">应该是不同的</strong>。这种情况下我们该怎么办？由于我们不能将实际的事件发送器类注入跟踪服务，我们应该为Dolap Lite的AwesomeTracking服务添加新的案例，这是糟糕设计的标志。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1599" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">新的模块化设计</h1><p id="8122" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">我们的目标是开发一些解决上述问题的东西，同时保留现有设计的积极方面。</p><p id="f1d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们通过导入它在其他框架中使用这个新的跟踪架构，所以让我们创建一个名为<strong class="kd iu"> CoreTracker的框架。</strong></p><blockquote class="lj lk ll"><p id="70b4" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">在这个框架的名称中使用<strong class="kd iu"> <em class="it"> Core </em> </strong>前缀的原因是，它为使用CoreTracker的特定跟踪框架或目标提供了核心级行为。</p></blockquote><figure class="kz la lb lc gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/b85632c0b2cdfcc6b7a13e7b61577bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*91O8lqAxnei98LJ9L7hGPg.png"/></div></figure><p id="89df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建CoreTracker框架后，让我们创建<strong class="kd iu"> CoreTrackable </strong>和<strong class="kd iu"> EventService，</strong>这些几乎和之前的跟踪实现一样。CoreTrackable <strong class="kd iu"> </strong>将是<strong class="kd iu">每个事件应该符合的协议。</strong></p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><blockquote class="lj lk ll"><p id="bb5f" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">注意，为了简单起见，将只使用一个第三方服务<strong class="kd iu"><em class="it">(</em>firebase<em class="it">)</em></strong>和一个内部服务<strong class="kd iu">(出色的跟踪)</strong>。</p></blockquote><p id="1a58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里你应该注意到一个区别，在以前的实现中，<strong class="kd iu"> <em class="lm"> track() </em> </strong>方法属于<strong class="kd iu"> Trackable </strong>协议(<em class="lm">又名CoreTrackable此处为</em>)，然而在新的设计中<strong class="kd iu"> CoreTrackable </strong>只需要服务数组，这意味着track方法不是通过事件本身调用的，让我们把它放到名为<strong class="kd iu"> CoreTracker的新协议中。</strong></p><blockquote class="lj lk ll"><p id="40cb" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">CoreTracker将是我们新事件结构的主干，每个使用这个事件框架的框架都应该定义一个符合CoreTracker的具体类型来发送事件。</p></blockquote><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="e10a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以看到在第10行和第12行应该有实例实际上是<strong class="kd iu">发送事件</strong>。由于每个使用CoreTracker的框架都希望给出自己的事件发送类，我们应该为它们考虑一个协议，而不是具体的类型。</p><p id="f462" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如对于<strong class="kd iu"> AwesomeTracking </strong>，我们可以为项目需求创建如下协议；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="8732" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似地，对于第三方服务(<em class="lm"> Firebase </em>)，我们可以创建一个协议，将实际的事件发送实现提供给CoreTracker模块；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="b565" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们将这两个事件服务放到我们之前创建的CoreTracker协议中；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="e50e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了形象化我们到目前为止所做的工作，我们可以看看下面的基本图表；</p><figure class="kz la lb lc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/474e53b04709e0a1860246c73cbb5576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FY3_wpYYepNY1SCasIQVeg.png"/></div></div></figure><p id="0a5d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，有一个<strong class="kd iu"> CoreTracker </strong>协议包含事件服务。当一个框架想要使用它时，它应该创建一个符合CoreTracker的tracker类，作为CoreTracker <strong class="kd iu"> </strong>的要求，它应该给出firebase service和awesome tracking service实例，这些实例必须符合<strong class="kd iu"> AwesomeTrackingService </strong>和<strong class="kd iu"> FirebaseService协议</strong>。</p><p id="bffa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们使用这个事件结构，考虑将二手电子商务功能嵌入到我上面提到的名为<strong class="kd iu"> <em class="lm"> DolapLite </em> </strong>的Trendyol应用程序中。它在项目中有自己的框架。</p><p id="9edc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">DolapLite由三个接口框架组成，我们称这些为<strong class="kd iu"> <em class="lm">模块</em></strong>；</p><figure class="kz la lb lc gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/aa6e1e3c8ea546fb577e2072f6d8034b.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*sIlZgrplf8whPfR5dy7kEw.png"/></div></figure><p id="da57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想使用CoreTracker框架，我们应该创建一个符合<strong class="kd iu"> CoreTracker </strong>协议的<strong class="kd iu"> Tracker </strong>类。既然我们想在<strong class="kd iu"><em class="lm">dola plite</em></strong>的所有接口框架中使用这个跟踪器，我应该创建一种包装器框架并在其中放入Dolap Lite spesific Tracker类。所以让我们创建<strong class="kd iu"> DLTracker </strong>(又名DolapLite Tracker)框架，并在导入CoreTracker后在其中创建Tracker类；</p><blockquote class="lj lk ll"><p id="56bc" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">注意，DL前缀用于属于Dolap Lite的所有类</p></blockquote><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="9049" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为firebase服务和awesome跟踪服务需要CoreTracker协议的参数，所以我们应该创建和设置这两个服务。</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="d672" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里创建这些服务的美妙之处在于，这些服务的实现将是Dolap Lite框架所独有的。这是必需的，因为Trendyol和DolapLite中的Awesome服务事件所需的参数将<strong class="kd iu">不同</strong>。</p><p id="7d50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们用这些新服务创建<strong class="kd iu">dl tracker</strong>；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><blockquote class="lj lk ll"><p id="017e" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">注意，我们已经将这些服务作为init方法的默认参数注入。因为在编写单元测试时，我们可以很容易地用模拟服务初始化这个跟踪器。</p></blockquote><p id="db40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以在Dolap Lite的一个框架中使用新的tracker。让我们导入<strong class="kd iu"> DLTracker </strong>框架，并在<strong class="kd iu"> DLProductDetail </strong>框架下创建一个示例产品细节事件；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="9977" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建活动后，考虑在dolap lite产品详细信息页面的演示者中使用它。因为所有的事件都应该通过一个符合<strong class="kd iu"> CoreTracker </strong>协议的实例来发送(对于Dolap Lite来说是<strong class="kd iu"> DLTracker </strong>，让我们把它注入到presenter对象中；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><blockquote class="lj lk ll"><p id="31c9" class="kb kc lm kd b ke kf kg kh ki kj kk kl ln kn ko kp lo kr ks kt lp kv kw kx ky im bi translated">注意，我们保留了tracker实例作为CoreTracker协议的一种类型，并注入了DLTracker实例作为init的默认参数。这是因为我们可以在单元测试中使用模拟跟踪器实例。</p></blockquote><p id="cb26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在演示器中发送事件很容易；</p><figure class="kz la lb lc gt ju"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="c8cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们用新的跟踪实现来重新考虑第一部分提到的问题；</p><h2 id="8318" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">#1模块化</h2><p id="d6c2" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">新的跟踪机制封装到一个单一的事件框架和高度模块化。如果在不同的框架中使用，导入和创建符合跟踪协议的类就足够了。</p><p id="e750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，对于像firebase或adjust这样的第三方服务，它们的SDK可以在tracker框架中实现，而不会影响其他模块。</p><h2 id="a4fc" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">#2可测试性</h2><p id="be00" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">事件发送不是在具体的事件类本身处理的，而是在符合CoreTracker协议的类中处理的，由于CoreTracker本身及其服务可以通过init注入，所以它很容易被模仿，并且事件发送在单元测试中是可测试的。</p><h2 id="81b6" class="mv ly it bd lz mw mx dn md my mz dp mh km na nb ml kq nc nd mp ku ne nf mt ng bi translated">#3灵活性</h2><p id="066d" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">不仅每个使用CoreTracker的框架都可以提供自己的服务(例如Dolap Lite示例中的DLAwesomeTrackingService)，以前创建的服务也可以在其他框架中重用。</p><p id="6332" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果firebase服务实现对于Dolap Lite和Trendyol是相同的，我们可以只创建一个firebase服务类，并将其注入到<strong class="kd iu">dl Tracker</strong>(Dolap Lite Tracker)和<strong class="kd iu">ty Tracker</strong>(Trendyol Tracker)。</p><p id="abec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们认为这种方法将解决我们目前的问题，我们将使用它，直到下一个里程碑。我希望你也能从中找到一些有用的东西。</p><p id="c219" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你喜欢，编码快乐！</p></div></div>    
</body>
</html>