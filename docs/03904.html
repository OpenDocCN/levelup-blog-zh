<html>
<head>
<title>Handling data at the edge of your Vue.js application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Vue.js应用程序的边缘处理数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-data-at-the-edge-of-your-vue-js-application-1872782d391a?source=collection_archive---------17-----------------------#2020-06-01">https://levelup.gitconnected.com/handling-data-at-the-edge-of-your-vue-js-application-1872782d391a?source=collection_archive---------17-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="9992" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">TLDR:在本文中，我们将讨论如何在应用程序边界处理数据。代码在<a class="ae ks" href="https://github.com/vinicius0026/handling-application-boundary" rel="noopener ugc nofollow" target="_blank"><em class="it">vinicius 0026/handling-application-boundary</em></a>可用</p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/9144205447c505792529ef772dddb828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYWeYxXwTuD4w-TqA8PCkQ.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@sylwiabartyzel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西尔维亚·巴蒂泽尔</a>在<a class="ae ks" href="https://unsplash.com/s/photos/boundary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ef08" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">这是我们构建大型Vue.js应用程序系列的第五篇文章。以下是已发布和计划发布的文章的完整列表:</p><ul class=""><li id="0ca3" class="lm ln it jw b jx jy kb kc lj lo lk lp ll lq kr lr ls lt lu bi translated"><a class="ae ks" href="https://medium.com/swlh/properly-typed-vuex-stores-427bf4c6a3d1" rel="noopener">正确输入的Vuex商店</a>—<em class="jv">2020年5月13日发布</em></li><li id="0ce2" class="lm ln it jw b jx lv kb lw lj lx lk ly ll lz kr lr ls lt lu bi translated"><a class="ae ks" href="https://medium.com/swlh/adopting-typescript-in-your-vue-js-application-in-a-sane-way-d6bd31757fe5" rel="noopener">以同样的方式在你的Vue.js应用中采用TypeScript</a>—<em class="jv">发布于2020年5月14日</em></li><li id="53e7" class="lm ln it jw b jx lv kb lw lj lx lk ly ll lz kr lr ls lt lu bi translated"><a class="ae ks" href="https://medium.com/swlh/modularizing-the-logic-of-your-vue-js-application-5b920e17c25e" rel="noopener">模块化您的Vue.js应用程序的逻辑</a>—<em class="jv">2020年5月15日发布</em></li><li id="4189" class="lm ln it jw b jx lv kb lw lj lx lk ly ll lz kr lr ls lt lu bi translated"><a class="ae ks" href="https://medium.com/swlh/data-driven-components-2ab02ccbf204" rel="noopener">数据驱动组件</a>—<em class="jv">2020年5月25日发布</em></li><li id="8e06" class="lm ln it jw b jx lv kb lw lj lx lk ly ll lz kr lr ls lt lu bi translated">在你的Vue.js应用边缘处理数据— <em class="jv">发布于2020年6月1日— </em> <strong class="jw iu">你在这里</strong></li></ul><p id="ebc8" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">在本系列的前几篇文章中，我们只处理了应用程序本地的数据，这意味着我们数据的整个生命周期都在控制之中。绝大多数应用程序都有一些与外部服务(应用程序的REST API)的接口，因此数据是在应用程序范围之外生成的。</p><p id="c239" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">今天，我们将讨论如何在应用程序的边界处理数据，确保无论何时数据从外部来源进入我们的Vue.js应用程序，我们都有适当类型的格式良好的对象。</p><h1 id="7070" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">问题是</h1><p id="93a9" class="pw-post-body-paragraph jt ju it jw b jx my jz ka kb mz kd ke lj na kh ki lk nb kl km ll nc kp kq kr im bi translated">每当我们接触外部API时，我们都无法确切知道将交付给我们的数据的形状。我们必须依赖API的文档，如果可用的话，用API来构建我们的前端应用程序接口。尽管如此，由于HTTP JSON APIs并没有对数据实施特定的模式，我们应该对传入的数据保持一定的不信任。</p><p id="8f2d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">因此，为了增加我们对应用程序中处理的数据的信心，我们应该在应用程序和消费的API之间建立一个清晰的边界，确保通过这个边界进入的所有数据都是预期的形状。</p><p id="5844" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">在本文中，我们将构建一个服务层，作为外部API的唯一接口，确保流经它的所有内容都是已知的类型。</p><h1 id="4e74" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">使用服务作为应用程序边界</h1><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nd"><img src="../Images/ae1da647a0b9d565d2519de310961d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ve78-1dud-MhEESx.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">外部API和Vue.js应用程序之间的服务层</figcaption></figure><p id="4430" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们的目标是拥有一个处理所有外部通信的服务层，确保进入我们应用程序的数据处于正确的状态。</p><p id="8ee2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们将扩展我们在以前的文章中讨论过的发票模型，并将为发票的CRUD操作构建服务层。</p><h1 id="4b46" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">查看类型定义</h1><p id="22c2" class="pw-post-body-paragraph jt ju it jw b jx my jz ka kb mz kd ke lj na kh ki lk nb kl km ll nc kp kq kr im bi translated">在前一篇<a class="ae ks" href="https://viniciusteixeira.tk/2020/05/14/adopting-typescript-in-your-vue-application-in-a-sane-way/" rel="noopener ugc nofollow" target="_blank">文章</a>中，我们将发票类型定义为:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">发票类型定义</figcaption></figure><p id="780e" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们为发票添加了类型为<code class="fe ng nh ni nj b">number</code>或<code class="fe ng nh ni nj b">null</code>的<code class="fe ng nh ni nj b">id</code>字段(当发票还没有在服务器端创建时)。</p><p id="ad86" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">现在，我们希望构建一个服务层，允许我们在发票中进行CRUD操作。现在让我们来定义服务框架。</p><h1 id="5729" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">服务层</h1><p id="b0a4" class="pw-post-body-paragraph jt ju it jw b jx my jz ka kb mz kd ke lj na kh ki lk nb kl km ll nc kp kq kr im bi translated">正如我们在构建应用程序的<a class="ae ks" href="https://medium.com/swlh/modularizing-the-logic-of-your-vue-js-application-5b920e17c25e" rel="noopener">核心逻辑</a>时所做的那样，我们将使用模块模式来构建我们的服务层。我们可以这样做:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">发票服务存根</figcaption></figure><p id="db7d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们假设REST API与我们的应用程序在同一个地方可访问，所有CRUD端点都可用。</p><p id="067d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">通过我们的应用程序专门通过这个服务访问外部数据，我们可以确信它将接收到有效的对象，并且具有已知的类型。请注意，我们留下了注释，说明我们需要解析来自API的响应。我们仍然需要编写这些解析函数。它们将是应用程序核心逻辑的一部分，在模块中，每个模块负责解析它们相关的数据类型。让我们看看这是什么样子:</p><h1 id="0f2f" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">解析API响应</h1><p id="b2ad" class="pw-post-body-paragraph jt ju it jw b jx my jz ka kb mz kd ke lj na kh ki lk nb kl km ll nc kp kq kr im bi translated">在<a class="ae ks" href="https://medium.com/swlh/data-driven-components-2ab02ccbf204" rel="noopener">的上一篇文章</a>中，我们引入了一个<code class="fe ng nh ni nj b">Partial</code>类型，用于当对象没有一个类型的所有必需属性时。我们可以在这里重用它，将来自API的数据视为我们想要的类型的可能部分对象。</p><p id="07e4" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">API提供的数据很可能有一些与我们的前端类型定义相同的字段(理想情况下是全部)。但是，为了安全起见，我们将假设任何字段都可能丢失，使用<code class="fe ng nh ni nj b">Partial</code>类型包装来自API的所有数据。</p><p id="fb36" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们来写发票解析函数。我们将把它放在之前创建的发票模块中:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">发票模块中的发票解析功能</figcaption></figure><p id="6b91" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated"><code class="fe ng nh ni nj b">parse</code>函数接受一个未知的数据对象，也可以是未定义的。然后，我们构建一个有效的Invoice对象，默认情况下给它一个null id，并适当地解析其他字段。例如，对于<code class="fe ng nh ni nj b">totalAmount</code>字段，我们调用<code class="fe ng nh ni nj b">Decimal</code>构造函数来构建有效的十进制数，而来自API的数据肯定不是十进制对象——它可能是字符串或数字，这取决于服务器如何序列化数据。</p><p id="1aef" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们已经将用户和行项目处理委托给他们自己的模块的parse函数，我们还没有实现它。让我们现在做那件事。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">用户模块中的用户解析函数</figcaption></figure><p id="c770" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">因为我们的用户模型非常简单，所以用户<code class="fe ng nh ni nj b">parse</code>功能很简单。我们只需要为用户名和头像提供默认值，以防来自API的数据缺少这些字段。</p><p id="4b19" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">让我们继续讨论行项目解析函数:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">行项目模块中的行项目解析功能</figcaption></figure><p id="0f00" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">对于行项目解析函数，我们将比率转换为有效的小数对象(就像我们对发票总金额所做的那样)；我们给quantity字段一个默认值0，并将产品解析委托给它自己的模块。让我们看看这是什么样子:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">产品模块中的产品解析功能</figcaption></figure><p id="01c3" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">类似于用户解析函数，解析产品非常简单。</p><p id="8d1b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">至此，我们已经为所有数据类型编写了解析器，现在我们可以将发票解析功能插入到发票服务中。</p><p id="8cbb" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">下面是我们发票服务的最终实现:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">发票服务的最终实现</figcaption></figure><p id="ff61" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">注意服务变得多么简单，因为我们将解析逻辑委托给了发票模块。服务的职责是与API对话，然后将API对解析逻辑的响应传送到模块中。这将确保服务的返回类型是已知的。</p><h1 id="aef6" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">处理有效载荷形状的不匹配</h1><p id="4e02" class="pw-post-body-paragraph jt ju it jw b jx my jz ka kb mz kd ke lj na kh ki lk nb kl km ll nc kp kq kr im bi translated">在前面的例子中，我们假设来自API的对象的形状类似于Vue.js应用程序中的对象的形状。如果我们能控制等式的两边，我们就能(或许应该)强制执行。但有时我们要么不控制服务器端，要么因为任何原因无法改变它。</p><p id="a428" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">如果是这种情况，我们可以为来自API的数据声明一个特定的类型，将其包装在一个分部类型中，然后在我们的应用程序中将其转换为一个适当的类型。</p><p id="e920" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">为了构建一个例子，我们假设有效载荷中的<code class="fe ng nh ni nj b">Product</code>对象有不同的字段名:<code class="fe ng nh ni nj b">product_name</code>而不是<code class="fe ng nh ni nj b">name</code>和<code class="fe ng nh ni nj b">product_desc</code>而不是<code class="fe ng nh ni nj b">description</code>。我们可以如下处理这种情况:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">处理API响应和应用程序定义类型的不匹配</figcaption></figure><p id="5de2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们已经声明了<code class="fe ng nh ni nj b">ApiProduct</code>接口，来表示API发送的产品的形状。</p><p id="5c0a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们不需要将这个接口导出到应用程序的其余部分，也不需要在我们的类型名称空间中声明它。它仅用于解析函数中。在应用程序的其余部分，我们应该只使用适当的<code class="fe ng nh ni nj b">Types.Product</code>类型。</p><p id="c656" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">如果我们需要从app <code class="fe ng nh ni nj b">Product</code>类型转换回API的<code class="fe ng nh ni nj b">ApiProduct</code>类型(例如，当处理产品CRUD时)，我们应该向产品模块添加一个函数来进行转换。我们可以随便叫它什么，只要我们在模块间的命名是一致的。</p><h1 id="2e28" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">获取意外API响应的通知</h1><p id="bcf5" class="pw-post-body-paragraph jt ju it jw b jx my jz ka kb mz kd ke lj na kh ki lk nb kl km ll nc kp kq kr im bi translated">在本文构建的示例中，我们忽略了API没有发送预期类型的完整对象这一事实。有时候这可能就是我们需要做的。但是在大多数情况下，我们应该得到通知并修复我们的API(如果这是我们可以控制的)或解析函数。</p><p id="2fb0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们编写的<code class="fe ng nh ni nj b">parse</code>函数是实现这一点的最佳场所。如果你正在使用类似于<a class="ae ks" href="https://sentry.io/" rel="noopener ugc nofollow" target="_blank"> Sentry </a>的东西来收集前端异常，你可以在有任何缺失字段的情况下引发一个异常，这个异常会被Sentry捕获。或者您可以使用<a class="ae ks" href="https://docs.sentry.io/platforms/javascript/#captureconsole" rel="noopener ugc nofollow" target="_blank">捕获控制台</a>集成，记录一个错误并返回一个有效的默认值(就像我们在示例中所做的那样),这样应用程序仍然可用，即使有一些数据丢失。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="b578" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">包扎</h1><p id="ad52" class="pw-post-body-paragraph jt ju it jw b jx my jz ka kb mz kd ke lj na kh ki lk nb kl km ll nc kp kq kr im bi translated">我们已经为我们的应用程序创建了一个清晰的边界，使用服务来转换来自外部来源(如我们的后端API)的数据，确保进入我们应用程序的数据具有已知的形状。</p><p id="45cc" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们在每个模块中创建了<code class="fe ng nh ni nj b">parse</code>函数来处理从一个潜在的不完整对象到一个已知的符合类型的对象的转换。</p><p id="db97" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">我们讨论了如何以完全不同的格式解析数据，而不会用仅转换类型污染我们的全局类型。</p><p id="b3e2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated">产生的服务和解析函数很短，易于推理和测试，使我们对应用程序的状态更有信心。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="d0f9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lj kg kh ki lk kk kl km ll ko kp kq kr im bi translated"><em class="jv">原载于2020年6月1日</em><a class="ae ks" href="https://viniciusteixeira.tk/2020/06/01/handling-data-at-the-edge-of-your-vuejs-app/" rel="noopener ugc nofollow" target="_blank"><em class="jv">https://viniciusteixeira . tk</em></a><em class="jv">。</em></p></div></div>    
</body>
</html>