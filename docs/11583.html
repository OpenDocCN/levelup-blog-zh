<html>
<head>
<title>Python is Not Just a Common OOP: Objects and Metaclass</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python不仅仅是一个普通的OOP:对象和元类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/two-types-of-abstractions-in-python-instance-of-inherited-from-e436a63cfcfd?source=collection_archive---------18-----------------------#2022-03-28">https://levelup.gitconnected.com/two-types-of-abstractions-in-python-instance-of-inherited-from-e436a63cfcfd?source=collection_archive---------18-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/71d461a28346c8b32622a1bb9a3d237e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkXoGeHqwCswfeaHZipPog.png"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="6df7" class="kf kg iq bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">所有的数据类型都是对象</h1><p id="a940" class="pw-post-body-paragraph ld le iq lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们都知道如何使用<code class="fe mb mc md me b">class</code>关键字定义数据类型并调用其实例对象。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="ce38" class="mn kg iq me b gy mo mp l mq mr">class Dog:<br/>    def __init__(self, name):<br/>        self.name = name<br/>    def bark(self):<br/>        print('Barking...')</span><span id="260c" class="mn kg iq me b gy ms mp l mq mr"># instantiate a Dog object<br/>husky = Dog(name)</span></pre><p id="5ef6" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">然而，在Python中，你可能不知道的是<strong class="lf ir">类本身是一个对象</strong>，作为<code class="fe mb mc md me b">type</code>类的一个实例。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="0636" class="mn kg iq me b gy mo mp l mq mr">&gt;&gt;&gt; type(Dog)<br/>&lt;class 'type'&gt;</span></pre><p id="cb49" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">更有甚者，<strong class="lf ir">所有的原语类型都是对象</strong>，如下例。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="fd3d" class="mn kg iq me b gy mo mp l mq mr">&gt;&gt;&gt; PI = 3.14<br/>&gt;&gt;&gt; text = 'human language'<br/>&gt;&gt;&gt; type(PI)<br/>&lt;class 'float'&gt;<br/>&gt;&gt;&gt; type(text)<br/>&lt;class 'str'&gt;</span><span id="a250" class="mn kg iq me b gy ms mp l mq mr">&gt;&gt;&gt; type(float)<br/>&lt;class 'type'&gt;<br/>&gt;&gt;&gt; type(str)<br/>&lt;class 'type'&gt;</span></pre><p id="4ae1" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">然而，尽管它们都是Python对象，但我们可以将它们分为<code class="fe mb mc md me b">type</code>对象、类对象(如<code class="fe mb mc md me b">Dog</code>、<code class="fe mb mc md me b">float</code>、<code class="fe mb mc md me b">str</code>)和实例对象(如<code class="fe mb mc md me b">husky</code>、<code class="fe mb mc md me b">PI</code>、<code class="fe mb mc md me b">text</code>)。</p><ul class=""><li id="2f6e" class="my mz iq lf b lg mt lk mu lo na ls nb lw nc ma nd ne nf ng bi translated">实例对象由类对象定义。</li><li id="9269" class="my mz iq lf b lg nh lk ni lo nj ls nk lw nl ma nd ne nf ng bi translated">类对象由<code class="fe mb mc md me b">type</code>定义。</li></ul></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="6d22" class="kf kg iq bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">Python中的两种抽象</h1><p id="c18b" class="pw-post-body-paragraph ld le iq lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">大多数人都知道，当我们定义一个<code class="fe mb mc md me b">Dog</code>类时，它会自动继承<code class="fe mb mc md me b">object</code>。如你所料，它也是一个类对象。</p><p id="0e10" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">换句话说，Python在<strong class="lf ir">继承</strong>(子类-超类)方面类似于其他面向对象的程序(OOPs)。</p><p id="4728" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">但是，Python对于类对象还有另外一个独特的抽象:<strong class="lf ir"> type。正如我们在上一节中讨论的，这种类型抽象是所有数据类型成为对象的基础。作为继承抽象中的超类对超类，更高层的对象被定义为该类型抽象中的<strong class="lf ir">元类型</strong>或<strong class="lf ir">元类</strong>。</strong></p><p id="42c1" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">让我们通过Python内置函数来看看<code class="fe mb mc md me b">Dog</code>的继承对象和元类。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="a64e" class="mn kg iq me b gy mo mp l mq mr"># Check what objects Dog inherits from<br/>print(Dog.__bases__) # (&lt;class 'object'&gt;,)</span><span id="de6a" class="mn kg iq me b gy ms mp l mq mr"># Check what is the metatype of Dog <br/>print(type(Dog))  # &lt;class 'type'&gt;</span></pre><p id="22a2" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">Python提供了检查继承抽象的<code class="fe mb mc md me b">issubclass</code>和检查类型抽象的<code class="fe mb mc md me b">isinstance</code>函数。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="d590" class="mn kg iq me b gy mo mp l mq mr"># True =&gt; Inherited from the superclass: object<br/>print(issubclass(Dog, object)) </span><span id="2b25" class="mn kg iq me b gy ms mp l mq mr"># True =&gt; Instance of the metaclass: type<br/>print(isinstance(Dog, type))</span></pre><p id="8d76" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在这种情况下，类<code class="fe mb mc md me b">Dog</code>继承自<code class="fe mb mc md me b">object</code>(我们称之为<strong class="lf ir">超类)</strong>，是<code class="fe mb mc md me b">type </code>(我们称之为<strong class="lf ir">元类)</strong>的实例。</p><p id="93c3" class="pw-post-body-paragraph ld le iq lf b lg mt li lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">有趣的是，一个类对象的实例化对象是在<strong class="lf ir">类型</strong>抽象(instance-class)中定义的，即类的实例与类的元类相同。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="1e70" class="mn kg iq me b gy mo mp l mq mr">type(husky) # &lt;class '__main__.Dog'&gt;</span></pre><h1 id="b291" class="kf kg iq bd kh ki nm kk kl km nn ko kp kq no ks kt ku np kw kx ky nq la lb lc bi translated">自定义超类和元类</h1><p id="c2d1" class="pw-post-body-paragraph ld le iq lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以自定义超类和元类，而不是默认的对象和类型。</p><ul class=""><li id="90ce" class="my mz iq lf b lg mt lk mu lo na ls nb lw nc ma nd ne nf ng bi translated">定制超类:我们可以将<code class="fe mb mc md me b">Animal</code>类定义为<code class="fe mb mc md me b">Dog</code>的超类。然后，<code class="fe mb mc md me b">Dog</code>可以自动从它的<code class="fe mb mc md me b">Animal</code>继承初始化和<code class="fe mb mc md me b">run()</code>行为。当然，我们也可以覆盖子类中的方法。</li></ul><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="84e3" class="mn kg iq me b gy mo mp l mq mr">class Animal(object): <br/>    def __init__(self, name):<br/>        self.name = name<br/>    def run(self):<br/>        pass</span><span id="d97d" class="mn kg iq me b gy ms mp l mq mr">class Dog(Animal): <br/>    pass</span></pre><ul class=""><li id="ac44" class="my mz iq lf b lg mt lk mu lo na ls nb lw nc ma nd ne nf ng bi translated">为狗定制的元类<code class="fe mb mc md me b">DogMeta</code>。</li></ul><blockquote class="nr ns nt"><p id="a0a4" class="ld le nu lf b lg mt li lj lk mu lm ln nv mv lq lr nw mw lu lv nx mx ly lz ma ij bi translated">有趣的是，<code class="fe mb mc md me b">CarMeta</code>必须继承<code class="fe mb mc md me b">type</code>类才能成为元类。</p></blockquote><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="e7e2" class="mn kg iq me b gy mo mp l mq mr">class DogMeta(type):<br/>     pass</span><span id="b243" class="mn kg iq me b gy ms mp l mq mr">class Car(metaclass=DogMeta):<br/>    pass</span></pre><h2 id="60b0" class="mn kg iq bd kh ny nz dn kl oa ob dp kp lo oc od kt ls oe of kx lw og oh lb oi bi translated"><strong class="ak">元类的Python核心模块</strong></h2><p id="d39a" class="pw-post-body-paragraph ld le iq lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">内置的<code class="fe mb mc md me b">abc</code>(<strong class="lf ir"><em class="nu">A</em></strong>bstrat<strong class="lf ir"><em class="nu">B</em></strong>ase<strong class="lf ir"><em class="nu">C</em></strong>lass)模块提供了使用元类的工具，而不是定义一个定制的元类。常见的类对象有两种:(1)使用元类<code class="fe mb mc md me b">ABCMeta</code>；(2)继承<code class="fe mb mc md me b">ABC</code>:由于<code class="fe mb mc md me b"><em class="nu">ABC</em></code>类有元类<code class="fe mb mc md me b"><em class="nu">ABCMeta</em></code>，从<code class="fe mb mc md me b"><em class="nu">ABC</em></code>继承的类也得到元类<code class="fe mb mc md me b"><em class="nu">ABCMeta</em></code>，这样用户就看不到关于元类的任何逻辑</p><h2 id="31ec" class="mn kg iq bd kh ny nz dn kl oa ob dp kp lo oc od kt ls oe of kx lw og oh lb oi bi translated">元类的实际用法</h2><p id="59e4" class="pw-post-body-paragraph ld le iq lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">元类的实际用途很少。Python提供它来克服传统OOP语言的限制。但是，随之而来的是杂乱的逻辑。具体用法可以参考本页。</p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><h1 id="cc9d" class="kf kg iq bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">分级编码</h1><p id="ed1c" class="pw-post-body-paragraph ld le iq lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae oj" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae oj" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae oj" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae oj" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">简讯</a> <br/> <strong class="lf ir">升一级正在转型的理工大招聘➡️ </strong> <a class="ae oj" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lf ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>