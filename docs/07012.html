<html>
<head>
<title>How to create an automatic ECS deployment with Jenkins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Jenkins创建自动ECS部署</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-an-automatic-ecs-deployment-with-jenkins-84c0e83e7cd0?source=collection_archive---------3-----------------------#2021-01-19">https://levelup.gitconnected.com/how-to-create-an-automatic-ecs-deployment-with-jenkins-84c0e83e7cd0?source=collection_archive---------3-----------------------#2021-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4e8b6a46d1a80bf090f6638e26dd8471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j64mp87zrF5EooGr.jpg"/></div></div></figure><p id="c6d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编程中最大的挑战之一是当我们有几个人同时在同一个项目上工作时，平滑地集成任何变化。对于这些情况<a class="ae kw" href="http://victorrentea.ro/" rel="noopener ugc nofollow" target="_blank"> <em class="kx">维克托·伦泰</em> </a>说:</p><blockquote class="ky kz la"><p id="1ccd" class="jy jz kx ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq">如果疼，那就多做几次，把疼痛带出来。</em></p></blockquote><p id="b764" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是持续集成和持续部署发挥作用的地方。我们知道，集成和部署小的变更远比更大、更重要的变更更容易实现，并且随着这些变更的增长，难度会成倍增加。那么这个问题的解决方法是什么呢？解决方案是更频繁地这样做，不断地、尽可能快地集成和部署小段代码。</p><p id="7f5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们知道，为了达到这个目标，并不是不断地合并和部署我们的代码那么简单。我们需要将以下概念引入我们的项目:</p><ul class=""><li id="f93d" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">测试:这对于验证我们正在集成的变更是否正常工作以及它们是否破坏了其他任何东西非常重要。</li><li id="58cd" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">自动化:如前所述，我们的目标是更频繁地进行这些变更，因此，最好的方法是采用自动化流程来节省时间并减少人为错误。</li></ul><p id="aef9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将关注第二点，并更具体地解释如何使用<em class="kx"> Jenkins </em>在<a class="ae kw" href="https://aws.amazon.com/ecs/?whats-new-cards.sort-by=item.additionalFields.postDateTime&amp;whats-new-cards.sort-order=desc&amp;ecs-blogs.sort-by=item.additionalFields.createdDate&amp;ecs-blogs.sort-order=desc" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> ECS(弹性容器服务)</em> </a>中自动集成和部署我们的代码。在我们开始之前，我建议看一下我以前的文章<a class="ae kw" href="https://carloshn90.medium.com/how-to-deploy-a-microservice-using-elastic-container-service-in-aws-b1ac20685f4" rel="noopener"> <em class="kx">如何在AWS </em> </a>中使用弹性容器服务部署微服务，因为我们将从那里将代码部署到这个集群中。</p><h1 id="ec32" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">概观</h1><p id="b9bc" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在这个例子中，我们将创建一个简单的管道来部署我们的代码。你可以在<em class="kx"> Github </em> ( <a class="ae kw" href="https://github.com/carloshn90/user-api-fargate" rel="noopener ugc nofollow" target="_blank">用户api代码</a>)中看到这个例子的代码。这是一个非常简单的微服务，有两个端点:</p><ul class=""><li id="3ba6" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">Get /users:返回用户名列表</li><li id="ac88" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">Post /users:创建一个接收json的用户，其主体中包含名称</li></ul><p id="5fac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">管道:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/2a4677c9d0fb83a43156666ef3f802d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*In9q4fvhf-m0lClQ2okZig.png"/></div></div></figure><ul class=""><li id="609b" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir">构建/测试</strong>:第一步是使用<em class="kx"> maven </em>构建并测试我们的代码。</li><li id="2168" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">构建映像</strong>:第二步是创建一个<em class="kx"> Docker </em>映像。</li><li id="2fd4" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">推送到ERC </strong>:有了前面步骤中创建的<em class="kx"> Docker </em>映像，现在是时候把它推送到我们的<em class="kx"> ERC(弹性存储库容器)</em>。</li><li id="2eea" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">在ECS中部署</strong>:最后，我们必须用新的映像版本更新我们的任务定义并部署它。</li></ul><h1 id="937c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">陷害詹金斯</h1><p id="041d" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">这里的第一步是安装<em class="kx">詹金斯</em>并设置它。要安装J <em class="kx"> enkins </em>，我建议遵循<a class="ae kw" href="https://www.jenkins.io/doc/book/installing/" rel="noopener ugc nofollow" target="_blank"> <em class="kx">官方指南</em> </a>。除此之外，我们还需要以下工具:</p><ul class=""><li id="dc49" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">Java 11</li><li id="c554" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">Maven 3.6.3</li><li id="f905" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">20.10.2</li><li id="b5d6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">AWS CLI 1.18.178</li></ul><p id="fd3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以及以下插件:</p><ul class=""><li id="842f" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">Docker管道1.25</li><li id="0e9d" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">HTML Publisher 1.25</li><li id="485b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">管道2.6</li><li id="d239" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">管道AWS步骤1.43</li><li id="e084" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">管道Maven集成3.9.3</li><li id="1591" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">管道实用程序步骤2.6.1</li><li id="2d0e" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">管道:GitHub Groovy库1.0</li><li id="69d8" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">工作空间清理插件0.38</li></ul><h1 id="587d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">多分支管道</h1><p id="9748" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">现在我们已经安装了<em class="kx">詹金斯</em>并设置好了，我们可以开始了。第一步是创建一个<em class="kx">多分支管道</em>，我们可以通过点击新项目(左侧菜单)找到该选项。下面您可以看到配置:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/64fec44adfdce29333091d30bff1d093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkV0VUpDK5tUEmBVymK22w.png"/></div></div></figure><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/3dcf1c7f0c506208f0f6a80100f6b224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*by1LE70SDwTL8_-BnjxZRQ.png"/></div></div></figure><h1 id="52b7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">詹金斯文件</h1><p id="4ba0" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在我看来，设置我们管道的最佳方式是使用<em class="kx"> jenkinsfile </em>，这是一个包含<em class="kx"> Jenkins管道</em>定义的文本文件。我把我的理由概述如下:</p><p id="3767" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么要用<em class="kx"> jenkinsfile </em>？</p><ul class=""><li id="a0b5" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated">管道将在我们的存储库中进行版本控制(我们可以看到变更，并在必要时回滚它们)。幕后没有魔法。</li><li id="b6e5" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">我们将开发人员的责任从开发人员转移到开发人员身上。没有人比项目的创建者更了解如何部署项目。</li><li id="0542" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">更容易和更快地，我们可以有一个初学者模板(使用公司标准)，我们可以在我们的项目中复制，根据具体的配置进行修改，并在必要时添加额外的阶段。</li></ul><p id="b5f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<em class="kx"> jenkinsfile </em>的主要结构如下所示:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="c30e" class="nd lt iq bd lu ne nf dn ly ng nh dp mc kj ni nj mg kn nk nl mk kr nm nn mo no bi translated">选择</h2><p id="9b5c" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">该指令允许在管道内部配置<em class="kx">管道特定的</em>选项。在我们的案例中，我们使用以下选项:</p><ul class=""><li id="f5e3" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><strong class="ka ir"> buildDiscarder </strong>:在这个选项中，我们指定了我们想要保存多少工件和日志。在这种情况下，我们将持续最后10个构建。</li><li id="e784" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">disableConcurrentBuilds</strong>:禁止并发执行<em class="kx">管道</em>。</li><li id="d4da" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">超时</strong>:设置<em class="kx">流水线</em>运行的超时时间，之后Jenkins应该中止<em class="kx">流水线</em>。我们的暂停时间是1小时。这是防止我们的<em class="kx"> Jenkins </em>中出现无限阻塞的好方法。</li><li id="27ef" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><strong class="ka ir">时间戳</strong>:将发出该行的时间作为<em class="kx">管道</em>运行生成的所有控制台输出的前缀。</li></ul><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="eadc" class="nd lt iq bd lu ne nf dn ly ng nh dp mc kj ni nj mg kn nk nl mk kr nm nn mo no bi translated">工具</h2><p id="4003" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">本节定义了要自动安装的工具，并放在以下路径中:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="ee0d" class="nd lt iq bd lu ne nf dn ly ng nh dp mc kj ni nj mg kn nk nl mk kr nm nn mo no bi translated">环境</h2><p id="d326" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在这里，我们可以指定一系列键值对，这些键值对将被定义为所有步骤的环境变量:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="6432" class="nd lt iq bd lu ne nf dn ly ng nh dp mc kj ni nj mg kn nk nl mk kr nm nn mo no bi translated">阶段</h2><p id="de1d" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在这个部分，我们将定义为了部署代码，我们需要在<em class="kx">管道</em>中执行的不同步骤。</p><p id="2522" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">构建和测试</strong></p><p id="37f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个阶段，我们将构建我们的项目，并使用<em class="kx"> maven </em>进行测试。我们使用<em class="kx"> maven </em>插件来发布最后一个成功的<em class="kx">工件</em>:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d69a00e1d80ec844ddb01ecfe3190eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*r3BV05G-P2h12inxRfhGbQ.png"/></div></figure><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1369" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">构建Docker映像</strong></p><p id="ef32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个阶段，我们将使用<em class="kx">docker文件构建<em class="kx"> docker </em>映像。</em>你可以在项目的根路径中找到这个文件<em class="kx"> </em>:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b221" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dockerfile 非常简单，我们使用<em class="kx"> openjdk:13-alpine </em>来执行我们的java应用程序，我们正在第5行安装<em class="kx"> curl </em>。我们使用<em class="kx"> ECS </em>中的<em class="kx">卷曲</em>来检查集装箱是向上还是向下。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0b76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这一阶段，我们使用<em class="kx"> docker </em>插件来构建图像，并用<em class="kx"> ERC </em> url对其进行标记，该url是我们之前保存在<em class="kx"> Jenkins的</em>凭证中的。在本文的后面，我们将看看如何在<em class="kx"> Jenkins </em>中设置凭证。</p><p id="a283" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">将图像推送到ECR </strong></p><p id="e878" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在建立了<em class="kx"> docker </em>图像之后，是时候把它推送给我们的<em class="kx"> ERC </em>了。在本节中，我们将使用<em class="kx"> AWS </em>插件来使用<em class="kx"> AWS </em>凭证来推送图像。在第7行中，我们有一个不同的<em class="kx"> sh </em>命令，这样做的原因是我们隐藏了login命令，以防止在我们的日志文件中打印它。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="98f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在ECS中部署</strong></p><p id="ec44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在最后阶段，我们将使用新的映像版本更新<em class="kx"> AWS </em>中的任务定义，并部署此服务:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="3be9" class="nd lt iq bd lu ne nf dn ly ng nh dp mc kj ni nj mg kn nk nl mk kr nm nn mo no bi translated">邮政</h2><p id="0189" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">本节定义了一个或多个在<em class="kx">管道</em>运行完成后运行的附加步骤。</p><p id="fc14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦<em class="kx">管道</em>完成，我们希望使用<a class="ae kw" href="https://github.com/jacoco/jacoco" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> jacoco </em> </a>显示代码的覆盖信息，并清理我们的目录，从我们的本地资源库<em class="kx"> </em>中删除<em class="kx"> docker </em>映像。</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="be2b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">詹金斯证书</h1><p id="8df9" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">这些凭证允许我们以安全的方式将用户名、密码等敏感数据保存在<em class="kx"> Jenkins </em>中。在本文中，我们使用凭证来保存我们的<em class="kx"> AWS </em>用户。<strong class="ka ir">重要！您需要为<em class="kx"> Jenkins </em>创建一个<em class="kx"> AWS </em>用户，并拥有必要的最小权限</strong>。在我们的例子中<em class="kx"> Jenkins的</em>用户只拥有将映像推送到<em class="kx"> ERC </em>并执行部署的权限。</p><p id="3619" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建凭证，我们首先必须转到我们的<em class="kx">管道</em>，在左侧菜单中，我们将看到选项凭证。从该菜单中，我们可以选择我们的<em class="kx">管道</em>范围，最后我们将有添加凭证的选项。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d0baf6e37fb23916db41ce2d2ea7450a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*p5p2Ey0qBjrdqgRfL8668w.png"/></div></figure><p id="2610" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加凭证后，可以从<em class="kx">管道</em>中使用<em class="kx"> ID </em>来识别凭证。</p><h1 id="ead7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="d08b" class="pw-post-body-paragraph jy jz iq ka b kb mq kd ke kf mr kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">完成本指南后，我们可以执行我们的<em class="kx">管道</em>并部署我们的代码(<a class="ae kw" href="https://github.com/carloshn90/user-api-fargate" rel="noopener ugc nofollow" target="_blank">用户api Github代码</a>):</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/bbd635ca656afd3e20c408c2af44922d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7m9gHW9Qx0RXSGFU6Rco3w.png"/></div></div></figure><p id="dd27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以使用这个基本的<em class="kx">管道</em>并根据我们的项目需要添加尽可能多的步骤来获得完美的管道。例如，我们可以在ECS中的部署阶段之后再添加一个阶段，该阶段会监视并等待，直到新版本的应用程序成功启动，或者显示错误。</p></div></div>    
</body>
</html>