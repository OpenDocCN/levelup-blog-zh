<html>
<head>
<title>Unit Testing ReactJs App with Mocha, Chai, Enzyme, and Nock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试使用Mocha、Chai、Enzyme和Nock对App进行测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-reactjs-app-with-mocha-chai-enzyme-and-nock-e25fb0ef4a15?source=collection_archive---------1-----------------------#2019-04-02">https://levelup.gitconnected.com/unit-testing-reactjs-app-with-mocha-chai-enzyme-and-nock-e25fb0ef4a15?source=collection_archive---------1-----------------------#2019-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88b899ac7346d034e2e2e4fdef9bcd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90uXpjmBWmLzVNVAjylZDw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">摩卡，茶，酵素，诺克</figcaption></figure><p id="127d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi la translated">几周前，当我在开发一个React应用程序时，我经历了为这个应用程序编写单元测试的练习。在这篇文章中，我将概述我是如何做的。我还写了启动React应用程序的过程，如果你想在这里阅读的话<a class="ae lj" href="https://medium.com/about-coding/getting-started-with-reactjs-and-asp-net-mvc-application-without-using-the-helper-template-a09aca27071a" rel="noopener"/>。因为我没有使用样板模板或<a class="ae lj" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>来启动应用程序，所以我必须手动连接测试环境。</p><h1 id="71f9" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">摩卡</h1><p id="86fb" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">Mocha是一个非常常见的用于测试运行的JavaScript框架。它拥有一个巨大的社区和一个庞大的支持生态系统。摩卡简单、灵活、有趣(从他们的标志中得来的)。你可以在这里和<a class="ae lj" href="https://github.com/mochajs/mocha" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到更多关于Mocha <a class="ae lj" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">的信息。要将Mocha作为开发依赖项安装在您的应用程序中，请执行<code class="fe mn mo mp mq b">npm install --save-dev mocha</code></a></p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/a7ae89784142919334c25d156c621f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLugtiZwNP6EQt_9YJNcSA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">将Mocha安装为开发人员依赖项的命令</figcaption></figure><h1 id="eca1" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">柴</h1><p id="59ff" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">柴是一个断言库。Mocha没有内置断言库，所以我选择Chai作为断言库。断言是一种声明测试中会发生什么的方式。Chai文档指出:</p><blockquote class="mw mx my"><p id="0fe0" class="kc kd mz ke b kf kg kh ki kj kk kl km na ko kp kq nb ks kt ku nc kw kx ky kz ij bi translated">Chai是一个用于<a class="ae lj" href="http://nodejs.org/" rel="noopener ugc nofollow" target="_blank">节点</a>和浏览器的BDD / TDD断言库，可以愉快地与任何JavaScript测试框架配对。</p></blockquote><p id="038c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过运行<code class="fe mn mo mp mq b">npm install --save-dev chai</code>将Chai安装为开发者依赖项</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/02fad9ce8edf9d27ef7b5e84b8abbbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZG4FFIS_So1dOChXIibgw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">将Chai作为开发人员依赖项安装的命令</figcaption></figure><h1 id="372a" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">酶</h1><p id="aa96" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">Enzyme是一个辅助库，用于帮助测试React组件的输出。它是由Airbnb的工程师开发的。Enzyme有助于测试组件，而无需在真实的浏览器中呈现它们。</p><blockquote class="mw mx my"><p id="231c" class="kc kd mz ke b kf kg kh ki kj kk kl km na ko kp kq nb ks kt ku nc kw kx ky kz ij bi translated">Enzyme是React的一个JavaScript测试工具，它使测试React组件的输出变得更加容易。您还可以操纵、遍历和以某种方式模拟给定输出的运行时。</p><p id="ca60" class="kc kd mz ke b kf kg kh ki kj kk kl km na ko kp kq nb ks kt ku nc kw kx ky kz ij bi translated">Enzyme的API旨在通过模仿jQuery的DOM操作和遍历API来实现直观和灵活。</p></blockquote><p id="9306" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里找到酶<a class="ae lj" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank">的文档</a>。<em class="mz">安装enzyme以及与您正在使用的react(或其他UI组件库)版本相对应的适配器</em>。要安装，请执行<code class="fe mn mo mp mq b">npm install --save-dev enzyme enzyme-adapter-react-16</code></p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/ff726ccb6f947e0904b0f216de15c9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2oOFcbITUhM3nIaSTMB0Kw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">将Enzyme作为开发人员依赖项安装的命令</figcaption></figure><h1 id="9ade" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">测试简单的组件</h1><p id="c424" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">下面是要测试的基本组件。该组件呈现一个带有作为属性提供的数字的div。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a006b37e348e012503e3bc1781bc066e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*BgnOccZ6xrKsOHxU478CwA.png"/></div></figure><p id="0e0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在测试组件(代码如下):</p><ol class=""><li id="6c9e" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated">将要测试的组件导入到测试模块的范围中。</li><li id="efb7" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">从<strong class="ke ir">酶</strong>导入<code class="fe mn mo mp mq b">configure</code> <strong class="ke ir"> <em class="mz"> </em> </strong>。这使得酶能够与衔接子一起配置。</li><li id="951e" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">从<strong class="ke ir">‘酶-接头-反应-16’</strong>导入<code class="fe mn mo mp mq b">Adapter</code> <strong class="ke ir"> </strong>。请注意，我的反应版本是16，因此从16进口。<em class="mz">要配置适配器，您应该在使用任何Enzyme的顶级API之前调用` Enzyme . configure({ adapter:new Adapter()})`，其中` Adapter `是对应于当前正在测试的库的适配器。例如从“酶-衔接子-反应-16”导入衔接子。</em></li><li id="09c4" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">从<strong class="ke ir">柴</strong>导入<code class="fe mn mo mp mq b">expect</code> <strong class="ke ir"> </strong>。期望或断言由函数<strong class="ke ir"> </strong> <code class="fe mn mo mp mq b">expect</code>生成，该函数采用生成值和期望值。</li><li id="6294" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">进口反应，所以我们可以使用JSX。</li><li id="3687" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated">从<strong class="ke ir">酶</strong>导入<code class="fe mn mo mp mq b">shallow</code> <strong class="ke ir"> </strong>。这是为了允许测试组件的浅层渲染。Enzyme的浅层渲染很重要，因为它允许您通过仅渲染最高/上层父组件来测试与其他组件隔离的组件。</li></ol><p id="4b76" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">参见下面的测试套件。</p><pre class="ms mt mu mv gt nt mq nu nv aw nw bi"><span id="272a" class="nx ll iq mq b gy ny nz l oa ob"><strong class="mq ir">import { configure, shallow }  from 'enzyme';<br/>import { expect } from 'chai';<br/>import Adapter from 'enzyme-adapter-react-16';<br/>import { RefundedEmd } from './RefundedEmd';<br/>import React from 'react';</strong></span><span id="5051" class="nx ll iq mq b gy oc nz l oa ob"><em class="mz">/* <br/>Enzyme expects an adapter to be configured<br/>To configure an adapter, you should call `Enzyme.configure({  adapter: new Adapter() })`before using any of Enzyme's top level APIs, where `Adapter` is the adapter corresponding to the library currently being tested. For example:</em></span><span id="4654" class="nx ll iq mq b gy oc nz l oa ob"><em class="mz">import Adapter from 'enzyme-adapter-react-16';<br/>To find out more about this, see </em><a class="ae lj" href="http://airbnb.io/enzyme/docs/installation/index.html" rel="noopener ugc nofollow" target="_blank"><em class="mz">http://airbnb.io/enzyme/docs/installation/index.html</em></a><em class="mz"><br/>*/</em></span><span id="07fc" class="nx ll iq mq b gy oc nz l oa ob"><em class="mz">// This connect enzyme to the react adapter<br/></em><strong class="mq ir">configure({ adapter: new Adapter() });</strong></span><span id="7bbb" class="nx ll iq mq b gy oc nz l oa ob"><strong class="mq ir">describe('</strong>Refunded Emd tests<strong class="mq ir">',()=&gt;{<br/></strong><em class="mz"> <br/>// Should render \'Span with Emd in it\'</em><br/> <strong class="mq ir">it('</strong>Should render \'&lt;span&gt;0864566536090&lt;/span&gt;\' when supplied emd  \'0864566536090\'<strong class="mq ir">', function() {</strong></span><span id="67d1" class="nx ll iq mq b gy oc nz l oa ob"><strong class="mq ir">const emd =</strong> '0864566536090';</span><span id="ab1c" class="nx ll iq mq b gy oc nz l oa ob"><em class="mz">// Using Enzyme's shallow to render the component. passing in emd<br/>  </em><strong class="mq ir">const wrapper = shallow(&lt;RefundedEmd EmdNumber={emd} /&gt;);</strong></span><span id="990b" class="nx ll iq mq b gy oc nz l oa ob"><em class="mz">// Arranging the expected value</em><br/>  <strong class="mq ir">const expectedContainedSpan =  &lt;span&gt;0864566536090&lt;/span&gt;;</strong></span><span id="9224" class="nx ll iq mq b gy oc nz l oa ob"><em class="mz">// Act<br/>  </em><strong class="mq ir">const actualValue = wrapper.contains(expectedContainedSpan);</strong></span><span id="5acc" class="nx ll iq mq b gy oc nz l oa ob"><em class="mz">// Assert<br/>  </em><strong class="mq ir">expect(actualValue).to.equal(true);<br/> });<br/>})</strong></span></pre><p id="5e62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面的测试套件从调用带有两个参数的Mocha函数<strong class="ke ir"> </strong> <code class="fe mn mo mp mq b">describe()</code> <strong class="ke ir"> </strong>开始:</p><ol class=""><li id="1ff0" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated"><code class="fe mn mo mp mq b">string</code>:被测试的测试套件的名称或标题，在这里是<code class="fe mn mo mp mq b">“Refunded Emd tests”</code>。</li><li id="ffe5" class="nf ng iq ke b kf no kj np kn nq kr nr kv ns kz nk nl nm nn bi translated"><code class="fe mn mo mp mq b">function</code> : <strong class="ke ir"> </strong>实现套件的代码块。</li></ol><p id="5cde" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过调用Mocha函数<code class="fe mn mo mp mq b">it()</code>来定义测试，该函数也接受一个字符串和一个函数作为参数:</p><ol class=""><li id="4508" class="nf ng iq ke b kf kg kj kk kn nh kr ni kv nj kz nk nl nm nn bi translated"><code class="fe mn mo mp mq b">string</code>:测试的标题，在本例中为<code class="fe mn mo mp mq b">“Should render \’&lt;span&gt;0864566536090&lt;/span&gt;\’ when supplied emd \’0864566536090\’<strong class="ke ir">’</strong></code></li></ol><p id="bf80" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">b.)<code class="fe mn mo mp mq b">function</code>:实现测试的代码块。在上面的测试中，它测试了一个组件应该在一个span中呈现所提供的数字。</p><p id="767e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了安排和方便测试组件，我们使用来自Enzyme的<code class="fe mn mo mp mq b">shallow</code>模拟呈现组件:</p><pre class="ms mt mu mv gt nt mq nu nv aw nw bi"><span id="7cd1" class="nx ll iq mq b gy ny nz l oa ob"><strong class="mq ir">const emd =</strong> '0864566536090';<strong class="mq ir"><br/>const wrapper = shallow(&lt;RefundedEmd EmdNumber={emd} /&gt;);</strong></span></pre><blockquote class="mw mx my"><p id="297b" class="kc kd mz ke b kf kg kh ki kj kk kl km na ko kp kq nb ks kt ku nc kw kx ky kz ij bi translated">浅层呈现对于约束自己将一个组件作为一个单元来测试是很有用的，并且可以确保你的测试不会间接断言子组件的行为。</p></blockquote><p id="811c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们<em class="mz">通过调用酶浅呈现组件包装器上的<code class="fe mn mo mp mq b">contains</code>来执行</em>,预期跨度为数字。</p><pre class="ms mt mu mv gt nt mq nu nv aw nw bi"><span id="7d72" class="nx ll iq mq b gy ny nz l oa ob"><em class="mz">// Arranging the expected value</em><br/>  <strong class="mq ir">const expectedContainedSpan =  &lt;span&gt;0864566536090&lt;/span&gt;;</strong></span><span id="551d" class="nx ll iq mq b gy oc nz l oa ob"><em class="mz">// Act<br/>  </em><strong class="mq ir">const actualValue = wrapper.contains(expectedContainedSpan);</strong></span></pre><h1 id="0cde" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">作凹痕于</h1><p id="0fc9" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">Nock是一个模仿HTTP请求的库。Nock的工作原理是劫持或拦截HTTP请求，然后返回测试所需的响应。换句话说，Nock允许您通过覆盖Node的<code class="fe mn mo mp mq b">HTTP.request</code>函数来指定一个假API，并允许您指定一个响应。您可以独立编写测试，而不需要外部API。Nock有很好的文档记录，我建议如果你想使用它，在这里浏览文档和例子<a class="ae lj" href="https://github.com/nock/nock" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7544" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">安装凹口:</p><pre class="ms mt mu mv gt nt mq nu nv aw nw bi"><span id="fc03" class="nx ll iq mq b gy ny nz l oa ob">npm install --save-dev nock</span></pre><p id="b160" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一个基本的JavaScript类，它封装了用于更新卡号的函数。更新函数向HTTP API“退款”发出一个获取post请求。为了测试这个函数，我必须模拟对HTTP API退款的调用，以便在测试中不依赖于API。在JavaScript中有很多方法可以实现这一点，但是Nock是最简单的。看看这个类，尤其是更新函数:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="de1b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">两个非常基本的测试来说明如何使用nock进行测试。从做所有必要的导入开始。下面看看。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="0612" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从<code class="fe mn mo mp mq b">beforeEach</code>函数开始，这个函数有在每次测试前运行的设置代码。首先实例化<code class="fe mn mo mp mq b">RefundCardSvc</code> <em class="mz"> </em>类<em class="mz"> </em>并设置公共变量。</p><p id="8256" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第19行准备了Nock在截获对API的调用后返回的预期响应。参见下面的片段。</p><pre class="ms mt mu mv gt nt mq nu nv aw nw bi"><span id="5fe2" class="nx ll iq mq b gy ny nz l oa ob">//setting up the expected response<br/>response ={<br/>  result:{<br/>    cards:[{<br/>      cardNumber: cardNumber<br/>    }]<br/>  }<br/>};</span></pre><p id="27ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Nock将拦截对<code class="fe mn mo mp mq b">.../api/Refund</code>的HTTP POST请求，并回复一个状态200，主体将包含上面在JSON中指定的响应。</p><p id="dda6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Nock将请求体与提供的JSON对象完全匹配，在本例中:<code class="fe mn mo mp mq b">{ CardNumber: cardNumber }</code>。当<code class="fe mn mo mp mq b">svc.Update()</code> <em class="mz"> </em>被调用<em class="mz">时，下面的代码将截取svc中对“http://localhost:4247/API/Refund/”<em class="mz"/>的调用。</em></p><pre class="ms mt mu mv gt nt mq nu nv aw nw bi"><span id="4b6e" class="nx ll iq mq b gy ny nz l oa ob">//Mock the call by hijacking the call nock("http://localhost:4247/api/Refund/")<br/>.post("/", { CardNumber: cardNumber })<br/>.reply(200, response);</span></pre><p id="5e93" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，通过调用更新函数，我们将对响应结果进行断言。</p><pre class="ms mt mu mv gt nt mq nu nv aw nw bi"><span id="c446" class="nx ll iq mq b gy ny nz l oa ob">// Act<br/>svc.Update(cardNumber)<br/>.then(resp =&gt; {<br/> // Assert<br/>  expect(resp.result.cards[0].cardNumber).to.equal("0864566536090");<br/>})<br/>.then(done, done);</span></pre><p id="bff1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Nock已经协助测试了隔离功能。不需要运行实际的API来测试您的代码。上面的代码可以在GitHub <a class="ae lj" href="https://github.com/gifthove/cardnumbertestdemo" rel="noopener ugc nofollow" target="_blank">这里</a>找到。如果您有任何疑问和意见，请在下面评论。如果你喜欢这篇文章，请不要忘记鼓掌。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><div class="ms mt mu mv gt om"><a href="https://gitconnected.com/learn/node-js" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">学习Node.js -最佳Node.js教程(2019) | gitconnected</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">前33个Node.js教程-免费学习Node.js。课程由开发人员提交和投票，使您能够…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">gitconnected.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa jw om"/></div></div></a></div></div></div>    
</body>
</html>