# C++中的依赖倒置原则

> 原文：<https://levelup.gitconnected.com/dependency-inversion-principle-in-c-14ec84408201>

## 编写可维护、可重用和可扩展的代码

![](img/3b47f0dd3c4299a2684afbc80462e5ab.png)

本·格里菲斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

在用 C++这样的高级语言设计代码结构时，考虑代码的可维护性和可重用性等因素非常重要。如今，软件开发人员不断受到新需求、平台和不断变化的库版本的冲击。一个设计良好的软件应该能够处理这个问题。设计(和维护)糟糕的软件倾向于代码杂乱无章，到处都是依赖关系。

开发人员通常依靠设计模式和设计原则来帮助他们设计软件。设计模式是常见情况下屡试不爽的方法。另一方面，设计原则是良好系统设计的指南。虽然设计模式通常适用于特定的语言或至少是一种范式(例如面向对象编程)，但原则往往更通用。

依赖倒置原则(DIP)是可靠的设计原则之一。它指出:

> 高层模块不应该依赖低层模块。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。

**高级模块**一般是指你代码中的**更抽象复杂的操作**。这些操作需要一个或多个**低级模块**来执行其功能。因此，实现这种复杂功能的直接方法是使高级模块依赖于低级模块。

# 简单的实现

让我们来看一个简单的例子，在一个假想的 RPG 中使用两个类， *Player* 和 *Door* 。期望的功能是一旦玩家与门交互就打开或关闭门(取决于门的状态)。播放器类可能如下所示:

玩家阶层

如您所见，它有一个相关的方法，*与*交互。该方法调用*门*类的 *toggleOpen* 方法。现在让我们来看看*门*班:

如你所见，游戏中的门在关闭和打开状态之间切换。

# 实施中的问题

乍一看，一切正常。玩家可以在游戏中与门互动。然而，可扩展性应该一直在我们的脑海中。在我们的实现中，由于 *Player* 类对 *Door* 类的依赖，我们降低了代码的可扩展性和可重用性。如果玩家想和游戏中的其他物体互动呢？我们需要为每个新对象编写一个单独的方法。

# 遵守依赖倒置原则的实现

这个问题的关键是引入一个*门*类可以实现的 *InteractiveObject* 接口。一个接口引入了一个抽象概念，帮助我们分离玩家和门。这样，我们将坚持高级模块和低级模块都应该只依赖于抽象的原则:

该接口声明了允许与对象交互的方法 *interact* 。我们还稍微重构了 *Door* 类来实现这个接口:

*Player* 类现在只需要知道 *InteractiveObject* 接口，而不关心对象的实现。这遵循了高级模块也应该只依赖于抽象的原则:

你可以通过像驾驶汽车一样的抽象来想象模块的通信:你只需要知道如何打开引擎，如何转向以及如何让汽车跑得更快或更慢。你不需要知道发动机和变速器的复杂。

# 替代实现

为了展示依赖性反转原则并不局限于编写接口，让我们用模板来解决同样的问题:

你可以看到，在这种情况下，我们不需要显式声明 *InteractiveObject* 接口，而是依赖于 *Door* 类实现的**特定契约**(在这种情况下，它需要实现 *interact* 方法。如果这个契约没有实现，编译器将抛出一个错误。因为模板方法不使用动态多态，所以运行起来可能会稍微快一点。除此之外，这两种实现几乎完全相同。

# 结论

正如你所看到的，依赖倒置原则通过使高级模块依赖抽象而不是详细的低级实现来增加我们代码的可维护性、可重用性和可扩展性。