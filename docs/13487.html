<html>
<head>
<title>Each of the SOLID Principles Explained in Less Than 20 Seconds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不到20秒的时间里解释了每一个坚实的原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/each-of-the-solid-principles-explained-in-less-than-20-seconds-b73057625dfc?source=collection_archive---------8-----------------------#2022-09-08">https://levelup.gitconnected.com/each-of-the-solid-principles-explained-in-less-than-20-seconds-b73057625dfc?source=collection_archive---------8-----------------------#2022-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1c26" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">S.O.L.I.D .是一套五个O.O.P .设计原则的首字母缩写，这些原则将帮助你避免编写脆弱、僵化或不可重用的软件。</p><p id="6dff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将简要描述它们，并了解它们如何帮助我们控制应用程序的依赖结构。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="14a2" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">1.单一责任原则</h2><p id="15fb" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">单一责任原则声明类或组件应该有单一的变更源。</p><p id="13e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果关于<em class="lt">支付</em>的业务用例发生了变化，那么只有来自专用组件的功能会受到影响。如果任何其他组件或模块需要更改，它们不符合单一责任原则。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/cb05905374a450a5e12234b8e496d897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*iVjcfHgS__dsKGk6mjgAWg.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">小刀不符合单一责任原则</figcaption></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="4440" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">2.开/关原则</h2><p id="8be4" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">根据开放/封闭原则，类或组件应该为扩展而开放，为更改而关闭。</p><p id="2389" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们遵循这个原则，我们应该能够仅仅通过扩展组件来添加一个新的特性——而不涉及任何现有的代码。</p><p id="0fcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你有没有注意到高级开发人员在添加新功能之前是如何重构现有代码的？最初，他们确保代码符合开放/封闭原则。之后，他们添加新的特性，而不需要进一步修改旧的代码。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/0975b6a79f17fc72ad342ed5edbeedc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*EvDPJ2FvhGtp_NCsgTvRHA.png"/></div></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="893c" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">3.利斯科夫替代原理</h2><p id="638f" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">Liskov替换原则指出，派生类应该能够在客户端不知道的情况下替换其父类。</p><p id="6c18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们的函数返回一个<em class="lt">列表</em>，我们可以自由地在内部将其从<em class="lt"> LinkedList </em>更改为<em class="lt"> HashList </em>，而不会破坏使用它的代码。</p><p id="c8ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，如果我们扩展了一个基类，而我们的实现将返回一个不同的结果或导致意想不到的副作用，这将违反Liskov的替换原则。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/21bfec725b1cfc2aa42652e2f20c9a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*zBKzBIJZTIrwAZ1NuBiAaA.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">明显违反了利斯科夫的替代原则</figcaption></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="ce6e" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">4.界面分离原理</h2><p id="947d" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">为了符合接口分离原则，客户端不应该依赖于它不会使用的函数。</p><p id="0ae7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有一个与方法<em class="lt"> a(…) </em>、<em class="lt"> b(…) </em>和<em class="lt"> c(…)的接口。</em>如果有客户端只使用<em class="lt"> a(…) </em>和<em class="lt">b(…)</em>的方法，我们就违反了接口分离原则。一个解决方案是将现有的接口分成更小的接口。</p><p id="4822" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，假设我们实现了这个接口，并且确实为<em class="lt"> a(…) </em>和<em class="lt"> b(…) </em>提供了实现，但是没有为<em class="lt"> c(…) </em>提供实现，这再次意味着将会有不使用<em class="lt"> c(...因此我们违反了原则。</em></p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="02ca" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">5.从属倒置原则</h2><p id="e005" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">根据依赖倒置原则，高层模块不应该依赖低层模块。细节应该依赖于抽象。</p><p id="a7ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们可以想象有一个<em class="lt">支付</em>模块和各种用于具体支付实现的类。各种实现应该依赖于支付模块，以符合依赖性反转原则。</p><p id="faac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，一个具体的支付实现(“<em class="lt">细节</em>”)的变化不会影响高层的<em class="lt">支付</em>模块(或任何其他组件)。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/cca2a699cbe105799342e40999b28872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*DYeh7OKkCR-XTyEJmssFmg.png"/></div></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h2 id="84e4" class="kv kw it bd kx ky kz dn la lb lc dp ld kb le lf lg kf lh li lj kj lk ll lm ln bi translated">结论</h2><p id="e823" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在本文中，我们简要描述了五个坚实原则中的每一个。</p><p id="42eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">坚实的原则教会我们如何构建不僵化、不脆弱或不可重用的类。</p><p id="3dca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果我们放眼全局，这些概念将在设计我们系统的组件或模块时使用。如果你想更深入地了解这个主题，请阅读关于</strong> <a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/3-component-cohesion-principles-explained-for-a-junior-developer-53576d1032b3"> <strong class="js iu">组件内聚原则</strong> </a> <strong class="js iu">的文章——它们是SOLID的<em class="lt">老大哥</em>。</strong></p><p id="2e30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，如果你想了解更多关于SOLId的知识，我强烈推荐你看鲍勃叔叔的这个演讲。</p><p id="9f5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在相当长的介绍之后，他解释了什么是O.O.P .语言，以及封装、继承和多态是如何工作的。</p><p id="3f39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，他展示了如何使用可靠的原则来控制系统的依赖结构，以及为什么这很重要。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="mj mk l"/></div></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="3499" class="ml kw it bd kx mm mn mo la mp mq mr ld ms mt mu lg mv mw mx lj my mz na lm nb bi translated">分级编码</h1><p id="58c1" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="e4e6" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="d829" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">📰查看<a class="ae mi" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="6f22" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">🔔关注我们:<a class="ae mi" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae mi" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mi" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="d897" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae mi" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>