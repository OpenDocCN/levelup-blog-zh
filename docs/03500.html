<html>
<head>
<title>Learning C++: Function Templates and the STL Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:函数模板和STL第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-function-templates-and-the-stl-part-1-a95dd8de200a?source=collection_archive---------14-----------------------#2020-05-12">https://levelup.gitconnected.com/learning-c-function-templates-and-the-stl-part-1-a95dd8de200a?source=collection_archive---------14-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5d7bce4a144486ade387409b02bea9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z_VwbxenrzwlxmTf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7dad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">C++的标准模板库不是一个面向对象的库，而是一个通用库。函数从各种容器类型调用迭代器范围，而不是从对象实例调用成员函数。这些容器可以保存各种类型的数据。为了能够做到这一点，C++广泛使用了模板。在接下来的系列文章中，我将研究如何在C++中使用模板，包括函数模板和类模板，从本文中的函数模板开始。</p><p id="c330" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我对本文的大部分研究来自David Vandevoore、Nicolai M. Josuttis和Douglas Gregor所著的《C++模板:完全指南(第二版)》( T10)一书的第一章。</p><h1 id="e970" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么需要函数模板</h1><p id="caef" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这里有一个简单的问题来说明为什么需要函数模板。我正在编写一系列统计或数学程序，我需要频繁地平方数字。我很自然地从编写一个函数来做平方开始:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5b71" class="mr lg it mn b gy ms mt l mu mv">int square(int number) {<br/>  return number * number;<br/>}</span></pre><p id="fc31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对整数很有效，但对浮点数就不那么有效了，如下例所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="fa7e" class="mr lg it mn b gy ms mt l mu mv">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="1be2" class="mr lg it mn b gy mw mt l mu mv">int square(int number) {<br/>  return number * number;<br/>}</span><span id="5e58" class="mr lg it mn b gy mw mt l mu mv">int main()<br/>{<br/>  int num = 12;<br/>  cout &lt;&lt; square(num) &lt;&lt; endl; // displays 144<br/>  double dnum = 2.22;<br/>  cout &lt;&lt; square(dnum) &lt;&lt; endl; // displays 4<br/>  return 0;<br/>}</span></pre><p id="f6c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可以重载<code class="fe mx my mz mn b">square</code>来包含<code class="fe mx my mz mn b">double</code> s的定义:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ce6b" class="mr lg it mn b gy ms mt l mu mv">double square(double number) {<br/>  return number * number;<br/>}</span></pre><p id="b066" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是现在我用一个重复的函数定义来占用空间。</p><p id="070e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个问题的解决方案是使用函数模板编写square函数。</p><h1 id="9b7a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">引入的功能模板</h1><p id="e515" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">函数模板定义了一系列函数，这些函数可以对多种数据类型进行操作。数据类型是参数化的，以便程序员在运行时指定类型，或者如果没有提供类型参数，编译器将根据函数参数确定类型。</p><p id="6b85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过为上面定义的<code class="fe mx my mz mn b">square</code>函数创建一个函数模板来看看这是怎么回事:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4673" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T&gt;<br/>T square(T number) {<br/>  return number * number;<br/>}</span></pre><p id="946c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数模板总是以关键字template开头，后跟<em class="le">模板</em>参数。这些参数总是以关键字<code class="fe mx my mz mn b">typename</code>开头，后跟一个类型占位符。传统上，占位符通常被命名为<code class="fe mx my mz mn b">T</code>，但实际上它可以是任何东西。</p><p id="cbf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数定义中，任何需要类型名的地方都用模板参数代替。在上面的<code class="fe mx my mz mn b">square</code>函数定义中，<code class="fe mx my mz mn b">T</code>用于函数返回类型的去向以及参数列表中的类型声明。在运行时，编译器会用一个实际的数据类型替换<code class="fe mx my mz mn b">T</code>，这个数据类型可以是程序提供的，也可以是编译器推导出来的。</p><p id="c547" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先看一个类型演绎的例子，它使用了我在上面使用的相同程序来平方一个整数和一个浮点数。下面是将<code class="fe mx my mz mn b">square </code>函数定义为模板函数的完整程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="fc2a" class="mr lg it mn b gy ms mt l mu mv">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="cc2f" class="mr lg it mn b gy mw mt l mu mv">template &lt;typename T&gt;<br/>T square(T number) {<br/>  return number * number;<br/>}</span><span id="c49d" class="mr lg it mn b gy mw mt l mu mv">int main()<br/>{<br/>  int num = 12;<br/>  cout &lt;&lt; square(num) &lt;&lt; endl;<br/>  double dnum = 2.22;<br/>  cout &lt;&lt; square(dnum) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="53bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4209" class="mr lg it mn b gy ms mt l mu mv">144<br/>4.9284</span></pre><p id="fbeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在调用函数的两种情况下，编译器通过检查函数的参数来推断要使用的类型。在第一个output语句中，参数是一个整数，因此返回一个整数；在第二个output语句中，参数是一个<code class="fe mx my mz mn b">double</code>，因此函数返回一个<code class="fe mx my mz mn b">double</code>。</p><p id="c845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我想明确告诉编译器应该使用什么类型，我可以在调用函数时将其作为模板参数提供。下面是一个使用显式类型参数的示例:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e7e5" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  int num = 12;<br/>  cout &lt;&lt; square&lt;int&gt;(num) &lt;&lt; endl;<br/>  double dnum = 2.22;<br/>  cout &lt;&lt; square&lt;double&gt;(dnum) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="7bce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出与前面的示例相同。</p><p id="c66f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看另一个例子。下面的函数定义是针对<code class="fe mx my mz mn b">maximum</code>的，这个函数采用两个值作为参数，并返回两个值中最大的一个。下面是函数模板定义:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f519" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T&gt;<br/>T maximum(T val1, T val2) {<br/>  if (val1 &lt; val2) {<br/>    return val2;<br/>  }<br/>  return val1;<br/>}</span></pre><p id="92d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将这个函数用于几种不同的数据类型:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4d77" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  double dnum = 3.11;<br/>  double dnum2 = 3.1;<br/>  cout &lt;&lt; "largest of 3.11 and 3.1: " &lt;&lt; maximum(dnum, dnum2)<br/>       &lt;&lt; endl;<br/>  int num = 123;<br/>  int num2 = 212;<br/>  cout &lt;&lt; "largest of 123 and 212: " &lt;&lt; maximum(num, num2)<br/>       &lt;&lt; endl;<br/>  string word = "hello";<br/>  string word2 = "hellos";<br/>  cout &lt;&lt; "largest of hello and hellos is: "<br/>       &lt;&lt; maximum(word, word2) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="8013" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8abe" class="mr lg it mn b gy ms mt l mu mv">largest of 3.11 and 3.1: 3.11<br/>largest of 123 and 212: 212<br/>largest of hello and hellos is: hellos</span></pre><p id="8d27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果我想比较不同类型的数字。我可以通过用两个模板参数重写函数来实现。</p><h1 id="4699" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">带有两个模板参数的模板函数</h1><p id="6d2f" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在你的编程中，你可能想要比较一个<code class="fe mx my mz mn b">int</code>和一个<code class="fe mx my mz mn b">double</code>，看看哪个是最大的。您可以通过重写<code class="fe mx my mz mn b">maximum</code>函数来获得两个模板参数。下面是函数定义:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="abad" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T1, typename T2&gt;<br/>T1 maximum(T1 val1, T2 val2) {<br/>  if (val1 &lt; val2) {<br/>    return val2;<br/>  }<br/>  return val1;<br/>}</span></pre><p id="c020" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你注意到这个定义有问题吗？我必须为返回数据类型选择一个模板参数。让我们通过比较int和double来看看这是如何工作的，并在运行时为模板参数指定<code class="fe mx my mz mn b">&lt;int, double&gt;</code>:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ed9d" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  int num = 3;<br/>  double dnum = 3.01;<br/>  cout &lt;&lt; "largest of 3 and 3.01 is: "<br/>       &lt;&lt; maximum&lt;int, double&gt;(num, dnum) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="f7ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="17cc" class="mr lg it mn b gy ms mt l mu mv">largest of 3 and 3.01 is: 3</span></pre><p id="8fcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这显然是不对的。我可以改变参数和模板参数的顺序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c596" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  int num = 3;<br/>  double dnum = 3.01;<br/>  cout &lt;&lt; "largest of 3 and 3.01 is: "<br/>       &lt;&lt; maximum&lt;double, int&gt;(dnum, num) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="23e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，这得到了正确的输出，但是破坏了使用函数模板的精神。</p><p id="fee8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种处理方法是向模板参数添加一个输出参数。下面是<code class="fe mx my mz mn b">maximum</code>的新定义:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a17c" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename RT, typename T1, typename T2&gt;<br/>RT maximum(T1 val1, T2 val2) {<br/>  if (val1 &lt; val2) {<br/>    return val2;<br/>  }<br/>  return val1;<br/>}</span></pre><p id="fc24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个利用这个新定义的程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="43e4" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  int num = 3;<br/>  double dnum = 3.01;<br/>  cout &lt;&lt; "largest of 3 and 3.01 is: "<br/>       &lt;&lt; maximum&lt;double, int, double&gt;(num, dnum) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="b8f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1046" class="mr lg it mn b gy ms mt l mu mv">largest of 3 and 3.01 is: 3.01</span></pre><p id="b7ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数模板的这种用法更好，但还有更好的方法，尽管它更复杂。</p><h1 id="a645" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用auto作为返回类型</h1><p id="6055" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在我讨论更复杂的定义之前，解决这个问题的一个简单方法是让编译器通过对函数返回类型使用auto来确定数据类型。使用这种技术，我似乎可以为<code class="fe mx my mz mn b">maximum</code>写一个新的定义:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6621" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T1, typename T2&gt;<br/>auto maximum(T1 val1, T2 val2) {<br/>  if (val1 &lt; val2) {<br/>    return val2;<br/>  }<br/>  return val1;<br/>}</span></pre><p id="b51a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，当我试图用我们的测试程序编译它时，我得到了下面的错误:</p><p id="0265" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">错误:“自动”的推导不一致:“double”和“int”</strong></p><p id="15be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以通过将函数体改为使用条件运算符来解决，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="fd45" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T1, typename T2&gt;<br/>auto maximum(T1 val1, T2 val2) {<br/>  return val1 &lt; val2 ? val2 : val1;<br/>}</span></pre><h1 id="2919" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用尾随返回类型</h1><p id="e40e" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">从C++11开始，这种语言允许函数声明一个<em class="le">尾随返回类型</em>。这意味着我可以通过从函数的返回值派生类型来确定函数的返回类型。关键字<code class="fe mx my mz mn b">decltype</code>执行这个任务。</p><p id="1af3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mx my mz mn b">decltype</code>，可以定义一个以auto为返回类型的函数，并使用<code class="fe mx my mz mn b">decltype</code>让编译器确定数据类型。下面是对<code class="fe mx my mz mn b">maximum</code>函数的操作方法:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="15c6" class="mr lg it mn b gy ms mt l mu mv">template &lt;typename T1, typename T2&gt;<br/>auto maximum(T1 val1, T2 val2) -&gt; <br/>  decltype(val1 &lt; val2 ? val2 : val1) {<br/>  return val1 &lt; val2 ? val2 : val1;<br/>}</span></pre><p id="fcc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将函数体改为使用条件操作符，这样我就可以使用带有<code class="fe mx my mz mn b">decltype</code>的表达式。</p><p id="bb1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试这个新版本<code class="fe mx my mz mn b">maximum</code>的程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="aaec" class="mr lg it mn b gy ms mt l mu mv">int main()<br/>{<br/>  int num = 3;<br/>  double dnum = 3.01;<br/>  cout &lt;&lt; "largest of 3 and 3.01 is: "<br/>       &lt;&lt; maximum&lt;int, double&gt;(num, dnum) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="cf18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a2fa" class="mr lg it mn b gy ms mt l mu mv">largest of 3 and 3.01 is: 3.01</span></pre><h1 id="942c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使返回类型成为通用类型</h1><p id="b804" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">C++有一个库<code class="fe mx my mz mn b">common_type</code>，它可以从可能的类型列表中选择最通用的数据类型。您可以在我们的最大值定义中使用这个库，这样当比较两个数值类型时，编译器将选择两个类型中更一般的类型。这意味着当比较一个<code class="fe mx my mz mn b">double</code>和一个<code class="fe mx my mz mn b">int </code>时，编译器将选择<code class="fe mx my mz mn b">double</code>作为更常见的类型，因为一个整数将适合一个<code class="fe mx my mz mn b">double</code>而不是相反。该库位于标题<code class="fe mx my mz mn b">&lt;type_traits&gt;</code>中。</p><p id="6f11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是为了利用<code class="fe mx my mz mn b">common_type</code>库而重写的<code class="fe mx my mz mn b">maximum</code>函数，以及头文件和测试程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1ff1" class="mr lg it mn b gy ms mt l mu mv">#include &lt;iostream&gt;<br/>#include &lt;type_traits&gt;<br/>using namespace std;</span><span id="45fb" class="mr lg it mn b gy mw mt l mu mv">template &lt;typename T1, typename T2&gt;<br/>typename common_type&lt;T1, T2&gt;::type maximum(T1 val1, T2 val2) {<br/>  return val1 &lt; val2 ? val2 : val1;<br/>}</span><span id="73fe" class="mr lg it mn b gy mw mt l mu mv">int main()<br/>{<br/>  int num = 3;<br/>  double dnum = 3.01;<br/>  cout &lt;&lt; "largest of 3 and 3.01 is: "<br/>       &lt;&lt; maximum&lt;int, double&gt;(num, dnum) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><h1 id="64ed" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">更多关于函数模板的信息</h1><p id="e121" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">当谈到函数模板时，仍然有很多东西需要讨论，包括默认的模板参数和重载函数模板。我将在下一篇文章中讨论这些话题。</p><p id="441a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。</p></div></div>    
</body>
</html>