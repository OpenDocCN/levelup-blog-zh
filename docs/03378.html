<html>
<head>
<title>Setting up Jest under Expo to work with .jsx files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在世博会下创建Jest。jsx文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/setting-up-jest-under-expo-to-work-with-jsx-files-ba35a51bc25a?source=collection_archive---------4-----------------------#2020-05-05">https://levelup.gitconnected.com/setting-up-jest-under-expo-to-work-with-jsx-files-ba35a51bc25a?source=collection_archive---------4-----------------------#2020-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9124f4b9a5490aa1549ff9bb413ab669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AA08BmGAhY7aIzIp3FBm5Q.jpeg"/></div></div></figure><p id="a4a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想了解React本地开发是创建跨平台应用程序的一种简单方法。我按照设置步骤进行了操作，我能够轻松地使用Expo来设置一个简单的应用程序，并让它在我的iPhone上运行。我想对我的项目做的一件事是用Jest添加单元测试。当您设置Expo时，它还包括Jest作为托管项目设置的一部分。这个简单的应用程序显示一切正常，但我想对我的项目结构做一些改变。</p><p id="dd1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我想把我所有的代码移动到一个src文件夹，里面有一个components文件夹。为此，我首先在项目中添加了一个src文件夹。然后，我将App.js文件移动到src文件夹中。因为Expo期望在项目的顶层文件夹中有一个App.js文件以便运行，所以我在顶层创建了一个新的App.js文件夹，它导入了实际文件的内容。所以我在顶层文件夹的App.js文件有如下内容:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6bf5" class="lf lg iq lb b gy lh li l lj lk">import App from ‘./src/components/App’;<br/>export default App;</span></pre><p id="59b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我的项目顶层就没有代码了，我可以测试我所有的代码。</p><p id="8daf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我想使用。jsx文件来跟踪哪些文件是简单的。js文件以及哪些文件是。包含React本机代码的jsx文件。因此，在src文件夹中，我将App.js文件重命名为App.jsx。我创建了一个App.test.jsx文件，内容如下:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5729" class="lf lg iq lb b gy lh li l lj lk">import React from ‘react’;<br/>import renderer from ‘react-test-renderer’;<br/>import App from ‘./App’;</span><span id="29c0" class="lf lg iq lb b gy ll li l lj lk">describe(‘&lt;App /&gt;’, () =&gt; {<br/>    it(‘has 1 children’, () =&gt; {<br/>        const tree = renderer.create(&lt;App /&gt;).toJSON();<br/>        expect(tree.children.length).toBe(1);<br/>    });<br/>});</span></pre><p id="24f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我对我的项目进行这些更改时，我无法让Jest工作。我一直收到这个错误:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6542" class="lf lg iq lb b gy lh li l lj lk">({“Object.&lt;anonymous&gt;”:function(module,exports, require,__dirname,__filename,global,jest){import React from ‘react’;</span><span id="0ed9" class="lf lg iq lb b gy ll li l lj lk">SyntaxError: Cannot use import statement outside a module</span></pre><p id="d0c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我花了很多时间研究这个错误，并尝试了很多方法来修复它。在看了很多其他项目并走进很多死胡同后，我找到了解决方案。我需要使用babel-jest来转换文件夹中的文件。</p><p id="b367" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当前的Expo项目设置将所有Jest设置放在package.json文件中。默认情况下，它只包括以下几行:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1ff7" class="lf lg iq lb b gy lh li l lj lk">"jest": {<br/>    "preset": "jest-expo",<br/>},</span></pre><p id="4db8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让我的更改生效，我需要为Jest添加另一个设置。下面是我对package.json文件中Jest设置的更改:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9d63" class="lf lg iq lb b gy lh li l lj lk">"jest": {<br/>    "preset": "jest-expo",<br/>    "transform": {<br/>        "^.+\\.[jt]sx?$": "babel-jest"<br/>    }<br/>},</span></pre><p id="583b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我做了这个更改后，我可以运行npm test并让它测试我的文件。这是个好消息。</p><p id="6bff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">奇怪的是，当你查看Jest文档时，对于transform，它显示我使用的转换应该是默认值。但出于某种原因，事实并非如此。要查看Jest的运行配置，可以使用Jest命令行选项— showConfig。在您的shell中，您可以运行以下命令:</p><p id="9fd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lm ln lo lb b">npm test — — showConfig</code></p><p id="376d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将显示Jest正在使用的所有当前配置。当我查看输出时，我发现Expo设置中有这个用于babel-jest的转换正则表达式:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9452" class="lf lg iq lb b gy lh li l lj lk">"transform": [<br/>    ["^.+\\.(js|ts|tsx)$",<br/>    "/Users/foo/git/expo-app/node_modules/babel-jest/build/index.js"],</span><span id="2d66" class="lf lg iq lb b gy ll li l lj lk">    ["^.+\\.(bmp|gif|jpg|jpeg|mp4|png|psd|svg|webp|ttf|otf|m4v|mov|mp4|mpeg|mpg|webm|aac|aiff|caf|m4a|mp3|wav|html|pdf|obj)$",<br/>    "/Users/foo/git/expo-app/node_modules/jest-expo/src/preset/assetFileTransformer.js"]<br/>],</span></pre><p id="fcf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会注意到正则表达式是bable-jest的<code class="fe lm ln lo lb b">“^.+\\.(js|ts|tsx)$”</code>。Jest只会转换以结尾的文件。js，。注意这一点。正则表达式中完全没有jsx文件。所以我的改变增加了转变。jsx文件放回到Jest的流程中。</p><p id="dcb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这有助于您按照自己的方式设置Expo项目，并向您展示一个很好的调试标志，用于发现Jest的问题。</p></div></div>    
</body>
</html>