<html>
<head>
<title>Using Transactions to Make Django Tests Run Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用事务使Django测试运行得更快</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-transactions-to-make-django-tests-run-faster-224fdd695bfd?source=collection_archive---------18-----------------------#2020-06-23">https://levelup.gitconnected.com/using-transactions-to-make-django-tests-run-faster-224fdd695bfd?source=collection_archive---------18-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8033" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">一步一步的教程</h2><div class=""/><div class=""><h2 id="633f" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">本教程展示了如何使用Django测试框架的嵌套事务机制来避免测试模型的重新初始化。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0adf9d8ff22e80eb14602b6a3e2e73b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*358n0-_8cPSkWS1m2Jc4Xg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">来源:理查德·希思科特/盖蒂图片欧洲</figcaption></figure><p id="6479" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Django为您提供的验证模型的最简单的测试设置如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="c810" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">成功了，太棒了！现在您想要向您的测试套件添加更多的断言。实际上，你可以将它们直接添加到同一个测试函数中，如果一切正常，你不会注意到与为每个断言使用一个单独的函数相比有什么不同，但是一旦你的一个断言失败了，如果所有的断言都在一个函数中，你会得到一个不太有用的图片，告诉你哪里出错了。</p><p id="3514" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此外，单独的函数有一个“保存游戏”的特性:不管前面的测试方法发生了什么，下一个测试方法都将从头开始(准确地说，从初始的<code class="fe mf mg mh mi b">migrate</code>应用到新创建的测试数据库之后的状态开始)。</p><p id="4d17" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">所以:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mj"><img src="../Images/ecfa30e0449b6e655d60f66f145ea30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFJ__RfHfy6wjSyb8zcXxA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">星号显示用户John的创建位置</figcaption></figure><p id="88f8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于每个测试都在一个单独的事务中运行(图中的橙色框),所以不需要手动删除测试记录，db层会为您做这件事。</p><p id="ab0a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请注意，John用户被创建了两次。不要重复自己！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mj"><img src="../Images/3c5e25f122fd8acb8b2f90871dea2c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U17tiLBp46Xh0G3ydsQotw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">setUp()方法执行两次</figcaption></figure><p id="080f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这无疑是向前迈进了一步:将模型创建重构到一个单独的函数中使得代码不容易出错并且更易于维护，但是实际上用户仍然会被创建两次！如果不止一个用户，那可能会导致速度大幅下降。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="265f" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">方法1:测试用例级初始化</h1><p id="fd06" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">为了避免这种情况，您可以使用django测试框架的“嵌套”事务特性，这涉及到将初始化转移到<code class="fe mf mg mh mi b"><a class="ae no" href="https://docs.djangoproject.com/en/3.0/topics/testing/tools/#django.test.TestCase.setUpTestData" rel="noopener ugc nofollow" target="_blank">setUpTestData</a>()</code>类方法:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="5529" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">执行此代码将完成以下工作:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0a2b611bd053c592aa84770df3af4d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*1fg2Sfj9T_3FZkddBbgABA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">嵌套的BEGIN/ROLLBACKs更容易理解，但是SQL不支持它们。实际上，保存点在L2使用。</figcaption></figure><ol class=""><li id="f068" class="nq nr it lj b lk ll ln lo lq ns lu nt ly nu mc nv nw nx ny bi translated">首先创建用户John</li><li id="3209" class="nq nr it lj b lk nz ln oa lq ob lu oc ly od mc nv nw nx ny bi translated">“还原点”已创建</li><li id="1724" class="nq nr it lj b lk nz ln oa lq ob lu oc ly od mc nv nw nx ny bi translated"><code class="fe mf mg mh mi b">test_john()</code>正在运行，这将在数据库中“看到”约翰</li><li id="b42c" class="nq nr it lj b lk nz ln oa lq ob lu oc ly od mc nv nw nx ny bi translated">将<code class="fe mf mg mh mi b">test_john()</code>中所做的一切回滚到步骤2中的恢复点</li><li id="d5d9" class="nq nr it lj b lk nz ln oa lq ob lu oc ly od mc nv nw nx ny bi translated"><code class="fe mf mg mh mi b">test_sam()</code>是凶多吉少。如果在<code class="fe mf mg mh mi b">test_john()</code>中完成，它不会看到任何db修改，但是John用户仍然可见。</li><li id="5963" class="nq nr it lj b lk nz ln oa lq ob lu oc ly od mc nv nw nx ny bi translated">在这个测试用例中创建的所有东西都被回滚，包括John。</li></ol><p id="93fd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">事实上，还有另一个类方法<code class="fe mf mg mh mi b">tearDownClass()</code>，您可以在其中删除在<code class="fe mf mg mh mi b">setUpTestData()</code>中创建的模型，但这并不是真正必要的，因为当回滚与上面步骤6中的测试用例相关的事务时，它们会被自动删除。</p><p id="26c0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在假设您需要另一个测试用例，例如，在另一个应用程序中，它也需要那个无处不在的John用户。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/b1d419045ac700d219c5a3012d1e033b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*GkrG1jFdcZlIpWogElEkBw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">同样，在现实中，嵌套事务是通过保存点实现的，而不是通过嵌套BEGIN/ROLLBACK实现的</figcaption></figure><p id="4595" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当执行进入测试用例B时，数据库层删除在<code class="fe mf mg mh mi b">A.setUpTestData()</code>中创建的所有内容，这样就不需要手动清理这些对象。</p><p id="ebc5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是如果我们对所有的测试都有相同的设置，我们又一次处于初始化被执行两次的情况中——这也是可以避免的！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8da3" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">方法2:项目级初始化</h1><p id="2027" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">姜戈有很多不同的跑步者。我们现在需要继承的是<code class="fe mf mg mh mi b"><a class="ae no" href="https://docs.djangoproject.com/en/3.0/topics/testing/advanced/#defining-a-test-runner" rel="noopener ugc nofollow" target="_blank">DiscoverRunner</a></code></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi of"><img src="../Images/f6427b018b6101d96def392690407424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*K0g-eiMPKsikiEwoGgSPmw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">通过保存点实现开始L2和回滚L2</figcaption></figure><p id="8997" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">就像一个测试用例一样，这个DiscoverRunner类有一个名为<code class="fe mf mg mh mi b">teardown_databases()</code>的拆卸方法，如果您使用<code class="fe mf mg mh mi b">--keepdb</code>命令行选项运行测试，以避免每次运行测试时都创建测试数据库，这可能会很方便，因为在这种情况下，没有封闭的事务来自动回滚在<code class="fe mf mg mh mi b">setup_databases()</code>方法中创建的模型。如果没有它，您将得到以下异常:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c3692be0dd70dce7bddeaa27a172b011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*FCoI4NBjRdsK_UUhGqcs7w.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">旋转星形表示模型清理；L2开始/回滚通过保存点实现</figcaption></figure><p id="2e49" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">调用flush management命令(与运行<code class="fe mf mg mh mi b">./manage.py flush --no-input</code>相同)比只使用<code class="fe mf mg mh mi b">delete()</code>函数要好，因为它一次处理所有的模型(只保存迁移表),而且它重置了序列，这样新创建的用户的id就不会无限增加。</p><p id="2387" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同样值得注意的是，如果您计划向用户模型添加定制字段，最好在<code class="fe mf mg mh mi b">tests.py</code>和<code class="fe mf mg mh mi b">testrunner.py</code>中用<code class="fe mf mg mh mi b">get_user_model()</code>导入它:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e39d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">见我的<a class="ae no" href="https://medium.com/swlh/production-ready-method-of-extending-django-user-model-in-mid-project-3afa174b000b" rel="noopener">演练</a>在项目中间扩展用户模型。</p><p id="0f27" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里有一个小问题:在python层面上，测试隔离并不是100%可靠的:一个2分钟的阅读<a class="ae no" rel="noopener ugc nofollow" target="_blank" href="/next-django-version-will-have-better-testcases-isolation-71959eb7b62c">注意</a>中的细节和解决方法。</p><p id="a524" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">继承自<code class="fe mf mg mh mi b">DiscoverRunner</code>的方法也适用于并行测试执行(<code class="fe mf mg mh mi b">manage.py test --parallel</code>)。在这个设置中，来自<code class="fe mf mg mh mi b">MyTestRunner.setup_databases()</code>的初始化代码在每个进程中只出现一次。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/93a3aecfd0a44a55751bcf694039046c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVSS2uEOFcAKOhup8qkz3Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">蓝色星号表示创建用户John实例，旋转星号表示删除它。</figcaption></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5899" class="mr ms it bd mt mu mv mw mx my mz na nb ki nc kj nd kl ne km nf ko ng kp nh ni bi translated">结论</h1><p id="3e9d" class="pw-post-body-paragraph lh li it lj b lk nj kd lm ln nk kg lp lq nl ls lt lu nm lw lx ly nn ma mb mc im bi translated">这两种技术——覆盖<code class="fe mf mg mh mi b">TestCase.setUpTestData()</code>方法和扩展<code class="fe mf mg mh mi b">DiscoverRunner</code>类——有助于构建不重复执行测试设置的测试，从而在运行测试套件时节省时间。它们可以与<code class="fe mf mg mh mi b">--keepdb and --parallel</code>标志到<code class="fe mf mg mh mi b">./manage.py test</code>命令结合使用，以进一步减少测试时间。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="2e34" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">脚注:</p><ol class=""><li id="e912" class="nq nr it lj b lk ll ln lo lq ns lu nt ly nu mc nv nw nx ny bi translated">用sqlite后端<code class="fe mf mg mh mi b">./manage.py flush</code>只重置django主分支中的序列(数据在任何版本都被刷新)，见ticket<a class="ae no" href="https://code.djangoproject.com/ticket/31479" rel="noopener ugc nofollow" target="_blank">31479</a>；其他后端可以与任何最新的django版本兼容。</li></ol><p id="eb94" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">2.<code class="fe mf mg mh mi b">./manage.py tests --parallel</code>还不能在Windows上运行，只能在Linux上运行。</p></div></div>    
</body>
</html>