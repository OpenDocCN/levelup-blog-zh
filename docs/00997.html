<html>
<head>
<title>Rethinking the Front-end</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新思考前端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rethinking-the-front-end-c0d86ccbbfe7?source=collection_archive---------0-----------------------#2019-10-10">https://levelup.gitconnected.com/rethinking-the-front-end-c0d86ccbbfe7?source=collection_archive---------0-----------------------#2019-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01df" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">组件构成(第一部分)</h2></div><h1 id="636b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">超越工具。</h1><p id="c5a1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为web开发社区的成员，我们经常用我们使用的工具来定义自己。我是React开发者，或者说我是Vue开发者。尽管这些工具很棒，但只在那个生态系统中思考是有局限性的。只有在一个框架内思考，你的思维过程才会以一种特殊的方式解决问题，这种方式是倒退的。我们没有考虑工具如何解决我们的问题，而是试图让我们的问题适合我们的工具。</p><p id="a6f1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这意味着我们正在失去一个巨大的机会。不断变化的开发环境和新的工具和框架并没有让你变得过时。对于木匠来说，电锯并没有让手锯变得无用。这也不会使他对不同木材和建筑技术的知识失效。</p><blockquote class="mb mc md"><p id="28b8" class="la lb me lc b ld lw ju lf lg lx jx li mf ly ll lm mg lz lp lq mh ma lt lu lv im bi translated">前端是由它的问题定义的。</p></blockquote><p id="45a0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">了解我们的问题，利用我们的新旧工具，探索解决问题的不同方法。然后，当你得到一个新的应用程序时，你可以深入自己的工具箱，写出优秀的代码。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="926c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="me">本系列的第一篇文章旨在提供关于前端开发的问题和目标的观点。在第1部分中，我们将讨论如何考虑组件组合。在第2部分中，我们将提供带有代码的具体示例。</em></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/39b3a585ba6673b3c91142b7b6172be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SyQ3hEg4pC4uyp0MpBRhpw.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">由<a class="ae nf" href="https://unsplash.com/@barnimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的谷仓图片</a>上<a class="ae nf" href="https://unsplash.com/s/photos/tools?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">的Unsplash </a></figcaption></figure><h1 id="3b66" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">成分组成</h1><h2 id="7f71" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated"><strong class="ak">为什么担心组件:</strong></h2><p id="b599" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在开始之前，我们应该想一想什么是“好代码”。代码:</p><ul class=""><li id="0e51" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">做我们想要的<strong class="lc iu">(功能性)</strong>，</li><li id="f0e9" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">易写<strong class="lc iu">(开发者速度)</strong>，</li><li id="44c3" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">易读<strong class="lc iu">(可维护)</strong>，</li><li id="b3f0" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">它好吗<strong class="lc iu">(小，快，可靠)</strong>。</li></ul><h2 id="b4e6" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">问题</h2><p id="8a4d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">过去写HTML、CSS、Javascript有点像噩梦。就说你正在做的网站有一个bug。有一个按钮，应该启动一个模态/弹出窗口，但按钮的大小是错误的，弹出窗口没有出现。</p><p id="55db" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们如何解决这个问题？我们会查看HTML来找到我们正在查看的按钮。然后，我们将寻找包含选择我们关心的按钮的CSS文件，并进行一些样式更改。最后，我们会在Javascript文件中搜索选择该按钮的内容，看看有什么问题。</p><p id="a4d4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu">问题？不清楚的意大利面条代码。我们不得不翻遍所有的文件，甚至不知道去哪里找，只是为了编辑我们关心的一小部分。</strong></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi og"><img src="../Images/1bcf70667dd0b92e6157f2973a4d4602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wzkd38oyBKuX6RyuUkw3A.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated"><a class="ae nf" href="https://unsplash.com/@yungnoma?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张侨勇</a>在<a class="ae nf" href="https://unsplash.com/s/photos/mess?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h2 id="911e" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">解决方案</h2><p id="34df" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">组件是为了分解我们网站的小部分而创建的工具。</p><ul class=""><li id="4db3" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">较小的相关代码意味着更容易找到、阅读和维护。</li><li id="7ca7" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">组件也是可重用的:更快的开发(DRY原则)</li></ul><p id="b166" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">虽然这在理论上听起来不错，但在实践中，会出现很多问题。</p><ul class=""><li id="b64d" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">组件本身会变得非常复杂。(我们如何保持代码简单？)</li><li id="ee8a" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">我们的组件不太容易重用。(我们如何设计可复用的组件？)</li></ul><h2 id="ad9e" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">文章路线图</h2><p id="83e0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了解决这些问题，我们需要设计组件的原则。以下是我们将要谈论的话题。</p><ol class=""><li id="fe6b" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv oh ny nz oa bi translated">分离关注级别</li><li id="91b3" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv oh ny nz oa bi translated">思考作文</li><li id="b2bc" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv oh ny nz oa bi translated">为可重用性而设计</li></ol><h1 id="dd7f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">分离关注级别</h1><p id="045b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">问题:如何避免我们的组件过于复杂？</strong></p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oi"><img src="../Images/1cede91f414906ae2c9d835dfc077dea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHMFOjw8bNfZsyDPoLS5qA.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">照片由<a class="ae nf" href="https://unsplash.com/@alexblock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alex Block </a>在<a class="ae nf" href="https://unsplash.com/s/photos/sort?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="aa2f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">复杂性通常来自于必须处理太多的问题。虽然数量是一个促成因素，但并不总是担心越少越好。</p><p id="1ebf" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">例如，正如前面所讨论的，很长时间以来，人们一直试图将标记、样式和脚本分成三个关注点。然而，这种分离实际上使代码更加复杂。这是三个不同的关注点，但是，它们因为同一个目标而高度相关:创建单个元素/组件。这三个关注点在一个关注层次上。</p><p id="484f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">而且很多工具都认识到了这个现实。每个框架主要是将动作直接附加到标记上(即使是普通的HTML/JS也有一个基于属性的API来将脚本附加到标记上)。Vue使用单个文件组件，将组件的标记、样式和脚本捆绑在同一个文件中。Tailwind CSS使用实用程序类将样式与标记混合在一起。</p><blockquote class="mb mc md"><p id="4c2b" class="la lb me lc b ld lw ju lf lg lx jx li mf ly ll lm mg lz lp lq mh ma lt lu lv im bi translated">不是转换关注点使编码变得困难。这是关心程度的转换。</p></blockquote><p id="ffe8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu">关注程度</strong></p><p id="32eb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">组织级别的问题(高)</p><ul class=""><li id="a32e" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">我们如何看待这个问题？</li><li id="421e" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">需要做些什么？</li><li id="2f72" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">我们如何委派责任？</li></ul><p id="18ff" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">接近级别问题(中间)</p><ul class=""><li id="8847" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">存在哪些更小的问题/目标？</li><li id="03e4" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">我们如何实现这些目标？</li></ul><p id="17ab" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">实施级别问题(低)</p><ul class=""><li id="d307" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">我们确切地知道我们想要做什么。</li><li id="f17c" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">我们该怎么做。</li></ul><p id="bc2c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu">示例<br/> </strong>一个组织关注点可能对应于你的博客应用程序中的一个特定视图。最重要的是，你需要为用户提供内容，一种导航到其他内容的方式，一种分享和阅读评论的方式。在这个关注级别上工作的组件可能是视图组件。视图组件将这三项任务委托给其他三个组件:导航栏(用于导航)、主区域(用于内容)和页脚(用于注释)。</p><p id="6792" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在，导航栏、页脚和侧边栏都有各自的关注点，但是它们是什么类型的关注点呢？导航栏的主要职责是列出网站结构。我们是否考虑决定将这个组件与组织、方法或实现相关联，完全取决于复杂性。如果它只是一个无序的链接列表，并且没有更小的问题要处理，那么它可能只是关于<strong class="lc iu">实现</strong>。也许我们希望在导航中有多层次的深度。也许描述我们的<strong class="lc iu">方法</strong>是有意义的，它通过向负责显示每个子菜单的导航栏添加一个子组件来解决这个问题。想要旋转木马和视频展示吗？在这个阶段，组织化也是有意义的。</p><p id="bcd1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为什么要将组件保持在级别上？首先，这是一种自然的责任层级。如果我正在观察一个子组件的行为，我总是可以很容易地从更高开始，一个组件一个组件地深入，并且很好地理解什么做什么和如何做。这与由他们所做的任务类型组织的关注形成了鲜明的对比，例如文件夹中的文件被标记为组件、动作、缩减器、样式等。想知道东西在哪里，怎么编辑？最好事先知道它是如何工作的。</p><p id="a5ef" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">主要原因是它把相关的问题放在了一起。当你要在一个关注层次上编辑某样东西时，你很可能会接触到同一层次上的其他东西。最好离他们近一点。可能更重要的是，这些级别将无关的问题排除在外！想象一下，视图/组织级别的代码就像控制注释/页脚部分的滚动监听器。想象一下，查看页脚组件，却找不到任何可能导致您所发现的错误的东西。这就是复杂性。</p><p id="90ea" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最终，描述关注级别的目的是让您将组件与问题的结构联系起来。还有其他类型和层次的担忧！但是在设计代码库时，这三个是最常见和最有用的。</p><p id="2408" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu">中断关注的常见原因</strong></p><ul class=""><li id="7010" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated"><strong class="lc iu">过度模块化</strong>:有时一个组件可能有三个部分，但它们都很简单。一个好的经验法则是，组件模板、代码和样式最多占据屏幕的一整页。你应该考虑分手了。</li><li id="1614" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><strong class="lc iu">过于拘泥于编程的经验法则:</strong>道具向下，事件向上的流动架构在很多情况下都有效。但有时不会。不要强迫自己上下5层。</li></ul><h1 id="a0c2" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">思考作文</h1><p id="75a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">问题:</strong>以什么方式？</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oj"><img src="../Images/b623ed760d2f584e244d7f741a5e8c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYlAeUzgZ5IVsxIVCQ46pA.jpeg"/></div></div></figure><p id="7783" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">编码时，我们通常会编写两种不同类型的代码。有与应用无关的代码，也有特定于应用的代码。像小元素、辅助函数、库之类的东西通常与它们所在的应用程序无关。因此，它们应该被设计成可重用的。此外，还有特定于您正在构建的应用程序的逻辑。可能不会移植到其他地方的东西。</p><p id="b783" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里有一种编写组件的方法。</p><h2 id="7208" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated"><strong class="ak">区块、</strong>T10】构图和<strong class="ak">视图</strong>。</h2><ul class=""><li id="8f40" class="ns nt it lc b ld le lg lh lj ok ln ol lr om lv nx ny nz oa bi translated"><strong class="lc iu">块</strong>是通用组件，您可以在任何应用程序中使用。(如按钮)</li><li id="86e6" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><strong class="lc iu">成分</strong>是“特定应用”成分。(如新闻供稿)</li><li id="6fce" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><strong class="lc iu">视图</strong>是高层次的应用特定组件，或多或少代表了一个站点/应用的主要领域。(如主页)</li></ul><p id="796f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">一般来说，块用于构建组合，组合用于构建视图。</p><blockquote class="mb mc md"><p id="2616" class="la lb me lc b ld lw ju lf lg lx jx li mf ly ll lm mg lz lp lq mh ma lt lu lv im bi translated"><strong class="lc iu">区块</strong> → <strong class="lc iu">构图</strong> → <strong class="lc iu">视图</strong></p></blockquote><h2 id="7c98" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">阻碍</h2><p id="04a1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">块是小的通用组件，我们可以在应用程序中的任何地方使用。我们也可以用更小的积木搭建更复杂的积木。关于块的关键是我们必须设计它们以一种通用的方式被重用。灵活性是关键！</p><p id="7496" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">块的例子</p><ul class=""><li id="3019" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">按钮(元素块)</li><li id="19c0" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">列(布局块)</li><li id="b220" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">数据提供者(资源块)</li><li id="8979" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">动画修改器(修改器块)</li></ul><p id="04b2" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="me">下一节</em>将详细介绍块类型</p><h2 id="0c74" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">作文</h2><p id="1334" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">构图是我们用特定用途的积木制作的东西。它们可以在你的应用程序中重用，页面之间略有不同，但你应该致力于使这些通用。只在你的应用需要的时候做抽象。</p><p id="9687" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">示例:</p><ul class=""><li id="99ab" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">脸书的新闻提要</li><li id="5da2" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">您定制设计的明信片组件</li></ul><h2 id="a6a3" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">视图</h2><p id="46ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">视图通常以描述布局结束，因此可以重用，因为它可以用于许多不同的上下文。然而，一般来说，你将提取布局作为块。</p><h2 id="c4f3" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated"><strong class="ak">好处</strong></h2><p id="d998" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种类型的组合的主要好处是它适合分离关注级别。例如，对于一个视图，你将主要担心组织。有了作文，你将思考行为的方法。Blocks会很自然地做底层实现:深入DOM并使用特定于框架的特性，如门户、双向数据绑定、钩子等。</p><p id="5b42" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">接下来，它有助于组织您的代码库。块将是跨平台共享的组件库。compositions文件夹的根将包含所有高级组合，子目录中包含它们的子组件。“视图”文件夹可以按照与路线相匹配的方式进行组织。</p><h1 id="8fd6" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">块设计:提高可重用性和可读性</h1><p id="c534" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">可重用性的关键是灵活性。在不同的情况下，当块满足您的需要时，您可以重用它。通常在块的数量和它的灵活性之间有一个折衷。一个做很多事情的块可能在一种情况下很棒，但在另一种情况下不一定。一个块应该做尽可能多的事情，但是让用户做尽可能少的事情。</p><p id="1531" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们需要在前端控制的两件主要事情是事物的外观和行为。在React世界中，人们试图通过创建表示组件(事物的外观)和容器组件(事物的行为)来实现这一点。虽然这是一个很好的划分，但大多数时候，这通常不够细化，不够灵活。例如，表示有许多子问题:上下文/标记、样式、定位等。因此，我们将需要看看许多其他类型…</p><p id="6ad6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这里，我们将只讨论几种不同类型的组件，以及它们在思考合成时是如何工作的。关于如何设计和实现块的具体例子，请参阅第2部分。</p><h2 id="40a6" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">演示组件责任</h2><p id="d858" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">他们负责:</p><ul class=""><li id="ecd1" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated"><strong class="lc iu">标记</strong> —显示的HTML。</li><li id="17f8" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><strong class="lc iu">样式</strong> —显示HTML的CSS</li><li id="656b" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><strong class="lc iu">基本事件处理/基本UI状态管理</strong> —管理基本状态和动作，如切换、悬停、点击等。</li></ul><p id="2906" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有些人会说，你应该尽量保持你的组件纯粹的功能性。只有对关键性能有意义时才这样做。如果你人为地使代码具有功能性，它会使你的代码更加复杂。</p><p id="a4e1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里有三种类型的表示组件。</p><ul class=""><li id="bca0" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">元素</li><li id="6c73" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">布局</li><li id="794b" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">视觉修饰词</li></ul><h2 id="fcd3" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">元素</h2><p id="3449" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">元素是标准块。您可以在应用程序中的任何地方重复使用的标记。它们通常只是包装一个真正的HTML元素，但是有额外的道具来提供更有用的可定制性。</p><h2 id="e4d4" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">布局组件</h2><p id="a863" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">布局组件是构建组件的一种策略。布局组件，顾名思义，只是用来布局内容的。</p><p id="a49f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">虽然布局通常可以通过css类名来实现，这是布尔玛或Bootstrap等框架的常用方法，但如果您想要更好的封装/想要阻止CSS通过全局类泄漏到您的布局中，在组件中使用作用域样式可能会更好。</p><p id="fb15" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有了像JS中的css和CSS变量这样的方法，我们还可以管理布局，这是单纯的CSS做不到的。我们可以将css值绑定到javascript变量/属性。我们可以做一些事情，比如进行元素查询(依赖于元素宽度而不仅仅是屏幕宽度的响应式设计)，控制间隙、填充道具等变量。</p><h2 id="8c2d" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">视觉修饰词</h2><p id="6a79" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">视觉修改器是可以用来包裹其他组件的组件，为它们提供特定的功能，如悬停效果、动画等。</p><p id="f1e8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">视觉修饰符比大多数传统的HTML/CSS策略更清晰、更灵活、更可重用。一个prop接口给你JavaScript的力量来控制这些修改器，允许你控制过渡速度，或者悬停风格覆盖等等。</p><h2 id="ba8f" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">容器组件</h2><p id="7b57" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">容器组件是“逻辑”和行为组件。他们利用生命周期挂钩、本地状态、状态管理等。在块的上下文中，它们为状态管理、用户交互或处理行为提供了可重用的模式。</p><p id="f9b9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">他们负责:</p><ul class=""><li id="575c" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated"><strong class="lc iu">状态管理</strong></li><li id="9abc" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><strong class="lc iu">数据操作/逻辑</strong></li><li id="1040" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><strong class="lc iu">数据通信</strong></li></ul><p id="e957" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有两种主要类型的容器组件:</p><ul class=""><li id="004e" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">行为修正组件</li><li id="d092" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">资源组件</li></ul><h2 id="ee04" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">行为修正组件</h2><p id="d901" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">行为修改器是帮助提供一小部分功能的组件。它们通常提供最少的标记/纯粹的逻辑或者是无渲染的组件。</p><p id="c5f6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">示例:</p><ul class=""><li id="3116" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">拖放重新排序列表</li><li id="506d" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">元素查询/视觉响应</li></ul><h2 id="3db2" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated"><strong class="ak">资源组件</strong></h2><p id="cc70" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">前端开发中经常出现的一种模式是数据管理。有些时候，你会带着同样的目的获取和处理数据。例如，您需要:</p><ul class=""><li id="0c25" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">从服务器获取数据</li><li id="4c73" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">创建加载器/旋转器</li><li id="8319" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">解决错误</li><li id="ac44" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">显示数据</li></ul><p id="8606" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">想象一下，有4种不同类型的数据资源。如果您将逻辑与视图紧密集成，您将不得不重写相同的逻辑4次(使用稍微不同的参数)。</p><p id="5a62" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">资源组件可能是与您的状态管理进行通信的好方法。您可以让resource component来完成繁重的工作，而不是为每个需要使用该数据的组件重写“dispatch”操作。</p><h2 id="2107" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated"><strong class="ak"> Widgets </strong></h2><p id="a471" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">积木是可组合的，所以很明显我们可以用更小的积木制作更复杂的积木。您通常会将多个组件放在一起，形成一个小的可用组件，如选项卡或工具栏。这些预设的小部件包含不同的UI模式，使得构建复杂的UI更加容易。</p><p id="62e1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">小部件通常做很多事情，因此通常不太灵活。创建可重用窗口小部件的一个好策略是使用默认标记，块的使用者可以在以后覆盖这些标记，但仍然可以与组件的数据和事件挂钩。另一个方法是让许多功能可选/隐藏。</p><h2 id="f44e" class="ng kj it bd kk nh ni dn ko nj nk dp ks lj nl nm ku ln nn no kw lr np nq ky nr bi translated">摘要</h2><p id="426f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，这是一个很长的帖子！恭喜你走到这一步。</p><p id="592e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu">关键要点:</strong></p><ul class=""><li id="1945" class="ns nt it lc b ld lw lg lx lj nu ln nv lr nw lv nx ny nz oa bi translated">按照关注点/问题组织代码</li><li id="fc3f" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">请随意让组件关注描述组织、描述方法和描述实现。</li><li id="e3a4" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">考虑将构件组织成块、组合和视图。</li><li id="0c5a" class="ns nt it lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">改进灵活组合是关于理解子问题/用户可能想要从一个项目到另一个项目改变的事情。</li></ul><p id="02ff" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在写作这一部分的后续部分，我们深入到现实生活中的例子和模式。</p><p id="5fa8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">附:这是我自大学以来第一次写作，所以非常感谢任何反馈。</p></div></div>    
</body>
</html>