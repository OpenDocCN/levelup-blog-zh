<html>
<head>
<title>Guide to Using Regular Expressions in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中使用正则表达式指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/guide-to-using-regular-expressions-in-golang-18a821ba1c16?source=collection_archive---------0-----------------------#2019-12-25">https://levelup.gitconnected.com/guide-to-using-regular-expressions-in-golang-18a821ba1c16?source=collection_archive---------0-----------------------#2019-12-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0b8797c6ba32859e87c147a16b26a639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tP-66Cx8HUNW1JODXh9xA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@sandrachile?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sandrachile拍摄的照片。</a> on <a class="ae kf" href="https://unsplash.com/s/photos/alphabet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="7bac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正则表达式是定义和使用字符串搜索模式以及在软件中构建查找/替换功能的一种广泛使用的方式。然而，处理它们有时会因为数百个库和框架造成的混乱而感到沮丧，每个库和框架使用稍微不同的方法来处理正则表达式。</p><p id="c1fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而在Golang中，内置的<code class="fe le lf lg lh b">regexp</code>包包含了正则表达式的所有用例，非常健壮，使用起来非常直观。</p><p id="bc9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="li">让我们来看看</em> <code class="fe le lf lg lh b"><em class="li">regexp</em></code> <em class="li">包的各种功能。</em></p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="f446" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">检查字符串中的模式匹配</h2><p id="fde3" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用<code class="fe le lf lg lh b">MatchString</code>方法在字符串中寻找模式。第一个参数是要搜索的正则表达式，第二个参数是输入字符串。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="d94f" class="lq lr it lh b gy mw mx l my mz">found, err := regexp.MatchString("g([a-z]+)ng", "golang")<br/>fmt.Printf("found=%v, err=%v", found, err)</span></pre><p id="cba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这为我们提供了以下输出:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="61ac" class="lq lr it lh b gy mw mx l my mz">found=true, err=&lt;nil&gt;</span></pre><p id="4442" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回一个布尔值，表明模式的存在，如果正则表达式编译失败，则返回一个错误值。</p><p id="c878" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将无效的正则表达式传递给<code class="fe le lf lg lh b">MatchString</code>方法会产生错误。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="af9a" class="lq lr it lh b gy mw mx l my mz">found, err := regexp.MatchString("g(-z]+ng  wrong regex", "golang")<br/>fmt.Printf("found=%v, err=%v", found, err)</span></pre><p id="6b79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给了我们:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="b531" class="lq lr it lh b gy mw mx l my mz">found=false, err=error parsing regexp: missing closing ): `g(-z]+ng  wrong regex`</span></pre><h2 id="6079" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">重用正则表达式</h2><p id="f588" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用内置的<code class="fe le lf lg lh b">Compile</code>函数将正则表达式存储在一个变量中。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="f7d9" class="lq lr it lh b gy mw mx l my mz">myRegex , err := regexp.Compile("g([a-z]+)ng")</span></pre><p id="2dd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Compile</code>返回一个指向已创建的<code class="fe le lf lg lh b">RegExp</code>对象的指针，一个错误表示regex中的一个编译错误。</p><p id="da53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">myRegex</code>变量现在可以在任何操作中重复使用。例如，我们可以在<code class="fe le lf lg lh b">myRegex</code>实例上使用<code class="fe le lf lg lh b">MatchString</code>函数。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="0247" class="lq lr it lh b gy mw mx l my mz">found := myRegex.MatchString("golang")<br/>fmt.Printf("found=%v", found)</span></pre><p id="7e59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给了我们:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="a9d1" class="lq lr it lh b gy mw mx l my mz">found=true</span></pre><p id="d4ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种选择是函数<code class="fe le lf lg lh b">MustCompile</code>。这仅返回一个参数并丢弃错误返回。如果提供的字符串没有编译成正则表达式，<code class="fe le lf lg lh b">MustCompile</code>函数会使应用程序死机。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="5472" class="lq lr it lh b gy mw mx l my mz">reg := regexp.MustCompile("g([a-z]+)ng")<br/>fmt.Println(reg.MatchString("golang"))</span></pre><p id="ed31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上工作与<code class="fe le lf lg lh b">Compile</code>类似。然而，像这样给<code class="fe le lf lg lh b">MustCompile</code>提供一个无效的正则表达式字符串，会产生混乱。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="657b" class="lq lr it lh b gy mw mx l my mz">reg := regexp.MustCompile("g([az]+ng") //Invalid regex<br/>fmt.Println(reg.MatchString("golang"))</span></pre><p id="4113" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这会产生:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="b786" class="lq lr it lh b gy mw mx l my mz">regexp.MustCompile(0x10f5b80, 0x9, 0x119f100)<br/>        /usr/local/Cellar/go/1.13.5/libexec/src/regexp/regexp.go:311 +0x152</span></pre><h2 id="7624" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">使用正则表达式进行单元素搜索</h2><p id="1a72" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用<code class="fe le lf lg lh b">FindString</code>功能找到给定模式的第一个或最左边的匹配。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="a8ba" class="lq lr it lh b gy mw mx l my mz">myRegex, _ := regexp.Compile("g([a-z]+)ng")<br/>found := myRegex.FindString("The best language is golang")<br/>fmt.Printf("found=%s", found)</span></pre><p id="844f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="53dd" class="lq lr it lh b gy mw mx l my mz">found=golang</span></pre><p id="973f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不匹配，结果是一个空字符串。</p><p id="fd98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要获得第一个匹配的子字符串的索引，使用<code class="fe le lf lg lh b">FindStringIndex</code>方法。它返回两个元素的整数切片，定义正则表达式最左边匹配的位置。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="2d57" class="lq lr it lh b gy mw mx l my mz">myRegex, _ := regexp.Compile("g([a-z]+)ng")<br/>found := myRegex.FindStringIndex("We all like golang because it is cool")<br/>fmt.Printf("start=%d, end=%d", found[0], found[1])</span></pre><p id="d81b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="84b0" class="lq lr it lh b gy mw mx l my mz">start=12, end=18</span></pre><p id="f953" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不匹配，则返回一个空切片。</p><p id="a8db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">FindStringSubmatch</code>将提供给定模式的最左边的匹配，以及该匹配中的子匹配。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="78de" class="lq lr it lh b gy mw mx l my mz">myRegex, _ := regexp.Compile("g([a-z]+)ng")<br/>found := myRegex.FindStringSubmatch("We all like golang because it is cool")<br/>fmt.Printf("found  =%v", found)</span></pre><p id="c2c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="ffce" class="lq lr it lh b gy mw mx l my mz">found  =[golang ola]</span></pre><p id="e477" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它提供了一段字符串，在本例中有两个元素。第一个元素用于匹配<code class="fe le lf lg lh b">g([a-z]+)ng</code>，第二个元素用于内部<code class="fe le lf lg lh b">([a-z]+)</code>。</p><p id="eef0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe le lf lg lh b">FindString</code>和<code class="fe le lf lg lh b">FindStringIndex</code>类似，<code class="fe le lf lg lh b">FindStringSubmatch</code>也有相应的<code class="fe le lf lg lh b">FindStringSubmatchIndex</code>。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="4b8b" class="lq lr it lh b gy mw mx l my mz">myRegex, _ := regexp.Compile("g([a-z]+)ng")<br/>found := myRegex.FindStringSubmatchIndex("We all like golang because it is cool")<br/>fmt.Printf("found  =%v", found)</span></pre><p id="a5ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="66f3" class="lq lr it lh b gy mw mx l my mz">found  =[12 18 13 16]</span></pre><h2 id="ae95" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">使用正则表达式进行多元素搜索</h2><p id="1fa7" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用<code class="fe le lf lg lh b">FindAllString</code>在给定的字符串中查找模式的所有匹配。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="638d" class="lq lr it lh b gy mw mx l my mz">myRegex, _ := regexp.Compile("g([a-z]+)ng")<br/>found := myRegex.FindAllString("Can golang be called godlang?", -1)<br/>fmt.Printf("found  =%v", found)</span></pre><p id="e296" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是指定所需的匹配计数。<code class="fe le lf lg lh b">-1</code>表示指定无计数。</p><p id="6a92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="745b" class="lq lr it lh b gy mw mx l my mz">found  =[golang godlang]</span></pre><p id="b5e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如下所示，<code class="fe le lf lg lh b">FindString</code>中讨论的所有变体在<code class="fe le lf lg lh b">FindAllString</code>中也可用。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="1908" class="lq lr it lh b gy mw mx l my mz">myRegex, _ := regexp.Compile("g([a-z]+)ng")<br/>found1 := myRegex.FindAllString("Can golang be called godlang?", -1)<br/>fmt.Printf("found1  =%v \n", found1)<br/>found2 := myRegex.FindAllStringIndex("Can golang be called godlang?", -1)<br/>fmt.Printf("found2  =%v \n", found2)<br/>found3 := myRegex.FindAllStringSubmatch("Can golang be called godlang?", -1)<br/>fmt.Printf("found3  =%v \n", found3)<br/>found4 := myRegex.FindAllStringSubmatchIndex("Can golang be called godlang?", -1)<br/>fmt.Printf("found4  =%v \n", found4)</span></pre><p id="b601" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相应的输出:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="10e9" class="lq lr it lh b gy mw mx l my mz">found1  =[golang godlang] <br/>found2  =[[4 10] [21 28]] <br/>found3  =[[golang ola] [godlang odla]] <br/>found4  =[[4 10 5 8] [21 28 22 26]]</span></pre><h2 id="5897" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">使用正则表达式进行修改</h2><p id="7487" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用<code class="fe le lf lg lh b">ReplaceAllString</code>函数用不同的子字符串替换正则表达式的所有匹配项。</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="f465" class="lq lr it lh b gy mw mx l my mz">myRegex, _ := regexp.Compile("g([a-z]+)ng")<br/>altered := myRegex.ReplaceAllString("Can golang be called godlang?", "python")<br/>fmt.Println(altered)</span></pre><p id="957d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="mo mp mq mr gt ms lh mt mu aw mv bi"><span id="d1c6" class="lq lr it lh b gy mw mx l my mz">Can python be called python?</span></pre><p id="0d19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，所有正则表达式匹配都被字符串<code class="fe le lf lg lh b">python</code>替换了。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="88fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望本指南能作为一个简单的入门，让你轻松地使用Golang中的正则表达式。</p></div></div>    
</body>
</html>