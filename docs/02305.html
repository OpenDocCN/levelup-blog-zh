<html>
<head>
<title>A Brief Introduction to Pointers in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的指针简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-brief-introduction-to-pointers-in-c-4526baf52637?source=collection_archive---------10-----------------------#2020-03-04">https://levelup.gitconnected.com/a-brief-introduction-to-pointers-in-c-4526baf52637?source=collection_archive---------10-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/385e1ccf20c392e277012af110a7c51f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDb-TH0we5X4Z8nIi7mp4Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">指针的工作原理。参考:<a class="ae kf" href="https://www.geeksforgeeks.org/pointers-c-examples/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/pointers-c-examples/</a></figcaption></figure><p id="ac96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在编程语言中，当你声明一个变量时，你把它的值存储在内存中的一个地方。</p><p id="c1df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得事情变得更容易。您不必直接处理创建该变量的内存地址。要访问它的值，您只需使用标识符(变量的名称),存储的值就在那里。</p><p id="cb0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是有时你想存储这个变量被创建的确切位置。为此，我们使用指针。</p><blockquote class="le lf lg"><p id="abf7" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">根据Josh Lospinoso 的书<a class="ae kf" href="https://www.amazon.co.uk/Crash-Course-Joshua-Alfred-Lospinoso/dp/1593278888/ref=sr_1_1?crid=T70DHEL5PYYQ&amp;keywords=c%2B%2B+crash+course&amp;qid=1583313734&amp;sprefix=c%2B%2B+crash+cours%2Caps%2C290&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank"> C++速成教程:“指针是用来引用内存地址的基本机制。指针编码了与另一个对象交互所需的两条信息——即对象的地址和对象的类型。”</a></p></blockquote></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="3768" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">指针的特征</h1><p id="181c" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">指针有许多优点，可以用于许多情况，但这里我们有它们最重要的特性:</p><ul class=""><li id="ab21" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">它们节省内存空间</li><li id="4245" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">执行时间更快，因为你将直接处理内存地址。</li><li id="fc34" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">高效访问内存(指针的内存是动态分配的)。</li><li id="173b" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">它可以用于数据结构。甚至对多维表示也很有用。</li><li id="f2b8" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">它可以用来访问数组的内容。</li><li id="4319" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">指针可以用于文件处理。</li><li id="a8ee" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">在C++中，声明为基类的指针可以访问派生类的对象。但是，指向派生类的指针不能访问基类的对象。</li></ul><p id="4998" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你想在内存中存储一个变量的位置。我们应该使用&amp;符号来做到这一点。这个符号被称为“地址-of”运算符。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="3274" class="ns lt it no b gy nt nu l nv nw">my_pointer = &amp;myvar;</span></pre><p id="7fbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按照上面的例子，<em class="lh"> my_pointer </em>不会存储<em class="lh"> myvar </em>的内容，而是在内存中存储他的地址。</p><p id="f452" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管只有在运行时才知道这个地址，但让我们假设myvar存储在内存中的位置115。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="bc5a" class="ns lt it no b gy nt nu l nv nw">myvar = 20;<br/>my_pointer = &amp;myvar;<br/>newvar = myvar;</span></pre><p id="3b1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将存储这个115的值，而不是变量的实际值。</p><p id="0255" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于更现实的代码示例:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="d239" class="ns lt it no b gy nt nu l nv nw">int main()<br/>{<br/>    int myvar = 20;<br/>    int* my_ptr = &amp;myvar;<br/>    int newvar = myvar;<br/>    std::cout &lt;&lt; "The myvar value is " &lt;&lt; myvar &lt;&lt; <br/>    ". \nThe newvar value is " &lt;&lt; newvar &lt;&lt;<br/>    ". \nThe my_ptr value is " &lt;&lt; my_ptr;<br/>}</span></pre><p id="dc76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出可能类似于:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="be4b" class="ns lt it no b gy nt nu l nv nw">The myvar value is 20.  <br/>The newvar value is 20.  <br/>The my_ptr value is 0x7586a3177c2c</span></pre><p id="cc77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每次运行代码时，存储变量的值应该是不同的。这是由于地址空间布局随机化造成的。这是一种安全特性，它对重要内存区域的基址进行加密，以防止被利用。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="d134" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">取消引用指针</h1><p id="83dd" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我们也可以反过来工作。如果你有一个存储在某个变量中的内存，你可以把存储在那个空间的信息放到内存中。</p><p id="fb28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用解引用操作符(*)和在内存中保存位置的变量来实现。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="33ae" class="ns lt it no b gy nt nu l nv nw">int main()<br/>{<br/>    int myvar = 10;<br/>    int* myvar_address = &amp;myvar;<br/>    printf("Value at myvar_address: %d\n", *myvar_address);<br/>    printf("myvar Address: %p\n", myvar_address);<br/>    *myvar_address = 17325;<br/>    printf("Value at myvar_address: %d\n", *myvar_address);<br/>    printf("myvar Address: %p\n", myvar_address);<br/>}</span></pre><p id="f089" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只是我们目前所见的一点点:</p><ul class=""><li id="0c29" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated"><strong class="ki iu"> &amp; </strong>是运营商的<em class="lh">地址(</em>可读作“的地址”)</li><li id="804c" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated"><strong class="ki iu"> * </strong>是<em class="lh">解引用操作符(</em>可以读作“指向的值”)</li></ul><p id="8667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在address-of操作符旁边使用解引用符号，我们可以给变量赋值，甚至不用直接接触它们:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="7af2" class="ns lt it no b gy nt nu l nv nw">int main()<br/>{<br/>  int firstvalue, secondvalue;<br/>  int * mypointer;</span><span id="bc72" class="ns lt it no b gy nx nu l nv nw">  mypointer = &amp;firstvalue;<br/>  *mypointer = 10;<br/>  mypointer = &amp;secondvalue;<br/>  *mypointer = 20;<br/>  std::cout &lt;&lt; "firstvalue is " &lt;&lt; firstvalue &lt;&lt; '\n';<br/>  std::cout &lt;&lt; "secondvalue is " &lt;&lt; secondvalue &lt;&lt; '\n';<br/>}</span></pre></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="9393" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">指针和数组</h1><p id="6e3d" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">指针和数组有相似之处。指针编码对象位置。数组对连续对象的位置和长度进行编码。</p><p id="297e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不同的是，指向数组的指针将返回第一个数组对象。让我们来看第一个例子，摘自前面引用的那本书:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="ca75" class="ns lt it no b gy nt nu l nv nw">struct College {<br/>    char name[256];<br/>};</span><span id="c97c" class="ns lt it no b gy nx nu l nv nw">void print_name(College* college_ptr) {<br/>    printf("%s College\n", college_ptr-&gt;name);<br/>}<br/>int main() {<br/>    College best_colleges[] = { "Magdalen", "Nuffield", "Kellogg" };<br/>    print_name(best_colleges);<br/>}</span></pre><p id="1317" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面代码的输出将是:<em class="lh">马格达林学院</em></p><p id="a07c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们声明了一个名为College的结构，它包含一个256字符的字符串。在main方法上，我们创建一个字符串数组，并将该数组传递给print_name方法。</p><p id="a938" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个方法有一个指针作为参数(指向学院结构)。这意味着当您调用print_name时，best_colleges数组将衰减为一个指针。</p><p id="ac32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数组总是衰减为指向其第一个元素的指针。变量college_ptr指向这个数组的第一个元素。我们使用箭头操作符来访问college_ptr指向的元素。</p><p id="73ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过将数组的大小作为另一个参数来处理这种衰减。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="3a77" class="ns lt it no b gy nt nu l nv nw">struct College {<br/>    char name[256];<br/>};</span><span id="95e8" class="ns lt it no b gy nx nu l nv nw">void print_names(College* colleges, size_t n_colleges) {<br/>    for (size_t i = 0; i &lt; n_colleges; i++) { <br/>        printf("%s College\n", colleges[i].name);<br/>    }<br/>};</span><span id="8e99" class="ns lt it no b gy nx nu l nv nw">int main() {<br/>    College oxford[] = { "Magdalen", "Nuffield", "Kellogg" };<br/>    print_names(oxford, sizeof(oxford) / sizeof(College));<br/>}</span></pre><p id="2489" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出将正确地为:</p><p id="9d67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">马格达林学院</em></p><p id="eb14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纳菲尔德学院</p><p id="ffc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">凯洛格学院</p><p id="1f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然使用指针处理数组看起来很傻，但这是大型C风格API中的一个经常性特性，例如，Windows和Linux这样的操作系统。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="a05c" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">指针的另一个用途</h1><p id="545c" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">您可以访问以下链接，在更高级的主题中找到指针的良好用法:</p><ul class=""><li id="b933" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated">为了<a class="ae kf" href="https://www.geeksforgeeks.org/passing-by-pointer-vs-passing-by-reference-in-c/" rel="noopener ugc nofollow" target="_blank">通过引用传递参数</a></li><li id="ae21" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">用于<a class="ae kf" href="https://www.geeksforgeeks.org/arrays-in-c-cpp/" rel="noopener ugc nofollow" target="_blank">访问数组元素</a></li><li id="a3b1" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">到<a class="ae kf" href="https://www.geeksforgeeks.org/how-to-return-multiple-values-from-a-function-in-c-or-cpp/" rel="noopener ugc nofollow" target="_blank">返回多个值</a></li><li id="3d61" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated"><a class="ae kf" href="https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/" rel="noopener ugc nofollow" target="_blank">动态内存分配</a></li><li id="5883" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated"><a class="ae kf" href="https://www.geeksforgeeks.org/data-structures/" rel="noopener ugc nofollow" target="_blank">实现数据结构</a></li><li id="db7b" class="mv mw it ki b kj ne kn nf kr ng kv nh kz ni ld na nb nc nd bi translated">在存储器地址有用的地方进行<a class="ae kf" href="https://www.geeksforgeeks.org/tag/system-programming/" rel="noopener ugc nofollow" target="_blank">系统级编程</a>。</li></ul></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><p id="48c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考资料:</p><div class="ny nz gp gr oa ob"><a href="https://www.geeksforgeeks.org/features-and-use-of-pointers-in-c-c/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">C/C++ - GeeksforGeeks中指针的特性和使用</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">指针存储变量的地址或内存位置。语法:datatype * var _ name示例:指针“ptr”保持…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ok l"><div class="ol l om on oo ok op jz ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="http://www.cplusplus.com/doc/tutorial/pointers/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">两颗北极指极星</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">在前面的章节中，变量被解释为计算机内存中的位置，可以被它们的…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.cplusplus.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op jz ob"/></div></div></a></div><p id="9887" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.amazon.co.uk/Crash-Course-Joshua-Alfred-Lospinoso/dp/1593278888/" rel="noopener ugc nofollow" target="_blank">《c++速成教程》，作者乔希·洛斯皮诺索(2019)。</a></p></div></div>    
</body>
</html>