<html>
<head>
<title>Memory Model Basic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本记忆模型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/memory-model-basic-d8b5f8fddd5f?source=collection_archive---------0-----------------------#2020-12-18">https://levelup.gitconnected.com/memory-model-basic-d8b5f8fddd5f?source=collection_archive---------0-----------------------#2020-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d03c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">C++中多线程编程的内存排序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b6b22db8a00b5b09d763713f34b1abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PZeSd8Rf0HhBjvGn"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@aridley88?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Andrew Ridley </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="4209" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="e1b5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">众所周知，从C++11开始，<code class="fe mn mo mp mq b">std::atomic&lt;T&gt;</code>就作为标准库的一部分被引入。可能该功能最明显的部分是每个实例化的类型<code class="fe mn mo mp mq b">std::atomic&lt;T&gt;</code>可以在不同的线程上自动操作，而不会导致任何数据竞争。但是，为了避免棘手的错误，或者为了提高程序的性能，了解<code class="fe mn mo mp mq b">std::atomic&lt;T&gt;</code>的另一个方面是很重要的。这与记忆模型有关，尤其是记忆排序。</p><p id="47b9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">C++标准中规定了六种内存排序:<code class="fe mn mo mp mq b">memory_order_relaxed</code>、<code class="fe mn mo mp mq b">memory_order_consume</code>、<code class="fe mn mo mp mq b">memory_order_acquire</code>、<code class="fe mn mo mp mq b">memory_order_release</code>、<code class="fe mn mo mp mq b">memory_order_acq_rel</code>和<code class="fe mn mo mp mq b">memory_order_seq_cst</code>。您可以使用如下原子操作来指定这些内存排序。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="ca05" class="na la it mq b gy nb nc l nd ne">example) x.store(true, std::memory_order_relaxed);</span></pre><p id="039c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这六种型号可以大致分为以下三个订购类别。</p><ul class=""><li id="8a15" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nk nl nm nn bi translated">轻松排序(<code class="fe mn mo mp mq b">memory_order_relaxed</code>)。</li><li id="e47d" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">获取-发布排序(<code class="fe mn mo mp mq b">memory_order_consume</code>、<code class="fe mn mo mp mq b">memory_order_acquire</code>、<code class="fe mn mo mp mq b">memory_order_release</code>、<code class="fe mn mo mp mq b">memory_order_acq_rel</code>)</li><li id="3761" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">顺序一致排序(<code class="fe mn mo mp mq b">memory_order_seq_cst</code>)</li></ul><p id="2625" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这篇文章中，我将使用简单的图表和具体的例子来解释这三个类别，希望它能给你足够的理解来研究每个memory_order选项的细节。</p><h1 id="b760" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">宽松订购</h1><p id="77fc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我将解释放松排序(<code class="fe mn mo mp mq b">std::memory_order_relaxed</code>)。让我们看看下面的示例程序。如您所见，有两个线程(<code class="fe mn mo mp mq b">thread_1</code>和<code class="fe mn mo mp mq b">thread_2</code>)。</p><p id="a93c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在<code class="fe mn mo mp mq b">thread_1</code>中，将<code class="fe mn mo mp mq b">true</code>存储到原子对象<code class="fe mn mo mp mq b">x</code>，然后将<code class="fe mn mo mp mq b">true</code>值存储到原子对象<code class="fe mn mo mp mq b">y</code>。</p><p id="0222" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在<code class="fe mn mo mp mq b">thread_2</code>中，它在一个<code class="fe mn mo mp mq b">while</code>循环中检查<code class="fe mn mo mp mq b">y</code>的值，并重复直到它读取<code class="fe mn mo mp mq b">true</code>为止。在它退出循环后，如果<code class="fe mn mo mp mq b">x</code>的值是<code class="fe mn mo mp mq b">true</code>，那么它打印<code class="fe mn mo mp mq b">"y == true also x == true”</code>。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="74ee" class="na la it mq b gy nb nc l nd ne">#include &lt;atomic&gt;<br/>#include &lt;thread&gt;<br/>#include &lt;iostream&gt;</span><span id="5dd4" class="na la it mq b gy nt nc l nd ne">std::atomic&lt;bool&gt; x,y;</span><span id="5311" class="na la it mq b gy nt nc l nd ne">void func_1() {<br/>  x.store(true, <strong class="mq iu">std::memory_order_relaxed</strong>);<br/>  y.store(true, <strong class="mq iu">std::memory_order_relaxed</strong>);<br/>}</span><span id="af82" class="na la it mq b gy nt nc l nd ne">void func_2() {<br/>  while(!y.load(<strong class="mq iu">std::memory_order_relaxed</strong>));<br/>  if(x.load(<strong class="mq iu">std::memory_order_relaxed</strong>)) {<br/>    std::cout &lt;&lt; "y == true also x == true \n";  <strong class="mq iu">// This might not be executed.</strong><br/>  }<br/>}</span><span id="5dc4" class="na la it mq b gy nt nc l nd ne">int main() {<br/> x = false;<br/> y = false;<br/> std::thread thread_1(func_1);<br/> std::thread thread_2(func_2);<br/> thread_1.join();<br/> thread_2.join();<br/>}</span></pre><p id="ccab" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">那么程序执行的结果是什么呢？由于在<code class="fe mn mo mp mq b">thread_1</code> ( <code class="fe mn mo mp mq b">func_1</code>)中<code class="fe mn mo mp mq b">y</code>被设置为<code class="fe mn mo mp mq b">true</code>之前<code class="fe mn mo mp mq b">x</code>被设置为<code class="fe mn mo mp mq b">true</code>，您会期望程序总是打印<code class="fe mn mo mp mq b">"y == true also x == true"</code>。然而，事实是<code class="fe mn mo mp mq b">"y == true also x == true”</code> <strong class="lt iu">可能不会被打印(可能会被打印，但标准不保证)。</strong></p><p id="de4c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这是为什么呢？当然，现代编译器，CPU可以重新排序内存访问操作(如<code class="fe mn mo mp mq b">x.store, x.load</code>)进行优化。</p><p id="a751" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">但是，这种意外不会发生在单线程程序中。在单线程程序中，只有在不破坏最终结果的情况下，编译器和CPU才被允许进行重新排序(称为“好像rule⁴). ”)假设规则对程序员来说是直观的，因为由此产生的可观察到的效果看起来就像编写的程序是按原样执行的(没有任何重新排序)。</p><p id="bd87" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">相反，在多线程程序中，指定的内存排序决定了编译器和CPU可能的重新排序。</p><p id="34b8" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">memory_order_relaxed</code>上例中指定的是约束最少的排序。它在不同线程之间的内存访问操作顺序上几乎不提供同步。一个例外是，它确实保证了在不同的线程中对同一对象的修改顺序必须相同。</p><p id="d4e2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">那么这意味着什么呢？让我试着用一些概念图来解释一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/a02709997c52b29b7477f044aca04251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jS-JieV6xnNrJC-R13Cwg.png"/></div></div></figure><p id="05f9" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">横轴代表内存位置。您可以看到示例程序中的对象<code class="fe mn mo mp mq b">x</code>和<code class="fe mn mo mp mq b">y</code>位于两个不同的内存位置，它有两个随时间变化的状态(<code class="fe mn mo mp mq b">True</code>、<code class="fe mn mo mp mq b">False</code>)。</p><p id="af4c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">绿线代表在特定时间从特定线程的角度来看的“内存快照”。这个“观点”是关键部分。它们是在特定时间从特定线程“观察”到的内存快照。所以，对于一个线程来说，在某一时刻内存中的值看起来就像你沿着绿线切片一样。从概念上讲，沿着绿色箭头的方向有无限的快照。</p><p id="b02c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">由于上述同步要求“在不同的线程中，对同一对象的修改顺序必须相同”，快照线不会彼此交叉。所以所有的线程仍然在每个内存位置观察相同的事件顺序。</p><p id="f5a1" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">有趣的部分来了。可以看到，<code class="fe mn mo mp mq b">thread_1</code>(上)和<code class="fe mn mo mp mq b">thread_2</code>(下)有各自的快照线，以各自的方式(不同的角度)切分内存位置空间。</p><p id="a05a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">为了解释示例程序令人惊讶的结果，我们需要看看从A行到b行的转换。</p><p id="15fa" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">从<code class="fe mn mo mp mq b">thread_1</code>的角度看，它看起来像(见绿线交叉的点处<code class="fe mn mo mp mq b">x</code>、<code class="fe mn mo mp mq b">y</code>的值)</p><ol class=""><li id="0225" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nv nl nm nn bi translated">首先，<code class="fe mn mo mp mq b">x</code>被设置为<code class="fe mn mo mp mq b">true</code>。</li><li id="f3d9" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nv nl nm nn bi translated">然后，<code class="fe mn mo mp mq b">y</code>被设置为<code class="fe mn mo mp mq b">true</code>。</li></ol><p id="3170" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">从<code class="fe mn mo mp mq b">thread_2</code>的角度来看，它看起来像</p><ol class=""><li id="1294" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nv nl nm nn bi translated">首先，<code class="fe mn mo mp mq b">y</code>被设置为<code class="fe mn mo mp mq b">true</code>。</li><li id="d3c4" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nv nl nm nn bi translated">其中，<code class="fe mn mo mp mq b">x</code>设置为<code class="fe mn mo mp mq b">true</code>。</li></ol><p id="f516" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，从<code class="fe mn mo mp mq b">thread_2</code>的角度来看，可能存在y是<code class="fe mn mo mp mq b">true</code>而x是<code class="fe mn mo mp mq b">false</code>的情况。这就是为什么示例程序可能不会打印出预期的结果。</p><p id="8dfd" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">通常，与其他选项相比，宽松排序的同步开销最小。然而，正如你所看到的，对实践中的行为进行推理是不直观和困难的。</p><h1 id="09f5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">获取-发布订单</h1><p id="4e66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">接下来，我们来看看获取-发布排序(<code class="fe mn mo mp mq b">memory_order_acquire</code>、<code class="fe mn mo mp mq b">memory_order_release</code>)。与宽松的排序相比，获取-释放排序增加了线程之间的同步。它确保存储和加载相同原子对象的线程之间的同步。</p><p id="53a2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">让我们看看下面的例子，<code class="fe mn mo mp mq b">thread_1</code>正在存储，<code class="fe mn mo mp mq b">thread_2</code>正在分别加载<code class="fe mn mo mp mq b">y</code>与<code class="fe mn mo mp mq b">memory_order_release</code>、<code class="fe mn mo mp mq b">memory_order_acquire</code>选项。为了使获取-释放排序工作，必须在同一个原子对象上成对使用<code class="fe mn mo mp mq b">memory_order_release</code>、<code class="fe mn mo mp mq b">memory_order_acquire</code>选项。</p><p id="4283" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">获取-释放排序保证了一个线程中发生在存储操作(在本例中为<code class="fe mn mo mp mq b">y.store(true, std::memory_order_release)</code>)之前的所有内存操作对于正在进行相应加载操作的另一个线程(同样，<code class="fe mn mo mp mq b">y.load(std::memory_order_acquire)</code>)是可见的。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="7461" class="na la it mq b gy nb nc l nd ne">#include &lt;atomic&gt;<br/>#include &lt;thread&gt;<br/>#include &lt;iostream&gt;</span><span id="f256" class="na la it mq b gy nt nc l nd ne">std::atomic&lt;bool&gt; x,y;</span><span id="43be" class="na la it mq b gy nt nc l nd ne">void func_1() {<br/>  x.store(true, std::memory_order_relaxed);<br/>  y.store(true, <strong class="mq iu">std::memory_order_release</strong>);<br/>}</span><span id="8fc8" class="na la it mq b gy nt nc l nd ne">void func_2() {<br/>  while(!y.load(<strong class="mq iu">std::memory_order_acquire</strong>));<br/>  if(x.load(std::memory_order_relaxed)) {<br/>    std::cout &lt;&lt; "y == true also x == true \n";  <strong class="mq iu">// This is guaranteed to be executed.</strong><br/>  }<br/>}</span><span id="cb0d" class="na la it mq b gy nt nc l nd ne">int main() {<br/> x = false;<br/> y = false;<br/> std::thread thread_1(func_1);<br/> std::thread thread_2(func_2);<br/> thread_1.join();<br/> thread_2.join();<br/>}</span></pre><p id="dc80" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">所以，这一次，内存快照图如下所示。基本上，额外的释放-获取同步确保了<code class="fe mn mo mp mq b">thread_1</code>和<code class="fe mn mo mp mq b">thread_2</code>的内存快照行看起来相似(为简单起见，在下图中绘制为相同的)。为什么？因为当<code class="fe mn mo mp mq b">thread_2</code>加载<code class="fe mn mo mp mq b">y</code>时，在<code class="fe mn mo mp mq b">thread_1</code>存储<code class="fe mn mo mp mq b">y</code>之前完成的所有内存操作都应该对<code class="fe mn mo mp mq b">thread_2</code>可见。为了确保从A到B的过渡期间<code class="fe mn mo mp mq b">thread_2</code>的内存快照行(它如何随着时间分割内存空间)应该看起来像<code class="fe mn mo mp mq b">thread_1</code>中的那些。如果以<code class="fe mn mo mp mq b">x</code>、<code class="fe mn mo mp mq b">y</code>更新的顺序为例，在从A到B的转换过程中，从两个线程来看，它看起来像</p><ol class=""><li id="aaa0" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nv nl nm nn bi translated">首先，<code class="fe mn mo mp mq b">x</code>设置为<code class="fe mn mo mp mq b">true</code>。</li><li id="0d83" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nv nl nm nn bi translated">然后，<code class="fe mn mo mp mq b">y</code>被设置为<code class="fe mn mo mp mq b">true</code></li></ol><p id="fea0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，使用发布-获取排序，可以保证示例程序打印出<code class="fe mn mo mp mq b">"y == true also x == true”</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/02c1b7daffb89475b9bfdf1e3728e791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MM0_z62RuI2yNZsWqqxakw.png"/></div></div></figure><p id="7670" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，如您所见，发布-获取订购模式看起来比宽松订购模式更直观。然而，有些情况下它会产生令人惊讶的结果。让我们看下一个例子。</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="09fd" class="na la it mq b gy nb nc l nd ne">#include &lt;atomic&gt;<br/>#include &lt;thread&gt;<br/>#include &lt;assert.h&gt;<br/>#include &lt;iostream&gt;<br/>std::atomic&lt;bool&gt; x,y;</span><span id="84cb" class="na la it mq b gy nt nc l nd ne">void func_1() {<br/>  x.store(true, <strong class="mq iu">std::memory_order_release</strong>);<br/>}</span><span id="1f77" class="na la it mq b gy nt nc l nd ne">void func_2() {<br/>  y.store(true, <strong class="mq iu">std::memory_order_release</strong>);<br/>}</span><span id="6abd" class="na la it mq b gy nt nc l nd ne">void func_3() {<br/>  while(!x.load(<strong class="mq iu">std::memory_order_acquire</strong>));<br/>  if(y.load(<strong class="mq iu">std::memory_order_acquire</strong>)) {<br/>    std::cout &lt;&lt; "x == true then also y == true \n"; <br/>  }<br/>}</span><span id="cc78" class="na la it mq b gy nt nc l nd ne">void func_4() {<br/>  while(!y.load(<strong class="mq iu">std::memory_order_acquire</strong>));<br/>  if(x.load(<strong class="mq iu">std::memory_order_acquire</strong>)) {<br/>    std::cout &lt;&lt; "y == true then also x == true \n";<br/>  }<br/>}</span><span id="c367" class="na la it mq b gy nt nc l nd ne"><strong class="mq iu">// It is possible that neither func_3 or func_4 executes print out</strong>.</span><span id="aaba" class="na la it mq b gy nt nc l nd ne">int main() {<br/> x = false;<br/> y = false;<br/> std::thread thread_1(func_1);<br/> std::thread thread_2(func_2);<br/> std::thread thread_3(func_3);<br/> std::thread thread_4(func_4);<br/> thread_1.join();<br/> thread_2.join();<br/> thread_3.join();<br/> thread_4.join();<br/>}</span></pre><p id="1e70" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">此时，有四个线程。两个独立的线程(<code class="fe mn mo mp mq b">thread_1</code>、<code class="fe mn mo mp mq b">thread_2</code>)分别存储<code class="fe mn mo mp mq b">x</code>、<code class="fe mn mo mp mq b">y</code>。<code class="fe mn mo mp mq b">thread_3</code>和<code class="fe mn mo mp mq b">thread_4</code>以不同的顺序加载<code class="fe mn mo mp mq b">x</code>、<code class="fe mn mo mp mq b">y</code>，如果<code class="fe mn mo mp mq b">x</code>、<code class="fe mn mo mp mq b">y</code>都是<code class="fe mn mo mp mq b">true</code>，则打印出信息。</p><p id="ac0b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">对于<code class="fe mn mo mp mq b">x</code>、<code class="fe mn mo mp mq b">y</code>，每个线程中的存储/加载操作与相应的<code class="fe mn mo mp mq b">std::memory_order_release</code>和<code class="fe mn mo mp mq b">std::memory_order_acquire</code>存储/加载操作正确配对。目前看来一切正常。</p><p id="63f0" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如果我们天真地猜测可能的执行结果，程序会打印，</p><ol class=""><li id="c1b1" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nv nl nm nn bi translated"><code class="fe mn mo mp mq b">x== true then also y == true</code>或者，</li><li id="69d5" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nv nl nm nn bi translated"><code class="fe mn mo mp mq b">y == true then also x == true</code>或者，</li><li id="1946" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nv nl nm nn bi translated"><code class="fe mn mo mp mq b">x== true then also y == true</code>和<code class="fe mn mo mp mq b">y == true then also x == true</code></li></ol><p id="c8cf" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">然而，再次令人惊讶的是<strong class="lt iu">程序可能</strong> <strong class="lt iu">不打印任何东西。</strong></p><p id="2c2c" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">让我们回到内存快照图。如你所见，<code class="fe mn mo mp mq b">thread_3</code>和<code class="fe mn mo mp mq b">thread_4</code>有不同的内存快照线。并且使用之前的类似解释，集中在两个线程上从A到B的过渡，</p><p id="76c6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">从<code class="fe mn mo mp mq b">thread_3</code>看起来，</p><ol class=""><li id="c710" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nv nl nm nn bi translated">首先，<code class="fe mn mo mp mq b">x</code>设置为<code class="fe mn mo mp mq b">true</code>。</li><li id="3898" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nv nl nm nn bi translated">然后，<code class="fe mn mo mp mq b">y</code>被设置为<code class="fe mn mo mp mq b">true</code>。</li></ol><p id="19ab" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">从<code class="fe mn mo mp mq b">thread_4</code>看起来，</p><ol class=""><li id="7191" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nv nl nm nn bi translated">首先将<code class="fe mn mo mp mq b">y</code>设置为<code class="fe mn mo mp mq b">true</code>。</li><li id="50a5" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nv nl nm nn bi translated">然后，<code class="fe mn mo mp mq b">x</code>被设置为<code class="fe mn mo mp mq b">true</code>。</li></ol><p id="8a9f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，示例程序可能不会打印出预期的结果。那么，我的观点是什么？基本上，释放-获取排序确保具有相应存储-加载对的线程是同步的，但是，如果它们没有与存储-加载操作配对，它不会强制线程同意该排序(因此，<code class="fe mn mo mp mq b">thread_3</code>和<code class="fe mn mo mp mq b">thread_4</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/67187f7e9ef4917470c1b752faf664d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4zd8R3kL1gwr9vMKkxtBA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/339fccb7166a485c93e9a2abf451471d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNd_FTKbZBjxZNbJLZoyrg.png"/></div></div></figure><p id="e0f5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，与宽松的排序相比，释放-获取排序对线程间的同步有更多的保证(有更多的开销)。然而，它仍然具有不直观的结果，因为仍然不同的线程可以具有不同的存储器快照线，如在上面的例子中所看到的。</p><p id="6509" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">C++标准有更严格的内存排序可以解决问题(开销更大)。这被称为顺序一致排序，这是我们接下来要看的。</p><h1 id="2c64" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">顺序一致排序</h1><p id="34e3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后的记忆排序是顺序一致排序模型(<code class="fe mn mo mp mq b">memory_order_seq_cst</code>)。这是最严格的排序，它保证了程序员最直观的结果。因为这是唯一容易推理的排序模型，所以如果不指定原子操作的排序模型，这将被设置为默认选项。</p><p id="7b84" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">顺序一致性排序不仅保证线程之间的同步与释放-获取排序相同，还保证所有线程必须看到相同的内存操作顺序。换句话说，它保证在不同的线程中只有一个共同的内存操作历史顺序。</p><p id="ae13" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">让我们看看下面的示例程序，</p><pre class="kj kk kl km gt mw mq mx my aw mz bi"><span id="1b5f" class="na la it mq b gy nb nc l nd ne">#include &lt;atomic&gt;<br/>#include &lt;thread&gt;<br/>#include &lt;assert.h&gt;<br/>#include &lt;iostream&gt;<br/>std::atomic&lt;bool&gt; x,y;</span><span id="0dc0" class="na la it mq b gy nt nc l nd ne">void func_1() {<br/>  x.store(true, <strong class="mq iu">std::memory_order_seq_cst</strong>);<br/>}</span><span id="540c" class="na la it mq b gy nt nc l nd ne">void func_2() {<br/>  y.store(true, <strong class="mq iu">std::memory_order_seq_cst</strong>);<br/>}</span><span id="68ea" class="na la it mq b gy nt nc l nd ne">void func_3() {<br/>  while(!x.load(<strong class="mq iu">std::memory_order_seq_cst</strong>));<br/>  if(y.load(<strong class="mq iu">std::memory_order_seq_cst</strong>)) {<br/>    std::cout &lt;&lt; "x == true then also y == true \n";<br/>  }<br/>}</span><span id="4578" class="na la it mq b gy nt nc l nd ne">void func_4() {<br/>  while(!y.load(<strong class="mq iu">std::memory_order_seq_cst</strong>));<br/>  if(x.load(<strong class="mq iu">std::memory_order_seq_cst</strong>)) {<br/>    std::cout &lt;&lt; "y == true then also x == true \n";<br/>  }<br/>}</span><span id="5322" class="na la it mq b gy nt nc l nd ne">int main() {<br/> x = false;<br/> y = false;<br/> std::thread thread_1(func_1);<br/> std::thread thread_2(func_2);<br/> std::thread thread_3(func_3);<br/> std::thread thread_4(func_4);<br/> thread_1.join();<br/> thread_2.join();<br/> thread_3.join();<br/> thread_4.join();<br/>}</span></pre><p id="2c7b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">此时，所有的原子操作都用<code class="fe mn mo mp mq b">memory_order_seq_cst</code>标记。</p><p id="509b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这保证了<code class="fe mn mo mp mq b">thread_1</code>、<code class="fe mn mo mp mq b">thread_2</code>、<code class="fe mn mo mp mq b">thread_3</code>和<code class="fe mn mo mp mq b">thread_4</code>之间只有一个共同的内存操作历史顺序。这与所有具有相同快照行的线程具有相同的含义，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/d0d506f9abdfb894a7cf5afea6622da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgtPGbXmD3axzWRK1bLvBw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/18b81750ecf6bfcb47eb1c8ef37f2542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCT2ozPwXHg3lEDs09P_KQ.png"/></div></div></figure><p id="cb97" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这种特殊的情况下，它恰巧是共同商定的快照行说</p><ol class=""><li id="d114" class="nf ng it lt b lu mr lx ms ma nh me ni mi nj mm nv nl nm nn bi translated">首先，<code class="fe mn mo mp mq b">x</code>设置为<code class="fe mn mo mp mq b">true</code>。</li><li id="4837" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nv nl nm nn bi translated">然后，<code class="fe mn mo mp mq b">y</code>被设置为<code class="fe mn mo mp mq b">true</code>。</li></ol><p id="f8c3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">因此，至少来自<code class="fe mn mo mp mq b">thread_4</code> ( <code class="fe mn mo mp mq b">func_4</code>)的打印执行<code class="fe mn mo mp mq b">y == true then also x == true</code>。</p><h1 id="2905" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="a517" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从C++11开始，多线程程序的内存排序模型作为语言标准的一部分与多线程同步的标准库一起被引入，例如运行在内存模型之上的<code class="fe mn mo mp mq b">std::atomic</code>。这使得编写可移植程序变得更加容易，因为在C++11之前，内存排序模型只由每个特定的体系结构定义。</p><p id="a04d" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">该语言提供了多种内存排序选项用于<code class="fe mn mo mp mq b">std::atomic</code>操作。</p><p id="dda6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">给出最直观的行为，这种行为很容易推理，通常是你在大多数情况下需要的。因此，<code class="fe mn mo mp mq b">memory_order_seq_cst</code>是标准库中所有原子操作的默认选项。</p><p id="71af" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">尽管如此，如果您需要理解或调试其他人编写的使用除<code class="fe mn mo mp mq b">memory_order_seq_cst </code>之外的内存排序的程序的行为，或者如果您需要优化程序并且您不能容忍<code class="fe mn mo mp mq b">memory_order_seq_cst</code>产生的开销，了解其他选项是有帮助的。</p><p id="3774" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">使用内存快照映像，希望您能够掌握可能的内存排序的基本概念，并准备进一步检查它们的细节。</p><p id="8f7b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">如果你想了解更多的话题，我推荐你去看看赫伯·萨特的<a class="ae ky" href="https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2" rel="noopener ugc nofollow" target="_blank">视频</a>。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="44b3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">[1]:<a class="ae ky" href="https://en.wikipedia.org/wiki/Memory_model_(programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Memory _ model _(编程)</a></p><p id="68fe" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">【2】:<a class="ae ky" href="https://en.wikipedia.org/wiki/Memory_ordering" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Memory_ordering</a></p><p id="762a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">[3]:<a class="ae ky" href="https://en.cppreference.com/w/cpp/atomic/memory_order" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/atomic/memory_order</a></p><p id="893e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">[4]:<a class="ae ky" href="https://en.wikipedia.org/wiki/As-if_rule" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/As-if_rule</a></p></div></div>    
</body>
</html>