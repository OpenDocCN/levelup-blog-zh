<html>
<head>
<title>5 Swift Extensions to write Smarter Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个Swift扩展来编写更智能的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-swift-extensions-to-write-smarter-code-7287b86fde68?source=collection_archive---------1-----------------------#2021-05-03">https://levelup.gitconnected.com/5-swift-extensions-to-write-smarter-code-7287b86fde68?source=collection_archive---------1-----------------------#2021-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个好的开发人员应该写出具有高度可维护性和可扩展性的优秀代码。更好的开发人员用智能功能扩展了编程语言，使得读写干净的代码更加容易。</p><p id="b770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我向您展示我日常使用的Swift的5个代码扩展。每一个都有详细的解释，并根据其背景故事/原始意图进行了重新创作。</p><p id="12fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">万一你TL；DR和只想查看代码，滚动到每个<strong class="jp ir">智能解决方案</strong>标题，查看复制粘贴就绪代码，或查看结论中的链接。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ec9b7e651d2671df3e9163c60f736f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8zmr2ra_G7CmrJpMBY9-Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@levajsics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">诺贝特·莱瓦西奇斯</a>在<a class="ae lb" href="https://unsplash.com/s/photos/mac?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="58c7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">1.使用自定义下标的安全数组访问</h1><p id="2be1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">每个开发者都至少经历过一次<em class="mf">【越界】</em>异常。当您尝试访问某个位置的元素时，如果该位置是负数或大于元素计数，就会出现这种情况。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="0889" class="ml ld iq mh b gy mm mn l mo mp">let values = ["A", "B", "C"]<br/>values[0] // A<br/>values[1] // B<br/>values[2] // C<br/>values[3] // Fatal error: Index out of range</span></pre><p id="bfcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在访问值之前，我们开始创建绑定检查。这导致了重复的代码，尽管它总是做完全相同的事情:检查索引界限。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="4372" class="ml ld iq mh b gy mm mn l mo mp">if 2 &lt; values.count {<br/>    values[2] // "C"<br/>}<br/>if 3 &lt; values.count {<br/>    values[3] // won't be called<br/>}</span></pre><p id="0c54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个函数来包装边界检查，将元素索引和元素数组作为参数。为了支持任何种类的元素，我们添加了一个泛型类型<code class="fe mq mr ms mh b">T</code>。如果索引超出界限，该函数返回一个包装元素或<code class="fe mq mr ms mh b">nil</code>的<code class="fe mq mr ms mh b">Optional</code>值。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="25e2" class="ml ld iq mh b gy mm mn l mo mp">func getValue&lt;T&gt;(in elements: [T], at index: Int) -&gt; T? {<br/>    guard index &gt;= 0 &amp;&amp; index &lt; elements.count else {<br/>        return nil<br/>    }<br/>    return elements[index]<br/>}</span><span id="5429" class="ml ld iq mh b gy mt mn l mo mp">let values = ["A", "B", "C"]<br/>getValue(in: values, at: 2) // "C"<br/>getValue(in: values, at: 3) // nil</span></pre><p id="b301" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这工作得很好，但与原来的(例如<code class="fe mq mr ms mh b">values[2]</code>)相比，它仍然相当冗长而且(简单地说)难看。尤其是因为附加的参数<code class="fe mq mr ms mh b">values</code>。</p><p id="f31b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们想要去掉参数<code class="fe mq mr ms mh b">values</code>，取而代之的是将函数<code class="fe mq mr ms mh b">getValue</code>与数组相关联。由于Swift支持扩展类和协议，我们可以将我们的<code class="fe mq mr ms mh b">getValue</code>移到<code class="fe mq mr ms mh b">Array</code>的扩展中:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="ea17" class="ml ld iq mh b gy mm mn l mo mp">extension Array {</span><span id="11ae" class="ml ld iq mh b gy mt mn l mo mp">    func getValue(at index: Int) -&gt; Element? {<br/>        guard index &gt;= 0 &amp;&amp; index &lt; self.count else {<br/>            return nil<br/>        }<br/>        return self[index]<br/>    }<br/>}</span><span id="45c3" class="ml ld iq mh b gy mt mn l mo mp">let values = ["A", "B", "C"]<br/>values.getValue(at: 2) // "C"<br/>values.getValue(at: 3) // nil</span></pre><p id="920d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使用更多的Swift语法功能，将该函数改为一个<code class="fe mq mr ms mh b">subscript</code>函数。</p><h2 id="03fe" class="ml ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">智能解决方案:</h2><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="19eb" class="ml ld iq mh b gy mm mn l mo mp">extension Array {</span><span id="253a" class="ml ld iq mh b gy mt mn l mo mp">    subscript (safe index: Int) -&gt; Element? {<br/>        guard index &gt;= 0 &amp;&amp; index &lt; self.count else {<br/>            return nil<br/>        }<br/>        return self[index]<br/>    }<br/>}</span><span id="558b" class="ml ld iq mh b gy mt mn l mo mp">values[safe: 2] // "C"<br/>values[safe: 3] // nil</span></pre><p id="74e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！我们的访问调用<code class="fe mq mr ms mh b">values[safe: 2]</code>看起来几乎与原来的调用<code class="fe mq mr ms mh b">values[2]</code>相同，但是为我们提供了对元素的边界安全访问。</p><p id="1ce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2021年5月4日编辑:</p><p id="9459" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢丹尼尔·沃罗比耶夫的回应！这里有一个更通用的例子，可以用于任何实现<code class="fe mq mr ms mh b">Collection</code>协议的类:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="5add" class="ml ld iq mh b gy mm mn l mo mp">extension Collection {<br/>   public subscript (safe index: Self.Index) -&gt; Iterator.Element? {<br/>     (startIndex ..&lt; endIndex).contains(index) ? self[index] : nil<br/>   }<br/>}</span></pre><h1 id="1a2f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2.同等处理零字符串和空字符串</h1><p id="a1b4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当处理可选值时，我们经常需要将它们与<code class="fe mq mr ms mh b">nil</code>进行比较，以进行空值检查。有时我们使用一个缺省值，以防这个值实际上是<code class="fe mq mr ms mh b">nil</code>，来继续下去。</p><p id="ca87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个示例方法，它在参数为零的情况下返回默认值:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="8f23" class="ml ld iq mh b gy mm mn l mo mp">func unwrap(value: String?) -&gt; String {<br/>    return value ?? "default value"<br/>}<br/>unwrap(value: "foo") // foo<br/>unwrap(value: nil) // default value</span></pre><p id="af45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是另一个优势也存在:空字符串。</p><p id="6db6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们将这个<code class="fe mq mr ms mh b">unwrap</code>方法与一个空字符串<code class="fe mq mr ms mh b">""</code>一起使用，它将返回相同的空字符串。在某些用例中，我们肯定不希望出现这种行为，而是像对待<code class="fe mq mr ms mh b">nil</code>一样对待空字符串。</p><p id="6907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须用长度检查来扩展我们的函数:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="d97d" class="ml ld iq mh b gy mm mn l mo mp">func unwrap(value: String?) -&gt; String {<br/>    let defaultValue = "default value"<br/>    guard let value = value else {<br/>        return defaultValue<br/>    }<br/>    if value.isEmpty {<br/>        return defaultValue<br/>    }<br/>    return value<br/>}<br/>unwrap(value: "foo") // foo<br/>unwrap(value: "")    // default value<br/>unwrap(value: nil)   // default value</span></pre><p id="bd7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这样一个简单的回退来说，这是一个非常糟糕的解决方案，对吗？那么，把它压缩成一行代码怎么样？</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="6933" class="ml ld iq mh b gy mm mn l mo mp">func unwrapCompressed(value val: String?) -&gt; String {<br/>    return val != nil &amp;&amp; !val!.isEmpty ? val! : "default value"<br/>}<br/>unwrapCompressed(value: "foo") // foo<br/>unwrapCompressed(value: "") // default value<br/>unwrapCompressed(value: nil) // default value</span></pre><p id="e5ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可以工作，但是无论从哪个标准来看，这个解决方案都是不可读的，也不是“好”的，尤其是当试图避免强制解包<code class="fe mq mr ms mh b">!</code>(以减少未处理的崩溃的可能性)时。</p><h2 id="869b" class="ml ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">智能解决方案:</h2><p id="a98a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">将空字符串转换为<code class="fe mq mr ms mh b">nil</code>并使用<code class="fe mq mr ms mh b">Optional</code>的内置支持</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="64f9" class="ml ld iq mh b gy mm mn l mo mp">public extension String {<br/>    var nilIfEmpty: String? {<br/>        self.isEmpty ? nil : self<br/>    }<br/>}</span></pre><p id="730a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个智能扩展，您可以使用<code class="fe mq mr ms mh b">if-let</code>展开来同时检查<code class="fe mq mr ms mh b">nil</code>和空字符串:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="bad4" class="ml ld iq mh b gy mm mn l mo mp">var foo: String? = nil<br/>if let value = foo?.nilIfEmpty {<br/>    bar(value) // not called<br/>}<br/>if let value = "".nilIfEmpty {<br/>    bar(value) // not called<br/>}<br/>if let value = "ABC".nilIfEmpty {<br/>    bar(value) // called with "ABC"<br/>}</span></pre><p id="8f1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，该扩展允许您在字符串为空时使用默认值<code class="fe mq mr ms mh b">??</code>:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="84db" class="ml ld iq mh b gy mm mn l mo mp">"ABC" ?? "123"  // ABC<br/>"" ?? "456      // 456</span></pre><h1 id="c5a1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">3.多赋值运算符</h1><p id="8af6" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在iOS上，接口是使用UIKit的<em class="mf"> </em> <code class="fe mq mr ms mh b">UIView</code>构建的，嵌套在更多的<code class="fe mq mr ms mh b">UIView</code>中，由一个<code class="fe mq mr ms mh b">UIWindow</code>管理，最终形成一个视图层次结构(macOS上的AppKit也是如此)。</p><p id="9cb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当开发人员与UI交互时，他们肯定需要对特定视图的引用，这些视图存储在实例变量中。</p><p id="6e9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看一个视图控制器的例子。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="218f" class="ml ld iq mh b gy mm mn l mo mp">class ViewController: UIViewController {<br/><br/>    private weak var someViewRef: UIView?<br/><br/>    override func viewDidLoad() {<br/>        super.viewDidLoad()<br/><br/>        let someView = UIView()<br/>        self.someViewRef = someView<br/>        self.view.addSubview(someView)<br/>    }<br/><br/>    override func viewWillAppear(_ animated: Bool) {<br/>        super.viewWillAppear(animated)<br/><br/>        // Update the background on appear<br/>        someViewRef?.backgroundColor = .red<br/>    }<br/>}</span></pre><p id="3ca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先我们创建<code class="fe mq mr ms mh b">someView</code>并将其添加到<code class="fe mq mr ms mh b">viewDidLoad</code>中的视图层次结构中。之后，我们设置一个对<code class="fe mq mr ms mh b">someViewRef</code>实例属性的<code class="fe mq mr ms mh b">weak</code>引用，这样我们就可以与<code class="fe mq mr ms mh b">viewWillAppear</code>中的视图进行交互:</p><p id="37ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">放大我们想要改进的细节:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="cb09" class="ml ld iq mh b gy mm mn l mo mp">(1) let someView = UIView()<br/>(2) self.someViewRef = someView<br/>(3) self.view.addSubview(someView)</span></pre><p id="d4b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望减少这3行代码，同时不影响可读性。对于这个小的单一用例来说，这可能看起来过于工程化了，但是想想一个视图控制器，其中创建了20个甚至30个视图→可以节省20–30行代码。</p><p id="f34f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要真正理解发生了什么，您必须了解自动引用计数(ARC)。</p><h2 id="faec" class="ml ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">自动参考计数</h2><p id="265b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">ARC是在iOS 5中作为内存管理的一种形式引入Objective-C的。</p><p id="6c5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mq mr ms mh b">(1)</code>中创建视图时，会为实例分配一些内存(足以容纳一个<code class="fe mq mr ms mh b">UIView</code>)。在同一步骤中，内部计数器被设置为<code class="fe mq mr ms mh b">1</code>，因为<code class="fe mq mr ms mh b">someView</code>是对该实例的引用。在<code class="fe mq mr ms mh b">(2)</code>中分配<code class="fe mq mr ms mh b">someViewRef</code>时，计数器加1。最后一行<code class="fe mq mr ms mh b">(3)</code>再次增加了它(总计数为<code class="fe mq mr ms mh b">3</code>)，因为视图层次结构还保存了对特定视图的引用。</p><p id="549d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mq mr ms mh b">viewDidLoad</code>方法结束时，所有的局部变量和引用都被丢弃，包括<code class="fe mq mr ms mh b">someView</code>。这减少了计数器，并且对于<code class="fe mq mr ms mh b">someViewRef</code>和<code class="fe mq mr ms mh b">view</code>层次结构(由于<code class="fe mq mr ms mh b">view.addSubview(...)</code>)它留在<code class="fe mq mr ms mh b">2</code></p><blockquote class="nh"><p id="1817" class="ni nj iq bd nk nl nm nn no np nq kk dk translated">UIKit/AppKit的核心原则之一是让视图层次结构成为唯一拥有对视图的强引用的层次结构。</p></blockquote><p id="8080" class="pw-post-body-paragraph jn jo iq jp b jq nr js jt ju ns jw jx jy nt ka kb kc nu ke kf kg nv ki kj kk ij bi translated">因此，如果视图从整个视图层次结构中删除，计数器应该递减到<code class="fe mq mr ms mh b">0</code>并自动从内存中释放。这有助于在浏览应用程序时减少内存泄漏。</p><p id="8386" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了遵守这一原则，我们总是使用<code class="fe mq mr ms mh b">weak</code>参考，因为它们<strong class="jp ir">不会增加电弧计数器</strong>。由于视图可以被释放，因此实例不再可用(它变成了<code class="fe mq mr ms mh b">nil</code>)，所以它需要是可选类型。</p><p id="a321" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码示例中，<code class="fe mq mr ms mh b">someViewRef</code>已经被声明为<code class="fe mq mr ms mh b">weak</code>，所以在<code class="fe mq mr ms mh b">viewDidLoad</code>的末尾，我们的计数器值是<code class="fe mq mr ms mh b">1</code>。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="ed54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们将前两行合并成一行会发生什么？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi od"><img src="../Images/5ddde9edf756b293395b45f572c62b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcOha5xBrXUB8E_B2h1eXw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">分配给弱属性的新实例将被立即释放</figcaption></figure><p id="c1eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器已经告诉我们，这条语句将是无用的。我们创建了一个新的实例，但是由于<code class="fe mq mr ms mh b">weak</code>，没有增加圆弧。因此，在执行完该行代码后，计数器仍然在<code class="fe mq mr ms mh b">0</code>处，实例被立即释放。</p><p id="255e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外<code class="fe mq mr ms mh b">someViewRef</code>现在是可选的，我们需要打开<code class="fe mq mr ms mh b">UIView</code>？将其添加到父<code class="fe mq mr ms mh b">view</code>中。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oe"><img src="../Images/43703d8551864c67ecbf63ccd5a088b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOAdcefJfZWPjQasJgv9PQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">弱引用需要展开，因为它们是可选的</figcaption></figure><p id="4375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结一下我们的要求:</p><ol class=""><li id="d619" class="of og iq jp b jq jr ju jv jy oh kc oi kg oj kk ok ol om on bi translated">我们想把代码简化成一行</li><li id="a5fd" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">我们需要一个本地实例，所以它不会立即被释放</li><li id="fc0b" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">我们需要一个展开的实例，这样我们可以将它添加到视图层次结构中</li><li id="2aef" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">我们需要使用<code class="fe mq mr ms mh b">weak</code>，这样引用计数器就不会递增</li><li id="ab90" class="of og iq jp b jq oo ju op jy oq kc or kg os kk ok ol om on bi translated">它最好能被<strong class="jp ir"> <em class="mf">任何对象</em> </strong>重用</li></ol><p id="58a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">似乎是一个棘手的问题，不是吗？<br/>幸运的是，Swift提供了许多语法功能，因此我们可以构建我们的定制解决方案。</p><h2 id="3426" class="ml ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">带有副作用的赋值函数:</h2><p id="37af" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">第一步，将<code class="fe mq mr ms mh b">someViewRef</code>的赋值移动到一个全局函数中(可以是任何地方)。一个参数是弱<code class="fe mq mr ms mh b">inout</code>引用，我们将实例分配给它，第二个参数是<code class="fe mq mr ms mh b">UIView</code>的实例。</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="f8de" class="ml ld iq mh b gy mm mn l mo mp">func assign(someViewRef: inout Optional&lt;UIView&gt;, <br/>            someView: UIView) -&gt; UIView {<br/>    someViewRef = someView<br/>    return someView<br/>}</span></pre><p id="9646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe mq mr ms mh b">viewDidLoad</code>可以转化为以下内容:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="bf26" class="ml ld iq mh b gy mm mn l mo mp">override func viewDidLoad() {<br/>    super.viewDidLoad()<br/><br/>    let someView = assign(someViewRef: &amp;someViewRef, <br/>                          someView: UIView())<br/>    self.view.addSubview(someView)<br/>}</span></pre><p id="6d37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！一行创建视图并分配<code class="fe mq mr ms mh b">someView</code>和<code class="fe mq mr ms mh b">someViewRef</code>🎉</p><p id="89c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它仍然是高度受限的，因为它只允许<code class="fe mq mr ms mh b">UIView</code>实例，但是我们可以通过将参数更改为泛型类型来改善这一点:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="da33" class="ml ld iq mh b gy mm mn l mo mp">func assign&lt;T&gt;(target: inout Optional&lt;T&gt;, value: T) -&gt; T {<br/>    target = value<br/>    return value<br/>}</span></pre><p id="1090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以进一步改进它，将<code class="fe mq mr ms mh b">value</code>参数改为一个返回值的闭包(这可能会变得有趣，例如，如果您想使用有限的代码范围):</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="145c" class="ml ld iq mh b gy mm mn l mo mp">func assign&lt;T&gt;(target: inout Optional&lt;T&gt;, value: () -&gt; T) -&gt; T {<br/>    let instance = value()<br/>    target = instance<br/>    return instance<br/>}</span><span id="e59c" class="ml ld iq mh b gy mt mn l mo mp">let someView = assign(target: &amp;someViewRef, value: {<br/>    let view = UIView()<br/>    view.backgroundColor = .orange<br/>    return view<br/>})</span></pre><p id="746d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，这打破了我们以前的习惯:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ot"><img src="../Images/0a5c9e46dbedccc4a0f1ade41ed3de4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_g7jJ3q9BbvydAUiBGyZsA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">值不能用作闭包参数(默认情况下)</figcaption></figure><p id="34e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过在<code class="fe mq mr ms mh b">value</code>的参数类型前加上<code class="fe mq mr ms mh b">@autoclosure</code>来修复它，两者再次工作🔥</p><p id="d280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你对这些变化有什么感受呢？</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="79d9" class="ml ld iq mh b gy mm mn l mo mp">// we started with<br/>let someView = UIView()<br/>someViewRef = someView</span><span id="cb2b" class="ml ld iq mh b gy mt mn l mo mp">// we are now at<br/>let someView = assign(target: &amp;someViewRef, value: UIView())</span></pre><p id="37e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mq mr ms mh b">&amp;</code>作为参考，以及参数名称等。导致一行相当冗长的代码…但至少是一行代码，amirite？！😅</p><p id="d487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得吗？可能不会…但幸运的是这甚至不是它的最终形式🤯</p><h2 id="930c" class="ml ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">智能解决方案:</h2><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="85e4" class="ml ld iq mh b gy mm mn l mo mp">infix operator &lt;--<br/><br/>public func &lt;-- &lt;T&gt;(target: inout T?, <br/>                    value: @autoclosure () -&gt; T) -&gt; T {<br/>    let val = value()<br/>    target = val<br/>    return val<br/>}</span></pre><p id="f6bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将函数从<code class="fe mq mr ms mh b">assign</code>重命名为圆滑的箭头<code class="fe mq mr ms mh b">&lt;--</code>，并声明为<code class="fe mq mr ms mh b">infix operator</code>(如果你喜欢冒险，你甚至可以使用表情符号箭头⬅️).这些<code class="fe mq mr ms mh b">infix</code>操作符的其他例子有<code class="fe mq mr ms mh b">+</code>和<code class="fe mq mr ms mh b">-</code>。它们都有两个参数……一个在运算符前面，一个在运算符后面。</p><p id="475c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的最终解决方案在一个简洁的语法中包含了所有的约束:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="6758" class="ml ld iq mh b gy mm mn l mo mp">let someView = someViewRef &lt;-- UIView()</span></pre><h1 id="fae0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4.数组中的过滤元素计数</h1><p id="b49e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">你多久计算一次数组中的元素？你的方法是什么？是以下其中一种吗？</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="cf35" class="ml ld iq mh b gy mm mn l mo mp">let array = ["A", "A", "B", "A", "C"]<br/>// 1.<br/>var count = 0<br/>for value in array {<br/>    if value == "A" {<br/>        count += 1<br/>    }<br/>}<br/>// 2.<br/>count = 0<br/>for value in array where value == "A" {<br/>    count += 1<br/>}<br/>// 3.<br/>count = array.filter { $0 == "A" }.count<br/>// 4...<br/>// get creative, there are many more</span></pre><p id="f90d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Swift尽量做到对人类友好，我们的代码也应该尽量反映人类的语言。</p><p id="627d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以不用过滤，计数，迭代等等。在代码库中的任何地方，检查这个干净、小巧、普遍适用的<code class="fe mq mr ms mh b">count(where:)</code>扩展(老实说，默认情况下它应该存在于Swift标准库中)。</p><h2 id="da29" class="ml ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">智能解决方案:</h2><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="3d45" class="ml ld iq mh b gy mm mn l mo mp">extension Sequence where Element: Equatable {<br/><br/>    func count(where isIncluded: (Element) -&gt; Bool) -&gt; Int {<br/>        self.filter(isIncluded).count<br/>    }<br/>}</span></pre><p id="eec7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过扩展<code class="fe mq mr ms mh b">Sequence</code>协议，也支持<code class="fe mq mr ms mh b">Array</code>以外的其他类，例如<code class="fe mq mr ms mh b">ArraySlice</code>:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="21ab" class="ml ld iq mh b gy mm mn l mo mp">["A", "A", "B"]<br/>    .count(where: { $0 == "A" }) // 2<br/>["B", "A", "B"]<br/>    .dropLast(1) // --&gt; ArraySlice&lt;String&gt;<br/>    .count(where: { $0 == "B" }) // 1</span></pre><h1 id="f3bf" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">5.SwiftUI绑定的逻辑运算符</h1><p id="e979" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这个扩展很可能不会像其他扩展那样经常使用。尽管如此，它解决了在SwiftUI中使用<code class="fe mq mr ms mh b">Binding</code>时的一个问题。</p><p id="2b7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下面的例子为例，显示了两个按钮，每个按钮显示不同的工作表:</p><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="7b91" class="ml ld iq mh b gy mm mn l mo mp">struct ContentView: View {<br/><br/>    @State var isPresentingSheet1 = false<br/>    @State var isPresentingSheet2 = false<br/><br/>    var body: some View {<br/>        VStack {<br/>            Button("Show Sheet 1") {<br/>                isPresentingSheet1 = true<br/>            }<br/>            Button("Show Sheet 2") {<br/>                isPresentingSheet2 = true<br/>            }<br/>        }<br/>        .sheet(isPresented: $isPresentingSheet1) {<br/>            Text("Sheet 1")<br/>        }<br/>        .sheet(isPresented: $isPresentingSheet2) {<br/>            Text("Sheet 2")<br/>        }<br/>    }<br/>}</span></pre><p id="c6f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接<code class="fe mq mr ms mh b">.sheet(isPresented:) {...}</code>感觉很自然。不幸的是，这实际上并没有工作很长时间，只是在几天前随着iOS 14.5 的<a class="ae lb" href="https://developer.apple.com/documentation/ios-ipados-release-notes/ios-ipados-14_5-release-notes" rel="noopener ugc nofollow" target="_blank">发布才得到解决(在以前的版本中仍然有问题)。</a></p><p id="67f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我想使用<code class="fe mq mr ms mh b">.sheet()</code>的<code class="fe mq mr ms mh b">isPresented</code>版本，而不是<code class="fe mq mr ms mh b">.sheet(item:)</code>(用某种枚举声明每一个可能的工作表)，我试图连接两个<code class="fe mq mr ms mh b">Binding&lt;Bool&gt;</code>实例:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ot"><img src="../Images/2611ceff4af94c50a30ee163941817fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1p_TsE6DF8zUSxQabbxtOA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">逻辑运算符不支持绑定</figcaption></figure><p id="3639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真扫兴。这是意料之中的，但我仍然不高兴。</p><p id="6a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，我们可以通过简单地创建一个同名的全局函数来重载已经存在的中缀操作符<code class="fe mq mr ms mh b">&amp;&amp;</code>，但是有两个<code class="fe mq mr ms mh b">Binding&lt;Bool&gt;</code>参数🚀</p><h2 id="10c7" class="ml ld iq bd le mu mv dn li mw mx dp lm jy my mz lq kc na nb lu kg nc nd ly ne bi translated">智能解决方案:</h2><pre class="km kn ko kp gt mg mh mi mj aw mk bi"><span id="ad56" class="ml ld iq mh b gy mm mn l mo mp">public func &amp;&amp; (lhs: Binding&lt;Bool&gt;,<br/>                rhs: Binding&lt;Bool&gt;) -&gt; Binding&lt;Bool&gt; {<br/>    Binding&lt;Bool&gt;(get: { lhs.wrappedValue &amp;&amp; rhs.wrappedValue },<br/>                  set: { _ in fatalError("Not implemented") })                       }</span></pre><p id="150d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mq mr ms mh b">Binding&lt;Bool&gt;</code>是一个属性包装器，它保存一个<code class="fe mq mr ms mh b">wrappedValue: Bool</code>。每个绑定都有一个getter和setter闭包，它返回两个参数的逻辑合取。由于setter方法未定义(应该更改哪个参数？)我们暂时不实现它。</p><h1 id="ce5e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="ef9a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在互联网的荒野中有更多的智能扩展。这里列出的所有工具都可以在我的工具箱<a class="ae lb" href="https://github.com/philprime/Cabinet" rel="noopener ugc nofollow" target="_blank">里找到，并在GitHub </a>上测试过。</p><p id="44d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想了解更多，请查看我的其他文章，在<a class="ae lb" href="https://twitter.com/philprimes" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，并随时给我发短信。你有具体的话题想让我介绍吗？让我知道！😃</p><p id="3933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">编辑:</strong></p><p id="2937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2021年5月4日—增加了对<a class="nf ng ep" href="https://medium.com/u/f550ee8e21d3?source=post_page-----7287b86fde68--------------------------------" rel="noopener" target="_blank">丹尼尔·沃罗比耶夫</a>的回应</p></div></div>    
</body>
</html>