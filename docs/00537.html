<html>
<head>
<title>Web Development with Rust — 03/x: Create a REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust-03/x进行Web开发:创建一个REST API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/web-development-with-rust-03-x-create-a-rest-api-f3d7e56dc502?source=collection_archive---------2-----------------------#2019-04-15">https://levelup.gitconnected.com/web-development-with-rust-03-x-create-a-rest-api-f3d7e56dc502?source=collection_archive---------2-----------------------#2019-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">关注我的</em><a class="ae kj" href="https://twitter.com/byteadventures" rel="noopener ugc nofollow" target="_blank"><em class="ki">Twitter</em></a><em class="ki">随时获取Rust最新的web开发信息。还检出了</em> <a class="ae kj" href="https://github.com/gruberb/web-programming-in-rust" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> GitHub库</em> </a> <em class="ki">到这个系列。</em></h2></div></div><div class="ab cl kk kl hx km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="im in io ip iq"><h1 id="8fb7" class="kr ks it bd kt ku kv kw kx ky kz la lb jz lc ka ld kc le kd lf kf lg kg lh li bi translated">内容</h1><ol class=""><li id="9b46" class="lj lk it ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">HTTP请求</li><li id="acaa" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">POST/PUT/PATCH/DELETE比较特殊</li><li id="f63a" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">框架的工作</li><li id="ecaa" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">创建API规范</li><li id="451c" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">制作API</li><li id="f8bf" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">输入验证</li><li id="1740" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">摘要</li></ol></div><div class="ab cl kk kl hx km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="im in io ip iq"><p id="fa75" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">API是现代快节奏网络环境的基础。前端应用程序、其他web服务和物联网设备需要能够与您的服务对话。API端点就像一扇门，你可以决定什么进来，以什么格式进来。</p><p id="4cea" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">由于Rust是一种静态类型语言，具有强大的编译器，所以在生产环境中运行web服务时不会遇到很多常见的陷阱。尽管仍有运行时错误需要您来弥补。</p><h1 id="c3c1" class="kr ks it bd kt ku mv kw kx ky mw la lb jz mx ka ld kc my kd lf kf mz kg lh li bi translated">HTTP请求</h1><p id="a66c" class="pw-post-body-paragraph mg mh it ll b lm ln ju mj lo lp jx ml lq na mn mo ls nb mq mr lu nc mt mu lw im bi translated">当我们谈论创建一个API时，我们基本上是指一个web应用程序，它监听某些路径并做出相应的响应。但首先要做的是。为了使两台设备能够相互通信，必须建立TCP连接。</p><p id="0c7a" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">TCP是双方可以用来建立连接的协议。建立此连接后，您可以接收和发送消息给对方。HTTP是另一种协议，建立在TCP之上，它定义了请求和响应的内容。</p><p id="377e" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">所以在Rust方面，TCP是在Rust核心库中实现的，HTTP不是。无论你在<a class="ae kj" href="https://medium.com/@gruberbastian/rust-for-the-web-02-x-deploy-your-first-app-51d1ed69cbe3" rel="noopener">上一篇文章</a>中选择了什么框架，它们都实现了HTTP，因此能够接收和发送HTTP格式的消息。</p><p id="581b" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">GET请求的示例如下所示:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="bf20" class="nm ks it ni b gy nn no l np nq">GET / HTTP/1.1<br/>Host: api.awesomerustwebapp.com<br/>Accept-Language: en</span></pre><p id="d69d" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">它包括:</p><ul class=""><li id="6222" class="lj lk it ll b lm mi lo mk lq nr ls ns lu nt lw nu ly lz ma bi translated"><code class="fe nv nw nx ni b">GET</code>:HTTP方法</li><li id="b959" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated"><code class="fe nv nw nx ni b">/</code>:路径</li><li id="8892" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated"><code class="fe nv nw nx ni b">HTTP/1.1</code>:HTTP协议的版本</li><li id="13a4" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated"><code class="fe nv nw nx ni b">HOST</code>:我们要向其请求数据的服务器的主机/域</li><li id="f2ce" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated"><code class="fe nv nw nx ni b">Accept-Language</code>:我们更喜欢和理解哪种语言</li></ul><p id="c210" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">最常用的HTTP方法有:</p><ul class=""><li id="547d" class="lj lk it ll b lm mi lo mk lq nr ls ns lu nt lw nu ly lz ma bi translated">得到</li><li id="bf45" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">邮政</li><li id="9e2a" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">放</li><li id="ae88" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">修补</li><li id="11fa" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">删除</li></ul><h1 id="ea62" class="kr ks it bd kt ku mv kw kx ky mw la lb jz mx ka ld kc my kd lf kf mz kg lh li bi translated">POST/PUT/PATCH/DELETE比较特殊</h1><p id="3044" class="pw-post-body-paragraph mg mh it ll b lm ln ju mj lo lp jx ml lq na mn mo ls nb mq mr lu nc mt mu lw im bi translated">每次浏览网页时，我们都在使用<code class="fe nv nw nx ni b">GET</code>。然而，如果我们想要改变数据(比如使用<code class="fe nv nw nx ni b">POST</code>将数据发送到另一个服务器)，我们需要更加小心和精确。</p><p id="5ae6" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">首先，不是每个人都被允许向另一台服务器发送大量数据。例如，我们的API可以说:“我只接受来自主机名为<code class="fe nv nw nx ni b">allowed.awesomerustapp.com</code>的服务器的数据。</p><p id="3bcc" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">因此，当你发送一个<code class="fe nv nw nx ni b">POST</code>到另一个服务器时，实际发生的是<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS工作流</a>:</p><figure class="nd ne nf ng gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ny"><img src="../Images/410fd681a355b0a017b75cfe8b807a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fJy1CEMpsNLeSWvh.png"/></div></div></figure><p id="7b68" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">我们首先询问服务器什么是允许的，你从哪里接受请求，你接受的头是什么。如果我们满足了所有这些要求，那么我们就可以派出一个<code class="fe nv nw nx ni b">POST</code>。</p><p id="8031" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">例如，web框架<a class="ae kj" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank"> actix </a>拥有自己的<a class="ae kj" href="https://actix.rs/actix-web/actix_web/middleware/cors/index.html" rel="noopener ugc nofollow" target="_blank"> cors中间件</a>。</p><blockquote class="og oh oi"><p id="5231" class="mg mh oj ll b lm mi ju mj lo mk jx ml ok mm mn mo ol mp mq mr om ms mt mu lw im bi translated"><em class="it">免责声明:并不是所有的框架(像</em> <a class="ae kj" href="https://github.com/SergioBenitez/Rocket/issues/25" rel="noopener ugc nofollow" target="_blank"> <em class="it">火箭</em> </a> <em class="it">和</em> <a class="ae kj" href="https://github.com/rustasync/tide/pull/104" rel="noopener ugc nofollow" target="_blank"> <em class="it">浪潮</em> </a> <em class="it">)都在它们的核心实现CORS。然而，在专业环境中，你处理CORS在</em> <a class="ae kj" href="https://imti.co/kubernetes-ingress-nginx-cors/" rel="noopener ugc nofollow" target="_blank"> <em class="it"> DevOps端</em> </a> <em class="it">的事情，并把它放在你的NGINX配置中作为例子。</em></p></blockquote><h1 id="ae37" class="kr ks it bd kt ku mv kw kx ky mw la lb jz mx ka ld kc my kd lf kf mz kg lh li bi translated">框架的工作</h1><p id="db73" class="pw-post-body-paragraph mg mh it ll b lm ln ju mj lo lp jx ml lq na mn mo ls nb mq mr lu nc mt mu lw im bi translated">我们利用其他人的辛勤工作来创建web应用程序。任何事情都必须在某个时候实现，只是大多数时候不是由你来实现。一个框架涵盖以下问题:</p><ul class=""><li id="ad09" class="lj lk it ll b lm mi lo mk lq nr ls ns lu nt lw nu ly lz ma bi translated">启动web服务器并打开一个端口</li><li id="1c15" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">在此端口上侦听请求</li><li id="4cca" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">如果有请求进来，查看HTTP头中的路径</li><li id="28b4" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">根据路径将请求路由到<code class="fe nv nw nx ni b">handler</code></li><li id="198e" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">帮助您从请求中提取信息</li><li id="009c" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">将生成的<code class="fe nv nw nx ni b">data</code>和<code class="fe nv nw nx ni b">HTTP StatusCode</code>(由你创建)打包，形成一个<code class="fe nv nw nx ni b">response</code></li><li id="9952" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">将<code class="fe nv nw nx ni b">response</code>发送回发送者</li></ul><p id="7dba" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">Rust web框架<a class="ae kj" href="https://github.com/rustasync/tide" rel="noopener ugc nofollow" target="_blank"> tide </a>包括<a class="ae kj" href="https://github.com/rustasync/http-service" rel="noopener ugc nofollow" target="_blank"> http-service </a>，它提供了处理http调用时所需的基本抽象。crate http-service构建在<a class="ae kj" href="https://github.com/hyperium/hyper" rel="noopener ugc nofollow" target="_blank"> hyper </a>之上，它将TCP流转换为有效的http请求和响应。</p><figure class="nd ne nf ng gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi on"><img src="../Images/7418dd8ec726f9a369622845e3b7d60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jT23hSjjiEZy32d3.png"/></div></div></figure><p id="818b" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">您的工作是创建类似于<code class="fe nv nw nx ni b">/users/:id</code>的<code class="fe nv nw nx ni b">routes</code>，并添加一个<code class="fe nv nw nx ni b">route_handler</code>，它是一个处理这个特定路径上的请求的函数。该框架确保将传入的HTTP请求定向到这个特定的处理程序。</p><h1 id="7006" class="kr ks it bd kt ku mv kw kx ky mw la lb jz mx ka ld kc my kd lf kf mz kg lh li bi translated">创建API规范</h1><p id="9561" class="pw-post-body-paragraph mg mh it ll b lm ln ju mj lo lp jx ml lq na mn mo ls nb mq mr lu nc mt mu lw im bi translated">您必须首先定义您的资源，以了解您的应用程序需要处理什么，并揭示它们之间的关系。所以，如果你想建立一个创意投票网站，你需要:</p><ul class=""><li id="6b80" class="lj lk it ll b lm mi lo mk lq nr ls ns lu nt lw nu ly lz ma bi translated">用户</li><li id="02d7" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">主意</li><li id="3516" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">投票</li></ul><p id="1862" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">此场景的简单规范如下所示:</p><h2 id="8f55" class="nm ks it bd kt oo op dn kx oq or dp lb lq os ot ld ls ou ov lf lu ow ox lh oy bi translated">用户</h2><ul class=""><li id="f1fc" class="lj lk it ll b lm ln lo lp lq lr ls lt lu lv lw nu ly lz ma bi translated">发布<code class="fe nv nw nx ni b">/users</code></li><li id="cd7a" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">得到<code class="fe nv nw nx ni b">/users</code></li><li id="5732" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">放<code class="fe nv nw nx ni b">/users/:user_id</code></li><li id="bd9e" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">补丁<code class="fe nv nw nx ni b">/users/:user_id</code></li><li id="f368" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">删除<code class="fe nv nw nx ni b">/users/:user_id</code></li><li id="c3fd" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">获取<code class="fe nv nw nx ni b">/users/:user_id</code></li></ul><p id="244e" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated"><strong class="ll iu">想法</strong>和<strong class="ll iu">投票</strong>随机应变。规范有两个好处:</p><ul class=""><li id="bff7" class="lj lk it ll b lm mi lo mk lq nr ls ns lu nt lw nu ly lz ma bi translated">它给你指引不要忘记一条路</li><li id="8332" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">它有助于向API用户传达期望的内容</li></ul><p id="61d5" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">你可以使用像<a class="ae kj" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> swagger </a>这样的工具来编写一个完整的规范，描述数据的结构以及每条路径和路由的消息/响应。</p><p id="4618" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">更专业的规范应该包括每个路由的返回值以及请求和响应主体。然而，一旦你知道你的API应该是什么样子和行为，规范就可以最终确定。要开始，简单的列表就足够了。</p><h1 id="a529" class="kr ks it bd kt ku mv kw kx ky mw la lb jz mx ka ld kc my kd lf kf mz kg lh li bi translated">制作API</h1><p id="a84c" class="pw-post-body-paragraph mg mh it ll b lm ln ju mj lo lp jx ml lq na mn mo ls nb mq mr lu nc mt mu lw im bi translated">根据您使用的框架，您的实现看起来会有所不同。你必须留意以下特征:</p><ul class=""><li id="8dee" class="lj lk it ll b lm mi lo mk lq nr ls ns lu nt lw nu ly lz ma bi translated">为每种方法创建路线(如<code class="fe nv nw nx ni b">app.at("/users").post(post_users_handler)</code>)</li><li id="3f2e" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">从请求中提取信息(比如来自请求体的头、uri-params和JSON)</li><li id="c340" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw nu ly lz ma bi translated">使用正确的HTTP代码(<code class="fe nv nw nx ni b">200</code>、<code class="fe nv nw nx ni b">201</code>、<code class="fe nv nw nx ni b">400</code>、<code class="fe nv nw nx ni b">404</code>等)创建响应。)</li></ul><p id="b960" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">对于这个网络系列，我使用的是最新版本的tide。您可以将它添加到您的<strong class="ll iu"> Cargo.toml </strong>文件中，并将其用于您的web应用程序:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="d9a9" class="nm ks it ni b gy nn no l np nq">[dependencies]<br/>tide = "0.1.0"</span></pre><p id="bf54" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">我们的第一个<code class="fe nv nw nx ni b">User</code>实现将如下所示:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="f4d6" class="nm ks it ni b gy nn no l np nq">async fn handle_get_users(cx: Context&lt;Database&gt;) -&gt; EndpointResult {<br/>    Ok(response::json(cx.app_data().get_all()))<br/>}</span><span id="620e" class="nm ks it ni b gy oz no l np nq">async fn handle_get_user(cx: Context&lt;Database&gt;) -&gt; EndpointResult {<br/>    let id = cx.param("id").client_err()?;<br/>    if let Some(user) = cx.app_data().get(id) {<br/>        Ok(response::json(user))<br/>    } else {<br/>        Err(StatusCode::NOT_FOUND)?<br/>    }<br/>}</span><span id="12b5" class="nm ks it ni b gy oz no l np nq">async fn handle_update_user(mut cx: Context&lt;Database&gt;) -&gt; EndpointResult&lt;()&gt; {<br/>    let user = await!(cx.body_json()).client_err()?;<br/>    let id = cx.param("id").client_err()?;</span><span id="76f5" class="nm ks it ni b gy oz no l np nq">    if cx.app_data().set(id, user) {<br/>        Ok(())<br/>    } else {<br/>        Err(StatusCode::NOT_FOUND)?<br/>    }<br/>}</span><span id="8bc1" class="nm ks it ni b gy oz no l np nq">async fn handle_create_user(mut cx: Context&lt;Database&gt;) -&gt; EndpointResult&lt;String&gt; {<br/>    let user = await!(cx.body_json()).client_err()?;<br/>    Ok(cx.app_data().insert(user).to_string())<br/>}</span><span id="97c0" class="nm ks it ni b gy oz no l np nq">async fn handle_delete_user(cx: Context&lt;Database&gt;) -&gt; EndpointResult&lt;String&gt; {<br/>    let id = cx.param("id").client_err()?;<br/>    Ok(cx.app_data().delete(id).to_string())<br/>}</span><span id="ba5c" class="nm ks it ni b gy oz no l np nq">fn main() {<br/>    // We create a new application with a basic, local database<br/>    // You can use your own implementation, or none: App::new(())<br/>    let mut app = App::new(Database::default());<br/>    app.at("/users")<br/>        .post(handle_create_user)<br/>        .get(handle_get_users);<br/>    app.at("/users/:id")<br/>        .get(handle_get_user)<br/>        .patch(handle_update_user)<br/>        .delete(handle_delete_user);</span><span id="507e" class="nm ks it ni b gy oz no l np nq">    app.serve("127.0.0.1:8000").unwrap();<br/>}</span></pre><p id="2d57" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated"><em class="oj">你可以在本系列的</em> <a class="ae kj" href="https://github.com/gruberb/web-programming-in-rust/tree/master/03-x" rel="noopener ugc nofollow" target="_blank"> <em class="oj"> GitHub资源库</em> </a> <em class="oj">中找到完整的实现代码。</em></p><p id="d22d" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">我们看到，我们首先必须创建一个新的应用程序</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="4140" class="nm ks it ni b gy nn no l np nq">let mut app = App::new(())</span></pre><p id="7d5b" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">添加路线</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="2752" class="nm ks it ni b gy nn no l np nq">app.at("/users")</span></pre><p id="9a7c" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">并且为每个路由添加我们想要处理的HTTP请求</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="708b" class="nm ks it ni b gy nn no l np nq">app.at("/users").get(handle_get_users)</span></pre><p id="514a" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">每个框架都有不同的提取参数和JSON主体的方法。Actix使用的是<a class="ae kj" href="https://actix.rs/docs/extractors/" rel="noopener ugc nofollow" target="_blank">提取器</a>，rocket使用的是<a class="ae kj" href="https://api.rocket.rs/v0.4/rocket/request/trait.FromQuery.html" rel="noopener ugc nofollow" target="_blank">查询守卫</a>。</p><p id="9b2c" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">使用tide，您可以通过<code class="fe nv nw nx ni b">Context</code>访问请求参数和主体以及数据库连接。所以当我们想用特定的<code class="fe nv nw nx ni b">id</code>更新一个<code class="fe nv nw nx ni b">User</code>时，我们向<code class="fe nv nw nx ni b">/users/:id</code>发送一个<code class="fe nv nw nx ni b">PATCH</code>。从那里，我们调用<code class="fe nv nw nx ni b">handle_update_user</code>方法。</p><p id="5bca" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">在这个方法中，我们可以像这样从URI访问<code class="fe nv nw nx ni b">id</code>:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="50b5" class="nm ks it ni b gy nn no l np nq">let id = cx.param("id").client_err()?;</span></pre><p id="b8ee" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">每个框架还处理自己的方式，将响应发送回发送方。潮汐用的是<code class="fe nv nw nx ni b">EndpointResult</code>，火箭用的是<a class="ae kj" href="https://api.rocket.rs/v0.4/rocket/struct.Response.html" rel="noopener ugc nofollow" target="_blank">响应</a>和actix <a class="ae kj" href="https://actix.rs/docs/response/" rel="noopener ugc nofollow" target="_blank"> HttpResponse </a>。</p><p id="66a3" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">其他的一切完全取决于你。该框架可以帮助您进行会话管理和身份验证，但是您也可以自己实现。</p><p id="c796" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">我的建议是:用你选择的框架构建你的应用程序的第一个框架，弄清楚如何从请求中提取信息，以及如何形成响应。一旦这样做了，你就可以用你的Rust技能构建你想要的或大或小的应用程序。</p><h1 id="5904" class="kr ks it bd kt ku mv kw kx ky mw la lb jz mx ka ld kc my kd lf kf mz kg lh li bi translated">输入验证</h1><p id="1e3a" class="pw-post-body-paragraph mg mh it ll b lm ln ju mj lo lp jx ml lq na mn mo ls nb mq mr lu nc mt mu lw im bi translated">你在Rust世界里最好的朋友将会是serde。它将帮助您解析JSON和其他格式，但也允许您序列化数据。</p><p id="b024" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">当我们谈到输入验证时，我们希望确保我们得到的数据具有正确的格式。假设我们从请求中提取JSON主体:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="2c0d" class="nm ks it ni b gy nn no l np nq">let user: User = serde_json::from_str(&amp;request_body);</span></pre><p id="de29" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">我们在这里使用<a class="ae kj" href="https://docs.serde.rs/serde_json/" rel="noopener ugc nofollow" target="_blank"> serde_json </a>将json字符串转换成我们选择的结构。所以如果我们创建了这个结构:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="8d9f" class="nm ks it ni b gy nn no l np nq">struct User {<br/>    name: String,<br/>    height: u32,<br/>}</span></pre><p id="4ee3" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">我们要确保发送者包括<code class="fe nv nw nx ni b">name</code> <strong class="ll iu">和</strong> <code class="fe nv nw nx ni b">height</code>。如果我们只是做了<code class="fe nv nw nx ni b">serde_json::from_str</code>，而发送者忘记了传递身高，应用程序将会死机并关闭，因为我们预计响应是一个用户:<code class="fe nv nw nx ni b">let user: User</code>。</p><p id="54db" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">我们可以这样改进错误处理:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="8f4b" class="nm ks it ni b gy nn no l np nq">let user: User = match serde_json::from_str(&amp;request_body) {<br/>    Ok(user) =&gt; user,<br/>    Err(error) =&gt; handle_error_case(error),<br/>};</span></pre><p id="dc6a" class="pw-post-body-paragraph mg mh it ll b lm mi ju mj lo mk jx ml lq mm mn mo ls mp mq mr lu ms mt mu lw im bi translated">我们捕捉错误并调用我们的<code class="fe nv nw nx ni b">handle_error_case</code>方法来优雅地处理它。</p><h2 id="aa58" class="nm ks it bd kt oo op dn kx oq or dp lb lq os ot ld ls ou ov lf lu ow ox lh oy bi translated">摘要</h2><ol class=""><li id="a07b" class="lj lk it ll b lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">挑选一个你自己选择的框架(<a class="ae kj" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> rocket </a>是夜间的，<a class="ae kj" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank"> actix </a>是稳定的，<a class="ae kj" href="https://github.com/rustasync/tide" rel="noopener ugc nofollow" target="_blank"> tide </a>是靠近铁锈核心培养的，也在夜间对铁锈起作用)</li><li id="4b6c" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">要知道目前还没有通用的CORS处理方法。建议在DevOps端处理这个问题(例如NGINX)</li><li id="dee7" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">选择一个框架后，详细说明你的资源(`/users`: GET，POST等。)</li><li id="0ea7" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">弄清楚您选择的框架如何处理从请求中提取参数和JSON，以及如何形成响应</li><li id="7968" class="lj lk it ll b lm mb lo mc lq md ls me lu mf lw lx ly lz ma bi translated">通过<code class="fe nv nw nx ni b">match</code>和<code class="fe nv nw nx ni b"><a class="ae kj" href="https://docs.serde.rs/serde_json/" rel="noopener ugc nofollow" target="_blank">serde_json</a></code>确认您的输入</li></ol></div></div>    
</body>
</html>