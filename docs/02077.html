<html>
<head>
<title>Understanding Laravel Macros</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Laravel宏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-laravel-macros-e2f493484a38?source=collection_archive---------8-----------------------#2020-02-17">https://levelup.gitconnected.com/understanding-laravel-macros-e2f493484a38?source=collection_archive---------8-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0d103ba0730a52871b917343342f5705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*abKVI5rXkNgv5idX"/></div></div></figure><p id="052c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Laravel宏允许我们向Laravel核心组件或类添加自定义功能。换句话说，它们允许我们扩展Laravel类。</p><p id="9856" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您以前从未听说过Laravel宏，您可能会疑惑:为什么我们需要一种不同的方法来扩展类，而不是默认的PHP对象继承方法？在这篇文章中，我将尝试向您展示是什么让Laravel宏如此独特，如何使用它们，以及它们如何在内部工作。</p><h1 id="5ee6" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">定义宏</h1><p id="bc0c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">假设您正在构建一个非常依赖于将数据导出为CSV文件的应用程序。如果我们能像这样做，岂不是很酷:‌</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">返回一个响应，其中包含根据提供的参数生成的CSV文件。</figcaption></figure><p id="d175" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">返回一个响应，其中包含根据提供的参数生成的CSV文件。</p><p id="ff42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，Laravel没有这个功能，它太具体了，把所有东西都装在Laravel里不好。</p><p id="3d2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在实现Laravel宏之前，您需要确保您想要扩展的类使用了trait。这就是你如何知道你可以使用宏来扩展一个类。在我们的例子中，我们将扩展<code class="fe mm mn mo mp b">Illuminate\\Http\\Response</code>类，它肯定使用了trait。因此，让我们在应用程序中添加新的功能。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">这将使用提供的标题和行编写一个新的CSV，并将其附加到响应中。</figcaption></figure><p id="0b9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将使用提供的标题和行编写一个新的CSV，并将其附加到响应中。</p><h1 id="e521" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在哪里定义宏？</h1><p id="dea7" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">宏可以在任何你想定义的地方定义，只是在你使用它之前要确保它已经被定义了。在相关的服务提供者中定义宏是一个很好的实践，但是如果你认为你的服务提供者在不久的将来会变得臃肿，你可以只为宏编写一个新的服务提供者。记得在<code class="fe mm mn mo mp b">config/app.php</code>注册。</p><h1 id="b39b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">混合蛋白</h1><p id="17a8" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">您还可以将相关的宏包装成类，并使用<code class="fe mm mn mo mp b">::mixin</code>方法扩展一个宏类。这个方法有两个参数:<code class="fe mm mn mo mp b">$mixin</code>，一个是您想要混合的类的实例，另一个是<code class="fe mm mn mo mp b">$replace</code>，一个布尔值，默认为true，表明它是否应该覆盖这个宏，如果它之前已经声明过的话。</p><p id="6d27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用我们的例子，如果我们计划添加更多的宏来以不同的格式导出数据，我们可以创建一个新的类<code class="fe mm mn mo mp b">ResponseMacros</code>，在这里我们可以定义我们想要添加到响应类的所有宏。另一个好的实践是将这些类存储在<code class="fe mm mn mo mp b">app/Mixins</code>中。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8399" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个非常重要的注意事项:所有方法都应该返回一个<a class="ae mq" href="https://stackoverflow.com/a/40942212" rel="noopener ugc nofollow" target="_blank">闭包或可调用的</a>值。</p><p id="d6da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用mixin方法:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="092c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Laravel将自动使类中所有公共的和受保护的方法作为宏可用。</p><h1 id="c1dc" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">解释宏背后的魔法</h1><p id="926c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果你像我一样，无法忍受好奇心，你可能会想“这听起来很酷，但它是如何工作的呢？怎么可能？”我不得不说，开始使用宏时，你不需要知道所有这些是如何工作的，但我会尽力向你解释。</p><p id="740a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你向下浏览到<code class="fe mm mn mo mp b">Macroable</code>特征，你会发现所有这些神奇之处都包含在仅仅117行代码中(截至2019年2月17日)，所以让我们开始吧。</p><p id="e408" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您首先会看到的是<code class="fe mm mn mo mp b">$macros</code>属性的声明。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="f320" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Laravel用它来存储每个类的宏。请记住，所有这些都是直接注入到使用trait的类中，因此属性将驻留在每个类中，并且它们永远不会交叉。</p><p id="a50e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其次，我们有<code class="fe mm mn mo mp b">macro</code>功能。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="767b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们在声明新宏时使用的函数。我们以前用过。它存储在$macros数组中传递的匿名函数，使用作为键传递的名称。</p><p id="6c7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，是<code class="fe mm mn mo mp b">mixin</code>方法。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9119" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它使用PHP反射API来检查提供的对象<code class="fe mm mn mo mp b">$mixin</code>，并提取object类中的所有公共或受保护的方法。Laravel将遍历列表，使每个方法都可以访问，并使用方法名注册每个返回的可调用或闭包。如果你注意到，如果你不表示尊重以前注册的宏，Laravel将覆盖它们。</p><p id="08f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，就是<code class="fe mm mn mo mp b">hasMacro</code>法了。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6308" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个很简单的方法。它检查一个宏是否已经注册。</p><p id="b1b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，我们现在要深入了。</p><p id="36e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">宏表特征中还有两个方法我们还没有谈到:<code class="fe mm mn mo mp b">__call</code>和<code class="fe mm mn mo mp b">__callStatic</code>。在PHP 中，它们都被认为是<a class="ae mq" href="https://www.php.net/manual/en/language.oop5.magic.php" rel="noopener ugc nofollow" target="_blank">神奇的方法，这意味着你不能在你的任何类中拥有这些名字的函数，除非你想要与它们相关的神奇功能。</a></p><p id="f2b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在PHP手册<a class="ae mq" href="https://www.php.net/manual/en/language.oop5.overloading.php#language.oop5.overloading.methods" rel="noopener ugc nofollow" target="_blank">中读到更多关于它们的内容。但本质上你应该知道的是:</a></p><ul class=""><li id="a551" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">在对象上下文中调用不可访问的方法时触发。</li><li id="4229" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated"><code class="fe mm mn mo mp b"><a class="ae mq" href="https://www.php.net/manual/en/language.oop5.overloading.php#object.callstatic" rel="noopener ugc nofollow" target="_blank">__callStatic()</a></code>在静态上下文中调用不可访问的方法时触发。</li></ul><p id="6b0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，<strong class="kd iu">不可接近</strong>是什么意思呢？根据PHP手册，这意味着那些方法没有被声明或者在你试图使用它们的范围内是不可见的。</p><p id="0cab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用我们的例子，这意味着当我们写的时候</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="dbc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="02a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们实际上分别调用了<code class="fe mm mn mo mp b">__call</code>和<code class="fe mm mn mo mp b">__callStatic</code>，因为<code class="fe mm mn mo mp b">Illuminate\\Http\\Response</code>类没有定义<code class="fe mm mn mo mp b">csv</code>方法。拉勒维尔为我们处理所有的事情。</p><p id="81ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Laravel是如何实现那些方法的？让我们看看。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="35ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这两种情况下，它开始检查我们试图使用的方法是否注册为宏。如果没有，它将抛出一个异常。如果是这样，Laravel将从$macros数组中取出它。</p><p id="a712" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在Laravel知道我们注册了一个宏用于那些情况，它将检查这个宏是否是一个闭包。如果没有，它会认为它是可调用类型，然后用所有发送的参数执行并返回。但如果是这样的话:</p><ul class=""><li id="2cb4" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">我们从一个对象上下文中调用宏，__call()，就像<code class="fe mm mn mo mp b">$object-&gt;macroName()</code>，它将闭包绑定到<code class="fe mm mn mo mp b">$this</code>范围和我们正在扩展的类。在我们的例子中，如果我们创建一个新的响应实例。当调用<code class="fe mm mn mo mp b">csv()</code>时，<code class="fe mm mn mo mp b">$this</code>关键字将对该实例求值，并且该函数也可以访问响应类中的所有内容。</li><li id="43ce" class="mr ms it kd b ke na ki nb km nc kq nd ku ne ky mw mx my mz bi translated">或者我们从静态上下文中调用宏，__callStatic()，就像<code class="fe mm mn mo mp b">ClassName::macroName()</code>一样，它将闭包只绑定到类，对象范围将为空。在宏中不引用<code class="fe mm mn mo mp b">$this</code>是合理的，因为它是未绑定的。</li></ul><p id="7afe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Laravel宏是扩展框架类的传统方式的一个很好的替代方式，我希望你很快会使用它们。</p><p id="d688" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读。祝你好运。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="e398" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nm">原载于2020年2月17日</em><a class="ae mq" href="https://leninpaulino.dev/understanding-laravel-macros/" rel="noopener ugc nofollow" target="_blank"><em class="nm">https://leninpaulino . dev</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>