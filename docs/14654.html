<html>
<head>
<title>What Is Inheritance and Composition in Java — Check the Differences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Java中的继承和组合——检查区别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-inheritance-and-composition-in-java-check-the-differences-updated-37b8fe54cf80?source=collection_archive---------22-----------------------#2022-12-14">https://levelup.gitconnected.com/what-is-inheritance-and-composition-in-java-check-the-differences-updated-37b8fe54cf80?source=collection_archive---------22-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3a11" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">面向对象编程</h2><div class=""/><div class=""><h2 id="4ebd" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">两个最广泛使用的面向对象编程特性——继承和组合。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/340b2f5a43e7baad5f2292f6cabc70ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUv3yOK8z9TbG8Dz_gHwXw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="bd le">照片由</strong> <a class="ae lf" href="https://unsplash.com/@seanlimm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <strong class="bd le">肖恩·林</strong> </a> <strong class="bd le">上</strong> <a class="ae lf" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <strong class="bd le">下</strong> </a></figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="0c46" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通过这篇文章，我将介绍java编程中的继承和组合的概念。阅读完本文后，您将对这两个java特性有了很好的了解。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="c616" class="mj mk iq bd le ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">Java中的继承是什么？</h1><p id="0268" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated"><strong class="lp ja">继承</strong>是使用已经定义的类定义一个新类的过程，这样新定义的类可以使用已经定义的类的数据成员(属性)和成员函数(方法)。</p><p id="8231" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="nf">已经定义的类称为</em> <strong class="lp ja"> <em class="nf">父类</em> </strong> <em class="nf">或</em> <strong class="lp ja"> <em class="nf">基类</em> </strong> <em class="nf">或</em> <strong class="lp ja"> <em class="nf">超类</em> </strong> <em class="nf">。</em></p><p id="9c79" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="nf">一个新定义的类叫做</em> <strong class="lp ja"> <em class="nf">子类</em> </strong> <em class="nf">类或者</em> <strong class="lp ja"> <em class="nf">派生的</em> </strong> <em class="nf">类或者</em> <strong class="lp ja"> <em class="nf">子类</em> </strong> <em class="nf">。</em></p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="6652" class="mj mk iq bd le ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">继承有什么好处？</h1><p id="4bfc" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">使用继承的优点如下:</p><ol class=""><li id="daff" class="ng nh iq lp b lq lr lt lu lw ni ma nj me nk mi nl nm nn no bi translated">新创建的类可以使用已经定义的类<strong class="lp ja"> <em class="nf">的属性(实例变量)和方法(实例方法)，而无需在子类</em>中重新定义。<em class="nf">这种方式提高了代码的可重用性。</em>T59】</strong></li><li id="4061" class="ng nh iq lp b lq np lt nq lw nr ma ns me nt mi nl nm nn no bi translated">一个子类可以有<em class="nf"> </em> <strong class="lp ja"> <em class="nf">自己的实例变量(字段)和方法。</em> </strong></li><li id="435e" class="ng nh iq lp b lq np lt nq lw nr ma ns me nt mi nl nm nn no bi translated">子类可以<strong class="lp ja"> <em class="nf">覆盖父类的实例方法。</em> </strong></li></ol><blockquote class="nu nv nw"><p id="9a61" class="ln lo nf lp b lq lr ka ls lt lu kd lv nx lx ly lz ny mb mc md nz mf mg mh mi ij bi translated">注1:当子类继承父类时，根据父类中实例变量和方法使用的访问修饰符(<strong class="lp ja">private/default/protected/public</strong>)，所有实例变量和实例方法都可以用子类对象访问。</p><p id="736f" class="ln lo nf lp b lq lr ka ls lt lu kd lv nx lx ly lz ny mb mc md nz mf mg mh mi ij bi translated">为了便于理解，我们可以说父类的变量和方法的一个副本<strong class="lp ja"> </strong>是在子类中创建的。</p><p id="a974" class="ln lo nf lp b lq lr ka ls lt lu kd lv nx lx ly lz ny mb mc md nz mf mg mh mi ij bi translated">注意2:当父类的实例变量和方法有公共的或受保护的访问修饰符时，那么子类<strong class="lp ja">对象</strong>可以直接访问它们，但是如果它们被声明为私有的，那么子类的对象将不能直接访问它们，因此这种私有变量需要公共的getters和setters。</p><p id="36c4" class="ln lo nf lp b lq lr ka ls lt lu kd lv nx lx ly lz ny mb mc md nz mf mg mh mi ij bi translated">注3:类似地，当父类的字段和方法用包私有访问级别声明时，那么子类对象不能在声明父类的包之外访问这些字段和方法。</p></blockquote><blockquote class="oa"><p id="aac9" class="ob oc iq bd od oe of og oh oi oj mi dk translated">私有变量对声明它们的类是可见的。</p></blockquote></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="90ff" class="mj mk iq bd le ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">继承的语法:</h1><pre class="kp kq kr ks gt ok ol om bn on oo bi"><span id="1cbd" class="op mk iq ol b be oq or l os ot">public class Parent {<br/>    //instance variables<br/>    //instance methods<br/>}<br/>public class Child extends Parent {<br/>    //instance variables<br/>    //instance methods<br/>    //Overridden methods of Parent class.<br/>}</span></pre><p id="a4e8" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们看一个例子来理解继承。</p><p id="b127" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">将<strong class="lp ja">动物</strong>类视为父类:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">动物类作为父类</figcaption></figure><p id="bce5" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">考虑将<strong class="lp ja"> Dog </strong>作为继承Animal类的子类:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">狗作为一个孩子类的动物类</figcaption></figure><p id="69fe" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Main作为驱动程序类来测试继承:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">主驱动程序类</figcaption></figure><p id="f304" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在上面的例子中，<strong class="lp ja">动物</strong>是父类，而<strong class="lp ja">狗</strong>是子类。现在我们可以说父类的所有实例变量(属性)和实例方法也是子类的一部分。因此我们可以说每一只<strong class="lp ja">狗</strong>都是一只<strong class="lp ja">动物</strong>。</p><p id="9c3b" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="nf">所以在继承的情况下，子类和超类之间总有一个</em><strong class="lp ja"><em class="nf">【IS-A】关系</em> </strong> <em class="nf">。</em></p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="cf3e" class="mj mk iq bd le ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">构造函数如何处理继承？</h1><p id="2260" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">当一个子类对象被创建时，它调用它自己的类<em class="nf">构造函数</em>，并且这个构造函数使用<strong class="lp ja"> <em class="nf">超级</em> </strong>关键字调用它的父类构造函数。这个父类构造函数调用是由编译器隐式完成的。让我们看一个例子来理解这一点。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">具有构造函数和继承的父级和子级</figcaption></figure><h2 id="1559" class="ow mk iq bd le ox oy dn mo oz pa dp ms lw pb pc mu ma pd pe mw me pf pg my iw bi translated">输出:</h2><pre class="kp kq kr ks gt ok ol om bn on oo bi"><span id="b3ef" class="op mk iq ol b be oq or l os ot">Parent constructor called!!!<br/>Child constructor called!!!</span></pre><p id="3da6" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">您可以看到，当创建一个子类对象时，调用了子类的无参数构造函数，但是注意，在内部，该构造函数中的第一条语句是对父类构造函数的super()调用，它是隐藏的。</p><p id="5475" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">因此，首先加载父类，并执行其构造函数，之后加载子类，并由JVM中的类加载器执行其构造函数。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="a2c0" class="mj mk iq bd le ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">有哪些不同类型的继承？</h1><ol class=""><li id="bb18" class="ng nh iq lp b lq na lt nb lw ph ma pi me pj mi nl nm nn no bi translated">单一遗传</li><li id="f039" class="ng nh iq lp b lq np lt nq lw nr ma ns me nt mi nl nm nn no bi translated">多级遗传</li><li id="a290" class="ng nh iq lp b lq np lt nq lw nr ma ns me nt mi nl nm nn no bi translated">多重遗传</li><li id="be9a" class="ng nh iq lp b lq np lt nq lw nr ma ns me nt mi nl nm nn no bi translated">分层继承</li><li id="7aed" class="ng nh iq lp b lq np lt nq lw nr ma ns me nt mi nl nm nn no bi translated">混合遗传</li></ol><h2 id="02e7" class="ow mk iq bd le ox oy dn mo oz pa dp ms lw pb pc mu ma pd pe mw me pf pg my iw bi translated">1.单一继承:</h2><p id="3c4f" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">一个类扩展了另一个类。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/0c651f02a846cd2f1e07ef986e1be125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*HqcthYAYEyyqcbLPx_TtHQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">单一遗传</figcaption></figure><h2 id="4e91" class="ow mk iq bd le ox oy dn mo oz pa dp ms lw pb pc mu ma pd pe mw me pf pg my iw bi translated">2.多级继承:</h2><p id="2a66" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">在这种类型的继承中，B类扩展A类，C类扩展B类。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pl"><img src="../Images/ebac185cae54fd4ac13fd31e6fa82d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjriFcJO7o4ene5DBmwAXQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">多级遗传</figcaption></figure><h2 id="efff" class="ow mk iq bd le ox oy dn mo oz pa dp ms lw pb pc mu ma pd pe mw me pf pg my iw bi translated">3.多重继承:</h2><p id="9483" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">在这种类型的继承中，一个类A扩展了两个类B和c。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/f4fc1be2d45315140ee8a15818f9c7b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*XfOe_xwHjA1TTkdyuiJGfQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">多重遗传</figcaption></figure><blockquote class="oa"><p id="e257" class="ob oc iq bd od oe of og oh oi oj mi dk translated">注意:Java不支持多重继承。</p></blockquote><h2 id="9347" class="ow mk iq bd le ox pn dn mo oz po dp ms lw pp pc mu ma pq pe mw me pr pg my iw bi translated">4.分层继承:</h2><p id="6933" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">在这种类型中，多个类扩展同一个父类。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ps"><img src="../Images/e049b7b31959cda51971b359e4b955cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*0DqVUjBMYUg7R-sl1DuX2g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">分层继承</figcaption></figure><h2 id="829d" class="ow mk iq bd le ox oy dn mo oz pa dp ms lw pb pc mu ma pd pe mw me pf pg my iw bi translated">5.混合遗传:</h2><p id="092b" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">将上述两种或两种以上的继承结合起来就是混合继承。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pt"><img src="../Images/d8a6f631890d5f0f8cd1760d75fe406b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umbXXY1VwVSm_mfo8fFv0A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">混合遗传</figcaption></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="066d" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在我们来了解一下构图。</p><h1 id="d0a3" class="mj mk iq bd le ml pu mn mo mp pv mr ms kf pw kg mu ki px kj mw kl py km my mz bi translated">Java中的Composition是什么？</h1><p id="6233" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">组合是Java中的另一个OOP特性(如<strong class="lp ja">继承</strong>、<strong class="lp ja">多态</strong>、<strong class="lp ja">封装</strong>和<strong class="lp ja">抽象)</strong>，类 之间存在<strong class="lp ja"/><strong class="lp ja"><em class="nf">【HAS-A】关系。</em></strong></p><p id="d2a1" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">比方说，我们有两类汽车<strong class="lp ja"> </strong>和发动机。然后在汽车和引擎类之间有一个关系<strong class="lp ja">‘HAS-A’</strong>，因此我们可以说<strong class="lp ja"> <em class="nf">汽车有一个引擎</em> </strong>。</p><blockquote class="nu nv nw"><p id="a647" class="ln lo nf lp b lq lr ka ls lt lu kd lv nx lx ly lz ny mb mc md nz mf mg mh mi ij bi translated">所以会有两个类<strong class="lp ja">汽车</strong>和<strong class="lp ja">引擎</strong>和<strong class="lp ja">汽车</strong>类会有一个<strong class="lp ja">引擎</strong>类的实例变量。</p></blockquote><p id="1867" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们看一个程序来理解这个概念。</p><p id="c0eb" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">发动机等级:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">引擎等级</figcaption></figure><p id="ca8e" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">汽车等级:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">汽车等级</figcaption></figure><p id="c0cc" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">主as驱动程序类:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="68eb" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">输出:</p><pre class="kp kq kr ks gt ok ol om bn on oo bi"><span id="a805" class="op mk iq ol b be oq or l os ot">Car Object is : Car{brandName=’Honda’, color=’Silver’, engine=Engine{fuelType=’Petrol’, cc=1498, maxTorque=98, maxPower=200}, model=’2020'}</span></pre><blockquote class="oa"><p id="3633" class="ob oc iq bd od oe of og oh oi oj mi dk translated">使用组合的好处是我们可以控制Car类中实例变量“engine”的可见性/可访问性。</p></blockquote><blockquote class="nu nv nw"><p id="342b" class="ln lo nf lp b lq pz ka ls lt qa kd lv nx qb ly lz ny qc mc md nz qd mg mh mi ij bi translated">注意<strong class="lp ja">继承和组合都提高了代码的可重用性。</strong></p></blockquote></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="1e1c" class="mj mk iq bd le ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">继承和作曲有什么区别？</h1><ol class=""><li id="6747" class="ng nh iq lp b lq na lt nb lw ph ma pi me pj mi nl nm nn no bi translated"><strong class="lp ja">继承是子类和父类之间的“是-A”关系</strong>，而<strong class="lp ja">组合是两个类之间的“有-A”关系</strong>。</li></ol><p id="5ffe" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">2.在继承的情况下，子类可以覆盖父类实例方法，但是这不适用于组合的情况。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="9cb6" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="nf">本文到此为止。希望你喜欢这篇文章。</em></p><h1 id="ebcb" class="mj mk iq bd le ml pu mn mo mp pv mr ms kf pw kg mu ki px kj mw kl py km my mz bi translated">类似内容可以关注<a class="qe qf ep" href="https://medium.com/u/2c3b611409dc?source=post_page-----37b8fe54cf80--------------------------------" rel="noopener" target="_blank">维克拉姆古普塔</a>。</h1></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="a594" class="mj mk iq bd le ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated">分级编码</h1><p id="9046" class="pw-post-body-paragraph ln lo iq lp b lq na ka ls lt nb kd lv lw nc ly lz ma nd mc md me ne mg mh mi ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="acd3" class="ng nh iq lp b lq lr lt lu lw ni ma nj me nk mi qg nm nn no bi translated">👏为故事鼓掌，跟着作者走👉维克拉姆·古普塔</li><li id="17fe" class="ng nh iq lp b lq np lt nq lw nr ma ns me nt mi qg nm nn no bi translated">📰查看更多内容请参见<a class="ae lf" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a></li><li id="0af0" class="ng nh iq lp b lq np lt nq lw nr ma ns me nt mi qg nm nn no bi translated">🔔关注我们:<a class="ae lf" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae lf" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lf" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="f05b" class="pw-post-body-paragraph ln lo iq lp b lq lr ka ls lt lu kd lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">🚀👉<a class="ae lf" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ja">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>