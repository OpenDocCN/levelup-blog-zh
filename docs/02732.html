<html>
<head>
<title>Using the React State Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用反应状态挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-the-react-state-hook-b54b54296f12?source=collection_archive---------6-----------------------#2020-04-01">https://levelup.gitconnected.com/using-the-react-state-hook-b54b54296f12?source=collection_archive---------6-----------------------#2020-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/865c838408cfc8a46b6429476bb48194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8og8ThP3N89KAHDn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">斯科特·沃尔什在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7a50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="c9e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解如何使用状态挂钩在函数组件中保持动态状态。</p><h1 id="7069" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用状态挂钩</h1><p id="3b0a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">React.useState</code>方法创建一个状态，并用相应的函数来改变状态。</p><p id="16ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来为我们的应用程序添加一个挂钩:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f82a" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="20a4" class="mt lf it mk b gy my mv l mw mx">function App() {<br/>  const [count, setCount] = React.useState(0);</span><span id="bfbf" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Count {count}&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="64b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个默认为0的<code class="fe mh mi mj mk b">React.useState</code>钩子。它返回一个包含状态的数组，我们称之为<code class="fe mh mi mj mk b">count</code>，以及一个设置状态的函数，我们称之为<code class="fe mh mi mj mk b">setCount</code>。</p><p id="1826" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在按钮的<code class="fe mh mi mj mk b">onClick</code>处理程序中，我们可以通过<code class="fe mh mi mj mk b">setCount</code>函数来更新计数。</p><h1 id="95d8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">等价类示例</h1><p id="86a8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">上面的示例与下面的类相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e87d" class="mt lf it mk b gy mu mv l mw mx">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      count: 0<br/>    };<br/>  }</span><span id="b1a0" class="mt lf it mk b gy my mv l mw mx">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;<br/>          Count: {this.state.count}<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="f9ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在构造函数中用<code class="fe mh mi mj mk b">count</code> 0初始化了<code class="fe mh mi mj mk b">this.state</code>。然后在<code class="fe mh mi mj mk b">button</code>中，我们传入一个click事件处理程序，它调用<code class="fe mh mi mj mk b">setState</code>来更新<code class="fe mh mi mj mk b">count</code>状态，使其增加1。</p><p id="42a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe mh mi mj mk b">this.setState({ count: this.state.count + 1 })</code>与<code class="fe mh mi mj mk b">setCount(count + 1)</code>相同，<code class="fe mh mi mj mk b">count</code>与<code class="fe mh mi mj mk b">this.state.count</code>相同。</p><h1 id="b936" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">挂钩和功能组件</h1><p id="e73e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">功能组件看起来像:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="23cc" class="mt lf it mk b gy mu mv l mw mx">const App = props =&gt; &lt;p&gt;foo&lt;/p&gt;;</span></pre><p id="6b88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5830" class="mt lf it mk b gy mu mv l mw mx">function App(props) {<br/>  return &lt;p&gt;foo&lt;/p&gt;;<br/>}</span></pre><p id="9f61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们以前被称为无状态组件。但是，现在React有了钩子，就可以保持自己的状态了。因此，它们应该被称为功能组件。</p><h1 id="54fa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是钩子？</h1><p id="13c8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">钩子是一个特殊的函数，它可以让我们钩住React特性。<code class="fe mh mi mj mk b">useState</code>在上面的例子中是一个钩子，它让我们将反应状态添加到函数组件中。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/037755169628909963f2630b26a53747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v8aQGiyyGNZGs6KX"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">汤米·利斯宾在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="46a5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">声明状态变量</h1><p id="7c5a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">useState</code>声明一个状态变量。在上面的例子中，我们有一个名为<code class="fe mh mi mj mk b">count</code>的变量，但是我们也可以用其他的名字来称呼它。</p><p id="5034" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">useState</code>和<code class="fe mh mi mj mk b">this.state</code>有着相同的能力，我们在一个班里就有。</p><p id="2c07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当函数存在时，变量消失，但是状态变量被React保存。</p><p id="75a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">useState</code>的唯一论据是初始状态。与类不同，状态不必是对象。</p><p id="d0a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用任何类型的数据作为初始状态。</p><p id="68a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想在state中存储多个值，那么我们将为每种数据调用<code class="fe mh mi mj mk b">useState</code>。</p><p id="ee8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">useState</code>总是给我们当前状态。这不仅仅是为了创造初始状态。</p><h1 id="a4ae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">阅读状态</h1><p id="6d16" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们的例子中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1da9" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="642e" class="mt lf it mk b gy my mv l mw mx">function App() {<br/>  const [count, setCount] = React.useState(0);</span><span id="5697" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Count {count}&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="4d31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe mh mi mj mk b">useState</code>返回的<code class="fe mh mi mj mk b">count</code>中获取当前状态。</p><h1 id="2e55" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更新状态</h1><p id="300e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不像在类组件中那样调用<code class="fe mh mi mj mk b">this.setState</code>，而是直接调用<code class="fe mh mi mj mk b">setCount</code>函数。</p><p id="8255" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不必担心<code class="fe mh mi mj mk b">this</code>的值。</p><h1 id="cc35" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">方括号是什么意思？</h1><p id="fe98" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">中的方括号:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d2b9" class="mt lf it mk b gy mu mv l mw mx">const [count, setCount] = React.useState(0);</span></pre><p id="d91e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是析构赋值操作，这意味着数组中的值根据位置被赋给变量。</p><p id="9c5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个元素赋给第一个变量，第二个元素赋给第二个变量，依此类推。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fa2f" class="mt lf it mk b gy mu mv l mw mx">const [count, setCount] = React.useState(0);</span></pre><p id="b001" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以下内容相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="56e9" class="mt lf it mk b gy mu mv l mw mx">const countState = React.useState(0);<br/>const count = countState[0];<br/>const setCount = countState[1];</span></pre><h1 id="8e66" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用多个状态变量</h1><p id="4a7b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们需要使用多个状态变量时，我们会多次调用<code class="fe mh mi mj mk b">useState</code>。</p><p id="acc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1519" class="mt lf it mk b gy mu mv l mw mx">function App() {<br/>  const [count, setCount] = React.useState(0);<br/>  const [foo] = React.useState({ text: "bar" });<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Count {count}&lt;/button&gt;<br/>      &lt;p&gt;{foo.text}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );</span></pre><p id="4554" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们调用了两次<code class="fe mh mi mj mk b">useState</code>来创建两个状态<code class="fe mh mi mj mk b">count</code>和<code class="fe mh mi mj mk b">foo</code>。</p><p id="3d4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">状态可以有对象值，所以我们不用创建太多的状态。</p><h1 id="02b2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="68db" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">useState</code>钩子来获取和设置功能组件中的动态状态。</p><p id="3388" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回当前状态和一个函数来更新数组中的状态。</p><p id="2f04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以直接使用它们来显示数据，并调用返回的函数来更新状态。</p></div></div>    
</body>
</html>