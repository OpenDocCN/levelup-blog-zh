<html>
<head>
<title>Variables and Types in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅中的变量和类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/variables-and-types-in-julia-750b057c4537?source=collection_archive---------4-----------------------#2020-09-03">https://levelup.gitconnected.com/variables-and-types-in-julia-750b057c4537?source=collection_archive---------4-----------------------#2020-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="eb95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">朱莉娅的变量和类型简介。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e6033961983ff95aac8c24d5e347d7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04Xw1LGYEXX8trDNc9kS0g.png"/></div></div></figure><p id="bb5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是Julia教程(关于Julia的一系列教程)的第4部分。如果你不熟悉茱莉亚的《REPL》，请浏览<a class="ae la" href="https://medium.com/@adarshms/read-eval-print-loop-in-julia-24a4192b999b" rel="noopener">第三部</a>以便更好地理解。</p><p id="1941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不熟悉Julia并想开始使用它，请随意查看完整的系列—</p><div class="lb lc gp gr ld le"><a href="https://medium.com/@adarshms/julia-tutorials-fa6b2b0e5498" rel="noopener follow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">朱莉娅教程</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">关于朱莉娅的一系列教程。</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">medium.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls ky le"/></div></div></a></div></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><blockquote class="ma mb mc"><p id="4fab" class="jq jr md js b jt ju jv jw jx jy jz ka me kc kd ke mf kg kh ki mg kk kl km kn im bi translated">注意:使用Julia的REPL可以快速理解本教程中的代码</p></blockquote><h1 id="f1c7" class="mh mi it bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">朱莉娅中的变量</h1><p id="0142" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">像其他编程语言一样，变量是计算机内存中由用户命名的位置，用来保存与程序相关的数据。</p><p id="8393" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">在Julia中创建变量</strong> <br/>在Julia中，变量名<strong class="js iu">区分大小写</strong>并且还支持多种unicode字符(UTF 8编码)。变量可以通过使用传统的赋值操作符“=”来赋值/创建。</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="e67d" class="np mi it nl b gy nq nr l ns nt">test_string = "Julia variable"<br/>pi_val = 3.14<br/>count = 35<br/>❄ = -12</span></pre><p id="1093" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上述示例中，创建了3个变量，即“test_string”、“pi_val”和“count”，并为其分配了一些值(数据类型)。</p><p id="1591" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">变量到变量的赋值<br/> </strong>一个变量中的值可以通过简单地遵循<code class="fe nu nv nw nl b">n</code>等于<code class="fe nu nv nw nl b">m</code>约定被赋值给另一个变量</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="5fbc" class="np mi it nl b gy nq nr l ns nt">m = 10<br/>n = m      # value of m will be copied to n</span></pre><p id="274e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">变量的命名约定<br/> </strong>虽然在命名变量方面没有太多限制，但还是推荐一些样式约定。</p><ul class=""><li id="efd7" class="nx ny it js b jt ju jx jy kb nz kf oa kj ob kn oc od oe of bi translated">首选小写名称</li><li id="8c9c" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated">变量名不能以数字或感叹号开头。</li><li id="48b2" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated">虽然不太喜欢在名称中使用“_ ”,但是可以使用“<strong class="js iu"> snake_cases </strong>”来提高长<strong class="js iu">函数</strong>和<strong class="js iu">变量</strong>名称的可读性。</li><li id="617a" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated"><strong class="js iu">山茶花</strong>优先用于命名<strong class="js iu">类型</strong>和<strong class="js iu">模块</strong></li><li id="c365" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated">为赋值运算符“=”提供前导和尾随空格</li></ul></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="207e" class="mh mi it bd mj mk ol mm mn mo om mq mr ms on mu mv mw oo my mz na op nc nd ne bi translated">朱莉娅的类型</h1><p id="5c9a" class="pw-post-body-paragraph jq jr it js b jt nf jv jw jx ng jz ka kb nh kd ke kf ni kh ki kj nj kl km kn im bi translated">类型约束表达式(如变量或函数)可能采用的值。</p><p id="92d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型可以大致分为2类:</p><ul class=""><li id="7cf2" class="nx ny it js b jt ju jx jy kb nz kf oa kj ob kn oc od oe of bi translated"><strong class="js iu">静态类型</strong>——每个可执行程序表达式在执行前都被定义了一个类型</li><li id="ec98" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated"><strong class="js iu">动态类型</strong> -编译器必须在代码编译时决定值的类型</li></ul><p id="2990" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Julia的类型系统主要是动态的，并通过在需要的地方指定类型的能力得到了增强，这意味着没有必要告诉Julia某个特定值是什么类型，除非您想这样做。</p><p id="868d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于Julia的类型层次结构，类型可以是<strong class="js iu"> <em class="md">抽象</em> </strong>或<strong class="js iu"> <em class="md">具体</em> </strong> <em class="md">。</em></p><ul class=""><li id="047a" class="nx ny it js b jt ju jx jy kb nz kf oa kj ob kn oc od oe of bi translated"><strong class="js iu">抽象类型</strong>——一种类型，仅仅用来作为其他类型的超类型，而不是特定对象的类型。也就是说，抽象类型可以分为子类型。一些例子是:<code class="fe nu nv nw nl b">Number</code>、<code class="fe nu nv nw nl b">String</code>、<code class="fe nu nv nw nl b">Bool</code>、<code class="fe nu nv nw nl b">Rational</code>、<em class="md">等等……</em></li><li id="c0bc" class="nx ny it js b jt og jx oh kb oi kf oj kj ok kn oc od oe of bi translated"><strong class="js iu">具体类型</strong>——这些是实际对象的类型。它们总是抽象类型的子类型，不允许有任何子类型。</li></ul><p id="806c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">具体类型</strong>又可分为两种，<strong class="js iu"><em class="md"/></strong>和<strong class="js iu"> <em class="md">复合。</em>T29】</strong></p><p id="5222" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">基元类型</strong>-<strong class="js iu"/>Julia中的基元类型是具体类型，其值以位的形式表示。基本类型的一些例子有:<code class="fe nu nv nw nl b">Int8</code>、<code class="fe nu nv nw nl b">Int16</code>、<code class="fe nu nv nw nl b">Int64</code>、<code class="fe nu nv nw nl b">Float16</code>、<code class="fe nu nv nw nl b">Float32</code>、<code class="fe nu nv nw nl b">String</code>、<em class="md">等……</em></p><p id="b490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与大多数语言不同，使用Julia你可以声明你自己的基本类型。</p><p id="ef37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">标准基本类型定义为:</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="2966" class="np mi it nl b gy nq nr l ns nt">primitive type Float64 &lt;: AbstractFloat 64 end<br/>primitive type Bool &lt;: Integer 8 end<br/>primitive type Char &lt;: AbstractChar 32 end<br/>primitive type Int64 &lt;: Signed 64 end</span></pre><p id="c1c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，我们可以使用以下语法定义自己的原语:</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="51c9" class="np mi it nl b gy nq nr l ns nt">primitive type Byte 8 end    # Define the primitive Byte<br/>Byte(val::UInt8) = reinterpret(Byte, val)<br/>b = Byte(0x02)   # Assign a byte value to b</span></pre><p id="8416" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，<code class="fe nu nv nw nl b">reinterpret</code>用于将8位无符号整数(UInt8)赋给字节。</p><blockquote class="ma mb mc"><p id="9e82" class="jq jr md js b jt ju jv jw jx jy jz ka me kc kd ke mf kg kh ki mg kk kl km kn im bi translated"><strong class="js iu">注意</strong>:你可能不知道<code class="fe nu nv nw nl b">::</code>操作符是干什么用的，别担心，后续教程会解释的</p></blockquote><p id="bfa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">复合类型</strong>-Julia中的复合类型是命名字段的集合，它们可以被单独视为特定类型的单个值。复合类型可以通过使用<strong class="js iu"> struct </strong>关键字来声明。</p><p id="77c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">语法:</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="6114" class="np mi it nl b gy nq nr l ns nt">struct Foo<br/>    Field1::Type<br/>    Field2::Type<br/>end</span></pre><p id="465a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="f63d" class="np mi it nl b gy nq nr l ns nt"># Define the struct<br/>struct Greet<br/>    x<br/>    y::String<br/>end</span><span id="5ab4" class="np mi it nl b gy oq nr l ns nt"><br/># Creating object with constructor<br/>greet1 =<!-- --> <!-- -->Greet("Hello", "World")</span></pre><p id="dc2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以使用点符号来访问复合对象的值，</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="69df" class="np mi it nl b gy nq nr l ns nt">greet1.x</span><span id="2091" class="np mi it nl b gy oq nr l ns nt">Output -&gt; "Hello"</span></pre><p id="4f13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于复合类型的一个有趣的事情是，它们在本质上是<strong class="js iu">不可变的</strong>，也就是说，我们不能在实例化对象之后改变值。幸运的是，Julia还提供了与不可变复合类型语法相似的<strong class="js iu"><em class="md"/></strong>，唯一的区别是<code class="fe nu nv nw nl b">struct</code>前面的<code class="fe nu nv nw nl b">mutable</code>关键字的用法。</p><p id="cb04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">语法:</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="be2e" class="np mi it nl b gy nq nr l ns nt">mutable struct Foo<br/>    Field1::Type<br/>    Field2::Type<br/>end</span></pre><p id="c302" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例:</p><pre class="kp kq kr ks gt nk nl nm nn aw no bi"><span id="7707" class="np mi it nl b gy nq nr l ns nt"># Define the mutable struct<br/>mutable struct Num<br/>    x::Float64<br/>    y::Float64<br/>end</span><span id="ac99" class="np mi it nl b gy oq nr l ns nt"># Creating object with constructor<br/>greet1 =<!-- --> <!-- -->Num(1, 5.3)</span><span id="0197" class="np mi it nl b gy oq nr l ns nt"># Update a value<br/>greet1.x = 4.5</span></pre><p id="f76f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在实例化后更改这些值。然而，这些值必须符合类型的定义，因为它们必须可转换为指定的类型(在我们的例子中是<code class="fe nu nv nw nl b">Float64</code>)。例如，<code class="fe nu nv nw nl b">Int64</code>输入是可以接受的，因为您可以很容易地将<code class="fe nu nv nw nl b">Int64</code>转换成<code class="fe nu nv nw nl b">Float64</code>。另一方面，一个字符串不能工作，因为你不能把它转换成<code class="fe nu nv nw nl b">Float64</code>。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="ffe1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来:深入探究朱莉娅的类型</p><div class="lb lc gp gr ld le"><a href="https://medium.com/@adarshms/dive-deep-into-julia-types-251d51f01c0" rel="noopener follow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd iu gy z fp lj fr fs lk fu fw is bi translated">深入探究朱莉娅的类型</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">了解一些内置运算符、文字和联合</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">medium.com</p></div></div><div class="ln l"><div class="or l lp lq lr ln ls ky le"/></div></div></a></div></div></div>    
</body>
</html>