<html>
<head>
<title>Possible Values For Antiforgery Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防伪标记的可能值</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/possible-values-for-antiforgery-tokens-d1adecb93db5?source=collection_archive---------21-----------------------#2021-01-26">https://levelup.gitconnected.com/possible-values-for-antiforgery-tokens-d1adecb93db5?source=collection_archive---------21-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="238d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究防伪标记的内部工作原理。NET 5.0</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6195d2929f9b2c50e64b9d4704372d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sI8sQ9C-zUHvf5vH"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aaronburden" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae ky" href="https://unsplash.com/photos/RgTI2KaQ5N4" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="77b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将谈论什么样的价值防伪令牌可以在。NET 5.0。</p><p id="e4c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该已经对防伪标记以及如何在中使用它们有了基本的了解。NET 5.0。</p><h2 id="b7e9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">前26个字符</h2><p id="794b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你读过我的第一篇关于防伪令牌的文章，你会知道在组成令牌的155个字符中，前5个字符总是相同的:</p><p id="5352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">CfDJ8</code></p><p id="cfc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为在进行base64编码之前，这些硬编码的八个字节总是被写入数组的开头:</p><p id="700d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">0x09F0C9F0</code></p><p id="41bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的应用程序使用的加密密钥ID，接下来的21个字符对于您的应用程序总是相同的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/95464f8f1e833069042a7d06db8e1821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*kDAAVY4o9fThQ-QJIekpnw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">前26个字符总是相同的</figcaption></figure><h2 id="9425" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">中间128个字符</h2><p id="9308" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">由于令牌只是一个base64 URL编码版本的加密随机生成的字节数组，因此中间128个字符的<a class="ae ky" href="https://stackoverflow.com/a/6102233/2063755" rel="noopener ugc nofollow" target="_blank">可能值</a>是这64个字符:</p><ul class=""><li id="5e4d" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><code class="fe mt mu mv mw b">A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z</code></li><li id="9085" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe mt mu mv mw b">a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z</code></li><li id="606a" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe mt mu mv mw b">0, 1, 2, 3, 4, 5, 6, 7, 8, 9</code></li><li id="5b37" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe mt mu mv mw b">-</code> ( <em class="nm">减</em>)和<code class="fe mt mu mv mw b">_</code> ( <em class="nm">下划线</em>)</li></ul><h2 id="ef55" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">最后一个字符</h2><p id="b6f1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您不断地重新加载使用防伪标记的页面，您会注意到每次最后一个字符都是这16个值中的一个:</p><p id="e414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">A, E, I, M, Q, U, Y, c, g, k, o, s, w, 0, 4, 8</code></p><p id="9067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这是为什么，让我们看一下base64 <a class="ae ky" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank">图表</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7ad424bc598cc188d8f004a3f393100b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*FjurNFlHNY12LpHxQFvO7g.png"/></div></figure><h2 id="23cf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">填充零</h2><p id="3485" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">注意最后一个字符的16个可能值，所有的<strong class="lb iu">在二进制编码中都以两个零</strong>结尾？</p><p id="329d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很大的暗示，暗示了幕后发生了什么。</p><p id="bfe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一些代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/ca2631a40b4b3c3b37653855ed467edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kuWqdiSVJzcZypeaPQJcw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">DefaultAntiforgeryTokenSerializer。序列化()</figcaption></figure><p id="e8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在<a class="ae ky" href="https://github.com/aspnet/Antiforgery/blob/master/src/Microsoft.AspNetCore.Antiforgery/Internal/DefaultAntiforgeryTokenSerializer.cs#L173" rel="noopener ugc nofollow" target="_blank">DefaultAntiforgeryTokenSerializer中生成的结果字节数组。Serialize() </a>方法来自ASP.NET核心源代码。</p><p id="9b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个字节数组是加密随机生成的字节数组的结果。为简单起见，让我们集中讨论最后两个字节:</p><p id="897d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">0x57, 0x4b</code></p><p id="9b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在二进制中，它们是:</p><p id="4e89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">01010111</code>和<code class="fe mt mu mv mw b">01001011</code></p><h2 id="5acd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Base64编码</h2><p id="9f7f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当您进行base64编码时，您将字节分成六位一组。对于上面的两个字节，这变成:</p><p id="da62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">010101 110100 1011</code></p><p id="18f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意到最后没有足够的位来组成一组六位吗？</p><p id="18f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长度* 8不是6和8的公倍数的任何字节数组，最后的余数都小于6位。</p><p id="f674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为前面描述的字节数组有116个值，也就是928位，还有<code class="fe mt mu mv mw b">928 modulo 6 = 4.</code></p><p id="08fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在base64 URL编码过程中，总会有四个剩余位<strong class="lb iu">。</strong></p><p id="c162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些接近928的六和八的<a class="ae ky" href="https://www.calculatorsoup.com/calculators/math/multiples.php" rel="noopener ugc nofollow" target="_blank">公倍数</a>有:</p><p id="8db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">912, 936, 960</code></p><p id="c42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果以位为单位的字节数组的长度是这三个值中的一个，则不会有剩余的位，最后一个字符将是64个值中的一个，而不是16个值中的一个。</p><p id="4a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为总有四位剩余，所以它们与两个零组合在一起形成一个六位值。</p><p id="846b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么最后一个字符总是这16个值中的一个。</p><h2 id="48bb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">不同的值将被解释为相同的值</h2><p id="4e06" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当防伪标记被验证时，该过程被逆转。字符串中的字符被转换为六位编码。然后，它们被转换成八位组，形成加密数组。</p><p id="515e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于最后两个零在转换为八位组时会被截断，因此实际上可以用base64表中其他三个连续值中的任何一个来替换防伪标记中的最后一个字符。</p><p id="e3cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，以下标记末尾的<code class="fe mt mu mv mw b">w</code>可以替换为<code class="fe mt mu mv mw b">x</code>、<code class="fe mt mu mv mw b">y</code>或<code class="fe mt mu mv mw b">z</code>，应用程序不会知道任何不同:</p><p id="45e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">CfDJ8JeOl95vyt5Fl-pHZGf77Sm3JmKSHdO1PQpV74QafJuJKW3y-uSagKNSpzLHS4SBLkNoOov2RrbaJow-61gPO3CoQllu1D9qeqWIDciJzPXJGakA-boNPsC_9H7DgtClsFHz6lS-Qd9qFeQs3vskEsw</code></p><h2 id="d295" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">仔细看看第六个字符</h2><p id="af72" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在您已经了解了字节是如何转换为base64的，让我们回过头来更仔细地看看第6个字符:</p><p id="c2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">J</code></p><p id="cbbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在互联网上测试许多不同的应用程序。NET 5.0防伪标记，您会注意到该字符始终是以下16个字符之一:</p><p id="08e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P</code></p><p id="0a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为“魔头”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/4bfde0679ffccf6e2801eaab0f5c929c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTC_mNGHX96716wP9SKV2w.png"/></div></div></figure><p id="5b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该报头是四个字节，当转换成六位组时，看起来像这样:</p><p id="a045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">000010 011111 000011 001001 111100 00</code></p><p id="d561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个与最后一个字符类似的情况。我们还剩两个零。</p><p id="a233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后两个零与加密密钥ID ( <code class="fe mt mu mv mw b">defaultId</code>)组合在一起，这就是为什么第6个字符总是来自base64表中第一列，该列的字符以两个零开头。</p><h2 id="6511" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">你能有多少独特的价值观？</h2><p id="bc3c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">前五个字符可以忽略，因为它们不会改变。</p><p id="6669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第六个字符可以是16个值之一。</p><p id="f707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的148个字符可以是64个值中的任何一个。</p><p id="4bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个字符只能是16个值中的一个。</p><p id="123b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以拥有以下可能数量的值:</p><p id="1cd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">16 * 64¹⁴⁸ * 16 = 5.282945 * 10²⁶⁹</p><p id="987a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">那就是</strong> 5282945 <strong class="lb iu">后面有263个零，或者:</strong></p><p id="24cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">528294500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</code></p><p id="4168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您知道<strong class="lb iu">加密密钥id </strong>，那么前26个字符将是相同的，您只需尝试以下数量的组合:</p><p id="ce9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">64个⁸ * 16 = 2.484029 * 10个组合。</p><p id="b4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那就是2484029后面有226个零。</p><p id="b484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常大的数字。很明显，了解内部工作原理可以帮助你最小化要尝试的唯一值的数量，但是仍然要花几个世纪来强力处理这么大的字符串。</p><h2 id="671a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="48b4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我希望您喜欢了解防伪标记如何在幕后工作，以及它们可能具有的不同价值。</p><p id="9079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在很大程度上是一个实现细节，然而理解这些细节真的很有趣，并且当涉及到<a class="ae ky" href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/" rel="noopener ugc nofollow" target="_blank">泄漏抽象</a>时会有所帮助。</p></div></div>    
</body>
</html>