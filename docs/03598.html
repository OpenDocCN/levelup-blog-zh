<html>
<head>
<title>Decoupling big React projects for beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为初学者解耦大型React项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/decoupling-big-react-projects-for-beginners-bd15000f1af5?source=collection_archive---------12-----------------------#2020-05-18">https://levelup.gitconnected.com/decoupling-big-react-projects-for-beginners-bd15000f1af5?source=collection_archive---------12-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="bc34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我想分享我如何从一个大项目中分离出一些重复的逻辑，如何托管私有npm模块，如何创建一个合适的持续集成以及这样做可能会遇到的所有问题。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="0671" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几个月前我开始了一份令人兴奋的新工作，产品非常棒，非常有趣，是每个开发人员的梦想——我们建立一个物联网平台。在我参与之前，该项目是一个客户可能会感兴趣的概念的生产证明。他们做到了🎉。因此，我公司里聪明的业务人员想:如果这个产品在一个物联网设备上卖得很好，为什么不为其他设备制作多个实例呢？</p><p id="f17d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我来了，我的工作是尽可能多地分离可重用项目中的公共逻辑。我有两项任务:</p><ol class=""><li id="63b0" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">分离所有的用户界面组件，并用我们公司的颜色重新命名</li><li id="5549" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">将这个完全独立的项目分离出来，这个项目中有复杂的业务逻辑。它有Redux和中间件，但也存在于我们将拥有的每个其他项目中。它被用作一个插件。</li></ol><p id="a9f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的小项目将组装Voltron:)</p><p id="c19f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以经过简短的讨论，我们决定创建我们自己的本地托管的npm模块，并将它们安装在我们未来的项目中。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/f2ab7e9e9dff364b1396bd2e4ead0a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aq_hL7jnr3aZo1DLn1LIpQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">我们的目标项目结构。</figcaption></figure><h1 id="0508" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">解耦UI项目</h1><p id="ad6e" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">对于这个项目，我决定用Storybook进行开发。Storybook是一个很棒的UI元素界面。它适合于设计驱动的开发，并且符合我们正在构建的产品的规格。</p><p id="34e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">网上和媒体上有很多关于故事书是什么以及为什么它是一个很棒的开发工具的信息，所以我不会花时间去推销它。对不熟悉它的人来说，一个非常简单的介绍是:Storybook是一个组件风格的游乐场。它展示了组件及其在隔离环境中的行为。</p><p id="bac8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从这个项目中得到的重要的东西是:</p><ol class=""><li id="61a8" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">有一个专门的空间来查看我们的组件(Storybook的主要目标)</li><li id="1abd" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">有一个简单的方法来构建这些组件，这样我们就可以将它们导入到我们的主项目中。</li></ol><p id="43c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将继续讨论如何安装Storybook和编写故事，所以如果你知道所有这些，或者你只是对如何创建一个npm模块感兴趣，就跳过这一节。结尾将用三个点(…)标记。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="a79f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说到这里，决定如何开始你的故事书是很重要的。当你打开它的文档时，你会看到一个选项:用create-react-app启动它。但是你还有一个:手动配置。我更喜欢后者，因为我想尽可能多地控制这个项目。我对这个过程进行了充分的思考，使自己形成了“利弊”表:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi nd"><img src="../Images/1d53ca7720a0f1be65dff98159ad310d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zL1VriJxiVrM6Q2CZpTeDw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">我对创建React应用程序与手动配置的看法。</figcaption></figure><p id="5373" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你决定使用<strong class="js iu"> Create React App </strong>解决方案，那就再简单不过了。只需输入您的终端:</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="1950" class="nj ma it nf b gy nk nl l nm nn">cd my-library-directory<br/>npx create-react-app my-library-name<br/>npx -p @storybook/cli sb init</span></pre><p id="ba8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Storybook是智能的，例如，它会检测CRA是否被使用，并将安装在react-scripts给你的结构之上。项目结构将如下所示:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi no"><img src="../Images/5445128c3d7e784b2b98dadcdb6bc163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRU_63v_CRhMs9IUArUuKg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">带故事书的CRA</figcaption></figure><p id="0d46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将获得react脚本的所有好处，如测试脚本、配置等等。</p><p id="25dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">手动</strong>配置并不难，虽然。这就像跑步一样简单:</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="afc7" class="nj ma it nf b gy nk nl l nm nn">cd my-library-directory<br/>npm init // follow the prompt to set up a new package.json</span><span id="1c37" class="nj ma it nf b gy np nl l nm nn">npm i @storybook/react -D // adds the react instance of storybook</span><span id="76b4" class="nj ma it nf b gy np nl l nm nn">npm i react react-dom -D // add the react dependencies</span><span id="1d62" class="nj ma it nf b gy np nl l nm nn">npm i babel-loader @babel/core -D // add babel as dependency</span></pre><p id="a7d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们需要在我们的package.json中添加一个启动脚本</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="a0f9" class="nj ma it nf b gy nk nl l nm nn">{<br/>  "scripts: {<br/>    "storybook": "start-storybook"<br/>  }<br/>}</span></pre><p id="bb2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要在。故事书文件夹。它用于配置，可以告诉storybook如何加载它的故事。我更喜欢下面的脚本，因为它允许我有一个清晰的组件结构:</p><p id="6217" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，安装一个打字系统，linter，测试库。</p><h2 id="f571" class="nj ma it bd mb nq nr dn mf ns nt dp mj kb nu nv mn kf nw nx mr kj ny nz mv oa bi translated">写故事</h2><p id="b77b" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">故事书建议保留这个文件夹配置:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ob"><img src="../Images/134b0f773c904a70c087e8f12b00e295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4JgKdHSedV8ra4u_"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">故事书推荐的文件夹配置</figcaption></figure><p id="8f02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我同意一个例外，即当你创建一个库时，你应该把你的组件保存在src文件夹中。我也倾向于在一个组件中包含几个文件:</p><ol class=""><li id="bfa6" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">index . js——当你创建一个库时，在每一层导出你的组件是一个非常好的实践</li><li id="964f" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">风格。[js/css/scss ] —取决于样式库首选项</li><li id="aed8" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">component.spec.js —使用storyshots进行测试。快照测试的绝佳工具。</li></ol><p id="38e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还在src/components级别导出我的组件，这样以后导入就很容易了。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="6ccc" class="lz ma it bd mb mc oc me mf mg od mi mj mk oe mm mn mo of mq mr ms og mu mv mw bi translated">构建和部署库</h1><h2 id="2645" class="nj ma it bd mb nq nr dn mf ns nt dp mj kb nu nv mn kf nw nx mr kj ny nz mv oa bi translated">建设</h2><p id="98c9" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">当最困难的部分结束时:编码所有的组件，使它们看起来很好，由设计师和PM测试和验证，是时候创建我们的本地npm模块并开始使用它们了。</p><p id="dfb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我注意到，对我来说，构建库就像跑步一样简单:</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="c554" class="nj ma it nf b gy nk nl l nm nn">"build": "babel src -d lib --ignore src/**/*.story.jsx,src/**/*.spec.js,src/**/*.test.js"</span></pre><p id="c46e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">翻译成:从文件夹“src”构建到“lib”并忽略我不需要的文件。我使用普通的babel，只是因为我不需要webpack加载器的复杂性。如果你需要图像等，你可能需要用webpack玩一会儿，然而，当它们是lightware时，库是最好的。也许如果你需要一个图像，你应该问自己:我能用SVG做这个吗？它将极大地减小你的库的大小并优化你的库。</p><p id="d1e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以上面的脚本会产生一个类似这样的结构:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi oh"><img src="../Images/db313ce064b7b275dec877a10af4310b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-cN7lGHneZ6cWREpU5FJA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">UI库结构示例</figcaption></figure><p id="f990" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会注意到我有两个额外的文件夹:“风格”和“实用工具”。我也倾向于从UI库中导出像主题(位于样式中)这样的东西，并且在utils中我保留了我经常使用的实用函数:deepclone、deepmerge、deepequal、classnames等等。它们都是简短的实用程序，所以通常你可以自己编写它们，而不是使用像lodash或其他npm模块这样的沉重的库。为了清楚起见，所有内容都应该在index.js中导出，这样，以后，您就可以在您的主要项目中有这个干净的导入:</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="ccbf" class="nj ma it nf b gy nk nl l nm nn">import { Avatar, Card, Flex, deepclone, cn } from 'my-lib/lib'</span></pre><h2 id="4ea2" class="nj ma it bd mb nq nr dn mf ns nt dp mj kb nu nv mn kf nw nx mr kj ny nz mv oa bi translated">部署</h2><p id="463c" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">部署是一个非常个人化的过程，每个人似乎都有自己的观点，但是我想介绍一种方法来完成它。在我看来，拥有本地npm模块的概念非常有效。</p><p id="82c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">部署代码的第一步是提交代码。承诺的标准化不是为了让你的生活变得更糟而创造的额外步骤。如果正确使用，它会使事情变得更容易。自动npm模块部署的一个很好的提交规范是<strong class="js iu">常规提交</strong>。</p><p id="5022" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">约定俗成</strong>来自角界。传统提交之所以伟大，是因为它们为创建显式提交历史提供了一组简单的规则，这使得自动化过程变得非常容易。</p><p id="0e9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要编写常规提交，您需要以下结构:</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="70bc" class="nj ma it nf b gy nk nl l nm nn">{type}:({scope}) - [message in lower case]</span><span id="9836" class="nj ma it nf b gy np nl l nm nn">[longer message]</span><span id="8959" class="nj ma it nf b gy np nl l nm nn">Optional: [BREAKING CHANGE]</span></pre><p id="561d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">整个<a class="ae oi" href="https://www.conventionalcommits.org/en/v1.0.0/" rel="noopener ugc nofollow" target="_blank">文档</a>只有一页。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi oj"><img src="../Images/8af8949bd3c815fa66920bb10855dbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaYI49_pZtnFp4C051kbtg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">提交消息的示例</figcaption></figure><p id="a4da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不想经常查阅文档，一些有用的工具可以帮助您编写传统的提交。我最喜欢《T7》和《T8》。</p><p id="3dbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">提交、提交和常规变更日志</strong>:</p><p id="a712" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Commitizen </strong>是一个提示工具，它将帮助您在提交时填写必填字段。与<strong class="js iu"> husky </strong>和<strong class="js iu">commit list</strong>结合使用，您将始终需要正确填写您的提交。这非常重要，因为与传统提交完美结合的持续集成依赖于那些提交消息来决定如何更新我们的包的版本。我们需要确保我们的团队遵循惯例。这就是为什么我们需要与哈士奇重新承诺钩。<strong class="js iu">传统的变更日志</strong>执行一个写得很好的变更日志。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c258bd8b91c7b563f7b23838c91b862d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*kgIFWCTowqgAMiYoQtEU1g.gif"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">使用commitizen自动提交，后跟来自commitlint的消息检查。</figcaption></figure><p id="37ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设置非常简洁和容易。用<code class="fe ol om on nf b">yarn add commitizen commitlint cz-conventional-changelog -D</code>安装后，在package.json中定义用法:</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="dedd" class="nj ma it nf b gy nk nl l nm nn">{<br/>  "name": "my-styleguide",<br/>  "version": "x.x.x",<br/>  (...)<br/>  "scripts": {<br/>    "commit": "git add . &amp; git-cz",<br/>    (...)<br/>  },<br/>  "config": {<br/>    "commitizen": {<br/>       "path": "cz-conventional-changelog"<br/>    },<br/>  "husky": {<br/>    "hooks": {<br/>      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"<br/>    }<br/>  }<br/>}</span></pre><p id="c714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我还添加了“git add”作为启动命令，因为需要在工作目录中添加更改。这里的缺点是，如果此时您只想在这个提交中添加一些文件(“git add”)，那么很难实现自动化。意味着它将添加所有已更改的内容)。好消息是，您可以只分别写两行，只添加您想要的文件。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="a6ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，提交被覆盖了。我们在拉请求中提交。我们的同行认可它，它应该去硕士。但是要进入master，我们还需要完成一个额外的步骤——我们需要想办法在我们的package.json上添加版本。因为每次提交都要手工完成，这实在是太烦人了！正如我们所知:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/3e88c619186bdfc3b55c79f7f19d6148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ear7R6oFcxc5v92LKfK5pQ.jpeg"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">对不起卓伟，这次我们不会失败了:)</figcaption></figure><p id="8b7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">版本碰撞对于npm模块是必不可少的。它确保了包管理器将拥有我们包的最新版本，当然还有:它的过去版本。另外，它们中的大多数(如果不是全部的话)不允许你上传同一个包的相同或更小的版本。很抱歉，你需要修改你的版本。</p><p id="359a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的梦想是提交一个提交，然后评估这个提交，并根据提交的内容修改版本。(只有在我们已经标准化提交的情况下，它才起作用，因此:)</p><p id="e35a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">标准版</strong>是我们所有问题的解决方案。这是一个实用的版本控制工具，适用于传统的提交。工作原理:</p><ol class=""><li id="e17f" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">它通过跟踪我们的bumpFiles (package.json，package-lock.json)来检索我们的存储库版本。它还获取我们所在的git标签。标准版本主要使用git标签。</li><li id="df59" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">它会根据我们的提交修改版本。</li><li id="4df7" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">它用我们的bump文件和CHANGELOG中的更改创建一个新的提交</li><li id="523c" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">创建一个新的git标记，以便在下次提交时读取。</li></ol><p id="e621" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它可以在本地工作，但我认为它最适合于CI代理，因为在当今时代，我们很难在没有拉请求的情况下提交。并且我们应该在我们的分支准备好进入master之后才删除文件。</p><p id="d8c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">设置也非常简洁和容易。我们需要用纱线或者npm来安装:<code class="fe ol om on nf b">yarn add standard-versiov -D</code>。在我们的package.json中，我们需要为CI提供一个要执行的命令:</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="aba8" class="nj ma it nf b gy nk nl l nm nn">{<br/>  "scripts": {<br/>    "release": "standard version"<br/>  }<br/>}</span></pre><h2 id="ad6d" class="nj ma it bd mb nq nr dn mf ns nt dp mj kb nu nv mn kf nw nx mr kj ny nz mv oa bi translated">这一切是如何联系在一起的？</h2><p id="dc37" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">所有这些助手看起来都不错，但是想象一下他们在一起做什么:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi op"><img src="../Images/c30a1380f90cd44c5578e98e0bb266b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UcRiQ6DA4d2NrQxKNh_wQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">整个持续集成流程。</figcaption></figure><ol class=""><li id="0452" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">我们编写了一个新的组件，它必须进入我们的库，由另外两个项目使用</li><li id="4e2a" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">我们使用commitizen提交代码。Commitlint评估提交消息是否正确，并允许将其推入新的分支。</li><li id="1422" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">我们运行git push并创建一个新的pull请求。</li><li id="70f9" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">我们的同事批准了拉取请求，持续集成被触发。</li><li id="f711" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">CI安装所有node_modules并构建项目。</li><li id="6869" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">CI运行标准版本。它评估提交消息，并智能地决定删除主要版本、次要版本或补丁版本。它在package.json上写入数据，并再次在CHANGELOG中创建一个新日志:基于提交消息。</li><li id="2ea2" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">CI使用package.json和CHANGELOG向master进行新的提交</li><li id="8eb3" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">CI将编译后的代码发布到私有注册中心(或者公共npm，如果这是我们的目标的话:)</li><li id="5715" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">我们在项目中安装新版本</li><li id="59d3" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">我们使用我们的新组件。</li></ol><p id="2990" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能看起来工作量很大，但请记住，设置完成后，CI会涵盖大部分内容。我的构建在Azure上运行，通常不到5分钟。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi op"><img src="../Images/78672b0f9c240cccc35f086aeeabed62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZbbBYbSune4o5_ZTZ4Nyg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">你永远不会老到哭不出来😭</figcaption></figure><p id="133c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nc">您可能遇到的问题:</em></p><ol class=""><li id="136a" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated"><strong class="js iu">CI“package/CHANGELOG”推送到master创建了版本碰撞的无限循环！是的，这是一个令人讨厌的问题。但是有一个简单的解决方法——配置您的标准版本。在项目的根目录下创建一个名为. versionrc的文件。例如，如果提交消息中出现[ci skip]字符串，Azure就会跳过提交。因此您的提交消息必须包含它。我的。versionrc看起来像:<code class="fe ol om on nf b">releaseCommitMessageFormat: "chore(release): {{currentTag}} [ci skip]</code></strong></li><li id="d164" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated"><strong class="js iu"> CI和标准版不能在master中提交？</strong> —如果您没有在git中进行身份验证，就会发生这种情况。因此，请确保将“git config”作为CI的第一步！</li></ol><p id="b94f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将在第2部分的文章中更多地讨论如何在Azure中设置CI，所以我将详细解释所有需要的步骤。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="4aec" class="lz ma it bd mb mc oc me mf mg od mi mj mk oe mm mn mo of mq mr ms og mu mv mw bi translated">将包添加到现有项目中</h1><p id="c79e" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">现在我们已经用新的闪亮的本地npm包设置好了一切，是时候将它添加到现有的项目中了。</p><p id="55c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们需要连接到本地提要。这是通过。npmrc文件，它放在我们接收项目的根目录下。在这个文件中，我们希望在本地指定要连接到哪个注册表。典型的。npmrc文件可能类似于:</p><pre class="lk ll lm ln gt ne nf ng nh aw ni bi"><span id="607e" class="nj ma it nf b gy nk nl l nm nn">registry=https:<em class="nc">//your_local_registry.com/</em><br/>always-auth=true</span></pre><p id="c88e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个简单的<code class="fe ol om on nf b">yarn install my-local-package</code>就可以了！</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi op"><img src="../Images/78672b0f9c240cccc35f086aeeabed62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZbbBYbSune4o5_ZTZ4Nyg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">这听起来好得令人难以置信</figcaption></figure><p id="6466" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nc">您可能遇到的问题:</em></p><ol class=""><li id="d78b" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated"><strong class="js iu">我有混合包:一些来自全球npm注册中心，一些来自我的私人注册中心。运行</strong> <code class="fe ol om on nf b">yarn install</code> <strong class="js iu">失败</strong>？—发生这种情况是因为您需要将您的私有注册表上游到全局npm注册表。什么？npmrc文件的作用是覆盖下载这些包的位置。因此，很明显，如果它不包含托管在全球npm中的所需软件包，它就没有权力下载它们。上游解决了这个问题。关于如何在Azure中做到这一点的更多信息，请参阅第2部分。</li></ol></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="15d3" class="lz ma it bd mb mc oc me mf mg od mi mj mk oe mm mn mo of mq mr ms og mu mv mw bi translated">在本地调试包</h1><p id="6534" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">但是，如果(合理地)您想要调试您正在编写的库，然后将它提交给注册表，该怎么办呢？好纱和npm在“链接”上给我们祝福。运行<code class="fe ol om on nf b">yarn link</code>将通过以下方式创建符号链接:</p><ol class=""><li id="97ab" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">转到要链接的项目。那是你的图书馆项目。</li><li id="2f15" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">在根目录(package.json所在的位置)运行<code class="fe ol om on nf b">yarn link</code>。这将使用package.json中的名称创建符号链接。您不能更改该名称。</li><li id="1570" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">导航到要将库链接到的项目</li><li id="8992" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">运行<code class="fe ol om on nf b">yarn link 'the-name-of-my-package'</code></li><li id="8b74" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">如果你已经安装了，它会得到一个覆盖。如果一切顺利，您将在宿主项目的node_modules中拥有本地库。</li></ol><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi op"><img src="../Images/78672b0f9c240cccc35f086aeeabed62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZbbBYbSune4o5_ZTZ4Nyg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">我开始讨厌这个形象了…</figcaption></figure><p id="9c3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nc">您可能遇到的问题:</em></p><p id="0787" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，我们在这里谈论的是反应。所以一旦你做了这个本地链接，你会立刻被迫观察这个美丽的屏幕:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi oq"><img src="../Images/c91db4a504a02fb37f8a94f17492764a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aM8fv7LC_UPNryDf"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">再多的重启也不会让它消失。</figcaption></figure><p id="f269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">无效挂机呼叫</strong>。不太好描述。好消息是，因为我已经经历了掉头发和调试，我在这里分享问题是什么— <em class="nc">因为符号链接，我们正在运行React的两个实例，</em>！</p><p id="ba6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们来谈谈我们应该怎么做！</p><ol class=""><li id="4df8" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn la lb lc ld bi translated">我们需要在package.json中正确定义我们的库依赖关系。当我们创建一个库时，我们不应该在dev-dependencies和dependencies中随机安装，因为这里的位置很重要:):<br/>a .<strong class="js iu">dependencies section</strong>—我们的库在生产中工作所需的一切<br/>b .<strong class="js iu">dev dependencies</strong>section—我们开发项目所需的东西:Ex-formatting libraries — eslint，bundlers — webpack等。<br/>c .<strong class="js iu">peer dependencies</strong>部分——我们标明了我们使用的重要库的版本，这样我们导入库的项目就可以知道它是否兼容！所以这里我们需要放入所有我们可能有的“复制品”:react、redux、material-ui等等。</li><li id="26dc" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn la lb lc ld bi translated">我们需要配置一个webpack别名！通过这样做，webpack将知道将React的哪个实例加载到您的项目中。<em class="nc">注意！如果您正在使用Create React App，您将无法修改您的webpack配置，因此您需要通过</em><a class="ae oi" href="https://github.com/timarney/react-app-rewired" rel="noopener ugc nofollow" target="_blank"><em class="nc">React-App-rewired</em></a><em class="nc">进行修改。或者弹出，这总是个好主意</em>👌<em class="nc">。</em></li></ol><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi or"><img src="../Images/05b8979fdb7d2a158bc95f5c80497a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAzy7_UKQ6ifeBAZ8pud9w.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">解决React应用程序重新布线的无效挂钩错误</figcaption></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><h1 id="e701" class="lz ma it bd mb mc oc me mf mg od mi mj mk oe mm mn mo of mq mr ms og mu mv mw bi translated">创建复杂的npm模块</h1><p id="eb10" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">最后，我想简单谈谈复杂的国家预防机制模块。有时候一个纯粹的反应对于你的模块来说是不够的。您可能需要状态，甚至可能需要中间件。考虑一个复杂的模块:比如Redux-forms。</p><p id="e3c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们该如何着手呢？不幸的是，我们没有太多选择。如果我们想让一个包进入另一个项目并拥有自己的Redux状态，我们有两个选择:</p><ul class=""><li id="0956" class="kv kw it js b jt ju jx jy kb kx kf ky kj kz kn os lb lc ld bi translated">导出我们的动作、缩减器、选择器，我们的包使用项目的redux状态</li><li id="9e73" class="kv kw it js b jt le jx lf kb lg kf lh kj li kn os lb lc ld bi translated">封装Redux存储，预构建它并让它与自己的存储一起工作，而不将其暴露给父项目</li></ul><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ot"><img src="../Images/0ac86fd621e41646fb8ef507e0676eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJQ9DqAiD-BzWUP5nq1QOA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated"><a class="ae oi" href="https://github.com/markerikson/redux-ecosystem-links/blob/master/widgets.md" rel="noopener ugc nofollow" target="_blank">https://github . com/markerikson/redux-ecosystem-links/blob/master/widgets . MD</a></figcaption></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="360f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">呸，那是篇很长的文章！感谢您的关注，我希望我对所有从事这样一个项目并花时间阅读本文的人有一点帮助！</p></div></div>    
</body>
</html>