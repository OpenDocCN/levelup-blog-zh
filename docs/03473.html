<html>
<head>
<title>Understanding decorators in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Javascript中的装饰器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-decorators-in-javascript-912a05d7a537?source=collection_archive---------8-----------------------#2020-05-11">https://levelup.gitconnected.com/understanding-decorators-in-javascript-912a05d7a537?source=collection_archive---------8-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/214ceeeaaea08eed19ca77b0b43e001d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SDNaL3o8ONFG_Mb8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ferenc Almasi </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，与装修工无关</figcaption></figure><p id="6af6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Javascript有很多特性。它实际上有很多，以至于我们容易忘记其中的一些。</p><p id="6226" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天我们将谈论<strong class="ki iu">装饰者</strong>，这是TC39流程(草案)第二阶段的一个特性。阶段2意味着语法是确定的，但它正等待在ECMAScript标准中实现。这也意味着该特性在标准javascript中不可用。<br/>但是多亏了<a class="ae kf" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>，我们现在可以使用它并将其转换成标准的<a class="ae kf" href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="noopener ugc nofollow" target="_blank"> ECMAScript </a>代码！</p><h1 id="b866" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是室内设计师</h1><p id="5941" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">装饰器是类的方法的包装器。通过应用它，它将为这些方法添加更多的特性，并允许以更可读的方式重用外部函数。</p><p id="a16e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于语法本身，它非常类似于Java中的注释:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fdbc" class="mq lf it mm b gy mr ms l mt mu">import { log } from './decorators';</span><span id="01fb" class="mq lf it mm b gy mv ms l mt mu">export default class Dog {<br/>  <br/>  @log<br/>  bark(){<br/>    console.log('Woof');<br/>  }</span><span id="5f5f" class="mq lf it mm b gy mv ms l mt mu">  say(toSay){<br/>    console.log(toSay);<br/>  }</span><span id="6358" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><p id="60e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这段代码中，我们决定使用在文件<code class="fe mw mx my mm b">decorators.js</code>中实现的装饰器<code class="fe mw mx my mm b">log</code></p><p id="bfff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，每次调用函数<code class="fe mw mx my mm b">bark</code>时，另一个函数将执行方法本身(我将在下面展示更多细节)。</p><p id="d53d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，方法<code class="fe mw mx my mm b">say</code>不会使用装饰器，因为它没有链接到它。<br/>要在所有方法上使用<code class="fe mw mx my mm b">log</code>装饰器而不必在每个方法上设置它，它可以应用于类声明本身:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="59e5" class="mq lf it mm b gy mr ms l mt mu">import { log } from './decorators';</span><span id="0f4c" class="mq lf it mm b gy mv ms l mt mu">@log<br/>export default class Dog {<br/>  <br/>  bark(){<br/>    console.log('Woof');<br/>  }</span><span id="ff01" class="mq lf it mm b gy mv ms l mt mu">say(toSay){<br/>    console.log(toSay);<br/>  }</span><span id="62c6" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><p id="198e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像这样，每次调用现有的和未来的方法都会调用装饰器<code class="fe mw mx my mm b">log</code>。</p><h1 id="2040" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">练习时间到了</h1><p id="fadc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们首先设置我们的项目。正如我所说的，原生javascript还不支持装饰器。所以我们必须将它包含在我们的项目中。</p><p id="7ddc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们创建javascript环境。创建一个新文件夹，移入并运行</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9891" class="mq lf it mm b gy mr ms l mt mu">npm init</span></pre><p id="c4ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，您可以保留CLI询问的所有信息。</p><p id="6af2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成后，在<code class="fe mw mx my mm b">devDependencies</code>中安装巴别塔的核心包:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ab47" class="mq lf it mm b gy mr ms l mt mu">npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node</span></pre><p id="85a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还因为我们需要多次刷新我们的更改，所以让我们安装Nodemon，它是一个节点包，可以检测我们代码中的更改，并为我们重新启动服务器:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9f20" class="mq lf it mm b gy mr ms l mt mu">npm install --save-dev nodemon</span></pre><p id="3388" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了工作，babel需要一个配置文件。创建一个名为<code class="fe mw mx my mm b">.babelrc</code>的文件，并在其中粘贴以下内容</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1d6b" class="mq lf it mm b gy mr ms l mt mu">{<br/>   "presets": [<br/>     "@babel/preset-env"<br/>   ]<br/>}</span></pre><p id="6096" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将告诉Babel解析标准的ECMAScript Javascript，因为NodeJS还不兼容它。它将提供本机没有的功能。</p><p id="d8fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，将以下脚本添加到您的package.json的<code class="fe mw mx my mm b">scripts</code>对象中，以运行dev服务器</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7430" class="mq lf it mm b gy mr ms l mt mu">"<strong class="mm iu">start</strong>": "nodemon <em class="mz">--exec babel-node index.js"</em></span></pre><p id="dbc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的项目现在已经准备好使用node运行ES6+ javascript，并且拥有一个使用Nodemon的开发服务器。</p><p id="2bca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们为代码创建文件。如果您在运行<code class="fe mw mx my mm b">npm init</code>命令时没有改变条目文件的默认选项，那么您的条目文件应该是<code class="fe mw mx my mm b">index.js</code>。</p><p id="1912" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建此文件，并将以下内容粘贴到其中:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e26d" class="mq lf it mm b gy mr ms l mt mu">(<br/>  function() {<br/>    console.log('Hello World');<br/>  }()<br/>)</span></pre><p id="5935" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码可能使用了你从未见过的语法。通过像这样将函数放在括号内，当文件被导入时，函数将被调用。这里，该文件是Nodemon的入口文件，这意味着它是主函数。</p><p id="4298" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">试试运行<code class="fe mw mx my mm b">npm start</code>，看看你的控制台。你应该有一个<code class="fe mw mx my mm b">Hello World</code>出现！</p><p id="345d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在一个<code class="fe mw mx my mm b">src</code>文件夹中，创建文件<code class="fe mw mx my mm b">Dog.js</code>，并在其中粘贴以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e874" class="mq lf it mm b gy mr ms l mt mu">export default class Dog {<br/><br/>  bark() {<br/>    console.log('woof');<br/>  }<br/><br/>  say(toSay) {<br/>    console.log(toSay)<br/>    return 'The dog said ' + toSay<br/>  }<br/>}</span></pre><p id="6945" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个类<code class="fe mw mx my mm b">Dog</code>是一个非常基础的类，显示一些输出。第一个函数只显示<code class="fe mw mx my mm b">woof</code>，第二个函数显示通过参数传递的内容。</p><p id="05fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mw mx my mm b">index.js</code>中，将console.log替换为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0ef7" class="mq lf it mm b gy mr ms l mt mu">const dog = new Dog()<br/>dog.bark();<br/>console.log('\n\n')<br/>dog.say('hello wo.. Woof!');</span></pre><p id="5aa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要忘记将您的<code class="fe mw mx my mm b">Dog.js</code>文件放入您的<code class="fe mw mx my mm b">index.js</code>中:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="03bf" class="mq lf it mm b gy mr ms l mt mu">//index.js<br/>import Dog from "./src/Dog";</span></pre><p id="d010" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以尝试运行您的程序，并通过运行<code class="fe mw mx my mm b">npm start</code>来查看输出。</p><p id="1674" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将创建一个装饰器。我们将要创建的装饰器是一个日志装饰器，它将显示传递给方法的参数及其执行结果。</p><p id="4e97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们在<code class="fe mw mx my mm b">src</code>文件夹下创建一个<code class="fe mw mx my mm b">decorators.js</code>文件，粘贴以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f35f" class="mq lf it mm b gy mr ms l mt mu">export function log(target) {<br/>  if (typeof target.descriptor.value === 'function') {<br/>    const original = target.descriptor.value;<br/>    target.descriptor.value = function(...args) {<br/>      console.log('arguments: ', args);<br/>      const result = original.apply(this, args);<br/>      console.log('result: ', result);<br/>      return result;<br/>    }<br/>  }<br/>  return target;<br/>}</span></pre><p id="7627" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们进一步看看这段代码。根据设计，装饰者接受一个参数<code class="fe mw mx my mm b">target</code>。<code class="fe mw mx my mm b">target</code>是一个对象，它可以有两个定义——类和方法。</p><h2 id="5f59" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">班级</h2><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bcb2" class="mq lf it mm b gy mr ms l mt mu">{<br/>  kind: 'class',<br/>  elements: [<br/>    Object [Descriptor] {<br/>      kind: 'method',<br/>      key: 'bark',<br/>      placement: 'prototype',<br/>      descriptor: [Object]<br/>    },<br/>    Object [Descriptor] {<br/>      kind: 'method',<br/>      key: 'say',<br/>      placement: 'prototype',<br/>      descriptor: [Object]<br/>    }<br/>  ]<br/>}</span></pre><p id="c4d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">kind</code>:定义的类型。这里是<code class="fe mw mx my mm b">class</code>,这意味着装饰器已经放在了类原型上。</p><p id="0fac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它包含一个带有<code class="fe mw mx my mm b">method</code>定义的元素数组。</p><h2 id="dba0" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">方法</h2><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="62ab" class="mq lf it mm b gy mr ms l mt mu">{<br/>  kind: 'method',<br/>  key: 'say',<br/>  placement: 'prototype',<br/>  descriptor: {<br/>    value: [Function: say],<br/>    writable: true,<br/>    configurable: true,<br/>    enumerable: false<br/>  }<br/>}</span></pre><p id="76d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">kind</code>:这里是<code class="fe mw mx my mm b">method</code>，表示装饰器放在方法原型上。如果类型是<code class="fe mw mx my mm b">class</code>,它也可以是元素数组中的方法。记住，这意味着你在方法层。</p><p id="987a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">key</code>:这是方法的名称。这里是<code class="fe mw mx my mm b">say</code>。</p><p id="a183" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">placement</code>:可以是<code class="fe mw mx my mm b">prototype</code>是把装饰器放在一个方法的原型上。如果方法是静态的，也可以是<code class="fe mw mx my mm b">static</code>。</p><p id="1f3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">descriptor</code>:这个对象包含了所有与被执行方法相关的信息。</p><p id="9191" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">descriptor.value</code>:由装饰者执行的功能。</p><p id="fca0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">descriptor.writable</code>:该值与其他babel插件的高级用法有关，与本文无关。</p><p id="acc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">descriptor.configurable</code>:该值与其他babel插件的高级用法有关，与本文无关。</p><p id="6f1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">descriptor.enumerable</code>:该值与其他babel插件的高级用法有关，与本文无关。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="f57a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然已经详细描述了目标对象，让我们回到我们之前的地方。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f73f" class="mq lf it mm b gy mr ms l mt mu">export function log(target) {<br/>  if (typeof target.descriptor.value === 'function') {<br/>    const original = target.descriptor.value;<br/>    target.descriptor.value = function(...args) {<br/>      console.log('arguments: ', args);<br/>      const result = original.apply(this, args);<br/>      console.log('result: ', result);<br/>      return result;<br/>    }<br/>  }<br/>  return target;<br/>}</span></pre><p id="b0ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了捕捉该方法并在其周围包含更多的逻辑，我们首先需要在目标中覆盖它。为了长期的目的，让我们检查描述符的值是否是一个函数。如果不是(例如，如果使用正确的巴别塔插件，类属性)，那么我们不想在这里应用任何覆盖。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f0f8" class="mq lf it mm b gy mr ms l mt mu">const original = target.descriptor.value;</span></pre><p id="ed0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望保留原始值，因为它仍然是我们想要执行的方法。我们把它保存在<code class="fe mw mx my mm b">original</code>变量下。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5145" class="mq lf it mm b gy mr ms l mt mu">target.descriptor.value = function(...args) {</span></pre><p id="b664" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用一个新函数覆盖这个值。<br/>出于打印目的，我们使用spreading获取参数。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d234" class="mq lf it mm b gy mr ms l mt mu">console.log('arguments: ', args);</span></pre><p id="1fb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以打印这些参数</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1adc" class="mq lf it mm b gy mr ms l mt mu">const result = original.apply(this, args);</span></pre><p id="ad6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一点很有趣。通过只执行原始函数，它将在一个新的作用域中执行，而不是在类1中。你可能听说过<code class="fe mw mx my mm b">bind(this)</code>。这里的原理是一样的，把这个权利赋予这个方法并执行它。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8f20" class="mq lf it mm b gy mr ms l mt mu">console.log('result: ', result);<br/>return result;</span></pre><p id="62b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以打印结果并返回。</p><p id="3058" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干得好！我们现在可以将装饰器应用到我们的方法中。您的<code class="fe mw mx my mm b">Dog.js</code>文件现在应该是这样的。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e714" class="mq lf it mm b gy mr ms l mt mu">import { log } from "./decorators";<br/><br/>export default class Dog {<br/><br/>  @log<br/>  bark() {<br/>    console.log('woof');<br/>  }<br/><br/>  @log<br/>  say(toSay) {<br/>    console.log(toSay)<br/>    return 'The dog said ' + toSay<br/>  }<br/>}</span></pre><p id="7809" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你运行你的程序，你会得到一个可怕的错误信息！别担心，这很正常。现在，我们的巴别还不能理解这一点。让我们给它知识吧！</p><p id="278c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">停止您的开发环境并运行命令:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="144a" class="mq lf it mm b gy mr ms l mt mu">npm install --save-dev @babel/plugin-proposal-decorators</span></pre><p id="33cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将安装babel插件来支持装饰者。</p><p id="442c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要修改我们的<code class="fe mw mx my mm b">.babelrc</code>文件来告诉babel使用这个插件。您的文件现在应该是这样的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="40c9" class="mq lf it mm b gy mr ms l mt mu">{<br/>  "presets": [<br/>    "@babel/preset-env"<br/>  ],<br/>  "plugins": [<br/>    ["@babel/plugin-proposal-decorators", {<br/>      "decoratorsBeforeExport": true<br/>    }]<br/>  ]<br/>}</span></pre><p id="7024" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们添加了一个<code class="fe mw mx my mm b">plugins</code>部分，它是一个数组，然后我们在里面添加了相应的插件。我们必须实现这些选项，并将<code class="fe mw mx my mm b">decoratorsBeforeExport</code>设置为true，以支持装饰者的阶段2。</p><p id="617f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以再次运行您的程序，这一次，您将得到以下输出</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f7d8" class="mq lf it mm b gy mr ms l mt mu">arguments:  []<br/>woof<br/>result:  undefined</span><span id="c46a" class="mq lf it mm b gy mv ms l mt mu">arguments:  [ 'hello wo.. Woof!' ]<br/>hello wo.. Woof!<br/>result:  The dog said hello wo.. Woof!</span></pre><p id="424a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的装饰器正在工作，现在您可以看到额外的输出！</p><p id="d6c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在还有最后一件事要做。如果您尝试在类级别应用装饰器，它不会给你一个错误。这是因为我们只在方法层次上处理，而不是在类层次上(记住<code class="fe mw mx my mm b">kind</code>)。</p><p id="e4a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们回到装饰者那里，把它改成:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d9aa" class="mq lf it mm b gy mr ms l mt mu">function doSingleLog(methodTypeTarget) {<br/>  if (typeof methodTypeTarget.descriptor.value === 'function') {<br/>    const original = methodTypeTarget.descriptor.value;<br/>    methodTypeTarget.descriptor.value = function(...args) {<br/>      console.log('arguments: ', args);<br/>      const result = original.apply(this, args);<br/>      console.log('result: ', result);<br/>      return result;<br/>    }<br/>  }<br/>  return methodTypeTarget;<br/>}<br/><br/>export function log(target) {<br/>  if (target.kind === 'method') {<br/>    return doSingleLog(target)<br/>  } else if (target.kind === 'class') {<br/>    target.elements = target.elements.map((element) =&gt; doSingleLog(element))<br/>  }<br/>  return target;<br/>}</span></pre><p id="6488" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们仍然有<code class="fe mw mx my mm b">log</code>函数，但是这一次，我们将逻辑导出到一个<code class="fe mw mx my mm b">doSingleLog</code>函数中，它将只处理方法级别，而<code class="fe mw mx my mm b">log</code>函数将完成分配正确元素的工作。</p><p id="2e15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以在类级别应用<code class="fe mw mx my mm b">@log</code>并将其从方法中移除。并且输出将保持不变！</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="4c72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">装饰者可以用在很多不同的情况下，只有你的想象力可以成为你的极限。这个日志示例是您拥有的大量可能性之一！</p><p id="a8aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你达到了它的结尾，并在未来使用装饰。我认为decorators是考虑使用Javascript的OOP的另一个原因！你可以在我的github repo <a class="ae kf" href="https://github.com/psyycker/decorator-test" rel="noopener ugc nofollow" target="_blank">这里</a>找到最终代码。</p><p id="a4e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>