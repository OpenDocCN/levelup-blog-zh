<html>
<head>
<title>React — Memory Leaks and How to Avoid Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React —内存泄漏以及如何避免它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-memory-leaks-and-how-to-avoid-them-bb05c571e728?source=collection_archive---------1-----------------------#2022-08-12">https://levelup.gitconnected.com/react-memory-leaks-and-how-to-avoid-them-bb05c571e728?source=collection_archive---------1-----------------------#2022-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3b3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，每当内存中存在不可访问或未被引用的数据时，就发生了内存泄漏。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2c8866375242cd3eb9ada63b90426467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5NUP_GMYu_M7BjuIF7Mbw.jpeg"/></div></div></figure><p id="dec9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据<a class="ae kx" href="https://en.wikipedia.org/wiki/Memory_leak" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，内存泄漏是一种资源泄漏，当计算机程序错误地管理内存分配，没有释放不再需要的内存时就会发生。当一个对象存储在内存中，但不能被运行的代码访问时，也可能发生内存泄漏。</p><p id="dad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React应用程序中的内存泄漏主要是由于在卸载组件之前没有取消组件安装时所做的订阅。这些订阅可以是:</p><ul class=""><li id="d2ac" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">DOM事件侦听器</li><li id="a478" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">WebSocket订阅</li><li id="fdb2" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">对API的请求</li></ul><p id="75c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将重点关注如何避免DOM事件侦听器上的内存泄漏，但是这个过程与WebSocket订阅非常相似。</p><p id="a68c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，当我们在React中添加一个事件侦听器时，为了避免内存泄漏，我们需要删除它们。</p><h1 id="a00c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">使用类组件</strong></h1><p id="870f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">让我们看看如何使用类组件来实现这一点:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="aff9" class="mu ln iq mq b gy mv mw l mx my">class MyComponent extends React.Component {<br/>  constructor(){<br/>    super(props)</span><span id="ff7c" class="mu ln iq mq b gy mz mw l mx my">    this.handleClick = this.handleClick.bind(this)<br/>  }</span><span id="f907" class="mu ln iq mq b gy mz mw l mx my">  handleClick = () =&gt; {<br/>     //do something when we clicked<br/>  }  </span><span id="a44a" class="mu ln iq mq b gy mz mw l mx my">  componentDidMount() {<br/>    document.addEventListener("mousedown", this.handleClick);<br/>  }</span><span id="8737" class="mu ln iq mq b gy mz mw l mx my">  componentWillUnMount() {<br/>    document.removeEventListener("mousedown", this.handleClick);<br/>  }</span><span id="fa9f" class="mu ln iq mq b gy mz mw l mx my">  render() {<br/>    renturn ...<br/>  }<br/>}</span><span id="55ce" class="mu ln iq mq b gy mz mw l mx my">export default MyComponent</span></pre><p id="a4d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所示，我们在<code class="fe na nb nc mq b">componentDidMount</code>中创建了事件监听器，并在<code class="fe na nb nc mq b">componentWillUnMount</code>中移除了它。</p><h1 id="8915" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用功能组件</h1><p id="a808" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我们可以使用useEffect挂钩来添加和删除事件侦听器，从而在功能组件中实现相同的功能，如下所示:</p><pre class="km kn ko kp gt mp mq mr ms aw mt bi"><span id="5283" class="mu ln iq mq b gy mv mw l mx my">const MyComponent = () =&gt; {<br/>  useEffect(() =&gt; {<br/>    const handleClick = () =&gt; {<br/>      //do something when we click<br/>    };<br/>    <br/>    document.addEventListener('mousedown', handleClick);</span><span id="953d" class="mu ln iq mq b gy mz mw l mx my">    return() =&gt; {<br/>      document.removeEventListener('mousedown', handleClick);<br/>    };<br/>  }, []);</span><span id="10b4" class="mu ln iq mq b gy mz mw l mx my">  return ...<br/>};</span><span id="4ae4" class="mu ln iq mq b gy mz mw l mx my">export default MyComponent;</span></pre><p id="57e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">空的<code class="fe na nb nc mq b">[ ]</code>依赖列表确保我们的useEffect在第一次渲染后只被调用一次。</p><p id="240f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了让我们清理东西，useEffect允许我们从回调函数中返回一个清理函数。React将在下一次调用我们的useEffect回调之前调用这个清理回调，比如当依赖关系改变时。</p><p id="422c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，当组件卸载时，React将调用此清理。因此，我们在清理回调中删除了事件侦听器。</p><h1 id="df15" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="ba9d" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在本文中，我们研究了使用DOM事件侦听器时发生的内存泄漏以及如何避免它们。我们还指出，对于由于WebSocket订阅导致的内存泄漏，这个过程非常相似。</p><p id="1210" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，对于由于“对API的请求”而导致的内存泄漏，这个过程有一点不同，需要一个叫做“AbortControllers”的东西。你可以在这里了解更多信息<a class="ae kx" href="https://dev.to/jeremiahjacinth13/memory-leaks-how-to-avoid-them-in-a-react-app-1g5e#:~:text=Causes%20of%20Memory%20Leaks%20in,a%20request%20to%20an%20API." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ad6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">— -</p><p id="8e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这篇文章，请留下几个(或很多)掌声，如果你还没有，请确保在Medium上关注我。您也可以订阅，以便在我发布时收到电子邮件。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="2072" class="lm ln iq bd lo lp nk lr ls lt nl lv lw lx nm lz ma mb nn md me mf no mh mi mj bi translated">分级编码</h1><p id="d362" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="da7e" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="5050" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">📰查看<a class="ae kx" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="79fa" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">🔔关注我们:<a class="ae kx" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae kx" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae kx" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="d3da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae kx" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>