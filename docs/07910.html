<html>
<head>
<title>WebAssembly + React Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebAssembly + React简化版</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/webassembly-react-simplified-cc092521a984?source=collection_archive---------3-----------------------#2021-03-21">https://levelup.gitconnected.com/webassembly-react-simplified-cc092521a984?source=collection_archive---------3-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/17666973d0acca2cd123e9ffdd0e00c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*k7b7Z8aISifNYfrntV3dgw.png"/></div></figure><p id="6802" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">WebAssembly  (WASM)有一个时间和地点，但即使你找到了你需要使用它的确切的正确时刻，也很难从周围的噪音中提取如何使用它的信息。</p><p id="f84e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们将着眼于获取一些开源C++并在自定义钩子中从React应用程序调用它。</p><h1 id="85c8" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是WebAssembly？</h1><p id="1cad" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我见过的最好的解释来自https://developer.mozilla.org/en-US/docs/WebAssembly<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/WebAssembly" rel="noopener ugc nofollow" target="_blank"/>:</p><p id="4e39" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">“WebAssembly是一种可以在现代web浏览器中运行的新型代码，它是一种低级的类似汇编的语言，具有紧凑的二进制格式，以接近本机的性能运行，并为C/C++、C#和Rust等语言提供编译目标，以便它们可以在web上运行。它还被设计成与JavaScript并行运行，允许两者协同工作。”</p><h2 id="c58d" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">我们不是一直都能做到吗？</h2><p id="8c79" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">是也不是。我们已经能够在本地运行所有这些语言，但不能在浏览器中运行。传统上，如果我们需要使用C++之类的东西来运行在浏览器中的任何类型的代码，它通常是一个发送到服务器上运行的请求。</p><h2 id="2c85" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">为什么我们需要在浏览器中运行它？</h2><p id="dd30" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">有很多时候你没有；这不是标准后端代码的替代品。但是如果你有一些不需要安全但是需要高性能的东西，那么能够在本地运行C/C++之类的东西是一个巨大的优势。服务器上的处理能力是要花钱的，在用户的浏览器上运行可以潜在地为你省钱，也为用户节省一些时间。对于我们的例子，我们有一个需要运行数百万次模拟的计算引擎，如果你在服务器上完成所有的工作，这可能会很昂贵，如果你用Javascript编写它，它会更慢。所以两全其美，浏览器中的C++。</p><p id="403c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Wasm正被用于许多事情，包括图形，对于我们的例子，我们只是将它作为一个本地服务。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="1e18" class="kt ku iq bd kv kw mp ky kz la mq lc ld le mr lg lh li ms lk ll lm mt lo lp lq bi translated">所以你决定要在你的React应用中运行C/C++？</h1><p id="8d92" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">如果(像我一样)你是一名Javascript开发人员，你已经找到了一些C/C++开源代码，现在想在你的浏览器中重用它，我有一点坏消息要告诉你。可能要写点C++。先别走，还没那么糟。你发现的大多数C++程序都有一个main，并期望在命令行上运行。这并不理想，我们需要把它变成更容易调用我们的自定义钩子的东西。</p><h2 id="f515" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">第一步</h2><p id="cd86" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">如果还没有，在C++项目中为你的API层写一个新的类。这主要是重新创建现有项目的“main”方法中的内容。谷歌将成为你的朋友。C++已经存在了几个世纪，所以有很多帮助。尽可能简单地使用这个API的请求和响应参数。我将json作为一个字符串传入，并使用<a class="ae ks" href="https://github.com/open-source-parsers/jsoncpp" rel="noopener ugc nofollow" target="_blank"> jsoncpp </a>读取它，但是还有许多其他选项可供选择。</p><h2 id="4a54" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">第二步</h2><p id="f853" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们将使用<a class="ae ks" href="https://emscripten.org/docs/introducing_emscripten/index.html" rel="noopener ugc nofollow" target="_blank"> emscripten </a>来移植代码，所以我们需要一个<code class="fe mu mv mw mx b"><a class="ae ks" href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html" rel="noopener ugc nofollow" target="_blank">EMSCRIPTEN_BINDINGS</a>() </code>块来公开我们的方法。我的看起来像这样:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="c06a" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">第三步</h2><p id="9269" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">安装emscripten——这里的说明很容易理解<a class="ae ks" href="https://emscripten.org/docs/getting_started/downloads.html" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="4c7d" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">第四步</h2><p id="2f39" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">使用emscripten移植您的C++。这里需要注意的重要一点是，如果有头文件(。h扩展名)，那么您需要在列表中指定相应的cpp类。我的看起来像这样:</p><pre class="my mz na nb gt ne mx nf ng aw nh bi"><span id="b75d" class="lw ku iq mx b gy ni nj l nk nl">em++ --bind emBinding.cpp fileOne.cpp fileTwo.cpp file3.cpp jsoncpp.cpp -s WASM=1 -o ../wasm/poker.js -s 'ENVIRONMENT="web"' -s USE_ES6_IMPORT_META=0 -s EXPORT_ES6=1 -s MODULARIZE=1 </span></pre><p id="f42f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果这是成功的，它应该生成2个文件。A *。js和*。wasm使用您提供的名称。现在我们可以忘记C/C++了，回到可爱的Javascript世界。</p><h2 id="7a90" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">第五步</h2><p id="f681" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">更新webpack.config以加载到。wasm文件是这样的:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="e452" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">第六步</h2><p id="a518" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">创建您的自定义挂钩:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="59a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们仔细看看！首先，我们加载wasm文件:</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ad0d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我对此有一个尝试，因为有些人在他们的浏览器中禁用了webassembly(为了测试这一点，你可以进入firefox并在地址栏中输入about:config，然后将javascript.options.wasm更改为false)。如果没有这个，你的用户可能只会收到一个没有任何提示的空白页面。</p><p id="2745" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于一个定制钩子来说，剩下的就很正常了，我们现在只是从wasm中调用我们的exposed方法。</p><p id="587a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们能谈谈房间里的大象吗？为什么我的承诺超时是0毫秒？当我第一次写这篇文章时，我让我的计算运行了200万次模拟——这几乎立刻就有了回报。(我知道，对！wasm能有多快就是这么快。)我想给用户提供运行更多的能力，只是1000万，这给了一个明显的停顿，我希望用户有一些迹象表明这里正在发生一些事情。所以，正如你所做的，我增加了一个装载旋转器。奇怪的事情发生了，直到wasm被调用后，它才显示出spinner，它闪烁着消失了。在进行了一些h̶a̶c̶k̶i̶n̶g̶调查并试图理解<a class="ae ks" href="https://youtu.be/cCOL7MC4Pl0" rel="noopener ugc nofollow" target="_blank">事件循环</a>之后，我发现这个超时冲走了承诺，显示了微调器，然后开始使用Wasm。</p><h2 id="5ae4" class="lw ku iq bd kv lx ly dn kz lz ma dp ld kf mb mc lh kj md me ll kn mf mg lp mh bi translated">第100步(好吧，我记不清了)</h2><p id="6cd2" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在就像使用其他钩子一样使用你的新钩子。关于Wasm的例子，你可以点击这里查看我的扑克应用<a class="ae ks" href="https://rockhopper.netlify.app?handid=293496318366581254" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>