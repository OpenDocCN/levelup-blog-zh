<html>
<head>
<title>One Problem, Multiple Solutions &amp; The Risk of Choosing Poorly — Welcome to The Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个问题，多个解决方案&amp;选择不当的风险——欢迎使用云计算</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/one-problem-multiple-solutions-the-risk-of-choosing-poorly-welcome-to-the-cloud-d64ed4494c27?source=collection_archive---------19-----------------------#2022-10-17">https://levelup.gitconnected.com/one-problem-multiple-solutions-the-risk-of-choosing-poorly-welcome-to-the-cloud-d64ed4494c27?source=collection_archive---------19-----------------------#2022-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="dd61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">对于您的云环境，什么是明智的解决方案选择？什么时候应该用什么？</em></p><h1 id="429c" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">让那里有云</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/c3001b6da24292bdfa41bbc9cfdd883e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*M1fb-7WO-S0dp7NQEyp7xQ.png"/></div></div></figure><p id="d495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">许多人会同意，云现在已经成为许多组织托管其技术的不可或缺的平台。如今，在云提供商的平台上终止部署管道流已经司空见惯。问题在于，对于一个问题，可能有许多解决方案。云技术提供的简单和丰富的选项是有代价的——根据您的情况做出<em class="ko">【差】</em>工具选择<em class="ko"> </em>非常容易。这些糟糕的选择会导致不必要的成本，甚至更糟，因为它们对你的流程施加了不必要的限制和约束。</p><p id="9b32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将探讨一种非常常见的情况，这种情况可以通过多个云解决方案来管理，并确定哪种解决方案更有意义或更适合这种情况。我们将把这种情况应用到一个假想的组织中，我们称之为CloudGifters。</p><h1 id="163b" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">有趣的情况</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi lz"><img src="../Images/1ee8fca9c33e3c7f3f07ab86bcaa9f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPso6_Mam4DfJYGxlYr3iw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">图1我们假设的基于云的云迁移器的期望流量</figcaption></figure><p id="6dd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如图1所示，CloudGifters期望的流程看起来非常简单明了。他们希望销售非常昂贵的精英/贵宾套餐，并希望在贵宾生日前两天为每位贵宾(订购了此功能的客户)启动特殊的赠送流程。</p><p id="90ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CloudGifters的贵宾只是更大的客户群体中的极小一部分，因此，他们的生日是很少发生的事件。</p><blockquote class="me"><p id="6c4b" class="mf mg it bd mh mi mj mk ml mm mn kn dk translated">为简单起见，这个假设情况中涉及的所有应用程序都在GCP上。</p></blockquote><p id="846a" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">CloudGifters的优秀工程师对这个问题感到兴奋，他们进行了头脑风暴，并提出了一个想法:由于CloudGifters非常严格地遵守由清晰有界的上下文定义的业务边界，他们不会在<code class="fe mt mu mv mw b">Subscription</code>微服务中做这项工作，而是在<code class="fe mt mu mv mw b">Gifting</code>微服务中公开一个<code class="fe mt mu mv mw b">/gift-vip</code>端点，该端点将在正确的时间被调用，以开始赠送过程——正确的时间是在VIP生日的前两天。简单…简短！</p><p id="0743" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，问题很快出现了:</p><ol class=""><li id="f3d8" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">从技术上讲，我们如何保证我们总是知道这是每个贵宾生日的前两天？</li><li id="82df" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">我们会部署一个云调度程序或一个Kubernetes cron作业来每天检查以了解哪些客户在两天后过生日吗？</li><li id="d4ab" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">嗯……既然我们知道VIP生日并不常见，那么做上面的第二步有意义吗？为什么要部署每天检查的东西来确认我们已经知道的大多数日子的情况——没有即将到来的生日？每天检查一些我们知道不会发现的东西不是很浪费吗？</li><li id="e329" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">CloudGifters在Kubernetes集群中的pods上运行微服务，但是由于上面的3，即使我们知道在这么多天、几周甚至可能几个月内不会有礼物要处理，继续运行<code class="fe mt mu mv mw b">Gifting</code>微服务有意义吗？这难道不是一种浪费吗？这难道不会产生成本吗？如果没有这些成本，我们会过得更好，不管这些成本有多小。</li><li id="72ea" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">借助Kubernetes的水平Pod Autoscaler (HPA ),我们可以轻松地将<code class="fe mt mu mv mw b">Gifting</code>微服务部署扩展到1，但我们能做得更好吗——当应用程序不处理任何礼品处理请求时，扩展到0？</li><li id="8465" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">我们是否可以考虑使用Cloud Run来运行<code class="fe mt mu mv mw b">Gifting</code>微服务容器，因为Cloud Run可以将容器实例扩展到0，在流量恢复时弹出适当数量的容器实例，并在微服务不服务任何请求时将容器实例缩减到0？</li><li id="8ccd" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">使用云任务队列在特定的调度时间显式调用消息(任务),而不是使用基于时间间隔的cron调度程序(不管是否有VIP要处理礼物，这些调度程序都会按照固定的周期/时间间隔运行),这样如何？</li><li id="9ed8" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">等等。</li></ol><p id="bb2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在头脑风暴会议中有这么多问题，团队决定重新思考这个问题，并在急需的咖啡休息后重新召集。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="1701" class="kp kq it bd kr ks ns ku kv kw nt ky kz la nu lc ld le nv lg lh li nw lk ll lm bi translated">候选解决方案</h1><p id="57df" class="pw-post-body-paragraph jq jr it js b jt nx jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj ob kl km kn im bi translated">现在，团队从他们的休息中恢复过来，精力充沛，准备决定一个真正有效的简洁的解决方案。</p><p id="40e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们会考虑CloudGifters的工程师和思想家试图处理这种情况并解决他们的优点和缺点的两种方法。这将有助于我们确定哪种方法更具可扩展性、更自然、更少浪费且更高效。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="6793" class="oc kq it bd kr od oe dn kv of og dp kz kb oh oi ld kf oj ok lh kj ol om ll on bi translated">Kubernetes部署的固定间隔隐式调用</h2><p id="da98" class="pw-post-body-paragraph jq jr it js b jt nx jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj ob kl km kn im bi translated"><code class="fe mt mu mv mw b">Gifting</code>流程的一个非常明显的方面是，它应该异步进行，并且完全独立于<code class="fe mt mu mv mw b">Subscription</code>微服务的流程。异步微服务通信的一种流行方法是使用例如<a class="ae oo" href="https://cloud.google.com/pubsub/docs/overview" rel="noopener ugc nofollow" target="_blank"> <em class="ko"> PubSub </em> </a>这样的工具进行消息调用。</p><blockquote class="me"><p id="1f9e" class="mf mg it bd mh mi mj mk ml mm mn kn dk translated">PubSub实现了过程的<em class="op">隐式调用</em>，完全由订阅者来监听发布的事件，并在这些事件被触发时运行相应的适当执行。</p></blockquote><p id="5462" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">发布者是订户不可知的，并且<strong class="js iu"> <em class="ko">通过简单地将消息广播到<a class="ae oo" href="https://cloud.google.com/pubsub/docs/overview#core_concepts" rel="noopener ugc nofollow" target="_blank"> <em class="ko">主题</em> </a>中，隐式地</em> </strong>在订户中引起执行。发布者无法控制已发布消息向订阅者的传递。</p><p id="4908" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们的CloudGifters情况，发布者是<code class="fe mt mu mv mw b">Subscription</code>微服务，订阅者是运行在Kubernetes pod中的<code class="fe mt mu mv mw b">Gifting</code>微服务容器。整个流程如下所示。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a613a0786605982940f2bc7ebec1c72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*CQDmTYplljxOaY9c_LigbQ.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">图2固定间隔隐式调用</figcaption></figure><p id="8ed9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的图2描述了CloudGifters的工程师们的建议，他们支持固定间隔隐式调用的思想。一旦客户进行了VIP订阅<em class="ko">(1)</em>,<code class="fe mt mu mv mw b">Subscription</code>微服务就会发布一条适当的消息，其中包含客户的出生日期<em class="ko"> (2) </em>。因为<code class="fe mt mu mv mw b">Gifting</code>微服务已经订阅了该消息的主题，所以该消息被传递给<code class="fe mt mu mv mw b">Gifting</code>微服务，后者然后将客户的详细信息保存在其数据存储中<em class="ko"> (3) </em>。与此同时，云调度程序定期运行，检查哪些客户的生日将在两天后到来，并为任何符合条件的客户<em class="ko"> (4) </em>调用<code class="fe mt mu mv mw b">Gifting</code>微服务的<code class="fe mt mu mv mw b">/gift-vip</code>端点。</p><h2 id="46d5" class="oc kq it bd kr od oe dn kv of og dp kz kb oh oi ld kf oj ok lh kj ol om ll on bi translated">赞成的意见</h2><ol class=""><li id="5981" class="mx my it js b jt nx jx ny kb or kf os kj ot kn nc nd ne nf bi translated"><code class="fe mt mu mv mw b">Subscription</code>微服务与<code class="fe mt mu mv mw b">Gifting</code>微服务完全解耦并且不知道。</li><li id="bb91" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">除了<code class="fe mt mu mv mw b">Gifting</code>微服务之外，<code class="fe mt mu mv mw b">Subscription</code>微服务还可能有多个订户。</li></ol><h2 id="4869" class="oc kq it bd kr od oe dn kv of og dp kz kb oh oi ld kf oj ok lh kj ol om ll on bi translated">骗局</h2><ol class=""><li id="d118" class="mx my it js b jt nx jx ny kb or kf os kj ot kn nc nd ne nf bi translated">浪费运行的<code class="fe mt mu mv mw b">Gifting</code>微服务容器的副本，因为VIP生日不是经常发生的事件，微服务会在不处理礼物请求时继续运行。</li><li id="1187" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">由于VIP生日活动的稀少，浪费的定期云调度检查。云调度器不断寻找符合条件的VIP，即使在执行检查的大部分时间内都没有。</li><li id="c637" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">PubSub不实现计划交付。</li><li id="9a8b" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">重复生日礼物请求的风险，因为没有办法指定消息队列中的消息是重复的。</li></ol></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="d5e5" class="oc kq it bd kr od oe dn kv of og dp kz kb oh oi ld kf oj ok lh kj ol om ll on bi translated">使用云运行服务的固定时间显式调用</h2><p id="bbc2" class="pw-post-body-paragraph jq jr it js b jt nx jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj ob kl km kn im bi translated">对于第二种方法，<code class="fe mt mu mv mw b">Gifting</code>微服务容器在云运行服务中运行，该服务根据传入的请求以及有效处理这些请求所需的实例数量来扩展其容器实例——是的，如果它没有收到任何请求，它会将其容器实例缩减到0。像第一种隐式调用方法一样，<code class="fe mt mu mv mw b">Subscription</code>微服务在这里也是发布者，但不同之处在于，在这种情况下，发布者不是订户不可知的，并且<code class="fe mt mu mv mw b">Gifting</code>微服务不是任何主题的订户。</p><blockquote class="me"><p id="684f" class="mf mg it bd mh mi mj mk ml mm mn kn dk translated">云任务提供了针对已知目的地(发布者已知)的过程的<em class="op">显式调用</em>。</p></blockquote><p id="54cd" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这意味着发布者(<code class="fe mt mu mv mw b">Subscription</code>微服务)控制并决定哪个微服务应该处理它的生日请求。<code class="fe mt mu mv mw b">Subscription</code>微服务知道<code class="fe mt mu mv mw b">Gifting</code>微服务，但只是为了指定<code class="fe mt mu mv mw b">Gifting</code>微服务在要被推入云任务队列的调度任务中的<code class="fe mt mu mv mw b">/gift-vip</code>端点。</p><p id="82ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法如下图3所示。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/02e4591abe3231d8db7747cfa213df68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*BFnJKB_ZI2UHji--bdXdVw.png"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">图3使用云运行服务的固定时间显式调用</figcaption></figure><h2 id="d292" class="oc kq it bd kr od oe dn kv of og dp kz kb oh oi ld kf oj ok lh kj ol om ll on bi translated">赞成的意见</h2><ol class=""><li id="7951" class="mx my it js b jt nx jx ny kb or kf os kj ot kn nc nd ne nf bi translated"><code class="fe mt mu mv mw b">Gifting</code>微服务不订阅任何主题，也不需要以任何方式与<code class="fe mt mu mv mw b">Subscription</code>微服务集成。它只是作为一个普通的服务存在，没有任何其他的开销来集成到任何消息的主题中。</li><li id="ce7e" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">云调度程序不会进行浪费的检查。没有必要保持任何cron工作，经常检查合格的客户，为他们准备生日礼物。</li><li id="3fe2" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">云任务已经被安排在特定的时间运行，在该时间到来之前不会发生任何事情。</li><li id="9567" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">没有浪费的<code class="fe mt mu mv mw b">Gifting</code>微服务副本如果没有收到请求，云运行服务可以将容器实例扩展到0。</li><li id="fd54" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">是的，失败的任务可以通过高度可配置的方式重试。</li><li id="1e88" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">预定交货。</li><li id="a3b7" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">对于命名任务，任务创建是重复的，因此保证每个VIP的生日礼物只被处理一次。</li></ol><h2 id="2f69" class="oc kq it bd kr od oe dn kv of og dp kz kb oh oi ld kf oj ok lh kj ol om ll on bi translated">骗局</h2><ol class=""><li id="497d" class="mx my it js b jt nx jx ny kb or kf os kj ot kn nc nd ne nf bi translated">云任务目前不会持续超过30天，如果没有被触发，它们会被自动删除，因此CloudGifters必须针对这种情况实施一些解决方案。</li></ol></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="f181" class="kp kq it bd kr ks ns ku kv kw nt ky kz la nu lc ld le nv lg lh li nw lk ll lm bi translated">结论</h1><p id="2a0a" class="pw-post-body-paragraph jq jr it js b jt nx jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj ob kl km kn im bi translated">在考虑了上述选项之后，选择第二个选项是有意义的——使用云运行服务进行固定时间的显式调用。该选项的特点是步骤较少，浪费较少。它甚至与人们执行预定手动任务的方式自然融合——我们不会每次都试图去做任务，却被告知时间还没到，我们只是试图只在该做的时候做任务。</p><p id="4952" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，虽然云引入了由于针对特定问题提供的多个选项而做出糟糕选择的可能性，但它真的不是什么新东西。在生活中，有很多方法去做事情，一个人必须选择哪种方法是最佳的，并且在特定的情况下更有意义。云没有任何不同，如果我们仔细想想，它是美丽的，因为它给人们提供了一个发挥创造力和独创性的机会。</p></div></div>    
</body>
</html>