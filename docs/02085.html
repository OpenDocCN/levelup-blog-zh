<html>
<head>
<title>Avoiding Shared Mutable State in JavaScript by Deep Copying Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过深度复制数据避免JavaScript中的共享可变状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/avoiding-shared-mutable-state-in-javascript-by-deep-copying-data-3c541614f884?source=collection_archive---------16-----------------------#2020-02-17">https://levelup.gitconnected.com/avoiding-shared-mutable-state-in-javascript-by-deep-copying-data-3c541614f884?source=collection_archive---------16-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/91cb501492f84b34fdacb4c14a2cd271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nldw6ucpIO681kBB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约根·哈兰在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4630" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与其他编程语言一样，JavaScript将数据存储在变量中，这些变量可以随时更改。这可能会导致一个问题，因为我们可能会意外地改变正在共享的变量。让许多代码共享同一个可变状态是很难追踪的。这使得调试和阅读代码变得困难。</p><p id="e7e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们在不同的函数中改变同一个数组如下:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="afdd" class="ln lo it lj b gy lp lq l lr ls">let arr = [];<br/>const foo = () =&gt; {<br/>  arr = [1, 2, 3];<br/>}</span><span id="c53a" class="ln lo it lj b gy lt lq l lr ls">const bar = () =&gt; {<br/>  arr = [4, 5, 6];<br/>}</span></pre><p id="ebd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe lu lv lw lj b">arr</code>的值根据最后调用的是<code class="fe lu lv lw lj b">foo</code>还是<code class="fe lu lv lw lj b">bar</code>而变化。如果<code class="fe lu lv lw lj b">foo</code>被调用，那么<code class="fe lu lv lw lj b">arr</code>就是<code class="fe lu lv lw lj b">[1, 2, 3]</code>。另一方面，如果调用了<code class="fe lu lv lw lj b">bar</code>，那么<code class="fe lu lv lw lj b">arr</code>就是<code class="fe lu lv lw lj b">[4, 5, 6]</code>。</p><p id="0918" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个问题，因为代码越复杂，函数调用就越多。如果许多函数都这样做，那么跟踪值就很困难，调试也很混乱。</p><p id="2ea7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，很难理解调用带有这些副作用的函数时逻辑是如何流动的。</p><p id="f363" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何通过制作数据的深层副本来进行数据的深层复制，以防止程序中共享状态的突变。此外，我们还研究了防止从类方法中暴露的数据突变的方法。</p><h1 id="4da9" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">深层拷贝</h1><h2 id="0be8" class="ln lo it bd ly mu mv dn mc mw mx dp mg kr my mz mk kv na nb mo kz nc nd ms ne bi translated">嵌套扩展</h2><p id="db71" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">我们可以在对象的每一层使用spread操作符来手动进行深度复制。</p><p id="edf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设我们有以下对象:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="cb19" class="ln lo it lj b gy lp lq l lr ls">const obj = {<br/>  foo: {<br/>    bar: 1,<br/>    baz: 2<br/>  },<br/>  a: 3<br/>}</span></pre><p id="9784" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以对其进行如下深度复制:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="833b" class="ln lo it lj b gy lp lq l lr ls">const objCopy = {<br/>  foo: {<br/>    ...obj.foo<br/>  },<br/>  a: obj.a<br/>};</span></pre><p id="255d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，当我们有更多的级别和属性时，这将是一个问题。然而，我们确实得到了原始对象的深层副本。</p><h1 id="c8a7" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">通过JSON.stringify和JSON.parse进行深度复制</h1><p id="cb42" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">我们可以调用<code class="fe lu lv lw lj b">JSON.stringify</code>返回一个对象的字符串，然后调用stringify上的<code class="fe lu lv lw lj b">JSON.parse</code>将其返回到原始形式。</p><p id="142a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这适用于JSON支持的所有属性和值，这意味着像符号和函数这样的实体被排除在外。</p><p id="3da0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9cc7" class="ln lo it lj b gy lp lq l lr ls">const obj = {<br/>  foo: {<br/>    bar: 1,<br/>    baz: 2<br/>  },<br/>  a: 3<br/>}</span><span id="a709" class="ln lo it lj b gy lt lq l lr ls">const objCopy = JSON.parse(JSON.stringify(obj));</span></pre><p id="8dfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lj b">objCopy</code>将是<code class="fe lu lv lw lj b">obj</code>的深度复制。这是因为如果一个字符串是不可变的，并且<code class="fe lu lv lw lj b">JSON.parse</code>返回一个新的解析过的stringified对象的副本。</p><h1 id="da44" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">复制类的实例</h1><p id="7c76" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">我们可以比复制对象更容易地复制一个类的实例。我们可以编写一个返回对象实例的<code class="fe lu lv lw lj b">clone</code>方法来完成这个任务。</p><p id="2705" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码来创建一个从另一个类继承的类:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="bc8c" class="ln lo it lj b gy lp lq l lr ls">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="c684" class="ln lo it lj b gy lt lq l lr ls">class Employee extends Person {<br/>  constructor(name, employeeCode) {<br/>    super(name);<br/>    this.employeeCode = employeeCode;<br/>  }</span><span id="b950" class="ln lo it lj b gy lt lq l lr ls">  clone() {<br/>    return new Employee(this.name, this.employeeCode);<br/>  }<br/>}</span></pre><p id="28c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe lu lv lw lj b">clone</code>来创建一个新的复制对象:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="390a" class="ln lo it lj b gy lp lq l lr ls">const employee = new Employee('Joe', 1);<br/>const employeeClone = employee.clone();</span><span id="8491" class="ln lo it lj b gy lt lq l lr ls">console.log(employee.__proto__);<br/>console.log(employeeClone.__proto__);</span></pre><p id="39d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe lu lv lw lj b">Employee</code>类的<code class="fe lu lv lw lj b">clone</code>方法中，我们返回了一个<code class="fe lu lv lw lj b">Employee</code>的新实例。</p><p id="4251" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在前2个<code class="fe lu lv lw lj b">console.log</code>输出中，我们看到<code class="fe lu lv lw lj b">employee</code>和<code class="fe lu lv lw lj b">employeeClone</code>具有相同的原型。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/28fd67e4964c85f2826f4387012771c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CxV_FLdnn3rMvJSk"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kf" href="https://unsplash.com/@tamtit24?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">bùI Thanh TM</a>拍摄的照片</figcaption></figure><h1 id="192c" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">为什么复制有助于防止共享状态突变？</h1><p id="6dda" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">复制防止了共享状态的突变，因为我们在试图改变共享数据之前复制了它。这很方便，因为它可以防止我们意外地更改共享数据。</p><p id="7c4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不对共享数据进行更改，那么跟踪它就很容易。那么我们就不必担心代码的不同部分会意外地改变相同的状态。</p><h1 id="2415" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">在进行更改之前复制公开的内部类数据</h1><p id="3237" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">在对内部类数据进行修改之前，我们应该复制一份，然后在方法中返回它。这使得我们无法直接更改类数据。</p><p id="69f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的类:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0e76" class="ln lo it lj b gy lp lq l lr ls">class NumArray {<br/>  constructor() {<br/>    this._arr = [];<br/>  }</span><span id="f6af" class="ln lo it lj b gy lt lq l lr ls">  add(num) {<br/>    this._arr.push(num);<br/>  }</span><span id="4939" class="ln lo it lj b gy lt lq l lr ls">  getParts() {<br/>    return this._arr;<br/>  }</span><span id="69cb" class="ln lo it lj b gy lt lq l lr ls">  toString() {<br/>    return this._arr.join('');<br/>  }<br/>}</span></pre><p id="4183" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过编写以下代码以各种方式调用这些方法:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="11c4" class="ln lo it lj b gy lp lq l lr ls">const numArr = new NumArray();<br/>numArr.add(1);<br/>numArr.add(2);<br/>console.log(numArr.toString());<br/>numArr.getParts().length = 0;<br/>console.log(numArr.toString());</span></pre><p id="d879" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到第一个<code class="fe lu lv lw lj b">console.log</code>的值是<code class="fe lu lv lw lj b">'1,2'</code>，第二个记录了一个空字符串。</p><p id="4b27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为我们改变了由<code class="fe lu lv lw lj b">getParts</code>方法公开的数组的<code class="fe lu lv lw lj b">length</code>属性。我们将其设置为0，因此数组被清空。</p><p id="5cac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了防止这种情况，我们可以在<code class="fe lu lv lw lj b">getParts</code>中返回数组之前复制它。我们改为编写以下内容:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b678" class="ln lo it lj b gy lp lq l lr ls">class NumArray {<br/>  constructor() {<br/>    this._arr = [];<br/>  }</span><span id="db18" class="ln lo it lj b gy lt lq l lr ls">  add(num) {<br/>    this._arr.push(num);<br/>  }</span><span id="3699" class="ln lo it lj b gy lt lq l lr ls">  getParts() {<br/>    return [...this._arr];<br/>  }</span><span id="a817" class="ln lo it lj b gy lt lq l lr ls">  toString() {<br/>    return this._arr.join(',');<br/>  }<br/>}</span></pre><p id="9e75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们对<code class="fe lu lv lw lj b">NumArray</code>类的方法进行同样的调用时，如下所示:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9e22" class="ln lo it lj b gy lp lq l lr ls">const numArr = new NumArray();<br/>numArr.add(1);<br/>numArr.add(2);<br/>console.log(numArr.toString());<br/>numArr.getParts().length = 0;<br/>console.log(numArr.toString());</span></pre><p id="3c9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在两个<code class="fe lu lv lw lj b">console.log</code>输出中都得到<code class="fe lu lv lw lj b">'1,2'</code>。</p><p id="b2bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过各种方式对数据进行深度复制。首先，我们可以通过在每个级别上重复使用spread操作符来手动复制数据。</p><p id="2c12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用<code class="fe lu lv lw lj b">JSON.stringify</code>和<code class="fe lu lv lw lj b">JSON.parse</code>来复制可以包含在JSON中的数据。</p><p id="789b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于类实例，我们可以创建一个方法，通过用相同的数据返回一个新的数据实例来返回类的实例。这保留了数据和继承结构。</p><p id="424b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以防止类方法中公开的数据被修改，方法是在方法中返回数据之前对其进行复制。</p></div></div>    
</body>
</html>