<html>
<head>
<title>The Real Potential in Java 14’s Records</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 14记录的真正潜力</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-real-potential-in-java-14s-records-dd42a24dc739?source=collection_archive---------6-----------------------#2020-08-24">https://levelup.gitconnected.com/the-real-potential-in-java-14s-records-dd42a24dc739?source=collection_archive---------6-----------------------#2020-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d7e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">输入更少的代码很好，但这只是冰山一角。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a715cf95b7217300bd294305a1979a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jVwZKpDiLbuAYIvO"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="958e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java 14引入的所有特性<a class="ae ky" href="https://www.techgeeknext.com/java/java14-features" rel="noopener ugc nofollow" target="_blank">中，可能最令人兴奋的是</a><a class="ae ky" href="https://www.techgeeknext.com/java/java14-features#rp" rel="noopener ugc nofollow" target="_blank">记录</a>。</p><p id="20fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员长期以来一直抱怨在创建简单的Java类时需要编写和维护繁琐、不必要的代码。记录——目前是预览功能——承诺改变这一切。Java开发人员很兴奋，这是理所当然的。但是他们是因为所有正确的理由而兴奋吗？</p><h2 id="0402" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">这不仅仅是保存击键</h2><p id="7767" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Java以冗长、臃肿的语言而闻名。也许最突出的原因是语言迫使我们实现编译器应该能够自己发现的方法。这些方法包括:</p><ul class=""><li id="e0d2" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">每个字段的getters和setters</li><li id="16da" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">初始化字段的显式构造函数</li><li id="19db" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe nh ni nj nk b">equals()</code>、<code class="fe nh ni nj nk b">hashCode()</code>、<code class="fe nh ni nj nk b">toString()</code>等方法</li></ul><p id="8433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以当<a class="ae ky" href="https://openjdk.java.net/jeps/359" rel="noopener ugc nofollow" target="_blank"> JEP 359:记录(预览)</a>展开时，许多开发者站起来鼓掌。然而，这种掌声大多只是庆祝我们不再需要打字的按键。我们找到的关于这个主题的大多数文章采取以下形式:</p><p id="d1cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">这里是我们到目前为止在创建一个类时必须做的事情:</em></p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="1990" class="lv lw it nk b gy nq nr l ns nt">final class Point {<br/>    public final int x;<br/>    public final int y;<br/><br/>    public Point(int x, int y) {<br/>        this.x = x;<br/>        this.y = y;<br/>    }</span><span id="4455" class="lv lw it nk b gy nu nr l ns nt">    public boolean equals(Point that) {<br/>        return this.x == that.x and this.y = that.y<br/>    }</span><span id="b57b" class="lv lw it nk b gy nu nr l ns nt">    public int hashCode() {<br/>        return 31 * x + y;<br/>    }</span><span id="5a9a" class="lv lw it nk b gy nu nr l ns nt">    public String toString() {<br/>         return "Point: x:" + x + " y:" + y;<br/>    }</span><span id="66a6" class="lv lw it nk b gy nu nr l ns nt">}</span></pre><p id="43e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">下面是我们需要对记录做的所有事情:</em></p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="2caf" class="lv lw it nk b gy nq nr l ns nt">record Point(int x, int y) { }</span></pre><p id="044a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">这样我们就不需要打字了！结束了。</em></p><p id="8b64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这的确值得兴奋。但是当谈话到此为止时，它错过了许多更令人兴奋的事情。</p><p id="4bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍我所看到的记录的一些主要好处。首先，我们将更多地讨论理论上的，记录促进好的软件设计的一些方法。然后，我们将讨论Records即将推出的一个实用、强大的功能——深度模式匹配。</p><h1 id="79f9" class="nv lw it bd lx nw nx ny ma nz oa ob md jz oc ka mg kc od kd mj kf oe kg mm of bi translated">设计的东西</h1><p id="ce84" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当我第一次开始用Java编程时，我学到了正确设计类的规则:</p><ul class=""><li id="b2bd" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">我应该显式实现<code class="fe nh ni nj nk b">equals()</code></li><li id="a9d5" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果我计划覆盖<code class="fe nh ni nj nk b">equals()</code>，那么我也必须覆盖<code class="fe nh ni nj nk b">hashCode()</code></li><li id="4533" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">我应该覆盖我的类的<code class="fe nh ni nj nk b">toString()</code>方法</li><li id="16dd" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果对我的类有一个自然的排序，我应该实现<code class="fe nh ni nj nk b">Comparable</code>并提供一个<code class="fe nh ni nj nk b">compareTo()</code>实现</li><li id="b210" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">按照JavaBean规范，我应该保持我的类的成员是私有的，并实现公共的getter/setter。</li></ul><p id="c88c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有些事我不太喜欢。特别是，那些规则对我写的许多类来说没有意义。</p><h2 id="3eb6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">名词对动词</h2><p id="424b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">渐渐地，我开始意识到有两种类别:<em class="nl">名词</em>和<em class="nl">动词</em>。</p><p id="c5e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">名词</em>代表事物。它们储存数据。它们是我们在第一个OO教程中学习的那些类:<em class="nl">形状</em>、<em class="nl">圆形</em>、<em class="nl">正方形</em>和<em class="nl">三角形</em>；<em class="nl">停车场</em>、<em class="nl">车轮</em>、<em class="nl">发动机</em>、<em class="nl">车门</em>。它们保持自己的状态，并需要适当的封装。我们通常会实例化它们中的许多，我们需要跟踪它们并对它们进行比较。</p><p id="0a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">动词</em>则执行动作。这些是Spring应用程序中的<em class="nl">控制器</em>，Hibernate层中的<em class="nl"> DAOs </em>，以及web应用程序中的<em class="nl">web控制器</em>。它们不维护任何状态，除了对依赖关系的引用(依赖关系本身通常是动词)。我们通常会创建类的单个实例，因此不需要定制<code class="fe nh ni nj nk b">equals()</code>、<code class="fe nh ni nj nk b">hashCode()</code>等的实现。</p><p id="6a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java中的具体类在历史上都是同一类型的。虽然框架可能提供了一些机制，但是直到现在还没有语言级别的特性可以将原型应用到类中。</p><h2 id="e224" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">建模数据</h2><p id="4efa" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有了记录，我们可以更清楚地表达我们的意图。我们现在可以说，“这个类是一个<em class="nl">的东西</em>。它被设计用来存储数据，并将数据从一个地方转移到另一个地方。”除了减少击键次数，记录还允许我们简明地对特定的<em class="nl">名词</em>类(也称为<em class="nl">数据类</em>)包含的数据建模。</p><p id="ed47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要简单地相信我的话。在<a class="ae ky" href="https://openjdk.java.net/jeps/359" rel="noopener ugc nofollow" target="_blank">官方的JEP </a>中，作者自己声明:</p><blockquote class="og oh oi"><p id="ed1c" class="kz la nl lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">虽然表面上很容易将记录视为主要是关于样板文件的减少，但我们选择了一个更具语义的目标:<em class="it">将数据建模为数据</em>。</p></blockquote><h2 id="7bb7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">不变</h2><p id="7265" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">关于我的名词/数据类，一些别的东西开始困扰我。如果<code class="fe nh ni nj nk b"><em class="nl">fooA</em>.equals(<em class="nl">fooB</em>)</code> <em class="nl">现在是</em>，那么<code class="fe nh ni nj nk b">fooA</code> <em class="nl">不应该总是</em>等于<code class="fe nh ni nj nk b">fooB</code>吗？或者可能更重要的是(当我们考虑像HashMaps这样的结构时)，应该允许任何<em class="nl"> </em> class' <code class="fe nh ni nj nk b">hashCode()</code>值改变吗？</p><p id="652d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是，<code class="fe nh ni nj nk b">equals()</code>和<code class="fe nh ni nj nk b">hashCode()</code>的输出是由对象的内部状态决定的。如果该状态被允许改变，那么由对象的<code class="fe nh ni nj nk b">equals()</code>和<code class="fe nh ni nj nk b">hashCode()</code>返回的值可能会因此而改变。</p><p id="c91d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这当然是一个<em class="nl">可变性</em>的问题。Java作为一种语言——以及它根深蒂固的约定——鼓励可变的数据结构。然而，在许多情况下，出于许多原因，我们实际上应该支持不可变的结构。像<code class="fe nh ni nj nk b">equals()</code>和<code class="fe nh ni nj nk b">hashCode()</code>这样的方法的返回值的变化是一个原因。共享的、可变的对象导致的意外错误是另一个原因。</p><p id="97d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，如果我们愿意，我们可以通过以下方式将我们的Java数据类设计成不可变的:</p><ul class=""><li id="155d" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">宣布所有的班级成员成为最终的<em class="nl">成员</em></li><li id="b7cf" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">实现一个构造函数，它在实例化过程中设置这些成员的值</li><li id="255a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">省略任何setters(编译器无论如何都不允许这样做)</li><li id="b9a4" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">理想情况下，声明类本身<em class="nl"> final </em>，不允许用额外的可变成员扩展类</li></ul><p id="59c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是它是非标准的，并且需要显式的工作。这是规则的例外。</p><p id="297f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用记录，字段是隐式最终的。我们的构造函数是为我们创建的，用于在实例化时设置那些最终字段。换句话说，不变性成为记录的规则。</p><h1 id="bd5d" class="nv lw it bd lx nw nx ny ma nz oa ob md jz oc ka mg kc od kd mj kf oe kg mm of bi translated">有趣的事情:模式匹配</h1><p id="2cb3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">记录为函数式编程语言中常见的一个极其强大的特性打开了大门，这个特性被称为<em class="nl">深度模式匹配</em>。如果看到“模式匹配”时，您的第一个想法是“正则表达式”，那么，如果不是在正确的位置上，您就在正确的范围内。</p><p id="0383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了描述模式匹配，让我们从Java迄今为止提供的最接近模式匹配的东西开始。然后我们将继续讨论提供真正的深度模式匹配的JVM语言的例子:Scala。</p><h2 id="5f77" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"><em class="om"/></strong>的实例</h2><p id="3669" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">虽然Java是静态类型的，但它也是多态的。所以我们在运行时可能并不总是知道类的确切类型。为此，Java提供了操作符的<em class="nl">实例。</em></p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="1198" class="lv lw it nk b gy nq nr l ns nt">public void attendTo(Animal a) {<br/>  if (a instanceof Dog) {<br/>    walk((Dog)a);<br/>  } else if (a instanceof Cat) {<br/>    cleanLitterBoxOf((Cat)a);<br/>  } else if (a instanceof Bird) {<br/>    cleanCageOf((Bird)a);<br/>  } else {<br/>    returnToStore(a);<br/>  }<br/>}</span></pre><p id="fae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无独有偶，操作符的<em class="nl">实例在Java 14中也得到了增强，称为</em> 实例的<a class="ae ky" href="https://openjdk.java.net/jeps/305" rel="noopener ugc nofollow" target="_blank"> <em class="nl">模式匹配。最明显的好处是，我们不再需要执行冗长且容易出错的强制转换，这使得我们可以像这样重写上面的示例:</em></a></p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="07ea" class="lv lw it nk b gy nq nr l ns nt">public void attendTo(Animal a) {<br/>  if (a instanceof Dog d) {<br/>    walkDog(d);<br/>  } else if (a instanceof Cat a) {<br/>    cleanLitterBoxOf(a);<br/>  } else if (a instanceof Bird b) {<br/>    clearCageOf(b);<br/>  } else {<br/>    returnToStore(a);<br/>  }<br/>}</span></pre><p id="ea0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以声明我们要检查的类型的变量；该变量将隐式地“转换”给我们。例如，在上面的第二行中，<em class="nl"> d </em>已经是类型<code class="fe nh ni nj nk b">Dog</code>；我们没有必要为了调用像<code class="fe nh ni nj nk b">public void walkDog(Dog d)</code>这样的方法而显式地转换它。</p><p id="c4ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到的第二个好处是，我们可以在我们的<em class="nl"> if </em>语句中使用这个变量。假设我们不想遛狗，如果它是一只拉布拉多犬；相反，我们想让它在湖边跑来跑去(有人告诉我，因为实验室喜欢水):</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="41f5" class="lv lw it nk b gy nq nr l ns nt">public void attendTo(Animal a) {<br/>  if (a instanceof Dog d and d.breed == Breed.Labrador) {<br/>    letDogRunByLake(d);<br/>  } else if (a instanceof Dog d) {<br/>    walkDog(d);<br/>  }<br/>  // ...<br/>}</span></pre><p id="be55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很强大的东西，是吧？但权力也就到此为止了。我们可以捕获隐式转换的变量(例如<em class="nl"> Dog d </em>)以备后用，但这是我们真正能捕获的全部。该特性名义上被称为“模式匹配”，但它是一种非常有限的形式，我们可以称之为“浅层”</p><h2 id="df09" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak"> <em class="om">开关</em> </strong></h2><p id="d8d3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在让我们切换…到Java的<em class="nl"> switch </em>语句。switch语句还提供了模式匹配的阴影。我们可以使用switch语句来匹配数值变量的值:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="2f3b" class="lv lw it nk b gy nq nr l ns nt">int i = ...<br/>String s = null;<br/>switch (i) {<br/>  case 0: <br/>    s = "none";<br/>    break;<br/>  case 1: <br/>    s = "one";<br/>    break;<br/>  default: <br/>    s = "many;<br/>}</span></pre><p id="03af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Java 7开始，字符串也可以打开:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="8242" class="lv lw it nk b gy nq nr l ns nt">int i = -1;<br/>String s = ...;<br/>switch (s) {<br/>  case "none":<br/>    i = 0;<br/>    break;<br/>  case "one":<br/>    i = 1;<br/>    break;<br/>  default:<br/>    i = 2;<br/>}</span></pre><p id="fde6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到最近，<em class="nl">开关</em>还只是一个<em class="nl">语句</em>，只能控制流量。有了Java 12，<em class="nl">开关</em>现在可以作为<em class="nl">表达式</em>；即发出一个新值:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="a340" class="lv lw it nk b gy nq nr l ns nt">int i = ...<br/>String s = switch (i) {<br/>  case 0 -&gt; "none";<br/>  case 1 -&gt; "one";<br/>  default -&gt; "many;<br/>}</span></pre><p id="9fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们想象我们可以将switch表达式与的最新<em class="nl">实例结合起来:</em></p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="073c" class="lv lw it nk b gy nq nr l ns nt">Animal a = ... // get a concrete instance of an Animal subclass<br/>String s = switch (a) {<br/>  case (Dog d &amp;&amp; d.breed == <!-- -->Breed.Labrador<!-- -->) -&gt; <br/>      "A dog that likes to swim";<br/>  case (Dog d) -&gt; "dog of breed " + d.breed;<br/>  case (Cat c) -&gt; "cat of breed " + c.breed;<br/>  default -&gt; "some other animal";<br/>}</span></pre><p id="9fc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们不能在Java中做到这一点；该代码将无法编译。但是如果我们可以，那么我们将开始看到模式匹配的真正力量。</p><h2 id="ef07" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">包含案例类的案例研究</h2><p id="2c21" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Scala是一种运行在JVM上的混合OO/函数式语言。Scala提供了许多强大的特性。其中之一，<em class="nl">深度模式匹配</em>。随着记录的引入，似乎更有可能被添加到Java开发人员的工具箱中。</p><p id="e16a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入细节之前，让我们看看如何使用Scala的模式匹配来实际实现最后一个(一厢情愿的)例子(<a class="ae ky" href="https://medium.com/@dt_23597/scala-syntax-for-java-developers-69734ce17cdf" rel="noopener">如果您不熟悉Scala的语法</a>，请查看本文):</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="0151" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">val</strong> a: Animal = ... // get a concrete instance of an Animal subclass<br/><strong class="nk iu">val</strong> s = a <strong class="nk iu">match</strong> {<br/>  <strong class="nk iu">case</strong> <em class="nl">Dog</em>(_, <em class="nl">Labrador</em>()) =&gt; "a dog that likes to swim"<br/>  <strong class="nk iu">case</strong> <em class="nl">Dog</em>(_, b) =&gt; s"a dog of breed $b"<br/>  <strong class="nk iu">case</strong> <em class="nl">Cat</em>(_, b) =&gt; s"a cat of breed $b"<br/>  <strong class="nk iu">case</strong> _ =&gt; "some other animal"<br/>}</span></pre><p id="a8cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉Scala，上面例子中最令人困惑的部分可能是case块本身。您可能会猜测，如果第一行匹配，<code class="fe nh ni nj nk b"><em class="nl">s</em></code>将被赋予字符串值<em class="nl">“一只喜欢游泳的狗”… </em>，但是<code class="fe nh ni nj nk b"><em class="nl">Dog</em>(_, Labrador())</code>到底会匹配什么呢？</p><p id="0feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要探索Scala中的<em class="nl">用例类</em>。Case类从一开始就是Scala的一等公民。Java记录非常类似于case类；乍一看，case类与记录非常相似:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="730b" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">case</strong> <strong class="nk iu">class</strong> Dog(name: String, breed: Breed) <strong class="nk iu">extends</strong> Animal</span></pre><p id="d561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还提供与唱片相同的内容:</p><ul class=""><li id="e92a" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">一个构造函数(以名为<code class="fe nh ni nj nk b">apply()</code>的函数的形式)，它接受并设置所有的字段(这里，<em class="nl"> name </em>和<em class="nl"> breed </em>)。除此之外，这个<code class="fe nh ni nj nk b">apply</code>方法允许我们在实例化一个case类时省略<em class="nl"> new </em>关键字(例如<code class="fe nh ni nj nk b">val d = Dog(“Fido”, Labrador())</code>而不是<code class="fe nh ni nj nk b">val d = new Dog(“Fido”, Labrador()</code></li><li id="15c5" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">隐式不可变字段</li><li id="2f1a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">字段的getters</li><li id="e653" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe nh ni nj nk b">equals()</code>、<code class="fe nh ni nj nk b">hashCode()</code>和<code class="fe nh ni nj nk b">toString()</code>实施</li></ul><p id="196f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Case类还隐含地提供了两个更重要的东西。第一个是<code class="fe nh ni nj nk b">copy()</code>方法，它允许我们制作一个case类实例的副本，在这个过程中修改特定的字段。比如<code class="fe nh ni nj nk b">val d2 = d.copy(name="Buddy")</code>。</p><p id="0999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个是<em class="nl">提取器</em>功能。就像构造函数获取<em class="nl">单个字段</em>并从中创建<em class="nl">对象实例</em>一样，提取器获取<em class="nl">对象实例</em>并返回<em class="nl">单个字段</em>作为元组。在Scala中，提取器采用名为<code class="fe nh ni nj nk b">unapply()</code>的函数形式。</p><p id="f897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在上面的例子中，<code class="fe nh ni nj nk b">Dog</code>的提取器将返回一个<code class="fe nh ni nj nk b">(String, Breed)</code>的元组。如果我们手工编写的话，下面是<code class="fe nh ni nj nk b">Dog</code>的构造函数和提取函数的样子:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="3940" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">def</strong> apply(name: String, breed: Breed) = {<br/>    new Dog(name, breed)<br/>}</span><span id="c29c" class="lv lw it nk b gy nu nr l ns nt"><strong class="nk iu">def</strong> unapply(d: Dog): Option[(String, Breed)] = {<br/>    Some(d.name, d.breed)<br/>}</span></pre><p id="e77c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(注意<code class="fe nh ni nj nk b">Option</code>和Java的<code class="fe nh ni nj nk b">Optional</code>差不多，<code class="fe nh ni nj nk b">Some</code>是<code class="fe nh ni nj nk b">Option</code>的子类。在这个练习中，你可以忽略所有这些。)</p><p id="386f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细看，你可能会注意到一些东西。<em class="nl">提取器</em>(忽略<code class="fe nh ni nj nk b">Option</code>包装器)的返回值看起来与传递给我们的case类的<em class="nl">构造器/apply </em>方法的参数相同。</p><p id="d888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们利用Scala的深度模式匹配时，我们是在匹配提取器的返回值。但是我们可以像使用对象的构造函数一样编写模式。</p><p id="b40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再看看上面的例子:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="1967" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">val</strong> s = a <strong class="nk iu">match</strong> {<br/>  <strong class="nk iu">case</strong> <em class="nl">Dog</em>(_, <em class="nl">Labrador</em>()) =&gt; "a dog that likes to swim"<br/>  <strong class="nk iu">case</strong> <em class="nl">Dog</em>(_, b) =&gt; s"a dog of breed $b"<br/>  <strong class="nk iu">case</strong> <em class="nl">Cat</em>(_, b) =&gt; s"a cat of breed $b"<br/>  <strong class="nk iu">case</strong> _ =&gt; "some other animal"<br/>}</span></pre><p id="f97d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在来看看以下val:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="45dd" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">val</strong> d1 = <em class="nl">Dog</em>("Buddy", <em class="nl">Labrador</em>()) <br/>  <em class="nl">// d1 matches the first case; it is a Labrador Dog with a name</em><br/><strong class="nk iu">val</strong> d2 = <em class="nl">Dog</em>("Fido", <em class="nl">Labrador</em>()) <br/>  <em class="nl">// d2 also matches the first case; it too is a Labrador with a name</em><br/><strong class="nk iu">val</strong> d3 = <em class="nl">Dog</em>("Pongo", <em class="nl">Dalmatian</em>()) <br/>  <em class="nl">// d3 matches the second case; it's a Dog, but not a Labrador</em><br/><strong class="nk iu">val</strong> c1 = <em class="nl">Cat</em>("Morris", <em class="nl">Tabby</em>()) <br/>  <em class="nl">// c1 matches the third case; it's a Cat of some breed</em></span></pre><p id="0e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nh ni nj nk b">Breed</code>和<code class="fe nh ni nj nk b">Labrador</code>类会是什么样子？<code class="fe nh ni nj nk b">Breed</code>可能是一个特征(类似于Java接口),而<code class="fe nh ni nj nk b">Labrador</code>可能是一个案例类:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="0647" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">trait</strong> Breed { }<br/><strong class="nk iu">case</strong> <strong class="nk iu">class</strong> Labrador() <strong class="nk iu">extends</strong> Breed</span></pre><p id="48fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把事情扩展一下。拉布拉多可以有多种颜色；比如<em class="nl">黄色</em>(又名<em class="nl">金色</em>)<em class="nl">黑色、</em>和<em class="nl">巧克力</em>。让我们添加一个可以传递给我们的<code class="fe nh ni nj nk b">Labrador</code>案例类的<code class="fe nh ni nj nk b">Color</code>案例类:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="6304" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">case</strong> <strong class="nk iu">class</strong> Color(value: String)<br/><strong class="nk iu">case</strong> <strong class="nk iu">class</strong> Labrador(color: Color) <strong class="nk iu">extends</strong> Breed</span></pre><p id="7796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以像这样创建一个实例:<br/> <code class="fe nh ni nj nk b"><strong class="lb iu">val</strong> d = <em class="nl">Dog</em>("Fido", <em class="nl">Labrador</em>(<em class="nl">Color</em>("yellow")))</code> <br/>并使用下面的模式匹配找到它:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="417c" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">val</strong> s = a match {<br/>  <strong class="nk iu">case</strong> <em class="nl">Dog</em>(n, <em class="nl">Labrador</em>(<em class="nl">Color</em>("yellow"))) =&gt; s"a Golden Lab named $n"<br/>  <strong class="nk iu">...</strong><br/>}</span></pre><p id="09cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，当我们这样做时，我们已经捕获并使用了<code class="fe nh ni nj nk b">Dog</code>的名称(通过<em class="nl"> n </em>变量)。</p><p id="6245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您已经可以看到这将变得多么强大。但是我们再举一个例子。Scala提供了一个名为<code class="fe nh ni nj nk b">Either[A,B]</code>的密封抽象类。任何一个都是有效的联合类型。被密封后，<code class="fe nh ni nj nk b">Either</code>的所有子类都是在编译时定义的；其实<code class="fe nh ni nj nk b">Either</code>只有两个子类:<code class="fe nh ni nj nk b">Left[A]</code>和<code class="fe nh ni nj nk b">Right[B]</code>。这允许Scala函数返回两种完全不同的类型之一。</p><p id="89ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们创建一个非<code class="fe nh ni nj nk b">Animal</code>案例类:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="90cd" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">case class</strong> Alien(planet: String, numberOfEyes: Int)</span></pre><p id="59ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这个功能之外:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="ff1f" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">def</strong> whoDugUpMyFlowers(): Either[Alien, Animal] =<br/>  if (Random.nextBoolean()) {<br/>    <em class="nl">Right</em>(<em class="nl">Dog</em>("Buddy", <em class="nl">Labrador</em>(<em class="nl">Color</em>("yellow"))))<br/>  } else {<br/>    <em class="nl">Left</em>(<em class="nl">Alien</em>("Neptune", 7))<br/>  }</span></pre><p id="1b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以对该函数的结果进行模式匹配，如下所示:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="5bbe" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">val</strong> v = <em class="nl">whoDugUpMyFlowers()</em><br/>v match {<br/>  <strong class="nk iu"><em class="nl">case</em></strong><em class="nl"> Left(Alien(p, e))</em> =&gt; println(s"A $e-eyed alien from $p")<br/>  <strong class="nk iu"><em class="nl">case</em></strong><em class="nl"> Right(Dog(n, b))</em> =&gt; println(s"A $b named $n")<br/>}</span></pre><p id="63fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">Option[A]</code>类类似，提供两个子类:<code class="fe nh ni nj nk b">Some[A]</code>和<code class="fe nh ni nj nk b">None</code>。我们可以用同样的方式对<code class="fe nh ni nj nk b">Option</code>的实例进行模式匹配:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="b602" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">val</strong> maybeDog: Option[Dog] = whatIsInMyYardRightNow()<br/>maybeDog match {<br/>  <strong class="nk iu"><em class="nl">case</em></strong><em class="nl"> Some(Dog(_, _))</em> =&gt; println(s"A dog is in my yard")<br/>  <strong class="nk iu"><em class="nl">case</em></strong><em class="nl"> None</em> =&gt; println("Nothing is in my yard")<br/>}</span></pre><p id="1a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，Java没有<code class="fe nh ni nj nk b">Either</code>或<code class="fe nh ni nj nk b">Option</code>类。但是没有什么能阻止我们写自己的，特别是一旦<a class="ae ky" href="https://openjdk.java.net/jeps/360" rel="noopener ugc nofollow" target="_blank"> JEP 360:密封类(预览版)</a>在Java 15中出现。</p><h1 id="634e" class="nv lw it bd lx nw nx ny ma nz oa ob md jz oc ka mg kc od kd mj kf oe kg mm of bi translated">Records和Java目前缺什么？</h1><p id="c31a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">记录有望为Java语言带来大大改进的数据建模、不可变的数据对象和强大的特性，比如深度模式匹配。</p><p id="8e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们还没到那一步。当然，记录JEP仍然是一个预览语言功能。但是记录，从设计上来说，有一些苛刻的限制。此外，记录——以及Java语言本身——缺少一些真正有用的重要特性。</p><p id="04e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不意味着没有希望的理由。例如，<a class="ae ky" href="https://openjdk.java.net/jeps/359" rel="noopener ugc nofollow" target="_blank"> <em class="nl"> JEP 359记录</em> </a> <em class="nl"> </em>文档本身多次提到模式匹配作为可能的未来添加。</p><p id="8017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为了让记录在Java中真正发挥其潜力，我们还希望有什么其他的语言特性呢？</p><h2 id="af03" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">复制()</h2><p id="18d3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">不变性很重要。它保护我们免受运行时可能发生的许多潜在错误的影响，并且它通常使我们更容易对代码进行推理。但是，不变性存在一个问题。那就是，我们不能修改我们的数据结构。</p><p id="93d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这才是重点。但是当我们有一个数据类和名词的实例时，我们只需要修改一个字段，这就很困难了。就目前的记录而言，我们需要构建一个全新的实例，复制除了我们想要修改的字段之外的所有字段:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="79cc" class="lv lw it nk b gy nq nr l ns nt"><strong class="nk iu">Dog</strong> <em class="nl">dog1</em> = <br/>  new <strong class="nk iu">Dog</strong>("Fido", new Labrador("chocolate"), "2019-07-01")<br/>// let's rename our dog<br/><strong class="nk iu">Dog</strong> <em class="nl">dog2</em> =<br/>  new <strong class="nk iu">Dog</strong>("Buddy", dog1.breed, dog1.dateOfBirth)</span></pre><p id="b5ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使像记录这样的不可变数据类真正可行，它们应该提供一些机制来轻松地产生修改后的副本。正如我们之前简单提到的，Scala的case类通过隐式生成的<code class="fe nh ni nj nk b">copy()</code>方法提供了一个简单的解决方案:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="ffc0" class="lv lw it nk b gy nq nr l ns nt">dog1.copy(name = "Buddy")</span></pre><p id="11f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，Java不允许我们按名称传递方法参数，所以向记录中添加一个<code class="fe nh ni nj nk b">copy()</code>方法不会那么简单。我们可能会认为这个特性——按名称传递参数——是Java中的一个语言特性。但不知何故，这似乎不像是我们在语言中所能期待的。但是，我们可以想象一个隐式创建的“复印机”被添加到记录中，允许我们做如下事情:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="2167" class="lv lw it nk b gy nq nr l ns nt">Dog dog2 = dog1.copier.name("Buddy").makeCopy()</span></pre><h2 id="748d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">元组</h2><p id="cdaa" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">正如我们在Scala中看到的，针对类的深度模式匹配依赖于提取器方法。反过来，提取器方法依赖于元组。我很难想到提取器可以产生的另一种数据结构。</p><p id="e63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组是一个简单的概念，但是Java语言从来没有直接支持它们。当然，各种库提供了它们自己的实现，但是为了支持像提取器这样的语言级特性，它们本身需要在语言级实现。</p><h2 id="e264" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">提取器/解构器</h2><p id="7232" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当然，除非元组用于实现提取器/解构器，否则它对我们没有帮助。<a class="ae ky" href="https://openjdk.java.net/jeps/359" rel="noopener ugc nofollow" target="_blank"> <em class="nl"> JEP 359 </em> </a>文档暗示解构器模式可能会作为未来的语言特性被添加进来。</p><h2 id="9c10" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">展开性</h2><p id="4fe3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们在这里讨论的记录的两大优势是:</p><ul class=""><li id="0240" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><em class="nl">名词</em>或<em class="nl">数据类</em>的正确语义建模。</li><li id="15d9" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">深度模式匹配</li></ul><p id="14ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些优点都可能受到记录不能扩展的限制，它们也不能扩展任何其他类。例如，像这样的类层次结构是不可能的:</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="c9fe" class="lv lw it nk b gy nq nr l ns nt">       Animal                              Shape<br/>__________|___________             __________|___________     <br/> ↓        ↓          ↓              ↓        ↓          ↓<br/>Dog      Cat      Bird             Circle  Square   Triangle</span></pre><p id="6cec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本原理是有道理的:记录必须是不可变的。不应该允许它扩展任何可能包含可变字段的类，也不应该允许任何其他类扩展记录并添加自己的可变字段。此外，我们希望开发人员能够快速推理出给定记录的结构。</p><p id="0ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，记录能够实现接口(包括默认方法)。此外，将来将记录与<a class="ae ky" href="https://openjdk.java.net/jeps/360" rel="noopener ugc nofollow" target="_blank">密封类</a>(另一个预览特性)配对可能会使记录扩展其他记录变得安全可行。</p><h1 id="b605" class="nv lw it bd lx nw nx ny ma nz oa ob md jz oc ka mg kc od kd mj kf oe kg mm of bi translated">摘要</h1><p id="8f11" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">减少我们需要输入的样板文件的数量足以让我们对记录感到兴奋。但正如《JEP》的作者所指出的，事情远不止如此。记录将允许我们清楚地模拟数据。它们使得创建不可变的数据结构变得容易。它们为一些非常强大的特性进入Java语言打开了大门。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="a6c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">觉得这个故事有用？想多读点？只需<a class="ae ky" href="https://dt-23597.medium.com/subscribe" rel="noopener">在这里订阅</a>就可以将我的最新故事直接发送到你的收件箱。</p><p id="f5eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天<a class="ae ky" href="https://dt-23597.medium.com/membership" rel="noopener">成为媒体会员</a>，你也可以支持我和我的写作，并获得无限数量的故事。</p></div></div>    
</body>
</html>