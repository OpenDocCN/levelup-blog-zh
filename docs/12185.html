<html>
<head>
<title>I18N for Angular microfrontends using Ngx-Locutus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Ngx-Locutus的角形微前端的I18N</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-new-approach-to-i18n-in-angular-d46476b9874e?source=collection_archive---------1-----------------------#2022-05-22">https://levelup.gitconnected.com/a-new-approach-to-i18n-in-angular-d46476b9874e?source=collection_archive---------1-----------------------#2022-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fad2732efc2862f2e503b62ed5a45dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nM3A9EakI9ZqLp4F"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@arptrastogi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Arpit Rastogi </a>拍摄的照片</figcaption></figure><p id="8591" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您是否曾经面临过将一个单片的Angular应用程序迁移到微前端架构的问题，或者只是想将您的应用程序重构为库？如果这本身不是一个挑战，那么将翻译文件分离到每个库和微前端以获得真正的独立性仍然是一个大问题。</p><h2 id="91e3" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">为什么还要分离翻译文件呢？</h2><p id="519d" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">微前端架构的要点是独立部署，因此不允许微前端之间存在依赖关系。</p><h2 id="4fb0" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">为什么它不能开箱即用。</h2><p id="2940" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">通常，您使用一个流行的主流i18n库，如Ngx-Translate或Transloco，这两个库默认情况下都从assets文件夹中加载翻译，其中为每种语言保存了一个json文件。</p><p id="7174" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">微前端使用翻译。</strong>当应用程序加载到浏览器中时，只有应用程序外壳的assets文件夹会存在于应用程序外壳上下文中。因此，不允许在微前端中相对引用翻译文件。相反，您必须编写一个CustomLoader，它通过引用绝对Uri的HttpClient获取翻译文件，如下所示:</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="ed18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将出现的新问题是，当运行应用程序shell时，这个http.get将遇到CORS错误，因为这是一个明显的安全问题。然而，我们可以通过在应用程序外壳中创建一个proxy.conf.json来再次绕过这一点，欺骗应用程序外壳，使其认为它调用了自己，而实际上它向微前端资产的来源发出了请求。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="db96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后将此配置添加到project.json/package.json serve部分的options部分:</p><pre class="mc md me mf gt mi mj mk ml aw mm bi"><span id="5f1d" class="le lf it mj b gy mn mo l mp mq">“proxyConfig”: “apps/shell/proxy/proxy.conf.json”</span></pre><p id="4969" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你的微前端已经被翻译了，但是你的库呢？你的库本身不像你的应用程序那样运行在一个端口上，所以你不能像以前那样编写一个自定义加载器。相反，您可以创建一个预构建脚本，将libraries文件夹中的所有资源合并到应用程序资源中。一方面，这是一种真正的可能性，但另一方面，整个翻译过程被过度设计了很多。</p><p id="4c41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">个人备注:</p><blockquote class="mr ms mt"><p id="7379" class="kg kh mu ki b kj kk kl km kn ko kp kq mv ks kt ku mw kw kx ky mx la lb lc ld im bi translated">我花了大约一周时间寻找这个问题的清晰解决方案，因为我真的不喜欢构建预构建脚本或创建全局翻译文件。我只是在想，如果翻译文件是纯typescript常量，并且不能在assets文件夹中引用，事情会简单得多。这样一切都可以很容易地分开。</p></blockquote><p id="2863" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我创建了一个替代的开源库来解决这个问题。😁</p><h1 id="664a" class="my lf it bd lg mz na nb lj nc nd ne lm nf ng nh lp ni nj nk ls nl nm nn lv no bi translated">Ngx-Locutus</h1><div class="np nq gp gr nr ns"><a href="https://github.com/HaasStefan/ngx-locutus" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub-HaasStefan/ngx-locutus:Angular的可选国际化(i18n)库</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">用于大规模微前端翻译的可选角度翻译库。不再担心…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og jz ns"/></div></div></a></div><ul class=""><li id="6c44" class="oh oi it ki b kj kk kn ko kr oj kv ok kz ol ld om on oo op bi translated">每个翻译都有一个范围</li><li id="496c" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated">每个翻译都是纯打字稿</li><li id="68f9" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated">翻译在单例服务中注册</li></ul><h2 id="489b" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">Typescript翻译常数万岁</h2><p id="74f9" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在Ngx-Locutus中，每个翻译文件都被实现为一个纯Typescript常量。一方面，这很好，因为翻译不是作为资产提供的，而是作为真正的代码，不需要以任何方式引用。另一方面，它甚至更酷，因为我们可以为每个翻译文件做一个接口定义，这样我们就可以保证每种语言都有相同的对象原型。</p><h2 id="971b" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">延迟加载翻译范围</h2><p id="1c4c" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">为了不一次加载所有的翻译，我们为每种语言实现了一个TranslationLoader，它实现了一个函数，当调用该函数时，它会缓慢地导入翻译并将其作为可观察的结果返回。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8159" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，<strong class="ki iu">非常重要的一点是</strong>惰性导入实际上是<strong class="ki iu">硬编码的</strong>，因为否则翻译文件将被Ivy从树上摇下来——这意味着它们将不会包含在包中！</p><h2 id="064e" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">导入和配置LocutusModule</h2><p id="d201" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在AppModule中，我们将调用静态函数<strong class="ki iu"> forRoot() </strong>，在该函数中，我们传递一个翻译配置，该配置由作用域名称、翻译加载器和最初应该使用的语言组成。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4e36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于功能模块，我们简单地使用<strong class="ki iu"> forChild() </strong>函数，它也由作用域和加载器组成，但不是初始语言。</p><h2 id="f66a" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">翻译API</h2><p id="b441" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在Ngx-Locutus中进行实际的翻译是非常直接和灵活的。你可以使用一个指令让你在模板中使用作用域的翻译，或者你可以使用管道。</p><p id="47b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该指令只需要指定作用域，并为其翻译对象服务。它在后台自动订阅，每当语言改变或注册新的翻译时，就会触发重新加载。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="dca8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">管道转换翻译对象的键，并将范围作为参数。它以可观察的形式返回翻译，这样当语言发生变化时，您总能得到新的翻译。</p><figure class="mc md me mf gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="903a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您需要访问代码中的翻译，您应该使用以下方法之一:</p><ul class=""><li id="a367" class="oh oi it ki b kj kk kn ko kr oj kv ok kz ol ld om on oo op bi translated"><strong class="ki iu">翻译</strong>(范围:字符串，关键:字符串):可观察&lt;字符串&gt;</li><li id="e803" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated"><strong class="ki iu"> getTranslations </strong>(范围:字符串):可观察&lt; any &gt;</li><li id="9bd1" class="oh oi it ki b kj oq kn or kr os kv ot kz ou ld om on oo op bi translated"><strong class="ki iu"> instant </strong> (scope: string，key: string): string <em class="mu"> //未找到则抛出错误</em></li></ul><p id="4673" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">强烈建议避免使用instant，因为很容易在最初几秒钟内抛出错误，因为翻译的延迟加载可能需要几毫秒。</p><h1 id="3806" class="my lf it bd lg mz na nb lj nc nd ne lm nf ng nh lp ni nj nk ls nl nm nn lv no bi translated">结论</h1><p id="4db0" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">国际化应该是一件容易的事情，不管是使用monolith还是microfrontends。Ngx-Locutus是一种新的方法，试图涵盖这两种架构。我很高兴收到任何批评和祝福，因为我期待着继续开发Ngrx-Locutus。</p><div class="np nq gp gr nr ns"><a href="https://github.com/HaasStefan/ngx-locutus" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub-HaasStefan/ngx-locutus:Angular的可选国际化(i18n)库</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">用于大规模微前端翻译的可选角度翻译库。不再担心…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og jz ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://www.npmjs.com/package/ngx-locutus" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">ngx-locutus</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">用于大规模微前端翻译的可选角度翻译库。不再担心…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.npmjs.com</p></div></div><div class="ob l"><div class="ov l od oe of ob og jz ns"/></div></div></a></div><p id="83c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想阅读无限量的文章并支持我，你可以使用我的推荐链接，这样我就可以获得50%的月/年费:</p><div class="np nq gp gr nr ns"><a href="https://medium.com/@stefan.haas.privat/membership" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">通过我的推荐链接-斯特凡·哈斯加入媒体</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="ow l od oe of ob og jz ns"/></div></div></a></div></div></div>    
</body>
</html>