<html>
<head>
<title>FCeph — What is Multipart upload, OMAP, and Resharding?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FCeph——什么是多部分上传、OMAP和重新共享？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ceph-what-is-multipart-upload-omap-and-resharding-b72d339c939f?source=collection_archive---------3-----------------------#2020-03-21">https://levelup.gitconnected.com/ceph-what-is-multipart-upload-omap-and-resharding-b72d339c939f?source=collection_archive---------3-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/40f6c4502b4d0a3366d3ed6cd91dad9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*t3zJ6VGo4a-6uDZU6YwoDA.png"/></div></figure><h1 id="6789" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">什么是多部分？</h1><p id="edf7" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">通常，使用multipart，您可以分部分上传大型对象文件。多部分包括三个步骤，如下所述。</p><p id="ea68" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">多部分上传的好处如下:</p><ul class=""><li id="a888" class="ly lz it kx b ky lt lc lu lg ma lk mb lo mc ls md me mf mg bi translated">暂停/恢复必要的部分；</li><li id="5087" class="ly lz it kx b ky mh lc mi lg mj lk mk lo ml ls md me mf mg bi translated">提高性能—更高的吞吐量</li><li id="44bb" class="ly lz it kx b ky mh lc mi lg mj lk mk lo ml ls md me mf mg bi translated">在创建过程中上传对象。</li></ul><h1 id="093a" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">三个步骤:</h1><ul class=""><li id="fcec" class="ly lz it kx b ky kz lc ld lg mm lk mn lo mo ls md me mf mg bi translated"><strong class="kx iu">Multipart Upload Initiation:</strong>当请求上传一个对象文件时，首先得到的是上传ID。这是您上传的唯一编号/标识符。</li><li id="d85a" class="ly lz it kx b ky mh lc mi lg mj lk mk lo ml ls md me mf mg bi translated"><strong class="kx iu">零件上传:</strong>重要的是要记住，除了上传ID，我们还需要零件ID。这意味着每次上传都有上传ID和零件ID。请注意，如果您使用现有零件ID上传新文件，此零件将被覆盖。</li><li id="38db" class="ly lz it kx b ky mh lc mi lg mj lk mk lo ml ls md me mf mg bi translated"><strong class="kx iu">多部分上传完成或中止</strong>:为了完成多部分流程，我们需要完成所有部分的上传。只有当过程完成时，我们得到所有部分都没问题的ACK，然后我们才能将上传标记为完成。请注意，如果上传过程被中止，则多部分过程会停滞，永远不会结束，除非有生命周期规则，或者您再次重新上传多部分对象文件。</li></ul><h1 id="b65d" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">我们来练习一下:</h1><p id="67a3" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">首先，您可以使用Ceph-Nano项目创建一个Ceph集群。在这里你可以找到更多关于它的细节:<a class="ae mp" href="https://github.com/ceph/cn" rel="noopener ugc nofollow" target="_blank">https://github.com/ceph/cn</a>。</p><p id="5a91" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">一旦集群开始工作并准备就绪，请按照以下步骤来理解Ceph池中的多部分是什么样子的。</p><p id="b017" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">让我们看看一个对象上传后在池中的样子。从上传对象开始:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7c7b" class="mz jy it mv b gy na nb l nc nd">aws s3 cp avi_test s3://test --endpoint-url <a class="ae mp" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></span></pre><p id="c8cd" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">然后，让我们使用以下命令查看名为:<strong class="kx iu"> default.rgw.buckets.data </strong>的池:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0347" class="mz jy it mv b gy na nb l nc nd">rados ls -p default.rgw.buckets.data</span></pre><p id="7c6c" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">默认情况下，该池包含用户通过RGW上传到集群的所有数据。输出应该类似于:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="933d" class="mz jy it mv b gy na nb l nc nd">cdeb898f-18fb-4509-b886-5bd67c627abb.14119.1_avi_test</span></pre><p id="e93a" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">请注意<strong class="kx iu">cdeb 898 f-18fb-4509-b886–5bd 67 c 627 abb . 14119 . 1</strong>是铲斗标记。</p><p id="c002" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">为了实现多部分，我们可以使用awscli工具。不得不说，用户端应该为多部分chuncks设置多部分阈值。让我们用dd命令创建一个:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8b07" class="mz jy it mv b gy na nb l nc nd">dd if=/dev/zero of=testfile bs=1024 count=10240</span></pre><p id="53db" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">您也可以使用truncate命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="80c3" class="mz jy it mv b gy na nb l nc nd">truncate -s 20M text.txt</span></pre><p id="249b" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">让我们上传这个文件。默认情况下，awscli工具支持多部分上传。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="12ef" class="mz jy it mv b gy na nb l nc nd">aws s3 cp testfile s3://test --endpoint-url <a class="ae mp" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></span></pre><p id="6394" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">再次键入命令“rados ls -p pool name ”,请注意这一次，它看起来像是:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0aca" class="mz jy it mv b gy na nb l nc nd">cdeb898f-18fb-4509-b886-5bd67c627abb.14119.1__multipart_testfile.2~Ebr8ghHTE-SGwufDxS_GaDp6WnZ9AA7.1</span></pre><p id="b7de" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">正如我前面提到的，我们有一个上传ID和一个零件ID:</p><p id="0ee4" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated"><strong class="kx iu"><em class="ne">UploadID:</em></strong>. 2 ~ EBR 8 ghhte-SGwufDxS _ gadp 6 wnz 9 aa 7 |<strong class="kx iu"><em class="ne">PartID:</em></strong>。1(在行尾)</p><p id="ea8e" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">此外，如果我们运行命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="afd4" class="mz jy it mv b gy na nb l nc nd">radosgw-admin bucket stats | grep "bucket name" -A 15</span></pre><p id="8a2a" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们将看到存储桶id没有变化:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1414" class="mz jy it mv b gy na nb l nc nd">"id": "cdeb898f-18fb-4509-b886-5bd67c627abb.14119.1"</span></pre><p id="2ad9" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">当使用multipart时，对象被上传到名为:<strong class="kx iu">" default . rgw . buckets . non-EC "</strong>的池中。当多部分未被使用时，该池将为空。只有当multipart运行时，我们才会看到该池中的对象。</p><p id="a499" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">要查看所有多部分上传状态，请运行以下命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="47f3" class="mz jy it mv b gy na nb l nc nd">aws s3api list-multipart-uploads --bucket my-bucket</span></pre><h1 id="b757" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">垃圾收集器:</h1><p id="a107" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当用户删除文件或上传同名文件时，文件会被覆盖(也是在re-multipart中)，Ceph会将它们插入到一个叫做GC的东西中。</p><p id="115f" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">Ceph不会立即删除文件，我们可以使用以下命令列出所有计划删除的文件:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="160e" class="mz jy it mv b gy na nb l nc nd">radosgw-admin gc list</span></pre><p id="4710" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">并且:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="cca7" class="mz jy it mv b gy na nb l nc nd">radosgw-admin gc list --include-all</span></pre><p id="9ad2" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">指定-包含-全部列出所有条目，包括未过期的条目。</p><p id="27e3" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">默认情况下，Ceph在gc周期之间等待2个小时。要手动运行gc删除过程，请运行:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c752" class="mz jy it mv b gy na nb l nc nd">radosgw-admin gc process --include-all</span></pre><h1 id="5b71" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Ceph索引和重新分级</h1><h2 id="931d" class="mz jy it bd jz nf ng dn kd nh ni dp kh lg nj nk kl lk nl nm kp lo nn no kt np bi translated">什么是OMAP？</h2><p id="214a" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">索引对象的OMAP包含池中所有对象的键值。</p><p id="fcb3" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">重要的是这个池叫做:<strong class="kx iu">" default . rgw . buckets . index "</strong>。基本上它是桶的索引。让我们运行命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1a9c" class="mz jy it mv b gy na nb l nc nd">rados ls -p default.rgw.buckets.index</span></pre><p id="6733" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们将看到桶id，从״.dir.״:开始</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2640" class="mz jy it mv b gy na nb l nc nd">.dir.cdeb898f-18fb-4509-b886-5bd67c627abb.14119.1</span></pre><p id="b737" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">要列出该存储桶中的对象，请编写以下命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ac17" class="mz jy it mv b gy na nb l nc nd">rados listomapkeys -p default.rgw.buckets.index .dir.cdeb898f-18fb-4509-b886-5bd67c627abb.14119.1</span></pre><p id="8750" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">输出:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="28bd" class="mz jy it mv b gy na nb l nc nd">avi_test</span></pre><p id="c284" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">有些情况下，OMAP会变得越来越大，例如:一个OMAP中有一千万个对象。这可能会影响我们的表现。基本上，我们在发送写请求时读取索引，然后它搜索应该写入对象的正确位置。</p><p id="ceff" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">正因为如此，我们可以使用重阴影选项，这个命令获取一个大的OMAP并将其切割成碎片。因此，对于一个桶，我们将有几个OMAPs。最佳实践是每个分片100，000个对象。</p><p id="43c8" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">要检查每个存储桶的状态，我们可以使用以下命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="169c" class="mz jy it mv b gy na nb l nc nd">radosgw-admin check limit | grep "OVER 100.000000%"</span></pre><p id="ec48" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">这个命令为我们找到具有大OMAPs的存储桶。</p><p id="7506" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">部分输出:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="bb45" class="mz jy it mv b gy na nb l nc nd">"fill_status": "OVER 100.000000%"</span></pre><p id="7bbc" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">这意味着桶超过了限制，我们需要进行重新授权过程。</p><p id="08c4" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">重要的事情:请注意，当重散列过程正在运行时，这个桶没有I/O，尽管对于不太大的桶来说，这是一个相当快的过程。我的建议是，在每一个reshard过程之前，请咨询支持人员。</p><p id="9ce9" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">要列出所有存储桶，请使用以下命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="776e" class="mz jy it mv b gy na nb l nc nd">radosgw-admin bucket list</span></pre><p id="6b51" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">一旦我们发现有问题的存储桶，我们可以使用命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9791" class="mz jy it mv b gy na nb l nc nd">radosgw-admin bucket reshard --num-shard 2 --bucket=test</span></pre><p id="bf97" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">我们将看到，现在我们有两个OMAPS:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="9287" class="mz jy it mv b gy na nb l nc nd">rados ls -p <!-- -->default.rgw.buckets.index</span><span id="a013" class="mz jy it mv b gy nq nb l nc nd">.dir.cdeb898f-18fb-4509-b886-5bd67c627abb.14270.1.0<br/>.dir.cdeb898f-18fb-4509-b886-5bd67c627abb.14270.1.1</span></pre><p id="3afe" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">基本上，我们会看到部分文件位于第一个OMAP，而其他文件位于第二个。</p><p id="d2fb" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">要更改每个分片的最大对象数的值，请编辑该值(请事先咨询支持人员):</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="73b4" class="mz jy it mv b gy na nb l nc nd">rgw_max_objects_per_shard = 100000 to something else.</span></pre><h1 id="7109" class="jx jy it bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">什么是RGW动态桶指数重排序？</h1><p id="2c68" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">基本上，在大型环境中工作，重新共享过程可能会非常令人沮丧。这个特性可以帮助解决这个问题，它检测有问题的存储桶，并在后台运行进程，为这个存储桶创建所需的碎片。</p><h2 id="6170" class="mz jy it bd jz nf ng dn kd nh ni dp kh lg nj nk kl lk nl nm kp lo nn no kt np bi translated">它是如何工作的？</h2><p id="dcc1" class="pw-post-body-paragraph kv kw it kx b ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">当一个新对象被添加到桶中时。此外，还有一个定期运行的自动后台进程。一旦我们有了所需的存储桶，这个存储桶就被添加到reshard队列中。</p><p id="8cd1" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">要列出列表中当前的所有存储桶，请键入以下命令:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a528" class="mz jy it mv b gy na nb l nc nd">radosgw-admin reshard list</span></pre><p id="816d" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">要检查流程的状态，请执行以下操作:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="3a15" class="mz jy it mv b gy na nb l nc nd">radosgw-admin reshard status --bucket &lt;bucket_name&gt;</span></pre><p id="a6a2" class="pw-post-body-paragraph kv kw it kx b ky lt la lb lc lu le lf lg lv li lj lk lw lm ln lo lx lq lr ls im bi translated">启用/禁用动态存储桶索引重散列，在/etc/ceph/ceph.conf的rgw部分下进行更改。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8adf" class="mz jy it mv b gy na nb l nc nd">rgw_dynamic_resharding = true</span></pre></div></div>    
</body>
</html>