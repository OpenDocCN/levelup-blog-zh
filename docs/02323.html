<html>
<head>
<title>Event Driven Programming in C# — Observer Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的事件驱动编程——观察者模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/event-driven-programming-in-c-observer-pattern-7a8d790bbdb2?source=collection_archive---------0-----------------------#2020-03-06">https://levelup.gitconnected.com/event-driven-programming-in-c-observer-pattern-7a8d790bbdb2?source=collection_archive---------0-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3b9a8b46891136c4e0dba2a4e42dc43d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gg9x-mmt2Fy_IzVB"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@shanehauser" rel="noopener ugc nofollow" target="_blank">沙恩·豪泽</a>在<a class="ae jg" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="6472" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的上一篇文章—<a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/event-driven-programming-in-c-9264efb06c01"><em class="le">c#</em></a>中的事件驱动编程中，我讲述了使用发布者-订阅者方法在ASP.Net核心应用程序中实现事件驱动架构的基础知识。</p><p id="2ef5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们来看看观察者模式——另一种用C#实现事件驱动编程的方式。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="9ae3" class="lm ln jj bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">观察者与发布者-订阅者模式</h1><p id="42ce" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">乍一看，观察者模式似乎与发布-订阅模式几乎相同。</p><p id="bc8c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<em class="le">可观察的</em>(发布者)发出事件。<br/>观察者<em class="le"/>(订阅者)订阅可观察对象，并在发出事件通知时执行操作。</p><p id="28e1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的关键区别在于事件通知如何传达给观察者(订阅者)。</p><p id="6400" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在发布-订阅模式中，事件通知是通过使用<em class="le">事件处理程序来实现的— </em>是一个抽象层，它将发布者和订阅者分离开来。发布者不需要知道订阅者。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/72a5bf7935ba3467e40baf1b9526cffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*vgThxKlfmbVZvUpjDyTU8w.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">在发布订阅中，事件处理程序充当发布者和订阅者之间的代理。发布者不需要知道关于订阅者的任何事情。</figcaption></figure><p id="d7c1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在观察者模式中，<em class="le">观察者</em>(发布者)必须跟踪<em class="le">观察者</em>(订阅者)。可观察对象将事件发送给每个观察者。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/ed991709c65a4c47f455996e12d8f71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*b1zjdFXbUb5LxDX3NROXSQ.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">可观察对象保存了一个观察对象列表。当一个事件发生时，一个通知事件必须被发送到被观察对象正在跟踪的每个用户。</figcaption></figure><p id="9a5f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就个人而言，我会选择发布-订阅而不是观察者模式，因为这种架构的耦合要松散得多。然而，有些人可能更喜欢Observer模式，因为它实现简单。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="fce1" class="lm ln jj bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">在C#中实现观察者模式</h1><p id="a627" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">与发布-订阅模式非常相似，观察者模式也可以说由两个“参与者”组成:</p><ul class=""><li id="f8ce" class="mu mv jj ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="ki jk">可观察:</strong>相当于Pub-Sub中的发布者；这是通知事件的类(事件发射器)。在C#中，这由<code class="fe nd ne nf ng b">IObservable&lt;T&gt;</code>接口来表示</li><li id="c4ed" class="mu mv jj ki b kj nh kn ni kr nj kv nk kz nl ld mz na nb nc bi translated"><strong class="ki jk">观察者:</strong>相当于发布订阅中的订阅者；这是响应事件的类。在C#中，这由<code class="fe nd ne nf ng b">IObserver&lt;T&gt; </code>接口表示。</li></ul><p id="d7da" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的图表是我展示可观察对象和观察者如何相互作用的最佳尝试。</p><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/bc47bf7934cd7bfe29b4c3cc6d1e5048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdKQ2aD5MfCV0ZkjWj-SXg.png"/></div></div></figure><p id="2f25" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是代码的样子:</p><p id="f179" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> #1 —事件类别</strong></p><p id="a256" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只是一个用于表示事件的标准POCO类。它应该包含响应事件所需的所有必要信息。示例:</p><pre class="mq mr ms mt gt nn ng no np aw nq bi"><span id="4b70" class="nr ln jj ng b gy ns nt l nu nv">public class SomeEvent<br/>{<br/>    public string Description{ get; set; }<br/>    public DateTime Date { get; set; }</span><span id="c2ea" class="nr ln jj ng b gy nw nt l nu nv">    public SomeEvent(string description, DateTime date)<br/>    {<br/>        Description = description;<br/>        Date = date;<br/>    }<br/>}</span></pre><p id="315a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"># 2——可观察类</strong></p><p id="ea85" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可观察对象是事件发射器(事件从那里产生)。</p><p id="6c21" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可观察对象必须:</p><ul class=""><li id="139c" class="mu mv jj ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated">维护一份观察员名单。<br/> <em class="le">提供商有责任跟踪哪些观察者已经订阅。</em></li><li id="6d0e" class="mu mv jj ki b kj nh kn ni kr nj kv nk kz nl ld mz na nb nc bi translated">实现<code class="fe nd ne nf ng b">IObservable&lt;T&gt;</code>接口。<br/>这需要实现一个<code class="fe nd ne nf ng b">Subscribe()</code>方法并定义一个<code class="fe nd ne nf ng b">Unsubcriber </code> (IDisposible)类。</li></ul><p id="0914" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nd ne nf ng b">Subcribe()</code>方法为观察者提供了一种订阅和获得事件通知的方式。</p><p id="0d80" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nd ne nf ng b">Unsubscriber </code>类为观察者提供了取消订阅通知的方法。</p><p id="018d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，记得在事件发生时通知观察员！</p><pre class="mq mr ms mt gt nn ng no np aw nq bi"><span id="7738" class="nr ln jj ng b gy ns nt l nu nv">public class NotificationProvider : IObservable&lt;SomeEvent&gt;<br/>{<br/>    // Maintain a list of observers<br/>    private List&lt;IObserver&lt;SomeEvent&gt;&gt; _observers;</span><span id="f291" class="nr ln jj ng b gy nw nt l nu nv">    public NotificationProvider()<br/>    {<br/>        _observers = new List&lt;IObserver&lt;SomeEvent&gt;&gt;();<br/>    }</span><span id="551c" class="nr ln jj ng b gy nw nt l nu nv">    // Define Unsubscriber class<br/>    private class Unsubscriber : IDisposable<br/>    {<br/>        private List&lt;IObserver&lt;SomeEvent&gt;&gt; _observers;<br/>        private IObserver&lt;SomeEvent&gt; _observer;</span><span id="2ce9" class="nr ln jj ng b gy nw nt l nu nv">        public Unsubscriber(List&lt;IObserver&lt;SomeEvent&gt;&gt; observers,<br/>                            IObserver&lt;SomeEvent&gt; observer)<br/>        {<br/>            this._observers = observers;<br/>            this._observer = observer;<br/>        }</span><span id="73d0" class="nr ln jj ng b gy nw nt l nu nv">        public void Dispose()<br/>        {<br/>            if (!(_observer == null)) _observers.Remove(_observer);<br/>        }<br/>    }</span><span id="dfa6" class="nr ln jj ng b gy nw nt l nu nv">    // Define Subscribe method<br/>    public IDisposable Subscribe(IObserver&lt;SomeEvent&gt; observer)<br/>    {<br/>        if (!_observers.Contains(observer))<br/>            _observers.Add(observer);</span><span id="b218" class="nr ln jj ng b gy nw nt l nu nv">        return new Unsubscriber(_observers, observer);<br/>    }</span><span id="4b97" class="nr ln jj ng b gy nw nt l nu nv">// Notify observers when event occurs<br/>    public void NotificationEvent(string description)<br/>    {<br/>        foreach (var observer in _observers)<br/>        {<br/>            observer.OnNext(new SomeEvent(description, <br/>                            DateTime.Now));<br/>        }<br/>    }<br/>}</span></pre><p id="d0e3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> #3 —观察者类</strong></p><p id="153c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">观察者根据发送的通知类型来响应事件。在C#中，有3种通知方法(或类型)可以调用:</p><p id="7101" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"><em class="le">on next():</em></strong><em class="le">为观察者提供新的数据。<br/></em><strong class="ki jk"><em class="le">on completed():</em></strong><em class="le">通知观察者提供者遇到了错误情况。<br/></em><strong class="ki jk"><em class="le">on error():</em></strong><em class="le">通知观察者提供者已经完成发送基于推送的通知。</em></p><p id="debe" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">观察员必须:</p><ul class=""><li id="0318" class="mu mv jj ki b kj kk kn ko kr mw kv mx kz my ld mz na nb nc bi translated">实现<code class="fe nd ne nf ng b">IObserver</code>接口。<br/>这意味着实施上述3种方法。</li><li id="046f" class="mu mv jj ki b kj nh kn ni kr nj kv nk kz nl ld mz na nb nc bi translated">实现一个<code class="fe nd ne nf ng b">Subscribe </code>方法。<br/>这又调用了可观察对象的<code class="fe nd ne nf ng b">Subscribe </code>方法。</li></ul><pre class="mq mr ms mt gt nn ng no np aw nq bi"><span id="8f56" class="nr ln jj ng b gy ns nt l nu nv">public class NotificationSubscriber : IObserver&lt;SomeEvent&gt;<br/>{<br/>    private IDisposable _unsubscriber;</span><span id="858d" class="nr ln jj ng b gy nw nt l nu nv">    public virtual void Subscribe(IObservable&lt;SomeEvent&gt; provider)<br/>    {<br/>        // Subscribe to the Observable<br/>        if (provider != null)<br/>            _unsubscriber = provider.Subscribe(this);<br/>    }</span><span id="7de2" class="nr ln jj ng b gy nw nt l nu nv">    public virtual void OnCompleted()<br/>    {<br/>        Console.WriteLine("Done");<br/>    }</span><span id="0850" class="nr ln jj ng b gy nw nt l nu nv">    public virtual void OnError(Exception e)<br/>    {<br/>        Console.WriteLine($"Error: {e.Message}");<br/>    }</span><span id="cb98" class="nr ln jj ng b gy nw nt l nu nv">    public virtual void OnNext(SomeEvent ev)<br/>    {<br/>        Console.WriteLine($"{ev.Date}: {ev.Description}");<br/>    }</span><span id="9ea7" class="nr ln jj ng b gy nw nt l nu nv">    public virtual void Unsubscribe()<br/>    {<br/>        _unsubscriber.Dispose();<br/>    }<br/>}</span></pre><p id="58e9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> #4 —订阅</strong></p><p id="b23d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，观察者必须认同可观察的事物才能让一切运转。</p><pre class="mq mr ms mt gt nn ng no np aw nq bi"><span id="bcad" class="nr ln jj ng b gy ns nt l nu nv">public class Program<br/>{<br/>    public static void Main(string[] args)<br/>    {<br/>        var observable = new NotificationProvider();<br/>        var observer = new NotificationSubscriber();<br/>        observer.Subscribe(observable);</span><span id="e4c6" class="nr ln jj ng b gy nw nt l nu nv">        observable.NotificationEvent("Event 1 just happened");<br/>        observable.NotificationEvent("Event 2 just happened");<br/>        observable.NotificationEvent("Event 3 just happened");<br/>    }<br/>}</span><span id="4863" class="nr ln jj ng b gy nw nt l nu nv">// Output<br/>6/03/2020 9:16:56 PM: Event 1 just happened<br/>6/03/2020 9:16:56 PM: Event 2 just happened<br/>6/03/2020 9:16:56 PM: Event 3 just happened</span></pre><figure class="mq mr ms mt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/7fec04fb0f9def61f804cf996e1190a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bs1yYSBbvhx0XM5TGPS3YQ.png"/></div></div></figure><p id="11e6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整的代码如下:</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="0f42" class="lm ln jj bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">参考</h1><ul class=""><li id="8ee8" class="mu mv jj ki b kj mk kn ml kr oa kv ob kz oc ld mz na nb nc bi translated"><a class="ae jg" href="https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/standard/events/observer-design-pattern</a></li><li id="cd96" class="mu mv jj ki b kj nh kn ni kr nj kv nk kz nl ld mz na nb nc bi translated"><a class="ae jg" href="https://stackoverflow.com/questions/17020011/iobserver-and-iobservable-in-c-sharp-for-observer-vs-delegates-events/17020368" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/17020011/iob server-and-iob servable-in-c-sharp-for-observer-vs-delegates-events/17020368</a></li></ul></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="9c67" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这篇文章对你有用。感谢阅读！</p></div></div>    
</body>
</html>