<html>
<head>
<title>Here’s what you should know about interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以下是你应该知道的关于接口的知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/heres-what-you-should-know-about-interfaces-808be7852ef7?source=collection_archive---------7-----------------------#2022-03-19">https://levelup.gitconnected.com/heres-what-you-should-know-about-interfaces-808be7852ef7?source=collection_archive---------7-----------------------#2022-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e6c1e40ea7a85b6c07c88c05af005779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XhNkimfHeDK7wgw0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">詹姆斯·哈里逊在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="db36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://medium.com/@kunal.nalawade25/oop-just-a-glimpse-354815efd81e" rel="noopener">之前的一篇</a>文章中，我给了你OOP世界的一瞥及其概念的概述。但是有一个概念我想单独介绍一下，那就是接口。要理解接口，你首先需要知道什么是<a class="ae kc" href="https://www.javatpoint.com/abstract-class-in-java" rel="noopener ugc nofollow" target="_blank">抽象类</a>。</p><h1 id="8f89" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">接口和抽象类有什么不同？</h1><p id="fac5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">抽象类不能被实例化(你不能创建它的对象)，它们必须有一个子类。抽象函数没有主体，必须在子类中重写。</p><p id="f6e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接口就像一个抽象类，只是它的所有方法都是抽象的，变量是公共的、静态的和最终的(常量)。接口不能有实例变量和方法实现(默认方法除外),抽象类不是这样。一个类可以实现多个接口，但是不管抽象如何，只能扩展一个类。</p><h1 id="df42" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是接口？</h1><p id="2826" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接口用于实现抽象。在Java中，接口的声明方式如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a252" class="mn lc iq mj b gy mo mp l mq mr">interface ABC {<br/>   void fun1();<br/>   int add(int a, int b);<br/>}</span></pre><p id="2aae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接口中的方法没有主体，因为它们都是抽象的。下面是一个类如何实现一个接口。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3143" class="mn lc iq mj b gy mo mp l mq mr">class A implements ABC {<br/>    void fun1() { ... }<br/>    int add(int a, int b) { ... }<br/>}</span></pre><p id="670a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你实现一个接口时，你必须定义它的所有函数，否则，编译器会抛出一个错误。</p><p id="2dbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现接口是一种继承形式，其中类继承接口内的方法和变量。接口用于实现多态性，这提供了最大的灵活性。您可以以任何方式实现这些方法。</p><p id="1f81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样考虑吧，扩展一个类就像出生在一个具有某些固定特征的家庭中，而实现一个接口就像学习其他不依赖于你的层次结构的东西。</p><h1 id="e842" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么时候使用接口？</h1><p id="40d4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如前所述，当您想要实现抽象和多态时，请使用接口。当一个类实现一个接口时，这个类来自哪个层次(继承)并不重要。任何类都可以实现一个接口并覆盖它的函数。当你希望你的类执行一个特定的<strong class="kf ir">角色</strong>时，使用接口。</p><p id="6df4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑下面的例子。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/a1d230752f4d477feb2085bb38698c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urxahYi1mrCcar3cdhYpvQ.png"/></div></div></figure><p id="bc7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<em class="mt"> Dog </em>类，它扩展了<em class="mt"> Animal </em>类并覆盖了它的一个方法。现在，让我们创建一个接口<em class="mt"> Pet </em>并让<em class="mt"> Dog </em>实现它。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/df7978e3862d485f6130a46375feba44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-pDFuupzzSV5MVMFHkt2eQ.png"/></div></div></figure><p id="1f69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦<em class="mt">狗</em>实现了接口，它就必须定义<em class="mt">宠物</em>的方法。在这个例子中，<em class="mt">狗</em>是<em class="mt">动物</em>层次的一部分，并且能够继承<em class="mt">动物</em>的大部分属性。但是它可以通过实现接口来扮演宠物的角色。</p><p id="c2a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，<em class="mt">狗</em>是-A <em class="mt">动物</em>，是-A <em class="mt">宠物</em> (IS-A是继承关系)。<em class="mt">宠物</em>接口也可以被其他扩展<em class="mt">动物</em>的类使用，例如<em class="mt">猫。</em></p><p id="7cb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">狗还可以通过实现另一个接口来执行额外的角色。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/60daa57c6889498cab0d73a894d7e605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pC_3CCa9dJ9F_5LwidjQXg.png"/></div></div></figure><p id="f5e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，<em class="mt">狗</em>可以扮演<em class="mt">宠物</em>以及<em class="mt">守卫</em>的角色。<em class="mt">守卫</em>接口可由想要扮演<em class="mt">守卫</em>角色的类使用，例如属于不同层级的<em class="mt">人、</em>。</p><p id="ab57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子给出了接口的另一种用法，即多重继承。</p><h2 id="9ef0" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">多重遗传</h2><p id="1ad1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这里，一个类可以有多个父类，因此可以从每个父类继承属性。不幸的是，Java不允许多重继承(至少不直接)。</p><p id="16ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Java中，一个类不能扩展多个类，但是可以实现多个接口。如上例所示，扩展了<em class="mt"> Animal </em>类的<em class="mt"> Dog </em>能够实现多个接口，这些接口指示了它扮演的各种角色。</p><p id="efaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，如果你想让一个类继承特定角色的属性，接口就是为你准备的。一个类可以通过接口扮演多个这样的角色。最棒的是，这个类来自哪个层次并不重要。它所要做的就是实现接口，然后就万事大吉了。</p><h1 id="63ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">其他功能</h1><p id="b397" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">到目前为止，我们已经学习了接口的主要概念及其用例。现在，让我们看看其他一些特性。</p><h2 id="68b0" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">扩展接口</h2><p id="f67f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接口可以像类一样扩展，其中子接口继承父接口的所有成员。参见<a class="ae kc" href="https://www.tutorialspoint.com/how-to-extend-interfaces-in-java" rel="noopener ugc nofollow" target="_blank">本</a>中的示例。</p><p id="d6de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与类不同，一个接口可以扩展<a class="ae kc" href="https://www.tutorialspoint.com/can-an-interface-in-java-extend-multiple-interfaces" rel="noopener ugc nofollow" target="_blank">多个接口</a>。</p><h2 id="62b3" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">默认方法</h2><p id="648a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接口中的默认方法有一个函数体。等等，什么？我们认为所有的接口方法都是抽象的。这是真的，但是Java允许您向接口方法添加实现。</p><p id="ba79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有必要重写默认方法，尽管您可以这样做。</p><p id="04b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<em class="mt">默认</em>关键字定义默认方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9c18" class="mn lc iq mj b gy mo mp l mq mr">interface Guard {<br/>    public void protect();<br/>    <br/>    public default void fight() {<br/>        // body of the function<br/>    }<br/>}</span></pre><p id="7c5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认方法的目的是什么？考虑上面只有<em class="mt"> protect() </em>方法的接口。假设您有许多实现接口的类。现在，如果您想要添加一个新的功能，在这个例子中，就是<em class="mt"> fight() </em>方法，您将不得不跟踪所有实现接口的类来定义这个方法。这可能会变得非常乏味，并引入冗余。</p><p id="6e36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，您可以使用默认方法添加一个默认的<em class="mt"> fight() </em>实现，它将被所有的类继承。如果您有不同地使用<em class="mt"> fight() </em>的类，您可以只修改那些类。</p><h2 id="713e" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">创建接口对象</h2><p id="5fb5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">您不能创建接口的对象并实例化它。但是您可以创建该接口的引用变量。</p><p id="acac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑前面例子中的保护接口。我们来看一个实现Guard的Man类。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dea2" class="mn lc iq mj b gy mo mp l mq mr">class Man implements Guard {<br/>    public void protect() { ... }<br/>}</span><span id="3e9e" class="mn lc iq mj b gy nh mp l mq mr">// In the main method<br/>Guard guard = new Man();   // This is allowed<br/>guard.protect();</span></pre><h2 id="b2eb" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">接口中的静态和私有方法</h2><p id="42fd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个接口可以有静态和私有方法。访问<a class="ae kc" href="https://www.geeksforgeeks.org/static-method-in-interface-in-java/" rel="noopener ugc nofollow" target="_blank">此处</a>查看接口中静态方法的演示。</p><p id="9ee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">私有方法通常用作接口中任何其他公共方法的辅助方法。参见<a class="ae kc" href="https://www.tutorialspoint.com/can-we-use-private-methods-in-an-interface-in-java-9" rel="noopener ugc nofollow" target="_blank">本</a>实施。</p><h1 id="f6fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2b6a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接口用于实现两件事，抽象和多态。当一个类实现一个接口时，它必须覆盖所有的方法。任何层次结构中的类都可以实现一个接口，因此提供了很大的灵活性。接口允许你在Java中实现多重继承。像类一样，它们可以有静态和私有方法，也可以被扩展。但是，它们不能直接实例化。</p><p id="4642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您无法理解内容或对解释不满意，请在下面评论您的想法。新想法总是受欢迎的！如果你喜欢这篇文章，请订阅并关注我的每周更新。到那时，再见！！</p></div></div>    
</body>
</html>