<html>
<head>
<title>Implement Slack Slash Command in Golang using Socket Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用套接字模式在Golang中实现Slack Slash命令</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-slack-slash-command-in-golang-using-socket-mode-ac693e38148c?source=collection_archive---------5-----------------------#2021-05-23">https://levelup.gitconnected.com/implement-slack-slash-command-in-golang-using-socket-mode-ac693e38148c?source=collection_archive---------5-----------------------#2021-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="62eb" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">GOLANG SLACKBOT教程</h2><div class=""/><div class=""><h2 id="2d27" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为您的用户提供便捷的快捷方式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/b88be9b25faf166968bc4a187c192419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*zrHYgmyoKFH_xz5uxBsMcA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">照片由<a class="ae ld" href="https://unsplash.com/@jipy32?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jean-Philippe Delberghe </a>在<a class="ae ld" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，Gopher由<a class="ae ld" href="https://github.com/egonelbre" rel="noopener ugc nofollow" target="_blank"> Egon Elbre </a>拍摄。</figcaption></figure><p id="2177" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">斜杠命令是您在对话框中键入的消息，以<code class="fe ma mb mc md b">"/"</code>开头。它们可以让你轻松地扩展Slack的功能，并且实现起来非常简单。我认为它们是通过从Slack通道进行编写来与您的生态系统进行交互的方式，然后您的Slack应用程序是幕后的指挥者，将您的用户请求重定向到正确的系统。简而言之，我想把它们描述为可以从Slack远程触发的功能。因此，无论您是想添加简单的实用程序，还是想将您的工作区变成一个功能齐全的ChatOps总部，<strong class="lg jd">斜杠命令是Slack应用程序中的必备工具。</strong></p><p id="27af" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这篇文章对slash命令进行了快速介绍，并详细解释了如何使用Socket模式开始使用Golang。演示的关键Slack API概念是Slack Slash命令、短暂消息和交互式消息。</p><h1 id="e5be" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">使用斜杠命令可以实现什么？</h1><p id="dfe4" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">您可能熟悉Slack内置命令。如果没有，第一次进入任何对话类型<code class="fe ma mb mc md b">"/"</code>，然后第二次进入<code class="fe ma mb mc md b">"/"</code>，你将在你的工作区看到所有可用的命令👍。</p><p id="9b72" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">Slack允许您为应用程序创建类似命令。您首先通过slack应用程序后端进行订阅。然后，您会听到用户发出的命令，并最终开始与他们交互。这是一个很好的方式来创建容易提醒快捷方式，让您的用户行动起来。我的工作区中最流行的Slack Slash命令之一绝对是<code class="fe ma mb mc md b">/giphy</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/4798697bc7718314893877b726bc2af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OQhEzsIcXYJjv79EOzBOJQ.gif"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">示例/giphy命令</figcaption></figure><p id="3ce7" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">斜杠命令由两个元素组成。例如，当你输入<code class="fe ma mb mc md b">/rocket count=5</code>时，信息会被Slack分成两部分:</p><ul class=""><li id="38b6" class="ng nh it lg b lh li lk ll ln ni lr nj lv nk lz nl nm nn no bi translated">命令<code class="fe ma mb mc md b">/rocket</code></li><li id="8e9a" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz nl nm nn no bi translated">正文<code class="fe ma mb mc md b">count=5</code></li></ul><p id="50ca" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">命令段帮助您将用户请求分派给正确的服务或控制器，并且需要对文本部分进行解析，以便您的应用程序能够理解它。如果你写一个传统的命令行界面，你可能会期待<code class="fe ma mb mc md b">key=value</code>参数。但是要小心；您的用户可以在命令后输入任何内容，因此每当命令行的参数不正确时，总是要提供一条帮助消息来解释命令行是如何工作的。好消息是松散的交互性；当一个命令出错时，你还可以发送一条交互消息或打开一个模态来收集所需的信息。我发现第二种方法更加用户友好🤗。</p><p id="2773" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这是您将在本教程中创建的命令的概述:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/626fe115e4dfff2e6761879f354373e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fdy1PLiVaoq3DMPKg8KQZw.gif"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">本教程的Slack命令示例</figcaption></figure><h1 id="fd67" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">教程步骤1至3:准备就绪</h1><p id="40fd" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">我已经写了几篇关于创建Slack Bot的文章，这几个基本步骤(1到3)最终是相同的😓。因此，我将向您简要介绍需要做哪些准备。如果您有任何疑问，请阅读专用文章。</p><div class="nu nv gp gr nw nx"><a href="https://medium.com/geekculture/build-slack-application-in-golang-using-socket-mode-setting-up-57f454e63c0a" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd jd gy z fp oc fr fs od fu fw jc bi translated">使用套接字模式在Golang中构建松弛应用程序—设置</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">每个Slack应用程序都是从几个简单的步骤开始的。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">medium.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kx nx"/></div></div></a></div><h2 id="b2ec" class="om mf it bd mg on oo dn mk op oq dp mo ln or os mq lr ot ou ms lv ov ow mu iz bi translated">第一步</h2><ol class=""><li id="c073" class="ng nh it lg b lh mw lk mx ln ox lr oy lv oz lz pa nm nn no bi translated">创建您的<a class="ae ld" href="https://api.slack.com/apps" rel="noopener ugc nofollow" target="_blank">新应用</a></li><li id="7aec" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz pa nm nn no bi translated">在适当的部分激活套接字模式</li><li id="5f5f" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz pa nm nn no bi translated">注册您需要的OAuth范围(chat:write —让您在通道中发布消息)</li><li id="9738" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz pa nm nn no bi translated">注册一个斜杠命令</li></ol><p id="4f58" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这个gif演示了如何注册一个新的Slask命令。对于这个例子，我将其命名为<code class="fe ma mb mc md b">/rocket</code>。</p><h2 id="e83f" class="om mf it bd mg on oo dn mk op oq dp mo ln or os mq lr ot ou ms lv ov ow mu iz bi translated">第二步</h2><p id="8c46" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">创建项目结构。后面的每一节都将关注这些文件中的一个。</p><pre class="ks kt ku kv gt pb md pc pd aw pe bi"><span id="9d15" class="om mf it md b gy pf pg l ph pi">+ controllers<br/>|`- slashCommandController.go<br/>+ drivers<br/>|`- Slack.go<br/>+ views<br/>|`+ slackCommandAssets<br/>| | `- rocket.json<br/>|`- slashCommandView.go<br/>+ main.go</span></pre><h2 id="8440" class="om mf it bd mg on oo dn mk op oq dp mo ln or os mq lr ot ou ms lv ov ow mu iz bi translated">第三步</h2><ol class=""><li id="8876" class="ng nh it lg b lh mw lk mx ln ox lr oy lv oz lz pa nm nn no bi translated">创建driver/slack.go(或者从<a class="ae ld" href="https://github.com/xNok/slack-go-demo-socketmode/blob/main/drivers/slack.go" rel="noopener ugc nofollow" target="_blank">这里</a>复制)</li><li id="bb08" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz pa nm nn no bi translated">创建main.go(或从这里的<a class="ae ld" href="https://github.com/xNok/slack-go-demo-socketmode/blob/main/main.go" rel="noopener ugc nofollow" target="_blank">复制</a>)</li></ol><h1 id="8a63" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">教程步骤4:创建控制器-&gt; slashCommandController.go</h1><p id="a786" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">以下流程图描述了控制器的行为:</p><ul class=""><li id="ec78" class="ng nh it lg b lh li lk ll ln ni lr nj lv nk lz nl nm nn no bi translated">接收一个松弛命令<code class="fe ma mb mc md b">/rocket</code>然后发送一个短暂的交互消息</li><li id="0b98" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz nl nm nn no bi translated">如果用户同意，更新消息以显示火箭发射倒计时。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/abc6f3f40777420d94dbb1520fd8df0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*naipDH6qFZ_4s-anYYnRGQ.png"/></div></figure><h2 id="3892" class="om mf it bd mg on oo dn mk op oq dp mo ln or os mq lr ot ou ms lv ov ow mu iz bi translated">设置控制器</h2><p id="f93b" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">我们首先创建一个初始化构造函数。这个方法使用<code class="fe ma mb mc md b">*socketmode.SocketmodeHandler</code>来注册我们想要接收的事件以及哪个函数将处理它们。在这种情况下，我们听到两个事件:</p><ul class=""><li id="6dcd" class="ng nh it lg b lh li lk ll ln ni lr nj lv nk lz nl nm nn no bi translated">将由<code class="fe ma mb mc md b">c.launchRocketAnnoncement</code>处理的斜线命令“/火箭”</li><li id="d88b" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz nl nm nn no bi translated">与我们消息的<code class="fe ma mb mc md b">approved</code>按钮的交互将由<code class="fe ma mb mc md b">c.launchRocket</code>处理。这个按钮是“交互块”的一部分，由常量<code class="fe ma mb mc md b">views.RocketAnnoncementActionID</code>代表的ActionID唯一标识。我在这里使用一个常量，因为我想确保我监听的<code class="fe ma mb mc md b">ActionID</code>与用户调用<code class="fe ma mb mc md b">/rocket</code>命令后我们发送的消息中定义的相同。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div></figure><h2 id="2248" class="om mf it bd mg on oo dn mk op oq dp mo ln or os mq lr ot ou ms lv ov ow mu iz bi translated">用一条短暂的消息回应<code class="fe ma mb mc md b">rocket</code></h2><p id="f76e" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">编写该函数的关键点如下:</p><ol class=""><li id="e4fe" class="ng nh it lg b lh li lk ll ln ni lr nj lv nk lz pa nm nn no bi translated">您需要将收到的泛型<code class="fe ma mb mc md b">socketmode.Event</code>转换为<code class="fe ma mb mc md b">slack.SlashCommand</code></li><li id="1df0" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz pa nm nn no bi translated">您需要确认您收到了该事件。(Slack希望您在3s内回复)</li><li id="eedf" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz pa nm nn no bi translated">您需要创建将要发送的消息。我将在后面用函数<code class="fe ma mb mc md b">views.LaunchRocketAnnoncement</code>讲述这一部分。</li><li id="5582" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz pa nm nn no bi translated">你需要通过Slack API发送你的消息。此操作有两个选项。首先是标准API <code class="fe ma mb mc md b">chat.postmessage</code>的使用。第二种是使用Slash命令中提供的响应URL。(下一节将详细介绍响应URL)</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div></figure><h2 id="edcd" class="om mf it bd mg on oo dn mk op oq dp mo ln or os mq lr ot ou ms lv ov ow mu iz bi translated">对用户在“批准”按钮上的操作做出反应</h2><p id="3560" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">该方法的结构类似于前一种方法。如果你能编码一个，你也能编码这个😇。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="5c3a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">参见slashCommandController.go完整代码<a class="ae ld" href="https://github.com/xNok/slack-go-demo-socketmode/blob/main/controllers/slashCommandController.go" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="de09" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">关于响应URL的更多信息</h1><p id="5b9c" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">响应URL基本上是一个webhook，让您在30分钟内与频道互动多达5次。每当触发斜杠命令或交互消息时，Slack都会提供响应URL。</p><p id="bcd1" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">使用响应URL时，您有两种选择:</p><ul class=""><li id="8405" class="ng nh it lg b lh li lk ll ln ni lr nj lv nk lz nl nm nn no bi translated">回应频道，让每个人都能看到机器人的回应<code class="fe ma mb mc md b">Slack.ResponseTypeInChannel</code></li><li id="6d26" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz nl nm nn no bi translated">用一个短暂的消息响应，只有触发命令的用户才能看到它<code class="fe ma mb mc md b">slack.ResponseTypeEphemeral</code></li></ul><p id="3fda" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在这种情况下，我们将一个<code class="fe ma mb mc md b">MsgOption</code>添加到我们的<code class="fe ma mb mc md b">PostMessage</code>调用中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="2a8d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">有必要提及的是，响应URL允许您在频道中发布消息，即使您的Bot尚未添加到频道中。实际上<a class="ae ld" href="https://api.slack.com/methods/chat.postMessage" rel="noopener ugc nofollow" target="_blank"> chat.postMessage </a>只允许你向你的机器人已经加入的频道发布消息；否则，您会收到错误<code class="fe ma mb mc md b">not_in_channel</code>。换句话说，响应URL允许您与用户进行交互，而不考虑通常的权限规则(当然，为了安全起见，次数是有限的)。</p><p id="cf45" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">创建命令时要考虑的其他选项:</p><ul class=""><li id="429e" class="ng nh it lg b lh li lk ll ln ni lr nj lv nk lz nl nm nn no bi translated">安排一条消息(如果你的应用程序创建了某种提醒)</li><li id="b9e8" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz nl nm nn no bi translated">在<a class="ae ld" href="https://api.slack.com/start/overview#app_home" rel="noopener ugc nofollow" target="_blank">应用主页</a>发送消息。与短暂的消息相比，我更喜欢这种方法，因为它在一个地方留下了您与应用程序的所有交互的痕迹。</li><li id="8ef1" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz nl nm nn no bi translated">使用<code class="fe ma mb mc md b">slack.SlashCommand</code>中提供的<code class="fe ma mb mc md b">trigger_id</code>打开一个模态。这是Slack的一个迷人的特性。我更喜欢在命令行中解析参数的方法；对于非开发人员来说，它更加用户友好。</li></ul><h1 id="1073" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">教程步骤5:创建视图&gt; slashCommandView.go</h1><p id="5808" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">最后但同样重要的是，我们需要学习如何生成松弛信息。Slack推出了<a class="ae ld" href="https://api.slack.com/block-kit" rel="noopener ugc nofollow" target="_blank"> Block-kit </a>来帮助我们不用试错就能创建我们的信息。我处理slack消息的方法是将Block-kit有效负载保存为JSON文件，然后使用<a class="ae ld" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank"> Go模板</a>来呈现我的视图并注入变量。</p><p id="17b4" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我写了一篇关于这个主题的专门文章，以进行更深入的解释:</p><div class="nu nv gp gr nw nx"><a href="https://couedeloalexandre.medium.com/manage-static-assets-with-embed-golang-1-16-75c89c3eea39" rel="noopener follow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd jd gy z fp oc fr fs od fu fw jc bi translated">管理Golang中的静态资产</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用Golang 1.16新包“嵌入”的新方法</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">couedeloalexandre.medium.com</p></div></div><div class="og l"><div class="pm l oi oj ok og ol kx nx"/></div></div></a></div><p id="4794" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">您可以在这里微调Block-kit <a class="ae ld" href="https://app.slack.com/block-kit-builder/T0B5XJYR2#%7B%22blocks%22:%5B%7B%22type%22:%22section%22,%22text%22:%7B%22type%22:%22mrkdwn%22,%22text%22:%22*You%20are%20about%20to%20lauch%20a%20new%20rocket*%22%7D%7D,%7B%22type%22:%22section%22,%22fields%22:%5B%7B%22type%22:%22mrkdwn%22,%22text%22:%22*Rocket:*%5CnFalcon%209%22%7D,%7B%22type%22:%22mrkdwn%22,%22text%22:%22*When:*%5Cn3s%20count%20down%22%7D%5D%7D,%7B%22type%22:%22actions%22,%22elements%22:%5B%7B%22type%22:%22button%22,%22text%22:%7B%22type%22:%22plain_text%22,%22emoji%22:true,%22text%22:%22Approve%22%7D,%22style%22:%22primary%22,%22value%22:%22click_me_123%22%7D,%7B%22type%22:%22button%22,%22text%22:%7B%22type%22:%22plain_text%22,%22emoji%22:true,%22text%22:%22Deny%22%7D,%22style%22:%22danger%22,%22value%22:%22click_me_123%22%7D%5D%7D%5D%7D" rel="noopener ugc nofollow" target="_blank">中的信息。将有效负载保存为一个名为。<code class="fe ma mb mc md b">slackCommandAssets/annoncement.json</code>。</a></p><p id="3b40" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">创建此视图的要点是:</p><ol class=""><li id="0691" class="ng nh it lg b lh li lk ll ln ni lr nj lv nk lz pa nm nn no bi translated">Render模板将用户名注入消息中。我创建了一个小的实用函数来做这件事，因为我在每个视图中都重用它。<a class="ae ld" href="https://github.com/xNok/slack-go-demo-socketmode/blob/main/views/utils.go" rel="noopener ugc nofollow" target="_blank"> views/utils.go </a>。模板中使用的参数有:倒计时的秒数<code class="fe ma mb mc md b">{{ .Number }}</code>，我们在创建控制器<code class="fe ma mb mc md b">{{ .ActionID }}</code>时讨论过的批准按钮的唯一标识符，</li><li id="4f5e" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz pa nm nn no bi translated">将生成的消息解组为一个Slack消息。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="c73b" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">见slashCommandView.go完整代码<a class="ae ld" href="https://github.com/xNok/slack-go-demo-socketmode/tree/main/views" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h1 id="d9c9" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">后续步骤</h1><h2 id="5cf9" class="om mf it bd mg on oo dn mk op oq dp mo ln or os mq lr ot ou ms lv ov ow mu iz bi translated">尝试此应用程序</h2><p id="7387" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">成功完成教程后💪，您可以运行您的应用程序:</p><pre class="ks kt ku kv gt pb md pc pd aw pe bi"><span id="5641" class="om mf it md b gy pf pg l ph pi">go run ./main.go</span></pre><p id="d4ed" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">也可以直接克隆<a class="ae ld" href="https://github.com/xNok/slack-go-demo-socketmode" rel="noopener ugc nofollow" target="_blank">我的库</a>提前试一试。</p><h2 id="774d" class="om mf it bd mg on oo dn mk op oq dp mo ln or os mq lr ot ou ms lv ov ow mu iz bi translated">能改善吗？</h2><p id="acd2" class="pw-post-body-paragraph le lf it lg b lh mw kd lj lk mx kg lm ln my lp lq lr mz lt lu lv na lx ly lz im bi translated">一旦完成了本教程，您就为所有后续的Slack命令打下了坚实的基础。您不仅学习了斜杠命令，还学习了发送消息(定期的和短暂的)、使用Block-kit和创建交互式消息。但是你还记得我提到过模态是通过命令行参数收集用户输入的首选方式吗？这是一个很好的后续挑战:</p><ul class=""><li id="9128" class="ng nh it lg b lh li lk ll ln ni lr nj lv nk lz nl nm nn no bi translated">向临时消息添加一个按钮(例如，配置rocket类型)</li><li id="a336" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz nl nm nn no bi translated">打开一个模式以提供可配置的选项(例如，使倒计时可配置)</li></ul><h1 id="2f07" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">参考</h1><ul class=""><li id="7a98" class="ng nh it lg b lh mw lk mx ln ox lr oy lv oz lz nl nm nn no bi translated"><a class="ae ld" href="https://api.slack.com/interactivity/slash-commands" rel="noopener ugc nofollow" target="_blank">https://api.slack.com/interactivity/slash-commands</a></li><li id="b170" class="ng nh it lg b lh np lk nq ln nr lr ns lv nt lz nl nm nn no bi translated"><a class="ae ld" href="https://api.slack.com/legacy/interactive-messages" rel="noopener ugc nofollow" target="_blank">https://api.slack.com/legacy/interactive-messages</a></li></ul></div></div>    
</body>
</html>