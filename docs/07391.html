<html>
<head>
<title>Never Return NULL References From Your Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">永远不要从函数中返回空引用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/never-return-null-references-from-your-methods-d696acc9eefe?source=collection_archive---------2-----------------------#2021-02-15">https://levelup.gitconnected.com/never-return-null-references-from-your-methods-d696acc9eefe?source=collection_archive---------2-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="20ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你总是有更好的选择。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3a92bf1d0dc28e396baeeccdda439750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cxCceaOMrKcZePzo"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sickhews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">韦斯·希克斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在C#中，引用类型可以被赋予<code class="fe lv lw lx ly b">null</code>值。这是开发人员在使用类来创建软件之前必须面对的问题。不幸的是，微软的人不能简单地禁止在编译时将<code class="fe lv lw lx ly b">null</code>赋值给引用变量，因为那会破坏几乎每个项目的代码库。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b080" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">返回Null是不好的做法</h1><p id="fe83" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">从方法中返回一个<code class="fe lv lw lx ly b">null</code>引用实际上有什么问题？</p><p id="b542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这个简单的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在数据库中没有找到订单，<code class="fe lv lw lx ly b">FirstOrDefault</code>方法会自动返回<code class="fe lv lw lx ly b">null</code>。</p><p id="4326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个问题:</p><ul class=""><li id="f58d" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">GetOrder</code>方法的调用方必须实现空引用检查，以避免在访问<code class="fe lv lw lx ly b">Order</code>类成员时得到<code class="fe lv lw lx ly b">NullReferenceException</code>。但是调用者应该如何知道如何正确地实现错误处理呢？如果调用者收到一个空引用或者返回一些错误代码，它应该抛出一个异常吗？</li><li id="439b" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">当每个调用者自己实现验证逻辑时，它将被复制，并且逻辑在所有调用者之间不一致的可能性很高。这是违反<strong class="lb iu">干</strong>原则的。</li><li id="6477" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">对于调用者来说，获取一个<code class="fe lv lw lx ly b">null</code>值是不明确的，因为它没有说明返回null是因为bug还是因为在数据库中没有找到订单。返回<code class="fe lv lw lx ly b">null</code>绝对不是<strong class="lb iu">域驱动设计</strong>的方法。</li><li id="7109" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">返回<code class="fe lv lw lx ly b">null</code>经常违反<strong class="lb iu">快速失败</strong>编程原则。由于应用程序中的某些问题，可能会出现<code class="fe lv lw lx ly b">null</code>。如果开发人员没有实现适当的异常处理，该问题甚至会进入生产环境，这有助于快速检测问题。</li></ul><p id="455d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员可以做一些事情来改善这种情况，比如使用可空的引用类型、抛出异常或者使用空对象设计模式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="61e9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用可空的引用类型</h1><p id="cfea" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果开发人员真的需要从方法中返回一个<code class="fe lv lw lx ly b">null</code>值(99%的情况下这是不必要的)，返回类型可以标记为可空引用类型(这个特性是在C# 8.0中引入的)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将返回类型标记为可空有两个主要好处:</p><ul class=""><li id="ca75" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">方法签名明确声明它可以返回空引用。这样，调用者通过查看方法签名就可以确定他们需要实现错误处理。</li><li id="6cad" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">如果调用者没有首先检查<code class="fe lv lw lx ly b">null</code>引用就访问<code class="fe lv lw lx ly b">Order</code>类的成员，编译器将发出警告。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="46b8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">通过抛出异常快速失败</h1><p id="c7a0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">快速失效原则是软件工程中的一个重要原则。这个想法非常简单——只要应用程序检测到问题(空引用),它就应该抛出一个异常。</p><p id="5dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不正确的<code class="fe lv lw lx ly b">orderId</code>可能由以下原因造成:</p><ul class=""><li id="224d" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">未正确配置自动映射库来映射<code class="fe lv lw lx ly b">orderId</code>值。</li><li id="67d7" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">一些代码在调用<code class="fe lv lw lx ly b">GetOrder</code>方法之前，意外地将错误的值赋给了<code class="fe lv lw lx ly b">orderId</code>变量。</li><li id="7d0c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">前端不会将订单id传递给后端。</li></ul><p id="f0b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">描述的每个原因都是应用程序中的一个bug。因此，根据<strong class="lb iu">快速失效</strong>原理，一旦系统检测到<code class="fe lv lw lx ly b">orderId</code>无效，它应该抛出异常。</p><p id="d396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于未找到的订单，抛出异常的最简单方法是在实现中使用<code class="fe lv lw lx ly b">First</code>方法，而不是<code class="fe lv lw lx ly b">FirstOrDefault</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="89a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们有另一个问题:调用者会得到没有任何有价值信息的<code class="fe lv lw lx ly b">InvalidOperationException</code>,因为这是一个常见的问题。净异常。解决方案是引入一个定制的异常类型，一旦在数据库中找不到订单，开发人员就应该抛出这个异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结自定义异常方法的优点:</p><ul class=""><li id="dd07" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">在部署生产环境之前发现和解决问题的几率要高得多。</li><li id="6645" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">呼叫者将获得有关问题的详细信息，这将简化故障排除过程。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3ca3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用空对象设计模式</h1><p id="c659" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">另一种避免返回<code class="fe lv lw lx ly b">null</code>的方法是使用空对象设计模式。</p><p id="6aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">空对象是一个没有存根行为的对象，开发人员可以将它返回给调用者，而不是返回<code class="fe lv lw lx ly b">null</code>值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用者不需要检查空值的顺序，因为返回了一个真实但空的<code class="fe lv lw lx ly b">Order</code>对象。</p><p id="0cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">空对象模式应该被仔细考虑作为抛出异常的一种替代方法。使用该模式与快速失效原则相反。</p><p id="83cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当调用者为了跳过对其成员的访问而检查对象的<code class="fe lv lw lx ly b">null</code>时，才应该使用这种模式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="afed" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="c905" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">结论很简单——永远不要从方法中返回空引用。</p></div></div>    
</body>
</html>