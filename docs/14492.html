<html>
<head>
<title>Implementing address autocomplete using SwiftUI and MapKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI和MapKit实现地址自动完成</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-address-autocomplete-using-swiftui-and-mapkit-c094d08cda24?source=collection_archive---------1-----------------------#2022-12-02">https://levelup.gitconnected.com/implementing-address-autocomplete-using-swiftui-and-mapkit-c094d08cda24?source=collection_archive---------1-----------------------#2022-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1fb268f53bb1242f9fdd9c2791041a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edRkUQrlKcOWSBZmnGT0vg.jpeg"/></div></div></figure><p id="82ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">令我自己惊讶的是，我意识到我从来没有只用苹果技术实现过地址自动补全。之前，我只体验过<a class="ae kw" href="https://developers.google.com/maps/documentation/places/ios-sdk/autocomplete" rel="noopener ugc nofollow" target="_blank"> Google Places SDK </a>，甚至还有不太知名的欧洲<a class="ae kw" href="http://geodatahub.eu" rel="noopener ugc nofollow" target="_blank">地理数据中心</a>。我觉得很好奇——想知道我们如何限制自己只使用SwiftUI和MapKit来解决类似的问题。</p><h1 id="8a27" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TL；速度三角形定位法(dead reckoning)</h1><div class="lv lw gp gr lx ly"><a href="https://github.com/maxkalik/address-autocomplete-swiftui" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">GitHub-maxkalik/Address-autocomplete-swiftui:地址自动完成的swift ui解决方案</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm jw ly"/></div></div></a></div><h1 id="25a0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">地图工具包</h1><p id="8d0d" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">在开始之前，让我们简单描述一下map kit——苹果发明的一个强大的框架。<a class="ae kw" href="https://developer.apple.com/documentation/mapkit/" rel="noopener ugc nofollow" target="_blank">参见文档</a>:</p><blockquote class="ms mt mu"><p id="502f" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">在应用程序中显示地图或卫星影像，调出兴趣点，并确定地图坐标的地标信息。</p></blockquote><p id="7c53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个框架包括了一堆有用的东西。我将只列出我们将要使用的:地图本身(<code class="fe mz na nb nc b">MapView</code>for swift ui)；<code class="fe mz na nb nc b">MKCoordinateRegion</code> —该模型将允许在地图上显示特定区域；<code class="fe mz na nb nc b"> </code>MK annotation——另一个带有坐标和其他数据的模型，用于在地图上显示<code class="fe mz na nb nc b">MapMarker</code>,以及<code class="fe mz na nb nc b">MKLocalSearch</code>引擎，我们将使用该引擎从可搜索的地址获取完成列表。为了实现这一点，我们需要使用<code class="fe mz na nb nc b">MKLocalSearchCompleterDelegate</code>和<code class="fe mz na nb nc b">MKLocalSearchCompleter</code>来获得结果——可能的地址。</p><h1 id="34b1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">项目概述</h1><p id="7190" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">完成的任务应该如下所示:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/de6f8282205b078611b8717902a53450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xPhqFxM3gXkOHtpJzVQo1Q.gif"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">带有地址完成和地图屏幕的iOS应用程序</figcaption></figure><p id="ba00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不会要求用户获取设备的当前位置，因此我们根本不会触及<code class="fe mz na nb nc b">plist</code>配置，我试图尽可能简化项目。让我们从几个模型开始。目标是看看我们需要为这个简单的应用程序实现多少东西。</p><p id="7955" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以结构如下，MVVM有两个屏幕:内容和地图。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/1af5026251c0b842df6ea70ad467bfcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*3UjUAGXJWIqkx920UMeXBA.png"/></div></figure><h1 id="b9d4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模型</h1><p id="5499" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">先说几款:<code class="fe mz na nb nc b">AddressResult</code>和<code class="fe mz na nb nc b">Annotation</code>。两者都应该符合<code class="fe mz na nb nc b">Identifiable</code>协议，因为我们将在集合中使用它们。</p><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="26c2" class="nr ky iq nc b be ns nt l nu nv">struct AddressResult: Identifiable {<br/>    let id = UUID()<br/>    let title: String<br/>    let subtitle: String<br/>}</span></pre><pre class="nw nn nc no bn np nq bi"><span id="791e" class="nr ky iq nc b be ns nt l nu nv">struct AnnotationItem: Identifiable {<br/>    let id = UUID()<br/>    let latitude: Double<br/>    let longitude: Double<br/>    var coordinate: CLLocationCoordinate2D {<br/>        CLLocationCoordinate2D(latitude: latitude, longitude: longitude)<br/>    }<br/>}</span></pre><p id="0bd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mz na nb nc b">AddressResult</code>模型将在结果列表中使用。<code class="fe mz na nb nc b">AnnotationItem</code>我们将在地图组件中设置正确的集合。但是在深入研究之前，让我们先建立视图模型。</p><h1 id="8ddf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">内容视图模型</h1><p id="db44" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">我们的iOS应用程序从<code class="fe mz na nb nc b">ContentView</code>开始，因为我们使用SwiftUI，因此，我们需要准备我们的第一个视图模型:<code class="fe mz na nb nc b">ContentViewModel</code>。<code class="fe mz na nb nc b">ContentViewModel</code>将是可观察到的，因为需要发布两件事——来自textfield(可搜索文本)的值和<code class="fe mz na nb nc b">AddressResult</code>模型的结果数组。</p><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="7d2f" class="nr ky iq nc b be ns nt l nu nv">class ContentViewModel: NSObject, ObservableObject {<br/>    <br/>    @Published private(set) var results: Array&lt;AddressResult&gt; = []<br/>    @Published var searchableText = ""<br/><br/>    private lazy var localSearchCompleter: MKLocalSearchCompleter = {<br/>        let completer = MKLocalSearchCompleter()<br/>        completer.delegate = self<br/>        return completer<br/>    }()<br/>    <br/>    func searchAddress(_ searchableText: String) {<br/>        guard searchableText.isEmpty == false else { return }<br/>        localSearchCompleter.queryFragment = searchableText<br/>    }<br/>}</span></pre><p id="9f56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你们中的一些人可能会注意到<code class="fe mz na nb nc b">searchableText</code>没有被标记为<code class="fe mz na nb nc b">private(set)</code>。这是因为这个值将被绑定。同样，正如你所看到的，这里有一个初始化的<code class="fe mz na nb nc b">MKLocalSearchCompleter</code>。这个完成器将有助于使用<code class="fe mz na nb nc b">queryFragment</code>获得结果。为此，我们需要符合<code class="fe mz na nb nc b">MKLocalSearchCompleterDelegate</code>:</p><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="5a42" class="nr ky iq nc b be ns nt l nu nv">extension ContentViewModel: MKLocalSearchCompleterDelegate {<br/>    func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {<br/>        Task { @MainActor in<br/>            results = completer.results.map {<br/>                AddressResult(title: $0.title, subtitle: $0.subtitle)<br/>            }<br/>        }<br/>    }<br/>    <br/>    func completer(_ completer: MKLocalSearchCompleter, didFailWithError error: Error) {<br/>        print(error)<br/>    }<br/>}</span></pre><p id="1ec4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在不打算处理错误，所以让我跳过这一部分，我们可以只打印一条消息。方法<code class="fe mz na nb nc b">completerDidUpdateResults</code>从完成器的结果中设置结果。由于我们的结果是公开的，所以我们需要主线程来避免这个警告:</p><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="d804" class="nr ky iq nc b be ns nt l nx nv">[SwiftUI] Publishing changes from within view updates is not allowed, this will cause undefined behavior</span></pre><h1 id="8376" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">地图视图模型</h1><p id="f2d5" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">此项目中的视图模型是独立的。我们将使用<code class="fe mz na nb nc b">@StateObject</code>观察它们。<code class="fe mz na nb nc b">MapViewModel</code>非常简单:两个发布的变量和一个方法:</p><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="99aa" class="nr ky iq nc b be ns nt l nu nv">class MapViewModel: ObservableObject {<br/><br/>    @Published var region = MKCoordinateRegion()<br/>    @Published private(set) var annotationItems: [AnnotationItem] = []<br/>    <br/>    func getPlace(from address: AddressResult) {<br/>        let request = MKLocalSearch.Request()<br/>        let title = address.title<br/>        let subTitle = address.subtitle<br/>        <br/>        request.naturalLanguageQuery = subTitle.contains(title)<br/>        ? subTitle : title + ", " + subTitle<br/>        <br/>        Task {<br/>            let response = try await MKLocalSearch(request: request).start()<br/>            await MainActor.run {<br/>                self.annotationItems = response.mapItems.map {<br/>                    AnnotationItem(<br/>                        latitude: $0.placemark.coordinate.latitude,<br/>                        longitude: $0.placemark.coordinate.longitude<br/>                    )<br/>                }<br/>                <br/>                self.region = response.boundingRegion<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="8e68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">区域值<code class="fe mz na nb nc b">MKCoordinateRegion</code>将与视图绑定，而<code class="fe mz na nb nc b">AnnotationItem</code>集合将由地图视图本身使用。</p><p id="7954" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最有趣的部分是这个参数为<code class="fe mz na nb nc b">AddressResult</code>的<code class="fe mz na nb nc b">getPlace</code>方法。简而言之，该方法使用<code class="fe mz na nb nc b">MKLocalSearch</code>请求将我们的行地址数据转换成坐标！</p><p id="607f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的地址由标题和副标题组成。在某些情况下，subtitle可以包含标题，所以我们需要先检查这部分来准备<code class="fe mz na nb nc b">naturalLanguageQuery</code>。接下来，这将是一个带有<code class="fe mz na nb nc b">MKLocalSearch</code>工具的任务。从响应中我们需要两样东西:<code class="fe mz na nb nc b">MapItem</code>集合和<code class="fe mz na nb nc b">MKCoordinateRegion</code>。从第一部开始，我们就准备<code class="fe mz na nb nc b">AnnotationItem</code>合集。第二个是一个包含返回的搜索结果的地图区域。</p><h1 id="b80f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">内容视图</h1><p id="884a" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">我真的很喜欢SwiftUI，因为你不需要花那么多时间来构建用户界面。这意味着您将花费大约10分钟的时间来实现所有功能，包括一张地图在内的两个屏幕。</p><p id="e63d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的任务很简单，我们只需要为查询和结果列表准备一个带有<code class="fe mz na nb nc b">TextField</code>的<code class="fe mz na nb nc b">NavigationView</code>。让我们来看看:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/68cc968ee7b1c7d5fc1d4efb7a86e386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uIbnYjBtgSKEBZ-AxKhVA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">地址自动完成屏幕</figcaption></figure><p id="021e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个屏幕是当应用程序刚刚启动，文本字段立即集中出现。此外，我忍不住给文本字段添加了一个清除按钮。所以，让我们实现所有这些观点。</p><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="c161" class="nr ky iq nc b be ns nt l nu nv">struct ContentView: View {<br/>    <br/>    @StateObject var viewModel: ContentViewModel<br/>    @FocusState private var isFocusedTextField: Bool<br/>    <br/>    var body: some View {<br/>        NavigationView {<br/>            VStack(alignment: .leading, spacing: 0) {<br/><br/>                TextField("Type address", text: $viewModel.searchableText)<br/>                    .padding()<br/>                    .autocorrectionDisabled()<br/>                    .focused($isFocusedTextField)<br/>                    .font(.title)<br/>                    .onReceive(<br/>                        viewModel.$searchableText.debounce(<br/>                            for: .seconds(1),<br/>                            scheduler: DispatchQueue.main<br/>                        )<br/>                    ) {<br/>                        viewModel.searchAddress($0)<br/>                    }<br/>                    .background(Color.init(uiColor: .systemBackground))<br/>                    .overlay {<br/>                        ClearButton(text: $viewModel.searchableText)<br/>                            .padding(.trailing)<br/>                            .padding(.top, 8)<br/>                    }<br/>                    .onAppear {<br/>                        isFocusedTextField = true<br/>                    }<br/><br/>                List(self.viewModel.results) { address in<br/>                    AddressRow(address: address)<br/>                        .listRowBackground(backgroundColor)<br/>                }<br/>                .listStyle(.plain)<br/>                .scrollContentBackground(.hidden)<br/>            }<br/>            .background(backgroundColor)<br/>            .edgesIgnoringSafeArea(.bottom)<br/>        }<br/>    }<br/>    <br/>    var backgroundColor: Color = Color.init(uiColor: .systemGray6)<br/>}</span></pre><p id="a98f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不会一行一行地看，因为在我看来，这段代码非常简单。我只是想引起你对某些部分的注意。</p><ul class=""><li id="4711" class="nz oa iq ka b kb kc kf kg kj ob kn oc kr od kv oe of og oh bi translated"><code class="fe mz na nb nc b">FocusState</code>用于在出现时聚焦<code class="fe mz na nb nc b">TextView</code>。</li><li id="cb29" class="nz oa iq ka b kb oi kf oj kj ok kn ol kr om kv oe of og oh bi translated">在<code class="fe mz na nb nc b">TextView</code>中接收值时，除了查询每个字母之外，至少需要等待1秒钟才能获得可搜索的文本。</li><li id="5065" class="nz oa iq ka b kb oi kf oj kj ok kn ol kr om kv oe of og oh bi translated">列表视图。我测试了仅在iOS16中有效的<code class="fe mz na nb nc b">.scrollContentBackground(.hidden)</code>——它有助于隐藏内容背景。</li><li id="0bb4" class="nz oa iq ka b kb oi kf oj kj ok kn ol kr om kv oe of og oh bi translated">使用<code class="fe mz na nb nc b">TextField</code>中的<code class="fe mz na nb nc b">overlay</code>,我们可以添加带有绑定可搜索文本的<code class="fe mz na nb nc b">ClearButton</code>( 1。为了检查此文本是否不为空，将呈现清除按钮；2.用于从<code class="fe mz na nb nc b">ClearButton</code>组件中清除文本)。</li></ul><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="5669" class="nr ky iq nc b be ns nt l nu nv">struct ClearButton: View {<br/>    <br/>    @Binding var text: String<br/>    <br/>    var body: some View {<br/>        if text.isEmpty == false {<br/>            HStack {<br/>                Spacer()<br/>                Button {<br/>                    text = ""<br/>                } label: {<br/>                    Image(systemName: "multiply.circle.fill")<br/>                        .foregroundColor(Color(red: 0.7, green: 0.7, blue: 0.7))<br/>                }<br/>                .foregroundColor(.secondary)<br/>            }<br/>        } else {<br/>            EmptyView()<br/>        }<br/>    }<br/>}</span></pre><p id="e3aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">地址行由<code class="fe mz na nb nc b">NavigationLink</code>包装，目的地在<code class="fe mz na nb nc b">MapView</code>。</p><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="0103" class="nr ky iq nc b be ns nt l nu nv">struct AddressRow: View {<br/>    <br/>    let address: AddressResult<br/>    <br/>    var body: some View {<br/>        NavigationLink {<br/>            MapView(address: address)<br/>        } label: {<br/>            VStack(alignment: .leading) {<br/>                Text(address.title)<br/>                Text(address.subtitle)<br/>                    .font(.caption)<br/>            }<br/>        }<br/>        .padding(.bottom, 2)<br/>    }<br/>}</span></pre><h1 id="cda1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">地图视图</h1><p id="2358" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">第二个屏幕是一个地图本身，这个视图应该显示搜索结果的正确位置。</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/effee258b2083296f19b363cdcafaab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e11AGkmpwp4nasPGlVa38A.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">地图视图</figcaption></figure><p id="f4fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将只有一个视图:地图视图。正如你所记得的<code class="fe mz na nb nc b">getPlace</code>方法将地址转换成坐标，所以当视图出现时我们需要更新坐标:区域和注释项。最终，在注释内容中，我们可以准备<code class="fe mz na nb nc b">MapMarker</code>。用<code class="fe mz na nb nc b">coordinateRegion</code>、<code class="fe mz na nb nc b">annotationItems,</code>和<code class="fe mz na nb nc b">annotationContent</code>参数配置的地图视图。当视图模型中的所有数据准备就绪时，地图视图将被更新。可以看到<code class="fe mz na nb nc b">coordinateRegion</code>参数应用了一个绑定值。<code class="fe mz na nb nc b">annotationItems</code>可以只是<code class="fe mz na nb nc b">identifiable</code>，里面有坐标变量(经纬度)——用于闭包的<code class="fe mz na nb nc b">annotationContent</code>项。</p><pre class="ne nf ng nh gt nn nc no bn np nq bi"><span id="5f9b" class="nr ky iq nc b be ns nt l nu nv">struct MapView: View {<br/>    <br/>    @StateObject private var viewModel = MapViewModel()<br/><br/>    private let address: AddressResult<br/>    <br/>    init(address: AddressResult) {<br/>        self.address = address<br/>    }<br/>    <br/>    var body: some View {<br/>        Map(<br/>            coordinateRegion: $viewModel.region,<br/>            annotationItems: viewModel.annotationItems,<br/>            annotationContent: { item in<br/>                MapMarker(coordinate: item.coordinate)<br/>            }<br/>        )<br/>        .onAppear {<br/>            self.viewModel.getPlace(from: address)<br/>        }<br/>        .edgesIgnoringSafeArea(.bottom)<br/>    }<br/>}</span></pre><p id="03b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句，当您构建项目时，您可能会看到一些SwiftUI警告:<strong class="ka ir">不允许在视图更新中发布更改…— </strong>,这意味着您可能在视图渲染期间更新了坐标。如果你认为你做的完全正确，你的状态从<code class="fe mz na nb nc b">onAppear</code>开始更新，所以这可能是地图内部的一个问题。你可以查看唐尼·瓦尔斯关于这个问题的这篇文章。</p><h1 id="63fd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">包扎</h1><p id="0e5f" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">无数应用使用地图。但是仍然很少有人使用SwiftUI和MapKit的组合。我很好奇如果只使用苹果技术，我们能造出什么。实现这个有用的特性需要多少行代码。每年在WWDC，你都会注意到苹果的工程师们严格地更新地图工具包，增加新的功能，尤其是SwiftUI。我只使用了SwiftUI building Address和自动完成功能，因为我真的相信这个框架是我们最接近的未来，UIKit很快就会成为次要技术。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="3b55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">想要连接？</strong> <br/>不要犹豫，在<a class="ae kw" href="http://twitter.com/maxkalik" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。我感谢任何关于我的研究和文章的建议或评论。</p></div></div>    
</body>
</html>