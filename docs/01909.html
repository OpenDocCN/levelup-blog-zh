<html>
<head>
<title>Why Should We Use the JavaScript For-Of Loop?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们为什么要使用JavaScript For-Of循环？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-should-we-use-the-javascript-for-of-loop-a92a6e1228ad?source=collection_archive---------9-----------------------#2020-02-05">https://levelup.gitconnected.com/why-should-we-use-the-javascript-for-of-loop-a92a6e1228ad?source=collection_archive---------9-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/93ff05d79f16925b219496cfc67d269f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sydR_hDmTaALlp1Z"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">布莱恩·霍尔兹沃思在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6beb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从ES6开始，我们有了<code class="fe le lf lg lh b">for...of</code>循环。这是一个非常有用的循环，它可以做比常规for循环更多的事情。在本文中，我们将看看为什么<code class="fe le lf lg lh b">for...of</code>循环对开发人员有用，以及其性能是否足以取代<code class="fe le lf lg lh b">for</code>循环。</p><p id="13ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">for...of</code>循环让我们遍历数组、类似数组的对象和用户定义的可重复项。它让我们不用使用不同种类的方法和循环就能遍历所有这些。</p><p id="d6bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建一个<code class="fe le lf lg lh b">for...of</code>循环来遍历数组，如下所示:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="eb29" class="lq lr it lh b gy ls lt l lu lv">const arr = [1, 2, 3];</span><span id="614d" class="lq lr it lh b gy lw lt l lu lv">for (const a of arr) {<br/>  console.log(a);<br/>}</span></pre><p id="fedb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该循环将产生以下输出:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="eed9" class="lq lr it lh b gy ls lt l lu lv">1<br/>2<br/>3</span></pre><p id="7088" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">for...of</code>循环的亮点在于能够遍历类似数组的对象，如节点列表和我们自己的可迭代对象。例如，如果我们有以下HTML:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="d34b" class="lq lr it lh b gy ls lt l lu lv">&lt;p&gt;<br/>  foo<br/>&lt;/p&gt;<br/>&lt;p&gt;<br/>  bar<br/>&lt;/p&gt;<br/>&lt;p&gt;<br/>  baz<br/>&lt;/p&gt;</span></pre><p id="ff01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用下面的JavaScript</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="1f24" class="lq lr it lh b gy ls lt l lu lv">const nodeList = document.querySelectorAll('p');</span><span id="d096" class="lq lr it lh b gy lw lt l lu lv">for (const element of nodeList) {<br/>  console.log(element.textContent.trim());<br/>}</span></pre><p id="31ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们记录了以下内容:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="01be" class="lq lr it lh b gy ls lt l lu lv">foo<br/>bar<br/>baz</span></pre><p id="cebd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">for...of</code>循环，我们不必像常规的<code class="fe le lf lg lh b">for</code>循环那样写出索引来遍历NodeList，这是唯一的选择，因为它不是一个数组，而是一个类似数组的对象。</p><p id="c694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以迭代用户定义的可迭代对象，如生成器和可迭代对象。例如，给定以下生成器:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="e4d5" class="lq lr it lh b gy ls lt l lu lv">function* generator() {<br/>  yield 1;<br/>  yield 2;<br/>  yield 3;<br/>}</span></pre><p id="70cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">for...of</code>循环来遍历它，如下所示:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="cbfd" class="lq lr it lh b gy ls lt l lu lv">for (let a of generator()) {<br/>  console.log(a);<br/>}</span></pre><p id="7584" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ecd7" class="lq lr it lh b gy ls lt l lu lv">1<br/>2<br/>3</span></pre><p id="735e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以定义自己的iterable对象。只要它有<code class="fe le lf lg lh b">Symbol.iterator</code>方法，我们就可以用<code class="fe le lf lg lh b">for...of</code>循环遍历它。鉴于我们有:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="cd70" class="lq lr it lh b gy ls lt l lu lv">const iterableObj = {<br/>  *[Symbol.iterator]() {<br/>    yield 1;<br/>    yield 2;<br/>    yield 3;<br/>  }<br/>}</span></pre><p id="e5ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用以下语句循环遍历它:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="d3a1" class="lq lr it lh b gy ls lt l lu lv">for (let a of iterableObj) {<br/>  console.log(a);<br/>}</span></pre><p id="7543" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">for...of</code>也可以循环遍历新对象，如<code class="fe le lf lg lh b">Set</code>和<code class="fe le lf lg lh b">Map</code> s:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="1c72" class="lq lr it lh b gy ls lt l lu lv">const set = new Set([1, 1, 2, 2, 2, 3, 5, 4, 3]);</span><span id="6d9b" class="lq lr it lh b gy lw lt l lu lv">for (const value of set) {<br/>  console.log(value);<br/>}</span></pre><p id="6068" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="5fc0" class="lq lr it lh b gy ls lt l lu lv">1<br/>2<br/>3<br/>5<br/>4</span></pre><p id="3a69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以循环浏览地图:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="a9c8" class="lq lr it lh b gy ls lt l lu lv">const map = new Map([<br/>  ['a', 1],<br/>  ['b', 2],<br/>  ['c', 3]<br/>]);</span><span id="04b8" class="lq lr it lh b gy lw lt l lu lv">for (const value of map) {<br/>  console.log(value);<br/>}</span></pre><p id="a014" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以用它来遍历字符串。例如，假设我们有以下字符串:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3132" class="lq lr it lh b gy ls lt l lu lv">const str = 'foo';</span></pre><p id="6b97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以循环遍历每个字符，如下所示:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3295" class="lq lr it lh b gy ls lt l lu lv">for (let char of str) {<br/>  console.log(char);<br/>}</span></pre><p id="a01d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ee8f" class="lq lr it lh b gy ls lt l lu lv">f<br/>o<br/>o</span></pre><p id="732b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，它对于循环任何可以循环的东西非常有用。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/a447b84ea8228fed8fefc93fcc197f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wm4JX1RS7MihXywh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@armedshutter?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ayo ogunsende</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="6d04" class="ly lr it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">表演</h1><p id="a8a9" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">我们可以通过遍历一个包含10000个条目的数字数组来测试这一点。该数组的构造如下:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="2555" class="lq lr it lh b gy ls lt l lu lv">let arr = [];<br/>for (let i = 1; i &lt;= 10000; i++) {<br/>  arr.push(i);<br/>}</span></pre><p id="d169" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试每个循环的性能，我们使用大多数现代浏览器中可用的<code class="fe le lf lg lh b">console.time</code>和<code class="fe le lf lg lh b">console.timeEnd</code>方法。</p><p id="ab63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用数组的<code class="fe le lf lg lh b">forEach</code>方法，我们得到使用数组的<code class="fe le lf lg lh b">forEach</code>方法遍历每个条目需要840.8779296875毫秒。</p><p id="d240" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">for...of</code>循环，遍历同一个数组的每个条目需要843.900390625毫秒。</p><p id="76ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，使用普通的<code class="fe le lf lg lh b">for</code>循环，遍历10000个数字需要841.210205078125毫秒。</p><p id="ef7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用长度缓存，如下所示:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="197c" class="lq lr it lh b gy ls lt l lu lv">const len = arr.length;<br/>for (let i = 0; i &lt; len; i++) {<br/>  console.log(arr[i]);<br/>}</span></pre><p id="e3a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更是快到了593.16796875ms。</p><p id="5062" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，普通的<code class="fe le lf lg lh b">for</code>循环要快得多。然而，对于少量数据的循环，我们可以忍受稍慢的性能。此外，我们不必编写任何额外的代码来遍历其他类型的可迭代对象，如<code class="fe le lf lg lh b">Map</code> s和<code class="fe le lf lg lh b">Set</code> s。</p><p id="b0e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着对于非数组可迭代对象来说，<code class="fe le lf lg lh b">for...of</code>循环仍然更适合遍历这类对象。更少的代码意味着需要更少的处理时间。</p><p id="2ae7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，对于数组来说，如果我们遍历一个有很多条目的数组，那么普通的老式<code class="fe le lf lg lh b">for</code>循环可能是更好的选择。</p><h1 id="0d31" class="ly lr it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">我们应该使用for…of循环吗？</h1><p id="3d11" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">从我们所看到的来看，<code class="fe le lf lg lh b">for...of</code>循环适用于除大型数组之外的任何东西。与其他循环或现成的数组的<code class="fe le lf lg lh b">forEach</code>方法相比，它可以循环更多种类的对象。</p><p id="866a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的设计比其他循环更加灵活和干净。</p><p id="d993" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，只要它们是可迭代的，我们就不必担心我们所循环的内容，这与其他循环不同。</p><p id="4441" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它唯一不擅长的是遍历大型数组。在这种情况下，使用缓存了数组长度的<code class="fe le lf lg lh b">for</code>循环。</p></div></div>    
</body>
</html>