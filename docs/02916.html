<html>
<head>
<title>Regular Expressions with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的正则表达式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/regular-expressions-with-python-8bc59c439d23?source=collection_archive---------7-----------------------#2020-04-10">https://levelup.gitconnected.com/regular-expressions-with-python-8bc59c439d23?source=collection_archive---------7-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0ca6ec9ae06c9a5abe1dfdfb669cabf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ze7SmEGmcWYOoLilGeKxOw.jpeg"/></div></div></figure><p id="a664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正则表达式在处理文本数据时提供了灵活性。</p><p id="ec54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Regex(正则表达式)只是一个对字符串模式表示的文本的搜索查询。对一段文本进行搜索时，您在正则表达式中指定的任何模式都将作为搜索结果返回。</p><p id="03e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能想知道，在python中已经有几个操作字符串的<em class="kw">方法</em>了，Regex还有什么用？</p><p id="cd7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题的答案在于正则表达式的强大和灵活性。</p><p id="1f2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑以下解决方案；</p><p id="9e60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解决方案1: </strong></p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="0deb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决方案2:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="3a3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两种解决方案都是为了解决上述问题，例如为日志输出提取<em class="kw">进程id </em>。然而，对于更大的日志文件，我们几乎不知道<em class="kw">进程id </em>是什么。这可能会改变并导致我们的代码破坏。正则表达式有力地解决了这个问题。</p><h1 id="7046" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">与Python匹配的简单正则表达式:</h1><p id="b0d1" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">正则表达式中，<em class="kw">搜索</em>函数中的<em class="kw">【r】</em>是什么意思？</p><p id="0c08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“r”表示这是一个原始字符串，这意味着python解释器不应该试图解释任何特殊字符，而应该只是将字符串解析为给定的函数。</p><p id="4662" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在python中，总是将Rawstrings与正则表达式一起使用是一个好主意。</p><ul class=""><li id="56f3" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">一个圆点(。)匹配任意字符</strong>。</li></ul><p id="62c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们在正则表达式中包含一个点，那么这个点就是一个通配符，可以用来表示任何字符。请注意，在下面使用点，我们仍然匹配<em class="kw"> lwve </em>，我们想要匹配爱情。<em class="kw">史诗失败</em>。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><ul class=""><li id="be6f" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">caret(^)和美元符号($)告诉我们正则表达式应该在一行的什么地方匹配。</li></ul><p id="85bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抑扬符号表示行的开始，而美元符号表示行的结束。</p><p id="0f5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:扬抑符和美元符号匹配一行的开始和结束，注意一个字符串。参见下面的例子。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><ul class=""><li id="f6d7" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir"> None </strong>是一个特殊的值，python使用它来表示没有匹配返回给正则表达式。</li></ul><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><ul class=""><li id="5f24" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">如果希望匹配不区分大小写，请使用re。IGNORECASE</li></ul><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><ul class=""><li id="8794" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">如果我们需要正则表达式模式中的特定匹配，而不是通配符，例如使用点(.)在我们的模式中，我们可以实现字符类，例如，我们如何匹配单词Python并在匹配中允许小写和大写字母“P”。有几种方法可以做到这一点。</li></ul><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><ul class=""><li id="6d30" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">在字符类中添加抑扬符将返回不在指定组中的匹配字符。在下面的例子中，匹配返回一个点(。)因为它是该组中唯一未指定的字符。注意，该组有一个<em class="kw">空格</em>，它匹配句子中单词之间的空格。</li></ul><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><ul class=""><li id="b4ec" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">您可以使用重复限定符来匹配任何重复多次的字符，包括零个字符。在第一个print语句中，点(。)将匹配扩展到整个单词Pystagrandin。</li></ul><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><h1 id="c8e9" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">使用正则表达式捕获组:</h1><p id="1eaf" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">到目前为止，我们已经使用了Regex <em class="kw">搜索函数</em>来检查一个字符串是否匹配某个模式，然后打印结果。大多数时候，我们希望获取匹配的信息并在代码中使用它。为了做到这一点，我们使用捕获组。</p><p id="d5e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">捕获组是用括号括起来的正则表达式模式的一部分。请参见下面的示例，其中捕获组用于颠倒名称的顺序。</p><pre class="kx ky kz la gt mp mq mr ms aw mt bi"><span id="8693" class="mu le iq mq b gy mv mw l mx my">import re<br/><br/>result= re.search(r"^(\w*), (\w*)$", "Lovelace, Ada")<br/>print(result)<br/>&gt;&gt;&gt;&gt; &lt;re.Match object; span=(0, 13), match='Lovelace, Ada'&gt;<br/><br/>print(result.groups())<br/>&gt;&gt;&gt;&gt;('Lovelace', 'Ada')<br/><br/>print(result[0])<br/>&gt;&gt;&gt;&gt;Lovelace, Ada<br/><br/>print(result[1])<br/>&gt;&gt;&gt;&gt;Lovelace<br/><br/>print(result[2])<br/>&gt;&gt;&gt;&gt;Ada<br/><br/>print("{} {}".format(result[2], result[1]))<br/>&gt;&gt;&gt;&gt;Ada Lovelace</span></pre><p id="00fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以用下面的函数来表示:</p><pre class="kx ky kz la gt mp mq mr ms aw mt bi"><span id="6b50" class="mu le iq mq b gy mv mw l mx my">def rearrange_name(name):<br/>    result= re.search(r"^(\w*), (\w*)$", name)<br/>    if result is None:<br/>        return name<br/>    return "{} {}".format(result[2], result[1])<br/><br/><br/>print(rearrange_name("Bruce, Lee"))<br/>&gt;&gt;&gt;Lee Bruce</span></pre><p id="c3a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上介绍了正则表达式的强大功能。您可以通过访问以下Python文档的链接了解更多信息；</p><ul class=""><li id="067b" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">【https://docs.python.org/3/howto/regex.html T2】号</li><li id="6755" class="mg mh iq ka b kb na kf nb kj nc kn nd kr ne kv ml mm mn mo bi translated">【https://docs.python.org/3/library/re.html T4】</li><li id="3bc0" class="mg mh iq ka b kb na kf nb kj nc kn nd kr ne kv ml mm mn mo bi translated"><a class="ae mz" href="https://docs.python.org/3/howto/regex.html#greedy-versus-non-greedy" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/how to/regex . html #贪婪与非贪婪</a></li></ul></div></div>    
</body>
</html>