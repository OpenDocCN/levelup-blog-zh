<html>
<head>
<title>Asymmetric Cryptography: Signing vs Encrypting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非对称加密:签名与加密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asymmetric-cryptography-signing-vs-encrypting-6ef042024fd9?source=collection_archive---------2-----------------------#2020-12-07">https://levelup.gitconnected.com/asymmetric-cryptography-signing-vs-encrypting-6ef042024fd9?source=collection_archive---------2-----------------------#2020-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/516384a33b11bf671b773e39b49a4fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wSuteDyUKfQ28yzn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">照片由Unsplash上的@hocza拍摄</em></figcaption></figure><p id="4c88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们谈论加密时，我们需要谈论Alice和Bob在示例部分扮演的角色。我希望你不会对它们感到厌烦，因为我也会用它们作为例子。这里，Alice和Bob将使用RSA作为非对称密钥，SHA256作为哈希函数，OAEP用于加密/解密，PSS用于签名/验证，Base64用于编码。</p><h1 id="3655" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">加密</h1><p id="2b03" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">爱丽丝想安全地给鲍勃发送一条重要的消息，而爱丽丝不想让除了鲍勃之外的任何人阅读这条消息。这可能是爱情告白，一个核代码，或者只是私人垃圾邮件。由于他们的亲密关系，爱丽丝和鲍勃交换了他们的公钥，很浪漫，不是吗？于是爱丽丝想到了创建一个小的Go程序来创建加密的消息发送给鲍勃<strong class="ki iu">用鲍勃的公钥</strong>加密消息。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ef09" class="mq lf it mm b gy mr ms l mt mu">import (<br/>  "crypto/rand"<br/>  "crypto/rsa"<br/>  "crypto/sha256"<br/>  "encoding/base64"<br/>  "fmt"<br/>)</span><span id="6270" class="mq lf it mm b gy mv ms l mt mu">func encrypt(key *rsa.PublicKey, plainText string) (string, error) {<br/>  cipherText, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, key, []byte(plainText), nil)</span><span id="c6e3" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return "", fmt.Errorf("encrypt error: %w", err)<br/>  }</span><span id="dcd7" class="mq lf it mm b gy mv ms l mt mu">  return base64.StdEncoding.EncodeToString(cipherText), nil<br/>}</span></pre><p id="b11f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">爱丽丝的加密信息看起来像这样:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bced" class="mq lf it mm b gy mr ms l mt mu">fUYx0yO6gkkCah9LmcX2e7puUkl0x4WsCl8UOajVG6sNse6ly6uGnXIXcRKY2R6khxHrPcvsuTaPK6b83QBgNmO0KU7C6kK2kYvah1/rkRK0WAiAfvA3Z+/i5CvUDJ2ZvbvCHjl9YH97qgUrXrZk7DrYMi+J8VIiF6h85ltLRBxAsTtE2zyYr5gZsWYBCp/NRV4i2kF5mBskbDMW6f/f6jm3jWl5zmaxcxF2NX14itK9VIoNUlFukx+5vR/y17ei7ClX4hgkF/Kdw8ruMpyxX74f9RpqK5KRHSjoJThOp2oDqdpK8r4T8wNGx/VfVcwRM8SyV+VMR91w37ppSCCm2E+XzZeFysKGG9Csbwgsh/KzsuJ3rZ30hYit0fDBqJ1PJTt3bNR05503xY7yaoUtQeDRzr+kfi0hdAYHZyiod/ZkUuphB7zYPS26Utn1synocQ82p1FlH8aAtSOREL9Pw9pNNNMi8Cq18Kcn0rmsjC+JFwlnEk5PkFY5ZLdSNMaXcwfh2kx6bH5d65GgRS1rbrRMBPwywkMmQgukjS9QN2R/GXqZlGeznrt/Pf4r0dV+ZLSgRPb0hSDRfEvjMBWLOvGFI/1dxx7AJhoGB/F9VveBHE6Ry5gMrgNs9Fr0cuMw8I651+GhpatwGVoX13WZaa5Q675RGaiVQaZW/W5bYrs=</span></pre><p id="1c5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当Bob收到来自Alice的加密消息时，Bob希望立即阅读它。因此Bob创建了一个程序用他的私钥解密这个消息。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5392" class="mq lf it mm b gy mr ms l mt mu">import (<br/>  "crypto/rand"<br/>  "crypto/rsa"<br/>  "crypto/sha256"<br/>  "encoding/base64"<br/>  "fmt"<br/>)</span><span id="2c9d" class="mq lf it mm b gy mv ms l mt mu">func decrypt(key *rsa.PrivateKey, cipherText string) (string, error) {<br/>  cipherBytes, err := base64.StdEncoding.DecodeString(cipherText)</span><span id="cd96" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return "", fmt.Errorf("decode error: %w", err)<br/>  }</span><span id="8c72" class="mq lf it mm b gy mv ms l mt mu">plainText, err := rsa.DecryptOAEP(sha256.New(), rand.Reader, key, cipherBytes, nil)</span><span id="38d1" class="mq lf it mm b gy mv ms l mt mu">if err != nil {<br/>    return "", fmt.Errorf("decrypt error: %w", err)<br/>  }</span><span id="89b8" class="mq lf it mm b gy mv ms l mt mu">  return string(plainText), nil<br/>}</span></pre><p id="7b11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，鲍勃能够阅读爱丽丝的信息。因为<strong class="ki iu"> Bob把他的私钥留给了自己，所以别人无法解密Alice的消息</strong>包括我在内，所以我不能在这篇博文里把明文消息给你看。抱歉伙计们。</p><h1 id="5617" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">签署</h1><p id="aaf8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">收到爱丽丝的信息后，鲍勃非常高兴。鲍勃想回复爱丽丝的信息。但是鲍勃忘记把爱丽丝的公钥放在哪里了。鲍勃想宣布一个回复，让每个人都知道他收到爱丽丝的信息后有多高兴。但问题是，<strong class="ki iu"> Bob怎么能保证回复不被别人修改，又能保证宣布回复的Bob</strong>。Bob开始创建一个Go程序<strong class="ki iu">用他的私钥签署消息，这样每个拥有Bob公钥的人都可以验证回复是由Bob宣布的</strong>包括Alice。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="06be" class="mq lf it mm b gy mr ms l mt mu">import (<br/>  "crypto"<br/>  "crypto/rand"<br/>  "crypto/rsa"<br/>  "crypto/sha256"<br/>  "encoding/base64"<br/>  "fmt"<br/>)</span><span id="e3e7" class="mq lf it mm b gy mv ms l mt mu">func sign(key *rsa.PrivateKey, plainText string) (string, error) {<br/>  hash := sha256.New()<br/>  hash.Write([]byte(plainText))<br/>  digest := hash.Sum(nil)</span><span id="d53a" class="mq lf it mm b gy mv ms l mt mu">  signature, err := rsa.SignPSS(rand.Reader, key, crypto.SHA256, digest, nil)</span><span id="e3c3" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return "", fmt.Errorf("sign error: %w", err)<br/>  }</span><span id="c7cf" class="mq lf it mm b gy mv ms l mt mu">  return base64.StdEncoding.EncodeToString(signature), nil<br/>}</span></pre><p id="e8cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鲍勃的回复是这样的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6f3b" class="mq lf it mm b gy mr ms l mt mu">Dear Alice, I'm so happy hearing that from you. Sincerely yours, Bob.</span></pre><p id="f404" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鲍勃的签名看起来像这样:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fddd" class="mq lf it mm b gy mr ms l mt mu">Jsl61bOJIzBs+Ccv8jkrVIeyCBPEU9Ps75ig/GnrP7aUncD3BbIP6AJ8x2jR0UK7aGSE6M/MhRN8zWIgwz8qthcACrec+fz99TGF9CRPn+R9cMezdOzZEMT00unO9u6DppNlQeNHLiCEVfVzvZrRP3GnLBYUzmFNM7LdySbwWmeUE/uOWYQT86FM0i1Tr4DXaVJwyVkIURgRIcmqFAYovQM4m+9Br93+SpnPmEiA4P8eWZ8E+Y5qzA4Hv0HXUHYLnGKUVVsVNhM4o8iL7CVgHr5Fd5JWCmGQPbrNUIOzGRiYOV0BQi/uDRkOW0yGbHtjPHjcuykXeHjgAFE1vVZCT1HwMdsJNOKruuXxoeD43UaoJ/h9ac+8sPKwuWEV476oN2Pm9df0E/JRytGYU7/7MDjs2yEuShhKjGWfj2gWCgJzTbx4IVYs+lwmfcODTkM5b4T+CjINzRXFX73INNWP67g3KxgL4k/3ys7i64HIn3ApMli8aZEvAwjkWyh9JHN7xAeE1TtMN3K3zKXqpRNyfg98kazsV7ViOdP7+oGap9z+22B2SIXgUC4B36UBhk+0chcKJv8fFkowQS0lNLwLM1kRwx69SBEgQpy2KV1ia6X81Q3twEz0nQSiy0iJ5/fN7Wllh+F088SLuyOLo7uK1Ieh+DKJda9R+BsgMC+xBG8=</span></pre><p id="c72b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">阅读公告<strong class="ki iu">的Alice想要确保该消息没有被Bob </strong>修改和发送。于是爱丽丝<strong class="ki iu">用签名和鲍勃的公钥</strong>验证了这条消息。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3754" class="mq lf it mm b gy mr ms l mt mu">import (<br/>  "crypto"<br/>  "crypto/rand"<br/>  "crypto/rsa"<br/>  "crypto/sha256"<br/>  "encoding/base64"<br/>  "fmt"<br/>)</span><span id="8b85" class="mq lf it mm b gy mv ms l mt mu">func verify(key *rsa.PublicKey, message, signature string) (bool, error) {<br/>  hash := sha256.New()<br/>  hash.Write([]byte(message))<br/>  digest := hash.Sum(nil)</span><span id="ffc0" class="mq lf it mm b gy mv ms l mt mu">  signatureBytes, err := base64.StdEncoding.DecodeString(signature)</span><span id="5900" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return false, fmt.Errorf("decode error: %w", err)<br/>  }</span><span id="e8ad" class="mq lf it mm b gy mv ms l mt mu">  err = rsa.VerifyPSS(key, crypto.SHA256, digest, signatureBytes, nil)</span><span id="8355" class="mq lf it mm b gy mv ms l mt mu">  return err == nil, err<br/>}</span></pre><p id="4c8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且核实是Bob公布的回复！总结一下，<code class="fe mw mx my mm b">Encrypt</code>是你在<code class="fe mw mx my mm b">you don't want anyone to read the message except the recipient</code>时要用的方法，而<code class="fe mw mx my mm b">Sign</code>是你在<code class="fe mw mx my mm b">you want to make sure the message hasn't been changed and it can be verified that only you who sent it</code>时要用的方法</p><p id="b8a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里阅读全部Golang代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="95be" class="mq lf it mm b gy mr ms l mt mu">package main</span><span id="8dbc" class="mq lf it mm b gy mv ms l mt mu">import (<br/>  "crypto"<br/>  "crypto/rand"<br/>  "crypto/rsa"<br/>  "crypto/sha256"<br/>  "encoding/base64"<br/>  "fmt"<br/>)</span><span id="b5b1" class="mq lf it mm b gy mv ms l mt mu">func hash(message string) []byte {<br/>  hash := sha256.New()<br/>  hash.Write([]byte(message))<br/>  return hash.Sum(nil)<br/>}</span><span id="0532" class="mq lf it mm b gy mv ms l mt mu">func encode(message []byte) string {<br/>  return base64.StdEncoding.EncodeToString(message)<br/>}</span><span id="a692" class="mq lf it mm b gy mv ms l mt mu">func decode(message string) ([]byte, error) {<br/>  return base64.StdEncoding.DecodeString(message)<br/>}</span><span id="331e" class="mq lf it mm b gy mv ms l mt mu">func encrypt(publicKey *rsa.PublicKey, plainText string) (string, error) {<br/>  cipherText, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, []byte(plainText), nil)</span><span id="7d56" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return "", fmt.Errorf("encrypt error: %w", err)<br/>  }</span><span id="022b" class="mq lf it mm b gy mv ms l mt mu">  return encode(cipherText), nil<br/>}</span><span id="ea2d" class="mq lf it mm b gy mv ms l mt mu">func decrypt(key *rsa.PrivateKey, cipherText string) (string, error) {<br/>  cipherBytes, err := decode(cipherText)</span><span id="304c" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return "", fmt.Errorf("decode error: %w", err)<br/>  }</span><span id="4e0e" class="mq lf it mm b gy mv ms l mt mu">  plainText, err := rsa.DecryptOAEP(sha256.New(), rand.Reader, key, cipherBytes, nil)</span><span id="d3cc" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return "", fmt.Errorf("decrypt error: %w", err)<br/>  }</span><span id="4b63" class="mq lf it mm b gy mv ms l mt mu">  return string(plainText), nil<br/>}</span><span id="840c" class="mq lf it mm b gy mv ms l mt mu">func sign(key *rsa.PrivateKey, plainText string) (string, error) {<br/>  digest := hash(plainText)</span><span id="5779" class="mq lf it mm b gy mv ms l mt mu">  signature, err := rsa.SignPSS(rand.Reader, key, crypto.SHA256, digest, nil)</span><span id="cf42" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return "", fmt.Errorf("sign error: %w", err)<br/>  }</span><span id="737a" class="mq lf it mm b gy mv ms l mt mu">  return encode(signature), nil<br/>}</span><span id="4917" class="mq lf it mm b gy mv ms l mt mu">func verify(key *rsa.PublicKey, message, signature string) (bool, error) {<br/>  digest := hash(message)</span><span id="1e72" class="mq lf it mm b gy mv ms l mt mu">  signatureBytes, err := decode(signature)</span><span id="6fd8" class="mq lf it mm b gy mv ms l mt mu">  if err != nil {<br/>    return false, fmt.Errorf("decode error: %w", err)<br/>  }</span><span id="54f3" class="mq lf it mm b gy mv ms l mt mu">  err = rsa.VerifyPSS(key, crypto.SHA256, digest, signatureBytes, nil)</span><span id="e0f8" class="mq lf it mm b gy mv ms l mt mu">  return err == nil, err<br/>}</span><span id="4d64" class="mq lf it mm b gy mv ms l mt mu">func getBobKey() (*rsa.PrivateKey, *rsa.PublicKey) {<br/>  privateKey, _ := rsa.GenerateKey(rand.Reader, 4096)<br/>  return privateKey, &amp;privateKey.PublicKey<br/>}</span><span id="8d88" class="mq lf it mm b gy mv ms l mt mu">func main() {<br/>  bobPriv, bobPub := getBobKey()<br/>  cipher, _ := encrypt(bobPub, "Dear Bob, &lt;REDACTED&gt;")<br/>  plain, _ := decrypt(bobPriv, cipher)<br/>  fmt.Println("cipher text from Alice:", cipher)<br/>  fmt.Println("plain text from Alice:", plain)</span><span id="f5bb" class="mq lf it mm b gy mv ms l mt mu">  bobReply := `Dear Alice,<br/>I'm so happy hearing that from you.<br/>Sincerely yours, Bob.`</span><span id="3a84" class="mq lf it mm b gy mv ms l mt mu">  replySignature, _ := sign(bobPriv, bobReply)<br/>  fmt.Println("reply from Bob:", bobReply)<br/>  fmt.Println("reply signature from Bob:", replySignature)</span><span id="4b0b" class="mq lf it mm b gy mv ms l mt mu">  isVerified, _ := verify(bobPub, bobReply, replySignature)<br/>  fmt.Println("Was it Bob who sent the message?", isVerified)<br/>}</span></pre><p id="7d60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="2cd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ng">最初发布于</em><a class="ae nh" href="https://clavinjune.dev/en/blogs/asymmetric-cryptography-signing-vs-encrypting/" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://clavinjune . dev</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>