<html>
<head>
<title>Best Practice for Using Timers in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中使用计时器的最佳实践。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/best-practice-for-using-system-timers-timer-in-net-c-867ab6b5027?source=collection_archive---------1-----------------------#2021-12-06">https://levelup.gitconnected.com/best-practice-for-using-system-timers-timer-in-net-c-867ab6b5027?source=collection_archive---------1-----------------------#2021-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="d540" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">最佳实践</h2><div class=""/><div class=""><h2 id="c0f2" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何完全控制计时器，并且能够用单元测试达到100%的覆盖率。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d41e726d02f45c6a54dd1e1920deee63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xdz6gKWXrm1MkaKh_PX_Tw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lh" href="https://unsplash.com/@agebarros?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">agrêBarros</a>拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><p id="6478" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<strong class="lk jd">系统时。定时器。定时器</strong>在你的<strong class="lk jd">里。NET </strong> <strong class="lk jd"> C# </strong>应用程序，你可能会面临抽象它和用单元测试覆盖你的模块的问题。</p><p id="20d4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将讨论如何克服这些挑战的<strong class="lk jd">最佳实践</strong>，最终您将能够实现100%覆盖您的模块。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="mf mg gp gr mh mi"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw lb mi"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="c0ab" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">方法</h1><p id="08d0" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">这是我们解决方案的方式:</p><ol class=""><li id="4f07" class="nu nv it lk b ll lm lo lp lr nw lv nx lz ny md nz oa ob oc bi translated">想出一个非常简单的例子。</li><li id="c886" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">从简单的坏解开始。</li><li id="d62c" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">不断尝试增强它，直到我们达到最终格式。</li><li id="1e78" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">总结我们旅途中的经验教训。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="0faa" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">这个例子</h1><p id="af88" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">在我们的例子中，我们将构建一个简单的<strong class="lk jd">控制台应用程序</strong>，它将只做一件简单的事情，<strong class="lk jd">使用一个系统。Timers.Timer </strong>每一秒向控制台<strong class="lk jd">写入</strong>和<strong class="lk jd">的日期和时间</strong>。</p><p id="effb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，您应该以此结束:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/d47abb6bfea69e9b1a52ce3c1d04f990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pv7nKxQYX3d7bfFaRYVmLA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="510a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你所看到的，这是简单的要求，没有什么花哨。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/728f2d39f8b62bab15a247681b04376d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWOukUlbbs3I273UzEUMhA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@mikael_seegen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mikael Seegen </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="7da7" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">放弃</h1><ol class=""><li id="6aa2" class="nu nv it lk b ll np lo nq lr ok lv ol lz om md nz oa ob oc bi translated">一些最佳实践可能会被忽略/放弃，以便将主要焦点转移到本文中针对的其他最佳实践上。</li><li id="c99d" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">在本文中，我们将重点介绍使用<strong class="lk jd">系统的模块。带有单元测试的定时器</strong>。然而，解决方案的其余部分不会包含在单元测试中。如果你想了解更多这方面的内容，可以查看文章<a class="ae lh" href="https://itnext.io/how-to-fully-cover-net-c-console-application-with-unit-tests-446927a4a793?sk=63c75b56de78903f09f0d0116df5fe3a" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">如何全面覆盖。NET C#控制台应用程序与单元测试</strong> </a>。</li><li id="60bd" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">有一些第三方库可以用来实现几乎类似的结果。然而，只要有可能，我宁愿遵循原生的简单设计，而不是依赖于一个庞大的第三方库。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/4b610410a7fd725d23029b2324a3dd0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJUlHkxtastAcsSSa6wNsw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@miteneva?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">玛利亚·特内娃</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="f378" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">糟糕的解决方案</h1><p id="8422" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">在这个解决方案中，我们将直接使用<strong class="lk jd">系统。Timers.Timer </strong>没有提供抽象层。</p><p id="a170" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">解决方案的结构应该如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/78836ff43875c5bfbf037da842dd60f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*Ryg49jfcpFy-1QcT-hozMQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="5361" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个<strong class="lk jd">使用定时器</strong>的解决方案，只有一个<strong class="lk jd">控制台定时器应用</strong>项目。</p><p id="0c3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我有意投入一些时间和精力将<code class="fe op oq or os b">System.Console</code>抽象成<code class="fe op oq or os b">IConsole</code>,以证明这不会解决我们的计时器问题。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="6cc5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的例子中，我们只需要使用<code class="fe op oq or os b">System.Console.WriteLine</code>，这就是为什么这是唯一的抽象方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="6fb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在<code class="fe op oq or os b">IPublisher</code>接口上只有两个方法；<code class="fe op oq or os b">StartPublishing</code>和<code class="fe op oq or os b">StopPublishing</code>。</p><p id="228b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，为了实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="76ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe op oq or os b">Console</code>只是<code class="fe op oq or os b">System.Console</code>的一个薄薄的包装。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="d897" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe op oq or os b">Publisher</code>是<code class="fe op oq or os b">IPublisher</code>的简单实现。它正在使用一个<code class="fe op oq or os b">System.Timers.Timer</code>并且正在配置它。</p><p id="39eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它将<code class="fe op oq or os b">IConsole</code>定义为一个依赖项。从我的角度来看，这不是最佳做法。如果你想明白我的意思，你可以查看文章<a class="ae lh" href="https://betterprogramming.pub/when-not-to-use-di-ioc-and-ioc-containers-f95881d0fe0?sk=b2aa002a72db4258756feb9cf1daa2a9" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">什么时候不要在。NET C# </strong> </a>。然而，仅仅为了简单起见，我们只是将它作为一个依赖项注入到构造函数中。</p><p id="3fe0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还将计时器间隔设置为1000毫秒(1秒)，并设置处理程序将计时器<code class="fe op oq or os b">SignalTime</code>写入控制台。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="be25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe op oq or os b">Program</code>课堂上，我们做得不多。我们只是创建了一个<code class="fe op oq or os b">Publisher</code>类的实例并开始发布。</p><p id="147d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行这段代码的结果应该是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/d47abb6bfea69e9b1a52ce3c1d04f990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pv7nKxQYX3d7bfFaRYVmLA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="c248" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在的问题是，如果你要为<code class="fe op oq or os b">Publisher</code>类编写一个单元测试，你能做什么？</p><p id="94d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可惜答案会是:<strong class="lk jd"> <em class="ov">不太多</em> </strong>。</p><p id="9a5f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，您没有将计时器本身作为依赖项注入。这意味着您在<code class="fe op oq or os b">Publisher</code>类中隐藏了依赖关系。因此，我们不能嘲笑或stub计时器。</p><p id="811c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其次，假设我们修改了代码，现在计时器被注入到构造函数中，问题仍然是，如何编写一个单元测试并用一个mock或stub替换计时器？</p><p id="1737" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我听到有人在喊，让我们把计时器包装成一个抽象，注入它而不是计时器。</p><p id="70b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，没错，但是，事情没那么简单。我将在下一节解释一些技巧。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/9c741f38bc897f693c45bc8015819689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NlyF-foOizBzsbd9LsxUWA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@carsonmasterson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡森·马斯特森</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="8627" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">好办法</h1><p id="1827" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">这是解决问题的时候了。让我们看看我们能做些什么。</p><p id="2259" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">解决方案的结构应该如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9ea64947a3337caa705fdedfa219755d.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*W9XBfTNsHelTd6Pt-Sdcyw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="f4cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是相同的<strong class="lk jd">使用定时器</strong>的解决方案，带有一个新的<strong class="lk jd">控制台BetterTimerApp </strong>项目。</p><p id="c1b9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe op oq or os b">IConsole</code>、<code class="fe op oq or os b">IPublisher</code>和<code class="fe op oq or os b">Console</code>将是相同的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="810d" class="oy my it bd mz oz pa dn nd pb pc dp nh lr pd pe nj lv pf pg nl lz ph pi nn iz bi translated">伊蒂默</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="0593" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="cc3e" class="nu nv it lk b ll lm lo lp lr nw lv nx lz ny md nz oa ob oc bi translated">我们定义了新的代表<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>。该代表代表由我们的<code class="fe op oq or os b">ITimer</code>提出的事件。</li><li id="9314" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">你可能会说我们不需要这个新的委托，因为我们已经有了原生的<code class="fe op oq or os b">ElapsedEventHandler</code>，它已经被<code class="fe op oq or os b">System.Timers.Timer</code>使用了。</li><li id="2ebb" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">是的，这是真的。然而，您会注意到<code class="fe op oq or os b">ElapsedEventHandler</code>事件提供了<code class="fe op oq or os b">ElapsedEventArgs</code>作为事件参数。这个<code class="fe op oq or os b">ElapsedEventArgs</code>有一个私有构造函数，你不能创建自己的实例。此外，<code class="fe op oq or os b">ElapsedEventArgs</code>类中定义的<code class="fe op oq or os b">SignalTime</code>属性是只读的。因此，您将无法在子类中重写它。</li><li id="e0a9" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">有一个为微软打开的变更请求标签来更新这个类，但是直到写这篇文章的时候还没有应用任何变更。</li><li id="6aa5" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">另外，请注意<code class="fe op oq or os b">ITimer</code>延伸了<code class="fe op oq or os b">IDisposable</code>。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="f06d" class="oy my it bd mz oz pa dn nd pb pc dp nh lr pd pe nj lv pf pg nl lz ph pi nn iz bi translated">出版者</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="e493" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了小改动，和老款<code class="fe op oq or os b">Publisher</code>差不多。现在我们将<code class="fe op oq or os b">ITimer</code>定义为通过构造函数注入的依赖项。代码的其余部分是相同的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="3a51" class="oy my it bd mz oz pa dn nd pb pc dp nh lr pd pe nj lv pf pg nl lz ph pi nn iz bi translated">计时器</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="1919" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">几乎所有的奇迹都发生在这里。</p><p id="2f95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="39c0" class="nu nv it lk b ll lm lo lp lr nw lv nx lz ny md nz oa ob oc bi translated">在内部，我们使用<code class="fe op oq or os b">System.Timers.Timer</code>。</li><li id="bc74" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">我们应用了IDisposable设计模式。所以才能看到<code class="fe op oq or os b">private bool m_IsDisposed</code>、<code class="fe op oq or os b">public void Dispose()</code>、<code class="fe op oq or os b">protected virtual void Dispose(bool disposing)</code>、<code class="fe op oq or os b">~Timer()</code>。</li><li id="4a27" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">在构造函数中，我们正在初始化一个新的<code class="fe op oq or os b">System.Timers.Timer</code>实例。在余下的步骤中，我们称之为<strong class="lk jd">内部定时器</strong>。</li><li id="702f" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">对于<code class="fe op oq or os b">public bool Enabled</code>、<code class="fe op oq or os b">public double Interval</code>、<code class="fe op oq or os b">public void Start()</code>和<code class="fe op oq or os b">public void Stop()</code>，我们只是将实现委托给内部定时器。</li><li id="8fef" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">对于<code class="fe op oq or os b">public event TimerIntervalElapsedEventHandler TimerIntervalElapsed</code>，这是最重要的部分，所以让我们一步步来分析。</li><li id="f624" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">我们需要对这个事件做的是，当有人从外部订阅/取消订阅它时进行处理。在这种情况下，我们希望将其镜像到内部定时器。</li><li id="358d" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">换句话说，如果来自外部的某个人正在拥有我们的<code class="fe op oq or os b">ITimer</code>的一个实例，他应该能够做这样的事情<code class="fe op oq or os b">t.TimerIntervalElapsed += (sender, dateTime) =&gt; { //do something }</code>。</li><li id="3994" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">此时此刻，我们应该做的是在内部做一些类似<code class="fe op oq or os b">m_Timer.Elapsed += (sender, elapsedEventArgs) =&gt; { //do something }</code>的事情。</li><li id="b95c" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">然而，我们需要记住，这两个处理程序并不相同，因为它们实际上是不同的类型；<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>和<code class="fe op oq or os b">ElapsedEventHandler</code>。</li><li id="45cb" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">因此，我们需要做的是将传入的<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>包装成一个新的内部<code class="fe op oq or os b">ElapsedEventHandler</code>。这是我们可以做到的。</li><li id="17f3" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">然而，我们还需要记住，在某些时候，有人可能需要取消处理程序对<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>事件的订阅。</li><li id="14e3" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">这意味着此时，我们需要知道哪个<code class="fe op oq or os b">ElapsedEventHandler</code>处理程序对应于那个<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>处理程序，这样我们就可以从内部定时器中取消订阅。</li><li id="574d" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">实现这一点的唯一方法是通过在字典中跟踪每个<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>处理程序和新创建的<code class="fe op oq or os b">ElapsedEventHandler</code>处理程序。这样，通过知道传入的<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>处理程序，我们就可以知道相应的<code class="fe op oq or os b">ElapsedEventHandler</code>处理程序。</li><li id="3b0d" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">然而，我们还需要记住，从外部来看，有人可能不止一次地订阅同一个<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>处理程序。</li><li id="62b0" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">是的，这不符合逻辑，但仍然是可行的。因此，为了完整起见，对于每个<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>处理程序，我们将保留一个<code class="fe op oq or os b">ElapsedEventHandler</code>处理程序的列表。</li><li id="d189" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">在大多数情况下，该列表只有一个条目，除非出现重复订阅。</li><li id="3b4f" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">这就是为什么你能看到这个<code class="fe op oq or os b">private Dictionary&lt;TimerIntervalElapsedEventHandler, List&lt;ElapsedEventHandler&gt;&gt; m_Handlers = new();</code>。</li></ol><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="54b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe op oq or os b">add</code>中，我们正在创建一个新的<code class="fe op oq or os b">ElapsedEventHandler</code>，在<code class="fe op oq or os b">m_Handlers</code>字典中添加一个记录，将它映射到<code class="fe op oq or os b">TimerIntervalElapsedEventHandler</code>，最后订阅内部计时器。</p><p id="877d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe op oq or os b">remove</code>中，我们正在获取相应的<code class="fe op oq or os b">ElapsedEventHandler</code>处理程序列表，选择最后一个处理程序，将其从内部定时器中取消订阅，将其从列表中删除，如果列表为空，则删除整个条目。</p><p id="33ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，值得一提的是,<code class="fe op oq or os b">Dispose</code>的实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="c7ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们从内部计时器中取消订阅所有剩余的处理程序，释放内部计时器，并清除<code class="fe op oq or os b">m_Handlers</code>字典。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="041f" class="oy my it bd mz oz pa dn nd pb pc dp nh lr pd pe nj lv pf pg nl lz ph pi nn iz bi translated">程序</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="776f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这方面，我们仍然做得不多。它几乎与旧的解决方案相同。</p><p id="c445" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行这段代码的结果应该是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/d47abb6bfea69e9b1a52ce3c1d04f990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pv7nKxQYX3d7bfFaRYVmLA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/ff456d3bb6f35b67174fcb943f551e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QHlvmi0Dxacckdoga_ad6A.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@testalizeme?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Testalize.me </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="c2f5" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated"><strong class="ak">考验的时候到了，考验的时刻到了</strong></h1><p id="6804" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">现在，我们有了最终的设计。然而，我们需要看看这个设计是否真的能帮助我们用单元测试覆盖我们的<code class="fe op oq or os b">Publisher</code>模块。</p><p id="2d41" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">解决方案的结构应该如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/d72a4388326cd52d359d4b0304c6afc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*9M9IYf_f1FqSso4FNz-gUQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="83c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我正在使用<strong class="lk jd"> NUnit </strong>和<strong class="lk jd"> Moq </strong>进行测试。你当然可以使用你喜欢的库。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="5420" class="oy my it bd mz oz pa dn nd pb pc dp nh lr pd pe nj lv pf pg nl lz ph pi nn iz bi translated">TimerStub</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="6703" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里可以注意到:</p><ol class=""><li id="f16c" class="nu nv it lk b ll lm lo lp lr nw lv nx lz ny md nz oa ob oc bi translated">我们定义了在记录通过计时器存根执行的操作时使用的<code class="fe op oq or os b">Action</code>枚举。这将在以后用于断言所执行的内部操作。</li><li id="b331" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">此外，我们定义了用于日志记录的<code class="fe op oq or os b">ActionLog</code>类。</li><li id="16a7" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">我们将<code class="fe op oq or os b">TimerStub</code>类定义为<code class="fe op oq or os b">ITimer</code>的存根。我们将在测试<code class="fe op oq or os b">Publisher</code>模块时使用这个存根。</li><li id="ee4f" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">实现很简单。值得一提的是，我们添加了一个额外的<code class="fe op oq or os b">public void TriggerTimerIntervalElapsed(DateTime dateTime)</code>方法，这样我们可以在单元测试中手动触发存根。</li><li id="33bd" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">我们还可以传入<code class="fe op oq or os b">dateTime</code>的期望值，这样我们就有了一个已知的值来断言。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h2 id="7598" class="oy my it bd mz oz pa dn nd pb pc dp nh lr pd pe nj lv pf pg nl lz ph pi nn iz bi translated">出版商测试</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4596" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在正如你所看到的，我们有了完全的控制权，我们可以轻松地用单元测试覆盖我们的<code class="fe op oq or os b">Publisher</code>模块。</p><p id="8968" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们计算覆盖率，我们应该得到这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/18dd99ddec64743757b337e0b0790143.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*SFjHbxhzT6OSpRox3T-r5g.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a></figcaption></figure><p id="0fbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如你所见，<code class="fe op oq or os b">Publisher</code>模块被100%覆盖。至于其他的，这超出了本文的范围，但是如果你按照文章<a class="ae lh" href="https://itnext.io/how-to-fully-cover-net-c-console-application-with-unit-tests-446927a4a793?sk=63c75b56de78903f09f0d0116df5fe3a" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">中的方法去做，你就可以简单地覆盖它。NET C#控制台应用程序与单元测试</strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/3368e7185a53faa8655ad047c009bed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9amJZoenBeazTphx_tGXzg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@jingdachen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">陈京达</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="32ef" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">最后的话</h1><p id="eb23" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">你能做到的。这只是将大模块分割成小模块，定义你的抽象概念，对棘手的部分进行创新，然后你就完成了。</p><p id="b171" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想更多地训练自己，你可以查看我关于一些最佳实践的其他文章。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="0d58" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="55db" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">如果您还不是<strong class="lk jd">媒介</strong>会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="lk jd">媒介</strong>那里获得您的一部分费用，您无需支付任何额外费用。订阅<a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="c67e" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">其他资源</h1><p id="ebf5" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">这些是你可能会发现有用的其他资源。</p><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/prototype-design-pattern-in-net-c-67db46c3d28f"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">中的原型设计模式。NET C#</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">中了解原型设计模式。NET C#</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="pn l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a href="https://itnext.io/how-to-fully-cover-net-c-console-application-with-unit-tests-446927a4a793" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">如何全面覆盖。带有单元测试的. NET C#控制台应用程序</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">知道什么吗？又是怎么做到的？使用TDD、DI和IoC完全覆盖您的控制台应用程序。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">itnext.io</p></div></div><div class="mr l"><div class="po l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/memory-management-in-net-740b03d01e24"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">中的内存管理。网</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">中关于内存管理的所有内容。NET和重要的相关主题。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="pp l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/compiler-friendly-code-sealed-keyword-in-net-c-b363fbcd1e35"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">编译器友好代码:在。NET C#</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">Why &amp; When Sealed关键字可以提高。NET C#</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="pq l mt mu mv mr mw lb mi"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>