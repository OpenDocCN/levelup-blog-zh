<html>
<head>
<title>Closest Binary Search Tree K-Values Problem — LeetCode Hard (Proposed Solution)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最接近的二叉查找树K值问题LeetCode Hard(建议的解决方案)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/closest-binary-search-tree-k-values-problem-leetcode-hard-proposed-solution-893cc5855df0?source=collection_archive---------4-----------------------#2020-12-25">https://levelup.gitconnected.com/closest-binary-search-tree-k-values-problem-leetcode-hard-proposed-solution-893cc5855df0?source=collection_archive---------4-----------------------#2020-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/09fc4a1b160694f40516ea20dbd3436d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UO-EJ8VT4-xhpP59BAl_Nw.png"/></div></div></figure><div class=""/><h1 id="5f01" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">背景</h1><p id="4619" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章和接下来的文章中，我会用我提出的解决方案深入探讨一些CS问题。我会尽量遵循最简单的方法“这是可以接受的，足够好，但可能不是最理想的”，让每个人都容易吸收。现在，我们开始吧。</p><p id="ceb4" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我最近检查的一个有趣的问题是最接近的二叉查找树k值问题。</p><h1 id="519b" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题陈述</h1><p id="c85f" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是<a class="ae lz" href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" rel="noopener ugc nofollow" target="_blank">原问题陈述</a>，给定一个非空二叉查找树和一个目标值，在BST中找出最接近目标的k值。</p><p id="d719" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意:</p><p id="8bb8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">给定的目标值是浮点值。</p><p id="4f20" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可以假设k总是有效的，即:k ≤总节点数。</p><p id="f35a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">保证BST中只有一组唯一的k值最接近目标值。</p><p id="3572" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">举例:</strong></p><p id="403b" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">输入:</strong>根= [4，2，5，1，3]，目标= 3.714286，<em class="ma"> k </em> = 2</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="874f" class="mk jz jb mg b gy ml mm l mn mo">    4</span><span id="81b2" class="mk jz jb mg b gy mp mm l mn mo">   / \</span><span id="631c" class="mk jz jb mg b gy mp mm l mn mo">  2   5</span><span id="b7e8" class="mk jz jb mg b gy mp mm l mn mo"> / \</span><span id="9ba8" class="mk jz jb mg b gy mp mm l mn mo">1   3</span></pre><p id="766f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">输出:</strong>【4，3】</p><h1 id="9937" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">提议解决方案(迭代方法+优先级队列)</h1><p id="1527" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">像许多其他CS问题一样，我们可以有多个可接受的解决方案。但是为了展示一个容易理解的方法，我们将尝试用一个简单且足够好的方法来解决它。这种方法的主要思想是遍历输入树，将该树的前k个值放入优先级队列，然后使用该优先级队列的值作为结果。让我们来看一个Java实现。</p><h2 id="8053" class="mk jz jb bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">密码</h2><figure class="mb mc md me gt is"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="f158" class="mk jz jb bd ka mq mr dn ke ms mt dp ki lh mu mv km ll mw mx kq lp my mz ku na bi translated">复杂性</h2><p id="7109" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">上述解决方案的时间复杂度为<code class="fe nd ne nf mg b">O(K(Log(N))</code>。注意，这个问题也可以递归解决，这可以将空间复杂度从<code class="fe nd ne nf mg b">O(N)</code>降低到<code class="fe nd ne nf mg b">O(k + height of traversed tree)</code>。</p><h1 id="5f95" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">其他可能的解决方案</h1><p id="c383" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以使用<a class="ae lz" href="https://en.wikipedia.org/wiki/Quickselect" rel="noopener ugc nofollow" target="_blank">快速选择算法</a>来解决这个问题，它可以有更好的时间复杂度O(N ),但它的最坏情况是O(N)。</p><h1 id="b643" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">下一步做什么</h1><p id="15d2" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果你有更好的解决方案，请随时发表评论。另外，请随意分享这种方法，并在:<a class="ae lz" href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/closest-binary-search-tree-value-ii/</a>中试用</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="47b1" class="jy jz jb bd ka kb nn kd ke kf no kh ki kj np kl km kn nq kp kq kr nr kt ku kv bi translated">分级编码</h1><p id="8d40" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">感谢您成为我们社区的一员！<a class="ae lz" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="ky jc">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae lz" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky jc"> Skilled.dev编码面试课程</strong> </a>。</p><div class="ip iq gp gr ir ns"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jc gy z fp nx fr fs ny fu fw ja bi translated">编写面试问题+获得开发工作</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">掌握编码面试的过程</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">技术开发</p></div></div><div class="ob l"><div class="oc l od oe of ob og ix ns"/></div></div></a></div></div></div>    
</body>
</html>