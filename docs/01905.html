<html>
<head>
<title>JavaScript Interview Questions: Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试问题:承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-interview-questions-promises-400c51805cbe?source=collection_archive---------5-----------------------#2020-02-05">https://levelup.gitconnected.com/javascript-interview-questions-promises-400c51805cbe?source=collection_archive---------5-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f282df36c6702e2ad7d966413780fe6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eZh8pAgIxOhCZVy2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">莎拉·塞万提斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4f5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="24e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于异步编程的普遍使用，承诺是JavaScript的重要部分。</p><p id="50cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些关于JavaScript承诺的常见问题。</p><h1 id="0182" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是承诺？</h1><p id="0b92" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">承诺是JavaScript中处理异步操作的一种方式。每个承诺代表一次行动。</p><p id="824d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它旨在以一种干净的方式解决组合多段异步代码的问题。</p><p id="2cbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了承诺，我们可以避免回调嵌套太深。</p><p id="9579" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不用编写如下深度嵌套的回调:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e4fe" class="mq lf it mm b gy mr ms l mt mu">const fs = require('fs');</span><span id="cf4e" class="mq lf it mm b gy mv ms l mt mu">fs.readFile('somefile.txt', function (e, data) {<br/>  <br/>  fs.readdir('directory', function (e, files) {<br/>    <br/>    fs.mkdir('directory', function (e) {<br/>    <br/>    })<br/>  })<br/>})</span></pre><p id="60f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="338b" class="mq lf it mm b gy mr ms l mt mu">const fs = require('fs');</span><span id="9306" class="mq lf it mm b gy mv ms l mt mu">const promiseReadFile = (fileName) =&gt; {<br/>  return new Promise((resolve) =&gt; {<br/>    fs.readFile('somefile.txt', function(e, data) {<br/>      resolve(data);<br/>    })<br/>  })<br/>}</span><span id="f77a" class="mq lf it mm b gy mv ms l mt mu">const promiseReadDir = (directory) =&gt; {<br/>  return new Promise((resolve) =&gt; {<br/>    fs.readdir(directory, function(e, data) {<br/>      resolve(data);<br/>    })<br/>  })<br/>}</span><span id="25f7" class="mq lf it mm b gy mv ms l mt mu">const promiseMakwDir = (directory) =&gt; {<br/>  return new Promise((resolve) =&gt; {<br/>    fs.mkdir(directory, function(e, data) {<br/>      resolve(data);<br/>    })<br/>  })<br/>}</span><span id="f7c4" class="mq lf it mm b gy mv ms l mt mu">promiseReadFile('somefile.txt')<br/>.then((data)=&gt;{<br/>  console.log(data);<br/>  return promiseReadDir('directory')<br/>})<br/>.then((data)=&gt;{<br/>  console.log(data);<br/>  return promiseMakwDir('directory')<br/>})<br/>.then((data)=&gt;{<br/>  console.log(data);  <br/>})</span></pre><p id="337b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将承诺串连起来，而不是嵌套起来，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="139b" class="mq lf it mm b gy mr ms l mt mu">promiseReadFile('somefile.txt')<br/>.then((data)=&gt;{<br/>  console.log(data);<br/>  return promiseReadDir('directory')<br/>})<br/>.then((data)=&gt;{<br/>  console.log(data);<br/>  return promiseMakwDir('directory')<br/>})<br/>.then((data)=&gt;{<br/>  console.log(data);  <br/>})</span></pre><p id="dc32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么我们要为长长的承诺链编写承诺，而不是深度嵌套的回调。读起来就容易多了。</p><p id="5cb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">承诺有三种状态。它们可能是待定的，这意味着结果还不知道，因为操作还没有开始。</p><p id="36b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以实现，也就是说异步操作成功了，我们有结果了。</p><p id="8750" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以拒绝，表示失败了，有失败的原因。</p><p id="6b65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个承诺可以被解决，这意味着它要么被实现，要么被拒绝。</p><p id="1529" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，在上面的代码中，我们调用了<code class="fe mw mx my mm b">resolve</code>函数来返回承诺的值。为了获得承诺的解析值，我们从回调的参数中获得解析值。</p><p id="c6d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">data</code>在每个回调中都有从它上面的承诺解析的数据。</p><p id="53fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在回调中运行下一个承诺，我们返回了下一个承诺。</p><p id="bf21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了拒绝一个承诺，我们在回调中调用<code class="fe mw mx my mm b">reject</code>函数，并将其传递给<code class="fe mw mx my mm b">Promise</code>构造函数。</p><p id="db31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以将上面的代码更改为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="56bf" class="mq lf it mm b gy mr ms l mt mu">const fs = require('fs');</span><span id="42ff" class="mq lf it mm b gy mv ms l mt mu">const promiseReadFile = (fileName) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    fs.readFile('somefile.txt', function(e, data) {<br/>      if (e){<br/>        reject(e);<br/>      }<br/>      resolve(data);<br/>    })<br/>  })<br/>}</span><span id="45df" class="mq lf it mm b gy mv ms l mt mu">const promiseReadDir = (directory) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    fs.readdir(directory, function(e, data) {<br/>      if (e){<br/>        reject(e);<br/>      }<br/>      resolve(data);<br/>    })<br/>  })<br/>}</span><span id="516a" class="mq lf it mm b gy mv ms l mt mu">const promiseMakwDir = (directory) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    fs.mkdir(directory, function(e, data) {<br/>      if (e){<br/>        reject(e);<br/>      }<br/>      resolve(data);<br/>    })<br/>  })<br/>}</span><span id="2c59" class="mq lf it mm b gy mv ms l mt mu">promiseReadFile('somefile.txt')<br/>.then((data)=&gt;{<br/>  console.log(data);<br/>  return promiseReadDir('directory')<br/>})<br/>.then((data)=&gt;{<br/>  console.log(data);<br/>  return promiseMakwDir('directory')<br/>})<br/>.then((data)=&gt;{<br/>  console.log(data);  <br/>})<br/>.catch((err)=&gt;{<br/>  console.log(err);<br/>})</span></pre><p id="4802" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦承诺被拒绝，随之而来的承诺就不会兑现。</p><p id="5f33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以得到错误的详细信息，并像上面那样在<code class="fe mw mx my mm b">catch</code>函数的回调中对它做些什么。</p><p id="31ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过创建一个函数将每个异步代码转换成一个承诺，然后在函数中返回一个承诺，调用<code class="fe mw mx my mm b">resolve</code>来实现承诺，调用<code class="fe mw mx my mm b">reject</code>来拒绝带有错误值的承诺。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/79177ee8187139a24f279f6739c8bee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zvv5Z-B0BiKgwdgD"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@christianbuehner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> christian buehner </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="9be9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是异步/等待？</h1><p id="8751" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">是一种以更短的方式编写承诺链的新方法。</p><p id="3690" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们没有像上面那样用回调来调用<code class="fe mw mx my mm b">then</code>函数，而是将其重写为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5d16" class="mq lf it mm b gy mr ms l mt mu">try {<br/>    const readFileData = await promiseReadFile('somefile.txt');<br/>    console.log(readFileData);<br/>    const readDirData = await promiseReadDir('directory');<br/>    console.log(readDirData);<br/>    const makeFileData = await promiseMakwDir('directory');<br/>    console.log(makeFileData);<br/>    return makeFileData;<br/>  }<br/>  catch(err){<br/>    console.log(err);<br/>  }  <br/>})();</span></pre><p id="09b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这与以下内容相同:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6f37" class="mq lf it mm b gy mr ms l mt mu">promiseReadFile('somefile.txt')<br/>.then((data)=&gt;{<br/>  console.log(data);<br/>  return promiseReadDir('directory')<br/>})<br/>.then((data)=&gt;{<br/>  console.log(data);<br/>  return promiseMakwDir('directory')<br/>})<br/>.then((data)=&gt;{<br/>  console.log(data);  <br/>})<br/>.catch((err)=&gt;{<br/>  console.log(err);<br/>})</span></pre><p id="551b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，<code class="fe mw mx my mm b">async/await</code>比用回调写<code class="fe mw mx my mm b">then</code>要短得多。</p><p id="e5b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们没有回调，也不需要在每次回调时都做出承诺。</p><p id="c0a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">readFileData</code>、<code class="fe mw mx my mm b">readDirData</code>和<code class="fe mw mx my mm b">makeFileData</code>与每个<code class="fe mw mx my mm b">then</code>回调中的<code class="fe mw mx my mm b">data</code>参数相同。</p><p id="0ad5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">async</code>中的<code class="fe mw mx my mm b">try...catch</code>功能与<code class="fe mw mx my mm b">catch</code>中的调用和回调结束相同。<code class="fe mw mx my mm b">err</code>在两个例子中有相同的错误对象。</p><p id="152a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">async</code>函数只能返回承诺，所以<code class="fe mw mx my mm b">makeFileData</code>实际上是承诺的解析值，而不是实际值。</p><p id="500e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管它看起来像一个同步函数，但它的行为并不相同。</p><h1 id="6e33" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5297" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">承诺是一种干净地链接异步操作而无需深度嵌套回调的方式。</p><p id="3dd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mw mx my mm b">async/await</code>语法让它们更短更简洁。</p></div></div>    
</body>
</html>