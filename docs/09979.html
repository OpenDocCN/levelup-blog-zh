<html>
<head>
<title>Performant URL routing — with PHP and regular expressions (regex)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高性能URL路由—使用PHP和正则表达式(regex)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/performant-url-routing-with-php-and-regular-expressions-regex-866480493412?source=collection_archive---------7-----------------------#2021-10-11">https://levelup.gitconnected.com/performant-url-routing-with-php-and-regular-expressions-regex-866480493412?source=collection_archive---------7-----------------------#2021-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8a7b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用PHP和regex实现高性能URL路由的简单教程。需要PHP，htaccess和regex的基础知识。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/26224c865472cdb4c7cf5ca9295556c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZqJqEoFBMqttecMQsefMWQ.jpeg"/></div></div></figure><p id="31d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开头简单解释了一下:url路由器是做什么的？url路由器评估请求的URL，并根据定义的规范对其进行解释。我使用这个路由器通过URL加载一个特定的控制器。一个例子:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="3d04" class="ls lt iq lo b gy lu lv l lw lx"><a class="ae ly" href="http://www.website.de/user/edit/4" rel="noopener ugc nofollow" target="_blank">http://www.website.com/user/edit/4</a></span></pre><p id="2999" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个url应该用动作<em class="lz">【编辑】</em>和参数<em class="lz">【4】</em>调用控制器<em class="lz">【用户】</em>。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="4d0a" class="ls lt iq lo b gy lu lv l lw lx">include 'ctrl/user-edit.ctrl.php';</span></pre><p id="e071" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个例子:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="68dd" class="ls lt iq lo b gy lu lv l lw lx">http://www.website.com/company/search/autocomplete/german</span></pre><p id="daee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个url应该调用控制器“company ”,动作为“search-autocomplete ”,过滤器为“german”。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="e411" class="ls lt iq lo b gy lu lv l lw lx">include 'ctrl/company-search-autocomplete.ctrl.php';</span></pre><p id="5fea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这两个例子中，我仍然有像用户id或过滤器这样的参数。这些应该能够传递给php脚本，而不是控制器名称的一部分，控制器名称应该来自url。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="35c8" class="mh lt iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">步骤htaccess文件</h1><p id="c424" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">为了让<em class="lz">“http://www . website . com/”</em>之后的部分被PHP读取，你需要一个htaccess文件，向web服务器发送重写指令。在这个例子中，这是由ModRewrite完成的，这是大多数Apache和nginx服务器的标准。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="a1f1" class="ls lt iq lo b gy lu lv l lw lx"># ModRewrite activate<br/>RewriteEngine On<br/><br/># Let files and folder through<br/>RewriteCond %{REQUEST_FILENAME} !-f<br/>RewriteCond %{REQUEST_FILENAME} !-d<br/><br/># rewrite URL<br/>RewriteRule (.+) index.php?path=$0 [L,QSA]</span></pre><p id="137c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后一行说的是<em class="lz">“http://www . domain . com/”</em>之后的部分是如何传递给PHP脚本的:作为get参数“path”。</p><h1 id="11a0" class="mh lt iq bd mi mj nd ml mm mn ne mp mq jw nf jx ms jz ng ka mu kc nh kd mw mx bi translated">第二步:路线</h1><p id="0377" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">为了使路由工作，脚本需要关于存在哪些路由的信息。在这个例子中，我定义了三条路由，并将所有内容放在一个文件<em class="lz">“index . PHP”</em>中。对于较大的项目，您也可以将路由放在配置文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2391" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些路线是一个三重嵌套的数组。<em class="lz">“path _ pattern”</em>值是一个正则表达式，表示通常应用于url的模式公式。本例中的值<em class="lz">“控制器”</em>是一个控制器文件的路径。</p><h1 id="e46c" class="mh lt iq bd mi mj nd ml mm mn ne mp mq jw nf jx ms jz ng ka mu kc nh kd mw mx bi translated">步骤3:路由器功能</h1><p id="8ac5" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">我现在将展示完整的路由器功能，然后一步一步地解释每个代码块的作用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="055d" class="mh lt iq bd mi mj nd ml mm mn ne mp mq jw nf jx ms jz ng ka mu kc nh kd mw mx bi translated">该功能</h1><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="4483" class="ls lt iq lo b gy lu lv l lw lx">function router($routes)<br/>{<br/>}</span></pre><p id="3caf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我把这个函数命名为<em class="lz">“路由器”</em>。参数是先前创建的数组“routes”。</p><h1 id="c5dd" class="mh lt iq bd mi mj nd ml mm mn ne mp mq jw nf jx ms jz ng ka mu kc nh kd mw mx bi translated">基本变量</h1><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="3a77" class="ls lt iq lo b gy lu lv l lw lx">function router($routes)<br/>{<br/>  $route_match = false;<br/>  $url_path    = 'index';<br/>  $url_params  = array();<br/>}</span></pre><p id="e2b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lz">“route _ match”</em>是一个布尔变量，目前设置为false。因此，在执行该函数之前，还没有匹配的路由。最初，变量<em class="lz">“URL _ path”</em>被设置为值<em class="lz">“index”</em>。为了存储可能的URL参数，我初始化了数组<em class="lz"> "url_params" </em>。</p><h1 id="c752" class="mh lt iq bd mi mj nd ml mm mn ne mp mq jw nf jx ms jz ng ka mu kc nh kd mw mx bi translated">获取参数路径</h1><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="35df" class="ls lt iq lo b gy lu lv l lw lx">function router($routes)<br/>{<br/>  $route_match = false;<br/>  $url_path    = 'index';<br/>  $url_params  = array();<br/>  <br/>  if(isset($_GET['path']))<br/>  {<br/>    $url_path = $_GET['path'];<br/>    if(substr($url_path,-1) == '/')<br/>    {<br/>      $url_path = substr($url_path,0,-1);<br/>    }<br/>  }<br/>}</span></pre><p id="dd23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我检查GET变量是否存在。如果是这样，我用GET参数<em class="lz">“path”</em>中的值覆盖<em class="lz">“URL _ path”</em>。</p><p id="ffd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">if条件<em class="lz"> "if(substr($url_path，-1) == '/')" </em>截断字符串<em class="lz"> "url_path" </em>的最后一个字符，如果是<em class="lz">"/</em>。</p><h1 id="f521" class="mh lt iq bd mi mj nd ml mm mn ne mp mq jw nf jx ms jz ng ka mu kc nh kd mw mx bi translated">用正则表达式检查路线</h1><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="7df3" class="ls lt iq lo b gy lu lv l lw lx">function router($routes)<br/>{<br/>  $route_match = false;<br/>  $url_path    = 'index';<br/>  $url_params  = array();<br/>  <br/>  if(isset($_GET['path']))<br/>  {<br/>    $url_path = $_GET['path'];<br/>    if(substr($url_path,-1) == '/')<br/>    {<br/>      $url_path = substr($url_path,0,-1);<br/>    }<br/>  }<br/>  <br/>  foreach($routes as $route)<br/>  {<br/>    if(preg_match($route['path_pattern'],$url_path,$matches))<br/>    {<br/>      $url_params  = array_merge($url_params,$matches);<br/>      $route_match = true;<br/>      break;<br/>    }<br/>  }<br/>}</span></pre><p id="d397" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在foreach循环中，我遍历了变量<em class="lz">“routes”</em>。if-condition<em class="lz">“if(preg _ match(…))”</em>检查当前循环元素的模式是否与变量<em class="lz">“URL _ path”</em>匹配，并立即传递带有变量<em class="lz">“matches”</em>的匹配变量。然后，变量<em class="lz">“url _ params”</em>包含URL中包含的参数。</p><p id="43c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将变量<em class="lz">“route _ match”</em>设置为<em class="lz">“true”</em>，并为foreach循环给出一个<em class="lz">“break”</em>。</p><h1 id="900e" class="mh lt iq bd mi mj nd ml mm mn ne mp mq jw nf jx ms jz ng ka mu kc nh kd mw mx bi translated">变量的评估</h1><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="5f9d" class="ls lt iq lo b gy lu lv l lw lx">function router($routes)<br/>{<br/>  $route_match = false;<br/>  $url_path    = 'index';<br/>  $url_params  = array();<br/>  <br/>  if(isset($_GET['path']))<br/>  {<br/>    $url_path = $_GET['path'];<br/>    if(substr($url_path,-1) == '/')<br/>    {<br/>      $url_path = substr($url_path,0,-1);<br/>    }<br/>  }<br/>  <br/>  foreach($routes as $route)<br/>  {<br/>    if(preg_match($route['path_pattern'],$url_path,$matches))<br/>    {<br/>      $url_params  = array_merge($url_params,$matches);<br/>      $route_match = true;<br/>      break;<br/>    }<br/>  }<br/>  <br/>  if(!$route_match)<br/>  {<br/>    exit('URL path "'.$url_path.'" is not defined.');<br/>  }<br/>  <br/>  if(file_exists($route['controller']))<br/>  {<br/>    include($route['controller']);<br/>  }<br/>  else<br/>  {<br/>    exit('Controller "'.$route['controller'].'" does not exists.');<br/>  }<br/>}</span></pre><p id="adef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我检查<em class="lz">“route _ match”</em>是否仍为<em class="lz">“false”</em>，并显示错误消息“未找到路线”退出。如果找到了路由，我会检查路由器规范中的控制器文件是否存在，并包含它。</p><h1 id="6e34" class="mh lt iq bd mi mj nd ml mm mn ne mp mq jw nf jx ms jz ng ka mu kc nh kd mw mx bi translated">完整的剧本</h1><p id="b006" class="pw-post-body-paragraph kr ks iq kt b ku my jr kw kx mz ju kz la na lc ld le nb lg lh li nc lk ll lm ij bi translated">用一个简单的<em class="lz">“路由器(＄routes)；”</em>路由器现在可以调用了。</p><p id="81a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在URL<em class="lz">" http://www . website . com/user/edit/4 "</em>处，加载了控制器<em class="lz">" ctrl/user-edit . ctrl . PHP "</em>，在关联数组<em class="lz"> "url_params" </em>中，现在有了条目<em class="lz"> "user_id" </em> = &gt; 4，include可以访问该条目。</p><p id="c7a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lz">“用户标识”</em>的值来自模式“/^user\/edit\/(？P\d+)$/。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0b62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我的例子中，我已经展示了基本思想。使用这种方法，您可以创建一个非常灵活的路由器。可以通过各种信息扩展路由阵列，并且可以自由配置从url获得的信息的完整处理。</p><p id="4324" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我已经用这个系统实现了几个项目，我对性能非常满意。你觉得剧本和方法怎么样？我期待你的反馈！</p></div></div>    
</body>
</html>