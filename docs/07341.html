<html>
<head>
<title>RxPy Explained: Map, Filter, and Scan</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxPy解释道:映射、过滤和扫描</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxpy-explained-map-filter-and-scan-4119d9cdece4?source=collection_archive---------6-----------------------#2021-02-10">https://levelup.gitconnected.com/rxpy-explained-map-filter-and-scan-4119d9cdece4?source=collection_archive---------6-----------------------#2021-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1fec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何掌握ReactiveX的三剑客</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0cf7c748b349ed2133c6ccb30e90a0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QV0BcPdbmGlY5xx0Uon8FQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">锡德·巴拉钱德朗在<a class="ae lb" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e2ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每项技术、范式或框架都依赖于一些基础。ReactiveX也不例外。无论你是初学者还是精通者，你都将依赖于三个基本操作:贴图、过滤和扫描。这是ReactiveX的三个火枪手。独立地说，它们是创建完整应用程序的基本块。结合在一起，它们可以让您实现您可能需要的几乎任何转换。</p><p id="c631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您是ReactiveX的新手，我建议您先阅读我的<a class="ae lb" href="https://medium.com/swlh/an-introduction-to-reactive-programming-in-python-a9985e4c43b9" rel="noopener">介绍文章</a>，然后再继续。</p><h1 id="ca3a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">地图</h1><p id="10b0" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">先说最基本的操作，也是可能用的最多的一个:<em class="mf">贴图</em>。map操作符对每个源项应用一个转换函数，并发出这个转换的结果。下面是地图操作符的大理石图:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/7d2788bce599c48c7baef7118bf0c122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*ok5iJ0qCLQiD5mZb.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</figcaption></figure><p id="b3eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，源可观测发射四个项目:1、2、3和4。转换包括将每一项乘以2。因此，操作员也发出四个项目:2、4、6和8。</p><p id="c4b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们考虑这样一种情况，输入项是字符串，我们希望将它们大写。RxPy中的实现如下:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="b441" class="mm ld iq mi b gy mn mo l mp mq">import rx<br/>import rx.operators as ops<br/><br/>source = [<br/>    "each night",<br/>    "the seed grows up",<br/>    "in the store galaxy",<br/>]<br/><br/>rx.from_(source).pipe(<br/>    ops.map(lambda i: i.capitalize())<br/>).subscribe(<br/>    on_next=print,<br/>    on_error=print,<br/>    on_completed=lambda: print("Done!")<br/>)</span></pre><p id="6315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过运行此示例，我们得到了以下结果:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="81db" class="mm ld iq mi b gy mn mo l mp mq">Each night<br/>The seed grows up<br/>In the store galaxy<br/>Done!</span></pre><p id="8f53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这三个字符串的第一个单词是大写的。我们还可以将几个地图操作链接起来。这通常比使用一张做很多事情的地图要好:这可以提高程序的可读性。例如，我们可以用减号替换空格作为另一个步骤:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="330d" class="mm ld iq mi b gy mn mo l mp mq">rx.from_(source).pipe(<br/>    ops.map(lambda i: i.capitalize()),<br/>    ops.map(lambda i: i.replace(" ", "-")),<br/>)</span></pre><h1 id="b17b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">过滤器</h1><p id="649e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">第二个基本操作符是<em class="mf">过滤器</em>。该运算符允许从可观察对象中删除项目:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/216db844b1524b9dbf0f315ca7f80a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*m0B8f2Iz9v7nQpLQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</figcaption></figure><p id="20b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个大理石图中，只有值大于2的项目才会被转发。其他人都放弃了。</p><p id="1c9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将这个操作符应用于字符串数据。我们可以这样删除包含“galaxy”一词的行:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="44c4" class="mm ld iq mi b gy mn mo l mp mq">import rx<br/>import rx.operators as ops<br/><br/>source = [<br/>    "each night",<br/>    "the seed grows up",<br/>    "in the store galaxy",<br/>]<br/><br/>rx.from_(source).pipe(<br/>    ops.filter(lambda i: "galaxy" not in i.lower())<br/>).subscribe(<br/>    on_next=print,<br/>    on_error=print,<br/>    on_completed=lambda: print("Done!")<br/>)</span></pre><p id="d8f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将产生以下结果:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="c24e" class="mm ld iq mi b gy mn mo l mp mq">each night<br/>the seed grows up<br/>Done!</span></pre><h1 id="1ea7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">扫描</h1><p id="8673" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们使用的前两个操作符是无状态的。这意味着他们的产出只取决于他们的投入。在函数式编程中，它们被命名为<em class="mf">纯函数</em>。但是有时我们需要的操作也依赖于先前收到的值。这通常是计算总和或平均值的情况。这些是<em class="mf">有状态</em>操作。<em class="mf">扫描</em>操作符可用于实现此类转换:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/fb5b9862bd9f0241b2fd483c40267a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*QSDhm1oljXMTnyz0.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</figcaption></figure><p id="1f5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个大理石图代表了一个总和的实现。</p><ul class=""><li id="b8de" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">扫描运算符将函数作为参数。</li><li id="dbdd" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">这个函数有两个输入参数:一个累加器和要处理的项。</li><li id="8fbc" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">这个函数的结果是一个更新的累加器。</li><li id="ec27" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">当处理几个项目时，作为输入参数提供的累加器是它在前面的调用中返回的值。</li></ul><p id="967b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在这个例子中，考虑到累加器初始化为0，发生以下步骤:</p><ul class=""><li id="712f" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">发出1:acc = 0，i=1，返回的ACC为0+1=1</li><li id="c30e" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">发出2:acc = 1，i=2，返回的ACC是1+2=3</li><li id="3746" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">发出3:acc = 3，i=3，返回的ACC是3+3=6</li><li id="bc4c" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">发出4:acc = 6，i=4，返回的ACC是6+4=10</li></ul><p id="c8eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们考虑我们的源数据是分段接收的，用换行符分隔:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="be03" class="mm ld iq mi b gy mn mo l mp mq">source = [<br/>    "each ni",<br/>    "ght\n",<br/>    "the seed grow",<br/>    "s up\n",<br/>    "in the store galaxy\n",<br/>]​</span></pre><p id="2486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们希望重建每个字符串并删除换行符。这可以通过<em class="mf">扫描</em>操作器来实现。考虑以下函数:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="603f" class="mm ld iq mi b gy mn mo l mp mq">def unframe(acc, i):<br/>    lines = i.split('\n')<br/>    lines[0] = acc[1] + lines[0]<br/>    return (<br/>        lines[0:-1],<br/>        lines[-1] or '',<br/>    )</span></pre><p id="8414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它使用一个由两个元素组成的元组。第一个是完整字符串的列表，第二个是剩余的不完整字符串。我们可以通过扫描运算符使用此函数来处理数据:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="c4dd" class="mm ld iq mi b gy mn mo l mp mq">rx.from_(source).pipe(<br/>    ops.scan(unframe, seed=([],'')),<br/>)</span></pre><p id="27e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们不能直接使用它，因为它发出完整的累加器而不是字符串。如果没有完整的字符串，它还会发出所有中间累加器值:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="0deb" class="mm ld iq mi b gy mn mo l mp mq">([], 'each ni')<br/>(['each night'], '')<br/>([], 'the seed grow')<br/>(['the seed grows up'], '')<br/>(['in the store galaxy'], '')<br/>Done!</span></pre><p id="2116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是否意味着扫描操作符只对琐碎的用例有用？肯定不是！现在，我们必须将几个运算符组合在一起。</p><p id="bc87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑上面的结果。为了只发出完整的字符串，我们必须:</p><ul class=""><li id="8d28" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">取累加器元组的第一个元素</li><li id="79e6" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">删除列表中为空的值</li><li id="93a8" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">取列表的第一个条目</li></ul><p id="2381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经猜到这些是<em class="mf">贴图</em>、<em class="mf">滤镜</em>和<em class="mf">贴图</em>变换。最终，对源数据的完整处理是这样的:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="e614" class="mm ld iq mi b gy mn mo l mp mq">rx.from_(source).pipe(<br/>    ops.scan(unframe, seed=([],'')),<br/>    ops.map(lambda i: i[0]),           # take string list<br/>    ops.filter(lambda i: len(i) &gt; 0),   # drop empty lists<br/>    ops.map(lambda i: i[0]),           # take first string<br/>)</span></pre><p id="4cfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个程序的完整代码是:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="d802" class="mm ld iq mi b gy mn mo l mp mq">source = [<br/>    "each ni",<br/>    "ght\n",<br/>    "the seed grow",<br/>    "s up\n",<br/>    "in the store galaxy\n",<br/>]​<br/><br/>def unframe(acc, i):<br/>    lines = i.split('\n')<br/>    lines[0] = acc[1] + lines[0]<br/>    return (<br/>        lines[0:-1],<br/>        lines[-1] or '',<br/>    )<br/><br/>rx.from_(source).pipe(<br/>    ops.scan(unframe, seed=([],'')),<br/>    ops.map(lambda i: i[0]),<br/>    ops.filter(lambda i: len(i) &gt; 0),<br/>    ops.map(lambda i: i[0]),<br/>).subscribe(<br/>    on_next=print,<br/>    on_error=print,<br/>    on_completed=lambda: print("Done!"),<br/>)</span></pre><p id="ac34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它为每个完整的字符串发出一个项目:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="f777" class="mm ld iq mi b gy mn mo l mp mq">each night<br/>the seed grows up<br/>in the store galaxy<br/>Done!</span></pre><p id="cfd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用了四个操作符来实现这个特性。如果我们需要做更多的转换，我们的管道将会变得很长，难以阅读，并且没有任何部分可以在其他应用程序中重用。为了解决所有这些问题，我们可以简单地实现一个新的<em class="mf"> unframe </em>操作符:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="87a1" class="mm ld iq mi b gy mn mo l mp mq">def unframe():<br/>    def _unframe(acc, i):<br/>        """unframes a string buffer<br/><br/>        acc is a tuple of two elements:<br/>        - first element is an array of complete lines<br/>        - second element is the current content of incomplete line<br/>        """<br/>        lines = i.split('\n')<br/>        lines[0] = acc[1] + lines[0]<br/>        return (<br/>            lines[0:-1],<br/>            lines[-1] or '',<br/>        )<br/><br/>    return rx.pipe(<br/>        ops.scan(_unframe, seed=([],'')),<br/>        ops.map(lambda i: i[0]),<br/>        ops.filter(lambda i: len(i) &gt; 0),<br/>        ops.map(lambda i: i[0]),<br/>    )</span></pre><p id="9e71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意子管道是如何构造和返回的。这个新的可观测值可用于应用程序的主管道:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="07ae" class="mm ld iq mi b gy mn mo l mp mq">rx.from_(source).pipe(<br/>    unframe(),<br/>)</span></pre><p id="9b6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样可读性强多了。我们可以在另一个应用程序中重用unframe操作符。另外，我们可以对unframe操作符进行单元测试。</p><p id="a23a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以事情已经很好了。但是如果我们考虑以下输入数据:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="0310" class="mm ld iq mi b gy mn mo l mp mq">source = [<br/>    "each night\nthe seed grows up\nin the store galaxy\n",<br/>]</span></pre><p id="a874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">unframe操作符将只发出一个字符串，第一个。这是因为，在最后一步，我们只取列表的第一个条目。但实际上，我们在接收一个物品时，必须发射几个物品。</p><p id="db77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候让第四个火枪手来帮助我们了！</p><h1 id="c726" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">平面地图</h1><p id="1bb8" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">最后但同样重要的是，<em class="mf">平面图</em>操作符也是经常使用的基本操作符之一。这是非常多才多艺的，并打开了<em class="mf">高阶</em>可观测量的大门。关于高阶可观测量的细节将在另一篇文章中讨论。现在让我们关注它的简单用法:为每个接收到的项目发出几个项目。考虑这个例子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/cb95a8bb49ed4dd749ab80b15bec4333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*DfZef6WGu6VijxYc.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</figcaption></figure><p id="e8fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于接收到的每个输入项目，发出项目的<em class="mf">范围</em>。当<em class="mf"> filter </em>操作符删除输入项时，<em class="mf"> flat_map </em>操作符添加新项。</p><ul class=""><li id="a817" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">flat_map运算符将函数作为参数。</li><li id="1d7e" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">对于接收到的每个输入项，都会调用这个函数。</li><li id="74da" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">它返回一个可观察的</li><li id="2780" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">这个可观察的项目被序列化为<em class="mf"> flat_map </em>操作符的输出项目。</li></ul><p id="7f17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以<em class="mf"> unframe </em>操作符的最终实现是这样的:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="17de" class="mm ld iq mi b gy mn mo l mp mq">return rx.pipe(<br/>        ops.scan(_unframe, seed=([],'')),<br/>        ops.map(lambda i: i[0]),<br/>        ops.filter(lambda i: len(i) &gt; 0),<br/>        ops.flat_map(lambda i: rx.from_(i)),<br/>    )</span></pre><p id="c208" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果是预期的:</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="a2f3" class="mm ld iq mi b gy mn mo l mp mq">each night<br/>the seed grows up<br/>in the store galaxy<br/>Done!</span></pre><h1 id="ae91" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="b457" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">仅使用四个运算符，就可以对数据应用许多转换，并且可以实现新的运算符。显然，这些并不足以实现一个完整的应用程序，但它们是基础。事实上，许多RxPy操作符是由这些操作符组合而成的。</p><p id="c6a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组成是ReactiveX的关键。这使得ReactiveX可以无限制地扩展。由于大多数应用程序需要特定的转换，这意味着框架永远不会限制实现！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="fd0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">原载于2021年2月10日https://blog.oakbits.com</em><a class="ae lb" href="https://blog.oakbits.com/rxpy-explained-map-filter-scan.html" rel="noopener ugc nofollow" target="_blank"><em class="mf"/></a><em class="mf">。</em></p></div></div>    
</body>
</html>