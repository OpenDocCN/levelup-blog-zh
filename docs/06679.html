<html>
<head>
<title>Kubernetes Authentication &amp; Authorization 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes认证和授权101</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-authentication-authorization-101-stefanie-lai-15080f64bcee?source=collection_archive---------4-----------------------#2020-12-19">https://levelup.gitconnected.com/kubernetes-authentication-authorization-101-stefanie-lai-15080f64bcee?source=collection_archive---------4-----------------------#2020-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何登录Kubernetes集群？如何向您的应用授予权限？</h2></div><p id="5d2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想用用户模块构建一个系统，认证和授权是我们永远不能忽视的，尽管它们可能很难理解。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/617b90034b8fe44858dcdb2a0fc6b954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wz2nQcGk8a-OnPVbSlgyAA.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Kubernetes验证和授权，按作者</figcaption></figure><blockquote class="lu lv lw"><p id="ee23" class="ki kj lx kk b kl km ju kn ko kp jx kq ly ks kt ku lz kw kx ky ma la lb lc ld im bi translated"><strong class="kk iu">认证</strong>(来自<a class="ae mb" href="https://en.wikipedia.org/wiki/Greek_language" rel="noopener ugc nofollow" target="_blank">希腊文</a>:αὐθεντικός<em class="it">authenti KOS</em>，<em class="it"> authentes </em>，【作者】)是<a class="ae mb" href="https://en.wikipedia.org/wiki/Proof_(truth)" rel="noopener ugc nofollow" target="_blank">证明</a>一个<a class="ae mb" href="https://en.wikipedia.org/wiki/Logical_assertion" rel="noopener ugc nofollow" target="_blank">断言</a>的行为，如计算机系统用户的<a class="ae mb" href="https://en.wikipedia.org/wiki/Digital_identity" rel="noopener ugc nofollow" target="_blank">身份</a>—来自<a class="ae mb" href="https://en.wikipedia.org/wiki/Authentication" rel="noopener ugc nofollow" target="_blank">维基</a></p><p id="8465" class="ki kj lx kk b kl km ju kn ko kp jx kq ly ks kt ku lz kw kx ky ma la lb lc ld im bi translated"><strong class="kk iu">授权</strong>是指定对资源的访问权限/特权的功能，与一般的<a class="ae mb" href="https://en.wikipedia.org/wiki/Information_security" rel="noopener ugc nofollow" target="_blank">信息安全</a>和<a class="ae mb" href="https://en.wikipedia.org/wiki/Computer_security" rel="noopener ugc nofollow" target="_blank">计算机安全</a>有关，尤其与<a class="ae mb" href="https://en.wikipedia.org/wiki/Access_control" rel="noopener ugc nofollow" target="_blank">访问控制</a>有关。—来自<a class="ae mb" href="https://en.wikipedia.org/wiki/Authorization" rel="noopener ugc nofollow" target="_blank">维基</a></p></blockquote><p id="cc4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以简单地归纳为两点。</p><ul class=""><li id="8ac0" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">你是谁？认证使用户能够正确登录系统。</li><li id="5eb3" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">你能做什么？授权授予用户适当的权限。</li></ul><p id="f0d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将解密Kubernetes的认证和授权，希望你不再被下面的问题所迷惑。</p><ul class=""><li id="395b" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">Kubernetes上有哪些用户？</li><li id="ca88" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">如何验证用户身份？</li><li id="348e" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">什么是RBAC？</li><li id="4ecd" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">如何为用户设置RBAC？</li></ul><h1 id="cb2e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Kubernetes的用户</h1><p id="23c0" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">作为Kubernetes的网关，APIServer是用户访问和管理资源对象的入口。每个访问请求都需要一个访问者合法性检查，包括身份验证和资源操作权限等。，然后在通过一系列验证后返回访问结果。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nn"><img src="../Images/40ffc65ad997f28bd3f6975b26157da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3CM8_GjpJacHaCZZVpwP-w.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">用户验证，按作者</figcaption></figure><p id="263d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户可以通过kubectl命令、SDK或者发送REST请求来访问API。用户和服务帐户是访问API的两种不同方式。</p><h2 id="dd82" class="no mr it bd ms np nq dn mw nr ns dp na kr nt nu nc kv nv nw ne kz nx ny ng nz bi translated"><strong class="ak">普通用户</strong></h2><p id="f6aa" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">Kubernetes中没有内置的用户资源类型是用户不能像其他资源那样存储在<code class="fe oa ob oc od b">etcd,</code>中的。因此，Kubernetes通过客户端证书或其他第三方用户管理系统(如Google Account)来完成对普通用户的认证。</p><p id="7ca3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的关键是找到一种安全的方法来帮助普通用户使用kubectl或rest API访问Kubernetes资源。</p><p id="acf6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几种方法可以验证普通用户的身份:</p><ul class=""><li id="26e3" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">客户端X509客户端证书</li><li id="16c6" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">HTTP请求</li><li id="08b3" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">不记名令牌</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oe"><img src="../Images/2bd1f8bbad22304ae2e9e02b5de03211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWJgD2A6sUefJGcyQuhYcw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">三种方式，作者</figcaption></figure><p id="3f14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> X509客户端证书</strong></p><p id="9401" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<a class="ae mb" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a>设置客户端证书:</p><pre class="lf lg lh li gt of od og oh aw oi bi"><span id="9a75" class="no mr it od b gy oj ok l ol om">$ (umask 077;openssl genrsa -out testuser.key 2048)<br/>Generating RSA private key, 2048 bit long modulus<br/>………….+++<br/>…+++<br/>e is 65537 (0x10001)</span><span id="329e" class="no mr it od b gy on ok l ol om"># generate key O:cluster name CN: username<br/>$ openssl req -new -key testuser.key -out testuser.csr -subj “/0=testcluster/CN=testuser”</span><span id="f2c2" class="no mr it od b gy on ok l ol om"># sign the cert<br/>openssl x509 -req -in testuser.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out testuser.crt -days 365</span></pre><p id="77c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成私钥后，我们现在需要在<code class="fe oa ob oc od b">kubeconfig</code>中设置密钥。</p><blockquote class="lu lv lw"><p id="bd7f" class="ki kj lx kk b kl km ju kn ko kp jx kq ly ks kt ku lz kw kx ky ma la lb lc ld im bi translated">PS:在这里，我使用OpenSSL来生成凭证。也可以使用<a class="ae mb" href="https://github.com/cloudflare/cfssl" rel="noopener ugc nofollow" target="_blank"> cfssl </a>。<a class="ae mb" href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/" rel="noopener ugc nofollow" target="_blank">官方文件在此</a>。</p></blockquote><p id="c400" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">什么是kubeconfig？</strong></p><p id="d755" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">kubectl命令支持上述所有身份验证方法。它使用一个<code class="fe oa ob oc od b">kubeconfig</code>配置文件，该文件通常(默认)存储在<code class="fe oa ob oc od b">~/.kube/config,</code>中，用于保存与APIServer的通信方法和认证所需的数据。</p><p id="f70e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该文件主要包含以下内容。</p><ul class=""><li id="75e1" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated"><strong class="kk iu">集群</strong>。集群列表，包括访问API服务器的URL及其所属集群的名称。</li><li id="a995" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">用户</strong>。用户列表，包括访问API服务器时的用户名和验证信息。</li><li id="9ce8" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">语境</strong>。Kubelet的可用上下文列表由用户列表中的特定用户名和集群列表中的特定集群名组成。</li><li id="c380" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><strong class="kk iu">Current-context</strong>:kube let当前使用的上下文名称是上下文列表中的一个特定项。</li></ul><p id="6fe1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，将创建的客户端证书添加到<code class="fe oa ob oc od b">kubeconfig</code>。</p><pre class="lf lg lh li gt of od og oh aw oi bi"><span id="2222" class="no mr it od b gy oj ok l ol om"># set kube config<br/>$ kubectl config set-cluster testcluster — kubeconfig=testuser — certificate-authority=ca.crt — embed-certs=true</span><span id="03e3" class="no mr it od b gy on ok l ol om"># view cluster config<br/>$ kubectl config view — kubeconfig=testuser</span></pre><p id="6132" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oa ob oc od b">kubectl config set-cluster</code>命令在这里非常重要，我们也将在其他解决方案中使用它。这是<a class="ae mb" href="https://jamesdefabia.github.io/docs/user-guide/kubectl/kubectl_config_set-cluster/" rel="noopener ugc nofollow" target="_blank">文件</a></p><p id="6ead" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是设置客户端凭据。</p><pre class="lf lg lh li gt of od og oh aw oi bi"><span id="8c12" class="no mr it od b gy oj ok l ol om">$ kubectl config set-credentials testuser — client-certificate=testuser.crt — client-key=testuser.key — embed-certs=true — kubeconfig=testuser</span></pre><p id="6282" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oa ob oc od b">kubeconfig</code>的输出是这样的</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0944" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一步是使用上下文。</p><pre class="lf lg lh li gt of od og oh aw oi bi"><span id="a78f" class="no mr it od b gy oj ok l ol om">$ kubectl config use-context testuser@testcluster — kubeconfig=testuser</span></pre><p id="6af2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">直到现在，你仍然不能得到任何东西，因为授权还没有完成。在下一节中，我将向您展示如何向用户授予权限。</p><p id="930c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">不记名令牌</strong></p><p id="c010" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">承载令牌是一种静态令牌验证方法，要启用它，需要用<code class="fe oa ob oc od b">token-auth-file=authfile</code>启动APIServer</p><p id="75be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oa ob oc od b">authfile</code>格式就像，<code class="fe oa ob oc od b">password,user,uid,"group1,group2".</code>每行代表一个用户。</p><p id="f2c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两种方式使用不记名令牌。</p><ul class=""><li id="a5b3" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">使用HTTP头集</li></ul><pre class="lf lg lh li gt of od og oh aw oi bi"><span id="d2a3" class="no mr it od b gy oj ok l ol om">curl -X "POST" "https://{kubernetes API IP}:{kubernetes API Port}/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token" \<br/>-H 'Authorization: Bearer {bearer token}' \<br/>-H 'Content-Type: application/json; charset=utf-8' -d $'{}'</span></pre><ul class=""><li id="9512" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">使用<code class="fe oa ob oc od b">kubeconfig</code></li></ul><pre class="lf lg lh li gt of od og oh aw oi bi"><span id="de13" class="no mr it od b gy oj ok l ol om"># set your token in the kubeconfig<br/><strong class="od iu">$ kubectl config set-credentials NAME [-client-certificate=path/to/certfile] [-client-key=path/to/keyfile] [-token=bearer_token] [-username=basic_user] [-password=basic_password]</strong></span><span id="e317" class="no mr it od b gy on ok l ol om"># use the context<br/>$ kubectl config use-context NAME</span></pre><p id="cb9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有关不记名令牌的更多信息，请查看此处的。</p><p id="faef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> HTTP登录</strong></p><p id="7295" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上就是一个用户名和密码的登录方式。要启用它，您需要用<code class="fe oa ob oc od b">basic-auth-file=authfile.</code>启动APIServer</p><p id="3d74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的<code class="fe oa ob oc od b">authfile</code>和不记名令牌的一样。使用它需要HTTP客户端在头中添加<code class="fe oa ob oc od b">Authorization: Basic BASE64ENCODED(USER:PASSWORD)</code>来执行HTTP基本身份认证。<code class="fe oa ob oc od b">BASE64ENCODED(USER:PASSWORD) is USER:PASSWORD</code> base64值。收到后，APIServer会根据<code class="fe oa ob oc od b">authfile</code>判断用户名和密码是否正确。</p><p id="367e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于HTTP登录方法在1.16中被放弃，在<a class="ae mb" href="https://v1-19.docs.kubernetes.io/docs/setup/release/notes/" rel="noopener ugc nofollow" target="_blank"> 1.19 </a>中被移除，所以我在这里不展开。</p><p id="25f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，建议使用客户端证书作为管理员登录方法，其他用户通常通过云提供商身份验证方法登录以访问集群。</p><p id="29ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这到底是怎么发生的？</p><p id="97f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">验证码在kubectl中。</p><ul class=""><li id="f83f" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">第一步是找到auth params并构建一个env exec。</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oo op l"/></div></figure><ul class=""><li id="111c" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">然后kubectl使用<a class="ae mb" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go </a> API针对集群验证所有的令牌/密钥，并确保用户拥有权限。</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="24b2" class="no mr it bd ms np nq dn mw nr ns dp na kr nt nu nc kv nv nw ne kz nx ny ng nz bi translated">服务帐户</h2><p id="d960" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">服务账户是Kubernetes管理的资源之一，不同于普通用户。它可以通过API创建，包含一组秘密，存储在<code class="fe oa ob oc od b">etcd</code>中，通常分配给一个名称空间。</p><ul class=""><li id="c48c" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">服务帐户由Kubernetes API管理。</li><li id="a8ee" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">服务帐户适用于在群集内运行的应用程序(pod)。</li><li id="f964" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">服务帐户通过承载令牌身份验证访问API。通过YAML很容易建立一个服务帐户。</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">服务帐户YAML</figcaption></figure><h1 id="8ee2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">批准</h1><p id="26c6" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">授权定义了您在登录后可以做什么。</p><p id="9293" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在传统的web系统中，用户管理有三大部分，<strong class="kk iu">用户，角色，权限，</strong>存储在关系数据库中的<strong class="kk iu"> </strong>，它们之间存在多对多的映射。</p><p id="4af3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Kubernetes也是一样的，只是术语不同。现在人们在云世界中使用<code class="fe oa ob oc od b">ServiceAccount</code>、<code class="fe oa ob oc od b">Role</code>、<code class="fe oa ob oc od b">Rolebinding</code>，这些都存储在<code class="fe oa ob oc od b">etcd</code>中。所以我相信可以肯定地说，Kubernetes的授权并不难理解。</p><p id="2ae7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但如果你认为Kubernetes是“<a class="ae mb" href="https://en.wikipedia.org/wiki/Flogging_a_dead_horse#:~:text=Flogging%20a%20dead%20horse%20(alternatively,to%20do%20any%20useful%20work." rel="noopener ugc nofollow" target="_blank">打死马</a>”，那你就错了。<strong class="kk iu">RBAC(Role-Based Access Control)</strong>是Kubernetes的授权机制，从它的名字就可以看出从面向用户到面向角色的转换。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oq"><img src="../Images/8ee96064c022f62927fac8279cc0f9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6qwMn-4W3Fry2VJBnBu4g.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">来自CNCF的RBAC</figcaption></figure><p id="9cd0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Kubernetes架构中，最大的优势之一就是<strong class="kk iu">不同资源的解耦</strong>。每种资源类型都是独立的，它们只通过APIServer进行通信。所以针对不同资源的<a class="ae mb" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#api-overview" rel="noopener ugc nofollow" target="_blank"> API对象</a>比如<code class="fe oa ob oc od b">/pod/create, /service/create</code>已经成为了新的权限类型，这是真正的资产。</p><p id="6425" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后是开发人员的工作，组织所有的API，将它们分配给不同的角色，最后使用<code class="fe oa ob oc od b">RoleBinding</code>将所有这些角色授予<code class="fe oa ob oc od b"> ServiceAccount(user)</code>。</p><p id="2046" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人们认为Kubernetes的插件资源设计带来了显著的优势。</p><ul class=""><li id="922e" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">它为整个Kubernetes生态系统带来了灵活性，能够在不损害其原始授权机制的情况下添加新资源。</li><li id="8b70" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">它<strong class="kk iu">解耦了</strong>权限和用户之间的碎片化关系，<strong class="kk iu">集中</strong>创建一个角色人物。</li></ul><p id="de7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面我们继续介绍RBAC。</p><h2 id="ec08" class="no mr it bd ms np nq dn mw nr ns dp na kr nt nu nc kv nv nw ne kz nx ny ng nz bi translated">RBAC</h2><p id="2a69" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">RBAC属于<code class="fe oa ob oc od b">rbac.authorization.k8s.io</code> API组，该组在<a class="ae mb" href="https://coreos.com/blog/kubernetes-1-6.html" rel="noopener ugc nofollow" target="_blank"> 1.6 </a>成为beta，在1.8 成为<a class="ae mb" href="https://kubernetes.io/blog/2017/09/kubernetes-18-security-workloads-and/#spotlight-on-security" rel="noopener ugc nofollow" target="_blank"> GA，并在当时为Kubernetes带来了巨大的安全改进。</a></p><p id="dfb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您需要在APIServer配置中设置<code class="fe oa ob oc od b">-authorization-mode=Node,RBAC</code>来启用动态RBAC功能。</p><p id="8575" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kubernetes使用名称空间来增加资源所有权的分离，集群范围的资源除外。所以RBAC也分成两个范围，<strong class="kk iu">集群范围的</strong>和<strong class="kk iu">名称空间范围的</strong>。此外，Kubernetes中不支持名称空间的非资源只能在集群范围内设置，比如<code class="fe oa ob oc od b">/heathz</code>。</p><p id="5605" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oa ob oc od b">ClusterRole</code>和<code class="fe oa ob oc od b">ClusterRolebinding</code>用于集群级资源。另一方面，<code class="fe oa ob oc od b">Role</code>和<code class="fe oa ob oc od b">Rolebinding</code>对应于名称空间中的资源。</p><p id="eb8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oa ob oc od b">Rolebinding/ClusterRoleBinding</code>有四种主要成分</p><ul class=""><li id="6e63" class="mc md it kk b kl km ko kp kr me kv mf kz mg ld mh mi mj mk bi translated">API资源</li><li id="0357" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">API组</li><li id="67df" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">学科</li><li id="094b" class="mc md it kk b kl ml ko mm kr mn kv mo kz mp ld mh mi mj mk bi translated">动词</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi or"><img src="../Images/054e46d32a10c03ead63b01017dfa000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSSyEweznqTvNFIrOY-PYg.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">角色绑定成分</figcaption></figure><p id="9926" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kubernetes将粒度API资源放在一起，组成各种API组。比如<code class="fe oa ob oc od b">Deployment</code>属于<code class="fe oa ob oc od b">apps</code>，而<code class="fe oa ob oc od b">Cronjob</code>属于<code class="fe oa ob oc od b">batch</code>组。</p><p id="597a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过运行以下命令在其YAML中找到信息:</p><pre class="lf lg lh li gt of od og oh aw oi bi"><span id="4e07" class="no mr it od b gy oj ok l ol om">kubectl create namespace test --dry-run -o yaml | cat</span></pre><p id="260f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="9ece" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们试着为<code class="fe oa ob oc od b">Pod</code>配置一个<code class="fe oa ob oc od b">Role</code>，为事件配置一个<code class="fe oa ob oc od b">ClusterRole</code>，两者都只有一些读权限。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a068" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很容易理解<code class="fe oa ob oc od b">Role</code>和<code class="fe oa ob oc od b">ClusterRole</code>都需要三大要素来构建一个<code class="fe oa ob oc od b"><strong class="kk iu">rule</strong></code>、<code class="fe oa ob oc od b">ApiGroup</code>、<code class="fe oa ob oc od b">resources,</code>和<code class="fe oa ob oc od b">verbs</code>。这里我们只补充<code class="fe oa ob oc od b">Pod</code>作为例子。如果你想让不同的类型拥有相同的权限，你可以在同一个<code class="fe oa ob oc od b">rule</code>中添加不同的类型。当然，你可以把它们分成不同的规则。</p><p id="302c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在图中提到的多种类型的用户中，我推荐使用ServiceAccount方法，因此本文主要关注这种方法。然而，为了完整起见，本文简要描述了替代方法。</p><p id="e714" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们定义一个<code class="fe oa ob oc od b">RoleBinding</code>来组合<code class="fe oa ob oc od b">ServiceAccount</code>和<code class="fe oa ob oc od b">Role</code>，对于<code class="fe oa ob oc od b">ClusterRole</code>，就是<code class="fe oa ob oc od b">ClusterRoleBinding</code>。这就决定了一个<code class="fe oa ob oc od b">ServiceAccount(user)</code>能做什么。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="ddeb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该示例将<code class="fe oa ob oc od b">test</code>名称空间中的<code class="fe oa ob oc od b">ServiceAccount</code>名称<code class="fe oa ob oc od b">default</code>和<code class="fe oa ob oc od b">testuser</code>(我们在用户部分使用客户端证书定义)绑定到<code class="fe oa ob oc od b">Role</code>和<code class="fe oa ob oc od b">ClusterRole</code>，因此<code class="fe oa ob oc od b">ServiceAccount</code>可以读取<code class="fe oa ob oc od b">test</code>名称空间中的pod信息和整个集群的事件。</p><h2 id="710f" class="no mr it bd ms np nq dn mw nr ns dp na kr nt nu nc kv nv nw ne kz nx ny ng nz bi translated"><strong class="ak">聚合集群角色</strong></h2><p id="f65c" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">v1.9中为<strong class="kk iu">聚合集群角色</strong>引入了一个新函数(v1.11中的GA)。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi os"><img src="../Images/0f219a8da7521a78f424da4e478c9332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5CMgjJ-et4SBtzJkMPJAA.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">来自CNCF<a class="ae mb" href="https://www.cncf.io/blog/2020/08/28/kubernetes-rbac-101-authorization/" rel="noopener ugc nofollow" target="_blank">的AggregatedClusterRole】</a></figcaption></figure><p id="364c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">配置如下。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="b73a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这基本上是一个简化的配置，允许用户将相似的<code class="fe oa ob oc od b">ClusterRoles</code>组合在一起，然后通过一个<code class="fe oa ob oc od b">Aggregated ClusterRole</code>将它们与其他<code class="fe oa ob oc od b">ServiceAccount</code>匹配。这真是一个“很好拥有”的功能！</p><h2 id="8dd8" class="no mr it bd ms np nq dn mw nr ns dp na kr nt nu nc kv nv nw ne kz nx ny ng nz bi translated">嵌入集群角色</h2><p id="a99f" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">Kubernetes已经有很多内置的<code class="fe oa ob oc od b">ClusterRoles</code>，你可以在你的<code class="fe oa ob oc od b">kube-system</code>名称空间中检查<code class="fe oa ob oc od b">ClusterRole</code>。</p><pre class="lf lg lh li gt of od og oh aw oi bi"><span id="377b" class="no mr it od b gy oj ok l ol om">kubectl get clusterroles -namespace=kube-system</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ot"><img src="../Images/caf479affcdfd1a71c12c89a9265ac4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bob1K26xLuxjehAG"/></div></div></figure><p id="ba6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何以<code class="fe oa ob oc od b">system:</code>开头的都是内置的<code class="fe oa ob oc od b">ClusterRole</code>。</p><h2 id="e41e" class="no mr it bd ms np nq dn mw nr ns dp na kr nt nu nc kv nv nw ne kz nx ny ng nz bi translated">Webhook</h2><p id="cb75" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">还有一个特殊的用例。如果你使用CRD，你可以定义一个<a class="ae mb" href="https://kubernetes.io/docs/reference/access-authn-authz/webhook/" rel="noopener ugc nofollow" target="_blank">授权webhook扩展</a>来验证它的权限。通过添加<code class="fe oa ob oc od b">--authorization-webhook-config-file=auth.yaml</code>标志，添加类似<code class="fe oa ob oc od b">auth.yaml</code>的<code class="fe oa ob oc od b">kubeconfig</code>格式。</p><p id="eb4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如需更多信息，请参考<a class="ae mb" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> Kubernetes RBAC官方文档</a>。</p><h1 id="ffd2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">概括起来</h1><p id="cc6d" class="pw-post-body-paragraph ki kj it kk b kl ni ju kn ko nj jx kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">Kubernetes的认证和授权可能比我们想象的要复杂，尤其是涉及到普通用户的登录和授权。但是<code class="fe oa ob oc od b">ServiceAccount</code>是一个优秀的设计，它允许我们灵活安全地管理<code class="fe oa ob oc od b">Pod’s</code>运行程序的权限。</p><p id="20ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像<code class="fe oa ob oc od b">Pod</code>、<code class="fe oa ob oc od b">Deployment</code>、<code class="fe oa ob oc od b">ConfigMap</code>这样的资源，永远是Kubernetes的核心资产，一切都围绕着它们运转。学习RBAC时，我们更好地理解了各种资源操作和APIServer设计。</p><p id="50d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于应用程序开发人员来说，了解如何使用RBAC至关重要，尤其是对于大多数通过各种云提供商(GKE、EKS)使用Kubernetes的用户来说。RBAC和云提供商的IAM管理有相似之处。</p><p id="0ceb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于GCP IAM和RBAC Kubernetes的特点和区别，请参考<a class="ae mb" href="https://medium.com/@laiyuanyuan-sg/gcp-iam-authentication-authorization-stefanie-lai-101-275f3c1fdfc5" rel="noopener"> GCP IAM认证&amp;授权101 </a>。</p><p id="5f7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读！</p></div></div>    
</body>
</html>