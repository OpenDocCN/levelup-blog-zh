<html>
<head>
<title>What’s new in Java 15</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 15的新特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/every-feature-java-15-came-with-b94116373ee1?source=collection_archive---------10-----------------------#2020-10-15">https://levelup.gitconnected.com/every-feature-java-15-came-with-b94116373ee1?source=collection_archive---------10-----------------------#2020-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="236b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><div class=""><h2 id="59f0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">JEP的Java 15将帮助开发者</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f70adba6e445b356518e16948a9e3262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZBhLE93SKOWtMGkMii1hw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">凯尔西·柯蒂斯在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4233" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">介绍</h1><p id="2b0b" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">正式发布的Java 15带来了一组非常好的14个特性。在这14个特性中，很少是添加的，也很少是从当前的java生态系统中删除/禁用的。下面是添加的功能列表</p><ul class=""><li id="55f1" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">爱德华兹曲线数字签名算法</li><li id="2930" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">密封类(预览)</li><li id="f10a" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">隐藏类</li><li id="87e2" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">移除Nashorn JavaScript引擎</li><li id="b965" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">重新实现旧的DatagramSocket API</li><li id="3528" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">禁用和反对有偏向的锁定</li><li id="272b" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">实例的模式匹配(第二次预览)</li><li id="9444" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">ZGC:一种可扩展的低延迟垃圾收集器</li><li id="5641" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">文本块</li><li id="cb89" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">Shenandoah:一个低暂停时间的垃圾收集器</li><li id="d841" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">删除Solaris和SPARC端口</li><li id="7837" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">外部存储器访问API(第二孵化器)</li><li id="ec68" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">记录(第二次预览)</li><li id="7395" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">不赞成为删除而激活RMI</li></ul><p id="bd3e" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">在这篇博客中，我们将通过一些代码片段来简单介绍一下这些新特性是什么，以及如何使用它们。</p><h1 id="e977" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">爱德华兹曲线数字签名算法</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/86f1f3d52b63ef964a33673b46f058ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OaLVmTPWttCktfRt"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="a2bd" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">Java 15包含这个特性的原因之一是</p><ul class=""><li id="d0ed" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">与类似的签名ECDSA相比，由于其安全性和性能，它是一种流行的签名算法</li><li id="2c7b" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">缓存流行的加密库，如OpenSSL和BoringSSL，它们已经支持EdDSA。</li><li id="65e4" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">目前TLS 1.3中允许的唯一签名</li></ul><p id="a9cf" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">代码片段</strong>生成密钥对并对其进行签名</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="79ed" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">代码片段</strong>用于构造公钥的代码片段</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e59c" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">更多阅读材料:<a class="ae lh" href="https://openjdk.java.net/jeps/339" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/339</a></p><h1 id="0a7f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">密封类(预览)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ns"><img src="../Images/5d276ad74b2a1ffbbabec8059bdbbac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kgZbsP982BygkDAe"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@natasyachen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Natasya Chen </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1115" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">密封类的主要目标是为Java创建一种支持<a class="ae lh" href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="noopener ugc nofollow" target="_blank"> <em class="nt">代数数据类型</em> </a>的方式。</p><p id="a651" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">当我们看Java类层次结构时，它允许通过继承来重用代码，但是《密封类》的作者Brian Goetz说，然而，这并不总是为了代码重用，而是为了模拟域中存在的各种可能性。</p><p id="aa5f" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">例如，如果名为<code class="fe nu nv nw nx b">Shape</code>的类的作者可能希望只有特定的类可以扩展该形状，而不是每个类，因此<code class="fe nu nv nw nx b">Shape</code>的作者可以编写代码给<code class="fe nu nv nw nx b">Shape</code>的已知子类，而不需要编写代码来保护<code class="fe nu nv nw nx b">Shape</code>的未知子类</p><p id="994d" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">“一个<code class="fe nu nv nw nx b">sealed class</code>或<code class="fe nu nv nw nx b">interface</code>只能由那些被允许这样做的类和接口来扩展或实现”——<a class="ae lh" href="https://openjdk.java.net/jeps/360" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/360</a></p><p id="7c5a" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">例如:</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="354f" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">在上面的代码片段中，通过将修饰符<code class="fe nu nv nw nx b">sealed</code>应用到声明中，类<code class="fe nu nv nw nx b">Shape</code>被标记为密封类，并且<code class="fe nu nv nw nx b">permits</code>子句指定了允许扩展密封类的类。这里只有<code class="fe nu nv nw nx b">Circle, Rectange and Square</code>可以扩展<code class="fe nu nv nw nx b">Shape</code>类。</p><p id="3443" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">密封级+ JEP 375模式匹配</strong></p><p id="f92e" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">密封一个类的主要目的是让客户端代码推断所有允许的子类。传统上，推理子类的方法是使用if-else链，例如:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e69d" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">使用<code class="fe nu nv nw nx b">permits</code>子句并让编译器知道允许的类可以用<a class="ae lh" href="https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html" rel="noopener ugc nofollow" target="_blank">模式匹配</a>扩展一个密封类，而不是用<code class="fe nu nv nw nx b">if-else</code>检查一个密封类的实例，客户端代码将能够使用<code class="fe nu nv nw nx b">switch</code>而不是使用<a class="ae lh" href="https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html" rel="noopener ugc nofollow" target="_blank"> JEP 375 </a>测试模式。这允许编译器检查模式是否详尽</p><p id="10b3" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">例如:</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="52e2" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">更多阅读材料:<a class="ae lh" href="https://openjdk.java.net/jeps/360" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/360</a></p><h1 id="0304" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">隐藏类</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/b551762cc4855da77a4306114c2ad887.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*omY23yAHa6DllvZ1"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">米哈伊尔·瓦西里耶夫在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2bbd" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">隐藏类是针对JVM的，并不是为了以任何方式改变java语言。隐藏类的意图主要针对在运行时生成类并通过反射使用它们的框架。</p><p id="684e" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">当一个隐藏类不再可达时，它可以被卸载，或者它可以共享一个类装入器的生命周期，这样它只有在类装入器被垃圾收集时才被卸载。</p><p id="b219" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">创建隐藏类的示例代码</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="38bd" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">隐藏类创建方式的重要区别在于它在创建时获得的名称。<strong class="mc jd">隐藏类不是匿名的。</strong>类的名字可以通过<code class="fe nu nv nw nx b">Class::getName</code>获取，这个名字有一个足够不寻常的形式，它有效地使这个类对所有其他类不可见。该名称由以下内容串联而成:</p><ol class=""><li id="0264" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nz ne nf ng bi translated">由<code class="fe nu nv nw nx b">ClassFile</code>结构中的<code class="fe nu nv nw nx b">this_class</code>指定的内部形式的二进制名称(JVMS 4.2.1)，比如说<code class="fe nu nv nw nx b">A/B/C</code>；</li><li id="9e5a" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nz ne nf ng bi translated"><code class="fe nu nv nw nx b">'.'</code>人物；和</li><li id="a105" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nz ne nf ng bi translated">由JVM实现选择的非限定名(JVMS 4.2.2)。</li></ol><p id="ba64" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">例如，它可能看起来像<code class="fe nu nv nw nx b">com.rockey.Test/0x0000000800b94440</code></p><p id="73a6" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">更多阅读材料:<a class="ae lh" href="https://openjdk.java.net/jeps/371" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/371</a></p><h1 id="716d" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">重新实现旧的DatagramSocket API</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/7aba538e06fcf193d95bf4fc0b577035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1lFLkt5z-GMQhq8f"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·温克勒在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="74ba" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这个特性重新实现了<code class="fe nu nv nw nx b">java.net.DatagramSocket</code>和<code class="fe nu nv nw nx b">java.net.MulticastSocket</code>API，因为它们的实现可以追溯到JDK 1.0，该版本混合了Java和C语言，对于作者来说很难维护。作者的想法是这些新的实现将很好地适应虚拟线程(这是作为<a class="ae lh" href="https://openjdk.java.net/projects/loom" rel="noopener ugc nofollow" target="_blank">项目织机</a>探索的)。这些重新实现是默认启用的，通过直接使用选择器提供者的平台默认实现(<code class="fe nu nv nw nx b">sun.nio.ch.SelectorProviderImpl</code>和<code class="fe nu nv nw nx b">sun.nio.ch.DatagramChannelImpl</code>)，为数据报和多播套接字提供不可中断的行为</p><p id="1244" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">更多阅读材料:<a class="ae lh" href="https://openjdk.java.net/jeps/373" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/373</a></p><h1 id="db06" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">实例的模式匹配(第二次预览)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/1b58c5189ca78b792653d3625f695da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_hQjrIOwOWPKGZpw"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@laurisamisa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">劳丽莎·迪肯</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0930" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">有了这个JEP，Java可能会开始采用<em class="nt">模式匹配</em>就像从Haskell到C#的许多语言一样，因为其简洁和安全而采用了模式匹配。模式匹配允许简洁地表达目标的期望“形状”(<em class="nt">模式</em>)</p><p id="81fd" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这是Java编程语言的一个增强，为<code class="fe nu nv nw nx b">instanceof</code>操作符提供了<em class="nt">模式匹配</em>。<a class="ae lh" href="https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html" rel="noopener ugc nofollow" target="_blank">模式匹配</a>允许程序中的公共逻辑，即从对象中有条件地提取组件，更简洁、更安全地表达。</p><p id="d962" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这背后的主要驱动因素几乎每个程序都有一种逻辑，这种逻辑结合了测试表达式是否具有某种类型的结构，然后有条件地提取其状态的组成部分以供进一步处理。</p><p id="3e62" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">示例:铸造习语的实例</strong>(不使用模式)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a3c4" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这里发生了三件事，所以我们可以使用字符串值:</p><ul class=""><li id="7f0e" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">一个测试(<code class="fe nu nv nw nx b">obj</code>是不是一个<code class="fe nu nv nw nx b">String</code>？)</li><li id="3ae4" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">转换(将<code class="fe nu nv nw nx b">obj</code>转换为<code class="fe nu nv nw nx b">String</code>)和</li><li id="ca9f" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">新局部变量的声明(<code class="fe nu nv nw nx b">s</code>)</li></ul><p id="3969" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">它是乏味的；没有必要同时进行类型测试和强制转换。但最重要的是，这种重复为错误悄悄潜入程序提供了机会。为了使用模式简化上面的代码，我们首先需要了解什么是模式“一个<em class="nt">模式</em>是(1)一个可以应用于目标的<em class="nt">谓词</em>和(2)一组<em class="nt">绑定变量</em>的组合，只有谓词成功应用于目标时，才能从目标中提取这些变量。”</p><p id="118d" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">上面的代码现在可以写成</p><p id="981a" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">示例:简化上述代码</strong>(s的范围限于if块)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f998" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">如果<code class="fe nu nv nw nx b">obj</code>是<code class="fe nu nv nw nx b">String</code>的一个实例，那么它被转换为<code class="fe nu nv nw nx b">String</code>，并被赋给绑定变量<code class="fe nu nv nw nx b">s</code>。绑定变量在<code class="fe nu nv nw nx b">if</code>语句的真块范围内，而不在<code class="fe nu nv nw nx b">if</code>语句的假块范围内，但是变量的这个范围依赖于包含表达式和语句的语义。例如，在下面的代码中，将根据条件评估将s的范围扩展到else块</p><p id="31e8" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">示例:(s的范围扩展到else块)</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a53f" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">附加阅读材料:<a class="ae lh" href="https://openjdk.java.net/jeps/375" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/375</a></p><h1 id="f068" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">ZGC:一种可扩展的低延迟垃圾收集器</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/46d5fbe0b541cc58c10d66ef73dcae8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-v0t5RxTJYXtPiTU"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@elevatebeer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">将</a>提升到<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</figcaption></figure><p id="3ece" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这个JEP本质上把Z垃圾收集器从一个实验性的特性变成了一个产品特性。在Java 11 JDK中引入这一JEP后，社区对此给予了积极的反馈，作者增加了许多特性和增强。哪些是</p><ul class=""><li id="404e" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">并发类别卸载</li><li id="d6ca" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">取消提交未使用的内存(<a class="ae lh" href="https://openjdk.java.net/jeps/351" rel="noopener ugc nofollow" target="_blank"> JEP 351 </a>)</li><li id="6360" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">最大堆大小从4TB增加到16TB</li><li id="6ad9" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">最小堆大小减少到8MB</li><li id="c0a0" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">-XX:SoftMaxHeapSize</code></li><li id="925c" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">支持JFR泄漏分析器</li><li id="7218" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">支持类数据共享</li><li id="60c6" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">有限且不连续的地址空间</li><li id="b52f" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">支持将堆放在NVRAM上</li><li id="d6f4" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">提高NUMA意识</li><li id="d9cb" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">多线程堆预接触</li></ul><p id="bc1f" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">此外，现在支持所有常用的平台:</p><ul class=""><li id="f3c9" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated">Linux/x86_64 ( <a class="ae lh" href="https://openjdk.java.net/jeps/333" rel="noopener ugc nofollow" target="_blank"> JEP 333 </a>)</li><li id="31c9" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">Linux/aarch64 ( <a class="ae lh" href="https://bugs.openjdk.java.net/browse/JDK-8214527" rel="noopener ugc nofollow" target="_blank"> 8214527 </a>)</li><li id="6958" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">视窗(<a class="ae lh" href="https://openjdk.java.net/jeps/365" rel="noopener ugc nofollow" target="_blank"> JEP 365 </a>)</li><li id="1a5e" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">macOS ( <a class="ae lh" href="https://openjdk.java.net/jeps/364" rel="noopener ugc nofollow" target="_blank"> JEP 364 </a>)</li></ul><p id="1d41" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">通过设置启用ZGC</p><pre class="ks kt ku kv gt od nx oe of aw og bi"><span id="0213" class="oh lj it nx b gy oi oj l ok ol">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span></pre><h1 id="657e" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">文本块</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/5ffd3b927c7cf13ac446ab609d310970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JI3uTW1-fEB_6CqK"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@gustaverobs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gustave Robinot </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="c796" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这个JEP将允许在Java语言中添加文本块。文本块是多行字符串文字，它避免了转义序列的必要性，并以可预测的方式自动格式化字符串。不仅如此，还向string添加了新的方法来支持文本块</p><ul class=""><li id="b947" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">String::stripIndent()</code>:用于去除文本块内容中附带的空白</li><li id="f651" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">String::translateEscapes()</code>:用于翻译转义序列</li><li id="4878" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">String::formatted(Object... args)</code>:简化文本块中的值替换</li></ul><h1 id="76dd" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">HTML示例</h1><p id="6d60" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><em class="nt">使用“一维”字符串文字</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f3dd" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><em class="nt">使用“二维”文本块</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c471" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">SQL示例</p><p id="78c9" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><em class="nt">使用“一维”字符串文字</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="05a7" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><em class="nt">使用“二维”文本块</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="5f42" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">Shenandoah:一个低暂停时间的垃圾收集器</h1><p id="6b25" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这个JEP从根本上改变了谢南多厄Garabage收藏家从实验功能到产品功能</p><p id="2230" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">启用这个垃圾收集命令使用的是<code class="fe nu nv nw nx b">java -XX:+UseShenandoahGC</code></p><h1 id="acd7" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">删除Solaris和SPARC端口</h1><p id="96ba" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">此JEP删除了对Solaris/SPARC、Solaris/x64和Linux/SPARC端口的源代码和构建支持。放弃对Solaris和SPARC端口支持的主要原因是，OpenJDK社区的贡献者可以加快新特性的开发，推动平台向前发展</p><h1 id="cf15" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">外部存储器访问API(第二孵化器)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/e288f4588b26771d5ed9b6095e172d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YlkxGUmX1FNZ0AdK"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@the_roaming_platypus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> timJ </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2baf" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这个特性将引入一个API，允许Java程序安全有效地访问Java堆之外的外部内存。</p><p id="8020" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">很多Java程序访问外来内存，比如<a class="ae lh" href="https://apacheignite.readme.io/v1.0/docs/off-heap-memory" rel="noopener ugc nofollow" target="_blank"> Ignite </a>、<a class="ae lh" href="http://www.mapdb.org/" rel="noopener ugc nofollow" target="_blank"> mapDB </a>、<a class="ae lh" href="https://github.com/dustin/java-memcached-client" rel="noopener ugc nofollow" target="_blank"> memcached </a>、<a class="ae lh" href="https://lucene.apache.org/" rel="noopener ugc nofollow" target="_blank"> Lucene </a>，Netty的<a class="ae lh" href="https://netty.io/wiki/using-as-a-generic-library.html" rel="noopener ugc nofollow" target="_blank"> ByteBuf </a> API。使用15版之前的Java API访问外部存储器有三种方法，它们是</p><ul class=""><li id="8580" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated"><a class="ae lh" href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/nio/ByteBuffer.html" rel="noopener ugc nofollow" target="_blank">字节缓冲API </a></li><li id="1952" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><a class="ae lh" href="https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java" rel="noopener ugc nofollow" target="_blank">不安全的API </a></li><li id="ac4b" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">使用JNI</li></ul><p id="ef5f" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">但是当访问外部存储器时，有一个两难的问题:如果他们应该选择一个安全但有限(可能效率较低)的路径，如<code class="fe nu nv nw nx b">ByteBuffer</code> API，或者他们应该放弃安全保证，拥抱危险和不受支持的<code class="fe nu nv nw nx b">Unsafe</code> API，所以这个JEP旨在通过引入三个主要的抽象:<code class="fe nu nv nw nx b">MemorySegment</code>、<code class="fe nu nv nw nx b">MemoryAddress</code>和<code class="fe nu nv nw nx b">MemoryLayout</code>，为外部存储器访问提供安全、受支持和高效的API解决方案:</p><ul class=""><li id="513a" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">MemorySegment</code>用给定的空间和时间界限对连续的存储区域进行建模。</li><li id="2d95" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">一个<code class="fe nu nv nw nx b">MemoryAddress</code>模拟一个地址。通常有两种类型的地址:一个<em class="nt">检查过的</em>地址是给定内存段内的偏移量，而一个<em class="nt">未检查过的</em>地址是其空间和时间界限未知的地址，就像从本机代码中不安全地获得的内存地址一样。</li><li id="ca99" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">MemoryLayout</code>是内存段内容的程序描述。</li><li id="abdf" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">创建本机内存段的示例代码片段，这将创建一个100字节的内存缓冲区</li></ul><pre class="ks kt ku kv gt od nx oe of aw og bi"><span id="b7c2" class="oh lj it nx b gy oi oj l ok ol">try (MemorySegment segment = MemorySegment.allocateNative(100)) {<br/>   ...<br/>}</span></pre><p id="0dba" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">示例代码:</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a8b2" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">补充阅读:<a class="ae lh" href="https://openjdk.java.net/jeps/383" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/383</a></p><h1 id="a470" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">记录(第二次预览)</h1><p id="3202" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">记录首先是在Java 14中引入的，这是JEP引入的一个特性，支持密封类型、本地记录、记录上的注释。记录是充当不可变数据的透明载体的类。记录可以看作是<em class="nt">名义元组</em>。</p><p id="5f87" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">对<code class="fe nu nv nw nx b">records</code>特性的主要动机是基于“Java太冗长”或“太多礼节”的抱怨。对于一些值来说，仅仅是不可变的<em class="nt">数据载体</em>的类可以作为一个很好的例子来说明这一点，正确地编写一个数据载体类需要大量低价值的、重复的、容易出错的代码:构造函数、访问函数、<code class="fe nu nv nw nx b">equals</code>、<code class="fe nu nv nw nx b">hashCode</code>、<code class="fe nu nv nw nx b">toString</code>等等</p><p id="8104" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">示例:</strong>(记录前)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0f65" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">省略一些方法，比如<code class="fe nu nv nw nx b">equals</code>，会导致对象比较过程中的错误行为，并且难以调试。</p><p id="ece0" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">记录旨在解决其中一些问题。它们是java语言中的一种新的类，其目的是声明一小组变量将被视为一种新的实体。一条记录声明它的<em class="nt">状态</em>——一组变量——并提交给一个与该状态匹配的API</p><p id="94c8" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">示例:</strong>(使用记录)</p><pre class="ks kt ku kv gt od nx oe of aw og bi"><span id="77fd" class="oh lj it nx b gy oi oj l ok ol">record Message(String message, long dimensionl) { }</span></pre><p id="7090" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">记录解剖</strong></p><p id="e581" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><code class="fe nu nv nw nx b">record</code>指定名称、标题和正文。标题列出了记录的<em class="nt">组成部分</em>，它们是构成记录状态的变量</p><p id="6a9c" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">例子</p><pre class="ks kt ku kv gt od nx oe of aw og bi"><span id="fb4e" class="oh lj it nx b gy oi oj l ok ol">record Point(int x, int y) { }</span></pre><p id="5159" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">这里的名字是<code class="fe nu nv nw nx b">Point</code></p><p id="19dd" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">表头是<code class="fe nu nv nw nx b">x</code>和<code class="fe nu nv nw nx b">y</code></p><p id="4287" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">主体是花括号中的内容</p><p id="52ff" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><code class="fe nu nv nw nx b">record</code>默认带有四个标准成员</p><ul class=""><li id="0b2a" class="mw mx it mc b md my mg mz mj na mn nb mr nc mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">public</code>与组件具有相同名称和返回类型的访问器方法，以及与组件具有相同类型的<code class="fe nu nv nw nx b">private</code> <code class="fe nu nv nw nx b">final</code>字段</li><li id="5c3e" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated">标准构造函数</li><li id="9dc3" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">equals</code>和<code class="fe nu nv nw nx b">hashCode</code>方法</li><li id="67ec" class="mw mx it mc b md nh mg ni mj nj mn nk mr nl mv nd ne nf ng bi translated"><code class="fe nu nv nw nx b">toString</code></li></ul><h2 id="6e29" class="oh lj it bd lk oo op dn lo oq or dp ls mj os ot lu mn ou ov lw mr ow ox ly iz bi translated">记录和密封类型</h2><p id="355f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">记录和密封类型的组合有时被称为<a class="ae lh" href="https://en.wikipedia.org/wiki/Algebraic_data_type" rel="noopener ugc nofollow" target="_blank"> <em class="nt">代数数据类型</em> </a>。</p><p id="de9c" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">记录允许表示<em class="nt">产品类型</em>，封存类型允许表示<em class="nt">汇总类型</em></p><p id="e6ac" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated"><strong class="mc jd">例如:</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="6ab8" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">不赞成为删除而激活RMI</h1><p id="f44e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">因为分布式系统基于web技术已经有很长时间了。关于穿越防火墙、过滤请求、认证和安全性的问题都在web服务领域得到了解决。资源的惰性实例化由负载平衡器、编排和容器来处理。这些机制都不存在于分布式系统的RMI激活模型中，Java团队没有发现任何使用RMI激活的新应用程序。</p><p id="cd3d" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">RMI激活在<a class="ae lh" href="https://docs.oracle.com/javase/8/docs/api/java/rmi/activation/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank"> Java 8 </a>中是可选的，在Java 15中被删除了</p><h1 id="51f4" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">禁用和反对有偏向的锁定</h1><p id="7fea" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这是偏向锁定的遗留同步优化，维护成本很高，因此JDK团队默认禁用它。</p><p id="e0b5" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">Hashtable和Vector等传统集合API利用了这些性能提升，但在当前趋势下，大多数较新的应用程序通常使用非同步集合，如<code class="fe nu nv nw nx b">HashMap</code>和<code class="fe nu nv nw nx b">ArrayList</code>，甚至是Java 5中引入的更高性能的并发数据结构，用于多线程场景</p><p id="30d5" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">有了这个JEP，HotSpot启动时将不再启用偏置锁定，除非在命令行上设置了<code class="fe nu nv nw nx b">-XX:+UseBiasedLocking</code>。</p><p id="a0df" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">更多阅读材料:<a class="ae lh" href="https://openjdk.java.net/jeps/374" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/374</a></p><h1 id="24d4" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">移除Nashorn JavaScript引擎</h1><p id="17cc" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这是从Java中移除的，它不应该影响方式<code class="fe nu nv nw nx b">javax.script</code> API</p><p id="e19d" class="pw-post-body-paragraph ma mb it mc b md my kd mf mg mz kg mi mj nm ml mm mn nn mp mq mr no mt mu mv im bi translated">更多阅读材料:<a class="ae lh" href="https://openjdk.java.net/jeps/372" rel="noopener ugc nofollow" target="_blank">https://openjdk.java.net/jeps/372</a></p></div></div>    
</body>
</html>