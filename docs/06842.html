<html>
<head>
<title>Redis for DevOps Engineers / SRE Part-1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向DevOps工程师/ SRE的Redis第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/redis-for-devops-engineers-dca8c548e9ef?source=collection_archive---------6-----------------------#2021-01-07">https://levelup.gitconnected.com/redis-for-devops-engineers-dca8c548e9ef?source=collection_archive---------6-----------------------#2021-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/498c3973607c00c2778fccd5561186b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YtWF_kxYSsreKqId.png"/></div></div></figure><p id="50cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我一直想知道作为DevOps工程师，我需要了解Redis多少。为什么开发人员使用它，为什么它在技术社区很热门？</p><p id="479e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redis是一个开源的键值存储，它主要用于缓存，但是Redis不仅仅是一个缓存。它有一个内存中的数据结构存储，用作数据库、缓存和消息代理。</p><h1 id="1389" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">关于Redis你必须知道的事情</strong></h1><p id="c729" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka ir">升级Redis版本<br/> </strong>较新版本的Redis可以在很多方面获得性能优化的好处，不仅仅是在内存管理方面。Redis版或更高版本，5.0版有更好的策略。如果您使用的Redis版本低于4.0，请考虑将其升级到更高版本。</p><p id="38e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">完全禁用交换功能<br/> </strong>如果操作系统配置了交换功能，它可以将一些Redis数据转储到磁盘，稍后Redis试图访问这些数据时，可能需要很长时间才能将它们读回内存。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c017" class="mi kx iq me b gy mj mk l ml mm">sysctl -w vm.swappiness=0</span></pre><p id="6fe7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更多内核！= Better++ <br/> </strong> Redis是一个单线程进程，如果启用了持久性，它最多消耗两个内核。对于Redis实例，您不需要两个以上的核心。</p><p id="0a3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">规模化成本高<br/> </strong> Redis不是银弹，规模化成本确实很高，因为它将数据存储在内存中，在这种情况下，您不需要那种内存级别的性能，请避免使用它，并转向更经济高效且易于操作的方式。</p><h1 id="c713" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">关于Redis您需要了解的命令。</h1><p id="1873" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka ir">要了解平均延迟<br/> </strong>要快速检查Redis实例的平均延迟，可以使用:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8c27" class="mi kx iq me b gy mj mk l ml mm">redis-cli — latency</span></pre><p id="d6fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">Redis-Benchmark To study latency<br/></strong>要确保您的redis-server行为正常，快速运行一个基准来研究延迟，您可以启动:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="29fb" class="mi kx iq me b gy mj mk l ml mm">redis-benchmark -q -n 10000 -c 1 -d average_size_of_your_objects_in_bytes</span></pre><p id="d405" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是真正的“负载测试”。<br/>除Redis-benchmark以外。很少有其他工具可以对Redis进行基准测试。<br/>-Memtier-Benchmark<br/>-YCSB<br/>-perf kit基准</p><p id="18ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">找出Redis <br/> </strong>变慢的原因，因为Redis没有详细的日志。通常很难跟踪实例内部到底发生了什么。Redis为您提供了commandstat实用程序来展示这一点:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0c15" class="mi kx iq me b gy mj mk l ml mm">127.0.0.1:6379&gt; INFO commandstats<br/>cmdstat_get:calls=12,usec=608,usec_per_call=2.4<br/>cmdstat_setex:calls=15,usec=71,usec_per_call=4.20<br/>cmdstat_keys:calls=21,usec=42,usec_per_call=1.00</span></pre><p id="c340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Commandstats为您提供了所有命令的明细、执行所用的微秒数(每次调用的总数和平均值)以及它们已经运行了多少次。</p><p id="c9d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">数据库<br/> </strong>监视器发生了什么是一个调试命令，它将Redis服务器处理的每个命令流回。它有助于了解数据库发生了什么。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8050" class="mi kx iq me b gy mj mk l ml mm">redis-cli monitor</span></pre><p id="d164" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是运行MONITOR是有代价的，因为它流回所有命令，它的使用是有代价的。</p><p id="0855" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重置Redis统计数据<br/> </strong>重置这个简单的运行配置RESETSTAT，你就有了一个全新的状态。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="bca9" class="mi kx iq me b gy mj mk l ml mm">CONFIG RESETSTAT</span></pre><p id="af66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">了解内存相关问题<br/></strong>MEMORY DOCTOR命令报告Redis服务器遇到的不同内存相关问题，并建议可能的补救措施。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0d36" class="mi kx iq me b gy mj mk l ml mm">MEMORY DOCTOR</span></pre><p id="a0b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">服务器的内存使用情况。<br/></strong>MEMORY STATS命令返回一个关于服务器内存使用情况的数组回复。它报告的内存统计列表。点击了解更多信息<a class="ae mn" href="https://redis.io/commands/memory-stats" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ab12" class="mi kx iq me b gy mj mk l ml mm">MEMORY STATS</span></pre><p id="a291" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">了解一个Redis实例的角色<br/> </strong>角色命令返回该实例当前是主、从还是哨兵的信息。该命令还返回关于复制输出状态的附加信息，作为以下三个字符串之一:<br/>【主】<br/>【从】<br/>【哨兵】</p><h1 id="4806" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使聚集</h1><p id="98f2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka ir">不要随着生产工作负载的增加而淹没一个实例<br/> </strong>将工作负载分散到多个Redis实例上。Redis集群现在从版本3.0.0开始可用。Redis Cluster允许您根据键的范围在给定的主/从组之间拆分键。<br/>如果集群不是一个选项，那么考虑在多个实例中分配名称空间和你的键。在redis.io网站上可以找到一篇关于数据分区的精彩文章。</p><p id="3e6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">高可用性和复制</strong></p><p id="bbe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redis有两个运行多个实例的主要类别。有标准复制和Redis集群。要管理复制，您可以使用Redis Sentinel。集群主要是自我管理，但是您可以将两者结合起来以获得扩展体验，如果复杂的话，还可以进行HA+复制。</p><p id="e921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redis Sentinel是一个久经考验的高可用性解决方案，许多用户已经在生产中运行它。始终将Redis Sentinel视为HA(高可用性)解决方案。</p><p id="6d5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何在Redis中设置复制或集群，以分散负载并超越单实例内存能力。</p><blockquote class="mo mp mq"><p id="5884" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated">进入第二部分</p></blockquote><p id="8de5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">开发者为什么要用Redis？</strong></p><ul class=""><li id="3d50" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">它快得惊人！</li><li id="2895" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">他们使用它进行缓存，这有助于节省数据库调用，减少数据访问延迟，增加吞吐量，并减轻关系数据库或<br/> NoSQL数据库的负担。这也有助于节省一些成本，</li><li id="9a28" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">Redis有助于以亚毫秒级的响应时间提供频繁请求的项目。它使开发人员能够轻松地扩展更高的负载，而不会增加更昂贵的后端。</li><li id="3241" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">不同的开发人员将它用于不同的用例，如数据库查询结果缓存、持久会话缓存、网页缓存和常用对象(如图像、文件和元数据)的缓存，这些都是Redis缓存的常见示例。</li><li id="950e" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">一些开发者甚至用它来进行实时分析。Redis使用Apache Kafka等流解决方案作为内存中的数据存储，以亚毫秒级延迟接收、处理和分析实时数据。</li><li id="2c7f" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">我们都知道程序中的数据结构非常重要，开发人员广泛使用他们各自编程语言的数据结构，但在某些例外情况下，他们使用Redis作为数据结构服务器。是的，Redis有数据结构，如字符串、哈希、列表、集合、带范围查询的排序集合、位图、超级日志、带radius查询的地理空间索引和流</li></ul><p id="c402" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">进一步阅读<br/></strong><a class="ae mn" href="https://redislabs.com/wp-content/uploads/2016/03/15-Reasons-Caching-is-best-with-Redis-RedisLabs-1.pdf" rel="noopener ugc nofollow" target="_blank">https://Redis labs . com/WP-content/uploads/2016/03/15-Reasons-Caching-is-best-with-Redis-Redis-1 . pdf</a><br/><a class="ae mn" href="https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Jon cole/925630 df 72 be 1351 b 2140625 ff 2671 f</a><br/><a class="ae mn" href="https://rtfm.co.ua/en/draft-eng-redis-main-configuration-parameters-and-performance-tuning-overview/" rel="noopener ugc nofollow" target="_blank">https://rtfm . co . ua</a></p><h2 id="3062" class="mi kx iq bd ky nj nk dn lc nl nm dp lg kj nn no lk kn np nq lo kr nr ns ls nt bi translated">如果这篇文章有帮助，请点击拍手👏按钮下面几下，以示你对作者的支持！⬇</h2></div></div>    
</body>
</html>