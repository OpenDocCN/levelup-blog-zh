<html>
<head>
<title>Java Optional Is Not So Obvious</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java的可选性不是那么明显</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-optional-is-not-so-obvious-263d9559dd41?source=collection_archive---------1-----------------------#2020-12-06">https://levelup.gitconnected.com/java-optional-is-not-so-obvious-263d9559dd41?source=collection_archive---------1-----------------------#2020-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7abc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">NullPointerException</code>在Java世界里就是这么烦人的东西，<code class="fe kl km kn ko b">Optional</code>就是为了解决这个问题而被带来的。我们不能说它已经完全消失了，但是我们已经迈出了巨大的步伐。许多流行的库和框架在其生态系统中加入了Optional。例如，<code class="fe kl km kn ko b">Spring Data </code>储存库返回<code class="fe kl km kn ko b">Optional&lt;Entity&gt;</code>，而不是<code class="fe kl km kn ko b">null</code>。</p><p id="1164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为一些程序员对<code class="fe kl km kn ko b">Optional</code>变得如此兴奋，以至于他们开始过度使用它，并用错误的模式应用它。在这篇文章中，我列举了这个单子的一些误用，并提供了我处理这些问题的方法。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/f42f243859e80ffbea573ed6074285d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yM5R6ZTtyR2QvCsxFPJ3FA.jpeg"/></div></figure><h1 id="95e1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">可选决不能是</strong> <code class="fe kl km kn ko b"><strong class="ak">null</strong></code></h1><p id="a56f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我想这里不需要额外的解释。将Optional赋给<code class="fe kl km kn ko b">null</code>打破了这个类的整体思路。您的API的任何客户端都不会检查可选的空值相等。你应该更喜欢用<code class="fe kl km kn ko b">Optional.empty().</code>而不是<code class="fe kl km kn ko b">null</code></p><h1 id="9625" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">了解API </strong></h1><p id="6a94" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">自从发布了新的Java版本以来，<code class="fe kl km kn ko b">Optional</code>被增强了新的特性，允许实现更少的冗长代码。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">可选. isPresent</figcaption></figure><p id="e1b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法很简单。如果名称为空，则返回默认名称。我们可以用更漂亮的方式重写。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">可选。否则</figcaption></figure><p id="a54c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们做一些更复杂的东西。假设，我们需要返回一个人名的<code class="fe kl km kn ko b">Optional</code>。如果该名称包含在允许的名称集中，则该值应该存在，否则不存在。下面是详细的方法。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">名称的可选性</figcaption></figure><p id="98d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kl km kn ko b">Optional.filter</code>可以让这段代码看起来好很多。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">可选名称—更好的方法</figcaption></figure><p id="ff65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个建议不仅适用于<code class="fe kl km kn ko b">Optional</code>而且适用于整个开发过程。</p><blockquote class="mg mh mi"><p id="9bbd" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">如果这种语言有自己的解决方案，在想出自己的解决方案之前，尝试使用它。</p></blockquote><h1 id="3f7d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">更喜欢基于价值的替代方案，而不是通用方案</strong></h1><p id="9d34" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">有一些特殊的非泛型可选类。<code class="fe kl km kn ko b">OptionalInt</code>、<code class="fe kl km kn ko b">OptionalLong</code>和<code class="fe kl km kn ko b">OptionalDouble</code>。如果需要使用基本类型，最好使用基于值的容器。在这种情况下，没有可能影响性能的额外装箱和取消装箱过程。</p><h1 id="7a84" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不要忽视懒惰</h1><p id="a0e3" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><code class="fe kl km kn ko b">Optional.orElse</code>是一种返回默认值的便捷方法。但是如果默认值的计算非常昂贵，这可能会导致一些性能问题。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">可选，性能不足</figcaption></figure><p id="c2f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使该表存在于缓存中，每次也将从远程服务器中获取。谢天谢地，这可以用<code class="fe kl km kn ko b">Optional.orElseGet</code>轻松解决。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">可选，没有性能问题</figcaption></figure><p id="f9d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">Optional.orElseGet</code>接受仅适用于空集装箱的λ值。</p><h1 id="e4b8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">不要从集合中选择</strong></h1><p id="c239" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">虽然我很少看到这种情况，但有时还是会发生。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">可选列表</figcaption></figure><p id="2ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何集合本身都是一个容器，其中的空性可以不用额外的类来确定。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">空列表—更好的方法</figcaption></figure><p id="1b04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不必要的选项使得API很难使用。</p><h1 id="d124" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不要将可选参数作为参数传递</h1><p id="2832" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这里我们开始讨论文章中最有争议的部分。</p><p id="3810" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么不应该把Optional作为参数传递呢？乍一看，这似乎合乎逻辑。这有助于我们避免意外的<code class="fe kl km kn ko b">NullPointerException</code>，对吗？嗯，也许是吧。但是这个问题有更深层次的原因。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">可选参数</figcaption></figure><p id="ac57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，API有不必要的界限。每次调用时，用户都必须用可选的。即使是已知的常数值。</p><p id="be2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二，<code class="fe kl km kn ko b">applySettings</code>有4种潜在的不同行为，这些行为基于可选方案的存在。这违反了<a class="ae mn" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank"> SRP(单一责任原则)</a>。</p><p id="a53f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们不知道该方法如何解释可选的？它只是用缺省值替换不存在的值，还是完全改变了业务逻辑？也可能它只是抛出了<code class="fe kl km kn ko b">NoSuchElementException</code>。</p><p id="22c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们看看可选的javadoc，我们可以发现一个有趣的注意事项。</p><blockquote class="mg mh mi"><p id="2a48" class="jn jo mj jp b jq jr js jt ju jv jw jx mk jz ka kb ml kd ke kf mm kh ki kj kk ij bi translated">Optional主要用于在明确需要表示“无结果”以及使用null可能会导致错误的情况下作为方法返回类型。</p></blockquote><p id="c779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可选字面定义<em class="mj">可能没有结果的</em>对象。在方法中传递<em class="mj">可能没有结果</em>听起来是个坏主意。这意味着API知道太多关于上下文的信息，并做出它不应该知道的决定。</p><p id="8406" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们该如何改进这段代码呢？如果<code class="fe kl km kn ko b">age</code>和<code class="fe kl km kn ko b">role</code>必须总是存在，我们可以从参数中删除可选的，并在顶层处理它的缺失。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">消除可选参数</figcaption></figure><p id="6fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，调用代码控制着参数值。如果你开发一个框架或者一个库，这变得更加重要。</p><p id="b3db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，如果<code class="fe kl km kn ko b">age</code>或<code class="fe kl km kn ko b">role</code>可能被省略，这种方法将不起作用。在这种情况下，最好的方法是为不同的用户需求声明不同的方法。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">分离的“applySettings”方法</figcaption></figure><p id="0ca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许这看起来有点冗长，但是现在用户有能力做他们需要做的事情，避免意外的错误。</p><h1 id="9832" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不要使用可选作为类字段</h1><p id="660e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">关于这一点，我听到了许多意见。有些人认为在类中直接存储选项有助于极大地减少<code class="fe kl km kn ko b">NullPointerException</code>。我在一家知名创业公司工作的朋友说，这种方法被认为是他们公司的一种模式。其他人认为这打破了单子的整个概念。</p><p id="27ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然直接存储Optional听起来是个好主意，但我认为这带来的问题多于好处。</p><h2 id="fbd9" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">没有可序列化性</h2><p id="a3df" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">可选不实现<code class="fe kl km kn ko b">Serializable</code>接口。这不是一个错误，这是手动完成的，因为Optional被设计为仅用作返回类型。因此，具有任何可选字段的类都不能序列化。</p><p id="c015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我认为这一点是最没有说服力的。因为在分布式系统和微服务的现代世界中，基于平台的序列化不再像过去那样重要。</p><h2 id="2c5b" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">保留不必要的引用</h2><p id="6671" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Optional是用户只需要几毫秒的对象。之后，它可以被垃圾收集器删除。但是如果我们把可选的作为一个类字段，它可以存储在那里直到程序停止。您可能不会注意到小项目中的任何性能问题。无论如何，如果我们在谈论一个有几十个beans的大型应用程序，可能会导致不同的结果。</p><h2 id="c848" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">与Spring Data/Hibernate的集成较差</h2><p id="74a4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">假设我们正在构建一个简单的Spring Boot应用程序。我们需要从表中检索值。这可以通过声明实体和相应的存储库来轻松完成。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">带有存储库的简单实体</figcaption></figure><p id="afe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<code class="fe kl km kn ko b">personRepository.findAll()</code>的可能结果。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="2a67" class="mo ky iq ko b gy ne nf l ng nh">Person(id=1, firstName=John, lastName=Brown)<br/>Person(id=2, firstName=Helen, lastName=Green)<br/>Person(id=3, firstName=Michael, lastName=Blue)</span></pre><p id="a2e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设<code class="fe kl km kn ko b">firstName</code>和<code class="fe kl km kn ko b">lastName</code>字段可为空。我们不想搞砸<code class="fe kl km kn ko b">NullPointerException</code>。所以，让我们用可选的替换简单的字段声明。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">具有可选字段的实体</figcaption></figure><p id="e475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在都碎了。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="b3d1" class="mo ky iq ko b gy ne nf l ng nh">org.hibernate.MappingException: Could not determine type for: java.util.Optional, at table: person, for columns: [org.hibernate.mapping.Column(firstname)]</span></pre><p id="efca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Hibernate只是不能将数据库中的值映射到Optional。</p><h1 id="37ae" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">但是有些东西确实可以正常工作</h1><p id="1b88" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我不得不承认，事情终究不是那么糟糕。一些框架与可选的正确集成。</p><h2 id="d9f3" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">杰克逊</h2><p id="1b3d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们声明简单的端点和DTO。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">PersonDTO</figcaption></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">简单端点</figcaption></figure><p id="44fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是<code class="fe kl km kn ko b">GET /person/1</code>的结果。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="c7c5" class="mo ky iq ko b gy ne nf l ng nh">{<br/>  "id": 1,<br/>  "firstName": "John",<br/>  "lastName": "Brown"<br/>}</span></pre><p id="a2af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我们没有配置。一切都开箱即用。让我们试着用<code class="fe kl km kn ko b">Optional&lt;String&gt;</code>代替<code class="fe kl km kn ko b">String</code></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">具有选项的人员</figcaption></figure><p id="123f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试多个案例，我用<code class="fe kl km kn ko b">Optional.empty()</code>替换了一个任务。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">带选项的端点</figcaption></figure><p id="d2f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人惊讶的是，一切仍然正常工作。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="7964" class="mo ky iq ko b gy ne nf l ng nh">{<br/>  "id": 1,<br/>  "firstName": "John",<br/>  "lastName": null<br/>}</span></pre><p id="82ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们可以在Spring Web中安全地使用Optional作为字段值，对吗？嗯，算是吧。有一些边角案例。</p><h2 id="c05c" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">SpringDoc</h2><p id="96e8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">SpringDoc是一个用于Spring Boot应用程序的库，可以自动生成<a class="ae mn" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank">开放Api模式</a>。</p><p id="3766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们为<code class="fe kl km kn ko b">GET /person/{id}</code>端点所得到的。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="0388" class="mo ky iq ko b gy ne nf l ng nh">"PersonDTO": {<br/>  "type": "object",<br/>  "properties": {<br/>    "id": {<br/>      "type": "integer",<br/>      "format": "int64"<br/>    },<br/>    "firstName": {<br/>      "type": "string"<br/>    },<br/>    "lastName": {<br/>      "type": "string"<br/>    }<br/>  }<br/>}</span></pre><p id="1f15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来相当果断。但是我们需要使<code class="fe kl km kn ko b">id</code>财产成为强制性的。这可以通过使用<code class="fe kl km kn ko b">@NotNull</code>或<code class="fe kl km kn ko b">@Schema(required = true)</code>来完成。再补充一些比较有意思的细节。如果我们把<code class="fe kl km kn ko b">@NotNull</code>放在一个可选的字段上呢？</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">具有强制id的人员</figcaption></figure><p id="df29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那将导致有趣的结果。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="fc86" class="mo ky iq ko b gy ne nf l ng nh">"PersonDTO": {<br/>  "required": [<br/>    "firstName",<br/>    "id"<br/>  ],<br/>  "type": "object",<br/>  "properties": {<br/>    "id": {<br/>      "type": "integer",<br/>      "format": "int64"<br/>    },<br/>    "firstName": {<br/>      "type": "string"<br/>    },<br/>    "lastName": {<br/>      "type": "string"<br/>    }<br/>  }<br/>}</span></pre><p id="b956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所见，<code class="fe kl km kn ko b">id</code>确实是必填字段。但是<code class="fe kl km kn ko b">firstName</code>也是。棘手的部分开始了。Optional不能是必需的，因为它的全部含义意味着该值可能被省略。无论如何，我们仅仅用了一个额外的注释就错误地指向了框架。</p><p id="a130" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有什么问题？例如，如果前端部分使用任何基于开放Api模式的类型生成器，这将破坏数据格式，并可能导致令人不快的后果。</p><h1 id="5737" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">解决办法</h1><p id="a57c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们能做些什么呢？答案很简单。仅对getters使用Optional。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">带有可选getters的PersonDTO</figcaption></figure><p id="8d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这个类可以安全地用作DTO或Hibernate实体。可选对数据没有影响。它只是包装可空值来适当地处理缺少的数据。</p><p id="b952" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有一个缺点。这种方法无法与<a class="ae mn" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> Lombok </a>完全整合。库不支持可选的getters。而且也不太可能发生。至少我们可以考虑通过<a class="ae mn" href="https://github.com/rzwitserloot/lombok/issues/1957" rel="noopener ugc nofollow" target="_blank">Github</a>上的一些讨论。</p><p id="8c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我写了一篇关于Lombok的文章，我认为这是一个很棒的工具。并且没有与Optional-Getter模式集成的事实令人不快。</p><p id="6431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前唯一的解决方法是手动定义getters。</p><h1 id="d932" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="4705" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">关于<code class="fe kl km kn ko b">java.util.Optional</code>，我想说的就是这些。我知道这是一个有争议的话题。如果您有任何问题或建议，请留下您的评论。感谢阅读！</p></div></div>    
</body>
</html>