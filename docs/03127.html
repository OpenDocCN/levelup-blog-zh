<html>
<head>
<title>Draw an SVG to canvas and download it as an image in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在画布上绘制一个SVG，并将其作为图像下载到JavaScript中</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/draw-an-svg-to-canvas-and-download-it-as-image-in-javascript-f7f7713cf81f?source=collection_archive---------1-----------------------#2020-04-21">https://levelup.gitconnected.com/draw-an-svg-to-canvas-and-download-it-as-image-in-javascript-f7f7713cf81f?source=collection_archive---------1-----------------------#2020-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d7ca1e4ad17fb9ccd42f8703c1df9085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssMmZ1C2WKQeEkzPa0825g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·施诺布里奇在<a class="ae kc" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="e8f6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">你会学到什么📖？</h1><ul class=""><li id="d2ff" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ld ir">在画布上绘制一个SVG</strong></li><li id="7d30" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated"><strong class="ld ir">将画布下载为图像(jpeg || png|| webp) </strong></li><li id="3d0a" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated"><strong class="ld ir">选择图像质量</strong></li><li id="2ecb" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated"><strong class="ld ir">下载多个zip文件</strong></li></ul><h1 id="bb31" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">在画布上绘制一个SVG🎨。</h1><p id="ffda" class="pw-post-body-paragraph ly lz iq ld b le lf ma mb lg lh mc md li me mf mg lk mh mi mj lm mk ml mm lo ij bi translated">假设我们有一个id为<code class="fe mn mo mp mq b"><strong class="ld ir">svg_element</strong></code>的SVG元素。我们会改变信仰</p><blockquote class="mr"><p id="c439" class="ms mt iq bd mu mv mw mx my mz na lo dk translated">SVG →图像→画布</p></blockquote><p id="d985" class="pw-post-body-paragraph ly lz iq ld b le nb ma mb lg nc mc md li nd mf mg lk ne mi mj lm nf ml mm lo ij bi translated">将SVG绘制到画布的步骤:</p><ul class=""><li id="8ffe" class="lb lc iq ld b le ng lg nh li ni lk nj lm nk lo lp lq lr ls bi translated">找到一个SVG的宽度和高度</li><li id="a294" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">克隆SVG节点</li><li id="5b43" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">从SVG创建一个blob对象</li><li id="f62c" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">为blob创建一个URL</li><li id="d927" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">将URL加载到图像元素中</li><li id="33af" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">用SVG的<code class="fe mn mo mp mq b">width</code>和<code class="fe mn mo mp mq b">height</code>创建一个画布</li><li id="94a2" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">将图像绘制到画布上</li></ul><p id="f3d5" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">🔷为了找到SVG的宽度和高度，我们可以使用<code class="fe mn mo mp mq b">svgElement.getBBox()</code>。这个方法将返回一个带有<code class="fe mn mo mp mq b">left , top, width, height</code>值的对象。换句话说，<code class="fe mn mo mp mq b">svg</code>元素的边界框。</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="b36b" class="nw ke iq mq b gy nx ny l nz oa">var svgElement = document.getElementById('svg_element');</span><span id="5a5e" class="nw ke iq mq b gy ob ny l nz oa">let {width, height} =<strong class="mq ir"> svgElement.getBBox()</strong>; </span></pre><p id="afb4" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">🔷要克隆一个节点，我们可以使用<code class="fe mn mo mp mq b">cloneNode</code>方法:</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="5068" class="nw ke iq mq b gy nx ny l nz oa">let clonedSvgElement = svgElement.cloneNode(true);<br/>// true for deep clone</span></pre><p id="b46a" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">🔷现在我们需要从克隆的节点创建一个blob对象:</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="29fe" class="nw ke iq mq b gy nx ny l nz oa">let outerHTML = clonedSvgElement.outerHTML,</span><span id="b6b1" class="nw ke iq mq b gy ob ny l nz oa">  blob = <strong class="mq ir">new Blob([outerHTML],{type:'image/svg+xml;charset=utf-8'})</strong>;</span></pre><p id="f125" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">🔷要从blob对象创建URL:</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="e87e" class="nw ke iq mq b gy nx ny l nz oa">let URL = window.URL || window.webkitURL || window;</span><span id="eb23" class="nw ke iq mq b gy ob ny l nz oa">let blobURL = URL.createObjectURL(blob);</span></pre><p id="5545" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">🔷我们有了blob的URL，现在我们需要将<code class="fe mn mo mp mq b">blobURL</code>加载到图像元素中。此外，我们需要向图像元素添加<code class="fe mn mo mp mq b">onload</code>事件。一旦图像被加载，这将被触发。一旦图像被加载，我们就可以将图像绘制到画布上。</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="4fcc" class="nw ke iq mq b gy nx ny l nz oa">let image = new Image();</span><span id="5760" class="nw ke iq mq b gy ob ny l nz oa">image.onload = () =&gt; {<br/>  <br/>   let canvas = document.createElement('canvas');<br/>   <br/>   canvas.widht = width;<br/>   <br/>   canvas.height = height;</span><span id="73af" class="nw ke iq mq b gy ob ny l nz oa">   let context = canvas.getContext('2d');</span><span id="b92a" class="nw ke iq mq b gy ob ny l nz oa">   // draw image in canvas starting left-0 , top - 0  </span><span id="abb3" class="nw ke iq mq b gy ob ny l nz oa"><strong class="mq ir">   context.drawImage(image, 0, 0, width, height );</strong></span><span id="e4f1" class="nw ke iq mq b gy ob ny l nz oa">  <em class="oc">//  downloadImage(canvas); need to implement</em></span><span id="4381" class="nw ke iq mq b gy ob ny l nz oa">};</span><span id="7610" class="nw ke iq mq b gy ob ny l nz oa">image.src = blobURL;</span></pre><p id="f21c" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">现在我们已经将图像绘制到画布上，让我们下载画布</p><h1 id="050a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">将画布下载为图像(png || webp || jpeg) </strong></h1><p id="7a5b" class="pw-post-body-paragraph ly lz iq ld b le lf ma mb lg lh mc md li me mf mg lk mh mi mj lm mk ml mm lo ij bi translated">我们有一个画布，我们需要将它转换成png或jpg。为此，我们将把画布转换成数据URL。</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="ea5d" class="nw ke iq mq b gy nx ny l nz oa">let png = canvas.toDataURL(); // default png</span><span id="288d" class="nw ke iq mq b gy ob ny l nz oa">let jpeg = canvas.toDataURL('image/jpg');</span><span id="8c8d" class="nw ke iq mq b gy ob ny l nz oa">let webp = canvas.toDataURL('image/webp');</span></pre><p id="7b97" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">为了下载图像，我们将编写一个函数来创建一个<code class="fe mn mo mp mq b">link</code>元素，并用<code class="fe mn mo mp mq b">href</code>指向从图像创建的DataURL。</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="000f" class="nw ke iq mq b gy nx ny l nz oa">var download = function(href, name){<br/>  var link = document.createElement('a');<br/>  link.download = name;<br/>  link.style.opacity = "0";<br/>  document.append(link);<br/>  link.href = href;<br/>  link.click();<br/>  link.remove();<br/>}</span><span id="023f" class="nw ke iq mq b gy ob ny l nz oa">download(png, "image.png");</span></pre><h1 id="796e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">选择🖼.图像的质量</strong></h1><p id="d035" class="pw-post-body-paragraph ly lz iq ld b le lf ma mb lg lh mc md li me mf mg lk mh mi mj lm mk ml mm lo ij bi translated">我们还可以为<code class="fe mn mo mp mq b">jpeg and webp</code>图像设置图像质量。</p><p id="5cb0" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">质量值是一个介于<code class="fe mn mo mp mq b">0</code>和<code class="fe mn mo mp mq b">1</code>之间的数字，表示用于使用有损压缩的图像格式(如<code class="fe mn mo mp mq b">image/jpeg</code>和<code class="fe mn mo mp mq b">image/webp</code>)的图像质量。默认值为<code class="fe mn mo mp mq b">0.92</code>。</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="a383" class="nw ke iq mq b gy nx ny l nz oa">let jpeg = canvas.toDataURL('image/jpg'); // 0.92</span><span id="28fe" class="nw ke iq mq b gy ob ny l nz oa">let webp = canvas.toDataURL('image/webp', 0.5);</span></pre><h1 id="7273" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">以zip 🗂.格式下载多个文件</strong></h1><p id="3e70" class="pw-post-body-paragraph ly lz iq ld b le lf ma mb lg lh mc md li me mf mg lk mh mi mj lm mk ml mm lo ij bi translated">考虑到我们有多个文件。我们可以将多个文件压缩成一个文件，然后下载。</p><p id="c30f" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">为了创建一个zip，我们可以使用<a class="ae kc" href="https://stuk.github.io/jszip/" rel="noopener ugc nofollow" target="_blank"> JSZip库</a>。下载<code class="fe mn mo mp mq b">jszip.js</code>并包含在您的html中。</p><p id="8c02" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">一旦纳入，我们需要:</p><ul class=""><li id="cdb4" class="lb lc iq ld b le ng lg nh li ni lk nj lm nk lo lp lq lr ls bi translated">创建一个JSZip()对象</li><li id="85d8" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">创建文件夹</li><li id="3fd9" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">将文件添加到文件夹中</li><li id="45a4" class="lb lc iq ld b le lt lg lu li lv lk lw lm lx lo lp lq lr ls bi translated">下载压缩文件</li></ul><p id="2eb4" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated"><strong class="ld ir">创建JSZip对象</strong></p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="9bc6" class="nw ke iq mq b gy nx ny l nz oa">let jsZip = new JSZip();</span></pre><p id="6d10" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated"><strong class="ld ir">创建文件夹</strong></p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="ca37" class="nw ke iq mq b gy nx ny l nz oa">let folder = jsZip.folder("images");</span></pre><p id="092c" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated"><strong class="ld ir">向文件夹添加图像</strong></p><p id="4ed7" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">我们有两个图像:</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="100a" class="nw ke iq mq b gy nx ny l nz oa">let jpeg = canvas.toDataURL('image/jpg'); // 0.92</span><span id="7a9e" class="nw ke iq mq b gy ob ny l nz oa">let webp = canvas.toDataURL('image/webp', 0.5);</span></pre><p id="5f1c" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">这两个图像是dataURL格式的，我们只需要传递base64字符串，因为我们需要从DataURL中分离base64字符串。</p><p id="7c3a" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">通常，dataURL看起来像这样:</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="3867" class="nw ke iq mq b gy nx ny l nz oa">data:image/png;base64, base64String</span></pre><p id="a071" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">我们需要从数据URL中分离出<code class="fe mn mo mp mq b">data:image/png;base64</code>:</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="d98d" class="nw ke iq mq b gy nx ny l nz oa">function getBase64String(dataURL) {</span><span id="7b92" class="nw ke iq mq b gy ob ny l nz oa">   var idx = dataURL.indexOf('base64,') + 'base64,'.length;</span><span id="f36d" class="nw ke iq mq b gy ob ny l nz oa">   return dataURL.substring(idx);</span><span id="7ebe" class="nw ke iq mq b gy ob ny l nz oa">}</span></pre><p id="f25f" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">然后，我们需要将baseString作为文件添加到文件夹中，因此最终的代码如下所示:</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="7b3f" class="nw ke iq mq b gy nx ny l nz oa">// image as dataURL<br/>let jpeg = canvas.toDataURL('image/jpg'); // 0.92<br/>let webp = canvas.toDataURL('image/webp', 0.5);</span><span id="fcac" class="nw ke iq mq b gy ob ny l nz oa">//zip <br/>let jsZip = new JSZip();<br/>let folder = jsZip.folder("images");</span><span id="3ff2" class="nw ke iq mq b gy ob ny l nz oa">let baseString = getBase64String(jpeg);<br/>folder.file("image1.jpeg", baseString, {base64 : true});</span><span id="740b" class="nw ke iq mq b gy ob ny l nz oa">let baseString2 = getBase64String(webp);<br/>folder.file("image2.webp", baseString2, {base64 : true});</span></pre><p id="02d1" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">生成zip文件</p><pre class="no np nq nr gt ns mq nt nu aw nv bi"><span id="4711" class="nw ke iq mq b gy nx ny l nz oa">zip.generateAsync({type:"blob"}).then(function (content) {<br/>      content = URL.createObjectURL(content);<br/>      let name = `JSJeep.zip`;<br/>      download(content, name); // already written above<br/>});</span></pre><p id="61a9" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">这将生成一个zip文件并开始下载。</p><p id="b7c8" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">如果你发现任何错误，请让我知道。因为<code class="fe mn mo mp mq b">Code without bug is like a book without title</code>。</p><p id="18cf" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">请在<a class="ae kc" href="https://paypal.me/jagathishSaravanan" rel="noopener ugc nofollow" target="_blank"> paypal </a>支持我。</p><p id="b303" class="pw-post-body-paragraph ly lz iq ld b le ng ma mb lg nh mc md li nl mf mg lk nm mi mj lm nn ml mm lo ij bi translated">跟随Javascript Jeep🚙💨获取更多JavaScript项目。</p><figure class="no np nq nr gt jr"><div class="bz fp l di"><div class="of og l"/></div></figure></div></div>    
</body>
</html>