<html>
<head>
<title>Mutation testing as a more robust check of dependent libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">突变测试作为对依赖库的更健壮的检查</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mutation-testing-as-a-more-robust-check-of-dependent-libraries-ca13af2a27ec?source=collection_archive---------10-----------------------#2022-05-03">https://levelup.gitconnected.com/mutation-testing-as-a-more-robust-check-of-dependent-libraries-ca13af2a27ec?source=collection_archive---------10-----------------------#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有效的测试金字塔形状和良好的测试覆盖率只是遵循TDD实践的副作用。这个话题在<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/test-pyramid-as-a-measurable-code-metric-b2363e95ebe8">之前的文章</a>中有详细介绍。</p><p id="1a9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遵循“测试优先”的范例也有助于以一种更加用户友好的方式定义模块API，因为测试实际上成为了公开的组件访问点的早期采用者。</p><p id="3f71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，您对无意的API误用和有意的错误使用的保护有多全面呢？TDD是否足以确保有一个可接受的覆盖组件行为的级别，并且没有暴露关键的漏洞？</p><h2 id="acd0" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">关于测试的✍传奇</h2><blockquote class="lf lg lh"><p id="a163" class="jn jo li jp b jq jr js jt ju jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj kk ij bi translated">“我所知道的大多数测试人员都很反常，如果你告诉他们通过应用程序的‘快乐之路’，那是他们最不愿意做的事情。”<br/> <strong class="jp ir">释放它！:设计和部署生产就绪软件</strong></p></blockquote><p id="92e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信这种说法不仅可以被测试人员所接受，也可以被许多软件工程师所接受，这些工程师试图在他们的应用程序中采用一个外部库，而这个库所涵盖的用例范围并不包括他们的特定用例。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/b20fd7f9774b65413fbd78568edd9fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSod1aTd4D-Yg-zaMABxWA.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">错误的形状</figcaption></figure><p id="2158" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这在软件工程中是一个非常常见的问题，因为库是为解决特定需求而构建的，而您的需求并不总是在本库旨在涵盖的范围内。因此，工程师需要不时地采用与他们的情况最接近的最合适的库。</p><p id="2c57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为已经获得了经验，所以通常在周围地区使用单一用途的库。因此，采用它作为通用组件比使用更专业的组件更容易。一个很好的例子是当Selenium成为事实上的通用测试平台时，包括API和性能测试领域。</p><h2 id="8f41" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">关于共享图书馆的✍传奇</h2><p id="065e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">公共库是封装不同应用程序之间共享逻辑的一种方式。当所有服务都基于单一设计规则或重用公共工作流时，这是确保服务之间行为一致性的好解决方案。</p><p id="0998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，支持一个有效的共享库依赖图是另一个需要考虑的架构挑战，所以要小心重载这个图。这个话题在本帖中<a class="ae kl" href="https://medium.com/codex/what-i-was-doing-wrong-dependency-management-and-monorepo-816c698ab9f" rel="noopener">已经很好的覆盖了，就不多停了。</a></p><p id="0121" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用公共库的另一个原因是为复杂的特性提供高层次的抽象，通过利用OOP封装隐藏实现并保护它不被覆盖。</p><p id="5d61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">独立模块与整个服务具有相同的体系结构，因为它有自己的消费者(其他模块或服务)、自己的功能路线图、部署周期等。</p><p id="7d60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一的区别是，它不是一个对最终用户隐藏的黑盒，而是另一段注入到现有体系结构中的代码，具有完全的读取权限。那么，如何确保模块仅限于由模块创建者定义的一组用例，并且没有不正确使用的后门呢？</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/0dd261893fc5763e89471688808730ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*NhSEykQ4o5Za8-EdMq-3uw.png"/></div></figure><p id="3f54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不仅是公共模块，公司私有库也应该从这个角度进行修改。不正确的库使用或未记录功能的使用可能会产生意想不到的副作用。并不总是故意的，而是由于缺乏文档或技术专业知识。</p><p id="e3b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来像一个完全不确定的任务？可能是的，但是也许我们可以定义一些阈值，这样任何低于这条线的结果都表明我们还不能推荐这个库进一步使用。</p><p id="3e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以让我们把这个挑战性的问题分解成子问题:</p><ol class=""><li id="3607" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">如何保证库不公开无证API？</li><li id="57c6" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">如何确保文档API只覆盖一组定义的用例，并且不恰当的API使用不会产生严重的副作用？</li></ol><h2 id="ba7b" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">⛅检查现有API可能的副作用</h2><p id="809c" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">从开发人员的角度来看，有哪些意想不到的副作用？当设计的API对不期望的输入变得敏感，并基于该输入提供扩展功能或意外行为时，我会感到不舒服。</p><p id="52b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何证明API只做规定的工作并且做得正确？正确，包括单元代码、集成和服务测试。</p><p id="1418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何证明测试是完整的，并且不仅检查成功路径，而且检查所有可能的条件流特性支持？正确，通过分析它的覆盖范围。</p><p id="7b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能确保足够好的测试覆盖率(例如90+ %)解决我们在执行过程中检测所有可能的信息流的问题，并防止意外的副作用吗？不幸的是，没有。它需要调味汁中的第三种成分——确保我们的测试也涵盖所有可能的数据突变。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/f9f599a339d9a9332ebf09c72eba5fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*1A22aKLRoGL_x1iTNloGbA.png"/></div></figure><p id="21fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的“突变”是什么意思？这是一个特定的度量，以确保测试检查实际行为，而不仅仅是代码执行流，它对边缘情况很敏感，并且它不仅仅是为了通过代码质量关而编写的。</p><p id="1d79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这三种配料的结合产生了非常浓的调味汁:</p><ul class=""><li id="26f3" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated"><strong class="jp ir">单元测试</strong> + <strong class="jp ir">覆盖率</strong> =测试场景的🗹丰满度</li><li id="f06c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated"><strong class="jp ir">覆盖</strong> + <strong class="jp ir">变异测试</strong>覆盖代码的=🗹丰满度，当应用变异时，它可以发出错误信号</li><li id="4638" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated"><strong class="jp ir">单元测试</strong> + <strong class="jp ir">突变测试</strong> =被检查场景的🗹丰满度</li></ul><h2 id="8e96" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">⚽:让我们在实践中检验一下</h2><p id="6694" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">源代码:<a class="ae kl" href="https://github.com/donvadicastro/docker-monitoring-stack" rel="noopener ugc nofollow" target="_blank">https://github.com/donvadicastro/docker-monitoring-stack</a></p><p id="a298" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在每个验证阶段使用以下工具:</p><ul class=""><li id="fd42" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">⚡ <strong class="jp ir"> JUnit </strong>进行单元和集成测试</li><li id="d16b" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">⚡<a class="ae kl" href="https://www.sonarqube.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">sonar cube</strong></a>用于测量由<a class="ae kl" href="https://sonarcloud.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> sonarcloud.io </strong> </a>管理的测试覆盖率</li><li id="7ea6" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">⚡ <a class="ae kl" href="https://pitest.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> PITest </strong> </a>用于执行变异测试</li><li id="f1c7" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mx mo mp mq bi translated">⚡ <a class="ae kl" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> GitHub动作</strong> </a>自动验证</li></ul><p id="befd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的目标是从所有三个角度检查发布的代码(在拉请求审查期间):测试通过，测试的数量足以证明质量，测试检查实际行为，而不仅仅是流程完成。</p><p id="ce17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这些检查中至少有一项没有通过，我们希望整个CI构建失败。</p><h2 id="b71f" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">🗹 <strong class="ak">配置单元测试门</strong></h2><p id="fb40" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">这是一个足够简单的步骤，因为JUnit已经广泛集成到开发文化中，所以市场上有许多开源和第三方插件，无需额外的代码就可以实现需求。首先是将测试运行作为CI流程的一部分:<code class="fe my mz na nb b">gradle test</code>稍后检查执行结果，以做出关于阶段结果的决定，并将其提交给PullRequest</p><pre class="ln lo lp lq gt nc nb nd ne aw nf bi"><span id="c0d5" class="km kn iq nb b gy ng nh l ni nj">- name: Report unit tests<br/>  uses: dorny/test-reporter@v1<br/>  if: always()<br/>  with:<br/>    name: Gradle Tests<br/>    path: '**/build/test-results/test/TEST-*.xml'<br/>    reporter: java-junit<br/>    fail-on-error: true<br/><br/>- name: Publish Unit Test Results<br/>  uses: EnricoMi/publish-unit-test-result-action@v1<br/>  if: always()<br/>  with:    files: "**/build/test-results/test/TEST-*.xml"</span></pre><p id="c5ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤完成后，将发布新的注释，以提取正在验证的请求。示例:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nk"><img src="../Images/80a1f84d81f9f10f120fe0d9ecc53f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bCWeoIXf6veTGY5gDa76Q.png"/></div></div></figure><h2 id="fb5f" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">🗹 <strong class="ak">配置代码覆盖门</strong></h2><p id="7bb4" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们可以使用自托管的SonarQube以及公共项目的免费云版本。在本练习中<a class="ae kl" href="https://sonarcloud.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Sonar cloud . io</strong></a><strong class="jp ir"/>使用的是声纳云版本，但是docker提供的声纳在<a class="ae kl" href="https://github.com/donvadicastro/docker-monitoring-stack/blob/master/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose配置</a>中声明。</p><p id="c931" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，声纳服务器和额外的工作空间信息需要添加到项目配置文件。示例:</p><pre class="ln lo lp lq gt nc nb nd ne aw nf bi"><span id="0fa6" class="km kn iq nb b gy ng nh l ni nj">systemProp.sonar.host.url=https://sonarcloud.io/<br/>systemProp.sonar.login=<br/>systemProp.sonar.projectKey=<br/>systemProp.sonar.projectName=</span></pre><p id="fb78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置完成后，将发布另一条注释，以提取正在验证的请求。示例:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nl"><img src="../Images/673f9c6c8c79268bdf221960243c7aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2l_imJhr06gxE7IBzJGeQ.png"/></div></div></figure><h2 id="86e3" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">🗹 <strong class="ak">配置变异测试门</strong></h2><p id="5b02" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">添加对运行变异测试的支持作为验证管道的一部分，需要实施以下步骤:</p><ul class=""><li id="10f1" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">在项目中注册<strong class="jp ir"> pitest </strong></li></ul><pre class="ln lo lp lq gt nc nb nd ne aw nf bi"><span id="84f6" class="km kn iq nb b gy ng nh l ni nj">plugins <strong class="nb ir">{<br/></strong>   id 'info.solidsoft.pitest' version '1.7.4'<br/><strong class="nb ir">}</strong></span></pre><ul class=""><li id="c286" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">配置新任务“pitest”</li></ul><pre class="ln lo lp lq gt nc nb nd ne aw nf bi"><span id="0ed5" class="km kn iq nb b gy ng nh l ni nj">pitest <strong class="nb ir">{<br/>   </strong>junit5PluginVersion = '0.15'<br/>   outputFormats = ['XML', 'HTML', 'CSV']<br/><strong class="nb ir">}</strong></span></pre><ul class=""><li id="130b" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">配置CI步骤以运行测试</li></ul><pre class="ln lo lp lq gt nc nb nd ne aw nf bi"><span id="5a12" class="km kn iq nb b gy ng nh l ni nj">- name: Mutation tests<br/>  run: gradle :application-backend:pitest</span></pre><ul class=""><li id="e3e2" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mx mo mp mq bi translated">配置CI步骤以发布结果</li></ul><pre class="ln lo lp lq gt nc nb nd ne aw nf bi"><span id="3e1f" class="km kn iq nb b gy ng nh l ni nj">- name: Comment PR<br/>  uses: machine-learning-apps/pr-comment@master<br/>  env:<br/>    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}<br/>  with:<br/>    path: &lt;path_to_report&gt;</span></pre><p id="66ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置完成后，将发布另一条注释，以提取正在验证的请求。示例:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nm"><img src="../Images/e2ac0b43a0a5015a6d846fe20dcb2f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg8MOhlVXBVMg880pcwyZg.png"/></div></div></figure><p id="ef1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你的持续集成管道是产生关于特性质量决策的唯一信任来源。这是进一步实现全自动化生产部署管道的先决条件。</p><p id="c328" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您的反馈。</p></div></div>    
</body>
</html>