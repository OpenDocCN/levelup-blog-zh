<html>
<head>
<title>Defensive Copy In .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">防御副本在。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/defensive-copy-in-net-c-38ae28b828?source=collection_archive---------0-----------------------#2022-12-22">https://levelup.gitconnected.com/defensive-copy-in-net-c-38ae28b828?source=collection_archive---------0-----------------------#2022-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="83b7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">最佳实践</h2><div class=""/><div class=""><h2 id="08f0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">理解为什么防御性拷贝很重要，以及它如何影响性能。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9b4bd4ea7acc503f3036b9e0c3800a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ImbqFBVNUlPhTVrAJ7MVQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">防御副本在。NET C#。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="aa3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你听说过<strong class="lk jd">防御副本</strong>吗？NET C#？</p><p id="e11d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你知道这个话题有多重要吗？</p><p id="0c94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你知道你可能会因此浪费内存和处理能力吗？</p><p id="689e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我告诉你吧…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><div class="mf mg gp gr mh mi"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw lb mi"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6bba7b659055f0e9d35c7d2c1aa3a728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kO-L4csOoP73w_-xVQ4N6g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">脑筋急转弯。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h1 id="8f03" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">脑筋急转弯</h1><p id="7704" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">在进入任何细节之前，让我给你看一些有趣的东西。</p><p id="0b0b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们有如下定义的结构:</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="f528" class="nz my it nv b be oa ob l oc od">public struct Num<br/>{<br/>    public int Value;<br/><br/>    public Num(int value)<br/>    {<br/>        Value = value;<br/>    }<br/><br/>    public void Increment()<br/>    {<br/>        Value++;<br/>    }<br/><br/>    public override string ToString() =&gt; $"Value = {Value.ToString()}";<br/>}</span></pre><p id="7001" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，这是一个简单的<code class="fe oe of og nv b">Num</code>结构，包含:</p><ul class=""><li id="77d8" class="oh oi it lk b ll lm lo lp lr oj lv ok lz ol md om on oo op bi translated">一个叫做<code class="fe oe of og nv b">Value</code>的<code class="fe oe of og nv b">int</code>字段。</li><li id="aaf1" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated">一个建筑工人。</li><li id="307c" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated">名为<code class="fe oe of og nv b">Increment</code>的方法将<code class="fe oe of og nv b">Value</code>字段增加1。</li><li id="1a7a" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md om on oo op bi translated">一个<code class="fe oe of og nv b">ToString</code>方法覆盖。</li></ul></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="acb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，假设我们有以下代码:</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="b4dc" class="nz my it nv b be oa ob l oc od">public class MainProgram<br/>{<br/>    private Num _number = new Num(1);<br/><br/>    public void Run()<br/>    {<br/>        Console.WriteLine("Before Increment: " + _number.ToString());<br/>        _number.Increment();<br/>        Console.WriteLine("After Increment: " + _number.ToString());<br/>    }<br/>}</span></pre><p id="06c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个类中，我们只是定义了一个私有字段类型<code class="fe oe of og nv b">Num</code>，在<code class="fe oe of og nv b">Run</code>方法中，我们只是通过调用它自己的<code class="fe oe of og nv b">Increment</code>方法来增加字段。</p><p id="fcbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们运行这段代码，我们会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/3f117f45dff22b63e88d42daeabf7d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*Ah1HpeXQ1qZo6vkHIYZL9g.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">预期结果。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="0218" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不出所料吧？</p><p id="d759" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们对代码做一个小的改动，看看这将如何反映。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="6d45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们将代码修改如下:</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="c36d" class="nz my it nv b be oa ob l oc od">public class MainProgram<br/>{<br/>    private readonly Num _number = new Num(1);<br/><br/>    public void Run()<br/>    {<br/>        Console.WriteLine("Before Increment: " + _number.ToString());<br/>        _number.Increment();<br/>        Console.WriteLine("After Increment: " + _number.ToString());<br/>    }<br/>}</span></pre><p id="3a63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如您在这里可以注意到的，我们应用的唯一更改是在字段声明中添加了<code class="fe oe of og nv b">readonly</code>关键字。</p><p id="cf3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果我们再次运行代码，您是否希望得到与之前不同的结果？不确定？让我们试一试。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="116d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们运行新代码时，我们会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/048a94b20580ae14fa92e880cf7af537.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*_zjSnsucPCxRkeMvuvXViQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">意外的结果。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="6f47" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我能听到你在尖叫:</p><blockquote class="pd pe pf"><p id="294c" class="li lj pg lk b ll lm kd ln lo lp kg lq ph ls lt lu pi lw lx ly pj ma mb mc md im bi translated">搞什么鬼？这怎么可能呢？！！！</p></blockquote><p id="a133" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，这是可能的，而且它实际上每次都会发生，因为它不是矩阵中的一个小故障或什么的😁</p><p id="7a79" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我给你解释一下。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/ec2b9788242fa51ba7d9810c6f4556b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-07c-9wq-B96M0n6wYCaVw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">引擎盖下的一瞥。由<a class="ae lh" href="https://unsplash.com/@evanbrorby?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Evan Brorby </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="2c05" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">引擎盖下的一瞥</h1><p id="f93b" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">实际发生的事情是我在这篇文章的前几行一直在问你的；是<strong class="lk jd">防御副本</strong>。</p><p id="405e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">发生的事情可以分解成简单的步骤:</p><ol class=""><li id="c84d" class="oh oi it lk b ll lm lo lp lr oj lv ok lz ol md pl on oo op bi translated">当我们用关键字<code class="fe oe of og nv b">readonly</code>标记该字段时，这表明了我们完全不改变该字段的意图。换句话说，我们不希望对该字段后面的对象应用任何更改。</li><li id="335b" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md pl on oo op bi translated">所以，编译器实际上是听我们的，理解我们的意图。因此，编译器决定帮助我们实现我们的目标。</li><li id="0cc6" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md pl on oo op bi translated">然后，我们试图通过调用它自己的<code class="fe oe of og nv b">Increment</code>方法来增加字段。</li><li id="ba3a" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md pl on oo op bi translated">因此，这是编译器决定介入并保护我们的字段对象免受任何改变的地方，即使这些改变是从内部触发的。但是编译器会怎么做呢？</li><li id="c431" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md pl on oo op bi translated">编译器会首先创建一个字段对象的副本，然后对其应用<code class="fe oe of og nv b">Increment</code>调用，而不是对原始字段对象。</li><li id="3ac8" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md pl on oo op bi translated">这里值得一提的是，field对象属于类型<code class="fe oe of og nv b">Num</code>，这是一个结构。众所周知，复制一个结构会产生一个全新的对象。</li><li id="0c79" class="oh oi it lk b ll oq lo or lr os lv ot lz ou md pl on oo op bi translated">因此，这将最终保护我们的字段对象免受任何更改。</li></ol></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="fb89" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，简单地说，这段代码:</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="79ad" class="nz my it nv b be oa ob l oc od">public class MainProgram<br/>{<br/>    private readonly Num _number = new Num(1);<br/><br/>    public void Run()<br/>    {<br/>        Console.WriteLine("Before Increment: " + _number.ToString());<br/>        _number.Increment();<br/>        Console.WriteLine("After Increment: " + _number.ToString());<br/>    }<br/>}</span></pre><p id="431b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最终会被翻译成这样的代码:</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="237d" class="nz my it nv b be oa ob l oc od">public class MainProgram<br/>{<br/>    private readonly Num _number = new Num(1);<br/><br/>    public void Run()<br/>    {<br/>        var number = _number;<br/>        Console.WriteLine("Before Increment: " + number.ToString());<br/><br/>        number = _number;<br/>        number.Increment();<br/><br/>        number = _number;<br/>        Console.WriteLine("After Increment: " + number.ToString());<br/>    }<br/>}</span></pre></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="8f5c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在你可能会问:</p><blockquote class="pd pe pf"><p id="3421" class="li lj pg lk b ll lm kd ln lo lp kg lq ph ls lt lu pi lw lx ly pj ma mb mc md im bi translated">但是为什么编译器会在<code class="fe oe of og nv b">ToString</code>调用之前创建字段对象的副本呢？！！这个调用不会以任何方式改变对象。</p></blockquote><p id="0f36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，你是对的。它不会对字段对象应用任何更改，但这不是编译器的想法。</p><p id="dfc0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">编译器不会检查方法内部的代码，并决定是否要对对象进行任何更改。</p><p id="4f2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它只是假设这可能发生，这足以让编译器保持谨慎，并应用<strong class="lk jd">防御复制</strong>机制。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="99b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你现在明白到底发生了什么。在下一节中，我们将更多地讨论<strong class="lk jd">防御副本</strong>机制。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/be9d2cfa77ace987a92144a37dbbbcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiemQwnKK3OmDGZSKszwIw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">防御性复制机制。照片由<a class="ae lh" href="https://unsplash.com/@joshredd?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔希·里德</a>在<a class="ae lh" href="https://unsplash.com/photos/u_RiRTA_TtY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><h1 id="6b22" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">防御性复制机制</h1><p id="814b" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">现在，让我们来看看你现在最可能想到的问题。</p><h2 id="10ec" class="pn my it bd mz po pp dn nd pq pr dp nh lr ps pt nj lv pu pv nl lz pw px nn iz bi translated">❓什么时候发生的？</h2><p id="0391" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">当一个<strong class="lk jd"> struct </strong>对象被用在一个<strong class="lk jd">只读</strong>上下文中，并且这个对象被操作时，就会发生这种情况。</p><h2 id="940d" class="pn my it bd mz po pp dn nd pq pr dp nh lr ps pt nj lv pu pv nl lz pw px nn iz bi translated">❓，你说被操纵是什么意思？</h2><p id="1465" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">被操纵意味着调用对象上的任何<strong class="lk jd">方法</strong>。同样，调用一个<strong class="lk jd">属性</strong>也是一样的，因为该属性最后是一个方法。然而，调用<strong class="lk jd">字段</strong>不会触发该机制。</p><h2 id="dc7d" class="pn my it bd mz po pp dn nd pq pr dp nh lr ps pt nj lv pu pv nl lz pw px nn iz bi translated">❓<strong class="ak">只读</strong>上下文是什么意思？</h2><p id="1d02" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">这意味着当对象被声明为下列之一时:</p><p id="a21a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉<strong class="lk jd">只读</strong>字段</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="5c1e" class="nz my it nv b be oa ob l oc od">public class MainProgram<br/>{<br/>    private readonly Num _number = new Num(1);<br/><br/>    public void Run()<br/>    {<br/>        Console.WriteLine("Before Increment: " + _number.ToString());<br/>        _number.Increment();<br/>        Console.WriteLine("After Increment: " + _number.ToString());<br/>    }<br/>}</span></pre><p id="e958" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉<strong class="lk jd"> ref只读</strong>局部变量</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="8579" class="nz my it nv b be oa ob l oc od">public class MainProgram<br/>{<br/>    private Num _number = new Num(1);<br/><br/>    public void Run()<br/>    {<br/>        ref readonly Num number = ref _number;<br/><br/>        Console.WriteLine("Before Increment: " + number.ToString());<br/>        number.Increment();<br/>        Console.WriteLine("After Increment: " + number.ToString());<br/>    }<br/>}</span></pre><p id="1f47" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉参数中的<strong class="lk jd"/></p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="daaa" class="nz my it nv b be oa ob l oc od">public class MainProgram<br/>{<br/>    public void Run(in Num number)<br/>    {<br/>        Console.WriteLine("Before Increment: " + number.ToString());<br/>        number.Increment();<br/>        Console.WriteLine("After Increment: " + number.ToString());<br/>    }<br/>}</span></pre><h2 id="0cd2" class="pn my it bd mz po pp dn nd pq pr dp nh lr ps pt nj lv pu pv nl lz pw px nn iz bi translated">❓，这真的重要吗？我们应该关心防御性复制是否被触发吗？</h2><p id="03ab" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">这实际上取决于<strong class="lk jd">结构</strong>和<strong class="lk jd">的大小以及</strong>防御复制<strong class="lk jd">机制被触发的频率。</strong></p><p id="8c1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉结构越大，我们预期的影响就越大。</p><p id="646b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉<strong class="lk jd">越频繁</strong>防御复制机制被触发，<strong class="lk jd">越会对</strong>产生我们应该预料到的影响。</p><p id="b300" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我给你看看…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/c81fd8627d78c1e9f129cfaa00cb946f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FE5w1jmsedvmmcEIYP4JxA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">性能影响。由<a class="ae lh" href="https://unsplash.com/@rockthechaos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">科林·格莱登</a>在<a class="ae lh" href="https://unsplash.com/photos/ij5_qCBpIVY?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="7372" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">性能影响</h1><p id="cc7b" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">让我们简化<code class="fe oe of og nv b">Num</code>结构，并向它添加更多的字段，以使它的大小更大。然后，代码应该如下所示:</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="c7dd" class="nz my it nv b be oa ob l oc od">public struct Num<br/>{<br/>    // Fields to just make the struct bigger<br/>    private long Field1, Field2, Field3, Field4;<br/><br/>    public long Value { get; }<br/><br/>    public Num(long value) : this()<br/>    {<br/>        Value = value;<br/>    }<br/>}</span></pre><p id="c4c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们构建一个<strong class="lk jd">基准测试</strong>项目来比较以下各项的性能:</p><p id="4c76" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉<code class="fe oe of og nv b">Num</code>结构的字段。</p><p id="4a65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉<strong class="lk jd">只读<code class="fe oe of og nv b">Num</code>结构的</strong>字段。</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="86b7" class="nz my it nv b be oa ob l oc od">[MemoryDiagnoser]<br/>[RankColumn]<br/>public class Benchmarker<br/>{<br/>    private const int Count = 1_000_000;<br/>    private Num _number = new Num(1);<br/>    private readonly Num _readonlyNumber = new Num(1);<br/><br/>    [Benchmark(Baseline = true)]<br/>    public long UsingField()<br/>    {<br/>        long total = 0;<br/><br/>        for (var i = 0; i &lt; Count; i++)<br/>        {<br/>            total += _number.Value;<br/>        }<br/><br/>        return total;<br/>    }<br/><br/>    [Benchmark]<br/>    public long UsingReadonlyField()<br/>    {<br/>        long total = 0;<br/><br/>        for (var i = 0; i &lt; Count; i++)<br/>        {<br/>            total += _readonlyNumber.Value;<br/>        }<br/><br/>        return total;<br/>    }<br/>}</span></pre><p id="c7f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行这个<strong class="lk jd">基准</strong>项目，我们会得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/49f39c1caaf47b98021ff218a58f653a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGXYXpGXQmkS8K41uREKIA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">基准结果。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="1fe5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从结果中我们可以注意到，使用字段比使用<code class="fe oe of og nv b">readonly</code>字段快4倍。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="b57c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可能会引发你提出以下问题:</p><blockquote class="pd pe pf"><p id="4f2c" class="li lj pg lk b ll lm kd ln lo lp kg lq ph ls lt lu pi lw lx ly pj ma mb mc md im bi translated">好了，现在我知道这可能会有所不同，但是，当实际上不需要时，有没有办法避免这种防御性拷贝呢？？</p></blockquote><p id="836b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，我明白你的意思。有时编译器只是触发<strong class="lk jd">防御复制</strong>机制，即使调用不会对对象应用任何改变。</p><p id="d31c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果仅仅因为编译器想要谨慎，我们就应该一直买单，那就不好了。但是，我们应该吗？？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/f4d7223846bf2a36223ded61b2d24172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Wmmi9vtJtcPagmSeB6j-w.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">解决方法。照片由<a class="ae lh" href="https://unsplash.com/@edge2edgemedia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Edge2Edge Media </a>在<a class="ae lh" href="https://unsplash.com/photos/x21KgBfOd_4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="b48c" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">解决方案</h1><p id="1a28" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">不，我们不应该。我们并不总是被迫接受分配更多内存和浪费处理能力的账单。有一个解决办法。</p><p id="0ef0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">修复就像将<strong class="lk jd">结构</strong>标记为<code class="fe oe of og nv b">readonly</code>一样简单。</p><p id="3d4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们将该结构标记为<strong class="lk jd"> readonly </strong>时，编译器确保它是<strong class="lk jd">不可变的</strong>。这意味着没有人可以操纵对象或改变其状态。</p><p id="3b52" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相应地，编译器确信没有调用会操纵对象，因此不需要<strong class="lk jd">防御复制</strong>机制。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="a5ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，如果我们将代码更改如下:</p><pre class="ks kt ku kv gt nu nv nw bn nx ny bi"><span id="7b0b" class="nz my it nv b be oa ob l oc od">public readonly struct Num<br/>{<br/>    public readonly int Value;<br/><br/>    public Num(int value)<br/>    {<br/>        Value = value;<br/>    }<br/><br/>    public Num Increment()<br/>    {<br/>        return new Num(Value + 1);<br/>    }<br/><br/>    public override string ToString() =&gt; $"Value = {Value.ToString()}";<br/>}</span></pre><p id="886b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果我们运行完全相同的<strong class="lk jd">基准测试</strong>项目，我们将得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qb"><img src="../Images/6083e3f14975464beaf9a5f0f2dab247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LJrASHMYH2VMzi8R0l_AQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">基准结果。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="ee1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看，将结构标记为<code class="fe oe of og nv b">readonly</code>移除了<strong class="lk jd">防御复制</strong>机制开销，节省了内存和处理能力。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qc"><img src="../Images/81ad335fb4e9f59bad10a43dc5e0febb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYs4ycDUI7vEMGeQMWIS1Q.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">检测手段。<a class="ae lh" href="https://unsplash.com/@flexpointsecurity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Flex Point Security Inc. </a>在<a class="ae lh" href="https://unsplash.com/photos/xKztxJdAmpM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="cd66" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">检测手段</h1><p id="a05a" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">现在，你可能会问:</p><blockquote class="pd pe pf"><p id="e40a" class="li lj pg lk b ll lm kd ln lo lp kg lq ph ls lt lu pi lw lx ly pj ma mb mc md im bi translated">有没有什么工具可以帮助我发现防御性拷贝的出现？</p></blockquote><p id="5f41" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，<a class="ae lh" href="https://www.nuget.org/packages/ErrorProne.NET.Structs" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">ErrorProne.NET结构</strong> </a> nuget包。</p><p id="eb3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一组帮助避免struct和<strong class="lk jd"> readonly </strong>引用性能陷阱的分析器。使用这个nuget包，您可以发现与结构相关的问题，以便您可以当场修复它们。</p><p id="4736" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您需要记住的是，只有当结构大小&gt; = 16字节时，分析器才会发出诊断信息。</p><p id="8253" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">据说您可以使用<strong class="lk jd">来更改该阈值。editorconfig </strong>文件并添加以下行:</p><p id="8628" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oe of og nv b"><strong class="lk jd">error_prone.large_struct_threshold = {new threshold}</strong></code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qd"><img src="../Images/4167260184ddee66d82fea7154e1613a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhonkMLNE18Ff84npNO6OA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">。网芯。图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h1 id="8642" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">。网络核心</h1><p id="a38c" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">到目前为止，我们讨论的所有内容都适用于<strong class="lk jd">。NET框架</strong>。带<strong class="lk jd">。网芯</strong>，事情有变。</p><p id="f8ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样的概念<strong class="lk jd">防御副本</strong>仍然存在，但框架现在更智能了。一些被<strong class="lk jd">错误检测到的代码。NET Framework </strong>作为操纵者不会被<strong class="lk jd">检测到。网芯</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/f9b214ad96409ebf23edba3c3d22a29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OlUeEFrFJE_GcJdFLZIPsQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">最后的想法。照片由<a class="ae lh" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">肯尼·埃利亚松</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="2f06" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">最后的想法</h1><p id="e011" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">我希望至此你已经了解了关于<strong class="lk jd">防御副本</strong>机制的一切。</p><p id="5d6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我给你的最后建议是:</p><p id="d33d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉总是试图设计和实现不可变的结构。</p><p id="054f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉这使得将结构标记为只读变得非常容易。</p><p id="c70a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉With structs总是尝试使用<strong class="lk jd">字段</strong>，而不是属性。这将帮助你避免太多的问题。</p><p id="6788" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">👉就算有<strong class="lk jd">。NET Core </strong>，你应该遵循最佳实践，而不仅仅是依靠框架来照顾它。</p><p id="656b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就是这样。希望你觉得读这篇文章和我写这篇文章一样有趣。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><h1 id="5756" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="8212" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">如果您还不是<strong class="lk jd">中的</strong>会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我可以从<strong class="lk jd">中的</strong>中获得您的一部分费用，您无需支付任何额外费用。订阅<a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他有趣的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure><h1 id="7927" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">其他资源</h1><p id="3652" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">这些是你可能会发现有用的其他资源。</p><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/compiler-friendly-code-sealed-keyword-in-net-c-b363fbcd1e35"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">编译器友好代码:在。NET C#</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">Why &amp; When Sealed关键字可以提高。NET C#</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="qe l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/why-split-large-methods-into-smaller-ones-7b71f26f8745"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">为什么要把大方法分成小方法呢？！</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">学习何时将大方法分解成小方法，让不可能变成可能。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="qf l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/memory-management-in-net-740b03d01e24"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">中的内存管理。网</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">中关于内存管理的所有内容。NET和重要的相关主题。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="qg l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/what-is-caching-in-software-systems-cfa71c385bfc"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">什么是软件系统中的缓存</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">软件系统中缓存的定义和最佳实践。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="qh l mt mu mv mr mw lb mi"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/38df81e16a78fcb4d39e85c893ba3922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp7Vof8nWAXNHeiqBL67eQ.png"/></div></div></figure></div></div>    
</body>
</html>