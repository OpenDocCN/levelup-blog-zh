<html>
<head>
<title>Multiprocessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多重处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/multiprocessing-in-python-b237c09b0b14?source=collection_archive---------1-----------------------#2022-12-13">https://levelup.gitconnected.com/multiprocessing-in-python-b237c09b0b14?source=collection_archive---------1-----------------------#2022-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="14ef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python中多重处理的基本部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f4db20de52b08ba0d7621b5af9369d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uolG1h9rU4Z0V2GPXQ8uA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Jorge Salvador 在<a class="ae kv" href="https://unsplash.com/s/photos/cpu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5f63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博文中，我们将探讨如何在Python中使用多重处理模块。我还有一篇关于Python中并发和并行工作的介绍性博文。因此，在本文中，我们将直接处理应用程序，而不是概念和主题解释。</p><div class="ls lt gp gr lu lv"><a href="https://faun.pub/concurrency-parallelism-in-python-59ea61e34ae0" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python中的并发和并行</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">多线程、多处理、异步和等待</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">faun.pub</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="e534" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多重处理允许我们在绕过GIL的同时编写并发程序。我们可以在一台机器上使用多个处理器。</p><p id="25d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从一个简单的例子开始。我们有一个<em class="mk">立方</em>函数，它计算给定值的立方。让我们对多个值并行运行这个函数。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="05c6" class="mq mr iq mm b be ms mt l mu mv">import os<br/>from multiprocessing import Process, current_process<br/><br/>def cube(x: int):<br/>    #the operation<br/>    value = x * x * x<br/><br/>    #get process id from os<br/>    process_id = os.getpid()<br/>    #process id from multiprocessing<br/>    process_name = current_process().name<br/>    print(f"Process ID: {process_id} Process Name: {process_name} x: {x} value: {value}")<br/><br/>if __name__ == '__main__':<br/>    process_list = []<br/>    value_list = [1,2,3,4,5]<br/><br/>    for value in value_list:<br/>        #create process<br/>        process = Process(target=cube, args=(value,))<br/>        process_list.append(process)<br/><br/>        process.start()</span></pre><p id="0a97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用Python的多重处理包来实现并发。它主要建立在Python的线程包之上。所以，他们之间有很多相似之处。你可以在这里找到官方文档<a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1ef2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使多重处理工作，我们必须使用<em class="mk"> __name__ == '__main__' </em>保护。否则会抛出类似<em class="mk"> freeze_support() </em>的错误。您的进程应该在<em class="mk"> __name__ == '__main__ '下声明。</em></p><p id="8737" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这适用于像函数式编程这样的工作方式。最重要的是，当一个模块被调用时，进程不应该直接运行。例如，在类方法中包含它是可以的。当您在顶层模块级别使用多处理时，当调用该模块时，该进程会启动一个新进程，而已启动的进程会启动一个新进程，依此类推。你将会在无穷无尽的新过程中结束。</p><p id="27cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们为循环中的每个值生成了一个新的进程。让我们近距离了解一下<em class="mk">流程</em>类。</p><h2 id="0fcc" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">过程</h2><p id="5ca6" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated"><strong class="ky ir">构造函数:</strong> ( <em class="mk"> group=None </em>，<em class="mk"> target=None </em>，<em class="mk"> name=None </em>，<em class="mk"> args=() </em>，<em class="mk"> kwargs={} </em>，<em class="mk"> * </em>，<em class="mk"> daemon=None </em>)</p><p id="32d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须一直使用关键字来调用构造函数。</p><ul class=""><li id="06db" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir">组</strong>:始终<em class="mk">无</em>。这个参数是为了线程兼容性。</li><li id="a0d7" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir">目标</strong>:是可调用的对象，是流程运行的对象。</li><li id="30de" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir">名称</strong>:进程的名称。</li><li id="5a71" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> args </strong>:将传递给目标对象的参数元组。</li><li id="30fb" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> kwargs </strong>:将传递给目标对象的参数关键字字典。</li><li id="9194" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir">守护进程</strong>:将进程设置为守护进程的标志。主进程终止后，守护进程也会自行终止。</li></ul><p id="2ab5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面，我们将cube函数设置为目标，并将值作为参数发送。</p><p id="6bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">方法:</strong></p><ul class=""><li id="f4bc" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir"> run() </strong>:调用流程中的目标。我们不必调用<em class="mk"> run </em>方法，但如果调用，它会运行同一个进程中的所有任务。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="95c2" class="mq mr iq mm b be ms mt l mu mv">#just change the start method with the run method above<br/>process.run()<br/><br/>"""<br/>Process ID: 14316 Process Name: MainProcess x: 1 value: 1<br/>Process ID: 14316 Process Name: MainProcess x: 2 value: 8<br/>Process ID: 14316 Process Name: MainProcess x: 3 value: 27<br/>Process ID: 14316 Process Name: MainProcess x: 4 value: 64<br/>Process ID: 14316 Process Name: MainProcess x: 5 value: 125<br/>"""</span></pre><ul class=""><li id="b4d4" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir"> start() </strong>:创建一个新流程，调用<em class="mk"> run </em>方法。</li><li id="a3fc" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> join(【超时】)</strong>:决定是否等待流程结束。如果我们不使用<em class="mk"> join </em>，父进程可以在其他子进程之前完成，在这种情况下子进程被中止。如果超时值是整数，它最多阻塞给定的秒数。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="f7d4" class="mq mr iq mm b be ms mt l mu mv">def sleeping():<br/>    print("Before sleep")<br/>    time.sleep(2)<br/>    print("After sleep")<br/><br/>if __name__ == '__main__':<br/>    p = Process(target=sleeping)<br/>    print('Before start')<br/>    p.start()<br/>    print('After start')<br/>    p.join()<br/>    print("After join")<br/><br/>"""<br/>Before start<br/>After start<br/>Before sleep<br/>After sleep<br/>After join<br/>"""<br/><br/>if __name__ == '__main__':<br/>    p = Process(target=sleeping)<br/>    print('Before start')<br/>    p.start()<br/>    print('After start')<br/>    #p.join()<br/>    print("After join")<br/><br/>"""<br/>Before start<br/>After start<br/>After join<br/>Before sleep<br/>After sleep<br/>"""</span></pre><ul class=""><li id="8595" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir"> name() : </strong>返回进程的名称。</li><li id="2e02" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> is_alive() : </strong>返回一个进程是否活动的布尔值。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="424f" class="mq mr iq mm b be ms mt l mu mv">if __name__ == '__main__':<br/>    p = Process(target=sleeping, daemon=False)<br/>    print('Before start')<br/>    p.start()<br/>    print(p.is_alive())<br/>    print('After start')<br/>    p.join(timeout=3)<br/>    print("After join")<br/>    print(p.is_alive())<br/><br/>"""<br/>Before start<br/>True<br/>After start<br/>Before sleep<br/>After sleep<br/>After join<br/>False<br/>"""</span></pre><ul class=""><li id="7938" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir"> terminate() : </strong>终止进程。Unix (SIGTERM)信号</li><li id="ff53" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> kill() </strong>:同终止。在Unix系统中，使用另一种信号(SIGKILL)</li><li id="83a8" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> close() : </strong>关闭流程。关闭一个进程后，引发一个<em class="mk">值错误</em>。</li></ul><p id="c17e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">属性:</strong></p><ul class=""><li id="72ce" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir">守护进程</strong>:一个布尔值，表示进程是否为守护进程。</li><li id="cab1" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> pid </strong>:进程id</li><li id="de8f" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> exitcode </strong>:如果进程还没有终止，则<em class="mk"> None </em>。如果正常终止，则为0。如果它是通过<em class="mk"> sys.exit()，</em>终止的，那么它就是<em class="mk"> sys.exit()的参数<em class="mk"> N </em>。</em></li><li id="8975" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> authkey </strong>:进程的认证密钥。大概是:<em class="mk">b ' \ xce \ xeay \ x9a \ xcb \ xa6；' d \ xcb \ xa3 \ x9bn \ xbdy \ xe2 \ xd4 { \ x04 \ x955b \ xc9 _ t \ x89 \ xdd \ xe9 \ xe5 * \ x84N \ x19 '</em></li><li id="53b5" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir"> sentinel </strong>:我们可以用数字设定一个过程结束时哪个准备好。它有类似排队的功能。使用<em class="mk"> join() </em>更简单。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="4675" class="mq mr iq mm b be ms mt l mu mv">def cube(numbers):<br/>    for number in numbers:<br/>        time.sleep(0.5)<br/>        value = number * number * number<br/>        print(f"{value} for {number}")<br/><br/>if __name__ == '__main__':<br/>    process_list = []<br/>    numbers = range(10)<br/><br/>    for i in range(5):<br/>        p = Process(target=cube, args=(numbers,))<br/>        process_list.append(p)<br/>        p.start()<br/><br/>    for process in process_list:<br/>        process.join()<br/><br/>    print("completed")<br/><br/>"""<br/>0 for 0<br/>0 for 0<br/>0 for 0<br/>0 for 0<br/>0 for 0<br/>1 for 1<br/>1 for 1<br/>1 for 1<br/>1 for 1<br/>1 for 1<br/>8 for 2<br/>8 for 2<br/>8 for 2<br/>...<br/>"""<br/><br/>#If we invoked join immediately after starting each, then we would be waiting<br/>#for each process to finish<br/>if __name__ == '__main__':<br/>    process_list = []<br/>    numbers = range(10)<br/><br/>    for i in range(5):<br/>        p = Process(target=cube, args=(numbers,))<br/>        process_list.append(p)<br/>        p.start()<br/>        p.join()<br/><br/>"""<br/>0 for 0<br/>1 for 1<br/>8 for 2<br/>27 for 3<br/>64 for 4<br/>125 for 5<br/>216 for 6<br/>343 for 7<br/>512 for 8<br/>729 for 9<br/>0 for 0<br/>1 for 1<br/>8 for 2<br/>27 for 3<br/>"""<br/></span></pre><h2 id="9d4a" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">锁</h2><p id="0333" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">锁(也称为互斥锁)是一种同步机制，用于防止出现竞争情况。</p><blockquote class="oh oi oj"><p id="de9b" class="kw kx mk ky b kz la jr lb lc ld ju le ok lg lh li ol lk ll lm om lo lp lq lr ij bi translated"><em class="iq">“当线程或进程试图同时访问一个共享资源，并且这种访问会导致错误时，我们经常说程序存在竞争条件，因为线程或进程在“竞争”执行操作。”</em>并行编程简介</p></blockquote><p id="0726" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，当有一个共享变量时，我们使用一个锁来防止另一个进程在实际的进程使用该变量完成其任务之前干扰该变量。</p><p id="2718" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有两个函数，一个是在一个值上加一些，另一个是减一些。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="a40b" class="mq mr iq mm b be ms mt l mu mv">def add(x: int) -&gt; int:<br/>    for _ in range(50):<br/>        time.sleep(0.01)<br/>        x += 10<br/>    return x<br/><br/>def sub(x: int) -&gt; int:<br/>    for _ in range(50):<br/>        time.sleep(0.01)<br/>        x -= 10<br/>    return x<br/><br/>if __name__ == '__main__':<br/>    x = 1000<br/>    print(f"Initial x: {x}")<br/>    x = add(x)<br/>    print(f"Added x: {x}")<br/>    x = sub(x)<br/>    print(f"Substracted x: {x}")<br/><br/>"""<br/>Initial x: 1000<br/>Added x: 1500<br/>Substracted x: 1000<br/>"""</span></pre><p id="3bba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我将在没有锁的情况下对这些函数使用两个进程。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="6dbc" class="mq mr iq mm b be ms mt l mu mv">import time<br/>from multiprocessing import Process, Value, sharedctypes<br/><br/><br/>def add(x: sharedctypes.Synchronized) -&gt; int:<br/>    for _ in range(50):<br/>        time.sleep(0.01)<br/>        x.value += 10<br/>    return x.value<br/><br/>def sub(x: sharedctypes.Synchronized) -&gt; int:<br/>    for _ in range(50):<br/>        time.sleep(0.01)<br/>        x.value -= 10<br/>    return x.value<br/><br/>if __name__ == '__main__':<br/>    x =Value('i', 1000)<br/>    add_p = Process(target=add, args=(x,))<br/>    sub_p = Process(target=sub, args=(x,))<br/><br/>    add_p.start()<br/>    sub_p.start()<br/><br/>    add_p.join()<br/>    sub_p.join()<br/>    print(x.value)<br/><br/>"""<br/>840<br/>"""</span></pre><p id="d910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我定义了一个共享类型变量。它分配一个共享内存。我们可以通过使用它的<em class="mk">值</em>属性从中检索值。两个过程结合在一起，最后，我们得到一个与第一个例子不同的值。因为两个进程在竞争更新共享类型变量。</p><p id="8b8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们使用锁来避免赛车:</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="f418" class="mq mr iq mm b be ms mt l mu mv">import time<br/>from multiprocessing import Process, Value, sharedctypes, Lock<br/><br/><br/>def add(x: sharedctypes.Synchronized, lock: Lock) -&gt; int:<br/>    for _ in range(50):<br/>        time.sleep(0.01)<br/>        lock.acquire()<br/>        x.value += 10<br/>        lock.release()<br/>    return x.value<br/><br/>def sub(x: sharedctypes.Synchronized, lock: Lock) -&gt; int:<br/>    for _ in range(50):<br/>        time.sleep(0.01)<br/>        lock.acquire()<br/>        x.value -= 10<br/>        lock.release()<br/>    return x.value<br/><br/>if __name__ == '__main__':<br/>    x =Value('i', 1000)<br/>    lock = Lock()<br/>    add_p = Process(target=add, args=(x, lock))<br/>    sub_p = Process(target=sub, args=(x, lock))<br/><br/>    add_p.start()<br/>    sub_p.start()<br/><br/>    add_p.join()<br/>    sub_p.join()<br/>    print(x.value)<br/><br/>"""<br/>1000<br/>"""</span></pre><p id="86c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mk">锁定</em>类有两种方法:</p><ul class=""><li id="136b" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir">获取</strong> ( <em class="mk"> block=True，timeout=None) </em>:锁定进程。这样，在其他事情发生之前，它就可以进行自己的操作了。我们还可以提供锁定持续时间的超时限制。</li><li id="60df" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir">释放</strong>():一旦操作完成，它就释放锁并允许进程完成。</li></ul><h2 id="6ed6" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">泳池</h2><p id="b82f" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">池管理工作进程。</p><blockquote class="oh oi oj"><p id="b010" class="kw kx mk ky b kz la jr lb lc ld ju le ok lg lh li ol lk ll lm om lo lp lq lr ij bi translated">pool类可用于管理固定数量的工作线程，在这种简单的情况下，要完成的工作可以分散并独立地分配给工作线程。</p><p id="1e5b" class="kw kx mk ky b kz la jr lb lc ld ju le ok lg lh li ol lk ll lm om lo lp lq lr ij bi translated">作业的返回值被求和并作为列表返回。</p><p id="312e" class="kw kx mk ky b kz la jr lb lc ld ju le ok lg lh li ol lk ll lm om lo lp lq lr ij bi translated">池参数包括进程的数量和启动任务进程时要运行的函数(为每个子进程调用一次)。</p></blockquote><ul class=""><li id="3b42" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated">大数据-&gt;池|小数据-&gt;流程</li><li id="55ce" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated">池只保存正在内存中执行的进程。另一方面，进程将所有数据保存在内存中。因此，当有许多任务时，池是更可取的。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="be77" class="mq mr iq mm b be ms mt l mu mv">import time<br/>import os<br/>from multiprocessing import Pool<br/><br/>def cube(number):<br/>    total = 0<br/>    for i in range(number):<br/>        total += i * i * i<br/>    return total<br/><br/>if __name__ == '__main__':<br/>    cpus = os.cpu_count() #cpu count available in machine<br/>    numbers = range(5)<br/>    p = Pool(cpus-1) #a pool with cpu_count - 1 cores (default is all cores)<br/>    result = p.map(cube, numbers) <br/>    print(result)<br/>    p.close()<br/>    p.join()<br/><br/>"""<br/>[0, 0, 1, 9, 36]<br/>"""</span></pre><pre class="on ml mm mn bn mo mp bi"><span id="fa50" class="mq mr iq mm b be ms mt l mu mv">import time<br/>import os<br/>from multiprocessing import Pool<br/><br/>def cube(number):<br/>    total = 0<br/>    for i in range(number):<br/>        total += i * i * i<br/>    return total<br/><br/>def cubing_multiprocess(numbers):<br/>    cpus = os.cpu_count()<br/>    numbers = range(5)<br/>    start = time.time()<br/>    p = Pool(cpus-1)<br/>    result = p.map(cube, numbers)<br/>    p.close()<br/>    p.join()<br/>    end = time.time() - start<br/>    print("Multiprocess time: ",end)<br/><br/>def cubing_serial(numbers):<br/>    start = time.time()<br/>    result = []<br/>    for i in numbers:<br/>        result.append(cube(i))<br/>    end = time.time() - start<br/>    print("Serial time: ",end)<br/><br/><br/>if __name__ == '__main__':<br/>    #number = range(100)<br/>    number = range(10000)<br/>    cubing_multiprocess(number)<br/>    cubing_serial(number)<br/><br/>"""<br/>for range 100: <br/>Multiprocess time:  0.1426091194152832<br/>Serial time:  0.0005009174346923828<br/><br/>for range 10000:<br/>Multiprocess time:  0.15067601203918457<br/>Serial time:  5.112032175064087<br/><br/>As the workload increases, the benefit of working in parallel <br/>becomes more apparent.<br/>"""</span></pre><p id="8c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">方法:</strong></p><ul class=""><li id="f136" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir"> apply </strong>():接受任务并在阻塞的同时执行，直到结果就绪。返回任务的结果。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="c2b3" class="mq mr iq mm b be ms mt l mu mv">def cube(number):<br/>    print(f"number: {number} ; process id: {os.getpid()}")<br/>    total = 0<br/>    for i in range(number):<br/>        total += i * i * i<br/>    return total<br/><br/>if __name__ == '__main__':<br/>    p = Pool() <br/>    result = p.apply(cube, args=(50,))<br/>    print("result: ",result)<br/>    result = p.apply(cube, args=(10,))<br/>    print("result: ",result)<br/>    p.close()<br/>    print("end")<br/><br/>"""<br/>number: 50 ; process id: 19202<br/>1500625<br/>number: 10 ; process id: 19202<br/>2025<br/>end<br/>"""</span></pre><ul class=""><li id="c44d" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir">apply _ async</strong>():apply方法<em class="mk">的异步变体。与<em class="mk">应用</em>不同，它不会阻塞。它返回一个<em class="mk">异步结果</em>对象。它可以在任务完成后执行回调函数。</em></li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="8259" class="mq mr iq mm b be ms mt l mu mv">def cube(number):<br/>    print(f"number: {number} ; process id: {os.getpid()}")<br/>    total = 0<br/>    for i in range(number):<br/>        total += i * i * i<br/>    return total<br/><br/>def custom_callback(result):<br/> print(f'Got result: {result}')<br/><br/>if __name__ == '__main__':<br/>    p = Pool() <br/>    result = p.apply_async(cube, callback=custom_callback,args=(50,))<br/>    print("result: ",result)<br/>    result = p.apply_async(cube, callback=custom_callback,args=(10,))<br/>    print("result: ",result)<br/>    p.close()<br/>    p.join()<br/>    print("end")<br/><br/>"""<br/>result:  &lt;multiprocessing.pool.ApplyResult object at 0x7fb510360b80&gt;<br/>result:  &lt;multiprocessing.pool.ApplyResult object at 0x7fb510360bb0&gt;<br/>number: 50 ; process id: 19304<br/>number: 10 ; process id: 19304<br/>Got result: 1500625<br/>Got result: 2025<br/>end<br/>"""</span></pre><p id="792a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用<em class="mk"> apply_async </em>调用同一个函数<em class="mk"> n次</em>。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="3268" class="mq mr iq mm b be ms mt l mu mv">#let's generate a dummy dataset using multiprocessing and apply_async<br/><br/><br/>import os<br/>import pickle<br/>import random<br/>import pandas as pd<br/>from faker import Faker<br/>from multiprocessing import Pool<br/><br/>N= 1_000_000<br/>fake = Faker()<br/><br/>def get_a_dummy_record():<br/>    name = fake.name()<br/>    city = fake.city()<br/>    plate = fake.license_plate()<br/>    job = fake.job()<br/>    return [name, city, plate, job]<br/><br/>if __name__ == '__main__':<br/>    cpus = os.cpu_count()<br/>    pool = Pool(cpus-1)<br/>    results = []<br/>    for _ in range(N):<br/>        results(pool.apply_async(get_a_dummy_record))<br/>    pool.close()<br/>    pool.join()<br/>    data = []<br/>    for i, results in enumerate(results):<br/>        data.append(results.get())<br/>    df = pd.DataFrame(data=data)</span></pre><ul class=""><li id="fc0e" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir">map</strong>():<em class="mk">apply</em>方法将一次性任务分配给池。有了<em class="mk">映射</em>，我们可以让同一个函数可迭代，同一个函数有多个参数。有了<em class="mk">映射</em>，我们只能向任务传递一个参数。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="7aee" class="mq mr iq mm b be ms mt l mu mv">result = p.map(cube, numbers)<br/>#we have sent the same function for many iterable. cube will be rerun <br/>#for each number in numbers</span></pre><ul class=""><li id="5850" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir"> map_async </strong>():是<em class="mk"> map </em>方法的变种。它返回一个<em class="mk"> AysncResult </em>对象。可以指定回调函数(它只能接受一个参数)。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="c115" class="mq mr iq mm b be ms mt l mu mv">def custom_callback(result):<br/> print(f'Got result: {result}')<br/><br/>def cube(number):<br/>    total = 0<br/>    for i in range(number):<br/>        total += i * i * i<br/>    return total<br/><br/>if __name__ == '__main__':<br/>    numbers = range(5)<br/>    p = Pool()<br/>    result = p.map_async(cube, numbers,callback=custom_callback) <br/>    print(result)<br/>    for value in result.get():<br/>        print(value)<br/>    p.close()<br/>    p.join()<br/><br/>"""<br/>&lt;multiprocessing.pool.MapResult object at 0x7faef0278a30&gt;<br/>Got result: [0, 0, 1, 9, 36]<br/>0<br/>0<br/>1<br/>9<br/>36<br/>"""</span></pre><ul class=""><li id="27c2" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><em class="mk"> imap </em>():懒人<em class="mk">地图</em>。返回迭代器。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="3fb4" class="mq mr iq mm b be ms mt l mu mv">if __name__ == '__main__':<br/>    numbers = range(5)<br/>    p = Pool()<br/>    r = p.imap(cube, numbers)<br/>    print(r)<br/>    print(next(r))<br/>    print(next(r))<br/>    print(next(r))<br/>    print("___")<br/>    for result in p.imap(cube, numbers):<br/>        print(result)<br/>    p.close()<br/>    p.join()<br/><br/>"""<br/>&lt;multiprocessing.pool.IMapIterator object at 0x7feea8238b20&gt;<br/>0<br/>0<br/>1<br/>___<br/>0<br/>0<br/>1<br/>9<br/>36<br/>"""</span></pre><ul class=""><li id="f25a" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir"> imap_unordered </strong>():返回结果的排序是任意的。除此之外，它与<em class="mk"> imap </em>相同。</li><li id="306e" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir">星图</strong>():和<em class="mk">星图</em>一样，但是允许多个参数。</li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="aeba" class="mq mr iq mm b be ms mt l mu mv">def multiply(a, b):<br/>    return a * b<br/><br/>if __name__ == '__main__':<br/>    numbers = range(50)<br/>    p = Pool()<br/>    items = [(i, random()) for i in range(10)]<br/>    result = p.starmap(multiply, items)<br/>    print(result)<br/>    p.close()<br/>    p.join()<br/>"""<br/>[0.0, 0.5344124538146042, 0.32835463076056914, 2.4787556253795424, 3.591264897479123, 0.18079992820166868, 5.686081327214689, 0.936017685360898, 6.241723690027337, 0.47898336456594226]<br/>"""<br/><br/>#if we would use the map instead of starmap, we would get<br/>#TypeError: multiply() missing 1 required positional argument: 'b'</span></pre><ul class=""><li id="23fc" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir">star map _ async</strong>():star map<em class="mk">方法的异步变体。</em></li></ul><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="8d7d" class="mq mr iq mm b be ms mt l mu mv">if __name__ == '__main__':<br/>    numbers = range(50)<br/>    p = Pool()<br/>    items = [(i, random()) for i in range(10)]<br/>    result = p.starmap_async(multiply, items)<br/>    print(result)<br/>    for value in result.get():<br/>        print(value)<br/>    p.close()<br/>    p.join()<br/><br/>"""<br/>&lt;multiprocessing.pool.MapResult object at 0x7fc370196760&gt;<br/>0.0<br/>0.15467946959662104<br/>1.848298292394195<br/>0.8187329778385587<br/>0.35192885312433964<br/>1.5011637932143362<br/>0.46087324835219023<br/>6.432101499360136<br/>2.970120169297701<br/>1.8696971399038436<br/>"""</span></pre><ul class=""><li id="dd1f" class="nt nu iq ky b kz la lc ld lf nv lj nw ln nx lr ny nz oa ob bi translated"><strong class="ky ir">关闭</strong>():一旦任务完成，就释放工人。</li><li id="e481" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir">终止</strong>():立即停止工人，不等待他们完成任务。</li><li id="744a" class="nt nu iq ky b kz oc lc od lf oe lj of ln og lr ny nz oa ob bi translated"><strong class="ky ir">加入</strong>():等待工人退出。只有在调用了<em class="mk">关闭</em>或<em class="mk">终止</em>方法后才能调用。</li></ul><h2 id="d2e8" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">长队</h2><p id="da72" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">我们使用队列在进程间共享数据。它是一个在不同进程之间进行通信的类。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="b457" class="mq mr iq mm b be ms mt l mu mv">from time import sleep<br/>from random import random<br/>from multiprocessing import Process<br/>from multiprocessing import Queue<br/> <br/>def producer(queue):<br/>    print('Producer is running')<br/>    for i in range(10):<br/>        value = random()<br/>        sleep(value)<br/>        # add to the queue<br/>        print("Producer generated: ", value)<br/>        queue.put(value)<br/>    # all done<br/>    queue.put(None)<br/>    print('Producer finished')<br/> <br/>def consumer(queue):<br/>    print('Consumer is running')<br/>    while True:<br/>        item = queue.get()<br/>        # check for stop<br/>        if item is None:<br/>            break<br/>        value = random()<br/>        new_val = item * value<br/>        print(f'&gt;from producer: {item} and new value: {new_val}')<br/>    print('Consumer finished')<br/> <br/># entry point<br/>if __name__ == '__main__':<br/>    queue = Queue()<br/>    consumer_p = Process(target=consumer, args=(queue,))<br/>    consumer_p.start()<br/>    producer_p = Process(target=producer, args=(queue,))<br/>    producer_p.start()<br/>    # wait for all processes to finish<br/>    producer_p.join()<br/>    consumer_p.join()<br/><br/>"""<br/>Consumer is running<br/>Producer is running<br/>Producer generated:  0.23572440272864092<br/>&gt;from producer: 0.23572440272864092 and new value: 0.048785819023252984<br/>Producer generated:  0.7656479584438751<br/>&gt;from producer: 0.7656479584438751 and new value: 0.5556933624110151<br/>Producer generated:  0.45935918843841095<br/>&gt;from producer: 0.45935918843841095 and new value: 0.1940662477009978<br/>Producer generated:  0.3775766218597175<br/>&gt;from producer: 0.3775766218597175 and new value: 0.31882165082562186<br/>Producer generated:  0.2210393194445769<br/>&gt;from producer: 0.2210393194445769 and new value: 0.010097210955178933<br/>Producer generated:  0.3365449280075862<br/>&gt;from producer: 0.3365449280075862 and new value: 0.3066809374677486<br/>Producer generated:  0.031468177390468255<br/>&gt;from producer: 0.031468177390468255 and new value: 0.012702824353497563<br/>Producer generated:  0.6236820349083204<br/>&gt;from producer: 0.6236820349083204 and new value: 0.026716990276386285<br/>Producer generated:  0.012352625457066502<br/>&gt;from producer: 0.012352625457066502 and new value: 0.006689869352644401<br/>Producer generated:  0.6995692026265108<br/>Producer finished<br/>&gt;from producer: 0.6995692026265108 and new value: 0.09095476181355872<br/>Consumer finished<br/>"""</span></pre><h2 id="7e5c" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">管</h2><p id="be65" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">双工(双向)连接的对象。每一方的对象都有<em class="mk"> send </em>和<em class="mk"> recv </em>方法并传递消息。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="058c" class="mq mr iq mm b be ms mt l mu mv">from multiprocessing import Process, Pipe<br/><br/>def foo(conn):<br/>    conn.send(["Hello","World",None])<br/>    conn.close()<br/><br/>if __name__ == '__main__':<br/>    parent, child = Pipe()<br/>    p = Process(target=foo, args=(child,))<br/>    p.start()<br/>    print(parent.recv())<br/>    p.join()<br/><br/>"""<br/>['Hello', 'World', None]<br/>"""</span></pre><h2 id="6d96" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">经理</h2><p id="465f" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">列表、字典和队列可以通过一个<em class="mk">管理器</em>对象共享。它控制保存Python对象的服务器进程，并允许其他进程使用代理来操作它们。</p><pre class="kg kh ki kj gt ml mm mn bn mo mp bi"><span id="d38f" class="mq mr iq mm b be ms mt l mu mv">from multiprocessing import Process, Manager, current_process<br/><br/>def worker(liste, x):<br/>    liste.append(x)<br/>    print("list by: ",current_process().name, liste)<br/><br/>if __name__ == '__main__':<br/>    m = Manager()<br/>    liste = m.list()<br/><br/>    p1 = Process(name='worker1', target=worker, args=(liste, 30))<br/>    p2 = Process(name='worker2', target=worker, args=(liste, 70))<br/><br/>    p1.start()<br/>    p2.start()<br/><br/>    p1.join()<br/>    p2.join()<br/><br/>    print("final list: ", liste)<br/><br/>"""<br/>list by:  worker1 [30]<br/>list by:  worker2 [30, 70]<br/>final list:  [30, 70]<br/>"""</span></pre><h2 id="2f10" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">结论</h2><p id="f5f1" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">多处理提供了同时使用多个处理器的机会，并有机会避开Python限制性的GIL。这样，我们可以最大限度地发挥我们的计算能力。Python中内置的多处理模块允许我们编写与它的各种特性并发运行的程序。</p><p id="4420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p><h2 id="04e3" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">阅读更多内容…</h2><div class="ls lt gp gr lu lv"><a href="https://faun.pub/concurrency-parallelism-in-python-59ea61e34ae0" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python中的并发和并行</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">多线程、多处理、异步和等待</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">faun.pub</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://python.plainenglish.io/how-does-python-work-7dc53da52065" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python是如何工作的？</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Python的内部工作原理</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">python .平原英语. io</p></div></div><div class="me l"><div class="oo l mg mh mi me mj kp lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://blog.devgenius.io/design-patterns-in-python-memento-pattern-dfbb8a6f36cb" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Python中的设计模式:纪念模式</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Memento设计模式在Python中的实现</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">blog.devgenius.io</p></div></div><div class="me l"><div class="op l mg mh mi me mj kp lv"/></div></div></a></div><div class="ls lt gp gr lu lv"><a href="https://blog.devgenius.io/cache-your-functions-in-python-95f8591caa07" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">在Python中缓存函数</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Python中缓存的简单演示</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">blog.devgenius.io</p></div></div><div class="me l"><div class="oq l mg mh mi me mj kp lv"/></div></div></a></div><h2 id="efe6" class="mw mr iq bd mx my mz dn na nb nc dp nd lf ne nf ng lj nh ni nj ln nk nl nm nn bi translated">来源</h2><p id="aa3f" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated"><a class="ae kv" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/multiprocessing.html</a></p><p id="ac92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://superfastpython.com/" rel="noopener ugc nofollow" target="_blank">https://superfastpython.com/</a></p><p id="3ab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=TQx3IfCVvQ0" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=TQx3IfCVvQ0</a></p><p id="e7af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=GT10PnUFLlE&amp;t=485s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=GT10PnUFLlE&amp;t = 485s</a></p><p id="5613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=tKdolYuydVE" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=tKdolYuydVE</a></p></div></div>    
</body>
</html>