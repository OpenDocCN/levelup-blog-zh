<html>
<head>
<title>Level Up Your Web Skills With the net/http Package in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go中的net/http包提升您的Web技能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/level-up-your-web-skills-with-the-net-http-package-in-go-6cc79837da8c?source=collection_archive---------6-----------------------#2021-03-21">https://levelup.gitconnected.com/level-up-your-web-skills-with-the-net-http-package-in-go-6cc79837da8c?source=collection_archive---------6-----------------------#2021-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解处理程序、请求、响应等等！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b94c8a75f8fe4d20f42a67b22633861c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zKkSjGmRg-_1FQgX.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://wallpapercave.com/w/wp7041189" rel="noopener ugc nofollow" target="_blank">壁纸洞穴</a></figcaption></figure><p id="7e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">Go正在迅速成长为一种最方便的通用编程语言，并且专门面向web。它的标准库不仅全面，而且足够模块化，可以鼓励程序员逻辑地解决程序，而不是用万能的库方法(看看你，Python)。</p><p id="d156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍Go中的<code class="fe me mf mg mh b">“net/http”</code>包，以提高您的web编程技能，同时学习技术领域中最热门的语言之一。我们要讨论的主题如下:</p><ul class=""><li id="b88f" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">处理程序接口</li><li id="0998" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">处理请求和响应</li></ul><p id="de1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们学一些围棋吧！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="e6a3" class="nd ne it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">处理程序接口</h1><p id="8626" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">make是一门非常值得学习的语言，这有三个方面。首先是它的语法客观上简单明了。第二个原因是Go提供了出色的文档，第三个原因是Go的源代码也是自文档化的。</p><p id="6f6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了给你一个更好的想法，看看Go文档中的<code class="fe me mf mg mh b">net/http</code>包的文档。我们将在整个教程中引用这些文档。</p><div class="oa ob gp gr oc od"><a href="https://golang.org/pkg/net/http/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">http-Go编程语言</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">resp，err := http。Get("http://example.com/")...resp，err := http。post(" http://example . com/upload "，" image/jpeg"…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">golang.org</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div><p id="f61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们立即从Go中Get或Post请求的简单RESTful示例开始，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="7a12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Go鼓励事件驱动架构，所以它对处理程序有很大的吸引力。处理程序只是一个函数，当被事件或环境变化触发时，它执行预定义的操作。Go将一个处理程序定义为一个<code class="fe me mf mg mh b">interface</code>，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="247a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">Handler interface</code>是通过一个名为<code class="fe me mf mg mh b">ServeHTTP()</code>的方法实现的，该方法带有两个参数<code class="fe me mf mg mh b">ResponseWriter</code>和一个指向<code class="fe me mf mg mh b">http.Request</code>的指针。因为Go不使用继承，你可以简单地通过给对象本身添加<code class="fe me mf mg mh b">ServeHTTP()</code>方法来使<strong class="lb iu">任何</strong> <strong class="lb iu">对象</strong>扩展为<code class="fe me mf mg mh b">Handler</code>类型。</p><p id="b1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看代码。在第9行，我们定义了自己的自定义Go类型<code class="fe me mf mg mh b">garbage</code>，它也是类型<code class="fe me mf mg mh b">string</code>。通过如上所述实现方法<code class="fe me mf mg mh b">ServeHTTP()</code>，我们隐式地实现了自定义类型<code class="fe me mf mg mh b">garbage</code>上的<code class="fe me mf mg mh b">Handler interface</code>。所以，<code class="fe me mf mg mh b">garbage</code>现在是<code class="fe me mf mg mh b">string</code>类型的<strong class="lb iu">和<code class="fe me mf mg mh b">Handler</code>类型的</strong>。</p><p id="db24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过打印<code class="fe me mf mg mh b">garbage</code>的一些属性(如第17行和第18行)来看到这一点。既然<code class="fe me mf mg mh b">g</code>属于类型<code class="fe me mf mg mh b">http.Handler</code>，我们也可以将我们实例化的<code class="fe me mf mg mh b">garbage</code>类型<code class="fe me mf mg mh b">g</code>传递到<code class="fe me mf mg mh b">http.ListenAndServe()</code>方法中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="ff9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到这个例子的输出，首先作为服务器运行上面的程序，然后使用命令行工具<code class="fe me mf mg mh b">curl</code>点击端口<code class="fe me mf mg mh b">:8080</code>来触发<code class="fe me mf mg mh b">http.ListenAndServe()</code>方法来使用我们的新处理程序<code class="fe me mf mg mh b">g</code>。</p><pre class="kj kk kl km gt ou mh ov ow aw ox bi"><span id="094f" class="oy ne it mh b gy oz pa l pb pc">$ go run handler.go<br/></span></pre><p id="3856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在另一个终端…</p><pre class="kj kk kl km gt ou mh ov ow aw ox bi"><span id="1648" class="oy ne it mh b gy oz pa l pb pc">$ curl localhost:8080<br/>$</span></pre><p id="e804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的第一个终端，我们现在应该看到输出:</p><pre class="kj kk kl km gt ou mh ov ow aw ox bi"><span id="4a79" class="oy ne it mh b gy oz pa l pb pc">$ go run handler.go<br/>Type of g: main.garbage<br/>Length of g: 0<br/>The garbage struct of type string is now also an http.Handler<br/></span></pre><p id="67c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了。我们可以看到<code class="fe me mf mg mh b">g</code>属于<code class="fe me mf mg mh b">main.garbage</code>类型，也可以访问<code class="fe me mf mg mh b">len()</code>方法，因为<code class="fe me mf mg mh b">g</code>也属于<code class="fe me mf mg mh b">string</code>类型。</p><blockquote class="pd pe pf"><p id="abe0" class="kz la pg lb b lc ld ju le lf lg jx lh ph lj lk ll pi ln lo lp pj lr ls lt lu im bi translated"><em class="it">但是</em> <code class="fe me mf mg mh b"><em class="it">http.ListenAndServe()</em></code> <em class="it">到底是怎么回事呢？好吧，许多高级软件工程师向我传授了一个亲密学习语言的伟大策略。那个提示是</em> <strong class="lb iu"> <em class="it">潜入源代码。</em> </strong></p></blockquote><h2 id="e207" class="oy ne it bd nf pk pl dn nj pm pn dp nn li po pp np lm pq pr nr lq ps pt nt pu bi translated">探索http。ListenAndServe()</h2><p id="7f2f" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">我使用的是Mac上的IntelliJ IDE，因此您访问方法源代码的方式可能会有所不同。最坏的情况是，您可以参考文档或查看下面的实际Go源代码:</p><div class="oa ob gp gr oc od"><a href="https://github.com/golang/go" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">golang/go</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">Go是一种开源编程语言，它使构建简单、可靠和高效的软件变得容易。地鼠…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="pv l oo op oq om or ks od"/></div></div></a></div><p id="9065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong>如果只是想看一下<code class="fe me mf mg mh b">net/http package</code>的基础，可以跳过这部分。或者，你可以做一个负责任的软件工程师，继续学习。=)</p><p id="f998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的基本程序，如果我将鼠标悬停在<code class="fe me mf mg mh b">http.ListenAndServe()</code>方法上，我可以看到它接受类型为<code class="fe me mf mg mh b">string</code>的端口地址的两个参数，以及当我们收到连接请求时执行的处理程序对象。我们还可以看到，该方法使用传输控制协议(TCP)作为其通信标准。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/4fadd4ea1bcc70c26dbde3357b63e3fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1P2ygQerNJ6b0VOEm5XxQ.png"/></div></div></figure><p id="95a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我按住Mac Command键，然后点击<code class="fe me mf mg mh b">http.ListenAndServe()</code>，我就可以看到那些写围棋的人是如何实现这个方法的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="1e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到谷歌的工程师给我们留下了关于功能<code class="fe me mf mg mh b">ListenAndServe()</code>的描述性评论。这包括这样的知识，如果处理程序是左<code class="fe me mf mg mh b">nil</code>，那么我们将使用一个<code class="fe me mf mg mh b">DefaultServeMux</code>作为我们的处理程序类型。基本上，它会寻找一个处理程序来匹配你要访问的URL。</p><p id="c95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这仍然没有真正回答这个问题，即<code class="fe me mf mg mh b">http.ListenAndServe()</code> <em class="pg">实际上是如何处理我们的连接请求的？嗯，我们可以CMD+点击方法<code class="fe me mf mg mh b">server.ListenAndServe()</code>了解一下！</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="c400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们变得更加冗长。我们可以看到，如果我们不从上面传递端口地址，那么在第15行我们将使用默认地址<code class="fe me mf mg mh b">“:http”</code>。我们也看到了如何使用<code class="fe me mf mg mh b">“tcp”</code>作为我们的通信协议。还是CMD+点击<code class="fe me mf mg mh b">srv.Serve()</code>继续挖吧！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="8ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太远，太远了！！在你离开之前，看一看，这是你可以从专业人士那里学习如何编写Go代码的地方。我们可以看到侦听器上的每个传入连接都为每个连接创建了一个新的go例程。go例程就像一个轻量级线程，独立于程序的其余部分运行。</p><p id="27c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员还通过在重新分配监听器后直接在监听器上使用<code class="fe me mf mg mh b">defer l.Close()</code>来保持代码的整洁，从而确保我们不会留下开放的连接。</p><p id="e7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以看到,“监听”过程是通过从第40行开始的无限for循环完成的。这段代码的大部分只是错误处理，第48–61行实现了后退错误检查，我们连续检查错误状态，直到达到最大时间限制。</p><p id="3fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个很酷的细节是在第72行看到我们为<code class="fe me mf mg mh b">Serve()</code>方法设置了某种形式的状态。也许围棋开发者用的是有限状态机？我自己的观察显然不全面，所以帮自己一个忙，继续探索！</p><blockquote class="pd pe pf"><p id="b3c7" class="kz la pg lb b lc ld ju le lf lg jx lh ph lj lk ll pi ln lo lp pj lr ls lt lu im bi translated">虽然你可能认为这是多余的，但是深入源代码的真正力量在于你对你的高级方法是如何相互作用的有了深刻的理解。不仅如此，您还可以向最优秀的人学习，获得如何更好地构建代码的想法，甚至获得新的架构想法！这是记录良好的源代码的真正价值，因为您不仅使代码变得更好，而且使开发人员社区作为一个整体变得更好。</p></blockquote></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="025a" class="nd ne it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">处理请求和响应</h1><p id="b316" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">别担心，我们会让事情变得简单。给你:</p><div class="oa ob gp gr oc od"><a href="https://golang.org/pkg/net/http/#Request" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">http-Go编程语言</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">resp，err := http。Get("http://example.com/")...resp，err := http。post(" http://example . com/upload "，" image/jpeg"…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">golang.org</p></div></div><div class="om l"><div class="px l oo op oq om or ks od"/></div></div></a></div><p id="a2c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算是开玩笑吧。如果你打开那个链接，你将会看到Go的请求结构有很多事情要做。归根结底，它只是一个结构。这个结构有我们可以访问的不同的字段和方法。</p><p id="2329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一起来看看。首先我们要定义一个名为<code class="fe me mf mg mh b">Response</code>的新<code class="fe me mf mg mh b">struct</code>，它将扩展<code class="fe me mf mg mh b">http.ResponseWriter</code>对象。然后我们可以定义一个名为<code class="fe me mf mg mh b">Text()</code>的新方法，它接受一个Http状态代码和一个字符串类型的<code class="fe me mf mg mh b">body</code>参数。</p><p id="e0e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的<code class="fe me mf mg mh b">Response</code>结构扩展了<code class="fe me mf mg mh b">http.ResponseWriter</code>，我们可以将响应的头设置为文本。头是键值对，用来描述我们希望如何配置请求和响应之间的附加信息。在本例中，我们在第16行自定义了自己的标题，将内容类型设置为text，在第17行用提供的状态代码调用<code class="fe me mf mg mh b">WriteHeader()</code>。最后，在我们的<code class="fe me mf mg mh b">Text()</code>方法中，我们调用<code class="fe me mf mg mh b">io.WriteString()</code>，它将主体写入我们的响应对象<code class="fe me mf mg mh b">r</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="0417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在main方法中，我们从定义一个来自<code class="fe me mf mg mh b">http.NewServeMux()</code>的新处理程序开始。该处理程序能够采用请求路由，并使用适当的处理程序进行响应。然后我们调用<code class="fe me mf mg mh b">handler.HandleFunc()</code>，它接受所描述的路线和一个函数，这个函数<strong class="lb iu">必须</strong>接受一个<code class="fe me mf mg mh b">ResponseWriter</code>和一个<code class="fe me mf mg mh b">Request</code>来实现<code class="fe me mf mg mh b">handler</code>方法。</p><p id="bcb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于上面给出的代码，我们有三种不同的可能路径。第一个是匹配任何可能的URL的一般路由<code class="fe me mf mg mh b">"/"</code>。这是我们的默认值，将创建一个新的响应，随后将状态代码设置为<code class="fe me mf mg mh b">http.StatusNotFound</code>，主体字符串值为<code class="fe me mf mg mh b">"Not found"</code>。</p><p id="9e25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二条路线将与<code class="fe me mf mg mh b">"/hello"</code>延长路线相匹配。这里我们将响应的状态设置为<code class="fe me mf mg mh b">http.StatusOK</code>，并返回一个主体为<code class="fe me mf mg mh b">"helo world"</code>的响应。</p><p id="dd2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三条也是最后一条路由使用了通配符语法，它可以采用任何形式<code class="fe me mf mg mh b">"/hello/something"</code>。在这种情况下，我们获取<code class="fe me mf mg mh b">req.URL.Path</code>并删除<code class="fe me mf mg mh b">"/hello"</code>子串，这样我们只剩下传递给请求的名称。当我们构建<code class="fe me mf mg mh b">resp.Text()</code>时，我们传递一个OK状态码，并将body值设置为<code class="fe me mf mg mh b">“Hello &lt;name&gt;”</code>。</p><p id="1f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们用<code class="fe me mf mg mh b">http.ListenAndServe()</code>启动我们的服务器并检查任何错误，因为这是负责任的Go开发者所做的。</p><p id="5c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过首先启动我们的服务器，我们可以看到这个例子的行为…</p><pre class="kj kk kl km gt ou mh ov ow aw ox bi"><span id="5c32" class="oy ne it mh b gy oz pa l pb pc">$ go run handlers.go<br/></span></pre><p id="8f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在另一个终端使用<code class="fe me mf mg mh b">curl</code>点击不同的路线…</p><pre class="kj kk kl km gt ou mh ov ow aw ox bi"><span id="3b46" class="oy ne it mh b gy oz pa l pb pc">$ curl localhost:8080<br/>Not found<br/>$ curl localhost:8080/hello<br/>Hello world<br/>$ curl localhost:8080/hello/Harry-Potter<br/>Hello Harry-Potter</span></pre><p id="95d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您已经构建了一个处理程序，它可以处理多个路由，通过<code class="fe me mf mg mh b">req.URL.Path</code>引用请求中的数据，并将自定义响应返回给客户端。恭喜你！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="6f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢学习Go中的<code class="fe me mf mg mh b">net/http</code>包的基础知识。如果你有任何进一步的问题，或者只是喜欢这篇文章，我鼓励你在下面留下评论。感谢您的阅读！</p></div></div>    
</body>
</html>