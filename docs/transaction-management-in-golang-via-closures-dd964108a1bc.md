# Golang 中通过闭包的事务管理

> 原文：<https://levelup.gitconnected.com/transaction-management-in-golang-via-closures-dd964108a1bc>

数据库管理中最熟悉和最重要的主题之一是原子性。这是数据库的一个属性，它保证要么执行所有指令，要么不执行任何指令。

如果是一个简单的 SQL 查询，它可以表示为

```
begin transaction;// Sequence of queries commit; or rollback;
```

交易有两种类型

*   一组不包含任何业务逻辑的 SQL 查询，可以驻留在数据库层。
*   我们需要将事务管理转移到服务层的情况。在这种情况下，我们运行一个查询并执行一些业务逻辑，根据业务逻辑的结果，我们决定是否需要提交或回滚我们在前面的查询中所做的更改。

案例 2 的示例:

*   在 Indmoney，我们发送一批 100 名用户进行 Demat(交易账户)创建，并在状态轮询中执行以下一组操作
*   更新批处理的状态(成功|失败)
*   针对作为批处理一部分的每个用户更新帐户创建的状态(100 DB 调用)。我们需要确保批处理状态&所有 100 个网络调用成功或全部失败，以便我们可以重试。

对于第二种情况，我们显然不能将业务逻辑放在数据库层中，因为 DB 层不理解如何解析批处理的响应，如何考虑批处理的状态是成功还是失败，如何考虑用户的交易帐户创建状态是已创建还是失败等。

**如何解决这个问题**？

我们提出的第一个解决方案有点容易出错，也有点粗糙，它将`BeginTransaction`、`Commit`和`Rollback`操作暴露给服务层，并使用 Go 的命名 Returns + Defer 函数来拯救。代码如下所示。

如果你看上面的代码，我们打开一个事务，我们做一组操作，如果任何操作中途失败，我们返回一个错误。在 defer 块中，我们使用 golang 的命名返回功能，并检查在执行操作时是否存在应用程序错误。

*   如果是，回滚未完成的事务。
*   如果否，提交打开的事务。

这其中的主要缺陷是

*   我有 20 个这样的地方，我需要在我的代码库中执行事务，我需要有 20 个地方，我需要在我的服务层中编写提交和回滚逻辑，在理想情况下，服务层不应该对此负责。
*   数据库层需要信任服务层提交或回滚打开的事务。否则会造成泄漏。

**封杀来了**。让我们看看使用闭包的代码是什么样子的。

**服务层**

**数据库层**

在使用闭包的第二种方法中，服务层只需要知道从代码的哪一部分到代码的哪一部分必须是原子性的。它只需要将整个业务逻辑包装在原子接口中，而不必再处理事务管理。

数据库层公开了一个名为`Atomic`的功能，它是一个高阶函数，接受实现 DAO 对象的函数。

调用者将业务逻辑包装在原子接口中，一旦被调用，数据库层就将一个新的连接传递给 params 中接受的函数，该函数将用于执行所有 DB 操作。

调用者必须使用这个`store`对象来执行所有应该是原子的操作，如果在处理任何操作时出现错误，它必须返回。一旦执行完所有操作，如果函数返回一个错误，就由数据库层决定是提交还是回滚。这样，我们不会在数据库层之外的任何地方公开事务，服务层只负责执行业务逻辑。

— — — — — — — — — — — — — — — — — — 0 — — — — — — — — — — — — — — — — — — —

感谢您成为我们社区的一员！在你离开之前:

*   👏为故事鼓掌，跟着作者走👉
*   📰更多内容请查看[升级编码刊物](https://levelup.gitconnected.com/?utm_source=pub&utm_medium=post)
*   🔔关注我们:[推特](https://twitter.com/gitconnected) | [LinkedIn](https://www.linkedin.com/company/gitconnected) | [时事通讯](https://newsletter.levelup.dev)

🚀👉 [**将像你这样的开发人员安置在顶级创业公司和科技公司**](https://jobs.levelup.dev/talent/welcome?referral=true)