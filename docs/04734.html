<html>
<head>
<title>Difference between weak and unowned references explained in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中解释了弱引用和无主引用之间的差异</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/difference-between-weak-and-unowned-references-explained-in-swift-24cb1d110650?source=collection_archive---------3-----------------------#2020-07-12">https://levelup.gitconnected.com/difference-between-weak-and-unowned-references-explained-in-swift-24cb1d110650?source=collection_archive---------3-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/98265907d99150286b5026da2daac1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kypuYdc3vOLkMJdLFSAAcQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kaleidico?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae kf" href="https://unsplash.com/t/business-work?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5702" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">了解Swift中内存管理的工作方式是一个很好的实践。Swift使用<em class="le">自动引用计数</em> (ARC)自动管理app的内存，无需编写任何额外的代码。当实例不再被使用时，它释放实例的内存。但是有时我们必须提供更多的信息来避免<em class="le">内存泄漏</em>和<em class="le">死锁</em>。</p><blockquote class="lf lg lh"><p id="0fe5" class="kg kh le ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">ARC仅适用于类的实例，因为类是引用类型。它不适用于结构和枚举，因为它们是值类型。</p></blockquote><p id="bb0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，类实例用它们的方法、常量、变量等创建一个<em class="le">强引用</em>。意味着在保留强引用之前不会释放它。有时会导致<em class="le">内存泄漏</em>和<em class="le">死锁</em>，我们可以通过声明<em class="le">弱引用</em>或<em class="le">无主引用</em>来避免这种情况。</p><p id="e942" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">弱引用和无主引用的区别</strong></p><p id="a926" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">弱引用</em>是可选类型，这意味着一旦它引用的实例释放内存，弱引用将设置为<em class="le"> nil </em>。</p><p id="f087" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，<em class="le">无主引用</em>是非可选类型，它永远不会被设置为<em class="le"> nil </em>并且总是有某个值<em class="le">。</em></p><p id="961b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">弱引用</strong></p><p id="26ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以在变量或属性前用<code class="fe ll lm ln lo b">weak</code>关键字声明<em class="le">弱引用</em>。以下示例将解释如何使用<em class="le">弱引用</em>。</p><p id="326b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用字符串的属性<code class="fe ll lm ln lo b">name</code>类型和可选类型<code class="fe ll lm ln lo b">zoo</code>来实现<code class="fe ll lm ln lo b">class Animal</code>。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="92d9" class="lx ly it lo b gy lz ma l mb mc"><strong class="lo iu">class</strong> Animal {<br/>    <strong class="lo iu">let</strong> name: String<br/>    <strong class="lo iu">var</strong> zoo: Zoo?</span><span id="55c4" class="lx ly it lo b gy md ma l mb mc">    <strong class="lo iu">init</strong>(name: String) {<br/>        self.name = name<br/>    }</span><span id="cd68" class="lx ly it lo b gy md ma l mb mc">    <strong class="lo iu">deinit</strong> { <br/>       print("\(name) is deinitialized.")<br/>    }<br/>}</span></pre><p id="4017" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，定义另一个类<em class="le">动物园</em>，其属性<em class="le">位置</em>类型字符串<em class="le">和<em class="le">动物</em>为<em class="le">弱引用</em>，这是一个可选类型。</em></p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="54a3" class="lx ly it lo b gy lz ma l mb mc"><strong class="lo iu">class</strong> Zoo {<br/>     <strong class="lo iu">let</strong> location: String<br/>     <strong class="lo iu">weak</strong> var animal: Animal?<br/>    <br/>     <strong class="lo iu">init</strong>(location: String) {<br/>         self.location = location<br/>     }</span><span id="07cc" class="lx ly it lo b gy md ma l mb mc">     <strong class="lo iu">deinit</strong> { <br/>         print("Zoo at \(location) is deinitialized.")<br/>     }<br/>}</span></pre><p id="b01a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义可选类型的两个变量<em class="le"> tiger </em>和<em class="le"> logoaZoo </em>并设置为实例<em class="le">。然后，使用unwrap将两个实例链接在一起。</em></p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="5b6d" class="lx ly it lo b gy lz ma l mb mc"><strong class="lo iu">var</strong> tiger: Animal? = Animal(name: "Amber")<br/><strong class="lo iu">var</strong> lagoaZoo: Zoo? = Zoo(location: "11th St, Corona, NY 11368, United States")</span><span id="7eeb" class="lx ly it lo b gy md ma l mb mc">tiger!.zoo = lagoaZoo<br/>lagoaZoo!.animal = tiger</span></pre><p id="3d9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们将<em class="le"> tiger </em>变量设置为<em class="le"> nil </em>时，它破坏了对<em class="le"> Animal </em>实例的强引用，并从内存中释放了它。</p><p id="d302" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于不再有对动物实例的强引用，所以<em class="le">动物</em>属性也将被设置为<em class="le">零。</em></p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="997c" class="lx ly it lo b gy lz ma l mb mc">tiger = <strong class="lo iu">nil</strong></span></pre><p id="2ece" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将<em class="le"> logoaZoo </em>设置为0，它将破坏对Zoo实例的强引用，并且也将从内存中释放。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="db9b" class="lx ly it lo b gy lz ma l mb mc">lagoaZoo = <strong class="lo iu">nil</strong></span></pre><p id="c1fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">无主引用</strong></p><p id="c99f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以在变量或属性前用<em class="le"> unowned </em>关键字声明<em class="le"> unowned引用</em>。下面的例子将解释如何使用<em class="le">无主引用</em>。</p><p id="ccb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用字符串类型的属性<em class="le">名称</em>和可选类型的<em class="le">银行</em>定义类<em class="le">雇员</em>。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="702d" class="lx ly it lo b gy lz ma l mb mc"><strong class="lo iu">class</strong> Employee {<br/>     <strong class="lo iu">let</strong> name: String<br/>     <strong class="lo iu">var</strong> bank: Bank?</span><span id="94f6" class="lx ly it lo b gy md ma l mb mc">     <strong class="lo iu">init</strong>(name: String) {<br/>         self.name = name<br/>     }</span><span id="5115" class="lx ly it lo b gy md ma l mb mc">     <strong class="lo iu">deinit</strong> { <br/>         print("\(name) is deinitialized.")<br/>     }<br/>}</span></pre><p id="7d3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们定义另一个类<em class="le"> Bank </em>，其属性名称为字符串类型，雇员为无主属性(非可选)。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="1fe4" class="lx ly it lo b gy lz ma l mb mc"><strong class="lo iu">class</strong> Bank {<br/>    <strong class="lo iu">let</strong> name: String<br/>    <strong class="lo iu">unowned</strong> let employee: Employee</span><span id="24f8" class="lx ly it lo b gy md ma l mb mc">    <strong class="lo iu">init</strong>(name: String,employee: Employee) {<br/>        self.name = name<br/>        self.employee = employee<br/>    }</span><span id="36e7" class="lx ly it lo b gy md ma l mb mc">    <strong class="lo iu">deinit</strong> { <br/>        print("\(name) is deinitialized.")<br/>    }<br/>}</span></pre><p id="96a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义可选类型的变量<em class="le">和</em>，并设置为实例<em class="le">。然后，将银行实例分配给员工的银行财产。</em></p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="b22b" class="lx ly it lo b gy lz ma l mb mc"><strong class="lo iu">var</strong> ana: Employee? = Employee(name: "Ana")<br/>ana!.bank = Bank(name: "SPI Bank", employee: ana!)</span></pre><p id="faf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们将<em class="le"> ana </em>设置为0时，没有对<em class="le"> Employee </em>实例的强引用，它将被释放。</p><p id="ecef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为没有与<em class="le">库</em>实例的强引用，所以它也将从内存中被释放。</p><pre class="lp lq lr ls gt lt lo lu lv aw lw bi"><span id="f4ea" class="lx ly it lo b gy lz ma l mb mc">ana = <strong class="lo iu">nil</strong></span></pre><p id="44ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">结论</strong></p><p id="427a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">了解Swift中的内存管理如何打破对实例的强引用并避免应用程序中的任何内存泄漏是很有用的。</p><p id="84f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要查找关于iOS开发、Xcode和Swift的最新提示和技巧，请访问<a class="ae kf" href="https://www.gurjit.co" rel="noopener ugc nofollow" target="_blank">https://www.gurjit.co</a></p><p id="6873" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢！</p></div></div>    
</body>
</html>