<html>
<head>
<title>Rapidly Spawn Meshes in Blender via Scripting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过脚本在Blender中快速生成网格</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rapidly-spawn-printable-meshes-via-blender-python-9ff5c3af6379?source=collection_archive---------4-----------------------#2021-04-23">https://levelup.gitconnected.com/rapidly-spawn-printable-meshes-via-blender-python-9ff5c3af6379?source=collection_archive---------4-----------------------#2021-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单的Python快速而干净地制作耗时的零件</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="3d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ks">这是系列文章的第2部分，记录了在模块化系统中构建Blender插件以生成可打印组件的每个步骤，但是这篇文章完全可以独立阅读。</em></p><p id="2f6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ks">TL；DR:底部是完整脚本的要点——相当短&amp;有文档字符串。</em></p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="3874" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我开始使用Blender为电子项目建模3D可打印组件时，一个早期和令人惊讶的挑战是如何为PCB和用螺钉将组件固定在一起的地方制作支架安装点。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/c54dfaf2adf888f42b63c6d33c86ffec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hb0RjQhndU2lxGOZKTmMNg.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">做一个不那么高级的甜甜圈能有多难？</figcaption></figure><p id="f819" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我花了比我想承认的更长的时间来依赖布尔修饰符和处理它们产生的工件和非流形几何图形。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/6593e7fcb0e2584a85317a1a91e45ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjmqokop3lUHzL4hswnC4g.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">线框。这么多线框。每个公制硬件直径的线框。(线框设置位于“对象属性&gt;视口显示”面板中)</figcaption></figure><p id="b621" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某些情况下，使用布尔修饰符仍然是正确的选择，我花在使事情过于复杂上的所有时间都被证明是有用的，可以找到一些技巧来解决非流形问题(即避免使用修饰符)。但对于更有经验的建模者来说，更简单的方法显然是首选，即在对象模式下为其中一个圆周添加圆形网格，将对象切换到编辑模式并添加另一个圆形网格，然后使用“桥边循环”来连接它们。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/406b7c669331da16fd046ee14d16223f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7uz8-W4CNuL0ywsn4U0pzg.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">单个对象中的多个网格&amp;从“添加[一个东西]”菜单中调整网格参数</figcaption></figure><p id="ad28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法可能会生成比严格必要的更多的面，但是因为这里的目标是制造而不是渲染，所以我没有发现它会导致任何性能或输出问题。桥接循环边，并选择所有生成的面，只需将它们挤出到所需的高度，这是一个简单的编写脚本的过程！</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/7a7c01a76869bec8f1d4e43795fb7a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMkmAY-urUebGCGfqzhNuA.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">在编辑模式下(面)—“A”选择全部，“E”拉伸，“数字”选择目标距离，“返回”提交</figcaption></figure><p id="0641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要编写网格操作的脚本，最好使用Blender Python <code class="fe lj lk ll lm b">BMesh</code>模块，而不是直接使用GUI的信息编辑器面板中记录的<code class="fe lj lk ll lm b">bpy.ops.mesh</code>对象。与许多3D对象API相比，<code class="fe lj lk ll lm b">BMesh</code>模块仍然提供对更高阶网格函数的访问，在这些3D对象API中，交互只能通过直接操纵顶点&amp;面索引来进行，但它作为一个后台进程工作，因此避免了重复调用<code class="fe lj lk ll lm b">bpy.ops</code>的额外开销(例如，查看每个添加到活动撤销堆栈)。</p><p id="146e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某些方面，可能对任何有前端开发经验的人都有帮助，<code class="fe lj lk ll lm b">BMesh</code>可以被描绘成像影子DOM一样工作——下面是<code class="fe lj lk ll lm b">BMesh</code> <a class="ae ln" href="https://docs.blender.org/api/current/bmesh.html" rel="noopener ugc nofollow" target="_blank">医生</a>对此的看法:</p><blockquote class="lo lp lq"><p id="c36b" class="jn jo ks jp b jq jr js jt ju jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj kk ij bi translated">“注意，与<code class="fe lj lk ll lm b">bpy</code>不同，BMesh不一定对应于当前打开的混合文件中的数据，BMesh可以被创建、编辑和释放，而无需用户查看或访问它。”</p></blockquote><p id="0fc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用<code class="fe lj lk ll lm b">bmesh</code>时，您可以使用<code class="fe lj lk ll lm b">bmesh.new()</code>在内存中实例化它，然后添加场景中不存在的新几何体，或者通过转换场景中的现有网格，在新实例化的网格上调用<code class="fe lj lk ll lm b">.from_mesh(some_mesh_in_scene)</code>。重要的是要记住，后者从场景中移除网格，因此一旦编辑完成，Python脚本必须释放所有权并将其作为网格放回到场景中。考虑到这一点，我认为遵循这个程序将遵循的步骤会变得容易得多。</p><ol class=""><li id="7f85" class="lu lv iq jp b jq jr ju jv jy lw kc lx kg ly kk lz ma mb mc bi translated">创建一个<code class="fe lj lk ll lm b">BMesh</code></li><li id="6f99" class="lu lv iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">用几何图形填充它</li><li id="611f" class="lu lv iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">转换为场景友好型<code class="fe lj lk ll lm b">Mesh</code></li><li id="c70d" class="lu lv iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">添加到场景</li></ol><p id="c7c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该脚本将结合自定义<code class="fe lj lk ll lm b">Standoff</code>类的<code class="fe lj lk ll lm b">class</code>定义，一个用于挤出在类外定义的平面几何体的函数，因为它不仅对<code class="fe lj lk ll lm b">Standoff</code>类网格有用，还可用于更多形状，一个用于将可编辑的<code class="fe lj lk ll lm b">BMesh</code>转换为<code class="fe lj lk ll lm b">Mesh</code>对象的函数，该对象也将在<code class="fe lj lk ll lm b">Standoff</code>类外定义，以及一个当脚本作为<code class="fe lj lk ll lm b">__main__</code>运行时执行的<code class="fe lj lk ll lm b">test</code>函数。这个测试函数将在场景中添加一个单独的<code class="fe lj lk ll lm b">Standoff</code>网格，并模仿这个模块在集成到一个更大的Blender插件中时的行为。在高层次上，在实现之前编写接口，脚本将如下所示:</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="0d3f" class="mm mn iq lm b gy mo mp l mq mr">import bpy<br/>import bmesh</span><span id="c1a4" class="mm mn iq lm b gy ms mp l mq mr">class Standoff:<br/>    # initializer<br/>    <br/>    # public class method returning Mesh based on current class attr</span><span id="7cc0" class="mm mn iq lm b gy ms mp l mq mr">    # internal class methods creating BMesh with Standoff geometry</span><span id="54a3" class="mm mn iq lm b gy ms mp l mq mr"># def a function for extruding planes to a desired distance</span><span id="9084" class="mm mn iq lm b gy ms mp l mq mr"># def a function for returning Mesh from input BMesh</span><span id="0bcd" class="mm mn iq lm b gy ms mp l mq mr"># def a test function to create a Standoff and add mesh into scene</span><span id="5013" class="mm mn iq lm b gy ms mp l mq mr">if __name__ == "__main__":<br/>    test()</span></pre><p id="8575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要开始这个脚本，导入两个必需的模块:<code class="fe lj lk ll lm b">bpy</code>和<code class="fe lj lk ll lm b">bmesh</code>，并定义<code class="fe lj lk ll lm b">Standoff</code>类:</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="4818" class="mm mn iq lm b gy mo mp l mq mr">class Standoff:<br/>    def __init__(self, name='Std', m_diam=3, depth=3, segments=64):         <br/>        self.name = name<br/>        self.depth = depth<br/>        self.segments = segments<br/>        self.radii = {<br/>            "inner": m_diam/2,<br/>            "outer": m_diam*1.25<br/>            }</span></pre><p id="4751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">设置默认参数似乎是一个很好的保护措施，3似乎是一个合理的数字(到目前为止，M3是我的项目中相当常见的直径)。使用更高的分段数而不是“阴影平滑”给了我很好的打印效果——但肯定有更好的方法，我错过了。因为无论何时更新新的直径，都需要更新<code class="fe lj lk ll lm b">self.radii</code>对象的属性，所以应该将其抽象为一个方法:</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="f675" class="mm mn iq lm b gy mo mp l mq mr">class Standoff:<br/>    def __init__(self, name='Std', m_diam=3, depth=3, segments=64):         <br/>        self.name = name<br/>        self.depth = depth<br/>        self.segments = segments<br/>        self.radii = self.__radii(m_diam)</span><span id="bb67" class="mm mn iq lm b gy ms mp l mq mr">    def __radii(m_diam):<br/>        return { "inner": m_diam/2, "outer": m_diam*1.25 }</span></pre><p id="66cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lj lk ll lm b">Standoff</code>类的一个实例将提供一个<code class="fe lj lk ll lm b">Standoff.mesh(args)</code>接口函数，接受<code class="fe lj lk ll lm b">depth</code>和<code class="fe lj lk ll lm b">m_diam</code>属性的新输入，并返回准备添加到场景中的网格数据。</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="84b7" class="mm mn iq lm b gy mo mp l mq mr">class Standoff:<br/>    # ...<br/>    def mesh(self, depth=None, m_diam=None):<br/>        if depth:<br/>            self.depth = depth<br/>        if m_diam:<br/>            self.radii = self.__radii(m_diam)<br/>        bm = self.__create_drum_bmesh()<br/>        return bmesh_to_mesh(bm)</span></pre><p id="b543" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lj lk ll lm b">__create_drum_bmesh</code>方法为<code class="fe lj lk ll lm b">Standoff</code>类提供了独特的<code class="fe lj lk ll lm b">bmesh</code>几何图形:</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="ad3e" class="mm mn iq lm b gy mo mp l mq mr">class Standoff:<br/>    # ...<br/>    def __create_drum_bmesh(self):<br/>        """<br/>        returns new bmesh instance for current self geom values<br/>        """<br/>        bm = bmesh.new()</span><span id="ca47" class="mm mn iq lm b gy ms mp l mq mr">        to_extrude = self.__make_footprint(bm)<br/>        extrude_faces(bm, to_extrude["faces"], self.depth)</span><span id="3723" class="mm mn iq lm b gy ms mp l mq mr">        return bm</span></pre><p id="fcb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个方法中，<code class="fe lj lk ll lm b">extrude_faces</code>也可以用在任何一组需要挤压的面上…所以它也存在于<code class="fe lj lk ll lm b">Standoff</code>类之外。目前，<code class="fe lj lk ll lm b">Standoff._make_footprint(bm)</code>是最后一个需要定义来启动和运行的类特有的东西。正如在<code class="fe lj lk ll lm b">_create_drum_bmesh</code>中调用的那样，<code class="fe lj lk ll lm b">_make_footprint</code>应该返回一个包含关键字<code class="fe lj lk ll lm b">faces</code>的字典:</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="e3d9" class="mm mn iq lm b gy mo mp l mq mr">class Standoff:<br/>    # ....<br/>    def __make_footprint(self, bm):<br/>        """<br/>        takes bmesh instance,<br/>        returns dict with keys 'faces', 'edges' from<br/>        bmesh.ops.bridge_loops<br/>        """<br/>        def circumference(radius):<br/>            """<br/>            for radius, create circle in bm, return edges list<br/>            """<br/>            edges = []<br/>            circ = bmesh.ops.create_circle(<br/>                bm,<br/>                radius=radius,<br/>                segments=self.segments,<br/>                cap_ends=False<br/>                )<br/>            [ edges.append(e) for v in circ["verts"]<br/>              for e in v.link_edges<br/>              if e not in edges ]<br/>            return edges</span><span id="60f6" class="mm mn iq lm b gy ms mp l mq mr">        edges = [ e for r in self.radii.values() for e in<br/>                  circumference(r) ]<br/>        bridged = bmesh.ops.bridge_loops(bm, edges=edges)<br/>        return bridged</span></pre><p id="fd41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">包装在<code class="fe lj lk ll lm b">circumference</code>函数中的<code class="fe lj lk ll lm b">bmesh.ops.create_circle</code>方法，加上之前在“编辑模式”下向对象添加圆形网格的可视化演示，很好地展示了<code class="fe lj lk ll lm b">bmesh</code> API是如何工作的。对于它们的第一个参数，<code class="fe lj lk ll lm b">bmesh.ops</code>方法引用一个特定的<code class="fe lj lk ll lm b">bmesh</code>实例，就像一个人在编辑模式下与一个网格交互，对这个实例做一些事情，然后返回。与<code class="fe lj lk ll lm b">bpy.ops</code>操作符不同，<code class="fe lj lk ll lm b">bmesh.ops</code>方法通常返回字典，提供对<code class="fe lj lk ll lm b">bmesh</code>的子集或相关修改属性的访问。在<code class="fe lj lk ll lm b">create_circle</code>的情况下，键<code class="fe lj lk ll lm b">"verts"</code>后面有一个已创建顶点的列表。在这种情况下，<code class="fe lj lk ll lm b">circumference</code>函数使用list comprehension来遍历它，获取每个顶点的<code class="fe lj lk ll lm b">link_edges</code> list属性中的边的值，仅追加那些尚未被发现附加到先前迭代的顶点的边。</p><p id="5cf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建内部和外部边，通过调用每个半径值的<code class="fe lj lk ll lm b">circumference</code>函数选择结果边，并使用<code class="fe lj lk ll lm b">bmesh.ops.bridge_loops</code>方法桥接这些边。这个方法返回一个带有<code class="fe lj lk ll lm b">faces</code>和<code class="fe lj lk ll lm b">edges</code>键的字典。</p><p id="fc3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建这个桥接足迹，并返回对其字典的访问，填充了在<code class="fe lj lk ll lm b">_create_drum_bmesh</code>中调用<code class="fe lj lk ll lm b">extrude_from_flat</code>所需的接口。在<code class="fe lj lk ll lm b">Standoff</code>类之外，<code class="fe lj lk ll lm b">extrude_from_flat</code>可以定义为:</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="3fc3" class="mm mn iq lm b gy mo mp l mq mr">def extrude_faces(bm, faces, depth=1.0):<br/>    extruded = bmesh.ops.extrude_face_region(bm, geom=faces)<br/>    verts=[ e for e in extruded["geom"]<br/>            if isinstance(e, bmesh.types.BMVert) ]<br/>    del extruded</span><span id="ba93" class="mm mn iq lm b gy ms mp l mq mr">    bmesh.ops.translate(bm, verts=verts, vec=(0.0, 0.0, depth))</span></pre><p id="25f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lj lk ll lm b">bmesh.ops.extrude</code>方法在<code class="fe lj lk ll lm b">bmesh</code>中创建了额外的几何图形，但是考虑到单一责任原则，它们本身并不转换几何图形。在我看来，这是一个特别容易描绘出<code class="fe lj lk ll lm b">bmesh</code>模块与在GUI中抽象的&amp;Blender操作接口的例子。在许多<code class="fe lj lk ll lm b">bmesh.ops.extrude</code>方法之间有细微的区别(但是在结果上有显著的差异),并且有大量的可选参数来配置它们的行为。</p><p id="52d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦从挤压返回的<code class="fe lj lk ll lm b">geom</code>序列中过滤出<code class="fe lj lk ll lm b">bmesh.types.BMVert</code>实例并将其复制到新创建的列表中，就可以并且应该从内存中删除<code class="fe lj lk ll lm b">extruded</code>对象，以确保<code class="fe lj lk ll lm b">bmesh</code>和结果<code class="fe lj lk ll lm b">mesh</code>保持有效状态。最后，调用<code class="fe lj lk ll lm b">bmesh.ops.translate</code>方法——在这个实例中，通过相对于<code class="fe lj lk ll lm b">bmesh</code>实例的对象矩阵沿z轴的<code class="fe lj lk ll lm b">depth</code>值平移顶点(该方法还接受一个<code class="fe lj lk ll lm b">space</code>参数来设置不同的相对变换原点)。</p><p id="83bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着这个逻辑的完成，所需的隔离几何现在存在于一个<code class="fe lj lk ll lm b">bmesh</code>中，如在<code class="fe lj lk ll lm b">Standoff</code>类初始化器的<code class="fe lj lk ll lm b">bmesh_to_mesh( self._create_drum_bmesh() )</code>调用中返回的。剩下的工作就是实现这个函数，它将处理对一个<code class="fe lj lk ll lm b">bmesh_to_mesh</code>的转换并从内存中清除<code class="fe lj lk ll lm b">bmesh</code>，然后将为<code class="fe lj lk ll lm b">Standoff</code>类实例创建的结果<code class="fe lj lk ll lm b">mesh</code>添加到场景中。在<code class="fe lj lk ll lm b">Standoff</code>类之外，<code class="fe lj lk ll lm b">bmesh_to_mesh</code>可以写成:</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="8ad7" class="mm mn iq lm b gy mo mp l mq mr">def bmesh_to_mesh(bm, me=None):<br/>    if not me:<br/>        me = bpy.data.meshes.new("Mesh")<br/>    bm.to_mesh(me)<br/>    bm.free()<br/>    return me</span></pre><p id="655d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过用一个默认的<code class="fe lj lk ll lm b">me=None</code>参数和一个处理它的条件来编写这个函数，它也可以处理更新一个现有的<code class="fe lj lk ll lm b">Mesh</code>实例。</p><p id="5785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在生产中，将<code class="fe lj lk ll lm b">Mesh</code>添加到场景中会在其他地方处理，所以现在，该操作的一个基本版本可以发生在一个测试函数中，当模块作为main运行时使用:</p><pre class="ku kv kw kx gt mi lm mj mk aw ml bi"><span id="32c8" class="mm mn iq lm b gy mo mp l mq mr">def test(m_diam=2.5, depth=3, name="Standoff"):<br/>    def add_mesh_to_collection(me, name): <br/>        """<br/>        gets reference to collection in active bpy.context,<br/>        creates new object with 'me' Mesh arg as obj data value<br/>        links created object into referenced collection<br/>        """</span><span id="74fc" class="mm mn iq lm b gy ms mp l mq mr">        collection = bpy.context.collection.objects<br/>        obj = bpy.data.objects.new(name, me)<br/>        collection.link(obj)<br/>        return obj</span><span id="d207" class="mm mn iq lm b gy ms mp l mq mr">    std = Standoff(m_diam=m_diam, depth=depth, name=name)<br/>    add_mesh_to_collection(std.mesh(), std.name)</span><span id="f302" class="mm mn iq lm b gy ms mp l mq mr">if __name__ == "__main__":<br/>    test()</span></pre><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/5553649295be3b3b9830701f871361c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IfveRP-BvesTyWBCntFraw.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">通过脚本创建，3D打印工具-&gt;分析菜单显示干净的流形几何图形，因为使用了正确的' bmesh.ops.extrude '任务方法。</figcaption></figure><p id="7290" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里开始，这个<code class="fe lj lk ll lm b">Standoff</code>类可以被扩展来创建稍微复杂一点的几何图形，并允许通过UI菜单动态调整模型——但是这些将在单独的文章中讨论。本系列的下一篇文章将记录如何创建一个附加组件，在一个定制的Blender UI元素后面注册这个脚本，配置为传递<code class="fe lj lk ll lm b">metric_diameter</code>、<code class="fe lj lk ll lm b">depth</code>和<code class="fe lj lk ll lm b">segments</code>参数的可调值。</p><p id="5d73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，完整的要点如下——感谢您的阅读，以及对如何改进我的代码或解释的任何意见。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div></div>    
</body>
</html>