<html>
<head>
<title>Learning C++: An Overview of the Containers of the STL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL容器概述</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-an-overview-of-the-containers-of-the-stl-72e736ae5c33?source=collection_archive---------15-----------------------#2020-04-09">https://levelup.gitconnected.com/learning-c-an-overview-of-the-containers-of-the-stl-72e736ae5c33?source=collection_archive---------15-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0e291156ad215947351835a485389083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WhoiJw6eCdAsOm3d"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@jpvalery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jp Valery </a></figcaption></figure><p id="a769" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标准模板库(STL)包含一组用于存储数据的容器(数据结构)。这些容器与STL的算法一起使用，以解决各种计算机处理问题。在本文中，我将概述STL中的三个容器类别，并简要讨论这些类别中的容器的细节。我还有其他文章更详细地讨论了这些容器。你可以在我的网站上找到它们。</p><h1 id="abc3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">STL容器类别</h1><p id="4b85" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">STL中的三类容器是:<em class="mh">序列</em>、<em class="mh">关联</em>和<em class="mh">适配器</em>。序列容器按顺序存储数据，顺序通常非常重要。例如，可能需要从最低到最高显示一组等级，因此将等级存储在序列容器中是必要的。</p><p id="789b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关联容器存储与其他数据相关联的数据。例如，一个联系人列表(我几乎用过电话簿，但意识到那让我听起来很老)存储了名字和与这些名字相关的电话号码。另一个例子可能是一个简单的库存，库存中的商品数量与一个商品名称相关联。</p><p id="b6b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">容器类别的第三种类型是适配器。适配器容器是其他类别之一的变体。两个经典的例子是栈和队列，我将在本文后面讨论。</p><p id="466d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我开始讨论序列容器之前，我需要花一点时间讨论一下它们与原始(在内置的意义上)数组的使用。多年来，即使在STL变得可用之后，程序员仍然坚持使用数组来满足大多数数据存储需求。这种偏好很大程度上是因为与STL容器相比，数组的效率有所提高，尽管使用数组会因其大小不灵活而产生问题。随着STL变得更加高效，内置数组相对于STL容器的这种优势现在基本上消失了。甚至像比雅尼·斯特劳斯特鲁普这样的权威也建议程序员在几乎所有的应用程序中选择向量(一个STL序列容器)而不是原始数组。</p><h1 id="bd8f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">序列容器</h1><p id="a646" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">序列容器是数据的有序集合，其中数据通常存储在连续的存储器位置中。一些序列容器中的数据可以被随机访问，但并非所有的序列容器都是如此。</p><p id="c738" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最常用的序列容器是<code class="fe mi mj mk ml b">vector</code>类。与原始数组相比，使用向量有几个优点。最重要的优点是，一个向量可以按照程序员的意愿增长和收缩。原始数组有一个固定的大小，如果不复制或使用动态内存就不能改变。vector的另一个优点是它有一个size函数，返回存储在vector中的元素数量。这意味着您可以使用向量作为函数参数，而不必像原始数组那样将向量的大小作为第二个参数。仅这两个优点就使vector成为大多数顺序数据存储需求的首选容器。</p><p id="dc6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个顺序容器是<code class="fe mi mj mk ml b">deque</code>类。这个容器就像一个动态数组，您可以在末尾或开头添加数据。这意味着，如果您的应用程序需要将数据添加到前端和后端，那么deque可能是一个很好的容器。但是，如果需要频繁地将数据添加到中间，就不要使用它，因为这需要上下移动元素来为新数据腾出空间。</p><p id="d7d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">STL也有一个<code class="fe mi mj mk ml b">array</code>类。这个类模仿了原始数组，但也有一些优于它的地方。例如，该类有一个您可以使用的<code class="fe mi mj mk ml b">size</code>函数，这样您就不需要将它与数组一起传递给函数，而您必须用原始数组来传递。</p><p id="7b71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">list</code>类是一个顺序容器，具有链表的行为。这意味着当您需要频繁插入或删除时，列表是一个很好的容器，因为列表插入或删除只涉及重新分配链接或删除不再需要的链接，而不是移动元素来为插入腾出空间或从删除中回收空间。<code class="fe mi mj mk ml b">list</code>类是一个双向链表，这样你可以在列表中向前或向后移动。</p><p id="632e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">forward_list</code>类是一个单向链表，只允许向前移动。这个类没有多大用处，因为它不提供list类的功能，而且由于单链表的性质，有些函数效率很低。但是，当您希望快速遍历列表的开头和结尾时，可以使用该类。</p><p id="f939" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就结束了STL序列容器的概述。关于这些容器的更深入的报道，请参阅我的其他文章。</p><h1 id="16fa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">关联容器</h1><p id="5e98" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">关联容器是一种根据某种排序标准自动对其元素进行排序的容器。存储在关联容器中的数据可以是任何类型的值，也可以是任何类型的键/值对。对于键控容器，一个键直接映射到一个值。</p><p id="4512" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将回顾的第一个关联容器是<code class="fe mi mj mk ml b">set</code>类。集合是根据值排序的唯一值的容器。集合通常由小于运算符(<code class="fe mi mj mk ml b">&lt;</code>)排序，这意味着集合的正常排序顺序是升序。将重复项放入集合的尝试将会失败。</p><p id="0372" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有另一个类<code class="fe mi mj mk ml b">multiset</code>，它允许重复，但具有与set类相同的排序行为。</p><p id="e92d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">map</code>类是一个关联容器，它以键/值对的形式存储数据。映射条目的键可以是任何数据类型，与该键相关联的值也可以是任何数据类型。<code class="fe mi mj mk ml b">map</code>类的实例通常被称为关联数组，因为一个映射的行为就像一个带有非整数索引的数组。当映射名用键“索引”时，它返回用键存储的值。映射的一个重要特征是不允许重复键。</p><p id="cb50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果需要一个包含重复键的容器，可以使用<code class="fe mi mj mk ml b">multimap</code>类。多映射可以用作字典，因为字典可以让同一个单词有多种含义，所以多映射可以让同一个键与多个值相关联。</p><p id="051e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是STL中的关联容器。set和map类是最常用的，除非必须存储非唯一数据。</p><h1 id="2359" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">适配器容器</h1><p id="ff95" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果一个容器为特定目的采用了更通用的容器类型，那么它就是容器适配器。适配器容器类是<code class="fe mi mj mk ml b">stack</code>、<code class="fe mi mj mk ml b">queue</code>和<code class="fe mi mj mk ml b">priority_queue</code>。</p><p id="7a08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">stack</code>类实现了一个特殊的容器，只允许后进先出(LIFO)访问。这是通过具有有限数量成员函数的类接口来实现的。使用<code class="fe mi mj mk ml b">push</code>函数将新数据值添加到堆栈中。使用<code class="fe mi mj mk ml b">pop</code>功能从堆栈中移除数据值。使用<code class="fe mi mj mk ml b">top</code>功能查看栈顶值。这是堆栈中唯一可以查看的元素。除了一些其他的实用函数，这些是唯一可以在堆栈上执行的操作。</p><p id="c037" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">栈在计算机科学中有很多应用，比如在解释器和编译器中的作用域操作，以及在其他领域，比如实现逆波兰符号算法。</p><p id="8d37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">queue</code>类实现了一个容器，该容器模拟数据缓冲区的操作或存储中的行。队列允许先进先出(FIFO)访问。使用<code class="fe mi mj mk ml b">push</code>函数将新数据放入队列中。使用<code class="fe mi mj mk ml b">front</code>功能检查队列的前面，使用<code class="fe mi mj mk ml b">back</code>功能检查队列的后面。函数的作用是:从队列中移除一个值。</p><p id="e22a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">队列在计算机科学(数据缓冲区)和模拟中有应用，其中客户活动(商店排队)需要建模。</p><p id="11f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">priority_queue</code>类类似于queue类，但是元素被放入基于排序标准的优先级队列中，该排序标准可以在声明优先级队列时提供。如果没有提供分类标准，则使用<code class="fe mi mj mk ml b">less</code>。</p><p id="1e7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mi mj mk ml b">push</code>函数将数据放入优先级队列，使用<code class="fe mi mj mk ml b"> pop </code>函数移除数据，但仅提供<code class="fe mi mj mk ml b">top</code>函数用于检查优先级队列的内容(前端元素)。</p><p id="c3a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">优先排队的一个典型例子是医院急诊室的排队。病人根据病情的严重程度排队等候，以便病情最重的病人先得到治疗。</p><h1 id="7e21" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">STL容器并不全面</h1><p id="76a4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">并不是每一个经典的计算机科学数据结构都是由STL实现的，但是所提供的容器将涵盖您将会遇到的大多数应用程序。虽然您可能已经在学校中实现了这些容器中的一部分或大部分，但是我们建议您只在C++程序中使用这些实现，因为它们肯定比您自己构建的任何东西都更有效。</p><p id="0b57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我还没有详细介绍本文中提到的任何容器，但是请查看我已经发表的文章或以后的文章，了解所有这些STL容器的详细介绍。</p><p id="394f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>