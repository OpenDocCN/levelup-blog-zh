<html>
<head>
<title>How Experienced Developers Use Enums in APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有经验的开发人员如何在API中使用枚举</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-experienced-developers-use-enums-in-apis-7798504e1857?source=collection_archive---------2-----------------------#2022-09-15">https://levelup.gitconnected.com/how-experienced-developers-use-enums-in-apis-7798504e1857?source=collection_archive---------2-----------------------#2022-09-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="fcff" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated"><strong class="ak">你应该在API中使用枚举的3个理由</strong></h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c99bf6059ef7b3bbb0b31c15582e6981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGUEhRKzBBM8L5-lty9Q8A.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://www.pexels.com/photo/a-man-writing-on-the-mirror-6914015/" rel="noopener ugc nofollow" target="_blank">来自Pexels的马体·米罗什尼琴科的照片</a></figcaption></figure><p id="f99c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你在API中使用枚举。<strong class="lc iv"> <em class="lw">但这是好的做法还是不好的做法？</em>T9】</strong></p><p id="fd79" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">到目前为止，API中的枚举没有任何问题。那么枚举有什么问题呢？为什么不能随心所欲的使用enums？</em></p><p id="6cfc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来区分不同的API，以及枚举如何适应每种API。同样，让我们看看生产API中的枚举。</p><p id="881a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这样我们就能更清楚地了解如何在API中使用枚举。另外，在API中哪里需要注意枚举</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="ca38" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">REST API中的枚举忽略了什么？</h1><p id="c527" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated"><strong class="lc iv"> <em class="lw">你要从API客户端鞋想。</em>T15】</strong></p><p id="f764" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">您希望获得新的枚举值还是普通的旧字符串值？你会如何处理每一个问题？枚举和字符串哪个更让你头疼？</em></p><p id="0956" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">添加新的枚举值会给客户端带来问题。他们需要为这个新值添加更多的映射。</p><pre class="kk kl km kn gu nb nc nd ne aw nf bi"><span id="d47b" class="ng mf iu nc b gz nh ni l nj nk">public enum MyEnum {<br/>     @JsonProperty("theFirstValue") THE_FIRST_VALUE,<br/>     @JsonProperty("another_value") ANOTHER_VALUE;<br/>     // another one here, or delete the previous ones<br/>}</span></pre><p id="b466" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="lw">如果这是一个字符串就不存在这个问题了。</em> </strong>你可以解析任何字符串并继续前进。您不会担心解析异常。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="c3bf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你实现你的API时，你可能会忽略客户端。 毕竟，你在实现端安然无恙。定义枚举并实现所需的行为。</p><p id="5d66" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">枚举可以作为API输入。T29】</p><p id="787d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">持有枚举的请求是好的，因为我们对它们负责。您可以为每个枚举值实现策略，或者随意使用它们。你不会像客户那样崩溃。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="2ddd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在服务器端使用枚举的一种方法是创建<em class="lw">可变</em>属性。这里有一个例子。</p><pre class="kk kl km kn gu nb nc nd ne aw nf bi"><span id="078a" class="ng mf iu nc b gz nh ni l nj nk">public enum AddressType { <br/>    HOME(true),<br/>    WORK(false),<br/>    OTHER(true);</span><span id="3ee7" class="ng mf iu nc b gz nl ni l nj nk">    private AddressType(boolean businessLogicCondition) {<br/>        this.businessLogicCondition = businessLogicCondition;<br/>    }</span><span id="ffd9" class="ng mf iu nc b gz nl ni l nj nk">    private final boolean businessLogicCondition;</span><span id="dd79" class="ng mf iu nc b gz nl ni l nj nk">    public boolean getCond() {<br/>        return businessLogicCondition;<br/>    }<br/>};</span><span id="2cb1" class="ng mf iu nc b gz nl ni l nj nk">@Entity<br/>public class Person {</span><span id="f7ca" class="ng mf iu nc b gz nl ni l nj nk">@Enumerated<br/>private AddressType address;</span><span id="d3ef" class="ng mf iu nc b gz nl ni l nj nk">// ...</span><span id="d940" class="ng mf iu nc b gz nl ni l nj nk">}</span><span id="b435" class="ng mf iu nc b gz nl ni l nj nk">// you can use it after inflation in your code where needed <br/>Person p1 = service.getPersonById("123");<br/>if(p1.getAddress().getCond()) { /*...*/ }</span></pre><p id="cc56" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Hibernate用一个enum字段来扩充实体。您将获得隐藏了<code class="fe nm nn no nc b">businessLogicCondition</code>的<code class="fe nm nn no nc b">AddressType</code>枚举。这使得这个字段不可变，除非你改变枚举本身。 </p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="3e7e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">在生产API中哪里可以看到这种做法？</em>我们来看看Google People API。</p><p id="cda4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您仍然可以在API的两边看到枚举。请求和响应都有枚举。</p><p id="a659" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即便如此，在回复中，<strong class="lc iv"><em class="lw"/></strong><strong class="lc iv"><em class="lw">枚举※</em></strong><a class="ae kz" href="https://developers.google.com/people/api/rest/v1/people#agerange" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv"><em class="lw">在某些情况下得到弃用</em> </strong> </a>。我们看到对象类型被表示为枚举。对象类型很好，因为你不会经常改变对象，而且类型的选择有限。</p><p id="9f0c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还可以看到，响应不包含枚举。一个例子是地址资源和类型字段。我们看到了可能的预定义值，但没有枚举。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj np"><img src="../Images/85d42903aaec1fd68781f616681ab5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qD2SiSJ78XR5oKWvMDKFqg.png"/></div></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="c663" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你不应该忽略以下几点:</p><p id="84a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="lw">输入可以包含Enum作为参数，响应应该非常小心地使用它们。</em> </strong></p><h1 id="a646" class="me mf iu bd mg mh nq mj mk ml nr mn mo ka ns kb mq kd nt ke ms kg nu kh mu mv bi translated">gRPC API中的枚举是一个问题吗？</h1><p id="ac43" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">你也可以在gRPC世界里推广这个想法。那么枚举在gRPC方法中是个问题吗？</p><p id="b4e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">枚举的唯一问题是默认值。 </p><p id="0302" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">零是gRPC枚举的默认值。这意味着零必须是一个默认值，或者是一个未知值。你可以在几乎每个API中看到这一点，它要么是未知的，要么是无法识别的值。</p><p id="92a5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你应该知道空字段会被默认值填充。T25】</p><p id="a792" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，如果客户端没有为enum发送任何字段值，它将获得默认值。您必须在API服务器端意识到这一点，这样您就不会得到无效的行为。FieldMasks可以过滤请求并挑选必要的字段。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="0436" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://medium.com/codex/should-your-api-use-enums-340a6b51d6c3" rel="noopener"> Ted还提到了类似RPC的SDK API中的</a>枚举。对于这些类型的API，两端都有一些问题。</p><p id="d038" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">For SDK枚举很好，因为你可以免费获得自动完成功能。对于OpenAPI客户端，这是有问题的，因为它们没有正确的描述。</p><p id="2081" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于RPC接口，客户端获得<a class="ae kz" href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Enum" rel="noopener ugc nofollow" target="_blank">生成的枚举类</a>。所以就像SDK里的用法一样。这意味着将它同时用作API的输入和输出并没有错。</p><p id="edae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，静态类型语言中的枚举不会引起问题。对于其他客户，他们可能会。例如，在Typescript <a class="ae kz" href="https://www.executeprogram.com/blog/typescript-features-to-avoid" rel="noopener ugc nofollow" target="_blank">中，enum的变化不支持开发人员在refactors </a>中的工作。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="c305" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在gRPC代码中使用枚举应该没有任何问题。您将获得所需的支持，同时也会遇到编译时的失败。</p><h1 id="6c3a" class="me mf iu bd mg mh nq mj mk ml nr mn mo ka ns kb mq kd nt ke ms kg nu kh mu mv bi translated">添加枚举会破坏API吗？</h1><p id="0dfe" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在API中使用枚举如何影响这三个API原则:</p><ul class=""><li id="fd6c" class="nv nw iu lc b ld le lg lh lj nx ln ny lr nz lv oa ob oc od bi translated"><em class="lw">什么都不带走</em></li><li id="2f36" class="nv nw iu lc b ld oe lg of lj og ln oh lr oi lv oa ob oc od bi translated"><em class="lw">不要重新定义API </em></li><li id="f24d" class="nv nw iu lc b ld oe lg of lj og ln oh lr oi lv oa ob oc od bi translated"><em class="lw">添加可选内容</em></li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oj"><img src="../Images/f5fd4e79e61b3b045adac11a82c62b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOkMn_E31wcSRHBY4enuMw.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://medium.com/pragmatic-programmers/table-of-contents-38e94a9476f2" rel="noopener">来源</a></figcaption></figure><p id="685b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="lw">假设您从API响应中移除了enum。你会打破什么都不带走和重新定义事物的原则。</em></strong></p><p id="e86a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你添加了一个枚举，你就没有选择添加。这也需要在客户端进行解析。</p><p id="5376" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="lw">假设你用string代替。</em> </strong>你可以呈现一些预定义的值，并允许附加值。我们可以在谷歌人的地址栏类型中看到这一点。</p><p id="561f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于gRPC或SDK APIs来说，这些原则并没有被打破，因为它们有客户端的支持。一旦你更新了SDK，你就会发现问题并知道如何改正。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="151f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在HTTP响应中有一个有趣的枚举怪癖。</p><p id="9e6c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如我们前面看到的，枚举不适合作为响应字段。即便如此，真正的常量字段也可以作为响应字段。我们都知道的一个例子是<code class="fe nm nn no nc b">HttpStatus</code>枚举。但是这个枚举能产生什么影响呢？</p><p id="0510" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="lw">枚举可能会增加内存占用。</em>T24】</strong></p><p id="1b66" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果枚举在每个响应中都被解析，那么它们可能会成为瓶颈。 这是导致内存占用的响应枚举的问题。</p><div class="ok ol gq gs om on"><a href="https://github.com/spring-projects/spring-framework/issues/26842" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fp"><div class="op ab oq cl cj or"><h2 class="bd iv gz z fq os fs ft ot fv fx it bi translated">HttpStatus.resolve在每次调用时分配一次HttpStatus.values()问题#26842 …</h2><div class="ou l"><h3 class="bd b gz z fq os fs ft ot fv fx dk translated">我刚刚注意到，查看我们运行的一些基于反应器的性能指标评测的配置文件来测量Datadog tracer开销…</h3></div><div class="ov l"><p class="bd b dl z fq os fs ft ot fv fx dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb kt on"/></div></div></a></div><p id="03c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">枚举状态代码解析为枚举值以恒定的速率分配内存。解决方案是使用<a class="ae kz" href="https://github.com/spring-projects/spring-framework/commit/7f1062159ee9926d5abed7cadc2b36b6b7fc242e" rel="noopener ugc nofollow" target="_blank">枚举值缓存</a>。</p><p id="edc7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在回应中使用枚举不是小事，应该从不同的角度来看。 </p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="93c0" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">相关文章</h1><p id="1ee0" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">你的API应该使用枚举吗？枚举值是一个聪明的… |作者Ted Spence | CodeX | Medium </p></div></div>    
</body>
</html>