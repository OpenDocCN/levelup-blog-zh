# 如何发现错误的抽象

> 原文：<https://levelup.gitconnected.com/how-to-spot-the-wrong-abstraction-2c0f1cecb07e>

## 为什么干涸需要被淹没

![](img/93b91582286c3bc9624f53f61382d2df.png)

由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的[图板](https://unsplash.com/@aplaceforcreation?utm_source=medium&utm_medium=referral)拍照

DRY 是一个代码缩写，是我们自己的**D**on t**R**EPE at**Y**的缩写，我对此颇有微词。我职业生涯中一些最痛苦的工作都围绕着收拾铁杆干从业者留下的烂摊子。

这是一个有用的心理模型。有点像开车。通过学习一个踏板使你前进，另一个踏板使你停止，轮子使你转向，你可以最快地站起来跑。你不需要了解发动机是如何工作的，刹车是如何工作的，或者汽车是如何抓地的。这种思维模式首先会很好地为你服务。直到你在寒冷的日子里开车。然后你踩下踏板停下来，你继续前进。

DRY 是编码的走走停停。这是一个有效的、有用的考虑代码的模型，但是它是对现实的简化，并且它也可能把你引入一个危险的事故中。我写这篇文章的原因是，我一次又一次惊讶地看到它出现在职位描述中——通常是高级和领导职位。

并不是资深开发者都在纠结干不明白。随着你经验的增长，你会对它的含义有更细微的理解。我的问题是，微妙的理解与缩写相矛盾。更像是有时候重复自己。

## 干旱逆火时

下面是一个简单但真实的例子，展示了 DRY 在本地化文件中的样子:

我举这个例子，因为我曾经继承了一个有这个问题的项目，并且必须本地化。这是纯干的。整个代码库都是这样。我也会在模板文件中找到连接在一起的字符串。字符串是重复的，所以它被抽象成一个变量。不幸的是，它也失去了拥有本地化文件的意义。并非所有语言都使用相同的句子结构，因此该网站无法再进行本地化。我不得不通过撤销所有的抽象。这里的问题是内容重复，但语境不同。这是错误的抽象。

这里有一个更复杂的例子:

我做了错误的抽象。我创造了一个怪物。

这段代码可能会导致一些错误。首先，当名字和姓氏连在一起时，名字和姓氏之间没有空格。想象一下被分配到那张票。两个名字之间缺少空格。这应该很容易解决，对不对？疯狂的是，当你孤立地看 addV3 时，并不明显它出了什么问题。如果有人要求你解决这个问题，你会怎么做？如果你时间紧迫，你可以添加一个 if (typeof a === 'string ')条件。问题变得越来越糟。

addV3 函数中没有任何内容表明该函数为何如此背后的*上下文*。为什么当它是一个数的时候它是+1？谁知道呢？

现在想象它是这样发生的:

简单多了。这一切都是因为我认识到，尽管我的原始函数能够将数字和字符串相加，但这些用例并没有上下文关联。巧合的是，同一个函数可以解决这两个问题。

有些情况下，使用相同的函数来添加数字和连接字符串是有意义的。如果您必须处理一个糟糕的第三方 API，它可能返回数字或字符串，您必须编写一个函数来处理这两种情况。但你不会称之为 add。你可以把它叫做 addTwoThingsFromTheTerribleAPI，它提供了为什么这两件事被同一个函数处理的上下文。他们在一起还有一个*原因——而不仅仅是“因为天气干燥”。*

重复桑迪·梅斯的一句精彩的[名言:](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)

> 复制比错误的抽象要便宜得多

在上面的例子中，很清楚每个函数在做什么。如果你决定把重复的相加部分提取出来，你会很容易做到。在上面的例子中，想象一下试图解开 addV3 函数——或者用它做任何事情。

## 发现错误的抽象

开发人员被训练去寻找重复。事实上，人类通常非常善于发现重复的模式。根据我的经验，很难发现错误的抽象。下面有一些半有用的指标，但它们不是铁一般的规则:

1.  函数中有许多条件和早期回报。
2.  (如果有静态类型)复杂/模糊的参数或返回类型。
3.  向函数提供了大量参数。
4.  很多可选参数。

所有事情都可能因为正当的理由而发生，但它们可能是一个警告信号。如果你知道任何其他人请让我知道，我很乐意建立一个全面的名单。

## 修复错误的抽象

这是一个噩梦般的场景。解开任何抽象总是一个痛苦的过程。如果你幸运的话，你可能有单元测试来帮助你理解它被使用的所有可能的方式。否则，您必须了解代码库中引用它的每个地方，并在此基础上进行重构。一旦你知道了它被引用的所有地方，你就可以开始隔离哪些是相同目的的真正重复，哪些是被错误地抽象出来的独立的东西。

## 结论

有一个与之竞争的首字母缩略词 WET，意思是把所有东西都写两遍。这个想法是，直到你重复第三次或第四次，你才进行抽象。我认为这也没有抓住它。

这里有一个秘密:重复不是 DRY 试图解决的问题。重复不会让我们付出任何代价。我们又不是手写出来的。对于 web 来说，这是一点点浪费的文件膨胀，但是一旦它被缩小和压缩，就不会太多了。

我们试图解决的问题是，如果你改变你的代码——为了一个特性或者一个 bug——你不希望在 20 个不同的地方做同样的改变，这些改变随着时间的推移会变得不同步。所以你需要问自己的问题是:

> 所有这些用例会一起改变吗？

或者通常是这样的:

> 不要重复会一致改变的代码。

这就是为什么它变得复杂——也是为什么 DRY 不是一个好的心智模型。因为你无法预测未来。你必须根据经验做出有根据的猜测，以我的经验来看，猜测它不会一致变化会更好，除非你有很好的理由认为它会。我宁愿有一两个我可以重构的重复，而不是一个抽象的怪物。

我上面给出的抽象本地化的例子很好地演示了如何做错。对本地化文件最有可能的改变是翻译它。在这种情况下，单个单词不会一致变化，所以你不应该抽象它。

我想想出另一个缩写，但我想不出一个。我能想到的最好的办法是,**D**on**R**EPE at c**O**de that**W**I I I u**N**ison...可能是什么时候重复自己，什么时候不重复自己的复杂性太难用几个字母来描述。

祝一切顺利，
尼克