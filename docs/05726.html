<html>
<head>
<title>Be Careful With Lombok</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小心龙目岛</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/be-careful-with-lombok-2e2edfc01110?source=collection_archive---------1-----------------------#2020-09-26">https://levelup.gitconnected.com/be-careful-with-lombok-2e2edfc01110?source=collection_archive---------1-----------------------#2020-09-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="912f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Lombok是一个很棒的Java库。它有助于减少“基础设施代码”的数量。您不再需要编写构造函数、获取函数、设置函数，甚至构建函数。你所要做的就是添加适当的注释，插件会为你生成一切。它有助于开发人员专注于业务逻辑。但是我认为过度使用Lombok可能会导致一些问题，使代码更加耦合和复杂。大家说说吧。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/021e6cb4d823e90d74dab589c998e21e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BO0ravxQ3SdlSe5l_RZELA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">阿什利·巴茨在<a class="ae le" href="https://unsplash.com/s/photos/labyrinth?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9b85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我看来，龙目岛不是银弹有几个原因。我们将从最不重要的几点开始。</p><h2 id="021c" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">0.附加依赖性</h2><p id="5839" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">尽管Lombok很方便，但它仍然是项目的一个附加依赖项。不仅如此，它还迫使其他开发人员在他们的ide和代码编辑器中安装一个特殊的插件。否则，Lombok用法就成了障碍，而不是蹦床。</p><blockquote class="md me mf"><p id="a0f4" class="jq jr mg js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">现在这不是什么大问题。你只需点击几次就可以安装所需的插件。说到附加的依赖项，Lombok是一个编译时库。因此，在运行时不需要它，它不会影响包的大小。所以我才把这些理由放在零的位置。它们没什么大不了的。</p></blockquote><h2 id="93e4" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">1.巨大的耦合</h2><p id="61d7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">让你的组件尽可能独立是一个好习惯。通常，可以通过接口来完成。接口是调用代码和底层实现之间的屏障。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mk"><img src="../Images/49ec2013e258befacdbafc19ffb40c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKhmbhcmxnarP5bHY0fcIA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">从底层细节中分离出来</figcaption></figure><p id="1d98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，商业逻辑并不依赖于底层细节。但是如果我们使用Lombok会发生什么呢？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ml"><img src="../Images/cb0bd71d495291047caef6cf3aed2b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ki7SK4d0H3fcHHDCat2AUQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">与龙目岛的巨大耦合</figcaption></figure><p id="545c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几乎我们系统中的每一个类都依赖于Lombok。为什么不好？</p><p id="36fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们不知道龙目进化的下一步是什么。也许下一个主要版本会打破向后兼容性。这将使得无法升级依赖关系，并迫使您使用将来会停止维护的旧依赖关系。</p><p id="4ed6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，如果你感染了病毒怎么办？这意味着它不会出现在一个孤立的模块中，而是出现在整个应用程序中。不是最好的开发者日。</p><p id="a913" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，如果许可证改变了怎么办？甚至现在龙目岛也提供某种<a class="ae le" href="https://projectlombok.org/tidelift" rel="noopener ugc nofollow" target="_blank">企业订阅</a>。也许再过几年，整个图书馆都会商业化。没人知道。</p><h2 id="72d6" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">2.代码缩减</h2><p id="e073" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Lombok最大的优势就是减少了你需要编写的代码量。看看这两个dto(数据传输对象)就知道了。第一个仅使用纯Java声明，第二个使用Lombok注释。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">没有Lombok注释的DTO示例</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">带有龙目岛注释的DTO示例</figcaption></figure><p id="bef9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不仅如此，我们还可以进一步减少代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">带有值注释的DTO示例</figcaption></figure><p id="c775" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不用说，最后两个选项看起来更简洁，也更容易理解。我们没有直接在代码中添加构造函数和getters，而是放入元信息，告诉我们所有必要的东西都将被生成。</p><p id="b06b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是它隐藏了我们的班级变得太大太复杂的事实。不仅如此，从Spring 4.3开始，它的影响甚至更大。如果一个bean有一个接受所有必需依赖项的构造函数，就没有必要在它上面放<code class="fe mo mp mq mr b">@Autowired</code>。所以，我们可以用Lombok注释代替它。</p><p id="3bb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有一个典型的弹簧控制器。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">带Lombok的控制器</figcaption></figure><p id="a6fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们想想办法。这个类有没有太多耦合？嗯，好像不是。只有<em class="mg">六</em>行的依赖关系。让我们摆脱龙目岛，看看会发生什么。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">不带Lombok的控制器</figcaption></figure><p id="14c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想现在你已经开始感到不舒服了。这个类的功能一点也没有改变，但是现在你可以看到它的耦合。在我看来，这是龙目岛最危险的事情之一。它<em class="mg">隐藏了</em>无处可去的复杂性。</p><p id="a1cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">巨大的构造函数的存在表明有些事情不对劲。也许班级太大或者责任太大。Lombok把它缩成一行。我见过有10个甚至15个依赖项和一个<code class="fe mo mp mq mr b">@AllArgsConstructor</code>注释的类。开发人员没有发现任何问题，因为他们没有感受到复杂性。</p><h2 id="9820" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">3.建设者</h2><p id="5540" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">建筑商怎么了？其实什么都不是。这是一个很好的设计模式，但经常被错误地使用。我认为Lombok的过度使用是原因。</p><p id="f092" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Java没有带默认值的命名参数和可选参数。因此，开发人员需要一些变通办法。这就是建筑工人到来的时刻。假设我们有一个用户DTO。我们希望<code class="fe mo mp mq mr b">role</code>字段有一个默认值。如果还没设置，应该是<code class="fe mo mp mq mr b">Role.GUEST</code>。这里有一个简单的例子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">构建器示例</figcaption></figure><p id="4c51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是它的使用方式。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">构建器使用示例</figcaption></figure><p id="b747" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个非常方便的方法，但是看看我们写的代码量。该逻辑不可重用。因此，如果我们有几个需要构建器的类，我们将需要反复编写几乎相同的代码片段。那将是乏味的。幸运的是，Lombok为我们提供了一种不那么冗长的方式来声明构建器。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">龙目岛建造者</figcaption></figure><p id="4cdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！仅仅几个注解，我们就达到了同样的结果。</p><p id="942e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们回到前面的问题。假设我们有一个巨大的DTO。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">巨大的DTO</figcaption></figure><p id="c89c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实例化是这样的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用构造函数的用户实例化</figcaption></figure><p id="0d81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，论点的意思不清楚，因为它们太多了。嗯，我们可以用<code class="fe mo mp mq mr b">@Builder</code>代替<code class="fe mo mp mq mr b">@RequiredArgsConstructor</code>。让我们看看会发生什么。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用构建器进行用户实例化</figcaption></figure><p id="e932" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法看起来更好。然而，有一个不明显的问题。如果我们忘记向构造函数传递参数，代码将无法编译。而建筑商呢？假设我们没有设置<code class="fe mo mp mq mr b">age</code>。或者也许有人给<code class="fe mo mp mq mr b">User</code>添加了另一个字段。会发生什么？什么都不会。这才是重点。构建器允许我们省略值，而构造器不允许。有时这是意料之中的行为。另一方面，如果它要求设置所有的值，构建者可能会带来问题。</p><p id="602e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们该怎么办呢？首先，这个班级太大了。我们应该把它分成几个小的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">具有分割子类别的用户</figcaption></figure><p id="e49d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以直接实例化<code class="fe mo mp mq mr b">User</code>了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用构造函数的用户实例化</figcaption></figure><p id="82cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有人可能会说，这种方法看起来不如前面的构建器方法漂亮。我同意你的观点。但是构造函数最大的优点是它有严格的不能被打破的界限。与构造器不同，构造器不允许我们将不完整的对象传递给客户端。</p><h2 id="f558" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">4.龙目岛会带来虫子</h2><p id="65b1" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Spring Boot能够直接将<code class="fe mo mp mq mr b">application.properties</code>绑定到dto。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">应用程序.属性</figcaption></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">数据库配置</figcaption></figure><p id="2d9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不仅如此，Spring Boot还有更强大的功能。它可以基于配置类自动生成元数据。您所要做的就是为<code class="fe mo mp mq mr b">spring-boot-configuration-processor</code>添加依赖关系。例如，这就是我们将从<code class="fe mo mp mq mr b">DatabaseConfig</code>类中得到的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Spring元数据</figcaption></figure><p id="27e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个JSON用于为我们的属性实现自动完成。</p><p id="9fe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不管怎样，我们为什么要手动声明getters和constructor？我们有龙目岛。让我们解决这个问题。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用Lombok的数据库配置</figcaption></figure><p id="28de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，一切都应该是一样的，对吗？</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">断掉的Spring元数据</figcaption></figure><p id="8c48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">坚持住。那是什么意思？什么是<code class="fe mo mp mq mr b">arg0</code>、<code class="fe mo mp mq mr b">arg1</code>、<code class="fe mo mp mq mr b">arg2</code>？这完全出乎我们的意料。</p><p id="998f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以通过<a class="ae le" href="https://github.com/spring-projects/spring-boot/issues/18730" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae le" href="https://github.com/rzwitserloot/lombok/issues/2275" rel="noopener ugc nofollow" target="_blank">那个</a>链接找到更多关于这个问题的信息。bug已经修复了，但是还没有发布。在此之前，唯一的解决方法是我们自己声明构造函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用Lombok修复数据库配置</figcaption></figure><h1 id="ca72" class="ms lg it bd lh mt mu mv lk mw mx my ln mz na nb lq nc nd ne lt nf ng nh lw ni bi translated">下一步是什么？</h1><p id="4b24" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">有人可能会认为我在试图说服你拒绝使用Lombok。一点也不。我认为Lombok是Java世界中最伟大的库之一。相反，我可以给你一些建议，可能有助于避免不愉快的后果。</p><h2 id="b7cf" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">0.Lombok必须是编译时依赖项</h2><p id="1bbd" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果您正在处理一个代码不应该被重用的服务，那么您如何声明Lombok是没有区别的。但是如果你正在开发一个库，不要忘记检查依赖的范围。否则，用户可能会面临在类路径中有两个不同版本的Lombok的问题。</p><h2 id="3340" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">1.跟踪复杂性</h2><p id="a4d3" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">正如我们所看到的，Lombok会误导我们关于类的耦合。您应该始终注意它包含的依赖项的数量。总之，不要忘记<a class="ae le" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank"> SRP(单一责任原则)</a>。</p><h2 id="6920" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">2.不要过度使用建筑商</h2><p id="6dbe" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">Builder是用默认值声明参数的一个很好的模式。如果您的DTO只有必填字段，最好使用构造函数。如果你有一个巨大的DTO，不要把问题藏在<code class="fe mo mp mq mr b">@Builder</code>注释后面。尽量分班。</p><h2 id="8c84" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">3.不要让你的业务逻辑依赖于生成的东西</h2><p id="93a2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这种情况并不常见，但确实会发生。</p><p id="9b6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Lombok为我们生成了大量代码。因此，一些开发人员想出了一个在其上实现功能的主意。例如，我们可以创建一个自定义的反序列化器，通过反射来设置值。我们所有的dto都使用<code class="fe mo mp mq mr b">@Builder</code>注释。生成器包含与字段同名的setter方法。我们就一个一个的调用这些方法吧。最后，所有需要做的就是打电话给<code class="fe mo mp mq mr b">build</code>。</p><p id="b5c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法是绝对脆弱的。如果我们传递一个没有生成器的对象会怎么样？如果有人决定用<code class="fe mo mp mq mr b">@Builder(setterPrefix = "set")</code>改变setter-method前缀会怎么样？一切都会崩溃。</p><p id="193a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在生成的代码上构建逻辑之前，您应该三思而行。</p><h2 id="0053" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">4.遵循相同的代码风格</h2><p id="0968" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这个规则不仅适用于龙目岛，也适用于整个开发过程本身。</p><p id="d8c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有成百上千的<em class="mg">最佳实践</em>和成千上万的书籍可以教你<em class="mg">写代码的正确方法</em>。但是在我看来，没有人真正知道如何去做。你会发现包括我在内的许多人都支持不变性和构造函数注入。同样的，也有很多其他专业开发人员有不同的看法。</p><p id="d5ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，我认为你真正应该关心的唯一标准是让你的代码尽可能的统一。如果您喜欢用setters初始化dto，可以将这种方法扩展到整个应用程序。如果你是构造函数注入的支持者，<code class="fe mo mp mq mr b">@RequiredArgsConstructor</code>应该成为你最好的朋友。</p><p id="7b12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Lombok是一个非常灵活的库。尝试它提供的每一个功能总是有很大的诱惑。而且没有问题。但是不要让你的好奇心把代码库弄得一团糟。</p><h1 id="b288" class="ms lg it bd lh mt mu mv lk mw mx my ln mz na nb lq nc nd ne lt nf ng nh lw ni bi translated">结论</h1><p id="a80f" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这就是我想说的关于龙目岛的一切。如果你有任何问题或建议，请在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>