<html>
<head>
<title>The Basics of Testing a React Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试React组件的基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-basics-of-testing-a-react-component-2ff635c99044?source=collection_archive---------0-----------------------#2019-01-25">https://levelup.gitconnected.com/the-basics-of-testing-a-react-component-2ff635c99044?source=collection_archive---------0-----------------------#2019-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="202b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Jest和酶测试反应中的受控形式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d2a3a123efe4fa9b9ee28e02fd41eb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QANxvFyNL5Jvb7U5Ny0iFA.png"/></div></div></figure><p id="e11d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">测试前端是出了名的痛苦。然而，一旦你掌握了基本的诀窍，如果不是很费时间的话，很多事情都会变得容易和标准化。所以，今天我想带大家了解一下在React中完全测试一个受控表单的过程。</p><p id="3a9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">受控形式是反应的核心。它们通常包含一些输入、一个按钮和支持它们的逻辑。任何在React中做大量工作的人都可能经常创建这些组件，所以了解如何测试它们是很重要的。以下是标准控制表单的外观:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="a8c3" class="ls lt iq lo b gy lu lv l lw lx">import React, { Component } from "react";</span><span id="e58d" class="ls lt iq lo b gy ly lv l lw lx">class ControlledForm extends Component {<br/>  constructor() {<br/>    super();</span><span id="7c65" class="ls lt iq lo b gy ly lv l lw lx">    this.state = {<br/>      title: "",<br/>      description: "",<br/>      submitActive: false<br/>    };<br/>  }</span><span id="90aa" class="ls lt iq lo b gy ly lv l lw lx">  handleChange = event =&gt; {<br/>    this.setState({<br/>      [event.target.name]: event.target.value<br/>    },this.checkFields);<br/>  };</span><span id="4b93" class="ls lt iq lo b gy ly lv l lw lx">  handleSubmit = event =&gt; {<br/>    event.preventDefault();<br/>  <br/>    if (!this.state.submitActive) {<br/>      return<br/>    }</span><span id="35fd" class="ls lt iq lo b gy ly lv l lw lx">    const submission = {<br/>      title: this.state.title,<br/>      description: this.state.description<br/>    };</span><span id="eb76" class="ls lt iq lo b gy ly lv l lw lx">    this.props.submit(submission);</span><span id="2ff1" class="ls lt iq lo b gy ly lv l lw lx">    this.setState({<br/>      title: '',<br/>      description: '',<br/>      submitActive: 'false'<br/>    })<br/>  };</span><span id="cd16" class="ls lt iq lo b gy ly lv l lw lx">  checkFields = () =&gt; {<br/>    if (this.state.title &amp;&amp; this.state.description) {<br/>      this.setState({submitActive: true});<br/>    } else {<br/>      this.setState({submitActive: false});<br/>    }<br/>  };</span><span id="bbe7" class="ls lt iq lo b gy ly lv l lw lx">  render() {<br/>    return (<br/>      &lt;form <br/>        className="controlled-form"<br/>        onSubmit={event =&gt; this.handleSubmit(event)}<br/>      &gt;<br/>        &lt;input <br/>          className="text-input title-input"<br/>          type="text"<br/>          name="title"<br/>          value={this.state.title}<br/>          onChange={event =&gt; {<br/>            this.handleChange(event);  <br/>          }}<br/>        /&gt;<br/>        &lt;input <br/>          className="text-input description-input"<br/>          type="text"<br/>          name="description"<br/>          value={this.state.description}<br/>          onChange={event =&gt; {<br/>            this.handleChange(event);  <br/>          }}<br/>        /&gt;<br/>        &lt;button <br/>          className={`submit-btn ${this.state.submitActive}`}<br/>        &gt;submit&lt;/button&gt;<br/>      &lt;/form&gt;<br/>    );<br/>  }<br/>}</span><span id="2750" class="ls lt iq lo b gy ly lv l lw lx">export default ControlledForm;</span></pre><p id="ea26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这个特殊的控制表单，我们有两个输入:标题和描述。它们都有调用<code class="fe lz ma mb lo b">handleChange()</code>方法的<code class="fe lz ma mb lo b">onChange</code>监听器。输入值也绑定到它们在<code class="fe lz ma mb lo b">state</code>中的相应属性，这些属性由<code class="fe lz ma mb lo b">handleChange()</code>方法修改。</p><p id="b3ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还有一个调用<code class="fe lz ma mb lo b">handleSubmit()</code>方法的<code class="fe lz ma mb lo b">onSubmit</code>监听器。该方法首先调用<code class="fe lz ma mb lo b">preventDefault()</code>来阻止页面刷新，检查<code class="fe lz ma mb lo b">submitActive</code>是否是<code class="fe lz ma mb lo b">state</code>中的<code class="fe lz ma mb lo b">true</code>，创建我们将向上传递组件树的对象，并调用props中传递的<code class="fe lz ma mb lo b">submit()</code>方法。</p><p id="3d26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们有<code class="fe lz ma mb lo b">checkFields</code>方法，用于将<code class="fe lz ma mb lo b">submitActive</code>设置为<code class="fe lz ma mb lo b">true</code>或<code class="fe lz ma mb lo b">false</code>。虽然不是必需的，但它经常用于样式设计，因为我们将<code class="fe lz ma mb lo b">submitActive</code>插入到按钮元素的<code class="fe lz ma mb lo b">className</code>中。</p><p id="8815" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于那些学习React的人来说，有一些坚实的工具可供你以<a class="ae mc" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae mc" href="https://github.com/airbnb/enzyme" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>的形式编写测试。Jest预装了<code class="fe lz ma mb lo b">create-react-app</code>，所以大多数人通常不需要担心安装它。然而，酶不会。</p><p id="0d61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您在React 16中，您可以使用npm从命令行安装Enzyme:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="1b53" class="ls lt iq lo b gy lu lv l lw lx">npm i --save-dev enzyme enzyme-adapter-react-16</span></pre><p id="7001" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将安装React 16所需的酶和适配器。如果没有与您的React版本匹配的适配器，Enzyme将无法工作。</p><p id="9486" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，在与ControlledForm组件相同的目录中创建一个测试文件，并将其命名为<code class="fe lz ma mb lo b">ControlledForm.test.js</code>。当您运行测试套件时，Jest/Enzyme会自动识别这个文件。</p><p id="842f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们需要设置我们已经创建的测试文件。您可能希望从文件顶部的以下内容开始:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="7cdc" class="ls lt iq lo b gy lu lv l lw lx">import React from "react";</span><span id="b666" class="ls lt iq lo b gy ly lv l lw lx">import { shallow } from "enzyme";</span><span id="4251" class="ls lt iq lo b gy ly lv l lw lx">import ControlledForm from "./ControlledForm";</span><span id="5290" class="ls lt iq lo b gy ly lv l lw lx">import { configure } from "enzyme";<br/>import Adapter from "enzyme-adapter-react-16";<br/>configure({ adapter: new Adapter() });</span></pre><p id="a9dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们正在使用React组件，所以显然我们需要导入React。第二行代码从Enzyme导入了<code class="fe lz ma mb lo b">shallow()</code>方法，这允许我们创建组件的“浅层”实例。这意味着在我们测试过的组件中创建的任何子组件将只作为引用存在。因为我们不处理ControlledForm的任何子组件，所以这在这里一点也不重要。</p><p id="552f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们导入组件进行测试。不言自明。</p><p id="828a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下三行用于配置酶以与React 16一起工作。这段代码通常放在setupTests.js文件你的<code class="fe lz ma mb lo b">/src</code>文件夹中，然后全局应用于所有测试，但是为了本教程，我们只是将它放在这个特定测试文件的顶部。</p><p id="2fe5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在我们准备写一些测试！</p><p id="f59f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将从我们的<code class="fe lz ma mb lo b">ControlledForm</code>组件的<code class="fe lz ma mb lo b">describe</code>方法开始，声明我们的包装器，作为道具传递的<code class="fe lz ma mb lo b">submit</code>函数的模拟，以及定义<code class="fe lz ma mb lo b">mockSubmit</code>和<code class="fe lz ma mb lo b">wrapper</code>的<code class="fe lz ma mb lo b">beforeEach</code>:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="403b" class="ls lt iq lo b gy lu lv l lw lx">describe("ControlledForm", () =&gt; {<br/>  let wrapper;<br/>  let mockSubmit;</span><span id="9e1c" class="ls lt iq lo b gy ly lv l lw lx">  beforeEach(() =&gt; {<br/>    mockSubmit = jest.fn();<br/>    wrapper = shallow(&lt;ControlledForm submit={mockSubmit} /&gt;);<br/>  });</span></pre><p id="9829" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过将mockSubmit定义为<code class="fe lz ma mb lo b">jest.fn()</code>，它允许识别它何时被调用以及使用什么参数。当我们测试调用它的<code class="fe lz ma mb lo b">handleSubmit()</code>方法时，这很重要。</p><p id="5d74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">快照测试</strong></p><p id="28fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们要编写的第一个测试将是一个简单的快照测试。快照就是它听起来的样子；它会给你的组件拍一张“照片”,然后观察它会呈现什么。这张图片作为组件的JSON对象表示保存在您的测试文件旁边，并与您随后每次对该文件运行测试时呈现的内容进行比较。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="21d4" class="ls lt iq lo b gy lu lv l lw lx">it("should match the snapshot", () =&gt; {<br/>  expect(wrapper).toMatchSnapshot();<br/>});</span></pre><p id="b0bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你改变了一些被渲染的东西，快照将会失败，你的测试套件会让你知道。快照的全部意义仅仅是让你知道一些东西随着被渲染的东西而改变。这在很大程度上是为了警告您，是否有流氓代码以某种方式被引入到您的JSX中，就像您的猫在您不注意的时候走过键盘一样。</p><p id="9060" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">测试状态变化</strong></p><p id="054c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来我们将测试<code class="fe lz ma mb lo b">handleChange()</code>方法。这个方法做两件事:它设置状态，并在我们的<code class="fe lz ma mb lo b">setState()</code>调用中调用<code class="fe lz ma mb lo b">checkFields</code>作为回调。它有一个参数:带有名称和值属性的事件对象，我们需要为测试模拟它。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="530a" class="ls lt iq lo b gy lu lv l lw lx">describe("handleChange", () =&gt; {<br/>  it("should call setState on title", () =&gt; {<br/>    const mockEvent = {<br/>      target: {<br/>        name: "title",<br/>        value: "test"<br/>      }<br/>    };</span><span id="1a38" class="ls lt iq lo b gy ly lv l lw lx">    const expected = {<br/>      title: "test",<br/>      description: "",<br/>      submitActive: false<br/>    };</span><span id="77e3" class="ls lt iq lo b gy ly lv l lw lx">    wrapper.instance().handleChange(mockEvent);<br/>    <br/>    expect(wrapper.state()).toEqual(expected);<br/>  });<br/>});</span></pre><p id="bf62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们模拟了事件对象之后，我们创建了一个对象<code class="fe lz ma mb lo b">expected</code>，我们将用它来比较调用<code class="fe lz ma mb lo b">handleChange()</code>后的状态变化。接下来，我们使用包装器上的<code class="fe lz ma mb lo b">instance()</code>方法调用该方法，这使我们能够访问我们在前面的<code class="fe lz ma mb lo b">beforeEach()</code>中实例化的组件实例上的所有方法。然后我们简单地将状态中的内容与我们的<code class="fe lz ma mb lo b">expected</code>对象进行比较。</p><p id="8fdd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">状态变化是React中经常要测试的东西。这里我要给出一个警告:当你编写方法时，不要在一个函数中对任何一个属性进行多种状态改变，因为这样做将使得不可能检查单个属性的改变是否发生了。例如，如果您正在设置状态，以便在进行fetch调用时有条件地呈现一个加载屏幕，然后在fetch调用完成后再改回来，那么您将希望在另一个函数中进行其中一个状态更改，以便可以单独测试它们。</p><p id="6a23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用jest.spyOn </strong></p><p id="400c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lz ma mb lo b">handleChange()</code>做的第二件事是在我们的<code class="fe lz ma mb lo b">setState()</code>中调用<code class="fe lz ma mb lo b">checkFields()</code>作为回调，所以这需要额外测试。我们通过使用<code class="fe lz ma mb lo b">jest.spyOn()</code>来做到这一点。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="6679" class="ls lt iq lo b gy lu lv l lw lx">it("should call checkFields", () =&gt; {<br/>  const spy = jest.spyOn(wrapper.instance(), "checkFields");<br/>  <br/>  wrapper.instance().forceUpdate();</span><span id="cf2b" class="ls lt iq lo b gy ly lv l lw lx">  const mockEvent = {<br/>    target: {<br/>      name: "description",<br/>      value: "test"<br/>    }<br/>  };</span><span id="2b75" class="ls lt iq lo b gy ly lv l lw lx">  const expected = true;</span><span id="fc91" class="ls lt iq lo b gy ly lv l lw lx">  wrapper.instance().handleChange(mockEvent);</span><span id="ab7a" class="ls lt iq lo b gy ly lv l lw lx">  expect(spy).toHaveBeenCalled();<br/>});</span></pre><p id="8d55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将声明一个变量<code class="fe lz ma mb lo b">spy</code>并将它赋给我们的<code class="fe lz ma mb lo b">spyOn()</code>方法。<code class="fe lz ma mb lo b">spyOn()</code>方法通常接受两个参数:我们组件的实例，以及我们作为字符串观察的方法。在分配了<code class="fe lz ma mb lo b">spy</code>之后，我们需要在我们的实例上调用<code class="fe lz ma mb lo b">forceUpdate()</code>，以便能够正确地观察它。没有它，这个测试将失败。</p><p id="d9f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们像前面的测试一样声明我们的模拟事件，这样函数就不会出错，声明我们期望的变量并调用<code class="fe lz ma mb lo b">handleChange()</code>。为了测试是否调用了<code class="fe lz ma mb lo b">checkFields()</code>，我们使用了<code class="fe lz ma mb lo b">toHaveBeenCalled()</code>方法。</p><p id="84e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe lz ma mb lo b">handleChange()</code>上还有一件事要测试，那就是确保它通过事件处理被正确调用，特别是两个相关输入的任何变化。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="a37f" class="ls lt iq lo b gy lu lv l lw lx">it("should call handleChange on description change with the correct params", () =&gt; {<br/>  const spy = jest.spyOn(wrapper.instance(), "handleChange");<br/>  wrapper.instance().forceUpdate();</span><span id="c18e" class="ls lt iq lo b gy ly lv l lw lx">  const mockEvent = {<br/>    target: {<br/>      name: "description",<br/>      value: "test"<br/>    }<br/>  };</span><span id="0fca" class="ls lt iq lo b gy ly lv l lw lx">  wrapper.find(".description-input").simulate("change", mockEvent);</span><span id="0f15" class="ls lt iq lo b gy ly lv l lw lx">  expect(spy).toHaveBeenCalledWith(mockEvent);<br/>});</span></pre><p id="88cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个测试与前一个有很多共同之处，除了这次我们把间谍放在了<code class="fe lz ma mb lo b">handleChange()</code>方法上。接下来，我们需要在DOM上模拟一个<code class="fe lz ma mb lo b">change</code>事件，通过利用描述输入的类名来使用<code class="fe lz ma mb lo b">simulate()</code>方法，我们使用上面的语法来完成，该方法可以接受一些参数。第一个参数是字符串形式的事件类型，这显然是强制性的。第二个参数是可选的，即与事件一起传递的内容(通常是事件对象)。</p><p id="1ab0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们检查我们的<code class="fe lz ma mb lo b">spy</code>是否是使用与我们之前的测试相似的方法调用的。然而，因为我们是用事件对象调用<code class="fe lz ma mb lo b">handleChange()</code>，所以我们还可以通过使用<code class="fe lz ma mb lo b">toHaveBeenCalledWith()</code>方法检查它是否被传入。</p><p id="d0a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">测试模拟功能</strong></p><p id="333d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的下一个函数<code class="fe lz ma mb lo b">handleSubmit()</code>，有一些事情与<code class="fe lz ma mb lo b">handleChange()</code>有些不同。首先，它调用作为事件对象的一部分传入的<code class="fe lz ma mb lo b">preventDefault()</code>。幸运的是，我们已经知道如何模拟这一点，因为我们在<code class="fe lz ma mb lo b">beforeEach()</code>中做了一些非常类似的事情，当时我们设置了要传递给这个组件的道具。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="26d0" class="ls lt iq lo b gy lu lv l lw lx">it("should call preventDefault", () =&gt; {<br/>  const mockPreventDefault = jest.fn();</span><span id="2135" class="ls lt iq lo b gy ly lv l lw lx">  const mockEvent = {<br/>    preventDefault: mockPreventDefault<br/>  };</span><span id="4aae" class="ls lt iq lo b gy ly lv l lw lx">  wrapper.instance().handleSubmit(mockEvent);</span><span id="1f76" class="ls lt iq lo b gy ly lv l lw lx">  expect(mockPreventDefault).toHaveBeenCalled();</span><span id="eab1" class="ls lt iq lo b gy ly lv l lw lx">});</span></pre><p id="0539" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们声明一个变量<code class="fe lz ma mb lo b">mockPreventDefault</code>，并把它赋给<code class="fe lz ma mb lo b">jest.fn()</code>的值。然后我们声明我们的模拟事件对象，并将<code class="fe lz ma mb lo b">preventDefault</code>属性赋给我们刚刚声明的<code class="fe lz ma mb lo b">mockPreventDefault</code>变量。现在当我们调用<code class="fe lz ma mb lo b">handleSubmit()</code>时，我们可以评估<code class="fe lz ma mb lo b">preventDefault()</code>是否被正确调用。同样，非常简单，但你会经常遇到。</p><p id="c3a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">测试函数是否返回</strong></p><p id="379b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lz ma mb lo b">handleSubmit()</code>函数要测试的下一部分是，如果<code class="fe lz ma mb lo b">submitActive</code>设置为false，它将返回。这将需要我们之前使用的相同类型的代码，唯一的不同是我们的测试方法:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="8da8" class="ls lt iq lo b gy lu lv l lw lx">it("should return if submitActive is false", () =&gt; {<br/>  const mockPreventDefault = jest.fn();<br/>  const mockEvent = {<br/>    preventDefault: mockPreventDefault<br/>  };<br/>  <br/>  const spy = jest.spyOn(wrapper.instance(), "handleSubmit");<br/>  wrapper.instance().forceUpdate();<br/>  <br/>  wrapper.instance().handleSubmit(mockEvent);</span><span id="620d" class="ls lt iq lo b gy ly lv l lw lx">  expect(spy).toReturn();<br/>});</span></pre><p id="4794" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们像前面一样模拟我们的事件对象，以便测试在到达我们的条件语句之前不会出错，在我们调用的方法上放置一个spy，强制更新，调用<code class="fe lz ma mb lo b">handleSubmit()</code>，并在我们的spy上使用<code class="fe lz ma mb lo b">toReturn()</code>方法。小菜一碟。</p><p id="c18c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">测试作为道具流传下来的功能</strong></p><p id="6c40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将快速看一下如何测试一个函数，我们传递给这个组件的一个道具，特别是<code class="fe lz ma mb lo b">submit()</code>函数。</p><p id="e8be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在beforeEach()中，我们将变量<code class="fe lz ma mb lo b">mockSubmit</code>赋给了<code class="fe lz ma mb lo b">jest.fn()</code>的值。每次我们运行测试时，mockSubmit都会被重新分配，所以我们甚至不需要担心用Jest重置任何东西。</p><p id="7f0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们开始调用submit之前，我们需要确保<code class="fe lz ma mb lo b">handleSubmit()</code>不会简单地返回，所以我们将通过设置state来开始我们的测试，使<code class="fe lz ma mb lo b">submitActive</code>为真，并且除了空字符串之外，<code class="fe lz ma mb lo b">title</code>和<code class="fe lz ma mb lo b">description</code>中还有其他内容。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="aeee" class="ls lt iq lo b gy lu lv l lw lx">it("should call submit with the correct params", () =&gt; {<br/>  wrapper.setState({<br/>    title: "test title",<br/>    description: "test description",<br/>    submitActive: true<br/>  });</span><span id="006e" class="ls lt iq lo b gy ly lv l lw lx">  const expected = {<br/>    title: "test title",<br/>    description: "test description"<br/>  };</span><span id="5f00" class="ls lt iq lo b gy ly lv l lw lx">  const mockPreventDefault = jest.fn();</span><span id="ed09" class="ls lt iq lo b gy ly lv l lw lx">  const mockEvent = {<br/>    preventDefault: mockPreventDefault<br/>  };</span><span id="f0a1" class="ls lt iq lo b gy ly lv l lw lx">  wrapper.instance().handleSubmit(mockEvent);</span><span id="94c8" class="ls lt iq lo b gy ly lv l lw lx">  expect(mockSubmit).toHaveBeenCalledWith(expected);<br/>});</span></pre><p id="f364" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们设置我们的期望，模拟我们的事件对象，调用<code class="fe lz ma mb lo b">handleSubmit(),</code>并检查是否调用了<code class="fe lz ma mb lo b">submit</code>道具上的或模拟。</p><p id="cbb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当测试这个组件时，这几乎是新概念。您需要测试通过在DOM上模拟提交调用了<code class="fe lz ma mb lo b">handleSubmit()</code>，测试了<code class="fe lz ma mb lo b">handleSubmit()</code>中的<code class="fe lz ma mb lo b">setState()</code>，测试了<code class="fe lz ma mb lo b">checkFields()</code>中的条件状态设置，但除此之外别无他法。</p><p id="e82d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想在你的编辑器中查看代码，你可以在这里找到repo<a class="ae mc" href="https://github.com/relasine/react-testing-demo" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi mk"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="ml mm gp gr mn mo"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">gitconnected.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc kp mo"/></div></div></a></div></div></div>    
</body>
</html>