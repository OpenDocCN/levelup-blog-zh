<html>
<head>
<title>Segment Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分段树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/segment-tree-640d1e0fee6f?source=collection_archive---------13-----------------------#2021-05-04">https://levelup.gitconnected.com/segment-tree-640d1e0fee6f?source=collection_archive---------13-----------------------#2021-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fcd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对细分树的全面介绍</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/57c6c7fc967d946afb3452850e996663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GU2swq5JtrD1Jcxe"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="e42e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">1.什么是细分树？</h1><p id="5106" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设我们有一个大小为<strong class="jp ir"> N </strong>的数组<strong class="jp ir"> A </strong>。数组的一个<strong class="jp ir">段</strong>是形式为<strong class="jp ir"> A[i : j] </strong>的数组的连续部分，使得<strong class="jp ir"> 0 ≤ i ≤ j ≤ N-1 </strong>。</p><p id="74ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">段树</strong>本质上是一个二叉树，在它的节点中我们存储了关于线性数据结构(如数组)的段的信息。现在不要担心什么样的信息。我们将在本文后面的部分中对此进行研究。</p><ul class=""><li id="9d6e" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">片段树的根节点将包含关于片段<strong class="jp ir">A【0:N-1】</strong>的信息</li><li id="5291" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">根节点的左子节点将包含关于片段<strong class="jp ir"> A[0 : (N-1)/2] </strong>的信息，</li><li id="7fe5" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">根节点的右子节点将包含关于片段<strong class="jp ir"> A[ 1+((N-1)/2) : (N-1) ] </strong>的信息，等等。</li></ul><p id="2e38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，根节点包含关于整个数组的信息，它的左子节点包含关于数组左半部分的类似信息，根节点的右子节点包含关于数组右半部分的信息，依此类推。因此，在每一步(树的级别)，我们将段分成两半，并且进一步的子节点包含关于这两半的信息。</p><p id="daad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一直持续到我们到达包含数组<strong class="jp ir"> A </strong>本身的元素的叶节点。<strong class="jp ir">第I个</strong>叶节点包含<strong class="jp ir">A【I】</strong>。因此，我们可以说将有N个叶节点，树的高度是以2为底的对数。</p><p id="5c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注:</strong>数组的段树一旦建立，其结构就不能改变。我们可以更新节点的值，但不能改变细分树的结构。也就是说，我们不能向数组中添加更多的元素，并期望段树进行更新。在这种情况下，我们将不得不创建一个新的细分树。但是，我们可以更新数组的值，细分树也应该相应地更新。</p><p id="288a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分段树允许以下两种操作:</p><ul class=""><li id="9fcd" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir">更新:</strong>该操作允许我们更新数组<strong class="jp ir"> A </strong>的值，并在段树中反映相应的变化。</li><li id="d3c4" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">查询:</strong>该操作允许我们对数组进行范围查询。例如，假设我们有一个大小为15的数组，我们希望找到数组段中的最大元素，该数组的起始索引为<strong class="jp ir"> 3 </strong>，结束索引为<strong class="jp ir"> 9 </strong>。这是一个范围查询的例子。</li></ul><p id="4adc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们可以说，当我们要在一个数组上执行大量基于范围的查询以及在同一个数组上进行值更新时，段树就派上了用场。创建细分树的过程需要一些时间，但一旦完成，范围查询的操作就会变得非常快。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="bf56" class="lc ld iq bd le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz bi translated">2.细分树包含什么样的信息？</h1><p id="f7a0" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在我们对细分树的结构有了基本的了解，让我们看看细分树包含什么样的信息。</p><p id="dd3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑一个数组<strong class="jp ir"> A = [1，4，5，8，0，13] </strong></p><p id="92c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，细分树总是与一条特定信息相关联，这条信息与我们希望执行的范围查询类型直接关联。其中几个例子如下:</p><ul class=""><li id="79d2" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">求A[i : j]范围内数组元素的和/积</li><li id="9ca1" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">找出范围A[i : j]中的最大/最小元素</li><li id="d2f8" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">找出范围A[i : j]中偶数/奇数/质数等的计数</li></ul><p id="a13c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据用途的不同，还可以有很多其他的。让我们来看看如何利用段树来寻找给定范围中元素的<strong class="jp ir">和。</strong></p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="9bac" class="lc ld iq bd le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz bi translated">3.创建细分树</h1><p id="8ac0" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设我们有一个数组<strong class="jp ir"> A = [1，2，3，4，5，6，7，8，9，10] </strong>，我们希望找到给定范围内元素的总和。那么每个节点将存储其子节点的总和，除了存储数组元素的叶节点。</p><p id="de57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么相同的细分树将看起来像这样</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nf"><img src="../Images/0b0af0e4c8eff1f748c3571ce1db4694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pG4eayBxBQCjAd43NROV4Q.png"/></div></div></figure><p id="bdc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">红色节点是根节点，蓝色节点是内部节点，绿色节点是叶节点。每个节点都包含有关数组特定段的信息。在这个例子中，</p><ul class=""><li id="fdef" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">根节点包含数组中所有元素的总和</li><li id="a7f9" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">根节点的左子节点包含关于数组左半部分的和的信息，即<strong class="jp ir">【1，2，3，4，5】</strong>。它的左孩子依次包含段<strong class="jp ir">【1，2，3】</strong>的和，右孩子包含段<strong class="jp ir">【4，5】</strong>的和，依此类推。</li><li id="60dc" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">根节点的右子节点包含关于数组左半部分的和的信息，即<strong class="jp ir">【6，7，8，9，10】</strong>。它的左子又包含段<strong class="jp ir">【6，7，8】</strong>的和，右子包含段<strong class="jp ir">【9，10】</strong>的和，依此类推。</li></ul><p id="3775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比方说，如果我们想要计算最大元素，那么我们将把最大元素存储在相应节点的每个段中。因此，在构建细分树之前，必须弄清楚构建树背后的意图以及要存储在树节点中的值的类型。</p><p id="a73b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们还可以注意到，段树始终是一个完整的二叉树，即每个节点有2个或0个子节点。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="7452" class="lc ld iq bd le lf na lh li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz bi translated">参考</h1><ul class=""><li id="1d61" class="mf mg iq jp b jq ma ju mb jy ng kc nh kg ni kk mk ml mm mn bi translated"><a class="ae lb" href="https://www.hackerearth.com/practice/data-structures/advanced-data-structures/segment-trees/tutorial/" rel="noopener ugc nofollow" target="_blank">分段树</a></li><li id="5241" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><a class="ae lb" href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" rel="noopener ugc nofollow" target="_blank">分段树(递归实现)</a></li><li id="b865" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><a class="ae lb" href="https://www.geeksforgeeks.org/iterative-segment-tree-range-minimum-query/" rel="noopener ugc nofollow" target="_blank">分段树(迭代实现)</a></li></ul></div></div>    
</body>
</html>