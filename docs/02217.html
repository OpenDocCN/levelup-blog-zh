<html>
<head>
<title>An Introduction to React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-introduction-to-react-hooks-50281fd961fe?source=collection_archive---------3-----------------------#2020-02-27">https://levelup.gitconnected.com/an-introduction-to-react-hooks-50281fd961fe?source=collection_archive---------3-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7821" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解内置钩子和定制钩子的创建过程</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8fb2ddcd1935964cb1fd25534e5bbe04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQx0YywYt_8AgMgF5U07Sg.png"/></div></div></figure><p id="38bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React钩子是React的一个很好的补充，它完全改变了我们编写代码的方式。从16.8.0版本开始，React中引入了钩子。</p><p id="d0f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在React hooks之前，没有办法在功能组件中使用状态和生命周期方法，这就是为什么功能组件被称为<code class="fe la lb lc ld b">Stateless Functional Components</code>。现在，随着React钩子的引入，我们可以在功能组件中使用生命周期方法和状态。使用钩子使我们的代码更简单、更短、更容易理解。</p><h2 id="4b73" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak">安装</strong></h2><p id="6d14" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">要开始使用React钩子，需要使用最新版本的<code class="fe la lb lc ld b">create-react-app</code>。如果您使用自己的webpack安装React，如本文中的<a class="ae mc" href="https://javascript.plainenglish.io/webpack-and-babel-setup-with-react-from-scratch-bef0fe2ae3e7?source=friends_link&amp;sk=880a6b9a35fb638eef19e5e99276428e" rel="noopener ugc nofollow" target="_blank">所述，您需要使用安装最新版本的<code class="fe la lb lc ld b">react</code>和<code class="fe la lb lc ld b">react-dom</code></a></p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="af75" class="le lf it ld b gy mh mi l mj mk">npm install react@latest react-dom@latest</span></pre><p id="929d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们开始探索React挂钩。</p><blockquote class="ml mm mn"><p id="f089" class="jq jr mo js b jt ju jv jw jx jy jz ka mp kc kd ke mq kg kh ki mr kk kl km kn im bi translated">挂钩是让您“挂钩”功能组件中的反应状态和生命周期特性的功能。</p></blockquote><p id="4b2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React提供了许多内置的钩子，还允许我们创建自己的定制钩子。</p><p id="8fbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看一些最重要的内置挂钩。</p><h2 id="a6fb" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak">使用状态挂钩</strong></h2><p id="afcc" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">这是React提供的第一个钩子，它允许我们在功能组件内部使用状态。</p><p id="f246" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useState</code>钩子接受一个参数，这个参数是状态的初始值。</p><p id="9f88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在基于类的组件中，<code class="fe la lb lc ld b">state</code>总是一个对象，但是当使用<code class="fe la lb lc ld b">useState</code>时，你可以提供任何值作为初始值，如<code class="fe la lb lc ld b">number</code>、<code class="fe la lb lc ld b">string</code>、<code class="fe la lb lc ld b">boolean</code>、<code class="fe la lb lc ld b">object</code>、<code class="fe la lb lc ld b">array</code>、<code class="fe la lb lc ld b">null</code>等。</p><p id="7ba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useState</code>钩子返回一个数组，它的第一个值是状态的当前值，第二个值是我们用来更新状态的函数，类似于<code class="fe la lb lc ld b">setState</code>方法。</p><p id="eb8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们举一个使用状态的基于类的组件的例子，我们将使用钩子把它转换成一个功能组件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6af6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:【https://codesandbox.io/s/delicate-thunder-xdpri T21】</p><p id="20b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们把上面的代码转换成使用钩子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7fc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/elegant-heyrovsky-3qco5" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/elegant-heyrovsky-3qco5</a></p><p id="73e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来理解上面的代码</p><p id="5e0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.为了使用<code class="fe la lb lc ld b">useState</code>钩子，我们需要像在第一行中那样导入它。</p><p id="c43d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.在App组件内部，我们通过传递0作为初始值并使用析构语法来调用<code class="fe la lb lc ld b">useState</code>，我们将<code class="fe la lb lc ld b">useState</code>返回的数组值存储到<code class="fe la lb lc ld b">counter</code>和<code class="fe la lb lc ld b">setCounter</code>变量中。</p><p id="cbcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.像在<code class="fe la lb lc ld b">setCounter</code>中一样，在用于更新状态的函数名前面加上<code class="fe la lb lc ld b">set</code>关键字是一种常见的约定。</p><p id="e890" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.当我们单击increment按钮时，我们定义了一个内联函数，并通过传递更新后的<code class="fe la lb lc ld b">counter</code>值来调用<code class="fe la lb lc ld b">setCounter</code>函数。</p><p id="75e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.注意，因为我们已经有了<code class="fe la lb lc ld b">counter</code>值，所以我们使用<code class="fe la lb lc ld b">setCounter(counter + 1)</code>来增加计数器</p><p id="b623" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.由于内联点击处理程序中只有一条语句，所以没有必要将代码移到单独的函数中。尽管如果处理程序内部的代码变得复杂，您也可以这样做。</p><p id="41cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们可以在单个功能组件中有多个</strong> <code class="fe la lb lc ld b"><strong class="js iu">useState</strong></code> <strong class="js iu">调用:</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a219" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/long-framework-n1tyn" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/long-framework-n1tyn</a></p><p id="1915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在上面的代码中看到的，我们已经声明了两个<code class="fe la lb lc ld b">useState</code>调用，用户名和计数器都是相互独立的。我们可以根据需要添加任意数量的<code class="fe la lb lc ld b">useState</code>通话。</p><p id="a972" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用useState钩子时状态不合并:</strong></p><p id="9d00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您在<code class="fe la lb lc ld b">useState</code>中使用<code class="fe la lb lc ld b">object</code>需要注意的一点是，在更新状态时，状态不会被合并。</p><p id="0526" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看当我们将<code class="fe la lb lc ld b">username</code>和<code class="fe la lb lc ld b">counter</code>组合成一个对象来更新状态时会发生什么。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d201" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/sleepy-darkness-6jz9b" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/sleepy-darkness-6jz9b</a></p><p id="3488" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您运行代码并尝试增加计数器，它会工作，但一旦您尝试在输入字段中键入内容，计数器值就会消失，当您再次尝试增加计数器时，它会显示为<code class="fe la lb lc ld b">NaN</code>，并且您也会在控制台中得到一个警告。</p><p id="d7f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这是因为当我们使用</strong> <code class="fe la lb lc ld b"><strong class="js iu">setState</strong></code> <strong class="js iu">方法设置状态时，使用</strong> <code class="fe la lb lc ld b"><strong class="js iu">useState</strong></code> <strong class="js iu">中的一个对象会完全替换该对象而不是合并它。</strong></p><p id="f812" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，初始状态值是</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="2fd1" class="le lf it ld b gy mh mi l mj mk">{ counter: 0, username: "" }</span></pre><p id="d205" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是当我们调用<code class="fe la lb lc ld b">increment</code>方法时，它就变成了</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="295e" class="le lf it ld b gy mh mi l mj mk">{ counter: 1 }</span></pre><p id="2fb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">于是<code class="fe la lb lc ld b">username</code>就这样失去了。</p><p id="563b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您首先在输入字段中键入内容，那么</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="a165" class="le lf it ld b gy mh mi l mj mk">{ counter: 0, username: "" }</span></pre><p id="a8e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">成为</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="50d6" class="le lf it ld b gy mh mi l mj mk">{ username: "new_value" }</span></pre><p id="935e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此<code class="fe la lb lc ld b">counter</code>丢失。</p><blockquote class="ml mm mn"><p id="2a40" class="jq jr mo js b jt ju jv jw jx jy jz ka mp kc kd ke mq kg kh ki mr kk kl km kn im bi translated">因此，建议使用多个<code class="fe la lb lc ld b">useState</code>调用，而不是使用单个<code class="fe la lb lc ld b">useState</code>来存储对象。</p></blockquote><p id="14c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你还想使用<code class="fe la lb lc ld b">useState</code>中的一个对象，你需要像这样手动合并之前的状态</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="5c0c" class="le lf it ld b gy mh mi l mj mk">const handleOnClick = () =&gt; { <br/>  setState(prevState =&gt; ({<br/>   ...prevState,<br/>   counter: prevState.counter + 1<br/>  }));<br/>};</span><span id="03f0" class="le lf it ld b gy mu mi l mj mk">const handleOnChange = event =&gt; {<br/> const value = event.target.value;<br/> setState(prevState =&gt; ({<br/>   ...prevState,<br/>   username: value<br/> }));<br/>};</span></pre><p id="a575" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/strange-dawn-s0nyi" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/strange-dawn-s0nyi</a></p><h2 id="0392" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak">使用特效挂钩</strong></h2><p id="b4ae" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">React提供了一个<code class="fe la lb lc ld b">useEffect</code>钩子，使用它我们可以在功能组件中实现生命周期方法。</p><p id="e63b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useEffect</code>钩子接受一个函数作为第一个参数，可选数组作为第二个参数。</p><p id="4c09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useEffect</code>允许您在功能组件中执行副作用。</p><blockquote class="ml mm mn"><p id="fed3" class="jq jr mo js b jt ju jv jw jx jy jz ka mp kc kd ke mq kg kh ki mr kk kl km kn im bi translated">数据获取、设置订阅和手动更改React组件中的DOM都是副作用的例子。</p></blockquote><p id="f45c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useEffect</code>接受两个参数:一个函数和一个可选数组。</p><p id="b300" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useEffect</code>与<code class="fe la lb lc ld b">componentDidMount</code>、<code class="fe la lb lc ld b">componentDidUpdate</code>和<code class="fe la lb lc ld b">componentWillUnmount </code>组合在一起的作用相同。</p><p id="001a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看下面的代码</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b9d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/stupefied-darwin-qpcmm" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/stupefied-darwin-qpcmm</a></p><p id="4ae5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您运行该代码，您将会看到<code class="fe la lb lc ld b">useEffect</code>中提供的功能在页面加载时(即组件安装时)被立即调用。当组件在任何状态或属性改变时被重新呈现时，它也会被调用。</p><p id="d4ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以当你点击增量按钮时，<code class="fe la lb lc ld b">useEffect</code>钩子会被再次调用。</p><p id="2a21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此它服务于<code class="fe la lb lc ld b">componentDidMount</code>和<code class="fe la lb lc ld b">componentDidUpdate</code>生命周期方法的目的。</p><p id="a7a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mo">如果你想让这个效果只在组件挂载时被调用，你需要提供一个空数组作为</em> <code class="fe la lb lc ld b"><em class="mo">useEffect</em></code> <em class="mo">调用的第二个参数。</em></p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="297c" class="le lf it ld b gy mh mi l mj mk">useEffect(() =&gt; {<br/>  console.log("useEffect called");<br/>}, []);</span></pre><p id="263c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在，这个效果只有在组件被挂载的时候才会被调用，再也不会被调用了。</p><p id="1f06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/gifted-newton-71vzl" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/gifted-newton-71vzl</a></p><p id="48e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看下面的代码</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="dabf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/long-framework-n1tyn" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/long-framework-n1tyn</a></p><p id="804c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，当计数器和用户名改变时，<code class="fe la lb lc ld b">useEffect</code>被执行。</p><p id="637f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想让它只在<code class="fe la lb lc ld b">counter</code>改变时执行，你需要在依赖数组中提到它，这是<code class="fe la lb lc ld b">useEffect</code>的第二个参数。</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="9fe8" class="le lf it ld b gy mh mi l mj mk">useEffect(()<em class="mo"> </em>=&gt;<em class="mo"> </em>{<br/><em class="mo"> </em>console.log("This will be executed when only counter is changed");<br/>},<em class="mo"> </em>[counter]);</span></pre><p id="7773" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解这一点非常重要，因为当计数器改变时，如果你在<code class="fe la lb lc ld b">useEffect</code>中做一些计算，当用户名或任何其他属性或状态改变时，执行这些代码是没有意义的。</p><blockquote class="ml mm mn"><p id="b9ef" class="jq jr mo js b jt ju jv jw jx jy jz ka mp kc kd ke mq kg kh ki mr kk kl km kn im bi translated">因此，通过在dependencies数组中提供变量，只有当这些变量被更改时，效果才会被执行。</p></blockquote><p id="eb78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个很大的改进，因为它不再需要我们以前在<code class="fe la lb lc ld b">componentDidUpdate</code>方法中使用的额外条件</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="6d16" class="le lf it ld b gy mh mi l mj mk">componentDidUpdate(prevProps) {<br/> if(prevProps.counter !== this.props.counter) {<br/>  // do something<br/> }<br/>}</span></pre><p id="ee2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，使用<code class="fe la lb lc ld b">useEffect</code>并提及依赖关系消除了将先前属性或状态值与当前属性或状态值进行比较的需要，因为<code class="fe la lb lc ld b">useEffect</code>内的代码将仅在依赖关系改变时执行。</p><p id="c453" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果有多个依赖项，可以在依赖项数组中将其指定为逗号分隔的值。</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="f166" class="le lf it ld b gy mh mi l mj mk">useEffect(()<em class="mo"> </em>=&gt;<em class="mo"> </em>{<br/> console.log("This will be executed when any of the dependency is changed");<br/>},<em class="mo"> </em>[counter, some_other_value]);</span></pre><h2 id="b796" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak">清理效果</strong></h2><p id="ff95" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">如果您从<code class="fe la lb lc ld b">useEffect</code>返回一个函数，它将在组件被卸载之前被调用。所以和<code class="fe la lb lc ld b">componentWillUnmount</code>方法差不多。</p><p id="20cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设你正在使用<code class="fe la lb lc ld b">setInterval</code>函数，那么你可以清除<code class="fe la lb lc ld b">useEffect</code>返回的函数中的区间。</p><blockquote class="ml mm mn"><p id="d449" class="jq jr mo js b jt ju jv jw jx jy jz ka mp kc kd ke mq kg kh ki mr kk kl km kn im bi translated">该清理效果在组件卸载时以及由于后续渲染而重新运行useEffect之前运行</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="91b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/sleepy-wood-biu89" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/sleepy-wood-biu89</a></p><p id="8ab5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，我们添加了scroll事件处理程序，当组件被挂载时，它将只被注册一次，因为我们在<code class="fe la lb lc ld b">useEffect</code>依赖列表中传递了一个空数组。</p><p id="f903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mo">当页面滚动时，这段代码在控制台中显示一条消息。</em></p><p id="4835" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们点击<code class="fe la lb lc ld b">unmount component</code>按钮时，组件将被移除，从<code class="fe la lb lc ld b">useEffect</code>返回的函数将被调用，我们移除滚动事件处理程序并将消息<code class="fe la lb lc ld b">“component unmounted”</code>打印到控制台。</p><p id="303e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得注意的是，在子组件中，每次重新渲染父组件时都会调用<code class="fe la lb lc ld b">useEffect</code>。</p><p id="c438" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看下面的代码</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="85e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整代码和演示:<a class="ae mc" href="https://codesandbox.io/s/jolly-tesla-gj170" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/jolly-tesla-gj170</a></p><p id="d9c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们添加了一个新的todo。因此，对于每个添加的todo，TodoList组件将被重新呈现，因此，TodoList中定义的<code class="fe la lb lc ld b">useEffect</code>将被调用，以便在控制台中打印消息。</p><p id="51cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果你不想重新渲染TodoList的效果，你需要在第二个参数<code class="fe la lb lc ld b">useEffect</code>中传递一个空数组<code class="fe la lb lc ld b">[]</code>作为依赖。</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="6129" class="le lf it ld b gy mh mi l mj mk">useEffect(() =&gt; {<br/> console.log("This will be executed only once");<br/>}, []);</span></pre><p id="54ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">单个组件中的多种使用效果:</strong></p><p id="7cba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以在单个功能组件中有多个<code class="fe la lb lc ld b">useEffect</code>调用，每个调用执行不同的任务，React将按照组件中定义的顺序调用它们。</p><h2 id="c101" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak"> useRef挂钩</strong></h2><p id="75d0" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated"><code class="fe la lb lc ld b">useRef</code>钩子允许我们访问任何DOM元素，这与在React中使用<code class="fe la lb lc ld b">ref</code>是一样的。</p><p id="6304" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它具有以下语法。</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="a82b" class="le lf it ld b gy mh mi l mj mk">const refContainer = useRef(initialValue);</span></pre><p id="cd15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">initialValue</code>是可选的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fb89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/damp-water-fye8r" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/damp-water-fye8r</a></p><p id="1993" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们已经使用</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="c90f" class="le lf it ld b gy mh mi l mj mk">const usernameRef = useRef();</span></pre><p id="3d5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并将其分配给输入字段。所以现在我们可以通过使用<code class="fe la lb lc ld b">usernameRef.current</code>属性随时访问输入字段。</p><p id="6fbf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useRef</code>与React <code class="fe la lb lc ld b">ref</code>并不完全相同，因为<code class="fe la lb lc ld b">useRef</code>返回一个可变的ref对象，其<code class="fe la lb lc ld b">.current</code>属性被初始化为传递的参数(<code class="fe la lb lc ld b">initialValue</code>)。</p><blockquote class="ml mm mn"><p id="3f03" class="jq jr mo js b jt ju jv jw jx jy jz ka mp kc kd ke mq kg kh ki mr kk kl km kn im bi translated">返回的对象将在组件的整个生存期内保持不变。</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="bcb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/black-cache-e5vlb" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/black-cache-e5vlb</a></p><p id="e0f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，我们创建了一个计时器，显示每秒钟更新的时间。当我们点击<code class="fe la lb lc ld b">unmount component</code>按钮时，我们清除<code class="fe la lb lc ld b">setInterval</code>从而停止计时器。</p><p id="bfad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还要注意，我们添加了另一个<code class="fe la lb lc ld b">useEffect</code>调用，在5秒钟后清除计时器。</p><p id="7c7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要记住的关键点是，我们能够在第一个<code class="fe la lb lc ld b">useEffect</code>中访问相同的<code class="fe la lb lc ld b">interval</code>变量的值，即使它在第二个<code class="fe la lb lc ld b">useEffect</code>中被赋值。如果我们没有使用<code class="fe la lb lc ld b">useRef</code>而是使用了普通变量，那么在第一个<code class="fe la lb lc ld b">useEffect</code>中它将不可用，因为<code class="fe la lb lc ld b">useEffect</code>为效果的每次执行创建了一个新函数。</p><h2 id="4e1f" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak"> useReducer挂钩</strong></h2><p id="2eca" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">React提供了一个<code class="fe la lb lc ld b">useReducer</code>钩子，允许我们使用redux来处理复杂的计算，而不需要安装redux库。</p><p id="32b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，它有助于避免创建样板redux动作、reducer代码。</p><p id="7494" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您有涉及多个子值的复杂状态逻辑或者下一个状态依赖于前一个状态时，<code class="fe la lb lc ld b">useReducer</code>通常比<code class="fe la lb lc ld b">useState</code>更好。</p><p id="05e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useReducer</code>的语法如下:</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="3568" class="le lf it ld b gy mh mi l mj mk">const [state, dispatch] = useReducer(reducer, initialState);</span></pre><p id="adbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">useReducer</code>接受<code class="fe la lb lc ld b">reducer</code>和<code class="fe la lb lc ld b">initialState</code>并返回<code class="fe la lb lc ld b">current state</code>和一个<code class="fe la lb lc ld b">dispatch</code>函数，我们可以用它来<code class="fe la lb lc ld b">dispatch</code>动作。</p><p id="a69f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过一个例子来了解一下。我们将创建一个待办事项列表组件，允许我们添加和删除待办事项。</p><p id="7168" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们创建一个<code class="fe la lb lc ld b">reducer</code>来处理todo。</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="aeff" class="le lf it ld b gy mh mi l mj mk">const todosReducer = (state, action) =&gt; {<br/> switch (action.type) {<br/>  case "ADD_TODO":<br/>   return [...state, action.todo];<br/>  case "REMOVE_TODO":<br/>   return state.filter(todo =&gt; todo !== action.todo);<br/>  default:<br/>   return state;<br/> }<br/>};</span></pre><p id="7c16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将<code class="fe la lb lc ld b">useReducer</code>的<code class="fe la lb lc ld b">initialState</code>中<code class="fe la lb lc ld b">todosReducer</code>的初始状态初始化为</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="e809" class="le lf it ld b gy mh mi l mj mk">const initialState = [];<br/>const [state, dispatch] = useReducer(todosReducer, initialState);</span></pre><p id="8aef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并分派像这样的动作</p><pre class="kp kq kr ks gt md ld me mf aw mg bi"><span id="fdd3" class="le lf it ld b gy mh mi l mj mk">dispatch({ type: "ADD_TODO", todo: value });</span></pre><p id="16fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整代码和演示:<a class="ae mc" href="https://codesandbox.io/s/admiring-bose-jw6wx" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/admiring-bose-jw6wx</a></p><p id="e6b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，<code class="fe la lb lc ld b">useReducer</code>钩子使得管理redux状态变得非常容易，而不需要实际使用redux，这是一个很大的改进。</p><p id="3002" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但这并不意味着redux现在就没用了。如果您正在管理更大的状态或者有多个reducers，那么您应该使用redux来处理这个问题。</p><p id="d38e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想在单个组件中处理复杂的状态，就让它变得简单。</p><h2 id="c0e7" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak">创建自定义挂钩</strong></h2><p id="7540" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">React允许我们使用内置钩子创建自己的定制钩子。这允许我们将组件逻辑提取到可重用的功能中。</p><p id="d299" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从这里的<a class="ae mc" href="https://codesandbox.io/s/black-cache-e5vlb" rel="noopener ugc nofollow" target="_blank">中取出之前的定时器代码</a>，我们将把它转换成一个定制的可重用钩子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c99a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示:<a class="ae mc" href="https://codesandbox.io/s/infallible-visvesvaraya-qkwdw" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/infallible-visvesvaraya-qkwdw</a></p><p id="c557" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们封装了在<code class="fe la lb lc ld b">useTimer</code>函数中显示计时器的代码，并从该函数返回更新的时间。</p><p id="62c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在任何想要显示时间的组件，都可以调用<code class="fe la lb lc ld b">useTimer</code>函数并使用这个定时器钩子。</p><blockquote class="ml mm mn"><p id="635d" class="jq jr mo js b jt ju jv jw jx jy jz ka mp kc kd ke mq kg kh ki mr kk kl km kn im bi translated">用<code class="fe la lb lc ld b">useTimer</code>这样的<code class="fe la lb lc ld b">use</code>关键字来<code class="fe la lb lc ld b">begin</code>自定义钩子名称是很常见的约定。</p></blockquote><h2 id="df0c" class="le lf it bd lg lh li dn lj lk ll dp lm kb ln lo lp kf lq lr ls kj lt lu lv lw bi translated"><strong class="ak">使用挂钩时需要注意的事项</strong></h2><ul class=""><li id="faa1" class="mv mw it js b jt lx jx ly kb mx kf my kj mz kn na nb nc nd bi translated">只调用顶层的钩子<strong class="js iu">。不要在循环、条件或嵌套函数中调用钩子。通过遵循这条规则，您可以确保每次组件呈现时都以相同的顺序调用钩子。这使得React能够在多个<code class="fe la lb lc ld b">useState</code>和<code class="fe la lb lc ld b">useEffect</code>调用之间正确地保持钩子的状态。</strong></li><li id="db05" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">仅从React函数组件调用钩子<strong class="js iu">。不要从常规的JavaScript函数中调用钩子。但是你可以从你自己定制的钩子中调用它。</strong></li></ul><p id="0381" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">要了解如何使用Async/await和</strong> <code class="fe la lb lc ld b"><strong class="js iu">useEffect</strong></code> <strong class="js iu">钩子处理API调用，请查看本文。</strong> </p><p id="1bf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看我最近出版的<a class="ae mc" href="https://master-redux.yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank">掌握Redux </a>课程。</p><p id="7969" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本课程中，您将构建3个应用程序以及一个点餐应用程序，您将了解:</p><ul class=""><li id="4264" class="mv mw it js b jt ju jx jy kb nj kf nk kj nl kn na nb nc nd bi translated">基本和高级冗余</li><li id="e45c" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">如何管理数组和对象的复杂状态</li><li id="9b8a" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">如何使用多个减速器管理复杂的冗余状态</li><li id="7599" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">如何调试Redux应用程序</li><li id="ca49" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">如何在React中使用Redux使用react-redux库让你的app反应性。</li><li id="524a" class="mv mw it js b jt ne jx nf kb ng kf nh kj ni kn na nb nc nd bi translated">如何使用redux-thunk库处理异步API调用等等</li></ul><p id="6a55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将从头开始构建一个完整的<a class="ae mc" href="https://www.youtube.com/watch?v=2zaPDfCKAvM" rel="noopener ugc nofollow" target="_blank">订餐应用</a>，集成stripe以接受支付，并将其部署到生产中。</p><p id="07d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">别忘了直接在你的收件箱</strong> <a class="ae mc" href="https://yogeshchavan.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">这里</strong> </a> <strong class="js iu">订阅我的每周时事通讯，里面有惊人的技巧、诀窍和文章。</strong></p></div></div>    
</body>
</html>