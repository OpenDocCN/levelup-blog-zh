<html>
<head>
<title>How To Periodically Check MongoDB Replica Set Status</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何定期检查MongoDB副本集状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-periodically-check-mongodb-replica-set-status-c25fc36d2b9e?source=collection_archive---------1-----------------------#2022-01-09">https://levelup.gitconnected.com/how-to-periodically-check-mongodb-replica-set-status-c25fc36d2b9e?source=collection_archive---------1-----------------------#2022-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3886" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">本教程将学习如何在MongoDB中检查副本集状态。</h2></div><p id="abac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> MongoDB </strong> </a> <strong class="kk iu">是</strong>一款NoSQL面向文档的数据库，让你轻松入门面向文档的数据库。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/7915ba4e1c2f0e4cdb8dcc12090a02de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZmN-fa07-hQyd9jOhQDKQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">来自<a class="ae le" href="https://docs.mongodb.com/manual/replication/" rel="noopener ugc nofollow" target="_blank"> Mongo </a>的mongo副本集</figcaption></figure><p id="0496" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">MongoDB的<a class="ae le" href="https://docs.mongodb.com/manual/reference/glossary/#std-term-replica-set" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">副本</strong> <strong class="kk iu">集</strong> </a>状态会告诉你副本集的健康状况，每个成员中有多少副本，副本集的大小，以及有多少副本集成员可用。</p><p id="97ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本教程将学习如何在MongoDB中定期检查副本集状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5000" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Mongo Shell</h1><p id="1dec" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">Mongo shell客户端提供了一些助手函数来与Mongo服务器对话。</p><ul class=""><li id="351e" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">rs.status()</code>:检查副本集的状态</li><li id="9c86" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">rs.initiate()</code>:用默认设置初始化set</li><li id="7294" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">rs.conf()</code>:获取当前配置对象</li><li id="5644" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">rs.add(hostportstr)</code>:向集合中添加新成员</li><li id="8338" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">rs.remove(hostportstr)</code>:从副本集中删除主机</li><li id="848f" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">rs.printReplicationInfo()</code>:检查<code class="fe ni nj nk nl b">oplog</code>大小和时间范围</li><li id="98bd" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">rs.printSecondaryReplicationInfo()</code>:检查副本集成员和复制延迟</li><li id="f050" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">db.isMaster()</code>:检查谁是主要的</li><li id="d3fc" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">db.hello()</code>:检查谁是主要的</li></ul><p id="bb6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中最有用的是<code class="fe ni nj nk nl b">rs.status()</code> <strong class="kk iu"> </strong>。它返回关于副本集的足够信息，并且易于记忆。另一个同样重要的功能是<code class="fe ni nj nk nl b">rs.printSecondaryReplicationInfo()</code>。</p><p id="359c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该函数的结果示例。</p><pre class="lg lh li lj gt nr nl ns nt aw nu bi"><span id="ff5c" class="nv md it nl b gy nw nx l ny nz">source: ctbx-dbup.cc:27017<br/> syncedTo: Fri Jan 07 2022 05:34:38 GMT+0000 (UTC)<br/> 411 secs (0.11 hrs) behind the primary<br/>source: ctbx-db-i1.cc:27017<br/> syncedTo: Fri Jan 07 2022 05:41:28 GMT+0000 (UTC)<br/> 1 secs (0 hrs) behind the primary<br/>source: ctbx-db-i2.cc:27017<br/> syncedTo: Fri Jan 07 2022 05:41:25 GMT+0000 (UTC)<br/> 4 secs (0 hrs) behind the primary</span></pre><p id="1be6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，它为我们提供了主节点和辅助节点之间复制延迟信息的格式化报告。</p><blockquote class="oa"><p id="66fa" class="ob oc it bd od oe of og oh oi oj ld dk translated">如何定期检查复制滞后信息？</p></blockquote><p id="cca6" class="pw-post-body-paragraph ki kj it kk b kl ok ju kn ko ol jx kq kr om kt ku kv on kx ky kz oo lb lc ld im bi translated">在Mongo Shell客户机中手动执行该函数是不可行的。让我们在下一节写一个简单的围棋程序。</p><h1 id="03fc" class="mc md it bd me mf op mh mi mj oq ml mm jz or ka mo kc os kd mq kf ot kg ms mt bi translated">Go程序</h1><h2 id="345d" class="nv md it bd me ou ov dn mi ow ox dp mm kr oy oz mo kv pa pb mq kz pc pd ms pe bi translated">数据结构</h2><p id="41d1" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">现在，让我们首先定义保存数据的基本数据结构</p><ul class=""><li id="145d" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">OpTime</code> : Mongo时间戳对象</li><li id="6618" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">ReplSetMember</code>:副本节点成员信息</li><li id="f6f6" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated"><code class="fe ni nj nk nl b">ReplSetGetStatus</code>:功能<code class="fe ni nj nk nl b">rs.status()</code>的结果</li></ul><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="pf pg l"/></div></figure><h2 id="f34d" class="nv md it bd me ou ov dn mi ow ox dp mm kr oy oz mo kv pa pb mq kz pc pd ms pe bi translated"><code class="fe ni nj nk nl b">GetReplSetStatus</code></h2><p id="2a56" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated"><code class="fe ni nj nk nl b">GetReplSetStatus</code>函数返回<code class="fe ni nj nk nl b">ReplSetGetStatus</code>结构。</p><p id="c431" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在其实现中，它首先在管理数据库上运行<code class="fe ni nj nk nl b">replSetGetStatus</code>命令，然后将结果解组到<code class="fe ni nj nk nl b">ReplSetGetStatus</code>结构中并返回。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="pf pg l"/></div></figure><h2 id="ec60" class="nv md it bd me ou ov dn mi ow ox dp mm kr oy oz mo kv pa pb mq kz pc pd ms pe bi translated">PrintSecondaryLags</h2><p id="945f" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">通过给定<code class="fe ni nj nk nl b">ReplSetGetStatus</code>结构，<code class="fe ni nj nk nl b">PrintSecondaryLags</code>函数打印每个辅助成员的滞后。</p><p id="a1cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它首先遍历ReplSetGetStatus结构的成员数组，以找到主成员的optime。然后，它再次遍历成员数组，以打印每个次要成员的lag。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="pf pg l"/></div></figure><h2 id="8887" class="nv md it bd me ou ov dn mi ow ox dp mm kr oy oz mo kv pa pb mq kz pc pd ms pe bi translated">主要功能</h2><p id="d764" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">主函数是程序的入口点。</p><ul class=""><li id="194b" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated">它首先创建一个<code class="fe ni nj nk nl b">mongo.Client</code>类型并连接到MongoDB数据库。</li><li id="8d39" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated">每隔5秒，它执行<code class="fe ni nj nk nl b">GetReplSetStatus</code>函数来获取<code class="fe ni nj nk nl b">ReplSetGetStatus</code>结构。然后它调用<code class="fe ni nj nk nl b">PrintSecondaryLags</code>函数来打印每个辅助成员的滞后。</li><li id="20fd" class="mz na it kk b kl nm ko nn kr no kv np kz nq ld ne nf ng nh bi translated">最后，它关闭与数据库的连接。</li></ul><p id="6f4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">main函数还处理Ctrl+C信号。它在退出之前关闭与数据库的连接。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="pf pg l"/></div></figure><p id="9440" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整的代码是<a class="ae le" href="https://gist.github.com/jerryan999/07c5fa5ad961ada799f4359b0faa6f0f" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="69a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢这篇文章，请鼓掌，让其他人也能看到。💚</p></div></div>    
</body>
</html>