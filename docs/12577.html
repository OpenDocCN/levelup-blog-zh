<html>
<head>
<title>How does JavaScript Scoping work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript作用域是如何工作的？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-does-javascript-scoping-work-f0f6b79ae896?source=collection_archive---------11-----------------------#2022-06-20">https://levelup.gitconnected.com/how-does-javascript-scoping-work-f0f6b79ae896?source=collection_archive---------11-----------------------#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fa7273a0ea90a3b95b8e08ae843cc856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gcpHX17g-moDLC6v"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">萨法尔·萨法罗夫在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4ffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据MDN的定义，JavaScript中的“作用域”就是当前执行的上下文。这到底意味着什么？作用域定义了当前可访问性范围内的变量和值，它也可以被称为变量的环境。让我们直接看一个例子:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b7fa" class="lk ll iq lg b gy lm ln l lo lp">function hello(){<br/>    var phrase = "Hello";<br/>    console.log(phrase + " Dylan");<br/>}</span><span id="5f57" class="lk ll iq lg b gy lq ln l lo lp">console.log(phrase);</span></pre><p id="9a8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个名为hello()的函数，并在函数中定义了一个名为“phrase”的变量。如果我们试图从函数外部访问变量“短语”,我们会得到这个错误:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="bbd0" class="lk ll iq lg b gy lm ln l lo lp">Uncaught ReferenceError: phrase is not defined</span></pre><p id="72b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很容易理解吧？从全球范围来看，我们不知道什么是“短语”。</p><p id="0433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我们定义了一个全局变量，并试图在函数内部使用它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6435" class="lk ll iq lg b gy lm ln l lo lp">var person = "Dylan"</span><span id="5200" class="lk ll iq lg b gy lq ln l lo lp">function hello(){<br/>    var phrase = "Hello";<br/>    console.log(phrase + " "+ person);<br/>}</span><span id="0123" class="lk ll iq lg b gy lq ln l lo lp">hello()</span></pre><p id="e3d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将获得:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d594" class="lk ll iq lg b gy lm ln l lo lp">Hello Dylan</span></pre><p id="078f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这里我们知道，作用域遵循层次结构，子层可以访问父层的变量，但反之则不行。</p><p id="671c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们上一篇文章(<a class="ae kc" href="https://medium.com/gitconnected/javascript-single-threaded-but-non-blocking-45c26d4d5bcc" rel="noopener"> JavaScript，单线程但非阻塞</a>)中，我们提到JavaScript引擎有一个函数执行上下文的调用栈。当创建全局执行上下文时，还会引入全局变量环境。如果我们现在定义一个全局变量，这个变量将被添加到全局对象(浏览器的窗口对象)下。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/39493c66a87b787acaf06e4bb84417f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Vm-POU6KTzCgUx6TFohPQ.png"/></div></div></figure><p id="594b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个执行上下文都有一个局部变量环境，称为局部范围。如果我们试图在当前的执行上下文中访问一个变量，它将开始在局部范围内寻找这个变量。如果没有找到该变量，它将向上到父作用域去寻找它。这就是所谓的范围链。例如:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="13a1" class="lk ll iq lg b gy lm ln l lo lp">function func1(){<br/>    var a = 20;<br/>    return function func2(){<br/>        console.log(a);<br/>    }<br/>}</span><span id="e586" class="lk ll iq lg b gy lq ln l lo lp">var a = 10;</span><span id="e3a1" class="lk ll iq lg b gy lq ln l lo lp">func1()();</span></pre><p id="9045" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，代码试图寻找变量<em class="ls"> a </em>，因为它在func2中使用。在func2范围内找不到它之后，它将向上找到func 1(a = 20)。因此，控制台日志的结果是20。</p><p id="2439" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ls">范围执行上下文链</em></p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lt"><img src="../Images/13e22cf478e8a6ed439381b9c7202fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qezGhhwbqelEZr-o43FSsA.png"/></div></div></figure><p id="5714" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把代码改成这样会怎么样:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1ef7" class="lk ll iq lg b gy lm ln l lo lp">function func1(){<br/>    var a = 20;<br/>    return func2()<br/>}</span><span id="46aa" class="lk ll iq lg b gy lq ln l lo lp">function func2(){<br/>    console.log(a);<br/>};</span><span id="1620" class="lk ll iq lg b gy lq ln l lo lp">var a = 10;</span><span id="5edf" class="lk ll iq lg b gy lq ln l lo lp">func1()</span></pre><p id="9122" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这次它印出了10张。为什么会这样呢？我们必须引入另一个术语，叫做词法作用域，这个作用域是我们决定函数定义的位置，而不是调用的位置。在第一个例子中，func2被定义在func1中；因此，它将接触func1来寻找不在其当前范围内的变量。然而，在第二个示例中，func2是在全局范围内定义的(与func1是同一级别)，因此它将在全局范围内查找丢失的变量。</p><p id="781a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这能让您对JavaScript作用域的工作原理有一个简单的了解。在我们以后的文章中，我还将引入提升、闭包、块范围等概念，让您有一个更清晰的了解。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><p id="c0bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想看更多的网络开发或软件工程相关的内容，请关注我。干杯！</p></div></div>    
</body>
</html>