<html>
<head>
<title>Coroutines, Retrofit, and a nice way to handle Responses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程、改进和处理响应的好方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coroutines-retrofit-and-a-nice-way-to-handle-responses-769e013ee6ef?source=collection_archive---------4-----------------------#2020-04-07">https://levelup.gitconnected.com/coroutines-retrofit-and-a-nice-way-to-handle-responses-769e013ee6ef?source=collection_archive---------4-----------------------#2020-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa29bac4befc36dc464e1916c9a22981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ci9Fk9bFKTDWgosl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马里奥·卡鲁索在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b778" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，我假设读者已经了解了<a class="ae kc" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>、<a class="ae kc" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协程</a>、<a class="ae kc" href="https://github.com/ReactiveX/RxKotlin" rel="noopener ugc nofollow" target="_blank">react vex</a>和<a class="ae kc" href="https://developer.android.com/jetpack/docs/guide#overview" rel="noopener ugc nofollow" target="_blank"> Android应用架构</a>的知识和基本概念。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="e796" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">一次性异步调用</h1><p id="2394" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">随着协程程序变得越来越流行，我决定更新我的<em class="ml">ViewModel-Repository-data source</em>通信逻辑，并将其从ReactiveX改为协程程序。Rx没有任何问题，实际上，Kotlin有数据流- checkout <a class="ae kc" href="https://medium.com/@elizarov/kotlin-flows-and-coroutines-256260fb3bdb" rel="noopener"> Flow和Channel </a> -但是我完全同意<a class="mm mn ep" href="https://medium.com/u/fa019abb3ca6?source=post_page-----769e013ee6ef--------------------------------" rel="noopener" target="_blank"> Daniel Lew </a>在他的<a class="ae kc" href="https://youtu.be/Axq8LdQqQGQ?t=2677" rel="noopener ugc nofollow" target="_blank"> Grokking Coroutines </a>演讲中所说的:</p><blockquote class="mo"><p id="4db3" class="mp mq iq bd mr ms mt mu mv mw mx la dk translated">“…并发与数据流没有任何关系。”</p></blockquote><p id="7a58" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们中有多少人实现过这样的场景:使用<em class="ml">“一次性提取操作”</em>来返回数据、完成或抛出错误:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基于流事件的体系结构</figcaption></figure><p id="201e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们真正想要的是一个异步任务，它将获取数据，可能执行一些操作，并最终在准备就绪时通知我们。我们不需要一个<a class="ae kc" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Single.html" rel="noopener ugc nofollow" target="_blank">单个的</a>或<a class="ae kc" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Completable.html" rel="noopener ugc nofollow" target="_blank">可完成的</a>来做这件事。</p><p id="0c8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到我已经在几个项目中成功地实现了这个方法，我决定写一篇关于它的文章。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="6c3c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步架构</h1><p id="f184" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">首先，让我们画出我们的建筑。我们将有一个<strong class="kf ir">基础服务</strong>负责处理网络呼叫、成功和错误。<strong class="kf ir"> ChildServices </strong>将扩展<em class="ml"> BaseService </em>。我们的<strong class="kf ir">存储库</strong>将与<em class="ml"> ChildServices </em>进行通信，并管理所有信息，然后将信息返回给<strong class="kf ir"> ViewModel </strong>，并将<strong class="kf ir">响应</strong>映射到ViewModel的世界。</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">异步架构的基础服务</figcaption></figure><p id="0b06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml"> Api </em>和<em class="ml">儿童服务</em>非常简单:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">异步架构的Api和子服务</figcaption></figure><p id="d1e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong> <em class="ml"> ApiService </em>它是一个抽象层，用来更好地将API逻辑与<em class="ml"> BaseService隔离开来。</em></p><p id="0472" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在有趣的部分，<strong class="kf ir">储存库</strong>。在我们的<em class="ml"> BaseService </em>中，我们将返回一个带有成功或错误的<strong class="kf ir">结果&lt; T &gt; </strong>:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，这也是我们将在存储库中返回的内容:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于拼图的最后一块，<strong class="kf ir">视图模型</strong>(子):</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9940" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！</p><p id="648f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经注意到，我的存储库调用被包装在一个<code class="fe nj nk nl nm b">safeCall</code>函数中。存在于<strong class="kf ir"> BaseViewModel中的简单函数:</strong></p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="aed5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的目的是通过<code class="fe nj nk nl nm b">parseError(e)</code>返回成功调用的数据或处理错误(可以显示Toast、Snackbar等)。</p><p id="5305" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，在某些情况下，我们可能需要向ViewModel返回更详细的信息，或者提供更好的错误处理UX体验，例如，根据类型显示错误动画。要做到这一点，让我们倒回去一点，再次关注我们的存储库(这就是为什么我把它叫做<em class="ml">有趣的部分</em>)。</p><blockquote class="mo"><p id="1c7a" class="mp mq iq bd mr ms mt mu mv mw mx la dk translated">"现在有趣的部分，<strong class="ak">储存库."</strong></p></blockquote><pre class="nn no np nq nr ns nm nt nu aw nv bi"><span id="7e95" class="nw lj iq nm b gy nx ny l nz oa">is Result.Success -&gt; result.data<br/>is Result.Error -&gt; throw result.exception</span></pre><p id="058d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用更优雅的方法更新这段代码。为此，让我们把它看作是一个<em class="ml">“用例”</em>响应<em class="ml">。</em>一个<code class="fe nj nk nl nm b">sealed class</code>是一个很好的候选，因为它可以表示<em class="ml">状态</em>并保存特定<em class="ml">状态</em>的数据</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2b7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将api调用更新为:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="12fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们的视图模型:</p><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0638" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，代码更容易阅读，因为它记录了自己，并且变得更容易维护和测试。</p><p id="9ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，<a class="mm mn ep" href="https://medium.com/u/d5885adb1ddf?source=post_page-----769e013ee6ef--------------------------------" rel="noopener" target="_blank">弗洛里纳·蒙特内斯库</a>发表了一篇文章<a class="ae kc" href="https://medium.com/androiddevelopers/sealed-with-a-class-a906f28ab7b5" rel="noopener"> <em class="ml">用一个类</em> </a> <em class="ml"> </em>密封，谈论如何实现这种行为。我很高兴地注意到我也在使用她的方法。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="c1c6" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="384b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">通过这种重构，我消除了对额外库的需要，在这种情况下是RxKotlin，但最重要的是——因为有人可能会说我也可以使用流和通道而不导入RxKotlin——我们使用了正确的工具来完成这项工作:</p><blockquote class="mo"><p id="9e2e" class="mp mq iq bd mr ms mt mu mv mw mx la dk translated">用协程程序实现的异步编程模式，用于执行“一次性调用”<em class="ob">。</em></p></blockquote><p id="b9ad" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">关于Android应用架构，我们的服务和存储库通过一个<code class="fe nj nk nl nm b">sealed class Result</code>进行通信。然后，在将它返回到ViewModel之前，如果需要的话，存储库会将它再次映射到另一个代表<em class="ml">“用例”的<code class="fe nj nk nl nm b">sealed class</code>中。</em>这种<em class="ml"> </em>方式返回了详细的响应，我们也受益于更清晰的代码。</p><p id="387b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你觉得这篇文章有用，感谢阅读。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="a605" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">分级编码</h1><p id="adf7" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">感谢您成为我们社区的一员！<a class="ae kc" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae kc" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Skilled.dev编码面试课程</strong> </a>。</p><div class="oc od gp gr oe of"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">编写面试问题</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">掌握编码面试的过程</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">技术开发</p></div></div><div class="oo l"><div class="op l oq or os oo ot jw of"/></div></div></a></div></div></div>    
</body>
</html>