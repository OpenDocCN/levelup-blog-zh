<html>
<head>
<title>Understanding Interfaces in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Go中的接口</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-interfaces-in-go-7dc9b1344b61?source=collection_archive---------6-----------------------#2021-10-30">https://levelup.gitconnected.com/understanding-interfaces-in-go-7dc9b1344b61?source=collection_archive---------6-----------------------#2021-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aa9c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在Go中使用接口向类型添加方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7629d8e8ed30101eaf55563553e233fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z19k_ClAsxl1akxK"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mangofantasy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·约翰逊</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">围棋中一个经常不容易掌握的重要话题是<strong class="lb iu">接口</strong>。一个<em class="lv">接口</em>定义一个对象的行为，指定它需要实现的方法。接口在Go中有几个重要的用途:</p><ul class=""><li id="432f" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">它使您的代码更加通用</li><li id="62e2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">它迫使你采用代码封装</li></ul><p id="3cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将让你很容易理解什么是Go中的接口，以及如何在你的程序中使用它。为了使这个主题不那么抽象，我将用几个具体的例子来说明接口。</p><h1 id="cbac" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">定义接口</h1><p id="2423" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在Go中，接口是一个名为方法签名集合的<em class="lv">。在下面的例子中，<code class="fe nh ni nj nk b">DigitsCounter</code>是一个接口，它包含一个名为<code class="fe nh ni nj nk b">CountOddEven</code>的方法签名:</em></p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="7c92" class="np ml it nk b gy nq nr l ns nt">type DigitsCounter <strong class="nk iu">interface</strong> {<br/>    CountOddEven() (int, int)<br/>}</span></pre><p id="4052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">CountOddEven</code>方法签名也包含函数的返回类型(它返回一对整数值)，但不包含实现。</p><h1 id="d962" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">实现接口</h1><p id="75f6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">现在让我们创建一个名为<code class="fe nh ni nj nk b">DigitString</code>的新类型，它的类型是<code class="fe nh ni nj nk b">string</code>:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="19df" class="np ml it nk b gy nq nr l ns nt">type DigitsCounter interface {<br/>    CountOddEven() (int, int)<br/>}</span><span id="761d" class="np ml it nk b gy nu nr l ns nt"><strong class="nk iu">type DigitString string</strong></span></pre><p id="2977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在围棋中，<code class="fe nh ni nj nk b">DigitString</code>被称为<em class="lv">的命名式</em>，是<em class="lv">的底层式</em> <code class="fe nh ni nj nk b">string</code>。通过将命名类型指定为<em class="lv">接收者</em>，命名类型可以拥有自己的方法，而这是通过实现接口来实现的。</p><blockquote class="nv nw nx"><p id="3c93" class="kz la lv lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">这类似于在面向对象编程范例中从对象调用方法。</p></blockquote><p id="fca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以通过实现在<code class="fe nh ni nj nk b">DigitCounter</code>接口中定义的<code class="fe nh ni nj nk b">CountOddEven</code>函数签名，将<code class="fe nh ni nj nk b">DigitString</code>指定为<code class="fe nh ni nj nk b">CountOddEven</code>函数的接收者:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="37e6" class="np ml it nk b gy nq nr l ns nt"><strong class="nk iu">// </strong>DigitString implements the DigitsCounter interface<strong class="nk iu"><br/></strong>func (ds DigitString) CountOddEven() (int, int) {<br/>    odds, evens := 0, 0<br/>    for _, digit := range ds {<br/>        if digit%2 == 0 {<br/>            evens++<br/>        } else {<br/>            odds++<br/>        }<br/>    }<br/>    return odds, evens<br/>}</span></pre><p id="9349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们说<em class="lv"> DigitString类型实现了DigitsCounter接口</em>。现在可以从类型为<code class="fe nh ni nj nk b">DigitString</code>的变量中调用<code class="fe nh ni nj nk b">CountOddEven</code>方法:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="0eee" class="np ml it nk b gy nq nr l ns nt">func main() {<br/><strong class="nk iu">    s := DigitString("123456789")<br/>    fmt.Println(s.CountOddEven()) // 5 4</strong><br/>}</span></pre><p id="17f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您可以让<code class="fe nh ni nj nk b">DigitString</code>成为任何其他函数的接收者，而不一定是在接口中定义的函数。例如，您还可以使<code class="fe nh ni nj nk b">DigitString</code>类型成为一个名为<code class="fe nh ni nj nk b">PrintContent</code>(没有在任何接口中定义)的函数的接收者:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="c387" class="np ml it nk b gy nq nr l ns nt"><strong class="nk iu">func (ds DigitString) PrintContent() {<br/>    fmt.Println(ds)<br/>}</strong></span><span id="3ead" class="np ml it nk b gy nu nr l ns nt">func main() {<br/>    s := DigitString("123456789")<br/>    fmt.Println(s.CountOddEven()) // 5 4<br/><strong class="nk iu">    s.PrintContent()              // "123456789"</strong><br/>}</span></pre><h1 id="b727" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">界面的使用</h1><p id="82ac" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">既然您已经看到了接口的基本概念以及如何通过命名类型实现它，那么让我们考虑另一个例子来看看使用接口的好处。考虑以下程序:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="0156" class="np ml it nk b gy nq nr l ns nt">package main</span><span id="ef26" class="np ml it nk b gy nu nr l ns nt">import (<br/>    "fmt"<br/>    "math"<br/>)</span><span id="2644" class="np ml it nk b gy nu nr l ns nt">//---define an interface called Shape---<br/>type Shape interface {<br/>    Area() float64<br/>}</span><span id="3ca0" class="np ml it nk b gy nu nr l ns nt">//---define two types here-Circle and Square---<br/>type Circle struct {<br/>    radius float64<br/>}</span><span id="73e9" class="np ml it nk b gy nu nr l ns nt">type Square struct {<br/>    length float64<br/>}</span><span id="21be" class="np ml it nk b gy nu nr l ns nt">//---Circle implements Shape---<br/>func (c Circle) Area() float64 {<br/>    return math.Pi * math.Pow(c.radius, 2)<br/>}</span><span id="e87e" class="np ml it nk b gy nu nr l ns nt">//---Square implements Shape---<br/>func (s Square) Area() float64 {<br/>    return math.Pow(s.length, 2)<br/>}</span><span id="a355" class="np ml it nk b gy nu nr l ns nt">func main() {<br/>    c1 := Circle{radius: 5}<br/>    s1 := Square{length: 6}<br/>    fmt.Println(c1.Area()) // 78.53981633974483<br/>    fmt.Println(s1.Area()) // 36<br/>}</span></pre><p id="1f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面，我有以下内容:</p><ul class=""><li id="4e1d" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">一个名为<code class="fe nh ni nj nk b">Shape</code>的接口，带有方法签名<code class="fe nh ni nj nk b">Area</code>。</li><li id="84a2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">两个命名类型称为<code class="fe nh ni nj nk b">Circle</code>和<code class="fe nh ni nj nk b">Square</code>，底层类型为<code class="fe nh ni nj nk b">struct</code>。它们每个都有一个成员，分别是<code class="fe nh ni nj nk b">radius</code>和<code class="fe nh ni nj nk b">length</code></li><li id="62b1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe nh ni nj nk b">Circle</code>和<code class="fe nh ni nj nk b">Square</code>命名类型都实现了<code class="fe nh ni nj nk b">Shape</code>接口，并为<code class="fe nh ni nj nk b">Area</code>方法提供了定义。这很有用，因为计算圆的面积的公式显然不同于正方形的面积公式。</li><li id="61fb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">现在可以从类型为<code class="fe nh ni nj nk b">Circle</code>和<code class="fe nh ni nj nk b">Square</code>的变量中调用<code class="fe nh ni nj nk b">Area</code>方法。</li></ul><p id="41cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时此刻，没有令人信服的理由使用界面。毕竟，如果我移除了<code class="fe nh ni nj nk b">Shape</code>接口，上面的程序仍然可以工作，不会有任何问题。</p><p id="a2ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果你想打印一组<code class="fe nh ni nj nk b">Circle</code>和<code class="fe nh ni nj nk b">Square</code>变量的区域呢？使用上面的例子，您必须单独调用<code class="fe nh ni nj nk b">Area</code>方法:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="39b1" class="np ml it nk b gy nq nr l ns nt">    fmt.Println(c1.Area()) <br/>    fmt.Println(s1.Area()) </span></pre><p id="bfcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有了接口，你现在可以把所有这些变量放到一个类型为<code class="fe nh ni nj nk b">Shape</code>的片段中，就像这样:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="cd61" class="np ml it nk b gy nq nr l ns nt">    shapes := []Shape{c1, s1}</span></pre><p id="2608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe nh ni nj nk b">c1</code>和<code class="fe nh ni nj nk b">s1</code>都实现了<code class="fe nh ni nj nk b">Shape</code>接口，所以现在可以遍历这个切片并调用每个对应类型的<code class="fe nh ni nj nk b">Area</code>方法。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="3fb2" class="np ml it nk b gy nq nr l ns nt">    for _, v := range shapes {<br/>        fmt.Println(v.Area())<br/>    }</span></pre><p id="4e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我现在有了一个名为<code class="fe nh ni nj nk b">Triangle</code>的新命名类型:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="cc40" class="np ml it nk b gy nq nr l ns nt">type Triangle struct {<br/>    base   float64<br/>    height float64<br/>}</span></pre><p id="80ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe nh ni nj nk b">Triangle</code>命名类型没有实现<code class="fe nh ni nj nk b">Shape</code>接口。如果创建一个类型为<code class="fe nh ni nj nk b">Triangle</code>的变量并尝试将其添加到类型为<code class="fe nh ni nj nk b">Shape</code>的切片中:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="0fef" class="np ml it nk b gy nq nr l ns nt"><strong class="nk iu">    t1 := Triangle{base: 6, height: 5}</strong><br/>    shapes := []Shape{c1, s1<strong class="nk iu">, t1</strong>}    // error</span></pre><p id="d10e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将得到错误:“<em class="lv">不能使用T1(类型三角形)作为切片文字中的类型形状:三角形不实现形状(缺少面积方法)</em>”。</p><p id="92b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决这个问题，让<code class="fe nh ni nj nk b">Triangle</code>命名类型实现<code class="fe nh ni nj nk b">Shape</code>接口:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="e55c" class="np ml it nk b gy nq nr l ns nt"><strong class="nk iu">func (t Triangle) Area() float64 {<br/>    return (t.base * t.height) / 2<br/>}</strong></span></pre><h1 id="ea3e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">桁条界面</h1><p id="dd2d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">即使您不熟悉Go中的接口，您也会不知不觉地使用接口。有没有试过打印出结构体或变量的值？您是否想知道为什么输出看起来是这样的？</p><p id="6564" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你有一个名为<code class="fe nh ni nj nk b">Person</code>的结构:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="1460" class="np ml it nk b gy nq nr l ns nt">type Person struct {<br/>    FirstName string<br/>    LastName  string<br/>    Age       int<br/>}</span><span id="1889" class="np ml it nk b gy nu nr l ns nt">func main() {<br/>    me := Person{FirstName: "Wei-Meng", LastName: "Lee", Age: 25}<br/>    fmt.Println(me) <br/>}</span></pre><p id="d20b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您打印了<code class="fe nh ni nj nk b">me</code>变量，有没有想过为什么打印struct的输出是这样的？</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="e56c" class="np ml it nk b gy nq nr l ns nt">{Wei-Meng Lee 25}</span></pre><p id="6435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来，每种类型都实现了一个名为<code class="fe nh ni nj nk b">Stringer</code>的特殊接口，该接口在<strong class="lb iu"> fmt </strong>包中定义。<code class="fe nh ni nj nk b">Stringer</code>接口包含一个名为<code class="fe nh ni nj nk b">String</code>的方法签名:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="9cfa" class="np ml it nk b gy nq nr l ns nt">type Stringer interface {<br/>    String() string<br/>}</span></pre><p id="c176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您试图使用<strong class="lb iu"> fmt </strong>包中的函数(如<code class="fe nh ni nj nk b">Println</code>)打印出变量值时，它将检查<code class="fe nh ni nj nk b">String</code>函数的实现，以决定如何打印其内容。所以如果你不喜欢你的变量的打印方式，你可以覆盖默认的<code class="fe nh ni nj nk b">String</code>方法，就像这样:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="0966" class="np ml it nk b gy nq nr l ns nt">type Person struct {<br/>    FirstName string<br/>    LastName  string<br/>    Age       int<br/>}</span><span id="b034" class="np ml it nk b gy nu nr l ns nt"><strong class="nk iu">// implements the Stringer interface and overrides the String <br/>// method<br/>func (p Person) String() string {  <br/>    return fmt.Sprintf("%v %v (%d years old)",<br/>    p.FirstName, p.LastName, p.Age)<br/>}</strong></span></pre><p id="e14b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您现在试图打印出一个类型为<code class="fe nh ni nj nk b">Person</code>的变量时，您将看到新的格式化输出:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="f23e" class="np ml it nk b gy nq nr l ns nt">    fmt.Println(me)<br/>    // Wei-Meng Lee (25 years old)</span></pre><h1 id="64ce" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">空界面</h1><p id="d3fa" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在Go中，没有方法的接口被称为<em class="lv">空接口</em>。空接口表示为:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="bfb3" class="np ml it nk b gy nq nr l ns nt">interface{}</span></pre><blockquote class="nv nw nx"><p id="9014" class="kz la lv lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">由于空接口没有方法，所有类型实际上都实现了空接口。</p></blockquote><p id="dd5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您希望在编译时处理未知类型的数据时，空接口非常有用。考虑下面的场景，您想要编写一个名为<code class="fe nh ni nj nk b">Multiple</code>的函数，它接受两个参数:</p><ul class=""><li id="8413" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">第一个参数可以是数值或字符串值</li><li id="09fd" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">第二个参数是一个整数</li><li id="48da" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果第一个参数是数值，则将第一个值乘以第二个值；如果第一个参数是字符串，则根据第二个参数中指定的值重复该值</li><li id="16c2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe nh ni nj nk b">Multiple</code>函数的返回值取决于第一个参数的类型</li></ul><p id="390d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于上述要求，现在您可以利用空接口(以粗体突出显示)编写<code class="fe nh ni nj nk b">Multiple</code>函数:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="2225" class="np ml it nk b gy nq nr l ns nt">func Multiple(<strong class="nk iu">i interface{}</strong>, times int) <strong class="nk iu">interface{}</strong> {<br/>    switch v := i.(type) {                 // checks the type of i<br/>    case int:<br/>        return (v * times)                 // v is int<br/>    case float64:<br/>        return (v * float64(times))        // v is float64<br/>    case string:<br/>        return strings.Repeat(v, times)    // v is string<br/>    default:        <br/>        return "I don't know what to do"<br/>    }<br/>}</span></pre><p id="b676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以使用各种数据类型调用<code class="fe nh ni nj nk b">Multiple</code>函数:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="acc8" class="np ml it nk b gy nq nr l ns nt">func main() {<br/>    result := Multiple(4, 5)<br/>    fmt.Printf("%T - %v\n", result, result) <br/>    <strong class="nk iu">// int - 20</strong></span><span id="4590" class="np ml it nk b gy nu nr l ns nt">    result = Multiple("Cool", 5)<br/>    fmt.Printf("%T - %v\n", result, result)<br/>    // <strong class="nk iu">string - CoolCoolCoolCoolCool</strong><br/>}</span></pre><h1 id="9a36" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">类型断言</h1><p id="b387" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">还记得我们之前创建的<code class="fe nh ni nj nk b">Triangle</code>命名类型吗？如果你想知道一个命名的类型是否实现了一个特定的接口，你可以使用<em class="lv">类型断言</em>。</p><p id="65e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，将变量赋给一个<em class="lv">空接口</em>:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="5e3f" class="np ml it nk b gy nq nr l ns nt">    t1 := Triangle{base: 6, height: 5}<br/>    <strong class="nk iu">var v interface{} = t1</strong></span></pre><p id="4a02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，使用<em class="lv">类型断言</em>来访问接口的底层具体值:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="9fc5" class="np ml it nk b gy nq nr l ns nt">    t, ok := <strong class="nk iu">v.(Shape)</strong></span></pre><p id="932a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型断言将返回两个值—基础值和指示断言是否成功的结果。您现在可以检查第二个结果，以了解该类型是否实现了<code class="fe nh ni nj nk b">Shape</code>接口，以及它是否调用了<code class="fe nh ni nj nk b">Area</code>方法:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="43b0" class="np ml it nk b gy nq nr l ns nt">    if ok {<br/>        fmt.Println(t.Area())<br/>    }</span></pre><p id="8951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上代码片段可以组合成以下内容:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="f15c" class="np ml it nk b gy nq nr l ns nt">    if t, ok := v.(Shape); ok {<br/>        fmt.Println(t.Area())<br/>    }</span></pre><h1 id="c2d5" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">摘要</h1><p id="d6ec" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">接口是围棋编程中的一个重要课题。在下一篇文章中，我将向您展示一些更实际的接口用法，特别是在解析JSON字符串方面。在那之前，好好学习围棋吧！或者看看我最近写的一本关于围棋编程的书。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/66e0defb6f428636cbd517aecfa77fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*vLaO3BdSWllS4RjheFPX0Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.amazon.com/Programming-Language-Dummies-Computer-Tech/dp/1119786193/" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/Programming-Language-Dummies-Computer-Tech/DP/1119786193/</a></figcaption></figure></div></div>    
</body>
</html>