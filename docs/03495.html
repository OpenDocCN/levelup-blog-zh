<html>
<head>
<title>What “Big O” Really Means</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“大O”的真正含义是什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-big-o-really-means-e5f15044c9d2?source=collection_archive---------9-----------------------#2020-05-12">https://levelup.gitconnected.com/what-big-o-really-means-e5f15044c9d2?source=collection_archive---------9-----------------------#2020-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ba13" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">大多数时候，大O符号的用法都有点不正确。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eda822505ebcef17179707ecf0831a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCfHR6TTkeyaDHMnxP3iWw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@emilep?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">émile Perron</a>拍摄。</figcaption></figure><p id="6e8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下你在下面的情况:你是一名招聘人员，正在面试两个软件工程师职位的候选人。因此，您向他们展示包含线性搜索算法的标准实现的Java代码，并让他们告诉您使用大O符号有多高效:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考生A检查完代码后告诉你，这个算法是<em class="lu"> O(n) </em>。另一方面，候选人B告诉你是<em class="lu"> O(n ) </em>。根据他们的回答，你认为这两个候选人中哪一个可能更适合这份工作？</p><p id="6bfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能是候选人A吧？</p><p id="8a5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我告诉你两个答案都是正确的呢？</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="0430" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">大O符号代表一个上限</h1><p id="6a6b" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">是真的。候选B在技术上也是正确的，因为根据定义，大O符号实际上代表一组数学函数的上界。当你说一个函数<em class="lu"> f(n)是O(g(n))，</em>真正的意思是<em class="lu"> f(n) </em> <em class="lu">并不比<em class="lu"> g(n) </em>有更高的增长阶</em>。</p><p id="084f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非正式地说，<em class="lu"> O(g(n)) </em>可以定义为包含所有不<em class="lu"/><em class="lu"/>比<em class="lu"> g(n) </em>增长更快的函数的<em class="lu">数学函数集</em>。因此，以下所有函数都在集合<em class="lu"> O(n ): </em>中</p><ul class=""><li id="c8c7" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated"><em class="lu"> f(n) = n +3n + 2 </em></li><li id="00dc" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><em class="lu"> f(n) = n log(n) </em></li><li id="3a88" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><em class="lu"> f(n) = 3n+1 </em></li><li id="d637" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><em class="lu"> f(n) =n </em></li><li id="6238" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><em class="lu"> f(n) = log(n) </em></li><li id="4d14" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><em class="lu"> f(n) =1 </em></li></ul><p id="d64c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，<em class="lu"> f(n)=n </em>不在<em class="lu"> O(n ) </em>中，因为<em class="lu"> f(n)=n </em>比<em class="lu"> g(n)=n . </em>增长得快</p><p id="0c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次考虑上面Java代码中的例子。在最坏的情况下，该算法执行<em class="lu"> n </em>次比较。考生A说是<em class="lu"> O(n) </em>显然是对的。但是考生B说算法是<em class="lu"> O(n ) </em>的时候<em class="lu">也是</em>正确的，因为，确实，<em class="lu"> f(n)=n </em>包含在<em class="lu"> O(n ) </em>中。尽管如此，他可能不会得到这份工作。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="c599" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">紧边界和大θ</h1><p id="15f3" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">问题是，许多人认为大O是对算法效率的准确描述，而根据定义，这种符号只能代表该效率的上限。如果你说一个算法是<em class="lu"> O(n)，</em>你不够精确。从技术上讲，同样的算法也可以同时是<em class="lu"> O(n)、O(log(n)) </em>和<em class="lu"> O(1) </em>，这里仅举几个可能性。</p><p id="b905" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果招聘人员在面试中问你一个给定算法的效率，你可以用一个不必要的高上限来回答，比如<em class="lu"> O(nⁿ) </em>，你可能在任何面试中都是正确的。但这绝不会帮助你得到这份工作，因为招聘人员并不是真的期望你提供算法效率的上限。当人们询问大O符号时，他们通常想知道描述该算法效率的<em class="lu">最低</em>上限是多少，在上面的例子中是<em class="lu"> O(n) </em>。这就是通常所说的“<strong class="ky ir"> <em class="lu">紧界</em></strong><em class="lu">”——</em>如果我们再把它变小，就不能用来描述算法的效率<em class="lu">。</em></p><p id="aed8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上有一个类似于大O的符号，确切地代表了招聘人员对候选人的期望。它被称为<strong class="ky ir"> <em class="lu">大θ</em></strong><em class="lu"/>(θ)<em class="lu"/>符号，用来表示函数的紧界。说<em class="lu"> f(n)是θ(g(n))</em>是指<em class="lu"> f(n) </em>与<em class="lu"> g(n) </em>有<em class="lu">相同的增长顺序。几个例子:</em></p><ul class=""><li id="d4a5" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">n∈θ(n)</li><li id="e5b1" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">2n∈θ(n)</li><li id="e167" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">n+3n+2∈θ(n)</li><li id="74e1" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">∉θ(n)</li><li id="5930" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">∉θ(n)。</li></ul><p id="32fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次考虑上面的例子，但是现在想象你重新表述你的问题，并且根据大Theta符号询问两个候选人关于算法的效率。如果考生A说算法运行在<em class="lu">θ(n)</em>，他就又一次正确了。但是，如果候选人B说它符合<em class="lu">θ(n)</em>，那么他就绝对错了，你的结论是正确的，他可能不适合这份工作。</p><p id="67a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当人们谈论算法的效率时，大多数时候他们感兴趣的是获得该效率的严格界限。但是，他们通常不使用大θ，而是使用大o。我猜，在某个时候，有人认为说“n的oh”比说“n的θ”听起来好得多，这最终成为了规范。</p><p id="2032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，这没什么大不了的。这只是人们用一个符号(<em class="lu"> O </em>)来表示紧密界限的问题，这个符号不同于约定俗成的符号(<em class="lu">θ</em>)。尽管如此，如果有人不能从上下文中判断出大O是用来表示上界还是紧界，有时还是会引起不必要的混乱。</p><h1 id="037d" class="mc md iq bd me mf nn mh mi mj no ml mm jw np jx mo jz nq ka mq kc nr kd ms mt bi translated">大ω</h1><p id="aee0" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">除了大O和大θ，还有第三种渐近符号经常在算法分析中使用:<strong class="ky ir"> <em class="lu">大ω</em></strong>(ω)。这可以理解为大O的逆，因为它代表了一组数学函数的下界:<em class="lu">ω(g(n))</em>是<em class="lu">不具有比</em> <em class="lu"> g(n) </em>低的增长顺序 <em class="lu">的所有函数的集合。比如<em class="lu">n∈ω(n)</em>和<em class="lu">n∈ω(n)</em>，但是<em class="lu">n∉ω(n)</em>。</em></p><p id="14e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然大O和大Theta大多用于描述算法的效率，但大Omega通常用于描述计算问题的<em class="lu">内在复杂性</em>。例如，在一个未排序的数组中搜索一个元素的问题被称为<em class="lu">ω(n)</em>，因为在最坏的情况下，任何算法都需要检查<em class="lu">至少</em>数组中所有的<em class="lu"> n </em>个位置，然后才能确定所搜索的元素不在那里。这意味着不可能为那个问题设计一个运行时间小于<em class="lu">θ(n)</em>的算法。</p><p id="3cab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">了解大ω其实更容易定义大θ:<em class="lu">θ(g(n))</em>是<em class="lu"> O(g(n)) </em>和<em class="lu">ω(g(n))</em>的交集。一个函数<em class="lu"> f(n) </em>在<em class="lu">θ(g(n))</em>中当且仅当它同时在<em class="lu">ω(g(n))</em>和<em class="lu"> O(g(n))中。</em></p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="4d26" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">数学定义</h1><p id="a40f" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">在上面的讨论中，我试图描述这些渐近符号的含义，而没有真正进入它们的数学形式。如果你有兴趣了解更多，看看我的文章“<a class="ae kv" href="https://towardsdatascience.com/the-math-behind-big-o-and-other-asymptotic-notations-64487889f33f" rel="noopener" target="_blank">“大O”背后的数学和其他渐近符号</a>”。</p><div class="ns nt gp gr nu nv"><a href="https://towardsdatascience.com/the-math-behind-big-o-and-other-asymptotic-notations-64487889f33f" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">“大O”和其他渐近符号背后的数学</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">像“大O”、“大ω”和“大θ”这样的符号的正式定义。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="5cd8" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">总结和最终想法</h1><p id="bc05" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf mw lh li lj mx ll lm ln my lp lq lr ij bi translated">很多时候，人们用大O来形容紧界。然而，根据定义，大O是一种描述上界的形式主义，而不是紧界。如果一个给定的算法是<em class="lu"> O(n) </em>，也可以说是<em class="lu"> O(n ) </em>、<em class="lu">O(n)</em>等无限个效率类。类似的符号Big Theta(θ)在描述给定算法的效率方面做得更好，因为它提供了一种准确描述严格界限的方法。然而，许多人从未听说过大θ，因为它在实践中很少使用。</p><p id="64f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请不要误解我。我的意图不是发起一场讨伐，强迫所有人在描述一个算法的效率时只使用大θ而不使用大O。我自己不这样做，正如我之前所说，我不认为这种对大O的误解有什么大不了的。尽管如此，我相信分享符号背后的理论是值得的，因为我确信有许多人经常使用大O符号，但不熟悉它的正式定义。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="990c" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">参考</h1><ul class=""><li id="3866" class="mz na iq ky b kz mu lc mv lf ok lj ol ln om lr ne nf ng nh bi translated"><a class="ae kv" href="https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/big-big-theta-notation" rel="noopener ugc nofollow" target="_blank">大西塔符号</a>，在可汗学院。</li><li id="d6fe" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated"><a class="ae kv" href="https://www.amazon.com/gp/product/0201743957/ref=as_li_tl?ie=UTF8&amp;tag=chaulio0b-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0201743957&amp;linkId=aff0d43922d6a31ae64de969b8441371" rel="noopener ugc nofollow" target="_blank">Anany Levitin的设计介绍&amp;算法分析</a>。</li></ul></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="aa05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lu">披露:此帖子包含一个或多个来自亚马逊服务有限责任公司协会计划的链接。作为代销商，我从通过这些链接购买的商品中获得佣金，客户无需支付额外费用。</em></p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="ca2c" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">更多由同一作者</h1><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/8-ways-to-measure-execution-time-in-c-c-48634458d0f9"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">C/C++中测量执行时间的8种方法</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">不幸的是，没有放之四海而皆准的解决方案。在这里你会找到一些可用的选项。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oe l"><div class="on l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://towardsdatascience.com/version-control-with-git-get-started-in-less-than-15-minutes-696b4ce7ce92" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">使用Git进行版本控制:不到15分钟即可开始</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">完全初学者的循序渐进教程。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="oo l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://towardsdatascience.com/two-simple-steps-to-create-colorblind-friendly-data-visualizations-2ed781a167ec" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">创建色盲友好数据可视化的两个简单步骤</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">你的剧情可能很多人都无法理解。以下是解决这个问题的方法。</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="op l og oh oi oe oj kp nv"/></div></div></a></div></div></div>    
</body>
</html>