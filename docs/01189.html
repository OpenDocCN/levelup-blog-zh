<html>
<head>
<title>JWT Auth in a React + Rails App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React + Rails应用程序中的JWT验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/jwt-auth-in-a-react-rails-app-8a7e6ba1ac0?source=collection_archive---------0-----------------------#2019-11-25">https://levelup.gitconnected.com/jwt-auth-in-a-react-rails-app-8a7e6ba1ac0?source=collection_archive---------0-----------------------#2019-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1b3df87f207ac583ac6dbb8ad9f3b2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*or-e6SwzLqNZ5_r0LnnlwQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">反应+轨道+ JWT</figcaption></figure></div><div class="ab cl kc kd hu ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ij ik il im in"><p id="7bdd" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">这是为React(客户端)+ Rails(服务器端)应用程序实现JSON Web令牌(JWT)的指南。为了完全实现JWT，React和Rails都将被设置来处理生成的令牌。请记住，本指南将涵盖实施JWT的一种基本方法。</p><p id="45d2" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">让我们从服务器端开始。</p><h1 id="1dab" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Rails API</h1><p id="f1c9" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">对于指南的这一部分，我将参考我的jwt后端存储库:<a class="ae mk" href="https://github.com/reireynoso/jwt-backend" rel="noopener ugc nofollow" target="_blank">https://github.com/reireynoso/jwt-backend</a></p><p id="f485" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">通过将以下内容添加到gemfile，JWT将被集成到API中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="24d3" class="mu li iq mq b gy mv mw l mx my">gem 'jwt'</span></pre><p id="874a" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">从终端运行:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="eaf4" class="mu li iq mq b gy mv mw l mx my">bundle install</span></pre><p id="ccb7" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">这种回购有以下几种途径:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="14d9" class="mu li iq mq b gy mv mw l mx my">Rails.application.routes.draw do</span><span id="3049" class="mu li iq mq b gy mz mw l mx my">   resource :users, only: [:create]</span><span id="1e97" class="mu li iq mq b gy mz mw l mx my">   post "/login", to: "auth#login"</span><span id="2978" class="mu li iq mq b gy mz mw l mx my">   get "/auto_login", to: "auth#auto_login"</span><span id="81ab" class="mu li iq mq b gy mz mw l mx my">   get "/user_is_authed", to: "auth#user_is_authed"</span><span id="4cbb" class="mu li iq mq b gy mz mw l mx my">end</span></pre><p id="a910" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated"><code class="fe na nb nc mq b">resource: users, only: [: create]</code>处理用户注册。<code class="fe na nb nc mq b">post “/login”, to: “auth#login”</code>处理数据库中现有用户的登录。一旦用户能够成功注册/登录,<code class="fe na nb nc mq b">get “/auto_login”, to: “auth#auto_login”</code>处理自动登录。最后，<code class="fe na nb nc mq b">get “/user_is_authed”, to: “auth#user_is_authed”</code> <strong class="kl ir"> </strong>是只有授权用户才能访问的路线。</p><h2 id="612a" class="mu li iq bd lj nd ne dn ln nf ng dp lr ku nh ni lv ky nj nk lz lc nl nm md nn bi translated">用户注册</h2><p id="7dbf" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">当用户注册时，会在后端创建一个新的用户实例。将向<code class="fe na nb nc mq b">/users</code>发出一个POST请求，该请求将被重定向到用户控制器<code class="fe na nb nc mq b">create</code>方法。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/88fbcd3c6c18f61fd0079be2d43f3459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYh9yfoo9KpZ-6jGgYzipw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用户控制器</figcaption></figure><p id="c592" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">让我们检查一下在<code class="fe na nb nc mq b">create</code>方法中发生了什么。创建一个用户实例。如果有效，将使用用户实例的id创建一个有效负载对象，并将其传递给在应用程序控制器中定义的<code class="fe na nb nc mq b">encode_token</code>方法。如果需要，有效负载对象可以包含多个键。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/8f9cded6963fe6566c96592eb54f8a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ob3jDe-DHUAWfzd-hhtQ9g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用控制器encode_token方法</figcaption></figure><p id="b724" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">将利用JWT gem提供的方法<code class="fe na nb nc mq b">encode</code>来生成令牌。<code class="fe na nb nc mq b">JWT.encode</code>有两个参数，<code class="fe na nb nc mq b">payload</code>对象和一个表示“秘密”的字符串。方法<code class="fe na nb nc mq b">encode_token</code>将返回由JWT生成的令牌。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c920" class="mu li iq mq b gy mv mw l mx my">eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjo2fQ.dnjqXrQ8HWQnIiSMoM-Yt66LbXidwwtdvo2hcXoQBMU</span></pre><p id="1e4e" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">成功创建用户对象和令牌后，它们都作为JSON对象呈现为键值对。否则，将引发并呈现一个错误。</p><h2 id="b6b4" class="mu li iq bd lj nd ne dn ln nf ng dp lr ku nh ni lv ky nj nk lz lc nl nm md nn bi translated">用户登录</h2><p id="47b5" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">当现有用户登录时，会实现类似的方法。在<strong class="kl ir">身份验证控制器中，</strong>让我们检查一下<code class="fe na nb nc mq b">login</code>方法。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/4e7925b8adea112d23f1bf845a3dffdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9ueD9XBWkAG-SGD3WhcSg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">授权控制器登录方法</figcaption></figure><p id="dbef" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">主要的区别是该方法使用<code class="fe na nb nc mq b">find_by</code>方法从传递的参数中检查用户实例，特别是用户名。然后使用<code class="fe na nb nc mq b">bcrypt</code>提供的身份验证方法来比较通过params传递的密码和存储在数据库中的密码是否匹配。</p><p id="145b" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">如果用户实例和authenticate方法都通过了，JWT将生成一个令牌，并使用用户和令牌的键值对呈现一个JSON对象。</p><h2 id="2e62" class="mu li iq bd lj nd ne dn ln nf ng dp lr ku nh ni lv ky nj nk lz lc nl nm md nn bi translated">自动登录</h2><p id="8d5e" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">让我们检查位于<strong class="kl ir">授权控制器</strong>中的<code class="fe na nb nc mq b">auto_login</code>方法。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/7336a9a6d84b786207163f82661e4a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66hTDV8EZJQTdg55CSGi-g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">授权控制器自动登录</figcaption></figure><p id="609f" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">自动登录似乎很简单。如果方法<code class="fe na nb nc mq b">session_user</code>返回任何东西，它将把它呈现为一个JSON对象。否则，它将错误地呈现JSON对象。现在让我们检查一下<code class="fe na nb nc mq b">session_user</code>方法，位置在<strong class="kl ir">应用控制器</strong>中。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/ad7a634937b26b2607fa1792c19ee1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJ7xww303XCSkz84hucxOw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序控制器会话_用户方法</figcaption></figure><p id="e27f" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">将一个<code class="fe na nb nc mq b">decoded_hash</code>设置为<code class="fe na nb nc mq b">decoded_token</code>方法的返回值。如果<code class="fe na nb nc mq b">decoded_hash</code>为<strong class="kl ir">非</strong>空，我们继续从<code class="fe na nb nc mq b">decoded_hash</code>获取特定信息，这将是一个数组。否则，<code class="fe na nb nc mq b">session_user</code>将返回<code class="fe na nb nc mq b">nil</code>。</p><p id="161e" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">只有数组的第一个索引是必需的，取出从JWT编码分配的有效载荷对象键。在这种情况下，只有一个键被分配给有效载荷<code class="fe na nb nc mq b">user_id</code>。将使用<code class="fe na nb nc mq b">find_by</code>方法找到与<code class="fe na nb nc mq b">user_id</code>关联的用户。</p><p id="6b4f" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">现在，让我们检查一下<strong class="kl ir">应用控制器</strong>中的<code class="fe na nb nc mq b">decoded_token</code>方法。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/7153dc093c007c8903619a8d17bb94d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eH73LCS8G4dsNB5ZPsJC9g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序控制器decoded_token和auth_header方法</figcaption></figure><p id="8f4c" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated"><code class="fe na nb nc mq b">decoded_token</code>调用另一个方法<code class="fe na nb nc mq b">auth_header</code>，该方法检查请求头中的“授权”密钥。当请求从前端发送时，它通常采用以下格式:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="248f" class="mu li iq mq b gy mv mw l mx my">"Authorization": `Bearer ${jwt-token}`</span></pre><p id="7716" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">使用这种格式，<code class="fe na nb nc mq b">auth_header</code>将只返回字符串:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="26ee" class="mu li iq mq b gy mv mw l mx my">`Bearer ${jwt-token}`</span></pre><p id="1682" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">但是只有<code class="fe na nb nc mq b">jwt-token</code>是必需的。因此，在Bearer和jwt-token之间的字符串中有空格的地方调用split方法。返回一个包含两个元素的数组，第一个元素是Bearer字符串，第二个元素是jwt-token。将只使用第二个索引。</p><p id="1564" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">一旦jwt-token被获取并分配给token变量，将使用jwt提供的<code class="fe na nb nc mq b">decode</code>方法。<code class="fe na nb nc mq b">JWT.decode</code>接受四个参数，要解码的令牌、编码时分配的秘密字符串、真值和算法(这里是‘hs 256’)。否则，如果有错误，它将返回一个空错误。</p><h2 id="7492" class="mu li iq bd lj nd ne dn ln nf ng dp lr ku nh ni lv ky nj nk lz lc nl nm md nn bi translated">授权用户</h2><p id="787c" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">API中的许多路由都需要用户授权才能访问。在任何人可以访问该路由之前，方法<code class="fe na nb nc mq b">user_is_authed</code>必须返回true以显示授权证明，也就是令牌。让我们导航回到<strong class="kl ir">授权控制器</strong>，</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/85a76ef9a29a946995fd06379097798b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQd_Umbieg2FJVcMrFyM5g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用控制器</figcaption></figure><p id="2d8c" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">宏<code class="fe na nb nc mq b">before_action</code>通知我们的API总是先运行方法<code class="fe na nb nc mq b">require_login</code>，这意味着在<code class="fe na nb nc mq b">require_login</code>允许之前<code class="fe na nb nc mq b">user_is_authed</code>不能被访问。除非<strong class="kl ir"> </strong>方法<code class="fe na nb nc mq b">logged_in?</code>返回true，否则<code class="fe na nb nc mq b">require_login</code>方法会返回一个JSON对象，并显示一条登录消息。为了检查用户是否登录，使用之前的方法<code class="fe na nb nc mq b">session_user</code>。本质上，<code class="fe na nb nc mq b">logged_in</code>使用<code class="fe na nb nc mq b">!</code>操作符检查<code class="fe na nb nc mq b">session_user</code>返回真还是假。</p><p id="9c36" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">已经讨论了Rails(服务器端)的基本JWT实现。我们现在将研究如何为React(客户端)实现JWT。</p><p id="8bdf" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">关于如何从头开始设置Rails API，请参考我的指南:</p><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/building-a-small-rails-api-with-serializers-32e3e69a078"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">用序列化器构建一个小型Rails API</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">先决条件</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om jw ny"/></div></div></a></div><h1 id="fb93" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">React应用</h1><p id="7001" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">对于指南的这一部分，我将引用我的jwt-前端库:<a class="ae mk" href="https://github.com/reireynoso/jwt-frontend" rel="noopener ugc nofollow" target="_blank">https://github.com/reireynoso/jwt-frontend</a>。</p><p id="89e3" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">请记住，前端是使用React钩子用功能组件构建的，但同样的方法也适用于类组件。此外，不需要安装与JWT相关的软件包或库。存储由Rails API生成的JWT的方法将是重点。</p><h2 id="3178" class="mu li iq bd lj nd ne dn ln nf ng dp lr ku nh ni lv ky nj nk lz lc nl nm md nn bi translated">注册/登录</h2><p id="63e8" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">用户注册和登录具有相似的功能。我们将只关注<code class="fe na nb nc mq b">SignIn</code>组件，特别是当表单被提交并且POST请求被发送到Rails API <code class="fe na nb nc mq b">/users</code>时。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/81f88889bdd8123b61933e26008b5b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40okmh9JTsdt6bUEp84NoA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">登录组件</figcaption></figure><h2 id="abef" class="mu li iq bd lj nd ne dn ln nf ng dp lr ku nh ni lv ky nj nk lz lc nl nm md nn bi translated">将令牌存储在本地存储中</h2><p id="5bd5" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">如前所述，成功创建用户实例后，将返回包含用户和令牌的JSON对象。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5bfa" class="mu li iq mq b gy mv mw l mx my">render json: {user: user, jwt: token}</span></pre><p id="9f4d" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">一旦JSON对象被返回，我们希望存储令牌，这样我们就可以保持登录状态。为此，将利用浏览器<strong class="kl ir">本地存储</strong>。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f396" class="mu li iq mq b gy mv mw l mx my">localStorage.setItem("token", data.jwt)</span></pre><p id="7a7e" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated"><code class="fe na nb nc mq b">LocalStorage.setItem</code>接受两个论点。第一个是要设置的项的名称，第二个是要设置的实际值。</p><h2 id="e286" class="mu li iq bd lj nd ne dn ln nf ng dp lr ku nh ni lv ky nj nk lz lc nl nm md nn bi translated">自动登录</h2><p id="3215" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">设置本地存储只是自动登录的第一步。必须在某个时候向<code class="fe na nb nc mq b">auto_login</code>发出请求。在加载react页面时自动登录是有意义的。在应用程序组件中，将使用一个<code class="fe na nb nc mq b">useEffect</code>来处理页面渲染。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/a69a4b88f38173d815852c1665783dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WbGM8gQjQGVvQ9CvTc9Mnw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序组件</figcaption></figure><p id="55b3" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">在页面加载时，从本地存储中获取令牌并存储在令牌变量中。<code class="fe na nb nc mq b">getItem</code>接受一个参数，即您想要的密钥，在本例中名称是“token”。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="13e8" class="mu li iq mq b gy mv mw l mx my">const token = localStorage.getItem("token")</span></pre><p id="86c3" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">如果令牌存在，就向Rails API <code class="fe na nb nc mq b">/auto_login</code>发出GET <strong class="kl ir"> </strong>请求，发送与令牌相关的用户的JSON对象。</p><h2 id="2766" class="mu li iq bd lj nd ne dn ln nf ng dp lr ku nh ni lv ky nj nk lz lc nl nm md nn bi translated">授权路线</h2><p id="c3bb" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">既然localStorage存储了授予用户授权所必需的令牌，那么让我们研究一下如何将该令牌发送给Rails API以获得对经过身份验证的路由的访问。此时，我们知道令牌被存储，因为用户对象被返回。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e9053184553599d01384fa17af49d69e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGH2EtKAcH-GqZkLITlv2A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">对页面加载做出反应</figcaption></figure><p id="52b2" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">目标是将令牌传递给Rails API。有一个名为“Access Authorized Route”的按钮，单击它会向Rails API发出GET请求。让我们检查一下<strong class="kl ir"> App组件中的回调函数，</strong> <code class="fe na nb nc mq b">handleAuthClick</code>。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/2fd90b046af60ebbf39089f4081707d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qa_y8zsoEfPpLvAwbL8SPA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序组件，handleAuthClick</figcaption></figure><p id="fa45" class="pw-post-body-paragraph kj kk iq kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ij bi translated">当回调函数被调用时，它从本地存储中获取令牌。令牌作为设置为值<code class="fe na nb nc mq b">Bearer ${token}</code>的<code class="fe na nb nc mq b">Authorization</code>键中的值被传递给头。从Rails API中，它将呈现一条消息，“您已被授权。”</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a6c4ce9572f694bea2adb22f913fecd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jv1zlWVskT9XVVykRpYHQw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">特许用户</figcaption></figure><h1 id="355e" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结束语</h1><p id="ac74" class="pw-post-body-paragraph kj kk iq kl b km mf ko kp kq mg ks kt ku mh kw kx ky mi la lb lc mj le lf lg ij bi translated">本指南不包括React和Rails的JWT设置。相反，它提供了其实现的结构和逻辑过程的解释。请记住，这是实现JWT的众多方法之一。感谢您的阅读！</p></div></div>    
</body>
</html>