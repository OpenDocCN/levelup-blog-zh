<html>
<head>
<title>How to Create a Javascript HTML Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建Javascript HTML生成器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-javascript-html-generator-439f52b88ccc?source=collection_archive---------6-----------------------#2020-08-27">https://levelup.gitconnected.com/how-to-create-a-javascript-html-generator-439f52b88ccc?source=collection_archive---------6-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d2e720f11a1592584a9d1ab9d12e6821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2eRJMTe3y9R2fp7sUMzw2Q.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kc" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近用vanilla Javascript构建了一个文本编辑器web应用程序，在编码几个小时后，我很快厌倦了不断创建DOM元素。我正在动态地创建元素，因为每次渲染时它们都需要动态id、事件侦听器和内容。我很快意识到模板系统会更好地满足我的需求，并清理我的类。</p><p id="b406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定建立自己的模板引擎，我决定称之为支配者只是为了好玩。我将介绍我所采取的基本步骤和我用来创建它的代码。</p><p id="1877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我想为模板创建一个简单的格式，所以我创建了一个名为<code class="fe lb lc ld le b">templates.js</code>的新文件，其中有一个对象<code class="fe lb lc ld le b">Templates</code>填充了我使用的每个模板。我将模板构建为函数，这样我就可以向它们传递变量。这是我的文档图标的模板。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4570" class="ln lo iq le b gy lp lq l lr ls">const Templates = {<br/>  docIcon: function(obj) {<br/>    return {<br/>      tag: 'div',<br/>      id: obj.id,<br/>      classes: ['doc-icon'],<br/>      properties: {<br/>        title: obj.name,<br/>        tabIndex: 0<br/>      },<br/>      children: [<br/>        {<br/>          tag: 'div',<br/>          classes: ['doc-icon-header'],<br/>          children: [<br/>            { tag: 'h3', content: obj.name }<br/>          ]<br/>        },<br/>        {<br/>          tag: 'p',<br/>          content: obj.exerp<br/>        },<br/>        {<br/>          tag: 'div',<br/>          id: 'docControls',<br/>          classes: ['doc-controls'],<br/>          children: [<br/>            {<br/>              tag: 'button',<br/>              classes: ['doc-control'],<br/>              id: 'moveDoc',<br/>              children: [<br/>                {<br/>                  tag: 'i',<br/>                  classes: ['fa', 'fa-folder']<br/>                }<br/>              ]<br/>            },<br/>            {<br/>              tag: 'button',<br/>              classes: ['doc-control'],<br/>              id: 'deleteDoc',<br/>              children: [<br/>                {<br/>                  tag: 'i',<br/>                  classes: ['fa', 'fa-trash']<br/>                }<br/>              ]<br/>            }<br/>          ]<br/>        }<br/>      ]<br/>    }<br/>  }</span></pre><p id="165d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，标签、id和类被明确定义为我们的对象的键，但是其他任何东西都在properties键中传递。我们还有一个子数组，每个子数组都有和父数组相同的格式。理论上，我们可以用这种格式无限嵌套DOM元素。</p><p id="359e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们的模板有了这个简单的Javascript对象格式，很容易很快地构建大量的模板，但是我们如何转换成HTML并添加到DOM中呢？</p><p id="82c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我创建了一个名为<code class="fe lb lc ld le b">Dominator</code>的类，用实例将一个DOM元素表示为一个对象。一个实例看起来非常像我们的模板，除了应用动态值。我只是使用<code class="fe lb lc ld le b">Object.assign()</code>来复制模板。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="620b" class="ln lo iq le b gy lp lq l lr ls">class Dominator {<br/>  constructor(object) {<br/>    Object.assign(this, object)<br/>  }<br/>}</span></pre><p id="27ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要弄清楚如何创建孩子。我们可以使用for循环递归地为孩子创建类的新实例。然后，我们将孩子推入一个空的初始化数组，在循环之后，我们将<code class="fe lb lc ld le b">this.children</code>赋值为等于我们的数组。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d450" class="ln lo iq le b gy lp lq l lr ls">----<br/>  constructor(object) {<br/>    Object.assign(this, object)<br/>    let childObjects = []<br/>    if (object.children){<br/>      for (const child of object.children) {<br/>        let childObject = new Dominator(child)<br/>        childObjects.push(childObject)<br/>      }<br/>    }<br/>    this.children = childObjects<br/>    this.element = this.domElement<br/>  }<br/>----</span></pre><p id="f99c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们有一个对象，它是模板的副本，我们的内容应用于它。还没用。接下来，我们需要将它们转换成DOM元素。我创建了一个名为<code class="fe lb lc ld le b">domElement()</code>的get函数来返回一个生成的DOM元素。我使用get，这样我们就可以随时更新我们的属性并重新生成元素。</p><p id="96fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数的第一部分创建元素并设置基本属性。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="9248" class="ln lo iq le b gy lp lq l lr ls">get domElement() {<br/>    const domElement = document.createElement(this.tag)<br/>    if (this.id) domElement.id = this.id<br/>    if (this.content) domElement.innerText = this.content<br/>    <br/>  -----</span><span id="d213" class="ln lo iq le b gy lt lq l lr ls">    return domElement<br/>}</span></pre><p id="f328" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来需要做的三件事是迭代并分配属性、迭代并设置类，以及迭代并向我们的domElement追加子元素。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e592" class="ln lo iq le b gy lp lq l lr ls">get domElement() {<br/>    const domElement = document.createElement(this.tag)<br/>    if (this.id) domElement.id = this.id<br/>    if (this.content) domElement.innerText = this.content</span><span id="69a4" class="ln lo iq le b gy lt lq l lr ls">    if (this.properties) for (const prop in this.properties) {<br/>      domElement[prop] = this.properties[prop]<br/>    }<br/>    if (this.classes) for (const cssClass of this.classes) {<br/>      domElement.classList.add(cssClass)<br/>    }<br/>    if (this.children) for (const child of this.children) {<br/>      domElement.append(child.domElement)<br/>      if (child.id) this[child.id] = child.domElement<br/>    }<br/>    this.element = domElement</span><span id="b356" class="ln lo iq le b gy lt lq l lr ls">    return domElement<br/>  }</span></pre><p id="1a24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们有条件地检查所有内容，以确保它存在于我们的模板中，然后将这些内容应用于我们的domElement，然后返回它。</p><p id="b76b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们的整个类是这样的:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e0b6" class="ln lo iq le b gy lp lq l lr ls">class Dominator {<br/>  constructor(object) {<br/>    Object.assign(this, object)<br/>    let childObjects = []<br/>    if (object.children){<br/>      for (const child of object.children) {<br/>        let childObject = new Dominator(child)<br/>        childObjects.push(childObject)<br/>      }<br/>    }<br/>    this.children = childObjects<br/>    this.element = this.domElement<br/>  }<br/>  get domElement() {<br/>    const domElement = document.createElement(this.tag)<br/>    if (this.id) domElement.id = this.id<br/>    if (this.content) domElement.innerText = this.content<br/>    if (this.properties) for (const prop in this.properties) {<br/>      domElement[prop] = this.properties[prop]<br/>    }<br/>    if (this.classes) for (const cssClass of this.classes) {<br/>      domElement.classList.add(cssClass)<br/>    }<br/>    if (this.children) for (const child of this.children) {<br/>      domElement.append(child.domElement)<br/>      if (child.id) this[child.id] = child.domElement<br/>    }<br/>    this.element = domElement<br/>    return domElement<br/>  }<br/>}</span></pre><p id="73ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看它的实际效果吧！</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5b1f" class="ln lo iq le b gy lp lq l lr ls">get docIcon() {<br/>  const dominator = new Dominator(Templates.docIcon(this))<br/>  const div = dominator.domElement<br/>  div.addEventListener('click', this.openDoc.bind(this))<br/>  div.querySelector('#deleteDoc').addEventListener('click', this.deleteDoc.bind(this))<br/>  div.querySelector('#moveDoc').addEventListener('click', this.moveDoc.bind(this))<br/>  this.icon = div<br/>  return div<br/>}</span></pre><p id="657c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何简化事件监听器过程？让我们添加一个名为<code class="fe lb lc ld le b">findChildById()</code>的新函数。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3ecf" class="ln lo iq le b gy lp lq l lr ls">findChildById(id) {<br/>  if (this.children) {<br/>    for (const child of this.children) {<br/>      if (child.id === id) {<br/>        return child<br/>      } else if (child.children) {<br/>        let found = child.findChildById(id)<br/>        if (found) return found<br/>      }<br/>    }<br/>  }<br/>  return false<br/>}</span></pre><p id="0125" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过一点递归，我们可以找到Dominator的子实例，并对其进行修改。现在，我们可以在构造函数中创建一个名为<code class="fe lb lc ld le b">this.eventListeners = []</code>的数组，我们将添加事件侦听器，稍后将其分配给DOM元素。</p><p id="e8e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了添加事件，我希望它尽可能简单，所以首先是回调，然后是可选ID，最后是事件类型，为了方便起见，默认为click。ID参数假设我们正在寻找具有该ID的子节点。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="b6ca" class="ln lo iq le b gy lp lq l lr ls">event(action, id, type = 'click') {<br/>    if (id) {<br/>      const node = this.findChildById(id)<br/>      if (node) {<br/>        node.eventListeners.push({type: type, action: action})<br/>      }<br/>    } else {<br/>      this.eventListeners.push({type: type, action: action})<br/>    }<br/>  }</span></pre><p id="5dee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，在我们的<code class="fe lb lc ld le b">get domElement()</code>函数中，我们需要以下内容:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="8732" class="ln lo iq le b gy lp lq l lr ls">if (this.eventListeners) for (const eventListener of this.eventListeners) {<br/>   domElement.addEventListener(eventListener.type, eventListener.action)<br/>}</span></pre><p id="4de2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以重构之前的代码了:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="b691" class="ln lo iq le b gy lp lq l lr ls">get docIcon() {<br/>  const dominator = new Dominator(Templates.docIcon(this))<br/>  dominator.event(this.openDoc.bind(this))<br/>  dominator.event(this.deleteDoc.bind(this), 'deleteDoc')<br/>  dominator.event(this.moveDoc.bind(this), 'moveDoc')<br/>  const div = dominator.domElement<br/>  this.icon = div<br/>  return div<br/>}</span></pre><p id="b4a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">维奥拉。干净多了。</p><p id="2eb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们支配者的全部代码:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3017" class="ln lo iq le b gy lp lq l lr ls">class Dominator {<br/>  constructor(object) {<br/>    Object.assign(this, object)<br/>    let childObjects = []<br/>    if (object.children){<br/>      for (const child of object.children) {<br/>        let childObject = new Dominator(child)<br/>        childObjects.push(childObject)<br/>      }<br/>    }<br/>    this.eventListeners = []<br/>    this.children = childObjects<br/>    this.element = this.domElement<br/>  }<br/>  get domElement() {<br/>    const domElement = document.createElement(this.tag)<br/>    if (this.id) domElement.id = this.id<br/>    if (this.content) domElement.innerText = this.content<br/>    if (this.properties) for (const prop in this.properties) {<br/>      domElement[prop] = this.properties[prop]<br/>    }<br/>    if (this.classes) for (const cssClass of this.classes) {<br/>      domElement.classList.add(cssClass)<br/>    }<br/>    if (this.children) for (const child of this.children) {<br/>      domElement.append(child.domElement)<br/>      if (child.id) this[child.id] = child.domElement<br/>    }<br/>    if (this.eventListeners) for (const eventListener of this.eventListeners) {<br/>      domElement.addEventListener(eventListener.type, eventListener.action)<br/>    }<br/>    this.element = domElement<br/>    return domElement<br/>  }<br/>  findChildById(id) {<br/>    if (this.children) {<br/>      for (const child of this.children) {<br/>        if (child.id === id) {<br/>          return child<br/>        } else if (child.children) {<br/>          let found = child.findChildById(id)<br/>          if (found) return found<br/>        }<br/>      }<br/>    }<br/>    return false<br/>  }<br/>  event(action, id, type = 'click') {<br/>    if (id) {<br/>      const node = this.findChildById(id)<br/>      if (node) {<br/>        node.eventListeners.push({type: type, action: action})<br/>      }<br/>    } else {<br/>      this.eventListeners.push({type: type, action: action})<br/>    }<br/>  }<br/>}</span></pre></div></div>    
</body>
</html>