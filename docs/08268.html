<html>
<head>
<title>An Up-To Date Review of gRPC with GoLang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoLang对gRPC的最新评述</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-up-to-date-review-of-grpc-with-golang-b8cc78b584f7?source=collection_archive---------0-----------------------#2021-04-16">https://levelup.gitconnected.com/an-up-to-date-review-of-grpc-with-golang-b8cc78b584f7?source=collection_archive---------0-----------------------#2021-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c80" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当今科技领域最受欢迎的组合。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9150fe7d254ee7a39a4cfd59c00db681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1PkI27KyncyBCN95.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://events.linuxfoundation.org/grpc-conf/" rel="noopener ugc nofollow" target="_blank"> gRPC Conf 2020 </a></figcaption></figure><p id="8533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">你可能听过这句话，唯一不变的是变化本身。不管是好是坏，这句话在技术领域尤其适用。流行的协议gRPC(远程过程调用，由于某些原因，我们不讨论g)已经成为软件工程师的一个有吸引力的选择，因为它的高性能，语言独立和基于契约的解决方案来连接客户端和服务器通信。</p><p id="f077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您以前是否使用过gRPC，或者您是第一次接触它，本文都将涉及GoLang中gRPC的以下方面:</p><ul class=""><li id="e9f0" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">为什么创建gRPC</li><li id="da68" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">gRPC + protobuf概述</li><li id="30b2" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">在Go中实现客户端和服务器</li><li id="022c" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><strong class="lb iu">奖励</strong>:为你的<code class="fe ms mt mu mv b">.proto</code>文件生成文档</li></ul><p id="5b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧！</p><p id="cd18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mw">免责声明:我假设你熟悉Go，可以创建一个新项目，编译等。我将包括代码示例，但我不会重复编译，使用</em> <code class="fe ms mt mu mv b"><em class="mw">go mod</em></code> <em class="mw">等。</em></p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="8aab" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">gRPC的起源</h1><p id="a252" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">多年来，web开发的世界高度依赖于基于REST(表述性状态转移)的API(应用程序编程接口)。这种与其他应用程序和第三方数据交互的方式有四个主要方法，GET、POST、PUT和DELETE。中间的两个已经不是你见过的最具描述性的命名标准了。</p><p id="7cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，基于REST的API通常缺乏标准化，许多公司实现了他们认为是基于REST的解决方案，而实际上他们开发的代码更符合他们自己的设计习惯。这就要求gRPCs具有一个令人满意的特性——<strong class="lb iu">一致性</strong>。</p><p id="3645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RESTful APIs通常也使用JSON或XML发送消息。虽然JSON是许多开发人员的热门选择，但它仍然是人类可读的格式，这是以高效的数据传输为代价的。因此，gRPC的开发人员创建了Protobuf(协议缓冲区),它通过以字节编码的格式传输数据而保持语言独立的平台。</p><p id="7efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gRPC对以前解决方案的另一个改进是<strong class="lb iu">利用现代HTTP </strong>(超文本传输协议)选项。HTTP版本背后有很多东西，因为它们是互联网的支柱，所以我们将保持简单。HTTP/1.1必须打开多个TCP(传输控制协议)连接，而HTTP/2只需要一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/9a85be380388064cc2dda0e89af2d74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_NxVizKHjIfpd7mg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">HTTP/1.1与HTTP/2</figcaption></figure><p id="f89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TCP连接只是客户端和服务器之间建立信任的一种方式，在能够更有效地发送数据之前，需要一些时间来发起“握手”。大多数REST服务都是使用HTTP/1.1构建的，所以当然<strong class="lb iu"> gRPC利用了HTTP/2。</strong></p><p id="1092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gRPC相对于REST提供的另外两个主要优势包括实时双向流，以及为不同语言生成可靠的客户端。gRPC还希望提供HTTP/3支持，一个比HTTP/2更快的版本。</p><blockquote class="oc od oe"><p id="e783" class="kz la mw lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated"><em class="it">这里我们还可以介绍更多的东西，而且很明显，基于REST的API仍然有很多优势。然而，如果你想记住</em> <strong class="lb iu"> <em class="it">性能</em> </strong> <em class="it">，那么</em> <strong class="lb iu"> <em class="it"> gRPC可能值得一试。</em> </strong></p></blockquote></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="a919" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">gRPC和Protobuf概述</h1><p id="c913" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">远程过程调用混淆了通信逻辑，使得看起来您是在客户端中直接调用服务器方法，反之亦然。利用gRPC，您可以更高效地创建分布式应用程序和服务。您需要做的只是通过指定方法参数和返回类型来定义服务。服务器将实现您定义的接口来处理客户端连接。然后，客户端将能够通过存根提供与服务器相同的方法。这可以在任何支持的语言配置中完成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/575180112a913edadcf8630484009c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*JfVq9rN8dABExCTIRwmE_g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://grpc.io/docs/what-is-grpc/introduction/" rel="noopener ugc nofollow" target="_blank"> grpc.io </a></figcaption></figure><h2 id="7d40" class="oj nf it bd ng ok ol dn nk om on dp no li oo op nq lm oq or ns lq os ot nu ou bi translated">使用Protobuf —也称为协议缓冲区</h2><p id="37d8" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">gRPC数据传输的默认行为是通过协议缓冲区完成的。这是一种<strong class="lb iu">序列化结构化数据</strong>的方法，虽然也可以用于JSON之类的格式。您可以通过简单地将数据结构定义为<em class="mw">消息</em>来使用协议缓冲区，然后使用编译器<code class="fe ms mt mu mv b">protoc</code>来生成数据访问类。包含在一个<code class="fe ms mt mu mv b">.proto</code>文件中的示例协议缓冲服务和消息定义如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="0bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想处理双向数据流，您可以简单地在第4行的<code class="fe ms mt mu mv b">HelloRequest</code>和<code class="fe ms mt mu mv b">HelloReply</code>前添加<code class="fe ms mt mu mv b">stream</code>——尽管在这个例子中我们不会涉及数据流。</p><p id="5b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是用您选择的语言生成数据访问代码，这将在下一个示例部分中讨论。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="0005" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">在Go中实现gRPC客户端和服务器</h1><p id="7990" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">幸运的是，在Go中设置gRPC客户端和服务器时，gRPC保持了Go的简单性。一旦我们为<code class="fe ms mt mu mv b">.proto</code>数据定义生成了访问代码，我们就可以快速编写方法来实现gRPC接口需求。首先，让我们创建我们的项目结构。</p><pre class="kj kk kl km gt ox mv oy oz aw pa bi"><span id="c254" class="oj nf it mv b gy pb pc l pd pe">$ mkdir server client hello<br/>$ touch server/main.go client/main.go hello/helloworld.proto</span></pre><h2 id="2284" class="oj nf it bd ng ok ol dn nk om on dp no li oo op nq lm oq or ns lq os ot nu ou bi translated">添加Protobuf定义</h2><p id="3ea2" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">首先让我们添加<code class="fe ms mt mu mv b">helloworld.proto</code>的代码。我们通过定义<code class="fe ms mt mu mv b">syntax="proto3"</code>为Protobuf使用最新的语法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="71f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要为这个<code class="fe ms mt mu mv b">.proto</code>文件生成数据访问代码，这取决于您选择的语言，您必须查阅<a class="ae ky" href="https://grpc.io/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>以了解您的具体选择。如果你要生成GoLang代码，你首先需要协议编译器插件。</p><pre class="kj kk kl km gt ox mv oy oz aw pa bi"><span id="beb5" class="oj nf it mv b gy pb pc l pd pe">$ export GO111MODULE=on  <em class="mw"># Enable module mode</em><br/>$ go get google.golang.org/protobuf/cmd/protoc-gen-go <strong class="mv iu">\<br/></strong>         google.golang.org/grpc/cmd/protoc-gen-go-grpc</span></pre><p id="8256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还需要更新PATH环境变量:</p><pre class="kj kk kl km gt ox mv oy oz aw pa bi"><span id="cb15" class="oj nf it mv b gy pb pc l pd pe">$ export PATH="$PATH:<strong class="mv iu">$(</strong>go env GOPATH<strong class="mv iu">)</strong>/bin"</span></pre><p id="1359" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了<strong class="lb iu">生成您的代码</strong>，您将运行:</p><pre class="kj kk kl km gt ox mv oy oz aw pa bi"><span id="abb8" class="oj nf it mv b gy pb pc l pd pe">$ protoc --go_out=. --go_opt=paths=source_relative <strong class="mv iu">\<br/></strong>    --go-grpc_out=. --go-grpc_opt=paths=source_relative <strong class="mv iu">\<br/></strong>    hello/helloworld.proto</span></pre><p id="69c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在您的<code class="fe ms mt mu mv b">hello</code>目录中应该有两个额外的数据访问Go文件。这两个生成的文件包含用于<strong class="lb iu">填充、序列化和检索</strong> <code class="fe ms mt mu mv b">HelloRequest</code>和<code class="fe ms mt mu mv b">HelloReply</code>消息类型的代码，以及客户端和服务器代码。现在我们可以设置我们的客户端和服务器程序。</p><h2 id="410a" class="oj nf it bd ng ok ol dn nk om on dp no li oo op nq lm oq or ns lq os ot nu ou bi translated">实现服务器代码</h2><p id="c280" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在导入必要的库和包含protobuf代码的目录<code class="fe ms mt mu mv b">hello</code>后，我们将端口设置为<code class="fe ms mt mu mv b">50051</code>。TCP端口<code class="fe ms mt mu mv b">50051</code>使用传输控制协议，并保证数据包以相同的顺序发送。</p><p id="ec63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们定义一个名为server的结构，它嵌入了<code class="fe ms mt mu mv b">UnimplementedGreeterServer</code> <code class="fe ms mt mu mv b">struct</code>。这是最近添加的，有一个<a class="ae ky" href="https://github.com/grpc/grpc-go/issues/3669" rel="noopener ugc nofollow" target="_blank">很长的线程</a>与之关联，但长话短说，它被添加到<strong class="lb iu">支持向前兼容</strong>并遵守protobuf <a class="ae ky" href="https://blog.golang.org/protobuf-apiv2" rel="noopener ugc nofollow" target="_blank"> APIv2 </a>的最新版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="eb65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们添加两个简单的函数<code class="fe ms mt mu mv b">SayHell()</code>和<code class="fe ms mt mu mv b">SayHelloAgain()</code>，它们具有相同的逻辑，并且附属于<code class="fe ms mt mu mv b">server</code>T3。在<code class="fe ms mt mu mv b">main()</code>方法中，我们使用TCP协议在端口<code class="fe ms mt mu mv b">50051</code>上调用<code class="fe ms mt mu mv b">net.Listen()</code>并进行标准错误处理。如果一切顺利，我们简单地实例化一个名为<code class="fe ms mt mu mv b">s</code>的gRPC服务器对象，然后注册实现<code class="fe ms mt mu mv b">GreeterServer</code> <code class="fe ms mt mu mv b">interface</code>的<code class="fe ms mt mu mv b">server</code>。这就是我们需要的服务器逻辑！</p><h2 id="8226" class="oj nf it bd ng ok ol dn nk om on dp no li oo op nq lm oq or ns lq os ot nu ou bi translated">实现客户端代码</h2><p id="d33c" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">客户端也有简单的逻辑。我们导入必要的包和protobuf文件，并定义我们需要的任何常量。在main函数中，我们首先使用<code class="fe ms mt mu mv b">grpc.Dial()</code>建立到服务器的连接。然后，我们将连接对象传递给<code class="fe ms mt mu mv b">protobuf.NewGreeterClient()</code>来生成我们的客户端存根。下面几行只是接受一个命令行参数，我们将把它附加到我们的消息中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="8a07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据命令行参数，我们获得一个上下文对象，并将其传递给客户端方法调用。注意我们如何调用客户机存根来直接调用服务器方法<code class="fe ms mt mu mv b">SayHello()</code>和<code class="fe ms mt mu mv b">SayHelloAgain()</code>。此外，我们不必担心数据类型是如何被访问、序列化或传递的。我们只需传递变量<code class="fe ms mt mu mv b">name</code>，它会自动转换为字节码，作为<code class="fe ms mt mu mv b">HelloRequest</code>，随后是<code class="fe ms mt mu mv b">HelloReply</code>。以上是gRPC的一些主要优势！</p><h2 id="1a06" class="oj nf it bd ng ok ol dn nk om on dp no li oo op nq lm oq or ns lq os ot nu ou bi translated">运行我们的代码</h2><p id="5459" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">打开两个终端，我们可以启动我们的服务器，然后从客户端发出请求。</p><p id="a855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器托管终端:</p><pre class="kj kk kl km gt ox mv oy oz aw pa bi"><span id="6b67" class="oj nf it mv b gy pb pc l pd pe">$ go run server/main.go<br/></span></pre><p id="c7be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端请求的终端:</p><pre class="kj kk kl km gt ox mv oy oz aw pa bi"><span id="3882" class="oj nf it mv b gy pb pc l pd pe">$ go run client/main.go Izzy<br/>2021/04/16 15:23:26 Greeting: Hello Izzy<br/>2021/04/16 15:23:26 Greeting: Hello again Izzy<br/>$</span></pre><p id="359c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，gRPC在Go中实现了！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="5a55" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">记录Protobuf定义</h1><p id="35ea" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">Protobuf编译器<code class="fe ms mt mu mv b">protoc</code>有一个文档工具叫做<a class="ae ky" href="https://github.com/pseudomuto/protoc-gen-doc" rel="noopener ugc nofollow" target="_blank">protoco-gen-doc</a>。回购维护得很好，有20多个贡献者和400多个对其开发的承诺。如果您开始发现自己创建了许多不同的<code class="fe ms mt mu mv b">.proto</code>文件，并且想要记录它们的用例，这是一个非常方便的选择。要安装该工具，只需运行:</p><pre class="kj kk kl km gt ox mv oy oz aw pa bi"><span id="2b53" class="oj nf it mv b gy pb pc l pd pe">$ go get -u github.com/pseudomuto/protoc-gen-doc/cmd/protoc-gen-doc</span></pre><p id="440a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该工具还使用特定的注释来添加到生成的文档中。要查看效果，将<code class="fe ms mt mu mv b">helloworld.proto</code>更新如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="6c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以使用推荐的和可重用的Docker映像，或者您可以简单地在本地运行该工具。对于我们的示例，您可以运行:</p><pre class="kj kk kl km gt ox mv oy oz aw pa bi"><span id="44f1" class="oj nf it mv b gy pb pc l pd pe">$ protoc --doc_out=./ --doc_opt=html,index.html helloworld/*.proto</span></pre><p id="ac9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在web浏览器中打开生成的<code class="fe ms mt mu mv b">index.html</code>文件，我们会得到一些非常干净的文档！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/c5052af8c8cda3683eb458db6f635eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpG-qXYsFJrlHzw4tE6Yew.png"/></div></div></figure><p id="3d48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您已经开始了解如何使用gRPC开发高效的解决方案。另外，如果您需要记录Protobuf定义，您可以保持您的团队有组织。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="4e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您喜欢阅读这篇文章，并了解为什么gRPC和Go是您的技术堆栈的理想选择。如果你喜欢这篇文章的任何部分，或者有自己的想法，我鼓励你在下面留下评论。非常感谢你的阅读！</p></div></div>    
</body>
</html>