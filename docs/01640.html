<html>
<head>
<title>Node.js FS Module — Symbolic Links and Timestamps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js FS模块-符号链接和时间戳</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-fs-module-symbolic-links-and-timestamps-93a58c9f4d92?source=collection_archive---------4-----------------------#2020-01-18">https://levelup.gitconnected.com/node-js-fs-module-symbolic-links-and-timestamps-93a58c9f4d92?source=collection_archive---------4-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/efd30188a398346954de9b92bf6568eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LIRv7N_4x1XD6Ie8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="aa06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">操作文件和目录是任何程序的基本操作。因为Node.js是一个服务器端平台，可以直接与运行它的计算机交互，所以能够操作文件是一个基本特性。</p><p id="ac7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，Node.js的库中内置了一个<code class="fe le lf lg lh b">fs</code>模块。它有许多功能，可以帮助操纵文件和文件夹。支持的文件和目录操作包括基本的操作，如操作和打开目录中的文件。同样，它也可以对文件做同样的事情。</p><p id="56ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以同步和异步地做到这一点。它有一个异步API，该API具有支持承诺的功能。</p><p id="9de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它还可以显示文件的统计数据。几乎所有我们能想到的文件操作都可以用内置的<code class="fe le lf lg lh b">fs</code>模块来完成。</p><p id="a647" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将用<code class="fe le lf lg lh b">symlink</code>函数族创建符号链接，并用<code class="fe le lf lg lh b">utimes</code>函数族设置时间戳。</p><h1 id="e2ee" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建符号链接</h1><p id="c7e4" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">符号链接是以文件的相对或绝对路径的形式引用其他文件的文件。我们可以用<code class="fe le lf lg lh b">symlink</code>函数在Node.js程序中创建符号链接。</p><p id="fd14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数有4个参数。</p><p id="07d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个参数是符号链接的目标路径，也就是我们想要在符号链接中引用的文件路径。它可以是字符串、缓冲区对象或URL对象的形式。</p><p id="ec46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是符号链接的路径，它也可以是字符串、缓冲区对象或URL对象的形式。</p><p id="1815" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三个参数是类型，它是一个字符串。它只在Windows上可用，在其他平台上被忽略。可能的值有<code class="fe le lf lg lh b">'dir'</code>、<code class="fe le lf lg lh b">'file'</code>或<code class="fe le lf lg lh b">'junction'</code>。</p><p id="5d77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有设置类型参数，它将自动检测目标的类型并使用<code class="fe le lf lg lh b">'file'</code>或<code class="fe le lf lg lh b">'dir'</code>。如果目标不存在，则使用<code class="fe le lf lg lh b">'file'</code>。Windows要求符号链接路径是绝对的。使用<code class="fe le lf lg lh b">'junction'</code>时，目标参数将被转换为绝对路径。</p><p id="f021" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个参数是在符号链接创建操作结束时调用的回调函数。它有一个<code class="fe le lf lg lh b">err</code>参数，当操作成功时为<code class="fe le lf lg lh b">null</code>，当操作失败时有一个包含错误信息的对象。</p><p id="46e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe le lf lg lh b">symlink</code>函数创建一个符号链接，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0496" class="mt lj it lh b gy mu mv l mw mx">const fs = require("fs");<br/>const target = "./files/file.txt";<br/>const path = "./files/symlink";</span><span id="2c42" class="mt lj it lh b gy my mv l mw mx">fs.symlink(target, path, "file", err =&gt; {<br/>  if (err) {<br/>    throw err;<br/>  }<br/>  console.log("Symbolic link creation complete!");<br/>});</span></pre><p id="8016" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的代码后，当我们在POSIX系统上运行<code class="fe le lf lg lh b">stat ./files/symlink</code>时，我们应该得到类似如下的输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="392b" class="mt lj it lh b gy mu mv l mw mx">File: './files/symlink' -&gt; './files/file.txt'<br/>  Size: 16              Blocks: 0          IO Block: 512    symbolic link<br/>Device: eh/14d  Inode: 62487444831945583  Links: 1<br/>Access: (0777/lrwxrwxrwx)  Uid: ( 1000/hauyeung)   Gid: ( 1000/hauyeung)<br/>Access: 2019-11-03 11:22:19.787359800 -0800<br/>Modify: 2019-11-03 11:22:19.787359800 -0800<br/>Change: 2019-11-03 11:22:19.787359800 -0800<br/> Birth: -</span></pre><p id="216c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着符号链接已经成功创建。</p><p id="3e6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个同步版本的<code class="fe le lf lg lh b">symlink</code>函数，叫做<code class="fe le lf lg lh b">symlinkSync</code>函数。它需要三个参数。</p><p id="0ed7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个参数是符号链接的目标路径，也就是我们想要在符号链接中引用的文件路径。它可以是字符串、缓冲区对象或URL对象的形式。</p><p id="b458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是符号链接的路径，它也可以是字符串、缓冲区对象或URL对象的形式。第三个参数是类型，它是一个字符串。它只在Windows上可用，在其他平台上被忽略。</p><p id="1e2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能的值有<code class="fe le lf lg lh b">'dir'</code>、<code class="fe le lf lg lh b">'file'</code>或<code class="fe le lf lg lh b">'junction'</code>。如果没有设置类型参数，它将自动检测目标的类型并使用<code class="fe le lf lg lh b">'file'</code>或<code class="fe le lf lg lh b">'dir'</code>。如果目标不存在，则使用<code class="fe le lf lg lh b">'file'</code>。Windows要求符号链接路径是绝对的。</p><p id="5fa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">'junction'</code>时，目标参数将被转换为绝对路径。它返回<code class="fe le lf lg lh b">undefined</code>。</p><p id="ad2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用它来创建符号链接，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f58e" class="mt lj it lh b gy mu mv l mw mx">const fs = require("fs");<br/>const target = "./files/file.txt";<br/>const path = "./files/symlink";</span><span id="b34e" class="mt lj it lh b gy my mv l mw mx">try {<br/>  fs.symlinkSync(target, path, "file");<br/>  console.log("Symbolic link creation complete!");<br/>} catch (error) {<br/>  console.error(error);<br/>}</span></pre><p id="c1ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的代码后，当我们在POSIX系统上运行<code class="fe le lf lg lh b">stat ./files/symlink</code>时，我们应该得到与上面相同的输出。</p><p id="49d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个<code class="fe le lf lg lh b">symlink</code>功能的承诺版本。它需要三个参数。</p><p id="e90a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个参数是符号链接的目标路径，也就是我们想要在符号链接中引用的文件路径。它可以是字符串、缓冲区对象或URL对象的形式。</p><p id="4ed2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是符号链接的路径，它也可以是字符串、缓冲区对象或URL对象的形式。</p><p id="806b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三个参数是类型，它是一个字符串。它只在Windows上可用，在其他平台上被忽略。</p><p id="2b28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能的值有<code class="fe le lf lg lh b">'dir'</code>、<code class="fe le lf lg lh b">'file'</code>或<code class="fe le lf lg lh b">'junction'</code>。如果没有设置类型参数，它会自动检测目标的类型并使用<code class="fe le lf lg lh b">'file'</code>或<code class="fe le lf lg lh b">'dir'</code>。如果目标不存在，则使用<code class="fe le lf lg lh b">'file'</code>。</p><p id="bca9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Windows要求符号链接路径是绝对的。当使用<code class="fe le lf lg lh b">'junction'</code>时，目标参数将被转换为绝对路径。当它成功时，它返回一个没有任何争论的承诺。</p><p id="b1fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用它来创建符号链接，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="817a" class="mt lj it lh b gy mu mv l mw mx">const fsPromises = require("fs").promises;<br/>const target = "./files/file.txt";<br/>const path = "./files/symlink";</span><span id="106d" class="mt lj it lh b gy my mv l mw mx">(async () =&gt; {<br/>  try {<br/>    await fsPromises.symlink(target, path, "file");<br/>    console.log("Symbolic link creation complete!");<br/>  } catch (error) {<br/>    console.error(error);<br/>  }<br/>})();</span></pre><p id="84b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的代码后，当我们在POSIX系统上运行<code class="fe le lf lg lh b">stat ./files/symlink</code>时，我们应该得到与上面相同的输出。</p><p id="2c45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您想连续做多件事(包括调用<code class="fe le lf lg lh b">symlink</code>函数)时，promise版本的<code class="fe le lf lg lh b">symlink </code>函数是比<code class="fe le lf lg lh b">symlinkSync</code>函数更好的选择，因为它不会占用整个程序，等待符号链接创建操作完成后再继续编写程序的其他部分。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/580657327fcb2846e354953ff02cbae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GJbtUXPw75RG1f2r"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">埃里克·维特索在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="9840" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">更改存储在磁盘上的项目的时间戳</h1><p id="1e4c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以用<code class="fe le lf lg lh b">utimes</code>函数更改文件的最后访问时间和最后修改时间的时间戳。</p><p id="86b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数有4个参数。</p><p id="330b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个是存储在磁盘上的对象的路径。它可以是字符串、缓冲区对象和URL对象。</p><p id="eb74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是<code class="fe le lf lg lh b">atime</code>，它是对象最后一次被访问的时间。它可以是数字、字符串或日期对象。</p><p id="5e54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它是一个数字，那么它应该是UNIX时间戳。</p><p id="bf7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它是一个字符串，那么它应该是UNIX时间戳的字符串形式。</p><p id="faf0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果该值不能转换成数字或者是<code class="fe le lf lg lh b">NaN</code>、<code class="fe le lf lg lh b">Infinity</code>或<code class="fe le lf lg lh b">-Infinity</code>，那么将会抛出一个错误。</p><p id="ee67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三个参数是<code class="fe le lf lg lh b">mtime</code>，这是对象最后一次被修改的时间。它可以是数字、字符串或日期对象。它应该与<code class="fe le lf lg lh b">atime</code>参数的格式相同。</p><p id="90cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第四个参数是一个接受<code class="fe le lf lg lh b">err</code>参数的回调函数。当操作成功时，它是<code class="fe le lf lg lh b">null</code>,如果操作失败，它有一个包含错误信息的对象。</p><p id="eb86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像下面的代码一样使用<code class="fe le lf lg lh b">utimes</code>函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1e79" class="mt lj it lh b gy mu mv l mw mx">const fs = require("fs");<br/>const path = "./files/file.txt";</span><span id="9847" class="mt lj it lh b gy my mv l mw mx">fs.utimes(<br/>  path,<br/>  new Date(2019, 0, 1, 0, 0, 0, 0),<br/>  new Date(2019, 0, 1, 0, 0, 0, 0),<br/>  err =&gt; {<br/>    if (err) {<br/>      throw err;<br/>    }<br/>    console.log("Timestamps changed");<br/>  }<br/>);</span></pre><p id="0522" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，然后运行<code class="fe le lf lg lh b">stat ./files/file.txt</code>，我们应该得到类似下面的输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9f3f" class="mt lj it lh b gy mu mv l mw mx">File: './files/file.txt'<br/>  Size: 16              Blocks: 0          IO Block: 512    regular file<br/>Device: eh/14d  Inode: 22799473115106242  Links: 1<br/>Access: (0777/-rwxrwxrwx)  Uid: ( 1000/hauyeung)   Gid: ( 1000/hauyeung)<br/>Access: 2019-01-01 00:00:00.000000000 -0800<br/>Modify: 2019-01-01 00:00:00.000000000 -0800<br/>Change: 2019-11-03 11:41:16.155815100 -0800<br/> Birth: -</span></pre><p id="5b98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，<code class="fe le lf lg lh b">Access </code>和<code class="fe le lf lg lh b">Modify </code>时间变成了<code class="fe le lf lg lh b">2019–01–01 00:00:00.000000000</code>，所以我们知道<code class="fe le lf lg lh b">utimes</code>函数已经成功地改变了时间戳。</p><p id="0366" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一个同步版本的<code class="fe le lf lg lh b">utimes</code>函数叫做<code class="fe le lf lg lh b">utimesSync</code>函数。</p><p id="ece8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数有3个参数。</p><p id="31bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个是存储在磁盘上的对象的路径。它可以是字符串、缓冲区对象和URL对象。第二个参数是<code class="fe le lf lg lh b">atime</code>，它是对象最后一次被访问的时间。</p><p id="abe7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以是数字、字符串或日期对象。如果它是一个数字，那么它应该是UNIX时间戳。如果它是一个字符串，那么它应该是UNIX时间戳的字符串形式。如果该值不能转换成数字或者是<code class="fe le lf lg lh b">NaN</code>、<code class="fe le lf lg lh b">Infinity</code>或<code class="fe le lf lg lh b">-Infinity</code>，那么将会抛出一个错误。</p><p id="3462" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三个参数是<code class="fe le lf lg lh b">mtime</code>，这是对象最后一次被修改的时间。它可以是数字、字符串或日期对象。它应该与<code class="fe le lf lg lh b">atime</code>参数的格式相同。</p><p id="19ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在下面的代码中使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1f50" class="mt lj it lh b gy mu mv l mw mx">const fs = require("fs");<br/>const path = "./files/file.txt";</span><span id="d4be" class="mt lj it lh b gy my mv l mw mx">try {<br/>  fs.utimesSync(<br/>    path,<br/>    new Date(2019, 0, 1, 0, 0, 0, 0),<br/>    new Date(2019, 0, 1, 0, 0, 0, 0)<br/>  );<br/>  console.log("Timestamps changed");<br/>} catch (error) {<br/>  console.error(error);<br/>}</span></pre><p id="4c69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，然后运行<code class="fe le lf lg lh b">stat ./files/file.txt</code>，我们应该得到与上面相同的输出。</p><p id="2e97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个<code class="fe le lf lg lh b">utimes</code>函数的承诺版本，它让我们异步运行<code class="fe le lf lg lh b">utimes</code>，同时像处理<code class="fe le lf lg lh b">utimesSync</code>函数一样按顺序运行它。</p><p id="e9cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数有3个参数。第一个是存储在磁盘上的对象的路径。它可以是字符串、缓冲区对象和URL对象。</p><p id="76ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是<code class="fe le lf lg lh b">atime</code>，它是对象最后一次被访问的时间。它可以是数字、字符串或日期对象。如果它是一个数字，那么它应该是UNIX时间戳。</p><p id="1392" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它是一个字符串，那么它应该是UNIX时间戳的字符串形式。如果该值不能转换成数字或者是<code class="fe le lf lg lh b">NaN</code>、<code class="fe le lf lg lh b">Infinity</code>或<code class="fe le lf lg lh b">-Infinity</code>，那么将会抛出一个错误。</p><p id="f330" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三个参数是<code class="fe le lf lg lh b">mtime</code>，它是对象最后一次被修改的时间。它可以是数字、字符串或日期对象。它应该与<code class="fe le lf lg lh b">atime</code>参数的格式相同。</p><p id="12d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在下面的代码中使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4a5e" class="mt lj it lh b gy mu mv l mw mx">const fsPromises = require("fs").promises;<br/>const path = "./files/file.txt";</span><span id="53c3" class="mt lj it lh b gy my mv l mw mx">(async () =&gt; {<br/>  try {<br/>    await fsPromises.utimes(<br/>      path,<br/>      new Date(2019, 0, 1, 0, 0, 0, 0),<br/>      new Date(2019, 0, 1, 0, 0, 0, 0)<br/>    );<br/>    console.log("Timestamps changed");<br/>  } catch (error) {<br/>    console.error(error);<br/>  }<br/>})();</span></pre><p id="51a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，然后运行<code class="fe le lf lg lh b">stat ./files/file.txt</code>，我们也应该得到与常规<code class="fe le lf lg lh b">utimes</code>示例相同的输出。</p><p id="63e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe le lf lg lh b">symlink</code>函数族创建符号链接。</p><p id="7f48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要三个参数。第一个是存储在磁盘上的对象的路径。它可以是字符串、缓冲区对象和URL对象。</p><p id="03ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是<code class="fe le lf lg lh b">atime</code>，它是对象最后一次被访问的时间。它可以是数字、字符串或日期对象。如果是数字，那么它应该是UNIX时间戳，如果是字符串，那么它应该是UNIX时间戳的字符串形式。</p><p id="4393" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">常规的异步版本也有一个回调函数，当它结束时运行。<code class="fe le lf lg lh b">utimes</code>函数改变存储在磁盘上的对象的访问时间戳和修改时间。它采用实体的路径来应用访问和修改时间的改变和时间戳。</p><p id="9be2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">常规的异步版本也有一个回调函数，当它结束时运行。当我们需要在Node.js程序中执行这些操作时，它们非常方便。</p></div></div>    
</body>
</html>