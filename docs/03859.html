<html>
<head>
<title>Run a self-driving car using JavaScript and TensorFlow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript和TensorFlow.js运行自动驾驶汽车</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/run-a-self-driving-car-using-javascript-and-tensorflow-js-8b9b3f7af23d?source=collection_archive---------3-----------------------#2020-05-30">https://levelup.gitconnected.com/run-a-self-driving-car-using-javascript-and-tensorflow-js-8b9b3f7af23d?source=collection_archive---------3-----------------------#2020-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/73892900747146c13279e7b5f0d03d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJ7NmwsqFq4ZIobBv2EBWg.png"/></div></div></figure><p id="6c81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，我们将学习如何使用Node.js、TensorFlow.js和Udacity自动驾驶汽车模拟器，在虚拟驾驶模拟器中训练深度学习模型自动驾驶汽车。我们会看到完全用JavaScript创建和训练深度学习模型是多么容易。</p><p id="4af2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在<a class="ae kz" href="https://github.com/bakoushin/self-driving-car-javascript" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到该项目的完整代码。</p><h1 id="b4ef" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">模拟器</h1><p id="7be2" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">汽车将在开源<a class="ae kz" href="https://github.com/udacity/self-driving-car-sim" rel="noopener ugc nofollow" target="_blank"> Udacity自动驾驶汽车模拟器</a>提供的模拟环境中运行。您可以从GitHub repo下载Linux、Mac和Windows的预构建版本。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/00f531a76ded5ba121988fb45affa19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*g5nsAT8dc_P2FKUFuYk8-g.png"/></div></div></figure><p id="8732" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用“术语1”标题下的一个构建。这些提供了两条虚拟轨道，我们将使用第一条。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/7435d506c45cae564f599c1d9a377878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*UIqHN8od8GbRkOIdwSwGKg.png"/></div></figure><h1 id="7a93" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">行动（或活动、袭击）计划</h1><p id="73e7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了让汽车使用深度学习自动驾驶，我们必须遵循以下5个步骤:</p><ol class=""><li id="0ab6" class="mj mk it kd b ke kf ki kj km ml kq mm ku mn ky mo mp mq mr bi translated">收集数据以训练模型。</li><li id="07ab" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">定义深度学习模型。</li><li id="7b2e" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">加载并准备用于培训的数据。</li><li id="0227" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">训练深度学习模型。</li><li id="43c5" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">使用模型驾驶汽车。</li></ol><h1 id="1fe0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.收集数据</h1><p id="337f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">基本上，我们所要做的就是向汽车展示我们通常是如何驾驶的。这被称为<em class="mx">行为克隆</em>。基本上，我们希望我们的汽车在类似的环境中模仿人类驾驶员的行为。</p><p id="edf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将教给我们的汽车的唯一技能是<em class="mx">转向</em>。我们希望它在左转时转向左边，在右转时转向右边，并且在直行时不要转向太多。这是一个故意过于简化的例子，但它旨在抓住自动驾驶汽车的基础。</p><blockquote class="my mz na"><p id="cd1c" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">事实上，英伟达的研究人员在2016年也在解决同样的转向问题。阅读他们的<a class="ae kz" href="https://devblogs.nvidia.com/deep-learning-self-driving-cars/" rel="noopener ugc nofollow" target="_blank">伟大文章</a>，观看<a class="ae kz" href="https://www.youtube.com/watch?v=NJU9ULQUwng" rel="noopener ugc nofollow" target="_blank">视频</a>。</p></blockquote><p id="c66f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从技术上来说，我们希望从透过汽车挡风玻璃观看的相机中收集一系列图像，以及相应的转向值。然后，我们的深度学习模型将查看这些图像，并学习如何相应地转向。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/cac2435419c141c67db70fe340cabe92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZBIc5NgJ7eNlviz5K4QCQ.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><strong class="bd lc">来自车载摄像头的图像与不同的转向值相关联</strong> <br/> <a class="ae kz" href="https://thenounproject.com/term/steer/850999" rel="noopener ugc nofollow" target="_blank">方向盘图标</a>来自名词项目</figcaption></figure><p id="4f79" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了Udacity模拟器，我们可以轻松地收集数据。就像在电子游戏中一样驾驶虚拟汽车，并记录旅程。模拟器将自动提取和保存所有必要的图像和转向值。</p><p id="2d9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最终数据集将保存在一个具有以下结构的文件夹中:一个包含一组图像的<code class="fe nj nk nl nm b">IMG</code>目录，以及一个包含映射到图像的转向和其他遥测数据的<code class="fe nj nk nl nm b">driving_log.csv</code>文件。</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="2098" class="nr lb it nm b gy ns nt l nu nv">data<br/>+- driving_log.csv<br/>+- IMG<br/>   +- center_2020_05_24_20_51_38_536.jpg<br/>   +- left_2020_05_24_20_51_38_536.jpg<br/>   +- right_2020_05_24_20_51_38_536.jpg<br/>   ...</span></pre><h2 id="0094" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">说明</h2><ol class=""><li id="db83" class="mj mk it kd b ke ly ki lz km oh kq oi ku oj ky mo mp mq mr bi translated">在训练模式下运行模拟器。</li><li id="60d4" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">点击屏幕右上角的录制按钮。</li><li id="ad4c" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">选择存储数据的文件夹。</li><li id="fd10" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">再次点击录音按钮开始录音。</li><li id="e1b0" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">驾驶展现出色驾驶技巧的汽车。至少跑一整圈，最好是两三圈。记住:这是汽车要学习的东西！</li><li id="ca35" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">再次点击录音按钮停止录音。等到它结束。同时，享受你的史诗旅程重播。</li></ol><h1 id="785a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.定义深度学习模型</h1><p id="585a" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">深度学习模型基本上是一系列操作，它接受一个输入——在我们的情况下，是一个图像，通过一组过滤器，并输出一些结果。我们的结果将是一个导向值，该模型认为适合于给定的图像。</p><blockquote class="my mz na"><p id="019e" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">如果你熟悉JavaScript <code class="fe nj nk nl nm b">Array.prototype.map()</code>的功能，我们的模型会做基本相同的事情:将给定的图像映射到合适的导向值。但是我们没有自己编写映射算法，而是让模型自己解决。这就是训练的全部内容。</p></blockquote><p id="d63a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">深度学习的网络架构有几种类型。我们将使用一个称为CNN的网络，它代表卷积神经网络。这种类型的神经网络在分析图像方面极其强大。通常CNN会从图像中提取一些特征，比如线条、形状、颜色。然后它使用这些信息来产生结果。</p><p id="a845" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用一个非常基本但功能强大的CNN架构:一个<em class="mx">裁剪层</em>，后面是两个<em class="mx">卷积层</em>，每个后面是一个<em class="mx">最大池层</em>，所有这些后面是三个<em class="mx">密集层</em>。对于所有层，除了最后一层，我们将使用<em class="mx"> ReLU激活功能</em>。最后一层将只有一个值，那就是我们的转向值。</p><p id="38d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果现在对你来说这听起来毫无意义，不要担心:我们将讨论这个架构的每个元素，以便对正在发生的事情有一些基本的了解。</p><p id="0ba7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们如何使用TensorFlow.js在代码中定义模型:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="657a" class="nr lb it nm b gy ns nt l nu nv">const model = tf.sequential({<br/>  layers: [</span><span id="2487" class="nr lb it nm b gy ok nt l nu nv">    <strong class="nm iu"><em class="mx">// Cropping layer</em></strong><br/>    tf.layers.cropping2D({<br/>      cropping: [[75, 25], [0, 0]],<br/>      inputShape: [160, 320, 3]<br/>     }),</span><span id="21de" class="nr lb it nm b gy ok nt l nu nv">    <strong class="nm iu"><em class="mx">// 1st convolutional layer</em></strong><br/>    tf.layers.conv2d({<br/>      filters: 16,<br/>      kernelSize: [3, 3],<br/>      strides: [2, 2],<br/>      activation: 'relu'<br/>    }),<br/><br/>    <strong class="nm iu"><em class="mx">// 1st max-pooling layer</em></strong><br/>    tf.layers.maxPool2d({ <br/>      poolSize: [2, 2] <br/>    }),</span><span id="9549" class="nr lb it nm b gy ok nt l nu nv">    <strong class="nm iu"><em class="mx">// 2nd convolutional layer</em></strong><br/>    tf.layers.conv2d({<br/>      filters: 32,<br/>      kernelSize: [3, 3],<br/>      strides: [2, 2],<br/>      activation: 'relu'<br/>    }),</span><span id="c6c9" class="nr lb it nm b gy ok nt l nu nv">    <strong class="nm iu"><em class="mx">// 2nd max-pool layer</em></strong><br/>    tf.layers.maxPool2d({ <br/>      poolSize: [2, 2] <br/>    }),</span><span id="f366" class="nr lb it nm b gy ok nt l nu nv"><strong class="nm iu"><em class="mx">    // Dense layers with dropout layer</em></strong><br/>    tf.layers.flatten(),<br/>    tf.layers.dense({ units: 1024, activation: 'relu' }),<br/>    tf.layers.dropout({ rate: 0.25 }),<strong class="nm iu"><em class="mx"><br/>    </em></strong>tf.layers.dense({ units: 128, activation: 'relu' }),<br/>    tf.layers.dense({ units: 1, activation: 'linear' })<br/>  ]<br/>});</span><span id="de91" class="nr lb it nm b gy ok nt l nu nv">model.compile({<br/>  optimizer: 'adam',<br/>  loss: 'meanSquaredError'<br/>});</span></pre><p id="6cd8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们使用<code class="fe nj nk nl nm b"><a class="ae kz" href="https://js.tensorflow.org/api/latest/#sequential" rel="noopener ugc nofollow" target="_blank">tf.equential()</a></code>创建我们的模型。这意味着我们的模型将循序渐进地从输入到输出进行处理。然后，我们添加一系列层来按顺序处理数据。让我们逐一讨论。</p><h2 id="1762" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">裁剪层</h2><p id="5e05" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">图像包括许多额外的细节，如风景或汽车引擎盖。这些细节并没有给出在给定的时间内转向何处的提示。为了加强信噪比，我们将裁剪图像的顶部和底部。</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="2316" class="nr lb it nm b gy ns nt l nu nv"><strong class="nm iu"><em class="mx">// Cropping layer</em></strong><br/>tf.layers.cropping2D({<br/>  cropping: [[75, 25], [0, 0]],<br/>  inputShape: [160, 320, 3]<br/>})</span></pre><p id="7a07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用<code class="fe nj nk nl nm b"><a class="ae kz" href="https://js.tensorflow.org/api/latest/#layers.cropping2D" rel="noopener ugc nofollow" target="_blank">tf.layers.cropping2D</a></code>从图像顶部(风景)裁剪<code class="fe nj nk nl nm b">75px</code>，从图像底部(汽车引擎盖)裁剪<code class="fe nj nk nl nm b">25px</code>。</p><blockquote class="my mz na"><p id="7f62" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">我们必须在<code class="fe nj nk nl nm b"><em class="it">inputShape</em></code>参数中指定初始图像的尺寸。这对于模型的第一层是必须的。这里的<code class="fe nj nk nl nm b"><em class="it">160</em></code>是图像的高度，<code class="fe nj nk nl nm b"><em class="it">320</em></code>是它的宽度，<code class="fe nj nk nl nm b"><em class="it">3</em></code>表示它有三个颜色通道——红色、绿色和蓝色(也称为RGB)。</p></blockquote><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/8518f88434972a4029b6700249a2d6cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*SdX0Ty4m2f8feqZsYVTLnQ.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">TF . layers . cropping 2d({ cropping:[[75，25]，[0，0]]，inputShape: [160，320，3] })</figcaption></figure><h2 id="8e47" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">卷积层</h2><p id="4165" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们使用<code class="fe nj nk nl nm b"><a class="ae kz" href="https://js.tensorflow.org/api/latest/#layers.conv2d" rel="noopener ugc nofollow" target="_blank">tf.layers.conv2d</a></code>创建两个连续的卷积层。这些方法的目的是从给定的图像中提取突出的特征，例如线条和形状。</p><p id="f4a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">卷积层通过将<em class="mx">内核过滤器</em>应用于前一层的数据来实现。</p><blockquote class="my mz na"><p id="054b" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">了解更多:<br/><a class="ae kz" href="https://setosa.io/ev/image-kernels/" rel="noopener ugc nofollow" target="_blank">Victor Powell的图像内核</a><br/><a class="ae kz" href="https://youtu.be/sAPg-qaT0b4" rel="noopener ugc nofollow" target="_blank">卷积</a>视频来自uda city<a class="ae kz" href="https://www.udacity.com/course/intro-to-tensorflow-for-deep-learning--ud187" rel="noopener ugc nofollow" target="_blank">tensor flow简介</a>免费课程</p></blockquote><p id="ce11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用哪种确切的滤波器，模型在训练期间自行决定。我们只需定义要使用多少种不同的过滤器、过滤器内核的大小以及应用过滤器时步长的大小。</p><p id="3b1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果是一组具有重要特征的灰度图像，由过滤器突出显示。我们将看不到这些图像中的任何一个，但是模型将使用它们来进行进一步的计算。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/c43f07ce043f39b4968c2df502dc13b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*udd9qPi6Kc9WYPkBQgs9Vg.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">tf.layers.conv2d({ filters: 16，kernelSize: [3，3]，steps:[2，2]，activation: 'relu' })</figcaption></figure><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="7f59" class="nr lb it nm b gy ns nt l nu nv"><strong class="nm iu"><em class="mx">// 1st convolutional layer</em></strong><br/>tf.layers.conv2d({<br/>  filters: 16,<br/>  kernelSize: [3, 3],<br/>  strides: [2, 2],<br/>  activation: 'relu'<br/>})</span></pre><p id="6ffa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将连续使用<code class="fe nj nk nl nm b">16</code>和<code class="fe nj nk nl nm b">32</code>过滤器和一个步幅为<code class="fe nj nk nl nm b">2</code>的<code class="fe nj nk nl nm b">3x3</code>内核。请随意尝试其他尺寸。</p><p id="f423" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们稍后将讨论的<code class="fe nj nk nl nm b">activation</code>参数。</p><h2 id="0a7a" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">最大池层数</h2><p id="2b97" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">每个卷积层之后是最大池层。可以把它想象成卷积层结果的压缩版本。最大池只是减少了数据量，同时保留了最重要的信息。我们在这里的目标和裁剪是一样的——加强噪音上的信号。在卷积层之后添加最大池层是计算机视觉中的常见做法。</p><blockquote class="my mz na"><p id="59fb" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">另见:<a class="ae kz" href="https://youtu.be/o_DJ-FO6dw0" rel="noopener ugc nofollow" target="_blank">来自Udacity的最大池</a>视频<a class="ae kz" href="https://www.udacity.com/course/intro-to-tensorflow-for-deep-learning--ud187" rel="noopener ugc nofollow" target="_blank">tensor flow简介</a>免费课程</p></blockquote><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi on"><img src="../Images/276aeea414135d474ee84eb94c563bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*DTdqlBMkeDxsOOPh0MaWmQ.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">TF . layers . maxpool 2d({ poolSize:[2，2] })</figcaption></figure><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="04d5" class="nr lb it nm b gy ns nt l nu nv"><strong class="nm iu"><em class="mx">// 1st max-pooling layer</em></strong><br/>  tf.layers.maxPool2d({ <br/>  poolSize: [2, 2] <br/>})</span></pre><p id="872d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们再次指定池过滤器的大小。我们使用<code class="fe nj nk nl nm b">2x2</code>的大小，这使得数据大小减少了一倍。请随意试验我们自己的尺寸。</p><h2 id="d018" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">致密层</h2><p id="1518" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">最后，我们添加三个<code class="fe nj nk nl nm b"><a class="ae kz" href="https://js.tensorflow.org/api/latest/#layers.dense" rel="noopener ugc nofollow" target="_blank">dense()</a></code>层。这些负责使用深度学习魔法实际推断转向值。把它们想象成另一套过滤器，用来提取我们需要的信息。这里，我们再次设置过滤器的大小，模型将在训练期间计算出这些过滤器的精确值。</p><p id="103b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，在第一个密集层之前，我们插入一个<code class="fe nj nk nl nm b"><a class="ae kz" href="https://js.tensorflow.org/api/latest/#layers.flatten" rel="noopener ugc nofollow" target="_blank">flatten()</a></code>层。它的工作是将多维表示的数据转换成单一的平面数组。这是必要的，因为每个密集层是一个单一的平面阵列。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6853fbf7cb3a83bcb4b5e06399d014fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*TeFRweHRYFULV47Qr0SA5g.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">tf.layers.dense({ units: 1024，activation: 'relu' })，<br/> tf.layers.dense({ units: 128，activation: 'relu' })，<br/> tf.layers.dense({ units: 1，activation: 'linear' })</figcaption></figure><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="953e" class="nr lb it nm b gy ns nt l nu nv"><strong class="nm iu"><em class="mx">// Dense layers with dropout layer</em></strong><br/>tf.layers.flatten(),<br/>tf.layers.dense({ units: 1024, activation: 'relu' }),<br/>tf.layers.dropout({ rate: 0.25 }),<strong class="nm iu"><em class="mx"><br/></em></strong>tf.layers.dense({ units: 128, activation: 'relu' }),<br/>tf.layers.dense({ units: 1, activation: 'linear' })</span></pre><p id="464a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将添加两个大小为<code class="fe nj nk nl nm b">1024</code>和<code class="fe nj nk nl nm b">128</code>的连续密集层。随意试验其他尺寸和一些密集层。</p><p id="f826" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一个密集层只有一个值——我们正在寻找的导向值。这是将模型中的所有滤镜应用于初始图像的结果。</p><h2 id="69eb" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">脱落层</h2><p id="6d23" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><code class="fe nj nk nl nm b"><a class="ae kz" href="https://js.tensorflow.org/api/latest/#layers.dropout" rel="noopener ugc nofollow" target="_blank">tf.layers.dropout()</a></code>层仅在训练期间使用。它的工作是关闭两个连续层之间特定数量的连接。这种技术被认为是训练的有效方法。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/09c0913b39b6fa4e934a87d5d2b9a911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*NJ16LyGAHxMhgnvzCKX2CQ.png"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated"><em class="op"> //虚线连接被丢弃</em><br/>TF . layers . dense({ units:1024，activation: 'relu' })，<br/><strong class="bd lc">TF . layers . dropout({ rate:0.25 })，</strong><br/>TF . layers . dense({ units:128，activation: 'relu' })</figcaption></figure><p id="bfa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将在前两个密集层之间增加25%的压差。随意试验你自己的价值观，或者干脆摆脱这一层。</p><h2 id="cc06" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">激活功能</h2><p id="45cd" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">对于我们网络的所有层，除了最后一层，我们将使用<em class="mx"> ReLU </em>激活函数。激活功能就像是图层末尾的另一个滤镜。ReLU所做的——它通过应用<code class="fe nj nk nl nm b">max(0, value)</code>丢弃小于零的值。这被认为是有效的培训，并被广泛使用。</p><p id="0990" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于最后一层，我们不想删除负值，因为我们的转向值应该在<code class="fe nj nk nl nm b">-1</code>和<code class="fe nj nk nl nm b">1</code>之间。所以我们使用一个<em class="mx">线性</em>激活函数。这仅仅意味着<em class="mx">“对该值不做任何事情，只传递它”</em>。</p><h2 id="8ea6" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">损失和优化函数</h2><p id="2a38" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">最后，我们必须指定我们的模型将使用哪个<em class="mx">损失</em>和<em class="mx">优化器</em>函数。这些是模型将在训练期间使用的工具，以便为其所有过滤器设置适当的值。</p><p id="c7c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">损失函数</strong>:模型用来衡量滤波器工作的好坏。我们将使用名为<em class="mx">的均方差</em>。当我们想得到一个单一的数值作为输出时，这是一个标准的做法。它衡量模型返回的值与实际值有多远。损失越少，模型就越好。训练的目标是使损失值最小化。</p><p id="be1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优化器函数</strong>:由模型使用，在训练期间复杂地更新所有过滤器。亚当是这里的标准人选。</p><h1 id="583c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.加载和准备培训数据</h1><p id="cc61" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了给我们的模型提供数据，我们将创建一个<em class="mx">生成器函数</em>，它将无限循环遍历我们的<code class="fe nj nk nl nm b">driving_log.csv</code>，并生成一个带有图像数据和转向值的<code class="fe nj nk nl nm b">Buffer</code>。</p><blockquote class="my mz na"><p id="9156" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">我们使用一个生成器函数，因为它是TensorFlow <code class="fe nj nk nl nm b"><em class="it">fitDataset()</em></code>方法所期望的——我们稍后会看到。基本上TensorFlow希望我们提供一个函数，允许它迭代数据集中的每一项。</p><p id="4388" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">了解关于生成器的更多信息:<br/><a class="ae kz" href="https://dev.to/gajus/the-definitive-guide-to-the-javascript-generators-1deo" rel="noopener ugc nofollow" target="_blank">Gajus Kuizinas的JavaScript生成器权威指南</a><br/><a class="ae kz" href="https://exploringjs.com/es6/ch_generators.html" rel="noopener ugc nofollow" target="_blank">生成器</a>在Axel Rauschmayer博士的书《探索ES6</p></blockquote><p id="9fe3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，<code class="fe nj nk nl nm b">driving_log.csv</code>的每一行实际上包含3个图像:一个来自汽车的中央摄像机，两个来自侧面摄像机。</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="30d2" class="nr lb it nm b gy ns nt l nu nv">/data/IMG/center_2020_05_24_15_52_29_872.jpg,/data/IMG/left_2020_05_24_15_52_29_872.jpg,/data/IMG/right_2020_05_24_15_52_29_872.jpg,-0.35,0,0,25.13947</span></pre><p id="5d67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用所有三个图像。对于来自侧面摄像机的图像，我们将对转向值应用偏移<code class="fe nj nk nl nm b">0.333</code>，因为它们从中心偏移了一点点。</p><blockquote class="my mz na"><p id="135f" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">这个偏移量从何而来？这是实证实验的结果。人们报告说，在<code class="fe nj nk nl nm b">0.2</code>和<code class="fe nj nk nl nm b">0.4</code>之间的数值范围内，他们得到了好的结果。我们将选择中间立场，但你可以自由地自己进行实验。</p></blockquote><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oq"><img src="../Images/e31d6051f6637087809342b2253ee6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQaprf44VlY-KCQOHJEdNQ.png"/></div></div></figure><p id="dff5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输出数据文件<code class="fe nj nk nl nm b">driving_log.csv</code>包含另一个遥测:<code class="fe nj nk nl nm b">throttle</code>、<code class="fe nj nk nl nm b">brake</code>和<code class="fe nj nk nl nm b">speed</code>。我们暂时忽略这些。</p><p id="de44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们如何实现一个生成器函数:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="7c59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个函数中，我们使用<a class="ae kz" href="https://www.npmjs.com/package/csv-parser" rel="noopener ugc nofollow" target="_blank"> csv解析器</a>创建了一个<code class="fe nj nk nl nm b">csvStream</code>，它将读取我们的<code class="fe nj nk nl nm b">driving_log.csv</code>并逐行循环。</p><p id="4b0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们有三个<code class="fe nj nk nl nm b">yield</code>语句，因为<code class="fe nj nk nl nm b">driving_log.csv</code>文件的每一个实际行都会产生3对单独的图像以及转向值。</p><p id="758d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当<code class="fe nj nk nl nm b">for await</code>循环到达<code class="fe nj nk nl nm b">driving_log.csv</code>的结尾时，文件将从开始处再次打开。这将使我们能够尽可能多地循环数据。</p><p id="f6c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用<code class="fe nj nk nl nm b">next()</code>方法检查我们的发电机是否正常工作:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="7749" class="nr lb it nm b gy ns nt l nu nv">const data = dataGenerator();<br/>data.next() // { value: [&lt;Buffer&gt;, &lt;Number&gt;], done: false }<br/>data.next() // { value: [&lt;Buffer&gt;, &lt;Number&gt;], done: false }<br/>...</span></pre><h2 id="2d54" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">转换张量流的数据</h2><p id="8228" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">最后，我们需要将数据转换为TensorFlow可以理解的表示形式:</p><ol class=""><li id="2f03" class="mj mk it kd b ke kf ki kj km ml kq mm ku mn ky mo mp mq mr bi translated">将图像中的每个像素值从<code class="fe nj nk nl nm b">0</code>和<code class="fe nj nk nl nm b">255</code>之间的范围转换为<code class="fe nj nk nl nm b">0</code>和<code class="fe nj nk nl nm b">1</code>之间的范围，因为深度学习模型在使用<code class="fe nj nk nl nm b">0</code>和<code class="fe nj nk nl nm b">1</code>之间的值时效果更好。</li><li id="54e4" class="mj mk it kd b ke ms ki mt km mu kq mv ku mw ky mo mp mq mr bi translated">将我们的数字打包到<code class="fe nj nk nl nm b"><a class="ae kz" href="https://js.tensorflow.org/api/latest/#Tensors" rel="noopener ugc nofollow" target="_blank">Tensors</a></code>中，因为这是TensorFlow处理的数据类型。</li></ol><p id="e43d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以这样做:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="41cf" class="nr lb it nm b gy ns nt l nu nv">const batchSize = 64;</span><span id="9ad6" class="nr lb it nm b gy ok nt l nu nv">const dataset = tf.data<br/>  <strong class="nm iu"><em class="mx">// Use our generator function</em></strong><br/>  .generator(dataGenerator)<br/>  <strong class="nm iu"><em class="mx">// Convert each datapoint to TensorFlow-specific representation</em></strong><br/>  .map(([imageBuffer, steering]) =&gt; {<br/>    const xs = tf.node.decodeJpeg(imageBuffer).div(255);<br/>    const ys = tf.tensor1d([steering]);<br/>    return { xs, ys };<br/>  })<br/>  <strong class="nm iu"><em class="mx">// Randomly shuffle data within batches of specific size</em></strong><br/>  .shuffle(batchSize)<br/>  <strong class="nm iu"><em class="mx">// Return datapoints in batches of specific size</em></strong><br/>  .batch(batchSize);</span></pre><p id="038d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用生成器函数创建TensorFlow <a class="ae kz" href="https://js.tensorflow.org/api/latest/#class:data.Dataset" rel="noopener ugc nofollow" target="_blank">数据集</a>，然后指示TensorFlow使用<code class="fe nj nk nl nm b">map</code>函数处理数据集中的每一项。</p><p id="8c83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe nj nk nl nm b">map</code>函数中，我们将<code class="fe nj nk nl nm b">JPEG</code>图像转换成<code class="fe nj nk nl nm b">Tensor</code>，然后将张量中的每个值除以<code class="fe nj nk nl nm b">255</code>。结果，我们有了一个适合深度学习的图像表示——一个值在<code class="fe nj nk nl nm b">0</code>和<code class="fe nj nk nl nm b">1</code>之间的张量。</p><blockquote class="my mz na"><p id="860f" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">将任意值调整到<code class="fe nj nk nl nm b">0</code>和<code class="fe nj nk nl nm b">1</code>之间的范围内，广泛应用于深度学习。</p></blockquote><p id="d33c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">转向值已经在<code class="fe nj nk nl nm b">0</code>和<code class="fe nj nk nl nm b">1</code>之间，我们就把它包装成一个<code class="fe nj nk nl nm b">Tensor</code>。</p><p id="bec4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们将每个条目作为一个带有两个键的对象返回:<code class="fe nj nk nl nm b">xs</code>和<code class="fe nj nk nl nm b">ys</code>。这就是我们如何为模型指定输入值(x)和预期输出值(y)的。</p><p id="0c1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们指示数据集以混合批次的<code class="fe nj nk nl nm b">64</code>项提供数据。这意味着我们的模型在学习时会一次看64张图片。批量通常会使训练更有效率。常见的尺寸有<code class="fe nj nk nl nm b">32</code>、<code class="fe nj nk nl nm b">64</code>、<code class="fe nj nk nl nm b">128</code>等。请随意试验您自己的尺寸。</p><h1 id="e4a0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.训练深度学习模型</h1><p id="00cc" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在定义了神经网络模型并且数据集准备好之后，我们想要最终训练我们的网络。</p><p id="ee2b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">训练代码非常简单。TensorFlow在幕后为我们完成了所有繁重的工作:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="55a8" class="nr lb it nm b gy ns nt l nu nv">const linesCount = require('file-lines-count');</span><span id="5c8a" class="nr lb it nm b gy ok nt l nu nv"><strong class="nm iu">// Initialize our model</strong><br/>const model = initModel();</span><span id="0ae4" class="nr lb it nm b gy ok nt l nu nv"><strong class="nm iu">// Calulate total number of samples in our dataset</strong><br/>const totalSamples = (await linesCount(pathToCSV)) * 3;</span><span id="fe19" class="nr lb it nm b gy ok nt l nu nv"><strong class="nm iu">// Train the model</strong><br/>await model.fitDataset(dataset, {<br/>  epochs,<br/>  batchesPerEpoch: Math.floor(totalSamples / batchSize)<br/>});</span><span id="033b" class="nr lb it nm b gy ok nt l nu nv"><strong class="nm iu">// Save the trained model</strong><br/>await model.save(`file://${modelDir}`);</span></pre><p id="7a66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们使用之前创建的<code class="fe nj nk nl nm b">initModel()</code>函数初始化我们的模型。那么我们称之为<code class="fe nj nk nl nm b"><a class="ae kz" href="https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset" rel="noopener ugc nofollow" target="_blank">model.fitDataset()</a></code>法。这个方法将做实际的训练。最后，我们将训练好的模型保存到磁盘上，以便进一步用于驾驶汽车。</p><p id="6efb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们向<code class="fe nj nk nl nm b">model.fitDataset()</code>提供以下参数:</p><p id="2c88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nj nk nl nm b"><strong class="kd iu">dataset</strong></code>:我们之前创建的TensorFlow数据集；</p><p id="83f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nj nk nl nm b"><strong class="kd iu">epochs</strong></code>:历元数。<em class="mx">历元</em>是在训练期间遍历整个数据集的一次迭代。通过指定历元的数量，我们定义了我们想要遍历数据集的次数。通常，我们想要循环几次，因为每个时期为模型中的所有滤波器产生更好的调整；</p><p id="a4c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nj nk nl nm b"><strong class="kd iu">batchesPerEpoch</strong></code>:单个历元中数据的批次数。因为我们提供数据集作为生成器，所以模型不知道总共有多少项。我们必须通过指定数据集包含多少个批次来自己提供它。我们将该值计算为样本总数除以批次大小。因为我们的<code class="fe nj nk nl nm b">CSV</code>文件中的每一行都产生<code class="fe nj nk nl nm b">3</code>个样本，所以我们将样本总数计算为<code class="fe nj nk nl nm b">CSV</code>文件中的行数乘以<code class="fe nj nk nl nm b">3</code>。为了在一行代码中快速计算文件中的行数，我们使用了一个很小的<code class="fe nj nk nl nm b"><a class="ae kz" href="https://www.npmjs.com/package/file-lines-count" rel="noopener ugc nofollow" target="_blank">file-lines-count</a></code>库。</p><h2 id="7ca2" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">命令行参数</h2><p id="a2dd" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们可能希望使用不同的数据集和不同的历元数进行训练实验。能够将数据集目录、历元数和最终模型目录指定为命令行参数会很方便。为此我们可以使用<code class="fe nj nk nl nm b"><a class="ae kz" href="https://www.npmjs.com/package/minimist" rel="noopener ugc nofollow" target="_blank">minimist</a></code>:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="54f9" class="nr lb it nm b gy ns nt l nu nv">const parseArgs = require('minimist');</span><span id="850a" class="nr lb it nm b gy ok nt l nu nv">const { <br/>  data: dataDir = 'data',<br/>  model: modelDir = 'model',<br/>  epochs = 10<br/>} = parseArgs(process.argv.slice(2));</span></pre><p id="647e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们读取命令行参数<code class="fe nj nk nl nm b">data</code>、<code class="fe nj nk nl nm b">model</code>、<code class="fe nj nk nl nm b">epochs</code>，并分别将它们赋给常量<code class="fe nj nk nl nm b">dataDir</code>、<code class="fe nj nk nl nm b">modelDir</code>和<code class="fe nj nk nl nm b">epochs</code>。<br/>训练代码可以这样调用:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="53e3" class="nr lb it nm b gy ns nt l nu nv">node train.js --data mydatadir --epochs 5 --model mymodeldir</span></pre><p id="cddb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还为每个参数提供了默认值，因此可以省略它们。</p><h2 id="f32a" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">培养</h2><p id="a023" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">最后，我们可以通过运行我们的脚本开始训练。例如，如果我们的记录存储在当前用户的目录<code class="fe nj nk nl nm b">Documents</code>中的目录<code class="fe nj nk nl nm b">track1</code>中，并且我们想要训练3个时期，我们可以在这里指定它:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="ccf9" class="nr lb it nm b gy ns nt l nu nv">node train.js --data ~/Documents/track1 --epochs 3</span></pre><p id="27cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个输出示例:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="1fd3" class="nr lb it nm b gy ns nt l nu nv">Epoch 1 / 3<br/>eta=0.0 ==========================================================&gt; <br/>103621ms 761918us/step - loss=0.0667 <br/>Epoch 2 / 3<br/>eta=0.0 ==================================================================&gt; <br/>127557ms 937918us/step - loss=0.0568 <br/>Epoch 3 / 3<br/>eta=0.0 ==================================================================&gt; <br/>116276ms 854970us/step - loss=0.0588 <br/>Model saved to: model</span></pre><p id="dd87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意<code class="fe nj nk nl nm b">loss</code>在第三个时期增加了一点。通常，这是停止训练的信号，因为模型不再改进了。</p><blockquote class="my mz na"><p id="24db" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">在配备1,6 GHz双核英特尔酷睿i5处理器的MacBookAir上，每个epoch大约需要2分钟。</p></blockquote><h1 id="d77e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.使用模型驾驶汽车</h1><p id="f019" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在，我们想在模拟器中向汽车发送转向命令。</p><p id="1202" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与模拟器的通信是通过WebSocket协议完成的，该协议封装在一个<a class="ae kz" href="https://www.npmjs.com/package/socket.io" rel="noopener ugc nofollow" target="_blank"> socket.io </a>库中。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ot"><img src="../Images/3a3d4e9b346a5ae759ebbb62df1f485a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjM0otEGSbjOqxHzisCg5w.png"/></div></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk translated">Udacity自动驾驶汽车模拟器反馈周期</figcaption></figure><p id="e2c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="mx">自主</em>模式下，Udacity模拟器连接到端口<code class="fe nj nk nl nm b">4567</code>上的socket.io服务器。一旦连接上，它将向该端口发送一条带有<code class="fe nj nk nl nm b">telemetry</code>数据的消息。服务器可以用<code class="fe nj nk nl nm b">steer</code>指令对该消息做出响应，这又会产生一个<code class="fe nj nk nl nm b">telemetry</code>消息，以此类推。</p><p id="7dfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是驾驶脚本:</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="05e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们等待模型被加载，然后我们开始在端口<code class="fe nj nk nl nm b">4567</code>上监听socket.io消息。</p><p id="aea0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe nj nk nl nm b">telemetry</code>消息中，我们解析图像数据(图像是<code class="fe nj nk nl nm b">base64</code>编码的)并将该数据输入到我们的模型中。</p><blockquote class="my mz na"><p id="cc34" class="kb kc mx kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">想知道模拟器还在发送什么遥测数据吗？<br/>在GitHub 上看它的<a class="ae kz" href="https://github.com/udacity/self-driving-car-sim/blob/bdcd588990df2db4706e772cd45d6e013631a2f2/Assets/1_SelfDrivingCar/Scripts/CommandServer.cs#L64-L67" rel="noopener ugc nofollow" target="_blank">代码里面。</a></p></blockquote><p id="7b6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了将接收到的图像传递给我们的模型，我们将其转换为张量，并将所有像素值归一化到<code class="fe nj nk nl nm b">0</code>和<code class="fe nj nk nl nm b">1</code>之间的范围。我们还必须在张量中增加另一个维度——批量。就是<code class="fe nj nk nl nm b">1</code>在这个声明里代表的东西:<code class="fe nj nk nl nm b">reshape([1, 160, 320, 3])</code>。</p><p id="ef4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们使用<code class="fe nj nk nl nm b">model.predict()</code>获得<code class="fe nj nk nl nm b">steering</code>值。这条语句的结尾:<code class="fe nj nk nl nm b">squeeze().arraySync()</code>是将转向值从张量转换回数字所需要的。</p><p id="26ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们通过发出<code class="fe nj nk nl nm b">steer</code>消息将转向值发送到套接字中。请注意，我们将所有数值转换为字符串，因为这是模拟器所期望的。</p><p id="e080" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还发送一个<code class="fe nj nk nl nm b">throttle</code>值，我们计算该值不会超过最大速度。</p><p id="fbf6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了方便起见，驱动脚本有两个命令行参数:<br/> <code class="fe nj nk nl nm b"><strong class="kd iu">model</strong></code>:要使用的模型的目录；<br/> <code class="fe nj nk nl nm b"><strong class="kd iu">speed</strong></code>:行驶中的最大速度。请注意，模拟器中的汽车已经被限制在30英里/小时左右。</p><p id="91c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们都准备好驾驶自动驾驶汽车了！</p><p id="96c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设模型在我们项目的默认<code class="fe nj nk nl nm b">model</code>目录中，让我们以自主模式启动模拟器并运行我们的驾驶脚本:</p><pre class="me mf mg mh gt nn nm no np aw nq bi"><span id="d395" class="nr lb it nm b gy ns nt l nu nv">node drive.js</span></pre><p id="2dfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它是完全自动驾驶的。观看是多么有意义啊！</p><figure class="me mf mg mh gt ju"><div class="bz fp l di"><div class="ou os l"/></div></figure><h1 id="a63b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">后续步骤</h1><p id="3690" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面是如何进一步改进这个项目的几个后续步骤。</p><h2 id="3bce" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">第二跑道的训练</h2><p id="753b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们只根据从模拟器的第一个轨道收集的数据来训练我们的模型。此外，我们可以为第二条轨道明确地训练另一个模型，或者使用来自两条轨道的数据来训练它，以使它具有普遍的自主性。</p><h2 id="5d3a" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">确认</h2><p id="acbe" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了简洁起见，我们没有将数据集分成训练和验证部分。那种分裂是机器学习中控制模型质量的标准做法。验证数据集仅用于测量模型的损失，所有验证样本都不会用于训练。因此，我们可以衡量我们的模型在以前看不到的数据上工作得有多好。</p><h2 id="3cee" class="nr lb it bd lc nw nx dn lg ny nz dp lk km oa ob lo kq oc od ls ku oe of lw og bi translated">图像增强</h2><p id="8657" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这种技术可以通过移动、缩放、改变亮度等等，用不同种类的相同图像来丰富我们的图像数据集。我们的模型看到的数据越多，就越强大。虽然，图像处理是一个密集的计算任务，这可能会大大降低训练速度。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><div class="me mf mg mh gt pc"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">编写面试问题</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">技术开发</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq jz pc"/></div></div></a></div></div></div>    
</body>
</html>