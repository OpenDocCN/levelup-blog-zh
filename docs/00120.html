<html>
<head>
<title>Build time travel debugging in Redux from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始在Redux中构建时间旅行调试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-time-travel-debugging-in-redux-from-scratch-665fea8fc6cc?source=collection_archive---------0-----------------------#2018-05-07">https://levelup.gitconnected.com/build-time-travel-debugging-in-redux-from-scratch-665fea8fc6cc?source=collection_archive---------0-----------------------#2018-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5edd54efebebb0c2198582ca55896b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WoJnfVeCnfT2cGzlsgAjJw.jpeg"/></div></div></figure><p id="66c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，我们将一步一步从头开始构建时间旅行调试。我们将首先介绍Redux的核心原则，以及它们如何支持构建如此强大的功能。然后，我们将用纯JavaScript构建Redux核心库和时间旅行调试，并将其连接到一个简单的HTML应用程序，而不使用任何React。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/7d142cbc2671e0c8d733e84622a07fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/1*cRt1u7SCt376nCWu_Ae7mA.gif"/></div></figure><h1 id="592e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Redux时间旅行的基本原理</h1><p id="8f5e" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">时间旅行调试指的是在应用程序的状态中前进和后退的能力，使开发人员能够准确理解在应用程序生命周期的任何一点上正在发生的事情。</p><div class="mh mi gp gr mj mk"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">学习React -最佳React教程(2018) | gitconnected</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">React的前48门课程。教程由开发者提交并投票，让你找到最好的反应…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">gitconnected.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my jz mk"/></div></div></a></div><p id="d0f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redux是通量模式的扩展，它强制单向数据流。此外，Redux为flux理念增加了3个原则。</p><ol class=""><li id="e1fb" class="mz na it kd b ke kf ki kj km nb kq nc ku nd ky ne nf ng nh bi translated">国家真相的单一来源。应用程序的整个状态存储在一个JavaScript对象中。</li><li id="c6d5" class="mz na it kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated"><strong class="kd iu">状态为只读</strong>。这就是不变性的概念。状态永远不会改变，但是每个动作都会生成一个全新的状态对象，取代旧的状态对象。</li><li id="f584" class="mz na it kd b ke ni ki nj km nk kq nl ku nm ky ne nf ng nh bi translated"><strong class="kd iu">纯功能变化</strong>。这意味着任何时候产生一个新的状态，它都不会触发任何其他副作用。</li></ol><p id="4891" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过利用Redux应用程序的状态是在这个线性且可预测的时间线中生成的基本概念，时间旅行调试通过存储每个被触发的动作所生成的状态树的副本来扩展这个概念。</p><p id="bdde" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">UI可以被认为是Redux状态的一个纯函数。时间旅行允许我们将应用程序的状态设置为所需的值，并生成将在这些条件下创建的精确UI。这种应用程序的可见性和透明性对于开发人员来说是一个非常强大的工具，可以帮助他们充分了解应用程序内部发生的事情，并显著减少调试工作。</p><h1 id="4cd6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Redux和时间旅行调试构建简单的应用程序</h1><p id="c89a" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们将构建一个简单的HTML应用程序，它在单击时生成一个随机的背景颜色，并使用Redux来存储RGB值。我们还将创建一个时间旅行扩展，这将允许我们重放应用程序的每个状态，并直观地看到每一步的背景变化。</p><h2 id="045a" class="nn lf it bd lg no np dn lk nq nr dp lo km ns nt ls kq nu nv lw ku nw nx ma ny bi translated">构建Redux核心库</h2><p id="4da2" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">如果您对构建时间旅行调试感兴趣，我也假设您熟悉Redux。如果你是Redux的新手，或者需要复习一下悬挂物和减速器，在继续详细解释之前，请参考本文<a class="ae nz" rel="noopener ugc nofollow" target="_blank" href="/learn-redux-by-building-redux-from-scratch-dcbcbd31b0d0?source=user_profile---------8----------------">中的</a>。在本教程中，您将一步一步地构建<code class="fe oa ob oc od b">createStore</code>和reducers。</p><p id="7372" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Redux核心库是<code class="fe oa ob oc od b">createStore</code>函数。Redux存储管理表示应用程序整个状态的状态对象，并公开读取和更新状态所需的方法。调用<code class="fe oa ob oc od b">createStore</code>初始化状态并返回一个包含<code class="fe oa ob oc od b">getState()</code>、<code class="fe oa ob oc od b">subscribe()</code>和<code class="fe oa ob oc od b">dispatch()</code>方法的对象。</p><p id="eab7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe oa ob oc od b">createStore</code>函数接受一个必需的参数，即reducer函数，并且可以选择接受一个<code class="fe oa ob oc od b">initialState</code>参数。<code class="fe oa ob oc od b">createStore</code>的全部内容如下(疯狂它有多小，对吧？):</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="6e32" class="nn lf it bd lg no np dn lk nq nr dp lo km ns nt ls kq nu nv lw ku nw nx ma ny bi translated">实现时间旅行调试</h2><p id="fd0e" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们将通过为Redux存储订阅一个新的侦听器并扩展存储的功能来实现时间旅行。状态的每一次变化都将被添加到一个数组中，为我们提供应用程序状态的每一次变化的同步表示。为了清楚起见，我们将把状态列表打印到DOM中。</p><p id="5eab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们初始化历史中活动状态的时间线和索引(第1–2行)。我们还创建了一个<code class="fe oa ob oc od b">saveTimeline</code>函数，它将当前状态添加到时间轴数组，将状态打印到DOM，并增加应用程序正在呈现的给定状态树的索引。为了确保捕捉到每个状态变化，我们订阅了<code class="fe oa ob oc od b">saveTimeline</code>函数作为Redux存储的监听器。</p><pre class="la lb lc ld gt og od oh oi aw oj bi"><span id="6b5b" class="nn lf it od b gy ok ol l om on">const timeline = [];<br/>let activeItem = 0;</span><span id="4d57" class="nn lf it od b gy oo ol l om on">const saveTimeline = () =&gt; {<br/>  timeline.push(store.getState());<br/>  timelineNode.innerHTML = timeline<br/>    .map(item =&gt; JSON.stringify(item))<br/>    .join('&lt;br/&gt;');<br/>  activeItem = timeline.length - 1;<br/>};</span><span id="e19f" class="nn lf it od b gy oo ol l om on">store.subscribe(saveTimeline);</span></pre><p id="fa56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来向商店添加一个新功能— <code class="fe oa ob oc od b">setState</code>。这将允许我们将任何状态注入Redux存储。当我们使用DOM上的按钮在状态间进行时间旅行时，将调用它，我们将在下一节中创建DOM。下面是<code class="fe oa ob oc od b">setState</code>功能在商店上的实现。</p><pre class="la lb lc ld gt og od oh oi aw oj bi"><span id="7381" class="nn lf it od b gy ok ol l om on">// FOR DEBUGGING PURPOSES ONLY<br/>store.setState = desiredState =&gt; {<br/>  store.state = desiredState;</span><span id="9263" class="nn lf it od b gy oo ol l om on">// Assume the debugger is injected last. We don't want to update<br/>// the saved states as we are debugging, so we slice it off.<br/>  const applicationListeners = store.listeners.slice(0, -1);<br/>  applicationListeners.forEach(listener =&gt; listener());<br/>};</span></pre><blockquote class="op oq or"><p id="a377" class="kb kc os kd b ke kf kg kh ki kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ky im bi translated">请记住，这只是出于教育目的。您不应该以这种方式扩展Redux存储或设置状态。</p></blockquote><p id="0194" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们在下一节构建完整的应用程序时，我们也将构建DOM。现在，你所需要知道的是将会有一个“上一页”和一个“下一页”按钮来启动时间旅行。这些按钮将更新正在显示的时间线状态的活动索引，使我们能够轻松地在状态变化中向前和向后移动。下面显示了我们如何注册事件侦听器来导航时间轴:</p><pre class="la lb lc ld gt og od oh oi aw oj bi"><span id="ba21" class="nn lf it od b gy ok ol l om on">const previous = document.getElementById('previous');<br/>const next = document.getElementById('next');</span><span id="809e" class="nn lf it od b gy oo ol l om on">previous.addEventListener('click', e =&gt; {<br/>  e.preventDefault();<br/>  e.stopPropagation();</span><span id="18ba" class="nn lf it od b gy oo ol l om on">  let index = activeItem - 1;<br/>  index = index &lt;= 0 ? 0 : index;<br/>  activeItem = index;</span><span id="4831" class="nn lf it od b gy oo ol l om on">  const desiredState = timeline[index];<br/>  store.setState(desiredState);<br/>});</span><span id="580a" class="nn lf it od b gy oo ol l om on">next.addEventListener('click', e =&gt; {<br/>  e.preventDefault();<br/>  e.stopPropagation();</span><span id="4c3c" class="nn lf it od b gy oo ol l om on">  let index = activeItem + 1;<br/>  index = index &gt;= timeline.length - 1 ? <br/>    timeline.length - 1 :   index;<br/>  activeItem = index;</span><span id="8e9a" class="nn lf it od b gy oo ol l om on">  const desiredState = timeline[index];<br/>  store.setState(desiredState);<br/>});</span></pre><p id="f6e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将所有这些放在一起会产生下面的代码来创建时间旅行调试。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="f05a" class="nn lf it bd lg no np dn lk nq nr dp lo km ns nt ls kq nu nv lw ku nw nx ma ny bi translated">使用时间旅行调试构建应用程序</h2><p id="7180" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们现在将创建一个可视化表示来理解时间旅行调试。我们向文档主体添加了一个事件监听器，它将生成三个介于0–255之间的随机数，并将它们保存为Redux存储中的<code class="fe oa ob oc od b">r</code>、<code class="fe oa ob oc od b">g</code>和<code class="fe oa ob oc od b">b</code>。商店订阅的一个功能，它将更新背景颜色，并在屏幕上显示当前的RGB值。此外，我们的时间旅行调试器将订阅状态更改，并将每个更改添加到时间线。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><div class="mh mi gp gr mj mk"><a href="https://gitconnected.com/portfolio-api" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">组合API —轻松发展您的编码事业| gitconnected</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">消除在每个单独位置手动更新您的详细信息的痛苦。只需在您的中更改一次数据…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">gitconnected.com</p></div></div><div class="mt l"><div class="ox l mv mw mx mt my jz mk"/></div></div></a></div><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ow"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><p id="5fc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们从如下初始化HTML文档开始。</p><pre class="la lb lc ld gt og od oh oi aw oj bi"><span id="a17c" class="nn lf it od b gy ok ol l om on">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;title&gt;&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div&gt;My background color is &lt;span id="background"&gt;&lt;/span&gt;&lt;/div&gt;<br/>    &lt;div id="debugger"&gt;<br/>      &lt;div&gt;<br/>        &lt;button id="previous"&gt;<br/>          previous<br/>        &lt;/button&gt;<br/>        &lt;button id="next"&gt;<br/>          next<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>      &lt;div id="timeline"&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;style&gt;<br/>      html, body {<br/>        width: 100vw;<br/>        height: 100vh;<br/>      }</span><span id="634d" class="nn lf it od b gy oo ol l om on">    #debugger {<br/>        margin-top: 30px;<br/>      }<br/>    &lt;/style&gt;<br/>    &lt;script&gt;<br/>      // Application logic will be added here...<br/>    &lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d93b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，我们还为调试器创建了一个<code class="fe oa ob oc od b">&lt;div&gt;</code>。有导航不同状态的按钮和列出状态中每个更新的节点。</p><p id="8fb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在脚本内部，我们从引用DOM节点和我们的<code class="fe oa ob oc od b">createStore</code>开始。</p><pre class="la lb lc ld gt og od oh oi aw oj bi"><span id="79d9" class="nn lf it od b gy ok ol l om on">const textNode = document.getElementById('background');<br/>const timelineNode = document.getElementById('timeline');</span><span id="34f6" class="nn lf it od b gy oo ol l om on">const createStore = (reducer, initialState) =&gt; {<br/>  const store = {};<br/>  store.state = initialState;<br/>  store.listeners = [];</span><span id="0ef8" class="nn lf it od b gy oo ol l om on">  store.getState = () =&gt; store.state;</span><span id="2171" class="nn lf it od b gy oo ol l om on">  store.subscribe = listener =&gt; {<br/>    store.listeners.push(listener);<br/>  };</span><span id="f47a" class="nn lf it od b gy oo ol l om on">  store.dispatch = action =&gt; {<br/>    console.log('&gt; Action', action);<br/>    store.state = reducer(store.state, action);<br/>    store.listeners.forEach(listener =&gt; listener());<br/>  };</span><span id="2d89" class="nn lf it od b gy oo ol l om on">  return store;<br/>};</span></pre><p id="f9c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建reducer来跟踪RGB值并初始化存储。初始状态将是白色背景。</p><pre class="la lb lc ld gt og od oh oi aw oj bi"><span id="c047" class="nn lf it od b gy ok ol l om on">const getInitialState = () =&gt; {<br/>  return {<br/>    r: 255,<br/>    g: 255,<br/>    b: 255,<br/>  };<br/>};</span><span id="6bc3" class="nn lf it od b gy oo ol l om on">const reducer = (state = getInitialState(), action) =&gt; {<br/>  switch (action.type) {<br/>    case 'SET_RGB':<br/>      return {<br/>        r: action.payload.r,<br/>        g: action.payload.g,<br/>        b: action.payload.b,<br/>      };<br/>    default:<br/>      return state;<br/>  }<br/>};</span><span id="a4e1" class="nn lf it od b gy oo ol l om on">const store = createStore(reducer);</span></pre><p id="ec10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以为商店订阅一个函数，该函数将设置背景色并将文本RGB值添加到DOM中。这是因为对状态的任何更新都要在我们的UI中表示出来。</p><pre class="la lb lc ld gt og od oh oi aw oj bi"><span id="0a48" class="nn lf it od b gy ok ol l om on">const setBackgroundColor = () =&gt; {<br/>  const state = store.getState();<br/>  const { r, g, b } = state;<br/>  const rgb = `rgb(${r}, ${g}, ${b})`;</span><span id="461b" class="nn lf it od b gy oo ol l om on">  document.body.style.backgroundColor = rgb;<br/>  textNode.innerHTML = rgb;<br/>};</span><span id="5dd5" class="nn lf it od b gy oo ol l om on">store.subscribe(setBackgroundColor);</span></pre><p id="142a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们添加一个函数来生成一个0–255的随机数和一个<code class="fe oa ob oc od b">onClick</code>事件监听器，它将向商店发送一个新的RGB值。</p><pre class="la lb lc ld gt og od oh oi aw oj bi"><span id="c310" class="nn lf it od b gy ok ol l om on">const generateRandomColor = () =&gt; {<br/>  return Math.floor(Math.random() * 255);<br/>};</span><span id="be56" class="nn lf it od b gy oo ol l om on">// A simple event to dispatch changes<br/>document.addEventListener('click', () =&gt; {<br/>  console.log('----- Previous state', store.getState());<br/>  store.dispatch({<br/>    type: 'SET_RGB',<br/>    payload: {<br/>      r: generateRandomColor(),<br/>      g: generateRandomColor(),<br/>      b: generateRandomColor(),<br/>    },<br/>  });<br/>  console.log('+++++ New state', store.getState());<br/>});</span></pre><p id="2323" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们应用程序逻辑的全部。我们在下面的脚本标签调用<code class="fe oa ob oc od b">store.dispatch({})</code>的底部添加上一节中的时间旅行代码来生成初始状态。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/e7a20435c8b702f687f578e8ca7b2797.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/1*i3L6QvShxky5wkcloijdqA.gif"/></div></figure><p id="6954" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是该应用程序的完整工作代码。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><h1 id="69fb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包裹</h1><p id="6e4e" class="pw-post-body-paragraph kb kc it kd b ke mc kg kh ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky im bi translated">我们的时间旅行调试教育实现描绘了Redux的核心原则。我们可以毫不费力地跟踪我们的应用程序正在进行的状态，使得调试和完全理解正在发生的事情变得容易。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi oy"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure></div><div class="ab cl oz pa hx pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="im in io ip iq"><p id="c347" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="os">如果您觉得这篇文章有帮助，请点击</em>👏<em class="os">。</em> <a class="ae nz" href="https://medium.com/@treyhuffine" rel="noopener"> <em class="os">关注我</em> </a> <em class="os">了解更多关于区块链、React、Node.js、JavaScript和开源软件的文章！也可以在</em><a class="ae nz" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="os">Twitter</em></a><em class="os">或者</em><a class="ae nz" href="https://gitconnected.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="os">git connected</em></a><em class="os">上找到我。</em></p><h2 id="7379" class="nn lf it bd lg no np dn lk nq nr dp lo km ns nt ls kq nu nv lw ku nw nx ma ny bi translated"><a class="ae nz" href="https://blockace.io" rel="noopener ugc nofollow" target="_blank">在区块链找工作和加密货币&gt; </a></h2></div></div>    
</body>
</html>