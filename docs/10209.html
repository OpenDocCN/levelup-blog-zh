<html>
<head>
<title>Practical SOLID in Golang: Liskov Substitution Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗的实用固体:利斯科夫替代原理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-solid-in-golang-liskov-substitution-principle-e0d2eb9dd39?source=collection_archive---------1-----------------------#2021-11-07">https://levelup.gitconnected.com/practical-solid-in-golang-liskov-substitution-principle-e0d2eb9dd39?source=collection_archive---------1-----------------------#2021-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4f31" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">坚实的原则</h2><div class=""/><div class=""><h2 id="7dab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们通过介绍一个具有最复杂定义的原理——利斯科夫替代原理，继续我们的坚实原理之旅。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/cac1b4789fb798258e55251a6a2c7aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uOr0tDpdA7zHZHuC"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·斯皮斯克在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="680c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不是一个喜欢阅读的人。很多时候，当我阅读的时候，我意识到我在最后几分钟没有跟上文章的主题。很多时候，我从头到尾看了一整章，却不知道最后讲的是什么。</p><p id="a36d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时当我试图专注于内容时会感到沮丧，但很快我意识到我需要回去。这就是我开始寻找不同类型的媒体来了解这个话题的地方。</p><p id="762d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我第一次遇到固体原理的阅读问题是在利斯科夫替代原理上。这个定义对于我的测试来说太复杂了，至少在它的主格式中是这样。</p><p id="7b37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以猜测，LSP代表单词SOLID中的字母L。可以想象，这并不难理解(虽然有一些不那么数学化的定义就好了)。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="6eeb" class="mj mk it mf b gy ml mm l mn mo">Other articles from the SOLID series:</span><span id="bf52" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-single-responsibility-principle-20afb8643483"><strong class="mf jd">Practical SOLID in Golang: Single Responsability Principle</strong></a></span><span id="48ff" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-open-closed-principle-1dd361565452"><strong class="mf jd">Practical SOLID in Golang: Open/Closed Principle</strong></a></span><span id="b2b8" class="mj mk it mf b gy mp mm l mn mo"><br/>Some articles from the DDD series:</span><span id="9f83" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1.</strong> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="a559" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="e0b4" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mf jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="b17a" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mf jd">Practical DDD in Golang: Repository</strong></a></span><span id="7ea4" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. ...</strong></span></pre><div class="mq mr gp gr ms mt"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">blog.ompluscator.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lb mt"/></div></div></a></div><h1 id="9ad8" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">当我们不尊重里斯科夫替代</h1><p id="0a6a" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">我们第一次听说这个原理是在1988年，作者是<a class="ae lh" href="https://en.wikipedia.org/wiki/Barbara_Liskov" rel="noopener ugc nofollow" target="_blank">芭芭拉·利斯科夫</a>。后来，<a class="ae lh" href="https://twitter.com/unclebobmartin" rel="noopener ugc nofollow" target="_blank">Bob</a>大叔在他的论文里给出了他对这个话题的<a class="ae lh" href="https://web.archive.org/web/20151128004108/http://www.objectmentor.com/resources/articles/lsp.pdf" rel="noopener ugc nofollow" target="_blank">看法</a>，后来作为坚实的原则之一。让我们看看上面写着什么:</p><blockquote class="oe of og"><p id="f676" class="li lj oh lk b ll lm kd ln lo lp kg lq oi ls lt lu oj lw lx ly ok ma mb mc md im bi translated">设φ(x)是关于t类型的对象x的一个可证明的性质，那么φ(y)对于S类型的对象y应该是真的，其中S是t的子类型。</p></blockquote><p id="582d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">祝这个定义好运。</p><p id="30be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不，说真的，这是什么定义？在写这篇文章的时候，即使我从根本上理解了LSP，我仍然不能理解这个定义。让我们再试一次:</p><blockquote class="oe of og"><p id="ca85" class="li lj oh lk b ll lm kd ln lo lp kg lq oi ls lt lu oj lw lx ly ok ma mb mc md im bi translated">如果S是T的子类型，那么程序中T类型的对象可以用S类型的对象替换，而不会改变该程序的任何期望的属性。</p></blockquote><p id="759f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，现在好一点了。如果<code class="fe ol om on mf b">ObjectA</code>是<code class="fe ol om on mf b">ClassA</code>的一个实例，<code class="fe ol om on mf b">ObjectB</code>是<code class="fe ol om on mf b">ClassB</code>的一个实例，<code class="fe ol om on mf b">ClassB</code>是<code class="fe ol om on mf b">ClassA</code>的一个子类型——如果我们在代码的某个地方使用<code class="fe ol om on mf b">ObjectB</code>而不是<code class="fe ol om on mf b">ObjectA</code>，应用程序的功能一定不能被破坏。</p><p id="cab0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这里讨论类和继承，这是我们在Go中不认可的两个范例。不过，我们可以通过使用<strong class="lk jd">接口</strong>和<strong class="lk jd">多态</strong>来应用这个原则。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="756e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们可以看到一个代码示例。老实说，我几乎找不到比这更糟糕、更愚蠢的了。就像,<code class="fe ol om on mf b">Update</code>方法所说的，它不是更新数据库中的<code class="fe ol om on mf b">User</code>,而是删除它。</p><p id="98e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，嘿，这才是重点。我们可以看到一个界面，<code class="fe ol om on mf b">UserRepository</code>。在接口之后，我们有一个结构，<code class="fe ol om on mf b">DBUserRepository</code>。尽管这个结构实现了初始接口，但它并没有做接口声称它应该做的事情。</p><p id="bef3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它破坏了界面的功能，而不是遵循预期。这里是Go中LSP的要点:struct一定不能违背接口的目的。</p><p id="002f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们来看看不那么荒谬的例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="19d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们有了新的<code class="fe ol om on mf b">UserRepository</code>接口及其两个实现:<code class="fe ol om on mf b">DBUserRepository</code>和<code class="fe ol om on mf b">MemoryUserRepository</code>。正如我们所见，<code class="fe ol om on mf b">MemoryUserRepository</code>确实需要<code class="fe ol om on mf b">Context</code>参数，但它仍然存在以尊重接口。</p><p id="887e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">问题开始了。我们修改了<code class="fe ol om on mf b">MemoryUserRepository</code>来支持这个接口，尽管这种意图是不自然的。因此，我们可以在应用程序中切换数据源，其中一个数据源不是永久存储。</p><p id="2e92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design" rel="noopener ugc nofollow" target="_blank">存储库</a>模式的目的是表示底层永久数据存储的接口，比如数据库。它不应该扮演缓存系统的角色，就像这里我们在内存中存储<code class="fe ol om on mf b">Users</code>一样。</p><p id="ec67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时不自然的实现会对编码本身产生影响，不仅仅是语义上的。这些情况对于实现来说更加明显，也是最难解决的，因为它们需要大量的重构。</p><p id="32f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了说明这种情况，我们可以查一下<a class="ae lh" href="http://stg-tud.github.io/sedc/Lecture/ws13-14/3.3-LSP.html#mode=document" rel="noopener ugc nofollow" target="_blank">关于几何形状的著名例子</a>。这个例子的有趣之处在于它与几何学中的事实相矛盾。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="96e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们可以看到几何图形在Go中的实现。在几何上，我们可以用<a class="ae lh" href="https://en.wikipedia.org/wiki/Quadrilateral#Convex_quadrilaterals" rel="noopener ugc nofollow" target="_blank">分型</a>来比较凸四边形、矩形、长方形、正方形。</p><p id="26a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们把它移到Go代码中来实现面积计算的逻辑，我们可能会得到与上面类似的结果。在顶部，我们有一个接口<code class="fe ol om on mf b">ConvexQuadrilateral</code>。</p><p id="66fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个接口只定义了一个方法<code class="fe ol om on mf b">GetArea</code>。作为<code class="fe ol om on mf b">ConvexQuadrilateral</code>的子类型，我们可以定义一个接口<code class="fe ol om on mf b">Rectangle</code>。这个子类型有两个侧面涉及它的区域，所以我们必须提供<code class="fe ol om on mf b">SetA</code>和<code class="fe ol om on mf b">SetB</code>。</p><p id="6a01" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来是实际的实现。第一个是<code class="fe ol om on mf b">Oblong</code>，可以有更宽的宽度，也可以有更宽的高度。在几何学中，它是任何不是正方形的矩形。实现这个结构的逻辑很容易。</p><p id="39c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ol om on mf b">Rectangle</code>的第二个子类型是<code class="fe ol om on mf b">Square</code>。在几何学中，正方形是矩形的子类型，但是如果我们在软件开发中遵循这一点，我们只能在我们的实现中产生问题。</p><p id="d4c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正方形有四条相等的边。所以，这使得<code class="fe ol om on mf b">SetB</code>过时了。为了尊重我们最初选择的子类型，我们意识到我们的代码有过时的方法。同样的问题是如果我们选择一条稍微不同的道路:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="c217" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们引入了<code class="fe ol om on mf b">EquilateralRectangle</code>接口，而不是<code class="fe ol om on mf b">Rectangle</code>。在几何学中，那应该是一个四边都相等的矩形。</p><p id="8679" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，当我们的接口只定义了<code class="fe ol om on mf b">SetA</code>方法时，我们在实现中避免了过时的代码。尽管如此，这破坏了LSP，因为我们为<code class="fe ol om on mf b">Oblong</code>引入了一个额外的方法<code class="fe ol om on mf b">SetB</code>，没有它我们不能计算面积，即使我们的接口说我们可以。</p><p id="293e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，我们已经开始理解围棋里的里斯科夫替代原理了。因此，我们可以总结一下，如果我们打破它，可能会出现什么问题:</p><ol class=""><li id="afde" class="oq or it lk b ll lm lo lp lr os lv ot lz ou md ov ow ox oy bi translated">它为实现提供了一个错误的捷径。</li><li id="71b3" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">它会导致过时的代码。</li><li id="76eb" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">它会破坏预期的代码执行。</li><li id="580e" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">它会破坏期望的用例。</li><li id="d82c" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated">它会导致不可维护的接口结构。</li><li id="5a17" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi">…</li></ol><p id="7eb2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，我们又来了，让我们做一些重构。</p><h1 id="507e" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">我们如何尊重利斯科夫替代</h1><blockquote class="oe of og"><p id="f83a" class="li lj oh lk b ll lm kd ln lo lp kg lq oi ls lt lu oj lw lx ly ok ma mb mc md im bi translated">只有尊重接口的目的和方法，我们才能在直通接口中提供子类型。</p></blockquote><p id="9718" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将避免为我们的第一个例子添加适当的实现，因为它非常清楚——<code class="fe ol om on mf b">Update</code>方法应该更新<code class="fe ol om on mf b">User</code>而不是删除它。</p><p id="d882" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，让我们首先来解决<code class="fe ol om on mf b">UserRepository</code>接口的不同实现的问题:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="4b32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个例子中，我们将接口一分为二，有明确的目的和不同方法的签名。现在，我们有了<code class="fe ol om on mf b">UserRepository</code>接口和<code class="fe ol om on mf b">UserCache</code>接口。</p><p id="9d90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ol om on mf b">UserRepository</code>现在的目的肯定是将用户数据永久存储到某个存储中。为此，我们准备了类似<code class="fe ol om on mf b">MySQLUserRepository</code>和<code class="fe ol om on mf b">CassandraUserRepository</code>的具体实现。</p><p id="9dd9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，我们有了<code class="fe ol om on mf b">UserCache</code>接口，我们清楚地知道我们需要它来将用户数据临时保存在某个缓存中。作为具体实现，我们可以使用<code class="fe ol om on mf b">MemoryUserCache</code>。</p><p id="1a01" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们可以切换到几何示例，这里的情况稍微复杂一些:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3690" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了支持Go中几何图形的子类型化，我们应该考虑它们的所有特性，以避免不完整或过时的方法。</p><p id="8ecf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们引入了三种新的界面:<code class="fe ol om on mf b">EquilateralQuadrilateral</code>(四条边都相等的四边形)<code class="fe ol om on mf b">NonEquilateralQuadrilateral</code>(有两对等边的四边形)<code class="fe ol om on mf b">NonEquiangularQuadrilateral</code>(有两对等角的四边形)。</p><p id="5d6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些接口中的每一个都提供了提供面积计算所需数据所需的附加方法。</p><p id="a366" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以定义一个<code class="fe ol om on mf b">Square</code>，仅使用<code class="fe ol om on mf b">SetA</code>方法，<code class="fe ol om on mf b">Oblong</code>同时使用<code class="fe ol om on mf b">SetA</code>和<code class="fe ol om on mf b">SetB</code>，而<code class="fe ol om on mf b">Parallelogram</code>则全部加上<code class="fe ol om on mf b">SetAngle</code>。因此，我们在这里没有使用子类型，而是更像特征。</p><p id="10ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这两个固定的例子，我们重新构造了我们的代码，以便它总是能够满足最终用户的期望。它还删除了过时的方法，并且没有破坏其中的任何一个。代码现在是稳定的。</p><h1 id="2d03" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">结论</h1><p id="8b29" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">利斯科夫替代原理告诉我们什么是正确的亚类型化方法。即使它反映了真实世界的情况，我们也不应该强迫多态。</p><p id="be90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">LSP代表单词<em class="oh"> SOLID </em>中的字母<em class="oh"> L </em>。虽然它绑定到了Go中不支持的继承和类，但我们仍然可以将这个原则用于多态和接口。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="ea14" class="mj mk it mf b gy ml mm l mn mo">Other articles from the SOLID series:</span><span id="8917" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-single-responsibility-principle-20afb8643483"><strong class="mf jd">Practical SOLID in Golang: Single Responsability Principle</strong></a></span><span id="6035" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-open-closed-principle-1dd361565452"><strong class="mf jd">Practical SOLID in Golang: Open/Closed Principle</strong></a></span><span id="aaba" class="mj mk it mf b gy mp mm l mn mo">Some articles from the DDD series:</span><span id="f569" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1.</strong> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="def3" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="deba" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mf jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="e1cb" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mf jd">Practical DDD in Golang: Repository</strong></a></span><span id="e954" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. ...</strong></span></pre></div></div>    
</body>
</html>