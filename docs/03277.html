<html>
<head>
<title>Learning C++: Sorting Algorithms of the STL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL的排序算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-sorting-algorithms-of-the-stl-3c473a1e3143?source=collection_archive---------6-----------------------#2020-04-29">https://levelup.gitconnected.com/learning-c-sorting-algorithms-of-the-stl-3c473a1e3143?source=collection_archive---------6-----------------------#2020-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/007751cdf6814c0189ba3e1eae79a0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*odmijWLAPqcL60A1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@traxing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">苏拉娅·欧文</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="28a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标准模板库(STL)有一小组排序算法，可以用来排序容器元素。所使用的排序算法的类型是依赖于实现的，但是STL保证了<em class="le"> n-log-n </em>(良好的)性能。在本文中，我将演示如何在STL中使用各种排序算法。</p><h1 id="07e1" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">排序功能</h1><p id="672e" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">STL的基本排序功能是<code class="fe mi mj mk ml b">sort</code>。该函数获取一系列容器元素并对它们进行排序。在该函数的第一个版本中，它使用<code class="fe mi mj mk ml b">&lt;</code>操作符对元素进行排序，在第二个版本中，您可以提供一个二元谓词函数来对元素进行排序。</p><p id="4eb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是两个版本的sort的语法模板:</p><p id="7aff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> void排序(range-start，range-end)；<br/> void排序(range-start，range-end，binary-predicate-function)；</em></p><p id="0813" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示第一版<code class="fe mi mj mk ml b">sort</code>如何工作的程序:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="2449" class="mu lg it ml b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="5f50" class="mu lg it ml b gy mz mw l mx my">void buildVec(vector&lt;int&gt; &amp;vec, int n) {<br/>  for (int i = 1; i &lt;= n; i++) {<br/>    vec.push_back(rand() % 100 + 1);<br/>  }<br/>}</span><span id="9c61" class="mu lg it ml b gy mz mw l mx my">void printVec(vector&lt;int&gt; &amp;vec) {<br/>  for (const int n : vec) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="4931" class="mu lg it ml b gy mz mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  printVec(numbers);<br/>  sort(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="f675" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="6fb5" class="mu lg it ml b gy mv mw l mx my">66 19 34 94 8 53 2 46 61 30 14 65 8 19 23 95 45 42 41 34</span><span id="8c0c" class="mu lg it ml b gy mz mw l mx my">2 8 8 14 19 19 23 30 34 34 41 42 45 46 53 61 65 66 94 95</span></pre><p id="db78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，vector的元素按照升序排序，这是由<code class="fe mi mj mk ml b">&lt;</code>操作符的默认操作指定的。</p><p id="2f35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想将这些数据按降序排序，我们可以向函数传递第三个参数来改变顺序。对于这个例子，我们将使用<code class="fe mi mj mk ml b">greater&lt;&gt;()</code>函数对象。程序是这样的:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="024d" class="mu lg it ml b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  printVec(numbers);<br/>  sort(numbers.begin(), numbers.end(), greater&lt;int&gt;());<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="2dfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="41ca" class="mu lg it ml b gy mv mw l mx my">10 49 36 75 32 66 96 32 82 10 38 94 15 79 30 99 97 48 30 88</span><span id="bb31" class="mu lg it ml b gy mz mw l mx my">99 97 96 94 88 82 79 75 66 49 48 38 36 32 32 30 30 15 10 10</span></pre><p id="b764" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mi mj mk ml b">sort</code>功能有一些限制。主要的约束是，您不能在关联容器(如<code class="fe mi mj mk ml b">map</code>)或基于列表的容器(如<code class="fe mi mj mk ml b">list</code>或<code class="fe mi mj mk ml b">forward_list</code>)上使用该函数，因为这些容器类型不提供对这些容器类型中的元素进行排序所需的迭代器类型。</p><h1 id="9120" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">稳定排序函数</h1><p id="5059" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我想讨论的下一种排序是稳定排序。稳定排序是指从原始容器到排序后的容器，相等元素的相对位置保持不变。实现稳定排序的函数是<code class="fe mi mj mk ml b">stable_sort</code>函数。这个函数也可以接受一个二元谓词函数作为可选参数。以下是该函数的语法模板:</p><p id="7b49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">void stable _ sort(range-begin，range-end)；<br/>void stable _ sort(range-begin，range-end，binary-predicate-function)；</em></p><p id="7e66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个程序是一个例子，说明了<code class="fe mi mj mk ml b">stable_sort</code>函数如何保持相等元素的位置。向量包含不同长度的字符串，并且有一个比较字符串长度的函数，强制小于排序。首先，我们调用<code class="fe mi mj mk ml b">sort</code>函数:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="eae5" class="mu lg it ml b gy mv mw l mx my">// this example is taken from a similar example in the book<br/>// <em class="le">The C++ Standard Library: Second Edition</em> by Nicolai Josuttis</span><span id="fe7a" class="mu lg it ml b gy mz mw l mx my">bool length(const string &amp;s1, const string &amp;s2) {<br/>  return s1.length() &lt; s2.length();<br/>}</span><span id="14a2" class="mu lg it ml b gy mz mw l mx my">int main () {<br/>  vector&lt;string&gt; words = {"1xxx", "2x", "3x", "4x", "5xx",<br/>                          "6xxxx", "7xx", "8xxx", "9xx",<br/>                          "10xxx", "11", "12", "13", "14xx",<br/>                          "15", "16", "17"};<br/>  vector&lt;string&gt; copied(words);<br/>  sort(words.begin(), words.end(), length);<br/>  cout &lt;&lt; "Order with sort function: " &lt;&lt; endl;<br/>  printVec(words);<br/>  return 0;<br/>}</span></pre><p id="15b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="ad1b" class="mu lg it ml b gy mv mw l mx my">Order with sort function:</span><span id="c52b" class="mu lg it ml b gy mz mw l mx my">2x 17 16 15 13 12 11 4x 3x 9xx 7xx 5xx 8xxx 14xx 1xxx 10xxx 6xxxx</span></pre><p id="0eb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe mi mj mk ml b">stable_sort</code>节目:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="2c13" class="mu lg it ml b gy mv mw l mx my">bool length(const string &amp;s1, const string &amp;s2) {<br/>  return s1.length() &lt; s2.length();<br/>}</span><span id="ea92" class="mu lg it ml b gy mz mw l mx my">int main () {<br/>  vector&lt;string&gt; words = {"1xxx", "2x", "3x", "4x", "5xx",<br/>                          "6xxxx","7xx", "8xxx", "9xx", "10xxx",<br/>                          "11", "12","13", "14xx",<br/>                          "15","16","17"};<br/>  vector&lt;string&gt; copied(words);<br/>  stable_sort(words.begin(), words.end(), length);<br/>  cout &lt;&lt; "Order with stable_sort function: " &lt;&lt; endl;<br/>  printVec(words);<br/>  return 0;<br/>}</span></pre><p id="9070" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="d5f0" class="mu lg it ml b gy mv mw l mx my">Order with stable_sort function:<br/>2x 3x 4x 11 12 13 15 16 17 5xx 7xx 9xx 1xxx 8xxx 14xx 6xxxx 10xxx</span></pre><p id="44ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，stable_sort函数保留了数字开头的字符串的原始顺序，但sort函数没有保留。</p><h1 id="2b12" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">部分排序算法</h1><p id="b7b3" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我上面讨论的算法主要用于对各种元素进行排序，比如一个完整的容器。下一个函数用于执行部分排序，其中只对一个范围的指定子范围进行排序。</p><p id="1390" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">执行部分排序的功能是<code class="fe mi mj mk ml b">partial_sort</code>。它的参数是范围起点、停止部分排序的位置和整个范围的终点。<code class="fe mi mj mk ml b">partial_sort</code>的第二个版本允许一个二元谓词函数作为最终参数。</p><p id="c277" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是partial_sort的语法模板:</p><p id="49da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">void partial _ sort(range-start，partial-range-end，range-end)；<br/>void partial _ sort(range-start，partial-range-end，range-end，<br/>二元谓词函数)；</em></p><p id="d28f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序演示了第一个版本的<code class="fe mi mj mk ml b">partial_sort</code>，排序在容器中的第十个元素后停止。程序是这样的:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="18b1" class="mu lg it ml b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  printVec(numbers);<br/>  partial_sort(numbers.begin(), numbers.begin() + 10,<br/>               numbers.end());<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="dd1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="cbc1" class="mu lg it ml b gy mv mw l mx my">73 39 68 1 32 4 78 74 7 39 39 45 10 22 33 78 53 50 20 68</span><span id="e133" class="mu lg it ml b gy mz mw l mx my">1 4 7 10 20 22 32 33 39 39 78 74 73 68 45 78 53 50 39 68</span></pre><p id="aade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果仔细观察，您会发现只有vector的前十个元素按照函数调用中的指定进行了排序。</p><p id="3aeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，它使用第二个版本的<code class="fe mi mj mk ml b">partial_sort</code>将向量的前半部分按降序排序:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="33ad" class="mu lg it ml b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  printVec(numbers);<br/>  partial_sort(numbers.begin(), numbers.begin() + 10,<br/>               numbers.end(), greater&lt;int&gt;());<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="6e97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8199" class="mu lg it ml b gy mv mw l mx my">33 61 50 27 24 71 1 88 12 13 30 75 47 44 34 97 100 93 77 91</span><span id="745e" class="mu lg it ml b gy mz mw l mx my">100 97 93 91 88 77 75 71 61 50 1 12 13 24 27 30 33 34 44 47</span></pre><p id="cee4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个函数执行部分排序，并将排序后的元素复制到另一个容器中。这个功能叫做<code class="fe mi mj mk ml b">partial_sort_copy</code>。它还有一个重载版本，接受二元谓词函数作为最后一个参数。以下是该函数的语法模板:</p><p id="38ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">void partial _ sort _ copy(range-start，range-end，destination-range-begin，<br/>destination-range-end)；</em></p><p id="0926" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">void partial _ sort _ copy(range-start，range-end，destination-range-begin，<br/> destination-range-end，binary-predicate-function)；</em></p><p id="65fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下程序演示了如何使用第一版<code class="fe mi mj mk ml b">partial_sort_copy</code>:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="fc63" class="mu lg it ml b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  vector&lt;int&gt; partSort(20);<br/>  buildVec(numbers, 20);<br/>  printVec(numbers);<br/>  partial_sort_copy(numbers.begin(), numbers.begin() + 10,<br/>                    partSort.begin(), partSort.end());<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Showing copied elements: " &lt;&lt; endl;<br/>  printVec(partSort);<br/>  return 0;<br/>}</span></pre><p id="f32c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="6884" class="mu lg it ml b gy mv mw l mx my">21 46 29 92 10 52 24 29 32 10 29 70 18 33 74 18 46 9 62 94</span><span id="fecc" class="mu lg it ml b gy mz mw l mx my">Showing copied elements:<br/>10 10 21 24 29 29 32 46 52 92</span></pre><p id="93ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有排序后的元素被复制到新的vector中，如输出所示。</p><h1 id="0f28" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">排序到第n个元素</h1><p id="8cf5" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">有时，您只需要看到容器中某个范围内的最高值或最低值。STL有一个函数提供这个视图:<code class="fe mi mj mk ml b">nth_element</code>。该函数的语法模板是:</p><p id="576a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">void n _ element(range-start，iterator-n-position，range-end)；<br/>void n _ element(range-start，iterator-n-position，range-end，binary- <br/>谓词-函数)；</em></p><p id="3734" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一个程序中，我将显示向量中的四个最低值:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="3336" class="mu lg it ml b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  nth_element(numbers.begin(), numbers.begin()+3,<br/>              numbers.end());<br/>  cout &lt;&lt; "The four lowest values are: " &lt;&lt; endl;<br/>  copy(numbers.begin(), numbers.begin()+4,<br/>       ostream_iterator&lt;int&gt;(cout, " "));<br/>  cout &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="e9ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c259" class="mu lg it ml b gy mv mw l mx my">71 43 55 81 27 56 21 42 96 98 3 29 35 23 44 82 30 27 87 21</span><span id="a0af" class="mu lg it ml b gy mz mw l mx my">The four lowest values are:<br/>21 3 21 23</span></pre><h1 id="a6c0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">堆算法</h1><p id="995c" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我将在本文中讨论的最后一组算法是堆算法。堆是一种数据结构，它有几个属性，这些属性对于存储排序后的数据很有用。介绍堆的细节超出了本文的范围，但是您可以在这里了解更多关于堆的内容。</p><p id="367a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆算法包含四个函数:</p><p id="d296" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mi mj mk ml b">make_heap</code>:将一定范围的元素转换成堆。<br/> <code class="fe mi mj mk ml b">push_heap</code>:将一个元素添加到一个堆中。<br/> <code class="fe mi mj mk ml b">pop_heap</code>:从堆中移除下一个元素。<br/> <code class="fe mi mj mk ml b">sort_heap</code>:将一个堆转换成一个排序的集合。</p><p id="94d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将只提供一个程序来演示这些函数的主要版本是如何工作的，而不是涵盖这些函数的语法模板。程序是这样的:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c9a1" class="mu lg it ml b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers = {4,1,2,18,9,6,11};<br/>  cout &lt;&lt; "The vector before make_heap: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  make_heap(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "After make_heap: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  numbers.push_back(15);<br/>  push_heap(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "After push_heap: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  pop_heap(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "After pop_heap: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  sort_heap(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "After sort_heap: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="4c9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="beea" class="mu lg it ml b gy mv mw l mx my">The vector before make_heap:<br/>4 1 2 18 9 6 11</span><span id="d2fe" class="mu lg it ml b gy mz mw l mx my">After make_heap:<br/>18 9 11 1 4 6 2</span><span id="3488" class="mu lg it ml b gy mz mw l mx my">After push_heap:<br/>18 15 11 9 4 6 2 1</span><span id="b9c0" class="mu lg it ml b gy mz mw l mx my">After pop_heap:<br/>15 9 11 1 4 6 2 18</span><span id="8a04" class="mu lg it ml b gy mz mw l mx my">After sort_heap:<br/>1 2 4 6 9 11 18 15</span></pre><p id="4c93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会注意到，在调用<code class="fe mi mj mk ml b"> sort_heap</code>函数后，数据没有完全排序。我不会将这些函数用于您的排序目的，但我将它们涵盖在内以使其完整。</p><h1 id="2595" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">接下来—排序范围算法</h1><p id="a07d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在我的下一篇文章中，我将介绍一组算法，您可以对已经排序的数据使用这些算法。这些算法中最著名的是二分搜索法，但也有其他算法。</p><p id="9d71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>