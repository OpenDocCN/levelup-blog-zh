<html>
<head>
<title>How Many Repositories Do You Need for a Microservices Project?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个微服务项目需要多少个存储库？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-many-repositories-do-you-need-for-a-microservices-project-b5c991aa440?source=collection_archive---------0-----------------------#2021-08-28">https://levelup.gitconnected.com/how-many-repositories-do-you-need-for-a-microservices-project-b5c991aa440?source=collection_archive---------0-----------------------#2021-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b696" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在多存储库和单存储库之间找到平衡点。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd77d7f0cd195d275c58cce449e9af17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MKrd4ziip1pQorev"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为一个整体项目选择存储库数量的规则通常非常简单——将整个代码库放在一个存储库中，就这样。</p><p id="292b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，随着项目的增长，开发人员可能会决定将整体项目拆分为微服务。选择存储库的数量变得有点困难。开发人员需要回答他们在处理整体项目时从未遇到过的问题:</p><p id="01c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">我应该把每个微服务放在一个单独的存储库中，还是应该把它们都放在同一个存储库中，但是放在不同的模块/文件夹中？</em></p><p id="dae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在单存储库和多存储库之间进行选择时，有什么规则、指南或最佳实践可以遵循吗？</p><p id="cc33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望能帮助你回答这两个问题以及其他一些问题，所以让我们开始吧。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5eb3" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">多储存库方法</h1><p id="9329" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">也许微服务项目最明显的策略是将每个微服务和每个共享库放入一个单独的存储库中。然后为每个存储库设置CI和CD管道，其中每个存储库代表一个部署单元。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/bdea1d72a46b463c864081d0698ce366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*Xhr0RZEaUKt7PTViiBDG4g.png"/></div></figure><p id="9384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序组件的这种分离为我们带来了许多优势:</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="2d26" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">快速IDE</h2><p id="7e62" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">one解决方案中的代码库越大，您喜欢的IDE需要的计算机资源就越多，这会影响您的性能。</p><p id="9b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员在IDE中执行的最常见操作如下:</p><ul class=""><li id="2b9b" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">打开解决方案。</li><li id="f39c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">构建解决方案。</li><li id="c53c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">执行自动重构。</li><li id="2df7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">在类和方法之间导航。</li></ul><p id="b98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于小型分解解决方案，所有这些和其他操作的运行速度要比大型整体解决方案快得多。</p><h2 id="3001" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">快速Git</h2><p id="454c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Git等版本控制系统在处理小型回购时比处理大型回购时运行得更快。</p><p id="106e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像git pull、git fetch、git check out、git clone、git status等命令对于小型存储库来说会更快，使得在一个存储库中进行本地开发更加方便。</p><h2 id="8e94" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">明确的职责划分</h2><p id="7354" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">存储库是严格而清晰的边界，将应用程序的整个代码库分隔开来。很容易为每个存储库分配一个负责团队，并跟踪谁负责什么。</p><p id="b0db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他团队也需要能够使用拉请求对不属于他们的存储库进行更改。这是必要的，因为拥有存储库的团队可能会被工作淹没，所以其他不太忙的团队可以帮助他们做出一些改变。</p><p id="c0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<strong class="lb iu">只有拥有存储库的团队才被允许批准拉请求</strong>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="ea52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，多存储库方法有几个缺点:</p><h2 id="9637" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">复杂的开发生命周期</h2><p id="c35d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">除非开发人员实现一个跨越多个存储库的特性，否则开发生命周期很简单。</p><p id="cf44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，开发人员需要在多个不同的存储库中进行更改。不同的团队应该花时间在沟通上以就合同达成一致，谁应该首先实现和部署变更等等。</p><h2 id="7629" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">代码复制</h2><p id="a072" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">开发团队可以开始独立地在他们的存储库中实现相同或相似的功能。这种问题通常是由于团队之间沟通不畅或不充分造成的。跟踪不同存储库中的重复代码是很困难的。</p><p id="bbfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码的重复可以通过将公共逻辑移动到共享库中来解决，共享库的代码放在单独的存储库中。</p><p id="9522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<strong class="lb iu">管理共享库</strong>有它的缺点:</p><ul class=""><li id="b551" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">开发人员在更新共享库的公共API时必须非常小心，以避免中断更改。</li><li id="70d1" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">发布新版本的库需要在所有使用它的存储库中进行版本更新。</li><li id="21eb" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">从使用共享库代码的服务中调试它是很困难的。</li></ul><h2 id="1a5b" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">难以实施系统一致性</h2><p id="8329" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当不同的团队在不同的存储库中工作时，很难保持整个系统处于一致的状态:</p><ul class=""><li id="bd4a" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">服务使用不同的框架。</li><li id="146e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">服务使用不同版本的库。</li><li id="139e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">服务使用不同的设计模式、方法和最佳实践。</li></ul><p id="0af0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当团队之间建立良好的关系时，这个问题通常不会发生。然而，当团队主要实现与其他存储库和团队隔离的特性时，交流就会受到影响。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5692" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">单一知识库方法</h1><p id="dc6f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在开始讨论单一存储库的优点和缺点之前，消除一个常见的误解很重要:</p><blockquote class="ob"><p id="29eb" class="oc od it bd oe of og oh oi oj ok lu dk translated">单一存储库并不意味着一个单一的项目。</p></blockquote><p id="09f0" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">具有微服务架构的项目可以驻留在单个解决方案的单个存储库中。每个微服务都可以存在于自己的模块中。每个模块可以有自己的单元测试、复合根、CI和CD管道，如果需要，可以独立地构建、部署和扩展。</p><p id="bad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有微服务放在一个解决方案中的一大优势是，它们可以直接引用共享库，因为一切都在一个解决方案中。共享库不再需要拥有自己的CI/CD管道，这可以大大简化开发生命周期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/d2f6babb871e7f930f08df963d75c643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*RZz75EiIbZZoxCSM00Nm3g.png"/></div></figure><p id="8642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">在。NET中，模块是一个类库项目。这个很酷的</em> <a class="ae ky" href="https://github.com/kgrzybek/modular-monolith-with-ddd" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> GitHub库</em> </a> <em class="lv">描述了如何尽可能模块化地构建你的应用。</em></p><p id="24dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当共享库的公共API发生变化时，开发人员要检测到重大变化所要做的就是构建解决方案并检查构建错误。</p><p id="0f2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单一存储库的几个优点:</p><ul class=""><li id="0a34" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">确保在整个项目代码库中使用相同的模式、框架、库版本和代码风格变得很容易。所有团队都会知道对存储库做了什么更改，因为GitHub上有一个地方可以跟踪对一个存储库的请求。单一存储库改善团队协作。</li><li id="5ef2" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当开发人员需要修改多个存储库的代码时，开发人员总是需要运行唯一的IDE实例来简化开发过程。此外，单个IDE实例简化了新开发人员的入职流程。</li><li id="263b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">在单个解决方案中跟踪代码重复和其他指标很容易，这提高了应用程序的整体质量。</li></ul><p id="fb64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是没有什么是免费的，所以单一存储库有它们的缺点:</p><ul class=""><li id="6d26" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">在多存储库方法中，每个存储库都是一个独立的部署单元(每个存储库都有自己的CI / CD管道)。然而，对于单一存储库，很容易错误地绕过独立部署的原则，一次部署整个系统。这导致了传统整体应用程序中固有的一个问题:一个小的代码更改需要重新部署整个系统。</li><li id="5dc8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">对于大型的单一解决方案，IDE和Git命令的性能会较慢。</li><li id="c6ee" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当许多团队在同一个存储库中工作时，合并冲突的可能性更高。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="352e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">“中庸”方法</h1><p id="75b2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">到目前为止，我们已经讨论了两种对立的方法:应用程序组件的最大分离和不分离。但是通常两者之间的平衡可能是最好的:一些与<strong class="lb iu">相关的</strong>服务和共享库可以被分组并推到一个存储库中，而其他服务可能仍然在单独的存储库中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/aa1640aa245530200fdf60cf43c955a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*NUuNLnYYd7QiIUFY512Ykg.png"/></div></figure><p id="c3e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何理解哪些相关的服务被分组到一个存储库中？以下是一些想法:</p><ul class=""><li id="6919" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">如果只有少数几个小服务使用一个或几个共享库，那么将它们全部放在同一个存储库中会更容易管理共享依赖关系。</li><li id="018c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果经常为开发人员实现的几乎每个功能一起修改多个服务，那么将这些服务放在同一个存储库中，甚至将它们作为一个单元一起部署是有意义的。</li><li id="3689" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果服务代码库很大，可以将其转移到单独的存储库中，以提高IDE和Git的性能。</li></ul><p id="1832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将相关的服务和共享库放入同一个存储库中，并将它们作为一个整体进行部署，这可以极大地简化开发生命周期，并避免破坏性的更改。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0fb0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="6ee6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们讨论了很多，现在是时候以具体提示的形式进行总结了:</p><ul class=""><li id="5c7d" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">大型单一存储库最好由每个微服务或一组相关的微服务分割成较小的存储库，以提高IDE和Git命令的性能。</li><li id="1dc5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">经常一起修改的服务和共享库可以驻留在同一个存储库中，甚至有一个CI / CD管道。</li><li id="81c8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当一个团队负责位于不同存储库中的多个服务时，它们可以被合并到一个存储库中。</li><li id="98a6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当对项目的未来有很大的疑虑时，从单一存储库中的模块化、整体式应用程序开始。以后，如果项目增长，可以很容易地将它分割成单独的存储库。</li><li id="4350" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">最好坚持团队中有大量初级开发人员的单一存储库方法，因为这种方法很简单。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="6d4a" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">我的其他文章</h2><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/developers-shouldnt-be-afraid-of-deadlocks-in-sql-server-8f8f4578675f"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">开发人员不应该害怕SQL Server中的死锁</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">后端开发人员处理死锁的策略。</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/why-is-list-struct-is-15-times-faster-to-allocate-than-list-class-17f5f79889ae"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">为什么C#中List <struct>的分配速度比List <class>快15倍</class></struct></h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">在上一篇文章《免费提高C#代码性能的5种方法》中，在其中一个例子中，我测量了…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj ks ov"/></div></div></a></div><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/50-software-engineering-best-practices-for-technical-leaders-and-seniors-cfcdf6a17e44"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">面向技术领导者和资深人士的50个软件工程最佳实践</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">最佳工程师的最佳实践。</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pe l"><div class="pl l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>