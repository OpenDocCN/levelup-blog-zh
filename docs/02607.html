<html>
<head>
<title>My foo.bar Experience</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的foo.bar经历</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-foo-bar-experience-ac7a5caf867a?source=collection_archive---------2-----------------------#2020-03-25">https://levelup.gitconnected.com/my-foo-bar-experience-ac7a5caf867a?source=collection_archive---------2-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1845" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">边注:</em> </strong>是的，我知道这不是通常的举例子博文。今天我想分享一些不同的东西，一些基于我经历的东西。</p><p id="0fe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在你像我一样兴奋之前，我必须说我没能完成挑战。我失望了吗？呃，当然。我后悔花时间尝试了吗？呃，当然没有。</p><p id="e20b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">那么，这个foo.bar挑战是什么？</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/01fbb610a9fda4bf9cbd2b57c4126c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8p6LZoeQpE-B0PfXelsx7g.png"/></div></div></figure><p id="3d19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我第一次听说这件事大概是2年前，当时我还在上大学。当时我正在准备我的技术编码面试，并听说了这个神秘的谷歌挑战，它在网上流传，你只能根据你的谷歌搜索被邀请参加。我记得当时在想，<em class="ko">“哦，天哪，现在我必须在我的邀请列表中添加我想收到的邀请了”</em>:</p><ol class=""><li id="e334" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">我的霍格沃茨信</li><li id="7fe1" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">这个foo.bar挑战</li></ol><p id="d023" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有什么比邀请我去foo.bar更好的方式来结束我在周六晚上的新冠肺炎隔离自我隔离派对的第一周呢。我立即给我的朋友发了消息，告诉她我刚刚收到了一个酒吧的邀请，我非常兴奋能参加。现在回想起来，我意识到收到你朋友的信息是多么令人困惑，他一直生动地告诉每个人呆在家里以保持安全，他们周六晚上要去酒吧，因为他们收到了邀请，但无论如何…</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="f9e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">挑战一:太阳能电池板</p><p id="75ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些问题的措辞相当“古怪”，而我在任何方面都不“古怪”，所以不得不整理这些“古怪的东西”有点烦人。最终，我解决了给定一片太阳能电池板金属(一个区域)的问题，找出所有太阳能电池板正方形(正方形)的面积总和。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lw"><img src="../Images/129023ae315dc6462d323bc3031772e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTTWl9iEvabhl_aIe71N8A.png"/></div></div></figure><p id="2bfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以他们给我的例子是，如果总面积= 12，找出可以组成12的正方形，本质上是[9，1，1，1]。</p><p id="b6df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个挑战不算太糟。一旦你发现你可以递归地求总面积数的平方根，去掉浮点小数点后的所有内容，取结果的平方，从总面积数中减去它，然后递归地调用函数，使用<em class="ko">那个</em>作为你新的总面积数。</p><p id="a87f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">让我们看一下这个例子:</strong></p><ol class=""><li id="47eb" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">12的平方根= 3.46410161514</li><li id="6686" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">去掉浮点运算，这样3.14就变成了3。48664.66666866661</li><li id="d372" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><strong class="js iu"><em class="ko">3的平方= 9 </em> </strong></li><li id="a19f" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">找出新的总面积，即12–9 = 3</li><li id="e648" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">3的平方根= 1.73205080757</li><li id="0bd9" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">去掉浮点的东西，这样1就变成了1。58657 . 66867686671</li><li id="6a59" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><strong class="js iu"><em class="ko">1的平方= 1 </em> </strong></li><li id="9e2d" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">找出新的总面积，即3–1 = 2</li><li id="bef7" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">2的平方根= 1.41421356237</li><li id="caa5" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">去掉浮点的东西，这样1就变成了1。54667 . 36668666661</li><li id="e7b8" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><strong class="js iu"><em class="ko">1的平方= 1 </em> </strong></li><li id="7944" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">找出新的总面积，即2–1 = 1</li><li id="f2dc" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><strong class="js iu"><em class="ko">1的平方= 1 </em> </strong></li><li id="476f" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">没有要删除的浮点</li><li id="4d74" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">找出1–1 = 0的新总面积</li><li id="79ec" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">哦，我忘了说基本情况是新的总面积小于1。</li><li id="4fac" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">所以0 &lt; 1 and we stop the recursive calls.</li></ol><p id="9145" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">我们返回9，1，1和1的所有方块。</em> </strong></p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="27d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">挑战二:</strong>棋盘上的骑士</p><p id="575b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个问题大概花了我一个小时来解决(我有48个小时来解决)，所以你可能知道，当我开始挑战第二个问题时，我变得有点自大。对于这个问题，我有72小时来解决。我通读了一遍，决定我有足够的时间来解决它，所以我去睡觉了。</p><p id="31ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个挑战结果是比看起来更痛苦。也是我浪费太多时间最后被踢出挑战的那一次。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lx"><img src="../Images/d48e1835955d2aec13720f3f4b0a5b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IH-k5P6ivSU2Z9z4pwJAdA.png"/></div></div></figure><p id="d217" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以基本上，我们得到一个棋盘，每个格子从0到63编号。注意是8×8的棋盘。</p><p id="f8a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果你熟悉国际象棋游戏，你可能会同意我说的<a class="ae ly" href="https://en.wikipedia.org/wiki/Knight_(chess)" rel="noopener ugc nofollow" target="_blank">骑士</a>棋子处于劣势，也是最难跟踪的棋子。正因为如此，它也是国际象棋中我最喜欢的棋子。</p><p id="76a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题本质上是，给定一个源单元格和一个目的单元格，并且您只能进行“骑士”移动，返回从源单元格到目的单元格所需的最少骑士移动次数。</p><p id="1f62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我举的两个例子是:</strong></p><ol class=""><li id="e86d" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">源= 19，目的= 36 -&gt;最小移动= 1</li><li id="ea74" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">源= 0，目的地= 1 -&gt;最小移动次数= 3</li></ol><p id="7f7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个案例很简单，因为36岁属于19岁的“骑士区”:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lz"><img src="../Images/6766f64f17107d768a59c259a9ac8884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xovzy1TwP-tmw7VTsfQ3pQ.png"/></div></div></figure><p id="8ac1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个案例让我真正思考。老实说，我在解决问题后找到了案例2 <strong class="js iu">的解决方案，而不是手动遍历所有可能的场景。让我告诉你为什么…</strong></p><p id="fd7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们从0开始骑士。这给了我们两个可能的行动。我们可以去10号或17号牢房:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ma"><img src="../Images/8bfb11d837d7a828efe4fc2e979e807c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtAIGYyRD4hR9q-IirLGZQ.png"/></div></div></figure><p id="eb02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们选择哪个单元格？</p><p id="9955" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们去了10号牢房，我们之后可能会采取以下行动:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mb"><img src="../Images/b451108b697bf3600e8ae0fc446c08d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrh6YlKzUMlAYMr_Bc3dcw.png"/></div></div></figure><p id="4829" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们去17号牢房，这些是我们之后可能采取的行动:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mc"><img src="../Images/dd28fc36f898d741465a75ff5d0f69c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YL85R7yOHqxNjtYpfK9VkA.png"/></div></div></figure><p id="4777" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我给你答案之前，让我带你看一下我的思考过程。</p><p id="1cdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从全套可能的骑士动作开始。幸运的是，网格是有编号的，这意味着我可以用一组数字来表示这些可能的移动:[-17，-15，-10，-6，+6，+10，+15，+17]。</p><p id="80da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们再看一下19号牢房，你就会明白我是如何得出这个结论的:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lz"><img src="../Images/6766f64f17107d768a59c259a9ac8884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xovzy1TwP-tmw7VTsfQ3pQ.png"/></div></div></figure><ul class=""><li id="1264" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn md lh li lj bi">19–17 = 2</li><li id="9bf9" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi">19–15 = 4</li><li id="1019" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi">19–10 = 9</li><li id="0e94" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi">19–6 = 13</li><li id="6e42" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi">19+6 = 25</li><li id="8a52" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi">19+10 = 29</li><li id="bb75" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi">19+15 = 34</li><li id="07c9" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi">19+17= 36</li></ul><p id="d019" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为19号格子处于完美的位置，可以做出所有可能的全套骑士走法，所以我可以算出[-17，-15，-10，-6，+6，+10，+15，+17]。</p><p id="f028" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是对于0号单元格，它不能完成所有的移动，因为它离网格的边界太近了。</p><p id="8a04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我想创建一个边界框来搜索所有可能的值，并丢弃“不可能”的值。</p><p id="1074" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">一个边界框？</strong></p><p id="2238" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，完全正确。一个边界框，但你可以随便叫它什么。我的“边界框”背后的想法是建立一组<strong class="js iu">实际可能值</strong>，我可以从我的<strong class="js iu">全套可能值</strong>中选择。</p><p id="661f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们再来看一下10号单元格:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mb"><img src="../Images/b451108b697bf3600e8ae0fc446c08d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrh6YlKzUMlAYMr_Bc3dcw.png"/></div></div></figure><p id="01b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用[-17，-15，-10，-6，+6，+10，+15，+17]来计算<strong class="js iu">可能值的完整集合，我们得到:</strong></p><ul class=""><li id="9f11" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn md lh li lj bi">[10–17, 10–15, 10–10, 10–6, 10+6, 10+10, 10+15, 10+17]</li><li id="9d80" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi">[-7, -5, 0, 4, 16, 20, 25, 27]</li></ul><p id="c4c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们知道值-7和-5是不可能的。</p><p id="49ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么？</strong></p><p id="b260" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为它们已经出界了。因此，我称它为我的“边界盒”。</p><p id="f9f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">那么我们如何弄清楚这个“边界框”呢？</strong></p><p id="75dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">啊，我很高兴你想知道，因为我花了一段时间思考这个问题。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi me"><img src="../Images/8c985116859ad4f82762ba3f30642e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s53_9Kjd3-ZxGkwCxowjIA.png"/></div></div></figure><p id="2f9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以我们的最佳情况为例，单元格19，我们知道这个边界框的最大尺寸可能是5x5的框，因为可能的骑士移动将总是在单元格左侧2列，单元格右侧2列，单元格上方2行，单元格下方2行。</p><p id="abb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用边界框，我们可以将搜索空间缩小到:</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mf"><img src="../Images/2a60d4c97b4a8dbf8306b87b78040aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5e2cbQtaDEif9k4tgHDRg.png"/></div></div></figure><p id="a203" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了算出左上角单元格的坐标，我算出了以下内容:</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="d732" class="ml mm it mh b gy mn mo l mp mq">int[] topLeft = new int[2];</span><span id="7ecd" class="ml mm it mh b gy mr mo l mp mq">if((row-2)&gt;=0){<br/>    if((column-2)&gt;=0){<br/>        // (r-2),(c-2) = top-left<br/>        topLeft[0] = row-2;<br/>        topLeft[1] = column-2;<br/>    }<br/>    else{<br/>        // (r-2),(c) = top-left<br/>        topLeft[0] = row-2;<br/>        topLeft[1] = column;<br/>    }<br/>}<br/>else{<br/>        if((column-2)&gt;=0){<br/>           // (r),(c-2) = top-left<br/>           topLeft[0] = row;<br/>           topLeft[1] = column-2;<br/>        }<br/>        else{<br/>           // (r),(c) = top-left<br/>           topLeft[0] = row;<br/>           topLeft[1] = column;<br/>        }<br/>}</span></pre><p id="fff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在最好的情况下，从单元格19到单元格1(因为它是左上角的单元格)，我只需向左移动2列(c-2)并向上移动2行(r-2)，其中:</p><ul class=""><li id="8b22" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn md lh li lj bi translated">c =当前单元格列</li><li id="8be9" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi translated">r =当前单元格行</li></ul><p id="bcda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，假设我们在单元0(不是最佳情况)，那么边界框实际上要小得多:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ms"><img src="../Images/f1356fa6f0310ef1b1e6c21387eb8307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUSzSFMJP-Ebbbt7zrzxGw.png"/></div></div></figure><p id="c93a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它只是一个3x3的盒子，因为其他可能的值都“出界”了。</p><p id="3544" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在单元格0中，如果我们向左移动2列，我们会到达不存在的列-2。类似地，如果我们向上移动2行，我们会到达同样不存在的第2行。因此，单元格0的左上角边界框最合理的坐标值实际上是单元格0本身在(r = 0，c = 0)或(0，0)。</p><p id="56d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果行或列超出界限，我们应用相同的逻辑，这意味着左上角的其他合理坐标值是(r-2，c)和(r，c-2)。</p><p id="301e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，左上角可能的坐标值是:</p><ul class=""><li id="8ea2" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn md lh li lj bi translated">r-2，c-2</li><li id="c998" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi translated">r-2，c</li><li id="e41a" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi translated">r，c-2</li><li id="ff5a" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi translated">r、c</li></ul><p id="105d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果我们将此逻辑应用于所有其他角，右上角、左下角和右下角，我们将得到以下代码:</p><pre class="kq kr ks kt gt mg mh mi mj aw mk bi"><span id="6c33" class="ml mm it mh b gy mn mo l mp mq">int[] topLeft = new int[2];<br/>int[] topRight = new int[2];<br/>int[] bottomLeft = new int[2];<br/>int[] bottomRight = new int[2];<br/>        <br/>        // TOP:<br/>        if((row-2)&gt;=0){<br/>            if((column-2)&gt;=0){<br/>                // (r-2),(c-2) = top-left<br/>                topLeft[0] = row-2;<br/>                topLeft[1] = column-2;<br/>            }<br/>            else{<br/>                // (r-2),(c) = top-left<br/>                topLeft[0] = row-2;<br/>                topLeft[1] = column;<br/>            }<br/>            if((column+2)&lt;8){<br/>                // (r-2),(c+2) = top-right <br/>                topRight[0] = row-2;<br/>                topRight[1] = column+2;<br/>            }<br/>            else{<br/>                // (r-2),(c) = top-right<br/>                topRight[0] = row-2;<br/>                topRight[1] = column;<br/>            }<br/>        }<br/>        else{<br/>            if((column-2)&gt;=0){<br/>                // (r),(c-2) = top-left<br/>                topLeft[0] = row;<br/>                topLeft[1] = column-2;<br/>            }<br/>            else{<br/>                // (r),(c) = top-left<br/>                topLeft[0] = row;<br/>                topLeft[1] = column;<br/>            }<br/>            if((column+2)&lt;8){<br/>                // (r),(c+2) = top-right<br/>                topRight[0] = row;<br/>                topRight[1] = column+2;<br/>            }<br/>            else{<br/>                // (r),(c) = top-right<br/>                // int topRight = chessboard[row][column];<br/>                topRight[0] = row;<br/>                topRight[1] = column;<br/>            }<br/>        }</span><span id="e5f5" class="ml mm it mh b gy mr mo l mp mq">        // BOTTOM: <br/>        if((row+2)&lt;8){<br/>            if((column-2)&gt;=0){<br/>                // (r+2),(c-2) = bottom-left<br/>                bottomLeft[0] = row+2;<br/>                bottomLeft[1] = column-2;<br/>            }<br/>            else{<br/>                // (r+2),(c) = bottom-left<br/>                bottomLeft[0] = row+2;<br/>                bottomLeft[1] = column;<br/>            }<br/>            if((column+2)&lt;8){<br/>                // (r+2),(c+2) = bottom-right<br/>                bottomRight[0] = row+2;<br/>                bottomRight[1] = column+2;<br/>            }<br/>            else{<br/>                // (r+2),(c) = bottom-right<br/>                bottomRight[0] = row+2;<br/>                bottomRight[1] = column;<br/>            }<br/>        }<br/>        else{<br/>            if((column-2)&gt;=0){<br/>                // (r),(c-2) = bottom-left<br/>                bottomLeft[0] = row;<br/>                bottomLeft[1] = column-2;<br/>            }<br/>            else{<br/>                // (r),(c) = bottom-left<br/>                bottomLeft[0] = row;<br/>                bottomLeft[1] = column;<br/>            }<br/>            if((column+2)&lt;8){<br/>                // (r),(c+2) = bottom-right<br/>                bottomRight[0] = row;<br/>                bottomRight[1] = column+2;<br/>            }<br/>            else{<br/>                // (r),(c) = bottom-right<br/>                bottomRight[0] = row;<br/>                bottomRight[1] = column;<br/>            }<br/>        }</span></pre><p id="a17f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">*原谅格式不良的缩进。</p><p id="44db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了左上、右上、左下和右下边界框的坐标，我们只需遍历并找出边界框中的所有值。那就是:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/bc5086ad63291aa4d0040e2590c9428e.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*QdrKUFJUsqXIeNBHIZI7EQ.png"/></div></figure><p id="0bf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们处理的是单元格0，那么边界框中的所有值都将是[0，1，2，8，9，10，16，17，18]。</p><p id="491e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们就有了完整的可能值和一组实际的可能值。</p><ul class=""><li id="411d" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn md lh li lj bi translated"><strong class="js iu">全套:</strong> [-17，-15，-10，-6，6，10，15，17]</li><li id="7943" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn md lh li lj bi translated"><strong class="js iu">实际设置:</strong>【0，1，2，8，9，10，16，17，18】</li></ul><p id="bb30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们只需找到重叠的值，即10和17。</p><p id="6b00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们这里有什么？</strong></p><p id="e735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没错，一个骑士从0号格移动到下两个可能的格。</p><p id="1744" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们重复这个过程，直到找到目标单元(这是递归部分)。我们可以通过做一点记忆来优化它，以确保我们已经检查过的单元格不会被再次检查。如果你想阅读更多关于递归和记忆化的内容，你可以在这里参考<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/explain-by-example-dynamic-programming-776ac2839d8a">我的动态编程帖子。对我来说，诀窍是我必须计算出我需要的最少骑士步数。</a></p><p id="e085" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我能够返回它能访问的细胞:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/0fa8f437aa23d1d680f8e23001299473.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*TgOLAMqUQ44yghZIFFEKzA.png"/></div></figure><p id="a7a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是由于某种原因，我通过递归调用来跟踪它需要移动的次数的计数器没有增加，所以我就去睡觉了，错过了最后期限。</p><p id="dc3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">趁我还没忘记，我之前承诺的解决方案:</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mv"><img src="../Images/108cd49d325644a27823fbc6dee69ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1zFSLYjKa5eHVtK9UNRPA.png"/></div></div></figure><p id="14e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以如果我们走了0号单元格-&gt; 10号单元格-&gt; 16号单元格-&gt; 1号单元格，我们基本上可以通过3步从0号单元格走到1号单元格。</p><p id="b22f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">备选方案为:</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mw"><img src="../Images/64b6dbde830741749debedb2c73a7cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8gvW6bb27KI0rWmQ6seLZg.png"/></div></div></figure><p id="5992" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以从0号单元格-&gt; 17号单元格-&gt; 11号单元格-&gt; 1号单元格开始，这也是通过3步完成的。</p><p id="1563" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，仅使用骑士移动，我们需要从单元格0到单元格1的最小移动次数是3。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="0b80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，我从这次失败中学到了什么呢？</p><ol class=""><li id="fe82" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">不要骄傲/自大。</li><li id="cb6a" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">上床不是解决办法。</li><li id="31fb" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">有更好的时间管理技巧。</li><li id="fcef" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">做一些研究，先去看看别人的经验。这本实际上相当不错，作者设法完成了所有5关。</li><li id="24d7" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">不要放弃。</li></ol><p id="cc20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使我没有完成挑战，我也不气馁再试一次(如果我足够幸运再次被邀请的话)。让我第一次爱上编程的不是代码，而是思考一个问题并解决它的能力。我总是告诉人们，编码是容易的部分，解决问题才是难的部分。但是困难的事情也是有趣的事情，所以继续挑战自己，继续享受乐趣吧！</p><p id="beaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道总有更好、更优化的方法来做事。我上面讨论的解决方案是我对如何解决这两个问题的思考过程，但是如果你有更好更优化的解决方案，<strong class="js iu">请</strong>告诉我！</p></div></div>    
</body>
</html>