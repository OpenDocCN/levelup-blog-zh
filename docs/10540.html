<html>
<head>
<title>The better way to debug your code in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中调试代码的更好方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-better-way-to-debug-your-code-in-flutter-a53df472bc8?source=collection_archive---------7-----------------------#2021-12-19">https://levelup.gitconnected.com/the-better-way-to-debug-your-code-in-flutter-a53df472bc8?source=collection_archive---------7-----------------------#2021-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0330da6947faf61d60cef2c1092ca029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uY-7pxg-At-k9tgkM1Ehwg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</figcaption></figure><p id="52a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有没有试过用VS代码调试器调试Flutter中的代码？如果是，那你就知道调试有多痛苦多困难，如果不是，那我来告诉你。当你试图一行一行地调试你的代码时，调试器有时倾向于调用Flutter SDK提供的方法/函数并执行它们。当然，这不是一个bug，而是任何调试器都会做的正常事情，因为有时您编写的代码倾向于调用用Flutter SDK编写的方法/函数来完成程序的执行。但是调试每一行你没有写的和你不知道的代码有时会很麻烦和浪费时间。想象一个场景，你写了一个方法<strong class="ke ir"> A </strong>调用写在Flutter SDK某处的方法<strong class="ke ir"> B </strong>，方法<strong class="ke ir"> B </strong>调用写在Flutter SDK某处的方法<strong class="ke ir"> C </strong>，然后方法<strong class="ke ir"> C </strong>返回帮助你的方法<strong class="ke ir"> A </strong>执行的东西。现在，想象你有一棵很深的树。<em class="la">是不是很忙乱？不是很费时间吗？在这种情况下，你会怎么做？</em></p><p id="09c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我见过的大多数开发人员试图通过不使用调试器来解决这个问题，他们倾向于使用<strong class="ke ir"><em class="la">【print()</em></strong>函数，以便他们了解函数或方法的执行情况。现在，我假设你使用的是flutter 2.5版本，默认情况下它带有包含Flutter规则集的<strong class="ke ir"> flutter_lints </strong>包，Flutter团队鼓励你在Flutter应用、包和插件中使用这些规则集。这个插件在你写的时候分析代码，当你使用<strong class="ke ir"> <em class="la"> print() </em> </strong>函数时，它显示一个警告<strong class="ke ir">“避免在生产代码中‘打印’调用”</strong>。现在，这可能看起来没问题，直到您在生产中使用它时忘记删除<strong class="ke ir"> <em class="la"> print() </em> </strong>。对此的快速解决方法是使用<strong class="ke ir"><em class="la">debug print()</em></strong><em class="la"/>方法。我试图使用这种方法，但不知何故，有时它会向我显示错误<strong class="ke ir">“方法<em class="la"> debugPrint() </em>未定义”</strong>我的意思是它默认由Dart SDK提供，它不应该向我显示此错误，但请相信我，它确实显示了此错误，我一次又一次地编写它，因此错误消失了。</p><p id="6dc2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我找到了解决所有这些问题的替代方案，事实上是以一种更好的方式。在我文章的剩余部分，我将向您介绍一个名为<a class="ae lb" href="https://pub.dev/packages/logger" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> logger </strong> </a> <strong class="ke ir">的包。</strong></p><h1 id="27a8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是记录器？</h1><p id="0ae4" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">小，易于使用，可扩展的记录打印美丽的日志。<br/>灵感来自安卓版<a class="ae lb" href="https://github.com/orhanobut/logger" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> logger </strong> </a>。简单，容易。现在，如何使用它？</p><h1 id="82f6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">如何使用logger？</h1><p id="5970" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">要使用logger，您必须实例化<strong class="ke ir"> <em class="la"> Logger </em> </strong>类。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="72f7" class="mo ld iq mk b gy mp mq l mr ms">final logger = Logger();</span></pre><p id="d989" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是您可以使用的方法:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0372" class="mo ld iq mk b gy mp mq l mr ms">logger.v("[VERBOSE] You don't always want to see all of these")<br/>logger.d("[DEBUGGING] Logs a debug message")<br/>logger.i("[INFORMATION] A method is called")<br/>logger.w("[WARNING] This might become a problem")<br/>logger.e("[ERROR] You got me 👀")<br/>logger.wtf("What a terrible failure log");</span></pre><h1 id="78dc" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么我推荐你使用记录器</h1><p id="b922" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">要仅显示特定的日志级别，您可以设置:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0919" class="mo ld iq mk b gy mp mq l mr ms">Logger.level = Level.warning;</span></pre><p id="c656" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面一行隐藏了详细、调试和信息日志事件，因此它只显示警告级别的日志。</p><h1 id="f7b0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">您也可以自定义记录器</strong></h1><p id="71e9" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">创建记录器时，您可以传递一些选项:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6fd2" class="mo ld iq mk b gy mp mq l mr ms">final logger = Logger(<br/>  filter: null, // Use the default LogFilter (-&gt; only log in debug mode)<br/>  printer: PrettyPrinter(), // Use the PrettyPrinter to format and print log<br/>  output: null, // Use the default LogOutput (-&gt; send everything to console)<br/>);</span></pre><p id="cc65" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，当您使用上面的方法来记录日志时，它做得很好，但这里的一个问题是它显示了所有的堆栈跟踪，这是我个人不喜欢的。而且，有时，日志的输出很长。还是多定制一下吧。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1444" class="mo ld iq mk b gy mp mq l mr ms">final logger = Logger(<br/>  printer: PrettyPrinter(<br/>    methodCount: 2, // number of method calls to be displayed<br/>    errorMethodCount: 8, // number of method calls if stacktrace is provided<br/>    lineLength: 120, // width of the output<br/>    colors: true, // Colorful log messages<br/>    printEmojis: true, // Print an emoji for each log message<br/>    printTime: true // Should each log print contain a timestamp  ),<br/>);</span></pre><p id="3ae7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以使用一个接受<strong class="ke ir"><em class="la">pretty printer()</em></strong>作为参数的<strong class="ke ir"> <em class="la">打印机</em> </strong>。上面的代码通过设置<strong class="ke ir"> <em class="la">错误方法计数</em> </strong>只会显示最多8条栈迹，你也可以通过提供<strong class="ke ir"> <em class="la">线长</em> </strong>来控制输出的宽度。如果我们能有某种视觉效果来更好地理解我们的日志，这不是很好吗？我的意思是红色代表错误，黄色代表警告，蓝色代表信息。将颜色设置为true来实现这一切。区分错误、警告、信息和详细信息对我帮助很大。</p><p id="5f4a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我是那种用表情符号来表达自己的人。所以我喜欢用表情符号来表达我的代码和日志。是的，我可以用<strong class="ke ir"> logger </strong>和<strong class="ke ir"><em class="la">pretty printer</em></strong>类做到这一点，只需将<strong class="ke ir"> <em class="la"> print表情符号</em> </strong>设为true。</p><p id="397c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">flutter中的状态管理是至关重要的，有时你必须跟踪你的部件何时重建以及为什么要重建。你如何跟踪你的部件重建？通过记录小部件构建和重建的时间。通过使<strong class="ke ir"> <em class="la">打印时间</em> </strong>为真，我不仅可以知道我的方法/函数在什么时候被调用，还可以知道方法在什么时候被调用，我的状态在什么时候被更新。最棒的是它还能以毫秒显示时间。现在，我可以真正跟踪我的小部件重建，并提高我的应用程序性能。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/4259208e97f8062e9afdd0348a72990e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*mhUN_HW0KzVo421m.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:<a class="ae lb" href="https://github.com/leisim/logger" rel="noopener ugc nofollow" target="_blank">记录者</a></figcaption></figure><h1 id="ce1f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">记录的不仅仅是一个字符串！</h1><p id="74a4" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">每次记录时，没有必要总是记录一个字符串。有时您需要记录列表、地图或集合。<strong class="ke ir"> <em class="la"> print() </em> </strong>和<strong class="ke ir"> <em class="la"> debugPrint() </em> </strong>方法限制您只能使用string，因此每次您需要记录列表、映射或集合时，您都需要将这些数据结构转换为string。这个包最大的优点是你不仅可以记录字符串，还可以记录列表、映射或集合。</p><p id="c4ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后但同样重要的是，这是我个人更喜欢的代码片段，我在所有的Flutter项目中都使用了它</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3d13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我将上面的代码添加到我的<strong class="ke ir"> constants.dart </strong>文件中，这样我就可以在整个项目中的任何时候任何地方使用它。</p><h1 id="05cf" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">提示和技巧</h1><p id="b9a8" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">你写的代码越多，添加的日志越多，你在执行程序时肯定会感到困惑。您会对所有这些日志的来源感到困惑。哪个班？又是从哪种方法？</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9ea9" class="mo ld iq mk b gy mp mq l mr ms">logger.e("[ClassName] Method Name: This is how I debug!")</span></pre><p id="da93" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我个人更喜欢上面的记录方式，我在[括号]中添加消息，然后是方法名，最后是类名。这对我了解哪个方法来自哪个类很有帮助。</p><h1 id="83b7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">摘要</h1><p id="d64c" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">还有更多关于日志包的东西我没有提到，因为上面提到的东西已经足够了。更专注于代码。logger只是帮助我们使调试更容易，这样我们就可以编写更多有用的代码，而不是一个错误。我希望你喜欢我的文章。感谢阅读。</p><h1 id="39f0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">去之前</h1><p id="d96b" class="pw-post-body-paragraph kc kd iq ke b kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv me kx ky kz ij bi translated">Flutter 2.8已经发布了，我想写一篇关于它的文章。你觉得我该不该写？请在评论中分享它，或者到我的社交媒体上来。<a class="ae lb" href="https://www.linkedin.com/in/jiten-patel-jp/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">LinkedIn</strong></a><strong class="ke ir">，</strong><a class="ae lb" href="https://twitter.com/thejitenpatel" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">Twitter</strong></a><strong class="ke ir">，</strong>&amp;<a class="ae lb" href="https://www.instagram.com/thejitenpatel/" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">insta gram</strong></a></p><div class="mw mx gp gr my mz"><a rel="noopener  ugc nofollow" target="_blank" href="/the-best-way-to-handle-network-requests-in-flutter-874a606c07b6"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">在Flutter中处理网络请求的最佳方式</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">用Dio包发出HTTP请求。用拦截器处理网络请求是一种简单的方法</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jw mz"/></div></div></a></div><div class="mw mx gp gr my mz"><a href="https://medium.datadriveninvestor.com/integrating-apis-in-flutter-897cc6bf3f73" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">在Flutter中集成API</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">将Flutter中的API与状态管理集成的简单易行的方法</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="ni l"><div class="no l nk nl nm ni nn jw mz"/></div></div></a></div></div></div>    
</body>
</html>