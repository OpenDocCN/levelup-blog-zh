# 使用 TypeScript 一年后我学到的经验

> 原文：<https://levelup.gitconnected.com/lessons-ive-learned-after-a-year-of-using-typescript-1be2853ce6cf>

![](img/1d33b0210061524df3a84a2ef18a806d.png)

如题所示，我使用 TypeScript 大约一年了，我想分享一下我在这一过程中所学到的一些经验。与生活中的大多数事情一样，打字稿需要时间、耐心和经验来真正理解它有多神奇。我仍在不断学习关于 TypeScript 编译器如何工作的新知识，以及在我的代码中使用类型的更好方法。这些是我希望在使用 TypeScript 的早期就告诉自己的事情，一旦我熟悉了语法。

首先，我是一名 React 开发人员，所以我提到的许多趣闻都是在 React 上下文中讲述的，但是 TypeScript 确实适用于所有 JavaScript 代码！

# 信任编译器

当我第一次开始使用 TypeScript 时，我非常勤奋，坦率地说，我对粒度类型化热情过度。我没有让编译器做任何事情——如果定义了变量或函数，我会显式地输入它的每个方面。当然，有人可能会说这是让你熟悉 TS 的一个好方法，特别是它会承认什么，会对什么嗤之以鼻。我回头看我在 6 个月前写的`.ts`或`.tsx`文件，坦率地说，我很害怕，因为我相信我们大多数人对过去的代码都是这样。

让我举一个具体的例子，说明为什么信任编译器可以减少您必须编写的代码，同时还能给您同等程度的类型安全性。假设您有一个注册表单，用户可以在其中注册您的服务。他们只需输入一封电子邮件和一个确认密码。下面是我刚开始使用 TypeScript 时会做的事情:

事情是这样的，尽管所有的输入看起来~ *很酷* ~，但它并没有给我们作为开发者带来任何好处。这是因为 TypeScript 能够进行[类型推断](https://www.typescriptlang.org/docs/handbook/type-inference.html)，这意味着您的显式类型在很大程度上是没有意义的。现在肯定会有 TS 编译器的推理不尽人意的情况，我只是鼓励你在那之前尽你所能地利用它

您可以在不使用[接口](https://www.typescriptlang.org/docs/handbook/interfaces.html)的情况下实现与上述完全相同的类型安全:

但是请注意，React 组件道具的情况并非如此。Props 应该总是显式类型化的，因为它们是在消费组件的范围之外定义的，因此 TS 不能对它们进行任何类型推断。

# 在考虑他人的情况下定义类型

你使用 TypeScript 越多，你越会意识到它真的不适合你。我的意思是，你在 API 或应用程序的不同部分添加类型定义所花费的时间不一定只是为了你的利益。对给定代码库了解不多的其他开发人员将从支持类型定义中受益匪浅。如果一个更熟悉静态类型语言的后端开发人员(不是 Node.js dev)正在研究 JavaScript 代码库，情况尤其如此。作为一种天生的动态语言，JavaScript 可能会让那些不熟悉它的人感到厌烦，仅仅因为它缺少使用 TypeScript 时获得的类型。

# 对你的类型应用干燥的原则

如果你不熟悉**干**原理，它代表**D**on**R**EPE at**Y**yourself。这是一个应用于编写代码的概念，它反对在多个地方复制逻辑。当定义你的类型/接口时，应该应用同样的思路——即使只是一两个属性的问题。由于它的[实用程序类型](https://www.typescriptlang.org/docs/handbook/utility-types.html)，TypeScript 是一个特别灵活的类型系统。我认为，这些是经验丰富的 TypeScript 开发人员工具箱中的基本工具。

让我们看一些例子。

假设您有一个`User`接口，在创建新用户时需要它的所有属性，但是在更新用户的情况下，这些属性中的任何一个都可以被传递——换句话说，没有一个属性是明确需要的。在一个没有`Partial`实用程序类型的世界中，这将看起来像这样:

使用`Partial`类型也可以达到同样的效果，但是代码要干燥得多。该实用程序类型只是使给定类型的每个属性都是可选的:

我更经常使用的另外两个实用程序类型是[选择](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktk)和[省略](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittk)助手。这些允许您利用已经定义的类型/接口，但是对某些属性更具选择性。例如，假设我有一个类似上面定义的`User`接口，但是这个新的`User`有一些我的客户端应用程序并不真正关心的元数据:

如果我有一个与用户相关的表单，我可以指向同一个`User`界面，同时“忽略”我不关心的属性:

现在，我将拥有与最初的`User`接口相同的类型安全，“省略”了`id`和`updated_at`属性，这些属性对于前端开发来说毫无用处。当原始界面更新时，我的表单类型也随之更新。使用`Pick`可以实现相反的效果，您可以选择希望给定变量遵循的属性子集。

# 打字的成本效益分析

有很多次，我试图调试一个“类型”场景，但似乎无法通过。如果你去过那里，你就知道我指的是什么。作为一名开发人员，你**知道**至少可以说应用程序的这个特定部分的类型安全是很好的，但是为什么你的类型声明不起作用却难倒了你，你拒绝向类型怪物屈服！

相信我，我去过很多次了。然而，我在 TypeScript 上花的时间越多，我就越愿意放弃这些战斗。毕竟，打字是为了团队的利益，如果编译器拒绝你的类型注释，你的代码可能有问题。我宁愿屈服于编译器，也不愿在我的代码中加入一个`@ts-ignore`。这只是我的想法！

我希望这些例子可以帮助其他人在有时相当模糊的打字稿池中找到他们的路！