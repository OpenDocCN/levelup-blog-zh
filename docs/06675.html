<html>
<head>
<title>Producer-Consumer Problem Using Condition Variable in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中使用条件变量的生产者-消费者问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/producer-consumer-problem-using-condition-variable-in-c-6c4d96efcbbc?source=collection_archive---------0-----------------------#2020-12-19">https://levelup.gitconnected.com/producer-consumer-problem-using-condition-variable-in-c-6c4d96efcbbc?source=collection_archive---------0-----------------------#2020-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在并发计算中，生产者-消费者问题是一个经典问题。我们经常用它来演示不同的同步技术。在<a class="ae kl" href="https://domiyanyue.medium.com/producer-consumer-problem-using-mutex-in-c-764865c47483" rel="noopener">之前的一篇文章</a>中，我们用互斥体解决了这个问题。今天，我们将重新讨论这个问题，并用条件变量改进解决方案。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7c1813317d176ca9b04738acf0ae9097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_zo1fMcoLzw0tc9CIN5pA.png"/></div></div></figure><p id="fe15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程由三部分组成。首先，我们将回顾互斥锁的唯一答案并分析它的缺点。接下来，我们将引入条件变量。最后，我们将利用学到的知识开发更好的解决方案。</p><h1 id="5b6b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">带有互斥的生产者-消费者</h1><p id="3ab2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果你没有看过我的<a class="ae kl" href="https://domiyanyue.medium.com/producer-consumer-problem-using-mutex-in-c-764865c47483" rel="noopener">上一篇</a>，我强烈推荐你先看看。以下是核心功能:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="05a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">低效率来自“忙等待”循环，因为CPU停留在一个循环中什么也不做。即使我们可以添加“睡眠命令”来“减慢”循环频率，也很难得到睡眠时间的合理估计。此外，等待时间在不同的迭代中是不同的。“忙着等待”不是最佳策略。</p><p id="ec52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根本原因是<em class="md">除了轮询</em>，我们没有办法让一个线程知道另一个线程已经完成。我们需要一种更直接的方式让线程通知其他线程。为这些场景创建了条件变量。</p><h1 id="890a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">条件变量</h1><p id="e0e5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">条件变量支持线程间的“等待和通知”行为。它们用于阻塞一个或多个线程，直到另一个线程发送通知。C++包含内置的(从C++11开始)std::condition_varible原语。</p><p id="39e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将调用一个发送通知的线程<em class="md"> sender </em>和一个被阻塞时等待通知的线程<em class="md"> receiver </em>。在同步过程中:</p><p id="a157" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发件人必须:</p><ol class=""><li id="8704" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">获取一个std::mutex(通过std::lock_guard)。</li><li id="cd98" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">修改全局状态shared(接收方将检查它是否应该启动)。</li><li id="df9c" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">std::condition_variable执行“notify_one”或“notify_all”来通知接收方。这一步不需要持有互斥/锁。</li></ol><p id="9ab6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等待的接收者:</p><ol class=""><li id="7221" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">获取一个std::unique_lock <:mutex>，这是同一个互斥发送器使用的。</:mutex></li><li id="befd" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">Declare std::condition_variable(同一个发送方引用)等待lambda表达式指定的特定条件。现在接收器处于“等待”状态。互斥体被释放。</li><li id="421e" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">当通知条件变量时，接收方重新获取互斥体并检查条件。只有当条件为真时，接收方才会继续执行。否则，它返回到“等待”状态并释放锁。</li></ol><p id="be46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该过程可以被证明为:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="76c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第15行可能是最令人困惑的一行。接收方线程处于“挂起”状态，直到它得到通知(由发送方发出)。当通知到达时:</p><ol class=""><li id="da90" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">接收方线程获取锁。</li><li id="0e8a" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">如果条件(g_ready)为假，则释放锁。回到“暂停”状态。</li><li id="0ac3" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">如果条件(g_ready)为真，继续执行不解锁。</li></ol><p id="e484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了帮助您理解，下面是一个使用“忙等待”方法的语义等效版本:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="4d77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逐行比较，条件变量取代了“busy wait”循环，并检查停止循环的相同谓词(g_ready)。</p><p id="d199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">互斥体+ condition_variable +共享全局状态的组合在进行线程间通信时很有用。让我们把它应用于生产者-消费者问题。</p><h1 id="3e8f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">有条件变量的生产者-消费者</h1><p id="3879" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们可以重用前一部分中的模式。这一次，两个线程都在发送方和接收方的角色之间切换。当产品产生时，生产者是发送者，消费者是接收者。在消费产品时，他们的角色颠倒了。以下是完整的解决方案:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="b2b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以将它与“忙碌-等待”解决方案<a class="ae kl" href="https://gist.github.com/domiyanyue/1a4646ec74f4f0934377da01f4e17db2#file-producer_consuer_mutex_only-cpp" rel="noopener ugc nofollow" target="_blank">进行比较，看看我们是如何修改代码的。</a></p><p id="573a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，你可能会有疑问。条件变量是如何实现的？他们有效率吗？取决于操作系统和CPU类型，实现可能会有所不同。这是一个复杂的话题，我们今天不讨论。在下一节中，我们将运行一个快速实验，将其与“忙-等待”进行比较</p><h1 id="39af" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">条件变量的性能如何？</h1><p id="98c9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们想验证当条件变量挂起线程时，它们没有浪费CPU周期。</p><p id="fe80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该程序包含一个等待另一个线程(工作线程)的简单线程(waitThread):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="58f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为比较，我们也有“忙-等待”版本:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="bc5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在Linux中使用“top”命令来监控一个线程等待时(另一个线程正在休眠)的CPU使用情况:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ms"><img src="../Images/fc5c6558af729fc8a74523f704685451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmDmAIMnAdEzRKnSBfp1zQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">CPU利用率比较:繁忙等待与条件变量</figcaption></figure><p id="7c34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CPU利用率是100%(忙-等待)对零(条件变量)。这并不奇怪，因为我们期望条件变量是有效的。</p><h1 id="df37" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="d651" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在本文中，我们:</p><ol class=""><li id="b2c2" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">分析了仅使用互斥体的生产者-消费者问题的解决方案，并指出其局限性。</li><li id="249d" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">引入了条件变量，学会了用C++编码。</li><li id="fe1a" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">生产者-消费者问题中的应用STD::condition _ variable。</li><li id="1f0f" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">测试条件变量的效率。</li></ol><h1 id="7cab" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><ol class=""><li id="0d7a" class="me mf iq jp b jq lw ju lx jy mx kc my kg mz kk mj mk ml mm bi translated"><a class="ae kl" href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem" rel="noopener ugc nofollow" target="_blank">生产者-消费者问题</a></li><li id="8186" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">【cppreference.com】STD::condition _ variable</li><li id="d010" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">C++核心指南:注意条件变量的陷阱</li></ol></div></div>    
</body>
</html>