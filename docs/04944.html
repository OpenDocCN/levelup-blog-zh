<html>
<head>
<title>Introduction to WebRTC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebRTC简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-webrtc-5310fae89085?source=collection_archive---------10-----------------------#2020-07-25">https://levelup.gitconnected.com/introduction-to-webrtc-5310fae89085?source=collection_archive---------10-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="df9e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">开源实时通信入门</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d046d3ac115ff342376b54b0d53560b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWwS_KrTXtmMadzkKiz1Lg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯·蒙哥马利在<a class="ae kv" href="https://unsplash.com/s/photos/video-call?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你没听说过，WebRTC是实时获取和共享用户视频、音频和其他数据的途径。代表<strong class="ky ir">网络实时通信</strong>，它是同类产品中的第一个——使用JavaScript APIs获取用户的媒体，创建点对点连接，并在浏览器中打开数据通道。在2011年WebRTC发布之前，需要几个开发人员和大量C#来完成这些任务。</p><p id="e34e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，将近10年过去了，WebRTC是web和移动媒体共享的标准。它由万维网联盟(W3C)和互联网工程任务组(IETF)标准化，在HTML5中有本地支持，并且是开源和完全免费的。所有这一切意味着你可以开始使用它，而不需要安装任何插件或软件包。</p><p id="cbf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将向您介绍使WebRTC能够完成所有这些工作的API，并提供一些简单的代码片段来帮助您熟悉数据类型以及如何开始使用它们。</p><p id="be5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:WebRTC有很多功能，尤其是对等连接和数据通道。我将从头到尾提供一些链接，以了解关于这些工具、它们的上下文以及使用它们所需的一些配置的更多信息。</p><h2 id="62e7" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">三个WebRTC APIs</h2><p id="336d" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">WebRTC使用三种JavaScript APIs:</p><ol class=""><li id="aa7a" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated"><code class="fe na nb nc nd b">MediaStream</code>又名<code class="fe na nb nc nd b">getUserMedia</code>——允许开发人员访问用户的媒体流:网络摄像头、麦克风和屏幕(当然是在用户允许的情况下)</li><li id="18d2" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">RTCPeerConnection</code> —支持用户之间通过点对点连接进行音频和视频“通话”</li><li id="2eb2" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><code class="fe na nb nc nd b">RTCDataChannel</code> —使用对等连接实现用户之间任何其他通用数据的实时共享</li></ol><h2 id="f919" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">媒体流</h2><p id="5a14" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">媒体流是WebRTC视频/音频/屏幕共享功能的核心。开始使用它非常容易。因为浏览器中已经有这个API了，所以你只需要调用<code class="fe na nb nc nd b">getUserMedia</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="cb5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，它在全局<code class="fe na nb nc nd b">navigator</code>对象上，作为<code class="fe na nb nc nd b">mediaDevices</code>上的一个方法。传入一些参数来获得您想要的特定媒体——这里我们从用户那里获得视频和音频，对视频或音频的大小、帧速率、纵横比等没有任何限制。阅读有关MDN上的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API/Constraints" rel="noopener ugc nofollow" target="_blank">用户媒体约束的更多信息</a>。</p><p id="2b68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc nd b">getUserMedia</code>用用户的媒体流返回一个承诺，媒体流是一个如下所示的对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在原型中，你可以看到这个流可以访问一系列方便的方法，比如<code class="fe na nb nc nd b">getAudioTracks</code>和<code class="fe na nb nc nd b">getVideoTracks</code>，它们可以在我们的流上使用，以进一步处理和潜在操纵媒体(关于你可以对音频轨道做什么的想法，请参见<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" rel="noopener ugc nofollow" target="_blank"> Web Audio API </a>)。</p><p id="be7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们访问了这个媒体流，我们也可以通过HTML中的<code class="fe na nb nc nd b">&lt;video&gt;</code>标签显示它。无论您如何在代码中保存返回的流，只需在<code class="fe na nb nc nd b">ref</code>属性中引用该位置:<br/> <code class="fe na nb nc nd b">&lt;video ref={usersSavedMediaStream} /&gt;</code>。</p><p id="63dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">了解更多关于在Flavio Copes 使用 <code class="fe na nb nc nd b"><a class="ae kv" href="https://flaviocopes.com/getusermedia/" rel="noopener ugc nofollow" target="_blank">MediaStream</a></code> <a class="ae kv" href="https://flaviocopes.com/getusermedia/" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe na nb nc nd b"><a class="ae kv" href="https://flaviocopes.com/getusermedia/" rel="noopener ugc nofollow" target="_blank">getUserMedia</a></code> <a class="ae kv" href="https://flaviocopes.com/getusermedia/" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae kv" href="https://flaviocopes.com/getusermedia/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="5c6b" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">RTCPeerConnection</h2><p id="1a77" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">好了，我们有了用户的媒体，但是现在我们如何分享它呢？输入对等连接。<code class="fe na nb nc nd b">RTCPeerConnection</code>表示本地用户计算机和远程对等用户计算机之间的连接，包括连接、维护和关闭连接的方法。您可以通过创建一个新的<code class="fe na nb nc nd b">RTCPeerConnection</code>实例并传递您的配置来建立对等连接:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0af9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">配置可以很多，但唯一绝对必要的是<code class="fe na nb nc nd b">iceServers</code>，它将保存一个URL对象数组，其中包含在寻找ICE候选对象的过程中使用的STUN和TURN服务器的信息。哇，那是整整一口！在一个非常基本的层面上，ICE候选是关于对等体之间交换的网络的信息。在进行对等连接时，两台远程计算机就它们之间的最佳连接达成一致。在Temasys 的Sherwin Sim的这篇文章中阅读更多关于<a class="ae kv" href="https://temasys.io/webrtc-ice-sorcery/" rel="noopener ugc nofollow" target="_blank">冰候选者和眩晕/变身服务器的信息。</a></p><p id="1312" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，虽然API将允许您进行这些对等连接，但是您还需要使用某种类型的<em class="ls">信令</em>来促进通过服务器的对等连接。WebRTC没有为此提供API，但是有很多选择。这方面做同行之间的连接我就不赘述了，不过可以推荐一下<a class="ae kv" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket。IO </a>作为基于Node.js的web socket选项，您可以在MDN 上了解更多关于<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling" rel="noopener ugc nofollow" target="_blank">信令的信息。</a></p><p id="6dbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能认为这听起来很复杂——你是对的。自从WebRTC最初发布以来，已经开发了许多库来掩盖这种复杂性，并使对等实时连接变得稍微容易一些。Simple-Peer 是一个众所周知的开源库，制造商也有一个很好的信号库，叫做<a class="ae kv" href="https://github.com/t-mullen/simple-signal" rel="noopener ugc nofollow" target="_blank"> Simple-Signal </a>(它使用了<a class="ae kv" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket。IO </a>)。此外，您可以查看WebRTC模块和资源的这个<a class="ae kv" href="https://github.com/openrtc-io/awesome-webrtc" rel="noopener ugc nofollow" target="_blank">集合。</a></p><h2 id="6ce1" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">rtcdataschannel</h2><p id="aa2a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">WebRTC中的最后一个API允许开发人员在两个对等点之间打开一个通道，通过它我们可以发送和接收其他数据，例如实时聊天的文本，甚至是从一台计算机到另一台计算机的任何文件的文件传输，例如基于torrent的文件共享。这与web sockets非常相似，通过<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank"> WebSocket API </a>引入，包含在Socket.IO的特性中。</p><p id="6926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，您需要一个通过<code class="fe na nb nc nd b">RTCPeerConnection</code>打开的对等连接(或者一个为您处理这个的库)。一旦建立了连接，就可以在本地对等体上调用<code class="fe na nb nc nd b">createDataChannel</code>,在远程对等体上调用<code class="fe na nb nc nd b">ondatachannel</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="6360" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">结论</h2><p id="c3d9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">这是对通过WebRTC可以获得的特性的高度概括。使用<code class="fe na nb nc nd b">getUserMedia</code>开始使用用户的媒体相当容易，而在用户之间建立点对点连接和数据通道的复杂性会迅速增加。您将需要使用第三方API来处理服务器信令(如<a class="ae kv" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket)。IO </a>，你可以选择使用另一个库来帮助导航<code class="fe na nb nc nd b">RTCPeerConnection</code>和<code class="fe na nb nc nd b">RTCDataChannel</code>的复杂性，就像<a class="ae kv" href="https://github.com/feross/simple-peer" rel="noopener ugc nofollow" target="_blank">简单对等</a>。</p><p id="f888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这套强大的API可能需要一点时间来开始使用，但它是一种优秀的、有良好文档记录的、立即可用的免费方式，可以将实时视频和音频通信、文件共享以及任何其他点对点远程交换引入您的应用程序。</p><p id="2d1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关WebRTC的更深入的教程，请查看以下两个资源:</p><ol class=""><li id="4f8a" class="mr ms iq ky b kz la lc ld lf mt lj mu ln mv lr mw mx my mz bi translated"><a class="ae kv" href="https://www.tutorialspoint.com/webrtc/webrtc_quick_guide.htm" rel="noopener ugc nofollow" target="_blank">教程点的WebRTC“快速指南”</a></li><li id="9aed" class="mr ms iq ky b kz ne lc nf lf ng lj nh ln ni lr mw mx my mz bi translated"><a class="ae kv" href="https://www.html5rocks.com/en/tutorials/webrtc/basics/" rel="noopener ugc nofollow" target="_blank">从HTML5 Rocks开始使用WebRTC</a></li></ol></div></div>    
</body>
</html>