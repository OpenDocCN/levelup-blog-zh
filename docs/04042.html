<html>
<head>
<title>Template Metaprogramming: A C++ walkthrough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模板元编程:C++演练</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/template-metaprogramming-a-c-walkthrough-a7c6db0b4148?source=collection_archive---------5-----------------------#2020-06-07">https://levelup.gitconnected.com/template-metaprogramming-a-c-walkthrough-a7c6db0b4148?source=collection_archive---------5-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="12eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新</strong>:有人在<a class="ae kl" href="https://www.reddit.com/r/cpp/comments/gyby5v" rel="noopener ugc nofollow" target="_blank"> Reddit </a>上告诉我，这是C++编程和编译器优化的老观点。如果你对模板元编程很熟悉，并且想更新最新的模板元编程，可以去看看Reddit <a class="ae kl" href="https://www.reddit.com/r/cpp/comments/gyby5v" rel="noopener ugc nofollow" target="_blank">帖子</a>上的评论。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/164e4fa6ab527a2f7bd70c6f9fbc2e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Stufi_hqYcHIryLwZd2Ylg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">阶乘的模板及其用法。</figcaption></figure><h1 id="5da1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是模板元编程？</h1><p id="3b8a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><strong class="jp ir"/>元编程指的是一个程序了解自身或者能够操纵自身的各种方式阅读维基百科。我第一次读这本书的时候，还是一个研究生新手，我对人工智能程序能够编写其他代码并接管世界的可能性感到震惊。虽然这是好莱坞的版本，但这是一个现实的版本，在业内使用C++模板进行编译时优化。</p><p id="f340" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在研究一个涉及优化的副业项目时遇到了这个概念。虽然这不是一个远离CS101课程所涵盖的基础的概念，但它并不广为人知，因此博客对其进行了分解。</p><p id="f545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们看看什么是模板:<br/>模板是泛型编程的基础，泛型编程包括以独立于任何特定变量类型的方式编写代码。</p><p id="eb24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下面的代码为例:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="8358" class="ml ld iq mh b gy mm mn l mo mp">#include &lt;iostream&gt;</span><span id="787d" class="ml ld iq mh b gy mq mn l mo mp"><strong class="mh ir">using</strong> <strong class="mh ir">namespace</strong> <!-- -->std;<br/></span><span id="9ec8" class="ml ld iq mh b gy mq mn l mo mp">// One function works for all data types.  </span><span id="e8e9" class="ml ld iq mh b gy mq mn l mo mp"><strong class="mh ir">template</strong> <!-- -->&lt;<strong class="mh ir">typename</strong> <!-- -->T&gt;<br/>T tMax(T x, T y)<!-- --> <br/>{ <strong class="mh ir">return</strong> <!-- -->(x &gt; y)? x: y; }<br/></span><span id="66ee" class="ml ld iq mh b gy mq mn l mo mp"><strong class="mh ir">int</strong> <!-- -->main()<br/>{</span><span id="786b" class="ml ld iq mh b gy mq mn l mo mp">cout &lt;&lt; tMax&lt;<strong class="mh ir">int</strong>&gt;(3, 7) &lt;&lt; endl; // Call myMax for <!-- -->type int<br/>cout &lt;&lt; tMax&lt;<strong class="mh ir">double</strong>&gt;(3.0, 7.0) &lt;&lt; endl; // call myMax for <!-- -->type d<br/>cout &lt;&lt; tMax&lt;<strong class="mh ir">char</strong>&gt;(’g’, 'e’) &lt;&lt; endl; // call myMax for type char</span><span id="f030" class="ml ld iq mh b gy mq mn l mo mp"><strong class="mh ir">return</strong> <!-- -->0;<br/>}</span></pre><p id="d261" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模板<code class="fe mr ms mt mh b">tMax</code>提供了一个通用函数，可以被所有数据类型使用。</p><h1 id="3f3e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">模板是如何工作的？</h1><blockquote class="mu"><p id="d12a" class="mv mw iq bd mx my mz na nb nc nd kk dk translated">模板被汇编器编译成实类型</p></blockquote><p id="3eac" class="pw-post-body-paragraph jn jo iq jp b jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">在程序编译后，模板本身不作为泛型存在，即在汇编代码中。</p><p id="65ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在上面看到的<code class="fe mr ms mt mh b">tMax</code>模板例子中一样，模板tMax被汇编器转换成代码中调用的每种类型的不同函数。<br/> ref: <a class="ae kl" href="https://godbolt.org/z/dDfnJz" rel="noopener ugc nofollow" target="_blank">汇编代码</a>(第38行定义了函数<em class="mf"> int tMax &lt; int &gt; (int，int) </em>这是int类型的tMax)</p><p id="f923" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能想分支到<a class="ae kl" href="https://www.tutorialspoint.com/cplusplus/cpp_templates.htm" rel="noopener ugc nofollow" target="_blank">教程点(C++模板)</a>来花一些时间在模板上。Java提供的模板的等价构造是<a class="ae kl" href="https://www.geeksforgeeks.org/generics-in-java/" rel="noopener ugc nofollow" target="_blank">泛型</a>。</p><h1 id="fd4a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使用模板进行优化</h1><p id="744f" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">由于模板在编译时“展开”到函数中，并且编译器在编译时本身也执行不涉及变量的计算，因此一些<em class="mf">计算可以在编译时完成，并在运行时避免</em>。</p><blockquote class="mu"><p id="5a00" class="mv mw iq bd mx my mz na nb nc nd kk dk translated"><em class="nj">计算可以在编译时完成，在运行时避免</em></p></blockquote><p id="5b6d" class="pw-post-body-paragraph jn jo iq jp b jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">假设您正在编写一段代码，并且您希望<strong class="jp ir">使用</strong>值15！(15阶乘)作为代码的一部分。<br/>递归的方法是使用如下代码:</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="f2f4" class="ml ld iq mh b gy mm mn l mo mp">long factorial(int n)<br/>{<br/>  if (n == 0)<br/>    return 1;<br/>  else<br/>    return(n * factorial(n-1));<br/>}</span><span id="0835" class="ml ld iq mh b gy mq mn l mo mp">int main()<br/>{<br/>  cout &lt;&lt; factorial(15) &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="78d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将编译成一个函数，并在运行时调用参数n=15的函数。<br/> ref: <a class="ae kl" href="https://godbolt.org/z/PS5bM4" rel="noopener ugc nofollow" target="_blank">汇编代码</a>(你可以在第17行看到factorial函数和一个<em class="mf">调用factorial(int) </em>)</p><p id="4af7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用模板转换成一个程序。</p><pre class="kn ko kp kq gt mg mh mi mj aw mk bi"><span id="5a3b" class="ml ld iq mh b gy mm mn l mo mp">template &lt;long N&gt;<br/>struct Factorial <br/>{<br/>    enum { value = N * Factorial&lt;N - 1&gt;::value };<br/>};</span><span id="c441" class="ml ld iq mh b gy mq mn l mo mp">template &lt;&gt;<br/>struct Factorial&lt;0&gt; <br/>{<br/>    enum { value = 1 };<br/>};</span><span id="baba" class="ml ld iq mh b gy mq mn l mo mp">int main()<br/>{<br/>    cout &lt;&lt; Factorial&lt;15&gt;::value &lt;&lt; endl;<br/>    return 0;<br/>}</span></pre><p id="b2ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在编译期间，编译器展开参数N=15的阶乘模板，并遇到参数N=14的模板，以此类推，直到N=0。由于在这些计算过程中没有遇到变量，它们在编译时被解析，阶乘&lt;15&gt;最终被解析为值15！即1307674368000，避免了任何运行时计算。你可以在汇编代码中看到，值1307674368000被直接使用，而不是调用一个函数。<br/> ref: <a class="ae kl" href="https://godbolt.org/z/aLMcxq" rel="noopener ugc nofollow" target="_blank">汇编代码</a>(没有函数定义为15的值！已经由汇编程序计算并用于第4行)</p><p id="90ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行带有时间剖析(和太多迭代)的两个实现向我们展示了优化的影响。<a class="ae kl" href="https://www.jdoodle.com/a/27mP" rel="noopener ugc nofollow" target="_blank">模板化代码</a>运行时间约为0.03毫秒，而<a class="ae kl" href="https://www.jdoodle.com/a/27mN" rel="noopener ugc nofollow" target="_blank">递归版本</a>运行时间至少是预期的30倍，在运行时计算阶乘并向下递归。</p><h1 id="0b6b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">其他例子:模板和特殊功能。</h1><p id="aaed" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">一个更深入(更复杂，更有益)的例子来自<a class="ae kl" href="http://www.cs.rpi.edu/~musser/design/blitz/meta-art.html" rel="noopener ugc nofollow" target="_blank">模板元程序(Todd Veldhuizen) </a>。使用模板进行<strong class="jp ir">冒泡排序</strong>似乎不太直观，因为输入的不是一个单一的数字，但想法是创建一个模板，展开成一个<code class="fe mr ms mt mh b">specialised function</code>冒泡排序，以迎合某个<em class="mf">数量的元素</em>。我强烈建议浏览一下这个例子，找出细节。</p><h1 id="102e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">这个用在哪里？</h1><p id="e7b8" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我首先想到的是，如果不涉及变量，为什么我们需要执行像调用模板这样的函数。这难道不等同于用值本身编写代码吗(比如用1307674368000代替` Factorial &lt;15&gt;`)。与此相反的观点是需要抽象函数，而不是在代码中散布随机值。</p><p id="1154" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，<a class="ae kl" href="https://www.boost.org/" rel="noopener ugc nofollow" target="_blank"> Boost </a>的库利用模板为复杂的函数提供库，如阶乘、正弦、余弦等。确保在运行时不计算这些值，而在编译时可以计算这些值。</p><p id="951a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之，模板是确保编译时计算和节省时间关键项目(高频交易，可能是航空和航天旅行)运行时间的一个巧妙技巧。</p><p id="c0d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看<a class="ae kl" href="https://stackoverflow.com/questions/63494/does-anyone-use-template-metaprogramming-in-real-life" rel="noopener ugc nofollow" target="_blank"> SO </a>关于模板元编程的社区讨论。如果你在你的代码中使用了它，以及如何使用，请在下面评论。</p></div></div>    
</body>
</html>