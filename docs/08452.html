<html>
<head>
<title>Patterns to know before migrating your monolith to microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的monolith迁移到微服务之前需要了解的模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/patterns-to-know-before-migrating-your-monolith-to-microservices-72fcbcc7846e?source=collection_archive---------5-----------------------#2021-05-04">https://levelup.gitconnected.com/patterns-to-know-before-migrating-your-monolith-to-microservices-72fcbcc7846e?source=collection_archive---------5-----------------------#2021-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/081c1eac814664351a6364599a462e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnqlCVLSCHQZG6A9-V4fpA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@kaleidico?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae jd" href="https://unsplash.com/s/photos/migration?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="866b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当正确实施时，微服务提供了许多优于整体服务的优势。许多组织希望将他们的monolith应用程序代码改为微服务代码。事实证明，迁移到微服务并不容易。你要问的第一个问题是，你真的需要微服务吗？通过使用模块化整体结构，可以容易地解决整体结构的许多问题。一旦你确定你想要微服务，你就必须制定一个计划将monolith转化为微服务。有一些模式可以帮助您创建所需的计划。</p><p id="bf21" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们进入实际的模式来划分一个整体之前，让我们来谈谈什么是不应该做的。</p><h1 id="47df" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要做大爆炸重写</h1><p id="c07c" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">大爆炸重写，顾名思义，我们必须在微服务中重写整个monolith的代码，并一次性将其部署到生产中。马丁·福勒曾经正确地说过:</p><blockquote class="me mf mg"><p id="c970" class="kd ke mh kf b kg kh ki kj kk kl km kn mi kp kq kr mj kt ku kv mk kx ky kz la ij bi translated">《生活大爆炸》唯一能保证的就是一场大爆炸！</p></blockquote><p id="3804" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大爆炸重写总是危险的。大爆炸重写需要花费大量的时间来开发，因为你必须对一个整体应用程序中的所有东西进行编码。此外，在微服务架构的开发过程中，您必须冻结您的monolith的进一步开发，因为monolith中所做的每个更改都必须在微服务中完成。对于大多数公司来说，冻结应用程序开发可能是危险的，因为他们必须根据业务环境的变化进行调整。</p><p id="0d44" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于一个组织来说，从整体逐渐转移到微服务总是更好的。有一些设计模式可以帮助你从monolith逐渐过渡到微服务架构。</p><h1 id="9200" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">扼杀者无花果</h1><p id="7b0b" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">扼杀者无花果是马丁·福勒提出的一种模式。扼杀者无花果的灵感来自于真实的无花果，从寄主树的顶端树枝开始变小。无花果的根开始向地面生长。慢慢地，它的根会到达地面，并继续生长，甚至在此过程中杀死宿主树。同样，在软件领域，我们将根据这种模式围绕单个整体应用构建微服务。我们将不断在系统中增加更多的微服务，最终有一天会取代整个monolith系统。</p><p id="08ef" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在扼杀者Fig中，我们在现有的monolith的边缘创建新的服务。我说的整块石头的边缘是什么意思？我们举个例子来理解。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/db871f44540c0c8d039c4c3fb3a176c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*J7Yih72_f2tCTn5oDE1mUA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图1:单片应用程序</figcaption></figure><p id="0f6e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在图1中，你可以看到我们有一个整体应用程序。现在，在上图中，产品库存、订单管理和账单管理模块位于应用程序的边缘。通知管理有来自应用程序内部的多个入站呼叫。因此，我们不能从外部应用程序将所有入站呼叫重定向到通知管理。我们还有另一种将通知管理转移到微服务的模式，我们将在后面讨论。</p><p id="38aa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想将计费管理迁移到微服务。我们可以使用以下步骤将整体迁移到微服务。</p><ol class=""><li id="eb85" class="mq mr jg kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated"><em class="mh">插入代理:</em>除非您已经有一个代理，否则我们需要部署另一个HTTP代理。在步骤1中，我们有一个HTTP代理，它将所有调用直接重定向到整体应用程序。通过引入HTTP代理，您还可以知道网络上的任何附加希望是否会延迟API调用。如果延迟很大，那么您必须停止迁移，在继续迁移之前先改善您的网络。</li><li id="df1d" class="mq mr jg kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><em class="mh">部署微服务:</em>在第2步中，您将只在生产中部署微服务。我们的微服务上不会有任何直播流量。在第二步中，我们将测试我们的微服务是否工作正常。</li><li id="ff0a" class="mq mr jg kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><em class="mh">重定向流量:</em>在第3步中，我们将把实际流量从HTTP代理重定向到我们新的微服务。如果有问题，我们可以通过更改HTTP代理来轻松回滚。</li></ol><p id="e1d5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有步骤也显示在图2中。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/026dfa583e523e46bc46a1158028ea53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gw637bHq5noRVLM3rkX-gg.png"/></div></div></figure><h1 id="3332" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">抽象分支</h1><p id="a0f9" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当你必须提取一个其他模块所依赖的模块时，那么抽象分支模式会很有用。假设在前面的示例中，我们想要将通知管理转换为微服务。在这种情况下，我们将使用抽象分支。我们需要执行以下步骤来提取一个模块。</p><ol class=""><li id="6b35" class="mq mr jg kf b kg kh kk kl ko ms ks mt kw mu la mv mw mx my bi translated"><em class="mh">创造抽象。你需要围绕你要替换的模块创建抽象。</em></li><li id="fde3" class="mq mr jg kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><em class="mh">更改现有功能的客户端以使用新的抽象:</em>您需要重构旧代码，以便旧实现实现在步骤1中创建的抽象。</li><li id="b49b" class="mq mr jg kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><em class="mh">创建新的实现。</em>您需要为功能创建一个新的微服务实施，并将其部署到生产环境中，然后运行一些测试。</li><li id="21e0" class="mq mr jg kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><em class="mh">开关实现。一旦你运行了一些测试，你有了一些信心，那么你就可以切换到一个新的代码。</em></li><li id="d123" class="mq mr jg kf b kg mz kk na ko nb ks nc kw nd la mv mw mx my bi translated"><em class="mh">清理。</em>一旦你的微服务启动并运行，最好清理旧代码库并移除旧模块。如果你愿意，你也可以去掉抽象。在许多情况下，您之前创建的抽象可能只是改进了您的代码库，在这些情况下，保留它完全没问题。</li></ol><p id="7a32" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好地理解整个过程，请参考图3。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/ba6f28c804ba5fbd497f16fddf0bb7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubyxKps8fBIk2w8tyA51SQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图3:通过抽象进行分支</figcaption></figure><p id="fba9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抽象分支可以用在很多地方。它总是建议尽可能使用扼杀者图而不是抽象分支。一旦你确定你不能用陌生的Fig替换你的微服务的某个部分，因为它在你的微服务中，那么就应该考虑抽象的分支。</p><h1 id="1824" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">并行运行</strong></h1><p id="1a2d" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">无论你做了多少测试，仍然有可能出现错误。当你在迁移一个关键系统时，你不能把任何东西留给运气。在这种情况下，并行运行模式会很有帮助。在这种模式中，我们将在生产中部署我们新开发的微服务和monolith。我们将让数据从两个系统中流出。整体系统最初将是真理的唯一来源。我们将比较新开发的微服务与整体服务的结果。如果我们发现任何不匹配，我们将在我们的微服务应用中修复它。一段时间后，当我们对我们的新微服务系统有足够的信心时，我们可以从monolith中退役功能，并使微服务成为唯一的真理来源。</p><p id="d8ad" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在前面的例子中，假设我们想将计费管理从monolith迁移到microservice。在这种情况下，我们将开发一个微服务，并将相同的流量发送到我们的新微服务。在一天结束时，我们可以对任何批处理作业进行比较，看遗留系统和新系统生成的账单是否相同。一旦我们有了信心，我们可以停止从整块的计费系统。我们也有一些开源库，比如Github的科学家库，可以帮助你更好地实现这个模式。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c307dc5a8138fb21457bfbecaf475cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*7psPOmlpES2hPaoIADqF4g.jpeg"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图4:并行运行模式</figcaption></figure><p id="e9c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你的功能已经存在于整块石头中时，到这里为止所经历的模式是有用的。让我们想象你必须增加新的功能。也许让我们说，你想在每次成功购买后，通过电子邮件向用户发送折扣券，供下次购买时使用。很简单，您可以从monolith的订单模块添加新代码来调用新创建的折扣微服务。但是如果你没有密码呢？假设您正在使用另一家供应商的解决方案，或者正在使用一些SAAS，那么您还能实现它吗？接下来我们将要看到的两种模式正是为这种情况量身定制的。</p><h1 id="63bb" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">装修合作方</strong></h1><p id="a5a4" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这种模式的灵感来自于我们已经知道并喜爱的一种模式，装饰者模式。在这种情况下，就像扼杀者模式一样，我们必须引入一个代理。我们将让调用通过代理传递到monolith，基于monolith的响应，代理将调用我们新创建的微服务。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/0ddbfc2094b52628e7f216964a00f6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iF9Xk3606N4w9s8bCOMqXQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图5:装饰合作者</figcaption></figure><p id="a8a9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图5展示了装饰者合作者的工作。只有当微服务所需的所有数据都已经出现在请求或响应中时，才应该使用这种模式。如果数据不存在，那么我们新创建的微服务将不得不与monolith的数据库连接。它将把我们新的微服务与monolith的数据库结合起来，这从来都不是一个好主意。</p><h1 id="aaa7" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更改数据捕获模式</h1><p id="3f14" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这种模式中，我们将对数据库中发生的变化做出反应。比方说，我们想为系统中创建的每个客户创建一张会员卡。在这种情况下，我们可以监听客户表中的变化。一旦我们检测到一个新客户在客户表中创建了n，我们就可以调用忠诚度微服务。忠诚度微服务然后可以向客户发放忠诚度卡，并向他们发送详细的电子邮件。有多种方法可以用来监听数据库中的变化。您可以使用触发器，也可以使用数据库的事务日志。您也可以编写一个过程，在几分钟后触发，并检查数据库中的任何更改。</p><h1 id="9ec2" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">结论</strong></h1><p id="08cd" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果实施得当，微服务可以提供许多优势。将您的monolith应用程序转换为微服务不会在一天或一周内发生。人们还应该记住，转换到微服务不是一场比赛，而是一场缓慢的马拉松。这需要很大的耐心，并且必须做出好的架构决策。</p><p id="c4d8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们讨论了一些您可以使用的模式。大多数情况下，您必须选择多种模式来将您的monolith应用程序完全转换为微服务。最后，我只是建议，在迁移到微服务之前，花点时间想清楚您将使用的策略，最终会有回报的。</p><h1 id="efb7" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考资料:</h1><div class="ip iq gp gr ir ni"><a href="https://martinfowler.com/bliki/StranglerFigApplication.html" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jh gy z fp nn fr fs no fu fw jf bi translated">bliki:奇异应用</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">当辛迪和我去澳大利亚的时候，我们在昆士兰海岸的雨林里呆了一段时间。一个自然的…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">martinfowler.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ix ni"/></div></div></a></div><div class="ip iq gp gr ir ni"><a href="https://martinfowler.com/bliki/BranchByAbstraction.html" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jh gy z fp nn fr fs no fu fw jf bi translated">bliki:branchbayabstraction</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">“抽象分支”是一种以渐进的方式对软件系统进行大规模变更的技术，它允许…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">martinfowler.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw ix ni"/></div></div></a></div></div></div>    
</body>
</html>