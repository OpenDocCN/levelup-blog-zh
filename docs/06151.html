<html>
<head>
<title>Implementing a sliding log rate limiter with Redis and Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Redis和Golang实现滑动对数速率限制器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-a-sliding-log-rate-limiter-with-redis-and-golang-79db8a297b9e?source=collection_archive---------7-----------------------#2020-10-30">https://levelup.gitconnected.com/implementing-a-sliding-log-rate-limiter-with-redis-and-golang-79db8a297b9e?source=collection_archive---------7-----------------------#2020-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="40a5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="814f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我开发了一个与多个支付提供商通信的应用程序。每个提供商对我们都有自己的费率限制。我们不想用尽任何支付提供商的费率限制，同时也要充分利用我们被允许的限制。我们可以将对支付提供商的请求延迟一小段时间，因为批量支付是作为异步作业离线处理的。</p><p id="056d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在一个普通的记账日，我们会在短时间内进行大量的支付。我们是否突破了支付处理器的费率限制？我们应该对此做些什么吗？我听说过一种叫做限速器的东西。</p><p id="4e36" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">什么是限速器？速率限制器限制发送方在特定时间窗口内可以发出的请求数量。一旦达到限制，它就会阻止请求。</p><p id="7a8f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通常，速率限制器组件位于接收系统中，但是由于我们非常依赖第三方处理器，所以适应提供商的速率限制和控制出站请求也是有意义的，以便不会获得太多的请求，或者乐观地说，甚至是单个请求。</p><p id="7f6f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们开始设计限速器时考虑到了这些要求:</p><ol class=""><li id="2b16" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">它应该限制在给定时间段内对特定支付提供商的请求数量</li><li id="de67" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">由于我们的系统运行在一个集群上(而不是一台服务器上)，速率限制应该应用于请求总数，而不是每个应用程序进程。</li><li id="325b" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">我们的后期限制逻辑应该是原子性的，即使多个请求同时到达我们的系统也不会失败</li></ol><h1 id="cde1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">系统结构</h1><p id="fa6d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们深入研究限速器设计之前，先来看看我们的异步支付处理系统:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/35787b7be73dcb6b130f11166fe0b651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zp-B3CM4iBss9mqH0XwlTA.png"/></div></div></figure><p id="897c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">任何到达支付消费者队列的消息都会被支付消费者处理。支付消费者从永久数据库中提取一些数据，以便向相应的支付处理器(以下称为PG)发出请求</p><p id="cb49" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">业界有几种用于速率限制的标准算法，如漏桶、固定窗口和滑动日志。没有进入决策的细节，我选择了滑动日志，因为它适合我们的需要，并且易于实现。</p><h1 id="39ba" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">该算法</h1><p id="a3a8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设对于一个PG pg1，我们被允许每秒进行100次API调用。每次我们进行API调用时，我们都会将API调用的时间戳(以纳秒为单位)添加到列表中。</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="d788" class="mu jo iq mq b gy mv mw l mx my">timestamps &lt;&lt; Time.now</span></pre><p id="a3f0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">当我们要在我们的消费者中进行API调用时，我们需要检查是否允许我们这样做:</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="1850" class="mu jo iq mq b gy mv mw l mx my">calls_already_made = timestamps.count {|t| t &gt; now - 1.second }</span></pre><p id="e6e4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">允许的剩余API调用:</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="50d3" class="mu jo iq mq b gy mv mw l mx my">allowed = max_calls_per_second - calls_already_made</span></pre><p id="c063" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">其中每分钟最大呼叫数来自支付网关配置。</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="b200" class="mu jo iq mq b gy mv mw l mx my">if allowed &gt; 0<br/>  // do magic<br/>else<br/>  // Oops! Rate limit breached, please try later!<br/>end</span></pre><p id="8210" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">简单吧？</p><h1 id="ce9f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">存储滑动日志</h1><p id="95a3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们需要某种数据库来存储按支付网关分组的时间戳列表。让我们从我们已经有的东西中选择。我们可以使用MySQL或MongoDB吗？是的，我们可以，但是我们需要一个定期删除过期时间戳的系统，因为MySQL和MongoDB都不允许我们在一行上设置TTL。Redis呢？Redis是一个键/值存储库，支持列表、集合、排序集合等等。我们可以使用一个有序的集合来保存我们的时间戳！</p><p id="85d7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">由于我们的一个关键需求是我们的窗口是自动填充的，我们可以使用<a class="ae lo" href="https://redis.io/topics/transactions" rel="noopener ugc nofollow" target="_blank"> redis事务</a>或者编写lua脚本并<a class="ae lo" href="https://redis.io/commands/EVAL" rel="noopener ugc nofollow" target="_blank"> eval </a>它。</p><h1 id="fac0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">深入redis</h1><p id="efcb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面是一个交易的样子</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="eade" class="mu jo iq mq b gy mv mw l mx my">// start the transaction<br/>MULTI</span><span id="542f" class="mu jo iq mq b gy mz mw l mx my">//  remove all values to the left of the start of the window<br/>ZREMRANGEBYSCORE &lt;pgName&gt; 0 &lt;windowStartTimestamp&gt;</span><span id="5abc" class="mu jo iq mq b gy mz mw l mx my">// Count the values in the window<br/>ZCARD &lt;pgName&gt;</span><span id="01b5" class="mu jo iq mq b gy mz mw l mx my">// Add current timestamp<br/>ZADD &lt;pgName&gt; &lt;currentTimestamp&gt; &lt;currentTimestamp&gt;</span><span id="5d1d" class="mu jo iq mq b gy mz mw l mx my">// expire the whole set after the window size<br/>EXPIRE &lt;pgName&gt; &lt;windowSize&gt;</span><span id="c7a6" class="mu jo iq mq b gy mz mw l mx my">// execute the transaction<br/>EXEC</span></pre><p id="09a7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">注意我们是如何执行ZADD的，不管是否达到了限制。这意味着我们的滑动日志将被失败的请求淹没，我们将无法满足合法的请求。</p><p id="a359" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">相反，我们只想在执行请求时添加当前时间戳。</p><p id="6af1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，事务不是一个明智的选择，因为我们需要1命令(<a class="ae lo" href="https://redis.io/commands/zcard" rel="noopener ugc nofollow" target="_blank"> ZCARD </a>)的输出来决定是否运行后续命令(<a class="ae lo" href="https://redis.io/commands/ZADD" rel="noopener ugc nofollow" target="_blank"> ZADD </a>)。</p><p id="9134" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此需要“评估”lua脚本——它允许我们在执行后续命令之前使用一个命令的输出，包括允许我们编写if条件。</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="daa6" class="mu jo iq mq b gy mv mw l mx my">// Set variables from arguments<br/>local pgname = KEYS[1]<br/>local now = tonumber(ARGV[1])<br/>local window = tonumber(ARGV[2])<br/>local limit = tonumber(ARGV[3])</span><span id="588b" class="mu jo iq mq b gy mz mw l mx my">// Remove keys older than now - window<br/>local clearBefore = now - window<br/>redis.call('ZREMRANGEBYSCORE', pgname, 0, clearBefore)</span><span id="6608" class="mu jo iq mq b gy mz mw l mx my">// Get already sent count<br/>local already_sent = redis.call('ZCARD', pgname)<br/>if already_sent &lt; limit then // if allowed, then add to sorted set<br/>redis.call('ZADD', pgname, now, now)<br/>end</span><span id="9e72" class="mu jo iq mq b gy mz mw l mx my">// for cleanup, expire the whole set in &lt;window&gt; secs<br/>redis.call('EXPIRE', pgname, window)</span><span id="abfc" class="mu jo iq mq b gy mz mw l mx my">// return the remaining amount of requests. If &gt;= 0 then request is // allowed<br/>return limit - already_sent</span></pre><p id="cabd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因为我们所有的支付消费者都连接到同一个redis集群，所以滑动日志是共享的。lua脚本的返回值大于0意味着允许进行更多的API调用。</p><p id="a614" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">下面是我们如何在redis-cli中运行它:(只需评估所有命令，用分号分隔)</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="cfae" class="mu jo iq mq b gy mv mw l mx my">eval "local pgname = KEYS[1]; local now = tonumber(ARGV[1]); local window = tonumber(ARGV[2]); local limit = tonumber(ARGV[3]); local clearBefore = now - window; redis.call('ZREMRANGEBYSCORE', pgname, 0, clearBefore); local amount = redis.call('ZCARD', pgname); if amount &lt; limit then redis.call('ZADD', pgname, now, now) end; redis.call('EXPIRE', pgname, window); return limit - amount" 1 &lt;pgname&gt; &lt;timestamp_secs&gt; &lt;window_size_secs&gt; &lt;rate&gt;</span></pre><p id="e5a5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这是我们将它嵌入golang计划的方式:</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="0e65" class="mu jo iq mq b gy mv mw l mx my">rdb := redis.NewClient(...)</span><span id="d297" class="mu jo iq mq b gy mz mw l mx my">now := time.Now().UnixNano()<br/>windowSize := int64(time.Second) // 1000000000 NanoSeconds<br/>rateLimit := 1000 // can get from config<br/>luaScript := `<br/>  local pgname = KEYS[1]<br/>  local now = tonumber(ARGV[1])<br/>  local window = tonumber(ARGV[2])<br/>  local limit = tonumber(ARGV[3])<br/>  local clearBefore = now - window<br/>  redis.call('ZREMRANGEBYSCORE', pgname, 0, clearBefore)<br/>  local amount = redis.call('ZCARD', pgname)<br/>  if amount &lt; limit then<br/>  redis.call('ZADD', pgname, now, now)<br/>  end<br/>  redis.call('EXPIRE', pgname, window)<br/>  return limit - amount<br/>`</span><span id="fd43" class="mu jo iq mq b gy mz mw l mx my">vals, err := rdb.Eval(<br/>  luaScript,            // script<br/>  1,                    // number of keys<br/>  []string{pgName},     // KEYS<br/>  now,                  // ARGV[1]<br/>  windowSize,           // ARGV[2]<br/>  rateLimit,            // ARGV[3]<br/>).Result()</span></pre><p id="bf98" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">好了，这个管用。但是我不想用内联lua脚本污染我整洁的go文件。肯定有办法把它保持为另一种。lua文件并从那里加载它</p><pre class="me mf mg mh gt mp mq mr ms aw mt bi"><span id="ebf8" class="mu jo iq mq b gy mv mw l mx my">filename := "/some/path/ratelimiter.lua"<br/>content, err := ioutil.ReadFile(filename)<br/>if err != nil {<br/>  // handle error<br/>  log.Errorf(err, "Could not read file %s", filename)<br/>}<br/>luaScript := string(content)<br/>vals, err := rdb.Eval(<br/>  luaScript,            // script<br/>  1,                    // number of keys<br/>  []string{pgName},     // KEYS<br/>  now,                  // ARGV[1]<br/>  windowSize,           // ARGV[2]<br/>  rateLimit,            // ARGV[3]<br/>).Result()</span></pre><p id="bb05" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">…我们完成了！</p><h1 id="d670" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">奖金部分:基准测试</h1><p id="72d5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">那么，我们如何知道我们的限制器实际上能够达到什么速率呢？我们试图做一些基准测试。</p><p id="597e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在总共运行2，236，110次之后，检查速率限制的平均操作耗时55.37微秒。使用本地redis实例，55.37相当于我的本地系统每秒发出超过18，000个请求。</p><p id="59da" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我从我的本地系统到我们的测试(远程)redis设置尝试了相同的基准测试，结果令人震惊。每个操作需要超过10毫秒。</p><p id="a6a6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，这意味着大部分时间被redis连接占用。然后，我们对执行简单的redis命令——SET &amp; GET——的时间进行了基准测试，在我的本地设置中为34.01微秒，在本地-远程设置中又超过了10毫秒。</p><p id="8f4e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">可以肯定地说，与简单的redis SET操作相比，速率限制器要多花大约21微秒的时间。在不久的将来，这不会成为我们支付系统的瓶颈。我们只需要确保我们的服务器到redis的连接足够快。</p><p id="cf23" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">希望这篇文章是有用的，请随时寻求问题或反馈！</p><h1 id="7942" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">附录</h1><h2 id="9132" class="mu jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">替代实现</h2><p id="d35a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae lo" href="https://github.com/RussellLuo/slidingwindow/blob/master/slidingwindow.go" rel="noopener ugc nofollow" target="_blank">纯围棋，记忆基础</a><br/>T3】Redis&amp;Lua，GCRA基础</p><h2 id="6e8d" class="mu jo iq bd jp na nb dn jt nc nd dp jx kw ne nf kb la ng nh kf le ni nj kj nk bi translated">资源</h2><p id="0cf6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/></p></div></div>    
</body>
</html>