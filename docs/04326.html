<html>
<head>
<title>Do not resolve your GraphQL fields like a REST endpoint</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要像REST端点一样解析GraphQL字段</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/do-not-resolve-your-graphql-fields-like-a-rest-endpoint-ac43242f269?source=collection_archive---------6-----------------------#2020-06-21">https://levelup.gitconnected.com/do-not-resolve-your-graphql-fields-like-a-rest-endpoint-ac43242f269?source=collection_archive---------6-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/f707bfbfaa60a718cd83cfa31af184b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*mhMF50PSG7XY9YWqlp-Wuw.png"/></div></figure><p id="8705" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用GraphQL的优势是巨大的。下面是其中的几个。</p><p id="1471" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">1.多个客户端可以使用同一个API，因为我们可以有条件地从一个API查询必要的数据。<br/> 2。减少了客户端的数据使用量，因为只从服务器传输所需的数据。<br/> 3。后端API与使用它的地方没有紧密的联系。</p><p id="1e85" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是从后端角度来看，最重要的优势之一是:</p><blockquote class="kv"><p id="fbd7" class="kw kx it bd ky kz la lb lc ld le ku dk translated"><strong class="ak">后端服务器根据客户端的查询减少处理。</strong></p></blockquote><p id="71ec" class="pw-post-body-paragraph jx jy it jz b ka lf kc kd ke lg kg kh ki lh kk kl km li ko kp kq lj ks kt ku im bi translated">注意，这不是GraphQL现成提供的东西。如果您没有以正确的方式编码，那么无论客户端的查询是什么，后端服务器上的负载都将是相同的。</p><p id="9c50" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">也就是说，您不应该像编写REST端点那样编写代码。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="39d7" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">方案</h1><p id="4677" class="pw-post-body-paragraph jx jy it jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">让我们看一个由用户和他们的帖子组成的例子。下面是两个表的结构:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mu"><img src="../Images/f9a01bf318e6a5b9e901940fd44cad9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwJcg2I15W6rx3DQUjP8Aw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">用户表</figcaption></figure><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nh"><img src="../Images/8c574a37cb3aa0952839c576a6ec26b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_jqzkXUJyC8sS_Sf_S4nw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">帖子表</figcaption></figure><p id="a2db" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">假设我需要一个解析器来列出用户及其帖子。我该怎么写这个解析器呢？</p><blockquote class="ni nj nk"><p id="1e76" class="jx jy nl jz b ka kb kc kd ke kf kg kh nm kj kk kl nn kn ko kp no kr ks kt ku im bi translated">注意:我将使用Apollo GraphQL服务器和Sequelize编写一个NodeJS应用程序来解释这个问题和解决方案。</p></blockquote><h1 id="d69c" class="lr ls it bd lt lu np lw lx ly nq ma mb mc nr me mf mg ns mi mj mk nt mm mn mo bi translated">一种可能的解决方案</h1><p id="af22" class="pw-post-body-paragraph jx jy it jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">您可以按如下方式定义模式:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="4865" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您的用户的解析器如下所示:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6feb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当然，这解决了我们的需求。<strong class="jz iu"> <em class="nl">但是这样有效率吗？</em> </strong></p><p id="d019" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们来看看两种情况下的日志。</p><blockquote class="ni nj nk"><p id="e2d2" class="jx jy nl jz b ka kb kc kd ke kf kg kh nm kj kk kl nn kn ko kp no kr ks kt ku im bi translated">注意:下面截图的左侧(LHS)包含执行的查询及其结果。右侧(RHS)包含在执行GraphQL查询时执行的应用程序日志。</p></blockquote><h2 id="95f3" class="oe ls it bd lt of og dn lx oh oi dp mb ki oj ok mf km ol om mj kq on oo mn op bi translated">案例1 —使用帖子数据查询用户</h2><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oq"><img src="../Images/53df2d1202f46da1f26bf3517a6d2bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXcVq1iwLc604tnpFsDmhQ.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">使用用户的帖子数据查询用户数据</figcaption></figure><h2 id="af44" class="oe ls it bd lt of og dn lx oh oi dp mb ki oj ok mf km ol om mj kq on oo mn op bi translated">案例2 —查询没有帖子数据的用户</h2><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oq"><img src="../Images/ef0c0bdf7465fda83c8faafd16fea363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3uEdiMQXGR5gHnMr-qIaw.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">查询没有帖子数据的用户</figcaption></figure><blockquote class="kv"><p id="2113" class="kw kx it bd ky kz or os ot ou ov ku dk translated"><strong class="ak">正如您从日志中看到的，获取帖子的查询总是被执行，不管客户端的查询是什么。也就是说，即使客户端不请求发布数据。</strong></p></blockquote><p id="479f" class="pw-post-body-paragraph jx jy it jz b ka lf kc kd ke lg kg kh ki lh kk kl km li ko kp kq lj ks kt ku im bi translated">那么我们该如何对此进行优化呢？</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="a1b8" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">更好的解决方案</h1><p id="5f1e" class="pw-post-body-paragraph jx jy it jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">GraphQL允许我们解析字段中存在的每个字段。这是我们需要做的。</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3fd2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如您所见，我们正在解析<code class="fe ow ox oy oz b">UserType</code>的字段<code class="fe ow ox oy oz b">posts</code>(这是由<code class="fe ow ox oy oz b">users</code>解析器返回的类型)。这允许GraphQL服务器仅在客户端明确查询该字段时才解析它。</p><h2 id="33cc" class="oe ls it bd lt of og dn lx oh oi dp mb ki oj ok mf km ol om mj kq on oo mn op bi translated">案例1 —使用帖子数据查询用户</h2><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oq"><img src="../Images/5c4f31d83a05f86098137fd97dfaf36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyxcxXERDkbT8L3WZHJtTQ.png"/></div></div></figure><h2 id="9324" class="oe ls it bd lt of og dn lx oh oi dp mb ki oj ok mf km ol om mj kq on oo mn op bi translated">案例2—查询没有帖子数据的用户</h2><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oq"><img src="../Images/d9fcb0eb0b4b2bf1f4139c9e1e19bdfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEGg51ILEYBkQWSCYXjLdg.png"/></div></div></figure><h1 id="d4fc" class="lr ls it bd lt lu np lw lx ly nq ma mb mc nr me mf mg ns mi mj mk nt mm mn mo bi translated">从日志中可以明显看出，当<code class="fe ow ox oy oz b">posts field </code>没有被查询时，获取<code class="fe ow ox oy oz b">posts</code>的查询也没有被执行。</h1><p id="cebb" class="pw-post-body-paragraph jx jy it jz b ka mp kc kd ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku im bi translated">现在，您可能已经注意到，正在执行多个查询来获取帖子。<em class="nl">也就是说，每个用户有一个post查询被触发</em>。这是我们将在下一篇博客中解决的问题。对于好奇的少数人，这里有一个小提示——你可能需要看看<a class="ae pa" href="https://github.com/graphql/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>。</p><p id="d170" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">希望这有用。敬请关注下一篇博客！</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><div class="mv mw mx my gt pb"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">编写面试问题</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">技术开发</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp jv pb"/></div></div></a></div></div></div>    
</body>
</html>