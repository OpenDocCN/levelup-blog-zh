<html>
<head>
<title>CSS at Scale — Public &amp; Private Styles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大规模CSS公共和私有风格</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/css-at-scale-public-private-styles-b5e693080d8d?source=collection_archive---------11-----------------------#2020-04-26">https://levelup.gitconnected.com/css-at-scale-public-private-styles-b5e693080d8d?source=collection_archive---------11-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f1f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提高共享UI组件的通用性，让非开发人员成为样式作者</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/52e66661e3dbcab55d883f3c81b0c081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gxAJROIUP4ensn0h.png"/></div></div></figure><p id="770e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/css-at-scale-cosmetic-vs-layout-properties-a1c8acc875d7">我之前写过一个类似的概念</a>——根据风格是与化妆品相关还是与布局相关来区分风格。这篇文章也许可以被认为是对最初想法的发展。与其按照<em class="lo">化妆品</em>和<em class="lo">布局</em>来思考风格，不如把它们想成<em class="lo">公共</em>和<em class="lo">私人</em>。在这一点上，必须澄清术语“公共”和“私有”是在组件级(或<em class="lo">模块化</em>级)应用的。这意味着(UI)组件可以有公共和/或私有样式。</p><p id="187e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自第一篇文章以来，基本原理没有改变——如果一个CSS属性倾向于根据组件在不同上下文中的实现而改变<em class="lo">,那么它可以被认为是组件的公共样式。如果一个CSS属性不容易改变，无论组件如何使用，它都可以被认为是组件的私有样式。在实践中，几乎可以肯定的是<strong class="kt ir">公共</strong>样式与组件的<em class="lo">外观和感觉</em>相关联，尽管一些私有样式也可能对外观和感觉有所贡献，但几乎可以肯定的是，影响<em class="lo">布局</em>的所有样式都将是<strong class="kt ir">私有</strong>(例如，为什么一个组件在一个上下文中需要位置<code class="fe lp lq lr ls b">relative</code>，而在另一个上下文中需要<code class="fe lp lq lr ls b">absolute</code>？我摸不透)。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/4bff555af67b8da28775613c40f75f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v-jlIyFP2T2wAdXO.png"/></div></div></figure><p id="1347" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的问题是——为什么要将这两套设备放在同一个位置？传统上，思考过程可能是“我需要改变组件的样式，所以我将转到组件的样式文件”。有道理，对吧？但是实际上，有两个主要原因可以解释为什么你想要改变一些现有组件的风格。第一种，是因为你发现了一些bug或者正在开发一个新特性——组件<em class="lo">坏了</em>或者<em class="lo">不完整</em>。第二，是因为你试图让组件看起来<em class="lo">不同</em>，也许是基于一些新的需求或者不同的上下文(以前背景是蓝色的，现在你想把它变成绿色，或者也许你想添加一个边框)——但是它以前不被认为是“坏的”或者“不完整的”。</p><p id="87f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对我来说，我认为这是两个完全独立的任务，可能由两个不同的领域来解决。虽然它们都是传统意义上的“改变组件的风格”，但其中一个可以被认为是开发/编码，另一个也许可以被认为是“配置的改变”(稍后将详细介绍)。在许多系统中，您可以自由地安全地调整一些配置，而不需要新的版本。想象一下，如果您可以安全地更改产品的外观和感觉，而不需要发布新版本，会是什么样子？也许通过采用一种私人和公共风格的哲学，你可以做到。这会不会导致一个世界，非开发人员可以为产品创作100%的公共样式，将“外观和感觉”交给实际“决定”它的人？嗯，这可能有点操之过急了，但想象起来很有趣。</p><h1 id="845e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">不是一个新概念…</h1><p id="6f68" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">顺便说一下，这并不是一个新概念。“裸UI组件”可能是我刚刚现场编造的一个名词，但我还是在野外见过。纯React Carousel 是React的一个非常好的Carousel组件。摘自自述文件:</p><blockquote class="mr ms mt"><p id="12a8" class="kr ks lo kt b ku kv jr kw kx ky ju kz mu lb lc ld mv lf lg lh mw lj lk ll lm ij bi translated">我的目标是创建一个100% ReactJS的carousel，它不试图强加需要被击败的结构或风格，以符合你的站点的设计标准。</p></blockquote><p id="fff4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作者在这里说的是，你必须自己设计转盘，使它符合你的系统的设计标准。它不提供任何开箱即用的“主题化”。那么，这是否意味着它没有任何现成的CSS？如果你回答“是”，你当然是错误的:</p><blockquote class="mr ms mt"><p id="a95e" class="kr ks lo kt b ku kv jr kw kx ky ju kz mu lb lc ld mv lf lg lh mw lj lk ll lm ij bi translated">Pure React Carousel中的组件提供了Carousel正常运行所需的最基本的样式和javascript。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/0166ecc91304edf7ccd96687bce5421b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HrPCihevax81ptTR"/></div></div></figure><p id="f569" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是什么？“造型”…正确“运作”所需？这是什么意思？功能性怎么可能需要样式呢？造型指的是“观感”，不是吗？因此，我写这篇文章的关键是。我们都知道“是的，样式的确会影响功能”，但是我很少看到有人真正区分影响功能的样式和不影响功能的样式。我们已经从<code class="fe lp lq lr ls b">pure-react-carousel</code>的例子中看到，通过拥有私有风格，你可以更容易地创建、共享和主题化UI组件。它们的多功能性显著增加。</p><p id="b4b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种哲学在野外也有一个更明显的例子(这种哲学是公共/私有风格)。你上过他妈的网站吗？如果没有，你就错过了。不过，关键是，尽管网站不包含任何CSS，但页面上的元素之间仍有明显的视觉区别。这是因为web浏览器将合理的默认CSS属性应用于HTML元素。每当你在一个新项目中设计一个裸露的H1元素时，它实际上并不是“裸露”的。它已经应用了浏览器的<em class="lo">私有</em>样式(最有用的属性可能是<code class="fe lp lq lr ls b">display</code>，值为<code class="fe lp lq lr ls b">block</code>)。你在上面添加的任何样式都可以被认为是“公共的”(至少就客户端/浏览器而言)。</p><h1 id="b15c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">到目前为止的总结</h1><p id="a73f" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">当我们考虑将语义HTML标签演变成抽象的可重用React JSX组件时，我们不再需要合并<code class="fe lp lq lr ls b">&lt;section&gt;</code>、<code class="fe lp lq lr ls b">&lt;div&gt;</code>、<code class="fe lp lq lr ls b">&lt;button&gt;</code>等HTML标签。我们可以用<code class="fe lp lq lr ls b">&lt;Slide&gt;</code>、<code class="fe lp lq lr ls b">&lt;Dot&gt;</code>、<code class="fe lp lq lr ls b">&lt;ButtonBack&gt;</code>等提供更多的语义。(摘自<code class="fe lp lq lr ls b">pure-react-carousel</code>)。</p><p id="8f6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如一位智者曾经说过的:语义越多，风格就越私人。也许开箱即用的<code class="fe lp lq lr ls b">&lt;Slide&gt;</code>组件只是一个带有<code class="fe lp lq lr ls b">relative</code>的<code class="fe lp lq lr ls b">position</code>的<code class="fe lp lq lr ls b">&lt;div&gt;</code>，也许<code class="fe lp lq lr ls b">&lt;Dot&gt;</code>组件只是一个带有<code class="fe lp lq lr ls b">50%</code>的<code class="fe lp lq lr ls b">border-radius</code>的<code class="fe lp lq lr ls b">&lt;button&gt;</code>(使其成为一个圆)。这些类型的样式对于它们的组件来说是私有的——它们可能是组件的功能所需要的(比如<code class="fe lp lq lr ls b">&lt;Slide&gt;</code>上的<code class="fe lp lq lr ls b">position</code>属性),或者它们可能是组件具有语义所需要的(比如<code class="fe lp lq lr ls b">&lt;Dot&gt;</code>上的<code class="fe lp lq lr ls b">border-radius</code>属性)。不幸的是，目前这仍然是非常主观的(例如，如果我不希望旋转木马<code class="fe lp lq lr ls b">&lt;Dot&gt;</code>是一个圆呢？为什么还要叫<code class="fe lp lq lr ls b">&lt;Dot&gt;</code>？会不会不是正方形？).</p><h1 id="e163" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">将哲学付诸实践</h1><p id="4662" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">这个概念完全不同于组件库，比如Bootstrap，或者任何其他提供现成主题的UI组件库。拥有一个默认主题在理论上是好的，但是根据我的经验，现有的提供“主题化”组件的组件库并不是那么可扩展或者通用的——在你必须实际编写一些基本代码之前，你实际上在如何“主题化”所提供的组件方面受到了很大的限制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/d62c7ee632cf26b84076fc7b93353a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eHtG2W9hcfak5jgE.jpg"/></div></div></figure><p id="e267" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实证明，当涉及到用户界面组件的主题化时，人们实际上是多功能性的爱好者。<a class="ae ln" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> Tailwind CSS </a>是一个流行的CSS框架，用于快速构建定制设计。摘自他们的主页:</p><blockquote class="mr ms mt"><p id="1a25" class="kr ks lo kt b ku kv jr kw kx ky ju kz mu lb lc ld mv lf lg lh mw lj lk ll lm ij bi translated">Tailwind CSS是一个高度可定制的低级CSS框架，它为您提供了构建定制设计所需的所有构件，而没有您必须努力克服的任何恼人的固执己见的风格。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/5058211481180abec0f71875bb04996a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TndiCHjaVtRXVI37"/></div></div></figure><p id="dceb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，你可以看到，Tailwind CSS和这篇文章中的哲学至少有一个共同的敌人:“令人讨厌的固执己见的风格，你必须努力克服”。Tailwind CSS以一种有趣的方式解决了这个问题。它将责任归咎于试图做“太多”的库本身，它们提供了“各种预先设计的组件，如<em class="lo">按钮</em>、<em class="lo">卡片</em>和<em class="lo">提醒</em>，这些组件可能会在一开始帮助你快速移动，但当涉及到用定制设计让你的网站脱颖而出时，会造成比它们所能治愈的更多的痛苦”。</p><p id="09c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我没有看到Tailwind CSS在组件驱动开发中的位置。一次完成整个页面的原型看起来真的很酷，但是对于实际创建可重用的UI组件，我想它可能不是为此而构建的。</p><p id="678a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">快速回到我个人描述的问题:</p><blockquote class="mr ms mt"><p id="35d4" class="kr ks lo kt b ku kv jr kw kx ky ju kz mu lb lc ld mv lf lg lh mw lj lk ll lm ij bi translated">提供“主题化”组件的组件库不是那么可扩展或通用——在您必须实际编写一些基本代码之前，您实际上在如何“主题化”所提供的组件方面受到很大限制</p></blockquote><p id="552e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对我来说，感觉我和Tailwind CSS在说同样的事情——但我不认为我们必须抛弃提供现成UI组件的概念来解决UI框架的问题，我认为<code class="fe lp lq lr ls b">pure-react-carousel</code>是一个很好的例子来说明如何做到这一点(或者更确切地说，是一个可能在未来的组件库中找到的UI组件的例子)。显然，人们喜欢拥有开箱即用组件的概念，从而产生了Bootstrap和所有曾经存在过的Bootstrap仿冒品；显然，人们喜欢多功能性、灵活性和可扩展性，从而产生了像Tailwind CSS这样的东西。</p><p id="ada2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我梦想有一个我们两者都拥有的世界，正如一位智者曾经说过的:“梦想是我的现实”，我不认为公共/私有风格和裸露的UI组件一定只是一个无聊的UI开发人员被困在锁定中的无意义的漫谈，它们也可能是下一波UI组件库的关键。</p><h2 id="29b0" class="na lv iq bd lw nb nc dn ma nd ne dp me la nf ng mg le nh ni mi li nj nk mk nl bi translated">编码vs配置？</h2><p id="95a7" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在文章的开始，我提到了改变一个组件的公共样式可以被看作是配置而不是编码。这更像是迄今为止所提出的概念的延伸。毕竟，如果你是用CSS创作样式，不管你是创作私有还是公共样式，你仍然是在写“代码”，你仍然需要一个新的版本来做任何改变。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/af6ee19114a7d447e94d9240c8ece6b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CAc7X9r2Vpf_S8TU.jpg"/></div></figure><p id="45b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是理论的终点，我们必须开始审视我们可用技术的能力。我如何告诉我的系统“我希望Accordion Title元素有一个红色背景，除非相应的Panel元素是<em class="lo">打开的，</em>那么它应该有一个绿色背景，除非元素本身是悬浮的，在这种情况下，它应该有一个蓝色背景”而不用编写任何代码，并且Accordion Title元素没有预先存在的任何“背景”属性来映射这些决定？</p><p id="971b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以从同意写配置和写代码(这里是CSS)的区别开始。我可以简单地提议“它必须能够以JSON的形式存在”然后就到此为止，但是一些聪明的人会提出这样的东西:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="94cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的反应会和你一样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/fe1f030ea4a939929468c8b26161f3a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pG-6gBk6LpVQ4wVq.jpg"/></div></div></figure><p id="d0c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…因为虽然我们几乎可以接受CSS-in-JS是一个东西，但CSS-in-JSON只是一个荒谬的概念…但低调地说，它实际上是伪装的解决方案，更像是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7e00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这不是“代码”，它不包含任何CSS，它只是我用尽可能简单的术语告诉我的系统我想要什么。恰好写出来的东西很容易翻译成CSS。我们可以将它提供给一些假设的Accordion组件，甚至不需要组件的源代码包含单词“background”。</p><p id="c7e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，在将风格决策映射到配置文件中的字符串时，我们需要遵循一些实际定义的标准；我们需要一些关于允许使用什么语言的规则(例如“面板是活动的”)，因为毕竟我们仍在与机器通信(当您设置任何配置时就是这种情况)。幸运的是，我已经起草了一个标准，至少对我和我的需求来说是有意义的，它被称为<a class="ae ln" href="https://github.com/One-Nexus/Synergy-Front-End-Guides/wiki/Cell-Query" rel="noopener ugc nofollow" target="_blank">单元格查询</a>，它提供了语言规则(<em class="lo"> CQ表达式</em>，以迎合我曾经面临的任何文体要求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/6ffedc384d10ec42f42df2f9acc84a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRSgOfWSZ7bg4G4IHuFqDg.png"/></div></div></figure><p id="c4ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你为什么想要这个？那么，为什么<em class="lo">不想</em>将CSS逻辑抽象成可读性更强的东西呢？你为什么想要<code class="fe lp lq lr ls b">.panel.open &gt; &amp;</code>而不是<code class="fe lp lq lr ls b">panel-is-open</code>？当你不必担心CSS的复杂性以及类和层叠等问题时，正如我在文章开始时提到的，这不仅减轻了开发人员的负担，还可以让非开发人员控制产品的外观。从各方面考虑，第二个例子的门槛要低得多。需要明确的是，我们在这里只讨论<em class="lo">公共</em>样式——私有样式仍然会使用CSS/Sass/what-have-you之类的代码进行创作。</p><h2 id="8bf7" class="na lv iq bd lw nb nc dn ma nd ne dp me la nf ng mg le nh ni mi li nj nk mk nl bi translated">单一联系</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/0c4342ab4de243e01db2cf9f1d5b563c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h7TPqSZdWJDlT3KX.png"/></div></div></figure><p id="b56b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/esr360/One-Nexus/wiki" rel="noopener ugc nofollow" target="_blank"> One-Nexus </a>是我正在构建的一个框架/库，旨在提供开箱即用的UI组件，如<em class="lo">按钮</em>、<em class="lo">卡片</em>和<em class="lo">提醒</em>，同时也只提供组件正确运行所需的最少样式和javascript。</p><p id="5146" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我甚至不需要自己想出这个描述，我只是从Tailwind和Pure React Carousel描述中复制并粘贴了一些部分，并将它们粘贴在一起。关注我在开发One-Nexus方面的进展，并查看支持One-Nexus组件的底层框架。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/0f4eaa82f76695a20f09ba4fa9fd37ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbifSkjSDCs7zGgIwXMiwg.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated"><a class="ae ln" href="https://twitter.com/esr360" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ln" href="https://github.com/esr360" rel="noopener ugc nofollow" target="_blank"> Github </a></figcaption></figure></div></div>    
</body>
</html>