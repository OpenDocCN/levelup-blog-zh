<html>
<head>
<title>Things every software engineer should know: The builder pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个软件工程师都应该知道的事情:构建器模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/things-every-software-engineer-should-know-the-builder-pattern-d076963f3298?source=collection_archive---------11-----------------------#2020-04-25">https://levelup.gitconnected.com/things-every-software-engineer-should-know-the-builder-pattern-d076963f3298?source=collection_archive---------11-----------------------#2020-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c9828b46eda1fa59475f610a2cfc44bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WoZsV4ekkTIRqobWznMUHw.jpeg"/></div></div></figure><div class=""/><h1 id="a042" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">泰勒:博士</h1><p id="4619" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">builder模式用于创建类，这使得创建类变得更加容易。当构建器创建的类特别大/复杂时，这很有用。构建器的一个主要优势是它们使代码更易于阅读。</p><p id="a83a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">它允许以下对象构造:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8de8" class="mi jz jb me b gy mj mk l ml mm">BookDTO book = new BookDTO(</span><span id="e492" class="mi jz jb me b gy mn mk l ml mm">  "072a36ae-0a6f-46cc-bdc9-aa1dcff38fd5",<br/>  ZonedDateTime.now(),<br/>  null,<br/>  "c0315e90-6faa-40ed-a796-7609a545c5a3",<br/>  "Clean Code: A Handbook of Agile Software Craftsmanship",<br/>  "Very interesting book on how to write your code in a clean way",<br/>  "9788025122853",<br/>  "45bbce25-4d7d-47ac-84d2-6bc7d4202890",<br/>  "Paperback",<br/>  431</span><span id="df8f" class="mi jz jb me b gy mn mk l ml mm">);</span></pre><p id="dbc5" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要写成:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8eb9" class="mi jz jb me b gy mj mk l ml mm">BookDTO book = BookDTOBuilder.builder()<br/>  .withId("072a36ae-0a6f-46cc-bdc9-aa1dcff38fd5")<br/>  .withDateCreated(ZonedDateTime.now())<br/>  .withDateModified(null)<br/>  .withAuthorId("c0315e90-6faa-40ed-a796-7609a545c5a3")<br/>  .withTitle(<br/>    "Clean Code: A Handbook of Agile Software Craftsmanship"<br/>  )<br/>  .withDescription(<br/>    "Very interesting book on how to write your code in a clean way"<br/>  )<br/>  .withISBN("9788025122853")<br/>  .withSeriesId("45bbce25-4d7d-47ac-84d2-6bc7d4202890")<br/>  .withEdition("Paperback")<br/>  .withNumberOfPages(431)<br/>  .build();</span></pre><p id="849a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我看来，它更容易阅读，因为浏览者对创建对象所用的参数有一个更清晰的概念。</p><h1 id="caf9" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">谁死了</h1><p id="0392" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">大家好，我是Doogal，我是Babylon Health的技术负责人，我是doodl.la的创始人，我也花了几年时间从几个非常有才华的人那里学习软件工程，这些故事是我努力向前回报的方式。</p><p id="2b8d" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我担任技术主管期间，我指导了许多新的软件工程师，我发现经常有这样的情况，工程师不知道他们不知道什么。所以这个“每个软件工程师都应该知道的事情”系列是我在做软件的第一年给自己的信息的备忘单。</p><p id="0cc7" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">软件是一个很大的主题，黄金法则是，任何问题的答案都可以从“视情况而定……”开始，因此，这些故事中的信息是不完整的。它试图给出最基本的信息，所以当你读这些故事时，请记住兔子洞比这里展示的主题更深。</p><h1 id="24b3" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题:带有太多参数的构造函数</h1><h2 id="0c89" class="mi jz jb bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">有什么问题？</h2><p id="2002" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有时候当你写一个类的时候，你想创建一个有很多字段的对象，5个，10个，20个，30个，也许更多。同时，您希望保持对象不可变，所以一旦构造好了，您就不希望允许修改它。对于不可变的对象，它应该具有的属性之一是没有任何setters，因为如果您可以在构造后设置字段，那么对象就不再是不可变的。</p><p id="1320" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要在大多数传统语言中创建这个对象，你需要使用一个构造函数，比如说我们在图书领域工作，我们有一个BookDTO，它包含以下字段:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4645" class="mi jz jb me b gy mj mk l ml mm">public BookDTO {</span><span id="e680" class="mi jz jb me b gy mn mk l ml mm">  private String id;<br/>  private ZonedDateTime dateCreated;<br/>  private ZonedDateTime dateModified;<br/>  private String authorId;<br/>  private String title;<br/>  private String description;<br/>  private String isbn;<br/>  private String seriesId;<br/>  private String edition;<br/>  private Integer numberOfPages;</span><span id="973f" class="mi jz jb me b gy mn mk l ml mm">}</span></pre><p id="ab01" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">注意:DTO是指数据传输对象，这些对象通常是为了在应用程序中携带信息而创建的。它们被创建一次，然后在几个地方被读取。</p><p id="41f7" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这个例子中，我们的BookDTO有10个字段，其中大部分是字符串，有些可能为空。当提到构造函数时，它会是这样的:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8e3d" class="mi jz jb me b gy mj mk l ml mm">public BookDTO(</span><span id="034b" class="mi jz jb me b gy mn mk l ml mm">  String id,<br/>  ZonedDateTime dateCreated,<br/>  ZonedDateTime dateModified,<br/>  String authorId,<br/>  String title,<br/>  String description,<br/>  String isbn,<br/>  String seriesId,<br/>  String edition,<br/>  Integer numberOfPages</span><span id="74e6" class="mi jz jb me b gy mn mk l ml mm">) {</span><span id="08a4" class="mi jz jb me b gy mn mk l ml mm">  this.id = id;<br/>  this.dateCreated = dateCreated;<br/>  this.dateModified = dateModified;<br/>  this.authorId = authorId;<br/>  this.title = title;<br/>  this.description = description;<br/>  this.isbn = isbn;<br/>  this.seriesId = seriesId;<br/>  this.edition = edition;<br/>  this.numberOfPages = numberOfPages;</span><span id="4eea" class="mi jz jb me b gy mn mk l ml mm">}</span></pre><h2 id="a24d" class="mi jz jb bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">为什么会有问题？</h2><p id="d66a" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">那么为什么这是一个问题呢？这是一个构造函数，它可以工作，你可以用它来创建你的不可变对象。在一段代码中，这个构造函数可能是这样使用的:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="aca3" class="mi jz jb me b gy mj mk l ml mm">BookDTO book = new BookDTO(</span><span id="44e4" class="mi jz jb me b gy mn mk l ml mm">  "072a36ae-0a6f-46cc-bdc9-aa1dcff38fd5",<br/>  ZonedDateTime.now(),<br/>  null,<br/>  "c0315e90-6faa-40ed-a796-7609a545c5a3",<br/>  "Clean Code: A Handbook of Agile Software Craftsmanship",<br/>  "Very interesting book on how to write your code in a clean way",<br/>  "9788025122853",<br/>  "45bbce25-4d7d-47ac-84d2-6bc7d4202890",<br/>  "Paperback",<br/>  431</span><span id="dd7e" class="mi jz jb me b gy mn mk l ml mm">);</span></pre><p id="1e56" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">或者，更有可能的是，它将通过从某种数据库记录类型对象中提取字段来构造:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6536" class="mi jz jb me b gy mj mk l ml mm">Record record = sqlExecutor.fetchOne(</span><span id="b3ec" class="mi jz jb me b gy mn mk l ml mm">  "SELECT * FROM books WHERE id = ?",<br/>  bookId</span><span id="88d3" class="mi jz jb me b gy mn mk l ml mm">);<br/>BookDTO book = new BookDTO(</span><span id="38b1" class="mi jz jb me b gy mn mk l ml mm">  record.get(0),<br/>  record.get(1),<br/>  record.get(2),<br/>  record.get(3),<br/>  record.get(4),<br/>  record.get(5),<br/>  record.get(6),<br/>  record.get(7),<br/>  record.get(8),<br/>  record.get(9)</span><span id="a724" class="mi jz jb me b gy mn mk l ml mm">);</span></pre><p id="bd04" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">阅读这个可能很困难，更糟糕的是，这种设置很容易出现错误。如果我们在BookDTO中添加一个新的字符串字段会发生什么？我们需要确保将它添加到构造函数调用中，但是如果我们不注意，我们可能会将错误的字符串赋给特定的参数。</p><p id="1c71" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">静态类型语言在这方面帮了你一点忙，但这仍然是个问题。在像Javascript这样的动态类型语言中，这可能是一个更大的问题，因为构造函数会接受你给它的任何东西，如果你没有正确地测试，这可能会导致很难跟踪的错误。</p><h2 id="ff4c" class="mi jz jb bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">经验法则:超过4个参数</h2><p id="6cd3" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">那么对于一个构造函数来说，多少个参数才算多呢？和所有软件一样，答案是“视情况而定…”。需要考虑使用构造函数的具体环境。</p><p id="860a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，当一个构造函数有4个参数时，我就开始问这样一个问题:参数太多了吗？如果已经确定构造函数有太多的参数，解决方法之一是使用构建器模式来构造对象。</p><h1 id="b398" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解决方案:构建器模式</h1><h2 id="3cf9" class="mi jz jb bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">如何实现一个</h2><p id="e11e" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">粗略地说，要创建一个构建器类:</p><ul class=""><li id="2022" class="na nb jb ky b kz lu ld lv lh nc ll nd lp ne lt nf ng nh ni bi translated">创建一个新类，可能命名为类似于“{NameOfTheClassToBuild}Builder”的名称，例如“BookDTOBuilder”。</li><li id="277f" class="na nb jb ky b kz nj ld nk lh nl ll nm lp nn lt nf ng nh ni bi translated">将与将要构建的类中存在的成员相同的成员添加到生成器类中</li><li id="78af" class="na nb jb ky b kz nj ld nk lh nl ll nm lp nn lt nf ng nh ni bi translated">对于每个成员，添加一个设置该成员的方法</li><li id="896f" class="na nb jb ky b kz nj ld nk lh nl ll nm lp nn lt nf ng nh ni bi translated">添加一个build方法，该方法收集所有成员并使用它们调用构造函数。</li></ul><p id="d4f8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以对于我们的书来说，这个看起来像这样:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f6ad" class="mi jz jb me b gy mj mk l ml mm">public BookDTOBuilder {</span><span id="a262" class="mi jz jb me b gy mn mk l ml mm">  private String id;<br/>  private ZonedDateTime dateCreated;<br/>  private ZonedDateTime dateModified;<br/>  private String authorId;<br/>  private String title;<br/>  private String description;<br/>  private String isbn;<br/>  private String seriesId;<br/>  private String edition;<br/>  private Integer numberOfPages;</span><span id="8342" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withId(String id) {</span><span id="fd21" class="mi jz jb me b gy mn mk l ml mm">    this.id = id;<br/>    return this;  </span><span id="d0f0" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="b054" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withDateCreated(ZonedDateTime dateCreated) {</span><span id="194f" class="mi jz jb me b gy mn mk l ml mm">    this.dateCreated = dateCreated;<br/>    return this;</span><span id="436e" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="205f" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withDateModified(<br/>      ZonedDateTime dateModified) {</span><span id="b210" class="mi jz jb me b gy mn mk l ml mm">    this.dateModified = dateModified;<br/>    return this;</span><span id="cb1d" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="62f5" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withAuthorId(String authorId) {</span><span id="68b4" class="mi jz jb me b gy mn mk l ml mm">    this.authorId = authorId;<br/>    return this;</span><span id="db20" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="d90f" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withTitle(String title) {</span><span id="b6e8" class="mi jz jb me b gy mn mk l ml mm">    this.title = title;<br/>    return this;</span><span id="adb8" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="b307" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withDescription(String description) {</span><span id="dcdc" class="mi jz jb me b gy mn mk l ml mm">    this.description = description;<br/>    return this;</span><span id="0e4b" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="b392" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withISBN(String isbn) {</span><span id="b967" class="mi jz jb me b gy mn mk l ml mm">    this.isbn = isbn;<br/>    return this;</span><span id="fbf0" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="f934" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withSeriesId(String seriesId) {</span><span id="0eb3" class="mi jz jb me b gy mn mk l ml mm">    this.seriesId = seriesId;<br/>    return this;</span><span id="0bb5" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="b13d" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withSeriesId(String edition) {</span><span id="6bfa" class="mi jz jb me b gy mn mk l ml mm">    this.edition = edition;<br/>    return this;</span><span id="d5f6" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="1347" class="mi jz jb me b gy mn mk l ml mm">  public BookDTOBuilder withNumberOfPages(Integer numberOfPages) {</span><span id="7759" class="mi jz jb me b gy mn mk l ml mm">    this.numberOfPages = numberOfPages;<br/>    return this;</span><span id="14ce" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="c38e" class="mi jz jb me b gy mn mk l ml mm">  public BookDTO build() {</span><span id="bc0e" class="mi jz jb me b gy mn mk l ml mm">    return new BookDTO(</span><span id="7147" class="mi jz jb me b gy mn mk l ml mm">      id,<br/>      dateCreated,<br/>      dateModified,<br/>      authorId,<br/>      title,<br/>      description,<br/>      isbn,<br/>      seriesId,<br/>      edition,<br/>      numberOfPages</span><span id="5691" class="mi jz jb me b gy mn mk l ml mm">    );</span><span id="da25" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="3962" class="mi jz jb me b gy mn mk l ml mm">  public static BookDTOBuilder builder() {</span><span id="f8f9" class="mi jz jb me b gy mn mk l ml mm">    return new BookDTOBuilder();</span><span id="e0bb" class="mi jz jb me b gy mn mk l ml mm">  }</span><span id="c465" class="mi jz jb me b gy mn mk l ml mm">}</span></pre><p id="2563" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您可能已经注意到，设置成员的方法正在返回构建器的实例，这是一个很好的功能。它允许将这些方法链接在一起。此外，有一个静态方法来构造构建器，这是一个方便，它不是必需的，我只是觉得它更整洁。</p><p id="22e9" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用这些额外功能，您可以更改原本应该写成的内容:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2282" class="mi jz jb me b gy mj mk l ml mm">BookDTOBuilder bookDTOBuilder = new BookDTOBuilder();<br/>bookDTOBuilder.withId(id);<br/>bookDTOBuilder.withDateCreated(dateCreated);<br/>BookDTO bookDTO = bookDTOBuilder.build();</span></pre><p id="05ef" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">变成像这样的东西:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2498" class="mi jz jb me b gy mj mk l ml mm">BookDTO bookDTO = BookDTOBuilder.builder()<br/>  .withId(id)<br/>  .withDateCreated(dateCreated)<br/>  .build();</span></pre><p id="cae5" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在我看来，这更清楚了。</p><h2 id="8a2a" class="mi jz jb bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">优势</h2><p id="a29c" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky jc">命名参数非常容易看到</strong></p><p id="8613" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用builder模式，前面提到的关于从数据库记录构造BookDTO的例子变成了这样:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="af37" class="mi jz jb me b gy mj mk l ml mm">Record record = sqlExecutor.fetchOne(</span><span id="97b9" class="mi jz jb me b gy mn mk l ml mm">"SELECT * FROM books WHERE id = ?",<br/>  bookId</span><span id="bc40" class="mi jz jb me b gy mn mk l ml mm">);<br/>BookDTO book = BookDTOBuilder.builder()<br/>  .withId(record.get(0))<br/>  .withDateCreated(record.get(1))<br/>  .withDateModified(record.get(2))<br/>  .withAuthorId(record.get(3))<br/>  .withTitle(record.get(4))<br/>  .withDescription(record.get(5))<br/>  .withISBN(record.get(6))<br/>  .withSeriesId(record.get(7))<br/>  .withEdition(record.get(8))<br/>  .withNumberOfPages(record.get(9))<br/>  .build();</span></pre><p id="a971" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这使得理解哪些参数与哪些构造函数参数相匹配变得容易得多。至关重要的是，这使得出错和引入意外错误变得更加困难。</p><p id="fa74" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">构建器上的“with”方法可以以任何顺序调用</strong></p><p id="cd7e" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">因此，如果开发人员将它们按不同的顺序排列，也没关系。如果他们在BookDTO的构造函数上这样做，就会导致数据被赋给错误的变量。可以按以下顺序调用构建器，这不会有什么不同:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="232e" class="mi jz jb me b gy mj mk l ml mm">BookDTO book = BookDTOBuilder.builder()<br/>  .withDescription(record.get(5))<br/>  .withISBN(record.get(6))<br/>  .withSeriesId(record.get(7))<br/>  .withEdition(record.get(8))<br/>  .withNumberOfPages(record.get(9))<br/>  .withId(record.get(0))<br/>  .withDateCreated(record.get(1))<br/>  .withDateModified(record.get(2))<br/>  .withAuthorId(record.get(3))<br/>  .withTitle(record.get(4))<br/>  .build();</span></pre><p id="f60f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我建议不要这样做，因为这会使代码更难阅读，因为记录中的参数顺序没有被按顺序调用，但构建器可能会以这种方式调用。</p><p id="7c0a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">可以有任意多的空值</strong></p><p id="dfe8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">由于构建器将只设置调用相关“with”方法的变量，所以您不必显式地将参数设置为null。例如，如果我们的构造函数是这样初始化的:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="673e" class="mi jz jb me b gy mj mk l ml mm">BookDTO book = new BookDTO(</span><span id="68d8" class="mi jz jb me b gy mn mk l ml mm">  "072a36ae-0a6f-46cc-bdc9-aa1dcff38fd5",<br/>  ZonedDateTime.now(),<br/>  null,<br/>  "c0315e90-6faa-40ed-a796-7609a545c5a3",<br/>  null,<br/>  null,<br/>  null,<br/>  "45bbce25-4d7d-47ac-84d2-6bc7d4202890",<br/>  null,<br/>  431</span><span id="4db5" class="mi jz jb me b gy mn mk l ml mm">);</span></pre><p id="5531" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们必须显式地添加所有的空输入，但是使用一个生成器，可以这样做:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="292d" class="mi jz jb me b gy mj mk l ml mm">BookDTO book = BookDTOBuilder.builder()<br/>  .withId("072a36ae-0a6f-46cc-bdc9-aa1dcff38fd5")<br/>  .withDateCreated(ZonedDateTime.now())<br/>  .withAuthorId("c0315e90-6faa-40ed-a796-7609a545c5a3")<br/>  .withSeriesId("45bbce25-4d7d-47ac-84d2-6bc7d4202890")<br/>  .withNumberOfPages(431)<br/>  .build();</span></pre><p id="ad6a" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">可以有更多开发者友好的方法</strong></p><p id="d0e8" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">当我们创建“with”方法时，我们可以添加覆盖常见用例的变体。例如，如果我们在BookDTO中更新了一个版本列表，那么“with”方法可能如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="95b1" class="mi jz jb me b gy mj mk l ml mm">public BookDTOBuilder withEditions(List&lt;String&gt; editions) {</span><span id="dfd0" class="mi jz jb me b gy mn mk l ml mm">  this.editions = editions;<br/>  return this;</span><span id="26dc" class="mi jz jb me b gy mn mk l ml mm">}</span></pre><p id="d19e" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，我们只有一个版本可能是相当常见的，因此，为了帮助开发人员使用这个构建器，可以添加一个新方法以方便使用:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="dff8" class="mi jz jb me b gy mj mk l ml mm">public BookDTOBuilder withEdition(String edition) {</span><span id="54ea" class="mi jz jb me b gy mn mk l ml mm">  this.editions = new ArrayList&lt;String&gt;();<br/>  this.editions.add(edition);<br/>  return this;</span><span id="94c5" class="mi jz jb me b gy mn mk l ml mm">}</span></pre><p id="c278" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用这种方法，复杂对象的构造可以变得更简单。</p><h2 id="7a29" class="mi jz jb bd ka mp mq dn ke mr ms dp ki lh mt mu km ll mv mw kq lp mx my ku mz bi translated">不足之处</h2><p id="a45e" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky jc">实施建设者更是功不可没</strong></p><p id="8f9d" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">仅仅是为这个故事的BookDTO编写构建器就相当耗时。必须为每个类添加一个这样的组件确实会带来很大的开销。手动编写它们也非常繁琐，因为它们非常公式化。</p><p id="a31c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">幸运的是，由于它们公式化的本质，它们变得易于自动化。在java中有一个库叫做<a class="ae mo" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> lombok </a>。它允许通过向类添加注释来为类自动生成构建器。</p><p id="9959" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我不知道Javascript有什么等价的东西，在我写这篇文章的时候，一个为Javascript创建构建器类的想法正在形成。您也许可以开发自己的类，编写一个接受构造函数和字段名列表的类，返回一个包含每个字段名的“with”方法的类，然后调用构造函数。</p><p id="7650" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">要求读者了解构建器模式</strong></p><p id="4a6f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果读者以前没有接触过构建器模式，那么这可能会有点令人不安。希望在阅读完这些方法之后，读者能够很容易地理解这个类的目的。</p><p id="170b" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">建筑商需要测试吗？</strong></p><p id="4702" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">构建器是很多代码，一般来说代码需要测试，那么构建器需要测试吗？就我个人而言，我会说不，他们往往是如此公式化，以至于花时间测试他们是不值得的，但一如既往，它取决于。有些人非常严格地要求测试每一行，在这种情况下，是的，构建者应该被测试。</p><h1 id="325d" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h1><p id="0971" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">构建器模式是一个有用的工具，可以使复杂/大型的类更容易构建。它们使用于构造类的参数更加清晰易读，并允许添加额外的方法来改善开发人员的体验。</p><p id="e7fc" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">缺点是它们需要更多的时间，而且写起来很乏味。幸运的是，有一些工具/库可以自动生成构建器。</p><p id="a096" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">感谢你的阅读，我希望你觉得这个指南有用，我打算在这个系列中增加几个故事，这样对新工程师来说，这是一个真正有用的资源。</p></div></div>    
</body>
</html>