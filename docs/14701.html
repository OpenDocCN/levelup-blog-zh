<html>
<head>
<title>Mocking with GoogleTest (gtest)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GoogleTest (gtest)嘲讽</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mocking-with-googletest-gtest-6dde5230e7aa?source=collection_archive---------5-----------------------#2022-12-19">https://levelup.gitconnected.com/mocking-with-googletest-gtest-6dde5230e7aa?source=collection_archive---------5-----------------------#2022-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dc22" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用C++进行良好的单元测试(第二部分)</h2></div><p id="940f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在之前的一篇文章中，我介绍了用gtest 进行测试的<a class="ae lb" href="https://medium.com/gitconnected/introduction-to-googletest-gtest-1ece21f55d0e" rel="noopener">基础。在这里，我们将研究模仿，这是许多用例的一个强大特性。</a></p><p id="8878" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模拟——顾名思义——描述了模拟某些功能以简化单元测试:主要的例子是昂贵的、难以测试的功能，例如数据库访问、涉及睡眠、等待用户输入的功能等。我们没有将不合理的工作放到单元测试中，而是简单地替换(模仿)有问题的函数。这也有助于封装，并允许“真正的”单元测试，而不是集成测试。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/d295b23ad687f810c230c34b0f2ebbb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgog5ZrmqFhEVRpqCS1HLg.jpeg"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae lb" href="https://www.freepik.com/free-vector/bug-fixing-software-testing-computer-virus-searching-tool-devops-web-optimization-antivirus-app-magnifier-cogwheel-monitor-design-element_12083098.htm#query=software%20testing&amp;position=2&amp;from_view=keyword" rel="noopener ugc nofollow" target="_blank">Freepik上的vectorjuice </a>图片</figcaption></figure><h1 id="3623" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">介绍性示例</h1><p id="f6bb" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们将使用与上一篇文章类似的项目设置，使用Bazel作为构建系统——但是请随意使用您喜欢的任何东西:</p><p id="c871" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">构建</strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="d5b7" class="mu lt iq mq b be mv mw l mx my">cc_library(<br/>    name = "gtest_example",<br/>    srcs = ["gtest_example.cc"],<br/>    hdrs = ["gtest_example.h"],<br/>    visibility = ["//visibility:public"],<br/>    deps = [<br/>        "@com_github_google_glog//:glog",<br/>    ],<br/>)<br/><br/>cc_test(<br/>    name = "gtest_example_test",<br/>    srcs = ["gtest_example_test.cc"],<br/>    deps = [<br/>        ":gtest_example",<br/>        "@com_google_googletest//:gtest_main",<br/>    ],<br/>)</span></pre><p id="1b03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_exampe.h </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="4b02" class="mu lt iq mq b be mv mw l mx my">#pragma once<br/><br/>class ExampleClass {<br/> public:<br/>  void mock_op();<br/><br/> private:<br/>  void foo();<br/>};</span></pre><p id="e65e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.cc </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="00a6" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;chrono&gt;<br/>#include &lt;thread&gt;<br/><br/>#include &lt;glog/logging.h&gt;<br/><br/>void ExampleClass::mock_op() { foo(); }<br/><br/>void ExampleClass::foo() {<br/>  LOG(INFO) &lt;&lt; "Calling foo ...";<br/>  std::this_thread::sleep_for(std::chrono::seconds(10));<br/>  LOG(INFO) &lt;&lt; "... calling foo done.";<br/>}</span></pre><p id="ed48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mz na nb mq b">ExampleClass</code>定义了一个公共函数<code class="fe mz na nb mq b">mock_op()</code>，内部调用私有函数<code class="fe mz na nb mq b">foo()</code>。粗略地看一下，我们假设这个函数是“有问题的”:在这个函数中，我们在返回之前要休眠10秒钟，这是我们不想在单元测试中做的事情→我们想要模拟它。</p><p id="4f03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，首先，这里是常规的单元测试:</p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="0820" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gmock/gmock.h&gt;<br/>#include &lt;gtest/gtest.h&gt;<br/><br/>TEST(ExampleClassTest, TestMockOp) {<br/>  ExampleClass example = ExampleClass();<br/>  example.mock_op();<br/>}</span></pre><h1 id="fb4e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模拟功能</h1><p id="271e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在，为了模仿<code class="fe mz na nb mq b">foo()</code>，我们在一个继承自<code class="fe mz na nb mq b">ExampleClass</code>的类中使用宏<code class="fe mz na nb mq b">MOCK_METHOD</code>:这将使gtest覆盖<code class="fe mz na nb mq b">ExampleClass</code>的<code class="fe mz na nb mq b">foo</code>，并且每当我们调用子类的<code class="fe mz na nb mq b">mock_op</code>时，我们将调用这个修补的函数(现在，它什么也不做):</p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="4926" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gmock/gmock.h&gt;<br/>#include &lt;gtest/gtest.h&gt;<br/><br/>class ExampleClassMocked : public ExampleClass {<br/> public:<br/>  MOCK_METHOD(void, foo, (), (override));<br/>};<br/><br/>TEST(ExampleClassTest, TestMockOp) {<br/>  ExampleClassMocked example = ExampleClassMocked();<br/>  example.mock_op();<br/>}</span></pre><p id="04e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这些改变，我们需要将基类的<code class="fe mz na nb mq b">foo</code>变成虚拟的，因此也要声明一个虚拟析构函数:</p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="5b1e" class="mu lt iq mq b be mv mw l mx my">#pragma once<br/><br/>class ExampleClass {<br/> public:<br/>  virtual ~ExampleClass(){};<br/><br/>  void mock_op();<br/><br/> private:<br/>  virtual void foo();<br/>};</span></pre><p id="426f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行时，我们看到单元测试立即结束，而不是休眠10秒钟。恭喜你，你嘲笑了你的第一个函数！</p><h1 id="f0ee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">定制模拟功能</h1><p id="752e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在这一节中，我们将加入更多的味道，看看如何测试被模仿的函数被正确调用，以及修改它的行为。</p><h2 id="c214" class="nc lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">适当地调用检查函数</h2><p id="c039" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">通过<code class="fe mz na nb mq b">EXPECT_CALL</code>可以检查被模仿的函数是否确实被调用。这是很常见的，因为这种单元测试通常会全面测试一个类的完整接口及其与其他接口的交互——我们希望确保调用了适当的函数。或者，我们可以指定我们期望函数被调用的频率:</p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="7ccb" class="mu lt iq mq b be mv mw l mx my">TEST(ExampleClassTest, TestMockOp) {<br/>  ExampleClassMocked example = ExampleClassMocked();<br/>  EXPECT_CALL(example, foo).Times(1);<br/>  example.mock_op();<br/>}</span></pre><p id="6daa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以进一步检查是否用正确的参数调用了一个函数。为此，我们扩展<code class="fe mz na nb mq b">foo</code>以期待一个参数:</p><p id="bde4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.cc: </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="2aba" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;chrono&gt;<br/>#include &lt;thread&gt;<br/><br/>#include &lt;glog/logging.h&gt;<br/><br/>void ExampleClass::mock_op() { foo(10); }<br/><br/>void ExampleClass::foo(int x) {<br/>  LOG(INFO) &lt;&lt; "Calling foo with ..." &lt;&lt; x;<br/>  std::this_thread::sleep_for(std::chrono::seconds(10));<br/>  LOG(INFO) &lt;&lt; "... calling foo done.";<br/>}</span></pre><p id="7b40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example_test.cc: </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="ac25" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gmock/gmock.h&gt;<br/>#include &lt;gtest/gtest.h&gt;<br/><br/>class ExampleClassMocked : public ExampleClass {<br/> public:<br/>  MOCK_METHOD(void, foo, (int x), (override));<br/>};<br/><br/>TEST(ExampleClassTest, TestMockOp) {<br/>  ExampleClassMocked example = ExampleClassMocked();<br/>  EXPECT_CALL(example, foo(10)).Times(1);<br/>  example.mock_op();<br/>}</span></pre><h2 id="e42b" class="nc lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">从模拟函数返回值</h2><p id="90a1" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">此外，我们可以修改被模仿函数的行为。让我们稍微改变一下我们的设置:我们想要单元测试<code class="fe mz na nb mq b">mock_op</code>，它现在返回一个值——即<code class="fe mz na nb mq b">foo</code>的返回。为了跳过睡眠，但仍然达到正确的结果，我们告诉戏弄<code class="fe mz na nb mq b">foo</code>简单地返回预期:</p><p id="928a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.cc: </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="6948" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;chrono&gt;<br/>#include &lt;thread&gt;<br/><br/>#include &lt;glog/logging.h&gt;<br/><br/>int ExampleClass::mock_op() { return foo(); }<br/><br/>int ExampleClass::foo() {<br/>  LOG(INFO) &lt;&lt; "Calling foo ...";<br/>  std::this_thread::sleep_for(std::chrono::seconds(10));<br/>  LOG(INFO) &lt;&lt; "... calling foo done.";<br/>  return 10;<br/>}</span></pre><p id="a02d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example_test.cc: </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="6aaf" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gmock/gmock.h&gt;<br/>#include &lt;gtest/gtest.h&gt;<br/><br/>class ExampleClassMocked : public ExampleClass {<br/> public:<br/>  MOCK_METHOD(int, foo, (), (override));<br/>};<br/><br/>TEST(ExampleClassTest, TestMockOp) {<br/>  ExampleClassMocked example = ExampleClassMocked();<br/>  EXPECT_CALL(example, foo()).Times(1).WillOnce(::testing::Return(10));<br/>  EXPECT_EQ(example.mock_op(), 10);<br/>}</span></pre><p id="b9c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想让这个例子更有趣/更真实，让我们改变代码s.t. <code class="fe mz na nb mq b">foo</code>接受一个参数作为输入并返回它——相应地，我们修改单元测试中的预期返回:</p><p id="72f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.cc: </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="2c20" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;chrono&gt;<br/>#include &lt;thread&gt;<br/><br/>#include &lt;glog/logging.h&gt;<br/><br/>int ExampleClass::mock_op(int x) { return foo(x); }<br/><br/>int ExampleClass::foo(int x) {<br/>  LOG(INFO) &lt;&lt; "Calling foo with ..." &lt;&lt; x;<br/>  std::this_thread::sleep_for(std::chrono::seconds(10));<br/>  LOG(INFO) &lt;&lt; "... calling foo done.";<br/>  return x;<br/>}</span></pre><p id="5b79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example_test.cc: </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="5846" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gmock/gmock.h&gt;<br/>#include &lt;gtest/gtest.h&gt;<br/><br/>class ExampleClassMocked : public ExampleClass {<br/> public:<br/>  MOCK_METHOD(int, foo, (int x), (override));<br/>};<br/><br/>TEST(ExampleClassTest, TestMockOp) {<br/>  ExampleClassMocked example = ExampleClassMocked();<br/>  EXPECT_CALL(example, foo(11)).Times(1).WillOnce(::testing::ReturnArg&lt;0&gt;());<br/>  EXPECT_EQ(example.mock_op(11), 11);<br/>}</span></pre><h1 id="2092" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将示例重构到专业软件级别</h1><p id="566e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们上面的例子希望有助于引入嘲讽，但这是不好的测试风格，也不会在专业软件项目中以这种形式使用。</p><p id="603b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单元测试应该只覆盖类的公共接口——我们测试类维护它们的契约，并隐藏内部实现。因此，我们不会模仿一个私有函数并测试它是否被正确调用(作为旁注，请注意上面看到的一点“好奇”:<a class="ae lb" href="https://softwareengineering.stackexchange.com/questions/308158/why-does-the-overriding-rule-of-c-not-care-about-visibility-changes" rel="noopener ugc nofollow" target="_blank">在继承的类中改变函数的可见性实际上是正确的C++ </a>)。</p><p id="8014" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，我们可能会模仿另一个类的公共函数——这带来了一些其他有趣的挑战/后果，这也是本节的目标。</p><p id="e962" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们首先重构我们的项目，以反映一个“更好”的设计(“更好”解释为:在专业项目中更容易看到——对于我们的玩具示例来说，将类分开实际上没有意义，但是如上所述，我们不会在实践中编写这样的单元测试):</p><p id="4b9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.h </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="b6f5" class="mu lt iq mq b be mv mw l mx my">#pragma once<br/><br/>class ExampleClassB {<br/> public:<br/>  int foo(int x);<br/>};<br/><br/>class ExampleClassA {<br/> public:<br/>  ExampleClassA(const ExampleClassB&amp; example_class);<br/>  int mock_op(int x);<br/><br/> private:<br/>  ExampleClassB example_class_b_;<br/>};</span></pre><p id="23c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.cc </strong></p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="112d" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;chrono&gt;<br/>#include &lt;thread&gt;<br/><br/>#include &lt;glog/logging.h&gt;<br/><br/>ExampleClassA::ExampleClassA(const ExampleClassB&amp; example_class_b)<br/>    : example_class_b_(example_class_b){};<br/><br/>int ExampleClassA::mock_op(int x) { return example_class_b_.foo(x); }<br/><br/>int ExampleClassB::foo(int x) {<br/>  LOG(INFO) &lt;&lt; "Calling foo with ..." &lt;&lt; x;<br/>  std::this_thread::sleep_for(std::chrono::seconds(10));<br/>  LOG(INFO) &lt;&lt; "... calling foo done.";<br/>  return x;<br/>}</span></pre><p id="7b87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一种常见的模式:通过<a class="ae lb" href="https://stackify.com/oop-concepts-composition/#:~:text=Composition%20is%20one%20of%20the,regularly%20in%20the%20real%20world." rel="noopener ugc nofollow" target="_blank">组合</a> <code class="fe mz na nb mq b">ExampleClassA</code>管理<code class="fe mz na nb mq b">ExampleClassB</code>的一个实例，在<code class="fe mz na nb mq b">mock_op</code>内部调用它的公共方法<code class="fe mz na nb mq b">foo</code>。</p><p id="e990" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，这可以在主文件中使用:</p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="68fd" class="mu lt iq mq b be mv mw l mx my">#include &lt;glog/logging.h&gt;<br/><br/>#include "gtest_samples/gtest_example.h"<br/><br/>int main() {<br/>  ExampleClassA example_class_a = ExampleClassA(ExampleClassB());<br/>  LOG(INFO) &lt;&lt; example_class_a.mock_op(10);<br/>}</span></pre><p id="f947" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们又要嘲弄<code class="fe mz na nb mq b">foo</code>。作为第一次尝试，我们可以简单地这样做:</p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="fd20" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gmock/gmock.h&gt;<br/>#include &lt;gtest/gtest.h&gt;<br/><br/>class ExampleClassBMocked : public ExampleClassB {<br/> public:<br/>  MOCK_METHOD(int, foo, (int x), (override));<br/>};<br/><br/>TEST(ExampleClassTest, TestMockOp) {<br/>  ExampleClassBMocked example_class_b = ExampleClassBMocked();<br/>  ExampleClassA example_class_a = ExampleClassA(example_class_b);<br/>  EXPECT_CALL(example_class_b, foo(11))<br/>      .Times(1)<br/>      .WillOnce(::testing::ReturnArg&lt;0&gt;());<br/>  EXPECT_EQ(example_class_a.mock_op(11), 11);<br/>}</span></pre><p id="499a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是由于C++中的<a class="ae lb" href="https://www.geeksforgeeks.org/object-slicing-in-c/" rel="noopener ugc nofollow" target="_blank">切片</a>，这实际上会调用基类的‘方法，即<code class="fe mz na nb mq b">ExampleClassB::foo</code>！原因是，当进行赋值<code class="fe mz na nb mq b">example_class_b_(example_class_b)</code>时，会产生一个副本，我们最终得到的对象是类型<code class="fe mz na nb mq b">ExampleClassB</code>。这种模式通常是令人讨厌的，会导致一些奇怪和意想不到的行为，因此应该避免。</p><p id="cd7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们改变属性<code class="fe mz na nb mq b">example_class_b_</code>来保存一个指针——这样就避免了切片的问题:</p><pre class="ld le lf lg gt mp mq mr bn ms mt bi"><span id="bbdc" class="mu lt iq mq b be mv mw l mx my">#pragma once<br/><br/>class ExampleClassB {<br/> public:<br/>  virtual ~ExampleClassB(){};<br/><br/>  virtual int foo(int x);<br/>};<br/><br/>class ExampleClassA {<br/> public:<br/>  ExampleClassA(ExampleClassB* example_class);<br/>  int mock_op(int x);<br/><br/> private:<br/>  ExampleClassB* example_class_b_;<br/>};</span></pre><pre class="no mp mq mr bn ms mt bi"><span id="1b6f" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;chrono&gt;<br/>#include &lt;thread&gt;<br/><br/>#include &lt;glog/logging.h&gt;<br/><br/>ExampleClassA::ExampleClassA(ExampleClassB* example_class_b)<br/>    : example_class_b_(example_class_b){};<br/><br/>int ExampleClassA::mock_op(int x) { return example_class_b_-&gt;foo(x); }<br/><br/>int ExampleClassB::foo(int x) {<br/>  LOG(INFO) &lt;&lt; "Calling foo with ..." &lt;&lt; x;<br/>  std::this_thread::sleep_for(std::chrono::seconds(10));<br/>  LOG(INFO) &lt;&lt; "... calling foo done.";<br/>  return x;<br/>}</span></pre><pre class="no mp mq mr bn ms mt bi"><span id="d19a" class="mu lt iq mq b be mv mw l mx my">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gmock/gmock.h&gt;<br/>#include &lt;gtest/gtest.h&gt;<br/><br/>class ExampleClassBMocked : public ExampleClassB {<br/> public:<br/>  MOCK_METHOD(int, foo, (int x), (override));<br/>};<br/><br/>TEST(ExampleClassTest, TestMockOp) {<br/>  ExampleClassBMocked example_class_b = ExampleClassBMocked();<br/>  ExampleClassA example_class_a = ExampleClassA(&amp;example_class_b);<br/>  EXPECT_CALL(example_class_b, foo(11))<br/>      .Times(1)<br/>      .WillOnce(::testing::ReturnArg&lt;0&gt;());<br/>  EXPECT_EQ(example_class_a.mock_op(11), 11);<br/>}</span></pre><h2 id="3222" class="nc lt iq bd lu nd ne dn ly nf ng dp mc ko nh ni me ks nj nk mg kw nl nm mi nn bi translated">观点</h2><p id="ec31" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这就结束了对用gtest模仿的介绍。作为一个离开的评论，我想指出的是<code class="fe mz na nb mq b"><a class="ae lb" href="https://en.cppreference.com/w/cpp/language/abstract_class" rel="noopener ugc nofollow" target="_blank">ExampleClassB</a></code>经常是一个抽象基类——这通常是由于所选软件设计的需要，并且进一步帮助组织所使用的类的关系。</p><p id="6ca0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇文章，如果你喜欢的话——希望你能回来看更多。</p></div></div>    
</body>
</html>