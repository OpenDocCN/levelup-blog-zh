<html>
<head>
<title>x86 Calling Conventions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">x86调用约定</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/x86-calling-conventions-a34812afe097?source=collection_archive---------3-----------------------#2020-01-26">https://levelup.gitconnected.com/x86-calling-conventions-a34812afe097?source=collection_archive---------3-----------------------#2020-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2c789e95da3f05f6c0e3fbfe6356a51a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wf-D-K83UCYFs8176AK8zQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@banestin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">巴特·阿内斯廷</a>在<a class="ae kf" href="https://unsplash.com/s/photos/payphone?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="kg"><p id="8aff" class="kh ki it bd kj kk kl km kn ko kp kq dk translated">" T <!-- -->在x86平台上调用约定的好处是有太多的选择了！"<em class="kr">雷蒙德·陈，微软</em></p></blockquote><p id="365e" class="pw-post-body-paragraph ks kt it ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo kq im bi translated"><strong class="ku iu">调用约定</strong>充当汇编级子程序之间的契约。它们描述了参数传递的方式和位置，以及谁负责清理堆栈。密切相关的考虑因素，如哪些寄存器可以被“破坏”，哪些寄存器必须被保留，以及返回值位于何处，都与特定的应用程序二进制接口(ABI)相关，这是一个更广泛的主题，在此不作讨论。</p><p id="fda6" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">我想，作为一名C/C++开发人员，即使没有真正理解各种调用约定及其细微差别，也有可能拥有一个漫长而充实的职业生涯。毕竟，它们是编译器关心的问题，通常不是开发人员关心的问题(除非您正在进行一些低级别的调试)。</p><p id="66cd" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">作为一名从事二进制目标的逆向工程师，理解调用约定并学习如何在您要逆向的代码中发现它们是很有帮助的。在这里，我们看一些x86调用约定，使它们独特的属性，并查看一些它们反汇编时的样子。</p><h1 id="4d63" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">呼叫者/被呼叫者</h1><p id="864a" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated">你将会看到术语<strong class="ku iu">呼叫者</strong>和<strong class="ku iu">被呼叫者</strong>在这里被大量使用，这可能会有点令人困惑。调用者只是一个<em class="mx">调用另一个函数</em>的函数。被调用者是从另一个函数调用的函数<em class="mx">。考虑下面包含两个函数的C程序，<em class="mx"> main </em>和<em class="mx"> printFavNums </em>。</em></p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/dd8553fbd5f3cccdbdc5f8e76ad0fd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-o8jvC2u08UwNqZkKRNtrQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">说明调用者和被调用者的c代码</figcaption></figure><p id="9388" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">在上面的代码中，<code class="fe nd ne nf ng b">caller</code>是<em class="mx"> main </em>而<code class="fe nd ne nf ng b">callee</code>是<em class="mx"> printFavNums </em>。为什么？因为<em class="mx">main</em>T29】调用另一个函数 ( <em class="mx"> printFavNums </em>)而<em class="mx"> printFavNums </em>是从另一个函数 ( <em class="mx"> main </em>)调用的<strong class="ku iu">。</strong></p><blockquote class="nh ni nj"><p id="25c6" class="ks kt mx ku b kv lp kx ky kz lq lb lc nk lr lf lg nl ls lj lk nm lt ln lo kq im bi translated">如果你想从这篇文章中复制并粘贴代码，请查看Github的要点。那些恶心的源代码图片是由<a class="ae kf" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">碳</a>生成的。❤</p></blockquote><h1 id="9110" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">谁决定使用哪种调用约定？</h1><p id="242f" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated">编译器确定哪个调用约定用于所有函数。然而，许多编译器允许程序员在每个函数的基础上设置特定的调用约定，正如我们在本文中对GCC所做的那样。</p><p id="ba0c" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">重要的是要记住，这些只是约定，编译器可以选择遵守或不遵守任何约定。您会遇到的调用约定通常是编译器设置的默认调用约定的结果，或者是目标平台正式采用的调用约定，比如Win32 API对<code class="fe nd ne nf ng b">stdcall</code>的使用。</p><h1 id="c579" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">x86 (32位)</h1><p id="fe4c" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated">x86体系结构在64位处理器之前就已经采用了许多<strong class="ku iu"><em class="mx"/></strong>调用约定。在这里，我们将了解四种最常见的32位调用约定、它们的定义特征以及它们在英特尔风格反汇编中的外观。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d4e867cee29ad4ce5a1488f65cb4a5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*pfUTK0WPCQzrDpuJgBtBLg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">通用x86调用约定属性</figcaption></figure><h1 id="535a" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">cdecl</h1><p id="a252" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated"><code class="fe nd ne nf ng b">cdecl</code>(发音为<em class="mx"> see-dec-el </em>，简称“C声明”)调用约定非常常见，因为它是当今最流行的编译器的默认x86 (32位)调用约定，包括<a class="ae kf" href="https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html" rel="noopener ugc nofollow" target="_blank"> GCC </a>、<a class="ae kf" href="https://docs.microsoft.com/en-us/cpp/build/reference/gd-gr-gv-gz-calling-convention" rel="noopener ugc nofollow" target="_blank"> MSVC </a>和<a class="ae kf" href="https://llvm.org/docs/LangRef.html#calling-conventions" rel="noopener ugc nofollow" target="_blank"> LLVM </a>。它具有以下属性:</p><ul class=""><li id="8512" class="no np it ku b kv lp kz lq ld nq lh nr ll ns kq nt nu nv nw bi translated">调用方将<em class="mx">所有</em>参数放入堆栈中的被调用方</li><li id="f6c6" class="no np it ku b kv nx kz ny ld nz lh oa ll ob kq nt nu nv nw bi translated">参数从<em class="mx">右向左</em>推至堆栈</li><li id="bee5" class="no np it ku b kv nx kz ny ld nz lh oa ll ob kq nt nu nv nw bi translated">堆栈清理由<em class="mx">调用方</em>执行</li></ul><p id="7832" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">让我们考虑一下前面提到的简单程序。我们不需要显式设置<em class="mx"> cdecl </em>，因为这是GCC的默认调用约定，我们在这里使用的编译器。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/dd8553fbd5f3cccdbdc5f8e76ad0fd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-o8jvC2u08UwNqZkKRNtrQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用GCC编译cdecl的一个例子</figcaption></figure><blockquote class="nh ni nj"><p id="2942" class="ks kt mx ku b kv lp kx ky kz lq lb lc nk lr lf lg nl ls lj lk nm lt ln lo kq im bi translated">这里我们用<code class="fe nd ne nf ng b">-m32</code>告诉GCC我们想要一个32位二进制，用<code class="fe nd ne nf ng b">-mpreferred-stack-boundary=2</code>告诉GCC我们想要2 (4字节)堆栈对齐。我们设置这种堆栈对齐，因为更容易确认谁清理了堆栈。如果不设置该选项，ABI会指示2⁴ (16字节)堆栈对齐，这只会增加不必要的混乱。</p></blockquote><p id="ec7e" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">让我们看看这个简单的程序(只需将<em class="mx"> main </em>和<em class="mx"> printFavNums </em>)与<a class="ae kf" href="https://binary.ninja/" rel="noopener ugc nofollow" target="_blank">Binary ninger</a>拆开，寻找我们期待看到的<em class="mx"> cdecl </em>特性。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3ab7973b886ad61b72630b8b4d1cc89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*YEwdlvX69EUf4Ijf3V-Xaw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">cdecl调用者功能(主)</figcaption></figure><p id="ed7f" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">这里我们可以看到<em class="mx"> main </em>(调用者)正在从右向左将<em class="mx"> printFavNums </em>(被调用者)的参数压入堆栈。它首先推8，然后推2，并调用<em class="mx"> printFavNums </em>。这确认了<em class="mx">‘调用者将被调用者的所有参数放在堆栈上’</em>，<em class="mx">‘参数从右向左推入堆栈’</em>。</p><p id="9799" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">但是最后一个特征呢？谁在清理这里的烟囱？如果您在调用<em class="mx"> printFavNums </em>后立即查看，<em class="mx"> main </em>会清理堆栈帧<code class="fe nd ne nf ng b">(add esp, 0x8)</code>的8个字节，这是传递给被调用者的两个4字节参数。这确认了<em class="mx">调用者，主</em>正在为<em class="mx">被调用者</em>清理堆栈。但是为了确保这里没有什么有趣的事情，让我们看看<em class="mx"> printFavNums </em>。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/60f64f3f8b1f6acb21df7778598a810e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*xAWAcWf0jJRMqUbRLtlU7A.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">cdecl被调用函数</figcaption></figure><p id="c762" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">我们可以看到，<em class="mx"> printf </em>的三个4字节参数从右到左被推到堆栈中，在调用完成后，<em class="mx">调用者printFavNums </em>通过向堆栈指针(esp)添加0xC (12)来为<em class="mx">被调用者</em> (printf)清理堆栈，正如我们对<em class="mx"> cdecl </em>的预期。<em class="mx"> printFavNums </em>在清理堆栈帧时从不考虑自己的参数。这是它的调用者(<em class="mx"> main </em>)在这个约定中要做的。</p><h1 id="7c69" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">快速呼叫</h1><p id="68e2" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated"><code class="fe nd ne nf ng b">fastcall</code>调用约定之所以得名，是因为它比其他在堆栈上传递参数的调用约定更快。在32位系统上，用于参数传递的寄存器数量有限(与x86-64和其他一些具有更多通用寄存器的体系结构相比)。因此，在<em class="mx"> fastcall </em>中，只有前2个参数被寄存器传递，而任何剩余的参数都在堆栈上传递。<em class="mx">快速调用</em>具有以下属性:</p><ul class=""><li id="d36a" class="no np it ku b kv lp kz lq ld nq lh nr ll ns kq nt nu nv nw bi translated">调用者将第一个<em class="mx"> 2参数</em>放入寄存器，其余放入堆栈</li><li id="a5a6" class="no np it ku b kv nx kz ny ld nz lh oa ll ob kq nt nu nv nw bi translated">从右到左<em class="mx">将参数加载到寄存器/推入堆栈</em></li><li id="ca11" class="no np it ku b kv nx kz ny ld nz lh oa ll ob kq nt nu nv nw bi translated">堆栈清理由<em class="mx">被调用者</em>执行</li></ul><p id="cbf9" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">让我们考虑一个与我们之前提到的简单C程序非常相似的程序。这一次我们增加了一个参数，并且我们明确地将<em class="mx"> fastcall </em>设置为一个函数属性(这是GCC特有的语法)。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/eb9f8c1ed80ad3ea6a2fe940790f6fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScelDgZsv80eqVykrOBvxA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用GCC编译fastcall的一个例子</figcaption></figure><p id="bc57" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">让我们看看编译器在这个版本的简单程序中做了什么，再次用<a class="ae kf" href="https://binary.ninja/" rel="noopener ugc nofollow" target="_blank">二进制忍者</a>反汇编。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/9b21e94e4aa333fe9897945ae19b7346.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*YjjZh-GzRoua3Gt305MRcg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">快速呼叫呼叫者功能</figcaption></figure><p id="47d3" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">这里我们可以看到<em class="mx"> main </em>(调用者)正在将最后一个参数推入堆栈，然后将第二个和第一个参数分别加载到<em class="mx"> edx </em>和<em class="mx"> ecx </em>寄存器中。这证实了在<em class="mx"> fastcall </em>中，<em class="mx">调用者将前2个参数放入寄存器中给被调用者，堆栈中的其余参数</em>和<em class="mx">参数从右向左处理</em>。</p><p id="aa99" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">注意在调用<em class="mx"> printFavNums </em>之后<em class="mx"> main没有</em>清理堆栈。让我们看一下<em class="mx"> printFavNums </em>以确保它清理了自己的参数。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e70f73cfb6395ac559f10811a56e0f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*93BqTW58ZzvtLvxUzUlu8A.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">快速调用被调用函数</figcaption></figure><p id="76ae" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">如果我们看下面对<em class="mx"> printf </em>(仍然是<em class="mx"> cdecl </em>)的调用，我们会看到<em class="mx"> printFavNums </em>清理0x10 (16)字节，以说明传递给<em class="mx"> printf </em>的四个4字节参数。但是<em class="mx"> printFavNums </em>在哪里清理它自己的三个4字节参数呢？嗯，记住在<em class="mx">快速调用</em>中，这三个中的两个通过了不需要清理的寄存器。这就只剩下一个4字节的参数需要清理，但是在哪里完成呢？</p><p id="d13a" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated"><em class="mx"> printFavNums </em>函数通过使用0x4的<code class="fe nd ne nf ng b">retn</code>指令的可选操作数来实现这一点。这将导致在返回操作中“清除”额外的4个字节。它看起来肯定与我们目前看到的有很大不同，堆栈指针(<em class="mx"> esp </em>)被直接操作，但效果是一样的。因此，<em class="mx">被调用者</em>在自身之后进行清理。</p><h1 id="62a5" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">stdcall</h1><p id="af34" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated"><code class="fe nd ne nf ng b">stdcall</code>(“标准调用”的缩写)是一种常见的x86调用约定，类似于<code class="fe nd ne nf ng b">cdecl</code>，但是<em class="mx">被调用方</em>负责从堆栈中清除自己的参数。如果你曾经做过Windows开发，你可能知道这个调用约定为<code class="fe nd ne nf ng b">WINAPI</code>，它只是在<code class="fe nd ne nf ng b">windef.h</code> ( <code class="fe nd ne nf ng b">#define WINAPI __stdcall</code>)中设置的<em class="mx"> stdcall </em>的别名。该调用约定具有以下属性:</p><ul class=""><li id="0ef5" class="no np it ku b kv lp kz lq ld nq lh nr ll ns kq nt nu nv nw bi translated">调用者将<em class="mx">所有</em>被调用者的参数放在堆栈上</li><li id="29a7" class="no np it ku b kv nx kz ny ld nz lh oa ll ob kq nt nu nv nw bi translated">参数从右到左从<em class="mx">推入堆栈</em></li><li id="4514" class="no np it ku b kv nx kz ny ld nz lh oa ll ob kq nt nu nv nw bi translated">堆栈清理由<em class="mx">被调用者</em>执行</li></ul><p id="3353" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">让我们考虑一下我们一直在使用的同一个简单的C程序，这次为<em class="mx"> printFavNums </em>设置了<em class="mx"> stdcall </em>。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/c91133f51400915737b01a5b0023093b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2upzYvpWMbDQO4Xv2ixi5w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用GCC编译stdcall的例子</figcaption></figure><p id="c083" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">现在让我们来看看我们的两个反汇编函数。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/133daa81b338442b3db66d16224640da.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*unmQZ-7fblWZbeKfRdWvKw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">stdcall调用程序函数</figcaption></figure><p id="2774" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">正如我们所料，<em class="mx"> main </em>将<em class="mx"> printFavNums </em>的参数从右向左推入堆栈。请注意<em class="mx"> main </em>在调用<em class="mx"> printFavNums </em>后没有清理堆栈。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/30b35bb4e038d20d85f2e5a709da6f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*mpcmwuqJA4DUiWrqWfMuFg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">stdcall被调用方函数</figcaption></figure><p id="85e7" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">在<em class="mx"> printFavNums </em>中我们可以看到<code class="fe nd ne nf ng b">retn 0x8</code>，它解释了传递给这个函数的两个4字节参数。正如我们所预料的，这个<em class="mx"> stdcall </em>函数会自动清理。</p><h1 id="284e" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">这通电话</h1><p id="1cb7" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated"><code class="fe nd ne nf ng b">thiscall</code>呼叫约定是一个非常有趣的东西。它旨在用于需要引用其“this指针”的C++类成员函数，以便该函数可以访问类实例变量。以下是此调用约定的属性:</p><ul class=""><li id="1587" class="no np it ku b kv lp kz lq ld nq lh nr ll ns kq nt nu nv nw bi translated">参数从右到左从<em class="mx">压入堆栈</em></li><li id="f720" class="no np it ku b kv nx kz ny ld nz lh oa ll ob kq nt nu nv nw bi translated">这个指针通过ECX寄存器传递给被调用者</li><li id="5b8c" class="no np it ku b kv nx kz ny ld nz lh oa ll ob kq nt nu nv nw bi translated">堆栈清理由<em class="mx">被调用者</em>执行</li></ul><p id="d4a4" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">让我们考虑一下我们一直使用的C程序的C++版本，其中<em class="mx"> printFavNums </em>是<em class="mx"> FavoriteNumbers </em>类的成员。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/cb1bd12d74d12796c37d10e336313311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*329xM4HOxlSPy99MBYPXXw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一个只有一个成员函数的C++类</figcaption></figure><p id="c580" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">基于我所阅读和了解的关于<code class="fe nd ne nf ng b">thiscall</code>的一切，GCC <em class="mx">应该</em>让<em class="mx"> printFavNums </em>成为<code class="fe nd ne nf ng b">thiscall</code>函数，因为我们正在调用一个C++类成员函数，它需要访问自己的实例变量。所以让我们看看…</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e15a12b8646fd73567126cb0fb621e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*IkB9u6lrYaD1l1y7-VCu-g.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">GCC使printFavNums成为cdecl调用，并将“this pointer”作为第一个参数注入</figcaption></figure><p id="8318" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">等一下。<em class="mx"> ecx </em>寄存器没有被用于<em class="mx"> this </em>指针，并且堆栈显然正在被<em class="mx">调用者(main) </em>清除。<em class="mx"> printFavNums </em>符合对<em class="mx"> cdecl </em>的描述。这里发生了什么？</p><p id="afaf" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">原来<code class="fe nd ne nf ng b">g++</code>(GCC的C++编译器命令)使这个函数成为了<em class="mx"> cdecl </em>函数，但是插入了<em class="mx"> this指针</em>作为<em class="mx"> pritnFavNums的第一个参数。所以这个函数在编译时被赋予了三个参数，尽管C++原型只有两个！</em></p><blockquote class="nh ni nj"><p id="5a46" class="ks kt mx ku b kv lp kx ky kz lq lb lc nk lr lf lg nl ls lj lk nm lt ln lo kq im bi translated">网上和书中有很多信息告诉你这种呼叫有两种版本。一份给海湾合作委员会，一份给MSVC。这可以从两个方面来考虑；1.这个调用有两个不同的版本，2。默认情况下，GCC使用cdecl代替thiscall，注入隐含的“this pointer”作为第一个参数。</p></blockquote><p id="76a2" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">这两种描述都是可以接受的，我个人喜欢用第二种来理解这里发生的事情。GCC与<em class="mx"> thiscall </em>的时髦业务可以追溯到4.7.0⁴版本，开发者从一种形式转换到另一种形式，试图变得与MSVC实现的<em class="mx"> thiscall </em>更加兼容。</p><p id="3a8b" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">这使得problems⁵的开发者们没有预料到这种变化。最终，GCC切换回他们自己的方式——但是增加了一个<em class="mx"> thiscall </em>函数attribute⁶，允许开发人员强制<em class="mx"> thiscall </em>而不是GCC奇怪的“cdecl with injected<em class="mx">this</em>pointer”约定。</p><p id="3ef2" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">让我们使用相同的代码，但是这次我们将使用GCC函数属性<em class="mx">显式地</em>设置<em class="mx"> printFavNums </em>为<code class="fe nd ne nf ng b">thiscall</code>。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/01ab2d6398831157e0982faa5388893b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pb5aaWKM9Xf1BVK7Np7lew.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">请注意printFavNumers方法上的显式属性修饰符</figcaption></figure><p id="761b" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">现在我们来编译反汇编一下，看看这次发生了什么。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d568f002c737d9f3ec225b7716bcc200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*zODI5e8zqmfnjovL8n3zyQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在我们显式地设置了fastcall属性之后，GCC屈从于我们的意志</figcaption></figure><p id="3e43" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">这还差不多！<em class="mx"> printFavNums </em>函数在堆栈上传递两个参数，并且在调用之前用<em class="mx"> this指针</em>加载<em class="mx"> ecx </em>。我们还可以看到<em class="mx"> main </em>在调用<em class="mx"> printFavNums </em>之后并没有清理堆栈。<em class="mx"> printFavNums </em>现在是一个<em class="mx"> thiscall </em>函数！</p><h1 id="123b" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">特殊考虑</h1><p id="4591" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated">调用约定的主题在某些情况下会变得复杂(这个调用已经够糟糕的了)。在许多情况下，到目前为止提供的信息都是正确的，但是在某些情况下，您必须考虑一些问题。这里我们讨论一些特殊情况。</p><h1 id="fa76" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">可变参数函数</h1><p id="d4e7" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated">在本文中，您已经了解了一些“被调用者清理”的调用约定，这意味着<em class="mx">被调用者</em>自己清理堆栈，但是有一个问题。<em class="mx">被调用者</em> <strong class="ku iu">无法</strong>清理他们自己的堆栈，如果他们被传递了可变数量的参数！</p><p id="b2d5" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">可变参数函数(也称为“vararg”或“variadic”函数)是接受可变数量参数的函数。下面给出了一个vararg函数的例子。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/4db8f98a0f14267f0276d18306f206e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSiF1-1avD2xp4oFJPHtCQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一个C语言中的变量函数例子，没有属性修饰符</figcaption></figure><p id="5d6d" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">上面的代码编译起来没有问题，因为默认的调用约定是<em class="mx"> cdecl </em>，一个<em class="mx">调用者清理</em>约定。然而，如果我们试图将这个函数设置为我们已经学过的任何一个<em class="mx">被调用者清理</em>函数，比如说<em class="mx"> stdcall </em> …</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/cce788e378becd3e51ba14c75a5148c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AsD0MD733RzHlGEtBqj6dQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">一个C语言中的变量函数例子，带有一个stdcall属性修饰符</figcaption></figure><p id="59ca" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">…编译器将抛出一个警告并退回到<em class="mx"> cdecl </em>，因为它不能使一个可变函数成为一个<em class="mx">被调用方</em>清理约定。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/e278887483bff2f9d549d34a6e23f3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TT00tjl0is_IKO0ZFmOzxw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">GCC吼我们是因为编译器开发者永远是对的:)</figcaption></figure><p id="467a" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">那么为什么可变被调用者不能清理自己的栈呢？难道他们就不能在返回前动态调整堆栈指针，或者用<em class="mx"> retn X </em>清理吗？</p><p id="ab32" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">在编译时，可变的被调用方不知道它可以传递多少个参数。它可能是零，一百，或其他任何值。所以编译器无法确定有效的堆栈清理策略。</p><p id="cb09" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">理论上，可变函数可以被编译器修改来动态解析它自己的参数数量和大小，然后清理它自己的堆栈吗？在大多数情况下，我相信是这样的。但是想到可能的边缘情况以及如何正式验证这一点，我就头疼。有了调用者和被调用者都可用的清理约定，当存在更简单的解决方案时，再经历所有这些麻烦就没有意义了；只是不要对变量函数使用调用者清理约定。</p><h1 id="42b6" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">随时打这个电话！</h1><p id="01e5" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated">因此，我们了解了<em class="mx"> thiscall </em>的预期用途，它将用于需要访问自己的类实例的C++类成员函数。但是<em class="mx">这个call </em>可以用在任何你想用的地方(当使用GCC的时候)。事实上，这段代码完全有效。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/4e4aa9ffc179e67d61c4a68f3613a1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zo0DcGHEhVA3PKJogwbHuA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在看不到C++类的情况下向GCC请求这个调用</figcaption></figure><p id="bd05" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">你可能会认为编译器(这里是GCC 5.4.0)会抱怨。这甚至不是C++，这里也没有类。为什么我们需要这个调用呢？但它工作，检查拆卸。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/bfcecef5f83082703cab6838f825b396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*mU9cxQyARmO4KdGTV6gyCA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">GCC将一个标准的C函数称为thiscall</figcaption></figure><p id="ad6d" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">由于没有<em class="mx">这个指针</em>，编译器通过栈上的<em class="mx"> ecx </em>和arg2传递arg1。正如我们在<em class="mx"> thiscall </em>函数中所预期的，被调用方<em class="mx">正在从堆栈中清除自己的参数。这种疯狂是GCC扩展的一部分，它允许这种情况发生在occur⁷.</em></p><h1 id="0d9a" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h1><p id="e7ec" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated">我希望您喜欢这篇关于常见x86调用约定的文章，并且您可以想象在每种情况下C到汇编的转换。还有一些特殊的调用约定我们没有在这里讨论，比如pascal、optlink、safecall等等。说实话，我是因为<a class="ae kf" href="https://en.wikipedia.org/wiki/X86_calling_conventions" rel="noopener ugc nofollow" target="_blank">维基百科</a>才知道这些的。我想在我的职业生涯中从来没有遇到过他们。</p><p id="176c" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">作为一名专业的逆向工程师，我已经做了很多年了，却从来没有在白板上写过这些东西。我知道x86调用约定之间的一些一般差异，但我从未花时间真正坐下来研究这个主题。</p><p id="1276" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">然而，在今天的现代x86–64系统中，调用约定实际上是我生活中每个工作日都必须考虑的事情。理解Windows和System-V ABI之间微妙但非常重要的差异在x86–64逆向工程过程中至关重要，我将在以后关于x86–64调用约定的文章中解释原因。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="88f0" class="lu lv it bd lw lx or lz ma mb os md me mf ot mh mi mj ou ml mm mn ov mp mq mr bi translated"><strong class="ak">脚注&amp;参考文献</strong></h1><p id="1e2e" class="pw-post-body-paragraph ks kt it ku b kv ms kx ky kz mt lb lc ld mu lf lg lh mv lj lk ll mw ln lo kq im bi translated">[1]维基百科，<a class="ae kf" href="https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall" rel="noopener ugc nofollow" target="_blank"> x86调用约定，thiscall </a>。</p><p id="392c" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">[2]: Ownedcore，魔兽世界，魔兽世界机器人和程序，WoW内存编辑。<a class="ae kf" href="https://www.ownedcore.com/forums/world-of-warcraft/world-of-warcraft-bots-programs/wow-memory-editing/281008-gcc-thiscall-calling-convention-linux-win32-mingw.html" rel="noopener ugc nofollow" target="_blank"><em class="mx">GCC“this call”调用约定【Linux/Win32 MinGW】</em></a><em class="mx">。</em></p><p id="8a9f" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">[3]: <a class="ae kf" href="https://books.google.com/books?id=_wucDwAAQBAJ&amp;pg=PA25&amp;lpg=PA25&amp;dq=gcc+and+thiscall&amp;source=bl&amp;ots=UEczyFq1Mk&amp;sig=ACfU3U1Txd1IobjPPBaIoE5PKc6Tr2-eog&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjiyPqg_aDnAhVNHc0KHZW_A_IQ6AEwEHoECAoQAQ#v=onepage&amp;q=gcc%20and%20thiscall&amp;f=false" rel="noopener ugc nofollow" target="_blank">掌握恶意软件分析</a>，Alexey Kleymenov，Amr Thabet，Packt Publishing，第25页:“在GCC编译器中，这个调用几乎与cdecl调用约定相同，它将对象地址作为第一个参数传递。但在微软C++编译器中，它类似于stdcall，在ecx中传递对象地址。”</p><p id="8621" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">[4]: <a class="ae kf" href="https://gcc-help.gcc.gnu.narkive.com/z7It0S03/how-to-disable-thiscall-on-mingw-gcc-4-7-x" rel="noopener ugc nofollow" target="_blank"> GCC 4.7发布系列<em class="mx">变更、新特性和修复。</em> </a> <em class="mx"> " </em> Windows x86目标使用C++类成员函数的<code class="fe nd ne nf ng b">__thiscall</code>调用约定。<em class="mx"/></p><p id="c552" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">[5]: Narkive Mailinglist Archive，"<a class="ae kf" href="https://gcc-help.gcc.gnu.narkive.com/z7It0S03/how-to-disable-thiscall-on-mingw-gcc-4-7-x" rel="noopener ugc nofollow" target="_blank">如何在MinGW-gcc-4.7.x上禁用__thiscall？</a>”。</p><p id="bab9" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">[6]: <a class="ae kf" href="https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> 6.33.34 x86函数属性</em> </a>，<em class="mx"> thiscall </em>。</p><p id="8dd8" class="pw-post-body-paragraph ks kt it ku b kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll lt ln lo kq im bi translated">[7]:来自GCC文档<a class="ae kf" href="https://gcc.gnu.org/onlinedocs/gcc/x86-Function-Attributes.html" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> 6.33.34 x86函数属性</em> </a>:“在x86–32目标上，<code class="fe nd ne nf ng b">thiscall</code>属性导致编译器传递寄存器ECX中的第一个参数(如果是整型的话)。[...] <strong class="ku iu">作为GCC的扩展，这个调用约定可以用于C函数和静态成员方法。</strong></p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><blockquote class="nh ni nj"><p id="6c13" class="ks kt mx ku b kv lp kx ky kz lq lb lc nk lr lf lg nl ls lj lk nm lt ln lo kq im bi translated">关于作者</p><p id="fcf4" class="ks kt mx ku b kv lp kx ky kz lq lb lc nk lr lf lg nl ls lj lk nm lt ln lo kq im bi translated">John Toterhi是Battelle Memorial Institute的安全研究员，他专门研究逆向工程、漏洞研究和工具开发。当他不是一个电脑迷时，他可能会培养一个新的爱好或者讲一些坏爸爸的笑话。你可以在<a class="ae kf" href="https://www.linkedin.com/in/john-toterhi/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae kf" href="https://github.com/cetfor" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae kf" href="https://twitter.com/cetfor" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kf" href="https://medium.com/@cetfor" rel="noopener"> Medium </a>上与约翰联系。</p></blockquote></div></div>    
</body>
</html>