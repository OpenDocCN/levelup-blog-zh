<html>
<head>
<title>Java: Developing smaller Docker images with jdeps and jlink</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java:用jdeps和jlink开发更小的Docker图像</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-developing-smaller-docker-images-with-jdeps-and-jlink-d4278718c550?source=collection_archive---------2-----------------------#2021-05-09">https://levelup.gitconnected.com/java-developing-smaller-docker-images-with-jdeps-and-jlink-d4278718c550?source=collection_archive---------2-----------------------#2021-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="53d7" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><em class="iq">技术栈:Java 17，Docker，Gradle </em></p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/6d3eb1fd123dc1fdae77188a704cccba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nl4XXKPC9mpQjjyTGV7Vjw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图1:用Java构建较小的Docker映像时创建定制JRE的管道。</figcaption></figure><p id="3841" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">随着容器和不可变基础设施的兴起，拥有大型动态虚拟机的一些好处已经丧失。不再需要有一个可以运行任何Java应用程序的扩展的运行时，因为您现在可以使用自己的环境测试和发布您的应用程序，从JVM一直到OS。您也倾向于确切地知道您的应用程序将使用运行时的哪些部分；当我们运行一个服务器端应用程序时，为什么我们要包含(甚至要考虑)Java Swing库呢？</p><p id="1993" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">所有这些都意味着，与一些更具云原生特性的替代方案相比，Java可能会显得有些臃肿和困难。那么，我们如何才能运送更小、更轻量级的容器，只包含我们运行应用程序明确需要的东西，同时仍然从Java生态系统中受益呢？</p><p id="1054" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这是2个新工具被创建并随JDK一起发布的地方:<strong class="jt ir"> jdeps </strong>和<strong class="jt ir"> jlink </strong>。</p><blockquote class="jn jo jp"><p id="37fc" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">Jdeps 负责分析JAR及其依赖项，并识别运行应用程序所需的JVM部分。它可以将其输出到一个文本文件，然后由<strong class="jt ir"> jlink </strong>使用。</p><p id="a31b" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">Jlink 获取一个JVM模块列表，并构建一个定制的JVM，只包含那些存在的部分。根据您的应用程序，这显然可以削减运行时的大部分，减少您的总体Docker图像大小。</p></blockquote><p id="ed47" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在本指南的其余部分，我们将执行以下操作:</p><ol class=""><li id="70dd" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko ln lo lp lq bi translated">设置一个Gradle项目，其中我们构建并打包了一个Java应用程序。</li><li id="834b" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">将Docker与Gradle集成，这样我们就可以使用Gradle工具来构建我们的应用程序。</li><li id="1043" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko ln lo lp lq bi translated">构建一个多阶段Docker文件，利用jdeps和jlink来显著减小我们最终的Docker图像大小。</li></ol></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="2f0e" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lg mp mq mr lh ms mt mu mv bi translated">步骤1:创建起始Gradle项目</h2><blockquote class="jn jo jp"><p id="95ba" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">确保您已经安装了gradle，或者已经有了gradle项目设置。</p></blockquote><p id="c7cc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">首先，我们将创建一个空的Gradle项目，然后构建docker文件来打包并运行一个简单的命令行应用程序。</p><p id="6517" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">为要存储的应用程序创建一个文件夹，然后从文件夹位置的终端运行以下命令:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="5181" class="md me iq mx b gy nb nc l nd ne">gradle init --type java-application</span></pre><p id="1845" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这将为您提供几个选项。对本指南来说，没有什么太重要的，但这里是我选择的参考。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/609fca7610e0377e86a33c5323344fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*RL26M-RIuKYhnkEwx6fMxQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图2:创建一个空的gradle项目。选择Groovy、JUnit Jupiter和一个项目名test-app。</figcaption></figure><p id="e4f1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">以此为起点，转到<strong class="jt ir"> build.gradle </strong>文件，并将此起始代码复制到:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="6ff1" class="md me iq mx b gy nb nc l nd ne">plugins <strong class="mx ir">{<br/>    </strong>id 'java-library'<br/><strong class="mx ir">}<br/><br/></strong>sourceCompatibility = '11'<br/>version = '1.0.0'</span><span id="208b" class="md me iq mx b gy ng nc l nd ne">repositories <strong class="mx ir">{<br/>    </strong>mavenCentral()<br/>    mavenLocal()<br/><strong class="mx ir">}<br/><br/></strong>dependencies <strong class="mx ir">{<br/>    </strong>implementation 'org.slf4j:slf4j-api:1.7.30'<br/>    implementation 'org.apache.logging.log4j:log4j-api:2.11.1'<br/>    implementation 'org.apache.logging.log4j:log4j-core:2.11.1'<br/>    implementation 'org.apache.logging.log4j:log4j-slf4j-impl:2.11.1'<br/><br/>    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.2'<br/>    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'<br/><strong class="mx ir">}<br/><br/></strong>tasks.named('test') <strong class="mx ir">{<br/>    </strong>// Use junit platform for unit tests.<br/>    useJUnitPlatform()<br/><strong class="mx ir">}</strong></span></pre><p id="5e0a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">上述代码执行以下操作:</p><ul class=""><li id="237f" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko nh lo lp lq bi translated">提供与Gradle的基本Java兼容性。</li><li id="e921" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">添加log4j依赖项，这样当我们在以后的步骤中运行jdeps时，我们就有了要分析的依赖项。</li></ul><p id="2de0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">要在我们的应用程序中使用log4j，请转到<strong class="jt ir"> app/src/main/resources </strong>并添加以下<strong class="jt ir"> log4j2.xml </strong>文件:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="bdd8" class="md me iq mx b gy nb nc l nd ne">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;Configuration status="WARN"&gt;<br/>    &lt;Appenders&gt;<br/>        &lt;Console name="Console" target="SYSTEM_OUT"&gt;<br/>            &lt;PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/&gt;<br/>        &lt;/Console&gt;<br/>    &lt;/Appenders&gt;<br/>    &lt;Loggers&gt;<br/>        &lt;Root level="INFO"&gt;<br/>            &lt;AppenderRef ref="Console"/&gt;<br/>        &lt;/Root&gt;<br/>    &lt;/Loggers&gt;<br/>&lt;/Configuration&gt;</span></pre><p id="ebaa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这意味着当我们添加任何信息级别的日志时，它们都会出现在控制台中。</p><p id="a5df" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">最后，进入<strong class="jt ir"> src/main/java/…/App.java </strong>，添加以下内容:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="7a2b" class="md me iq mx b gy nb nc l nd ne">package test.app;<br/><br/>import org.slf4j.Logger;<br/>import org.slf4j.LoggerFactory;<br/><br/>public class App {<br/><br/>    private static final Logger <em class="js">LOG </em>= LoggerFactory.<em class="js">getLogger</em>(App.class);<br/><br/>    public String getGreeting() {<br/>        return "Hello World!";<br/>    }<br/><br/>    public static void main(String[] args) {<br/>        <em class="js">LOG</em>.info("hello, the application has started");<br/><br/>        <em class="js">LOG</em>.error(new App().getGreeting());<br/><br/>        <em class="js">LOG</em>.info("the application is now complete");<br/>    }<br/>}</span></pre><p id="8abd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这意味着当我们运行我们的应用程序时，结合我们的log4j配置，我们将在退出之前向控制台打印一些消息。</p><p id="86a3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">实施这些更改后，您应该能够运行以下命令:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="892c" class="md me iq mx b gy nb nc l nd ne">./gradlew clean check</span></pre><p id="99ff" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">您应该会看到一个不错的“BUILD SUCCESSFUL”消息，这意味着您已经正确地初始化了起始项目，我们已经准备好继续构建一个可执行的JAR了。</p><h2 id="4e9d" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lg mp mq mr lh ms mt mu mv bi translated">步骤2:创建可执行的JAR</h2><p id="e0db" class="pw-post-body-paragraph jq jr iq jt b ju ni jw jx jy nj ka kb lf nk ke kf lg nl ki kj lh nm km kn ko ij bi translated">为了使用jdeps，对于本指南，我们需要将我们的应用程序打包成一个可执行的JAR。然后，我们需要将它的所有依赖项复制到一个单独的文件夹中。</p><p id="8f46" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">为此，将以下任务添加到您的<strong class="jt ir"> build.gradle </strong>文件中:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="e3d0" class="md me iq mx b gy nb nc l nd ne">// copies all the jar dependencies your app needs to the lib folder<br/>task copyDependencies(type: Copy) <strong class="mx ir">{<br/>    </strong>from configurations.runtimeClasspath<br/>    into "$buildDir/lib"<br/><strong class="mx ir">}<br/><br/></strong>// creates your manifest file within the JAR<br/>jar <strong class="mx ir">{<br/>    </strong>manifest <strong class="mx ir">{<br/>        </strong>attributes["Main-Class"] = "test.app.App"<br/>        attributes["Class-Path"] = configurations.runtimeClasspath.collect <strong class="mx ir">{ </strong>'lib/' + it.getName() <strong class="mx ir">}</strong>.join(' ')<br/>    <strong class="mx ir">}<br/>}</strong></span></pre><p id="72d4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这将执行以下操作:</p><ul class=""><li id="18b6" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko nh lo lp lq bi translated">将所有应用程序依赖项复制到<strong class="jt ir"> app/build/lib </strong>目录。这意味着当我们想要运行jdeps时，我们可以告诉它在解析依赖项时要使用的文件夹。</li><li id="98cf" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">将jar中的主类设置为保存主方法的类。如果您创建了不同的包结构，请确保将其更新以匹配。</li><li id="b9cc" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">设置jar的类路径，因此当这个JAR运行时，它将在<strong class="jt ir"> lib/ </strong>文件夹中寻找依赖项。这意味着我们不构建一个胖jar，而是设置可以找到所有外部jar的位置，然后在运行时和运行jdeps工具时使用这个位置。</li></ul><p id="ec5d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">有了这个设置，我们就可以开始集成Docker了。</p><h2 id="8993" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lg mp mq mr lh ms mt mu mv bi translated">步骤3:集成Docker</h2><p id="fa01" class="pw-post-body-paragraph jq jr iq jt b ju ni jw jx jy nj ka kb lf nk ke kf lg nl ki kj lh nm km kn ko ij bi translated">将Docker集成到我们的应用程序中的第一步是提供一种将docker build命令作为Gradle任务运行的方法。这意味着我们可以使用Gradle来确保依赖步骤在docker被调用之前被执行(例如，确保JAR和依赖项被构建并复制到正确的位置，然后被复制到Docker映像中)。</p><p id="13df" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">为此，将以下任务添加到您的<strong class="jt ir"> build.gradle </strong>文件中:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="5cd2" class="md me iq mx b gy nb nc l nd ne">// builds the docker image, tagging it with the same group id, name, and version as the JAR<br/>task buildDocker(type: Exec) <strong class="mx ir">{<br/>    </strong>dependsOn copyDependencies, build<br/>    workingDir "$projectDir"<br/>    commandLine 'docker', 'build', '--rm', '.', '-t', "$project.group/$project.name:$project.version", "-f", "$projectDir/src/main/docker/Dockerfile"<br/><strong class="mx ir">}</strong></span><span id="90a3" class="md me iq mx b gy ng nc l nd ne">// runs the docker image<br/>task runDocker(type: Exec) <strong class="mx ir">{<br/>    </strong>dependsOn buildDocker<br/>    workingDir "$projectDir"<br/>    commandLine 'docker', 'run', "$project.group/$project.name:$project.version"<br/><strong class="mx ir">}</strong></span></pre><p id="d8d4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这些任务将完成以下任务:</p><ul class=""><li id="7954" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko nh lo lp lq bi translated">buildDocker:确保应用程序已构建且copyDependencies已运行。然后它调用docker build命令，在<strong class="jt ir">app/src/main/docker/Dockerfile中查找docker file。</strong></li><li id="2987" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">runDocker:简单地确保buildDocker已经运行，然后在新构建的映像上调用docker run命令。</li></ul><p id="6ef8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">接下来，在<strong class="jt ir">app/src/main/docker/docker file</strong>中创建<strong class="jt ir"> Dockerfile </strong>，添加起始内容:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="3ec4" class="md me iq mx b gy nb nc l nd ne">####<br/># This Dockerfile is used to package the yak-server application<br/>#<br/># Build the image with:<br/>#<br/># ./gradlew buildDocker<br/>#<br/>###<br/><br/>FROM openjdk:17-alpine AS <em class="js">jre-build<br/></em>WORKDIR /app<br/><br/># copy the dependencies into the docker image<br/>COPY build/lib/* build/lib/<br/><br/># copy the executable jar into the docker image<br/>COPY build/libs/app-*.jar build/app.jar<br/><br/># tempoarily test our JAR works when we run the image<br/>WORKDIR /app/build<br/>ENTRYPOINT java -jar app.jar</span></pre><p id="34ab" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">至此，您应该能够从项目的根目录运行了:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="0db0" class="md me iq mx b gy nb nc l nd ne">./gradlew clean runDocker</span></pre><p id="13f5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">您应该会看到以下情况:</p><ul class=""><li id="d4fe" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko nh lo lp lq bi translated">这个JAR被编译并放在<strong class="jt ir"> app/build/libs </strong>目录中。</li><li id="c772" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">JAR依赖项被复制到<strong class="jt ir"> app/build/lib </strong>目录。</li><li id="0505" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">构建Docker映像，将这两个目录复制到其中。</li><li id="ab99" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">Docker图像已运行，您可以看到我们的Hello World！输出到控制台。</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/55158905a71b2470bc6f4960ba2a9e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*OGwrlZ9eAbAf4hgtxAeJyA.png"/></div></figure><p id="ef41" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这意味着我们现在已经准备好开始使用jdeps和jlink优化Dockerfile了。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="16ff" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated"><strong class="jt ir">重要提示:</strong>在我们开始优化之前，最好知道我们从哪里开始。现在，我们拥有了正常运行该应用程序所需的一切，但是如果我们看看docker图像的大小:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="aa69" class="md me iq mx b gy nb nc l nd ne">docker images</span></pre><p id="a5c9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">您将看到类似于以下内容的内容:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi no"><img src="../Images/09b336c68092b11a87d640f29f91f005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFrPlGg0DH4g1FwgnE-cjQ.png"/></div></div></figure><p id="0646" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这表明我们有大约一个<strong class="jt ir"> 330Mb </strong>的docker映像用于这个命令行应用程序。记住这一点，让我们看看通过使用新的工具，我们可以使它变得多小。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a331" class="np me iq bd mf nq nr ns mi nt nu nv ml nw nx ny mo nz oa ob mr oc od oe mu of bi translated">步骤4:使用jdeps和jlink创建一个较小的Docker图像</h1><h2 id="b9d3" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lg mp mq mr lh ms mt mu mv bi translated">使用jdeps找到您需要的JVM模块</h2><p id="8258" class="pw-post-body-paragraph jq jr iq jt b ju ni jw jx jy nj ka kb lf nk ke kf lg nl ki kj lh nm km kn ko ij bi translated">因为我们现在在Dockerfile中有了一个起点，在这里我们可以访问我们想要运行的JAR及其依赖项，我们现在可以调用jdeps来分析这些并输出我们在运行时需要的JVM部分。</p><p id="8b07" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">为此，请编辑docker文件，使其包含以下内容:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="2794" class="md me iq mx b gy nb nc l nd ne">####<br/># This Dockerfile is used to package the yak-server application<br/>#<br/># Build the image with:<br/>#<br/># ./gradlew buildDocker<br/>#<br/>###<br/><br/>FROM openjdk:17-alpine AS <em class="js">jre-build<br/></em>WORKDIR /app<br/><br/># copy the dependencies into the docker image<br/>COPY build/lib/* build/lib/<br/><br/># copy the executable jar into the docker image<br/>COPY build/libs/app-*.jar build/app.jar<br/><br/># find JDK dependencies dynamically from jar<br/>RUN jdeps \<br/># dont worry about missing modules<br/>--ignore-missing-deps \<br/># suppress any warnings printed to console<br/>-q \<br/># java release version targeting<br/>--multi-release 17 \<br/># output the dependencies at end of run<br/>--print-module-deps \<br/># specify the the dependencies for the jar<br/>--class-path build/lib/* \<br/># pipe the result of running jdeps on the app jar to file<br/>build/app.jar &gt; jre-deps.info<br/><br/># temp print jdeps output<br/>ENTRYPOINT cat /app/jre-deps.info</span></pre><p id="ea82" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">您现在可以看到我们用以下代码调用jdeps:</p><ul class=""><li id="66fa" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko nh lo lp lq bi translated">我们的目标是哪个版本的Java(在这个例子中是17，它与我们正在构建的基本docker映像相匹配)。</li><li id="be25" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">在哪里可以找到JAR的依赖项。</li><li id="6ef1" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">最后，我们将命令的输出通过管道传输到一个文件<strong class="jt ir"> jre-deps.info </strong>，现在我们只是在docker映像运行时将它打印到控制台。</li></ul><p id="fc25" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这样，运行docker映像:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="3ee2" class="md me iq mx b gy nb nc l nd ne">./gradlew clean runDocker</span></pre><p id="5c43" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">您将看到以下输出:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi og"><img src="../Images/c7aed246b64cb90e9f5d2b06319d95aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiBwD4_NPItzraav95EkpA.png"/></div></div></figure><p id="9bd5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">它以逗号分隔的列表显示了运行我们的应用程序时所需的JVM模块。这样，我们就确切地知道了我们的应用程序在运行时需要什么，现在我们可以考虑构建一个只包含这些部分的JRE，从而显著减小最终Docker映像的大小。</p><h2 id="c6d5" class="md me iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lg mp mq mr lh ms mt mu mv bi translated">使用jlink创建自定义JRE</h2><p id="d10e" class="pw-post-body-paragraph jq jr iq jt b ju ni jw jx jy nj ka kb lf nk ke kf lg nl ki kj lh nm km kn ko ij bi translated">将jdeps的输出存储到文件中后，我们现在可以调用jlink来构建一个只包含所提供模块的定制JRE。为此，请编辑您的docker文件，使其包含以下内容:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="6bb9" class="md me iq mx b gy nb nc l nd ne">####<br/># This Dockerfile is used to package the yak-server application<br/>#<br/># Build the image with:<br/>#<br/># ./gradlew buildDocker<br/>#<br/>###<br/><br/>FROM openjdk:17-alpine AS <em class="js">jre-build<br/></em>WORKDIR /app<br/><br/># copy the dependencies into the docker image<br/>COPY build/lib/* build/lib/<br/><br/># copy the executable jar into the docker image<br/>COPY build/libs/app-*.jar build/app.jar<br/><br/># find JDK dependencies dynamically from jar<br/>RUN jdeps \<br/># dont worry about missing modules<br/>--ignore-missing-deps \<br/># suppress any warnings printed to console<br/>-q \<br/># java release version targeting<br/>--multi-release 17 \<br/># output the dependencies at end of run<br/>--print-module-deps \<br/># specify the the dependencies for the jar<br/>--class-path build/lib/* \<br/># pipe the result of running jdeps on the app jar to file<br/>build/app.jar &gt; jre-deps.info</span><span id="07a8" class="md me iq mx b gy ng nc l nd ne"># new since last time!<br/>RUN jlink --verbose \<br/>--compress 2 \<br/>--strip-java-debug-attributes \<br/>--no-header-files \<br/>--no-man-pages \<br/>--output jre \<br/>--add-modules $(cat jre-deps.info)<br/><br/># take a smaller runtime image for the final output<br/>FROM alpine:latest<br/>WORKDIR /deployment<br/><br/># copy the custom JRE produced from jlink<br/>COPY --from=<em class="js">jre-build </em>/app/jre jre<br/><br/># copy the app dependencies<br/>COPY --from=<em class="js">jre-build </em>/app/build/lib/* lib/<br/><br/># copy the app<br/>COPY --from=<em class="js">jre-build </em>/app/build/app.jar app.jar<br/><br/># run the app on startup<br/>ENTRYPOINT jre/bin/java -jar app.jar</span></pre><p id="6a9a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">让我们分解我们的最终文档:</p><ul class=""><li id="873d" class="li lj iq jt b ju jv jy jz lf lk lg ll lh lm ko nh lo lp lq bi translated">我们将应用程序和依赖项复制到docker映像中。</li><li id="0b7b" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">然后，我们运行jdeps来找出这个特定应用程序所需的JRE模块。</li><li id="b170" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">我们运行jlink为这个特定的应用程序构建一个定制的、精简的JRE。</li><li id="9785" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">我们采用一个新的运行时映像，利用dockers的多阶段构建过程。这张图片来自阿尔卑斯山:最新的so非常小。</li><li id="3891" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">我们将自定义的JRE、应用程序及其依赖项复制到这个最终的精简映像中。</li><li id="47a3" class="li lj iq jt b ju lr jy ls lf lt lg lu lh lv ko nh lo lp lq bi translated">我们设置入口点来使用jlink产生的JRE运行我们的应用程序。</li></ul><p id="9b47" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">如果您正确地复制了下面的代码，您将看到应用程序启动并打印“Hello World！”运行时记录消息:</p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="2f8e" class="md me iq mx b gy nb nc l nd ne">./gradlew clean runDocker</span></pre></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="cd89" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">因此，我们的应用程序成功地在Docker中运行，但大问题仍然存在…经过所有这些麻烦后，我们最终的Docker图像会小多少？</p><p id="4819" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">目前，在我的机器上，我最终的docker图像大小是:<strong class="jt ir"> 58.6mb </strong></p><pre class="kq kr ks kt gt mw mx my mz aw na bi"><span id="4cfa" class="md me iq mx b gy nb nc l nd ne">docker images</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi oh"><img src="../Images/d4c1f99bee22f670d619adda4fb44ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6RFUjkosuIVI0af6VFvkQ.png"/></div></div></figure><p id="ded7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这超过了<strong class="jt ir"> 250mb </strong>比我们开始的原始图像小！</p><p id="114b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">我希望本指南已经向您展示了如何用最少的工作创建一个最小化的Docker映像来运行一个标准的Java应用程序。</p><blockquote class="jn jo jp"><p id="160b" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">快速补充说明:有时候jdeps工作起来很痛苦，尤其是当你有一个复杂的类路径时。您总是可以手工设计出您需要的模块，并简单地将它传递给jlink命令。您可能得不到最佳的图像，但与运行完整的JRE相比，这是一个显著的改进。</p></blockquote><p id="8438" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">如果您对这种方法有任何疑问，请随时联系我。</p><div class="oi oj gp gr ok ol"><a href="https://www.linkedin.com/in/joe-honour-8693029a/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">Joe Honour -高级软件工程师-和数字| LinkedIn</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">查看Joe Honour在全球最大的职业社区LinkedIn上的个人资料。乔有6份工作列在他们的…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.linkedin.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kz ol"/></div></div></a></div></div></div>    
</body>
</html>