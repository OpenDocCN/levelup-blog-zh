<html>
<head>
<title>Time Complexity: A Guide To Building Better Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间复杂性:构建更好软件的指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/time-complexity-a-guide-to-building-better-software-f8fe633cead?source=collection_archive---------0-----------------------#2022-08-27">https://levelup.gitconnected.com/time-complexity-a-guide-to-building-better-software-f8fe633cead?source=collection_archive---------0-----------------------#2022-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/30491bcc65fb6525489363985b60c615.png" data-original-src="https://miro.medium.com/v2/0*coaWuGUZXX2MlP4b"/></div></figure><h1 id="c47c" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是时间复杂度？</h1><p id="4ec6" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">时间复杂性是一种描述软件功能内部算法运行时间的数学方法。它用于指示算法的运行时间如何随着输入大小的增加而增加。这篇博文将讨论大O符号以及它如何影响软件应用。我们还将提供一些例子来帮助你更好地理解这个概念。</p><p id="aa16" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这种方法是一种渐进的方式，可以理解某种算法如何随着时间的推移影响应用程序。并不能准确显示一个应用程序完成一个问题需要多长时间，但是可以给你一个大概的概念。</p><p id="31f1" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">这类似于了解你的汽车每加仑行驶的英里数，以确定你在一次给定的旅行中将如何花费燃料。并非所有的行程或输入都是相同的大小，大O符号有助于我们理解应用程序中的时间和内存开销。</p><p id="2332" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">计算机科学中有4种常见的算法，从最快到最慢。</p><figure class="lw lx ly lz gt jq gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/a35b2a1cda607f0ab86468bba8f8764b.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/0*E0so2MQ0erpgEyvU.png"/></div></figure><h1 id="2908" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">常数— 0(1)</h1><p id="41f1" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">恒定的时间复杂度意味着只需一步就能完成。例如数学运算、访问数组的索引、推入和弹出堆栈以及保留函数的值。</p><p id="368c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">示例:</p><p id="6d2d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><code class="fe ma mb mc md b">let num = 10</code> <br/> <code class="fe ma mb mc md b"> function addNum(num){ <br/> return num + 2 <br/> }</code></p><p id="89a8" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated"><code class="fe ma mb mc md b">const result = addNum(19)</code></p><h1 id="3cde" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">线性— O(n)</h1><p id="f765" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">线性时间复杂度被认为是非常高效的，并且经常是算法设计者的目标。然而，这可能很难实现，尤其是对于大而复杂的输入。设计算法时，考虑最坏情况和最好情况是很重要的。最坏的情况是处理时间最长的输入，而最好的情况是处理速度最快的输入。对于具有线性时间复杂度的算法，最坏情况和最好情况将总是花费大约相同的时间。这使得它们非常一致和可预测，这在许多应用中是有价值的。</p><p id="48ca" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">具有线性时间复杂度的函数的一些例子是</p><ul class=""><li id="2bcb" class="me mf iq ku b kv lq kz lr ld mg lh mh ll mi lp mj mk ml mm bi translated">For循环</li><li id="e041" class="me mf iq ku b kv mn kz mo ld mp lh mq ll mr lp mj mk ml mm bi translated">。forEach() (JavaScript)</li><li id="7ed5" class="me mf iq ku b kv mn kz mo ld mp lh mq ll mr lp mj mk ml mm bi translated">。map() (JavaScript)</li><li id="e8e8" class="me mf iq ku b kv mn kz mo ld mp lh mq ll mr lp mj mk ml mm bi translated">。filter() (JavaScript)</li></ul><p id="627c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">我发现只有当你需要遍历数据结构中的每个值时，这个算法才是有用的。</p><h1 id="3a07" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">二次——O(n)</h1><p id="05fd" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">二次时间复杂度将算法运行所需的时间描述为输入大小的函数。换句话说，它衡量的是相对于给定的数据量，算法完成任务需要多长时间。二次时间算法采用大小为n的输入，需要O(n)次运算才能完成。这意味着，随着输入大小的增加，完成任务所需的操作数量会以与输入大小的平方成正比的速度增加。二次时间算法通常用于排序和搜索等任务，在这些任务中，输入大小相对较小，所需的操作数量也不会过多。然而，对于较大的输入大小，二次时间算法可能会变得非常慢，使它们无法用于许多实际应用。</p><h1 id="157e" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">对数— O(对数n)</h1><p id="c1bc" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对数时间复杂度是指当输入大小增加时，运行所需的时间只增加一个常量。也就是说，如果输入大小增加一倍，运行时只会增加一个很小的常量。因此，对数时间复杂度非常有效，并且通常比其他类型的时间复杂度更受欢迎。</p><p id="4150" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">但是，应该注意的是，对数时间复杂度仍然会受到特定输入值的影响。例如，如果输入值已经排序，那么运行时间会更短。因此，在确定算法的时间复杂度时，考虑输入大小和输入值非常重要</p><h1 id="c7ec" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="0435" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如上所述，您可以在不掌握大o的情况下进行编码。请记住，这只是一个估计值，因为计算的运行时间可能会根据实际情况(如处理速度和使用的语言)而有所不同。然而，这不应该阻止您学习更多关于大O符号的知识——这样做可以为您理解设计算法时什么是重要的，什么是不重要的提供有用的背景。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h2 id="cce3" class="mz jv iq bd jw na nb dn ka nc nd dp ke ld ne nf ki lh ng nh km ll ni nj kq nk bi translated">在网上和我联系！</h2><ul class=""><li id="b192" class="me mf iq ku b kv kw kz la ld nl lh nm ll nn lp mj mk ml mm bi translated"><a class="ae no" href="https://digyt.co" rel="noopener ugc nofollow" target="_blank">和我一起工作</a></li><li id="b15d" class="me mf iq ku b kv mn kz mo ld mp lh mq ll mr lp mj mk ml mm bi translated"><a class="ae no" href="http://www.christopherclemmons.com/" rel="noopener ugc nofollow" target="_blank">个人博客</a></li><li id="af90" class="me mf iq ku b kv mn kz mo ld mp lh mq ll mr lp mj mk ml mm bi translated">电子邮件:christopher.clemmons2020@gmail.com</li></ul></div></div>    
</body>
</html>