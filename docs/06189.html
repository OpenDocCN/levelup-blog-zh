<html>
<head>
<title>Deep Dive on .NET Core String.Create() Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始深潜。网芯串。创建()性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deep-dive-on-net-core-string-create-performance-6597bb47f3c6?source=collection_archive---------6-----------------------#2020-11-02">https://levelup.gitconnected.com/deep-dive-on-net-core-string-create-performance-6597bb47f3c6?source=collection_archive---------6-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/15a151fae935b514cb3cb0fe1c1fab0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*foOQKnu4KYfBahq8grZHNw.png"/></div></div></figure><div class=""/><div class=""><h2 id="d738" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">我研究了提高字符串性能的策略。NET和ASP.NET核心。创建()</h2></div><p id="6c4a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上一次一个无关紧要的细节在你的大脑中引发一场运动是什么时候？作为一名软件工程师，我习惯于关注新代码块中我从未见过的微小细节。那时，我大脑中的齿轮开始转动。我喜欢这些时刻。最微小的琐事都会让我陷入探索的兔子洞。</p><p id="5339" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上次你想到的时候是什么样子的？</p><p id="4f35" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最近我在浏览Twitter时遇到了这种情况。我偶然发现大卫福勒和达米安爱德华兹之间的交流，讨论。NET <code class="fe lm ln lo lp b">Span&lt;T&gt;</code> API。我以前用过<code class="fe lm ln lo lp b">Span&lt;T&gt;</code> API，但是我在tweets中发现了一些新的和不同的东西。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/090cb13f61e7858905fd8831cd730747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*5-KiYiQ3Oqq6muE17DD5dA.png"/></div></figure><p id="77dd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是一件小事，也是我开始潜入兔子洞的原因。<strong class="ks jc">字符串。上面使用的创建</strong>方法是我从未见过的。<strong class="ks jc">字符串。Create </strong>是一颗隐藏的宝石，我决心揭开它的神秘面纱。我发现自己问了一个问题:</p><blockquote class="lv"><p id="e6ec" class="lw lx jb bd ly lz ma mb mc md me ll dk translated"><em class="mf">“为什么使用这种方法创建字符串？”</em></p></blockquote><p id="acbd" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">我开始了旅程，它带我去了几个有趣的地方，我想和你们分享。在本文中，我们将深入探讨几个主题…</p><ul class=""><li id="ff45" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll mq mr ms mt bi translated">什么是<strong class="ks jc">字符串。创建</strong>和其他API有什么不同？</li><li id="2865" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated"><strong class="ks jc">什么字符串。Create </strong>做得更好，如何能让我的C#代码更快？</li><li id="f157" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">它还能实现多少性能？</li><li id="7d5a" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">可以并且应该避免哪些陷阱？</li></ul><h1 id="b89c" class="mz na jb bd nb nc nd ne nf ng nh ni nj kh nk ki nl kk nm kl nn kn no ko np nq bi translated">定义</h1><p id="fcc4" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">为了使文章简单一点，我将引用几个例子。NET核心API的方式如下:</p><ul class=""><li id="2cb1" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll mq mr ms mt bi translated"><strong class="ks jc">创造</strong>——指使用<code class="fe lm ln lo lp b">String.Create()</code>。</li><li id="497e" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated"><strong class="ks jc"> Concat </strong> —指使用<code class="fe lm ln lo lp b">String.Concat()</code>或加号(<code class="fe lm ln lo lp b">+</code>)运算符。</li><li id="3b60" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated"><strong class="ks jc">格式</strong> —指的是使用<code class="fe lm ln lo lp b">String.Format()</code>，它的许多重载之一，或者使用<code class="fe lm ln lo lp b">$""</code>语法的字符串插值。</li><li id="a8e7" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated"><strong class="ks jc"> StringBuilder </strong> —指用fluent <code class="fe lm ln lo lp b">StringBuilder</code>类和API构造一个字符串。</li></ul><h1 id="6f0c" class="mz na jb bd nb nc nd ne nf ng nh ni nj kh nk ki nl kk nm kl nn kn no ko np nq bi translated">它是如何工作的？</h1><p id="6a04" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">的。NET核心代码库是开源的，在GitHub 上开发的<a class="ae nw" href="https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/String.cs" rel="noopener ugc nofollow" target="_blank">。这为深入分析微软自己的实践提供了一个很好的机会。他们提供了<strong class="ks jc"> Create </strong> API，因此观察他们如何使用它应该会提供有价值的见解。让我们从深入研究<code class="fe lm ln lo lp b">String</code>对象及其相关的API开始。</a></p><p id="5f2a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了从原始字符数据中构建一个字符串，您需要使用需要一个指向 <code class="fe lm ln lo lp b"><a class="ae nw" href="https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/String.cs#L57" rel="noopener ugc nofollow" target="_blank">char</a></code> <a class="ae nw" href="https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/String.cs#L57" rel="noopener ugc nofollow" target="_blank">数组</a>的<a class="ae nw" href="https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/String.cs#L57" rel="noopener ugc nofollow" target="_blank">指针的构造函数。直接使用这个API需要将单个字符放入特定的数组位置。下面是使用此构造函数分配字符串时运行的代码。还有许多其他方法来创建字符串，但这是我认为最能与<strong class="ks jc"> Create </strong>方法相提并论的。</a></p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">来自的字符串构造函数。NET核心运行时</figcaption></figure><p id="945d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">重要步骤总结如下:</p><ol class=""><li id="f106" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll od mr ms mt bi translated">输入经过验证。空数组返回<code class="fe lm ln lo lp b">String.Empty</code>。</li><li id="6d2f" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">我们基于数组<code class="fe lm ln lo lp b">Length</code>使用<code class="fe lm ln lo lp b">FastAllocateString</code>分配内存。<code class="fe lm ln lo lp b">FastAllocateString</code>在内部实现。NET运行时本身，并支持几乎所有的字符串分配。</li><li id="ff9a" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">我们调用<code class="fe lm ln lo lp b">Buffer.Memmove</code>，将原来数组的所有字节复制到新分配的字符串中。</li><li id="d462" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">返回结果字符串。</li></ol><p id="6241" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">要使用这个构造函数，我们需要为它提供一个<code class="fe lm ln lo lp b">char</code>数组。它的工作完成后，我们得到了一个(现在不必要的)<code class="fe lm ln lo lp b">char</code>数组和一个<code class="fe lm ln lo lp b">string</code>，每个数组都有相同的数据。如果我们要修改原始数组，那么<code class="fe lm ln lo lp b">string</code>将保持不变，因为它是数据的一个单独且不同的副本。在一个高性能。NET环境中，保存对象和数组分配非常有价值，因为它减少了。NET垃圾收集器在运行时需要做的事情。留在内存中的每一个额外的对象都会增加收集的频率，降低整体性能。</p><p id="4a8f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您想了解更多关于。NET垃圾收集及其对性能的影响，网上有许多精彩的资源:</p><ul class=""><li id="10a9" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll mq mr ms mt bi translated"><a class="ae nw" href="https://youtu.be/kej3YJDMAW4?t=505" rel="noopener ugc nofollow" target="_blank">ASP.NET核心红隼:构建快速网络服务器的冒险——达米安·爱德华兹&amp;大卫·福勒</a></li><li id="8e04" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">避免GC压力并提高C#性能的8个技巧。净</li><li id="49e6" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated"><a class="ae nw" href="https://www.red-gate.com/simple-talk/dotnet/asp-net/how-the-garbage-collector-can-cause-random-slowness/" rel="noopener ugc nofollow" target="_blank">垃圾收集器如何导致随机变慢</a></li></ul><p id="4045" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了与构造函数对比并消除这种不必要的数组分配，我们来看看为<strong class="ks jc"> Create </strong>方法运行的代码:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">字符串。从创建()。NET核心运行时</figcaption></figure><p id="b971" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些步骤很相似，但有一个关键区别:</p><ol class=""><li id="bee6" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll od mr ms mt bi translated">输入经过验证。无效的<code class="fe lm ln lo lp b">action</code>或负的<code class="fe lm ln lo lp b">Length</code>将抛出异常，为0的<code class="fe lm ln lo lp b">Length</code>返回空；</li><li id="b851" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">我们基于<code class="fe lm ln lo lp b">length</code>参数使用<code class="fe lm ln lo lp b">FastAllocateString</code>分配内存。</li><li id="db8a" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">将新分配的<code class="fe lm ln lo lp b">string</code>转换为<code class="fe lm ln lo lp b">Span&lt;char&gt;</code>。</li><li id="5af2" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">调用提供的<code class="fe lm ln lo lp b">action</code>并传入新的<code class="fe lm ln lo lp b">Span&lt;char&gt;</code>和提供的<code class="fe lm ln lo lp b">state</code>。</li><li id="6ede" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">返回结果<code class="fe lm ln lo lp b">string</code>。</li></ol><p id="d02b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这种方法通过允许我们传入一个<code class="fe lm ln lo lp b">SpanAction</code>来避免额外的分配，它的功能是作为一组应该如何创建我们的字符串的指令，而不是要求我们需要放入字符串的所有字节的第二个副本。</p><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/9ac9f0aab276b624de1b82aa0af65765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqXvXhg7cqnvhVNHBU2-og.png"/></div></div></figure><figure class="lr ls lt lu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/b588fcabf1efeba203fb9cf99498dc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXNibkdYiFJtpr3ZDZiTjA.png"/></div></div></figure><p id="9a0a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从平面设计中可以得出一个类比。你可能想为你的企业创建一个专业的标志，你可能决定你想用SVG或EPS这样的矢量格式来创建它。您创建了一个文档，其中详细介绍了徽标的主题、颜色和总体外观。您现在有几个选择:</p><ol class=""><li id="66ef" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll od mr ms mt bi translated">自己画初稿，尽量接近专业版，发给平面设计师，让他们创作定稿。</li><li id="3a5c" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">将您的原始详细文档发送给平面设计师，他会根据您提供的信息创建最终的徽标。</li></ol><p id="f61f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在第一种情况下，您最终有两个图像，但只有一个是您计划使用的。你的原件可能不需要任何仪式就可以扔掉，因为你现在有了你专业设计的版本。在第二种情况下，你没有生产任何额外的产品，因此产生了较少的浪费。</p><p id="4340" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> Create </strong>方法的过程更接近于将文档发送给设计者的情况。通过告诉他们你从一开始就想要什么，你只能以你需要的形式生成一个最终的工件。</p><h1 id="2089" class="mz na jb bd nb nc nd ne nf ng nh ni nj kh nk ki nl kk nm kl nn kn no ko np nq bi translated">弦怎么样。创建()更好？</h1><p id="3733" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">此时，您可能对<strong class="ks jc">创建</strong>方法感到好奇，但是您不一定知道为什么它比您以前使用的方法更好。<strong class="ks jc">Create</strong>API的有用性是视情况而定的，但是在适当的上下文中它会非常强大。</p><ul class=""><li id="2306" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll mq mr ms mt bi translated">它预先分配一个桶，然后给你一个接口来安全地装满这个桶。产生类似结果的其他方法可能需要编写不安全的代码或管理缓冲池。</li><li id="e365" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">它避免了额外的数据复制操作，这通常会导致较少的分配。这减少了来自垃圾收集器的压力，从而加快了整个程序的速度。</li><li id="1fab" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">它允许您将高性能代码集中在应用程序的业务需求上，而不是将字符串构建代码与复杂的内存管理交织在一起。</li></ul></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h1 id="a775" class="mz na jb bd nb nc om ne nf ng on ni nj kh oo ki nl kk op kl nn kn oq ko np nq bi translated">字符串的用例。创建()</h1><p id="92df" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">当你已经知道最终字符串的长度时，你只能使用<strong class="ks jc"> Create </strong>方法。然而，您可以创造性地处理这个约束，并发现几种利用<strong class="ks jc"> Create </strong>的方法。我搜索了<a class="ae nw" href="https://github.com/dotnet/aspnetcore" rel="noopener ugc nofollow" target="_blank"> dotnet/aspnetcore </a>和<a class="ae nw" href="https://github.com/dotnet/runtime" rel="noopener ugc nofollow" target="_blank"> dotnet/runtime </a>的代码库，看看微软团队决定在哪里使用这个API。本文的其余部分将深入探讨我发现的三个趋势:</p><ul class=""><li id="f138" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll mq mr ms mt bi translated">生成id</li><li id="5385" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">对性能敏感的连接</li><li id="93b9" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">格式化复杂字符串</li></ul><h2 id="9c53" class="or na jb bd nb os ot dn nf ou ov dp nj kz ow ox nl ld oy oz nn lh pa pb np pc bi translated">生成id</h2><p id="4da7" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">考虑来自ASP.NET核心存储库的这个类，用于为每个web请求生成关联id。它以从数字(0–9)和大多数大写字母(A-V)中选择的13个字符的格式生成一个相关ID。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="52de" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">算法很简单:</p><ol class=""><li id="74df" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll od mr ms mt bi translated">从UTC的最新刻度计数开始您的相关ID。滴答计数是一个64位整数。</li><li id="565c" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">对新ID的每个请求增加1。</li><li id="4a92" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">对于13个字符中的每一个:<br/> -将值移动5个额外的(<code class="fe lm ln lo lp b">character_index * 5</code>)位。<br/> -抓取最右边的5位(<code class="fe lm ln lo lp b">shifted_value &amp; 31</code>)，并根据预定的表格选择一个字符。</li></ol><p id="d160" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于我们的基线比较，我使用了一个利用了<code class="fe lm ln lo lp b">StringBuilder</code>的简单实现。我选择这个选项是因为<code class="fe lm ln lo lp b">StringBuilder</code>是<a class="ae nw" href="https://docs.microsoft.com/en-us/troubleshoot/dotnet/csharp/string-concatenation" rel="noopener ugc nofollow" target="_blank">经常推荐的</a>API，在性能上优于常规的字符串连接。我编写了额外的实现，试图使用<code class="fe lm ln lo lp b">StringBuilder</code>(有容量)、<code class="fe lm ln lo lp b">StringBuilder</code>(没有容量)和简单的连接。</p><p id="b38c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">执行基准</strong></p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="9442" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">内存基准</strong></p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9c9d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lm ln lo lp b">String.Create()</code>方法在性能(16.58纳秒)和分配(只有48字节)方面表现最好！).有趣的是，没有指定容量的<code class="fe lm ln lo lp b">StringBuilder</code>也显示出比常规<code class="fe lm ln lo lp b">StringBuilder</code>小的优势(它仍然输给<code class="fe lm ln lo lp b">String.Create()</code>，但这对于未来的<code class="fe lm ln lo lp b">StringBuilder</code>使用来说是有趣的)。</p><h2 id="b6b9" class="or na jb bd nb os ot dn nf ou ov dp nj kz ow ox nl ld oy oz nn lh pa pb np pc bi translated">对性能敏感的串联</h2><p id="2255" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">C# Roslyn编译器在优化不良连接方面非常聪明。编译器倾向于将加号<code class="fe lm ln lo lp b">+</code>操作符的多次使用转换成对<strong class="ks jc"> Concat </strong>的单次调用，并且可能有许多我不知道的额外技巧。由于这些原因，串联通常是一个快速的操作，但是对于简单的场景，它仍然可以被<strong class="ks jc"> Create </strong>挤掉。</p><p id="38e4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">演示用<strong class="ks jc"> Create </strong>方法连接的示例代码非常简单。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9a51" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在发现<a class="ae nw" href="https://github.com/dotnet/runtime/blob/a9b1173e64f628c7233850be6b762a58897bc6be/src/libraries/System.Diagnostics.TextWriterTraceListener/src/System/Diagnostics/XmlWriterTraceListener.cs" rel="noopener ugc nofollow" target="_blank">只有一个真实的例子</a>之后，我精心制作了这个特殊的案例。NET核心源代码。这看起来像是一个可以被合理地抽象出来并散布在频繁过度使用加号<code class="fe lm ln lo lp b">+</code>操作符或<code class="fe lm ln lo lp b">String.Concat</code>的代码库中的案例。我没有找到更多案例的可能原因是基准测试证明这是一个边际收益。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="689e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="pd">注意:内存基准没有什么可报告的，因为两种方法生成了相同数量的分配内存。</em></p><p id="81bf" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我发现这些结果很有趣。即使对于通用的<strong class="ks jc"> Concat </strong>用法，<strong class="ks jc"> Create </strong>方法也略微快了几个百分点。然而，由于有可能推广一个快速字符串连接方法库，维护和性能之间的权衡将变得更加清晰。您可以将所有串联方法包装在一个静态类中，添加您的单元测试，并且再也不用接触它们。</p><p id="893c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从维护的角度来看，<strong class="ks jc"> Concat </strong>仍然更干净，因为对团队中的其他开发人员来说非常容易识别。然而，如果你以每秒数百万的速度连接字符串(比如一个高流量的<a class="ae nw" href="http://ASP.NET" rel="noopener ugc nofollow" target="_blank">ASP.NET</a>应用程序)，这几个百分点可能是值得的。总的来说，我仍然建议剖析您的具体案例，以证明您的专用方法更快。</p><h2 id="2acd" class="or na jb bd nb os ot dn nf ou ov dp nj kz ow ox nl ld oy oz nn lh pa pb np pc bi translated">复杂字符串的格式</h2><p id="e49b" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">当您知道所涉及的所有较小片段的长度时，也可以使用<strong class="ks jc"> Create </strong>构建复杂的格式。通常，当您将这些字符串封装为单个类的属性或单个方法的参数时，就会出现这种情况。当处理固定宽度或分隔数据行时，如CSV文件，使用<strong class="ks jc"> Create </strong>可能也是有利的。</p><p id="70a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我在<a class="ae nw" href="http://ASP.NET" rel="noopener ugc nofollow" target="_blank">ASP.NET</a>核心库中发现了一个<a class="ae nw" href="https://github.com/dotnet/aspnetcore/blob/8a81194f372fa6fe63ded2d932d379955854d080/src/Http/Headers/src/SetCookieHeaderValue.cs" rel="noopener ugc nofollow" target="_blank">很好的例子</a>，以<code class="fe lm ln lo lp b">SetCookieHeaderValue</code>类的形式。这个类包含写出cookie HTTP头所需的所有属性。方便的是，这个类还包含了一个使用<strong class="ks jc"> StringBuilder </strong>来完成相同格式化任务的方法。这给了我一个很好的机会来编写快速基准测试。</p><p id="99f4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下表显示了这两种方法的不同之处:</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b4c1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于像cookie头这样的复杂字符串，<strong class="ks jc"> Create </strong>将性能提高了近33%！像这样的复杂格式表明，当使用<strong class="ks jc"> Create </strong>方法时会有很多收获。</p><p id="d1eb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">虽然<code class="fe lm ln lo lp b">SetCookieHeaderValue</code>类提供了一个理想的数据点，但它的逻辑相当长且复杂。我编写了一个简单的类来演示相同的格式化原则。</p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b856" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的<code class="fe lm ln lo lp b">Dog</code>类包含三个应该产生相同输出的方法:<code class="fe lm ln lo lp b">StringCreate</code>、<code class="fe lm ln lo lp b">Concatenation</code>和<code class="fe lm ln lo lp b">StringFormat</code>。每种方法都使用与其名称相匹配的格式策略。尽管复杂得多，但<code class="fe lm ln lo lp b">StringCreate</code>的实际策略相对简单:</p><ol class=""><li id="e010" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll od mr ms mt bi translated">抢先计算<code class="fe lm ln lo lp b">Dog</code>类的每个属性的长度。有些属性可能需要一些创造性的逻辑来计算长度，而不需要具体化整个字符串(<code class="fe lm ln lo lp b">Int32</code>就是一个很好的例子)。</li><li id="111c" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">使用当前类(<code class="fe lm ln lo lp b">this</code>)作为<code class="fe lm ln lo lp b">state</code>参数以及预先计算的长度调用<code class="fe lm ln lo lp b">String.Create</code>。</li><li id="c5b4" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll od mr ms mt bi translated">使用<code class="fe lm ln lo lp b">Span&lt;T&gt;</code>API填充新实例化的<code class="fe lm ln lo lp b">buffer</code>变量并返回最终字符串。</li></ol><p id="f2c6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">总的来说，<code class="fe lm ln lo lp b">StringFormat</code>和<code class="fe lm ln lo lp b">Concatenation</code>方法要短得多，也不复杂。这举例说明了在使用<strong class="ks jc"> Create </strong>方法正确格式化复杂字符串时可能遇到的困难，以及为什么它应该只用于代码中的性能关键路径。然而，适当地利用这种方法可以在整体性能上获得显著的好处。</p><p id="bae9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">执行时间基准</strong></p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="8182" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">内存基准</strong></p><figure class="lr ls lt lu gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6dd3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于更复杂的情况，使用<strong class="ks jc"> Create </strong>方法格式化要快25%到35%。我选择的基准方法显示了仔细考虑这个用例的另一个原因，即<strong class="ks jc"> Create </strong>方法。您可以看到，当需要格式化的元素较少时，简单串联的性能会稍好一些。在<code class="fe lm ln lo lp b">Dog</code>没有<code class="fe lm ln lo lp b">Age</code>或<code class="fe lm ln lo lp b">Color</code>值的情况下，计算和格式化字符串所需的工作掩盖了使用<strong class="ks jc"> Create </strong>带来的性能提升。</p><p id="b5c6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦我们填充了这些属性，<strong class="ks jc"> Concat </strong>很快就变成了较差的选项。这说明了为什么在使用这种方法之前理解您的数据也很重要。如果99%的案例都很简单，你就不需要这么多帮助。<strong class="ks jc">格式</strong>方法始终是最慢的选择，尽管可以说是最初编写最快的方法，并且很可能是未来最易维护的方法。</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><h1 id="f238" class="mz na jb bd nb nc om ne nf ng on ni nj kh oo ki nl kk op kl nn kn oq ko np nq bi translated">何时不使用字符串。创建()</h1><p id="1104" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated"><strong class="ks jc"> Create </strong>在性能关键型代码中显示出巨大的潜力，但是有许多合理的理由避免它。作为软件工程师，我们经常以牺牲大局为代价，变得更加依赖于我们系统的度量标准。一般来说，我认为体面但可维护的代码应该优先于出色的性能。这让我开出了三种通常情况下应该避免使用<strong class="ks jc"> Create </strong>的方法，即使这会牺牲性能。</p><h2 id="122a" class="or na jb bd nb os ot dn nf ou ov dp nj kz ow ox nl ld oy oz nn lh pa pb np pc bi translated">1)可读性很重要时不要使用</h2><p id="fc46" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">最终，这个API不是易于维护的。你的场景应该要求非常高的性能，你的代码应该是分解良好的，并且包含单元测试。当编写需要偶尔维护的代码时，您可以很容易地坚持使用这些更简单的格式化方法之一:</p><ul class=""><li id="3239" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll mq mr ms mt bi translated"><strong class="ks jc">格式</strong>或<strong class="ks jc">字符串插值</strong>生成带有动态值的简单字符串。</li><li id="0a02" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated"><strong class="ks jc"> StringBuilder </strong>创建需要循环或许多条件元素的字符串时。</li><li id="070d" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated"><strong class="ks jc"> Concat </strong>或者简单的<code class="fe lm ln lo lp b">+</code>当你只需要组合少量字符串的时候。</li></ul><h2 id="388a" class="or na jb bd nb os ot dn nf ou ov dp nj kz ow ox nl ld oy oz nn lh pa pb np pc bi translated">2)当文化很重要时不要使用</h2><p id="8e70" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated"><strong class="ks jc">格式</strong>、<strong class="ks jc">字符串插值</strong>，大多数<code class="fe lm ln lo lp b">ToString()</code>方法都尊重文化格式化选项。这为您的代码提供了适应特定于区域性的日期、数字和货币格式的重要能力，而不必自己编写逻辑代码。<strong class="ks jc"> Create </strong>本身并不提供对这些API的任何支持，试图在代码中模仿行为可能需要分配额外的字符串，从而消除了使用<strong class="ks jc"> Create </strong>方法的优势。</p><h2 id="cc90" class="or na jb bd nb os ot dn nf ou ov dp nj kz ow ox nl ld oy oz nn lh pa pb np pc bi translated">3)(可能)不要在输出给人类时使用</h2><p id="0161" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">这个情况有点主观。我不推荐使用<strong class="ks jc"> Create </strong>为人类格式化的原因是人类<strong class="ks jc">经常希望事情发生变化</strong>。由于使用<strong class="ks jc"> Create </strong>方法进行格式化极其冗长，随着时间的推移，任何更改都可能导致复杂性增加，从而产生越来越多的技术债务。在我看来，<strong class="ks jc"> Create </strong>的最佳用法是在机器可读的字符串上，或者在将来不太可能改变的更一般化的字符串编写API上。正如软件开发中经常出现的情况一样，您的具体情况是最重要的，但是我认为这是一个很好的通用规则，可以避免您预期在将来频繁修改的任何代码出现这种情况。</p><h1 id="0d4a" class="mz na jb bd nb nc nd ne nf ng nh ni nj kh nk ki nl kk nm kl nn kn no ko np nq bi translated">是字符串。创建()适合你吗？</h1><p id="c620" class="pw-post-body-paragraph kq kr jb ks b kt nr kc kv kw ns kf ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">这个问题的答案肯定是<strong class="ks jc">看情况</strong>。我通过关注对我来说新的东西开始了这项研究:字符串。创建方法。我一头扎进兔子洞，寻找使用这个API的新的有趣的方法。在这个过程中，我发现了使用该方法的三种主要方式:(1)生成id，(2)快速连接，以及(3)复杂的字符串格式化。我们的基准测试表明，我们可以，<strong class="ks jc">以合理的一致性</strong>，使用<strong class="ks jc">字符串产生一个更快的方法。以更简单、更易读的代码为代价来创造</strong>。回答上述问题时，您应该始终考虑:</p><ul class=""><li id="749c" class="ml mm jb ks b kt ku kw kx kz mn ld mo lh mp ll mq mr ms mt bi translated">这段代码的可读性有多重要？</li><li id="7bdc" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">改变的可能性有多大？</li><li id="edfc" class="ml mm jb ks b kt mu kw mv kz mw ld mx lh my ll mq mr ms mt bi translated">我的程序会在多大程度上使用这段代码，它会获得多少性能？</li></ul><p id="fa4a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些都取决于你的代码和你的团队的实力，但我今天的希望是，我已经给了你一些工具来帮助你确定你的道路。</p><p id="33c1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本文基准测试的代码可以在GitHub 上获得<a class="ae nw" href="https://github.com/cmcquillan/StringCreateBenchmarks" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>