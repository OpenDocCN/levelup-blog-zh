<html>
<head>
<title>Elastic Search Simplified: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化的弹性搜索:第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/elastic-search-simplified-part-1-9f7bd4985ee5?source=collection_archive---------14-----------------------#2020-10-13">https://levelup.gitconnected.com/elastic-search-simplified-part-1-9f7bd4985ee5?source=collection_archive---------14-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dbc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我们使用弹性搜索来实现通配符搜索功能。在花了一个星期的时间之后，我们意识到虽然开始很容易，但是很好地理解弹性搜索的基础，可以帮助以更优化的方式实现解决方案。</p><blockquote class="kl km kn"><p id="5ac7" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">弹性搜索有多个用例，如日志分析、可视化和聚合数据，但本系列与“搜索”用例相关。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/e62daa4ba366ccb8c8846f8e5acaaa05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5iY9BGXbMLpSjpFZ09ziww.png"/></div></div></figure><p id="a352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将讨论以下项目</p><ol class=""><li id="ed98" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">什么是文本搜索</li><li id="a9e7" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">倒排索引</li><li id="32a3" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">TF/IDF</li><li id="b4ba" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">文本分析</li><li id="5de5" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">绘图</li><li id="8491" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">数据类型</li><li id="6067" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">查询类型</li><li id="bf1f" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">子字符串/通配符搜索</li></ol><h1 id="a93d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">什么是文本搜索</h1><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi mq"><img src="../Images/b4e670e1ea62ec6ccbdf549ffc5baa77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUq1Yx3u9X9fU0FgidgLMw.png"/></div></div></figure><p id="a4df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您想在亚马逊上搜索具有特定要求的移动设备，如128gb存储空间、6gb内存和大约15k INR的价格。</p><p id="6ac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们将这些细节存储在SQL表中，如下所示</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi mr"><img src="../Images/392ea15459cbeac63a6364414cd26ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRCVO1HjHyYtziq1rEkMhQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">产品详细信息SQL表</figcaption></figure><p id="700d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须在SQL表中实现这一点，我们可能需要创建如下所示的查询</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="a9ad" class="nb lt iq mx b gy nc nd l ne nf">select * from Products where details like “%mobile” and details like “%4gb%” and details like “%128gb%” and details like “%6gb” and details like “%prices 10000%</span></pre><p id="988f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，这是一个效率极低的全表扫描查询。</p><p id="ae1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个查询可能仍然不起作用，因为查询有一个错别字“价格”而不是“价格”。</p><p id="4f86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的案例中，我们还可以看到“<em class="ko">限时交易</em>”被赋予了更高的优先级。在传统的数据库中添加这种功能将是困难的。</p><p id="8b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到所有这些因素，我们显然需要一个定制的文本搜索解决方案。</p><h1 id="1bb6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">倒排索引</h1><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ng"><img src="../Images/42c5d1ce6b7eef629761e26a2788d1e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ECkcgOyMRGLw1ZLB"/></div></div></figure><p id="a394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">倒排索引是单个术语及其在所有索引文档中的总频率的简单映射。术语“winter”在文档1中出现过一次，术语“The”出现过两次，因此它们被映射到相应的文档id。</p><h1 id="d028" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">TF/IDF</h1><h2 id="10ea" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">TF —术语频率</h2><p id="5e69" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">术语频率就是一个术语在<strong class="jp ir">个体</strong> <strong class="jp ir">给定文档中出现的次数。</strong>对于较长和较短的文档，这将进一步规范化</p><h2 id="6798" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">IDF —反向文档频率</h2><p id="2200" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">它只是表明一个给定的单词在所有索引文档中的稀有程度</p><p id="a729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们运行查询时，我们需要首先返回最相关的结果。为了计算分数，我们使用TF/IDF的概念。让我们借助一个使用外行数学的例子来理解它。</p><blockquote class="kl km kn"><p id="1f83" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">lastic Search确实提供了很大的灵活性来帮助计算分数，比如使用boosts等，但是TF/IDF将有助于理解这个想法。</p></blockquote><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="95f5" class="nb lt iq mx b gy nc nd l ne nf">"The sky is blue.<br/>"The sun is bright today."<br/>"The sun in the sky is bright."<br/>"We can see the shining sun, the bright sun."</span><span id="1905" class="nb lt iq mx b gy nx nd l ne nf"><strong class="mx ir">Inverted Index<br/></strong>+--------+----------------------+-------------------+<br/>|  Term  | total term frequency |    document_id    |<br/>+--------+----------------------+-------------------+<br/>| sky    |                    2 | (1,1) (3,1)       |<br/>| blue   |                    1 | (1,1)             |<br/>| sun    |                    4 | (2,1) (3,1) (4,2) |<br/>| bright |                    3 | (2,1) (3,1) (4,1) |<br/>| shine  |                    1 | (4,1)             |<br/>| today  |                    1 | (2,1)             |<br/>+--------+----------------------+-------------------+</span><span id="0c08" class="nb lt iq mx b gy nx nd l ne nf">The documents have been normalised by removing common terms like is, a, the etc and also words like shining have been stemmed to shine. More on this in the article below</span><span id="5ff5" class="nb lt iq mx b gy nx nd l ne nf"><strong class="mx ir">Term Frequency Table</strong></span><span id="f748" class="nb lt iq mx b gy nx nd l ne nf">+-------------+------+--------+-------+-----+------+-------+<br/>| document_id | blue | bright | shine | sky | sun  | today |<br/>+-------------+------+--------+-------+-----+------+-------+<br/>| 1           |    1 |      0 |     0 |   1 |    0 |     0 |<br/>| 2           |    0 |      1 |     0 |   0 |    1 |     1 |<br/>| 3           |    0 |      1 |     0 |   1 |    1 |     0 |<br/>| 4           |    0 |      1 |     1 |   0 |    2 |     0 |<br/>| n_t         |    1 |      3 |     1 |   2 |    3 |     1 |<br/>+-------------+------+--------+-------+-----+------+-------+<br/>*n_t -&gt; total occurances in all documents</span><span id="6318" class="nb lt iq mx b gy nx nd l ne nf"><strong class="mx ir">Inverse Document Frequency Table</strong></span><span id="7195" class="nb lt iq mx b gy nx nd l ne nf">+------+--------+-------+-----+------+-------+<br/>| blue | bright | shine | sky | sun  | today |<br/>+------+--------+-------+-----+------+-------+<br/>| 4/1  | 4/3    | 4/1   | 4/2 | 4/3  | 4/1   |<br/>+------+--------+-------+-----+------+-------+<br/></span><span id="017f" class="nb lt iq mx b gy nx nd l ne nf"><strong class="mx ir">TF * IDF score for query "sky sun"</strong></span><span id="9a15" class="nb lt iq mx b gy nx nd l ne nf">+-------------+-------------+---------------+-------------+------+<br/>| document_id |  TF * IDF   | matching word | final score | <strong class="mx ir">rank </strong>|<br/>+-------------+-------------+---------------+-------------+------+<br/>|           1 | 1 * 2       | sky           |           2 |    3 |<br/>|           2 | 1* 4/3      | sun           |        1.33 |    4 |<br/>|           <strong class="mx ir">3 | 1*2 + 1*4/3 | sky,sun       |        3.33 |    1</strong> |<br/>|           4 | 2*4/3       | sun           |        2.66 |    2 |<br/>+-------------+-------------+---------------+-------------+------+</span><span id="bf42" class="nb lt iq mx b gy nx nd l ne nf">As we can see term "sky" is less common compared to term "sun", so <strong class="mx ir">sky</strong> has been given <strong class="mx ir">higher weightage</strong> when calculating score</span></pre><blockquote class="kl km kn"><p id="7458" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">这是为了便于理解而进行的简化，真正的公式是不同的，但是思路是一样的，你可以查看<a class="ae ny" href="https://sci2lab.github.io/ml_tutorial/tfidf/" rel="noopener ugc nofollow" target="_blank">链接</a>来深入了解</p></blockquote><h1 id="4bf6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">文本分析</strong></h1><p id="6c0d" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">文本分析使Elasticsearch能够执行全文搜索，搜索返回所有与<em class="ko">相关的</em>结果，而不仅仅是与<strong class="jp ir">完全匹配的</strong></p><p id="506f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ElasticSearch为一些常见的用例提供了分析器，还提供了定义定制分析器的能力。我们将在下面介绍一个标准的分析器，并在本文的后面讨论如何创建一个定制的分析器。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/65d9b0299d65e86b50c2e82909d9f43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*Fyh0wUZ-mWeVzrd-CoNnJg.png"/></div></figure><h2 id="8af7" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">字符过滤器</h2><p id="98f7" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">假设文档中有一些HTML元素，字符过滤器可以帮助删除这些过滤器。这些是可选的。</p><h2 id="acbe" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">标记化者</h2><p id="3e1e" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">记号赋予器用于将文档分解成单独的记号(术语)。例如，我们将在英语文档中使用“空白”</p><h2 id="21c7" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">令牌过滤器</h2><p id="e271" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">令牌过滤器可用于将令牌转换为小写的<em class="ko"/>。一个<em class="ko"> stop </em>令牌过滤器可以用来删除英语中常见的停用词，如“is”、“the”“a”等。另一个常见的需求是将“闪亮”和“闪耀”视为同一术语，这可以通过使用<em class="ko">词干分析器</em>过滤器来实现。</p><blockquote class="kl km kn"><p id="c302" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">还有更多的过滤器和记号赋予器，您可以在弹性搜索文档中找到。</p></blockquote><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="8450" class="nb lt iq mx b gy nc nd l ne nf"><strong class="mx ir">query</strong> localhost:9200/_analyze</span><span id="2ee4" class="nb lt iq mx b gy nx nd l ne nf">{<br/> "char_filter": [<br/>  "html_strip"<br/> ],<br/> "tokenizer": "standard",<br/> "filter": [<br/>  "stop",<br/>  "lowercase",<br/>  "stemmer"<br/> ],<br/> "text": "&lt;b&gt;the sky is <strong class="mx ir">Blue</strong> bright and <strong class="mx ir">shining</strong>&lt;b&gt;"<br/>}</span><span id="89d0" class="nb lt iq mx b gy nx nd l ne nf">{ </span><span id="448e" class="nb lt iq mx b gy nx nd l ne nf">"details" : "&lt;b&gt;the sky is <strong class="mx ir">Blue</strong> bright and <strong class="mx ir">shining</strong>&lt;b&gt;"</span><span id="cc01" class="nb lt iq mx b gy nx nd l ne nf">}</span><span id="a8f3" class="nb lt iq mx b gy nx nd l ne nf"><strong class="mx ir">Output<br/></strong>{<br/> "tokens": [{<br/>   "token": "sky",<br/>   "start_offset": 7,<br/>   "end_offset": 10,<br/>   "type": "&lt;ALPHANUM&gt;",<br/>   "position": 1<br/>  },<br/>  {<br/>   "token": "<strong class="mx ir">blue</strong>",<br/>   "start_offset": 14,<br/>   "end_offset": 18,<br/>   "type": "&lt;ALPHANUM&gt;",<br/>   "position": 3<br/>  },<br/>  {<br/>   "token": "bright",<br/>   "start_offset": 19,<br/>   "end_offset": 25,<br/>   "type": "&lt;ALPHANUM&gt;",<br/>   "position": 4<br/>  },<br/>  {<br/>   "token": "<strong class="mx ir">shine</strong>",<br/>   "start_offset": 30,<br/>   "end_offset": 40,<br/>   "type": "&lt;ALPHANUM&gt;",<br/>   "position": 6<br/>  }<br/> ]<br/>}</span></pre><blockquote class="kl km kn"><p id="3030" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">ElasticSearch提供了现成的常用停用词，同时提供了定义自己列表的灵活性。</p></blockquote><p id="b0df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文本分析分两次进行</p><ul class=""><li id="ee58" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk oa lk ll lm bi translated">指数分析器</li><li id="05b3" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk oa lk ll lm bi translated">搜索分析器</li></ul><p id="daac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文的后面，我们将介绍一个这样的例子。</p><h1 id="8704" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">绘图</h1><p id="7cde" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">映射是定义如何存储和索引文档及其包含的字段的过程。<strong class="jp ir"> Lucene </strong>只理解倒排索引，弹性搜索转换，并根据提供的映射创建适当的倒排索引。</p><blockquote class="kl km kn"><p id="6a0c" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">ElasticSearch索引实际上是Lucene索引，ElasticSearch是Lucene之上的分布式系统。</p></blockquote><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="b517" class="nb lt iq mx b gy nc nd l ne nf">PUT /my-index-000001<br/>{<br/>  "mappings": {<br/>    "properties": {<br/>      "age":    { "type": "integer" },  <br/>      "email":  { "type": "keyword"  }, <br/>      "name":   { "type": "text"  }     <br/>    }<br/>  }<br/>}</span></pre><h2 id="ccad" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">菲尔茨</h2><p id="85ad" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">映射包含与文档相关的字段或属性的列表，每个字段都有自己的数据类型。</p><h2 id="7342" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">动态映射</h2><p id="c68c" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">创建索引时没有必要定义映射，弹性搜索本身会动态创建映射</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="52d0" class="nb lt iq mx b gy nc nd l ne nf">PUT data/_doc/1 <br/>{ "count": 5 }</span><span id="2ada" class="nb lt iq mx b gy nx nd l ne nf"><strong class="mx ir">count </strong>field with data type <strong class="mx ir">long </strong>gets created</span></pre><h1 id="b789" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">数据类型</h1><p id="0d9b" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">支持的数据类型的完整列表可以在此<a class="ae ny" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。我们将讨论两种重要的数据类型</p><h2 id="3b4a" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">关键词</h2><p id="4527" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">关键字字段类型通常包含结构化内容，如id、电子邮件地址、邮政编码、标签等，可用于过滤、排序。</p><h2 id="950a" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">文本</h2><p id="7cdc" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">文本字段类型用于文本分析，我们可以为每个单独的文本字段定义索引和搜索分析器。</p><h1 id="795b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">查询类型</h1><p id="059e" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">ElasticSearch查询可以包含两种类型的子句。详情请使用此<a class="ae ny" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" rel="noopener ugc nofollow" target="_blank">链接</a></p><ul class=""><li id="3e4f" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk oa lk ll lm bi translated"><strong class="jp ir">叶查询子句</strong></li></ul><p id="7e0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">引导查询寻找特定字段中的特定值，例如<em class="ko">匹配、术语</em>或<em class="ko">范围</em></p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="5218" class="nb lt iq mx b gy nc nd l ne nf">GET /_search<br/>{<br/>  "query": {<br/>    "term": {<br/>      "name": {<br/>        "value": "foobar",<br/>        "boost": 1.0<br/>      }<br/>    }<br/>  }<br/>}</span></pre><ul class=""><li id="847b" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk oa lk ll lm bi translated"><strong class="jp ir">复合查询子句</strong></li></ul><p id="fae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复合查询子句包装其他<strong class="jp ir">叶查询或复合查询</strong>，并用于以逻辑方式组合多个查询</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="307e" class="nb lt iq mx b gy nc nd l ne nf">Example of boolean query</span><span id="fccf" class="nb lt iq mx b gy nx nd l ne nf">POST _search<br/>{<br/>  "query": {<br/>    "bool" : {<br/>      "<strong class="mx ir">must</strong>" : {<br/>        "term" : { "user.id" : "kimchy" }<br/>      },<br/>      "<strong class="mx ir">filter</strong>": {<br/>        "term" : { "tags" : "production" }<br/>      },<br/>      "<strong class="mx ir">must_not</strong>" : {<br/>        "range" : {<br/>          "age" : { "gte" : 10, "lte" : 20 }<br/>        }<br/>      },<br/>      "<strong class="mx ir">should</strong>" : [<br/>        { "term" : { "tags" : "env1" } },<br/>        { "term" : { "tags" : "deployed" } }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><h1 id="7907" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">子字符串搜索/N元语法过滤器</h1><p id="6a4f" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">我们研究了使用弹性搜索进行子串/通配符搜索的用例。</p><p id="b4f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑一个带有名称的文档索引</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="b7eb" class="nb lt iq mx b gy nc nd l ne nf">{<br/> "name": "nitin agarwal"<br/>}, {<br/> "name": "nitish"<br/>}</span></pre><p id="b68a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想要搜索“nit*”，在传统的数据库中，字段上的普通索引将返回结果，因为我们正在进行“以查询开始”(添加了名称≥ nit和名称&lt; niu).</p><h2 id="1e04" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">Edge N-gram</h2><p id="a11f" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">But as we use inverted indexes in elastic search, and we would need to use something called “edge N-gram”.</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="1b60" class="nb lt iq mx b gy nc nd l ne nf">Edge N-gram for word "<strong class="mx ir">nitin</strong>"  doc_id -&gt; 1</span><span id="ca09" class="nb lt iq mx b gy nx nd l ne nf">unigram - ['n']  -&gt; 1<br/>bigram - ['ni']  -&gt; 1<br/>trigram - ['nit'] <br/>quadgram - ['niti']<br/>hexagram - ['nitin']</span><span id="93d6" class="nb lt iq mx b gy nx nd l ne nf">An inverted index is created with the above configuration for a quick lookup.</span></pre><h2 id="56b9" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">Wildcard Queries</h2><p id="67e7" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">Let's take the example of a “*iti*” query. Elastic Search does provide the functionality of wildcard queries</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="2636" class="nb lt iq mx b gy nc nd l ne nf">GET /_search<br/>{<br/>  "query": {<br/>    "wildcard": {<br/>      "name": {<br/>        "value": "*iti*",<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="5273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">But this query is actually doing a full index scan and will be extremely slow.</p><h2 id="7b4d" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">N-gram</h2><p id="773b" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">We can define the max and min length of chunks to be created from a given term and token will be created like below</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="92b4" class="nb lt iq mx b gy nc nd l ne nf">min_len = 2, max_len = 5, term = ["nitin"]<br/>["ni", "it", "ti", "in"]<br/>["nit", "iti", "tin"]<br/>["niti", "itin"]<br/>["nitin"]</span></pre><blockquote class="kl km kn"><p id="22d7" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">With Version 7.9 <a class="ae ny" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/keyword.html#wildcard-field-type" rel="noopener ugc nofollow" target="_blank">通配符字段类型</a>，这与创建N元语法相比存储效率更高。通配符字段类型没有完全解决我们的用例，所以我们继续使用我们定制的N-gram解决方案</p></blockquote><h1 id="0467" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">索引和搜索分析器</strong></h1><p id="c47c" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">我们的搜索实现有以下要求</p><ul class=""><li id="1ac9" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk oa lk ll lm bi translated">通配符搜索</li><li id="7bb8" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk oa lk ll lm bi translated">名称可以包含Unicode字符，例如，如果用户搜索“ϟth”，像“ϟTHOST⁷⁷”这样的名称应该是可搜索的</li><li id="15f0" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk oa lk ll lm bi translated">不需要空格分割，例如，如果用户搜索“op ja”，像“op jap”这样的名称应该是可搜索的</li><li id="5a7d" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk oa lk ll lm bi translated">最大搜索字符长度为10个字符，否则，用户将搜索完全匹配的字符。</li></ul><p id="96a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们必须为我们的特定需求创建一个定制的索引分析器。</p><h2 id="c5e0" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">自定义索引分析器</h2><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="f43d" class="nb lt iq mx b gy nc nd l ne nf">{</span><span id="71a6" class="nb lt iq mx b gy nx nd l ne nf">"analysis": {<br/>  "analyzer": {<br/>   "ngram_custom_analyser": {<br/>    "tokenizer": "ngram_tokenizer",<br/>    "filter": [<br/>     "lowercase" ----------------&gt; <strong class="mx ir">added lowercase filter</strong><br/>    ]<br/>   }<br/>  },<br/>  "tokenizer": {<br/>   "ngram_tokenizer": {<br/>    "type": "ngram", -----------&gt; <strong class="mx ir">defines type as ngram</strong><br/>    "min_gram": 2,   -----------&gt; <strong class="mx ir">defines the min len</strong><br/>    "max_gram": 10,  -----------&gt; <strong class="mx ir">defines the max len</strong><br/>    "token_chars": [----&gt; <strong class="mx ir">defines signs which should be included</strong><br/>     "letter",<br/>     "punctuation",<br/>     "whitespace",  ------------&gt; <strong class="mx ir">allow whitespace</strong><br/>     "digit",    <br/>     "symbol"    --------------&gt; <strong class="mx ir">allow symbols</strong><br/>    ]<br/>   }<br/>  }<br/> }<br/>}</span><span id="2a8a" class="nb lt iq mx b gy nx nd l ne nf">{<br/> "mappings": {<br/>  "properties": {<br/>   "name": {<br/>    "type": "text",<br/>    "analyzer": "ngram_custom_analyser",<br/>    "search_analyzer": "custom_search_analyzer"<br/>   }<br/>  }<br/> }<br/>}</span></pre><h2 id="4fe6" class="nb lt iq bd lu nh ni dn ly nj nk dp mc jy nl nm mg kc nn no mk kg np nq mo nr bi translated">自定义搜索分析器</h2><p id="5b3c" class="pw-post-body-paragraph jn jo iq jp b jq ns js jt ju nt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">我们还需要在字段上定义一个自定义搜索分析器，因为默认情况下，弹性搜索会将搜索查询拆分为字段上定义的N元语法标记，例如，“nitin ag”会被拆分为N元语法，如“ni”、“it”等，这些会被搜索，从而给出错误的结果。</p><pre class="kt ku kv kw gt mw mx my mz aw na bi"><span id="8027" class="nb lt iq mx b gy nc nd l ne nf">{<br/> "analyzer": {<br/>  "custom_search_analyzer": {<br/>   "tokenizer": "ngram_search_tokenizer",<br/>   "filter": [<br/>    "lowercase"<br/>   ]<br/>  }<br/> },<br/> "tokenizer": {<br/>  "ngram_search_tokenizer": {<br/>   "type": "char_group",<br/>   "token_chars": [ -----&gt; <strong class="mx ir">defines signs which should be inclued</strong><br/>    "letter",<br/>    "punctuation",<br/>    "whitespace",  ------&gt; <strong class="mx ir">allow whitespace in search query</strong><br/>    "digit",<br/>    "symbol" --------&gt; <strong class="mx ir">allow symbols in search query</strong><br/>   ]<br/>  }<br/> }<br/>}</span></pre><p id="ad99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这种方法的优势</strong></p><ul class=""><li id="aab4" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk oa lk ll lm bi translated">搜索会非常快，因为我们会做直接匹配。</li></ul><p id="cab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这种方法的缺点</strong></p><ul class=""><li id="b71d" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk oa lk ll lm bi translated">与普通的标准分析器相比，这将占用更多的存储空间，但是在我们的用例中，我们可以删除超过1个月的文档。</li></ul><p id="56b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用弹性搜索，您将需要尝试找到最符合您要求的解决方案。</p><p id="3d10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他未涉及的与搜索相关的有趣主题包括</p><ul class=""><li id="809a" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk oa lk ll lm bi translated"><a class="ae ny" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html" rel="noopener ugc nofollow" target="_blank">模糊查询</a> y</li><li id="933b" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk oa lk ll lm bi translated">匹配短语查询</li></ul><p id="52f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ny" href="https://medium.com/@nitinagg.nitkkr/elastic-search-simplified-part-2-342a55a1a7c7" rel="noopener"> <strong class="jp ir">第二部分</strong> </a>本文我们来谈谈弹性搜索集群以及关于索引和搜索请求的旅程。</p></div></div>    
</body>
</html>