<html>
<head>
<title>Throttle in JavaScript: Improve Your Application’s Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的节流:提高应用程序的性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/throttle-in-javascript-improve-your-applications-performance-984a4e020a3f?source=collection_archive---------0-----------------------#2020-01-07">https://levelup.gitconnected.com/throttle-in-javascript-improve-your-applications-performance-984a4e020a3f?source=collection_archive---------0-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8b1d455050acb354680e50ea75d5dc76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fw3_7Lx21RCAcfwew4kmOw.gif"/></div></div></figure><p id="a960" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://skilled.dev/course/throttle" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="la">原载于</em> </strong> </a></p><p id="5a0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">节流是浏览器中常用的一种技术，通过限制代码需要处理的事件数量来提高应用程序的性能。当您希望以受控的速率执行回调时，应该使用throttle，允许您在每个固定的时间间隔重复处理中间状态。</p><p id="e27a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将从现实世界的类比开始，然后描述web环境中的节流，最后提供一个如何实现节流的注释代码示例。在文章的最后，有一个带有throttle示例的Codepen，您可以与它进行交互来查看它的工作情况。如果您只关心代码，请跳到“用JavaScript实现节流”一节。</p><p id="dab7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">throttle是<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/debounce-in-javascript-improve-your-applications-performance-5b01855e086?source=friends_link&amp;sk=609d18e56befb764f6606141a2eaf481">去抖</a>的表亲，它们都提高了web应用程序的性能。但是，它们用于不同的情况。当您只关心最终状态时，可以使用去抖。例如，等待直到用户停止键入来获取提前键入搜索结果。当你想处理所有的中间状态，但速度可控时，最好使用节流。例如，在用户调整窗口大小时跟踪屏幕宽度，并在页面内容改变时重新排列页面内容，而不是等到用户完成。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lb"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><p id="c0da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建和维护一份简历并不有趣。相反，让我们为你生成一份令人敬畏的简历:)<a class="ae kz" href="https://gitconnected.com/resume-builder" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">简历生成器&gt; </strong> </a></p><div class="lg lh gp gr li lj"><a href="https://gitconnected.com/resume-builder" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iu gy z fp lo fr fs lp fu fw is bi translated">软件工程师简历生成器和示例| gitconnected</h2><div class="lq l"><h3 class="bd b gy z fp lo fr fs lp fu fw dk translated">一份有价值的简历模板，使用您个人资料中的详细信息构建。从你的投资组合网站链接到你的简历或…</h3></div><div class="lr l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">gitconnected.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx jz lj"/></div></div></a></div><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lb"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h2 id="7f7e" class="ly lz it bd ma mb mc dn md me mf dp mg km mh mi mj kq mk ml mm ku mn mo mp mq bi translated">Web开发环境中的节流</h2><p id="89c3" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">假设您有一个scroll事件处理程序，您希望在用户向下移动页面时向他们显示新内容。如果我们在用户每次滚动一个像素时执行回调，那么当用户快速滚动时，我们会很快被事件堵塞，因为它会连续发送成百上千个事件。相反，我们节流它，以便我们只检查滚动量每100毫秒，所以我们得到每秒只有10个回调。对于用户来说，响应仍然是即时的，但是计算效率更高。</p><p id="92a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">throttle创建均匀分布的函数调用。想象一下，如果您正在事件处理程序回调函数中执行一些繁重的计算或API请求。通过限制这些回调，您可以防止应用程序冻结或不必要地向您的服务器发送请求。</p><h2 id="b3a2" class="ly lz it bd ma mb mc dn md me mf dp mg km mh mi mj kq mk ml mm ku mn mo mp mq bi translated">JavaScript中的节流实现</h2><p id="6fba" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">让我们立即进入油门的代码。我将在下面描述它，然后提供该函数的注释版本。</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><blockquote class="my mz na"><p id="0fcc" class="kb kc la kd b ke kf kg kh ki kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ky im bi translated">这个throttle实现应该是最简单易懂的。它是出于教育目的，并不一定是最有效的或使用最少的代码行。</p></blockquote><p id="13fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">throttle是一个高阶函数，它是一个返回另一个函数的函数(为了清楚起见，这里命名为<code class="fe ne nf ng nh b">throttledEventHandler</code>)。这样做是为了在<code class="fe ne nf ng nh b">callback</code>、<code class="fe ne nf ng nh b">delay</code>、<code class="fe ne nf ng nh b">throttleTimeout</code>和<code class="fe ne nf ng nh b">storedEvent</code>功能参数周围形成一个<a class="ae kz" href="https://medium.freecodecamp.org/lets-learn-javascript-closures-66feb44f6a44" rel="noopener ugc nofollow" target="_blank">闭合</a>。这保存了执行<code class="fe ne nf ng nh b">throttledEventHandler</code>时要读取的每个变量的值。以下是每个变量的定义:</p><ul class=""><li id="fb80" class="ni nj it kd b ke kf ki kj km nk kq nl ku nm ky nn no np nq bi translated"><code class="fe ne nf ng nh b">callback</code>:希望以给定速率执行的节流功能。</li><li id="4bd0" class="ni nj it kd b ke nr ki ns km nt kq nu ku nv ky nn no np nq bi translated"><code class="fe ne nf ng nh b">delay</code>:您希望节流功能在执行<code class="fe ne nf ng nh b">callback</code>之间等待的时间。</li><li id="7a1e" class="ni nj it kd b ke nr ki ns km nt kq nu ku nv ky nn no np nq bi translated"><code class="fe ne nf ng nh b">throttleTimeout</code>:用于指示我们<code class="fe ne nf ng nh b">setTimeout</code>创建的运行油门的值。</li><li id="71b2" class="ni nj it kd b ke nr ki ns km nt kq nu ku nv ky nn no np nq bi translated"><code class="fe ne nf ng nh b">storedEvent</code>:你想用节流<code class="fe ne nf ng nh b">callback</code>处理的事件。该值将不断更新，直到节流结束。然后，它将使用最近的值执行<code class="fe ne nf ng nh b">callback</code>。</li></ul><p id="a2ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以在下面的代码中使用我们的throttle:</p><pre class="lc ld le lf gt nw nh nx ny aw nz bi"><span id="5c8f" class="ly lz it nh b gy oa ob l oc od">var returnedFunction = throttle(function() {<br/>  // Do all the taxing stuff and API requests<br/>}, 500);<br/><br/>window.addEventListener('scroll', returnedFunction);</span></pre><p id="15a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于throttle返回一个函数，第一个示例中的<code class="fe ne nf ng nh b">throttledEventHandler</code>和第二个示例中的<code class="fe ne nf ng nh b">returnedFunction</code>函数实际上是同一个函数。用户每滚动一次就会执行<code class="fe ne nf ng nh b">throttledEventHandler</code> / <code class="fe ne nf ng nh b">returnedFunction</code>。</p><p id="c338" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们逐步了解当我们限制一个函数时会发生什么。首先，我们围绕变量创建一个闭包，这样每次执行时它们都可以被<code class="fe ne nf ng nh b">throttledEventHandler</code>使用。<code class="fe ne nf ng nh b">throttledEventHandler</code>接收1个自变量，即为事件。它将此事件存储在<code class="fe ne nf ng nh b">storedEvent</code>变量中。</p><p id="6296" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们检查是否有超时运行。主动节流阀)。如果我们确实有一个节流阀，那么<code class="fe ne nf ng nh b">throttledEventHandler</code>已经完成了这个执行并等待执行回调。如果油门没有被激活，我们可以通过回调函数立即处理这个事件。然后我们调用<code class="fe ne nf ng nh b">setTimeout</code>并存储超时值，这表明我们的油门正在运行。</p><p id="ee08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当超时处于活动状态时，总是存储最近的事件。回调执行被绕过，这使我们不必执行CPU密集型任务或调用我们的API。</p><p id="8031" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当<code class="fe ne nf ng nh b">setTimeout</code>结束时，我们将<code class="fe ne nf ng nh b">throttleTimeout</code>置空，表示该功能不再受限制，可以处理事件。如果有<code class="fe ne nf ng nh b">storedEvent</code>的话，我们想立即处理它，为此我们递归地调用<code class="fe ne nf ng nh b">throttledEventHandler</code>。<code class="fe ne nf ng nh b">setTimeout</code>内部的递归调用允许我们以恒定的速率处理事件。只要新的事件继续出现，它就会在一个期望的延迟后重复执行相同的过程。</p><p id="f325" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该函数的注释版本也是如此:</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="f5c9" class="ly lz it bd ma mb mc dn md me mf dp mg km mh mi mj kq mk ml mm ku mn mo mp mq bi translated">交互式示例</h2><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="oe mx l"/></div></figure><h2 id="8b28" class="ly lz it bd ma mb mc dn md me mf dp mg km mh mi mj kq mk ml mm ku mn mo mp mq bi translated">包裹</h2><p id="f25e" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">对于JavaScript开发人员来说，节流是一个非常重要且值得学习的概念。这是一种提高web应用程序性能的常用工具，从头开始实现节流也加强了高级JS技术，例如闭包、异步事件处理、高阶函数和递归。</p><p id="0777" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">—<a class="ae kz" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank">@特雷胡芬</a> | <a class="ae kz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank"> @gitconnected </a></p></div></div>    
</body>
</html>