<html>
<head>
<title>Mocking Outbound HTTP Calls in Golang — interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模仿Golang-interfaces中的出站HTTP调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mocking-outbound-http-calls-in-golang-9e5a044c2555?source=collection_archive---------0-----------------------#2020-12-14">https://levelup.gitconnected.com/mocking-outbound-http-calls-in-golang-9e5a044c2555?source=collection_archive---------0-----------------------#2020-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/07c7cee521ea37ec9c7db2b7bd8d7a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqBdXbhZiIEU2Iv6py48ug.jpeg"/></div></div></figure><p id="670a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在的工程师有这么多很酷的API可以使用。你可以通过谷歌搜索找到满足特定需求的API。我们有<a class="ae kz" href="https://www.twilio.com/" rel="noopener ugc nofollow" target="_blank"> Twilio </a>用于发送电子邮件/传真/短信，<a class="ae kz" href="https://therundown.io/api" rel="noopener ugc nofollow" target="_blank">丛林奇兵</a>用于实时体育比分和赔率，或者<a class="ae kz" href="https://www.airbnb.com/partner" rel="noopener ugc nofollow" target="_blank"> Airbnb </a>用于管理你的房源。您也可以前往<a class="ae kz" href="https://rapidapi.com/collection/recommended-apis" rel="noopener ugc nofollow" target="_blank"> RapidAPI </a>网站，发现数百种API以满足任何需求。</p><p id="d7e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Golang中进行出站HTTP调用非常容易，但是当您测试使用第三方API的代码时，您最不想做的事情就是为此进行真正的调用。原因有很多:您的CI/CD管道可能不允许出站调用，调用可能需要太长时间来响应，您可能需要为调用API付费，等等。在这种情况下，嘲笑是很有意义的。幸运的是，嘲笑这些电话几乎和打电话一样简单。在这篇文章中，我们将看看一个模仿出站HTTP调用的简单模式。</p><blockquote class="lb lc ld"><p id="b7f6" class="kb kc la kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated"><strong class="kd iu">注</strong>:这篇帖子很大程度上是受<a class="ae kz" href="https://www.linkedin.com/in/sophiedebenedetto/" rel="noopener ugc nofollow" target="_blank"> Sophie DeBenedetto </a>写的一篇的启发，你可以在这里查看:<a class="ae kz" href="https://www.thegreatcodeadventure.com/mocking-http-requests-in-golang/" rel="noopener ugc nofollow" target="_blank">https://www . the greatcodeadventure . com/mocking-http-requests-in-golang/</a>。我真的很喜欢她的解决方案，你会发现这里是她的代码略有修改的版本。</p></blockquote></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="5af0" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">设置</h1><p id="f207" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">出于本文的目的，我有意使我的代码尽可能简单。我想把重点放在对电话的嘲讽上，而不是别的。因此，这是一个单一功能的Golang项目，它将调用GitHub来检索给定用户的所有回购。简单扼要。GitHub API可以在未经认证的情况下使用，所以这样更好！让我们从<code class="fe mr ms mt mu b">github.go</code>文件开始:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="9eba" class="nd lp it mu b gy ne nf l ng nh">package github</span><span id="4e9d" class="nd lp it mu b gy ni nf l ng nh">import (<br/> "encoding/json"<br/> "fmt"<br/> "net/http"<br/>)</span><span id="6fa2" class="nd lp it mu b gy ni nf l ng nh">// GetRepos takes a username and retreives<br/>func GetRepos(username string) ([]map[string]interface{}, error) {<br/> <br/> url := fmt.Sprintf("https://api.github.com/users/%s/repos?sort=created&amp;direction=desc", username)</span><span id="3734" class="nd lp it mu b gy ni nf l ng nh"> request, err := http.NewRequest(http.MethodGet, url, nil)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="fec7" class="nd lp it mu b gy ni nf l ng nh"> client := &amp;http.Client{}<br/> response, err := client.Do(request)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="1543" class="nd lp it mu b gy ni nf l ng nh">defer response.Body.Close()</span><span id="50c9" class="nd lp it mu b gy ni nf l ng nh"> m := []map[string]interface{}{}<br/> err = json.NewDecoder(response.Body).Decode(&amp;m)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="9c53" class="nd lp it mu b gy ni nf l ng nh">return m, nil<br/>}</span></pre><p id="d219" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里没有太多内容，但还是让我们解开这段代码:</p><ul class=""><li id="461d" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated">首先，该函数将GitHub用户名作为一个参数，并立即将其放入一个格式化的URL中，请求返回按回购的“创建日期”降序排序的结果。</li><li id="f24e" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">接下来，我们有正常的出站HTTP调用代码:创建一个请求，创建一个客户机，然后进行调用。</li><li id="98f9" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">最后，我们将响应的主体映射到一个<code class="fe mr ms mt mu b">[]map[string]interface{}</code>来从函数返回JSON。对于这个例子来说，这并不是真正需要的，但是它使得编写测试变得更加容易；)</li></ul><p id="5c06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们来看一下<code class="fe mr ms mt mu b">github_test.go</code>文件:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="f74d" class="nd lp it mu b gy ne nf l ng nh">package github</span><span id="af63" class="nd lp it mu b gy ni nf l ng nh">import (<br/> "testing"<br/>)</span><span id="d757" class="nd lp it mu b gy ni nf l ng nh">func TestGitHubCallSuccess(t *testing.T) {<br/> result, err := GetRepos("atkinsonbg")<br/> if err != nil {<br/>  t.Error("TestGitHubCallSuccess failed.")<br/>  return<br/> }</span><span id="02c9" class="nd lp it mu b gy ni nf l ng nh"> if len(result) == 0 {<br/>  t.Error("TestGitHubCallSuccess failed, array was empty.")<br/>  return<br/> }</span><span id="7d27" class="nd lp it mu b gy ni nf l ng nh"> if result[0]["full_name"] != "atkinsonbg/unittest-outbound-http-calls-golang" {<br/>  t.Error("TestGitHubCallSuccess failed, array was not sorted correctly.")<br/>  return<br/> }<br/>}</span><span id="6b9d" class="nd lp it mu b gy ni nf l ng nh">func TestGitHubCallFail(t *testing.T) {<br/> _, err := GetRepos("atkinsonbgthisusershouldnotexist")<br/> if err == nil {<br/>  t.Error("TestGitHubCallFail failed.")<br/>  return<br/> }<br/>}</span></pre><p id="70f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里没有太多要测试的，但是我们也将打开这个:</p><ul class=""><li id="0abb" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated">TestGitHubCallSuccess调用我们的<code class="fe mr ms mt mu b">GetRepos</code>函数，传递一个有效的用户名。它首先检查JSON数组中是否有内容，然后获取第一个结果以确保我们期望的名称存在。</li><li id="c8cd" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">TestGitHubCallFail还调用我们的<code class="fe mr ms mt mu b">GetRepos</code>函数，传入一个非常无效的用户名。它确保函数抛出适当的错误。</li></ul><p id="cb56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以运行一个<code class="fe mr ms mt mu b">go test -v ./... -coverpkg ./... -coverprofile cover.out</code>命令，看到我们得到了85.7%的覆盖率！不算太寒酸！！</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="7624" class="nd lp it mu b gy ne nf l ng nh">Users-Air:unittest-outbound-http-calls-golang user$ go test -v ./... -coverpkg ./... -coverprofile cover.out<br/>=== RUN   TestGitHubCallSuccess<br/>--- PASS: TestGitHubCallSuccess (0.35s)<br/>=== RUN   TestGitHubCallFail<br/>--- PASS: TestGitHubCallFail (0.04s)<br/>PASS<br/>coverage: 85.7% of statements in ./...<br/>ok      _/Users/user/Documents/GitHub/atkinsonbg/unittest-outbound-http-calls-golang    0.411s  coverage: 85.7% of statements in ./...</span></pre><p id="9b1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，这个测试有一个明显的问题。我们在测试中实际调用了GitHub。这是站不住脚的。现在让我们继续，模拟这个调用，同时仍然实现我们的高代码覆盖率！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="acbf" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">嘲笑它直到你成功</h1><p id="cedf" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">一般来说，在Go中，如果你想模仿某个东西，你可以创建一个接口。反之亦然，如果你有一个接口，你可以很容易地嘲笑它。<em class="la">(抱歉打哑谜，很快就清楚了。)</em> Go关于接口的官方文档可以在这里<a class="ae kz" href="https://golang.org/doc/effective_go.html#interfaces" rel="noopener ugc nofollow" target="_blank">找到</a>，它提供了一个很好的解释:</p><blockquote class="lb lc ld"><p id="f4e1" class="kb kc la kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated">Go中的接口提供了一种指定对象行为的方式:如果某个东西可以做<em class="it">这个</em>，那么它就可以用<em class="it">这里</em>。</p></blockquote><p id="08a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://www.linkedin.com/in/nathanleclaire/" rel="noopener ugc nofollow" target="_blank"> Nathan LeClaire </a>在Golang中写了一篇关于接口和有效测试的<a class="ae kz" href="https://nathanleclaire.com/blog/2015/10/10/interfaces-and-composition-for-effective-unit-testing-in-golang/" rel="noopener ugc nofollow" target="_blank">好文章，他总结为:</a></p><blockquote class="lb lc ld"><p id="98dd" class="kb kc la kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated">接口允许您定义一组方法，一个类型(通常是<code class="fe mr ms mt mu b">struct</code>)必须定义这些方法才能被认为是接口的实现。</p><p id="f077" class="kb kc la kd b ke kf kg kh ki kj kk kl le kn ko kp lf kr ks kt lg kv kw kx ky im bi translated">当任何给定的类型实现了该接口的所有方法时，Go编译器自动知道它被允许作为该类型使用。</p></blockquote><p id="2c90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在最棒的部分是，我们<strong class="kd iu">不必实现接口/结构上的所有</strong>方法来实现它(<em class="la">然而，如果你想使用它，你必须实现它</em>)。在我们的代码中，我们确实需要模仿Go的HTTP客户端，但是我们确实不需要模仿所有的方法。我们只使用Do方法，所以这是我们唯一关心的方法。如果我们看一下<a class="ae kz" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank"> http包</a>的官方文档，我们可以看到<a class="ae kz" href="https://golang.org/pkg/net/http/#pkg-index" rel="noopener ugc nofollow" target="_blank">客户机结构</a>是如何定义的。它由六个函数组成:CloseIdleConnections、Do、Get、Head、Post和PostForm。在我们的代码中，我们使用的是Do函数，所以这是我们唯一关心的模拟函数。</p><p id="0b1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://golang.org/pkg/net/http/#Client.Do" rel="noopener ugc nofollow" target="_blank"> Do功能</a>定义为:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="c1dd" class="nd lp it mu b gy ne nf l ng nh">func (c *<a class="ae kz" href="https://golang.org/pkg/net/http/#Client" rel="noopener ugc nofollow" target="_blank">Client</a>) Do(req *<a class="ae kz" href="https://golang.org/pkg/net/http/#Request" rel="noopener ugc nofollow" target="_blank">Request</a>) (*<a class="ae kz" href="https://golang.org/pkg/net/http/#Response" rel="noopener ugc nofollow" target="_blank">Response</a>, <a class="ae kz" href="https://golang.org/pkg/builtin/#error" rel="noopener ugc nofollow" target="_blank">error</a>)</span></pre><p id="dfb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，当需要模拟我们的HTTP调用时，这是我们必须匹配的签名。现在我们有了这些信息，我们可以开始重新编写代码来支持嘲讽。下面是<code class="fe mr ms mt mu b">github.go</code>文件现在的样子:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="52ea" class="nd lp it mu b gy ne nf l ng nh">package github</span><span id="d5ab" class="nd lp it mu b gy ni nf l ng nh">import (<br/> "encoding/json"<br/> "fmt"<br/> "net/http"<br/>)</span><span id="26ac" class="nd lp it mu b gy ni nf l ng nh">// HTTPClient interface<br/>type HTTPClient interface {<br/> Do(req *http.Request) (*http.Response, error)<br/>}</span><span id="cc19" class="nd lp it mu b gy ni nf l ng nh">var (<br/> Client HTTPClient<br/>)</span><span id="451b" class="nd lp it mu b gy ni nf l ng nh">func init() {<br/> Client = &amp;http.Client{}<br/>}</span><span id="d1c2" class="nd lp it mu b gy ni nf l ng nh">// GetRepos takes a username and retreives<br/>func GetRepos(username string) ([]map[string]interface{}, error) {<br/> <br/> url := fmt.Sprintf("https://api.github.com/users/%s/repos?sort=created&amp;direction=desc", username)</span><span id="ed60" class="nd lp it mu b gy ni nf l ng nh"> request, err := http.NewRequest(http.MethodGet, url, nil)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="cd59" class="nd lp it mu b gy ni nf l ng nh"> response, err := Client.Do(request)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="1940" class="nd lp it mu b gy ni nf l ng nh"> defer response.Body.Close()</span><span id="7001" class="nd lp it mu b gy ni nf l ng nh"> m := []map[string]interface{}{}<br/> err = json.NewDecoder(response.Body).Decode(&amp;m)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="f9fe" class="nd lp it mu b gy ni nf l ng nh">return m, nil<br/>}</span></pre><p id="7d9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将深入探讨四个显著的差异:</p><ul class=""><li id="d98d" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated">首先，我们定义了一个名为<code class="fe mr ms mt mu b">HTTPClient</code>的新接口，它有一个名为<code class="fe mr ms mt mu b">Do</code>的方法，恰好匹配Go http包Do的签名模式。</li><li id="6d18" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">接下来，我们创建一个名为<code class="fe mr ms mt mu b">Client</code>的包级变量，它是<code class="fe mr ms mt mu b">HTTPClient</code>的一种。这是我们将用来进行所有出站HTTP调用的变量。因为这是一个包级别的声明，并且我们的测试在同一个包中，他们将能够在以后将这个变量设置为一个模拟的客户端。</li><li id="8b27" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">在我们的包初始化函数中，我们将变量<code class="fe mr ms mt mu b">Client</code>设置为Go的http包客户端的一个实例。</li><li id="7dfa" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">最后，在我们的代码中，当我们进行<code class="fe mr ms mt mu b">Do</code>调用时，我们使用我们的<code class="fe mr ms mt mu b">Client</code>变量:<code class="fe mr ms mt mu b">reponse,err := Client.Do(request)</code></li></ul><p id="99bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在有了要模拟的主要代码设置。我们可以再次运行我们的测试，应该没有什么变化。输出将是完全相同的，包括代码覆盖率。这里最大的不同是，我们现在可以模拟我们的HTTP调用了！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="264c" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">实现模拟调用</h1><p id="28e5" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">现在我们已经有了主代码设置，我们可以修改我们的测试来注入一个模拟的<code class="fe mr ms mt mu b">Do</code>调用。让我们看看<code class="fe mr ms mt mu b">github_test.go</code>文件中的代码:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="5261" class="nd lp it mu b gy ne nf l ng nh">package github</span><span id="7a41" class="nd lp it mu b gy ni nf l ng nh">import (<br/> "bytes"<br/> "errors"<br/> "io/ioutil"<br/> "net/http"<br/> "testing"<br/>)</span><span id="b843" class="nd lp it mu b gy ni nf l ng nh">// Custom type that allows setting the func that our Mock Do func will run instead<br/>type MockDoType func(req *http.Request) (*http.Response, error)</span><span id="042f" class="nd lp it mu b gy ni nf l ng nh">// MockClient is the mock client<br/>type MockClient struct {<br/> MockDo MockDoType<br/>}</span><span id="f892" class="nd lp it mu b gy ni nf l ng nh">// Overriding what the Do function should "do" in our MockClient<br/>func (m *MockClient) Do(req *http.Request) (*http.Response, error) {<br/> return m.MockDo(req)<br/>}</span><span id="13c2" class="nd lp it mu b gy ni nf l ng nh">func TestGitHubCallSuccess(t *testing.T) {</span><span id="a50a" class="nd lp it mu b gy ni nf l ng nh"> // build our response JSON<br/> jsonResponse := `[{<br/>   "full_name": "mock-repo"<br/>  }]`</span><span id="be77" class="nd lp it mu b gy ni nf l ng nh"> // create a new reader with that JSON<br/> r := ioutil.NopCloser(bytes.NewReader([]byte(jsonResponse)))</span><span id="ca44" class="nd lp it mu b gy ni nf l ng nh"> Client = &amp;MockClient{<br/>  MockDo: func(*http.Request) (*http.Response, error) {<br/>   return &amp;http.Response{<br/>    StatusCode: 200,<br/>    Body:       r,<br/>   }, nil<br/>  },<br/> }</span><span id="a5c7" class="nd lp it mu b gy ni nf l ng nh"> result, err := GetRepos("atkinsonbg")<br/> if err != nil {<br/>  t.Error("TestGitHubCallSuccess failed.")<br/>  return<br/> }</span><span id="26c2" class="nd lp it mu b gy ni nf l ng nh"> if len(result) == 0 {<br/>  t.Error("TestGitHubCallSuccess failed, array was empty.")<br/>  return<br/> }</span><span id="3386" class="nd lp it mu b gy ni nf l ng nh"> if result[0]["full_name"] != "mock-repo" {<br/>  t.Error("TestGitHubCallSuccess failed, array was not sorted correctly.")<br/>  return<br/> }<br/>}</span><span id="5cb1" class="nd lp it mu b gy ni nf l ng nh">func TestGitHubCallFail(t *testing.T) {</span><span id="d9e8" class="nd lp it mu b gy ni nf l ng nh"> // create a client that throws and returns an error<br/> Client = &amp;MockClient{<br/>  MockDo: func(*http.Request) (*http.Response, error) {<br/>   return &amp;http.Response{<br/>    StatusCode: 404,<br/>    Body:       nil,<br/>   }, errors.New("Mock Error")<br/>  },<br/> }</span><span id="5248" class="nd lp it mu b gy ni nf l ng nh"> _, err := GetRepos("atkinsonbgthisusershouldnotexist")<br/> if err == nil {<br/>  t.Error("TestGitHubCallFail failed.")<br/>  return<br/> }<br/>}</span></pre><p id="752c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在这里还有更多的东西，但是这是一个很好的可重复模式，提供了大量的灵活性。让我们来分解一下:</p><ul class=""><li id="9072" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated">首先，我们创建一个名为<code class="fe mr ms mt mu b">MockDoType</code>的新<code class="fe mr ms mt mu b">type</code>，它与Go http包的<code class="fe mr ms mt mu b">Do</code>函数具有相同的签名。</li><li id="f911" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">接下来，我们创建一个名为<code class="fe mr ms mt mu b">MockClient</code>的<code class="fe mr ms mt mu b">struct</code>，它有一个名为<code class="fe mr ms mt mu b">MockDo</code>的属性，这是我们新创建的<code class="fe mr ms mt mu b">MockDoType</code>。</li><li id="87c4" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">最后，我们将一个<code class="fe mr ms mt mu b">Do</code>方法挂在我们的<code class="fe mr ms mt mu b">MockClient</code>结构上，该结构也具有与http包的<code class="fe mr ms mt mu b">Do</code>函数相同的签名。这里的主要区别是，它所做的只是转过身，将<code class="fe mr ms mt mu b">request</code>交给<code class="fe mr ms mt mu b">MockDoType</code>运行。</li></ul><p id="c9c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们的每个测试中，我们可以编写这样的代码:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="87b3" class="nd lp it mu b gy ne nf l ng nh"> // build our response JSON<br/> jsonResponse := `[{<br/>   "full_name": "mock-repo"<br/>  }]`</span><span id="a688" class="nd lp it mu b gy ni nf l ng nh"> // create a new reader with that JSON<br/> r := ioutil.NopCloser(bytes.NewReader([]byte(jsonResponse)))</span><span id="6746" class="nd lp it mu b gy ni nf l ng nh"> Client = &amp;MockClient{<br/>  MockDo: func(*http.Request) (*http.Response, error) {<br/>   return &amp;http.Response{<br/>    StatusCode: 200,<br/>    Body:       r,<br/>   }, nil<br/>  },<br/> }</span></pre><p id="d2bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们也打开包装:</p><ul class=""><li id="1401" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated">首先，我们创建一个JSON响应，我们希望从对GitHub的实际调用中得到这个响应。在这种情况下，我们期望一个对象数组，但我并不在乎这里有完整的对象，只要足够测试就行。</li><li id="0761" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">接下来，我们用JSON创建一个响应体，它将从调用中返回。一个HTTP响应有一个类型为<code class="fe mr ms mt mu b">io.Reader</code>的主体，幸运的是，Go提供了<a class="ae kz" href="https://golang.org/pkg/io/ioutil/#NopCloser" rel="noopener ugc nofollow" target="_blank">no closer</a>函数，它返回其中的一个，非常适合测试。</li><li id="daea" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">最后，我们用我们的<code class="fe mr ms mt mu b">MockClient</code>的一个实例设置包级别<code class="fe mr ms mt mu b">Client</code>变量(在<code class="fe mr ms mt mu b">github.go</code>文件中声明)。我们用支持测试所需的任何响应来初始化这个客户机！在这个例子中，我们现在有一个包含test JSON的<code class="fe mr ms mt mu b">io.Reader</code>,所以我们将它传递给我们的<code class="fe mr ms mt mu b">MockDo</code>属性。因为<code class="fe mr ms mt mu b">MockDo</code>是一个<code class="fe mr ms mt mu b">MockDoType</code>，它基本上是<code class="fe mr ms mt mu b">Do</code>函数的一个实现，我们可以在这里设置HTTP响应的所有属性！</li></ul><p id="8796" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个乍一看有点混乱。最终，我们在这里试图做的是模拟我们从<code class="fe mr ms mt mu b">Do</code>呼叫中得到的响应。我们不在乎嘲笑请求，只在乎回应。我们将我们的<code class="fe mr ms mt mu b">HTTPClient</code>定义为一个接口，带有一个<code class="fe mr ms mt mu b">Do</code>属性，我们不能在测试中设置它。因此我们的<code class="fe mr ms mt mu b">MockDoType</code>是我们可以设置的，只是通过我们的<code class="fe mr ms mt mu b">MockClient</code> <code class="fe mr ms mt mu b">Do</code>方法来调用。</p><p id="0646" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种模式在测试失败调用时非常出色:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="aaf9" class="nd lp it mu b gy ne nf l ng nh">func TestGitHubCallFail(t *testing.T) {</span><span id="91ca" class="nd lp it mu b gy ni nf l ng nh"> // create a client that throws and returns an error<br/> Client = &amp;MockClient{<br/>  MockDo: func(*http.Request) (*http.Response, error) {<br/>   return &amp;http.Response{<br/>    StatusCode: 404,<br/>    Body:       nil,<br/>   }, errors.New("Mock Error")<br/>  },<br/> }</span><span id="4631" class="nd lp it mu b gy ni nf l ng nh"> _, err := GetRepos("atkinsonbgthisusershouldnotexist")<br/> if err == nil {<br/>  t.Error("TestGitHubCallFail failed.")<br/>  return<br/> }<br/>}</span></pre><p id="630f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该代码将在调用<code class="fe mr ms mt mu b">Client.Do</code>后立即触发<code class="fe mr ms mt mu b">github.go</code>文件中的错误检查。再次运行我们的测试，我们得到相同的输出:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="953f" class="nd lp it mu b gy ne nf l ng nh">go test -v ./... -coverpkg ./... -coverprofile cover.out<br/>=== RUN   TestGitHubCallSuccess<br/>--- PASS: TestGitHubCallSuccess (0.00s)<br/>=== RUN   TestGitHubCallFail<br/>--- PASS: TestGitHubCallFail (0.00s)<br/>PASS<br/>coverage: 85.7% of statements in ./...<br/>ok      _/Users/user/Documents/GitHub/atkinsonbg/unittest-outbound-http-calls-golang    0.013s  coverage: 85.7% of statements in ./...</span></pre><p id="0ca6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗯，几乎相同的输出，这些测试运行得快得多！我们仍然有85.7%的覆盖率，这太好了！现在我们已经有了模拟，我们可以测试以前很难测试的代码，GitHub响应到JSON的映射:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="39c4" class="nd lp it mu b gy ne nf l ng nh"> response, err := Client.Do(request)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="b1a2" class="nd lp it mu b gy ni nf l ng nh"> defer response.Body.Close()</span><span id="4eb1" class="nd lp it mu b gy ni nf l ng nh"> m := []map[string]interface{}{}<br/> err = json.NewDecoder(response.Body).Decode(&amp;m)<br/> if err != nil {<br/>  return nil, err<br/> }</span></pre><p id="4c8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的模拟之前，我们调用的是实际的GitHub API，它非常稳定，不会经常失败。因此，解码对JSON的响应几乎总是成功的。我们不能在这里正确地测试负面的情况，在这里坏的数据回来了。有了我们的模拟，我们现在可以编写一个这样的测试:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="9e7f" class="nd lp it mu b gy ne nf l ng nh">func TestGitHubCallBadJsonFail(t *testing.T) {</span><span id="3cd4" class="nd lp it mu b gy ni nf l ng nh"> // build our response JSON<br/> jsonResponse := `{<br/>  "full_name": "mock-repo"<br/> }`</span><span id="dfc1" class="nd lp it mu b gy ni nf l ng nh"> // create a new reader with that JSON<br/> r := ioutil.NopCloser(bytes.NewReader([]byte(jsonResponse)))</span><span id="c9df" class="nd lp it mu b gy ni nf l ng nh"> // create a client that throws and returns an error<br/> Client = &amp;MockClient{<br/>  MockDo: func(*http.Request) (*http.Response, error) {<br/>   return &amp;http.Response{<br/>    StatusCode: 200,<br/>    Body:       r,<br/>   }, nil<br/>  },<br/> }</span><span id="8638" class="nd lp it mu b gy ni nf l ng nh"> _, err := GetRepos("atkinsonbg")<br/> if err == nil {<br/>  t.Error("TestGitHubCallBadJsonFail failed.")<br/>  return<br/> }<br/>}</span></pre><p id="92bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个测试中，我们将我们的JSON响应指定为一个JSON对象，而不是一个数组，数组应该被返回。现在，当我们运行这个测试时，JSON映射代码将失败，并应该返回一个错误。现在运行我们的测试，我们可以看到我们的覆盖率上升到92.9%！</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="c3f4" class="nd lp it mu b gy ne nf l ng nh">go test -v ./... -coverpkg ./... -coverprofile cover.out<br/>=== RUN   TestGitHubCallSuccess<br/>--- PASS: TestGitHubCallSuccess (0.00s)<br/>=== RUN   TestGitHubCallFail<br/>--- PASS: TestGitHubCallFail (0.00s)<br/>=== RUN   TestGitHubCallBadJsonFail<br/>--- PASS: TestGitHubCallBadJsonFail (0.00s)<br/>PASS<br/>coverage: 92.9% of statements in ./...<br/>ok      _/Users/user/Documents/GitHub/atkinsonbg/unittest-outbound-http-calls-golang    0.014s  coverage: 92.9% of statements in ./...</span></pre></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="664c" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">包扎</h1><p id="b8de" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在这篇文章中，我们了解了如何在Go测试中轻松模拟出站HTTP调用。希望您会发现这种模式也很容易在您的代码中实现。这不仅提供了一种方便的方法来模拟您的调用，还提供了一种灵活的方法来基于每个测试修改这些模拟。再次感谢<a class="ae kz" href="https://www.thegreatcodeadventure.com/mocking-http-requests-in-golang/" rel="noopener ugc nofollow" target="_blank">索菲·德贝尼代托</a>的精彩帖子，这篇帖子很大程度上基于。尽情享受吧！</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="ddff" class="nd lp it bd lq nx ny dn lu nz oa dp ly km ob oc mc kq od oe mg ku of og mk oh bi translated">资源</h2><ul class=""><li id="730d" class="nj nk it kd b ke mm ki mn km oi kq oj ku ok ky no np nq nr bi translated"><a class="ae kz" href="https://github.com/atkinsonbg/unittest-outbound-http-calls-golang" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li><li id="1d07" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated"><a class="ae kz" href="https://www.thegreatcodeadventure.com/mocking-http-requests-in-golang/" rel="noopener ugc nofollow" target="_blank">模仿Golang中的HTTP请求</a></li></ul></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><figure class="mv mw mx my gt ju gh gi paragraph-image"><a href="https://ko-fi.com/O5O63ENS7"><div class="gh gi ol"><img src="../Images/3515ab52cb6fb5e74c27c7a2e06d3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5imNjCtY48Wh3owQyPv6Cw.png"/></div></a></figure></div></div>    
</body>
</html>