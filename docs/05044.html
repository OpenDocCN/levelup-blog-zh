<html>
<head>
<title>JSON Queries? Empower your users with JMESPath!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JSON查询？使用JMESPath增强用户的能力！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/json-queries-give-your-users-jmespath-power-ef8ab0d38553?source=collection_archive---------8-----------------------#2020-07-31">https://levelup.gitconnected.com/json-queries-give-your-users-jmespath-power-ef8ab0d38553?source=collection_archive---------8-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="64b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么应该将JSON查询处理器集成到API、SDK或CLI中</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/87609d0f2c715b459cbcae17d975d277.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*UmMkiz1pGQ5NjkUlvF98rg.png"/></div></figure><p id="3ee5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JSON可能是当今开放数据交换最常见的格式。尽管JSON文档被设计成一种轻量级的类似JavaScript对象的格式，但它可能会变得非常大，尤其是当它们包含深度嵌套的对象和数组时。</p><p id="83f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">真正需要的是能够在JSON文档上运行一般的处理查询——过滤、整形和转换JSON数据。</p><p id="35fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些文档数据库，如MongoDB和PostgreSQL，有自己的查询语言，允许在JSON上运行复杂的查询，但当我们的JSON数据在数据库记录的上下文之外时，这通常是无关紧要的(尽管您可以使用<a class="ae kw" href="https://github.com/kofrasa/mingo" rel="noopener ugc nofollow" target="_blank"> MingoJS </a>，一种MongoDB查询语言的JavaScript实现)。<strong class="js iu">如果我们能为用户提供这种查询的内置支持会怎么样？</strong></p><h1 id="bb39" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用案例:</h1><ol class=""><li id="23b1" class="lv lw it js b jt lx jx ly kb lz kf ma kj mb kn mc md me mf bi translated">你的软件输出一些JSON，你想给用户一个简单、标准化的方法来过滤或操作数据(例子:<strong class="js iu">API、SDK、CLIs、在线游乐场</strong></li><li id="b0b2" class="lv lw it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">您的软件将JSON作为输入，并且您希望以统一且可重用的方式以编程方式过滤或操作数据。(想想JSON文档，对象数组嵌套了更多的数组和对象)。是的，您可以使用map、filter和reduce函数编写自己的逻辑，但也许有更好、更具声明性的方法。</li></ol><p id="744d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章主要关注第一个用例，您希望<strong class="js iu">为您的用户提供一个内置选项来处理输出</strong>(但实际上，这两个用例是相似的)。</p><h1 id="27ed" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JSON查询语言的候选语言</h1><blockquote class="ml mm mn"><p id="801c" class="jq jr mo js b jt ju jv jw jx jy jz ka mp kc kd ke mq kg kh ki mr kk kl km kn im bi translated"><strong class="js iu"> XML有</strong><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/XPath" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">XPath</strong></a><strong class="js iu">用于查询和遍历XML节点。JSON的等价物是什么？</strong></p></blockquote><h2 id="41b6" class="ms ky it bd kz mt mu dn ld mv mw dp lh kb mx my ll kf mz na lp kj nb nc lt nd bi translated">JSONPath</h2><p id="1823" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated"><a class="ae kw" href="https://www.baeldung.com/guide-to-jayway-jsonpath" rel="noopener ugc nofollow" target="_blank">JSON path</a>——“JSON的XPath是<a class="ae kw" href="https://goessner.net/articles/JsonPath/" rel="noopener ugc nofollow" target="_blank">第一个想到的查询语言</a>。这是JSON查询语言的最早实现之一，它完成了任务。它的一个优点是允许遍历整个JSON树(例如，访问父节点)，并且可以将树中的路径位置作为JSON指针(嵌套键)输出。</p><p id="10e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，如果我们希望向用户提供一个基于JSONPath的接口，那么JSON path的语法并不那么直观。更大的问题是它没有严格的规范，这意味着有许多JSONPath的实现可能会给出不同的结果。这使得在很多情况下很难依赖JSONPath。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/193aea66ae46b5763349c1c4aa2f1e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Jtlsm1mxvvI1K5fWG_VxxQ.png"/></div></div></figure><h1 id="1746" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">japan quarterly 日本季刊</h1><p id="0206" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated"><a class="ae kw" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> jq </strong> </a>是命令行JSON处理器，使用强大的JSON查询语言。用jq你几乎可以做任何事情！一种在DevOps人群中流行的通用语言，可能是因为CLI很容易通过管道传输另一个进程的输出，然后使用jq的管道系统通过附加管道处理格式化的输出。</p><p id="2c6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">但是有两个问题:</strong> jq是一个命令行工具，而不是我们可以在自己的API、SDK等中提供给用户的接口。像<a class="ae kw" href="https://github.com/sanack/node-jq" rel="noopener ugc nofollow" target="_blank"> node-jq </a>和<a class="ae kw" href="https://github.com/arakelian/java-jq" rel="noopener ugc nofollow" target="_blank"> java-jq </a>这样的库只是jq二进制文件的包装器，可能会遇到性能问题，这对实时性能至关重要。其次，强大的功能带来了巨大的复杂性——一些用户声称jq是一种太复杂的语言，对我们的用例来说可能是多余的，因为它允许的不仅仅是操纵现有的JSON。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/03cc3540ddb54eaa44ec6e648da0e475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abyVj39ulJuYv-cFsiu31A.png"/></div></div></figure><h1 id="3a89" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">JMESPath</h1><p id="e814" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated"><a class="ae kw" href="http://jmespath.org/" rel="noopener ugc nofollow" target="_blank">jme path</a>是一种针对JSON的查询语言，允许对JSON文档进行复杂的过滤、提取和转换。与JSONPath和jq不同，它有完整的规范和精确的语法，所以语法在所有实现中都有很好的定义。它拥有完全兼容的多种语言的库(Java、Python、JavaScript、Go、PHP等等)。它是一种强大的查询语言，但语法非常简单。</p><p id="4304" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这些原因，在将JMESPath作为面向用户的接口集成到我们自己的服务中时，它是我们的首选语言。它有一个友好的<a class="ae kw" href="https://jmespath.org/" rel="noopener ugc nofollow" target="_blank">游乐场</a>和<a class="ae kw" href="https://jmespath.org/tutorial.html" rel="noopener ugc nofollow" target="_blank">教程</a>，我们可以提供给用户作为参考。</p><p id="2f4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">https://jmespath.org/examples.html的例子可以让你了解这种语言的强大和简单。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nn"><img src="../Images/b5c707f90f2b6e09ca4d0f1b4d6aaf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ov5VPxrPsE_bOzqT3dlraw.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated"><a class="ae kw" href="https://www.npmtrends.com/jmespath-vs-jsonpath-vs-node-jq" rel="noopener ugc nofollow" target="_blank">JMESPath、JSONPath和JQ的流行度比较——在JavaScript / npm领域</a></figcaption></figure><h1 id="d0ec" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">给用户供电</strong></h1><p id="d69d" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">多亏了库，将JMESPath添加到我们的服务代码非常简单。通过集成JMESPath，我们现在可以为我们的API、SDK或CLI用户提供一种强大、简单和标准化的方法来形成从我们的服务返回的JSON响应，而不需要外部工具。</p><p id="f89d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们假设我们的服务是一个公共REST API。通过让用户能够在数据上指定一个JMESPath查询，他们最终节省了时间、网络上的字节数和进行后处理的代码行，因为处理发生在服务器上，并且响应正好包含用户需要的内容。</p><p id="a0a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将JMESPath集成到我们的API处理程序代码中非常简单，因为这个库只有一个功能(“search”)。下面以Node.js / JavaScript为例:</p><pre class="kp kq kr ks gt ns nt nu nv aw nw bi"><span id="5cf4" class="ms ky it nt b gy nx ny l nz oa">const jmespath = require(‘jmespath’);</span><span id="bcf7" class="ms ky it nt b gy ob ny l nz oa">const requestHandler = (req, res, next) =&gt; {<br/>    // response res was passed here from previous handler <br/>    if (req.query &amp;&amp; req.query.filter) {<br/>        res = applyJmesPathFilter(res, req.query.filter); <br/>    } // ...more logic and eventually res.send()<br/>}</span><span id="5372" class="ms ky it nt b gy ob ny l nz oa">const applyJmesPathFilter = (res, jmespathExpression) =&gt; {<br/>    try {<br/>       res = jmespath.search(res, jmespathExpression) || {}; <br/>    } <br/>    catch (e) { <br/>        res = {}; <br/>        log.error(e);<br/>    }<br/>    return res;<br/>}</span></pre><p id="929f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，用户可以立即使用<em class="mo">过滤器</em>查询参数指定一个JMESPath表达式来处理初始JSON结果:</p><p id="05f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GET /api/players？过滤器= <code class="fe oc od oe nt b">[JMESPATH_EXPRESSION]</code></p><p id="303c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们的服务输出是NBA球员API，其中存储了一些传奇篮球运动员的信息。一个<code class="fe oc od oe nt b">GET /api/players</code>请求返回下面的JSON对象数组:</p><pre class="kp kq kr ks gt ns nt nu nv aw nw bi"><span id="b72d" class="ms ky it nt b gy nx ny l nz oa">[<br/> {<br/>  "playerId": "7c3f73dd-0b38-48dc-9347-c78811bd80c4",<br/>  "playerName": "Scottie Pippen",<br/>  "yearOfBirth": "1965",<br/>  "collegeId": "77302082-2758-48cc-ab3a-7b811a8bdf80",<br/>  "jerseyNumber": "33",<br/>  "playerStats": {<br/>      "points": 18940,<br/>      "rebounds": 7494,<br/>      "assists": 6135<br/>  },<br/>  "teamNames": [<br/>     "Chicago Bulls",<br/>     "Portland Trail Blazers",<br/>     "Houston Rockets",<br/>     "Chicago Bulls"<br/>  ]<br/> },<br/> {<br/>  "playerId": "8d75bb0f-a444-4264-a583-4ca5799169cf",<br/>  "playerName": "Patrick Ewing",<br/>  "yearOfBirth": "1962",<br/>  "collegeId": "0456a17b-320d-4ddc-bfc2-011670af2b77",<br/>  "jerseyNumber": "33",<br/>  "playerStats": {<br/>     "points": 24815,<br/>     "rebounds": 11617,<br/>     "blocks": 2894<br/>  },<br/>  "teamNames": [<br/>     "New York Knicks",<br/>     "Seattle SuperSonics",<br/>     "Orlando Magic" <br/>  ]<br/> } <br/>]</span></pre><p id="4da6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为原始结果是一个数组，所以下面的JMESPath表达式以“[]”开头来引用该数组。</p><p id="642a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe oc od oe nt b">GET /api/players?filter=[].playerName</code>将返回以下数组:</p><pre class="kp kq kr ks gt ns nt nu nv aw nw bi"><span id="bb21" class="ms ky it nt b gy nx ny l nz oa">[<br/>  "Scottie Pippen",<br/>  "Patrick Ewing"<br/>]</span></pre><p id="3ebf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以改为索要对象，并修改原来的键名:<br/> <code class="fe oc od oe nt b">GET /api/players?filter=[].{name: playerName, number: jerseyNumber} </code>返回:</p><pre class="kp kq kr ks gt ns nt nu nv aw nw bi"><span id="8bed" class="ms ky it nt b gy nx ny l nz oa">[<br/>  {<br/>    "name": "Scottie Pippen",<br/>    "number": "33"<br/>  },<br/>  {<br/>    "name": "Patrick Ewing",<br/>    "number": "33"<br/>  }<br/>]</span></pre><p id="7fc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以基于一个或多个键运行过滤查询，并通过管道将结果格式化(这里是普通字符串):</p><p id="0b6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe oc od oe nt b">GET /api/players?filter=[?yearOfBirth &gt; `1964`].playerName | [0]</code>回报</p><pre class="kp kq kr ks gt ns nt nu nv aw nw bi"><span id="aed3" class="ms ky it nt b gy nx ny l nz oa">"Scottie Pippen"</span></pre><p id="3925" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以及更高级的逻辑，它使用sort()和join()函数:</p><p id="cd13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe oc od oe nt b">GET /api/players?filter=[].playerName | sort(@) | { nbaLegends: join(‘, ‘, @) }</code></p><pre class="kp kq kr ks gt ns nt nu nv aw nw bi"><span id="ceb9" class="ms ky it nt b gy nx ny l nz oa">{<br/>  "nbaLegends": "Patrick Ewing, Scottie Pippen"<br/>}</span></pre><p id="d064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户可以调整结果，使其符合自己的确切需求。例如:</p><p id="615a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe oc od oe nt b">GET /api/players?filter=[].{name: playerName, firstTeam: teamNames | [0], points: playerStats.points }</code></p><pre class="kp kq kr ks gt ns nt nu nv aw nw bi"><span id="8c92" class="ms ky it nt b gy nx ny l nz oa">[<br/>  {<br/>    "name": "Scottie Pippen",<br/>    "firstTeam": "Chicago Bulls",<br/>    "points": 18940<br/>  },<br/>  {<br/>    "name": "Patrick Ewing",<br/>    "firstTeam": "New York Knicks",<br/>    "points": 24815<br/>  }<br/>]</span></pre><p id="efad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些只是通过JMESPath可用的JSON处理选项的一部分。</p><p id="0713" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些读者可能会注意到，通过使用GraphQL可以让用户“准确地获得他们想要的数据”。没错，但这是一个REST API:)(这个场景可以用SDK或CLI代替)。事实上，GraphQL并没有提供像JMESPath这样的JSON查询语言所提供的处理能力。当然，JSON处理在初始数据集被完全获取后运行，这不如在GraphQL APIs中使用数据访问层上的解析器进行早期过滤有效。</p><p id="7bf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经将JMESPath集成到一些<a class="ae kw" href="https://sisense.dev/guides/rest/datamodels.v2.html" rel="noopener ugc nofollow" target="_blank"> Sisense公共REST API</a>中，并作为<a class="ae kw" href="https://medium.com/swlh/graphql-api-or-rest-api-why-not-have-both-c4171e68900a" rel="noopener"> GraphQL2REST包</a>中的一个特性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/99dadb9b69e94c4680cebfe047a3a479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*is6sat9OSXIWbbBYWF8ZUg.jpeg"/></div></figure><h1 id="bce4" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">限制</h1><p id="0262" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb ne kd ke kf nf kh ki kj ng kl km kn im bi translated">与jq和JSONPath相比，JMESPath有一些限制。对我来说，最大的限制是没有简单的方法来获取给定JSON文档的路径列表(也称为节点名或JSON指针)，并且您不能将键表示为JMESPath表达式(以便在满足测试的一组键上运行操作)。递归遍历是不可能的——您必须指定JSON键的完整路径。另一个问题是JMESPath不允许在迭代时引用父节点。这些限制有时会限制开发人员的使用，但通常不会影响这里讨论的常见用例。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="975a" class="kx ky it bd kz la on lc ld le oo lg lh li op lk ll lm oq lo lp lq or ls lt lu bi translated">额外资源</h1><h2 id="14f0" class="ms ky it bd kz mt mu dn ld mv mw dp lh kb mx my ll kf mz na lp kj nb nc lt nd bi translated">对于冒险者—更多查询语言:</h2><ul class=""><li id="6bc3" class="lv lw it js b jt lx jx ly kb lz kf ma kj mb kn os md me mf bi translated"><a class="ae kw" href="https://yaql.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> YAQL(又一种查询语言)</a></li><li id="d1f5" class="lv lw it js b jt mg jx mh kb mi kf mj kj mk kn os md me mf bi translated"><a class="ae kw" href="https://github.com/dflemstr/rq" rel="noopener ugc nofollow" target="_blank"> rq查询语言</a></li><li id="aa2f" class="lv lw it js b jt mg jx mh kb mi kf mj kj mk kn os md me mf bi translated"><a class="ae kw" href="https://github.com/chrisdone/jl" rel="noopener ugc nofollow" target="_blank">JL(JSONλ)查询语言</a></li><li id="5319" class="lv lw it js b jt mg jx mh kb mi kf mj kj mk kn os md me mf bi translated"><a class="ae kw" href="https://glom.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> glom (Python) </a></li><li id="8f47" class="lv lw it js b jt mg jx mh kb mi kf mj kj mk kn os md me mf bi translated"><a class="ae kw" href="https://github.com/mariocasciaro/object-path" rel="noopener ugc nofollow" target="_blank">对象路径(JavaScript) </a></li></ul><p id="2828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae kw" href="https://github.com/jmespath/jp" rel="noopener ugc nofollow" target="_blank">jp:JMESPath的命令行接口(CLI)</a></p></div></div>    
</body>
</html>