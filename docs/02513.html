<html>
<head>
<title>Guide to improve Python performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Python性能的指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/guide-to-improve-python-performance-d1d1a10d7a4d?source=collection_archive---------10-----------------------#2020-03-18">https://levelup.gitconnected.com/guide-to-improve-python-performance-d1d1a10d7a4d?source=collection_archive---------10-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a24579bd5854b4c299b9b10944fcb279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7s14p9xWB-1cm3RENLVSg.png"/></div></div></figure><p id="bdf9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python是一种令人惊叹的编程语言，但是与编译语言相比，它有两个巨大的缺陷。</p><ul class=""><li id="480a" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">第一个是GIL或全局解释器锁。GIL是一个真正的进程锁，它迫使Python解释器在单个进程上工作，并且只使用CPU中的一个内核。由于这种锁定，Python既简单又稳定，但与C或Java等其他编程语言相比，速度非常慢。</li><li id="cc5b" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">第二个障碍对于非静态类型也就是动态类型编程语言来说是相当普遍的。简而言之，当您没有指定将要使用的变量的数据类型并依赖于动态类型赋值时，您最终会获得非常慢的执行性能。</li></ul><p id="e9cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幸运的是，有几种方法可以提高Python代码的速度。</p><h1 id="fa4b" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">绕过GIL(并发性/GIL持久性)</h1><p id="5441" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">在这种方法中，目标代码的执行是以并行或同时处理数据的方式进行的。本质上，它仅仅意味着将一个任务分成多个独立的子任务，并在不同的线程或进程中处理每个子任务。这也被称为多线程或多重处理。这种方法非常有效，前提是你的任务可以分成不同的任务。</p><p id="b84e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在继续之前，区分线程和进程是很重要的。线程和进程是两个不同的东西，它们可以以相似的方式使用，但是目的不同。单个进程可以创建多个线程，这受到操作系统的限制。任何单个进程的所有线程都共享同一个内存堆。然而，在Python中，新线程并不意味着新的CPU核心；因此，线程不会给你带来实际的性能提升，而是帮助你同时关注几个任务。因此，创建线程的成本很低，并且主要应用于I/O操作。相反，当你创建一个新的进程时，原始的内存堆被复制，一个新的被创建。两个进程看不到彼此的内存堆，但是在不同的CPU内核上工作。创建一个新的进程是很昂贵的，而且最终会占用更多的内存。但是，新的进程为您提供了额外的CPU核心(达到最大值),并且可以在本地或集群中的不同计算机上创建。[3,4]</p><p id="c41a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是一些例子:</p><ul class=""><li id="779a" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">假设您的磁盘上有一个非常大的文件，或者内存中有一个列表/数组需要处理。你可以将你的目标/数据分解成更小的任务/块，而不是在一个循环中处理所有的数据，并在你的CPU上使用一个内核。最后，您可以在不同的线程或进程中分别处理每个块。</li><li id="5fbe" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">类似地，您可以在单线程中运行一些Python代码，这些代码将监听网络套接字，以获取可能从TCP连接收到的包。</li><li id="40c6" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">并发的另一个流行应用可以在数据分析问题中看到。假设您想要在一个计算机/服务器集群中在短时间内对大量数据执行计算开销很大的操作。在这种情况下，每个进程可以在不同的计算机中运行，数据可以通过网络接口共享。</li></ul><p id="c898" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python为并发处理提供了几个内置包。</p><ul class=""><li id="56c6" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">这个模块非常容易使用，但是缺乏高级控制。</li><li id="7875" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">如果你想用线程做更复杂的事情，比如锁定线程或者在队列中运行任务，这很有用。</li><li id="1a85" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe mq mr ms mt b"><strong class="kd iu">multiprocessing</strong></code> -如果你想做更复杂的事情，比如共享内存或者在队列中运行任务，这很有用。</li></ul><blockquote class="mu mv mw"><p id="bb1f" class="kb kc mx kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu"> <em class="it">并发vs真正的并行</em> </strong> <em class="it">:基于并发的并行不是真正的并行。当所有CPU内核同时处理同一项任务时，一段代码就会以真正并行的方式执行。真正的并行性基于实际的硬件，通常比并发性更复杂。Python的GIL阻止了代码的真正并行执行。然而，幸运的是，有一些方法可以释放GIL，实现真正的并行处理。[1] </em></p></blockquote><h1 id="e8f3" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">无GIL(真正的并行)+可选的静态类型</h1><p id="4dc3" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">为了发布GIL并提升你的Python代码，你至少需要做一点点手脚。Python是很棒的高级编程语言，其他低级编程语言也是这么写的。原始的和最流行的Python实际上是用C实现的，这个参考实现叫做CPython。然而，Python的其他实现也有其自身的优点和问题。每一个都是由不同的社区开发的；因此，每个Python实现都和它的社区一样强大。[5]</p><blockquote class="mu mv mw"><p id="aa6d" class="kb kc mx kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu"><em class="it">Python包呢？</em> </strong> <em class="it">此时，你可能会问自己一个问题。我目前使用的Python包在其他Python实现中也可用吗？不幸的是，答案是模糊的，因为它实际上取决于实现。肯定会有一些不兼容的地方。为了确保这一点，请务必检查文档资料。</em></p></blockquote><p id="4ce4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一些流行的Python替代实现。</p><ul class=""><li id="e7ca" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu"> IronPython </strong> —是。用C#语言编写的基于. NET框架的Python实现。如果您喜欢编写Python代码并且需要使用。NET框架。</li><li id="bd68" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><strong class="kd iu"> Jython </strong> —是用Java编写的基于JVM的Python实现。如果您喜欢编写Python代码，并且需要将它与您的纯Java后端紧密集成，这是一个很好的选择。</li><li id="c346" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">PyPy——是Python的另一种实现，带有实时(JIT)编译器。与Python的参考实现(CPython)相比，PyPy利用JIT提供了比在CPython中实现的原始字节码编译器更好的性能。所以PyPy/Python比CPython/Python有更好的性能。另外，根据PyPy文档，PyPy支持几乎所有的Python包，所以这是PyPy的一大优势。但是，PyPy只支持32位架构，更新不像Python那么频繁。</li></ul><p id="6e54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下不是Python实现</p><ul class=""><li id="5952" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu">NumPy/Pandas/Dask</strong>——“正确”使用这些数据分析包中实现的许多方法几乎总是会给你带来显著的性能提升。</li><li id="743c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><strong class="kd iu"> Cython </strong> —不是Python的实现。它是编译成C的Python的超集。它的语法几乎与Python的语法相同，但更像C，因为它可以理解静态类型。几乎任何Python代码都可以使用Cython编译，以生成具有相同功能但执行时间更快的模块。同样，大多数情况下，将C代码重写为Cython代码是很容易的。此外，许多内置模块和方法都针对Cython进行了优化，以便在编译之前生成最少的C代码。而且，Cython还支持NumPy，使用<code class="fe mq mr ms mt b">numpy.ndarray</code>时运行非常高效。[2]</li><li id="ad6c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">Numba是一个支持NumPy的Python JIT编译器。Numba是非常用户友好的，可以很容易地应用到你想要加速的Python代码的特定部分。</li></ul><blockquote class="mu mv mw"><p id="d6df" class="kb kc mx kd b ke kf kg kh ki kj kk kl my kn ko kp mz kr ks kt na kv kw kx ky im bi translated"><strong class="kd iu"> <em class="it">重要提示:</em> </strong> <em class="it">本节描述的每种方法都有可比较的优点和缺点、最佳使用应用、最佳实践、学习曲线。然而，如果您想从任何方法中获得最佳性能，您将需要亲自动手。</em></p></blockquote><h1 id="6182" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">无GIL(真正的并行)+强制静态类型</h1><p id="2937" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">下面的方法不同于上面的所有方法，因为它们需要对第二种低级编程语言(如C/C++)有足够的了解。本节描述的是在Python和用低级编程语言编写的扩展之间充当“桥梁”的工具/方法。因此，性能只受低级编程语言和桥的限制。此时，在我们继续之前，必须说明两个重要的问题。[5]</p><ul class=""><li id="66ac" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">如果像C这样的编译语言，需要源代码的编译和链接，有没有可能在包分发过程中自动编译？</li><li id="3853" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">由于编译C代码可能因操作系统而异，这是否意味着您的扩展代码将不再是跨操作系统的？</li><li id="5dcb" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">如何将Python数据类型转换成C类型，反之亦然？</li></ul><p id="d79e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些问题没有单一的答案，因为这取决于你想做什么。编译器配置和自动化都可以使用一个名为<code class="fe mq mr ms mt b">distutils</code>的内置Python模块来管理，这个模块非常容易使用。然而，如果你想跨操作系统使用它，这真的取决于你如何设计你的扩展。然而，就数据类型而言，有三种逻辑方法。</p><p id="3a31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mx">让C端处理数据类型:</em></p><ul class=""><li id="7f7c" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><strong class="kd iu">Python API(CPython)</strong>—CPython是Python编程语言的参考实现。换句话说，CPython本质上是主要的C代码，编译时会生成Python解释器及其字节码编译器。幸运的是，CPython/Python开发人员通过<code class="fe mq mr ms mt b">Python.h</code> include文件为C/C++程序员提供了对核心Python API的访问。使用这种方法编写的扩展可以使用<code class="fe mq mr ms mt b">distutils</code>轻松分发。还可以使用CPython将Python功能嵌入到C程序中。[5]</li></ul><p id="1f09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mx">让Python端处理数据类型</em></p><ul class=""><li id="3275" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe mq mr ms mt b"><strong class="kd iu">cffi</strong></code>(Python的C外来函数接口)——一个拥有自己世界的非常强大的工具。CFFI为用C扩展来扩展Python和在C程序中嵌入Python提供了几种模式。此外，除了API模式，CFFI还提供了ABI模式，可用于访问任何编译库中可用的函数，如Windows的<code class="fe mq mr ms mt b">.dll</code>或Linux/macOS的<code class="fe mq mr ms mt b">.so</code>。</li><li id="9431" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe mq mr ms mt b"><strong class="kd iu">ctypes</strong></code> -这是一个内置的Python包，为Python-C提供了一个外来的函数接口，然而这个包只提供了ABI访问类似CFFI的库。</li></ul><p id="7f7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mx">让桥处理数据类型。</em></p><ul class=""><li id="e2a4" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">SWIG<strong class="kd iu">SWIG</strong>(简化的包装器和接口生成器)——这是一个古老但流行的工具，它可以让你连接不同的编程语言，包括Python和C。SWIG是最古老的工具之一，它可以连接不同的编程语言，但与其他较新的连接Python和C的工具相比，它似乎失去了它的流行性。</li><li id="ec64" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><strong class="kd iu"> Cython </strong> — Cython值得再次出现在这里，因为它的灵活性。Cython扩展还允许通过<code class="fe mq mr ms mt b">Python.h</code>使用Python API，甚至可以作为纯C扩展的接口。Cython非常擅长理解C和Python。[2]</li></ul><h1 id="94c5" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="bbe2" class="pw-post-body-paragraph kb kc it kd b ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku mp kw kx ky im bi translated">总结一下，我们来做一个非常粗略的概括。绕过GIL非常容易实现，并且可以显著提高整体性能。此外，多线程允许同步I/O，而不会阻塞您的主代码。然而，并发并不意味着真正的并行，只能应用于特定的任务。然而，在第二部分中，我们学习了不同的方法来释放GIL并保持它的Python性。</p><p id="2e3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">替代的Python实现可以通过释放GIL来实现真正的并行，而不会失去Python的灵活性。另一方面，Cython可能需要一些经验来充分利用它。同样，像Pandas这样的数据分析包，如果使用正确，可以产生闪电般的性能，但其应用取决于任务的性质。最后，对于那些不怕弄脏手的人来说，GIL可以通过C扩展来发布。c扩展可以提供对代码的完全控制和最佳的执行速度。但是，C知识是必须的，因为过多的控制意味着过多的责任。</p><h1 id="c52d" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">参考</h1><ol class=""><li id="ca1b" class="kz la it kd b ke ml ki mm km nb kq nc ku nd ky ne lf lg lh bi translated">“并发性与并行性”，HowToDoInJava。【在线】。可用:<a class="ae nf" href="https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/" rel="noopener ugc nofollow" target="_blank">https://howtodoinjava . com/Java/多线程/并发-并行/ </a>。[访问日期:2020年3月18日]。</li><li id="dc61" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated">K.cy thon:python程序员指南，第一版。北京剑桥法纳姆科隆塞瓦斯托波尔东京:奥莱利，2015。</li><li id="fd27" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated">A.J. J. Davis，“Grok the GIL:编写快速且线程安全的Python”【在线】。可用:<a class="ae nf" href="https://emptysqua.re/blog/grok-the-gil-fast-thread-safe-python/" rel="noopener ugc nofollow" target="_blank">https://emptysqua . re/blog/grok-the-Gil-fast-thread-safe-python/</a>。[访问日期:2020年3月18日]。</li><li id="c118" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated">“Java多线程教程”。【在线】。可用:【https://howtodoinjava.com/java/multi-threading/】T4。[访问日期:2020年3月18日]。</li><li id="99fe" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky ne lf lg lh bi translated">米（meter的缩写））实践中的Python:使用并发性、库和模式创建更好的程序。艾迪森-韦斯利，2013年。</li></ol><p id="09fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mx">原文:</em><a class="ae nf" href="https://mmtechslv.github.io/2020/03/python-boost/" rel="noopener ugc nofollow" target="_blank"><em class="mx">https://mmtechslv.github.io/2020/03/python-boost/</em></a></p></div></div>    
</body>
</html>