<html>
<head>
<title>The 2 Worst Mistakes You Do with Logging in .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">登录时你犯的两个最大的错误。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-2-worst-mistakes-you-do-with-logging-in-net-55e317392932?source=collection_archive---------5-----------------------#2022-10-04">https://levelup.gitconnected.com/the-2-worst-mistakes-you-do-with-logging-in-net-55e317392932?source=collection_archive---------5-----------------------#2022-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8a96" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果您没有以正确的方式使用日志记录，将会损失很多性能！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/445013e20bff1cd26c96b0a4d0b3904f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5F5GodbF3Uobfoq3"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="58a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.nuget.org/packages/Microsoft.Extensions.Logging" rel="noopener ugc nofollow" target="_blank">Microsoft.Extensions.Logging</a></code> NuGet包是仅次于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.nuget.org/packages/Serilog/" rel="noopener ugc nofollow" target="_blank">Serilog</a></code>的NuGet下载量最多的日志包。作为最常用的一种，它也有一个陷阱，你很容易掉进去，这会让你损失很多性能。</p><h2 id="273b" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">1.不必要的日志调用</h2><p id="47b9" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">第一个也是可能最严重的错误是，由于<code class="fe lv lw lx ly b">LogLevel</code>太低，对<code class="fe lv lw lx ly b">ILogger</code>的调用太多，即使它们没有被处理。</p><p id="0206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当您实现日志记录时，您需要区分不同的日志级别，从<strong class="lb iu">跟踪</strong>到<strong class="lb iu">关键</strong>。当您配置了您的日志记录器，只记录<strong class="lb iu">错误</strong>事件时，该级别下的所有内容都将被忽略。还是会？</p><p id="b186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常情况下，<code class="fe lv lw lx ly b">LogLevel</code>越低，您拥有的日志就越多，因为出于调试目的，您可能会记录所有内容。基本上这是没有错的，但是，你应该做得正确，并意识到副作用，当它是错误的。</p><p id="d02d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a9a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这似乎是记录调试条目的合法方式。然而，这里有一个隐藏的陷阱:字符串插值。<br/>插入一个字符串总是导致该字符串被<a class="ae ky" href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" rel="noopener ugc nofollow" target="_blank">装箱</a>，从而被放入堆中。</p><p id="e9ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象一下，您正在调用这些日志方法几千次，并将您的<code class="fe lv lw lx ly b">LogLevel</code>设置为<strong class="lb iu">错误</strong>。对于这里的每个调用，您都是在堆上分配内存，这些内存最终需要由垃圾收集器来收集。</p><blockquote class="mz"><p id="c10b" class="na nb it bd nc nd ne nf ng nh ni lu dk translated">在垃圾收集期间，你的应用程序完全停止执行！</p></blockquote><p id="21fd" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这让你付出了极大的代价，你本可以很容易地节省下来。要么完全删除不必要的日志<strong class="lb iu">，要么首先检查</strong>，如果你必须在这里登录的话:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在看起来很美，对吧？嗯，不完全是这样，但是我们会看到，在本文的后面我们可以做些什么。尽管如此，我们还是省去了大量的垃圾收集，因为字符串不会被插值，也不会被放到堆中。</p><h2 id="3252" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">2.不使用模板功能</h2><p id="27e1" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">您可能已经注意到，当您将一个简单的字符串作为<code class="fe lv lw lx ly b">message</code>参数传递给日志记录函数时，您的IDE会警告您:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6152a1268186240d8802f4e80216acd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*o2w6_dHjVbxaLY6jcFr-0g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">IDE警告:消息模板</figcaption></figure><p id="2a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你的结果，使用日志功能错误的所有时间！不是仅仅将一个简单的字符串作为log方法的第一个参数，而是传递一个<strong class="lb iu">模板</strong>和模板的参数。使用日志功能的预期方式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">日志模板的正确使用</figcaption></figure><p id="56c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ItemId </strong>和<strong class="lb iu"> ItemName </strong>是命名参数，您必须按照参数在模板中出现的顺序在字符串后传递参数。</p><p id="c403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法有几个好处，乍一看并不清楚:</p><ul class=""><li id="1a1e" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">外部<strong class="lb iu">监控</strong>工具(如Azure AppInsights或AWS CloudWatch)除了记录日志消息之外，还会记录参数名称和值。然后，您可以在那里进行更详细的过滤。</li><li id="6f99" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">在默认实现中，没有性能优势。但是，当将这种方法与cutom扩展方法结合使用时，这些参数可以是一般类型的，因此不会被装箱，从而在记录器不记录日志时节省堆上的内存。</li></ul><p id="a074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何利用这些性能优势。</p><h2 id="879e" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">履行</h2><p id="58d6" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">既然我们已经确定了日志记录过程中的两个主要错误，那么让我们实现一个允许我们正确使用它们的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d87b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是定制的<a class="ae ky" href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" rel="noopener ugc nofollow" target="_blank">扩展方法</a>，它们将替换原来对<code class="fe lv lw lx ly b">ILogger</code>的<code class="fe lv lw lx ly b">LogInformation</code>调用。请特别注意这里的泛型类型参数。由于它们是泛型的，它允许传递的参数<strong class="lb iu">而不是</strong>被装箱，从而节省了潜在的分配堆内存。</p><p id="5eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您只需为所有的<code class="fe lv lw lx ly b">LogLevel</code>创建所有那些扩展方法，就万事俱备了。还是有更快的方法？</p><p id="68c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以简单地使用NuGet包<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/serilog/serilog" rel="noopener ugc nofollow" target="_blank">Serilog</a></code>，而不是自己实现这个逻辑和其他许多现有的方法。这个包已经预先实现了所有的功能，具有很强的可扩展性，并且有很多已经过性能优化的特性。</p><h2 id="3ae4" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">基准</h2><p id="1d4a" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">为了直观地显示这些错误真正造成的影响，让我用<a class="ae ky" href="https://benchmarkdotnet.org/articles/overview.html" rel="noopener ugc nofollow" target="_blank">BenchmarkDotNet</a>中的一些基准来测试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d80f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我比较了所有提到的日志记录的变体，一次是用<code class="fe lv lw lx ly b">Microsoft.Extensions.Logging.ILogger</code>(微软后缀)包括自定义扩展方法<code class="fe lv lw lx ly b">Information()</code>，一次是用默认的<code class="fe lv lw lx ly b">Serilog.ILogger</code> (Serilog后缀)。</p><p id="1e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的机器上，这些基准测试产生了以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/fa5c8795cf151bcaddeb322be54a62c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*W_MXO8rVK_MOakIG8bcHyQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">不同测井变化的对比</figcaption></figure><p id="b3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，默认情况下，Serilog在日志记录性能方面有一些优势。尽管如此，使用我们为Microsoft ILogger定制的扩展方法，我们可以实现大约相同的性能<strong class="lb iu">和</strong>无堆内存分配，当我们低于我们的<code class="fe lv lw lx ly b">LogLevel</code>！这为您节省了大量的性能。</p><p id="519f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们做一些数学计算，我们只是(不)记录一个小字符串1000次，这已经有大约50 KB的总分配内存。当我们在一个<code class="fe lv lw lx ly b">for</code>循环中调用<code class="fe lv lw lx ly b">ILogger</code>时，循环次数增加了10.000次，我们使用了一个更大的字符串，我们已经有了<strong class="lb iu"> 1 GB </strong>的总分配堆内存，这些内存需要一直进行垃圾收集，因此每分钟暂停整个应用程序的时间超过了一秒钟！</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="5455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这些方法能帮助您识别应用程序中的一些性能灾难。对我来说，他们当然做到了！</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="bf35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。</p><p id="2403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。</p><p id="5f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你有美好的一天！</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/429378e6a7aee01df92851fb0e90e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK4zVN8TtnIM37dhEhE54g.png"/></div></div></figure><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@tobias.streng/membership" rel="noopener"> <em class="om">现在加入介质</em> </a></p><p id="cb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。</p></div></div>    
</body>
</html>