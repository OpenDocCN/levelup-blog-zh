<html>
<head>
<title>Building a React Typing Terminal Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个反应式终端组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-react-typing-terminal-component-b01a96ba368d?source=collection_archive---------11-----------------------#2022-08-07">https://levelup.gitconnected.com/building-a-react-typing-terminal-component-b01a96ba368d?source=collection_archive---------11-----------------------#2022-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3a206142ae5d6f17c3751463a7713f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYGuglQs8BzNx5xUwobgSA.png"/></div></div></figure><p id="74b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近，我一直在开发我的开发者组合。在此期间，我想尝试创造一种效果，看起来像一些在终端上打印出来的文本，以此作为一种有趣的方式向其他技术人员展示我的技能。我开发的最终产品使用了简单的CSS和一个名为<a class="ae kz" href="https://github.com/mattboldt/typed.js/" rel="noopener ugc nofollow" target="_blank"> Typed.js </a>的优秀包，为下面的效果制作了一个react组件。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/850789289e9d3cff3f13a65c1e395cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dPnUSjdY4htmhAKqfW2nYw.gif"/></div></div></figure><p id="7966" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了构建这种效果，我将向您展示如何利用Typed.js来制作组件，以获得我们的终端键入效果，以及如何将多行链接在一起，以便动画按预期播放。最后，通过一些造型，我们可以使它看起来像一个计算机终端，以吸引其他技术类型来查看您想要显示的任何信息。我已经把这个组件放在GitHub上了，如果你想安装它或者为你需要的任何东西分叉它。</p><div class="lf lg gp gr lh li"><a href="https://github.com/Aaron-K-T-Berry/react-component-typed-terminal" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">GitHub-Aaron-K-T-Berry/react-component型终端</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">一个react组件，用于显示一个打字动画，使用TypedJs来显示一个类似终端的组件来显示…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">github.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw jz li"/></div></div></a></div><h1 id="0bb4" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">创建组件</h1><p id="d038" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">构建这个效果需要两个React组件:终端窗口的包装器和使用typed.js为我们创建输入效果的终端行。我们将在下面分别讨论这些组件。</p><h1 id="2990" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">终端窗口</h1><p id="2f91" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">终端窗口将用于给出我们的终端输出将出现的区域的结构。为了达到这种效果，如果您要立即显示每一行，typed.js动画会立即启动。因此，我们希望为每一行存储一些状态，以跟踪何时应该开始输入以及何时完成输入，从而允许像开发人员一样在终端窗口上同步输出这些行。</p><p id="1de7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面看到的<code class="fe na nb nc nd b">TypedTerminal</code>，请注意type.js完成动画时将调用的<code class="fe na nb nc nd b">onComplete</code>函数。我们在这里定义了一个函数，它将把下面终端行的<code class="fe na nb nc nd b">animationState</code>标记为true，所以终端like将被取消隐藏并启动typed.js。</p><pre class="lb lc ld le gt ne nd nf ng aw nh bi"><span id="e27b" class="ni ly it nd b gy nj nk l nl nm">export const TypedTerminal: React.FunctionComponent&lt;{<br/>  title: string;<br/>  terminalData: { command: string; results: string[] }[];<br/>  promptText: string;<br/>  typedJsProps?: TypedOptions | {};<br/>}&gt; = (props) =&gt; {<br/>  // Create an array for each terminal line to track the animation completed<br/>  // state so the next terminal line typing can be picked off<br/>  const [animationState, setAnimationState] = useState&lt;boolean[]&gt;(<br/>    // Set the first line as true to start typing and set all other lines to false<br/>    props.terminalData.map((item, index) =&gt; (index == 0 ? true : false))<br/>  );</span><span id="a071" class="ni ly it nd b gy nn nk l nl nm">return (<br/>    &lt;div className={"TerminalWrapper"}&gt;<br/>      &lt;div className={"TerminalTitle"}&gt;{props.title}&lt;/div&gt;<br/>      &lt;div className={"TerminalBody"}&gt;<br/>        {props.terminalData.map((item, index) =&gt; {<br/>          return (<br/>            &lt;TerminalLine<br/>              key={`${item.command.toLowerCase().replace(" ", "")}_${index}`}<br/>              promptText={props.promptText}<br/>              // Animation has not be started so don't show the prompt<br/>              hidden={!animationState[index]}<br/>              typedJsProps={{<br/>                // Combine the command and results into a single string separated<br/>                // by new lines to get the effect of some terminal output<br/>                strings: [item.command + "\n" + item.results.join("\n")],<br/>                // When the line has completed its animation progress to the next one<br/>                onComplete: () =&gt; {<br/>                  let currentState = [...animationState];<br/>                  currentState[index + 1] = true;<br/>                  setAnimationState(currentState);<br/>                },<br/>                loop: false,<br/>                typeSpeed: 40,<br/>                showCursor: false,<br/>                ...props.typedJsProps,<br/>              }}<br/>            /&gt;<br/>          );<br/>        })}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="c53b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在为样式，我们将使用下面的样式表建立一个矩形窗口，在它和文本颜色之间有一些对比背景，就像你在终端上看到的一样。但是当然，这可以为你正在构建的任何主题定制，类是可重写的。</p><pre class="lb lc ld le gt ne nd nf ng aw nh bi"><span id="201b" class="ni ly it nd b gy nj nk l nl nm">.TerminalWrapper {<br/>  max-width: 1000px;<br/>  font-family: Monaco, Consolas, "Lucida Console", monospace;<br/>  display: block;<br/>  margin: auto;<br/>  border-radius: 5px;<br/>  box-shadow: rgb(0 0 0 / 30%) 5px 5px 30px;<br/>  clear: both;<br/>  overflow: auto;<br/>  -webkit-transition: all 0.5s ease-out;<br/>  -moz-transition: all 0.5s ease-out;<br/>  -ms-transition: all 0.5s ease-out;<br/>  -o-transition: all 0.5s ease-out;<br/>  transition: all 0.5s ease-out;<br/>}</span><span id="8e45" class="ni ly it nd b gy nn nk l nl nm">.TerminalTitle {<br/>  padding: 5px 0;<br/>  font-size: 0.75em;<br/>  text-align: center;<br/>  background-color: #eeeeee;<br/>  border-bottom: #e0e0e0 1px solid;<br/>}</span><span id="2c0b" class="ni ly it nd b gy nn nk l nl nm">.TerminalBody {<br/>  padding: 5px 10px;<br/>  height: 350px;<br/>  overflow-y: auto;<br/>  word-break: normal;<br/>  background-color: #3a3a3a;<br/>  color: #fff;<br/>}</span><span id="11fc" class="ni ly it nd b gy nn nk l nl nm">.TerminalLine {<br/>  padding-bottom: 0.5rem;<br/>  font-family: Monaco, Consolas, "Lucida Console", monospace;<br/>}</span><span id="741e" class="ni ly it nd b gy nn nk l nl nm">.TerminalPrompt {<br/>  color: #ff00df;<br/>}</span><span id="e069" class="ni ly it nd b gy nn nk l nl nm">.TerminalResults {<br/>  white-space: pre;<br/>}</span></pre><h1 id="b3d4" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">终端打字线路</h1><p id="20a0" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">所以现在我们想构建一个组件来保存我们为每一行输入的文本，这样我们就可以在显示时对它有更多的控制。这是一个简单的组件，它将接受文本和typed.js配置，并在组件显示时实例化typed.js实例。组件如下所示；</p><pre class="lb lc ld le gt ne nd nf ng aw nh bi"><span id="1f6b" class="ni ly it nd b gy nj nk l nl nm">export const TerminalLine: React.FunctionComponent&lt;{<br/>  promptText: string;<br/>  hidden?: boolean;<br/>  typedJsProps?: TypedOptions | {};<br/>}&gt; = (props) =&gt; {<br/>  // Create reference to store the DOM element containing the animation<br/>  const targetEl = React.useRef(null);<br/>  // Create reference to store the Typed instance itself<br/>  const typed = React.useRef(null);</span><span id="5cfd" class="ni ly it nd b gy nn nk l nl nm">// Trigger this effect when props.hidden changes<br/>  useEffect(() =&gt; {<br/>    if (!props.hidden) {<br/>      if (!typed.current) {<br/>        // elRef refers to the &lt;span&gt; rendered below<br/>        (typed.current as unknown as Typed) = new Typed(<br/>          targetEl.current as unknown as Element,<br/>          props.typedJsProps ?? {}<br/>        );<br/>      }<br/>    }<br/>  }, [props.hidden]);</span><span id="d707" class="ni ly it nd b gy nn nk l nl nm">return (<br/>    &lt;div className={"TerminalLine"}&gt;<br/>      &lt;span className={"TerminalPrompt"} hidden={props.hidden}&gt;<br/>        {props.promptText + " "}<br/>      &lt;/span&gt;<br/>      &lt;span className={"TerminalResults"} ref={targetEl} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="adba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要注意的一点是，在我们需要的行准备好之前，我们不想初始化typed.js对象；如果我们不这样做，每一行都会同时输出，这看起来不太像终端。为了让typed.js只在需要时初始化，当组件在屏幕上可见时，我们使用下面每当<code class="fe na nb nc nd b">props.hidden</code>改变状态时触发的react效果来启动typed.js动画。</p><p id="34ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当组件第一次被加载到页面中时，类型化的对象将是<code class="fe na nb nc nd b">null</code>，当该行被触发显示时，类型化的元素将被一个新的typed.js实例填充。然后，这个实例被附加到引用<code class="fe na nb nc nd b">targetEl</code>上，在我们漂亮的样式bash提示文本被添加到typed.js动画之前之后，该引用作为组件范围的一部分被输出。</p><pre class="lb lc ld le gt ne nd nf ng aw nh bi"><span id="9d9e" class="ni ly it nd b gy nj nk l nl nm">return (<br/>    &lt;div className={"TerminalLine"}&gt;<br/>      &lt;span className={"TerminalPrompt"} hidden={props.hidden}&gt;<br/>        {props.promptText + " "}<br/>      &lt;/span&gt;<br/>      &lt;span className={"TerminalResults"} ref={targetEl} /&gt;<br/>    &lt;/div&gt;<br/>  );</span></pre><h1 id="289a" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">把这些都集中起来。</h1><p id="df51" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">现在我们有了组成效果的两个组件，我们可以将它们结合起来，在应用程序中获得一个可配置的终端。使用<code class="fe na nb nc nd b">TypedTerminal</code>组件，您必须为命令和结果以及您可能需要的任何其他typed.js选项传递一些数据。</p><pre class="lb lc ld le gt ne nd nf ng aw nh bi"><span id="7f3c" class="ni ly it nd b gy nj nk l nl nm">import React from "react";<br/>import { TypedTerminal } from "react-component-typed-terminal";</span><span id="238c" class="ni ly it nd b gy nn nk l nl nm">const App = () =&gt; {<br/>    const typedJsProps = {<br/>        loop: false,<br/>        typeSpeed: 40,<br/>        showCursor: false,<br/>    }</span><span id="c1e4" class="ni ly it nd b gy nn nk l nl nm">const terminalData = [<br/>        {<br/>          command: "ls -a ./folder-1",<br/>          results: ["file 1", "file 2", "file 3", "file 4"],<br/>        },<br/>        {<br/>          command: "ls -a ./folder-2",<br/>          results: ["file 1", "file 2", "file 3", "file 4"],<br/>        },<br/>    ]</span><span id="e930" class="ni ly it nd b gy nn nk l nl nm">return &lt;TypedTerminal typedJsProps={typedJsProps} terminalData={terminalData}/&gt;<br/>}</span></pre><p id="2ecd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当您使用该组件时，您应该会在屏幕上看到下面的效果，您可以通过修改输入数据来自定义该效果，以控制终端输出的内容。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/850789289e9d3cff3f13a65c1e395cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dPnUSjdY4htmhAKqfW2nYw.gif"/></div></div></figure><h1 id="b02a" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">包扎</h1><p id="e9f3" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">希望看到这个组件是如何组装在一起的，会让您对如何使用它、实现类似的东西或者在其他react项目中使用typed.js有所启发。如果需要，我已经在这里打包了安装在您的项目中的回购，或者随时打开任何更改的拉请求。</p><div class="lf lg gp gr lh li"><a href="https://github.com/Aaron-K-T-Berry/react-component-typed-terminal" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">GitHub-Aaron-K-T-Berry/react-component-type-terminal</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">一个react组件，用于显示一个打字动画，使用TypedJs来显示一个类似终端的组件来显示…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">github.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw jz li"/></div></div></a></div><p id="3976" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，我已经在我的开发人员作品集中使用了这个组件，以一种开发人员和技术人员会欣赏的方式来展示我的一些技能。将这种功能封装到一个可配置的组件中，应该意味着如果需要的话，我可以将这个组件用于其他项目，并覆盖那个项目的任何样式。</p><h1 id="fdf1" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">进一步连接</h1><ul class=""><li id="224b" class="no np it kd b ke mv ki mw km nq kq nr ku ns ky nt nu nv nw bi translated">如果你正在考虑获得一个中型订阅，你可以通过使用我的<a class="ae kz" href="https://aaron-kt-berry.medium.com/membership" rel="noopener">推荐链接</a>来帮助我。</li><li id="a12a" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">查看我在<a class="ae kz" href="https://medium.com/@aaron-kt-berry" rel="noopener">媒体</a>上的其他文章，如果你想了解最新消息，请通过<a class="ae kz" href="https://aaron-kt-berry.medium.com/subscribe" rel="noopener">电子邮件</a>订阅。</li><li id="8cad" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">如果你想聊天，在推特上联系我，或者在T2的LinkedIn上联系我，如果你想雇佣我，我在T4的Codementor上。</li></ul></div></div>    
</body>
</html>