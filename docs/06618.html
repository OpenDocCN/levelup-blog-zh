<html>
<head>
<title>Coordinating goroutines — errGroup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协调goro routines-err group</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coordinating-goroutines-errgroup-c78bb5d80232?source=collection_archive---------3-----------------------#2020-12-13">https://levelup.gitconnected.com/coordinating-goroutines-errgroup-c78bb5d80232?source=collection_archive---------3-----------------------#2020-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b45a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">协调不同的路线以实现单一目标</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/708e782193bfaf426f91066e3760b00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hyfxBS1PCk7x7XTo"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@hharritt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨特·哈里特</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="3c9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在之前的一篇文章中，我谈到了我们如何使用上下文。上下文用于共享数据和分组不同goroutines的结构。这篇文章遗漏了一件事，那就是如何同步这一组事物。同步并发任务意味着要么等待所有任务完成后再做其他事情，要么取消所有任务以防出错。这就是<code class="fe lf lg lh li b">sync/errgroup</code>出现的地方。这是这个包的官方文件。包名传达了两件事:用于同步，我们将处理<code class="fe lf lg lh li b">errors</code>。这与上面提到的非常吻合，对吗？作为同步goroutines的机制，<code class="fe lf lg lh li b">errgroup</code>这个名字听起来可能有点奇怪，但是请原谅我，以后它会变得有意义。本质上，您将向该组注册goroutines，并以某种方式等待它们完成。包内的主结构是<code class="fe lf lg lh li b">errgroup.Group</code>。</p><p id="6410" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要创建一个新组，您可以调用<code class="fe lf lg lh li b">errgroup.WithContext</code>，它将接收一个<code class="fe lf lg lh li b">context.Context</code>作为参数，并返回一个指向新组和新上下文的指针。</p><p id="664c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将在此结构中使用两种方法:</p><ul class=""><li id="dec1" class="lj lk it js b jt ju jx jy kb ll kf lm kj ln kn lo lp lq lr bi translated"><code class="fe lf lg lh li b">(*errgroup.Group).Go</code> —向群组注册一个功能，并将其作为新的goroutine启动；</li><li id="8ddd" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lo lp lq lr bi translated"><code class="fe lf lg lh li b">(*errgroup.Group).Wait</code> —等待所有注册的goroutine完成或组中的任何go routine出现错误。这就是它使用<code class="fe lf lg lh li b">error</code>作为同步机制的原因。如果出现错误，上下文(由<code class="fe lf lg lh li b">errgroup.WithContext</code>返回的那个)被取消，并返回错误。这里需要注意的一点是，已经开始执行的goroutine将继续执行，因此将上下文传递给goroutine并检查它是否在go routine中被取消是很重要的(通常这是用<code class="fe lf lg lh li b">select</code>语句很容易实现的)；</li></ul><p id="204f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这对于“分散和聚集”类型的问题非常有用。例如，当您收到一个请求时，您需要从不同的外部来源获取该请求的不同信息。为了提高性能，您可以在一个goroutine中从每个数据源获取数据。这将受益于并发性，并在等待外部资源响应的同时执行多项任务。这是一个获取用户电子邮件相关数据的小程序的例子。我们从名称服务获取用户名，从内部映射(模拟数据库或内存缓存)获取忠诚度积分。你可以在我的<a class="ae le" href="https://github.com/RicardoLinck/scatter-gather" rel="noopener ugc nofollow" target="_blank"> github </a>上查看完整的实现。不过，我会在相关部分添加一些片段，并解释发生了什么。</p><p id="ab62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将从<code class="fe lf lg lh li b">main</code>函数开始，然后我们将深入研究实际的获取功能。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="5428" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步是确定如何存储从这些goroutines返回的数据。在本例中，我们将获取数据并将结果存储到一个<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/goroutines-and-channels-concurrent-programming-in-go-9f9f8495c34d">缓冲通道</a>，这是一种非常常见的模式。为了让它工作，我们需要创建将要使用的上下文(当然，为了增加趣味，需要超时)、结果通道和实际的组。</p><p id="1dd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PS:我也在一个goroutine中解雇了<code class="fe lf lg lh li b">nameservice.StartServer()</code>,只是因为我想让它成为一个外部服务，而且我也懒得做任何花哨的事情🤷‍♂.</p><p id="9820" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还将配置我们想要使用的所有获取器，我已经为此创建了一个接口和一个助手装饰器，只是为了减少样板文件，并准确地关注我们想要获取什么以及如何获取。</p><p id="11ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以使用<code class="fe lf lg lh li b">g.Go</code>运行每个提取器。它将注册我们的fetchers并在单独的goroutines中执行它们。</p><p id="43b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在触发我们的fetchers之后，我们现在等待它们完成，不管有没有错误。就处理结果(和错误)而言，我只是将它们打印到<code class="fe lf lg lh li b">stdout</code>。显然，在一个真实的应用程序中，你会想用它做些什么，但是对于这个测试，这就足够了。</p><p id="a352" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是fetcher接口和helper方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4216" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个助手只是在一个goroutine中触发底层的fetcher，并选择先发生的事情:</p><ol class=""><li id="bfbb" class="lj lk it js b jt ju jx jy kb ll kf lm kj ln kn lz lp lq lr bi translated">所提供的上下文被取消(或者是由于组中的另一个goroutine返回错误，或者是由于我们设置的超时)；</li><li id="23e2" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lz lp lq lr bi translated">提取器实际上完成了任务，并在结果通道上发送了一些东西；</li><li id="b231" class="lj lk it js b jt ls jx lt kb lu kf lv kj lw kn lz lp lq lr bi translated">或者取出器出错。</li></ol><p id="852d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我使用了多种渠道，以便更容易了解发生了什么。<code class="fe lf lg lh li b">select</code>语句将等待，直到任何一个被使用的通道返回一些东西。一旦发生这种情况，它将继续前进。</p><p id="5c50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重要的是要注意，如果底层提取器内部发生了错误，我们只记录它，而不会将该错误返回给组。这意味着当错误发生时，我们不会中止该组的其他goroutines的执行，我们只会忽略我们无法获得结果并继续前进。在各种情况下，有一些数据总比没有数据好。如果您想在出现任何错误时中止执行，只需在第38行返回错误。</p><p id="caef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里是<code class="fe lf lg lh li b">NameFetcher</code>的样子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="400b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很简单。我们只向已配置的名称服务发出HTTP请求，并将响应反序列化为一个结构。这里唯一重要的事情是我们正在传递提供给实际HTTP请求的<code class="fe lf lg lh li b">context.Context</code>。这在上下文在请求中途被取消的情况下很有用，因为HTTP客户端会在没有任何额外代码的情况下正确地关闭它。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="39c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我所说的<code class="fe lf lg lh li b">PartnerFetcher</code>要简单得多。只是在地图上查找。有一个<code class="fe lf lg lh li b">time.Sleep</code>用来模拟通话时间。这很有用，因为我们可以在<code class="fe lf lg lh li b">main</code>中将上下文超时设置为少于一秒，并看到响应中不存在获取器的输出，以及超时错误。输出应该是这样的:</p><pre class="kp kq kr ks gt ma li mb mc aw md bi"><span id="0404" class="me mf it li b gy mg mh l mi mj">{name {ricardo linck}}<br/>{loyalty_points 20}</span></pre><p id="57d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，如果我们将超时设置为500毫秒，输出将如下所示:</p><pre class="kp kq kr ks gt ma li mb mc aw md bi"><span id="af7c" class="me mf it li b gy mg mh l mi mj">{name {ricardo linck}}<br/>2020/12/13 12:51:20 context deadline exceeded<br/>exit status 1</span></pre><p id="7a95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，由于在goroutines中事情是并发运行的，所以在实际结果打印之后，会出现错误的输出，即在Fetcher中打印出来的输出。</p><h2 id="441c" class="me mf it bd mk ml mm dn mn mo mp dp mq kb mr ms mt kf mu mv mw kj mx my mz na bi translated">结束语</h2><p id="79e1" class="pw-post-body-paragraph jq jr it js b jt nb jv jw jx nc jz ka kb nd kd ke kf ne kh ki kj nf kl km kn im bi translated">我们经常需要使用并发编程来提高应用程序的性能。这并不总是一项容易的任务。但是，我们需要更进一步，同步这些并发的事情。这可能更难。<code class="fe lf lg lh li b">sync/errgroup</code>包简化了这项任务。围绕您希望您的应用程序如何运行，您仍然需要做出相当多的设计决策。该软件包带来了很大的灵活性，并消除了一些必须手动完成的样板文件和复杂性。</p><p id="8c06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有许多应用程序需要同步并发任务。我们关注的是分布式系统中常见的一种。其他例子可能包括启动多个长期服务，这些服务需要在收到信号或发生严重错误时正常关闭。并行做事通常也需要同步。这种技术在许多不同的场景中都很有用。</p></div></div>    
</body>
</html>