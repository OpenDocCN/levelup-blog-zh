<html>
<head>
<title>Create An Advanced CLI — With TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用类型脚本创建高级CLI</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-your-own-advanced-cli-with-typescript-5868ae3df397?source=collection_archive---------0-----------------------#2019-07-17">https://levelup.gitconnected.com/create-your-own-advanced-cli-with-typescript-5868ae3df397?source=collection_archive---------0-----------------------#2019-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="607f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">已经知道如何做一个简单的CLI？通过这篇文章增加你的知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/235bbf3e4fd91defce6130472b1ac4e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3RqvSFK5mZphiGm9"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jantined?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹汀·杜恩博斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="4403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是为那些已经有构建CLI的基本经验的人写的，我们将制作一个小版本的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx" rel="noopener ugc nofollow" target="_blank">CGX CLI</a></code>并使用相同的文件夹结构。CLI执行以下操作:</p><blockquote class="lz ma mb"><p id="a917" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated">为Github、Gitlab和Bitbucket社区标准生成所有推荐的markdown文档(预填充)</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/a3450df52425d0151b485a8eae0a860f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1sVcCAV2lFrGNVmIgDMOSQ.gif"/></div></div></figure><p id="1e1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户将得到一个带有选项列表的问题，选择一个选项将导致不同的结果。</p><p id="358d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">备注:</strong></p><p id="bb6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> — </strong>这与我在<a class="ae ky" href="https://itnext.io/how-to-create-your-own-typescript-cli-with-node-js-1faf7095ef89" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中写的关于用TypeScript制作一个小型“pizza”CLI的设置有些重叠。</p><p id="a19f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—本文中提到的每个文件都有一个指向完整/原始文件的链接。</p><h1 id="8423" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">项目设置</h1><p id="52d6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">首先，我们要用<code class="fe lv lw lx ly b">npm init</code>初始化一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/package.json" rel="noopener ugc nofollow" target="_blank">package.json</a></code>。您可以选择名称、作者、版本、描述、关键字和许可证。</p><h2 id="feeb" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">属国</h2><ul class=""><li id="9be6" class="nq nr it lb b lc mz lf na li ns lm nt lq nu lu nv nw nx ny bi translated">figlet —从字符串中获得一个漂亮的ASCII艺术作品</li><li id="13ed" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">inquirer —一组常见的交互式命令行用户界面。</li><li id="47ba" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">fs-extra — fs-extra包含vanilla Node.js fs包中不包含的方法。例如mkdir -p、cp -r和rm -rf。</li><li id="4a8f" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">types/fs-extra—fs-extra的类型脚本定义</li><li id="0edc" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">inversify——一个强大的轻量级反转控制容器，用于TypeScript支持的JavaScript和Node.js应用程序。</li><li id="f192" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">kleur——用ANSI颜色格式化终端文本的最快Node.js库！</li><li id="4c5f" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">反射-元数据-元数据反射API的多填充</li><li id="f1e0" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">ts lib—TypeScript助手函数的运行时库</li></ul><p id="14e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要安装所有的依赖项:</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="59db" class="ne mi it ly b gy oi oj l ok ol">npm i figlet inquirer fs-extra @types/fs-extra inversify kleur reflect-metadata tslib</span></pre><h2 id="adf6" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">开发依赖性</h2><ul class=""><li id="12d8" class="nq nr it lb b lc mz lf na li ns lm nt lq nu lu nv nw nx ny bi translated">types/node-node . js的类型脚本定义</li><li id="a5ac" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">类型/查询者—查询者的打字稿定义</li><li id="07cd" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">types/fig let—fig let的类型脚本定义</li><li id="803b" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">liftr/tscov —使用这个简单的npm包检查任何TypeScript项目的类型覆盖率</li><li id="0072" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">ts-node—node . js的类型脚本执行环境和REPL，支持源映射</li><li id="4ca8" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">typedoc—为typescript项目创建api文档。</li><li id="e5cf" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">typescript — TypeScript是一种用于应用规模JavaScript开发的语言</li></ul><p id="db06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后安装我们的devDependencies:</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="116b" class="ne mi it ly b gy oi oj l ok ol">npm i @types/node @types/inquirer @types/figlet @liftr/tscov ts-node typedoc typescript --save-dev</span></pre></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ot"><a href="https://github.com/jeroenouw/liness" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">jeroenouw/early</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">CLI计算当前项目中使用的行数。这个项目有99+%的类型覆盖率由tscov检查…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><h2 id="c074" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">Bin和main</h2><p id="bdf0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在我们的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/package.json" rel="noopener ugc nofollow" target="_blank">package.json</a></code>中，我们需要设置应用程序的入口点(main和bin)。这将是我们在<code class="fe lv lw lx ly b">lib</code>文件夹中编译的<code class="fe lv lw lx ly b">index.js</code>文件:<code class="fe lv lw lx ly b">./lib/index.js</code>。</p><p id="253a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">advanced-cli</code>是您最终用来调用CLI的命令。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/943a9011c3c8c89577ab1d918240db68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0aZspWn2OimbHO0GYu9-A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">杰克·凯恩在unsplash上拍摄的照片</figcaption></figure><h2 id="2aa2" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">剧本</h2><p id="5aa9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在我们需要一些脚本来简化我们的工作。我们有十个剧本:</p><ul class=""><li id="6ec4" class="nq nr it lb b lc ld lf lg li pj lm pk lq pl lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm start</code>—一起运行我们的<code class="fe lv lw lx ly b">build</code>和<code class="fe lv lw lx ly b">global</code>脚本。使用它来启动您的CLI</li><li id="104f" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run build</code>—运行我们的<code class="fe lv lw lx ly b">clean:some</code>脚本并将我们的类型脚本文件传输到<code class="fe lv lw lx ly b">lib</code>文件夹中的JavaScript文件</li><li id="dcfe" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run global</code> —全局安装我们的CLI并运行CLI</li><li id="589c" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run clean:some</code>—删除<code class="fe lv lw lx ly b">lib</code>和<code class="fe lv lw lx ly b">docs</code>文件夹</li><li id="1a64" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run clean:all</code>—删除<code class="fe lv lw lx ly b">node_modules</code>、<code class="fe lv lw lx ly b">package-lock.json</code>、<code class="fe lv lw lx ly b">lib</code>和<code class="fe lv lw lx ly b">docs</code>文件夹和文件</li><li id="2b21" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run refresh</code>—运行我们的<code class="fe lv lw lx ly b">clean:all</code>脚本并运行<code class="fe lv lw lx ly b">npm install</code></li><li id="7908" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run tscov</code>—检查至少90%的类型覆盖率</li><li id="c3d3" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run tscov:d</code>—参见缺失类型覆盖范围</li><li id="22f5" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run publish-package</code>—运行我们的<code class="fe lv lw lx ly b">build</code>和<code class="fe lv lw lx ly b">npm publish</code>脚本</li><li id="41a5" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe lv lw lx ly b">npm run docs</code>—在<code class="fe lv lw lx ly b">docs</code>文件夹中生成自动化文档</li></ul><p id="04dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下内容写入<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/package.json" rel="noopener ugc nofollow" target="_blank">package.json</a></code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/a3b0b6da118ed206f4d82babe17722b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F82J2GdLycdk_bGK8ScOzA.png"/></div></div></figure><h2 id="2b63" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">TSconfig</h2><p id="9cc1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">对于我们的CLI，我们在名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/tsconfig.json" rel="noopener ugc nofollow" target="_blank">tsconfig.json</a></code>的文件中设置了一些类型脚本配置，在根目录下创建该文件，并将以下配置写入其中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/989941961870fd0c4cbe6eeee6f3040b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIGvzrLOu46EQejNNBmsgQ.png"/></div></div></figure><h2 id="2e9f" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">环境</h2><p id="6c5f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在名为<code class="fe lv lw lx ly b">bin</code>的文件夹中创建一个名为<code class="fe lv lw lx ly b">advanced-cli</code>的文件。有了这个内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/f13f907d1b77504ac694058087dae33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RR8XCvqw8bQzNT6m7htINA.png"/></div></div></figure><h1 id="ee60" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">编码时间！</h1><h2 id="32b6" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">文件夹结构— 1</h2><p id="27d3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">用以下文件夹创建一个<code class="fe lv lw lx ly b">src</code>文件夹:</p><ul class=""><li id="e43d" class="nq nr it lb b lc ld lf lg li pj lm pk lq pl lu nv nw nx ny bi translated">模型</li><li id="5f02" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">问题</li><li id="6078" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">模板</li><li id="dc68" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">实用工具</li></ul><p id="c4f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，在<code class="fe lv lw lx ly b">src</code>文件夹中创建以下文件:</p><ul class=""><li id="9568" class="nq nr it lb b lc ld lf lg li pj lm pk lq pl lu nv nw nx ny bi translated">index.ts</li><li id="c4ca" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">客户</li></ul><h2 id="c8ab" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">型号— 2</h2><p id="552e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">接下来我们将开始在我们的<code class="fe lv lw lx ly b">models</code>文件夹中制作一些界面和枚举，在名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/models/choice.ts" rel="noopener ugc nofollow" target="_blank">answer-choice.ts</a></code>的文件中。我选择枚举而不是常量，因为其中的属性与其他属性有相似之处。因此应该组合在一起。<code class="fe lv lw lx ly b">Answer</code>和<code class="fe lv lw lx ly b">choice</code>接口的名称不言自明。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/d051989341a4185ba7bc7f0be7bedf61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLETnAAKZrAkPsI_fXq2gA.png"/></div></div></figure><p id="0849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个文件；<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/models/file.ts" rel="noopener ugc nofollow" target="_blank">filename.ts</a></code>包含文件名及其扩展名。在这种情况下<code class="fe lv lw lx ly b">.md</code>用于降价。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/103a6997d50e651d825c670639c7b918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRmNt-PlWlh0pNMS2u7H3A.png"/></div></div></figure><p id="3855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最后的文件；<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/models/path.ts" rel="noopener ugc nofollow" target="_blank">path.ts</a></code>确实有需要生成文件的具体路径。这对于<code class="fe lv lw lx ly b">gitlab</code>和<code class="fe lv lw lx ly b">github</code>是不同的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/61123a11a221f25b17ddb5116d2de9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ms6Hzp5-UHXYp4a1eP74dA.png"/></div></div></figure><h2 id="d53a" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">问题— 3</h2><p id="49ac" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在我们将在问题中使用枚举和接口。在我们的问题文件夹中创建一个名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/questions/provider.question.ts" rel="noopener ugc nofollow" target="_blank">provider.question.ts</a></code>的文件。导入<code class="fe lv lw lx ly b">inquirer</code>，这让我们可以在命令行中提问，并根据答案采取行动。我们有一个包含列表和提示的异步函数。它返回一个答案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/b79883d0c6a4c3bb0ca13faf0010f2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Sd6t6V48v9smKRypNziDw.png"/></div></div></figure><p id="b7e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建另一个名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/questions/gitlab-file.question.ts" rel="noopener ugc nofollow" target="_blank">gitlab-file.question.ts</a></code>的文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/4fe5a2ecc10994adb5c5916e486126a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bxsFXlgKBDhgHnHJ9LczMw.png"/></div></div></figure><p id="2b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个问题文件叫做<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/questions/github-file.question.ts" rel="noopener ugc nofollow" target="_blank">github-file.question.ts</a></code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/5bdfa4e839d52effd574b2388790f797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QK2UjiyFxl5qKUkR99a8oQ.png"/></div></div></figure><p id="b7ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当每个提供者有更多文件时，您现在可以轻松地将它们添加到<code class="fe lv lw lx ly b">listOfFiles</code>中。</p><p id="c808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将问题导出到<code class="fe lv lw lx ly b">index.ts</code>文件中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/5aeda861a0b0331b9be09f7314d77e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7n5llJZ-nfp29qOm5hXYnQ.png"/></div></div></figure><h2 id="7b61" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">实用工具— 4</h2><p id="772f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu">可选:</strong>实用程序是可选的。在我自己的项目中，我使用了一个util来检查一个文件/文件夹是否已经存在，如果不存在，就创建一个文件/文件夹。另一个util是用于可重用和“漂亮”的控制台日志(错误、成功、信息等)。).他们可以在这里找到。</p><h2 id="ec1a" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">模板— 5</h2><p id="2b53" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在我们的<code class="fe lv lw lx ly b">templates </code>文件夹中，我们创建了一个名为<code class="fe lv lw lx ly b">default</code>的文件夹。在默认文件夹中，我们创建了一个文件<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/templates/default/default.template.ts" rel="noopener ugc nofollow" target="_blank">default.template.ts</a></code>。正如文件名所说，这将是我们的默认模板，不同的文件将在这里生成。我们通过<code class="fe lv lw lx ly b">inversify</code>使用依赖注入。因为有了<code class="fe lv lw lx ly b">@injectable</code>装饰器，我们的模板可以<code class="fe lv lw lx ly b">Injected</code>到其他模板中。为了在您的本地机器上创建一个文件，我们使用来自<code class="fe lv lw lx ly b">fs-extra</code>的<code class="fe lv lw lx ly b">fs.writeFile</code>。</p><p id="4a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/templates/default/default.template.ts" rel="noopener ugc nofollow" target="_blank">原</a> <code class="fe lv lw lx ly b">generateFile</code>方法包含文件/文件夹是否存在以及覆盖文件的选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/8ad0793213957f0bbea619bebb0c6b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fnKvE-LXApV9bm0gBXMPg.png"/></div></div></figure><p id="e025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">templates</code>中创建另一个名为<code class="fe lv lw lx ly b">gitlab</code>的文件夹。在这个文件夹中创建一个名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/templates/gitlab/merge-request.template.ts" rel="noopener ugc nofollow" target="_blank">merge-request.template.ts</a></code>的文件。在我们的模板类中，有三个属性:</p><ul class=""><li id="a24e" class="nq nr it lb b lc ld lf lg li pj lm pk lq pl lu nv nw nx ny bi translated">fileName —我们使用之前创建的enum作为文件名和扩展名</li><li id="b8dd" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">hasPath —如果生成的文件不在项目的根目录中，则设置为true</li><li id="b062" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">path offfile—指定文件所属的路径</li></ul><p id="d822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次使用了<code class="fe lv lw lx ly b">@injectable</code>装饰器，但是现在也使用了<code class="fe lv lw lx ly b">@inject</code>装饰器来注入我们的默认模板。</p><p id="f1c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个公共方法，其中我们调用默认模板的公共可重用<code class="fe lv lw lx ly b">generateFile</code>方法。和一个私有方法，我们在其中粘贴我们的markdown文件内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/aa4b636027cef24f6a82e2d179c0692a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JeDXFWD3y_rTBho2nWTvFQ.png"/></div></div></figure><p id="f905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来在我们的<code class="fe lv lw lx ly b">templates</code>文件夹中创建一个名为<code class="fe lv lw lx ly b">github</code>的文件夹。在这个文件夹中创建一个名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/templates/github/feature-request.template.ts" rel="noopener ugc nofollow" target="_blank">feature-request.template.ts</a></code>的文件。这个文件与前一个文件非常相似。但是具有不同的属性值和文件内容。我们现在可以很容易地为未来的文件制作更多的模板。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/495ed7e8b8818a0bf138d1ca608c2c66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9sfdth7MlXNdq-m_XmJUg.png"/></div></div></figure><h2 id="bd3e" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">客户端-6</h2><p id="2588" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">倒数第二档是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/cgx.ts" rel="noopener ugc nofollow" target="_blank">cli.ts</a></code>。我们在构造函数中注入两个模板，并调用<code class="fe lv lw lx ly b">executeCLI</code>方法。在这个方法中，我们询问用户他想要选择哪个提供商。如果他选择Github，那么我们的<code class="fe lv lw lx ly b">githubActions</code>方法将被调用。这里提出了第二个问题。用户想要生成哪个文件。在这种情况下，我们只有一个文件。选择文件后，它将被生成。如果我们选择了Gitlab，这同样适用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/4b3a1f96ea9400ef56e2e95dd13293ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RVJip80uh-goPWv__DQHBQ.png"/></div></div></figure><h2 id="5bd9" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">index.ts — 7</h2><p id="9f16" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们的最后一个文件<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/jeroenouw/cgx/blob/master/src/index.ts" rel="noopener ugc nofollow" target="_blank">index.ts</a></code>，是我们的CLI初始化的地方。我们需要这个项目中使用的自定义装饰<code class="fe lv lw lx ly b">reflect-metadata</code>。index函数包含一个容器，我们将所有的类(包含可注入的decorator)绑定到这个容器，作为一个单独的作用域。最后，我们返回CLI，在那里我们会被提问。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/dee70dd68c3794cb1c956512455876ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7O_huUo7M4wtxPjn0AqGg.png"/></div></div></figure><p id="2ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行<code class="fe lv lw lx ly b">npm start</code>，我们应该得到两个问题。回答完这些问题后，我们现在在本地项目中有了一个生成的文件</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/7a2d8e3af0021459b8703c66573e7975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyiFUxuCZ6Q-RTeY6heD-A.png"/></div></div></figure></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><h2 id="db2d" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">感谢您的阅读！我的<a class="ae ky" href="https://github.com/jeroenouw/" rel="noopener ugc nofollow" target="_blank"> Github </a>。考虑阅读我的其他文章，看看我的开源项目:</h2><div class="pu pv gp gr pw ot"><a href="https://github.com/jeroenouw/cgx" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">杰罗诺/cgx</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">💻🔥为Github、Gitlab和Bitbucket社区生成所有推荐的文档/模板(预填充)</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="px l pe pf pg pc ph ks ot"/></div></div></a></div><div class="pu pv gp gr pw ot"><a href="https://itnext.io/javascript-array-loop-methods-46ad0d7a5a7c" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">JavaScript —数组循环方法</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">数组方法forEach，map，flatMap，filter，reduce，sort，some，every —简单的例子</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">itnext.io</p></div></div><div class="pc l"><div class="py l pe pf pg pc ph ks ot"/></div></div></a></div><div class="pu pv gp gr pw ot"><a href="https://medium.com/@jeroenouw/ecmascript-vs-typescript-private-fields-640ae37aa162" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">EcmaScript与TypeScript —私有字段</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">TypeScript的private关键字和EcmaScript/JavaScript的#字符有什么区别</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pz l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>