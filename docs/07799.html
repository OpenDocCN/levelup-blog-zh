<html>
<head>
<title>Building a Realtime GraphQL Chat Application With SMS Notifications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个带有SMS通知的实时GraphQL聊天应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-realtime-graphql-chat-application-with-sms-notifications-cc8ecbd0ada0?source=collection_archive---------8-----------------------#2021-03-11">https://levelup.gitconnected.com/building-a-realtime-graphql-chat-application-with-sms-notifications-cc8ecbd0ada0?source=collection_archive---------8-----------------------#2021-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10fec5a6aebd5fe249ac9d2ec8a1545c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fW-rkj0CoQjC0ALtbvsGig.png"/></div></div></figure><p id="a279" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着<a class="ae kw" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">的出现，GraphQL </a>为开发者提供了一种开发客户机/服务器应用程序的新方法。开发GraphQL应用程序的好处很多，从向服务器明确请求您需要的东西到通过订阅进行实时事件驱动的通信。本文重点介绍代码优先的GraphQL及其强大功能。本文还将概述如何开发一个聊天应用程序，在前端使用<a class="ae kw" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>和<a class="ae kw" href="https://www.apollographql.com/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>，在后端使用优秀的<a class="ae kw" href="https://www.vonage.com/communications-apis/sms/" rel="noopener ugc nofollow" target="_blank"> Vonage SMS API </a>使用<a class="ae kw" href="https://www.prisma.io/blog/prisma-2-beta-b7bcl0gd8d8e" rel="noopener ugc nofollow" target="_blank"> Prisma 2 </a>、<a class="ae kw" href="https://github.com/prisma-labs/graphql-yoga/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> Graphql-yoga </a>和SMS通知。</p><h1 id="ee74" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">代码优先图</h1><p id="2c3a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">代码优先的GraphQL是一种开发GraphQL服务器的方法，它通过编写解析器和外包模式定义来以编程方式生成。它通常被称为解析器优先方法。模式的生成由一个工具处理，该工具遍历解析器并生成模式。模式优先与代码优先方法相反，它涉及定义类型、响应等。，您的服务器。</p><h1 id="89c4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">后端开发</h1><p id="0ca3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将建立一个带有短信通知的实时聊天应用程序。</p><p id="aa89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，克隆这个<a class="ae kw" href="https://github.com/themmyloluwaa/nextjs-graphql-prisma-starter" rel="noopener ugc nofollow" target="_blank">库</a>。它包含了您需要遵循本文的基本设置。</p><h2 id="a496" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">先决条件</h2><ul class=""><li id="ad2c" class="mm mn iq ka b kb lv kf lw kj mo kn mp kr mq kv mr ms mt mu bi translated">节点js &gt;=10.0.0</li><li id="161a" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">之前对Prisma的理解</li><li id="7582" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">了解GraphQL</li><li id="80ea" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">数据库，例如MySQL</li><li id="7536" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">Prisma CLI</li><li id="2a08" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">Vonage账户</li></ul><p id="be8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要完成本教程，您将需要一个<a class="ae kw" href="http://developer.nexmo.com/ed?c=blog_text&amp;ct=2021-02-25-building-a-realtime-graphql-chat-application-with-sms-notifications" rel="noopener ugc nofollow" target="_blank"> Vonage API帐户</a>。如果你还没有，你可以<a class="ae kw" href="http://developer.nexmo.com/ed?c=blog_text&amp;ct=2021-02-25-building-a-realtime-graphql-chat-application-with-sms-notifications" rel="noopener ugc nofollow" target="_blank">今天</a>注册，开始用免费的信用点数建造。一旦你有了一个帐户，你可以在<a class="ae kw" href="http://developer.nexmo.com/ed?c=blog_text&amp;ct=2021-02-25-building-a-realtime-graphql-chat-application-with-sms-notifications" rel="noopener ugc nofollow" target="_blank"> Vonage API仪表板</a>的顶部找到你的API密匙和API秘密。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/941d1ebad7252085aa9c1e88f9dc18f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9RUNrmWVrhuK9uZKQ1igZA.png"/></div></div></figure><p id="1b1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们了解一下项目目录。</p><p id="ca1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根目录中包含两个文件夹。后端目录包含一个保存Prisma配置的Prisma文件夹。prisma文件夹中有一个schema.prisma文件，其中包含数据库设置配置和一个名为dev.db的SQLite db。导航到后端目录并运行<code class="fe ne nf ng nh b"><strong class="ka ir">npm install</strong></code>来安装所有必要的依赖项。</p><p id="719e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，在后端目录中创建一个. env文件；这将包含必要的环境变量，如数据库URL和变量等。对于数据库URL，将其粘贴到env文件中:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="264d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">frontend文件夹中的pages目录是Next.js将为应用程序页面提供服务的地方。pages目录包含一个_app.js，它被设置为使用Bootstrap。导航到前端目录并运行<code class="fe ne nf ng nh b">npm install</code>。该文件夹还包括一个src目录，其中包含资产、组件和utils子目录。</p><p id="bff2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，导航到prisma/schema.prisma文件。我们需要两个模型，一个用于用户，一个用于聊天。下面是生成器客户端配置:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="16db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模型表示将在数据库中创建的表名，而字段表示将存储在那里的列名和数据类型。除了Prisma中可用的数据类型之外，模型也可以是一种数据类型。这就是定义两个或更多模型之间的关系或者一个模型的自身关系。我们用Prisma关键字注释每个模型。如果你不明白所使用的关键字，请查阅Prisma <a class="ae kw" href="https://www.prisma.io/docs/concepts" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="9045" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe ne nf ng nh b">prisma migrate save --experimental</code>。命名您的迁移并运行<code class="fe ne nf ng nh b">prisma migrate up --experimental</code>。该命令将基于模式中的模型定义创建表。最后，运行<code class="fe ne nf ng nh b">prisma generate</code>来展示映射到Prisma方法的数据库模式和支持CRUD功能的特性。</p><p id="d78c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导航到<strong class="ka ir"> src/types </strong>目录并创建一个用户和聊天文件。已经存在四个文件:Mutation.js、Query.js、Subscription.js和一个index.js文件，该文件将所有解析器合并为一个。</p><p id="0466" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在User.js文件中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8ac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Chat.js文件中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ad28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从nexus导入一个<strong class="ka ir"> <em class="nk"> objectType </em> </strong>，因为用户和聊天模型是object类型的。我们使用模型方法和字段名称来访问我们在模式中定义的字段。这是通过我们安装的<strong class="ka ir"><em class="nk">nexus-plugin-prisma</em></strong>实现的。这有助于我们不再需要开始逐个定义和配置每个字段。以下代码是手动进行配置的示例:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f7b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在突变文件中，我们来处理登录和注册。在src/types目录下创建一个名为<strong class="ka ir"> AuthPayload.js </strong>的新文件。这是一个对象类型，表示返回给客户端的身份验证负载类型。</p><p id="0783" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在AuthPayload.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3dea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在src/utils目录中，创建一个helper.js文件并创建这些方法。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:现在你应该已经在你的。这些方法的env文件。</p><p id="d425" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们有了一种使用getUser方法获取用户ID的方法。让我们修改script.js文件。从src/utils/helpers导入getUser方法，并在服务器配置文件上取消对这部分上下文方法的注释。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9f84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在mutation.js文件中，添加注册代码:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们首先检查数据库是否包含一个有电子邮件或电话的用户，如果用户存在，我们抛出一个错误，否则我们创建用户，使用用户的id生成一个令牌，并将令牌设置为cookie。我们还返回注册有效载荷。</p><p id="9bf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容添加到login.js中，就在注册解析器的下面:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c8e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们验证用户是否存在，验证他们的登录凭证，将令牌设置为cookie，并返回auth有效负载突变类型。我们还通过在服务器配置中创建的Vonage SMS API实例向他们发送SMS通知。</p><p id="9974" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在应用程序上处理用户的短信通知，我从Vonage购买了一个虚拟号码。你应该按照这篇<a class="ae kw" href="https://learn.vonage.com/blog/2019/09/16/how-to-send-and-receive-sms-messages-with-node-js-and-express-dr" rel="noopener ugc nofollow" target="_blank">文章</a>开始创建一个Vonage短信应用程序。一旦你创建了一个应用程序，一个私钥文件会自动下载到你的电脑上。将此文件移动到后端目录。您还应该在您的。env文件，我从Vonage账号买的虚拟号。</p><p id="9082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前进到<strong class="ka ir"> types/index.js文件</strong>，注释掉查询和订阅导入，因为我们在那里没有任何东西。现在，导入User.js和Chat.js文件。</p><p id="36fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一个查询解析器，允许用户查询他们的帐户详细信息。在Query.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b750" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们已经在服务器配置的上下文字段中处理了对收到的每个请求的用户查询，所以如果用户存在于ctx对象上，我们就可以访问他们。如果ctx对象上不存在该用户，则意味着该用户需要登录。在types/index.js文件中，取消对导入的Query.js文件的注释。</p><p id="e374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再创建两个查询解析器；一个用于查询一个用户，一个用于查询多个用户。我们将使用nexus-plugin-prisma crud功能；这是一个实验性的功能，所以我们需要打开它。在<strong class="ka ir"> script.js </strong>文件中，在plugins字段中，将<code class="fe ne nf ng nh b">{experimentalCRUD: true}</code>添加到nexusPrisma函数(如果没有添加的话)。</p><p id="2f5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Query.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d410" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用这个功能，请确保用单数形式命名您的模式模型，如<strong class="ka ir">用户</strong>而不是<strong class="ka ir">用户</strong>。让我们也使用这个特性来处理变异文件中的更新一个用户和删除一个用户解析器。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="94b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们来处理聊天解析器。让我们再添加两个文件，一个叫做Subscription.js，另一个叫做SubscriptionPayload。将这两个文件添加到index.js文件中的类型(解析器)列表中。</p><p id="10a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b"><strong class="ka ir">SubscriptionPayload.js</strong></code></p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a6ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了处理订阅，我们将使用Graphql-yoga包附带的<strong class="ka ir"> PubSub </strong>方法。</p><p id="50e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们为一个聊天创建CRUD功能，订阅解析器将监听这些CRUD事件。让我们还创建一个sendNewMessageNotification函数，用于在聊天接收者之间的前一次对话不到一小时之前的任何时候向他们发送通知。</p><p id="3999" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在helper.js文件中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="73e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此方法检查最后发送的消息是否少于1小时。如果是，我们向消息的接收者发送短信通知，如果不是，我们什么也不做。导出sendNewMessageNotification方法并将其导入到Mutation.js文件中。现在让我们来处理createChat解析器。</p><p id="59ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Mutation.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d8e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过检查服务器上是否存在用户对象来验证消息发送者是否登录，然后验证消息是否为空。我们首先查询用户发送或接收的最后一条消息，然后创建新消息。如果两者之间的前一条消息不到一小时，则sendNewMessageNotification方法将被触发。最后，让我们处理订阅方面。</p><p id="6cf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Subscription.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7ebf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从nexus/schema中导入intArg和subScriptionFIeld对象，还从graphql-yoga包中导入withFIlter方法——这有助于我们确保只有正确的用户才能接收有效负载或事件。第一个参数是subscribe resolver，它返回我们想要过滤的asyncIterator，它传递了我们想要监听的事件，即<em class="nk">创建、更新、删除</em>。第二个参数是事件通过必须满足的条件。对于我们的用例，这个事件应该只传递给消息数据的发送者和接收者。出于好奇，注释掉该字段并进行测试。您应该注意到，发送消息会通知应用程序中监听createChat解析器的所有用户。</p><p id="f32c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们添加updateChat和deleteChat变体——这与创建聊天略有不同。首先，我们需要检查用户是否经过身份验证。其次，我们必须检查消息是否存在；最后，我们需要检查消息的发送者是否可以更新或删除它。没有发送邮件的用户不应该有权删除邮件。如果这些条件通过，我们更新或删除聊天，然后通知我们的订户。</p><p id="84d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于updateChat变体，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="05d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于deleteChat突变，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e92c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们利用聊天和聊天查询的CRUD功能。在Query.js文件中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="10eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们一直致力于应用程序的变异、查询和订阅方面。我们已经创建了低级别的权限和授权机制，以确保应用程序的一些功能是安全的，但现在是时候保护我们的API了。让我们在许可上工作。</p><p id="b5cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理想情况下，我们不希望应用程序中的所有特性都是私有的，或者对未经身份验证的用户不可访问。我们也不想让所有东西都可以访问，那么我们如何解决这个问题呢？</p><p id="f05f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将使非认证用户可以访问用户列表查询，而其他功能将受到保护。我们还将为一些解析器添加额外的权限，以确保只有管理员可以执行某些操作，如删除用户。让我们开始吧。我们将使用Graphql-shield。这里有一个很好的<a class="ae kw" href="https://medium.com/@maticzav/graphql-shield-9d1e02520e35" rel="noopener">教程</a>，它涵盖了Graphql-shield的基础知识。</p><p id="9801" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在permissions/rules.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在permissions/index.js文件中，我们将我们的规则定义应用于我们的每个解析器。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在script.js的服务器配置文件中，取消对中间件字段的注释以打开权限。</p><h1 id="5c7b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">前端开发</h1><p id="18e6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">GitHub存储库已经附带了编码所需的包和默认设置。运行<code class="fe ne nf ng nh b"><strong class="ka ir">npm i</strong></code>安装所需的依赖项。</p><p id="0580" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导航到pages文件夹并创建login、signup.js和index.js文件。</p><p id="2d0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们来研究用户登录和注册。在我们继续之前，让我们创建一个Layout.js文件，用站点标题、favicon等可重用功能包装我们的页面。</p><p id="12d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在components文件夹中，创建一个Layout.js文件。</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1272" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在login.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="33fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在getServerSideProps中，我们检查令牌是否存在。如果令牌存在，这意味着用户还没有登录，我们将用户重定向到主页。如果令牌不存在，我们继续。导入所需的导入，如setToken、Mutation和useMutation。我们定义了一个基本的UI，用于登录并提供用户名和密码字段。该用户名接受电子邮件或电话号码。如果我们从服务器得到一个成功的响应，我们就设置令牌，并把用户导航到在<code class="fe ne nf ng nh b">redirecTo</code>变量中定义的所需URL。否则，如果登录凭证不正确，我们向用户显示此消息。如果你不明白useMutation钩子是如何工作的，请阅读Apollo客户端文档<a class="ae kw" href="https://www.apollographql.com/docs/react/data/mutations/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="be39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Signup.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="109b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，导航到您的浏览器并测试登录和注册。</p><p id="1dca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，创建index.js和chat.js文件。在index.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ba61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在getServerSideProps中，我们检查令牌cookie。如果令牌不存在，用户将被重定向到登录页面。如果令牌存在，则在将数据作为props返回之前，会过滤掉登录的用户。array filter方法用于处理客户端搜索，useMemo React钩子用于记忆用户数据以防止不必要的重新呈现。</p><p id="166d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在项目目录的gql文件夹中找到用于这些页面的GraphQL查询。</p><p id="4060" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在组件文件夹中创建一个ChatBubble组件。我们将利用day.js包来处理消息时间戳。安装<code class="fe ne nf ng nh b">npm install dayjs</code>包并在utils中创建一个格式化数据文件。在formatDate.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1948" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在ChatBubble.js中插入:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7b0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据收到的聊天对象，如果发送者是当前登录的用户，我们会应用各种样式，如聊天气泡的方向。</p><p id="e841" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在chat.js中，添加:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5270" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们来了解一下这是怎么回事。我们首先检查令牌cookie是否存在。如果不存在，我们将用户重定向到登录页面，并将聊天页面作为redirectTo函数传递。如果令牌存在，用户对象有效负载被添加到prop中，聊天数据在客户机上使用useQuery钩子获取。这使我们可以访问一个名为<code class="fe ne nf ng nh b">subscribeToMore</code>的方法，我们在<code class="fe ne nf ng nh b">useEffect</code> hook中调用该方法来处理订阅更多的消息以立即接收更新。<code class="fe ne nf ng nh b">subscribeToMore</code>方法接受订阅查询、所需的变量和一个updateQuery方法，该方法告诉它如何处理收到的新消息。关于如何工作的更多信息，<a class="ae kw" href="https://www.apollographql.com/docs/react/data/subscriptions/#usesubscription-api-reference" rel="noopener ugc nofollow" target="_blank">文档</a>有一个有用的指南。useMutation钩子处理新消息的创建。</p><p id="be00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们在配置文件页面上工作，用户可以在处理云部署之前查看和更新他们的配置文件。</p><p id="4641" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，创建profile.js文件。然后添加以下内容:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d56c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只编辑姓名和电子邮件字段。如果更新成功，我们向用户显示一条toast消息，并在1.3秒后将用户重定向到登录页面，以便使用新的凭据登录。</p><h1 id="21d7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">部署</h1><p id="3010" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们已经创建了GraphQL服务器，还开发了一个用NextJS构建的应用程序来使用这些端点。服务器API受到保护，页面也是如此。由于我们一直在本地开发，现在是时候向世界公开这个应用程序了。我们将在Heroku上部署服务器，在Vercel上部署客户端应用。我将向您展示两种部署应用程序的方法。一个使用命令行界面，另一个使用Vercel仪表板。在这里创建一个Vercel账户<a class="ae kw" href="https://vercel.com/" rel="noopener ugc nofollow" target="_blank">。在这里</a>创建一个Heroku账号<a class="ae kw" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1da0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，安装带有<code class="fe ne nf ng nh b">npm i -g vercel</code>的Vercel CLI。按照此处的说明<a class="ae kw" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank">安装Heroku CLI。</a></p><p id="347b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建两个新分支。一个称为生产/服务器，另一个称为生产/客户端。让我们先来部署服务器。</p><p id="ea2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们删除生产中不需要的文件。在Prisma文件夹中，删除dev.db文件和migration文件夹。我们将在生产中使用Postgres数据库。我们可以从ElephantSql获得一个免费的PostgreSQL数据库。创建一个<a class="ae kw" href="https://www.elephantsql.com/" rel="noopener ugc nofollow" target="_blank">账户</a>并创建一个新的Postgres数据库。导航到后端目录，复制数据库URL并将其替换到您的。环境文件。在prisma/schema.prisma文件中，将数据源数据库设置替换为:</p><figure class="na nb nc nd gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2329" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有了新的数据库，是时候运行迁移了。运行<code class="fe ne nf ng nh b"><strong class="ka ir">npx prisma migrate save --experimental</strong></code>和<code class="fe ne nf ng nh b"><strong class="ka ir">npx prisma migrate up --experimental</strong></code>。</p><p id="7fcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在终端中，运行heroku login并输入您的凭证。然后，运行<code class="fe ne nf ng nh b">heroku create &lt; name-of-your-app &gt;</code>。让我们设置应用程序使用的环境变量。要设置配置变量，使用<code class="fe ne nf ng nh b">heroku config:set &lt; name &gt;= &lt; value &gt; -a &lt; namme-of-your-app&gt;</code>，例如我的SALTROUND变量<code class="fe ne nf ng nh b"><strong class="ka ir">heroku config:set SALTROUND=10 -a vongage-graphql-api</strong></code></p><p id="d21b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的根目录包含客户端和服务器代码，Heroku不支持子目录部署，我们必须使用不同的构建包进行部署。请在此处遵循本文<a class="ae kw" href="https://medium.com/@timanovsky/heroku-buildpack-to-support-deployment-from-subdirectory-e743c2c838dd" rel="noopener">进行操作。添加所需的配置变量后，运行:</a></p><ul class=""><li id="7223" class="mm mn iq ka b kb kc kf kg kj nl kn nm kr nn kv mr ms mt mu bi translated"><code class="fe ne nf ng nh b"><strong class="ka ir">heroku buildpacks:clear</strong></code></li><li id="c239" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated"><code class="fe ne nf ng nh b"><strong class="ka ir">heroku buildpacks:set </strong><a class="ae kw" href="https://github.com/timanovsky/subdir-heroku-buildpack" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">https://github.com/timanovsky/subdir-heroku-buildpack</strong></a></code></li><li id="fd9d" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated"><code class="fe ne nf ng nh b"><strong class="ka ir">heroku buildpacks:add heroku/nodejs</strong></code></li><li id="1499" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated"><code class="fe ne nf ng nh b"><strong class="ka ir">heroku config:set PROJECT_PATH=Backend</strong></code></li></ul><p id="f0c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，将其添加到package.json文件中的脚本中:</p><p id="5bba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng nh b">"heroku-postbuild": "npm run postinstall"</code></p><p id="e131" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们刚刚添加的脚本确保了在安装了项目的依赖项之后，Heroku会生成必要的Prisma数据库实例。</p><p id="94f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过运行<code class="fe ne nf ng nh b">git remote -v</code>确认Heroku是远程存储库的一部分。如果没有看到名为Heroku的遥控器，通过运行<code class="fe ne nf ng nh b">heroku git:remote -a &lt;app-name&gt;</code>添加它。</p><p id="2122" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，运行git <code class="fe ne nf ng nh b">git push heroku master</code>。这将推动您的代码并构建它。如果您遇到任何问题，请确保您已经设置了应用程序使用的所有env变量，并仔细按照说明进行操作。接下来，运行<code class="fe ne nf ng nh b">heroku apps:open /playground</code>。</p><h1 id="7dac" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">前端</h1><p id="1334" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">确保您已经将所有的更改推送到生产/服务器分支中的GitHub。从那里创建一个名为production/client的新分支，并为查询替换相应的Graphql端点，并将其转换为您的生产URL。对于订阅，请将HTTPS协议替换为WSS。将更改推送到GitHub并导航到您的Vercel帐户。</p><p id="1792" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的仪表板中，</p><ul class=""><li id="886d" class="mm mn iq ka b kb kc kf kg kj nl kn nm kr nn kv mr ms mt mu bi translated">点击导入项目，复制你的GitHub库链接并粘贴</li><li id="0e78" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">选择前端目录作为项目的根目录并命名</li><li id="c491" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">它应该会自动将NextJS检测为首选框架。我们没有使用任何env变量，所以让这部分为空。然后单击部署。</li><li id="b355" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">项目完全部署后，导航到settings选项卡。在git中，将部署分支从main更改为production/client。</li><li id="3a56" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">导航到您的代码，对您的文件进行更改，提交它，并推送到生产/客户端分支。它将自动构建并启动您的项目。</li><li id="1008" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">部署完成后，导航到您的Heroku仪表板。在您的服务器应用程序中，导航到settings选项卡，并将FRONTEND_ORIGIN URL更改为我们刚刚在Vercel上部署的生产客户端URL。确保您没有在URL的末尾添加斜杠。比如应该是www.example.com的<a class="ae kw" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">，而不是www.example.com/</a>的<a class="ae kw" href="http://www.example.com/" rel="noopener ugc nofollow" target="_blank"/></li><li id="bf27" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated">瞧，我们完成了。</li></ul><h1 id="5fb7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="963d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一篇很长的文章，但我相信它值得一试。总的来说，我们已经介绍了如何使用代码优先的方法创建一个同样支持订阅的GraphQL服务器。我们进入了Vonage SMS API，并使用它向用户发送短信通知。我们使用奇妙的Prisma 2数据库ORM来处理数据库查询。别忘了，我们使用Apollo和NextJS来消耗端点。最后，我们使用CLI和GUI在Vercel主机服务和Heroku上进行部署。我坚信我已经用这些工具武装了你构建下一个伟大想法所需要的一切。我对你的挑战是把这个应用程序提高到一个新的水平，增加更多的功能，如密码重置，添加朋友，帖子等。</p><p id="54e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您花时间尝试本教程。如果你被卡住了，不要犹豫，通过Twitter联系我，电话是<a class="ae kw" href="https://twitter.com/themmyloluwaaa" rel="noopener ugc nofollow" target="_blank"> @codekagei </a>或者发表评论。黑客快乐！</p><p id="f267" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考代码:</p><ul class=""><li id="0f50" class="mm mn iq ka b kb kc kf kg kj nl kn nm kr nn kv mr ms mt mu bi translated"><a class="ae kw" href="https://vonage-nextjs-client.vercel.app/login?redirectTo=/" rel="noopener ugc nofollow" target="_blank">前端</a></li><li id="1a65" class="mm mn iq ka b kb mv kf mw kj mx kn my kr mz kv mr ms mt mu bi translated"><a class="ae kw" href="https://vonage-graphql-server.herokuapp.com/playground" rel="noopener ugc nofollow" target="_blank">后端</a></li></ul><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/36041bd8c76b9e351bb98c0e9d6cd4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRxbG9WxMVfp21rfMvQ1Gg.png"/></div></div></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="acb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nk">最初发布于</em><a class="ae kw" href="https://learn.vonage.com/blog/2021/02/25/building-a-realtime-graphql-chat-application-with-sms-notifications/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://learn . vonage . com/blog/2021/02/25/building-a-real time-graph QL-chat-application-with-SMS-notifications/</em></a></p></div></div>    
</body>
</html>