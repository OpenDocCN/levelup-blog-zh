<html>
<head>
<title>JavaScript Best Practices — Exceptions, Loops, and Returns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—异常、循环和返回</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-exceptions-loops-and-returns-a9a5f9946033?source=collection_archive---------10-----------------------#2020-07-01">https://levelup.gitconnected.com/javascript-best-practices-exceptions-loops-and-returns-a9a5f9946033?source=collection_archive---------10-----------------------#2020-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c8aa81476fdcd41cb93d4dc74cf42dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OwPLKefvcXhZL1Y9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@pafuxu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kouji鹤</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="872c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些在编写JavaScript代码时应该遵循的最佳实践。</p><h1 id="136d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正则表达式中没有多个空格</h1><p id="d02d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正则表达式中不应该有多个空格。</p><p id="1093" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="596b" class="mq lf it mm b gy mr ms l mt mu">const regex = /foo  bar/;</span></pre><p id="5bff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0e58" class="mq lf it mm b gy mr ms l mt mu">const regexp = /foo bar/;</span></pre><h1 id="6f20" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">return语句中的赋值必须用括号括起来</h1><p id="46b9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该用括号将<code class="fe mv mw mx mm b">return</code>语句括起来，这样我们就可以确定赋值是在返回值之前完成的。</p><p id="bebc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="369e" class="mq lf it mm b gy mr ms l mt mu">function add (a, b) {<br/>  return result = a + b;<br/>}</span></pre><p id="1db8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a004" class="mq lf it mm b gy mr ms l mt mu">function add (a, b) {<br/>  return (result = a + b);<br/>}</span></pre><h1 id="10e2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要给变量本身赋值</h1><p id="0dc2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">给变量赋值是一个无用的语句，所以我们不应该写它。</p><p id="907f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cb03" class="mq lf it mm b gy mr ms l mt mu">num = num;</span></pre><h1 id="ef7a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要拿一个变量和它本身做比较</h1><p id="88d0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">既然一个变量和它自己比永远是<code class="fe mv mw mx mm b">true</code>，那么让一个变量和它自己比是没有用的。</p><p id="0b42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4cd0" class="mq lf it mm b gy mr ms l mt mu">if (score === score) {}</span></pre><h1 id="6c76" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用逗号运算符</h1><p id="8a17" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">逗号操作符总是返回序列中的最后一个表达式，所以它是非常无用的。</p><p id="f2bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该有这样的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="99d3" class="mq lf it mm b gy mr ms l mt mu">const foo = (doSomething(), !!test);</span></pre><h1 id="b304" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要将事物分配给受限的名称</h1><p id="abd8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该用受限的名字创建变量并给它们赋值。</p><p id="2765" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它不起作用，只会引起混乱。</p><p id="b8f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该有这样的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d2e5" class="mq lf it mm b gy mr ms l mt mu">let undefined = 'value';</span></pre><h1 id="66c4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有稀疏数组</h1><p id="4121" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以拥有在偶数槽中没有条目的数组。</p><p id="ba8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要做到这一点，我们只需写逗号，中间不加任何东西来创建稀疏数组。</p><p id="35c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这很容易被误认为是一个错别字，或者说这是一个错别字。</p><p id="0156" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该有那样的表达。</p><p id="e06e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4af7" class="mq lf it mm b gy mr ms l mt mu">let fruits = ['banana',, 'grape'];</span></pre><h1 id="e3a5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有标签</h1><p id="43dd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">制表符会导致不同文本编辑器出现问题。</p><p id="9876" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标签之间的间距不一致，</p><p id="f8fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该使用它们。</p><p id="fdec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们使用2个空格或将制表符自动转换为2个空格进行缩进。</p><h1 id="8c8b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">常规字符串应该包含模板文字占位符</h1><p id="ac15" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">模板字符串和常规字符串很容易被混淆，因为它们使用相似的字符作为分隔符。</p><p id="9d56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能在常规字符串中使用模板文字占位符。</p><p id="35e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该有这样的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4cb6" class="mq lf it mm b gy mr ms l mt mu">const greeting = 'hi  ${name}';</span></pre><p id="0df1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="be5d" class="mq lf it mm b gy mr ms l mt mu">const greeting = `hi  ${name}`;</span></pre><p id="eaf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模板字符串用反斜杠而不是单引号分隔。</p><h1 id="e6f9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在此之前必须调用super</h1><p id="8c3f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在类构造函数中，我们必须在<code class="fe mv mw mx mm b">this</code>之前调用<code class="fe mv mw mx mm b">super</code>。</p><p id="248a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们会得到一个错误。</p><p id="2823" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，与其写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c34d" class="mq lf it mm b gy mr ms l mt mu">class Dog extends Animal {<br/>  constructor () {<br/>    this.breed = 'chow chow';<br/>    super();<br/>  }<br/>}</span></pre><p id="3e6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b1b9" class="mq lf it mm b gy mr ms l mt mu">class Dog extends Animal {<br/>  constructor () {<br/>    super();<br/>    this.breed = 'chow chow';<br/>  }<br/>}</span></pre><h1 id="648e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">总是抛出错误实例</h1><p id="fd34" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">一个<code class="fe mv mw mx mm b">Error</code>实例包含有用的信息，比如堆栈跟踪和错误所在的行号。</p><p id="0148" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该总是抛出<code class="fe mv mw mx mm b">Error</code>实例，而不是其他值。</p><p id="2b1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9014" class="mq lf it mm b gy mr ms l mt mu">throw 'error';</span></pre><p id="4af5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2884" class="mq lf it mm b gy mr ms l mt mu">throw new Error('error');</span></pre><h1 id="64c8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">空白不应该出现在行尾</h1><p id="b878" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">空白不应该出现在行尾。</p><p id="d1d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们做的不多。所以我们应该移除它们。</p><h1 id="17b1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要初始化为未定义</h1><p id="29e0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该将变量初始化为<code class="fe mv mw mx mm b">undefined</code>。</p><p id="090b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们在没有值的情况下声明它们时，变量已经是<code class="fe mv mw mx mm b">undefined</code>了。</p><p id="60d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不需要显式地将它设置为<code class="fe mv mw mx mm b">undefined</code>。</p><p id="7c89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b360" class="mq lf it mm b gy mr ms l mt mu">let name = undefined;</span></pre><p id="d218" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d640" class="mq lf it mm b gy mr ms l mt mu">let name;</span></pre><h1 id="d860" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有未修改的循环条件</h1><p id="1bfe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们忘记更新条件，那么我们可能会得到一个无限循环。</p><p id="26b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该记住在每次迭代中修改条件。</p><p id="c5ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5384" class="mq lf it mm b gy mr ms l mt mu">for (let i = 0; i &lt; arr.length; j++) {...}</span></pre><p id="7f8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0b37" class="mq lf it mm b gy mr ms l mt mu">for (let i = 0; i &lt; arr.length; i++) {...}</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/23cc9597b4a24dab8b7134a4f9e2fd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_XdQO363cGffLuSy"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@mbenna?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·本纳</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="f983" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9c17" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该有条件不更新的循环。</p><p id="5a50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不应该在代码中有无用的空格。</p><p id="1407" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">抛出<code class="fe mv mw mx mm b">Error</code>实例比抛出其他值更好，因为它提供了更多的信息。</p></div></div>    
</body>
</html>