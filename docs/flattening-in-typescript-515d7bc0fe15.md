# 打字稿中的扁平化

> 原文：<https://levelup.gitconnected.com/flattening-in-typescript-515d7bc0fe15>

TypeScript 的类型系统使得使用递归和嵌套类型成为可能。在某些情况下，软件开发人员可以用嵌套值来简化类型，以获得简单性；例如，将二维数组展平为一维数组时。本文概述了与扁平化相关的*范畴理论*的相关部分，并展示了示例性实现。

![](img/4d33125637527a3d49816b5e00df7a75.png)

由 [CHUTTERSNAP](https://unsplash.com/@chuttersnap?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 范畴理论

范畴理论提出了一个单子的构造，单子是一个值容器，充当操纵适用值的代理。在函数式编程中，单子充当用于在计算管道中保存值的基本结构。最流行的(根据我目前的经验)包括`Option`、`Either`、`Task`、`Array`、`Set`和`Map`单子。

传统上，单子需要两个函数才能存在:

*   一个单子构造函数(称为`of`或`wrap`)，它接受单个参数并产生一个包含传递值的单子，
*   一个一元组合子(称为`bind`、`chain`或`flatMap`)，一个一元作为第一个参数，另一个一元构造函数(具有非平凡逻辑)作为第二个参数；组合子将一元值传递给前面提到的构造函数，并返回新创建的一元值。

在 TypeScript 中，人们可以将`ReadonlyArray<T>`视为一个单子，因为它包含一个值集合并公开以下方法:

*   `Array.prototype.of`、`Array.prototype.from`、`Array.prototype.constructor`，在某些情况下，可以分别作为一元构造函数，
*   `Array.prototype.flatMap`，充当一元组合子。

一元组合子的存在间接暗示了一元的一元(*嵌套一元*)的行为就像*简单一元*。在一元世界中，开发人员应该将数组中的数组视为一维数组，除非另有说明。大多数专业人士都知道"*将嵌套结构简化为简化的对应结构*"称为*扁平化*，本文将深入解释如何高效地编写扁平化代码。

# 打字稿中的单子

TypeScript 的类型系统允许开发人员轻松创建一元类型。这种类型必须包含一个(或多个)值，最好还包含一个区分类型的属性，以区别于其他单子。我在下面提供了一个`Option<T>`单子的基本实现:

我选择了`type`作为`Option`类型的鉴别器属性；它可以接受`someOptionSymbol`或`noneOptionSymbol`作为值。我更喜欢一个符号而不是一个属性值，而是一个属性本身(因为它在迭代对象属性时有优先处理权)，但是从 TypeScript 4.2 开始，有区别的联合仍然不能处理符号键属性。符号的使用减少了来自不受`Option`机制管理的代码的可能的结构注入。

# 链接

软件开发人员可能会在管道中使用一元组合符(*链接*)来在嵌套一元出现问题之前绕过它们。如果应用的顺序正确，组合子应该将嵌套限制在第一级复杂度(简单单子)，而不是允许创建嵌套单子。在某种程度上，人们可以把这样一个函数看作是*映射和展平*的组合，因此有些人把它命名为`flatMap`。

名为`chainOption`的一元组合器使用*部分应用程序设计模式*。非平凡的单子构造函数`ctor`作为第一个部分应用的参数，`option`单子作为第二个。最终，功能的实现归结为 3 行有效代码，如下所示:

我提供了一个如何在实践中使用`chainOption`的例子。`multiplyByTen`函数是一个部分应用的`chainOption`实例，它提供了数字单子内的映射操作(我建议读者检查一下给出的签名)。下面的代码片段展示了如何应用`multiplyByTen`两次来产生一个简单的数字单子:

# 嵌套展平

人们可以通过提取一个单子的值，将一个单子(或者换句话说，二级嵌套单子)转换成一个简单单子。基本展平的实现在很大程度上取决于所讨论的单子类型。我为`Option<T>`单子创建了一个例子，如下所示:

可以根据需要在管道中多次应用基本展平，以实现所需的嵌套级别。下面的例子展示了如何将一个`nestedOption`(第三层嵌套单子)展平为一个简单单子。这种解决方案适用于低级嵌套单子，因为增加几层扁平化不会让开发人员筋疲力尽。

# 显式展平

数组对象的原型包含一个有趣的方法，叫做`flat`。它的用户可以定义应用于所讨论的数组的扁平化深度，从而减少单次调用的最终扁平化调用的数量。我非常仔细地阅读了该方法的类型定义，这启发我想出一种方法将它们移植到一元世界中。

我想从创建一个描述任何级别的嵌套单子的类型开始。下面可用的`NestedOption<T, L extends number>` ( *L* like level)的示例性实现利用了对于`L > 1` a `NestedOption<T, L>`等于`Option<NestedOption<T, L-1>>`的定律。我建议读者做一个思维实验，看看 TypeScript 编译器如何将`NestedOption<string, 5>`解析成最终类型。

定义了`NestedOption`类型后，我终于可以引入`flattenNestedOption`，如下图所示。不幸的是，由于类型的复杂性和 TypeScript 的限制，我需要使用`@ts-ignore`来隐藏类型差异。如果读者找到了解决这个问题的方法，请在评论区写下评论。

应用`flattenNestedOption`函数可以归结为计算嵌套的级别，并使用嵌套的单子调用函数，如下例所示。拥有一个在运行时计算嵌套级别的函数将是最大的改进。我将让读者来思考如何恰当地实现这样的挑战。

# 摘要

范畴理论引入了单子的概念，允许开发者抽象出一些值的操作。在某些情况下，递归和嵌套类型可能遵循一元的定义，因此开发人员在处理这类类型时可以利用一元法则。由上述法则管理的扁平化是将数学概念应用到软件开发中的一个典型例子。

# 分级编码

感谢您成为我们社区的一员！[订阅我们的 YouTube 频道](https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1)或者加入 [**Skilled.dev 编码面试课程**](https://skilled.dev/) 。

[](https://skilled.dev) [## 编写面试问题+获得开发工作

### 掌握编码面试的过程

技术开发](https://skilled.dev)