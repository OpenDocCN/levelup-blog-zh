<html>
<head>
<title>Getting Started with TDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TDD入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-tdd-69a67b610a49?source=collection_archive---------18-----------------------#2020-01-29">https://levelup.gitconnected.com/getting-started-with-tdd-69a67b610a49?source=collection_archive---------18-----------------------#2020-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/447ef864bbf895313f73448409bfa6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pk7TefrxFkVCJB6D"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7655" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几个月来，我一直对测试驱动开发(TDD)感兴趣。我读了几篇文章，但不能真正理解其中的概念。</p><p id="e2ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本月早些时候，我看了一段视频，视频中T4的罗伯特·马丁正在做TDD的现场演示。我对TDD如何激怒200多名观众感到震惊。；)</p><p id="dfa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但最重要的是，我也对它的简单性和快速获得结果的速度印象深刻。</p><p id="2925" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">初学者总是一需要编码就奔向键盘，而不是花时间去思考问题本身，边缘情况或复杂性…随着你作为一名开发人员的成长，你会学会与这种情况作斗争。</p><p id="1871" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是TDD似乎并不关心这个。使用TDD，你有一个问题，你从写一个测试开始。然后你写代码…然后你写测试…如此周而复始，直到你解决问题。</p><p id="f30d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是基本的TTD规则:</p><ul class=""><li id="1579" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">只编写足够测试失败的测试代码</li><li id="c598" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">只有在测试失败的情况下才编写产品代码</li><li id="6ba5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">只编写足够通过测试的生产代码</li></ul><p id="ae44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近我不得不写一个简单的Python函数，并决定尝试使用TDD。</p><p id="8b5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题:给定两个字符(一个移动的和一个固定的)和一个数字，得到所有可能的字符串。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0ca5" class="ly lz iq lu b gy ma mb l mc md"># Given a moving char, a fixed char, and a number, generate all possible strings<br/>#With: A, n, 4 We will have Annn, nAnn, nnAn,nnnA<br/>#With: 0, 1, 5 We will have 01111, 10111, 11011, 11101, 11110</span></pre><p id="aa36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们开始吧！</p><p id="40b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第一步</strong>。写一个测试，期待一个结果。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="5a47" class="ly lz iq lu b gy ma mb l mc md">AllPatterns('A', 'n', 4) #Should return ["Annn"]</span></pre><p id="f540" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后执行，您会得到一个不错的错误:<strong class="kf ir">名称‘all patterns’没有定义</strong></p><p id="e6fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第二步</strong>。编写最小<em class="me">代码</em>以通过测试</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a52d" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    return ["Annn"]</span></pre><p id="f38f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">最小代码</strong> …</p><p id="d163" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您刚刚修复了刚刚编写的测试的问题。毫无疑问。</p><p id="a060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个重要步骤:<strong class="kf ir">重构</strong>。如何重构代码以使其可读性、可维护性和整洁性？</p><p id="3d87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一步中，代码非常干净，所以让我们进入第二个测试。</p><p id="87a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤1a </strong>。写一个测试，期待一个结果。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="34f6" class="ly lz iq lu b gy ma mb l mc md">AllPatterns('A', 'n', 4) #Should return ["Annn","nAnn"]</span></pre><p id="e03c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第2a步。编写最小<em class="me">代码</em>以通过测试。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="ef4e" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    return ["Annn","nAnn"]</span></pre><p id="56a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这时，你开始听到有人对你大喊:“给这该死的东西编码！”</p><p id="b509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，神奇的事情发生了:<strong class="kf ir">重构部分</strong>。显然，我不能像这样离开代码。首先，因为我将不得不硬编码所有的解决方案，其次，因为我没有更接近找到算法，因此，没有更接近找到解决方案。</p><p id="f1a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤2a。重构1 </strong>。我需要返回一个数组。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="4b15" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    result = []<br/>    result.append("Annn")<br/>    result.append("nAnn")<br/>    return result</span></pre><p id="c3ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤2a。重构2 </strong>。让我们打破移动的角色和固定的角色。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="862e" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    result = []<br/>    result.append("A" + "nnn")<br/>    result.append("n" + "A" + "nn")<br/>    return result</span></pre><p id="081c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的打印仍然返回正确的值，并且我对算法有了更多的了解。我们继续。</p><p id="5cf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤1b </strong>。写一个测试，期待一个结果。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="27ef" class="ly lz iq lu b gy ma mb l mc md">AllPatterns('A', 'n', 4) #Should return ["Annn","nAnn","nnAn"]</span></pre><p id="6546" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤2b </strong>。编写最小<em class="me">代码</em>以通过测试。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="ebbc" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    result = []<br/>    result.append("A" + "nnn")<br/>    result.append("n" + "A" + "nn")<br/>    result.append("nn" + "A" + "n")<br/>    return result</span></pre><p id="1c4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我可以开始重构，但是我还有一个案例要测试，所以让我们开始吧。</p><p id="6202" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤1c </strong>。写一个测试，期待一个结果。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c313" class="ly lz iq lu b gy ma mb l mc md">AllPatterns('A', 'n', 4) #Should return ["Annn","nAnn","nnAn","nnnA"]</span></pre><p id="5f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤2c </strong>。编写最小<em class="me">代码</em>以通过测试。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="b5db" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    result = []<br/>    result.append("A" + "nnn")<br/>    result.append("n" + "A" + "nn")<br/>    result.append("nn" + "A" + "n")<br/>    result.append("nnn" + "A" + "")<br/>    return result</span></pre><p id="78e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我得到了我的示例代码，所以我们重构。这里有相当多的事情要做。</p><p id="bc7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤2c。重构1 </strong>。对齐代码以查看模式。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0af5" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    result = []<br/>    result.append(""    + "A" + "nnn")<br/>    result.append("n"   + "A" + "nn" )<br/>    result.append("nn"  + "A" + "n"  )<br/>    result.append("nnn" + "A" + ""   )<br/>    return result</span></pre><p id="8702" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤2c。重构2 </strong>。替换固定部分的字符重复。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="e7c7" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    result = []<br/>    result.append("".join("n" for i in range(0)) + "A" + "".join("n" for i in range(3)) )<br/>    result.append("".join("n" for i in range(1)) + "A" + "".join("n" for i in range(2)) )<br/>    result.append("".join("n" for i in range(2)) + "A" + "".join("n" for i in range(1)) )<br/>    result.append("".join("n" for i in range(3)) + "A" + "".join("n" for i in range(0)) )<br/>    return result</span></pre><p id="5da5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤2c。重构3 </strong>。看到循环，编码。；)</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="31c8" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    result = []<br/>    for i in range(4):<br/>        result.append("".join("n" for i in range(i)) + "A" + "".join("n" for i in range(4-1-i)) )<br/>    return result</span></pre><p id="f4b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">步骤2c。重构4 </strong>。把变量换成参数就行了。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c1c0" class="ly lz iq lu b gy ma mb l mc md">def AllPatterns(movingChar, fixedChar, length):<br/>    result = []<br/>    for i in range(length):<br/>        result.append("".join(fixedChar for i in range(i)) + movingChar + "".join(fixedChar for i in range(length-1-i)) )<br/>    return result</span></pre><p id="47db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="me">等着瞧</em>！只需几个步骤，您就可以得到一个漂亮的小函数。；)</p><p id="5bba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道这是一个基本功能，大多数开发人员第一次就能做好。但是使用TDD，就像使用任何其他技能一样，您需要从小处着手，然后朝着更大的目标前进。</p><p id="0814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从那以后，我曾多次尝试TDD，并发现每次都很有收获。我仍然不能在完整的项目或非常相关的代码上做到这一点，但我会尝试在简单的功能上做到这一点。就像我说的，你需要从小处着手，一步一步来。</p><p id="b55e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Github: <a class="ae kc" href="https://github.com/satan87/Medium/blob/master/TDD%20-%20Moving%20Character.ipynb" rel="noopener ugc nofollow" target="_blank">链接</a></p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><div class="lp lq lr ls gt mm"><a href="https://medium.com/swlh/tdd-and-randomness-b0ad8a5f5ae6" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">TDD和随机性</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">如何TDD随机行为？</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jw mm"/></div></div></a></div></div></div>    
</body>
</html>