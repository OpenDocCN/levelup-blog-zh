<html>
<head>
<title>Scala Journals — What’s Functional Programming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala期刊——什么是函数式编程？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-part-1-whats-functional-programming-d6300979bae6?source=collection_archive---------0-----------------------#2019-07-19">https://levelup.gitconnected.com/scala-journals-part-1-whats-functional-programming-d6300979bae6?source=collection_archive---------0-----------------------#2019-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c8ba9f6a8093c2b77f3305dabdb25554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHWz_psgHQyNOL3ecS9TBQ.jpeg"/></div></div></figure><p id="3efd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个程序员迟早都会遇到函数式编程范式。我们中的一些人开始使用它，一些人只是听说过它，一些人甚至尝试过它，不禁想知道——为什么它现在被如此炒作？开始的时候我自己也在想这个。</p><p id="b57a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数式编程一开始可能没什么意义——事实上，在某种程度上，它甚至会让你觉得它违背了你以前所学的东西。如果你和我刚开始学习数学的时候一样，你可能会有一个普遍的误解，认为你首先需要非常了解数学，或者认为函数范式是解决任何编程问题的灵丹妙药。</p><p id="1eb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将尝试指出一些基础知识，让你理解函数式编程到底是什么，它不是什么，它基于什么，为什么人们在上下文中如此多地提到数学，为什么你可能听说它很难，以及为什么这些天它到处都是新闻。请耐心听我说，我会试着回答所有这些问题。</p><h2 id="71f3" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">都是数学，对吧？</h2><p id="137a" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这个问题很简短的回答就是:<strong class="kd iu">否</strong>。</p><p id="b7ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对这个问题的一个稍微长一点的回答是:它比命令式语言更接近数学，但这并不意味着你需要对数学了如指掌才能编写函数式代码。了解数学的某些分支会有帮助吗？是的。很关键吗？号码</p><p id="e73e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想想一个建筑工人。是否要求他们学习建筑和土木工程的基础知识？不会。这是否有助于他们理解为什么某些任务必须以某种方式完成，尽管这看起来有些矫枉过正？很有可能是的。</p><p id="9338" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个问题的一个很长的答案是:函数式编程基于一个叫做<em class="lx">范畴理论</em>的数学分支。在<strong class="kd iu">大规模</strong>过度简化范畴理论是数学的一个分支，它推理类别和它们之间的关系，而不是关注类别中的对象，例如，范畴理论将负数推理为抽象概念，而不是关注像-2或-23这样的文字值。有点像鸟瞰图，你看不到细节，但看到图案。</p><p id="e697" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不打算深入探讨，因为这很容易成为一个单独的博客的主题——但是让我们同意，从范畴理论中主要学到的应该是<strong class="kd iu">可组合性</strong>——将较小的功能<strong class="kd iu"> * </strong>组装成较大的功能。这在函数式编程中随处可见。我们来稍微说一下:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/e3a88d188805edc7c42c326f661b02b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*3bDG_qsjCL3anp2P.png"/></div></figure><p id="55f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑到上图——如果<code class="fe md me mf mg b">f</code>是一个从<code class="fe md me mf mg b">A</code>到<code class="fe md me mf mg b">B</code>的函数，而<code class="fe md me mf mg b">g</code>是一个从<code class="fe md me mf mg b">B</code>到<code class="fe md me mf mg b">C</code>的函数，那么一定有一个像<code class="fe md me mf mg b">g o f</code>(f之后的g)这样的从<code class="fe md me mf mg b">A</code>到<code class="fe md me mf mg b">C</code>的组合。来吧——不要只是浏览我写在这里的东西——读一读！</p><p id="87c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用Scala术语来说(这是一种非常麻烦的获取数字长度的方法，显示了可组合性):</p><pre class="lz ma mb mc gt mh mg mi mj aw mk bi"><span id="8613" class="kz la it mg b gy ml mm l mn mo">val A = List(1, 11, 111) <br/>def f: Int =&gt; String = _.toString  <br/>def g: String =&gt; Int = _.length </span><span id="624f" class="kz la it mg b gy mp mm l mn mo">// g and f composed  A.map(gof) // List(1, 2, 3)<br/>)def gof: Int =&gt; Int = g compose f</span></pre><p id="1671" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们重写上面的语句来匹配我们的Scala示例:</p><p id="7202" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果<code class="fe md me mf mg b">f</code>是一个从<code class="fe md me mf mg b">Int</code>到<code class="fe md me mf mg b">String</code>的函数，而<code class="fe md me mf mg b">g</code>是一个从<code class="fe md me mf mg b">String</code>到<code class="fe md me mf mg b">Int</code>的函数，那么一定有一个类似于<code class="fe md me mf mg b">g o f</code>(f之后的g)的组合，它从<code class="fe md me mf mg b">Int</code>到<code class="fe md me mf mg b">Int</code>。</p><p id="39fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想象可组合性的另一种方式是shell命令的管道(下面的例子实际上已经类似于一个真实的程序流)。下面的每个函数都可以由更小的函数组成:</p><pre class="lz ma mb mc gt mh mg mi mj aw mk bi"><span id="dfe3" class="kz la it mg b gy ml mm l mn mo">get_data_command | verify_data_command | process_data_command &gt; output.data.file</span></pre><h1 id="a182" class="mq la it bd lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd ne nf lq ng bi translated">那么什么是函数式编程呢？</h1><p id="27d8" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">当我想到函数式编程时，我会想到代数T21——你评估函数并组合它们，直到你得到你需要的。你远离副作用，不变异数据。由于没有突变和副作用，结果总是确定的。如果结果总是确定的，就没有必要担心隐藏状态的变化。如果你不必担心隐藏状态的改变，那么你可以并行执行。如果你能并行执行，那就意味着多线程的快乐时光。这也意味着拥有多核CPU和/或分布式执行我们的计算的美好时光——如今这几乎已经成为一种标准。</p><p id="6748" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们理解<strong class="kd iu">代数</strong>部分——我相信这是为什么数学在函数式编程中被经常提及的原因之一。</p><p id="ce54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回想以前在数学课上做代数时，很明显<code class="fe md me mf mg b">z</code>总是会计算为<code class="fe md me mf mg b">8</code>:</p><pre class="lz ma mb mc gt mh mg mi mj aw mk bi"><span id="8b5d" class="kz la it mg b gy ml mm l mn mo">x = 5<br/>y = 3<br/>z = x + z</span></pre><p id="810d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">变异是不允许的，所以想象一下你的老师会怎么说:</p><pre class="lz ma mb mc gt mh mg mi mj aw mk bi"><span id="0ab4" class="kz la it mg b gy ml mm l mn mo">x = 5<br/>x = 3<br/>y = 3<br/>z = x + z</span></pre><p id="7ae3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…这是不是有点像命令式的方式？</p><pre class="lz ma mb mc gt mh mg mi mj aw mk bi"><span id="7d3a" class="kz la it mg b gy ml mm l mn mo">var number = 5 <br/>number = 3 <br/>var number2 = 3 <br/>println(number + number2) // 6</span></pre><p id="f997" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，上面这个带有变异的<code class="fe md me mf mg b">number</code>的例子看起来并不像是世界末日，但是试着想象一下，如果<code class="fe md me mf mg b">number = 3</code>实际上被另一个函数调用，可能是在另一个线程上，会发生什么。这个功能需要时间。我们的结果实际上不是<code class="fe md me mf mg b">6</code>，而是<code class="fe md me mf mg b">8</code>，即使一旦代码被执行<code class="fe md me mf mg b">number</code>将会是<code class="fe md me mf mg b">3</code>。现在来看一下，想象一下<code class="fe md me mf mg b">number</code>和<code class="fe md me mf mg b">number2</code>不是整数，而是更新客户数据的实际对象…</p><p id="6d91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数式编程远离可变性以避免这些问题(从现在开始所有的例子都在Scala中):</p><pre class="lz ma mb mc gt mh mg mi mj aw mk bi"><span id="d108" class="kz la it mg b gy ml mm l mn mo">val number = 3 // val is immutable <br/>number = 5 // error: reassignment to val</span></pre><p id="a10c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果你不能改变任何东西，那你怎么编程呢？</p><p id="361e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是将<strong class="kd iu">纯函数</strong>带到桌面上的好时机。纯函数是没有副作用的函数。一个纯函数接受一个输入值，在不修改它的情况下做一些计算并返回一些新的东西。纯函数是可组合的、确定的，没有副作用，因此可以并行化，这又回到了我之前的观点。</p><p id="f861" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有两条经验法则可以帮助你永远不要进行变异和升级:</p><ul class=""><li id="af2d" class="nh ni it kd b ke kf ki kj km nj kq nk ku nl ky nm nn no np bi translated">复制时更新</li><li id="9009" class="nh ni it kd b ke nq ki nr km ns kq nt ku nu ky nm nn no np bi translated">只使用val，不要使用var</li></ul><p id="0be7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这在Scala的case类中表现得最好。</p><pre class="lz ma mb mc gt mh mg mi mj aw mk bi"><span id="9aeb" class="kz la it mg b gy ml mm l mn mo">case class User(id: String, name: String) </span><span id="5d85" class="kz la it mg b gy mp mm l mn mo">val user = User("123", "annette") </span><span id="0e19" class="kz la it mg b gy mp mm l mn mo">// pure function, update as you copy: <br/>def updateUser(user: User, newName: String) = <br/>    user.copy(name = newName)  </span><span id="557b" class="kz la it mg b gy mp mm l mn mo">val newUser = updateUser(user, "john")</span><span id="8429" class="kz la it mg b gy mp mm l mn mo">// User(123,john)<br/>println(newUser)</span></pre><p id="5065" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于case类在默认情况下是不可变的，所以甚至不可能编写一个不纯的更新函数来编译。</p><p id="d6fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果你不能变异，那么for循环呢？</p><p id="f19b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">说到Scala，真正的答案是，这取决于你想成为一个多么纯粹的函数主义者。我已经可以想象在局部未公开函数中使用可变数据的话题，以及这是否是一个坏习惯的巨大争论。就我自己而言，我更喜欢坚持不可变性，这意味着我不使用for循环，而是映射或使用递归——这使我的代码很好，很纯粹，感觉很一致。此外，看到完美的递归函数通过所有测试用例也是一件非常令人满意的事情…</p><p id="8752" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果一切都是纯粹的、不变的，你如何设计你的程序？</p><p id="5aea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常重要的问题，我被这个问题困扰了很长一段时间，因为存在明显的差异，但显然没有金科玉律。有关于这个主题的书籍，但是我注意到的一般经验法则是尽可能地将数据和函数分开。想想我上面展示的构图图像。它可能看起来像这样:</p><pre class="lz ma mb mc gt mh mg mi mj aw mk bi"><span id="f6e6" class="kz la it mg b gy ml mm l mn mo">case class A // only data <br/>case class B // only data <br/>case class C // only data  </span><span id="de01" class="kz la it mg b gy mp mm l mn mo">def f: A =&gt; B = ??? // only function <br/>def g: B =&gt; C = ??? // only function <br/>def gof: A =&gt; C = ??? // only function</span></pre><h1 id="aedb" class="mq la it bd lb mr ms mt le mu mv mw lh mx my mz lk na nb nc ln nd ne nf lq ng bi translated">摘要</h1><p id="92f6" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">有了以上所有的信息，让我们试着和我在文章开头提到的一些误解作斗争。</p><p id="04a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">误区一:</strong> <strong class="kd iu">函数式编程讲的都是数学。</strong></p><p id="20d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看你想挖多深了。它来源于范畴理论，但是学习函数式编程根本不需要成为数学大师。只要你懂代数:)</p><p id="2b3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">误解2:函数式编程是银弹。</p><p id="3f87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编程没有灵丹妙药。函数式编程就像任何其他范式一样，只是你工具箱中的一个工具——它不会是所有任务的最佳选择。当然你可以用撬棍敲钉子，但是其他工具可能更合适。</p><p id="5ffd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">误解3:函数式编程很难。</strong></p><p id="0460" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一种不同的思维方式，使它看起来更复杂。这显然不是一条规则，但我个人发现，有时在函数式编程中，被认为非常简单的事情(命令式方法)往往看起来有点复杂或麻烦。这完全是一个实践的问题，随着时间的推移，你会“重新连接”你的思维方式。但是，即使一旦你的大脑重新布线，我可以保证学习将永远不会停止，无论是功能或任何其他范式！</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="a491" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="lx"> * </em> </strong> <em class="lx">我故意跳过正确的范畴理论术语，以免混淆。澄清一下:正确的术语是“态射”，而不是“函数”。</em></p><p id="03f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参考资料:B. Milewski的<br/> <em class="lx">程序员范畴理论</em>t . Leinster的<br/> <em class="lx">基础范畴理论</em><br/>t . Alexander的<em class="lx"> Scala食谱</em></p><p id="8b22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">演职员表:<br/> <a class="ae oc" href="https://www.linkedin.com/in/malgorzata-bagnicka/" rel="noopener ugc nofollow" target="_blank"> M .巴格妮卡</a>——感谢你帮我润色我的建造者类比:)</p></div></div>    
</body>
</html>