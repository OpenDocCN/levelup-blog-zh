<html>
<head>
<title>Data structures: heaps and how to implement them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构:堆以及如何实现它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/data-structures-heaps-and-how-to-implement-them-f7c3a0479f82?source=collection_archive---------25-----------------------#2022-06-19">https://levelup.gitconnected.com/data-structures-heaps-and-how-to-implement-them-f7c3a0479f82?source=collection_archive---------25-----------------------#2022-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4141" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文介绍了堆，并展示了如何在C++中实现它们以及它们支持的基本操作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/96f8885f3cedfa1534ff65586046228c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g9CXYemFDsm2-pYV"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">马库斯·斯皮斯克在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="c283" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">动机</h1><p id="1b05" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">堆的目标是以优化以下操作的方式存储有序类型的元素:</p><ul class=""><li id="4c5c" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">访问并移除最小元素；</li><li id="6780" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">插入新元素；</li><li id="033c" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">移除元素。</li></ul><p id="8f0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多经典算法可以使用堆来实现，比如Dijkstra的最短路径算法和Huffman代码。</p><h1 id="ee66" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结构实现</h1><p id="a5e7" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们将堆实现为<em class="mt">近乎完整的二叉树</em>。非正式地(我们将满足于一个非正式的定义)，如果每一个深度级别都被完全填充，一个二叉树被称为<em class="mt">接近完全</em>，除了最底层，所有的节点都被分组在左边。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/49af6e3a61a7562fd7281dcb0df0192a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W05mHYOK2cnwhgUgRYjdug.png"/></div></div></figure><p id="3ed2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，紫色的树和蓝色的树都接近完成(紫色的树甚至<em class="mt">完成</em>！)但是橘子树和红树不是。因为倒数第二层没有填满，所以桔子树还没有完成。因为最后一级的节点没有被分组到左边，所以红树还没有接近完成。</p><p id="8d31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几乎完全二叉树的一个优点是，它们的特点是节点排序良好、实用且易于存储。更准确地说，每一棵近乎完整的二叉树都可以表示为一个节点数组，其中包含了该树的所有信息。这种数组是通过从上到下、从左到右一个接一个地追加所有节点来构建的。这是一个近乎完整的二叉树及其数组表示的例子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/116a54f0fb1d347b02064afd85fb6bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lAC5gPX0BzPeq_Dgh02zjw.png"/></div></div></figure><p id="925a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，数组的索引集从1开始。我们稍后会看到为什么这很重要。</p><p id="eb42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用近乎完整的二叉树的数组表示和节点数量，我们可以检查索引<em class="mt"> i </em>处的节点是否有父节点、左子节点和右子节点，如果有，则找到其索引。所有这些都需要持续的时间。</p><p id="74f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们想找到某个节点<em class="mt"> N </em>的左子节点，也就是深度<em class="mt"> d </em>的第<em class="mt"> i </em>个节点(从左到右编号)，假设它存在。我们首先计算节点在数组中的位置:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/c0894c18c7bd0c1deaec93c5ffd2172a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vx3pG5jEdEyC_v_KAVbLbA.png"/></div></div></figure><p id="c2c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要遍历数组的所有元素，直到找到<em class="mt"> N </em>的左子元素。首先，我们消耗n右边的节点:有(2^d)-i节点。因为N有一个左孩子，根据几乎完全二叉树的定义，我们知道N左边的每个节点(总共i-1个节点)都有两个孩子。因此，我们必须经过2(i-1)个额外的节点。n的左孩子位于下一个索引，即索引i+(2^d)-1+(2^d)-i+2(i-1)+1 = 2 *(2^d+i-1).</p><p id="2291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之，我们可以说，如果<em class="mt"> N </em>位于索引<em class="mt"> k </em>处，并且树中有<em class="mt"> n </em>个节点，则:</p><ul class=""><li id="f5e9" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">如果2 <em class="mt"> k </em> ≤ n，那么<em class="mt"> N </em>有一个左子，它位于索引2<em class="mt">k</em>；</li><li id="1428" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">否则，<em class="mt"> N </em>没有左子。</li></ul><p id="dcd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该属性使得能够找到第<em class="mt"> k </em>个节点的右子节点和父节点的索引:</p><ul class=""><li id="53cd" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">如果2 <em class="mt"> k </em> + 1 ≤ <em class="mt"> n </em>那么<em class="mt"> N </em>有一个右子，在索引2<em class="mt">k</em>+1；</li><li id="46d1" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果2 <em class="mt"> k </em> + 1 &gt; n那么它没有右子；</li><li id="ea78" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果<em class="mt"> k </em> = 1那么它没有双亲(显然！) ;</li><li id="2373" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果<em class="mt"> k </em></li></ul><p id="3597" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">近完全二叉树的另一个优点是，其高度的增长速度与其大小的对数一样快，即<em class="mt">h</em>=θ(<em class="mt">n</em>)，其中<em class="mt"> h </em>是高度，<em class="mt"> n </em>是节点数。</p><p id="56af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这一点，我们可以定义一个结构<em class="mt"> Heap </em>，它包含一个表示树的向量、一个包含树的大小的整数以及访问给定索引的节点的父节点和子节点的函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cdec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想在堆中存储<code class="fe mx my mz na b">n</code>值，那么数组将至少包含<code class="fe mx my mz na b">n+1</code>个元素:<code class="fe mx my mz na b">array[0]</code>是未使用的，<code class="fe mx my mz na b">array[1]</code>到<code class="fe mx my mz na b">array[n]</code>是接近完整的二叉树的表示。其他元素，<em class="mt"> k </em> &gt; <em class="mt"> n </em>的<code class="fe mx my mz na b">array[k]</code>没有使用。</p><p id="48f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用标准库中的类<code class="fe mx my mz na b">optional</code>来返回父节点或子节点的值(如果存在的话),以及一个指示符(如果存在的话，指示节点<code class="fe mx my mz na b">i</code>没有父节点、没有左子节点或右子节点)。</p><h1 id="f5b9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">查找并删除最小值</h1><p id="5cb3" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了实现一个堆，我们希望我们将要使用的树满足一个额外的属性，我们称之为<em class="mt">堆属性</em>。它声明除了根之外的每个节点<em class="mt"> N </em>的父节点必须小于或等于<em class="mt"> N </em>。换句话说，树必须相对于祖先关系增加<em class="mt">:如果包含<em class="mt"> N </em>的节点是包含<em class="mt"> M </em>的节点的祖先，那么<em class="mt"> N </em> ≤ <em class="mt"> M </em>。</em></p><p id="9e5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据堆属性，节点集的最小元素总是根。这允许我们在常数时间内执行<code class="fe mx my mz na b">min-peek</code>，简单地通过索引访问数组的元素。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们用来删除最小值的算法的粗略描述:</p><ul class=""><li id="e6a0" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">用树中的最后一个元素替换树根；</li><li id="3097" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">当最后一个元素至少有一个子元素并且大于它的一个子元素时，将其与其最小的子元素交换。</li></ul><p id="eb94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了该算法执行过程中堆的配置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/f148e0802627f6077bade36aa521abb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eX-QmwGn0_apYJUhgSqvjQ.png"/></div></div></figure><p id="fe96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法相对于堆的高度以线性时间运行，即相对于堆中元素的数量以对数时间运行。</p><p id="87d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在C++中实现它，我们从定义函数<code class="fe mx my mz na b">rearrangeDown</code>开始，该函数获取一个节点的索引，并在适当的时候将其与其最小的子节点交换(即，如果它还没有小于它的子节点)。它返回输入节点的新位置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mx my mz na b">m</code>表示位置<code class="fe mx my mz na b">i</code>的节点、其左子节点(如果有)及其右子节点(如果有)之间的最小值。</p><p id="740e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果<code class="fe mx my mz na b">i</code>有两个子节点<code class="fe mx my mz na b">X</code>和<code class="fe mx my mz na b">Y</code>，并且根在<code class="fe mx my mz na b">X</code>和<code class="fe mx my mz na b">Y</code>的树都满足堆属性，那么可以证明在执行<code class="fe mx my mz na b">i = rearrangeDown(i)</code>到<code class="fe mx my mz na b">rearrangeDown(i) == i</code>之后根在<code class="fe mx my mz na b">i</code>的树也满足堆属性。</p><p id="a9ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在如下实现<code class="fe mx my mz na b">pop</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="7e2e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">插入元素</h1><p id="332a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">插入和删除非常相似。这一次，我们将使用一个子程序<code class="fe mx my mz na b">rearrangeUp</code>,如果它能够维护堆属性，就将一个节点与其父节点交换。它的实现类似于<code class="fe mx my mz na b">rearrangeDown</code>，除了只有一个值与节点进行比较。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5fff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用这个程序来实现<code class="fe mx my mz na b">insert</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="9596" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">使肥胖</h1><p id="7ebf" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们可以使用<code class="fe mx my mz na b">insert</code>在线性时间内将一个未排序的列表变成一个堆(复杂度可以利用以下事实推导出来:log( <em class="mt"> k </em> ) for <em class="mt"> k </em>范围在1和<em class="mt"> n </em>之间，即log( <em class="mt"> n </em>)！)，<em class="mt"> </em>渐近等价于<em class="mt"> n </em> log( <em class="mt"> n </em>))。但是我们可以做得更好！本节展示了如何实现过程<em class="mt"> heapify </em>，该过程在线性时间内将一个列表变成一个堆(相对于列表的长度)。</p><h2 id="4a21" class="nb ld iq bd le nc nd dn li ne nf dp lm jy ng nh lq kc ni nj lu kg nk nl ly nm bi translated">算法</h2><p id="4ba8" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">先说个例子。考虑下面这个近乎完整的二叉树。树叶显然是成堆的根。如果我们想要填充的链表长度为<em class="mt"> n </em>，那么节点<em class="mt"> k </em>是一个叶子当且仅当2<em class="mt">k</em>T53】T27】n，即当且仅当<em class="mt"> k </em> ≥ <em class="mt"> n </em> /2 + 1(其中<em class="mt"> n </em> /2指欧几里德除法)。</p><p id="e34b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想让每隔一个节点成为一个堆的根。先说3。3小于6，因此(3，6)满足堆属性。</p><p id="5749" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">移动到4楼。4大于它的一个孩子(都是！)，所以我们跟它最小的孩子交换。4现在是叶子，所以确实是堆的根。因为以2为根的树和以1为根的树都是堆，所以更新后的树中以1为根的树也是堆。</p><p id="7c69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要考虑的最后一个节点是5。因为5 &gt; 3 &gt; 1，所以我们用1交换5。5仍然大于它的子代(2和4)；所以我们用2换了5。5现在是一片叶子，整棵树成了一堆。</p><p id="1543" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们按如下方式实现它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0ba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第11行到第15行与<code class="fe mx my mz na b">insert</code>过程中的第9行到第14行完全相同，即它向下重新排列原来在<code class="fe mx my mz na b">i</code>位置的节点，直到<code class="fe mx my mz na b">rearrangeDown</code>不再改变它的位置。</p><h2 id="9f38" class="nb ld iq bd le nc nd dn li ne nf dp lm jy ng nh lq kc ni nj lu kg nk nl ly nm bi translated">分析</h2><p id="2bc4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">第11行到第16行中的子程序运行时间为O(height( <em class="mt"> i </em>))，I的范围为1到n/2。设<em class="mt"> H </em>为堆的高度，即<em class="mt"> H </em> = floor( <em class="mt"> n </em> /2)。对于1和<em class="mt"> H </em>之间的每一个高度<em class="mt"> h </em>(我们不考虑高度为0的节点)，都有高度为<em class="mt"> h </em>的2^{ <em class="mt"> H </em> - <em class="mt"> h </em> }节点。所以<code class="fe mx my mz na b">heapify</code>的复杂度由c(h)= 1≤h≤h的2^{H-h} h之和给出，由于h2^{-h}之和收敛，我们得到C(h) = Theta(2^H)，即c相对于节点数是线性的。</p></div></div>    
</body>
</html>