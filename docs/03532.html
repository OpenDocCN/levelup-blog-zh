<html>
<head>
<title>How to create your custom iterables in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript创建你的自定义iterables</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-your-custom-iterables-in-javascript-6ddaf1b5201b?source=collection_archive---------7-----------------------#2020-05-14">https://levelup.gitconnected.com/how-to-create-your-custom-iterables-in-javascript-6ddaf1b5201b?source=collection_archive---------7-----------------------#2020-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9ca0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ES6最重要的增加之一是iterables。</p><p id="b842" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">iterable是一种特殊的对象，它实现了iterable协议，这意味着它们有一个特殊的属性，带有键[Symbol.iterator]和一个返回迭代器的函数值。</p><p id="1a39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">迭代器是实现迭代器协议的对象。它应该有一个<code class="fe ko kp kq kr b">next()</code>方法，该方法返回一个具有两个属性的对象:</p><ul class=""><li id="4ea1" class="ks kt it js b jt ju jx jy kb ku kf kv kj kw kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">value</code>可以是任何JavaScript值，</li><li id="48af" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">done</code>这是一个布尔值，表示迭代器是否完成了它的序列。</li></ul><p id="1e0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，使用TypeScript接口，可迭代对象和迭代器具有以下签名:</p><pre class="lg lh li lj gt lk kr ll lm aw ln bi"><span id="8cdb" class="lo lp it kr b gy lq lr l ls lt">interface Iterable {<br/>    [Symbol.iterator]() : Iterator;<br/>}<br/>interface Iterator {<br/>    next() : IteratorResult;<br/>    return?(value? : any) : IteratorResult;<br/>}<br/>interface IteratorResult {<br/>    value: any;<br/>    done: boolean;<br/>}</span></pre><p id="cc95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些协议允许我们迭代与我们的对象相关的一组值。</p><p id="fae6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解可迭代的一个很好的比喻是，如果我们把可迭代的物理对象当成一本书。在这种情况下，迭代器将是书签，它保存了我们在迭代过程中所处位置的引用。下一个方法实际上是过渡到下一个迭代，在这种情况下是翻页。</p><figure class="lg lh li lj gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/cccb07188592fc968d3b32215f779a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTTS99TRqZf-jj793x-BcQ.jpeg"/></div></div></figure><p id="c83b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在ES6中，许多内置类型都有迭代器属性。例如:</p><ul class=""><li id="7ac8" class="ks kt it js b jt ju jx jy kb ku kf kv kj kw kn kx ky kz la bi translated">用线串</li><li id="e48b" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">数组</li><li id="5d03" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">地图</li><li id="8933" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">设置</li><li id="e5b1" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">节点列表</li><li id="76ce" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">还有那个<code class="fe ko kp kq kr b">argument</code>物体</li></ul><p id="f9b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">都是可重复的。</p><p id="484a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以用for…of循环遍历它们，使用spread操作符，或者使用析构赋值。</p><blockquote class="mc md me"><p id="3472" class="jq jr mf js b jt ju jv jw jx jy jz ka mg kc kd ke mh kg kh ki mi kk kl km kn im bi translated">我们可以用生成器函数创建迭代器，但我们不会在这里使用它们，我们将只关注迭代器协议。</p></blockquote></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="4099" class="lo lp it bd mq mr ms dn mt mu mv dp mw kb mx my mz kf na nb nc kj nd ne nf ng bi translated">简单的迭代器函数示例</h2><p id="6c0e" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">默认情况下，字符串是可迭代的，但是我们可以简单地通过在[Symbol.iterator]属性上添加我们自己的迭代器函数来覆盖默认的字符串迭代器。假设我们想要向后遍历字符串的字符:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8dce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我们必须使用字符串构造函数来避免自动装箱。此外，我们必须在下一个方法中使用箭头函数来保持<code class="fe ko kp kq kr b">this</code>引用我们的字符串对象。</p><p id="d0c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用封闭的<code class="fe ko kp kq kr b">i</code>变量作为迭代器状态，并从末尾到第一个字符返回字符串的字符。一旦我们到达那里，我们返回我们的IteratorResult对象，并将done标志设置为true，表示迭代过程结束。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="20d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于多种原因，JavaScript中的对象在默认情况下是不可迭代的，但这并不意味着我们不能为它们添加自定义迭代器。例如，如果我们想以升序遍历对象的值:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="61d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以像这样简单地定义一个可迭代范围:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="b2a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想让一个链表是可迭代的呢？让我们来看一个简单的链表实现:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e3c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以将迭代器添加到LinkedList类中:</p><figure class="lg lh li lj gt lv"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="4187" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考资料:<br/><a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Iteration _ protocols</a><br/>【https://exploringjs.com/es6/ch_iteration.html】T4</p></div></div>    
</body>
</html>