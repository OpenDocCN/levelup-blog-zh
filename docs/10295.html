<html>
<head>
<title>Reader, Writer, and State Monads in TypeScript with fp-ts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用fp-ts的TypeScript中的读取器、编写器和状态单子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reader-writer-and-state-monad-with-fp-ts-6d7149cc9b85?source=collection_archive---------0-----------------------#2021-11-18">https://levelup.gitconnected.com/reader-writer-and-state-monad-with-fp-ts-6d7149cc9b85?source=collection_archive---------0-----------------------#2021-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="05af" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">使用类型脚本的函数式编程</h2><div class=""/><div class=""><h2 id="e1bc" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何用三个简单的单子丰富你的fp-ts工作流程</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/02d48889ae77a592d8b66b970ec14a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-hV9GBsrk-_kyLHoPKhMSA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">来源:https://www.pexels.com/</figcaption></figure><p id="3645" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">读取器、写入器和状态单子是函数式编程中三个非常常用的概念。Fp-ts支持这些现成的类型，尽管它们不像有良好文档记录的选项或任务单子那样受欢迎。为了简化读者、作者和状态对初学者的使用，下面的文章借助一些简单的打字稿示例对这个主题进行了简短的介绍。</p><h1 id="0721" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">《朗读者》</h1><p id="394a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">fp-ts中阅读器monad的接口如下:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="c997" class="ng mf it nc b gy nh ni l nj nk">export interface Reader&lt;R, A&gt; {<br/>  (r: R): A<br/>}</span></pre><p id="cf5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">读取器只是一个接收类型R作为参数并返回类型a的值的函数。因此，读取器“读取”值R，处理它并返回结果。这里重要的是，阅读器在概念上不会改变输入值。这就是为什么Reader monad非常适合通过一系列读取配置值的函数来传递配置。命令式编程中的对应物是对全局配置变量的访问。</p><p id="9b2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">举个例子，假设我们想写一个简单的函数来计算分数。分子应该是函数的参数值，而分母值应该从配置中读取。然后，我们希望应用分数函数三次，并返回结果。</p><p id="5732" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们定义配置类型:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="811a" class="ng mf it nc b gy nh ni l nj nk">type ReaderConfig = {<br/>    denominator: number;<br/>};</span></pre><p id="05ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们定义高阶函数“fraction ”,它获取分子值并返回一个读者单子:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="75d9" class="ng mf it nc b gy nh ni l nj nk">import * as R from 'fp-ts/Reader';</span><span id="108c" class="ng mf it nc b gy nl ni l nj nk">type ReaderConfig = {<br/>    denominator: number;<br/>};</span><span id="f78a" class="ng mf it nc b gy nl ni l nj nk">const fraction: (numerator: number) =&gt; <br/>R.Reader&lt;ReaderConfig, number&gt; = (numerator: number) =&gt; <br/>(config: ReaderConfig) =&gt; numerator / config.denominator;</span></pre><p id="4f35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">之后，我们在fp-ts管道的帮助下三次组合分数函数:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="fbbd" class="ng mf it nc b gy nh ni l nj nk">import * as R from 'fp-ts/Reader';<br/>import * as f from 'fp-ts/function';</span><span id="2d84" class="ng mf it nc b gy nl ni l nj nk">type ReaderConfig = {<br/>    denominator: number;<br/>};</span><span id="b569" class="ng mf it nc b gy nl ni l nj nk">const fraction: (numerator: number) =&gt; <br/>R.Reader&lt;ReaderConfig, number&gt; =(numerator: number) =&gt; <br/>(config: ReaderConfig) =&gt; numerator / config.denominator;</span><span id="886c" class="ng mf it nc b gy nl ni l nj nk">const fractionThreeTimes = (numerator: number) =&gt;<br/>f.pipe(<br/>  numerator,<br/>  fraction,<br/>  R.chain(fraction),<br/>  R.chain(fraction)<br/>);</span></pre><p id="157d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里很酷的一点是，配置值本身在组合中并不显式可见——它只是通过管道“隐藏”起来。我们只需要在最后触发管道时注入配置:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="42fa" class="ng mf it nc b gy nh ni l nj nk">import * as R from 'fp-ts/Reader';<br/>import * as f from 'fp-ts/function';</span><span id="16ce" class="ng mf it nc b gy nl ni l nj nk">type ReaderConfig = {<br/>    denominator: number;<br/>};</span><span id="047b" class="ng mf it nc b gy nl ni l nj nk">const fraction: (numerator: number) =&gt; <br/>R.Reader&lt;ReaderConfig, number&gt; = (numerator: number) =&gt; <br/>(config: ReaderConfig) =&gt; numerator / config.denominator;</span><span id="605d" class="ng mf it nc b gy nl ni l nj nk">const fractionThreeTimes = (numerator: number) =&gt;<br/>f.pipe(<br/>  numerator,<br/>  fraction,<br/>  R.chain(fraction),<br/>  R.chain(fraction)<br/>);</span><span id="5545" class="ng mf it nc b gy nl ni l nj nk">const startValue = 10;<br/>const config: ReaderConfig = {<br/>  denominator: 2<br/>};</span><span id="81eb" class="ng mf it nc b gy nl ni l nj nk">console.log(fractionThreeTimes(startValue)(config)); // Returns 1.25</span></pre><h1 id="b7d6" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">作家</h1><p id="1c64" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">fp-ts中的Writer monad的接口如下:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="5c14" class="ng mf it nc b gy nh ni l nj nk">export interface Writer&lt;W, A&gt; {<br/>  (): [A, W]<br/>}</span></pre><p id="2403" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与读取器相反，写入器monad根本不接收任何输入，但是除了类型a的实际值之外，还将类型W的附加值“写入”到元组类型中。通常，类型W是幺半群，这意味着该类型可以连接其值。典型的幺半群是数组，它甚至在Javascript规范中有一个名为“concat”的函数。那么这个单子有什么用呢？一个经典的例子是日志记录:除了计算类型A的值之外，monad还返回类型W的日志条目，因此这不会被计算为副作用，而是将在工作流结束时进行处理。命令式编程中的对应物是标准的“console.log()”，从概念上讲，它是对全局“控制台”变量的访问。</p><p id="0aaf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一个例子，让我们假设我们想写一个计算分数的替代函数，这一次有额外的日志记录。因为我们不能再从注入的配置中读取分母值，所以我们现在需要将它硬编码到函数本身中。让我们从创建一个带有数组幺半群的Writer monad开始，这样我们工作流的所有日志都被连接到一个字符串数组中。帮助器方法“getChain”返回一个实际的Monad对象，它有一个“Chain”方法:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="0d7e" class="ng mf it nc b gy nh ni l nj nk">import * as W from 'fp-ts/Writer';<br/>import * as A from 'fp-ts/Array';</span><span id="a7f7" class="ng mf it nc b gy nl ni l nj nk">const ArrayWriter = W.getChain&lt;Array&lt;string&gt;&gt;(A.getMonoid());</span></pre><p id="1575" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们定义我们的高阶函数“fractionWithStaticDenominator ”,它获取分子值并返回一个编写器单子，包括作为数组的日志字符串:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="de99" class="ng mf it nc b gy nh ni l nj nk">import * as W from 'fp-ts/Writer';<br/>import * as A from 'fp-ts/Array';</span><span id="19a7" class="ng mf it nc b gy nl ni l nj nk">const ArrayWriter = W.getChain&lt;Array&lt;string&gt;&gt;(A.getMonoid());</span><span id="65c9" class="ng mf it nc b gy nl ni l nj nk">const fractionWithStaticDenominator: (numerator: number) =&gt; W.Writer&lt;Array&lt;string&gt;, number&gt; = (numerator: number) =&gt; () =&gt; [numerator / 2, [`Numerator: ${numerator}. Denominator: 2`]];<br/>// The denominator of 2 is hardcoded because we cannot read it from anywhere</span></pre><p id="dfec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">之后，我们在fp-ts管道的帮助下三次组合分数函数:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="3ec3" class="ng mf it nc b gy nh ni l nj nk">import * as W from 'fp-ts/Writer';<br/>import * as A from 'fp-ts/Array';<br/>import * as f from 'fp-ts/function';</span><span id="c77a" class="ng mf it nc b gy nl ni l nj nk">const ArrayWriter = W.getChain&lt;Array&lt;string&gt;&gt;(A.getMonoid());</span><span id="6d4b" class="ng mf it nc b gy nl ni l nj nk">const fractionWithStaticDenominator: (numerator: number) =&gt; W.Writer&lt;Array&lt;string&gt;, number&gt; = (numerator: number) =&gt; () =&gt; [numerator / 2, [`Numerator: ${numerator}. Denominator: 2`]];<br/>// The denominator of 2 is hardcoded because we cannot read it from anywhere</span><span id="0b77" class="ng mf it nc b gy nl ni l nj nk">const fractionThreeTimes = (numerator: number) =&gt; <br/>f.pipe(<br/>  numerator,<br/>  fractionWithStaticDenominator,<br/>  (writer) =&gt; ArrayWriter.chain(writer,     fractionWithStaticDenominator),<br/>  (writer) =&gt; ArrayWriter.chain(writer, fractionWithStaticDenominator)<br/>);</span></pre><p id="f398" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种组合不如Reader中的组合漂亮，因为fp-ts中的“ArrayWriter.chain”方法不是curried，它同时接受两个参数。但是基本流程保持不变。我们可以像在读取器的情况下那样触发流，这一次没有配置:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="6393" class="ng mf it nc b gy nh ni l nj nk">import * as W from 'fp-ts/Writer';<br/>import * as A from 'fp-ts/Array';<br/>import * as f from 'fp-ts/function';</span><span id="7028" class="ng mf it nc b gy nl ni l nj nk">const ArrayWriter = W.getChain&lt;Array&lt;string&gt;&gt;(A.getMonoid());</span><span id="ab69" class="ng mf it nc b gy nl ni l nj nk">const fractionWithStaticDenominator: (numerator: number) =&gt; W.Writer&lt;Array&lt;string&gt;, number&gt; = (numerator: number) =&gt; () =&gt; [numerator / 2, [`Numerator: ${numerator}. Denominator: 2`]];<br/>// The denominator of 2 is hardcoded because we cannot read it from anywhere</span><span id="b563" class="ng mf it nc b gy nl ni l nj nk">const fractionThreeTimes = (numerator: number) =&gt; <br/>f.pipe(<br/>  numerator,<br/>  fractionWithStaticDenominator,<br/>  (writer) =&gt; ArrayWriter.chain(writer, fractionWithStaticDenominator),<br/>  (writer) =&gt; ArrayWriter.chain(writer, fractionWithStaticDenominator)<br/>);</span><span id="1786" class="ng mf it nc b gy nl ni l nj nk">const startValue = 10;<br/>console.log(fractionThreeTimes(startValue)());<br/>/**<br/>[<br/>  1.25,<br/>  [<br/>    'Numerator: 10. Denominator: 2',<br/>    'Numerator: 5. Denominator: 2',<br/>    'Numerator: 2.5. Denominator: 2'<br/>  ]<br/>]<br/>*/</span></pre><p id="3576" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Writer模式的好处是，我们不需要显式地处理日志值的连接，而是可以专注于修改类型A的实际值。其他一切都在“引擎盖下”再次处理。</p><h1 id="72a3" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">国家</h1><p id="48d7" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">读取器可以读取值，写入器可以写入——组合就是状态单子！它是三个单子中最强大的，因为它不仅可以读取配置，还可以修改它。这就是为什么注入的配置值实际上变成了通过工作流传输的状态值。</p><p id="a4c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">fp-ts中状态monad的接口如下:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="6e0f" class="ng mf it nc b gy nh ni l nj nk">export interface State&lt;S, A&gt; {<br/>  (s: S): [A, S]<br/>}</span></pre><p id="812b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">状态接收类型S，处理它并将类型S的(潜在的)新值与类型A的值一起写入元组。命令式编程中的对应物将是全局变量的访问和突变，例如共享映射。</p><p id="d562" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一个例子，让我们通过处理状态单子来扩展我们的分数函数。首先，我们需要定义新的配置类型:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="331f" class="ng mf it nc b gy nh ni l nj nk">type WriterConfig = {<br/>    denominator: number;<br/>    logs: Array&lt;string&gt;<br/>};</span></pre><p id="4300" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以定义“fractionWithLogs”函数来读取和修改配置，并计算分数:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="93e7" class="ng mf it nc b gy nh ni l nj nk">import * as S from 'fp-ts/State';</span><span id="a139" class="ng mf it nc b gy nl ni l nj nk">type WriterConfig = {<br/>    denominator: number;<br/>    logs: Array&lt;string&gt;<br/>};</span><span id="2a66" class="ng mf it nc b gy nl ni l nj nk">const fractionWithLogs: (numerator: number) =&gt; <br/>S.State&lt;Config, number&gt; = (numerator: number) =&gt; (c: Config) =&gt;<br/>[<br/>  numerator / c.denominator,<br/>  {<br/>    denominator: c.denominator,<br/>    logs: [<br/>      …c.logs,<br/>      `Numerator: ${numerator}. Denominator: ${c.denominator}`<br/>    ]<br/>  }<br/>];</span></pre><p id="80fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">之后，我们可以再次构建函数:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="640d" class="ng mf it nc b gy nh ni l nj nk">import * as S from 'fp-ts/State';<br/>import * as f from 'fp-ts/function';</span><span id="72d1" class="ng mf it nc b gy nl ni l nj nk">type WriterConfig = {<br/>    denominator: number;<br/>    logs: Array&lt;string&gt;<br/>};</span><span id="da78" class="ng mf it nc b gy nl ni l nj nk">const fractionWithLogs: (numerator: number) =&gt; <br/>S.State&lt;Config, number&gt; = (numerator: number) =&gt; (c: Config) =&gt;<br/>[<br/>  numerator / c.denominator,<br/>  {<br/>    denominator: c.denominator,<br/>    logs: [<br/>      …c.logs,<br/>      `Numerator: ${numerator}. Denominator: ${c.denominator}`<br/>    ]<br/>  }<br/>];</span><span id="7e6f" class="ng mf it nc b gy nl ni l nj nk">const fractionThreeTimes = (numerator: number) =&gt;<br/>f.pipe(<br/>  numerator,<br/>  fractionWithLogs,<br/>  S.chain(fractionWithLogs),<br/>  S.chain(fractionWithLogs)<br/>);</span></pre><p id="ff6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们用一个配置值触发工作流:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="80bf" class="ng mf it nc b gy nh ni l nj nk">import * as S from 'fp-ts/State';<br/>import * as f from 'fp-ts/function';</span><span id="60e9" class="ng mf it nc b gy nl ni l nj nk">type WriterConfig = {<br/>    denominator: number;<br/>    logs: Array&lt;string&gt;<br/>};</span><span id="8738" class="ng mf it nc b gy nl ni l nj nk">const fractionWithLogs: (numerator: number) =&gt; <br/>S.State&lt;Config, number&gt; = (numerator: number) =&gt; (c: Config) =&gt;<br/>[<br/>  numerator / c.denominator,<br/>  {<br/>    denominator: c.denominator,<br/>    logs: [<br/>      …c.logs,<br/>      `Numerator: ${numerator}. Denominator: ${c.denominator}`<br/>    ]<br/>  }<br/>];</span><span id="835a" class="ng mf it nc b gy nl ni l nj nk">const fractionThreeTimes = (numerator: number) =&gt;<br/>f.pipe(<br/>  numerator,<br/>  fractionWithLogs,<br/>  S.chain(fractionWithLogs),<br/>  S.chain(fractionWithLogs)<br/>);</span><span id="e435" class="ng mf it nc b gy nl ni l nj nk">const startValue = 10;<br/>const config: Config = {<br/>  denominator: 2,<br/>  logs: []<br/>};</span><span id="1017" class="ng mf it nc b gy nl ni l nj nk">console.log(fractionThreeTimes(startValue)(config));<br/>/**<br/>[<br/>  1.25,<br/>  {<br/>    denominator: 2,<br/>    logs: [<br/>      'Numerator: 10. Denominator: 2',<br/>      'Numerator: 5. Denominator: 2',<br/>      'Numerator: 2.5. Denominator: 2'<br/>    ]<br/>  }<br/>]<br/>*/</span></pre><p id="a238" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们愿意，我们也可以改变分母的值，这个值已经在“Writer”示例中进行了硬编码。这显示了状态单子对于许多工作流是多么灵活。然而，作为一个经验法则，如果你真的需要这个功能，你应该只使用更复杂的单子。否则，函数定义会变得过于复杂，并误导其他开发人员。当然，在fp-ts库中有更多的组合子和实用函数可供读者、作者和状态单子使用，可以用于更复杂的用例。看看官方文件就知道了:<a class="ae lh" href="https://gcanti.github.io/fp-ts/modules/" rel="noopener ugc nofollow" target="_blank">https://gcanti.github.io/fp-ts/modules/</a>。</p></div></div>    
</body>
</html>