<html>
<head>
<title>JavaScript Web Workers, An Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Web Workers，简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/web-workers-an-introduction-6b96a442411f?source=collection_archive---------11-----------------------#2020-02-17">https://levelup.gitconnected.com/web-workers-an-introduction-6b96a442411f?source=collection_archive---------11-----------------------#2020-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8ddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JavaScript中的Web Workers是什么？这是一种使用后台线程处理繁重任务而不阻塞主线程的方法。</p><p id="fdc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它有3个主要的API</p><ul class=""><li id="4aea" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><code class="fe ku kv kw kx b">postMessage</code></li><li id="5930" class="kl km iq jp b jq ky ju kz jy la kc lb kg lc kk kq kr ks kt bi translated"><code class="fe ku kv kw kx b">onmessage</code></li><li id="279f" class="kl km iq jp b jq ky ju kz jy la kc lb kg lc kk kq kr ks kt bi translated"><code class="fe ku kv kw kx b">onerror</code></li></ul><p id="0839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始之前，我需要介绍一些关于JavaScript内部工作的要点，比如callstack，因为要理解web workers，我们应该知道所有这些东西的基础。</p><p id="1314" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们知道在JavaScript中一切都是并行运行的，除了你的代码。这意味着你用JS编写的所有I/O代码都是非阻塞的，而(反过来)你用JS编写的所有非I/O代码都是阻塞的。</strong></p><p id="de89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上所有的Web API，例如<strong class="jp ir"> setTimeout(fn) </strong>、<strong class="jp ir"> I/O操作等</strong>，都是非阻塞的，因为它进入了本地服务，并且由线程池中的一个工作线程执行。一旦执行完成，回调(响应)被放入回调队列，我们运行事件循环，不断检查调用堆栈是否为空。一旦调用堆栈为空，回调队列中的第一个回调就被放入调用堆栈并执行。</p><p id="4ae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ld" href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYWNoaWV2ZU5pcnZhbmEoKXsKICAgIGNvbnNvbGUubG9nKCJZb3UgYXJlIEdvb2QiKTsKfQoKZnVuY3Rpb24gYygpewogICAgc2V0VGltZW91dChhY2hpZXZlTmlydmFuYSwgMzAwMCk7Cn0KCmZ1bmN0aW9uIGIoKXsKICAgIGMoKTsKfQoKZnVuY3Rpb24gYSgpewogICAgYigpOwp9CgphKCk7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">演示</a></p><p id="930b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:默认情况下JavaScript是单线程的，但浏览器本身不是。回调只在主线程上执行。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/0dd5fc361c1438f364dd004f0988f58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FA9NGxNB6-v1oI2qGEtlRQ.png"/></div></div></figure><p id="eb3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是正常情况下会发生的事情，但是如果调用了CPU密集型的代码，比如运行一个大的循环，或者一些繁重的计算呢？</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="2f75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们可以选择使用<strong class="jp ir"> Web Worker </strong>概念。</p><p id="1333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以<strong class="jp ir">产生一个新线程来处理繁重的任务，然后在新产生的线程上执行该任务。</strong></p><p id="6237" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何产生一个新线程？</strong></p><pre class="lf lg lh li gt lx kx ly lz aw ma bi"><span id="c1ad" class="mb mc iq kx b gy md me l mf mg">let worker = new Worker(“background.js”);</span></pre><p id="95d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">向工作人员发送消息</strong></p><pre class="lf lg lh li gt lx kx ly lz aw ma bi"><span id="aeb5" class="mb mc iq kx b gy md me l mf mg">worker.postMessage(message);</span></pre><p id="b1c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">接收来自工人的消息</strong></p><pre class="lf lg lh li gt lx kx ly lz aw ma bi"><span id="43e7" class="mb mc iq kx b gy md me l mf mg">worker.onmessage = function(e){<br/>  console.log(e.message);<br/>}</span></pre><p id="d64b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主线程不会被阻塞，写在<strong class="jp ir"> background.js </strong>中的代码将在后台线程中执行。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mh"><img src="../Images/0cf5e25b4df61526865a6ebbe41205b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBBRxrh2dLu2Zj6kp0CCUQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">索引. js</figcaption></figure><p id="eec7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，你可以看到我生成了一个新线程来单独运行background.js文件的代码，并且我还使用<code class="fe ku kv kw kx b">postMessage</code> API向该文件发送了额外的参数。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mm"><img src="../Images/e80d6302a06b24b9db3d58c894fec950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nKbFkemd9_vx0rZxUacCQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">背景. js</figcaption></figure><p id="37dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">background.js中的<code class="fe ku kv kw kx b">onmessage</code> API接收index.js中的<code class="fe ku kv kw kx b">postMessage</code> API发送的数据，然后在需要时使用该消息。如你所见，我在这个文件中运行了一个沉重的<code class="fe ku kv kw kx b">for</code>循环，它不是在主线程上运行，而是在后台线程上运行，并且没有阻塞主线程。</p><p id="027b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦执行完成，使用<code class="fe ku kv kw kx b">postMessage</code> API将结果再次发送回主线程，并由index.js文件中的<code class="fe ku kv kw kx b">onmesage</code> API捕获</p><p id="3d9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我强烈推荐查看这个repo:<a class="ae ld" href="https://github.com/yogain123/Web-Workers/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://github.com/yogain123/Web-Workers/</strong></a>以了解关于Web Workers的见解和在background.js文件中编写的代码等等。</p><h2 id="47ba" class="mb mc iq bd mn mo mp dn mq mr ms dp mt jy mu mv mw kc mx my mz kg na nb nc nd bi translated"><strong class="ak">用例:制作音乐App </strong></h2><p id="65cb" class="pw-post-body-paragraph jn jo iq jp b jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">假设你想创建一个类似于<strong class="jp ir">架子鼓</strong>的音乐应用程序，你点击一个按钮就可以播放声音。然后，让我们说你不断地按下按钮，但你也做了一些繁重的计算后，每一个按钮按下。产生一个新线程来处理这种繁重的计算将是正确的解决方案，因为如果繁重的计算在主线程上运行，您的音乐应用程序体验将会混乱。</p><p id="a9f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看我的<strong class="jp ir">架子鼓</strong>app<a class="ae ld" href="https://github.com/yogain123/drum-kit" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://github.com/yogain123/drum-kit</strong></a>就知道了。如果可能的话，试着在上面实现web workers，看看它有多有用。</p><p id="56cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:你可以产生<code class="fe ku kv kw kx b">n</code>个线程，你甚至可以从产生的线程中产生线程，等等。</p><p id="5497" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐学习:)</p></div></div>    
</body>
</html>