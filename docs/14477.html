<html>
<head>
<title>Microservices. Circuit Breaker. Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务。断路器。节点. js</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/microservices-circuit-breaker-node-js-c2062af14e47?source=collection_archive---------2-----------------------#2022-12-01">https://levelup.gitconnected.com/microservices-circuit-breaker-node-js-c2062af14e47?source=collection_archive---------2-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ace5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么要用，如何在Node.js中实现</h2></div><p id="5d45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">微服务是构建可扩展系统的现代方式，但与任何方法一样，它也有自己的挑战。尤其是当我们谈论你的软件的可靠性和可用性的时候。</p><h2 id="66d6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">什么是断路器？</h2><p id="ec96" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在我们谈论软件之前，让我们看看这个想法来自哪里。在电子产品中，当电源/电压出现尖峰时，我们需要切断设备的电源，否则它们可能会被损坏。断路器执行这样的动作。</p><p id="ac35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有两种状态，关闭和打开。在闭合状态下，电可以接触到设备，而在打开状态下，电不能接触到设备。那么断路器需要由人手动复位到闭合状态。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/212b15da3a99cd6674be966ebd947c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YjLJUgXCquVZsJRuZwT6Q.png"/></div></div></figure><h2 id="ac44" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">我们为什么需要它？</h2><p id="db3d" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">与电子产品类似，有时我们的软件中会出现请求高峰或错误高峰，这可能会导致我们的服务器出现故障，因此要帮助我们的服务器进行自我修复(例如，进行自动伸缩，杀死不健康的实例等。)我们需要调用此服务器的客户端给它一些时间，并停止向它发送流量。</p><p id="935e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们可以帮助我们的系统更好地适应“暂时性”错误，这些错误可以在短时间内自我修复。</p><h2 id="9367" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Node.js中的断路器</h2><p id="7abb" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">断路器可以表示为以下状态机。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/13a87303e4f5de8b5b8617d75dfb48f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-a_kauh5t1Tfx73dRE1mnw.png"/></div></div></figure><p id="5a5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，与基本断路器相比，我们增加了第三种状态HALF_OPEN。我们的断路器将通过从客户端传递的大量请求来测试我们的服务器，以验证我们可以将所有流量传递回服务器。除此之外，与电动断路器相比，我们不需要手动将断路器从断开状态复位到闭合状态，我们可以在一段时间后进行复位。</p><p id="2ea0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以安装我的包含测试的npm包<a class="ae mm" href="https://www.npmjs.com/package/axios-circuit-breaker" rel="noopener ugc nofollow" target="_blank">axios-断路器</a>，现在就开始使用Node.js中的断路器模式！尽管断路器可以用于任何类型的传输层。</p><p id="739d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一下使用示例。您需要为每个Axios实例定义断路器，以区分不同服务器的状态。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="01ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，每个Axios实例都有一个单独的断路器实例与之相连。您可以深入配置每个实例，并指定记录器实例和策略来定义请求是否应该被视为故障。我要说的是，定义一个记录器是在运行时了解断路器状态的必要条件。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0952" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在到达<code class="fe mp mq mr ms b">threshold</code>的<code class="fe mp mq mr ms b">thresholdPeriodMs</code>期间，多次请求失败后，断路器将切换到<code class="fe mp mq mr ms b">OPEN</code>状态。断路器将使用<code class="fe mp mq mr ms b">isFault</code> a方法确定请求失败。在<code class="fe mp mq mr ms b">OPEN</code>状态下，它会拒绝任何对服务器的请求。</p><p id="6e55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe mp mq mr ms b">ressetPeriodMs</code>之后，它将切换到<code class="fe mp mq mr ms b">HALF_OLPEN</code>并以最大值<code class="fe mp mq mr ms b">numRequestToCloseCircuit</code>进入，其他请求将被拒绝。如果所有请求成功，它们将再次进入<code class="fe mp mq mr ms b">CLOSED</code>状态。如果至少有一个请求失败，它将返回到<code class="fe mp mq mr ms b">OPEN</code>状态。</p><h2 id="5ac1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">摘要</h2><p id="992c" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">断路器有助于使您的后端更加可靠，因为它为服务器提供了更多的时间进行自我修复，从而使您的整个分布式系统更具弹性。</p><p id="f843" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Axios是Node.js的一个很棒的可扩展的HTTP客户端，允许您更改HTTP客户端的行为。</p><h2 id="4d8d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">接下来呢？</h2><p id="2eb5" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">爱Node.js？你可以看看我关于它的其他文章:</p><ul class=""><li id="3be8" class="mt mu iq kh b ki kj kl km ko mv ks mw kw mx la my mz na nb bi translated"><a class="ae mm" rel="noopener ugc nofollow" target="_blank" href="/streams-and-how-they-fit-into-node-js-async-nature-a08723055a67">流以及它们如何适应Node.js的异步特性。</a></li><li id="515b" class="mt mu iq kh b ki nc kl nd ko ne ks nf kw ng la my mz na nb bi translated"><a class="ae mm" rel="noopener ugc nofollow" target="_blank" href="/how-to-handle-blockers-in-node-js-1966d0399703">如何处理Node.js中的拦截器？</a></li></ul></div></div>    
</body>
</html>