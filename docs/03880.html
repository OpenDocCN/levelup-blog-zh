<html>
<head>
<title>RxJava Basics in Android Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android开发中的RxJava基础知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxjava-basics-in-android-development-a1befbd8008c?source=collection_archive---------13-----------------------#2020-05-31">https://levelup.gitconnected.com/rxjava-basics-in-android-development-a1befbd8008c?source=collection_archive---------13-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/bfeb22763b5fc647526a31d0708619e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*hWhb8Qiwc9pVTI5QJSKx6Q.png"/></div></figure><p id="81c3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">RxJava是Java和Android开发领域中一个流行的开源库。对于初学者来说，很难理解它是什么，为什么它很重要，或者如何使用它。这篇文章中的讨论很容易理解，它不仅限于Android开发人员，也适用于Java或其他JVM相关语言的开发人员。为了更好地理解这个库，它涵盖了一些基本概念，随后是RxJava本身以及一个解释的例子。我们骑吧！</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="1b49" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">观察者模式和反应式编程</h1><p id="27fa" class="pw-post-body-paragraph jx jy it jz b ka ma kc kd ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku im bi translated">RxJava是一个反应式编程库。因此，在深入RxJava之前，理解什么是反应式编程是很重要的。</p><p id="353d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">反应式编程是一种编程风格(或范式)，它扩展了<strong class="jz iu">观察者设计模式</strong>。设计模式是一种代码结构，它使解决给定的编程问题变得更加简单。比方说，<strong class="jz iu"> ExpensiveObject </strong>是一类在你的程序中需要几毫秒才能创建的对象。每次需要一个实例时创建一个新的<strong class="jz iu"> ExpensiveObject </strong>并不是一个好主意，因为这可能会降低你的应用程序的速度。为了解决这个问题，您可以通过使用私有构造函数和静态方法来使用<strong class="jz iu"> Singleton </strong>模式，以确保只创建一个<strong class="jz iu"> ExpensiveObject </strong>，如下所示:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mf"><img src="../Images/b8c00049063735f060c9566438612b1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHb7piCXzETEOPK4otYIvA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图1 </strong>。单例设计模式实现。</figcaption></figure><p id="ebde" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">还有很多设计模式，并不是说你应该知道所有的。<strong class="jz iu">观察者模式</strong>寻求有效地解决从应用程序的一个部分向一个或多个其他部分发送通知(或更新)的问题。这个模式中的关键对象是通知的<strong class="jz iu">源</strong>和通知的消费者(<strong class="jz iu">观察者</strong>)。他们的互动是这样的:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ms"><img src="../Images/689c361a70edb3222d128570dd6b8ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*65OjYQ5ZDIH0DMnju4K2qQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图2。</strong>观察者设计模式。</figcaption></figure><p id="01aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">数据源(也称为主题)包含对其所有观察者的引用，并在新数据生成时向每个观察者发送通知。新数据可能是来自后端API、数据库或任何东西的异步网络响应。观察者的角色是接收新数据并对其进行处理。这种安排比每个观察者定期检查是否有来自数据源的新数据，然后再对其进行操作要好。举一个简单的例子，假设一个观察者订阅了图3中接口指定的随机整数。它包含一个<strong class="jz iu"> handleInteger() </strong>方法，该方法将数据源中的一个随机整数作为参数，并对其进行操作。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mt"><img src="../Images/cf21f4957209128674cfb5a899f3bfc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tiWn9tdKw9I1RnQrQGj8UA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图3。</strong>用随机生成的整数通知观察者的接口。</figcaption></figure><p id="0491" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于这样一个观察者，图4是其数据源的一个虚拟实现。它在实例化时开始生成随机整数，并定义了一个<strong class="jz iu"> subscribe() </strong>方法，用于向随机整数更新的订阅者列表中添加一个观察者。每次在<strong class="jz iu"> pushUpdates() </strong>中生成一个随机整数，所有的观察者都会被通知一个对它们的<strong class="jz iu"> handleInteger() </strong>方法的调用。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mu"><img src="../Images/329fda9b30cf795901f9a382281cbf53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mu6U7IqEtnzsi4QfT0djWg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图4。</strong>一个随机整数数据源。</figcaption></figure><p id="cd73" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了使用随机整数，每个观察者都必须订阅数据源👇</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mv"><img src="../Images/c32ceff8c3442388b787a56b39d6c304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ofp1XgPEuFwR6KJQmg_HsQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图5。</strong>订阅一个观察器从数据源接收随机整数。</figcaption></figure><p id="0ae0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个简单的例子有几个问题。例如，当图4中的<strong class="jz iu"> pushUpdates() </strong>中的线程由于某种原因被中断时，观察者没有得到通知。在现实世界中，这种异常可能是网络中断，通知观察者这一点很重要。其次，当不再需要数据源时，线程会发生什么？这些是使用RxJava时可以解决的一些问题。</p><p id="905b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">反应式编程类似于所解释的观察者设计模式。它以<strong class="jz iu">流</strong>的概念为中心。顾名思义，流由从源到消费者的数据流(或对象、信号等)组成。在流中流动的对象主要有三种类型:数据对象、错误和完整信号。数据对象可以是任何类型。在Java中，它可以是预构建或用户定义的类的实例。它代表了消费者所期望的那种信息。例如，在显示由标题和描述组成的待办事项列表的应用程序中，数据流中的数据项可以是这样一个类的实例👇</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mw"><img src="../Images/1e7f7dfe092709da012fd75d19380ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7q2aLJt7czpyTDhIis3_yQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图6。</strong>一类可以在流中运行的对象的例子。</figcaption></figure><p id="bc10" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">流中的错误意味着发生了错误。可能发生了网络错误，或者服务器遇到了内部错误。当这种情况发生时，消费者通常应该向应用程序用户显示一些描述性消息。完整的信号意味着没有更多的数据从信号源发出。作为示范，考虑图7中的待办事项应用程序的流，由于某种未知的原因😁，拉五个待办事项，痛苦地一个接一个，而不是作为一个列表从服务器上显示给用户。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mx"><img src="../Images/541b219519d83a8796403d4f30b61147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GccDUMqn47KgOyYUvAyiVA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图7。一连串的待办事项。</strong></figcaption></figure><p id="1e6d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最左边的箭头表示流的方向，项目按顺序发出，直到发出完整的信号，表示所有五个待办事项都已发出。请注意，流对象之间的间距是不均匀的，这表明发出的项的异步特性(它们到达的时间是不确定的)。第四个待办事项发出后，第五个待办事项发出前，最后是完整信号发出后，流中出现错误。</p><p id="1e6e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">需要注意的是，流对象可以在从源到消费者的流中经历转换。使用<strong class="jz iu">运算符完成转换。</strong>例如，操作员可以过滤掉一些数据项，将每个数据项映射到一个全新的数据项，或者生成并行流并将其合并到一个数据流中，就像高度复杂的制造环境中的装配线一样(夸张)。可能性是无限的。通过链接运算符，程序员可以编写非常紧凑的代码。然而，这可能会使代码难以理解，这也是让反应式编程感到困难的原因之一。紧凑性和易于理解性之间的折衷类似于递归算法与迭代算法的情况。你应该知道什么时候用什么。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="5c36" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">RxJava</h1><p id="7cdf" class="pw-post-body-paragraph jx jy it jz b ka ma kc kd ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku im bi translated">RxJava(<strong class="jz iu">R</strong>E<strong class="jz iu">x</strong>张力<strong class="jz iu"> J </strong> ava)是一个Java虚拟机(JVM)的开源反应式编程库。它是由<a class="ae my" href="https://github.com/ReactiveX" rel="noopener ugc nofollow" target="_blank">reaction vex组织</a>开发的反应式扩展的Java变体。还有其他变体，如RxJs(用于JavaScript)、RxScala和RxSwift。它并不局限于Android开发，它可以用于服务器实现等。这篇文章主要关注它在Android开发中的应用。</p><p id="762d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">RxJava的API为线程提供了一个抽象层。线程本质上是由操作系统调度的CPU内核独立执行的控制流。一个应用程序可以由多个线程组成，每个线程运行一个独立的操作序列。对用户与安卓应用交互的反应由一个特殊的用户界面线程管理。任何长时间运行的任务，如异步网络请求，都应该在后台线程中执行，而不是UI线程，以避免应用程序无响应。直接使用线程可能很困难，尤其是当多个并发线程需要同步时(这是一个完全不同的主题)。为了省去您担心线程的负担，RxJava提供了<strong class="jz iu">调度器</strong>来为您处理线程的细节。通过调用scheduler类中的静态方法，可以很容易地获得许多scheduler。三个例子是:</p><ol class=""><li id="4806" class="mz na it jz b ka kb ke kf ki nb km nc kq nd ku ne nf ng nh bi translated"><strong class="jz iu"> Schedulers.io(): </strong>一个输入/输出调度器。使用它来执行需要数据传输的任务，例如，通过网络或使用磁盘。</li><li id="a9fb" class="mz na it jz b ka ni ke nj ki nk km nl kq nm ku ne nf ng nh bi translated"><strong class="jz iu">schedulers . computation():</strong>用于执行CPU密集型任务的调度程序，例如从原始数据分段渲染图像。</li><li id="4e39" class="mz na it jz b ka ni ke nj ki nk km nl kq nm ku ne nf ng nh bi translated"><strong class="jz iu"> Schedulers.newThread(): </strong>创建并处理新后台线程的调度程序。</li></ol><p id="799e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要在Android中开始使用RxJava，请将以下依赖项添加到您的模块级Gradle build配置文件(<strong class="jz iu"> app/build.gradle </strong>)中:</p><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="4541" class="ns ld it no b gy nt nu l nv nw">implementation 'io.reactivex.rxjava2:rxjava:2.2.10'</span></pre><p id="c538" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">请务必点击查看最新版本<a class="ae my" href="https://github.com/ReactiveX/RxJava/blob/3.x/README.md" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d520" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您需要安排一些工作在UI线程上运行(您很可能会这样做)，比如显示从服务器检索的数据，那么添加下面的依赖项，它包括一个用于UI线程的特殊调度程序(<strong class="jz iu">androidschedulers . main thread()</strong>)。</p><pre class="mg mh mi mj gt nn no np nq aw nr bi"><span id="2a0e" class="ns ld it no b gy nt nu l nv nw">implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'</span></pre><p id="536c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">举个例子，考虑一个简单的应用程序，它由一个来源的0到10000范围内的随机整数流组成。这些整数的使用者将每个整数显示为偶数、奇数或质数，如下所示👇</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/69ee36fb3f9266503204915e3baa5c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*Jr563YWO3PbJHeomUE6x4Q.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图8。</strong>一个应用程序屏幕，将流中的随机整数显示为偶数、奇数或质数。</figcaption></figure><p id="71cf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个例子中，数据源是一个名为<strong class="jz iu"> Flowable </strong>的参数化类类型。Flowable是RxJava中许多数据源类型中的一种。其他一些类型有<strong class="jz iu">可观察</strong>、<strong class="jz iu">单个</strong>和<strong class="jz iu">可完成</strong>。从某种意义上来说，可流动流体是独一无二的，因为它能够指定一个<strong class="jz iu">背压</strong>策略。当数据源以使用者无法应付的速度发出数据时，就会出现背压。假设，如果消费者用100毫秒处理一次排放，那么就会出现背压，比如说如果数据源在100毫秒内排放20个项目。为了解决这个问题，可以使用缓冲区(临时存储)来保存多余的项目，或者可以丢弃多余的项目，以及其他技术。如果消费者需要，删除项目可能不是一个好主意。对于这个例子，可流动数据源删除多余的项目，因为整数不一定重要。创建的数据源如以下代码片段所示:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ny"><img src="../Images/377e6c150f5ef2fe967148d6db0a8e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_PEjWNR8iocH079_6GUYQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图9。</strong>随机整数的可流动来源。</figcaption></figure><p id="1a7b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">可流动源是通过调用静态的<strong class="jz iu">floable . create()</strong>方法创建的，该方法将一个<strong class="jz iu"> FlowableOnSubscribe </strong>对象作为其第一个参数，表示为lambda，将一个<strong class="jz iu"> BackpressureStrategy </strong>作为其第二个参数。它使用while循环来检查流是否仍在运行，这由静态布尔可变变量<strong class="jz iu"> runStream决定。</strong>如果仍在运行，它会生成一个随机整数，并使用发射器的<strong class="jz iu"> onNext() </strong>方法将其推送到流中。当通过将<strong class="jz iu"> runStream </strong>更改为false来停止流时，将通过调用<strong class="jz iu"> onComplete()向消费者发送一个完成信号。</strong>消费者由<strong class="jz iu"> handleInteger() </strong>方法定义👇</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nz"><img src="../Images/3b5c561336966e80ce0dbe8429a30479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4iPpu3bRsBV0qy-pbC62A.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图10。</strong>用于处理随机生成的整数的消费者代码。</figcaption></figure><p id="e655" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">消费者向用户显示整数为质数、偶数或奇数。为了启动流，使用者必须订阅源。使用下面的方法链进行订阅👇</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi oa"><img src="../Images/b4389719b06c9f017d8a50ec39cd8044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5_OiovhcYeb-IW4baQnsA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd le">插图11。</strong>方法调用链来触发随机整数流。</figcaption></figure><p id="cf00" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它从调用静态方法<strong class="jz iu"> getIntegerStream() </strong>开始，该方法返回一个<strong class="jz iu">floable。</strong>随后是一个<strong class="jz iu"> subscribeOn() </strong>调用，指定用于流的调度程序。记住，调度程序用线程为你处理工作。在这种情况下，<strong class="jz iu"> Schedulers.newThread() </strong>调度程序创建一个新的工作线程来执行整数生成代码。对<strong class="jz iu"> observeOn() </strong>的第三次调用指定消费者的代码应该在Android特有的UI线程上运行。<strong class="jz iu">androidschedulers . main thread()</strong>调度程序由前面描述的<strong class="jz iu"> rxandroid </strong> Gradle依赖关系提供。如果Android操作系统要求在UI线程上运行一些代码，比如更新视图，这一点很重要。对<strong class="jz iu"> subscribe() </strong>的第三次调用使用Java 8的方法引用语法定义了三个参数。第一个参数运行图10中的代码，第二个参数处理来自源的错误，第三个参数处理完整的信号。该应用的完整源代码可以在Github 上找到<a class="ae my" href="https://github.com/ongebo/rxjava-basics" rel="noopener ugc nofollow" target="_blank">。对<strong class="jz iu"> subscribe() </strong>的调用返回一个<strong class="jz iu">可处置的</strong>,只要不再需要订阅，就应该将其处置掉，以避免由于线程导致的内存泄漏。当应用程序不再运行时，如果操作系统没有回收分配给应用程序的部分系统堆内存，就会发生内存泄漏。这会导致用户设备不必要的RAM消耗。</a></p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="6820" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="e39b" class="pw-post-body-paragraph jx jy it jz b ka ma kc kd ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku im bi translated">本文中的讨论涵盖了RxJava的基础知识。RxJava示例强调了使用库的关键组件，即创建数据源、创建消费者代码，以及将消费者连接到数据源以启动流/流。关于RxJava，还有很多值得探索的地方。首先，<strong class="jz iu">可流动的</strong>可能并不总是首选的数据源。例如，在显示待办事项列表的待办事项应用程序中，使用单个<strong class="jz iu">源更有意义，该源只发出一个完整的待办事项列表，或者在获取待办事项列表时出错时发出一个错误。我还暗示了可以在源和消费者之间转换流项目的操作符。存在很多运营商，你可以在这里了解更多关于他们的<a class="ae my" href="https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators" rel="noopener ugc nofollow" target="_blank">。</a></strong></p><p id="f330" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您使用过LiveData(来自Android Architecture Components ), rx Java就可以派上用场，因为与向LiveData对象发送值所需的时间相比，处理和向用户显示一些信息需要很长时间。这是因为RxJava与LiveData不同，它支持背压。</p><p id="cbb6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是RxJava的基础，如果您需要了解更多，下面的资源可能值得您花费时间。黑客快乐！</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="c37f" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">进一步阅读</h1><ol class=""><li id="e893" class="mz na it jz b ka ma ke mb ki ob km oc kq od ku ne nf ng nh bi translated"><a class="ae my" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank">反动宣言</a></li><li id="e67e" class="mz na it jz b ka ni ke nj ki nk km nl kq nm ku ne nf ng nh bi translated"><a class="ae my" href="https://github.com/ReactiveX/RxJava/wiki/How-To-Use-RxJava" rel="noopener ugc nofollow" target="_blank">如何使用RxJava </a></li></ol></div></div>    
</body>
</html>