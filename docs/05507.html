<html>
<head>
<title>An Alternative Approach to BDD in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中BDD的另一种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-alternative-approach-to-bdd-in-go-776bbbc24be9?source=collection_archive---------3-----------------------#2020-09-04">https://levelup.gitconnected.com/an-alternative-approach-to-bdd-in-go-776bbbc24be9?source=collection_archive---------3-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3ff47dc6f8475ce7b12d5c2dd5a440d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WASKJZHsOWiNMWXJ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</figcaption></figure><p id="f239" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我是TDD的忠实粉丝。BDD对我来说总是有点难以捉摸，我希望我能更经常地使用它。然而，我似乎总是最终难以通过BDD来表达相同的细微差别，而这些细微差别通过标准测试用例来表达是轻而易举的。</p><p id="5350" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说实话，我已经有一段时间没碰BDD了。然而，这个问题最近一直在我脑海里蹦蹦跳跳:</p><p id="cca3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">为什么通过BDD来表达简单的系统常常如此困难？</strong></p><p id="0bc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于代码的测试非常擅长描述我们如何完成一项任务。BDD非常擅长描述一个任务想要达到的目标。想了想，我得出结论，根本问题是<em class="le">状态</em>:</p><blockquote class="lf lg lh"><p id="41f5" class="kg kh le ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">DD在像我们用代码那样访问和描述状态方面做得不好。因此，在描述算法和底层功能的行为时，抽象鸿沟变得太大了。</p></blockquote><h1 id="df8e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">简单的例子</h1><p id="809f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">让我们考虑一个简单的银行账户的例子。测试如下:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="286e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们在BDD中表达相同行为的一种方式:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d7ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两种方法都没有本质上的错误。然而，细节决定成败。这是一个非常简单、直接的例子，但是我已经能感觉到抽象的鸿沟让我离代码太远了。</p><p id="84dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着测试变得越来越复杂(我真正谈论的是增加状态的数量)，用语言表达变得越来越困难。最终，语言变得比代码本身更难理解。</p><h1 id="af03" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">以前的方法</h1><p id="536e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">BDD场景在管理状态方面做得不太好，因为描述步骤的语言和步骤实现可能想要/需要的变量之间存在脱节。我看到了解决这个问题的两种主要方法:</p><h2 id="b9c0" class="mu lm it bd ln mv mw dn lr mx my dp lv kr mz na lz kv nb nc md kz nd ne mh nf bi translated">将步骤直接保存为代码，并依赖于变量的范围</h2><p id="7837" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">一些以这种方式工作的框架有<a class="ae kf" href="https://onsi.github.io/ginkgo/#adding-specs-to-a-suite" rel="noopener ugc nofollow" target="_blank">银杏</a>和<a class="ae kf" href="https://chromium.googlesource.com/external/github.com/smartystreets/goconvey/+/1.2/README.md#quick-start" rel="noopener ugc nofollow" target="_blank"> GoConvey </a>。我不想说这是一个糟糕的方法。我过去曾广泛使用银杏，最终这感觉就像是嵌套的测试。个人感觉并没有把行为和实现分开。不过，这是描述场景步骤的更好方式。</p><h2 id="2b18" class="mu lm it bd ln mv mw dn lr mx my dp lv kr mz na lz kv nb nc md kz nd ne mh nf bi translated">代码生成器</h2><p id="db1e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">godog T2框架就是一个很好的例子。它获取实际的cucumber特性文件并生成一堆空函数，您可以将您的实现放入其中。我个人没有使用过godog，但是我在Ruby上使用cucumber的时候就非常熟悉这种方法。</p><p id="1c21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为当在代码之外读取或维护特性文件时，这是一个很好的方法。这对于首先需要高度抽象的自动化和流程来说非常有效。然而，这并没有真正解决我的问题，我想在我的系统中使用BDD来处理底层的东西。</p><h1 id="36c0" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">另一种方法</h1><p id="162b" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这两种策略当然都有优点(毫无疑问，我还没见过更多的优点)，这取决于哪种策略最适合您的工作流程。对我来说，我想要一些对我传统上用单元测试做的事情有效的东西。或者，至少探索一下这可能是什么样子。</p><p id="04aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我首先要澄清的是，这些例子还没有经过大型代码库的测试，所以我不能告诉你长期的细微差别和问题，但这些是我的初步想法。</p><p id="ea47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将首先向您展示整个框架:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b272" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，真的那么轻。事实上，这只是用类似小黄瓜的方式编写步骤的一点语法糖。</p><p id="6a0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，回到我们的银行账户例子:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="410a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用这个框架来表达这两个场景:</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3fc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里运行<a class="ae kf" href="https://play.golang.org/p/e77rqeSqQ0g" rel="noopener ugc nofollow" target="_blank">的例子</a>。它分为三个部分:</p><ol class=""><li id="08cf" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated"><strong class="ki iu">状态</strong>(这是顶部的三个变量)。这些由所有步骤共享，甚至可以用作步骤本身的输入。</li><li id="b6e9" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated"><strong class="ki iu">步骤</strong>是作为场景可重用部分的函数或闭包。</li><li id="7fe0" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">底部的<strong class="ki iu">场景</strong>成为命名的子测试。</li></ol><p id="ac8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我建议仍然使用像<a class="ae kf" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">verify</a>这样的测试框架来测试断言和其他特性。</p><p id="d7b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢这个解决方案的原因是:</p><ol class=""><li id="dd86" class="ng nh it ki b kj kk kn ko kr ni kv nj kz nk ld nl nm nn no bi translated">它不依赖于任何运行时魔法，因此您可以从编译器那里获得更好的理解和保护。</li><li id="7540" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">没有外部工具、文件或任何好的ol' <code class="fe nu nv nw nx b">go test</code>以外的东西。每个场景都是一个子测试，您可以在详细的输出中看到这一点——如果您对这类事情感兴趣的话。</li><li id="afc2" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">我觉得我以一种合理的方式将场景从步骤的实现中分离出来。</li></ol><h1 id="285b" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">警告</h1><ol class=""><li id="9e03" class="ng nh it ki b kj mj kn mk kr ny kv nz kz oa ld nl nm nn no bi translated">除了几个微不足道的例子之外，这是完全未经检验的。我不知道更复杂的设置会有多有效。如果这看起来像是你想尝试的东西，我很想知道这对你是否有效。</li><li id="8286" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">尽管每个场景都作为单独的测试运行，但是场景不能并行运行，并且在设置结构时需要小心，以便测试不会相互影响。如果你想在场景之间保持状态，这实际上可能是一个积极的方面。</li><li id="844d" class="ng nh it ki b kj np kn nq kr nr kv ns kz nt ld nl nm nn no bi translated">步骤闭包中使用的变量需要通过引用传递(即使它们已经是指针)。这是一个很小的缺点，但是值得注意。</li></ol></div></div>    
</body>
</html>