<html>
<head>
<title>JavaScript Problem Solvers: Minimum Time Visiting All Points</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题解决者:访问所有点的最短时间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problem-solvers-minimum-time-visiting-all-points-bd9122929ce2?source=collection_archive---------9-----------------------#2020-08-16">https://levelup.gitconnected.com/javascript-problem-solvers-minimum-time-visiting-all-points-bd9122929ce2?source=collection_archive---------9-----------------------#2020-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f22" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">案例011:斜面上的蛇</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea1c214895a99795aa32b0869812c6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YmdYYrkiojhQGpYresvBQ.png"/></div></div></figure><p id="77f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我似乎陷入了一个嵌套数组、矩阵和模式匹配的网络。今天的问题不像上周的洋葱交换那样复杂，但从技术上讲，仍然涉及矩阵。从技术上来说，我们是在处理一个图表，但同时，我们不是。</p><p id="8fa1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我也一直在努力提高我的递归技能。我一直在练习的方法之一是回到我已经解决的问题，用递归重构它们。所以，在这篇博客的最后，我也将提供一个使用尾部调用递归的解决方案。</p><p id="68d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管怎样，让我们开始解决。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="4e59" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">问题是</h2><p id="c07e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><a class="ae mv" href="https://leetcode.com/problems/minimum-time-visiting-all-points/submissions/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">这里是LeetCode </strong> </a>上问题的链接</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="3c5b" class="lx ly it mx b gy nb nc l nd ne">On a plane there are n points with integer coordinates points[i] = [xi, yi]. </span><span id="f471" class="lx ly it mx b gy nf nc l nd ne">Your task is to find the minimum time in seconds to visit all points.</span><span id="e5d3" class="lx ly it mx b gy nf nc l nd ne">You can move according to the next rules:<br/>- In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second).<br/>- You have to visit the points in the same order as they appear in the array.</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a36348eebf5248de194c49b56c811c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*X1JcmRJDsZK8Xs-HuTf1Vw.png"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="165e" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">制约因素</h2><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2754" class="lx ly it mx b gy nb nc l nd ne">points.length == n</span></pre><p id="2340" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这实际上不是一个必要的约束，但是为下一个约束提供了一个定义。<code class="fe nh ni nj mx b">n</code>只在问题的解释中使用，其他地方不使用。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="4f12" class="lx ly it mx b gy nb nc l nd ne">1 &lt;= n &lt;= 100</span></pre><p id="4e23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们得到了一个我们应该期望多少组点的范围，下限为1，上限为100。这告诉我们不必担心给定的数组是空的。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="344b" class="lx ly it mx b gy nb nc l nd ne">points[i].length == 2</span></pre><p id="905a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到一个静态值，它表示每组点将有多少个元素。每组点，或者说<code class="fe nh ni nj mx b">points[i]</code>，应该有一个<code class="fe nh ni nj mx b">x</code>值和<code class="fe nh ni nj mx b">y</code>值，或者说<code class="fe nh ni nj mx b">[x, y]</code>或者<code class="fe nh ni nj mx b">points[i][x, y]</code>。我们可以使用这些信息来避免在我们的解决方案中嵌套迭代。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="293f" class="lx ly it mx b gy nb nc l nd ne">-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</span></pre><p id="d82e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这给了我们坐标平面的大小，以及我们期望看到任何点的范围。<code class="fe nh ni nj mx b">points[i][0]</code>是每组点的<code class="fe nh ni nj mx b">x</code>值，<code class="fe nh ni nj mx b">points[i][1]</code>是<code class="fe nh ni nj mx b">y</code>值，这意味着我们需要考虑出现在<code class="fe nh ni nj mx b">[-1000, -1000]</code>到<code class="fe nh ni nj mx b">[1000, 1000]</code>范围内的点。换句话说，整个飞机。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="ee24" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">测试</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="e5f2" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">崩溃了</h2><p id="84cb" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">剖析了我们的约束，观察了测试用例，让我们开始分解问题的解释，并弄清楚我们需要做什么:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="7b6f" class="lx ly it mx b gy nb nc l nd ne">On a plane there are n points with integer coordinates points[i] = [xi, yi].</span></pre><p id="a7b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是问题的背景。<code class="fe nh ni nj mx b">n</code>(或<code class="fe nh ni nj mx b">points.length</code>)是二维图形(坐标平面)上的一组点，<code class="fe nh ni nj mx b">points[i]</code>代表每组点。<code class="fe nh ni nj mx b">points[i]</code>的元素是每个点的<code class="fe nh ni nj mx b">x</code>和<code class="fe nh ni nj mx b">y</code>位置，<code class="fe nh ni nj mx b">points[i][0]</code>是<code class="fe nh ni nj mx b">x</code>位置，<code class="fe nh ni nj mx b">points[i][1]</code>是<code class="fe nh ni nj mx b">y</code>位置。由于约束<code class="fe nh ni nj mx b">points[i].length == 2</code>，我们可以为<code class="fe nh ni nj mx b">x</code>和<code class="fe nh ni nj mx b">y</code>使用静态值。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="86b1" class="lx ly it mx b gy nb nc l nd ne">Your task is to find the minimum time in seconds to visit all points.</span></pre><p id="89e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，这是我们的任务。我们只需找到每组点之间的最短距离，从<code class="fe nh ni nj mx b">points[0]</code>开始，到<code class="fe nh ni nj mx b">points[points.length - 1]</code>结束。我说距离是因为我们在坐标平面上每秒只能移动1个单位。在下面的规则中，我们得到了更多关于时间如何与这个问题相关的信息。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="77c1" class="lx ly it mx b gy nb nc l nd ne">In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second).</span></pre><p id="3af7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么时间和距离是相对可互换的。速度是固定值1。我们一次只能遍历坐标平面的一个点。</p><p id="a4cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在两点之间沿对角线移动相当于同时增加或减少<code class="fe nh ni nj mx b">points[i][0]</code>和<code class="fe nh ni nj mx b">points[i][1]</code>。水平移动等于只递增/递减<code class="fe nh ni nj mx b">points[i][0]</code>，垂直移动等于<code class="fe nh ni nj mx b">incrementing/decrementing points[i][1]</code>。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="1b24" class="lx ly it mx b gy nb nc l nd ne">You have to visit the points in the same order as they appear in the array.</span></pre><p id="bd00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个比其他任何东西都更大的限制。它告诉我们，当索引时，我们必须遍历<code class="fe nh ni nj mx b">points</code>中的元素。我们必须从头开始，一直走到最后。</p><p id="3a40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们一次只能移动1点，我们需要比较<code class="fe nh ni nj mx b">points[i]</code>和<code class="fe nh ni nj mx b">points[i + 1]</code>。我们严格处理相邻对。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="51d5" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">嫌疑犯</h2><p id="e0af" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">基于对问题的解释和我们通过分解每个部分获得的额外信息，我提出了我们需要做的6件事:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="8955" class="lx ly it mx b gy nb nc l nd ne">1.) Iterate from 0 until i &lt; points.length — 1</span></pre><p id="3c02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是基本设置。我们需要使用一个<code class="fe nh ni nj mx b">for</code>循环并遍历整个点集，这样我们就可以访问相对于<code class="fe nh ni nj mx b">i</code>的下一个点集。我们需要将上限设置为<code class="fe nh ni nj mx b">points.length - 1</code>，因为我们将访问<code class="fe nh ni nj mx b">i</code>的下一个相邻元素。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="370a" class="lx ly it mx b gy nb nc l nd ne">2.) Find the distance between points[i][0] and points[i + 1][0]</span></pre><p id="1d97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们可以对角移动，我们需要找到两组相邻点之间的最大差异。对于x轴，这是<code class="fe nh ni nj mx b">points[i][0]</code>和<code class="fe nh ni nj mx b">points[i + 1][0]</code>之间的差值。</p><p id="4657" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，我们可能会遇到一个问题。如果<code class="fe nh ni nj mx b">points[i + 1][0]</code>的值大于<code class="fe nh ni nj mx b">points[i][0]</code>，我们将得到一个负的差值。我们不想那样。但是，我们可以通过找到<code class="fe nh ni nj mx b">points[i][0]</code>和<code class="fe nh ni nj mx b">points[i + 1][0]</code>之差的绝对值来解决这个问题。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="311e" class="lx ly it mx b gy nb nc l nd ne">3.) Find the distance between points[i][1] and points[i + 1][1]</span></pre><p id="b357" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与步骤2相同，但针对的是每组点的<code class="fe nh ni nj mx b">y</code>值。我们在步骤2中所做的一切都可以重新应用到步骤3中。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="c22e" class="lx ly it mx b gy nb nc l nd ne">4.) Find the maximum of each difference</span></pre><p id="6406" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将<code class="fe nh ni nj mx b">points[i][0]</code>和<code class="fe nh ni nj mx b">points[i + 1][0]</code>之差的绝对值设置为超出范围的变量<code class="fe nh ni nj mx b">xDist</code>。我们可以对<code class="fe nh ni nj mx b">points[i][1]</code>和<code class="fe nh ni nj mx b">points[i + 1][1]</code>之差的绝对值做同样的处理，并将结果设置为另一个超出范围的变量<code class="fe nh ni nj mx b">yDist</code>。</p><p id="8aeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以比较<code class="fe nh ni nj mx b">xDist</code>和<code class="fe nh ni nj mx b">yDist</code>的值，找出哪个更大。</p><p id="7c95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们可以对角移动，唯一重要的是我们需要纯粹水平或垂直走多少步。如果<code class="fe nh ni nj mx b">points[i][0] === points[i][1]</code>，我们可以在两点之间旅行的整个时间内一直走对角线，差异并不重要。但是一旦<code class="fe nh ni nj mx b">points[i][0] !== points[i][1]</code>开始，我们将需要至少水平或垂直移动一次，而不要对角移动。这就是为什么<code class="fe nh ni nj mx b">x</code>和<code class="fe nh ni nj mx b">y</code>值之间的最大差值也代表两点之间的最小距离。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="fac2" class="lx ly it mx b gy nb nc l nd ne">5.) Add the maximum difference of each pair to the total</span></pre><p id="a7a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们比较了<code class="fe nh ni nj mx b">xDist</code>和<code class="fe nh ni nj mx b">yDist</code>并发现哪个更大，我们就可以把它加到总距离变量<code class="fe nh ni nj mx b">totalDist</code>中。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="3fef" class="lx ly it mx b gy nb nc l nd ne">6.) Return the total amount of distance between each set of points.</span></pre><p id="7ae2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们迭代了整组点，找到了每组点的差值的绝对值，找到了最大差值并将最大差值加到总距离上，<code class="fe nh ni nj mx b">totalDist</code>应该等于访问所有点的最小时间，我们可以<code class="fe nh ni nj mx b">return</code> <code class="fe nh ni nj mx b">totalDist</code>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="d072" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">伪代码</h2><p id="c58b" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们采取我们列出的6个步骤，并将其浓缩成一些更容易理解的伪代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="220d" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">代码</h2><p id="39a4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们的伪代码看起来不错，让我们开始写一个解决方案。</p><p id="9532" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们定义三个变量<code class="fe nh ni nj mx b">xDist</code>、<code class="fe nh ni nj mx b">yDist</code>和<code class="fe nh ni nj mx b">totalDist</code>。然后，设置<code class="fe nh ni nj mx b">for</code>循环的基础:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c1ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们可以添加逻辑来将<code class="fe nh ni nj mx b">xDist</code>和<code class="fe nh ni nj mx b">yDist</code>重新分配给每组点的<code class="fe nh ni nj mx b">x</code>和<code class="fe nh ni nj mx b">y</code>值的绝对差值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="15d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在每次迭代结束时，我们可以将<code class="fe nh ni nj mx b">xDist</code>和<code class="fe nh ni nj mx b">yDist</code>的最大值加到<code class="fe nh ni nj mx b">totalDist</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a865" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，添加我们的<code class="fe nh ni nj mx b">totalDist</code>的<code class="fe nh ni nj mx b">return</code>值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5ed3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们针对3个测试用例运行我们的解决方案，我们应该可以毫无问题地通过所有测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/9056c9372512165187af059179084b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*yp0QbknvoeWiIoRR90C5Bg.png"/></div></figure><p id="2c90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="c183" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">递归</h2><p id="383e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">正如所承诺的，这里是我们使用尾部调用优化的解决方案的递归版本。我不会在这里讲太多细节，因为递归是另一个棘手的问题，但是我会概述一些我们必须要做的基本重构。</p><p id="ab1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以设置我们的基本情况等于我们的<code class="fe nh ni nj mx b">for</code>循环的上限。当我们遇到基本情况时，我们希望:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e102" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们要使用3个变量来跟踪距离(<code class="fe nh ni nj mx b">xDist</code>、<code class="fe nh ni nj mx b">yDist</code>、<code class="fe nh ni nj mx b">totalDist</code>)，将它们添加到函数的参数中，并将它们的默认值设置为0。我们还想添加默认值为0的<code class="fe nh ni nj mx b">i</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b1e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们要<code class="fe nh ni nj mx b">return</code>我们的递归<code class="fe nh ni nj mx b">function</code>调用。因为我们想要使用尾部调用递归，所以我们需要确保我们没有在每次递归调用时创建新的本地执行上下文。我们可以通过更新递归调用参数中的每个变量来做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9977" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们对我们的3个测试用例运行我们的递归解决方案，我们应该再次通过它们:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/fec5547b21e469d119c68f4337df6cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IXMeM1HBUkQ_67ooq6xJg.png"/></div></div></figure><p id="02b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="a968" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">最终解决方案</h2><p id="92e1" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们最后看一下不带注释的解决方案，并清理一些语法:</p><p id="6721" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">非递归:</p><p id="920b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mv" href="https://leetcode.com/submissions/detail/379052930/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> LeetCode提交明细</strong> </a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f182" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">递归:</p><p id="097b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mv" href="https://leetcode.com/submissions/detail/381828155/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> LeetCode提交明细</strong> </a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6d7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来递归解决方案要快一点。有意思。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="026d" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">任务完成</h2><p id="5213" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">虽然<code class="fe nh ni nj mx b">minTimeToVisitAllPoints</code>不是最复杂的问题，但我觉得我们提出的解决方案足够有趣，值得分享，用尾部调用递归重构它也足够有趣。</p><p id="dfdd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">递归可能是一个很难解决的话题，对我来说仍然有点神秘，所以我认为在每个博客中加入一点递归(如果适用的话)对我来说是一个练习和提高的好方法。</p><p id="3749" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我当然明白我的解决方案不会是最好的或最有效的，但不管怎样，我希望它们能帮助你或其他人找到一种方法来解决你在这个旅程中遇到的问题，我们称之为JavaScript。</p><p id="b85d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管怎样，我希望你得到了一些有用的信息，希望你所有的函数都返回true，所有的请求都用200来响应。</p><p id="2edb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保持安全…保持健康…继续为正义而战。</p></div></div>    
</body>
</html>