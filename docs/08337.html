<html>
<head>
<title>Building Gradle Tasks with Kotlin DSL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin DSL构建梯度任务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-gradle-tasks-with-kotlin-dsl-342d4c2e4bd7?source=collection_archive---------3-----------------------#2021-04-22">https://levelup.gitconnected.com/building-gradle-tasks-with-kotlin-dsl-342d4c2e4bd7?source=collection_archive---------3-----------------------#2021-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="23e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解gradle和任务生命周期的好处。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66d6c3ca8c2497c7ebe697946eed44c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z5j5woQwOh1tZb6H.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank">gradle.org</a></figcaption></figure><p id="dbab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">你知道是什么让软件工程成为现代世界最酷的职业之一吗？<strong class="lb iu">我们造东西</strong>，而且我们造东西<strong class="lb iu">快</strong>——或者至少<strong class="lb iu">那是我们想要的</strong>。不幸的是，软件工程师经常被日常任务耽误，比如配置、构建和运行他们的应用程序。Shell脚本可能变得特定于团队，如果使用不当，构建自动化工具可能会变得很麻烦。</p><p id="1a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将强调用Kotlin领域特定语言(DSL)实现Gradle任务的基本方法。在深入Gradle任务系统之前，我们将介绍Gradle对以前的自动化工具(如Ant)所做的改进。</p><blockquote class="me mf mg"><p id="94c7" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated"><em class="it">这篇文章可以带你从没有梯度知识到能够建立你自己的功能任务。</em></p></blockquote><p id="b0c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>本教程不包括安装gradle或初始化项目等基本步骤。你可以在<a class="ae ky" href="https://gradle.org/install/" rel="noopener ugc nofollow" target="_blank"> Gradle安装文档中找到更多信息。</a></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="2fc3" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">格拉德vs蚂蚁</h1><p id="0a08" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Gradle将自己定位为一个非常灵活的构建自动化工具，具有可重用的任务结构，用于高效的构建过程。</p><p id="b1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不相信我？在实现Gradle任务之前，让我们来比较一下它的语法和它曾经的前身——Ant。一个简单的<strong class="lb iu">Ant构建文件可能是这样的:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">都是XML格式的，恶心！正如您所看到的，标准的Ant构建文件极其冗长，这为可读性付出了巨大的代价。让我们看一个简单的Gradle构建文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使你从未见过Gradle，你也可以从这个例子中得到大概的意思。<code class="fe nr ns nt nu b">plugins</code>块包括附加功能的包，<code class="fe nr ns nt nu b">dependencies</code>包括你的项目需求，<code class="fe nr ns nt nu b">repositories</code>告诉你从哪里得到<code class="fe nr ns nt nu b">dependencies</code>，而<code class="fe nr ns nt nu b">task</code>是一些要执行的动作。很干净，是吧？</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="8c02" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">用Kotlin构建Gradle任务</h1><p id="cb4f" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Gradle使用两种语言作为构建脚本，Groovy和Kotlin。<strong class="lb iu"> Groovy </strong>(上面的前一个例子)已经成为<strong class="lb iu">标准</strong>很多年了，网上有很多例子。Kotlin 是一个较新的附加功能，作为一种<strong class="lb iu">类型语言</strong>有额外的好处。这允许对您的任务对齐进行更多的控制，以及对更高效开发的IDE支持。</p><p id="be4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于Gradle的Kotlin DSL与一些Groovy语法成对工作。Gradle保留了Groovy的一些关键字，同时允许完整的Kotlin编程能力。让我们看看代码。</p><h2 id="9d5b" class="nv mt it bd mu nw nx dn my ny nz dp nc li oa ob ne lm oc od ng lq oe of ni og bi translated">运行简单的Gradle任务</h2><p id="7b26" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这里有一个用Kotlin写的简单的Gradle任务。如果您在IntelliJ中启动了一个新的Gradle项目，您可以删除根目录中的<code class="fe nr ns nt nu b">build.gradle</code>并用<code class="fe nr ns nt nu b">build.gradle.kt</code>替换它——其中扩展名代表Kotlin脚本。现在，您可以用不到5行代码创建一个基本的Gradle任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bfed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用<code class="fe nr ns nt nu b">tasks.register()</code>向Gradle注册一个任务，同时给该任务命名为<code class="fe nr ns nt nu b">“hello”</code>。然后我们调用<code class="fe nr ns nt nu b">doLast{}</code>，这是<strong class="lb iu"> Gradle lifecycle </strong>的一部分，我们将在接下来展开。除此之外，我们称之为简单的打印语句。</p><p id="a5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在项目的根目录下打开一个终端并运行<code class="fe nr ns nt nu b">gradle hello</code>来执行上面的任务。</p><pre class="kj kk kl km gt oh nu oi oj aw ok bi"><span id="627b" class="nv mt it nu b gy ol om l on oo">$ gradle hello</span><span id="0a7b" class="nv mt it nu b gy op om l on oo">&gt; Task :hello<br/>Hello Gradle</span><span id="b1fd" class="nv mt it nu b gy op om l on oo">BUILD SUCCESSFUL in 510ms<br/>1 actionable task: 1 executed</span></pre><p id="f816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以运行命令<code class="fe nr ns nt nu b">gradle tasks</code>,它将列出项目中所有可用的任务及其基本描述。</p><h2 id="2b84" class="nv mt it bd mu nw nx dn my ny nz dp nc li oa ob ne lm oc od ng lq oe of ni og bi translated">运行梯度构建</h2><p id="cfa7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果你有一个标准构建的Java或Kotlin项目，你可以运行<code class="fe nr ns nt nu b">gradle build</code>来运行一组预定义的任务，这些任务内置于Gradle中，以便编译、构建和测试你的项目。这里有一个用Kotlin编写的简单hello world示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c2b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您第一次运行gradle build，您将得到类似如下的输出:</p><pre class="kj kk kl km gt oh nu oi oj aw ok bi"><span id="5353" class="nv mt it nu b gy ol om l on oo">$ gradle build</span><span id="ef90" class="nv mt it nu b gy op om l on oo">BUILD SUCCESSFUL in 645ms<br/>3 actionable tasks: 3 up-to-date</span></pre><p id="2d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以运行带有<code class="fe nr ns nt nu b">-i</code>标志的命令来获得更多信息。这将向我们显示所有正在运行的任务，但是这里我们只检查<code class="fe nr ns nt nu b">compileKotlin task</code>。如果您已经运行了<code class="fe nr ns nt nu b">gradle build</code>，您会看到任务被缓存了。</p><pre class="kj kk kl km gt oh nu oi oj aw ok bi"><span id="2eef" class="nv mt it nu b gy ol om l on oo">$ gradle -i build</span><span id="2adb" class="nv mt it nu b gy op om l on oo">. . . . . .</span><span id="2db1" class="nv mt it nu b gy op om l on oo">&gt; Task :compileKotlin UP-TO-DATE<br/>Build cache key for task ':compileKotlin' is f8831c991f078512392cf3ac3fc0c63e<br/>Skipping task ':compileKotlin' as it is up-to-date.</span></pre><p id="9d3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将Kotlin <code class="fe nr ns nt nu b">main()</code>方法改为打印Hello World，那么再次运行<code class="fe nr ns nt nu b">gradle -i build</code>将显示文件已经更改，我们将运行compileKotlin任务。</p><pre class="kj kk kl km gt oh nu oi oj aw ok bi"><span id="5b8a" class="nv mt it nu b gy ol om l on oo">$ gradle -i build</span><span id="744e" class="nv mt it nu b gy op om l on oo">. . . . . .</span><span id="6de1" class="nv mt it nu b gy op om l on oo">&gt; Task :compileKotlin<br/>Build cache key for task ':compileKotlin' is 374fd90fedd6a3acea0979619cc2adb4<br/>Task ':compileKotlin' is not up-to-date because:<br/>  Input property 'source' file /Users/israelmiles/Sandbox/gradle-kotlin-demo/src/main/kotlin/hello.kt has changed.</span></pre><blockquote class="me mf mg"><p id="c679" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated">这个缓存特性是Gradle如此受欢迎的部分原因。  <em class="it">如果一个任务已经被证明是成功的，我们就不需要再运行它了。Gradle将存储任何生成的jar文件或依赖项，以便在以后的任务中使用。这使得</em> <strong class="lb iu"> <em class="it">保持构建时间最小的高效过程成为可能。</em>T19】</strong></p></blockquote><h2 id="9436" class="nv mt it bd mu nw nx dn my ny nz dp nc li oa ob ne lm oc od ng lq oe of ni og bi translated">这是生命周期的循环</h2><p id="d8c2" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Gradle build文件生命周期有三个阶段— <strong class="lb iu">初始化、配置和执行</strong>。初始化阶段可以在<code class="fe nr ns nt nu b">settings.gradle.kts</code>进行。配置阶段在任务内部或外部的构建脚本中。执行阶段发生在<code class="fe nr ns nt nu b">doFirst</code>或<code class="fe nr ns nt nu b">doLast</code>块的最后。</p><p id="b415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将关键字<code class="fe nr ns nt nu b">doFirst</code>和<code class="fe nr ns nt nu b">doLast</code>视为添加到Gradle构建序列的命令的<strong class="lb iu">队列</strong> <strong class="lb iu">的<strong class="lb iu">前端</strong>或<strong class="lb iu">后端</strong>。让我们来看看实际的生命周期。首先向<code class="fe nr ns nt nu b">settings.gradle.kts</code>添加一条打印语句(如果文件不存在，只需将其添加到项目根文件夹中):</strong></p><pre class="kj kk kl km gt oh nu oi oj aw ok bi"><span id="9931" class="nv mt it nu b gy ol om l on oo">rootProject.name = "gradle-kotlin-demo"<br/>println("This is executed during the initialization phase.")</span></pre><p id="b507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在<code class="fe nr ns nt nu b">build.gradle.kts</code>中调用配置和执行阶段。可以立即调用配置阶段。每次您调用<code class="fe nr ns nt nu b">doFirst</code>时，您都将该命令添加到队列的最前面。如果您调用<code class="fe nr ns nt nu b">doLast</code>，我们会将该命令添加到队列的末尾。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行gradle倒计时任务将向我们展示我们的生命周期是有序的:</p><pre class="kj kk kl km gt oh nu oi oj aw ok bi"><span id="521c" class="nv mt it nu b gy ol om l on oo">$ gradle countdown<br/>This is executed during the initialization phase.<br/>This is the configuration phase</span><span id="d970" class="nv mt it nu b gy op om l on oo">&gt; Task :countdown<br/>This is the execution phase<br/>4<br/>3<br/>2<br/>1</span><span id="dddf" class="nv mt it nu b gy op om l on oo">BUILD SUCCESSFUL in 1s<br/>1 actionable task: 1 executed</span></pre><h2 id="ad38" class="nv mt it bd mu nw nx dn my ny nz dp nc li oa ob ne lm oc od ng lq oe of ni og bi translated">建立任务相关性</h2><p id="e290" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">随着您的项目变得越来越复杂，您可能会遇到这样的情况:在调用后续任务之前，您<strong class="lb iu">需要完成某些任务。这可以通过使用<code class="fe nr ns nt nu b">dependsOn()</code> Groovy关键字告诉Gradle哪些任务需要在当前任务之前执行来轻松实现。这里有一个例子:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8e70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以单独运行独立任务——但是如果我们执行依赖任务，我们将首先调用独立任务。</p><pre class="kj kk kl km gt oh nu oi oj aw ok bi"><span id="6dde" class="nv mt it nu b gy ol om l on oo">$ gradle dependent<br/>This is executed during the initialization phase.</span><span id="005c" class="nv mt it nu b gy op om l on oo">&gt; Task :independent<br/>This is the independent task</span><span id="c5aa" class="nv mt it nu b gy op om l on oo">&gt; Task :dependent<br/>This is the dependent task</span><span id="94e7" class="nv mt it nu b gy op om l on oo">BUILD SUCCESSFUL in 1s<br/>2 actionable tasks: 2 executed</span></pre><blockquote class="me mf mg"><p id="be91" class="kz la mh lb b lc ld ju le lf lg jx lh mi lj lk ll mj ln lo lp mk lr ls lt lu im bi translated"><em class="it">这些只是</em><strong class="lb iu"><em class="it"/></strong><em class="it"/><strong class="lb iu"><em class="it"/></strong><em class="it">的语法</em><strong class="lb iu"><em class="it"/></strong><em class="it"/><strong class="lb iu"><em class="it">的渐变任务。</em> </strong> <em class="it">进一步的配置可以让您的任务</em> <strong class="lb iu"> <em class="it">扩展您的项目的功能</em> </strong> <em class="it">除了</em> <strong class="lb iu"> <em class="it">自动化项目构建流程</em> </strong> <em class="it">。在这里，我们已经开始了解使用Kotlin DSL的Gradle任务的基础，这是将Gradle作为您自己项目的一部分的第一步！</em></p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="7754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是Gradle生态系统的一小部分。Gradle <strong class="lb iu"> plugins </strong>也可以用来将预构建的任务功能添加到您的项目中。你也可以创建你自己的<strong class="lb iu">定制插件</strong>来进一步重用。不仅如此，Gradle还有很棒的<strong class="lb iu">依赖管理</strong>、<strong class="lb iu">多项目构建配置</strong>以及管理你的项目<strong class="lb iu">测试过程</strong>。</p><p id="5c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想阅读更多关于这些话题的内容，请在下面留下评论！如果你喜欢这篇文章的任何部分，或者想知道更多的细节，我也非常希望听到你的想法。:-)感谢阅读！</p></div></div>    
</body>
</html>