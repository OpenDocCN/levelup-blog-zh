<html>
<head>
<title>Validation using the Chain of Responsibility Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用责任链模式进行验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/validation-using-the-chain-of-responsibility-pattern-236a6ded7078?source=collection_archive---------0-----------------------#2020-05-19">https://levelup.gitconnected.com/validation-using-the-chain-of-responsibility-pattern-236a6ded7078?source=collection_archive---------0-----------------------#2020-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/27261efaacb19446b50051e3c404cca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zv99SMd32F8wNzXr6FnR2g.jpeg"/></div></div></figure><p id="4faf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">责任链模式是软件工程中最有用的设计模式之一。至少在我的经验中，这也是最少实现的方法之一。在我参与开发的商业应用程序中，我只在野外遇到过一次——我认为这是一种耻辱。</p><p id="6cd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">责任链模式可以描述为面向对象版本的<em class="kw">if…else if…else…end if</em>blocks；但它远不止于此——它允许甚至鼓励松耦合，这反过来带来了许多好处。</p><p id="7763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了乐趣、利润和更好的代码库，我们可以实现责任链模式的一个地方是验证器。</p><p id="cf93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经很快地(并且相当复杂和肮脏地)收集了一个例子来说明这可能是什么样子。</p><p id="e714" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们得到了一个“插入”一个<em class="kw">汽车模型</em>实例的服务。验证我们将要放入数据库的东西是相当明智的，所以这看起来是一个不错的例子。</p><p id="179c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看可以插入的模型。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/c1a4adaa2e15e3557a3898bbd8bc62c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZdd3SLfoHzIsqQjGZEBPw.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">模型类</figcaption></figure><p id="beff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，一切都很简单。这四个都实现了<em class="kw"> IVehicleModel </em>接口，如下所示，并且具有相同的基本属性。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/42b64218e71c50415732a54dee91c13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bF8l6dlf0oKmSgTwhCtLjg.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">IVehicleModel接口。如果我们真的要实现这个，我们可能会使用一个抽象基类。尽管对于这个例子来说，接口是很好的。</figcaption></figure><p id="b1e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看服务。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/b4911429adfce0ffe8113f64e270762c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kkMkj6xlZynt_M65UUSKdw.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">车辆服务—我们验证然后插入</figcaption></figure><p id="f136" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个服务有一个单独的依赖项——一个<em class="kw"> IVehicleValidator </em>的实例(我们一会儿就会看到它是什么样子)。第9行调用验证器的<em class="kw"> Validate </em>方法，如果模型验证失败，则<em class="kw"> InsertVehicleModel </em>方法返回。出于示例的目的，验证结果被写入控制台。</p><p id="4cb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再说一次——这是非常简单的，我相信这是一个我们都很熟悉的概念。验证输入-如果验证通过，则继续，否则返回。</p><p id="0e5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，<em class="kw"> IVehicleValidator </em>长什么样呢？嗯，看起来是这样的。一个单独的方法<em class="kw"> Validate </em>，它将<em class="kw"> IVehicleModel </em>的一个实例作为其参数，并返回一个<em class="kw">vehicle validation result</em>。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/c6bca6a02dd658f77e7fae1822fd2f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOjsuFeWx4lZWreZtVGMQg.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">简单的IVehicleValidator接口</figcaption></figure><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/2c0d72340809f96724befffa9929b82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CCP9JMGn-mahh_djM7awwg.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">验证结果类</figcaption></figure><p id="aea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">vehicle validation result</em>有一个布尔属性来表示模型是否有效，还有一个消息字符串列表——验证失败的原因。如果我们的实现需要的话，我们可以很容易地用异常来代替字符串。</p><p id="8498" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了——这就是我们的设置。我们有一个服务，一些模型和一些接口。现在我们需要在这些骨头上放些肉。让我们使用责任链实现一个没有的验证器<strong class="ka ir">。下面的代码展示了如何做到这一点——对于这个例子来说有些笨拙。</strong></p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/af66d469ecdcad789bc5cc43596300e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDZSP1ukRloC2YlCCWY40Q.png"/></div></div></figure><p id="8330" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这个验证器需要迎合不同的模型类型，我们有<em class="kw"> if </em>块，它在执行所需的验证之前检查模型的类型。如果我们的执行失败了，因为不支持或意外的类型被传递给了validate方法，就会抛出<em class="kw"> NotImplementedException </em>。</p><p id="7990" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从表面上看，这似乎很好。对于那些永远不会增长或修改的小应用程序来说，可能是这样的。老实说，你开发过多少永远不会增长或修改的小应用程序？</p><p id="0a13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种“整体”方法有一些潜在的问题等待着我们:</p><ul class=""><li id="7055" class="lj lk iq ka b kb kc kf kg kj ll kn lm kr ln kv lo lp lq lr bi translated">可扩展性——当必须支持一个新的模型类型时会发生什么？没错——我们需要修改这个类并重新测试它，因为我们已经修改了这个类，所以我们也需要重新测试依赖于它的任何东西。</li><li id="2a91" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated">可扩展性(再次)——让我们假设这是多租户应用程序的一部分，不同的租户开始为不同类型的车辆改变验证规则。一种可能允许只有<a class="ae lx" href="https://duckduckgo.com/?q=reliant+robin&amp;iax=images&amp;ia=images" rel="noopener ugc nofollow" target="_blank">三个轮子的汽车</a>，另一种可能允许<a class="ae lx" href="https://duckduckgo.com/?q=flintsones+car&amp;iar=images&amp;iax=images&amp;ia=images" rel="noopener ugc nofollow" target="_blank">无引擎汽车</a>。实现这一点意味着要么是每租户验证器，要么是在<em class="kw"> if </em>语句中的一堆<em class="kw"> if </em>语句。两者都不可取。</li><li id="e128" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated">可维护性——对验证器的任何更改都会增加<em class="kw"> Validate </em>方法的圈复杂度，使得维护变得更加困难。新的规则，或者说变化的规则，意味着更多的条件代码。变化意味着更多的测试，以及对任何依赖于它的类的更多测试。</li></ul><p id="4078" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个验证器也违反了<em class="kw">单一责任原则</em>——验证汽车的东西没有验证船的权利。</p><p id="d12d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们使用责任链模式实现一个验证器，我们可以解决这些问题。</p><p id="f239" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步是将验证器分解成单独的验证器，每个验证器负责一个<em class="kw"> IVehicleModel </em>的实现。我们将实现三个，它们都遵循相同的基本模式。下面显示的是<em class="kw">汽车验证器</em>。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/b780ade1db3e168220f454ad9830ba6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aaq7mBMk7j9BkVWTOY_u3w.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">CarValidator类—链中的第一个链接</figcaption></figure><p id="9442" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以看出，该类实现了<em class="kw"> IVehicleValidator </em>，就像单片验证器一样，并使用相同的规则来验证汽车模型。不过还有一些额外的东西。</p><p id="d82f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先是构造函数——我们现在有一个，而不是默认的，它需要一个参数。我们正在形成一个<em class="kw"> </em>链，所以每个环节都需要访问下一个环节。我们将链中的下一个链接传递给每个验证器实例。</p><p id="dc41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，看看第11行到第14行。有一个<em class="kw"> if </em>语句，看起来非常像我们实现的第一个验证器类中的条件。但是有一点不同——如果当前的不负责模型类型，那么责任会传递给下一个验证器，而不是对特定的模型类型进行验证。</p><p id="85e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面显示的是另外两个模型验证器——遵循相同的模式。如果模型不是验证者的责任，那么它将被传递到链中的下一个环节。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/0870b5ef6b765eaeb60154e0259d6360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZiOD1K73oLae-WOiVY52A.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">BikeValidator类</figcaption></figure><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/d97c28d4655cf8c3fff733b0b3021fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euG3zPJy67_2TAPvy0IeQQ.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">BoatValidator类</figcaption></figure><p id="409e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的——这几乎取代了单一的验证器，但是还缺少一样东西。如果一个模型在所有条件下都失败了会发生什么？如果到了链条的末端，没有一个环节承担责任，会发生什么？</p><p id="076f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是下面这个类出现的原因:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/a8f050531dc380451c403cdf8900cf15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eL4dMgouAkdkoxfDqjH-dw.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">NoResultValidator——一种结束我们的链的方法</figcaption></figure><p id="233c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从<em class="kw"> VehicleValidator </em>中替换了<em class="kw"> NotImplementedException </em>，并创建了一个链接，只是为了结束这个链。在这个例子中，除了返回一个<em class="kw">NoResultVehicleValidationResult</em>(命名事物，最难的是软件……)之外，什么都不做。这个“默认”结果如下所示:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lg"><img src="../Images/fc550fd998e8b521ec4ddc5ac87037c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_M_sN3_dimgefqGC95UxA.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">是啊——给东西命名……</figcaption></figure><p id="275f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里什么也看不到…在实际的实现中，我们可能会检查结果类型并输出一些有用的信息到日志中。可能是验证失败消息，也可能是存在无法验证的模型类型。</p><p id="6e14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯——这就是我们的责任链。我们有三个验证器，每个负责一个模型类型，还有一个类结束这个链。</p><p id="1b2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它解决了可维护性问题——每个验证器中的代码要少得多，任何更改都只需要重新测试那个验证器，并且只重构它的单元测试。</p><p id="4b05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它以两种方式解决了可扩展性问题。第一个——即当我们需要验证一个新模型时会发生什么——很容易解释。我们创建一个新的验证器，并将其添加到链中。就是这样。完成了。没有重构其他验证器，也没有大量重写单元测试。</p><p id="d7d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个可扩展性问题——上面描述了多租户应用程序的假设——需要另一个代码片段来解释…</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/3a2f7e7b1226a3201ca2f3ee2d561579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WMtjw1hXGPBL9nfTg1CBg.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">使用Unity创建链。这里有一个与策略模式的交叉，特别是当我们讨论多租户应用程序时</figcaption></figure><p id="1751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们有一种方法可以使用IoC提供者实现验证链(在这个例子中使用了Unity，但是几乎可以使用任何东西)。每个验证器都被注册，每个验证器通过其构造函数接收链中的下一个链接。服务注册到链中的第一个链接，在这个例子中是<em class="kw"> CarValidator </em>。</p><p id="b128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句——如果您在Real Life中实现这一点，您可能希望创建一个工厂来完成这种连接，除非您喜欢大量的IoC配置文件(我真的不喜欢)。</p><p id="4d47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在谈谈多租户应用程序的问题。一方面，有三个轮子的汽车是有效的，另一方面，没有引擎的汽车也是有效的。国际奥委会如何在这方面提供帮助？</p><p id="7c6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上，很简单。</p><p id="a8f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您实现每个租户的IoC配置。这是一个独立的主题，所以我现在不会详细讨论它，但简单地说，这是我如何使用Unity (ymmv和其他提供商)来实现它:</p><ul class=""><li id="1767" class="lj lk iq ka b kb kc kf kg kj ll kn lm kr ln kv lo lp lq lr bi translated">所有常见的注册都是用代码实现的</li><li id="82ae" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated">特定于租户的注册将以XML实现</li><li id="b158" class="lj lk iq ka b kb ls kf lt kj lu kn lv kr lw kv lo lp lq lr bi translated">在运行时，代码将决定加载哪个XML文件，特定于租户的注册将覆盖通用的注册</li></ul><h1 id="26c6" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="07f0" class="pw-post-body-paragraph jy jz iq ka b kb my kd ke kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv ij bi translated">这个简短的、有点笨拙的例子有望展示使用责任链模式可以带来的优势。我们可以编写更干净、更易维护、更易扩展和更可靠的代码，而不需要太多的开销。因为我们使用了多个类，并且需要将链连接在一起，所以需要的引导量会有轻微的增加，但是这对于所获得的收益来说是微不足道的。</p><p id="1185" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例代码是用C#编写的，但是这种模式几乎适用于任何语言——包括弱类型和没有接口概念的语言(JavaScript，我正在看着你)。</p></div></div>    
</body>
</html>