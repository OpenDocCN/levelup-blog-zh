<html>
<head>
<title>How to build your first Micro Frontend with SSR in minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在几分钟内用SSR构建您的第一个微前端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-your-first-micro-frontend-with-ssr-in-minutes-95cd57788529?source=collection_archive---------4-----------------------#2020-04-27">https://levelup.gitconnected.com/how-to-build-your-first-micro-frontend-with-ssr-in-minutes-95cd57788529?source=collection_archive---------4-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b4459ce76ee6c6378c5478017a3246be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cG6997wSY9OD5ozy7hRxVw.jpeg"/></div></div></figure><p id="d29c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当前的趋势是构建一个功能丰富、功能强大的浏览器应用程序，也称为单页应用程序，它位于微服务架构之上。随着时间的推移，前端层(通常由单独的团队开发)会增长，并且变得更加难以维护。这就是我们所说的<a class="ae kz" href="https://www.youtube.com/watch?v=pU1gXA0rfwc" rel="noopener ugc nofollow" target="_blank">前端巨石</a>。几年前，我们在Namecheap面临所有相关的挑战。所以我们决定进一步发展<a class="ae kz" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">微前端</a>。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/a2fa56862ae8f266466693ac1c005c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bYAemxgp0Yh-m3i2"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">Michael Geers @ micro-frodends . org</figcaption></figure><p id="7067" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">目前，我们已经使用3种不同的框架(Vue.js、React &amp; Angular)在生产中运行微前端2年了。实际上namecheap.com的<a class="ae kz" href="https://www.namecheap.com/" rel="noopener ugc nofollow" target="_blank">主页是由几个应用程序组成的。我们现在使用的方法与Zalando在</a><a class="ae kz" href="https://github.com/zalando/tailor" rel="noopener ugc nofollow" target="_blank">裁缝</a>中使用的方法非常相似。我现在不会解释我们当前方法的所有利弊，因为这不是本文的目标🙂重要的是，最近我们决定向前迈出一步&amp;提出一种更加灵活的&amp;性能方法。</p><p id="6c73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们构建了<a class="ae kz" href="https://github.com/namecheap/ilc" rel="noopener ugc nofollow" target="_blank">同构布局生成器(ILC)</a>——一个完整的解决方案，用于将微前端组合到支持SSR的SPA中。别忘了看看GitHub，看看它的所有特性，让我们转向这篇文章的主要目标——创建你的第一个微前端。</p><h1 id="9b67" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我们需要先用SSR反应app</h1><p id="3eaf" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">正如你可能已经猜到的，要构建一个新的微前端，我们首先需要有常规的应用程序。希望我已经为你亲爱的读者做了所有的脏活。</p><p id="46e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以你可以去github.com/StyleT/ilc-learning-react这里拿。或者你可以使用<a class="ae kz" href="https://codesandbox.io/s/github/StyleT/ilc-learning-react" rel="noopener ugc nofollow" target="_blank">codesandbox.io/s/github/StyleT/ilc-learning-react</a>让它在云中为你运行。我建议使用<a class="ae kz" href="https://codesandbox.io/s/github/StyleT/ilc-learning-react" rel="noopener ugc nofollow" target="_blank"> codesandbox.io </a>来消除我们前进过程中可能出现的所有本地环境相关问题。</p><p id="65c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦你启动了这个应用程序，试着玩几局井字游戏😎</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/50f4fbba96a91d5da073b9000681c985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-CN_49Ljqx56-BcX"/></div></div></figure><h1 id="2ebb" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">使应用程序适应ILC</h1><p id="7cd1" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">为了使应用程序与ILC一起正确工作，我们需要使其符合<a class="ae kz" href="https://github.com/namecheap/ilc/blob/cdf6afaa73c3dd7358036ebb0fae3cf0b0ec391f/docs/ilc_app_interface.md" rel="noopener ugc nofollow" target="_blank"> ILC到App接口</a>。幸运的是，这很容易，浏览源代码并解决我为你放置的所有注释。</p><p id="f322" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦你完成这项工作，重启应用程序并尝试打开<code class="fe mn mo mp mq b">/microfrontend</code>路线。你应该得到<code class="fe mn mo mp mq b">200 OK</code>响应代码&amp;一些SSR标记。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/9723eec0e24e163bd882c69a9541abb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EoAheiUaT906456S"/></div></div></figure><blockquote class="ms mt mu"><p id="6d63" class="kb kc mv kd b ke kf kg kh ki kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>:如果有任何问题，请尝试切换到repo中的“step_1-ILC_integration”分支，它已经为您完成了所有更改。</p></blockquote><h1 id="9f88" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">配置ILC以处理新应用程序</h1><p id="0db1" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">在这一步中，我们将使用我们的公共演示网站和"<a class="ae kz" href="https://github.com/namecheap/ilc/blob/cdf6afaa73c3dd7358036ebb0fae3cf0b0ec391f/docs/develop_at_production.md" rel="noopener ugc nofollow" target="_blank">开发“生产”</a> " ILC功能来完成任务。我们这样做只是为了简单起见。然而，您可以使用本地运行的ILC获得非常相同的结果。</p><p id="2617" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让你的新花式微前端工作，我们需要先确定你的<code class="fe mn mo mp mq b"><strong class="kd iu">publicPath</strong></code> &amp; <code class="fe mn mo mp mq b"><strong class="kd iu">ssrPath</strong></code>。</p><h2 id="c228" class="mz lk it bd ll na nb dn lp nc nd dp lt km ne nf lx kq ng nh mb ku ni nj mf nk bi translated">如果你使用codesandbox.io <em class="nl">(推荐方法)</em></h2><ul class=""><li id="c38f" class="nm nn it kd b ke mh ki mi km no kq np ku nq ky nr ns nt nu bi translated">你的<code class="fe mn mo mp mq b">publicPath</code>会有点像<code class="fe mn mo mp mq b">https://abcde.sse.codesandbox.io/public/</code>。检查你的虚拟浏览器的地址栏。</li><li id="2e0a" class="nm nn it kd b ke nv ki nw km nx kq ny ku nz ky nr ns nt nu bi translated">而你的<code class="fe mn mo mp mq b">ssrPath</code>将会是<code class="fe mn mo mp mq b">https://abcde.sse.codesandbox.io/microfrontend</code></li></ul><h2 id="180f" class="mz lk it bd ll na nb dn lp nc nd dp lt km ne nf lx kq ng nh mb ku ni nj mf nk bi translated">如果您在本地运行应用程序</h2><ul class=""><li id="2203" class="nm nn it kd b ke mh ki mi km no kq np ku nq ky nr ns nt nu bi translated">你的<code class="fe mn mo mp mq b">publicPath</code>会是<code class="fe mn mo mp mq b"><em class="mv">http://127.0.0.1:5000/public/</em></code>。</li><li id="3342" class="nm nn it kd b ke nv ki nw km nx kq ny ku nz ky nr ns nt nu bi translated">而您的<code class="fe mn mo mp mq b">ssrPath</code>将是<code class="fe mn mo mp mq b"><em class="mv">http://XXX.XXX.XXX.XXX:5000/microfrontend</em></code>，在这里您需要用您机器的真实公共IP地址替换XXX。如果你的网络提供商让你使用NAT，你可以使用像https://ngrok.com/这样的服务来获得一个。</li></ul><p id="5f6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您弄清楚了所有的细节——让我们为您更改ILC配置。为此，您需要打开<a class="ae kz" href="http://demo.microfrontends.online/nosuchpath" rel="noopener ugc nofollow" target="_blank">demo.microfrontends.online/nosuchpath</a>并在浏览器控制台中执行以下代码:</p><pre class="lb lc ld le gt oa mq ob oc aw od bi"><span id="a42a" class="mz lk it mq b gy oe of l og oh">var publicPath = 'https://abcde.sse.codesandbox.io/public/';<br/>var ssrPath = 'https://abcde.sse.codesandbox.io/microfrontend';</span><span id="c215" class="mz lk it mq b gy oi of l og oh">var overrideConfig = encodeURIComponent(JSON.stringify({<br/>    apps: {<br/>        '@portal/myapp': {<br/>            spaBundle: publicPath + 'client.js',<br/>            cssBundle: publicPath + 'style.css',<br/>            ssr: {<br/>                src: ssrPath,<br/>                timeout: 10000,<br/>            },<br/>            props: { publicPath },<br/>            kind: 'primary',<br/>        },<br/>    },<br/>    routes: [{<br/>        routeId: 555,<br/>        route: '/nosuchpath',<br/>        slots: {<br/>            body: {<br/>                appName: '@portal/myapp'<br/>            }<br/>        }<br/>    }]<br/>}));<br/><br/>document.cookie = `ILC-overrideConfig=${overrideConfig}; path=/;`</span></pre><p id="4446" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">代码执行后刷新页面。如果你做的一切都正确——你应该能够看到你的应用程序在一个公共的ILC演示网站上运行。</p><blockquote class="ms mt mu"><p id="0198" class="kb kc mv kd b ke kf kg kh ki kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ky im bi translated">如果这对你不起作用——确保<code class="fe mn mo mp mq b">ssrPath</code>不仅可以从你的机器上访问(使用<a class="ae kz" href="https://reqbin.com/" rel="noopener ugc nofollow" target="_blank">https://reqbin.com/</a>)，而且JS/CSS链接确实可以从你的机器上工作。</p></blockquote><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi la"><img src="../Images/b396d0109e717bc99b2c632a03b2b968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oAPf5hIyYFDBW-XR"/></div></div></figure><p id="47f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在试着使用顶部的工具条在不同的页面之间切换。看到不仅服务器端渲染工作，而且客户端。禁用JS，看看页面没有它是什么样子。</p><p id="a9c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果它能和其他应用程序一起很好地工作——我祝贺亲爱的读者🎉你刚刚建立了你的第一个微前端。</p><p id="3a0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果它对你不起作用，请在下面留下评论或PM我，这样我可以试着帮助你&amp;提高这篇文章的效果。</p><h1 id="c707" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">摘要</h1><p id="00c2" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">我们刚刚把最简单的React应用程序变成了一个微前端，我希望你能顺利完成。正如你所看到的，有了合适的工具链，这并不像你想象的那么难。</p><p id="77bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样值得一提的是，这篇文章并没有涵盖这个过程的很多特性，但是如果它能从社区获得足够的反馈，我将会写更多关于如何在合理的时间内实际构建和发布更复杂的微前端的文章。</p><p id="69f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">故事续:</strong> <a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/building-micro-frontend-with-ssr-part-2-routing-d86480de8894">用SSR构建微前端——路由</a></p></div></div>    
</body>
</html>