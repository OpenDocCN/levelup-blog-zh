<html>
<head>
<title>React.js is overrated, use Svelte instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js被高估了，用Svelte代替</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-react-js-is-overrated-31b2c6a4e138?source=collection_archive---------6-----------------------#2021-11-29">https://levelup.gitconnected.com/why-react-js-is-overrated-31b2c6a4e138?source=collection_archive---------6-----------------------#2021-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/3ae529db10c941a5431c195589bfb568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ivxIknkPbUhjKQX3"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">米歇尔·玛特隆在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="557e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我写React.js已经快3年了。React.js是一个很好的库。它拥有JavaScript世界中最好的生态系统之一。但是，我感觉React.js在某种程度上被高估了。我每天都在React.js中写很多样板代码，所以我能理解一个开发者的痛苦。这可能是我个人的看法。但是像<a class="ae jg" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki jk">苗条</strong> </a>这样的框架，相比React.js要好得多</p><p id="b678" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我以前试过苗条的身材。当它在2016年发布时，我第一次不喜欢它。其中一个主要原因是，当时生态系统和成熟度缺失。最近，几个月前，当我开始做一个小型的POC时，我开始探索React.js之外的一些框架。说实话，我喜欢新版本的苗条。它比<strong class="ki jk">更成熟</strong>，更少<strong class="ki jk">误删</strong>(打字稿)，并且<strong class="ki jk">开发速度非常快</strong>。我们将在后面更详细地讨论苗条的所有方面。</p><h2 id="d5f1" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">基础应用的构建——前端Hello World</h2><p id="9862" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">要理解一个框架，你要做的第一件事就是构建一个<strong class="ki jk"> Hello World App </strong>。就像Hello World CLI应用程序一样，<strong class="ki jk"> ToDo应用程序</strong>是一个Hello World前端应用程序。</p><p id="87eb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<strong class="ki jk"> ToDo </strong>应用程序包含<strong class="ki jk"> CRUD </strong>操作。CRUD操作可以在内存中或通过网络调用来执行。在本文中，我们将尝试使用网络调用创建一个ToDo应用程序。</p><figure class="md me mf mg gt iv gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/0cb6dffb88cba485db81ac9f95f6d453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*oklPG-O1h6Qks83oIEHYew.gif"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">演示待办事项应用程序</figcaption></figure><h2 id="17c0" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">模拟服务器</h2><p id="a63a" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">模仿服务器是一门艺术。如果你能自己写一个模仿服务器，你就能成为一名艺术家。然而，有一些像我一样懒惰的艺术家，他们喜欢用静止的颜色来画画。因此，对于这个演示，我们将使用<a class="ae jg" href="https://jsonplaceholder.typicode.com/todos/1" rel="noopener ugc nofollow" target="_blank">jsonplaceholder.typicode.com</a>。这个网站提供了一个免费的模拟环境来执行CRUD操作。</p><p id="b6a4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">原料药:</strong></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e950" class="le lf jj mi b gy mm mn l mo mp">### <br/># Get All Todos<br/>GET <a class="ae jg" href="https://jsonplaceholder.typicode.com/todos/" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/</a></span><span id="d9e6" class="le lf jj mi b gy mq mn l mo mp">####<br/># Create an new Todo<br/>POST <a class="ae jg" href="https://jsonplaceholder.typicode.com/todos/" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/</a></span><span id="ba88" class="le lf jj mi b gy mq mn l mo mp">{<br/>    "title": "Write a blog on Svelte",<br/>    "completed": false<br/>}</span><span id="a588" class="le lf jj mi b gy mq mn l mo mp">####<br/># Get todo with id 1</span><span id="fab7" class="le lf jj mi b gy mq mn l mo mp">GET <a class="ae jg" href="https://jsonplaceholder.typicode.com/todos/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1</a></span><span id="bb4e" class="le lf jj mi b gy mq mn l mo mp">####<br/># Update todo with id 1</span><span id="41d9" class="le lf jj mi b gy mq mn l mo mp">PUT <a class="ae jg" href="https://jsonplaceholder.typicode.com/todos/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1</a></span><span id="93b1" class="le lf jj mi b gy mq mn l mo mp">{<br/>    "completed": true<br/>}</span><span id="1ef8" class="le lf jj mi b gy mq mn l mo mp">####<br/># Delete todo with id 200</span><span id="8d33" class="le lf jj mi b gy mq mn l mo mp">DELETE <a class="ae jg" href="https://jsonplaceholder.typicode.com/todos/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1</a><br/>content-type: application/json</span></pre><h2 id="783a" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">编写React.js代码</h2><p id="f483" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在，既然我们已经模拟了服务器，让我们构建我们的第一个应用程序。我不打算解释React.js的详细步骤，我希望你已经熟悉它了。下面是React.js中ToDo应用程序的工作代码。</p><h2 id="ccdb" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak">使用React.js创建一个Todo应用</strong></h2><p id="d7f0" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><strong class="ki jk"> 1。ToDo服务类:</strong> ToDo服务是一个可重用的类，包含通过HTTP API调用的CRUD操作。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ff26" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> 2。使用style.css: </strong>在React.js中，可以用多种方式对DOM元素进行样式化。您可以使用CSS文件来设置DOM的样式。<a class="ae jg" href="https://webpack.js.org/loaders/" rel="noopener ugc nofollow" target="_blank"> Webpack loader </a>将CSS和其他文件捆绑在一起。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f426" class="le lf jj mi b gy mm mn l mo mp">.checked {<br/>  text-decoration: line-through;<br/>}</span></pre><p id="93d8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> 3。创建应用组件:</strong>Todo应用的基本逻辑写在<strong class="ki jk"> App.js </strong>中。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b112" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用<strong class="ki jk"> useState </strong>在组件级别创建一个状态。<strong class="ki jk"> useState </strong>创建一个状态，并在整个组件生命周期中维护其数据。接下来，使用<strong class="ki jk"> useEffect </strong>钩子可以获取组件数量的数据。方法<strong class="ki jk"> addToList </strong>，<strong class="ki jk"> removeFromList </strong>，<strong class="ki jk"> onUpdate </strong>主要用于进行API调用。这里<strong class="ki jk"> onChangeItem </strong>，<strong class="ki jk"> onChecked </strong>用于处理事件，绑定数据的状态。其余的代码是模板或DOM元素。</p><p id="4093" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> Codesandbox: </strong></p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt ms l"/></div></figure><h2 id="1dd4" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">用苗条的身材写待办事项应用程序</h2><p id="82a7" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">如你所见，编写一个简单的ToDo应用程序也需要80-90行代码。让我们尝试使用Svelte构建相同的应用程序。</p><p id="1f6c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> 1。ToDo服务类:</strong>由于服务API调用没有变化，我们可以重用<strong class="ki jk"> todo.service.js </strong>。</p><p id="7c0a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> 2。使用苗条样式:</strong>苗条样式支持<strong class="ki jk"> &lt;样式&gt; </strong>标签的模板。我们可以使用相同的<strong class="ki jk"> App.svelte </strong>文件来编写样式。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="21f5" class="le lf jj mi b gy mm mn l mo mp">&lt;style&gt;<br/>.checked {<br/>  text-decoration: line-through;<br/>}</span><span id="896e" class="le lf jj mi b gy mq mn l mo mp">.App {<br/>  font-family: sans-serif;<br/>  text-align: center;<br/>}<br/>&lt;/style&gt;</span></pre><p id="fa04" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> 3。HTML模板</strong>:就像普通的HTML文件一样，你可以在同一个<strong class="ki jk"> App.svelte </strong>文件中编写一个HTML模板。我们将在后面详细讨论代码。</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b9f2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> 4。业务逻辑(控制器):</strong> Svelte遵循与HTML文件相同的语法。这样你就可以在同一个瘦文件中的<strong class="ki jk"> &lt;脚本&gt; </strong>标签中编写逻辑</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="12d9" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">代码剖析</h2><ol class=""><li id="1fc6" class="mu mv jj ki b kj lx kn ly kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="ki jk">更少的冗长和易于学习:</strong>你将看到的第一个主要变化是，你可以不用额外的<em class="nd"> setter </em>和<em class="nd"> getter </em>来编写代码。同时，苗条的编译器不会创建任何肮脏的观察者。Svelte采取了不同的机制。当斯维尔特编译代码时。它为所有数据更新添加了一个<strong class="ki jk"> $$invalidate </strong>函数。这将使状态无效并重新呈现组件。这使得细长的代码<strong class="ki jk">不那么冗长</strong>和<strong class="ki jk">易于学习</strong>。你可以在这里阅读更多<a class="ae jg" href="https://svelte.dev/blog/svelte-3-rethinking-reactivity" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="490e" class="mu mv jj ki b kj ne kn nf kr ng kv nh kz ni ld mz na nb nc bi translated"><strong class="ki jk">数据绑定:</strong> Svelte使用<em class="nd">绑定属性(指令)</em>支持数据绑定。每当你绑定一个像<strong class="ki jk"> 'bind:value '，</strong>这样的属性时，编译器会创建一个setter来更新DOM中的值。就像value一样，你可以绑定其他属性，比如<strong class="ki jk">类</strong>、<strong class="ki jk"> onClick </strong>等。这大大减少了代码的大小。</li><li id="91a2" class="mu mv jj ki b kj ne kn nf kr ng kv nh kz ni ld mz na nb nc bi translated"><strong class="ki jk"> HTML模板</strong>:也支持HTML标签内的模板。语法非常类似于<a class="ae jg" href="https://mustache.github.io/" rel="noopener ugc nofollow" target="_blank"> mustache.js </a>。Svelte编译代码并转换成普通的JS。</li></ol><h2 id="afd7" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">更多示例</h2><ol class=""><li id="177f" class="mu mv jj ki b kj lx kn ly kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="ki jk">将组件绑定在一起:</strong>你可能会说，在上面的例子中，我们只是减少了绑定代码。我们再举一个例子。假设我们有两个范围组件，其值取决于两个数字输入。</li></ol><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e83a" class="le lf jj mi b gy mm mn l mo mp">&lt;script&gt;<br/> let a = 1;<br/> let b = 2;<br/>&lt;/script&gt;</span><span id="44bb" class="le lf jj mi b gy mq mn l mo mp">&lt;label&gt;<br/> &lt;input type=number <strong class="mi jk">bind:value={a}</strong> min=0 max=10&gt;<br/> &lt;input type=range <strong class="mi jk">bind:value={a}</strong> min=0 max=10&gt;<br/>&lt;/label&gt;</span><span id="6d6e" class="le lf jj mi b gy mq mn l mo mp">&lt;label&gt;<br/> &lt;input type=number <strong class="mi jk">bind:value={b} </strong>min=0 max=10&gt;<br/> &lt;input type=range <strong class="mi jk">bind:value={b}</strong> min=0 max=10&gt;<br/>&lt;/label&gt;<br/>&lt;p&gt;{a} + {b} = {a + b}&lt;/p&gt;<br/>&lt;style&gt;<br/> label { display: flex }<br/> input, p { margin: 6px }<br/>&lt;/style&gt;</span></pre><p id="f71d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，指令“<strong class="ki jk">bind:value”</strong>将负责同步值<strong class="ki jk">“a”</strong>和<strong class="ki jk">“b”</strong>。</p><p id="16f7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.<strong class="ki jk">组绑定</strong>:再举个例子，一个很常见的用例就是绑定一组输入。通常，您必须创建一个数组并通过索引进行更新。这似乎是一项容易的任务。然而，太多的样板代码。Svelte优雅地处理这个问题。只要看看下面给出的例子。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="ed86" class="le lf jj mi b gy mm mn l mo mp">&lt;script&gt;<br/> let flavours = ['Mint choc chip'];<br/> let menu = ['Cookies and cream', 'Mint choc chip', 'Raspberry ripple'];<br/> const join = (flavours) =&gt; (flavours.length ? flavours.join(', ') : 'Please select items');<br/>&lt;/script&gt;</span><span id="fecc" class="le lf jj mi b gy mq mn l mo mp">&lt;h2&gt;Flavours&lt;/h2&gt;<br/>{#each menu as flavour}<br/> &lt;label&gt;<br/>  &lt;input type="checkbox" <strong class="mi jk">bind:group={flavours} </strong>name="flavours" value={flavour} /&gt;<br/>  {flavour}<br/> &lt;/label&gt;<br/>{/each}<br/>&lt;p&gt;<br/> You ordered {join(flavours)}<br/>&lt;/p&gt;</span></pre><blockquote class="nj nk nl"><p id="2ae3" class="kg kh nd ki b kj kk kl km kn ko kp kq nm ks kt ku nn kw kx ky no la lb lc ld im bi translated"><strong class="ki jk">结论</strong></p><p id="1dc8" class="kg kh nd ki b kj kk kl km kn ko kp kq nm ks kt ku nn kw kx ky no la lb lc ld im bi translated">即使现在，我们有高配置的设备。但是一个设备有它自己的局限性。我们无法完全在内存上优化性能。Svelte采取了不同的方法。它编译代码并生成高度优化的代码。这样做，大大减少和减少了代码。作为开发人员，您不需要担心反应性。苗条也照顾结合和反应性。Svelte严格遵循HTML、CSS和JS的经典web开发模型。Svelte还支持插件来执行复杂的编译时修改。最后，Svelte离React.js还很远，不过，相信很快就会赶上React.js。</p></blockquote><p id="87d6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:你可以从下面给定的codesandbox下载整个代码</p><figure class="md me mf mg gt iv"><div class="bz fp l di"><div class="mt ms l"/></div></figure><p id="3c3f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">参考文献:</strong></p><ol class=""><li id="c21d" class="mu mv jj ki b kj kk kn ko kr np kv nq kz nr ld mz na nb nc bi translated">【https://svelte.dev/ T4】</li><li id="941c" class="mu mv jj ki b kj ne kn nf kr ng kv nh kz ni ld mz na nb nc bi translated"><a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_getting_started" rel="noopener ugc nofollow" target="_blank">苗条_入门</a></li></ol></div></div>    
</body>
</html>