<html>
<head>
<title>SPA, SSG, SSR and JAMStack: a front-end acronyms guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SPA、SSG、SSR和JAMStack:首字母缩略词指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/spa-ssg-ssr-and-jamstack-a-front-end-acronyms-guide-6add9543f24d?source=collection_archive---------1-----------------------#2020-06-14">https://levelup.gitconnected.com/spa-ssg-ssr-and-jamstack-a-front-end-acronyms-guide-6add9543f24d?source=collection_archive---------1-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="56fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的十年中，前端开发经历了多种范式的变化，很难跟上。</p><p id="3aad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从jQuery / Mootools转移到Angularjs，然后是React/Vue/Angular，这很令人兴奋，但也足够困难。现在来了<a class="ae kl" href="https://www.gatsbyjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">盖茨比</strong> </a> <strong class="jp ir">，</strong> <a class="ae kl" href="https://nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Nuxt </strong> </a> <strong class="jp ir">，</strong><a class="ae kl" href="https://gridsome.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">grid some</strong></a><strong class="jp ir">，</strong>以及他们的朋友们，他们以再次震撼我们开发者的世界为乐。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6efce0886d04968f8ccb4ac6e7dcbf83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*I-u1F9bj9Zast3XfBduCNA.gif"/></div></div></figure><p id="2f5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将探讨前端web开发的新模式，看看它们带来了什么，以及如何用合适的工具实现它们。</p><h1 id="3f60" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">单页应用程序</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lw"><img src="../Images/5c924a801b1cdd0bb256566e5252a42a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSvIzQyxb-aVRQqEeXC1Cw.jpeg"/></div></div></figure><p id="a236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单页面应用在2010年代初真正起飞，当时AngularJS的流行使得前端开发人员希望用JavaScript编码他们的整个应用内容和流程，而不是为每个页面编写传统的HTML/CSS/JS文件。</p><p id="d4a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单页应用程序(SPA)背后的理念是以开发移动或桌面客户端应用程序的方式开发网站:<br/>您的应用程序源代码(主要是JavaScript)负责在可用呈现器(您用户的web浏览器)内的应用程序内容之间进行<strong class="jp ir">填充、交互和导航</strong>。</p><p id="4b81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，与加载不同CSS和JavaScript资源的多个HTML页面以及浏览器使用链接在这些页面之间导航不同，使用SPA，您有一个没有内容的<strong class="jp ir">单个HTML页面</strong>(index.html ),加载一个或多个<strong class="jp ir"> JavaScript文件</strong>,这些文件将<strong class="jp ir">呈现您的内容，在应用程序的各个部分之间导航，并处理您的DOM组件之间的任何交互</strong>。</p><p id="9a4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们利用了以下技术:</p><ul class=""><li id="5e8f" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated"><strong class="jp ir"> HTML5历史API(或位置散列#) </strong>:该API能够感知网站页面之间的可导航性，使导航与本机浏览器行为兼容(上一页/下一页按钮和URL更改)</li><li id="cb59" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir"> JavaScript Web框架:</strong> React、Angular、Vue都处理内容表示与数据的解耦，以及这些数据到DOM的渲染和更新。该模型简化了数据密集型应用程序的制作，其灵感来自客户端应用程序的MVVM架构。</li><li id="890d" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir"> Ajax和HTTP API</strong>:由于app的初始页面是空的，JavaScript代码会经常调用一个API来获取用户内容。这些API通常使用REST协议和JSON作为数据格式，但是最近GraphQL为内容查询提供了一个灵活的选择。</li></ul><p id="bb4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为你可能不想在一个JavaScript ES5文件中编写你的应用程序，现代工具提供了一个<strong class="jp ir">构建工具链</strong> (webpack是目前最著名的捆绑器)，使你能够在一个结构化和开发友好的环境(ES2020标准，组件树)中编写你的应用程序，并编译它以最小化，连接和分块你的JS &amp; CSS文件到一个构建文件夹中。</p><p id="3f77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，现代框架通常自带类似HTML的语法(JSX，vue基于HTML的模板),以增强HTML语言的动态特性，如数据插值和事件绑定。</p><p id="d67c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，以下是SPA带给前端开发界的东西:</p><ul class=""><li id="6e14" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">使用<strong class="jp ir">新框架</strong>的能力，简化了高度数据绑定和交互式应用的开发。</li><li id="a745" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">能够以你喜欢的方式构建你的代码，并将其构建在一个可部署的包(HTML、JS、CSS)上</li><li id="0e4c" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">由于您的应用程序是一次性加载的<strong class="jp ir"/>，所以以后的导航和交互不会生成资产请求，这使得它比传统的完全重新加载导航更快</li><li id="2c09" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir"> SPA利用API</strong>来查询应用程序的内容，这鼓励了数据和它的表示之间的<strong class="jp ir">解耦</strong></li></ul><p id="b373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这些优势也伴随着代价，例如:</p><ul class=""><li id="b6d3" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">你的应用捆绑包的总大小可能会变得很大，从而减慢你的应用的第一次加载</li><li id="42dc" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">状态管理可能会变得复杂</strong>，因为使用JavaScript导航，您的应用程序状态不会在页面导航上重置(您不会获得完全重新加载的空白)。Redux/Vuex或React reducer挂钩使它更容易。</li><li id="3644" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir"> SEO可能很棘手:</strong>尽管存在索引机器人的ajax爬行，但普遍认为服务器呈现的HTML页面作为SPAs更容易优化。</li><li id="3739" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">性能</strong>会受到影响:随着你的应用增长，会运行越来越多的JS代码来渲染你的应用，这会让你的访客CPU疯狂运行。幸运的是，大多数框架都推荐最佳实践，比如使用内存化来防止过多的DOM重新呈现。</li></ul><p id="9697" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，单页面应用程序使你能够<strong class="jp ir">拥抱现代JavaScript </strong>框架的精神(ES2020、组件架构、捆绑和优化、HTML5历史API)，但如果你想要最好的SEO和UX体验，也会带来一些挑战。</p><h1 id="c313" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">静态站点生成器</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ml"><img src="../Images/cdac344066d28693c23240560c295e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28AryTRLRpzSRR_PisbWrw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><a class="ae kl" href="https://www.netlify.com/blog/2020/04/14/what-is-a-static-site-generator-and-3-ways-to-find-the-best-one/" rel="noopener ugc nofollow" target="_blank">https://www . netlify . com/blog/2020/04/14/what-a-static-site-generator-and-3-ways-to-find-the-best-one/</a></figcaption></figure><p id="fc95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">早期的静态站点生成器从2008年就出现了(<a class="ae kl" href="https://jekyllrb.com/" rel="noopener ugc nofollow" target="_blank"> Jekyll </a>)，我认为他们想为基于CMS的网络应用提供一种替代方案。</p><p id="5c1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，很多网站向所有用户展示的内容都是由CMS编辑的(比如Wordpress)。这使得CMS中的更改可以直接部署给用户，因为内容是在<strong class="jp ir">运行时生成的(基于PHP的CMS的事件请求时间</strong>)。</p><p id="ebd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SSG挑战的是这样一种假设，即对于用户的每个请求，都应该从数据库中请求内容。事实上，他们建议在<strong class="jp ir">构建时</strong>生成内容。因为一旦你的页面已经从CMS中生成，就这样了，在你的CMS中的下一个内容改变之前，它不需要被改变。</p><p id="cedc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，为什么不在每次你的内容发生变化的时候<strong class="jp ir">将你所有的网站页面</strong>生成为静态页面<strong class="jp ir">？</strong></p><p id="7ba5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它通常的工作方式是你将连接你的内容(CMS，headless CMS，文件存储等)到<strong class="jp ir">你的CI引擎</strong>例如使用<strong class="jp ir"> webhooks </strong>，这样每次你的内容改变时，一个CI管道被触发，从而重建你的所有网站并使缓存失效。</p><p id="05c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，新SSG如<strong class="jp ir"> Gatsby或Gridsome是围绕React/Vue框架</strong>构建的，这意味着您的静态站点将受益于框架架构和生态系统，并且一旦您的页面被初始加载，额外的DOM交互将由您的代码使用框架来处理。</p><p id="365b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用静态站点生成器代替单页面应用程序的好处是:</p><ul class=""><li id="1e4a" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">更好的搜索引擎优化:因为你的网站由多个HTML页面组成，机器人抓取更容易，你的内容会被很好地索引。</li><li id="33bb" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">更好的性能:</strong>现代的SSG工具只包含运行请求页面所必需的JS/CSS代码，如果用户浏览你的网站，它们会加载额外的代码。</li><li id="2f62" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">内容分离: SSG提供了一种将你内容从它的表现中分离出来的方法。</li><li id="545d" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">多源内容:</strong>SSG提供多内容源集成，如无头CMS ( <a class="ae kl" href="https://www.contentful.com/" rel="noopener ugc nofollow" target="_blank"> Contentful </a>、<a class="ae kl" href="https://strapi.io/" rel="noopener ugc nofollow" target="_blank"> Strapi </a>)、本地标记文件或远程文件。</li></ul><p id="e511" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这通常会带来一些缺点和限制:</p><ul class=""><li id="1453" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated"><strong class="jp ir">用户定制内容:</strong>只有当内容页面<strong class="jp ir">对所有用户都相同时，内容的静态生成才有效</strong>，否则，您需要为每个用户生成每个页面，这将占用大量空间，并可能导致安全问题，因为所有静态页面都是公开的。<br/>所以对于用户定制的内容(仪表板、论坛帖子、收件箱等等)，你需要进行API调用来获得格式化的内容。</li><li id="c547" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">学习曲线</strong>:每个SSG都有自己的方式来查询你的内容和生成你的页面。尽管Gatsby是基于React的，但它使用GraphQL进行内容查询，所以您需要深入了解它才能使它工作。</li><li id="a2ed" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir"> CI开销和预览延迟</strong>:如果你想让你的网站总是与你的内容保持同步，你应该插入webhooks和CI管道来使其工作。如果你的管道运行需要5分钟，那么你就要等5分钟才能看到你的网站更新你的内容。</li></ul><p id="db99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，如果你关心SEO，如果你的网站有大量的公共内容，我会说静态站点生成器是单页应用程序的一个很好的替代品。如果你关心<strong class="jp ir">性能和开发者体验</strong>，它也是经典CMS的一个很好的替代品。</p><h1 id="e74c" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">服务器端渲染</h1><p id="b0b0" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">我们这里要提到的最新趋势是服务器端渲染。从历史上看，服务器端呈现(或脚本)已经存在很长时间了。</p><pre class="kn ko kp kq gt mv mw mx my aw mz bi"><span id="6b68" class="na kz iq mw b gy nb nc l nd ne">&lt;div&gt;Hello &lt;?php echo 'world'; ?&gt;&lt;/div&gt;</span></pre><p id="3b76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得那些邪恶的台词吗？这是最坏的服务器端渲染。所以SSR仅仅意味着从服务器呈现你的HTML内容。ASP.Net，JEE，PHP Symfony，Ruby on Rails，所有这些常规的MVC框架都提供了某种带有模板引擎的服务器端渲染。</p><p id="eeb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是那些基于服务器的渲染有局限性:你不能处理客户端与它的交互，你被限制在浏览器中显示的初始内容。以下任何行为都必须在附加的JavaScript文件中进行编码。</p><p id="8983" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在JavaScript世界中谈论SSR时，我们在<strong class="jp ir"> JavaScript同构渲染</strong>中真正指的是什么。随着NodeJS的出现，JavaScript现在既可以在服务器上运行<strong class="jp ir">，也可以在客户机上运行</strong>，这使得共享呈现逻辑成为可能。</p><p id="a0d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，NextJS、Nuxt和其他公司提供的是一种<strong class="jp ir">共享组件渲染逻辑的方式</strong>，在服务器的初始加载和客户端的后续交互之间。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/0fa84e6fd94efdffc95a8bb0d247e708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*DI5qzdJQKNA8xcYwTXkiTg.jpeg"/></div></figure><p id="f163" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会问，像盖茨比这样的现代SSG有什么不同？事实上，它们也在React中呈现页面，并让框架处理客户端交互。是的，但是使用SSR <strong class="jp ir">你的页面在运行时为每个请求</strong>呈现，这意味着你可以根据你的用户上下文定制你页面的初始呈现<strong class="jp ir">。而Gatsby生成的页面是静态的，因此初始内容对所有用户都是相同的。</strong></p><p id="dc79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们总结一下为什么要使用SSR，以及您可以从中获得哪些好处:</p><ul class=""><li id="0a13" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated"><strong class="jp ir"> SEO </strong>:如果你想让用户定制的页面在搜索引擎上被编入索引，或者在社交媒体共享中预载缩略图，你需要这些页面在服务器端呈现。</li><li id="47ad" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">内容更新</strong>:如果你的内容存放在CMS中，你希望每次更新都能立即反映在你的网站上，SSR正是你所需要的。</li><li id="ed42" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">性能</strong>:与SSG一样，SSR通常意味着比SPA更好的性能，至少在第一次加载页面内容时是如此。</li><li id="2b87" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">相同代码库中的后端和前端:</strong>由于SSR运行在您的服务器上，您也可以用它托管您的API，为您的API和前端提供一个单一的存储库。</li></ul><p id="d653" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，这也带来了限制和棘手的方面:</p><ul class=""><li id="a9bb" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated"><strong class="jp ir">需要一台服务器</strong>:要让SSR工作，你需要一台服务器。虽然有些神奇的托管平台，如<a class="ae kl" href="https://nextjs.org/docs/deployment#optimized-for-nextjs" rel="noopener ugc nofollow" target="_blank"> Vercel </a>会利用无服务器的功能来做预渲染，这样就不需要服务器了。</li><li id="d279" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">性能:</strong>是的，页面的初始加载会包含内容，但它是由服务器计算的，服务器可能会臃肿。与提供静态文件的SSG相反，使用SSR你需要确保你的初始加载足够快。</li><li id="47bf" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">学习曲线:</strong>为了让同构的JavaScript工作，框架在你创建组件的方式上执行约定。在熟练使用它们之前，你必须学习和理解它们。</li><li id="e9b0" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">并非真正通用:</strong>尽管从理论上讲，JavaScript可以在服务器和客户端使用，但这两种环境还是有区别的。例如，<code class="fe ng nh ni mw b">window</code>在服务器上不存在，所以您将需要一些类似代码的“杂注”,以确保您的一些前端依赖项仍然工作良好</li></ul><h1 id="6b2a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JAMStack</h1><p id="33e0" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">JAMStack更像是一个营销世界。它意味着JavaScript、API和标记。因此，从历史上看，它主要会促进静态站点生成器的使用，作为传统CMS (Wordpress)或传统服务器端MVC框架的替代方案。</p><p id="f8c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着时间的推移，这个术语汇集了所有与静态和服务器端渲染网站相关的生态系统和工具，例如:</p><ul class=""><li id="bac6" class="lx ly iq jp b jq jr ju jv jy lz kc ma kg mb kk mc md me mf bi translated">CI管道</li><li id="07c1" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">Git集成</li><li id="75f9" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">面向缓存和地理性能的CDN</li><li id="be1f" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">缓存失效</li><li id="4c62" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">API的云函数</li><li id="fa88" class="lx ly iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">…而且每天都在增加</li></ul><h1 id="f75d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">好吧，那我应该用什么？</h1><p id="2717" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">首先恭喜你熬过了这篇重磅文章。如果你跳到这部分，我能理解。</p><p id="abf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我从头开始一个前端项目时，我会浏览这个决策图，以了解我应该关注什么技术。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nj"><img src="../Images/d8f2c19d42b227ee0bcf06fce4cfe60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1GlfIbRJHQfm2qKA4ddyQ.jpeg"/></div></div></figure><p id="6c63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这将有助于你对下一个项目的决定。如果您觉得我遗漏了什么，或者如果您想与社区分享您的决策过程和具体工具，请分享您的评论。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="0d42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS: NextJS处理<a class="ae kl" href="https://nextjs.org/docs/advanced-features/automatic-static-optimization" rel="noopener ugc nofollow" target="_blank">自动静态优化</a>，这意味着如果需要，这个框架可以处理静态页面生成和服务器端呈现。所以当有疑问时，这是一个安全的选择。</p></div></div>    
</body>
</html>