<html>
<head>
<title>I built an app that searches an API with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用React创建了一个搜索API的应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/i-built-an-app-that-searches-an-api-with-react-f1428222bcb3?source=collection_archive---------12-----------------------#2021-05-12">https://levelup.gitconnected.com/i-built-an-app-that-searches-an-api-with-react-f1428222bcb3?source=collection_archive---------12-----------------------#2021-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="377d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个不知名的加拿大电子商务平台(<em class="kf">是的，就是那个</em>)正在招聘实习生，而<em class="kf">我</em>就是那个实习生。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/1a9041817ae26fd388e664ae6a79214b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lydTfBPaj3Z7btCV"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@masonkimbar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅森·金巴罗夫斯基</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5258" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">他们的申请过程不同于我以前经历过的任何过程。我的任务是创建一个利用OMDB电影应用程序接口的网络应用程序，它可以免费获取电影数据，也可以付费获取电影海报。在 <a class="ae kw" href="https://www.patreon.com/omdb" rel="noopener ugc nofollow" target="_blank"> <em class="lt"> Patreon </em> </a>上查看)，显示搜索结果，并能够添加和删除任何显示的标题的提名，以及完成这些任务的按钮(<em class="lt">或div的</em>)的预期功能。这个构建必须完成，并与要考虑的应用程序一起发送。</p><p id="4117" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我在这篇文章中的重点是回顾我的思维模式和我在构建这个搜索应用程序时遇到的一些问题，以及未来将它作为我作品集中的一个项目来完善的目标。你可以在我的Github上看到我的应用库:<a class="ae kw" href="https://github.com/jvckmo/challenge" rel="noopener ugc nofollow" target="_blank">前端</a>，<a class="ae kw" href="https://github.com/jvckmo/challenge-backend" rel="noopener ugc nofollow" target="_blank">后端</a>。我的代码将定期更新，文章中的代码截至5/11/21是准确的，并且处于提交该工作的状态。</p><p id="1358" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">关于构建，我想谈的第一件事是我与一位朋友的对话，话题是:</p><blockquote class="lu lv lw"><p id="326a" class="kx ky lt kz b la lb jr lc ld le ju lf lx lh li lj ly ll lm ln lz lp lq lr ls ij bi translated">为了一份你可能得不到的工作，这样做值得吗？在完成后没有就业保障的情况下，这种构建值得花费时间吗？</p></blockquote><p id="9d25" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在真正开始之前，我在内心为这个问题挣扎了几天，在我看来，提出的问题是有道理的。我最终得出的结论是，是的，这是值得的。即使我没有得到这个职位，我的投资组合中也有了一个新项目，并且我以一种我以前没有的方式用我选择的技术进行了大量的实践，回想起来，这被证明是正确的。我能够巩固我对React &amp; Redux + thunk到Rails后端、到数据库、再回到前端之间的数据流的理解。我也能够对CSS(我喜欢使用它，但它是我目前最弱的一点)和媒体查询进行更多的练习。</p><p id="d6dd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就构建而言，我选择使用React和Redux作为前端，Ruby on Rails作为后端。最初，我将所有东西都构建为前端，只包含需要跨应用程序状态处理的组件持久化的任何数据。大约进行到一半时，这变得不切实际，也不是我想要的。我的前端组件结构相当简单，一个<code class="fe ma mb mc md b">Search</code>组件，一个<code class="fe ma mb mc md b">SearchResults</code>组件绑定到redux的状态，一个<code class="fe ma mb mc md b">Signup</code> &amp; <code class="fe ma mb mc md b">Login</code> +一个<code class="fe ma mb mc md b">Loading</code>组件绑定到它们各自的状态。所有这些组件都嵌套在React路由器中，并有自己的路由。这种简单的设置是我觉得足够有效地执行了要求我完成的任务。</p><p id="624b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这篇文章中，我的重点是分解<code class="fe ma mb mc md b">Search</code>和<code class="fe ma mb mc md b">SearchResults</code>组件以及它们是如何构建的。首先，我需要谈谈我应该使用的API，以及我是如何设法保证API密匙安全的。这很容易实现，但第一次有点棘手。我在我的前端文件夹的根目录下创建了一个名为<code class="fe ma mb mc md b">.env</code>的文件。在这个文件中，我创建了一个名为<code class="fe ma mb mc md b">REACT_APP_API_KEY</code>的变量，并将其设置为从API站点生成的密钥。出于显而易见的原因，我不会在这里描绘这一行代码，但实际上它就像听起来一样简单。这里最重要的一步无疑是<strong class="kz ir">将</strong> <code class="fe ma mb mc md b">.env</code> <strong class="kz ir">文件添加到您的</strong> <code class="fe ma mb mc md b">.gitignore</code> <strong class="kz ir">文件</strong>中。如果你不这么做，API密匙会被上传到GitHub让任何窥探的眼睛看到。</p><p id="96bc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于这个特定的API，如果发生这种情况，也不是世界末日；如果发生这种情况，比如说，<strong class="kz ir"> <em class="lt">你的AWS账户然而</em> </strong>，你的信用卡可能会出现你意想不到的巨额费用(更不用说可能发生的任何数据丢失)。尽你所能保护你的API密匙是非常重要的。</p><p id="05ad" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，在正确存储API密钥之后，我需要一种方法来访问它。我是在<code class="fe ma mb mc md b">index.js</code>里面做的这个。我创建了一个名为<code class="fe ma mb mc md b">API</code>的导出变量，将它设置为API的URL，并使用字符串插值将我的键附加到URL上。这很容易通过React中的<code class="fe ma mb mc md b">process</code>对象和存放我的<code class="fe ma mb mc md b">REACT_APP_API_KEY</code>的<code class="fe ma mb mc md b">.env</code>属性来实现。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi me"><img src="../Images/5b66f6ad651145832988fb0e395dcd3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ud-pN2-5RNHukIac43zPmQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">index.js中的const API</figcaption></figure><p id="bc03" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在API中访问数据的下一步是用React实际调用一个fetch请求。</p><blockquote class="lu lv lw"><p id="0514" class="kx ky lt kz b la lb jr lc ld le ju lf lx lh li lj ly ll lm ln lz lp lq lr ls ij bi translated">为了简洁起见，我不会解释我的所有文件之间的整个数据流，但会描绘出它们的代码。关于React/Redux中数据流的解释，请查看这篇<a class="ae kw" href="https://www.tutorialspoint.com/redux/redux_data_flow.htm" rel="noopener ugc nofollow" target="_blank">文章</a>。我还将我的调度和应用程序状态映射到我的一个组件的props。关于这个look <a class="ae kw" href="https://react-redux.js.org/using-react-redux/connect-mapdispatch" rel="noopener ugc nofollow" target="_blank">的更多信息请点击</a>。这些都是重要的概念，但它们不是我这篇文章的重点，所以我将继续假设对这些概念有一个基本的理解。</p></blockquote><p id="ddfe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">获取请求最初是从我的搜索栏触发的。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mf"><img src="../Images/318ce1867ff704e1054d11d55d66c901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMfbeIEbCTWemQwWGd2HoQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">输入标签使用了搜索栏；包含onChange函数</figcaption></figure><p id="c479" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一个简单的带有<code class="fe ma mb mc md b">onChange</code>功能的<code class="fe ma mb mc md b">input</code>标签；每次输入一个字符，都会调用一个函数来触发一个函数，这个函数(目前)只调用一个映射到叫做<code class="fe ma mb mc md b">exSearch</code>的组件道具的动作。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mg"><img src="../Images/541f62ea381ea6f24706458025bbd619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLr5kE54Mwmh_1rorsc9hg.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">触发exSearch操作的handleInput函数</figcaption></figure><p id="045f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">搜索栏中的输入被传递到这个函数和动作中。在当前的形式下，这个函数可以完全省略，<code class="fe ma mb mc md b">onChange</code>函数可以直接调用动作，但是我想在获取API的次数上留有改进的空间。这可以减少API本身的负载，并通过减少连续快速调用的异步函数来提高我的应用程序的速度。</p><p id="8c5c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">文件<code class="fe ma mb mc md b">exSearch.js</code>导入我之前定义的<code class="fe ma mb mc md b">API</code>变量，并在获取请求中使用它。在OMDB的文档中，列出了要搜索API，我们需要在URL的关键字后面加上<code class="fe ma mb mc md b">&amp;s=</code>，以及要搜索的标题。这在使用字符串插值的开发中相当简单。在第二个<code class="fe ma mb mc md b">.then</code>语句中，我需要首先检查来自API的响应是否是一个实际的标题数组(在字符的前三个或四个变体中，它响应匹配的标题太多而无法显示)，以及被搜索的标题是否是一个有效的标题。我的动作中的最后一个条件是专门修复一个问题，在输入标题并删除所有字符后，我的应用程序会中断。删除的最后一个字符将发送一个对标题<code class="fe ma mb mc md b">‘’</code>的请求，并在数据路径的更深处尝试映射一个空字符串，这将抛出一个错误。根据满足的条件，该操作将向我的商店发送一个派单来更新状态。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mh"><img src="../Images/403ef38e4d1887effd3cec9ad7773b48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_XzLf0IyKUuZOzUr3k15g.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">提取API的exSearch函数</figcaption></figure><p id="8957" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了简单起见，我选择在应用程序中只使用一个减速器。我的状态实际上是在这个缩减器内部设置的。就状态而言，应用程序非常简单，只有四个属性；<code class="fe ma mb mc md b">currentUser</code>:用于后端请求的字符串<code class="fe ma mb mc md b">id</code>，<code class="fe ma mb mc md b">searchTitles</code>:被搜索的字符串，<code class="fe ma mb mc md b">currentUserTitles</code>:包含与当前用户相关联的所有标题的对象数组，<code class="fe ma mb mc md b">allNominatedTitles</code>:包含所有用户提名的所有标题的对象数组。减速器的<code class="fe ma mb mc md b">UPDATE_SEARCH</code>箱体较短，只需将状态中的<code class="fe ma mb mc md b">searchTitles</code>属性设置为<code class="fe ma mb mc md b">exSearch</code>函数内的<code class="fe ma mb mc md b">desiredTitle</code>即可。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mi"><img src="../Images/ab79b777faf0366c773e3a5aa0b6af0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZJM0J-aQek7dFVjmZzQ0A.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">我的减速器中的案例“更新_搜索”</figcaption></figure><p id="be1d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">真正的魔力始于<code class="fe ma mb mc md b">SearchResults</code>组件内部，嵌套在<code class="fe ma mb mc md b">Search</code>组件内部。这里我有一大堆<code class="fe ma mb mc md b">Search</code>传下来的道具，最重要的是<code class="fe ma mb mc md b">titles</code>(即<code class="fe ma mb mc md b">this.props.searchTitles</code>)，也就是我们上面更新的<code class="fe ma mb mc md b">searchTitles</code>。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mj"><img src="../Images/edad18082ba84a206b37e9e541a5ee38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wlUfT6o3TROwnkcY2GsfA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">SearchResults组件在搜索的呈现函数中的位置</figcaption></figure><p id="2f2e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我的<code class="fe ma mb mc md b">SearchResults</code>函数的<code class="fe ma mb mc md b">render</code>中，我有一个一行三进制语句来检查状态中的<code class="fe ma mb mc md b">searchTitles</code>。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mk"><img src="../Images/fd4365a3b231b01128357957bc350d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrgpnbjlvErMVXuOipeBfA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">在搜索结果中呈现函数</figcaption></figure><p id="29e3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果没有标题(即没有进行搜索)，它将触发函数<code class="fe ma mb mc md b">rollNominated</code>，返回所有已被提名的标题。如果有标题并且已经进行了搜索，<code class="fe ma mb mc md b">showSearch</code>函数将从API返回匹配输入的标题。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ml"><img src="../Images/2800b494214b11ae671084793ae57674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRBGCqciEUSC2SRWjHK_DQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">在搜索结果中显示搜索函数</figcaption></figure><p id="21ae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">由于影响应用程序状态的<code class="fe ma mb mc md b">searchTitles</code>属性的动作的设置方式，当您在搜索栏中键入时，<code class="fe ma mb mc md b">showSearch</code>功能会被实时触发。只要输入返回这些标题，这些显示的标题就只存在于状态中；例如，如果用户删除了一个字符，顶部的结果将根据API找到的匹配而改变。如前图所示，如果输入返回到一个空字符串，那么<code class="fe ma mb mc md b">searchTitles</code>也将返回到一个空字符串。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mm"><img src="../Images/e7cf04b70dbe92044aa8b49579c7d5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3H4c9FMOmOJ8qehyMhXaQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">搜索结果中的rollNominated函数</figcaption></figure><p id="9a18" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这两个函数中，您会注意到有一个名为<code class="fe ma mb mc md b">source</code>的<code class="fe ma mb mc md b">const</code>。这个<code class="fe ma mb mc md b">const</code>就在那里，并被传递给所有处理状态的函数，无论是<code class="fe ma mb mc md b">allNominatedTitles</code>还是<code class="fe ma mb mc md b">currentUserTitles</code>，并直接处理来自API的任何返回。这对于当前版本的应用程序来说是必需的，因为从API返回的单个对象(<em class="lt">由于某种原因</em>)是用大写字母作为属性名构造的，而我的数据库是用小写字母构造的(<em class="lt">你知道，</em> <em class="lt">就像一个正常人</em>)。之所以这样做，是因为我在构建后期遇到的错误有时会出现，有时不会，当我发现如何修复这些问题时，我只剩下大约6个小时了，而且手头上还有比重构数据库迁移和种子文件更紧迫的问题。我在下面画出了使用这些源变量的函数。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mk"><img src="../Images/285bfb7b4e6cab2ee5887408eed74c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3HmaQAV9OzbZkc7kgr_i_A.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">使用源常量的其他函数</figcaption></figure><p id="5451" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">设置基于这些源变量的条件是因为state的<code class="fe ma mb mc md b">currentUserTitles</code>和<code class="fe ma mb mc md b">allNominatedTitles</code>属性从发送到我的后端的获取请求中提取。那么每当提名一个标题时，在数据库中创建一个条目。每个标题只有一个条目，它收到的每个提名的匹配条目都有一个简单的<code class="fe ma mb mc md b">user_id</code>和<code class="fe ma mb mc md b">title_id</code>作为数据。一个用户只能提名一个标题一次。</p><p id="e15a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我一直在纠结如何包装这些东西，所以，谢谢你们来听我的ted演讲。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mn"><img src="../Images/a3dbd50d88eff1e3b9cfeb457268cf0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*2WfMKRZvyLlmt7vCNbuidA.gif"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">应用程序运行的gif</figcaption></figure><p id="19de" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你想亲自体验这款应用，<a class="ae kw" href="https://shopifychallengejvckmo.netlify.app" rel="noopener ugc nofollow" target="_blank">请便</a>。我知道我打算修复几个bug，但是如果你自己发现了任何bug并且想告诉我，请随时直接回复这个帖子或者发电子邮件给我，地址是<strong class="kz ir"><em class="lt">jvckmo@gmail.com</em></strong>。</p><p id="56ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">附言</p><p id="6949" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">未命名的加拿大电商平台(没错就是那个)，请录用我。</p></div></div>    
</body>
</html>