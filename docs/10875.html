<html>
<head>
<title>Pure Functions in Software Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件开发中的纯函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pure-functions-in-software-development-d315a4520da1?source=collection_archive---------16-----------------------#2022-01-18">https://levelup.gitconnected.com/pure-functions-in-software-development-d315a4520da1?source=collection_archive---------16-----------------------#2022-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d5f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简单介绍一下纯函数以及它们如何帮助我们拥有一个好的可测试架构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5a2a58672dac549746033cc4af1ff516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MoSPUecqrWkO7TbY"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">安特·罗泽茨基在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="809f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当我们想到<strong class="ky ir">的纯净</strong>与<strong class="ky ir">的不纯净</strong>时，我们都努力得到尽可能接近100%纯净的东西。</p><p id="40f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">软件开发对纯度有同样的偏好吗？</p><h1 id="b267" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是软件开发中的纯函数？</h1><div class="mk ml gp gr mm mn"><a href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">纯功能-维基百科</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">在计算机程序设计中，一个纯函数是一个具有以下性质的函数:函数返回值…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">en.wikipedia.org</p></div></div><div class="mw l"><div class="mx l my mz na mw nb kp mn"/></div></div></a></div><p id="524a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在<em class="nc">维基百科上查找，</em>我们会注意到这些纯函数有两个属性:</p><ol class=""><li id="44ab" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">用相同的参数调用时，函数的返回值总是相同的</li><li id="10f8" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">功能应用没有副作用</li></ol><p id="88a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯……让我们用一些实际例子来更好地理解它:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="4d2c" class="nw lt iq ns b gy nx ny l nz oa">int sum(int a, int b) {<br/>  return a + b;<br/>}</span></pre><p id="530a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nc"> sum </em>函数是否尊重纯函数的两个性质？</p><p id="28a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，对于相同的<em class="nc"> a </em>和<em class="nc"> b </em>值，我们将总是得到这些值的总和，而且，无论它在内部做什么，它都不会改变应用程序/模块的状态。</p><p id="e8dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们尝试一个反例:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="8c4f" class="nw lt iq ns b gy nx ny l nz oa">DateTime giveMeTheCurrentDate() {<br/>  return DateTime();<br/>}</span></pre><p id="48a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们经历同样的过程？是否违背了纯函数的两个性质中的任何一个？</p><p id="786d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对第一个来说是这样的:每次我们调用它，结果都会不同，因为尽管我们很想这么做，但我们无法冻结时间😭</p><p id="3f4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而现在的<strong class="ky ir">100万美元问题</strong>？如果我们不能控制它并得到一个确定的结果，我们怎么能为它编写一个单元测试或任何类型的测试，并保证一切都按预期工作呢？</p><p id="aa5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">是时候引入一些新的工具和概念了:</strong></p><ul class=""><li id="19e9" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ob nj nk nl bi translated">从属倒置原则</li><li id="47bf" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ob nj nk nl bi translated">控制世界</li></ul><p id="c854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，<strong class="ky ir">依赖倒置原则</strong>声明我们不应该依赖具体类型，而应该依赖抽象。</p><p id="4b89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这在<strong class="ky ir"> Flutter </strong>中会是什么样子(<em class="nc">抽象类</em>与其他语言中的<em class="nc">接口</em>等价——如果乍一看很怪异的话)</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="16af" class="nw lt iq ns b gy nx ny l nz oa">abstract class IDateManager {<br/>  DateTime retrieveDate();<br/>}</span><span id="c356" class="nw lt iq ns b gy oc ny l nz oa">class ConcreteDateManager implements IDateManager {<br/>  <a class="ae kv" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  DateTime retrieveDate() {<br/>    return DateTime.now();<br/>  }<br/>}</span><span id="f05b" class="nw lt iq ns b gy oc ny l nz oa">class DateService {<br/>  DateTime giveMeTheCurrentDate(IDateManager manager) {<br/>    return manager.retrieveDate();<br/>  }<br/>}</span></pre><p id="f477" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想获得具体实现的日期，这是一个不纯粹的函数，我们可以这样调用它:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="58db" class="nw lt iq ns b gy nx ny l nz oa">final currentDate = DateService()<br/>    .giveMeTheCurrentDate(ConcreteDateManager());</span></pre><p id="be3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，一个纯函数会是什么样子呢？</p><p id="254b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为我们的单元测试创建另一个确定性的类:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="0251" class="nw lt iq ns b gy nx ny l nz oa">class DummyDateManager implements IDateManager {<br/>  <a class="ae kv" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  DateTime retrieveDate() {<br/>    return DateTime.fromMicrosecondsSinceEpoch(1642167154);<br/>  }<br/>}</span></pre><p id="5ffa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们用<em class="nc"> DummyDateManager </em>调用<em class="nc"> DateService </em>，它将始终产生相同的结果<em class="nc">2022年1月14日星期五，13:32:34 </em></p><blockquote class="od"><p id="04dd" class="oe of iq bd og oh oi oj ok ol om lr dk translated">控制我们的依赖和环境使我们能够快速编写单元测试用例，并轻松重用代码库的部分内容。</p><p id="55bd" class="oe of iq bd og oh oi oj ok ol om lr dk translated">毕竟，当你写一段代码的时候，你就是它的创造者；为什么你不能控制时间？</p></blockquote><p id="157e" class="pw-post-body-paragraph kw kx iq ky b kz on jr lb lc oo ju le lf op lh li lj oq ll lm ln or lp lq lr ij bi translated">我们包里的第二个工具是<strong class="ky ir">控制世界</strong>:我们的世界。在不涉及太多细节的情况下(因为这将在后面的故事中涉及)，这个想法是，所有外部不确定的依赖关系，如时间、存储、网络、设备传感器，都可以通过在应用程序/模块中可用的<em class="nc">环境</em>结构或<em class="nc">服务定位器</em>内部的具体实现来实例化。它可能看起来像这样:</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="399b" class="nw lt iq ns b gy nx ny l nz oa">void setupEnvironment() {<br/>  serviceLocator.registerFactory&lt;IDateManager&gt;(() =&gt; ConcreteDateManager());<br/>}</span></pre><p id="3eb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了在<em class="nc"> DateService、</em>中使用它，我们可以使用服务定位器(抛弃抽象参数<em class="nc">管理器</em>):</p><pre class="kg kh ki kj gt nr ns nt nu aw nv bi"><span id="8b22" class="nw lt iq ns b gy nx ny l nz oa">class DateService {<br/>  DateTime giveMeTheCurrentDate() {<br/>    return serviceLocator&lt;IDateManager&gt;().retrieveDate();<br/>  }<br/>}</span></pre></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="f266" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢你花时间阅读以上所有内容，我希望这个故事能帮助你提高一点点水平。此外，请不要犹豫将知识传播给其他开发人员。</p><div class="mk ml gp gr mm mn"><a href="https://medium.com/@catalin.patrascu/membership" rel="noopener follow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd ir gy z fp ms fr fs mt fu fw ip bi translated">用我的推荐链接加入媒体- Catalin Patrascu</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">阅读Catalin Patrascu的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">medium.com</p></div></div><div class="mw l"><div class="oz l my mz na mw nb kp mn"/></div></div></a></div></div></div>    
</body>
</html>