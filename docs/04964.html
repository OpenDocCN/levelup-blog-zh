<html>
<head>
<title>How To Turn SetTimeout and SetInterval Into Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何把SetTimeout和SetInterval变成承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-turn-settimeout-and-setinterval-into-promises-6a4977f0ace3?source=collection_archive---------1-----------------------#2020-07-27">https://levelup.gitconnected.com/how-to-turn-settimeout-and-setinterval-into-promises-6a4977f0ace3?source=collection_archive---------1-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7bb4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何承诺JavaScript计时器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ba3ad6d256ff21d5798943071dc6c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjC8FP5gPbBKkTEEk8J-2w.png"/></div></div></figure><p id="3c75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你曾经想要<code class="fe lq lr ls lt b">then</code>或<code class="fe lq lr ls lt b">await</code> JavaScript的<code class="fe lq lr ls lt b">setTimeout</code>或<code class="fe lq lr ls lt b">setInterval</code>功能，你并不孤单。我不得不在工作中多次使用这些方法来处理一些… <em class="lu">有趣的… </em>第三方行为，所以我终于熟悉了承诺函数。<code class="fe lq lr ls lt b"><a class="ae lv" href="https://www.w3schools.com/jsref/met_win_settimeout.asp" rel="noopener ugc nofollow" target="_blank">setTimeout</a></code>可能很简单，而<code class="fe lq lr ls lt b"><a class="ae lv" href="https://www.w3schools.com/jsref/met_win_setinterval.asp" rel="noopener ugc nofollow" target="_blank">setInterval</a></code>有点复杂，所以确保你理解<a class="ae lv" href="https://medium.com/@mostlyfocusedmike/promises-promises-understanding-the-basics-of-js-promise-objects-dd5c656f2db4" rel="noopener">承诺</a>。</p><h1 id="793e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">TL:DR；代码</h1><pre class="kj kk kl km gt mo lt mp mq aw mr bi"><span id="39ad" class="ms lx it lt b gy mt mu l mv mw"><em class="lu">const</em> <strong class="lt iu">sleep</strong> = <em class="lu">async</em> (<strong class="lt iu">ms</strong>) =&gt; {<br/>    return <em class="lu">new</em> <strong class="lt iu">Promise</strong>(<strong class="lt iu">resolve</strong> =&gt; <strong class="lt iu">setTimeout</strong>(<strong class="lt iu">resolve</strong>, <strong class="lt iu">ms</strong>));<br/>}</span><span id="8fcc" class="ms lx it lt b gy mx mu l mv mw"><em class="lu">const</em> <strong class="lt iu">asyncInterval</strong> = <em class="lu">async</em> (<strong class="lt iu">callback</strong>, <strong class="lt iu">ms</strong>, <strong class="lt iu">triesLeft</strong> = 5) =&gt; {<br/>  return <em class="lu">new</em> <strong class="lt iu">Promise</strong>((<strong class="lt iu">resolve</strong>, <strong class="lt iu">reject</strong>) =&gt; {<br/>    <em class="lu">const</em> <strong class="lt iu">interval</strong> = <strong class="lt iu">setInterval</strong>(<em class="lu">async</em> () =&gt; {<br/>      if (<em class="lu">await</em> <strong class="lt iu">callback</strong>()) {<br/>        <strong class="lt iu">resolve</strong>();<br/>        <strong class="lt iu">clearInterval</strong>(interval);<br/>      } else if (<strong class="lt iu">triesLeft</strong> &lt;= 1) {<br/>        <strong class="lt iu">reject</strong>();<br/>        <strong class="lt iu">clearInterval</strong>(<strong class="lt iu">interval</strong>);<br/>      }<br/>      <strong class="lt iu">triesLeft</strong>--;<br/>    }, <strong class="lt iu">ms</strong>);<br/>  });<br/>}</span></pre><p id="ac57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是了，如果你想知道为什么，请看下面！但如果这就是你所需要的，很高兴我能帮上忙！</p><h1 id="3e5b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">如何承诺设置超时</h1><p id="5c81" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">以这段代码为例:</p><pre class="kj kk kl km gt mo lt mp mq aw mr bi"><span id="d558" class="ms lx it lt b gy mt mu l mv mw"><em class="lu">const</em> <strong class="lt iu">foo</strong> = () =&gt; {<br/>    <strong class="lt iu">setTimeout</strong>(() =&gt; {<br/>        <strong class="lt iu">console</strong>.log('<em class="lu">Callback based stuff'</em>);<br/>        <strong class="lt iu">console</strong>.log('<em class="lu">yet another thing</em>');<br/>        // lots more stuff<br/>    }, 2000);<br/>}</span></pre><p id="264d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于<code class="fe lq lr ls lt b">setTimeout</code>恼人的事情是所有东西都必须放在回调函数中。如果有很多事情要做，会变得很麻烦。但是当我们使用<code class="fe lq lr ls lt b">await</code>时，不需要额外的回调:</p><pre class="kj kk kl km gt mo lt mp mq aw mr bi"><span id="a407" class="ms lx it lt b gy mt mu l mv mw">const <strong class="lt iu">asyncFoo</strong> = <em class="lu">async</em> () =&gt; {<br/>    <em class="lu">await</em> <em class="lu">new</em> <strong class="lt iu">Promise</strong>((<strong class="lt iu">resolve</strong>) =&gt; <strong class="lt iu">setTimeout</strong>(<strong class="lt iu">resolve</strong>, 2000));<br/>    <strong class="lt iu">console</strong>.log('<em class="lu">nice</em>');<br/>    <strong class="lt iu">console</strong>.log('<em class="lu">way</em> <em class="lu">better</em>');<br/>}</span></pre><p id="9824" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里发生了什么事？嗯，如你所知，<a class="ae lv" href="https://medium.com/@mostlyfocusedmike/promises-promises-understanding-the-basics-of-js-promise-objects-dd5c656f2db4" rel="noopener">承诺实际上只是在事情发生后调用一个解决</a>函数或拒绝函数。我们正在做的是创建一个新的<code class="fe lq lr ls lt b">Promise</code>，而不是传入一个对<code class="fe lq lr ls lt b">setTimeout</code>的回调，而是传入<code class="fe lq lr ls lt b">resolve</code>。这样，经过几毫秒后，调用的是<code class="fe lq lr ls lt b">resolve</code>,我们的承诺被触发并解决。然后我们可以做任何我们想做的事情。很简单……但也可以更简单。</p><h1 id="2137" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">创建睡眠功能</h1><p id="52dc" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">人们倾向于像使用暂停按钮一样使用<code class="fe lq lr ls lt b">setTimeout</code>功能。其他语言有一个<code class="fe lq lr ls lt b">sleep</code>功能，可以在设定的时间内暂停它们的程序。我们做一个吧！</p><pre class="kj kk kl km gt mo lt mp mq aw mr bi"><span id="0c4f" class="ms lx it lt b gy mt mu l mv mw"><em class="lu">const</em> <strong class="lt iu">sleep</strong> = (<strong class="lt iu">ms</strong>) =&gt; {<br/>  return <em class="lu">new</em> <strong class="lt iu">Promise</strong>(<strong class="lt iu">resolve</strong> =&gt; <strong class="lt iu">setTimeout</strong>(<strong class="lt iu">resolve</strong>, <strong class="lt iu">ms</strong>));<br/>}</span><span id="82f6" class="ms lx it lt b gy mx mu l mv mw"><em class="lu">const</em> <strong class="lt iu">asyncFoo</strong> = <em class="lu">async</em> () =&gt; {<br/>    <em class="lu">await</em> <strong class="lt iu">sleep</strong>(2000);<br/>    <strong class="lt iu">console</strong>.log('<em class="lu">look at this</em>');<br/>    <em class="lu">await</em> <strong class="lt iu">sleep</strong>(1000);<br/>    <strong class="lt iu">console</strong>.log('<em class="lu">getting fancy now</em>');<br/>}</span></pre><p id="27f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个简单的实用函数，非常有用，尤其是在不止一次使用它的情况下，因为嵌套<code class="fe lq lr ls lt b">setTimeout</code>看起来真的很可怕。</p><h1 id="64fa" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">承诺设置间隔</h1><p id="0395" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">如果你想让<code class="fe lq lr ls lt b">setInterval</code>永远运行，你会陷入困境，但如果你只是想用它来处理几次重试，然后继续前进，它可以工作。为此，我们将使用与之前相同的<code class="fe lq lr ls lt b">resolve</code>技巧，但我们也将增加最大尝试次数。如果到那时我们还没有得到什么，我们将继续使用<code class="fe lq lr ls lt b">reject</code>。我们必须将我们尝试任务(一个假的服务器检查)包装到一个函数中，它必须返回true或false:</p><pre class="kj kk kl km gt mo lt mp mq aw mr bi"><span id="8424" class="ms lx it lt b gy mt mu l mv mw"><em class="lu">// task must return true or false</em><br/><em class="lu">const</em> <strong class="lt iu">fakeServerCheck</strong> = async () =&gt; {<br/>  <strong class="lt iu">console</strong>.log('<em class="lu">check...</em>');<br/>  return <strong class="lt iu">Math</strong>.random() &gt; 0.8;<br/>}</span><span id="4201" class="ms lx it lt b gy mx mu l mv mw"><em class="lu">const</em> <strong class="lt iu">asyncInterval</strong> = <em class="lu">async</em> (<strong class="lt iu">callback</strong>, <strong class="lt iu">ms</strong>, <strong class="lt iu">triesLeft</strong> = 5) =&gt; {<br/>  return <em class="lu">new</em> <strong class="lt iu">Promise</strong>((<strong class="lt iu">resolve</strong>, <strong class="lt iu">reject</strong>) =&gt; {<br/>    <em class="lu">const</em> <strong class="lt iu">interval</strong> = <strong class="lt iu">setInterval</strong>(<em class="lu">async</em> () =&gt; {<br/>      if (<em class="lu">await</em> <strong class="lt iu">callback</strong>()) {<br/>        <strong class="lt iu">resolve</strong>();<br/>        <strong class="lt iu">clearInterval</strong>(interval);<br/>      } else if (<strong class="lt iu">triesLeft</strong> &lt;= 1) {<br/>        <strong class="lt iu">reject</strong>();<br/>        <strong class="lt iu">clearInterval</strong>(<strong class="lt iu">interval</strong>);<br/>      }<br/>      <strong class="lt iu">triesLeft</strong>--;<br/>    }, <strong class="lt iu">ms</strong>);<br/>  });<br/>}</span><span id="0a27" class="ms lx it lt b gy mx mu l mv mw"><em class="lu">const</em> <strong class="lt iu">wrapper</strong> = <em class="lu">async</em> () =&gt; {<br/>  try {<br/>    <em class="lu">await</em> <strong class="lt iu">asyncInterval</strong>(<strong class="lt iu">fakeServerCheck</strong>, 500);<br/>  } catch (e) {<br/>    <strong class="lt iu">console</strong>.log('<em class="lu">error handling</em>');<br/>  }<br/>  <strong class="lt iu">console</strong>.log("Done!");<br/>}</span><span id="0c06" class="ms lx it lt b gy mx mu l mv mw"><strong class="lt iu">wrapper</strong>();</span></pre><p id="ca96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的秘诀是我们的任务函数返回一个布尔值。这样，我们就能知道是否要继续前进。你还会注意到我在<code class="fe lq lr ls lt b">callback</code>前添加了一个<code class="fe lq lr ls lt b">await</code>，尽管<code class="fe lq lr ls lt b">fakeServerCheck</code>是同步的。这是因为在现实生活中，这个函数可能会做一些事情<code class="fe lq lr ls lt b">async</code>，我正试图使<code class="fe lq lr ls lt b">asyncInterval</code>函数尽可能的可剪切和可复制。</p><h1 id="7aad" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">现在一切都匹配了</h1><p id="9096" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">这就对了。有了这两个功能，<code class="fe lq lr ls lt b">sleep</code>和<code class="fe lq lr ls lt b">asyncInterval</code>，你就不会有定时回调和常规承诺的尴尬组合。我知道使用这种计时器并不常见，但是如果你真的发现自己在使用它们，这应该会很有帮助。</p><p id="cd6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="cc71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>