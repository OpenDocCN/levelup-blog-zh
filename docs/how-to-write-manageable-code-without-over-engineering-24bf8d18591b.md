# 如何在不过度工程化的情况下编写可管理的代码

> 原文：<https://levelup.gitconnected.com/how-to-write-manageable-code-without-over-engineering-24bf8d18591b>

![](img/b8e475144eb371d5d01d0417d70a508e.png)

图片来源:[aviation.stackexchange.com](https://aviation.stackexchange.com/)

基本上可管理的代码是指无需太多更改即可轻松扩展的代码。如果我们的代码库易于管理，我们将拥有以下众所周知的优势。

*   新来者将能够在短时间内理解和添加新功能。
*   当开发团队很大时，减少 git 冲突。
*   无需修改太多文件或位置，即可轻松添加新功能。

考虑这个非常简单的例子

```
let action1Clicked = () => {
  // some common logic same as action2Clicked
  // specific logic
}let action2Clicked = () => {
  // some common logic same as action1Clicked
  // specific logic
}
```

我们可以清楚地看到，这两种方法都有重复的逻辑。事实上，如果我们需要改变共同的逻辑，我们将不得不修改两个地方。因此，让我们按如下方式重构它。

```
let commonLogic() => {
  // common logic goes here
}let action1Clicked = () => {
  commonLogic();
  // some specific logic
}let action2Clicked = () => {
  commonLogic();
  // some specific logic
}
```

如果您认为最好的方法是创建一个新的模块，那么本文就是为您准备的。

## 过度工程化

> 凡事都有个限度，否则会有不好的副作用。

根据您的喜好，您可以对一组良好链接的类或良好链接的模块使用良好的逻辑分解。因此，您可以明智地将每个类或模块的责任分配给多个方法。如果我们做得太多，除了引入不必要的复杂性之外，没有任何收益，那会怎么样呢？

如果我们在纸上画一条直线，我们可以说左边的角代表最糟糕的代码，它根本不可管理，看起来也很乱，右边的角代表最过度设计的垃圾代码，看起来也很乱。因此，我们需要根据我们正在解决的问题，在这两个边缘之间平衡我们代码库的质量。

我想给你 3 个原则来写易于管理但不过度工程化的代码。

## 1.摆脱虚构特征的困境

当一个特定的特性被实现时，可能会有将来需要的特性。因此，您可以通过添加更多的类/模块或方法来增加代码的灵活性。

示例:

假设一个外部 API 返回摄氏温度，但您需要显示华氏温度，可以引入一个简单的实用函数在呈现之前进行转换。另一方面，假设将来会有更多的温度单位，我们也可以为整个温度单位转换引入新的模块/类。然而，无论是外部 API 还是您的应用程序在将来都不会改变它的单位。不知何故，如果用户要求开尔文作为一个显示单元，它将只是另一个实用功能。

在实现特定功能之前，最好先确定哪些功能是真实的，哪些功能是虚构的。

## 2.控制分解的程度

将逻辑分解成模块/类或方法是非常好的，但是理解分解的层次也是必须的。分解和组织良好的代码库通常具有高度可重用的组件。但是有时候，原子级的分解增加了项目的复杂性，却没有投资回报。重要的是，分解的级别显然取决于我们正在解决的问题。例如，当当前计划的分离级别有明显的增长，或者当未分离的元素显示出可重用的用例时，更深一点的逻辑分离是很好的。

示例:

假设您正在编写一个 CLI 程序，有一个命令将使用磁盘上的一些现有文件创建一个 zip 文件。有人可能会创建一个模块/类来处理这个任务，或者为压缩文件、压缩文件、将文件写入磁盘等等创建一组模块/类。如果没有人会重用那些东西；除了增加项目的复杂性之外，这样做没有任何好处。

这一点也适用于现代软件架构；现在，人们倾向于为一个最多只有数百个用户的应用程序创建数百个微服务。

## 3.不要想太多

DRY(不要重复自己)是通过重用现有的东西或者编写更多可扩展的代码来减少额外工作的好习惯。然而，并非所有的东西都可以转换成干净的可重用元素。

示例:

```
let someAlgorithm = (myParam_1.. MyParam_n) => {
   // some logic
}
```

假设您需要添加另一个看起来相同的算法，但根据参数，这里和那里有许多差异。诚然，写`anotherAlgorithm`方法比用大量条件语句严格复用`someAlgorithm`要好。

## 结论

一个良好设计和管理的代码库是好的。然而，确保你不要过度设计，因为它有更多的副作用。将工程学原理应用于一个问题应该会简化它，而不是让一切都变得过于复杂。

编码快乐！🥳