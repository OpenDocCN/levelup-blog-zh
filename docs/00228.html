<html>
<head>
<title>How to Create Custom HTML Markers on Google Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在谷歌地图上创建自定义HTML标记</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-custom-html-markers-on-google-maps-9ff21be90e4b?source=collection_archive---------0-----------------------#2018-10-09">https://levelup.gitconnected.com/how-to-create-custom-html-markers-on-google-maps-9ff21be90e4b?source=collection_archive---------0-----------------------#2018-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="717b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何用HTML &amp; CSS，ES6类和闭包在谷歌地图上创建标记</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/63b8a4e8a01497656daafcfd8f602ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWTltmi3hvgfQawopMvnmw.jpeg"/></div></div></figure><p id="848f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在谷歌地图上创建标记的默认方法(当使用谷歌地图的JavaScript API时)是使用图像或SVG路径，这限制了开发的可能性。本教程将介绍如何使用HTML和CSS在谷歌地图上创建地图标记。该技术涉及扩展Google Map的库类<code class="fe ky kz la lb b">OverlayView</code>，这带来了自身的挑战，因此我们还将介绍如何异步扩展我们的新类，以避免构建问题、竞争条件和重复依赖。</p><h1 id="2c14" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">地图和标记是如何制作的</h1><p id="ccb1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在现代应用中，大多数依赖项将通过包管理器(如npm或yarn)添加，通过<code class="fe ky kz la lb b">import</code>语句在代码中使用，并通过构建工具(如webpack)在构建时捆绑成高性能代码块。另一方面，谷歌地图通常通过脚本标签加载到webapp的HTML文件中，然后将谷歌地图JavaScript库放在全局对象(<code class="fe ky kz la lb b">window.google</code>)上，供运行时使用。</p><p id="6a2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Google Maps JavaScript API中的每个特性在<code class="fe ky kz la lb b">google.maps</code>的父名称空间下都有自己的类/名称空间。向地图添加标记的最简单方法是使用位于<code class="fe ky kz la lb b">google.maps.Marker</code>的<a class="ae mf" href="https://developers.google.com/maps/documentation/javascript/reference/marker#Marker" rel="noopener ugc nofollow" target="_blank">标记类</a>。这个用于在地图上创建标记的接口仅限于接受两种类型的标记内容实体:图像或SVG路径。这对于许多用例来说都很好，但是也引入了对开发人员如何处理地图上的标记的限制。</p><p id="9df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Google Maps JavaScript API也有一个更通用的类用于在地图上创建实体:位于<code class="fe ky kz la lb b">google.maps.OverlayView</code>的<a class="ae mf" href="https://developers.google.com/maps/documentation/javascript/reference/overlay-view#OverlayView" rel="noopener ugc nofollow" target="_blank"> OverlayView类</a>。文档称这些<em class="kl">自定义覆盖图为</em>，并将它们定义为“地图上与纬度/经度坐标相关的对象，因此当你拖动或缩放地图时，它们会移动。”</p><p id="3f02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这听起来很像使用marker类定义的地图标记！事实证明，<code class="fe ky kz la lb b">google.maps.Marker</code>只是一个预定义的覆盖类型。因此，通过利用<code class="fe ky kz la lb b">OverlayView</code>类，开发人员可以使用适合给定项目的任何HTML内容来创建地图标记。由于自定义覆盖图的内容只是HTML，CSS和JavaScript都可以通过元素的id和/或类属性来定位自定义覆盖图，从而允许对行为、更灵活的内容和CSS动画进行更精细的控制！</p><h1 id="11a7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建HTMLMapMarker类</h1><p id="b2fc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我们将创建一个名为<code class="fe ky kz la lb b">HTMLMapMarker</code>的ES6类，它扩展了<code class="fe ky kz la lb b">OverlayView</code>类。构造函数将接受三个参数:</p><ol class=""><li id="01d7" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">纬度/经度对象。这将是另一个Google Maps类的实例，<a class="ae mf" href="https://developers.google.com/maps/documentation/javascript/reference/coordinates" rel="noopener ugc nofollow" target="_blank">lating类</a> ( <code class="fe ky kz la lb b">google.maps.LatLng</code>)。这个类的构造函数接受两个<code class="fe ky kz la lb b">Number</code>参数，分别代表地图上标记应该放置的位置的纬度和经度。</li><li id="c130" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">应该用作标记内容的HTML。这是用字符串表示的HTML。对于用webpack构建的更复杂的应用程序，这可以是通过<a class="ae mf" href="https://github.com/webpack-contrib/html-loader" rel="noopener ugc nofollow" target="_blank"> html-loader </a>导入的HTML文件。</li><li id="99cc" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">将放置标记的Google地图实例。</li></ol><p id="cfe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的类还需要实现四个方法来满足一个<code class="fe ky kz la lb b">OverlayView</code>的要求:</p><ol class=""><li id="5a29" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><code class="fe ky kz la lb b">draw()</code>。此方法将用于在地图上绘制标记。</li><li id="5153" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe ky kz la lb b">remove()</code>。此方法将用于从地图中移除标记。</li><li id="aa81" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe ky kz la lb b">getPosition()</code>。该方法将用于跟踪标记放置的位置(纬度/经度)。</li><li id="efeb" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe ky kz la lb b">getDraggable()</code>。这个方法将决定我们的标记是否是可拖动的。既然不是，这个方法就简单的返回<code class="fe ky kz la lb b">false</code>。</li></ol><p id="0a4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从类定义和构造函数开始。我们将通过一个具有上述三个属性的<code class="fe ky kz la lb b">args</code>对象将参数传递给构造函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0e4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，传递给构造函数的LatLng和HTML只是保存为同名的实例属性(<code class="fe ky kz la lb b">this.latlng</code>和<code class="fe ky kz la lb b">this.html</code>)。然而,<code class="fe ky kz la lb b">map</code>的实例可以马上使用。在构造函数中，我们调用继承自扩展<code class="fe ky kz la lb b">OverlayView</code>的<code class="fe ky kz la lb b">setMap</code>方法，传入<code class="fe ky kz la lb b">map</code>实例，有效地将新标记链接到页面上当前的<code class="fe ky kz la lb b">map</code>实例。</p><p id="633e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们继续讨论<code class="fe ky kz la lb b">draw</code>方法。这个方法将为这个类完成大部分繁重的工作。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2cd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是检查<code class="fe ky kz la lb b">this.div</code>是否被定义。这是实例属性，它将保存最终放置在地图上的<code class="fe ky kz la lb b">&lt;div&gt;</code>元素。如果不是，我们通过<code class="fe ky kz la lb b">document.createElement(“div”)</code>创建一个新的<code class="fe ky kz la lb b">&lt;div&gt;</code>并存储在<code class="fe ky kz la lb b">this.div</code>中，并将其<code class="fe ky kz la lb b">position</code>设置为<code class="fe ky kz la lb b">absolute</code>。</p><p id="8c88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从构造函数分配给<code class="fe ky kz la lb b">this.html</code>的HTML然后被设置为<code class="fe ky kz la lb b">&lt;div&gt;</code>的<code class="fe ky kz la lb b">innerHTML</code>属性，定义元素的HTML内容。</p><p id="4a02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在方法的第8行，我们使用<code class="fe ky kz la lb b">google.maps.event</code>类方法<code class="fe ky kz la lb b">addDomLister</code>向我们的新div添加一个事件监听器。该方法将<code class="fe ky kz la lb b">this.div</code>作为第一个参数，将事件名称(‘click’)作为第二个参数，将事件发生时要执行的回调作为第三个参数。在我们的例子中，回调参数只需要将点击事件传递给<code class="fe ky kz la lb b">this</code>，一旦我们使用了我们的类，它就变成了创建的标记。稍后将详细介绍。</p><p id="d966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">draw</code>方法的第10行使用从<code class="fe ky kz la lb b">OverlayView</code>继承的<code class="fe ky kz la lb b">getPanes</code>方法来获取当前地图实例的窗格。谷歌地图将窗格称为不同的层，实体可以放置在这些层中，以便在地图上显示。有关可用窗格的更多信息，您可以<a class="ae mf" href="https://developers.google.com/maps/documentation/javascript/reference/overlay-view#MapPanes" rel="noopener ugc nofollow" target="_blank">阅读此处的文档</a>。我们使用<code class="fe ky kz la lb b">overlayImage</code>窗格的<code class="fe ky kz la lb b">appendChild</code>方法来追加存储在<code class="fe ky kz la lb b">this.div</code>中的<code class="fe ky kz la lb b">&lt;div&gt;</code>元素。</p><p id="e2c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">draw</code>方法的最后一步是将新放置的<code class="fe ky kz la lb b">&lt;div&gt;</code>定位到正确的纬度/经度。这可以通过用继承的方法<code class="fe ky kz la lb b">getProjection</code>获取地图投影，然后在返回的投影上调用<code class="fe ky kz la lb b">fromLatLngToDivPixel</code>方法来完成。该方法将提供的纬度/经度转换为屏幕上相应的x，y位置。然后我们将div的<code class="fe ky kz la lb b">left</code>和<code class="fe ky kz la lb b">top</code>属性分别定位到x和y值。这也是添加基于像素的偏移来精确调整呈现元素的位置的最佳位置。在本文底部的演示中，您会注意到我在高度和宽度上添加了25px的偏移量，因为图像是50px的平方，期望的效果是图像在提供的纬度/经度上居中。</p><p id="11ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的类的<code class="fe ky kz la lb b">draw</code>方法是完整的，但是一点点重构真的可以提高可读性。我选择将函数的逻辑重构为三个助手方法，这三个方法根据它们的功能命名:<code class="fe ky kz la lb b">createDiv</code>、<code class="fe ky kz la lb b">appendDivToOverlay</code>和<code class="fe ky kz la lb b">positionDiv</code>。下面是重构后的方法，以及它使用的助手方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2637" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们准备继续使用<code class="fe ky kz la lb b">remove</code>方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3574" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个方法只是检查存储在<code class="fe ky kz la lb b">this.div</code>中的HTML元素是否存在。如果它存在，我们可以通过从div的<code class="fe ky kz la lb b">parentNode</code>调用<code class="fe ky kz la lb b">removeChild</code>将其从DOM中移除。一旦从DOM中移除，我们还将<code class="fe ky kz la lb b">this.div</code>设置为<code class="fe ky kz la lb b">null</code>，这样实例引用也被移除。</p><p id="e4e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剩下的方法，<code class="fe ky kz la lb b">getPosition</code>和<code class="fe ky kz la lb b">getDraggable</code>都非常简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9f67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">getPosition</code>方法只返回保存在构造函数<code class="fe ky kz la lb b">this.latlng</code>中的纬度/经度，而<code class="fe ky kz la lb b">getDraggable</code>只返回布尔值<code class="fe ky kz la lb b">false</code>，因为我们的标记是不可拖动的。</p><p id="6a1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经完成了类的定义。最终的类定义应该如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="5d16" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在运行时定义OverlayView</h1><p id="adb1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">因为我们扩展了Google Maps JavaScript库提供的<code class="fe ky kz la lb b">OverlayView</code>类，所以我们需要保证在扩展它的时候已经定义了<code class="fe ky kz la lb b">google.maps.OverlayView</code>。</p><p id="1b16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在构建一个不使用构建过程的应用程序，您也许能够将<code class="fe ky kz la lb b">HTMLMapMarker</code>类定义为直接扩展<code class="fe ky kz la lb b">OverlayView</code>。如果在定义类的时候已经定义了全局<code class="fe ky kz la lb b">google.maps</code>对象，那么可以直接扩展这个类:</p><pre class="kn ko kp kq gt mw lb mx my aw mz bi"><span id="a1ac" class="na ld iq lb b gy nb nc l nd ne">class HTMLMapMarker extends google.maps.OverlayView {</span></pre><p id="2d0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果你在一个有任何构建过程的项目中工作，当你试图用它来扩展<code class="fe ky kz la lb b">HTMLMapMarker</code>类时，很有可能<code class="fe ky kz la lb b">google.maps.OverlayView</code>还没有被定义。虽然将<code class="fe ky kz la lb b">OverlayView</code>类直接添加到项目代码中可能会解决这个问题，但这会导致重复的代码，因为<code class="fe ky kz la lb b">OverlayView</code>总是在Google Maps库加载时被加载。</p><p id="4c3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢闭包的力量，我们可以包装我们的类定义，这样保证在使用它的时候定义好了<code class="fe ky kz la lb b">google.maps.OverlayView</code>。没有竞争条件，没有重复的代码。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/870fc63d163ea4dbe939b67b86bde926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAtO25mhi5dKlOzc8m9a-g.jpeg"/></div></div></figure><p id="3b43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将闭包函数命名为<code class="fe ky kz la lb b">createHTMLMapMarker</code>。这个函数接受一个具有两个属性的对象:一个具有默认值<code class="fe ky kz la lb b">google.maps.OverlayView</code>的<code class="fe ky kz la lb b">OverlayView</code>属性，以及一个<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> rest操作符</a> ( <code class="fe ky kz la lb b">…args</code>)来收集调用时传递给<code class="fe ky kz la lb b">createHTMLMapMarker</code>的参数。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f358" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这个小小的改变，我们可以保证<code class="fe ky kz la lb b">google.maps.OverlayView</code>将由我们调用<code class="fe ky kz la lb b">createHTMLMapMarker</code>的时间来定义，因为我们可以完全控制何时调用<code class="fe ky kz la lb b">createHTMLMapMarker</code>。</p><p id="1d99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经有了我们的类和闭包，让我们使用它们吧！本教程的其余部分将采用以下文件夹结构:</p><pre class="kn ko kp kq gt mw lb mx my aw mz bi"><span id="7dc3" class="na ld iq lb b gy nb nc l nd ne">/index.html<br/>/src/index.js<br/>/src/html-map-marker.js &lt;-- Our closure + class definition<br/>/src/style.css</span></pre><p id="5b7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的教程来说，<code class="fe ky kz la lb b">index.html</code>只需要加载我们的CSS，加载谷歌地图JavaScript库，并在<code class="fe ky kz la lb b">src/index.js</code>加载应用程序的入口点。页面上唯一的元素是一个ID为<code class="fe ky kz la lb b">map</code>的singe <code class="fe ky kz la lb b">&lt;div&gt;</code>，它将用于显示谷歌地图。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a9b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe ky kz la lb b">index.js</code>将定义一个新的Google Maps <code class="fe ky kz la lb b">map</code>实例，以廷巴克图的纬度和经度为中心。然后，它将使用我们之前定义的导入的<code class="fe ky kz la lb b">createHTMLMapMarker</code> closer函数定义一个<code class="fe ky kz la lb b">marker</code>，传递相同的<code class="fe ky kz la lb b">latlng</code>、<code class="fe ky kz la lb b">map</code>实例和要作为标记内容呈现的<code class="fe ky kz la lb b">html</code>。我们将在一个图像标签中使用一只party parrot，它的ID属性为<code class="fe ky kz la lb b">parrot</code>用于样式化。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="58d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得我们在<code class="fe ky kz la lb b">HTMLMapMarker</code>类的<code class="fe ky kz la lb b">draw</code>方法中定义了‘click’的DOM事件吗？如前所述，点击事件只是传递给了<code class="fe ky kz la lb b">marker</code>实例。这允许我们通过<code class="fe ky kz la lb b">addListener</code>方法将事件监听器直接添加到新创建的<code class="fe ky kz la lb b">marker</code>中，如<code class="fe ky kz la lb b">index.js</code>的第16–18行所示。</p><p id="9187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">style.css</code>中的样式只是用地图<code class="fe ky kz la lb b">&lt;div&gt;</code>填充页面，并对<code class="fe ky kz la lb b">marker</code>应用边框、高度和宽度作为概念证明。由于我们用来创建<code class="fe ky kz la lb b">marker</code>的HTML元素的ID是<code class="fe ky kz la lb b">parrot</code>，我们可以用<code class="fe ky kz la lb b">#parrot</code>选择器来设计它的样式。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！有了新的<code class="fe ky kz la lb b">createHTMLMapMarker</code>函数，我们现在可以轻松地向google map实例添加任何HTML。你可以在下面的codesandbox中看到教程的最终结果。</p><p id="6a6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">注意，CodeSandbox也会有一个来自Google的警告，说“这个页面不能正确加载Google地图”，因为没有使用API键。该应用程序应该仍然按照预期工作。</em></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ng mv l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="edfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您觉得这篇文章有帮助，请务必👏👏👏。你也可以<a class="ae mf" href="http://www.medium.com/@warlyware" rel="noopener">关注我</a>获取更多关于JavaScript、Vue和React原生开发的文章。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><a href="http://levelup.gitconnected.com"><div class="gh gi no"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure><div class="np nq gp gr nr ns"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2018) | gitconnected</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">排名前64的JavaScript教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">gitconnected.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kw ns"/></div></div></a></div></div></div>    
</body>
</html>