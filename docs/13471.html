<html>
<head>
<title>Customize secret handling with Azure Key Vault in ASP.NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ASP中的Azure Key Vault自定义秘密处理。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/customize-secret-handling-with-azure-key-vault-in-asp-net-380a676dd369?source=collection_archive---------17-----------------------#2022-09-06">https://levelup.gitconnected.com/customize-secret-handling-with-azure-key-vault-in-asp-net-380a676dd369?source=collection_archive---------17-----------------------#2022-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b3fd0bb884822080662854e6266ffff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycoPwI7Y9-Mu0ErvCC8adQ.png"/></div></div></figure><div class=""/><p id="da8f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谈论秘密(密码、令牌等)时。)，不言而喻，这种数据必须得到保护。有了Azure Key Vault，您可以依靠托管服务来安全地管理应用程序的密钥、机密和证书。</p><p id="1bec" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时，尤其是在开发基于服务的应用程序时，可能需要单独的秘密处理。在本文中，我将向您展示为什么定制的秘密处理可能与您相关，以及如何使用ASP.NET为Azure Key Vault实现它。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="4bb6" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">在ASP中使用Azure Key Vault。网</h1><p id="58d1" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">使用ASP.NET开发的应用程序通常通过使用一个或多个<a class="ae mg" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-6.0#cp" rel="noopener ugc nofollow" target="_blank">配置提供者</a>来使用嵌入式系统进行配置。提供者从特定的来源读取键值对，并通过统一的接口使整个配置可用。</p><p id="08cc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最常见的提供者是负责处理<code class="fe mh mi mj mk b">appsettings.json</code>文件的<a class="ae mg" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-6.0#json-configuration-provider" rel="noopener ugc nofollow" target="_blank"> JSON配置提供者</a>。另一个重要的提供者是<a class="ae mg" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-6.0#non-prefixed-environment-variables" rel="noopener ugc nofollow" target="_blank">环境变量配置提供者</a>。顾名思义，这个提供程序从环境变量中加载设置。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cd5b" class="mt le jb mk b gy mu mv l mw mx">var builder = WebApplication.CreateBuilder(args);<br/>var app = builder.Build();<br/><br/>app.MapGet("/", () =&gt; "Hello World!");<br/><br/>app.Run();</span></pre><p id="797d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码片段显示了一个最小的。默认情况下，它注册各种配置提供程序。由提供程序映射的属性根据注册顺序排列优先级。这意味着当多个配置提供程序包含相同的属性时，将使用最新提供程序的值。</p><blockquote class="my mz na"><p id="aac2" class="jy jz nb ka b kb kc kd ke kf kg kh ki nc kk kl km nd ko kp kq ne ks kt ku kv ij bi translated">调用栈:<br/> <a class="ae mg" href="https://github.com/dotnet/aspnetcore/blob/00706e7699009e67f48987491a8b54820649dba5/src/DefaultBuilder/src/WebApplication.cs#L105" rel="noopener ugc nofollow" target="_blank"> WebApplication。CreateBuilder(…) </a> - &gt; <a class="ae mg" href="https://github.com/dotnet/runtime/blob/30dc7e7aedb7aab085c7d9702afeae5bc5a43133/src/libraries/Microsoft.Extensions.Hosting/src/HostApplicationBuilder.cs#L142" rel="noopener ugc nofollow" target="_blank">新建HostApplicationBuilder(…)</a>-&gt;-<a class="ae mg" href="https://github.com/dotnet/runtime/blob/30dc7e7aedb7aab085c7d9702afeae5bc5a43133/src/libraries/Microsoft.Extensions.Hosting/src/HostingHostBuilderExtensions.cs#L227" rel="noopener ugc nofollow" target="_blank">HostingBuilderExtensions。ApplyDefaultAppConfiguration(…)</a></p><p id="64b2" class="jy jz nb ka b kb kc kd ke kf kg kh ki nc kk kl km nd ko kp kq ne ks kt ku kv ij bi translated">默认配置提供者:<br/> JSON，用户机密，环境变量，命令行</p></blockquote><p id="a8ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要将Azure Key Vault添加为配置提供程序，我们必须首先添加NuGet包:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2ccb" class="mt le jb mk b gy mu mv l mw mx">dotnet add package Azure.Extensions.AspNetCore.Configuration.Secrets</span></pre><p id="ec18" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以添加Azure Key Vault作为额外的配置数据源，如下例所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="627b" class="mt le jb mk b gy mu mv l mw mx">using Azure.Identity;</span><span id="f3b4" class="mt le jb mk b gy nf mv l mw mx">var builder = WebApplication.CreateBuilder(args);</span><span id="471c" class="mt le jb mk b gy nf mv l mw mx">// Add Azure Key Vault as a configuration provider<br/>// To benefit from authorization using DefaultAzureCredential,<br/>// please install Microsoft.Identity.Web in addition.<br/>builder.Configuration.AddAzureKeyVault(<br/>  new Uri(builder.Configuration["KeyVaultUri"]), <br/>  new DefaultAzureCredential());</span><span id="8ae5" class="mt le jb mk b gy nf mv l mw mx">var app = builder.Build();</span><span id="9e68" class="mt le jb mk b gy nf mv l mw mx">app.MapGet("/", () =&gt; "Hello World!");</span><span id="d13d" class="mt le jb mk b gy nf mv l mw mx">app.Run();</span></pre><p id="d7cd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们使用如下所示的<code class="fe mh mi mj mk b">appsettings.json</code>文件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d085" class="mt le jb mk b gy mu mv l mw mx">{<br/>  "Logging": {<br/>    "LogLevel": {<br/>      "Default": "Warning"<br/>    }<br/>  },<br/>  "KeyVaultUri": "https://&lt;&lt;key-vault-name&gt;&gt;.vault.azure.net/",<br/>  "SecretProperty": ""<br/>}</span></pre><p id="a6b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的Azure KeyVault中添加了一个名为<code class="fe mh mi mj mk b">SecretProperty</code>的秘密后，通过<code class="fe mh mi mj mk b">appsettings.json</code>定义的值将被替换为我们的Vault中的值。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/8b61dba02c0627c50d6b5f5df41eed1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*najkW6z-uiP1uA34.png"/></div></div></figure><p id="3c0b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，使用Azure Key Vault，你的应用程序中的弹性和安全的秘密管理可以非常简单。记住这些基础知识后，我们现在可以开始定制秘密处理了。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ebfb" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为什么要自定义秘密处理？</h1><p id="4504" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">想一个基于微服务的应用。两个服务使用一个名为的机密，该机密具有相同的密钥，但具有特定于服务的值。当两个服务现在使用相同的Azure密钥库时，我们必须考虑对相同密钥的服务特定值的需求。</p><p id="9319" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使它更具体，让我们考虑下面的例子:<br/>一个名为<code class="fe mh mi mj mk b">Connection</code>的属性在两个服务中都可用，但它表示每个服务到一个单独数据库的连接。因此属性的值对于每个服务来说必须是独立的。否则，将导致错误配置，如下图所示:</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/61247adc7239ffb6deb409af4de7e8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SuldUwzzPRBo5FLh.png"/></div></div></figure><p id="91ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们不能在KeyVault中使用名为<code class="fe mh mi mj mk b">Connection</code>的属性，因为我们必须覆盖不同的值。当然，我们可以使用不同的密钥名来避免这种行为。但这不是一个干净的解决方案。还好有<code class="fe mh mi mj mk b">KeyVaultSecretManager</code>班。它允许我们修改秘密如何被消费和转移到应用程序配置的行为。在下一节中，我们将看一个使用前缀来区分两个服务设置的示例实现。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="8f48" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">如何定制秘密处理？</h1><p id="28e2" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">Azure Key Vault SDK已经支持注册一个<code class="fe mh mi mj mk b">KeyVaultSecretManager</code>，它允许我们定制如何处理秘密。因此，secret manager实例可以与Azure Key Vault注册一起传递。在下一个示例代码中，<code class="fe mh mi mj mk b">PrefixPreferredKeyVaultSecretManager</code>被用作一个定制的secret manager实现。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e401" class="mt le jb mk b gy mu mv l mw mx">using Azure.Identity;</span><span id="fb02" class="mt le jb mk b gy nf mv l mw mx">var builder = WebApplication.CreateBuilder(args);</span><span id="51c7" class="mt le jb mk b gy nf mv l mw mx">// Add Azure Key Vault as a configuration provider<br/>// To benefit from authorization using DefaultAzureCredential,<br/>// please install Microsoft.Identity.Web in addition.<br/>builder.Configuration.AddAzureKeyVault(<br/>  new Uri(builder.Configuration["KeyVaultUri"]), <br/>  new DefaultAzureCredential(),<br/>  new PrefixPreferredKeyVaultSecretManager("ServiceA"));</span><span id="ab15" class="mt le jb mk b gy nf mv l mw mx">var app = builder.Build();</span><span id="9347" class="mt le jb mk b gy nf mv l mw mx">app.MapGet("/", () =&gt; "Hello World!");</span><span id="594e" class="mt le jb mk b gy nf mv l mw mx">app.Run();</span></pre><p id="7c1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<code class="fe mh mi mj mk b">PrefixPreferredKeyVaultSecretManager</code>实际上是做什么的？<br/>你会在下图中找到答案:</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/71a7cf33d74822496897b18c1214b340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EwTjXlgNZ9HYbHYk.png"/></div></div></figure><p id="0470" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Azure Key Vault现在包含两个秘密，每个秘密代表特定服务所需的值。在应用程序启动期间，所有的秘密都被加载，然后根据定义的规则进行过滤。在我们的例子中，我们使用基于前缀的方法。秘密<code class="fe mh mi mj mk b">ServiceA-Connection</code>被应用于<code class="fe mh mi mj mk b">ServiceA</code>，秘密<code class="fe mh mi mj mk b">ServiceB-Connection</code>在<code class="fe mh mi mj mk b">ServiceB</code>内使用。</p><p id="defb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候仔细看看下面代码块中显示的<code class="fe mh mi mj mk b">PrefixPreferredKeyVaultSecretManager</code>实现了:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="884c" class="mt le jb mk b gy mu mv l mw mx">internal sealed class PrefixPreferredKeyVaultSecretManager : KeyVaultSecretManager<br/>{<br/>    private readonly string _prefix;</span><span id="96ac" class="mt le jb mk b gy nf mv l mw mx">    public PrefixPreferredKeyVaultSecretManager(string prefix) =&gt; _prefix = $"{prefix}-";</span><span id="2131" class="mt le jb mk b gy nf mv l mw mx">    public override Dictionary&lt;string, string&gt; GetData(IEnumerable&lt;KeyVaultSecret&gt; secrets)<br/>    {<br/>        return base.GetData(secrets)<br/>            .GroupBy(x =&gt; x.Key.Replace(_prefix, string.Empty))<br/>            .Select(x =&gt; new { x.Key, Value = x.OrderByDescending(y =&gt; y.Key).First() })<br/>            .ToDictionary(x =&gt; x.Key, x =&gt; x.Value.Value);<br/>    }<br/>}</span></pre><p id="301f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">PrefixPreferredKeyVaultSecretManager</code>继承自<code class="fe mh mi mj mk b">KeyVaultSecretManager</code>。因此，我们可以通过覆盖方法<code class="fe mh mi mj mk b">GetData(IEnumerable&lt;KeyVaultSecret&gt; secrets)</code>来集成到秘密加载机制中。首先，我们调用基方法来检索所有可用的秘密。假设我们在Azure Key Vault实例中存储了以下机密:</p><ul class=""><li id="27ad" class="ni nj jb ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated">连接:回退</li><li id="53c5" class="ni nj jb ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">服务a-连接:值a</li><li id="6329" class="ni nj jb ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">服务b-连接:值b</li></ul><p id="a70f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第二步中，根据以下模式应用基于前缀的过滤逻辑:</p><ol class=""><li id="3cd8" class="ni nj jb ka b kb kc kf kg kj nk kn nl kr nm kv nw no np nq bi translated">按密钥分组</li></ol><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a285" class="mt le jb mk b gy mu mv l mw mx">- Connection<br/> - Connection:Fallback<br/> - ServiceA-Connection:ValueA<br/>- ServiceB-Connection<br/> - ServiceB-Connection:ValueB</span></pre><p id="7b06" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.按组排序以找到前缀的正确值</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="38f7" class="mt le jb mk b gy mu mv l mw mx">- Connection<br/> - ServiceA-Connection:ValueA<br/> - Connection:Fallback<br/>- ServiceB-Connection<br/> - ServiceB-Connection:ValueB</span></pre><p id="4cfc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.使用每组的第一个条目作为最终配置值</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="595e" class="mt le jb mk b gy mu mv l mw mx">- Connection -&gt; ValueA<br/>- ServiceB-Connection -&gt; ValueB</span></pre><p id="21a0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的方法允许我们指定特定于服务的秘密以及在没有特定于服务的秘密可用时使用的一种“回退”秘密。该方法仅代表一种可能的方式，当然，它可以进一步改进，例如通过从其他服务中移除值。但基本上，这就是在ASP.NET用Azure Key Vault实现个人秘密处理所要做的全部工作。</p><h1 id="3eac" class="ld le jb bd lf lg nx li lj lk ny lm ln lo nz lq lr ls oa lu lv lw ob ly lz ma bi translated">包扎</h1><p id="7ca2" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">在本文中，我解释了为什么定制的秘密管理是有用的，以及如何在ASP.NET项目中将它与Azure Key Vault一起使用。<code class="fe mh mi mj mk b">KeyVaultSecretManager</code>的一个示例实现展示了如何将前缀优先的方法集成为一个可能的解决方案。当然，还有很多其他的选择。所以你可以根据自己的要求找到合适的方式。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="f44e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您花时间阅读我的文章。😄</p><p id="f09d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢它，并希望看到更多与编码相关的内容，请关注我的社交资料。不要犹豫，喜欢，评论或分享这篇文章。我非常感谢对这篇文章的任何反馈。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="eba0" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">分级编码</h1><p id="7337" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="6254" class="ni nj jb ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="185d" class="ni nj jb ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">📰查看<a class="ae mg" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="4d12" class="ni nj jb ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">🔔关注我们:<a class="ae mg" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae mg" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mg" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="db21" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🚀👉<a class="ae mg" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>