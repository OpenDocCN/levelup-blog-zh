<html>
<head>
<title>How to Build a Simple CLI with oclif</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用oclif构建一个简单的CLI</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-simple-cli-with-oclif-af9051f56903?source=collection_archive---------1-----------------------#2022-06-22">https://levelup.gitconnected.com/how-to-build-a-simple-cli-with-oclif-af9051f56903?source=collection_archive---------1-----------------------#2022-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f3429cdb7d6932b206367ffcb0f84feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vOllPNjGkW2rEJZDFQpvA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@spacex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae jg" href="https://unsplash.com/s/photos/space-computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h2 id="bf89" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">咖啡店里的编码</h2><div class=""/><div class=""><h2 id="1303" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">不喜欢shell脚本？用Node.js构建CLI工具！</h2></div><p id="af56" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Salesforce开发人员对开源社区贡献良多。在他们的众多贡献中，有一个重要的，但可能不太为人所知的项目，名为oclif。<a class="ae jg" href="https://oclif.io/" rel="noopener ugc nofollow" target="_blank"> Open CLI框架</a>于2018年初发布，此后发展成为Salesforce CLI和Heroku CLI的基础。</p><p id="38a6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这篇文章中，我们将提供一个oclif的简要概述，然后我们将介绍如何用oclif构建一个简单的CLI。</p><h1 id="0707" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">oclif简史</h1><p id="a673" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Oclif最初是一个内部Heroku项目。Heroku一直专注于开发人员的体验，它的CLI为通过API使用服务设定了标准。毕竟，Heroku是<code class="fe na nb nc nd b">git push heroku</code> for deployment的创造者，这是一个现在在整个行业广泛使用的标准。</p><p id="3d5f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你曾经运行过<code class="fe na nb nc nd b">heroku ps</code>或者<code class="fe na nb nc nd b">sfdx auth:list</code>，那么你就使用过oclif。从一开始，oclif就被设计成一个开放的、可扩展的、轻量级的框架，用于快速构建简单和复杂的CLI。</p><p id="a05a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">发布四年多后，oclif已经成为构建CLI的权威框架。一些最受欢迎的oclif组件每周下载量超过一百万次。oclif项目仍在积极开发中。</p><p id="1c2b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过oclif建立的知名公司或项目包括:</p><ul class=""><li id="474c" class="ne nf jj lj b lk ll ln lo lq ng lu nh ly ni mc nj nk nl nm bi translated"><a class="ae jg" href="https://developer.salesforce.com/tools/sfdxcli" rel="noopener ugc nofollow" target="_blank"> Salesforce </a></li><li id="8efe" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc nj nk nl nm bi translated"><a class="ae jg" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> Heroku </a></li><li id="34be" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc nj nk nl nm bi translated"><a class="ae jg" href="https://www.twilio.com/blog/building-conference-cli-in-react" rel="noopener ugc nofollow" target="_blank"> Twilio </a></li><li id="8465" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc nj nk nl nm bi translated"><a class="ae jg" href="https://www.adobe.io/project-firefly/docs/guides/#cli" rel="noopener ugc nofollow" target="_blank">土坯萤火虫</a></li><li id="1394" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc nj nk nl nm bi translated"><a class="ae jg" href="https://www.npmjs.com/package/getstream-cli" rel="noopener ugc nofollow" target="_blank">流</a></li></ul><h2 id="a7db" class="ns me jj bd mf nt nu dn mj nv nw dp mn lq nx ny mp lu nz oa mr ly ob oc mt jp bi translated">为什么今天一个开发者会选择oclif？</h2><p id="93dd" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">人们想要构建CLI的原因有很多。也许你的公司有一个API，你想让客户更容易使用它。也许您使用内部API，并且希望通过CLI运行命令来自动化日常任务。在这些场景中，您总是可以编写Powershell或Bash脚本，或者从头开始构建自己的CLI，但是oclif是最好的选择。</p><p id="f9b0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Oclif构建于Node.js之上，运行于所有主流操作系统上，有多种分发选项。除了速度快之外，oclif还是自文档化的，并支持插件，允许开发人员构建和共享可重用的功能。随着oclif的迅速普及，越来越多的库、插件和有用的包变得可用。</p><p id="8d34" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">例如，<code class="fe na nb nc nd b">cli-ux</code>预打包了<code class="fe na nb nc nd b">@oclif/core</code>包，并提供了常见的UX功能，如微调器、表格和进度条，您可以将它们添加到您的CLI中。</p><p id="0ebe" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很容易理解为什么oclif是成功的，并且应该成为构建CLI的选择。</p><h1 id="300d" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">介绍我们的迷你项目</h1><p id="de43" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">让我们为您将要构建的CLI设置场景。你想为你的爱好之一建立你自己的命令行界面:<strong class="lj jt">太空旅行</strong>。</p><p id="bb71" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你如此热爱太空旅行，以至于你观看了每一次SpaceX的发射直播，你查看HowManyPeopleAreInSpaceRightNow.com页面的次数比你愿意承认的还要多。您希望通过构建一个关于太空旅行细节的CLI来简化这种困扰，从一个简单的命令开始，该命令将显示当前在太空中的人数。最近，您发现了一个名为<a class="ae jg" href="http://open-notify.org/" rel="noopener ugc nofollow" target="_blank"> Open Notify </a>的服务，它有一个用于此目的的API端点。</p><p id="b2e3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将使用<code class="fe na nb nc nd b">oclif generate </code>命令来创建我们的项目，这将为一个新的CLI项目提供一些合理的默认值。使用该命令创建的项目默认使用TypeScript这是我们的项目将使用的——但是也可以配置为使用普通的JavaScript。</p><h1 id="9e6b" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">创建项目</h1><p id="82be" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">首先，如果您还没有Node.js，那么您需要在本地安装它。oclif项目需要使用Node.js 的活动<a class="ae jg" href="https://nodejs.org/en/about/releases/" rel="noopener ugc nofollow" target="_blank"> LTS版本。</a></p><p id="b6c6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可以通过以下命令验证已安装的Node.js的版本:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="fde8" class="ns me jj nd b gy ol om l on oo">/ $ <strong class="nd jt">node -v</strong><br/>v16.15.0</span></pre><p id="22a5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，全局安装oclif CLI:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="0b46" class="ns me jj nd b gy ol om l on oo">/ $ <strong class="nd jt">npm install -g oclif</strong></span></pre><p id="0694" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，是时候使用generate命令创建oclif项目了:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="612c" class="ns me jj nd b gy ol om l on oo">/ $ <strong class="nd jt">oclif generate space-cli</strong><br/><br/>     _-----_<br/>    |       |    ╭──────────────────────────╮<br/>    |--(o)--|    │  Time to build an oclif  │<br/>   `---------´   │    CLI! Version: 3.0.1   │<br/>    ( _´U`_ )    ╰──────────────────────────╯<br/>    /___A___\   /<br/>     |  ~  |<br/>   __'.___.'__<br/> ´   `  |° ´ Y `<br/><br/>Cloning into '/space-cli'...</span></pre><p id="edd0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此时，您将会看到一些设置问题。对于这个项目，您可以将它们全部留空以使用默认值(由括号指示)，或者您可以选择自己填写它们。最后一个问题将要求您选择一个包管理器。对于我们的示例，选择<strong class="lj jt"> npm </strong>。</p><h2 id="c050" class="ns me jj bd mf nt nu dn mj nv nw dp mn lq nx ny mp lu nz oa mr ly ob oc mt jp bi translated">从oclif的hello world命令开始</h2><p id="4c13" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">从这里开始，oclif将为您完成CLI项目的创建。在<code class="fe na nb nc nd b">bin/</code>文件夹中，您将找到一些节点脚本，您可以在开发时运行这些脚本来测试您的CLI。这些脚本将从<code class="fe na nb nc nd b">dist/</code>文件夹中的构建文件运行命令。如果您只是按原样运行脚本，您将会看到类似以下消息的内容:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="cd2b" class="ns me jj nd b gy ol om l on oo">/ $ <strong class="nd jt">cd space-cli/</strong></span><span id="ecd3" class="ns me jj nd b gy op om l on oo">/space-cli $ <strong class="nd jt">./bin/run</strong><br/>oclif example Hello World CLI<br/><br/>VERSION<br/>  space-cli/0.0.0 darwin-arm64 node-v16.15.0<br/><br/>USAGE<br/>  $ space-cli [COMMAND]<br/><br/>TOPICS<br/>  hello    Say hello to the world and others<br/>  plugins  List installed plugins.<br/><br/>COMMANDS<br/>  hello    Say hello<br/>  help     Display help for space-cli.<br/>  plugins  List installed plugins.</span></pre><p id="0ddd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">默认情况下，如果您没有为CLI指定要运行的命令，它将显示帮助消息。让我们再试一次:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="3c5c" class="ns me jj nd b gy ol om l on oo">/space-cli $ <strong class="nd jt">./bin/run hello</strong><br/> &gt;   Error: Missing 1 required arg:<br/> &gt;   person  Person to say hello to<br/> &gt;   See more help with --help</span></pre><p id="eda6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这一次，我们收到了一个错误。我们缺少一个必需的参数:我们需要指定我们在问候谁！</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="4ae8" class="ns me jj nd b gy ol om l on oo">/space-cli $ <strong class="nd jt">./bin/run hello John</strong><br/> &gt;   Error: Missing required flag:<br/> &gt;    -f, --from FROM  Whom is saying hello<br/> &gt;   See more help with --help</span></pre><p id="cc6b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们收到了另一条有用的错误消息。我们还需要指定欢迎者，这次用一个标志:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="8714" class="ns me jj nd b gy ol om l on oo">/space-cli $ <strong class="nd jt">./bin/run hello John --from Jane</strong><br/>hello John from Jane! (./src/commands/hello/index.ts)</span></pre><p id="efd9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，我们已经正确地问候了约翰，我们可以看看hello命令的代码，它可以在<code class="fe na nb nc nd b">src/commands/hello/index.ts</code>中找到。看起来是这样的:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="5967" class="ns me jj nd b gy ol om l on oo">import {Command, Flags} from '@oclif/core'<br/><br/>export default class Hello extends Command {<br/>  static description = 'Say hello'<br/><br/>  static examples = [<br/>    `$ oex hello friend --from oclif<br/>hello friend from oclif! (./src/commands/hello/index.ts)<br/>`,<br/>  ]<br/><br/>  static flags = {<br/>    from: Flags.string({char: 'f', description: 'Whom is saying hello', required: true}),<br/>  }<br/><br/>  static args = [{name: 'person', description: 'Person to say hello to', required: true}]<br/><br/>  async run(): Promise&lt;void&gt; {<br/>    const {args, flags} = await this.parse(Hello)<br/><br/>    this.log(`hello ${args.person} from ${flags.from}! (./src/commands/hello/index.ts)`)<br/>  }<br/>}</span></pre><p id="cc8a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如您所看到的，oclif命令被简单地定义为一个带有<code class="fe na nb nc nd b">async run()</code>方法的类，不出所料，它包含了命令运行时执行的代码。此外，一些静态属性提供了额外的功能，尽管它们都是可选的。</p><ul class=""><li id="8db4" class="ne nf jj lj b lk ll ln lo lq ng lu nh ly ni mc nj nk nl nm bi translated"><code class="fe na nb nc nd b">description</code>和<code class="fe na nb nc nd b">examples</code>属性用于帮助消息。</li><li id="255f" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc nj nk nl nm bi translated"><code class="fe na nb nc nd b">flags</code>属性是一个定义命令可用标志的对象，其中对象的关键字对应于标志名。稍后我们将对此进行深入探讨。</li><li id="ce40" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc nj nk nl nm bi translated">最后，<code class="fe na nb nc nd b">args</code>是一个对象数组，表示命令可以接受的一些选项的参数。</li></ul><p id="eda0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe na nb nc nd b">run()</code>方法解析参数和标志，然后使用<code class="fe na nb nc nd b">person</code>参数打印出一条消息，使用<code class="fe na nb nc nd b">this.log()</code>打印出<code class="fe na nb nc nd b">from</code>标志(这是<code class="fe na nb nc nd b">console.log</code>的非阻塞替代方案)。注意，标志和参数都用<code class="fe na nb nc nd b">required: true</code>配置，这是得到验证和有用的错误消息所需要的，就像我们在早期测试中看到的那样。</p><h2 id="8da4" class="ns me jj bd mf nt nu dn mj nv nw dp mn lq nx ny mp lu nz oa mr ly ob oc mt jp bi translated">创建我们自己的命令</h2><p id="629f" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">既然我们已经理解了命令的结构，我们就可以编写自己的命令了。我们称之为<code class="fe na nb nc nd b">humans</code>，它会打印出目前在太空中的人数。您可以删除<code class="fe na nb nc nd b">src/commands</code>中的hello文件夹，因为我们不再需要它了。oclif CLI也可以帮助我们搭建新的命令:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="1eba" class="ns me jj nd b gy ol om l on oo">/space-cli $ <strong class="nd jt">oclif generate command humans</strong><br/><br/>     _-----_<br/>    |       |    ╭──────────────────────────╮<br/>    |--(o)--|    │    Adding a command to   │<br/>   `---------´   │ space-cli Version: 3.0.1 │<br/>    ( _´U`_ )    ╰──────────────────────────╯<br/>    /___A___\   /<br/>     |  ~  |     <br/>   __'.___.'__   <br/> ´   `  |° ´ Y ` <br/><br/>   create src\commands\humans.ts<br/>   create test\commands\humans.test.ts<br/><br/>No change to package.json was detected. No package manager install will be executed.</span></pre><p id="deb6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们有了一个可以编辑的<code class="fe na nb nc nd b">humans.ts</code>文件，我们可以开始编写命令了。我们将使用的Open Notify API端点可以在以下URL找到:<code class="fe na nb nc nd b"><a class="ae jg" href="http://open-notify.org/Open-Notify-API/People-In-Space/" rel="noopener ugc nofollow" target="_blank">http://open-notify.org/Open-Notify-API/People-In-Space/</a></code></p><p id="ec1c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如您在描述中看到的，端点返回了一个简单的JSON响应，其中包含了当前太空中人类的详细信息。用以下代码替换<code class="fe na nb nc nd b">src/commands/humans.ts</code>中的代码:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="9c4b" class="ns me jj nd b gy ol om l on oo">import {Command} from '@oclif/core'<br/>import {get} from 'node:http'<br/><br/>export default class HumanCommand extends Command {<br/>  static description = 'Get the number of humans currently in space.'<br/><br/>  static examples = [<br/>    '$ space-cli humans\nNumber of humans currently in space: 7',<br/>  ]<br/><br/>  public async run(): Promise&lt;void&gt; {<br/>    get('http://api.open-notify.org/astros.json', res =&gt; {<br/>      res.on('data', d =&gt; {<br/>        const details = JSON.parse(d)<br/>        this.log(`Number of humans currently in space: ${details.number}`)<br/>      })<br/>    }).on('error', e =&gt; {<br/>      this.error(e)<br/>    })<br/>  }<br/>}</span></pre><p id="9b59" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是我们在上面代码中所做工作的分解:</p><ol class=""><li id="feb7" class="ne nf jj lj b lk ll ln lo lq ng lu nh ly ni mc oq nk nl nm bi translated">使用<code class="fe na nb nc nd b">http</code>包向Open Notify端点发送请求。</li><li id="57d9" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc oq nk nl nm bi translated">解析JSON响应。</li><li id="ed64" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc oq nk nl nm bi translated">用消息输出号码。</li><li id="71db" class="ne nf jj lj b lk nn ln no lq np lu nq ly nr mc oq nk nl nm bi translated">捕捉并打印我们可能遇到的任何错误。</li></ol><p id="2a57" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于这个命令的第一次迭代，我们不需要任何标志或参数，所以我们没有为它们定义任何属性。</p><h2 id="9fe1" class="ns me jj bd mf nt nu dn mj nv nw dp mn lq nx ny mp lu nz oa mr ly ob oc mt jp bi translated">测试我们的基本命令</h2><p id="d402" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">现在，我们可以测试我们的新命令了。首先，我们必须重新构建<code class="fe na nb nc nd b">dist/</code>文件，然后我们可以像之前的hello world示例一样运行我们的命令:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="e4a7" class="ns me jj nd b gy ol om l on oo">/spacecli $ <strong class="nd jt">npm run build</strong><br/><br/>&gt; space-cli@0.0.0 build<br/>&gt; shx rm -rf dist &amp;&amp; tsc -b<br/><br/><br/>/spacecli $ <strong class="nd jt">./bin/run humans</strong><br/>Number of humans currently in space: 7</span></pre><p id="97a3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很简单，不是吗？您现在有了一个简单的CLI项目，通过oclif框架构建，它可以立即告诉您太空中的人数。</p><h2 id="8352" class="ns me jj bd mf nt nu dn mj nv nw dp mn lq nx ny mp lu nz oa mr ly ob oc mt jp bi translated">用标志和更好的用户界面增强我们的命令</h2><p id="eccc" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">知道目前有多少人在太空是件好事，但是我们可以得到更多的太空数据！我们使用的端点提供了更多关于宇航员的细节，包括他们的名字和他们乘坐的飞船。</p><p id="e623" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将进一步使用我们的命令，演示如何使用标志，并给我们的命令一个更好的UI。我们可以用<code class="fe na nb nc nd b">cli-ux</code>包将我们的数据输出为一个表格，这个包已经被卷进了<code class="fe na nb nc nd b">@oclif/core</code>(从版本<code class="fe na nb nc nd b">1.2.0</code>开始)。为了确保我们可以访问<code class="fe na nb nc nd b">cli-ux</code>，让我们更新我们的包。</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="efb2" class="ns me jj nd b gy ol om l on oo">/spacecli $ <strong class="nd jt">npm update</strong></span></pre><p id="85fd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以在我们的<code class="fe na nb nc nd b">humans</code>命令中添加一个可选的<code class="fe na nb nc nd b">--table</code>标志，以在表格中打印出这些数据。对于这个漂亮的输出，我们使用了<code class="fe na nb nc nd b">CliUx.ux.table()</code>函数。</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="f097" class="ns me jj nd b gy ol om l on oo">import {Command, Flags, CliUx} from '@oclif/core'<br/>import {get} from 'node:http'<br/><br/>export default class HumansCommand extends Command {<br/>  static description = 'Get the number of humans currently in space.'<br/><br/>  static examples = [<br/>    '$ space-cli\nNumber of humans currently in space: 7',<br/>  ]<br/><br/>  static flags = {<br/>    table: Flags.boolean({char: 't', description: 'display who is in space and where with a table'}),<br/>  }<br/><br/>  public async run(): Promise&lt;void&gt; {<br/>    const {flags} = await this.parse(HumansCommand)<br/><br/>    get('http://api.open-notify.org/astros.json', res =&gt; {<br/>      res.on('data', d =&gt; {<br/>        const details = JSON.parse(d)<br/>        this.log(`Number of humans currently in space: ${details.number}`)<br/>        if (flags.table) {<br/>          CliUx.ux.table(details.people, {name: {}, craft: {}})<br/>        }<br/>      })<br/>    }).on('error', e =&gt; {<br/>      this.error(e)<br/>    })<br/>  }<br/>}</span></pre><p id="7dd0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们更新的代码中，我们的第一步是带回<code class="fe na nb nc nd b">flags</code>属性。这次我们定义一个布尔标志——它要么存在，要么不存在——与字符串标志相反，字符串标志以字符串作为参数。我们还为传入的options对象中的标志定义了描述和简写-t。</p><p id="474d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">接下来，我们解析我们的<code class="fe na nb nc nd b">run</code>方法中的标志。如果存在，我们显示一个带有<code class="fe na nb nc nd b">CliUx.ux.table()</code>的表格。第一个参数<code class="fe na nb nc nd b">details.people</code>是我们希望在表中显示的数据，而第二个参数是定义表中列的对象。在本例中，我们定义了一个<code class="fe na nb nc nd b">name</code>和一个<code class="fe na nb nc nd b">craft</code>列，每个列都有一个空对象。(表列有一些<a class="ae jg" href="https://oclif.io/docs/table" rel="noopener ugc nofollow" target="_blank">配置选项</a>，但是在这种情况下我们不需要任何选项。)Oclif会在我们传入的数据对象上寻找那些属性，并为我们处理其他的事情！</p><p id="bb4f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以构建并重新运行带有新表标志的命令，看看会是什么样子:</p><pre class="od oe of og gt oh nd oi oj aw ok bi"><span id="c494" class="ns me jj nd b gy ol om l on oo">/spacecli $ ./bin/run humans --table<br/>Number of humans currently in space: 10<br/> Name                   Craft    <br/> ───────────────── ──────── <br/> Oleg Artemyev          ISS      <br/> Denis Matveev          ISS      <br/> Sergey Korsakov        ISS      <br/> Kjell Lindgren         ISS      <br/> Bob Hines              ISS      <br/> Samantha Cristoforetti ISS      <br/> Jessica Watkins        ISS      <br/> Cai Xuzhe              Tiangong <br/> Chen Dong              Tiangong <br/> Liu Yang               Tiangong</span></pre><p id="4621" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">漂亮！</p><h2 id="de0b" class="ns me jj bd mf nt nu dn mj nv nw dp mn lq nx ny mp lu nz oa mr ly ob oc mt jp bi translated">自己添加更多的功能</h2><p id="c403" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">至此，我们的示例项目已经完成，但是您可以轻松地在它的基础上构建更多的项目。Open Notify服务提供了一个API端点来获取国际空间站的当前位置。您也可以添加这个功能，使用一个命令，比如运行时返回位置的<code class="fe na nb nc nd b">space-cli iss</code>。</p><h2 id="aa1c" class="ns me jj bd mf nt nu dn mj nv nw dp mn lq nx ny mp lu nz oa mr ly ob oc mt jp bi translated">分配呢？</h2><p id="7dce" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">您可能正在考虑发布选项，以分享您令人惊叹的新CLI。您可以通过一个简单的命令将这个项目发布到npm。您可以创建一个tarball，在内部将项目分发给您的团队或同事。如果你想与macOS用户分享，你也可以创建一个自制公式。Oclif可以在这些选项中帮助你。</p><h1 id="3be7" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">结论</h1><p id="e9c3" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">本文开始时，我们回顾了oclif的历史，以及为什么它应该是您创建CLI时的首选。它的一些优势包括速度、可扩展性和各种分发选项。我们学习了如何搭建CLI项目并向其中添加新命令，并构建了一个简单的CLI作为示例。</p><p id="6bba" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在你已经有了知识和新工具，出去冒险吧。</p></div></div>    
</body>
</html>