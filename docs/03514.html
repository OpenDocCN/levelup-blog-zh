<html>
<head>
<title>A container pattern for React Redux in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript中React Redux的容器模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-container-pattern-for-react-redux-in-typescript-e138a6ac33ca?source=collection_archive---------7-----------------------#2020-05-13">https://levelup.gitconnected.com/a-container-pattern-for-react-redux-in-typescript-e138a6ac33ca?source=collection_archive---------7-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8699" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过学习如何将组件连接到存储，同时将呈现与状态管理逻辑隔离开来，来增强您的React游戏</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ad63a235c07590e772e06c9197fd4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRO89ceImWBB3Jj28Ugexw.jpeg"/></div></div></figure><p id="d058" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使您相对来说是编程新手，您也可能听说过容器模式。通过将业务逻辑从用户界面中分离出来，您可以使布局组件<strong class="kt ir">可重用</strong>。在这个过程中，你还必须定义这些组件的道具看起来像什么，提高代码的<strong class="kt ir">清晰度</strong>，并在道具不匹配时让代码<strong class="kt ir">大声打断</strong>。</p><p id="9ffb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将向您展示如何按照Redux和Typescript的类似容器的模式来构造组件，以使它们更易于阅读。这将很容易和立即加强你的反应游戏。</p><h1 id="9517" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">要求</h1><p id="f1f8" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">假设您已经<a class="ae mk" href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/development_environment" rel="noopener ugc nofollow" target="_blank">建立了一个节点开发环境</a>，这里列出了您成功完成本教程所需的一切。</p><h2 id="b9c9" class="ml lo iq bd lp mm mn dn lt mo mp dp lx la mq mr lz le ms mt mb li mu mv md mw bi translated">用类型脚本反应应用程序</h2><p id="a9a1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果你是React新手，我建议<a class="ae mk" href="https://create-react-app.dev/docs/adding-typescript/" rel="noopener ugc nofollow" target="_blank">在继续之前，看一下文档</a>并学习如何用create-react-app创建你的第一个React应用程序。我将在本教程中输入我的组件，所以了解一点Typescript 不会有什么坏处。</p><h2 id="7357" class="ml lo iq bd lp mm mn dn lt mo mp dp lx la mq mr lz le ms mt mb li mu mv md mw bi translated">Redux商店</h2><p id="4a28" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我还假设您已经掌握了一些关于如何使用Redux跟踪应用程序状态的知识。我不会在这里详细介绍如何创建你的商店和reducers。如果您是Redux的新手，首先看看如何创建您的商店并将其连接到您的组件。</p><h1 id="8969" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">履行</h1><p id="ac1e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">制作一个简单的布局组件，并让它大声清晰地声明它的属性。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4a90" class="ml lo iq my b gy nc nd l ne nf">interface <strong class="my ir">IProps</strong> {<br/>    <strong class="my ir">applicationProperty</strong>: string,<br/>    <strong class="my ir">externalState</strong>: string,<br/>    <strong class="my ir">functionWithDispatch</strong>: () =&gt; void,<br/>}<br/><br/>const <strong class="my ir">ComponentLayout</strong>: React.FunctionComponent&lt;<strong class="my ir">IProps</strong>&gt; = props =&gt; {<br/>    return &lt;div onClick={props.<strong class="my ir">functionWithDispatch</strong>}&gt;<br/>        &lt;h1&gt;App state property: {props.<strong class="my ir">applicationProperty</strong>}&lt;/h1&gt;<br/>        &lt;h3&gt;External state: {props.<strong class="my ir">externalState</strong>}&lt;/h3&gt;<br/>    &lt;/div&gt;<br/>}<br/><br/>export<strong class="my ir"> </strong>default<strong class="my ir"> ComponentLayout</strong></span></pre><p id="d4cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在已经定义了布局，可以用一个连接到Redux存储的容器包装它。</p><p id="5896" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，创建连接器，并使用ConnectedProps提取其类型:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="cc28" class="ml lo iq my b gy nc nd l ne nf">const mapStateToProps = (state: MyApplicationState) =&gt; {<br/>    return {<br/>        <strong class="my ir">someProperty</strong>: state.someReducer.someKey,<br/>        // Other properties to be obtained from your state<br/>    }<br/>}<br/><br/>const mapDispatchToProps = (dispatch: Dispatch&lt;AnyAction&gt;) =&gt; {<br/>    return {<br/>        <strong class="my ir">someFunction</strong>: () =&gt; {<br/>            dispatch(someAction())<br/>        },<br/>        // Other functions with dispatch<br/>    }<br/>}<br/><br/>const connector = <em class="ng">connect</em>(mapStateToProps, mapDispatchToProps)<br/>export type <strong class="my ir">ContainerProps</strong> = <strong class="my ir">ConnectedProps</strong>&lt;typeof connector&gt;</span></pre><p id="0012" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，创建一个与连接器具有相同Props需求的组件，并让它包装您的布局，传递您映射到连接器上的属性。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2d3a" class="ml lo iq my b gy nc nd l ne nf">const <strong class="my ir">ComponentContainer</strong>: React.FunctionComponent&lt;<strong class="my ir">ContainerProps</strong>&gt; = props =&gt; {<br/><br/>    const [<strong class="my ir">extState</strong>, setExtState] = useState("default")<br/><br/>    return &lt;ComponentLayout<br/>        externalState={<strong class="my ir">extState</strong>}<br/>        applicationProperty={props.<strong class="my ir">someProperty</strong>}<br/>        functionWithDispatch={props.<strong class="my ir">someFunction</strong>}/&gt;<br/><br/>}<br/><br/>export const <strong class="my ir"><em class="ng">Component </em></strong>= connector(<strong class="my ir">ComponentContainer</strong>)</span></pre><h1 id="4c26" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">好了</h1><p id="b9cd" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您的布局组件现在完全独立于您的外部逻辑和应用程序状态，并且可以很容易地重用。此外，所有的呈现逻辑现在都与数据获取事务隔离开来，这些事务既可以在容器中完成，也可以在调度的操作中完成。现在可以在呈现函数中直接调用包装的组件:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ccb2" class="ml lo iq my b gy nc nd l ne nf">ReactDOM.<em class="ng">render</em>(<br/>    &lt;React.StrictMode&gt;<br/>        &lt;Provider store={store}&gt;<br/>            <strong class="my ir">&lt;Component/&gt;</strong><br/>        &lt;/Provider&gt;<br/>    &lt;/React.StrictMode&gt;,<br/>    <em class="ng">document</em>.getElementById('root')<br/>);</span></pre></div></div>    
</body>
</html>