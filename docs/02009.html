<html>
<head>
<title>Your Private CI/CD using self-hosted GitLab and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用自托管GitLab和Docker的私人CI/CD</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/your-private-ci-cd-using-self-hosted-gitlab-ci-and-docker-ee1aca71b99e?source=collection_archive---------0-----------------------#2020-02-12">https://levelup.gitconnected.com/your-private-ci-cd-using-self-hosted-gitlab-ci-and-docker-ee1aca71b99e?source=collection_archive---------0-----------------------#2020-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="16f2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Docker和GitLab建立一个通用的CI/CD管道，提高您的工作效率。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b85c04d0ec10b44a4fb7d4c90864cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtHMbVC1EpQzR40zTCoxtw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@yancymin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae kv" href="https://unsplash.com/s/photos/development?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="eb50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开发人员在开发个人项目时经常需要一个私有的部署环境。在开发过程中，我尝试了许多替代方法来测试、打包和部署我的解决方案，现在，我在开始一个新项目之前，都会先建立一个CI管道。</p><p id="66b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您还没有CI/CD环境，您应该考虑自己购买或设置一个。有许多平台即服务(PaaS)形式的解决方案，但我更喜欢GitLab的社区版本，以满足我的Git和CI/CD需求。自托管GitLab版本实际上是无限的。我正在开发微服务和单片产品，因此灵活地使用CI/CD对我来说至关重要。</p><p id="f7c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将使用Docker引导自己完成GitLab的初始设置。我们将在VPS中使用Docker来托管我们的GitLab实例，在构建时随意生成GitLab runners，并创建Docker映像。通过下面的设置，我们将能够使用任何技术栈来执行构建，无论是基于Go、NodeJS还是Java等等。</p><h1 id="8274" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">硬件选择</h1><p id="f1cb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要选择我们的硬件堆栈，我们需要了解我们将在这台机器上部署什么。以下是执行设置所需的部分清单:</p><ul class=""><li id="229e" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">码头工人。在Linux中，它不基于任何虚拟化，所以它将使用主机系统的资源。</li><li id="5a1a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">运行和使用Docker——仅这一项我们就需要4–6GB的RAM</li><li id="8e15" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">GitLab跑步者。每个转轮有40-100 MB的额外内存。如果你正在建造的东西很重，你可能需要更多。</li></ul><p id="9018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就磁盘而言，这是另一个我们需要感到舒适的领域。GitLab使用了太多的驱动器，这是有原因的——除了您的CI/CD，这也是我们的Git repo，并构建缓存。我们只需要磁盘和RAM —我们可以在CPU上妥协，因为在CI/CD期间，构建时间不是关键任务。</p><h1 id="5393" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在Docker中设置GitLab</h1><p id="68f1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">以下步骤描述了以下过程:</p><ul class=""><li id="042d" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">安装Docker</li><li id="1cc4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">在docker容器中安装GitLab</li><li id="78d1" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">将Nginx安装到主机上</li><li id="8163" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用主机的Nginx通过HTTPS服务GitLab，使用<code class="fe nd ne nf ng b">certbot</code></li><li id="7ac3" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用docker添加一些GitLab runners，并将它们与我们的GitLab安装连接起来</li></ul><p id="3bb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遵循这篇文章中的步骤的先决条件是要有一个功能齐全的Docker安装。数字海洋有一个全面的<a class="ae kv" href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04" rel="noopener ugc nofollow" target="_blank">演练，适用于任何安装了Ubuntu LTS 18.xx的机器。</a></p><h1 id="4afc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将GitLab安装为Docker容器</h1><p id="b4f8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">设置Docker安装后，设置环境的第一步是运行GitLab的映像，使用主机中的持久性存储。因此GitLab将在docker容器中运行，但它将使用主机的磁盘来保存数据和加载配置。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="6694" class="nl lt iq ng b gy nm nn l no np">sudo docker run --detach \<br/>  --hostname gitlab.example.com \<br/>  --publish 127.0.0.1:4443:443 --publish 127.0.0.1:4000:80 \<br/>  --name gitlab \<br/>  --restart always \<br/>  --volume /srv/gitlab/config:/etc/gitlab \<br/>  --volume /srv/gitlab/logs:/var/log/gitlab \<br/>  --volume /srv/gitlab/data:/var/opt/gitlab \<br/>  gitlab/gitlab-ce:latest</span></pre><p id="df0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着:</p><ul class=""><li id="93b3" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">将安装的主机名设置为<code class="fe nd ne nf ng b">gitlab.example.com</code></li><li id="0ae3" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">公开端口443、80、22，并将它们映射到主机的相同端口。</li><li id="a83a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">将容器的卷装载到主机上</li><li id="f467" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nd ne nf ng b">/srv/gitlab/config</code>将保存GitLab的配置</li><li id="16e4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nd ne nf ng b">/srv/gitlab/logs</code>将持有GitLab的日志</li><li id="d7ce" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nd ne nf ng b">/srv/gitlab/data</code>将保存实际git回购的数据。</li></ul><p id="eac5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这些文件夹被映射到主机，这意味着这些位置在容器重启和GitLab升级时保持不变。如果我们使用容器运行Gitlab的升级版本，并将相同的文件夹映射到相同的主机位置，我们将能够在新的GitLab版本中重用您的旧数据。</p><p id="70ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也意味着在阅读GitLab的文档时，需要有一个配置位置的心理地图。例如，在当前安装中，我们将<code class="fe nd ne nf ng b">/etc/gitlab</code>文件夹映射到<code class="fe nd ne nf ng b">srv/gitlab/config</code>而主机。因此，当GitLab配置提到:</p><blockquote class="nq nr ns"><p id="a64c" class="kw kx nt ky b kz la jr lb lc ld ju le nu lg lh li nv lk ll lm nw lo lp lq lr ij bi translated"><em class="iq">您也可以只编辑</em> <code class="fe nd ne nf ng b"><em class="iq">/etc/gitlab/gitlab.rb</em></code> <em class="iq"> : </em></p></blockquote><p id="40ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…它可以解释为:</p><blockquote class="nq nr ns"><p id="0ccc" class="kw kx nt ky b kz la jr lb lc ld ju le nu lg lh li nv lk ll lm nw lo lp lq lr ij bi translated"><em class="iq">您也可以在您的主机</em>中编辑 <code class="fe nd ne nf ng b"><em class="iq">/srv/gitlab/config/gitlab.rb</em></code> <em class="iq"/></p></blockquote><p id="cb57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为文档将GitLab安装视为安装在主机上。然而，在这种情况下，它安装在docker容器中。</p><p id="b8c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你注意到类型<code class="fe nd ne nf ng b">127.0.0.1:4443:443 --publish 127.0.0.1:4000:80</code>的奇怪的端口绑定了吗？这意味着i/o将只绑定到本地主机。容器的端口4443和4000永远不会暴露给外界。我们将使用安装在同一台机器上的Nginx反向代理来访问这些URL。</p><p id="0838" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望只通过HTTPS，在我们的自定义域名中公开GitLab。我们把这个域命名为<code class="fe nd ne nf ng b">mydomain.com</code>。为了完成这一步，我们需要访问我们的域名注册机构的网站，并访问其控制面板，允许设置域名服务器。不同域名注册商的设置方法不同，但设置原则是相同的。在这个控制面板中，让我们将子域名称(在本例中为<code class="fe nd ne nf ng b">git</code>)设置为我们的服务器的IP。为了这篇文章，让我们假设你的服务器的IP是<code class="fe nd ne nf ng b">55.55.55.55</code>。</p><p id="2cd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的名称服务器设置现在应该是这样的(可能存在更多条目，但它们与本场景无关):</p><h1 id="bc45" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">通过Nginx和https提供服务</h1><p id="4b8d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有两种方法来设置Nginx:使用docker容器，安装到主机上，并将docker容器暴露的端口映射到外部世界。</p><p id="e48b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就我个人而言，我更喜欢后者，因为我喜欢保持整洁。我也喜欢将我的certbot证书保存在主机的一个集中位置，以备将来使用，比如测试我的docker映像(将主机作为一个临时服务器)。</p><p id="f846" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了遵循这种方法，我们首先需要安装Nginx</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="59e7" class="nl lt iq ng b gy nm nn l no np">apt install nginx</span></pre><p id="5c3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，安装certbot。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="2dff" class="nl lt iq ng b gy nm nn l no np">sudo apt-get update<br/>sudo apt-get install software-properties-common<br/>sudo add-apt-repository universe<br/>sudo add-apt-repository ppa:certbot/certbot<br/>sudo apt-get update</span></pre><p id="ed90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后运行certbot。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="4120" class="nl lt iq ng b gy nm nn l no np">sudo certbot --nginx</span></pre><p id="cb4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你成功了，当你访问https://mydomain.com时，你会看到一个网页。这不是试驾</p><p id="3b2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在Nginx配置中设置您的服务器。Certbot已经在“/etc/nginx/sites-enabled”中为您创建了一个配置。更改主机及其指向的端口的配置，如下所示:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="532e" class="nl lt iq ng b gy nm nn l no np">server {<br/> server_name git.domain.com;<br/> client_max_body_size 256M;</span><span id="fad6" class="nl lt iq ng b gy nx nn l no np">location / {<br/>  proxy_pass <a class="ae kv" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank">http://localhost:4000</a>;</span><span id="af80" class="nl lt iq ng b gy nx nn l no np">proxy_read_timeout 3600s;<br/>  proxy_http_version 1.1;<br/>  # Websocket connection<br/>  proxy_set_header Upgrade $http_upgrade;<br/>  proxy_set_header Connection $connection_upgrade;<br/> }</span><span id="3f7a" class="nl lt iq ng b gy nx nn l no np">listen [::]:443;</span><span id="3129" class="nl lt iq ng b gy nx nn l no np">listen 443 ssl; # managed by Certbot<br/>    ssl_certificate /etc/letsencrypt/live/git.domain.com/fullchain.pem; # managed by Certbot<br/>    ssl_certificate_key /etc/letsencrypt/live/git.domain.com/privkey.pem; # managed by Certbot<br/> include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot<br/> ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><span id="1f2d" class="nl lt iq ng b gy nx nn l no np">}</span></pre><p id="93a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，您需要设置子域并将其映射到一个端口。当域是“git.example.com”时，Nginx会将流量转向这台机器上的端口4000——在本例中，它对应于docker中的GitLab安装。</p><p id="596e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们使用<code class="fe nd ne nf ng b">service nginx restart</code>重启Nginx安装时，我们就可以访问我们在<code class="fe nd ne nf ng b">https://git.mydomain.com/</code>的域名了。如果一切都做得正确，我们将会看到下面的结果——一个允许您为用户<code class="fe nd ne nf ng b">root</code>设置新密码的页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/514106e8a2324f315ecb360c6ddf8a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KRPzFzkKgIEsO_TK.png"/></div></div></figure><p id="a55d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成初始设置后，我们创建一个git repo，其中包含一个NodeJS应用程序(这里不讨论)。</p><p id="4f88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例应用</strong></p><p id="6df6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一节假设我们已经用一个可构建的NodeJS应用程序和一个有效的Dockerfile建立了一个git repo。</p><p id="3d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为示例，我们将采用一个稍微高级一些的Dockerfile来构建一个NodeJS应用程序。你的Dockerfile可能不一样，但是流程应该是一样的。下面的docker文件存储在我们的git存储库的根目录中。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="ff21" class="nl lt iq ng b gy nm nn l no np">FROM node:10.16<br/>EXPOSE 8080</span><span id="8fd3" class="nl lt iq ng b gy nx nn l no np">WORKDIR /app/</span><span id="e47f" class="nl lt iq ng b gy nx nn l no np">COPY . .<br/>COPY package*.json ./</span><span id="b7dd" class="nl lt iq ng b gy nx nn l no np">RUN npm install<br/>RUN npm run build<br/>RUN echo "finished building"<br/>RUN ls -afl dist</span><span id="e181" class="nl lt iq ng b gy nx nn l no np">FROM node:10.16-alpine<br/>WORKDIR /app/</span><span id="3107" class="nl lt iq ng b gy nx nn l no np">COPY --from=0 /app/dist ./dist<br/>COPY package*.json ./<br/>COPY --from=0 /app/node_modules ./node_modules</span><span id="1f5f" class="nl lt iq ng b gy nx nn l no np">ENTRYPOINT NODE_ENV=production npm run start:prod</span></pre><p id="28f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的Dockerfile使用<code class="fe nd ne nf ng b">node:10.16</code>来传输我们的应用程序。当构建完成时，它生成一个准备好执行的映像，使用<code class="fe nd ne nf ng b">10.16-alpine</code>作为基础映像。通过这种方式，我们可以在构建时安装所有需要的组件(webpack、node-sass、typescript编译工具)，但在运行时只安装少数几个，这导致了一个非常瘦的映像。当将它存储到docker容器注册中心时，这将节省很多空间(每个构建超过1GB)(如果使用付费的docker注册中心，这尤其重要)。</p><h1 id="f3ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用docker添加跑步者和设置构件</h1><p id="657d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们已经准备好了一个安装，我们需要添加“gitlab-runners”并将它们连接到我们的gitlab安装。当GitLab管道运行时，它会搜索可用的已配置运行程序，并使用它来执行构建。GitLab runner有许多模式可以操作，这些模式代表了构建将如何执行。在其他模式中，支持生成Kubernetes pods或Docker容器来执行构建。</p><p id="2809" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，我们将使用普通docker模式，这将生成一个新的容器，其中包含您选择的图像(由您的docker文件决定)</p><p id="5d60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的终端上运行以下命令:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="9aad" class="nl lt iq ng b gy nm nn l no np">docker run -d --name gitlab-runner --restart always \ -v /srv/gitlab-runner/config:/etc/gitlab-runner \ -v /var/run/docker.sock:/var/run/docker.sock \ gitlab/gitlab-runner:latest</span></pre><p id="ee4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的命令将把<code class="fe nd ne nf ng b">gitlab-runner</code>作为一个容器运行。它还会将主机的<code class="fe nd ne nf ng b">/srv/gitlab-runner/config</code>文件夹挂载到容器的<code class="fe nd ne nf ng b">/etc/gitlab-runner</code>位置。正如我们的主GitLab安装一样，容器的配置将持久保存在我们主机的文件夹中，这意味着通过更改<code class="fe nd ne nf ng b">/srv/gitlab-runner/config</code>文件夹中的配置，您也可以配置<code class="fe nd ne nf ng b">gitlab-runner</code>容器。该配置也将在容器的任何重新启动后继续存在。</p><p id="b5a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一切顺利，一个简单的<code class="fe nd ne nf ng b">docker ps</code>将显示以下信息。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="5021" class="nl lt iq ng b gy nm nn l no np">8c3322fea7d4        gitlab/gitlab-ce:latest                        "/assets/wrapper"        42 hours ago        Up 42 hours (healthy)   0.0.0.0:23-&gt;22/tcp, 127.0.0.1:4000-&gt;80/tcp, 0.0.0.0:4443-&gt;443/tcp   gitlab<br/>48aea5eded7e        gitlab/gitlab-runner:latest                    "/usr/bin/dumb-init …"   5 months ago        Up 5 days                                                                                   gitlab-runner</span></pre><p id="73ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在需要使用这个容器为GitLab安装创建一个新的运行器配置</p><p id="a67a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到“<a class="ae kv" href="https://git.oramind.net/admin/runners" rel="noopener ugc nofollow" target="_blank">https://mydomain.com/admin/runners</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5b59d14cf667a305dd13762c3311fa4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C0DwTa6jExohB6dR.png"/></div></div></figure><p id="ec75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到GitLab正在说“<code class="fe nd ne nf ng b">Use the following registration token during setup</code>”，并为is提供了一个注册令牌。这将被<code class="fe nd ne nf ng b">gitlab runner</code>用来注册一个新的流道配置。复制完这个令牌后，让我们使用刚刚创建的<code class="fe nd ne nf ng b">gitlab-runner</code>配置来设置我们的runner配置。让我们通过<code class="fe nd ne nf ng b">bash</code>进入新创建的<code class="fe nd ne nf ng b">gitlab-runner</code>容器。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="7e0c" class="nl lt iq ng b gy nm nn l no np">$ docker exec -ti gitlab-runner bash</span></pre><p id="fb17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过<code class="fe nd ne nf ng b">gitlab-runner register</code>设置一个新的流道配置。命令行会问你几个关于如何设置跑步者的问题。我们将按如下方式填写所需信息:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="5be2" class="nl lt iq ng b gy nm nn l no np">root@48aea5eded7e:/# gitlab-runner register</span><span id="8e5b" class="nl lt iq ng b gy nx nn l no np">Runtime platform                                    arch=amd64 os=linux pid=249 revision=a987417a version=12.2.0<br/>Running in system-mode.</span><span id="3b1a" class="nl lt iq ng b gy nx nn l no np">Please enter the gitlab-ci coordinator URL (e.g. <a class="ae kv" href="https://gitlab.com/" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/</a>):<br/><a class="ae kv" href="https://mydomain.com" rel="noopener ugc nofollow" target="_blank">https://mydomain.com</a></span><span id="9d45" class="nl lt iq ng b gy nx nn l no np">Please enter the gitlab-ci token for this runner:<br/>&lt;&lt;your gitlab ci token here&gt;&gt;</span><span id="b091" class="nl lt iq ng b gy nx nn l no np">Please enter the gitlab-ci description for this runner:<br/>[48aea5eded7e]: sample-docker-runner</span><span id="8704" class="nl lt iq ng b gy nx nn l no np">Please enter the gitlab-ci tags for this runner (comma separated):<br/>docker (whatever you need)<br/>Registering runner... succeeded                     runner=4usxjjv2</span><span id="7c1f" class="nl lt iq ng b gy nx nn l no np">Please enter the executor: custom, docker-ssh, parallels, shell, docker+machine, docker, ssh, virtualbox, docker-ssh+machine, kubernetes:<br/>docker</span><span id="e8c7" class="nl lt iq ng b gy nx nn l no np">Please enter the default Docker image (e.g. ruby:2.6):<br/>alpine:latest<br/>Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded!</span><span id="752e" class="nl lt iq ng b gy nx nn l no np">root@48aea5eded7e:/#</span></pre><p id="835a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以重新访问“<a class="ae kv" href="https://git.oramind.net/admin/runners" rel="noopener ugc nofollow" target="_blank">https://mydomain.com/admin/runners</a>”，我们将能够在跑步者列表中看到我们的新跑步者！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f4735d6c50f5020cacc3da1e264f8a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gMj0oMWM6sS0xqE7.png"/></div></div></figure><h1 id="267b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">编写构建步骤并触发构建</h1><p id="c2d1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面的<code class="fe nd ne nf ng b">.gitlab-ci.yml</code>放在我们git repo的根中。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="0f34" class="nl lt iq ng b gy nm nn l no np">image: docker:latest</span><span id="8e3c" class="nl lt iq ng b gy nx nn l no np">build_job:<br/>  stage: build<br/>  script:<br/>    - ls<br/>    - echo "starting job..."<br/>    - docker build -t "${CI_PROJECT_NAME}:${CI_COMMIT_REF_NAME}-0.1.${CI_JOB_ID}" .<br/>    - echo job finished<br/>  only:<br/>    - develop<br/>    - master</span></pre><p id="be12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">访问<a class="ae kv" href="https://git.oramind.net/unicorn/unicorn-api/pipelines" rel="noopener ugc nofollow" target="_blank">https://mydomain.com/&lt;my project&gt;/&lt;my repo&gt;/pipelines</a>并运行管道:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/231e7639e6798e1f3a6a41849a7ed00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U2Vzckqs3zkT871S.png"/></div></div></figure><p id="bef5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当构建完成时，我们的主机docker机器将创建一个新的映像，这个映像是由这个管道构建的。</p><h1 id="ebce" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">高级主题</h1><h2 id="0576" class="nl lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">将gitlab-runner和gitlab容器连接到同一个网络</h2><p id="5884" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你没有注意到，我们向gitlab-runner提供了我们域名的完整URL，尽管我们的gitlab安装建议使用<code class="fe nd ne nf ng b">http://localhost:4000</code>。我们这样做是因为<code class="fe nd ne nf ng b">gitlab-runner</code>和<code class="fe nd ne nf ng b">gitlab</code>容器不在同一个逻辑网络中——因此当从<code class="fe nd ne nf ng b">gitlab-runner</code>容器内部调用localhost时，会导致一个“连接被拒绝”的消息。</p><p id="d878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要解决这个问题，我们应该告诉Docker这两个容器存在于同一个逻辑网络上。</p><p id="43d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们可以这样做</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="3947" class="nl lt iq ng b gy nm nn l no np">$ docker network create gitlabnet $ docker network connect gitlabnet gitlab $ docker network connect gitlabnet gitlab-runner</span></pre><p id="b71f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中“gitlab”和“gitlab runner”是容器在创建时的名称(使用<code class="fe nd ne nf ng b">--name=...</code>)。</p><p id="ed62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以给<code class="fe nd ne nf ng b">http://gitlab</code>Docker的内部DNS给定的地址，而不是给<code class="fe nd ne nf ng b">https://git.mydomain.com</code>作为<code class="fe nd ne nf ng b">gitlab-runner register</code>命令的根检验url。</p><h1 id="d7dc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">避免码头工人在码头</h1><p id="033e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们的例子中，我们使用了<code class="fe nd ne nf ng b">image: docker:latest</code>作为基础图像，如我们的<code class="fe nd ne nf ng b">.gitlab-ci.yml</code>文件所示。我们的Dockerfile也使用了NodeJS映像。这意味着您使用Docker-In-Docker (dind)。这给你的构建带来了很大的开销。在某些情况下这可能无关紧要，但是如果资源有限，那么在构建时会很快耗尽内存。这个问题有两种解决方案:</p><p id="7126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个相当简单，涉及重写您的<code class="fe nd ne nf ng b">gitlab-ci.yml</code>文件，以便您使用您选择的图像作为基本图像，并在那里执行所有步骤，而不是在嵌入式docker中。这将从您的<code class="fe nd ne nf ng b">Dockerfile</code>中移除完整构建的负担，因为您可能只在任何构建的最后阶段需要它(只需复制构建的文件，并创建映像)。</p><p id="d721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你绝对想给你的Dockerfile完全的控制权，还有另外一个选择。当执行Dockerfile命令时，您可以配置您的runner使用主机的docker。您可以通过配置<code class="fe nd ne nf ng b">gitlab-runner</code>配置来使用主机docker。在我们的例子中，配置位于<code class="fe nd ne nf ng b">/srv/gitlab-runner/config/config.toml</code>。编辑文件，如下所示:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="c893" class="nl lt iq ng b gy nm nn l no np">[[runners]]<br/>  name = "sample-docker-runner"<br/>  url = "<a class="ae kv" href="https://git.mydomain.com" rel="noopener ugc nofollow" target="_blank">https://git.mydomain.com</a>"<br/>  token = "NyVXkhyh1atSm5x_werQ"<br/>  executor = "docker"<br/>  [runners.custom_build_dir]<br/>  [runners.docker]<br/>    tls_verify = false<br/>    image = "alpine:latest"<br/>    privileged = false<br/>    disable_entrypoint_overwrite = false<br/>    oom_kill_disable = false<br/>    disable_cache = false<br/>    volumes = ["/var/run/docker.sock:/var/run/docker.sock", "/cache"]<br/>    shm_size = 0<br/>  [runners.cache]<br/>    [runners.cache.s3]<br/>    [runners.cache.gcs]</span></pre><p id="d941" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们将<code class="fe nd ne nf ng b">/var/run/docker.sock:/var/run/docker.sock</code>卷挂载添加到了将由<code class="fe nd ne nf ng b">gitlab-runner</code>生成的容器中。</p><p id="8514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，请注意，这将把主机的docker暴露给容器。<a class="ae kv" href="https://stackoverflow.com/questions/40844197/what-is-the-docker-security-risk-of-var-run-docker-sock" rel="noopener ugc nofollow" target="_blank">这带来了安全风险</a>，如果不采取额外的预防措施，在大规模GitLab部署中应该可以避免。</p><h1 id="e21f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">从这里去哪里</h1><p id="c602" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">事实证明，使用Docker设置GitLab比我最初想象的更加灵活。我以此为基础为我的个人项目建立了一个跨越多个服务器的开发环境。</p><p id="98a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我鼓励任何人在完成这篇文章中的步骤后要做的事情。</p><ul class=""><li id="4975" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">配置SSH签出。有了这个配置，你应该能够使用HTTPS拉和推。如果您想要启用SSL，您将需要从GitLab容器中公开端口22，并执行一些更高级的配置，以避免将GitLab的SSL与您的主机的SSL(默认情况下将在同一个端口中运行)混合。</li><li id="3045" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用外部Docker容器注册表。你可以使用像<a class="ae kv" href="https://git.oramind.net/unicorn/unicorn-api/pipelines" rel="noopener ugc nofollow" target="_blank"> canister.io </a>这样的免费服务来保存你的docker图片。</li><li id="9207" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用像<a class="ae kv" href="https://www.portainer.io/" rel="noopener ugc nofollow" target="_blank">https://www.portainer.io/</a>这样的映像/容器管理工具来管理你主机上的容器/映像。这包括您的GitLab安装和GitLab运行程序。</li><li id="1d13" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">你可以通过谷歌搜索找到一些非常便宜的服务器，但是我建议你考虑一个按小时收费的主机。如果您需要一个用于宠物项目的CI/CD环境，这可以证明是特别有用的，因为您可以在一天中的大部分时间关闭机器，并避免为您不使用的东西付费。</li></ul><h1 id="be69" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="80a0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们只是触及了使用这种配置作为基础的可能性的表面。就我个人而言，我曾多次惊讶于只安装一个小的VPS Docker/GitLab就能完成的工作。</p><p id="4bdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的希望这篇文章对你有用。我渴望在评论里看到你的想法！</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="eccf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nt">原贴于</em> <a class="ae kv" href="https://oramind.com/private-cicd-using-gitlab-docker/" rel="noopener ugc nofollow" target="_blank"> <em class="nt"> Oramind </em> </a></p></div></div>    
</body>
</html>