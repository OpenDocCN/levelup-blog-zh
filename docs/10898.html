<html>
<head>
<title>Go Generics: Holistic Thoughts on Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go Generics:关于性能的整体思考</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-generics-holistic-thoughts-on-performance-fc6688fb414b?source=collection_archive---------1-----------------------#2022-01-23">https://levelup.gitconnected.com/go-generics-holistic-thoughts-on-performance-fc6688fb414b?source=collection_archive---------1-----------------------#2022-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/39216bc30ae0c2897d3c9abfc3816524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*7cdIN7ncTNPzhkBvr-OzMw.png"/></div></figure><p id="6e65" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">已经有很多关于Go中泛型的性能影响的讨论，围绕着具体的场景和抽象地，让我们试着更全面地思考一下。</p><h2 id="4aab" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">什么是性能？</h2><p id="cf9a" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">为了明确这一点，让我们快速澄清一下我们所说的性能是什么意思。</p><ul class=""><li id="1f60" class="lt lu it jz b ka kb ke kf ki lv km lw kq lx ku ly lz ma mb bi translated"><strong class="jz iu"> Raw </strong>:对照基准研磨代码，是快了还是慢了？它能很好地处理内存和垃圾收集器吗？</li><li id="93db" class="lt lu it jz b ka mc ke md ki me km mf kq mg ku ly lz ma mb bi translated"><strong class="jz iu">开发</strong>:使用的难易程度，即对开发者性能的影响。</li><li id="6306" class="lt lu it jz b ka mc ke md ki me km mf kq mg ku ly lz ma mb bi translated"><strong class="jz iu">寿命</strong>:可靠性？可以理解？灵活？可增强？</li></ul><p id="14b5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你认为只有原始性能才是最重要的，我会说为什么不是所有代码都用汇编语言编写？</p><h2 id="fbe7" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">给一个简单的例子评分</h2><p id="362e" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">让我们举一个简单的例子，用Go的泛型给性能打分。我将使用一个简单的<em class="mh"> min </em>函数，它接受两个参数并返回这两个参数中的最小值:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ead9" class="kv kw it mn b gy mr ms l mt mu"><em class="mh">// Min returns minimum value of two constraints.Ordered values,<br/>func </em>Min[T constraints.Ordered](a, b T) T {<br/>   <em class="mh">if </em>a &lt; b {<br/>      <em class="mh">return </em>a<br/>   }<br/>   <em class="mh">return </em>b<br/>}</span></pre><p id="3563" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将自下而上地工作。</p><h2 id="fd16" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">寿命:A+</h2><p id="eb19" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">这是一个单一的<a class="ae mv" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>功能，易于阅读，适用于许多类型。</p><h2 id="5a66" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated"><strong class="ak">开发:A+ </strong></h2><p id="2817" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">出于与它的终身性能相同的原因，它更适合开发。您不需要在众多特定类型的min函数中寻找一个，或者更糟的是，发现您想要的类型不受支持，需要重新编写。</p><h2 id="08e7" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">Raw:一个-</h2><p id="7f4f" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">因此，原始性能是更值得讨论的地方。通用函数<strong class="jz iu">不会比任何相应的特定类型函数</strong>更快。如果特定类型的丢失迫使你降低算法的速度，那么它可能会更慢。然而，考虑一下，如果你以前需要一个更加类型不可知的min，并且你写了一个接受类型<em class="mh"> interface{}，</em>的参数，即使实现很出色，<em class="mh"> interface{} </em>也要花费你装箱、拆箱和反射的时间。通用函数<strong class="jz iu">将</strong>明显更快。所以在原始性能方面，<strong class="jz iu"> <em class="mh">如果你需要泛型，使用Go的泛型会更快。</em> </strong></p><p id="6fb0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，如果你只需要一种类型，泛型版本不会天生就慢，除非它导致一个不太优雅的算法。这将产生一个稍大的二进制文件。</p><h2 id="abb2" class="kv kw it bd kx ky kz dn la lb lc dp ld ki le lf lg km lh li lj kq lk ll lm ln bi translated">摘要</h2><p id="999e" class="pw-post-body-paragraph jx jy it jz b ka lo kc kd ke lp kg kh ki lq kk kl km lr ko kp kq ls ks kt ku im bi translated">Go的泛型几乎肯定会提高您的开发和生命周期性能，在原始性能方面，如果在您真正需要时使用泛型，它们也应该是性能提升。</p></div></div>    
</body>
</html>