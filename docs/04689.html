<html>
<head>
<title>Programming Practices That Make Python More like An Object-Oriented Programming Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使Python更像面向对象编程语言的编程实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/programming-practices-that-make-python-more-like-an-object-oriented-programming-language-e8a62de65a4c?source=collection_archive---------18-----------------------#2020-07-09">https://levelup.gitconnected.com/programming-practices-that-make-python-more-like-an-object-oriented-programming-language-e8a62de65a4c?source=collection_archive---------18-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fb97095a5a45120da75c9ef0f413a420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*av7ZwZK_UcSuCmRR1C7gTg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://burst.shopify.com/@ndekhors?utm_campaign=photo_credit&amp;utm_content=Free+Stock+Photo+of+Developer+Coding+On+Laptop+%E2%80%94+HD+Images&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">妮可·德·霍斯</a>从<a class="ae kf" href="https://burst.shopify.com/education?utm_campaign=photo_credit&amp;utm_content=Free+Stock+Photo+of+Developer+Coding+On+Laptop+%E2%80%94+HD+Images&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">爆出</a></figcaption></figure><p id="3373" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di">作为一个长期使用Unity开发游戏的程序员，我使用的编程语言是C#。众所周知，C#是一种强类型语言，通常使用面向对象的范式进行编程(当然，它还有其他范式)。最近开始用Python编程。距离我上次使用Python已经过去5–6年了，那时候我用的是Python 2.7。因此，我的印象是Python是一种面向过程的动态编程语言，没有类型。</span></p><p id="704c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，现在我知道我错了。而且我发现下面的做法可以让我这样使用C#的程序员也非常习惯使用Python。</p><h1 id="ae96" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">类型注释和类型注释</h1><p id="a760" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我的第一个尝试是让Python成为一种强类型语言，至少让它看起来像一种强类型语言。好消息是，从Python3.5开始，Python通过<a class="ae kf" href="https://www.python.org/dev/peps/pep-0484" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 484 </strong> </a>引入了<strong class="ki iu">类型注释</strong>。</p><p id="36d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面是一个简单的函数，其参数和返回类型在注释中声明:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="f79b" class="mz lo it mv b gy na nb l nc nd">def greeting(name: str) -&gt; str:<br/>    return 'Hello ' + name</span></pre><p id="e590" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你在上面的例子中看到的，类型注释是通过在变量后添加<code class="fe ne nf ng mv b">: &lt;type&gt;</code>来完成的。对了，如果函数不返回，返回类型应该是<code class="fe ne nf ng mv b">None</code>。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2ef1" class="mz lo it mv b gy na nb l nc nd">def retry(url: Url, retry_count: int) -&gt; None: ...</span></pre><p id="8e2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果类型更复杂呢？例如，类型是元素为int的列表。</p><p id="0996" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python 3.5中的<strong class="ki iu">类型化</strong>模块可以用于此目的。本模块为<a class="ae kf" href="https://www.python.org/dev/peps/pep-0484" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 484 </strong> </a>、<a class="ae kf" href="https://www.python.org/dev/peps/pep-0526" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 526 </strong> </a>、<a class="ae kf" href="https://www.python.org/dev/peps/pep-0544" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 544 </strong> </a>、<a class="ae kf" href="https://www.python.org/dev/peps/pep-0586" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 586 </strong> </a>、<a class="ae kf" href="https://www.python.org/dev/peps/pep-0589" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 589 </strong> </a>、<a class="ae kf" href="https://www.python.org/dev/peps/pep-0591" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 591 </strong> </a>指定的类型提示提供运行时支持。最基本的支持包括类型<code class="fe ne nf ng mv b"><a class="ae kf" href="https://docs.python.org/3/library/typing.html#typing.Any" rel="noopener ugc nofollow" target="_blank">Any</a></code>、<code class="fe ne nf ng mv b"><a class="ae kf" href="https://docs.python.org/3/library/typing.html#typing.Union" rel="noopener ugc nofollow" target="_blank">Union</a></code>、<code class="fe ne nf ng mv b"><a class="ae kf" href="https://docs.python.org/3/library/typing.html#typing.Tuple" rel="noopener ugc nofollow" target="_blank">Tuple</a></code>、<code class="fe ne nf ng mv b"><a class="ae kf" href="https://docs.python.org/3/library/typing.html#typing.Callable" rel="noopener ugc nofollow" target="_blank">Callable</a></code>、<code class="fe ne nf ng mv b"><a class="ae kf" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" rel="noopener ugc nofollow" target="_blank">TypeVar</a></code>和<code class="fe ne nf ng mv b"><a class="ae kf" href="https://docs.python.org/3/library/typing.html#typing.Generic" rel="noopener ugc nofollow" target="_blank">Generic</a></code>。</p><p id="c536" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在键入的帮助下，您可以像这样添加类型注释:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e5d8" class="mz lo it mv b gy na nb l nc nd">from typing import <strong class="mv iu">List</strong></span><span id="bf26" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">def</strong> scale(scalar: float, vector: <strong class="mv iu">List[float]) -&gt; List[float]</strong>:<br/>    <strong class="mv iu">return</strong> [scalar * num <strong class="mv iu">for</strong> num <strong class="mv iu">in</strong> vector]</span></pre><p id="0fb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，<a class="ae kf" href="https://www.python.org/dev/peps/pep-0484" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 484 </strong> </a>主要关注的是函数注释，在Python 3.6中通过<a class="ae kf" href="https://www.python.org/dev/peps/pep-0526" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> PEP 526 </strong> </a> <strong class="ki iu">增加了一个用于输入变量的语法。</strong>有两种语法变体，有或没有初始化表达式:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d4ae" class="mz lo it mv b gy na nb l nc nd">from typing import Optional<br/>foo<strong class="mv iu">: Optional[int]</strong>  <em class="ni"># No initializer</em><br/>bar<strong class="mv iu">: List[str] = []</strong>  <em class="ni"># Initializer</em></span></pre><p id="6b3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">添加类型提示的另一种方式是<a class="ae kf" href="https://www.python.org/dev/peps/pep-0484/#type-comments" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">类型注释</strong> </a>，这是Python 2代码的一种基于注释的注释语法。有一些例子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7ac8" class="mz lo it mv b gy na nb l nc nd">x = 1  <em class="ni"># type: int</em><br/>x = 1.0  <em class="ni"># type: float</em><br/>x = True  <em class="ni"># type: bool</em><br/>x = "test"  <em class="ni"># type: str</em><br/>x = u"test"  <em class="ni"># type: unicode</em></span></pre><p id="c7a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类型注释是通过在变量后添加<code class="fe ne nf ng mv b"># type:</code>来完成的。</p><h1 id="7a87" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">接口/抽象类</h1><p id="89d5" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">Python标准库<code class="fe ne nf ng mv b"><a class="ae kf" href="https://docs.python.org/3/library/abc.html#module-abc" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">abc</strong></a></code>(<strong class="ki iu">A</strong>B<strong class="ki iu">B</strong>ase<strong class="ki iu">C</strong>lass)模块经常被用来定义和验证接口。它定义了一个元类<code class="fe ne nf ng mv b">ABCMeta</code>和装饰者<code class="fe ne nf ng mv b">@abstractmethod</code>和<code class="fe ne nf ng mv b">@abstractproperty</code>。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1df4" class="mz lo it mv b gy na nb l nc nd">from abc import <strong class="mv iu">ABCMeta, abstractmethod</strong></span><span id="6a06" class="mz lo it mv b gy nh nb l nc nd">class AbstractStrategy(<strong class="mv iu">metaclass=ABCMeta</strong>):    <br/>    <strong class="mv iu">@abstractmethod </strong>   <br/>    def algorithm_interface(self):        <br/>        pass</span><span id="b259" class="mz lo it mv b gy nh nb l nc nd">class ConcreteStrategyA(<strong class="mv iu">AbstractStrategy</strong>):    <br/>    def algorithm_interface(self):        <br/>        print("ConcreteStrategyA")</span></pre><p id="b498" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而另一个替代方案是使用<a class="ae kf" href="https://interface.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">接口</strong> </a>库。它是一个用于声明接口和静态断言类实现这些接口的库。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1323" class="mz lo it mv b gy na nb l nc nd"><strong class="mv iu">from</strong> <strong class="mv iu">interface</strong> <strong class="mv iu">import</strong> implements, Interface</span><span id="dbaa" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">class</strong> <strong class="mv iu">MyInterface</strong>(Interface):</span><span id="feac" class="mz lo it mv b gy nh nb l nc nd">    <strong class="mv iu">def</strong> method1(self, x):<br/>        <strong class="mv iu">pass</strong></span><span id="a4ad" class="mz lo it mv b gy nh nb l nc nd">    <strong class="mv iu">def</strong> method2(self, x, y):<br/>        <strong class="mv iu">pass</strong><br/></span><span id="6d0c" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">class</strong> <strong class="mv iu">MyClass</strong>(implements(MyInterface)):</span><span id="3098" class="mz lo it mv b gy nh nb l nc nd">    <strong class="mv iu">def</strong> method1(self, x):<br/>        <strong class="mv iu">return</strong> x * 2</span><span id="3e00" class="mz lo it mv b gy nh nb l nc nd">    <strong class="mv iu">def</strong> method2(self, x, y):<br/>        <strong class="mv iu">return</strong> x + y</span></pre><h1 id="da19" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">静态方法</h1><p id="747d" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">您可以使用<code class="fe ne nf ng mv b"><a class="ae kf" href="https://docs.python.org/3/library/functions.html#staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a></code>装饰器来定义一个类中的静态函数。静态方法不接收隐式第一个参数(self)。还有一个例子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="8ded" class="mz lo it mv b gy na nb l nc nd"><strong class="mv iu">class</strong> <strong class="mv iu">C</strong>:<br/>    <strong class="mv iu">@staticmethod</strong><br/>    <strong class="mv iu">def</strong> f(arg1, arg2, ...): ...</span></pre><p id="9515" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在静态方法<code class="fe ne nf ng mv b">f()</code>既可以在类上调用(比如<code class="fe ne nf ng mv b">C.f()</code>)，也可以在实例上调用(比如<code class="fe ne nf ng mv b">C().f()</code>)。</p><h1 id="028b" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">无商标消费品</h1><p id="7f51" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">通过使用上面提到的<strong class="ki iu">类型化</strong>模块，可以在Python中使用泛型。类型模块提供了几个通用集合，比如<strong class="ki iu"> List、Mapping、Dict。它们分别是list、Mapping、dict的通用版本。</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="e48a" class="mz lo it mv b gy na nb l nc nd">T = <strong class="mv iu">TypeVar</strong>('T', int, float)</span><span id="24d2" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">def</strong> vec2(x: T, y: T) -&gt; <strong class="mv iu">List</strong>[T]:<br/>    <strong class="mv iu">return</strong> [x, y]</span><span id="b80f" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">def</strong> keep_positives(vector: <strong class="mv iu">Sequence</strong>[T]) -&gt; <strong class="mv iu">List</strong>[T]:<br/>    <strong class="mv iu">return</strong> [item <strong class="mv iu">for</strong> item <strong class="mv iu">in</strong> vector <strong class="mv iu">if</strong> item &gt; 0]</span><span id="99f2" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">def</strong> get_position_in_index(word_list: <strong class="mv iu">Mapping</strong>[str, int], word: str) -&gt; int:<br/>    <strong class="mv iu">return</strong> word_list[word]</span><span id="de9e" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">def</strong> count_words(text: str) -&gt; <strong class="mv iu">Dict</strong>[str, int]:<br/>    ...</span></pre><p id="4c70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户定义的类也可以定义为泛型类。类只需要继承<code class="fe ne nf ng mv b">Generic</code>。<a class="ae kf" href="https://docs.python.org/3/library/typing.html#typing.Generic" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">泛型</strong> </a>是泛型类型的抽象基类。例如，一般用户定义的类可以定义为:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="5a9c" class="mz lo it mv b gy na nb l nc nd">from typing import TypeVar, Generic<br/>from logging import Logger</span><span id="e8dd" class="mz lo it mv b gy nh nb l nc nd">T = TypeVar('T')</span><span id="3f64" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">class</strong> LoggedVar(<strong class="mv iu">Generic[T]</strong>):<br/>    <strong class="mv iu">def</strong> __init__(self, <strong class="mv iu">value: T</strong>, name: str, logger: Logger) -&gt; <strong class="mv iu">None</strong>:<br/>        self.name = name<br/>        self.logger = logger<br/>        self.value = value</span></pre><p id="422c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类<code class="fe ne nf ng mv b">LoggedVar</code>采用单一类型参数<code class="fe ne nf ng mv b">T</code>。</p><p id="49fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后可以如下使用<code class="fe ne nf ng mv b">LoggedVar</code>类:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="06b4" class="mz lo it mv b gy na nb l nc nd">T = TypeVar('T')</span><span id="22a3" class="mz lo it mv b gy nh nb l nc nd"><strong class="mv iu">def</strong> foo(logged: LoggedVar[T]) -&gt; None:</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="9a81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，通过以上的编程实践，我一个C#程序员，可以用熟悉的方式用Python语言编程了，耶！</p><p id="17fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读，希望这篇文章有用！</p></div></div>    
</body>
</html>