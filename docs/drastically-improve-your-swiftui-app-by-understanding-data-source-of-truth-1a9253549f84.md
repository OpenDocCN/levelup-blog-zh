# 通过了解真实数据来源来增强您的 SwiftUI 应用程序

> 原文：<https://levelup.gitconnected.com/drastically-improve-your-swiftui-app-by-understanding-data-source-of-truth-1a9253549f84>

在苹果全球开发者大会上发布的视频“SwiftUI 中的[数据要点”中，短语“真相的来源”被提及多达 31 次。那么这意味着什么呢？思考这个原则如何帮助你编写更好的 SwiftUI 应用程序？](https://developer.apple.com/videos/play/wwdc2020/10040/)

![](img/2944fd0aa97be613f54c342eb457d02f.png)

像用户详细信息这样的数据，我们的真实来源在哪里？

# 真理的来源是什么？

真实的来源是 SwiftUI 中的一个关键概念，如果你看苹果的全球开发者大会视频，你会听到他们一遍又一遍地重申这个概念。他们本质上是说，你需要决定在一个地方存储一段数据，并让其他地方读取同一段数据——因此是真实的单一来源。

您不应该试图保持两个值同步，或者在一个值改变时手动更新另一个值。SwiftUI 的整体思想是它是一种声明性语言，这意味着给定状态为 X，视图将始终看起来像 y。如果您给它状态 X，它应该调用函数 A 来更新状态 B，您正在强制性地编写代码。这可能是编写 UIKit 应用程序、Kotlin 中的 Android 应用程序或中的 Web APIs 的方式。NET，但它不是 SwiftUI 的做事方式。

让我们看看如何显示一个项目列表，我们可以用三种方式排序，例如:按最后更新时间、按字母顺序或随机。

进行这种排序的声明性方式是通过保存某种状态来指示我们当前排序的三种方式中的哪一种。然后，视图获取要排序的项目列表，以及指示它们应该如何排序的状态，并显示按照用户指示的方式排序的项目列表。当用户点击一个按钮来改变列表的排序方式时，它所做的只是设置这个排序状态的值，视图将重新计算(或重新计算、重新呈现等)。)按新的排序方法显示数据。

这与命令式的方法相反，当你点击一个按钮时，会直接调用一个排序方法。使用这种方法，无法知道我们当前使用的是哪种排序方法。相反，我们依靠用户采取的行动来排序列表。如果我们还想显示一个代表我们排序方式的图标，我们需要更新当用户改变排序方式时调用的动作，以更新图标。

让我们来看一个我为了演示而编造的例子:

每种方法都会更新视图。即使我们只调用每个方法一次，许多不同的排列也会产生不同的视图。看一看:

![](img/c71675f30379bc5ffaa163e5727a1107.png)

相同三个方法的不同排列只调用一次

现在想象一下，如果我们只添加一个方法，或者重复这些方法，那么更新视图的可能方式有多种。确定我们的视图应该是什么样子变得非常复杂。再加上屏幕旋转、网络活动或应用生命周期等事件，你的用户界面就变得非常复杂。难怪 UI 这么硬。

相反，让我们来看看用 SwiftUI 编写的视图:

当然，这个视图不允许用户采取任何行动——但是屏幕上显示的内容完全来自于它的状态。我们只需要理解两种状态——条目和计数器，而不是有无限多的组合可以影响视图的外观。是的，这个视图可以有一个更复杂的状态，但是重点是我们不需要担心直接操纵视图的一系列事件，以及它们的顺序。相反，我们告诉视图世界的状态是什么，它决定如何显示我们的数据。世界的状态是什么？嗯，这是我们的数据，我们的**真相来源**。

而现在，我们的数据直接驱动了我们的 UI。给定相同的数据，我们的 UI 看起来总是一样的。我们不再需要以正确的顺序调用事件来更新我们的 UI，我们只需要更新数据，让视图响应数据。

# 我们的真理之源在哪里？

因此，我们知道我们的真实来源是什么——驱动我们应用程序的数据——下一个合乎逻辑的问题是我们将它存储在哪里？首先，我喜欢将所有**重要的**数据存储在[可观察对象](/state-vs-stateobject-vs-observedobject-vs-environmentobject-in-swiftui-81e2913d63f9)中。我的意思是，在符合 ObservableObject 的结构中存储任何非简单 UI 状态的数据(例如，开关)。这超出了本文的范围，但是要了解关于 ObservableObjects 的更多信息，请查看我的另一个故事。

我们的真理之源应该永远放在最高的父母身上。也就是说，该视图包含可能需要该数据的所有其他视图。换句话说，最接近需要数据的`ContentView`的第一个视图。

所以现在的问题是，我们在哪里实例化我们的 ObservableObject？让我们使用两个我们可能希望在应用程序中访问的真实数据示例:

1.  电影列表，以及用户是否看过这些电影
2.  用户是否登录，以及他们的姓名

第一个例子是两个例子中比较简单的一个。我们可以将电影列表的数据包含到两种类型的视图中。一个是电影本身的列表，另一个是每部电影单独的列表。请看一些示例代码:

如你所见，电影的使用仅限于这两种观点。它不需要在我的应用程序的任何其他地方访问，至少在我的应用程序的当前实现中。

因此，我们的`Movies`对象是在`MoviesListView`中创建的，正如您在第 2 行的**中看到的。这是最上层的父视图，因为它是包含`MovieView`的视图，也需要访问相同的数据。我们不会在`MovieView`中创建`Movies`，因为我们无法从`MoviesListView`访问它，我们也不想为每一部电影都重新创建它。**

另一个例子是存储用户是否登录，以及他们的名字是什么。我再一次提到我之前说过的话。我们应该在最上面的父类中实例化这些数据。然而，对于用户详细信息，这可能会在我们的应用程序中使用——在任何视图中。

考虑到这一点，让我们继续把它放在应用程序的最上层——我们的应用程序本身。

正如我们在这里看到的，我已经在应用程序的顶部实例化了我们的`UserDetails` ObservableObject，然后将其作为环境对象添加到`ContentView`上，这样我们的整个应用程序就可以访问来自`UserDetails`的任何属性。这意味着我们应用程序中的任何视图都可以知道用户是否登录，以及用户的用户名是什么。

如果用户登录了，我们可以用它来显示内容；如果用户没有登录，我们可以用一个简单的条件语句将他们指向登录屏幕。我们没有触发类似于`login()`的事件，而是通过类似于`if userDetails.isLoggedIn { ContentView() } else { LoginView() }`的东西来决定是否向他们显示登录屏幕。这使得理解你的应用程序的用户界面的不同行为方式变得更加容易。

这就是你要做的——快速进入声明式用户界面和事实来源的世界。希望这个故事能给你一些启发，让你知道你的真实来源是什么，然后在你的应用程序中把它存储在哪里。因为在 SwiftUI 中，UI 直接与您的应用程序的生命周期相关联，所以这些决策对于确保您的数据在您需要时可用非常重要。通过了解您的真实来源以及它在应用程序中的位置，您将能够更好地决定在哪里实例化您的对象，这将使您的代码更容易理解和遵循。

如果你喜欢这个故事，请鼓掌，并留下你的任何问题，我会尽我所能来回答他们！