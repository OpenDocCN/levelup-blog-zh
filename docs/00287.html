<html>
<head>
<title>Go With Go(Lang): Features and Testing Frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go With Go(Lang):特性和测试框架</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-with-go-lang-features-and-testing-frameworks-ab39c51d0c66?source=collection_archive---------0-----------------------#2018-12-21">https://levelup.gitconnected.com/go-with-go-lang-features-and-testing-frameworks-ab39c51d0c66?source=collection_archive---------0-----------------------#2018-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/67040fef59a42725379c9f82ac19f75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8c333d_YNEHG4q3UDb1wTA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">在<a class="ae jd" href="https://unsplash.com/search/photos/software-development?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jd" href="https://unsplash.com/photos/5fNmWej4tAA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Helloquence </a>拍摄的照片</figcaption></figure><div class=""/><p id="3d01" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用GoLang进行自动化测试</p><p id="85cb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文的第一部分中，<a class="ae jd" href="https://medium.com/@iryna.suprun/go-with-golang-e863cf874e0e" rel="noopener"> Go With Go(郎):为什么要走？</a>我们讨论了如何为测试自动化选择编程语言，以及为什么Go是一个强有力的竞争者。在这一部分中，我们将看一看使自动化变得更加容易的几个更令人兴奋的特性，并简要概述最流行的Go测试框架。</p><p id="279b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最喜欢的GoLang功能是<strong class="kf jh"> goroutines。自动化测试通常需要等待一些事情发生。等待时间可能不同，可能是几毫秒或几秒，甚至几分钟。当被测产品向内部或外部的消息服务(Kafka，PubSub)发布消息时，这种情况很常见。当被测系统软件使用微服务架构构建时，就会出现这种情况。当测试查询巨大的数据集(现在大数据无处不在)或下载大文件时，也会发生这种情况。它发生在我们看到异步或事件驱动行为的任何地方。</strong></p><p id="cb3a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">处理这种情况最常见的错误是使用睡眠。这在测试自动化中是一个大问题。这是反模式的。睡眠使自动化测试变得缓慢或古怪，或者两者兼而有之。如果你的测试中有它们，就尽快把它们去掉。</p><p id="62ae" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自动化测试应该等待事件发生或超时，而不是休眠，在其他情况下，它们应该能够处理异步。Goroutines使实现异步逻辑变得容易。那么这是什么——戈鲁丁？官方定义称<em class="lb"> goroutine </em>是一个轻量级的执行线程。对于本文的范围来说，这就是我们需要知道的全部内容。</p><p id="4ed9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几个特性使goroutine非常适合自动化:</p><ul class=""><li id="b093" class="lc ld jg kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">你甚至可以在普通的笔记本电脑上旋转许多goroutine，甚至不会注意到它(每个go routine只使用2KB的内存)。此外，他们只使用他们需要的内存。</li><li id="b382" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">使用通道在goroutines之间实现和通信很容易。</li><li id="56e4" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">goroutines易于使用，不需要高级编码技能</li></ul><p id="11db" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一点非常重要，在测试中使用goroutines和实现多线程，你不需要成为一个围棋大师。您需要知道的所有内容都包含在基础的<a class="ae jd" href="https://tour.golang.org/welcome/1" rel="noopener ugc nofollow" target="_blank"> go教程</a>中(如果您编写了一个需要在开始之前阅读和学习更多关于并发性的产品代码，请不要误解我的意思)。</p><p id="8420" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我以前使用Java和Python来自动化复杂的测试用例，用这些语言实现异步的、事件驱动的逻辑(读多线程)需要高级的编码技能。如果你使用Go，那就简单多了。</p><p id="1a51" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的例子中，test验证了通过点击API端点创建的消息被发送到Kafka队列。如果在队列中找到我们发送的消息，测试应该通过，如果没有或超时，测试应该失败。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="d947" class="lz ma jg lv b gy mb mc l md me"><strong class="lv jh">func </strong>TestPostToKafkaQueue(t *testing.T) {</span><span id="bbbf" class="lz ma jg lv b gy mf mc l md me"><strong class="lv jh">    var </strong>waitGroup sync.WaitGroup<br/>    //create and post message to Kafka queue<br/>    resp, _ := buildAndSendMessage(url, id, <strong class="lv jh"><em class="lb">true</em></strong>)<br/>    //fail test if creating message resulted in error<br/>    assert.Equal(t, resp.Status, <strong class="lv jh">“200 OK”</strong>)<br/>    //setting up a timeout. Test will stop when timeout is reached<br/>    ctx, cancel := context.WithTimeout(context.Background(),   timeout)<br/><strong class="lv jh">    defer </strong>cancel()<br/>    waitGroup.Add(1)</span><span id="09a4" class="lz ma jg lv b gy mf mc l md me">//this is our goroutine. In the code below we start separate      thread that will be constantly consuming messages from queue and checking that it is message that we expected to see<strong class="lv jh"><br/>    go func</strong>(){<br/>       result, err := consume(ctx, topic, true, topic, id)<br/><strong class="lv jh">       if </strong>err != nil {<br/>          fmt.Println(<strong class="lv jh">“ERROR: Consuming error”</strong>, err)<br/>          assert.FailNow(t, "Failed to consume message from queue<strong class="lv jh"><em class="lb">"</em></strong>)<br/>       }<br/>       fmt.Println(<strong class="lv jh">“Found event in kafka topic:”</strong>, result)<br/>       waitGroup.Done()<br/>       ctx.Done()<br/>       assert.Equal(t, result, <em class="lb">expected_result</em>)<br/>       }()<br/>    waitGroup.Wait()<br/>}</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="aedf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有另外两个特性使得Go非常适合测试自动化:</p><ul class=""><li id="a3ce" class="lc ld jg kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><strong class="kf jh">没有例外。自己处理错误的能力对于编写自动化测试和框架来说是一个很大的优势。它给了我们工具来查明到底哪里出错了，并使失败测试用例的调试变得轻而易举。例如，我们自动化了完全模拟生产系统中数据流端到端测试。测试运行了几个小时，数据由不同的系统组件处理。当它失败时，我们有非常具体的错误消息，并能够在几秒钟内找到失败的根本原因。</strong></li><li id="74da" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf jh">多个返回值。</strong>您可以返回错误和部分响应、测试结果以及解释错误的消息。一切。这个特性最常用的情况是返回一些对象和错误。</li></ul><p id="30c5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个在测试中使用多个响应的例子，该测试命中<em class="lb">/执行</em> API端点并验证它返回200 OK。如果请求失败，它会点击<em class="lb">google.com</em>并返回来自它的响应和来自请求的错误到<em class="lb">/执行</em>(请不要问我为什么有人会有这样奇怪的测试，也许我们想检查我们仍然能够连接到谷歌，这已经成为互联网连接的同义词)</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="e4b5" class="lz ma jg lv b gy mb mc l md me"><strong class="lv jh">func httpRequestMultipleResponseValues</strong>(url string) (*http.Response, error) {<br/>  client := &amp;http.Client{}<br/>  r, err := http.NewRequest(http.MethodGet, url)<br/>  r.Close = <strong class="lv jh"><em class="lb">true<br/>  </em>if </strong>err != nil {<br/>    <strong class="lv jh">return </strong>nil, err<br/>  }</span><span id="3667" class="lz ma jg lv b gy mf mc l md me">response, err := client.Do(r)<br/>  <strong class="lv jh">if </strong>err != nil {<br/>    //if error is returned when we hit 'url' we will hit google  and return response from google and 'url' error<br/>     r, _ := http.NewRequest(http.MethodGet, "<strong class="lv jh">http://google.com/</strong>")<br/>     responseAlt, _ := client.Do(r)<br/>     <strong class="lv jh">return </strong>responseAlt, err<br/>  }</span><span id="4468" class="lz ma jg lv b gy mf mc l md me">//in case of positive scenario we return /execute response and nil as an error<strong class="lv jh"><br/>  return </strong>response, nil<br/>}</span><span id="14a3" class="lz ma jg lv b gy mf mc l md me"><strong class="lv jh">func TestMultipleReturns</strong>(t *testing.T) {<br/>  url := fmt.Sprint("<strong class="lv jh">http://localhost:8080/execute"</strong>)<br/>  resp, err := httpRequestMultipleResponseValues(url)<br/>  <strong class="lv jh">if </strong>err != nil {<br/>     if resp.Status != http.StatusOK {<br/>     fmt.Println("Additional requests failed")<br/>     }<br/>     assert.FailNow(t, "Test Failed!<strong class="lv jh"><em class="lb">"</em></strong>)<br/>  }<br/>  assert.Equal(t, resp.Status, "<strong class="lv jh">200 OK"</strong>)<br/>}</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="93e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在来说说<strong class="kf jh">工装</strong>。首先，Go不需要web框架。HTTP，JSON，HTML模板支持是在语言中内置的，这是一个巨大的优势。</p><p id="e866" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有多种测试框架可以帮助组织测试，提供额外的资产，报告功能和许多其他有用的特性。其中一个是<a class="ae jd" href="https://github.com/smartystreets/goconvey" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">go convey</strong></a><strong class="kf jh">。这是地鼠的BDD框架。它允许将测试描述和测试代码保存在一个地方。GoConvey与<em class="lb"> go test </em>配合使用，可在终端或浏览器中使用，提供出色的报告。它需要不到一分钟，包括下载时间开始使用它。可惜GoConvey的开发已经在2017年8月停止。</strong></p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="8d9d" class="lz ma jg lv b gy mb mc l md me"><strong class="lv jh">func </strong>TestExecute_POST(t *testing.T) {</span><span id="f9ee" class="lz ma jg lv b gy mf mc l md me">Convey("<strong class="lv jh">Given call to /execute EP of test API"</strong>, t, <strong class="lv jh">func</strong>() {<br/>   resp, err := httpRequest("<strong class="lv jh">http://localhost:8080/execute", </strong>url)<br/>   Convey("<strong class="lv jh">When successful response returned"</strong>, <strong class="lv jh">func</strong>() {<br/>      <strong class="lv jh">if </strong>err != nil {<br/>        fmt.Println(<strong class="lv jh">“Requests failed”</strong>, err)<br/>        So(<strong class="lv jh"><em class="lb">true</em></strong>, ShouldEqual, <strong class="lv jh"><em class="lb">false</em></strong>)<br/>      }<br/>      fmt.Println(<strong class="lv jh">“Response:”</strong>, resp.Status)<br/>      Convey("<strong class="lv jh">The response HTTP status code should be 200"</strong>, <strong class="lv jh">func</strong>() {<br/>        So(resp.Status, ShouldContainSubstring, "200<strong class="lv jh">"</strong>)<br/>    })<br/>   })<br/>})<br/>}</span></pre><p id="0e9a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种，比较流行的BDD式围棋测试框架是<strong class="kf jh"> </strong> <a class="ae jd" href="http://github.com/onsi/ginkgo" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">银杏</strong> </a> <strong class="kf jh">。</strong>它最好与<a class="ae jd" href="http://github.com/onsi/gomega" rel="noopener ugc nofollow" target="_blank"> Gomega </a> matcher库配对，但被设计成与匹配器无关。银杏比GoConvey有更复杂的设置，但是它有更好的测试组织，更多的特性，并且更成熟。银杏是建立在<code class="fe mn mo mp lv b">testing</code>包之上的，所以它与其他测试兼容，即使他们不使用银杏。</p><p id="03c1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最新版本—2018年8月。如果我现在选择自动化框架，我会选择银杏。</p><p id="961f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">银杏声称它支持测试异步性，但我不会说这是银杏的特性，它只是包装良好的常规GoLang例程。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="4597" class="lz ma jg lv b gy mb mc l md me">It("<strong class="lv jh">should post to the channel, eventually"</strong>, <strong class="lv jh">func</strong>(done Done) {<br/> c := make(<strong class="lv jh">chan </strong>string, 0)</span><span id="b05b" class="lz ma jg lv b gy mf mc l md me"><strong class="lv jh">go </strong>DoSomething(c)<br/> Expect(&lt;-c).To(ContainSubstring(<strong class="lv jh">“Done!”</strong>))<br/> close(done)<br/>}, 0.2)</span></pre><p id="cf55" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个银杏测试的例子(我从银杏文档中获得)</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="b9c3" class="lz ma jg lv b gy mb mc l md me"><strong class="lv jh">func </strong>TestApi(t *testing.T) {<br/>   RegisterFailHandler(Fail)<br/>   RunSpecs(t, "<strong class="lv jh">Api Suite"</strong>)<br/>}</span><span id="b6d4" class="lz ma jg lv b gy mf mc l md me"><strong class="lv jh">var </strong>_ = Describe("<strong class="lv jh">Api</strong>", <strong class="lv jh">func</strong>() {<br/>    Describe("<strong class="lv jh">Test Convey APIs — execute ep</strong>", <strong class="lv jh">func</strong>() {<br/>    resp, _ := httpRequest(<strong class="lv jh">“http://localhost:8080/execute"</strong>)<br/>     Context("<strong class="lv jh">Hit execute EP"</strong>, <strong class="lv jh">func</strong>() {<br/>       It("<strong class="lv jh">Should get response 200 OK</strong>", <strong class="lv jh">func</strong>() {<br/>          Expect(resp.Status).To(Equal(<strong class="lv jh">“200 OK”</strong>))<br/>       })<br/>     }) <br/>    })<br/>})</span></pre><p id="bd11" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为Go最适合后端测试，但是有一个用于Go的通用WebDriver客户端— <a class="ae jd" href="http://github.com/sclevine/agouti" rel="noopener ugc nofollow" target="_blank"> Agouti </a>。我个人从未使用过它，但我相信它有未来。Agouti提供<a class="ae jd" href="https://github.com/onsi/gomega" rel="noopener ugc nofollow" target="_blank"> Gomega </a>匹配器，与<a class="ae jd" href="https://github.com/onsi/ginkgo" rel="noopener ugc nofollow" target="_blank">银杏</a>和<a class="ae jd" href="https://github.com/sclevine/spec" rel="noopener ugc nofollow" target="_blank"> Spec </a>一起工作(另一个BBD测试组织者)。上一次发布是在2018年3月，所以它的开发非常活跃。</p><p id="ae28" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有多种用于负载测试的GoLang测试工具。其中最成熟的是<a class="ae jd" href="https://github.com/tsenart/vegeta" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">贝吉塔</strong> </a> <strong class="kf jh">，</strong> HTTP负载测试工具。它既可以用作命令行实用工具，也可以用作库，并且和本文中提到的所有其他工具一样是开源的。上一次发布是在2018年10月。</p><p id="74d7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:我提到的所有发布日期都是截至2018年12月的实际日期。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="4a2a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在你走之前，我想强调几点。</p><ul class=""><li id="c34f" class="lc ld jg kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">测试库足以创建单元、集成和e2e测试</li><li id="c4b6" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">无论你选择什么样的框架，go test总是运行你的测试</li><li id="4fd9" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">有许多测试框架，它们都是开源的</li><li id="8261" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">异步的、事件驱动的测试非常容易构建</li><li id="5faf" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">一个框架—所有测试(api、负载、后端端到端)</li></ul><p id="db18" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一点——本文的重点不是说服每个人使用GoLang实现自动化，而是让测试社区对新事物更加开放。有许多工具和语言可能比大多数流行的工具和语言更适合您的自动化需求。明智地选择你的语言和工具，祝你自动化愉快！</p><p id="1951" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用来准备本文的资源:</p><ul class=""><li id="efa1" class="lc ld jg kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae jd" href="https://github.com/avelino/awesome-go#testing" rel="noopener ugc nofollow" target="_blank">Awesome Go</a>—Awesome Go框架、库和软件列表。</li><li id="78d5" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae jd" href="https://medium.com/agrea-technogies/basic-testing-patterns-in-go-d8501e360197" rel="noopener">围棋基本测试模式</a>作者<a class="ae jd" href="https://medium.com/@sebdah" rel="noopener">塞巴斯蒂安·达尔格伦</a></li><li id="d381" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae jd" href="https://hackernoon.com/the-beauty-of-go-98057e3f0a7d" rel="noopener ugc nofollow" target="_blank">围棋之美</a>作者<a class="ae jd" href="https://hackernoon.com/@kanishkdudeja" rel="noopener ugc nofollow" target="_blank">卡尼什克·杜德佳</a></li><li id="a0d6" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae jd" href="https://opensource.com/article/17/11/why-go-grows" rel="noopener ugc nofollow" target="_blank">为什么围棋人气暴涨</a>作者<a class="ae jd" href="https://opensource.com/users/jeffr" rel="noopener ugc nofollow" target="_blank">杰夫·劳斯</a></li><li id="9e8c" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae jd" href="https://medium.com/exploring-code/why-should-you-learn-go-f607681fad65" rel="noopener">为什么要学围棋？</a>作者<a class="ae jd" href="https://medium.com/@kevalpatel2106" rel="noopener">凯夫尔·帕特尔</a></li><li id="1a93" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae jd" href="https://hackernoon.com/5-reasons-why-we-switched-from-python-to-go-4414d5f42690" rel="noopener ugc nofollow" target="_blank">我们从Python转向Go的5个原因</a>作者<a class="ae jd" href="https://hackernoon.com/@tigranbs" rel="noopener ugc nofollow" target="_blank"> Tigran Bayburtsyan </a></li><li id="f0f5" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae jd" href="https://about.sourcegraph.com/go/gophercon-2018-from-prototype-to-production-lessons-from-building-and/" rel="noopener ugc nofollow" target="_blank">GopherCon 2018——从原型到生产:用Go<a class="ae jd" href="https://twitter.com/devalshah" rel="noopener ugc nofollow" target="_blank">Deval Shah</a>构建和扩展Reddit广告服务平台的经验教训</a></li><li id="1b04" class="lc ld jg kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">Mat Ryer 用#golang 编写单元测试的5个简单提示和技巧</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><figure class="lq lr ls lt gt is gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi mq"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure><div class="ip iq gp gr ir mr"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jh gy z fp mw fr fs mx fu fw jf bi translated">学习围棋-最佳围棋教程(2018) | gitconnected</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">23大围棋教程。课程由开发者提交并投票，使您能够找到最好的围棋课程…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">gitconnected.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ix mr"/></div></div></a></div></div></div>    
</body>
</html>