<html>
<head>
<title>WebSockets in Actix Web Full Tutorial — WebSockets &amp; Actors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Actix Web完整教程中的Web sockets—Web sockets &amp; Actors</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/websockets-in-actix-web-full-tutorial-websockets-actors-f7f9484f5086?source=collection_archive---------1-----------------------#2020-11-27">https://levelup.gitconnected.com/websockets-in-actix-web-full-tutorial-websockets-actors-f7f9484f5086?source=collection_archive---------1-----------------------#2020-11-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/86ecc663c1a97926cb8ec18ad5c2f2c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iml33VlJ5CbqobIoujj_0g.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Actix Web和WebSockets</figcaption></figure><p id="c43c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本教程将带你深入了解用Actix Web编写速度惊人的WebSocket客户端的每一个步骤，并有一个工作库作为参考。</p><p id="1769" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将建立一个简单的聊天室，向房间里的每个人发送信息，包括私人信息。我还会解释每一步，这样你就可以扩展这个例子，用Actix Web编写自己的WebSocket服务器。</p><p id="cf94" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">已完工项目回购:<code class="fe ld le lf lg b"><a class="ae lh" href="https://github.com/antholeole/actix-sockets" rel="noopener ugc nofollow" target="_blank">https://github.com/antholeole/actix-sockets</a></code></p><h1 id="8d74" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">先决条件:</strong></h1><ol class=""><li id="a264" class="mg mh it kh b ki mi km mj kq mk ku ml ky mm lc mn mo mp mq bi translated">大致了解什么是WebSockets</li><li id="38cb" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">知道一些基本的铁锈</li></ol><p id="20d3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">其他的都将在本教程中讨论。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="aacd" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><strong class="ak">熟悉Actix架构</strong></h1><p id="1838" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">在Actix架构中，有两个主要组件:参与者和消息。把每个演员想象成自己在内存中的对象，有一个邮箱。参与者可以读取他们的邮箱，并相应地回复他们的邮件，无论是通过向另一个参与者发送邮件、更改其状态，还是什么都不做。就是这样！这就是演员——阅读和回复邮件的简单小东西。</p><p id="fff4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">演员的速度如此之快，是因为他们完全独立于彼此工作。一个actor可以在它自己的线程上，或者在完全不同的机器上。只要演员能读它的邮件，它就能完美地工作。</p><p id="93d8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">需要注意的是，actor只存在于内存中，它的地址像<code class="fe ld le lf lg b">Addr&lt;Actor&gt;</code>一样传递。Actor本身可以改变它的属性(也许您有一个“messages_received”属性，并且您需要在每个消息上递增它)，但是您不能在其他任何地方这样做。相反，使用<code class="fe ld le lf lg b">Addr&lt;Actor&gt;</code>元素，您可以做<code class="fe ld le lf lg b">.send(some_message)</code>将消息放入演员的邮箱。</p><p id="cf2f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在Actix web中，每个套接字连接都是它自己的角色，而“大厅”(我们稍后会讲到)也是它自己的角色。</p><h1 id="a712" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">应用架构</strong></h1><p id="909d" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">应用架构简介:</p><p id="c786" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">每个插座位于一个“房间”中，每个房间位于一个单独的大厅结构中。就是这样！</p><p id="a879" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">预先警告:我们将一次写一个文件，而不是从一个地方跳到另一个地方，所以在很多情况下你的代码无法编译。放心吧！最后，如果你按照教程正确操作，一切都会像胶水一样粘在一起并完美运行。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="4d0b" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated"><strong class="ak">第一步:设置</strong></h1><p id="9aea" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">首先，运行<code class="fe ld le lf lg b">cargo init</code>或类似的东西。然后，转到您的<code class="fe ld le lf lg b">Cargo.toml</code>，确保您依赖这些软件包:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="9012" class="nt lj it lg b gy nu nv l nw nx">[dependencies]<br/>actix-web="3.2.0" # duh<br/>actix-web-actors="3" # actors specific to web<br/>actix = "0.10.0" # actors<br/>uuid = { version = "0.8", features = ["v4", "serde"] }</span></pre><p id="291a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可能想去<code class="fe ld le lf lg b">cargo run</code>hello world，去泡一杯咖啡；整理这些箱子需要一两分钟。</p><h1 id="d03e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">第二步:WebSocket Actor — ws.rs </strong></h1><p id="56bf" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">第一步是定义我们的WebSocket对象。创建一个名为<code class="fe ld le lf lg b">ws.rs</code>的文件。您需要在文件顶部添加以下导入和常量:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="9909" class="nt lj it lg b gy nu nv l nw nx">actix::{fut, ActorContext};<br/>use crate::messages::{Disconnect, Connect, WsMessage, ClientActorMessage}; //We'll be writing this later<br/>use crate::lobby::Lobby; // as well as this<br/>use actix::{Actor, Addr, Running, StreamHandler, WrapFuture, ActorFuture, ContextFutureSpawner};<br/>use actix::{AsyncContext, Handler};<br/>use actix_web_actors::ws;<br/>use actix_web_actors::ws::Message::Text;<br/>use std::time::{Duration, Instant};<br/>use uuid::Uuid;<br/><br/><br/>const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(5);<br/>const CLIENT_TIMEOUT: Duration = Duration::from_secs(10);</span></pre><p id="93c1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">用以下签名定义结构:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="f17b" class="nt lj it lg b gy nu nv l nw nx">struct WsConn {<br/>    room: Uuid,<br/>    lobby_addr: Addr&lt;Lobby&gt;,<br/>    hb: Instant,<br/>    id: Uuid,<br/>}</span></pre><p id="91b7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些字段如下所示:</p><ul class=""><li id="8a0b" class="mg mh it kh b ki kj km kn kq ny ku nz ky oa lc ob mo mp mq bi translated">room:每个套接字都存在于一个“room”中，在这个实现中，它只是一个简单的HashMap，将Uuid映射到套接字id列表。</li><li id="3c74" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">addr:这是套接字所在的大厅的地址。这将用于向大厅发送数据。因此，向大厅发送短信可能是这样的:<code class="fe ld le lf lg b">self.addr.do_send('hi!')</code>。没有这个属性，这个演员是不可能找到大堂的。</li><li id="d004" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">hb:虽然WebSockets在关闭时确实会发送消息，但有时WebSockets会在没有任何警告的情况下关闭。我们每隔N秒发送一次心跳，如果没有得到响应，我们就终止套接字，而不是让这个参与者永远存在。此属性是自我们收到最后一个心跳以来的时间。在许多库中，这是自动处理的。</li><li id="b5cb" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">id:这是我们分配给那个插座的ID。这对于私人信息传递非常有用，所以我们可以<code class="fe ld le lf lg b">/whisper &lt;id&gt; hello!</code>和客户耳语。</li></ul><p id="1088" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们将编写一个快速的<code class="fe ld le lf lg b">new</code>特征，这样我们可以更容易地启动套接字:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="7098" class="nt lj it lg b gy nu nv l nw nx">WsConn {<br/>    pub fn new(room: Uuid, lobby: Addr&lt;Lobby&gt;) -&gt; WsConn {<br/>        WsConn {<br/>            id: Uuid::new_v4(),<br/>            room,<br/>            hb: Instant::now(),<br/>            lobby_addr: lobby,<br/>        }<br/>    }<br/>}</span></pre><p id="82fd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这样，我们就不必设置心跳或分配id。</p><p id="a45d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">使WsConn结构成为一个参与者</strong></p><p id="ab3c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意<code class="fe ld le lf lg b">WsConn</code>只是一个普通的老铁锈结构。要将它转换成一个actor，我们需要在它上面实现Actor特征。</p><p id="4261" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是完整的代码，然后我们将对其进行剖析:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="d818" class="nt lj it lg b gy nu nv l nw nx">Actor for WsConn {<br/>    type Context = ws::WebsocketContext&lt;Self&gt;;<br/><br/>    fn started(&amp;mut self, ctx: &amp;mut Self::Context) {<br/>        self.hb(ctx);<br/><br/>        let addr = ctx.address();<br/>        self.lobby_addr<br/>            .send(Connect {<br/>                addr: addr.recipient(),<br/>                lobby_id: self.room,<br/>                self_id: self.id,<br/>            })<br/>            .into_actor(self)<br/>            .then(|res, _, ctx| {<br/>                match res {<br/>                    Ok(_res) =&gt; (),<br/>                    _ =&gt; ctx.stop(),<br/>                }<br/>                fut::ready(())<br/>            })<br/>            .wait(ctx);<br/>    }<br/><br/>    fn stopping(&amp;mut self, _: &amp;mut Self::Context) -&gt; Running {<br/>        self.lobby_addr.do_send(Disconnect { id: self.id, room_id: self.room });<br/>        Running::Stop<br/>    }<br/>}</span></pre><p id="02d0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，你会看到我们在定义(<code class="fe ld le lf lg b">type Context = ws::WebsocketContext&lt;Self&gt;;</code>)中定义了一个名为<code class="fe ld le lf lg b">Context</code>的类型。这是演员要求的。那就是这个演员生活的<code class="fe ld le lf lg b">context</code>；这里，我们说上下文是WebSocket上下文，应该允许它做WebSocket的事情，比如开始监听端口。每个参与者都需要一个上下文，但是只有WebSocket参与者需要WebSocket上下文。</p><p id="7408" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还编写了<code class="fe ld le lf lg b">started</code>和<code class="fe ld le lf lg b">stopping</code>方法——这将分别创建和销毁Actor。</p><p id="8090" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<code class="fe ld le lf lg b">started</code>中，我们开始心跳循环；它只是一个间隔触发的函数，所以在我们开始循环后，我们不必担心它——如果心跳没有回音，它会自动关闭套接字。我们一会儿再写。</p><p id="8e53" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还获取大厅的地址并向其发送消息(<code class="fe ld le lf lg b">Connect {}</code>)说“嘿！我联系上了。这是我想进入的大厅，还有我的身份证，还有我的邮箱地址，你可以通过它联系到我。”这条消息由一个游说团处理，我们稍后会写进去。</p><p id="02ff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们异步发送消息<strong class="kh iu"/>。如果我们做了<code class="fe ld le lf lg b">do_send</code>而不是<code class="fe ld le lf lg b">send</code>，我们将会同步发送<em class="oc">和</em>。我的意思是“把信息扔进邮箱，然后开车离开。”<code class="fe ld le lf lg b">do_send</code>不关心消息是否被发送或阅读。<code class="fe ld le lf lg b">send</code>需要等待，这就是本块的目的:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="e28b" class="nt lj it lg b gy nu nv l nw nx">.then(|res, _, ctx| {<br/>     match res {<br/>        Ok(_res) =&gt; (),<br/>        _ =&gt; ctx.stop(),<br/>    }<br/>    fut::ready(())<br/>})</span></pre><p id="61ca" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果有任何失败，我们只需用<code class="fe ld le lf lg b">ctx.stop</code>停止整个演员。这种情况可能不会发生，但如果你的<code class="fe ld le lf lg b">Lobby</code>演员出了问题，这种情况可能会发生。客户端将会看到类似于<code class="fe ld le lf lg b">ws handshake couldn't be completed.</code>的东西</p><p id="d152" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">停下来容易多了。你可以看到<code class="fe ld le lf lg b">do_send</code>在这里的作用:我们试图发送一个断开消息到大厅，但如果我们不能，没什么大不了的。阻止这个演员。</p><p id="2f96" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！我们的<code class="fe ld le lf lg b">WsConn</code>现在是演员。</p><p id="9ef0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">心跳</strong></p><p id="dca4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是我们之前讨论的心跳方法:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="37d3" class="nt lj it lg b gy nu nv l nw nx">WsConn {<br/>    fn hb(&amp;self, ctx: &amp;mut ws::WebsocketContext&lt;Self&gt;) {<br/>        ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {<br/>            if Instant::now().duration_since(act.hb) &gt; CLIENT_TIMEOUT {<br/>                println!("Disconnecting failed heartbeat");<br/>                act.lobby_addr.do_send(Disconnect { id: act.id, room_id: act.room });<br/>                ctx.stop();<br/>                return;<br/>            }<br/><br/>            ctx.ping(b"PING");<br/>        });<br/>    }<br/>}</span></pre><p id="cbcb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们在这里所做的就是ping客户端，并间隔一段时间等待响应。如果响应不来，套接字就死了；发送断开连接并停止客户端。</p><p id="d56f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">处理WS消息</strong></p><p id="8325" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下一个方法有点长，但并不复杂:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="61d8" class="nt lj it lg b gy nu nv l nw nx">StreamHandler&lt;Result&lt;ws::Message, ws::ProtocolError&gt;&gt; for WsConn {<br/>    fn handle(&amp;mut self, msg: Result&lt;ws::Message, ws::ProtocolError&gt;, ctx: &amp;mut Self::Context) {<br/>        match msg {<br/>            Ok(ws::Message::Ping(msg)) =&gt; {<br/>                self.hb = Instant::now();<br/>                ctx.pong(&amp;msg);<br/>            }<br/>            Ok(ws::Message::Pong(_)) =&gt; {<br/>                self.hb = Instant::now();<br/>            }<br/>            Ok(ws::Message::Binary(bin)) =&gt; ctx.binary(bin),<br/>            Ok(ws::Message::Close(reason)) =&gt; {<br/>                ctx.close(reason);<br/>                ctx.stop();<br/>            }<br/>            Ok(ws::Message::Continuation(_)) =&gt; {<br/>                ctx.stop();<br/>            }<br/>            Ok(ws::Message::Nop) =&gt; (),<br/>            Ok(Text(s)) =&gt; self.lobby_addr.do_send(ClientActorMessage {<br/>                id: self.id,<br/>                msg: s,<br/>                room_id: self.room<br/>            }),<br/>            Err(e) =&gt; panic!(e),<br/>        }<br/>    }<br/>}</span></pre><p id="09c4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对所有可能的WebSocket消息进行简单的模式匹配。</p><ul class=""><li id="a741" class="mg mh it kh b ki kj km kn kq ny ku nz ky oa lc ob mo mp mq bi translated">ping以pong回应——那是客户端在敲打我们。用乒乓回应。作为副产品，由于客户端可以检测我们的心跳，我们知道它是活的，所以我们可以重置我们的心跳时钟。</li><li id="a098" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">pong是对我们发送的ping的响应。重置我们的时钟，他们还活着。</li><li id="4283" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">如果消息是二进制的，我们将把它发送给WebSocket上下文，它将决定如何处理它。这实际上不应该被触发。</li><li id="7f2e" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">如果是关闭消息，就关闭。</li><li id="2313" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">对于本教程，我们不打算响应连续帧(简而言之，这些是无法放入一条消息的WebSocket消息)</li><li id="358c" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">在nop上让我们nop(无操作)</li><li id="0698" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">发短信，(这一条我们做的最多！)送到大厅。游说团将负责把它安排到需要去的地方。</li><li id="1498" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc ob mo mp mq bi translated">一出错，我们就慌了。您可能希望合理地实现这里要做的事情。</li></ul><p id="f570" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">回复短信</strong></p><p id="761e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是我们第一次处理邮箱信息。当一个<code class="fe ld le lf lg b">WsMessage</code>被放入我们的邮箱时，这个方法被调用。</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="7fc8" class="nt lj it lg b gy nu nv l nw nx">Handler&lt;WsMessage&gt; for WsConn {<br/>    type Result = ();<br/><br/>    fn handle(&amp;mut self, msg: WsMessage, ctx: &amp;mut Self::Context) {<br/>        ctx.text(msg.0);<br/>    }<br/>}</span></pre><p id="e396" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这里，如果服务器将一封<code class="fe ld le lf lg b">WsMessage</code>(我们需要定义)邮件放入我们的邮箱，我们所做的就是将它直接发送给客户端。这就是从邮箱中“阅读邮件”的样子；<code class="fe ld le lf lg b">impl Handler&lt;MailType&gt; for ACTOR</code>。请注意，我们还需要定义对该邮件的回复可能是什么样子。如果邮件像<code class="fe ld le lf lg b">do_send</code>一样放置，回复类型并不重要。如果像<code class="fe ld le lf lg b">send()</code>一样放置，那么等待的结果类型将是<code class="fe ld le lf lg b">Result</code>的类型。也许你做<code class="fe ld le lf lg b">type Result = String</code>，或者类似的。不管你把什么类型的<code class="fe ld le lf lg b">T</code>放到那里，<code class="fe ld le lf lg b">handle</code>都需要返回<code class="fe ld le lf lg b">T</code>。</p><p id="8a55" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此外，处理程序消息的签名包括:</p><ol class=""><li id="a567" class="mg mh it kh b ki kj km kn kq ny ku nz ky oa lc mn mo mp mq bi translated">信息本身。您可以完全控制该邮件传递多少数据。</li><li id="b69d" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">自我语境。这是你自己的语境，是自我的一个“邮箱”。你可以从ctx中读取memeber变量，也可以在这里将消息放入你自己的邮箱。</li></ol><p id="1fe7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！那就是整个<code class="fe ld le lf lg b">WsClient</code>。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="e02a" class="li lj it bd lk ll nd ln lo lp ne lr ls lt nf lv lw lx ng lz ma mb nh md me mf bi translated">第三步:为邮箱定义邮件</h1><p id="af9d" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">创建一个名为<code class="fe ld le lf lg b">messages.rs</code>的新文件。这个文件将保存所有放入演员邮箱的“消息”。</p><p id="9f28" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">消息是具有两个特征的结构:第一个很简单，仅仅是<code class="fe ld le lf lg b">#[derive(Message)]</code>告诉我们它是一个参与者消息。第二个是<code class="fe ld le lf lg b">rtype</code>。该返回类型必须与我们在上一节末尾讨论的<code class="fe ld le lf lg b">T</code>类型相同——在消息被处理后返回的类型。因此，如果我们想定义一个返回字符串的消息，它应该是这样的:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="4270" class="nt lj it lg b gy nu nv l nw nx">#[derive(Message)]<br/>#[rtype(result = "String")] // result = your type T<br/>pub struct MyMessage; // they usually carry info, but not for this example<br/><br/>impl Handler&lt;MyMessage&gt; for MyActor {<br/>    type Result = String; // This type is T<br/><br/>    fn handle(&amp;mut self, msg: MyMessage, ctx: &amp;mut Self::Context) -&gt; String { // Returns your type T<br/>        ...<br/>    }<br/>}</span></pre><p id="b582" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！定义消息实际上很简单。下面是消息文件的代码，带有相应的注释:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="5897" class="nt lj it lg b gy nu nv l nw nx">actix::prelude::{Message, Recipient};<br/>use uuid::Uuid;<br/><br/>//WsConn responds to this to pipe it through to the actual client<br/>#[derive(Message)]<br/>#[rtype(result = "()")]<br/>pub struct WsMessage(pub String);<br/><br/>//WsConn sends this to the lobby to say "put me in please"<br/>#[derive(Message)]<br/>#[rtype(result = "()")]<br/>pub struct Connect {<br/>    pub addr: Recipient&lt;WsMessage&gt;,<br/>    pub lobby_id: Uuid,<br/>    pub self_id: Uuid,<br/>}<br/><br/>//WsConn sends this to a lobby to say "take me out please"<br/>#[derive(Message)]<br/>#[rtype(result = "()")]<br/>pub struct Disconnect {<br/>    pub room_id: Uuid,<br/>    pub id: Uuid,<br/>}<br/><br/>//client sends this to the lobby for the lobby to echo out.<br/>#[derive(Message)]<br/>#[rtype(result = "()")]<br/>pub struct ClientActorMessage {<br/>    pub id: Uuid,<br/>    pub msg: String,<br/>    pub room_id: Uuid<br/>}</span></pre><p id="a665" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为演员定义消息非常简单。关于actor框架，我最喜欢的部分之一是，如果您需要从一个Actor获取数据到另一个Actor，那么创建消息或向现有消息添加数据是非常容易的。</p><h1 id="fbcd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第四步:定义大厅</h1><p id="dfd9" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">第一，进口为<code class="fe ld le lf lg b">lobby.rs</code>:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="64c4" class="nt lj it lg b gy nu nv l nw nx">crate::messages::{ClientActorMessage, Connect, Disconnect, WsMessage};<br/>use actix::prelude::{Actor, Context, Handler, Recipient};<br/>use std::collections::{HashMap, HashSet};<br/>use uuid::Uuid;</span></pre><p id="abee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们快完成了！现在，我们有实际的游说写。正如我们所说，游说是一个演员，但演员是一个普通的老结构。下面是该结构(将放在<code class="fe ld le lf lg b">lobby.rs</code>中):</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="10b5" class="nt lj it lg b gy nu nv l nw nx">Socket = Recipient&lt;WsMessage&gt;;<br/><br/>pub struct Lobby {<br/>    sessions: HashMap&lt;Uuid, Socket&gt;,          //self id to self<br/>    rooms: HashMap&lt;Uuid, HashSet&lt;Uuid&gt;&gt;,      //room id  to list of users id<br/>}</span></pre><p id="b2af" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将套接字存储为一个简单的WsMessage接收方。通过这种设置，我们可以轻松地浏览全部、部分或找到特定的客户端。</p><p id="08b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为助手，我们将为大厅实现一个默认设置:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="d39e" class="nt lj it lg b gy nu nv l nw nx">Default for Lobby {<br/>    fn default() -&gt; Lobby {<br/>        Lobby {<br/>            sessions: HashMap::new(),<br/>            rooms: HashMap::new(),<br/>        }<br/>    }<br/>}</span></pre><p id="49c8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，让我们编写一个向客户端发送消息的助手。</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="6876" class="nt lj it lg b gy nu nv l nw nx">Lobby {<br/>    fn send_message(&amp;self, message: &amp;str, id_to: &amp;Uuid) {<br/>        if let Some(socket_recipient) = self.sessions.get(id_to) {<br/>            let _ = socket_recipient<br/>                .do_send(WsMessage(message.to_owned()));<br/>        } else {<br/>            println!("attempting to send message but couldn't find user id.");<br/>        }<br/>    }<br/>}</span></pre><p id="03a9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">该方法接受一个字符串和一个id，并将该字符串发送给具有该Id的客户端(如果它存在；如果没有，它只是打印一些东西来安慰。您可能希望通过返回一个结果或类似的结果来相应地处理这个问题。)</p><p id="8c38" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">让大厅成为演员</strong></p><p id="e053" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">准备好学习整个教程中最短的部分了吗？要使大厅成为演员，请使用以下代码:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="6022" class="nt lj it lg b gy nu nv l nw nx">Actor for Lobby {<br/>    type Context = Context&lt;Self&gt;;<br/>}</span></pre><p id="1ae3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！我们不关心大厅的任何生命周期。我们只有一个，我们只在应用程序启动时挂载它，在应用程序关闭时移除它。房间只是散列表，所以在这个简单的例子中，我们不需要让它们成为参与者。</p><p id="fe5a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">处理消息</strong></p><p id="fbc2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">大厅将从客户端获得3种类型的消息:连接、断开和WsMessage。两者都来自actor特征的WsConn生命周期方法。这一部分不是actix特有的，但是我将解释代码的主要部分。</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="2141" class="nt lj it lg b gy nu nv l nw nx">/// Handler for Disconnect message.<br/>impl Handler&lt;Disconnect&gt; for Lobby {<br/>    type Result = ();<br/><br/>    fn handle(&amp;mut self, msg: Disconnect, _: &amp;mut Context&lt;Self&gt;) {<br/>        if self.sessions.remove(&amp;msg.id).is_some() {<br/>            self.rooms<br/>                .get(&amp;msg.room_id)<br/>                .unwrap()<br/>                .iter()<br/>                .filter(|conn_id| *conn_id.to_owned() != msg.id)<br/>                .for_each(|user_id| self.send_message(&amp;format!("{} disconnected.", &amp;msg.id), user_id));<br/>            if let Some(lobby) = self.rooms.get_mut(&amp;msg.room_id) {<br/>                if lobby.len() &gt; 1 {<br/>                    lobby.remove(&amp;msg.id);<br/>                } else {<br/>                    //only one in the lobby, remove it entirely<br/>                    self.rooms.remove(&amp;msg.room_id);<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="9c15" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们所做的只是通过以下任一方式来响应断开消息:</p><ol class=""><li id="5593" class="mg mh it kh b ki kj km kn kq ny ku nz ky oa lc mn mo mp mq bi translated">从房间中移除单个客户端。“UUID把其他人都断开了！</li><li id="fab5" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">如果该客户是房间中的最后一个，则完全移除房间(这样我们就不会阻塞散列表)</li></ol><p id="9d74" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们需要响应连接消息。同样，几乎没有特定于参与者的逻辑:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="2760" class="nt lj it lg b gy nu nv l nw nx">Handler&lt;Connect&gt; for Lobby {<br/>    type Result = ();<br/><br/>    fn handle(&amp;mut self, msg: Connect, _: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {<br/>        // create a room if necessary, and then add the id to it<br/>        self.rooms<br/>            .entry(msg.lobby_id)<br/>            .or_insert_with(HashSet::new).insert(msg.self_id);<br/><br/>        // send to everyone in the room that new uuid just joined<br/>        self<br/>            .rooms<br/>            .get(&amp;msg.lobby_id)<br/>            .unwrap()<br/>            .iter()<br/>            .filter(|conn_id| *conn_id.to_owned() != msg.self_id)<br/>            .for_each(|conn_id| self.send_message(&amp;format!("{} just joined!", msg.self_id), conn_id));<br/><br/>        // store the address<br/>        self.sessions.insert(<br/>            msg.self_id,<br/>            msg.addr,<br/>        );<br/><br/>        // send self your new uuid<br/>        self.send_message(&amp;format!("your id is {}", msg.self_id), &amp;msg.self_id);<br/>    }<br/>}</span></pre><p id="2b2b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里所做的只是添加一个套接字并向它们发送消息。</p><p id="34f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们打开邮箱让客户给大堂发消息，让大堂转发给客户。</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="c123" class="nt lj it lg b gy nu nv l nw nx">Handler&lt;ClientActorMessage&gt; for Lobby {<br/>    type Result = ();<br/><br/>    fn handle(&amp;mut self, msg: ClientActorMessage, _: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {<br/>        if msg.msg.starts_with("\\w") {<br/>            if let Some(id_to) = msg.msg.split(' ').collect::&lt;Vec&lt;&amp;str&gt;&gt;().get(1) {<br/>                self.send_message(&amp;msg.msg, &amp;Uuid::parse_str(id_to).unwrap());<br/>            }<br/>        } else {<br/>            <br/>self.rooms.get(&amp;msg.room_id).unwrap().iter().for_each(|client| self.send_message(&amp;msg.msg, client));<br/>        }<br/>    }<br/>}</span></pre><p id="9ad1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将检查消息是否以\w开头。如果是，我们知道这是一个密语，并将它发送到一个特定的客户端。如果不是，我们会将它发送给房间中的所有用户。(这是<strong class="kh iu">而不是</strong>生产就绪！如果在w后面有一个无效的UUID，它将会死机，如果它后面没有任何东西，它将会自动失败。)</p><p id="9eeb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那是大厅！</p><h1 id="3e99" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">最后一步:设置路线/运行服务器</h1><p id="4ce1" class="pw-post-body-paragraph kf kg it kh b ki mi kk kl km mj ko kp kq ni ks kt ku nj kw kx ky nk la lb lc im bi translated">首先，我们必须打开一条让我们连接到服务器的路由。创建一个名为“start_connection.rs”的文件，并放入以下路径:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="7067" class="nt lj it lg b gy nu nv l nw nx">crate::ws::WsConn;<br/>use crate::lobby::Lobby;<br/>use actix::Addr;<br/>use actix_web::{get, web::Data, web::Path, web::Payload, Error, HttpResponse, HttpRequest};<br/>use actix_web_actors::ws;<br/>use uuid::Uuid;<br/><br/><br/>#[get("/{group_id}")]<br/>pub async fn start_connection(<br/>    req: HttpRequest,<br/>    stream: Payload,<br/>    Path(group_id): Path&lt;Uuid&gt;,<br/>    srv: Data&lt;Addr&lt;Lobby&gt;&gt;,<br/>) -&gt; Result&lt;HttpResponse, Error&gt; {<br/>    let ws = WsConn::new(<br/>        group_id,<br/>        srv.get_ref().clone(),<br/>    );<br/><br/>    let resp = ws::start(ws, &amp;req, stream)?;<br/>    Ok(resp)<br/>}</span></pre><p id="5082" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将一个只有组id(应该是有效的uuid)的路由定义为路径参数。然后，我们创建一个引用大厅的新WsConn(在下一步中，我们向actix web注册大厅)。最后，我们将请求升级为WebSocket请求，然后砰！我们现在有了一个开放的持久连接。</p><p id="b6b3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的最后一步是将大厅注册为共享数据，这样我们就可以像刚才那样获取它(<code class="fe ld le lf lg b">srv: Data&lt;Addr&lt;Lobby&gt;&gt;</code>)。您的main.rs应该如下所示:</p><pre class="nl nm nn no gt np lg nq nr aw ns bi"><span id="9629" class="nt lj it lg b gy nu nv l nw nx">ws;<br/>mod lobby;<br/>use lobby::Lobby;<br/>mod messages;<br/>mod start_connection;<br/>use start_connection::start_connection as start_connection_route;<br/>use actix::Actor;<br/><br/>use actix_web::{App, HttpServer};<br/><br/>#[actix_web::main]<br/>async fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    let chat_server = Lobby::default().start(); //create and spin up a lobby<br/><br/>    HttpServer::new(move || {<br/>        App::new()<br/>            .service(start_connection_route) //. rename with "as" import or naming conflict<br/>            .data(chat_server.clone()) //register the lobby<br/>    })<br/>    .bind("127.0.0.1:8080")?<br/>    .run()<br/>    .await<br/>}</span></pre><p id="c59b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后嘣！我们的整个应用程序现在共享一个大厅。这是我们写的所有东西:</p><ol class=""><li id="3948" class="mg mh it kh b ki kj km kn kq ny ku nz ky oa lc mn mo mp mq bi translated">游说聊天</li><li id="d76b" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">发送私人消息</li><li id="90d1" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">发送广播消息</li><li id="f0d5" class="mg mh it kh b ki mr km ms kq mt ku mu ky mv lc mn mo mp mq bi translated">易于扩展！</li></ol><p id="26d3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">全部在actix web中，使用actors！为了测试客户端，我会使用一个简单的websocket来测试chrome或者T2的firefox。打开多个选项卡，在不同的大厅发送耳语或广播！</p><p id="235f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">快乐的网络社交！</p></div></div>    
</body>
</html>