<html>
<head>
<title>Currying in Javascript and its practical usage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的Currying及其实际应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/currying-in-javascript-and-its-practical-usage-6cabbe1c53f?source=collection_archive---------19-----------------------#2020-04-04">https://levelup.gitconnected.com/currying-in-javascript-and-its-practical-usage-6cabbe1c53f?source=collection_archive---------19-----------------------#2020-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/512f58079b42dca0c384b0055cea6ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_GnqvMjTOHq-xbB7"/></div></div></figure><p id="2ce2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">奉承有时很难理解或混淆实际用法。在本文中，我将解释它是什么以及一些用例。</p><h1 id="21a6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是currying？</h1><p id="d617" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Currying是将接受多个参数的函数转换成一系列函数的过程，每个函数一次接受一个参数。是<a class="ae lz" href="https://en.wikipedia.org/wiki/Partial_application" rel="noopener ugc nofollow" target="_blank">部分功能应用</a>的特殊类型。在纯函数式编程语言(如ML或Haskell)中，函数在默认情况下是以curried形式定义的。让我们看看它在Javascript中是如何工作。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="57e3" class="mj kx iq mf b gy mk ml l mm mn"><br/>// A normal JS function<br/>const sum = (a, b) =&gt; a + b<br/>sum(1, 2) // 3</span><span id="d8ee" class="mj kx iq mf b gy mo ml l mm mn">// Curried version of the sum function above<br/>const curriedSum = a =&gt; b =&gt; a + b<br/>curriedSum(1)(2) // 3</span></pre><p id="c0b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的<code class="fe mp mq mr mf b">curriedSum</code>函数返回一个函数而不是最终结果。返回的函数在其闭包范围内包含<code class="fe mp mq mr mf b">a</code>，接受列表中的另一个参数(<code class="fe mp mq mr mf b">b</code>，然后计算最终结果。听起来不错？现在，如果有更多的参数会怎么样呢？</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a643" class="mj kx iq mf b gy mk ml l mm mn">// Normal sum function with 3 parameters<br/>const sum = (a, b, c) =&gt; a + b + c<br/>sum(1, 2, 3)  // 6</span><span id="da5f" class="mj kx iq mf b gy mo ml l mm mn">const curriedSum = a =&gt; b =&gt; c =&gt; a + b + c<br/>curriedSum(1)(2)(3)  // 6</span></pre><p id="0e32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数需要多少参数并不重要。如果一个函数有<code class="fe mp mq mr mf b">n</code>个参数，它的简化版本将是一串<code class="fe mp mq mr mf b">n</code>函数。只有最后一个函数会返回期望的结果。其他函数返回链中的下一个函数。注意，每个函数应该只有一个参数，称为<code class="fe mp mq mr mf b">Unary function</code>。我们将在另一节更深入地讨论一元函数。</p><h1 id="7820" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么是咖喱？</h1><p id="79b9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Currying是部分功能应用的一种类型。我们可以使用它返回的函数来创建一个现有函数的简化版本。当我们有很多地方以完全相同的方式使用一个函数时，这是很有帮助的。我们的实现将会更短，可读性更强。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1e5d" class="mj kx iq mf b gy mk ml l mm mn">// Normal usage<br/>const PERCENT_120 = 1.2<br/>const multiply = (a, b) =&gt; a * b</span><span id="a52d" class="mj kx iq mf b gy mo ml l mm mn">const newSalary = multiply(salary, PERCENT_120)</span><span id="1397" class="mj kx iq mf b gy mo ml l mm mn">// Currying usage<br/>const multiply = a =&gt; b =&gt; a * b<br/>const increase20Percent = multiply(1.2)</span><span id="eb10" class="mj kx iq mf b gy mo ml l mm mn">const newSalary = increase20Percent(salary)</span></pre><p id="1922" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">听起来很酷。但这不是主要的好处。正如我在上一节提到的，currying需要严格使用<code class="fe mp mq mr mf b">unary function</code>。它为标准接口打下了良好的基础。当我们有一组实现公共接口的函数时，我们可以很容易地在它们上面引入灵活的用法。这非常类似于<code class="fe mp mq mr mf b">Promise</code>如何定义其标准并变得超级强大。</p><p id="45e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是约定函数的标准:</p><ul class=""><li id="4139" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">它有一个参数</li><li id="f13d" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">它返回一个<code class="fe mp mq mr mf b">unary function</code>，它也有一个参数</li></ul><p id="da68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章的范围内，我将讨论两种主要的用法:自由风格和功能组合。</p><h1 id="0722" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">无点样式</h1><p id="a121" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">单点自由风格，也称为<a class="ae lz" href="https://en.wikipedia.org/wiki/Tacit_programming" rel="noopener ugc nofollow" target="_blank">隐性编程</a>，是一种调用者不将参数显式传递给函数的编码风格。请看下面的两个例子。第二个解释了自由风格，其中<code class="fe mp mq mr mf b">console.log</code>符合<code class="fe mp mq mr mf b">catch</code>要求的标准。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6896" class="mj kx iq mf b gy mk ml l mm mn">// Normal implementation<br/>try {<br/>  ...<br/>} catch (err =&gt; console.log(err))</span><span id="8806" class="mj kx iq mf b gy mo ml l mm mn">// Point free style<br/>try {<br/>  ...<br/>} catch (console.log)</span></pre><p id="d2a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对无点风格的唯一要求是输入函数的原型与参数的规格相匹配。这种风格可以缩短代码，使其可读性更好。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="08db" class="mj kx iq mf b gy mk ml l mm mn">// Normal implementation<br/>fetchUser(id).then(user =&gt; {<br/>  return verifyAdminUser(user)<br/>}).then(isAdmin =&gt; {<br/>  return render(isAdmin)<br/>})</span><span id="e43e" class="mj kx iq mf b gy mo ml l mm mn">// Point free style<br/>fetchUser(id).then(verifyAdminUser).then(render)</span></pre><p id="059b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，现在让我们看看如何在下面的例子中用curried函数实现这种风格。这个示例中的<code class="fe mp mq mr mf b">compose</code>函数非常流行，出现在许多库中，一个流行的函数是<a class="ae lz" href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener ugc nofollow" target="_blank"> lodash </a>。我把它的实现放在这里，以防您想自己运行代码。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="071f" class="mj kx iq mf b gy mk ml l mm mn">const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)));</span><span id="8c09" class="mj kx iq mf b gy mo ml l mm mn">const sum = a =&gt; b =&gt; a + b<br/>const multiply = a =&gt; b =&gt; a * b</span><span id="7948" class="mj kx iq mf b gy mo ml l mm mn">const addTransactionFee = sum(2)<br/>const addTax = multiply(1.1)<br/>const addMonthlyPromotion = multiply(0.8)</span><span id="a433" class="mj kx iq mf b gy mo ml l mm mn">// Result of compose function below equals to<br/>// addTransactionFee(addTax(addMonthlyPromotion(100)))<br/>const paymentAmount = compose(addTransactionFee, addTax, addMonthlyPromotion)(100)  // 100 * 0.8 * 1.1 + 2 = 90</span></pre><h1 id="280f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">功能组成</h1><p id="593a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae lz" href="https://en.wikipedia.org/wiki/Function_composition_(computer_science)" rel="noopener ugc nofollow" target="_blank">功能组合</a>是一种将简单功能组合起来构建更复杂功能的机制。在组合链中，每个函数的结果都是下一个函数的参数。最后一个函数的结果将是最终结果。在我之前的示例中，我将3个函数<code class="fe mp mq mr mf b">addTransactionFee</code>、<code class="fe mp mq mr mf b">addTax</code>和<code class="fe mp mq mr mf b">addMonthlyPromotion</code>组合成一个。</p><p id="89cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Javascript中，函数只返回一个值。因为这个值将是下一个调用的参数，所以一个函数必须是一元的才是可组合的。一个课程化的函数完全适合写作。如果你想构造一个有不止一个参数的函数，最好的方法是curry。</p><p id="4a9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们回到之前的例子。现在我想在每一步之间添加一个日志函数来调试我的代码。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d1a5" class="mj kx iq mf b gy mk ml l mm mn">const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)));</span><span id="f899" class="mj kx iq mf b gy mo ml l mm mn">const sum = a =&gt; b =&gt; a + b<br/>const multiply = a =&gt; b =&gt; a * b</span><span id="4897" class="mj kx iq mf b gy mo ml l mm mn">const addTransactionFee = sum(2)<br/>const addTax = multiply(1.1)<br/>const addMonthlyPromotion = multiply(0.8)<br/>const log = a =&gt; {<br/>  console.log(a)<br/>  return a<br/>}</span><span id="37eb" class="mj kx iq mf b gy mo ml l mm mn">const paymentAmount = compose(<br/>  log,<br/>  addTransactionFee, <br/>  log,<br/>  addTax,<br/>  log,<br/>  addMonthlyPromotion<br/>)(100)<br/>// Output:<br/>// 80<br/>// 88<br/>// 90</span></pre><p id="2d04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的示例中，我添加了一个新函数<code class="fe mp mq mr mf b">log</code>。这个函数只是在返回输入参数之前添加了一个日志。注意，我不能直接编写<code class="fe mp mq mr mf b">console.log</code>，因为这个函数不返回任何东西。现在一切似乎都好了。但是，如果我想为每个步骤记录一个自定义标签，会发生什么呢？log函数将接收另一个参数:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7031" class="mj kx iq mf b gy mk ml l mm mn">const log = (label, value) =&gt; {<br/>  console.log(label, value)<br/>  return value<br/>}</span></pre><p id="fba1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数不再是可组合的，因为它有两个参数。该是奉承的时候了。以下是完整的代码:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="e9d5" class="mj kx iq mf b gy mk ml l mm mn">const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)));</span><span id="e30a" class="mj kx iq mf b gy mo ml l mm mn">const sum = a =&gt; b =&gt; a + b<br/>const multiply = a =&gt; b =&gt; a * b</span><span id="74d3" class="mj kx iq mf b gy mo ml l mm mn">const addTransactionFee = sum(2)<br/>const addTax = multiply(1.1)<br/>const addMonthlyPromotion = multiply(0.8)<br/>const log = label =&gt; value =&gt; {<br/>  console.log(label, value)<br/>  return value<br/>}</span><span id="dcfa" class="mj kx iq mf b gy mo ml l mm mn">const paymentAmount = compose(<br/>  log('addTransactionFee'),<br/>  addTransactionFee, <br/>  log('addTax'),<br/>  addTax,<br/>  log('addMonthlyPromotion'),<br/>  addMonthlyPromotion<br/>)(100)<br/>// Output:<br/>// addMonthlyPromotion 80<br/>// addTax 88<br/>// addTransactionFee 90</span></pre><h1 id="2217" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="091c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在这篇文章中，我介绍了currying的定义和它的一些实际用法。在我看来，最有用的是函数构成。感觉好吗？如果你想更深入地了解，我推荐埃里克·艾略特的书<code class="fe mp mq mr mf b">Composing Software</code>。他从数学和函数式编程的角度对currying做了很好的解释。</p><p id="e60a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍后，我可能会带着另一篇关于奉承技巧的文章回来。下次见。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="a619" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nn">原发布于</em><a class="ae lz" href="https://huynvk.dev/blog/currying-in-javascript-and-its-practical-usage" rel="noopener ugc nofollow" target="_blank"><em class="nn">https://huynvk . dev</em></a><em class="nn">。</em></p></div></div>    
</body>
</html>