<html>
<head>
<title>Securing Blockchain with Proof of Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用工作证明保护区块链</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/securing-blockchain-with-proof-of-work-be162f0bec67?source=collection_archive---------0-----------------------#2019-01-11">https://levelup.gitconnected.com/securing-blockchain-with-proof-of-work-be162f0bec67?source=collection_archive---------0-----------------------#2019-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6273872a28f14340af5c5af9f8210d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9-DXBU_BovprTNMzLz8Vw.png"/></div></div></figure><p id="0278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Eric Traub是纽约的一名软件工程师，他有着丰富的教师和教授各种不同科目的经验。</p><h1 id="d59c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是工作证明？</h1><p id="3fe6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对于区块链技术来说,<code class="fe ma mb mc md b">proofOfWork</code>方法非常重要且必不可少，因为它让比特币和许多其他区块链变得安全。</p><p id="48a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，你一定很好奇<strong class="ka ir">工作证明</strong> ( <strong class="ka ir"> PoW </strong>)到底是什么。看看任何一个区块链——每个区块链基本上都是一系列街区。必须创建每个单独的块并将其添加到链中。然而，我们不仅仅希望创建任何块并将其添加到链中。我们希望确保添加到链中的每个数据块都是合法的，具有正确的事务，并且其中包含正确的数据。这是因为如果它没有正确的交易或正确的数据，那么人们可以伪造他们有多少比特币，并从本质上导致欺诈和窃取他人的钱。每当创建一个新块时，我们首先必须通过PoW挖掘它来确保它是一个合法的块。</p><p id="2fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<code class="fe ma mb mc md b">proofOfWork</code>方法将接受<code class="fe ma mb mc md b">currentBlockData</code>和<code class="fe ma mb mc md b">previousBlockHash</code>。从这些数据中，<code class="fe ma mb mc md b">proofOfWork</code>方法将尝试生成一个特定的散列。在我们的例子中，这个特定的散列将是一个以四个零开始的散列。因此，有了给定的<code class="fe ma mb mc md b">currentBlockData</code>和<code class="fe ma mb mc md b">previousBlockHash</code>，该方法将以某种方式生成一个以四个零开始的结果散列。</p><p id="8963" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们试着理解我们如何做到这一点。假设散列是随机的。因此，如果产生的散列实际上是随机的，那么我们如何从当前块生成一个以四个零开始的散列呢？做到这一点的唯一方法是通过反复试验，或者通过猜测和检查。所以，我们要做的是多次运行我们的<code class="fe ma mb mc md b">hashBlock</code>方法，直到我们幸运地生成一个开头有四个零的散列。</p><p id="d3cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能想知道我们的<code class="fe ma mb mc md b">hashBlock</code>方法的输入是什么——它们是<code class="fe ma mb mc md b">previousBlockHash</code>、<code class="fe ma mb mc md b">currentBlockData</code>和<code class="fe ma mb mc md b">nonce</code>参数。当我们总是传递完全相同的数据时，这三个已经传入一次并可能生成多个不同散列的参数将会如何？</p><p id="5f5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们如何在不改变我们的<code class="fe ma mb mc md b">currentBlockData</code>或<code class="fe ma mb mc md b">previousBlockHash</code>的情况下改变这个数据，但是我们仍然得到一个开头有四个零的结果散列？这个问题的答案是，我们将不断改变<code class="fe ma mb mc md b">nonce</code>值。这可能现在看起来有点混乱，所以让我们通过了解<code class="fe ma mb mc md b">proofOfWork</code>中实际发生的事情来澄清一下。</p><p id="a65c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<code class="fe ma mb mc md b">proofOfWork</code>中发生的是，我们将重复散列我们的块，直到我们找到正确的散列，它将是以四个零开始的任何散列。我们将通过不断增加<code class="fe ma mb mc md b">nonce</code>值来改变<code class="fe ma mb mc md b">hashBlock</code>方法的输入。我们第一次运行我们的<code class="fe ma mb mc md b">hashBlock</code>方法时；我们将从nonce值0开始。</p><p id="5e83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，如果结果散列的开头没有四个零，我们将再次运行我们的<code class="fe ma mb mc md b">hashBlock</code>方法，只是这次我们将把我们的<code class="fe ma mb mc md b">nonce</code>值增加1。如果我们没有再次获得正确的哈希值，我们将增加nonce值并重试。如果这不起作用，我们将再次增加nonce值并重试。然后我们将继续运行这个<code class="fe ma mb mc md b">hashBlock</code>方法，直到我们找到一个以四个零开始的散列。这就是我们的<code class="fe ma mb mc md b">proofOfWork</code>方法的工作方式。</p><p id="f26a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能想知道这个<code class="fe ma mb mc md b">proofOfWork</code>方法实际上是如何保护区块链的。这样做的原因是，为了生成正确的散列，我们将不得不多次运行我们的<code class="fe ma mb mc md b">hashBlock</code>方法，这将消耗大量的能量和计算能力。</p><p id="5cca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果有人想回到区块链，试图改变一个块或该块中的数据——也许是为了给自己更多的比特币——他们将不得不进行大量的计算，并花费大量的精力来创建正确的哈希。在大多数情况下，回过头来试图重新创建一个已经存在的块，或者试图用自己的假数据重新挖掘一个已经存在的块是不可行的。我们的<code class="fe ma mb mc md b">hashBlock</code>方法不仅接受<code class="fe ma mb mc md b">currentBlockData</code>，还接受之前的BlockHash。这意味着区块链中的所有区块都通过它们的数据链接在一起。</p><p id="4c91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有人试图返回并重新挖掘或重新创建一个已经存在的块，他们还必须重新挖掘和重新创建他们重新创建的第一个块之后的每个块。这将需要大量的计算和精力，对于一个发展良好的区块链来说是不可行的。一个人必须进去，使用工作证明重新创建一个块，然后通过对每个块进行新的工作证明来重新创建每个块。这对于任何生产精良的区块链都是不可行的，这也是区块链技术如此安全的原因。</p><p id="3576" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在这一切看起来似乎令人不知所措，有点混乱，但是不要担心——我们将在下一节构建<code class="fe ma mb mc md b">proofOfWork</code>方法，然后我们将使用许多不同类型的数据来测试它。</p><h1 id="27cb" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建proofOfWork方法</h1><p id="6356" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们构建出<code class="fe ma mb mc md b">proofOfWork</code>方法:</p><ol class=""><li id="3a59" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">在<code class="fe ma mb mc md b">hashBlock</code>方法之后，定义<code class="fe ma mb mc md b">proofOfWork</code>方法如下:</li></ol><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/e786c1f69807e3f4eeb13c6dc2bbfee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVyJUTWlCfUlPM5vZywzew.jpeg"/></div></div></figure><p id="ed62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.该方法接受两个参数:<code class="fe ma mb mc md b">previousBlockHash</code>和<code class="fe ma mb mc md b">currentBlockData</code>:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/0d3b5b6dd5ef920c2eec59104b1200f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AfKwkOhe77PwqZaSlDUvnQ.jpeg"/></div></div></figure><p id="0b21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.我们想在方法内部做的第一件事是定义一个nonce:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/eeb4cf07796bf43067bc53089b21954d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iP4h-N1SckWrtKx3ACZCyw.jpeg"/></div></div></figure><p id="3819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.接下来，我们要第一次散列我们的所有数据，所以键入下面突出显示的代码行:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/0651b89a6b5ec4f3237f2b0a2a412a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDTICVvbtFg8h5mEgvidEA.jpeg"/></div></div></figure><p id="1110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前面的代码中，您可能会注意到我们使用了let这个术语，因为我们的<code class="fe ma mb mc md b">nonce</code>和<code class="fe ma mb mc md b">hash</code>都会随着方法的执行而改变。</p><p id="5da3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.我们想要做的下一步是不断地反复运行<code class="fe ma mb mc md b">hashBlock</code>方法，直到我们得到一个以四个零开始的散列。我们将在while循环的帮助下重复这个操作:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/2690976c324091e9ede9c581365519f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKENntPYQY8SYK6eAglg0A.jpeg"/></div></div></figure><p id="fc2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">6.如果我们创建的散列不是以四个零开始，我们将再次运行我们的散列，除了这次使用不同的nonce值。因此，在while循环中，添加以下突出显示的代码行:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/c6b85718aef337bfa8076f9b53b17d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJ7IcNBd7rx17HxLnh_1Ig.jpeg"/></div></div></figure><p id="133a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在while循环中，我们使用所有相同的数据再次运行我们的<code class="fe ma mb mc md b">hashBlock</code>方法，除了这次我们的<code class="fe ma mb mc md b">nonce</code>增加并等于1而不是0。这将是while循环的第一次迭代。</p><p id="7668" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在第一次迭代之后，生成的新散列的前四个字符不等于0000。在这种情况下，我们需要生成一个新的散列。因此，我们的while循环将再次运行，nonce值将增加到2，并将创建一个新的散列。如果散列也不是以四个零开始，那么while循环将再次运行，nonce值将再次递增，并且散列将再次生成。</p><p id="121a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的循环将继续这样做，直到得到一个以四个零开始的散列。这可能需要多次迭代。这种情况可能会发生10次、1万次或10万次。</p><p id="fd4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个循环是所有计算发生的地方，这就是为什么<code class="fe ma mb mc md b">proofOfWork</code>方法使用这么多能量的原因——有很多计算正在进行。</p><p id="4989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将继续遍历while循环，直到生成一个以四个零开始的合适的散列。当我们最终得到正确的散列时，我们的while循环将停止运行，在我们的<code class="fe ma mb mc md b">proofOfWork</code>结束时，它将简单地返回给我们有效散列的<code class="fe ma mb mc md b">nonce</code>值:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/1d047f317d6d6f5af57b252e2507251a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iR6iDEiaTy30Bk3al32Tbg.jpeg"/></div></div></figure><p id="6ea0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，这就是我们的<code class="fe ma mb mc md b">proofOfWork</code>方法如何工作并验证散列。在下一节中，我们将测试我们的<code class="fe ma mb mc md b">proofOfWork</code>方法，以确保它正常工作。我们还将研究为什么我们返回一个<code class="fe ma mb mc md b">nonce</code>值而不是返回散列值。</p><h1 id="ee22" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试proofOfWork方法</h1><p id="c020" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们测试一下我们的<code class="fe ma mb mc md b">proofOfWork</code>方法，确保它能正常工作。我们将在我们的<code class="fe ma mb mc md b">test.js</code>文件中测试这个方法。你可以在<a class="ae my" href="https://github.com/PacktPublishing/Learn-Blockchain-Programming-with-JavaScript/tree/master/dev" rel="noopener ugc nofollow" target="_blank">https://github . com/packt publishing/Learn-block chain-Programming-with-JavaScript/tree/master/dev</a>找到本文的代码文件。那么，让我们开始吧:</p><ol class=""><li id="300d" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">打开test.js文件。</li></ol><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/3b712729429b9578c21a45ea776d6f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*GxPOysSmzXyhrkDWEvZuZw.png"/></div></div></figure><p id="23c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.如果test.js文件中没有任何数据，将它添加到test.js文件中，如前面的屏幕截图所示，然后就可以开始测试数据了。</p><p id="9b50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.为了测试我们的<code class="fe ma mb mc md b">proofOfWork</code>方法，我们需要<code class="fe ma mb mc md b">previousBlockHash</code>和<code class="fe ma mb mc md b">currentBlockData</code>。因此，在我们的测试案例中，去掉nonce值，并将以下代码行添加到我们的文件中:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/edbe950e7344e22d119f0b2b17df43c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1vdHejjTYqltxBWiTyE_w.jpeg"/></div></div></figure><p id="97d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们应该从这个<code class="fe ma mb mc md b">proofOfWork</code>方法得到一个<code class="fe ma mb mc md b">nonce</code>值。我们的<code class="fe ma mb mc md b">proofOfWork</code>方法所做的是测试正确的<code class="fe ma mb mc md b">nonce</code>值是否与我们的块数据和我们的<code class="fe ma mb mc md b">previousBlockHash</code>进行散列，以生成以四个零开始的结果块散列。在这里，<code class="fe ma mb mc md b">proofOfWork</code>为我们找到了正确的<code class="fe ma mb mc md b">nonce</code>。</p><p id="2b7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.保存这个文件，并通过在我们的终端窗口中键入<code class="fe ma mb mc md b">node dev/test.js</code>命令来运行我们的测试。运行测试后，您会发现屏幕上弹出一个数字作为输出:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/7bd466497e1b1f5e51e8ab5c59e3d31e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*DSfsUCU7OYJurrwogQ3qXQ.png"/></div></figure><p id="7295" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个数字意味着我们的<code class="fe ma mb mc md b">proofOfWork</code>方法花了27，470次迭代才找到一个以四个零开始的散列。</p><p id="16b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.为了深入理解整个过程，我们可以做的是，在我们的while循环中，注销我们尝试的每个散列。我们必须对while循环做一些小的修改:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/46bda372fdb8b80dd8396c8e58bcb5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5cSdUa_d7fhl8ys1y8PFw.jpeg"/></div></div></figure><p id="1284" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们现在运行我们的测试文件时，将会发生的是，我们实际上会看到27，000个不同的散列在我们的终端中注销。除了最后一个，这些哈希都不会以四个零开头。只有被注销的最后一个散列应该以四个零开始，因为在我们的方法之后，它将终止并返回获得有效散列的nonce值。</p><p id="372e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次保存我们的test.js文件。现在，您可以在屏幕上看到，我们有一大堆不同的散列被登录到终端:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/51ed40b2c6d8d195fff7d14434d13329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJ7nAtmbkA_5HtdQnLjTDw.png"/></div></div></figure><p id="6bb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，对于已经记录的每一个散列，在我们获得最终值之前，开头永远不会是一行中的四个零。</p><p id="0ddd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生的事情是，我们从值为0的<code class="fe ma mb mc md b">currentBlockData</code>、<code class="fe ma mb mc md b">previousBlockHash</code>和<code class="fe ma mb mc md b">nonce</code>生成散列。然后，对于下一个散列，我们将nonce递增1。因此，都是相同的输入数据，但是nonce值会递增，直到获得有效的散列。最后，在27，470，利用随机数的值，获得有效散列。</p><p id="8ce9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们尝试使用我们的<code class="fe ma mb mc md b">hashBlock</code>方法。在我们的<code class="fe ma mb mc md b">dev/test.js file</code>中，删除<code class="fe ma mb mc md b">proofOfWork</code>方法并添加以下代码行:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/0a64743ee3e32a4ada435fc24a04cb59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IH8AK70CcwneHz4NAncYSA.jpeg"/></div></div></figure><p id="fc27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前面的代码中，对于nonce，我们输入值27，470。这个值是我们从<code class="fe ma mb mc md b">proofOfWork</code>方法中获得的。</p><p id="f639" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将观察到的输出是使用正确的nonce值运行单个hash，该值是通过运行<code class="fe ma mb mc md b">proofOfWork</code>方法获得的。通过这样做，我们应该在第一次尝试时生成一个以四个零开始的散列。让我们保存它并运行它。一旦测试运行，您将观察到以四个零开始的单个散列，如下面的屏幕截图所示:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/894e20f9614fec5edb5d7a31cc885699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDk_3B7UhWNGYA8vwKOt6Q.png"/></div></div></figure><p id="a5f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">proofOfWork</code>是区块链技术非常重要的一部分。这很难计算，正如您从测试结果中观察到的那样——我们花了27，000多次迭代来生成正确的哈希。因此，一个<code class="fe ma mb mc md b">proofOfWork</code>需要大量的能量和计算，并且很难生产。</p><p id="138c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们有了正确的证据或生成所需散列的<code class="fe ma mb mc md b">nonce</code>值，我们应该很容易验证我们有正确的nonce值。我们可以通过简单地将它传递给我们的<code class="fe ma mb mc md b">hashBlock</code>方法来验证这一点——我们将获得以四个零开始的散列。</p><p id="1c6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生成一个工作证明需要大量的工作，但是验证它是正确的是非常容易的。因此，如果我们想要返回到我们的区块链并检查以确保一个块是有效的，您所要做的就是使用前一个块的散列和当该块被挖掘时从<code class="fe ma mb mc md b">proofOfWork</code>生成的随机数来散列该块的数据。如果它返回给我们一个以四个零开始的有效散列，那么我们已经知道这个块是有效的。</p><p id="f568" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，从我们的测试中，我们可以得出结论，<code class="fe ma mb mc md b">proofOfWork</code>方法如预期的那样工作。</p><p id="7301" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">如果你觉得这篇文章有意思，可以看看</em> <a class="ae my" href="https://amzn.to/2CicZ9r" rel="noopener ugc nofollow" target="_blank"> <em class="kw">用JavaScript学习区块链编程</em> </a> <em class="kw">探索用JavaScript开发高度安全的类比特币应用的区块链技术要领。</em> <a class="ae my" href="https://www.packtpub.com/web-development/learn-blockchain-programming-javascript" rel="noopener ugc nofollow" target="_blank"> <em class="kw">用JavaScript学习区块链编程</em> </a> <em class="kw">可以帮助你理解去中心化的区块链网络是如何运作的，以及为什么去中心化对于获得区块链是如此重要的特征。</em></p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><figure class="mo mp mq mr gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nn"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="no np gp gr nq nr"><a href="https://gitconnected.com/learn/solidity" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">学习坚固性-最佳坚固性教程(2019) | gitconnected</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">14大坚实度教程。课程由开发者提交并投票，让你找到最好的稳定性…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">gitconnected.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of jw nr"/></div></div></a></div></div></div>    
</body>
</html>