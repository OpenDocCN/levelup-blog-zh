<html>
<head>
<title>How to Handle Errors in an Express and Node.js App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理Express和Node.js应用程序中的错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-handle-errors-in-an-express-and-node-js-app-cb4fe2907ed9?source=collection_archive---------0-----------------------#2020-01-13">https://levelup.gitconnected.com/how-to-handle-errors-in-an-express-and-node-js-app-cb4fe2907ed9?source=collection_archive---------0-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div class="gh gi ju"><img src="../Images/bf1766a1b578b79f323a34dde80aa504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*kAe6SPoTlc7wgVo5won7Vw.jpeg"/></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">图片由<a class="ae kg" href="https://pixabay.com/users/mohamed_hassan-5229782/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3085712" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>从<a class="ae kg" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3085712" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</figcaption></figure><p id="9059" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">当我们用Express创建API时，我们定义了<code class="fe lf lg lh li b">routes</code>和它们的<code class="fe lf lg lh li b">handlers</code>。在理想的情况下，我们的API的消费者将只对我们定义的路由发出请求，并且我们的路由将正确无误地工作。但是如果你注意到了，我们并不是生活在一个理想的世界里。Express知道这一点，并使处理我们的API中的错误变得轻而易举。</p><p id="19d6" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在这篇文章中，我将解释如何在Express中处理错误。要继续操作，请克隆这个<a class="ae kg" href="https://github.com/Olusamimaths/Express-Error-Handling-Tutorial" rel="noopener ugc nofollow" target="_blank">库</a>。克隆回购后记得要<code class="fe lf lg lh li b">npm install</code>。</p><p id="6cf3" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">存储库有一个JavaScript文件，<code class="fe lf lg lh li b">index.js</code>，包含以下内容:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="edd0" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果你不想克隆回购，创建一个新的文件夹，<code class="fe lf lg lh li b">npm init -y</code>，然后<code class="fe lf lg lh li b">npm i --save express</code>。在这个文件夹中创建<code class="fe lf lg lh li b">index.js</code>并将代码粘贴到其中。</p><h1 id="0da3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">误差来源</h1><p id="a649" class="pw-post-body-paragraph kh ki iq kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ij bi translated">在Express app中有两种基本的出错方式。</p><p id="79e5" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">一种方式是向没有定义路由处理器的<code class="fe lf lg lh li b">path</code>发出请求。例如，<code class="fe lf lg lh li b">index.js</code>定义了两条<code class="fe lf lg lh li b">get</code>路线(一条到<code class="fe lf lg lh li b">/</code>和<code class="fe lf lg lh li b">/about</code>)。我使用了<code class="fe lf lg lh li b">get</code>路线，这样我们可以在浏览器中轻松测试路线。请注意，路由定义了一个<code class="fe lf lg lh li b">path</code>和一个中间件函数，当向该路径发出请求时，将调用该函数:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="b822" class="ms lm iq li b gy mt mu l mv mw">app.HTTPMethod(path, middleware)<br/>// HTTPMethod = get, post, put, delete …</span></pre><p id="6b85" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">错误的另一个来源是当我们的路由处理器或代码中的其他地方出错时。例如，将“index.js”中的第一条路线更新如下:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="a763" class="ms lm iq li b gy mt mu l mv mw">…<br/>app.get(‘/’, (req, res, next) =&gt; {<br/> // mimic an error by throwing an error to break the app!<br/> throw new Error(‘Something went wrong’);<br/> res.send(‘Welcome to main route!’)<br/>})<br/>…</span></pre><p id="8db4" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">重启服务器并访问<code class="fe lf lg lh li b">localhost:3000</code>，你会看到一个错误和一个堆栈跟踪。</p><h1 id="fcae" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">通过路由排序处理路由错误</h1><p id="e3e9" class="pw-post-body-paragraph kh ki iq kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ij bi translated">删除<code class="fe lf lg lh li b">index.js</code>中抛出错误的语句。启动服务器并在浏览器中访问<code class="fe lf lg lh li b">localhost:3000</code>,您应该会看到消息:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="1eb0" class="ms lm iq li b gy mt mu l mv mw">Welcome to the main route!</span></pre><p id="d9ca" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">来访<code class="fe lf lg lh li b">localhost:3000/about</code>:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="8195" class="ms lm iq li b gy mt mu l mv mw">This is the about route!</span></pre><h1 id="5dda" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Express如何查找路线？</h1><p id="0a14" class="pw-post-body-paragraph kh ki iq kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ij bi translated">Express创建了一个被称为<strong class="kj ir">的路由表</strong>，它按照代码中定义的顺序放置路由。当请求进入web服务器时，URI会在路由表中运行，并使用路由表中的第一个匹配项，即使匹配项不止一个。</p><p id="5555" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果没有找到匹配，那么Express会显示一个错误。要查看实际效果，请访问<code class="fe lf lg lh li b">localhost:3000/contact</code>，浏览器显示:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="bd27" class="ms lm iq li b gy mt mu l mv mw">Cannot GET /contact</span></pre><p id="58c7" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在检查路由表后，Express没有找到与<code class="fe lf lg lh li b">/contact</code>匹配的条目，因此它以一个错误响应。</p><h1 id="4dde" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">集中式错误处理:如何利用路由顺序</h1><p id="8210" class="pw-post-body-paragraph kh ki iq kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ij bi translated">因为当在路由表中找不到给定URI的匹配时，Express会显示错误消息，这意味着我们通过确保该路由是路由表中的最后一条来定义处理错误的路由。错误路由应该匹配哪条路径？</p><p id="d13f" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">因为我们不知道用户将请求的不存在的路径，所以我们不能将路径硬编码到这个错误路由中。我们也不知道请求可能使用哪种HTTP方法，因此我们将使用<code class="fe lf lg lh li b">app.use()</code>而不是<code class="fe lf lg lh li b">app.get</code>。</p><p id="7dd4" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在<code class="fe lf lg lh li b">app.listen()</code>之前，通过将以下路线放在路线声明的末尾来更新<code class="fe lf lg lh li b">index.js</code>:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="803f" class="ms lm iq li b gy mt mu l mv mw">…<br/>// this matches all routes and all methods i.e a centralized error handler<br/>app.use((req, res, next) =&gt; {<br/> res.status(404).send({<br/> status: 404,<br/> error: ‘Not found’<br/> })<br/>})</span><span id="aa01" class="ms lm iq li b gy mx mu l mv mw">app.listen(port …</span></pre><p id="19e6" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">重启服务器并访问未定义的路径，例如<code class="fe lf lg lh li b">localhost:3000/blog</code></p><p id="171d" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">现在，我们有一个自定义的错误响应:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="e539" class="ms lm iq li b gy mt mu l mv mw">{“status”:404,”error”:”Not found”}</span></pre><p id="05aa" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">请记住，路线的顺序对这一工作非常重要。如果这个错误处理路由位于路由声明的顶部，那么每个路径(有效的和无效的)都将与之匹配。我们不希望这样，所以错误处理路径必须在最后定义。</p><h1 id="1447" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">处理路由处理程序中的错误</h1><p id="d3da" class="pw-post-body-paragraph kh ki iq kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ij bi translated">如前所述，路由处理程序只是JavaScript函数(如果我们正在编写OOP，它们也可以是类方法)，就像任何其他函数一样，我们可以使用<code class="fe lf lg lh li b">try catch</code>状态来处理错误。</p><p id="99aa" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe lf lg lh li b">try catch</code>语句标记了一个要尝试的语句块(在<code class="fe lf lg lh li b">try</code>块中),然后指定了一个响应(在<code class="fe lf lg lh li b">catch</code>块中),以防出现异常。JavaScript中的异常在语法上等同于错误。</p><p id="c5ec" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">通过更新中间件功能来更新<code class="fe lf lg lh li b">index.js</code>:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="3a31" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果您在中间函数中执行任何异步操作，</p><h1 id="c8f8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">处理任何类型的错误</h1><p id="a2e7" class="pw-post-body-paragraph kh ki iq kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ij bi translated">如果我们只想处理对不存在的路径的请求的错误，那么上一节的解决方案是可行的。但是它不处理我们的应用程序中可能发生的其他错误，这是一种不完整的处理错误的方法。它只解决了问题的一半。</p><p id="6610" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">更新<code class="fe lf lg lh li b">index.js</code>以在第一个get路径中抛出错误:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="2e0e" class="ms lm iq li b gy mt mu l mv mw">…<br/>app.get(‘/’, (req, res, next) =&gt; {<br/> throw new Error(‘Something went wrong!’);<br/> res.send(‘Welcome to main route!’)<br/>})<br/>…</span></pre><p id="4375" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果你访问<code class="fe lf lg lh li b">localhost:3000</code>，你仍然会看到默认错误处理程序的响应。</p><h1 id="0fbf" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">定义错误处理中间件</h1><p id="9772" class="pw-post-body-paragraph kh ki iq kj b kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la mn lc ld le ij bi translated">错误处理中间件函数的声明方式与其他中间件函数相同，只是它们有四个参数，而不是三个。例如:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="127c" class="ms lm iq li b gy mt mu l mv mw">// error handler middleware<br/>app.use((error, req, res, next) =&gt; {<br/> console.error(error.stack);<br/> res.status(500).send(‘Something Broke!’);<br/>})</span></pre><p id="8d9d" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">将这段代码放在<code class="fe lf lg lh li b">index.js</code>中<code class="fe lf lg lh li b">app.listen</code>前<code class="fe lf lg lh li b">app.use</code>后的路由声明之后，重启服务器后访问localhost:3000。现在的回应是:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="10e3" class="ms lm iq li b gy mt mu l mv mw">Something Broke!</span></pre><p id="c193" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">现在，我们正在处理这两种类型的错误。啊哈！</p><p id="a6df" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这是可行的，但是我们能改进它吗？。是的。怎么会？</p><p id="5b8b" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">当您将一个参数传递给<code class="fe lf lg lh li b">next()</code>时，Express会认为这是一个错误，它会跳过所有其他路由，并将传递给<code class="fe lf lg lh li b">next()</code>的内容发送给已定义的错误处理中间件。</p><p id="e8f0" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">更新<code class="fe lf lg lh li b">index.js</code>:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="200a" class="ms lm iq li b gy mt mu l mv mw">…<br/>app.use((req, res, next) =&gt; {<br/> const error = new Error(“Not found”);<br/> error.status = 404;<br/> next(error);<br/>});</span><span id="95d4" class="ms lm iq li b gy mx mu l mv mw">// error handler middleware<br/>app.use((error, req, res, next) =&gt; {<br/>  res.status(error.status || 500).send({<br/>   error: {<br/>   status: error.status || 500,<br/>   message: error.message || ‘Internal Server Error’,<br/>  },<br/> });<br/>});<br/>…</span></pre><p id="f542" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">处理错误请求的中间件功能现在移交给错误处理器中间件。<code class="fe lf lg lh li b">next(error)</code>暗示:‘嘿，错误处理者先生，我有一个错误，处理它！’。</p><p id="dd45" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">为了确保您与我在同一页上，行<code class="fe lf lg lh li b">error.status || 500 </code>暗示如果错误对象没有状态属性，我们使用500作为状态代码。<code class="fe lf lg lh li b">index.js</code>的完整内容是:</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="f732" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果您提供的是静态页面，而不是发送JSON响应，逻辑还是一样的。您只需要改变错误处理程序中发生的事情。例如:</p><pre class="jv jw jx jy gt mo li mp mq aw mr bi"><span id="c3db" class="ms lm iq li b gy mt mu l mv mw">app.use((error, req, res, next) =&gt; {<br/> console.error(error); // log an error<br/> res.render(‘errorPage’) // Renders an error page to user!<br/>});</span></pre><p id="c666" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果你觉得这篇文章很有帮助，请与你的朋友和追随者分享，并查看我的其他帖子。</p><p id="1228" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">你可以在推特上关注我</p><p id="b7cc" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">黑客快乐！</p><p id="27a2" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><em class="my">如果你点击拍手图标50次，你认为会发生什么？试试吧！</em></p></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><div class="jv jw jx jy gt mz"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">编写面试问题</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">技术开发</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ka mz"/></div></div></a></div></div></div>    
</body>
</html>