# 编码问题:Go 中第一个不重复的字符

> 原文：<https://levelup.gitconnected.com/coding-problem-first-non-repeating-character-in-go-e16fcab5da40>

## 提高你的编码技能！

![](img/e7edad0871b00adf8ea4fbb9575af514.png)

从 [unsplash](https://unsplash.com/photos/W8VDpcZeeFc)

这篇文章是我用最相关的语言写编码问题的个人习惯的一部分，以保持我的编程和解决问题的技能。*第一个不重复字符*题是一个众所周知的初学计算机科学题。在这里我们将理解问题，编写表驱动测试，并使用 Go 开发两个解决方案。

我们来编码吧！

# 理解问题

虽然标题相当自描述性，但最好通过首先浏览一些例子来理解编码问题。在我们的例子中，*第一个非重复字符*问题是由一个英文字符串的输入和该字符串的第一个非重复字符的索引的输出来定义的。如果没有不重复的字符，那么函数应该返回`-1`。

这里有几个例子:

```
----- Example 1 -----
Input:  abbcddeff
Output: 0
----- Example 2 -----
Input:  abbNadNe
Output: 4
----- Example 3 -----
Input:  ddd
Output: -1
```

你应该总是试着自己解决这些例子，尤其是在编码面试中，以获得对问题的初步理解。这个问题只需举几个例子就能理解，所以现在让我们继续测试。

# Go 中的表格驱动测试

我认为编码问题的下一个伟大的步骤是开发测试。在你开始写任何代码之前，它继续你完全理解问题的道路。此外，编写测试可以促进全面的软件开发技能，并鼓励您保持代码逻辑的灵活性和简洁性。

Go 有一个很好的方法来创建针对单个函数的多个测试，称为*表驱动测试*。第一步是找出我们要测试的函数，在这种情况下，我们只需要让`FirstNonRepeatingCharacter()`总是返回`-1`。

接下来我们可以添加我们的测试。Go 中的表驱动测试是通过首先定义一个 struct 作为您的`testCases`来构建的。在我的上一篇文章中，我只使用了一个包含`name`字段的`struct`。在这个例子中，我使用一个`map`构建了`testCases`，它将一个`string`作为表示名称的键，对应于一个带有`input`和`expectedResult`字段的`struct`。

如下所示，我们有 6 个不同字符串的测试用例，以及它们各自的预期结果。我鼓励你添加你自己的测试用例！

在为每个测试定义了对象之后，我们开始一个`for`循环(Go 中唯一的循环机制),它使用`range`关键字从每个`testCases`条目中获取`name`和`struct`。您可能会注意到，我将该结构作为`v`获取，然后在循环的第 40 行将其重新赋值给`tc`。这与循环执行的 Go 有关。如果您没有在 for 循环的开始重新分配`tc := v`，那么您实际上会得到一个与对象`v`不一致的测试状态。我不确定这是为什么，所以如果你知道，请在下面留下评论！

接下来，一旦我们有了测试用例以及测试的名称，我们就可以通过嵌套调用`t.Parallel()`来调用`t.Run()`来并发运行我们的测试，从而提高性能。然后，我们可以通过用我们的测试用例输入`tc.input`调用`FirstNonRepeatingCharacter`来简单地获得`actualResult`。然后使用`tc.expectedResult`和`actualResult`上的`assert.Equal()`验证该值。在这一点上，唯一通过的测试是当我们期望`-1`作为返回类型时，所以让我们修复它。

# 解决方案#1 — O(N)时间和 O(1)空间

像往常一样，让我们从一个蛮力解决方案开始。如果我们想找到在字符串中没有重复出现的字符的第一个索引，我们可以创建一个 double for 循环来检查字符串中每个字符的重复。

在第一个 for 循环的开始，我们默认设置一个布尔值`foundDuplicate`等于`false`。然后第二个 for 循环将遍历字符串，看看我们当前的字符是否有重复的。我们通过检查`str[i] == str[j]`来做到这一点，但也小心地检查我们没有将同一个字符本身与条件`&& i != j`进行比较。

假设这些字符彼此相等，并且它们不在同一个索引上，那么这个字符有一个副本，我们设置`foundDuplicate = true`。否则，如果我们在嵌套的 for 循环中没有找到当前字符的副本，那么`foundDuplicate`将保持其默认值`false`，第 12 行的条件将导致我们返回我们刚刚检查的唯一字符的索引值。

如果`foundDuplicate`在我们的双 for 循环中保持`true`，那么就没有不重复的字符，我们将返回值`-1`作为结果。

再次运行我们的测试显示所有测试都通过了:

```
$ go test *.go
ok      command-line-arguments  0.378s
```

因为我们嵌套了在整个字符串上循环的 for 循环，所以这个算法的时间复杂度是 O(N)。但是我们不存储任何额外的数据类型，所以我们的空间复杂度将是常数 O(1)。

# 解决方案#2 — O(N)时间和 O(1)空间

优化时间到了。这个问题建立在一个基本原则上，那就是我们需要找到一个不会重复的角色。有没有一种方法可以让我们遍历字符串一次，并记录一个字符出现的次数，而不是一个双循环来迭代地检查每个字符的重复项？当然有，我们可以使用哈希映射来实现——这是一种非常有用的数据结构，对编程和编码采访都是如此。

在这个解决方案中，我们将第一次遍历字符串，记录每个字符出现的次数。Go 中的`range`关键字首先返回一个索引，然后返回字符。我们不关心第一个循环的索引，所以用第 6 行的`_`符号忽略它。然后，对于字符串`str`中的每个字符`char`，我们将键值对递增 1。我特别喜欢 Go 不会对你大喊大叫，如果你还没有创建一个键，你可以简单地增加一个键值，如果它还没有被引用，它将默认为零。

在下一个 for 循环中，我们再次迭代字符串。这一次，我们从字符串`str`中引用当前字符`char`，并通过引用我们的哈希映射`characterCounts`来查看它出现了多少次。如果字符出现的次数等于 1，那么我们找到一个不重复的字符。因为我们想返回第一个不重复的字符，所以当这个条件满足时，我们将立即返回。

如果我们从未找到键值为`1`的字符，那么就没有唯一的字符，我们返回`-1`作为结果。

在这个算法中，我们在字符串上循环两次，导致 O(2N)=O(N)的时间复杂度。我们现在存储一个散列映射，但是空间复杂度仍然是恒定的，因为我们最多只能存储字符中的字母表。即使字符是 unicode 的，它也是一个有限的集合。这将是你和面试官讨论的一个重要话题！

当然，使用上面的解决方案也会导致我们所有的测试都通过。干得好！

我希望你喜欢阅读这篇文章，并能够学到一些新的东西。如果您发现任何部分特别有用，或者想要任何其他编码问题的教程，我鼓励您在下面留下评论！感谢阅读。