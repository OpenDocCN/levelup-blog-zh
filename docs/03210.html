<html>
<head>
<title>The SOLID principles of Object-Oriented Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象设计的坚实原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-solid-principles-of-object-oriented-design-deeae9a626d9?source=collection_archive---------9-----------------------#2020-04-25">https://levelup.gitconnected.com/the-solid-principles-of-object-oriented-design-deeae9a626d9?source=collection_archive---------9-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a6ac4590f1339f0bd105aac672d681a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VyOPe65nrJ9VtjRi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">泰勒·拉斯托维奇在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1e9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在面向对象编程中，SOLID是在设计软件时要牢记的五个基本原则的首字母缩写，以使软件更加灵活、易于理解和维护。</p><blockquote class="le lf lg"><p id="fc60" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">坚实原理的理论是由罗伯特·C·马丁也就是鲍勃大叔提出的，坚实的首字母缩略词后来是由迈克尔·费哲提出的。</p></blockquote><p id="4a14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">坚固</strong>的设计原则是:</p><ol class=""><li id="2857" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated">单一责任原则</li><li id="38f3" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated"><strong class="ki iu"> O </strong>笔/闭原理</li><li id="90ae" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">伊斯科夫替代原理</li><li id="9533" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated"><strong class="ki iu"> I </strong>界面偏析原理</li><li id="fa72" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated"><strong class="ki iu"> D </strong>依赖反转原理</li></ol><h1 id="4bdc" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">单一责任原则</h1><p id="7a0b" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">实线中的“S”代表单一责任原则。</p><blockquote class="le lf lg"><p id="b530" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">每个软件模块应该有且只有一个改变的理由。</p></blockquote><p id="079c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你写一个软件模块时，你想确保每个模块只有一个功能。当一个新的功能出现时，它被添加到一个单独的模块中。您希望将您的模块从整个组织的复杂性中分离出来。</p><p id="bfd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">我们什么时候违反了SRP原则？</em></p><p id="1fd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你创建一个具有多个功能的类时，这个原则就被打破了。这使得代码冗长、复杂且紧密耦合。</p><blockquote class="le lf lg"><p id="0aa4" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">把因为同样的原因而改变的东西聚集在一起。把那些因为不同原因而改变的东西分开。</p></blockquote><p id="bc36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你思考这个问题，你会意识到这只是定义内聚和耦合的另一种方式。我们希望增加因相同原因而变化的事物之间的内聚力，我们希望减少因不同原因而变化的事物之间的耦合。</p><h1 id="fe19" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">开/关原则</h1><p id="84d8" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">实线中的“O”代表开/关原理。</p><blockquote class="le lf lg"><p id="de7a" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">软件实体(类、模块、函数等。)应该对扩展开放，但对修改关闭。</p></blockquote><p id="9056" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">这里开和关是什么？</em></p><ul class=""><li id="d6f1" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld nc lr ls lt bi translated">如果一个模块仍然可以扩展，那么这个模块就被认为是开放的。应该可以扩展一个类，并向派生类中添加新功能。</li><li id="2dcd" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld nc lr ls lt bi translated">如果一个模块可以使用，但是不能被其他模块修改，那么这个模块就被认为是关闭的。</li></ul><p id="22f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们什么时候打破了开闭原则？</p><p id="172e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们需要向现有的类中添加新的特性或新的行为时，在类中添加它本身就违背了这个原则。</p><h1 id="26ce" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">利斯科夫替代原理</h1><p id="09f7" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">固体中的“L”代表利斯科夫替代原理。</p><blockquote class="le lf lg"><p id="f459" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性。</p></blockquote><p id="4ba6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">派生类或子类必须可以替换它们的基类或父类。</p><p id="ec2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们什么时候违反了LSP原则？</p><p id="bd53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当子类对象不能代替父类对象时，这个原则就被打破了。</p><h1 id="b8ca" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">界面分离原理</h1><p id="d39f" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">固体中的“I”代表界面分离原理。</p><blockquote class="le lf lg"><p id="9d2a" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">许多特定于客户端的接口比一个通用接口要好。</p></blockquote><p id="86ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该强迫一个类实现与其无关的接口。一个类应该只实现那些它想要实现其属性/功能的接口。</p><p id="0cab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">我们什么时候违反了ISP原则？</em></p><p id="9a38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">向类中添加不相关的接口属性违反了这一原则。例如，当一个素食者去餐馆要菜单时，提供给他的菜单包括素食和非素食。非素食对他来说无关紧要，这就是ISP原则被打破的地方。按照这个原则，只有素菜菜单卡才应该给他。</p><h1 id="d6af" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">从属倒置原则</h1><p id="04df" class="pw-post-body-paragraph kg kh it ki b kj mx kl km kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">实线中的“D”代表依赖倒置原则。</p><blockquote class="le lf lg"><p id="dd0d" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">一个人应该依靠抽象而不是具体。</p></blockquote><ol class=""><li id="805a" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated">根据这个原则，高级代码不应该依赖于低级代码。高级和低级代码都应该依赖于抽象。</li><li id="7cf4" class="ll lm it ki b kj lu kn lv kr lw kv lx kz ly ld lq lr ls lt bi translated">同样，抽象不应该依赖于细节，但是细节应该依赖于抽象。</li></ol><p id="2d93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有助于分离类之间的依赖关系，因此对一个类的修改不需要对另一个类进行修改。</p><p id="a04b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">我们什么时候打破了蘸原则？</em></p><p id="e459" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个具体的类依赖于另一个类，而不是仅仅依赖于抽象时，这个原则就被打破了。这导致了类之间的紧密耦合。</p></div></div>    
</body>
</html>