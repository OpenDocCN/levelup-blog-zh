<html>
<head>
<title>CORS Every Web Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CORS是每个网络开发者都应该知道的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cors-every-web-developer-should-know-e6db4ba4df38?source=collection_archive---------3-----------------------#2022-04-10">https://levelup.gitconnected.com/cors-every-web-developer-should-know-e6db4ba4df38?source=collection_archive---------3-----------------------#2022-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你真的了解CORS吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d864ad839391f6287582ceb97b136c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zBIVc9rVHVpu5yIff3y2g.png"/></div></div></figure><p id="5d55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一名web开发人员，我相信你一定听说过cross-origin，知道CORS机制，那么我来问你一个问题:</p><blockquote class="lq lr ls"><p id="90db" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">跨源请求会到达服务器吗？如果到达，相应的后端特性会被执行吗？</p></blockquote><p id="00e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许你已经有答案了，那就看看我的分析是不是和你的一样！</p></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><h1 id="3d3c" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">同源政策</h1><p id="9621" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">首先，我们再来回顾一下同源政策。</p><p id="29f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同源策略是浏览器的关键安全机制。当从JavaScript发起HTTP请求时，如果当前页面的URL和被访问服务的URL的协议、端口(如果指定)和主机相同，则认为它们是同源的。也就是说，只要有一个不同，就是不同的原点，就会发生跨原点。</p><h1 id="bc0f" class="me mf it bd mg mh nb mj mk ml nc mn mo jz nd ka mq kc ne kd ms kf nf kg mu mv bi translated">什么是CORS？</h1><p id="0b8c" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">顾名思义，跨源资源共享(CORS)允许浏览器客户端基于HTTP头从不同的源加载服务器端资源。</p><p id="89d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是失败的跨来源请求:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/5b17212e1ded49e032736386abda5e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYmABtCwnyFYlJ6nlmCyVg.png"/></div></div></figure><p id="ed8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们可以回答第一个问题，跨原点请求会到达服务器吗？浏览器发送请求时会拦截吗？</p><p id="36cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答案是跨源请求将到达服务器，因为它需要根据服务器返回的<strong class="kw iu"> HTTP头决定是否返回对JavaScript的响应。</strong></p><p id="30bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么相应的后端特性执行了吗？要回答这个问题，你需要了解简单请求和飞行前请求。</p><h1 id="8f8d" class="me mf it bd mg mh nb mj mk ml nc mn mo jz nd ka mq kc ne kd ms kf nf kg mu mv bi translated">简单的请求</h1><p id="efe4" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">简单请求是指<strong class="kw iu">满足以下所有条件:</strong></p><ol class=""><li id="b69c" class="nh ni it kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated"><strong class="kw iu">允许的方法之一:</strong> GET或HEAD或POST。</li><li id="c4b0" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated"><strong class="kw iu">仅使用允许的请求头</strong>，它们包括:Accept、Accept-Language、Content-Language、Content-Type(限于3个值application/x-www-form-urlencoded、multipart/form-data、text/plain)、Range(仅具有简单的范围头值；例如，字节=256或字节= 127–255)。</li><li id="a111" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated">如果请求是使用一个<code class="fe nv nw nx ny b">XMLHttpRequest</code>对象发出的，那么在请求中使用的<code class="fe nv nw nx ny b">XMLHttpRequest.upload</code>属性返回的对象上没有注册事件监听器；也就是说，给定一个XMLHttpRequest实例<code class="fe nv nw nx ny b">xhr</code>，没有代码调用<code class="fe nv nw nx ny b">xhr.upload.addEventListener()</code>来添加一个事件监听器来监控上传。</li><li id="b411" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated">请求中未使用ReadableStream对象。</li></ol><h1 id="8804" class="me mf it bd mg mh nb mj mk ml nc mn mo jz nd ka mq kc ne kd ms kf nf kg mu mv bi translated">飞行前请求</h1><p id="fc84" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">在不同源的情况下，除简单请求之外的请求将触发<a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request" rel="noopener ugc nofollow" target="_blank"> CORS预检</a>。</p><p id="b87c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为这些请求可能会对服务器的数据产生副作用。浏览器使用OPTIONS方法发起的预检请求是为了知道跨原点请求是否被服务器允许，被允许后再发起实际的HTTP请求。</p><p id="9e89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们可以回答第二个问题，当跨原点请求到达时，相应的后端特性会被执行吗？</p><p id="d8ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">答案是不一定，需要分情况。</strong>如果是简单的请求，就会执行；否则，预检请求将不会执行相应的后端功能，只会执行预检请求通过后的请求。</p><p id="1192" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在浏览器客户端，只要是跨原点的请求，其响应能否传递给渲染过程中的主线程(JavaScript)就取决于那些响应头(下面详细描述)。<strong class="kw iu">如果响应头不允许，那么:</strong></p><ol class=""><li id="68fc" class="nh ni it kw b kx ky la lb ld nj lh nk ll nl lp nm nn no np bi translated">对简单请求的响应在浏览器的网络进程中被丢弃，数据不会传递给JavaScript。</li><li id="5adf" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated">对飞行前请求的响应不仅会在网络过程中被丢弃，而且不会发出下一个真正的请求。</li><li id="46f1" class="nh ni it kw b kx nq la nr ld ns lh nt ll nu lp nm nn no np bi translated">如果预检请求通过，但是实际请求的响应头<strong class="kw iu">不允许通过</strong>，数据也不会传递给JavaScript。</li></ol><h1 id="f684" class="me mf it bd mg mh nb mj mk ml nc mn mo jz nd ka mq kc ne kd ms kf nf kg mu mv bi translated">请求/响应标头</h1><p id="c1d3" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated">虽然上面已经解决了一开始提出的问题，但是您还需要了解CORS的这些重要的请求/响应头。</p><h2 id="01aa" class="oa mf it bd mg ob oc dn mk od oe dp mo ld of og mq lh oh oi ms ll oj ok mu ol bi translated">请求标题:</h2><p id="3000" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><code class="fe nv nw nx ny b">Origin: &lt;origin&gt;</code>:表示跨原点访问请求或预检请求的服务器原点。它只是服务器的名称，不包含任何路径信息。在任何访问控制请求中，总是发送源报头。</p><p id="2553" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nv nw nx ny b">Access-Control-Request-Method: &lt;method&gt;</code>:在预检请求中携带，表示在随后的实际请求中将使用哪种HTTP方法。</p><p id="0d73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nv nw nx ny b">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</code>:在预检请求中携带，以指示哪些HTTP报头将在随后的实际请求中使用。服务器会用Access-Control-Allow-Headers来回答，下面会介绍。</p><p id="090e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的例子中，我从本地客户端<code class="fe nv nw nx ny b">127.0.0.1:7000</code>向服务器<code class="fe nv nw nx ny b">127.0.0.1:3000</code>发出了一个飞行前请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/4d0a44147ccaf7944b6b4440102e83cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*vzes-W2Vz7q1DeRbfHJk6Q.png"/></div></figure><h2 id="9cfb" class="oa mf it bd mg ob oc dn mk od oe dp mo ld of og mq lh oh oi ms ll oj ok mu ol bi translated">响应标题:</h2><p id="872e" class="pw-post-body-paragraph ku kv it kw b kx mw ju kz la mx jx lc ld my lf lg lh mz lj lk ll na ln lo lp im bi translated"><code class="fe nv nw nx ny b">Access-Control-Allow-Origin: &lt;origin&gt; | *</code>:这是一个重要的响应头，表示服务器允许来自某个来源的请求。它可以指定一个原点，也可以指定“*”通配符来允许任何原点。此外，如果指定单个原点，最好在响应头中添加<code class="fe nv nw nx ny b">Vary: Origin</code>，以表明服务器的响应将根据原点请求头而变化。</p><p id="f466" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nv nw nx ny b">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</code>:响应飞行前请求，告诉客户端在发出实际请求时使用哪种HTTP方法，与上面描述的<code class="fe nv nw nx ny b">Access-Control-Request-Method</code>相比。</p><p id="b2c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nv nw nx ny b">Access-Control-Allow-Headers: &lt;header-name&gt;[, &lt;header-name&gt;]*</code>:对飞行前请求的响应，告诉客户端在发出实际请求时使用哪个HTTP头，与上面描述的<code class="fe nv nw nx ny b">Access-Control-Request-Headers</code>相比。</p><p id="cf68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nv nw nx ny b">Access-Control-Max-Age: &lt;delta-seconds&gt;</code>:表示预检请求的结果可以缓存多长时间，<code class="fe nv nw nx ny b">delta-seconds</code>参数以秒为单位。</p><p id="9511" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的截图是本地客户端<code class="fe nv nw nx ny b">127.0.0.1:7000</code>对服务器<code class="fe nv nw nx ny b">127.0.0.1:3000</code>的预检请求的响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/1daba2d1496e1efed5869c09b582e566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*m3A4UPDU3MdOYmiXhB-keA.png"/></div></figure></div><div class="ab cl lx ly hx lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="im in io ip iq"><p id="96f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lt">今天就到这里。我是Zachary，我会继续输出与web开发相关的故事，如果你喜欢这样的故事并想支持我，请考虑成为</em> <a class="ae nz" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="lt">中级会员</em> </a> <em class="lt">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae nz" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="lt">我的链接</em> </a> <em class="lt">报名，我会得到一点佣金。</em></p><p id="fc10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你的支持对我来说很重要——谢谢。</p></div></div>    
</body>
</html>