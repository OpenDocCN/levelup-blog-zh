<html>
<head>
<title>Full-stack Web App with Python, React and Bootstrap — Backend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">包含Python、React和Bootstrap的全栈Web应用程序—后端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/full-stack-web-app-with-python-react-and-bootstrap-backend-8592baa6e4eb?source=collection_archive---------0-----------------------#2021-06-25">https://levelup.gitconnected.com/full-stack-web-app-with-python-react-and-bootstrap-backend-8592baa6e4eb?source=collection_archive---------0-----------------------#2021-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c874" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Python Flask和SQLite创建一个RESTful API后端</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/72dd47111959363b0e60b35b846915f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jsi4bR2aWTGlIEm4AeP3Tw.png"/></div></div></figure><p id="e27a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗨，伙计们，欢迎来到另一个很棒的网络教程。我将向您展示如何使用Python flask/SQLite作为后端，Reactjs/bootstrap作为前端来构建一个全栈web应用程序。我们将在本教程中讨论后端实现，在下一个教程中讨论前端实现。这将会非常有趣，因为这将使你具备构建酷的全栈web应用的一般原则和实践。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="3c17" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">我们将会建造什么</h1><p id="6ec7" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们将通过实现一个简单的用户管理API来学习后端全栈web应用的架构。下面的视频展示了完成的后端应用程序。该应用程序提供了管理用户数据的功能，包括创建、读取、更新和删除数据。涵盖的概念和原则可以应用于创建其他更复杂的web应用程序，也可以应用于其他web技术。所以，让我们从Python flask/SQLite的后端RESTful API开始吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="8157" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">RESTful API</h1><p id="c16a" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">REST API(或RESTful API)，代表<strong class="kt ir"> R </strong>表示<strong class="kt ir"> S </strong>状态<strong class="kt ir"> T </strong>传输— <strong class="kt ir">应用程序<strong class="kt ir"> P </strong>编程<strong class="kt ir"> I </strong>接口，允许应用程序通过HTTP协议与资源交互。这种交互通常是实现特定业务逻辑的CRUD操作。因此，运行在web、桌面或移动设备上的应用程序通过HTTP方法请求资源，响应通常以JSON格式返回，以实现互操作性。在我们的用例中，我们的业务逻辑包括向数据库添加用户——创建操作、获取用户或单个用户的列表——读取操作、更新用户——更新操作和删除用户——删除操作。所有这些都将通过HTTP请求来完成。</strong></p><p id="5ff5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们定义我们的REST API端点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/06c814995553efb3599f9a9555ca5a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwdW7bsYv3vB9hYXk_PJAg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">用户管理API端点</figcaption></figure><p id="c634" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上表显示了用户管理应用程序的API端点。端点非常容易理解，它们执行数据库CRUD操作。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="6122" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">后端实现</h1><p id="40e1" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">如前所述，我们将使用Python Flask和SQLite作为后端。本教程使用Python 3。幸运的是，SQLite附带了一个数据库服务器，所以我们不需要担心单独的数据库服务器。本教程假设您熟悉Python和基本SQL查询。但是，如果您还不熟悉SQL查询，也不要担心，因为您仍然能够理解。首先，确保您已经安装了Python，最好是Python 3。*.您也可以使用您选择的任何IDE我使用的是流行的PyCharm。完整的<a class="ae my" href="https://github.com/effiongcharles/full_stack_web_python_flask_react_bootstrap" rel="noopener ugc nofollow" target="_blank">项目源代码可以在我的github页面上找到。</a></p><p id="b258" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使用Python Flask，我们需要首先安装这个包。您可以在您的终端中使用下面的命令。安装Python时，即在标准库中，已经包含了SQLite3。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="c962" class="ne lv iq na b gy nf ng l nh ni"># install flask package<br/>pip install Flask</span><span id="6cae" class="ne lv iq na b gy nj ng l nh ni"># Only if you don't have sqlite installed<br/>pip install db-sqlite3</span></pre></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="d3bc" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">数据库实现</h1><p id="922f" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">现在我们已经有了基本的设置，让我们来看看源代码。首先，我们将关注数据库实现，然后我们将关注REST API实现。基本上，我们需要创建我们的数据库和表。然后，为我们的每个业务逻辑编写函数。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="ba15" class="ne lv iq na b gy nf ng l nh ni">#!/usr/bin/python<br/>import sqlite3<br/><br/>def connect_to_db():<br/>    conn = sqlite3.connect('database.db')<br/>    return conn<br/><br/>def create_db_table():<br/>    try:<br/>        conn = connect_to_db()<br/>        conn.execute('''<br/>            CREATE TABLE users (<br/>                user_id INTEGER PRIMARY KEY NOT NULL,<br/>                name TEXT NOT NULL,<br/>                email TEXT NOT NULL,<br/>                phone TEXT NOT NULL,<br/>                address TEXT NOT NULL,<br/>                country TEXT NOT NULL<br/>            );<br/>        ''')<br/><br/>        conn.commit()<br/>        print("User table created successfully")<br/>    except:<br/>        print("User table creation failed - Maybe table")<br/>    finally:<br/>        conn.close()</span></pre><p id="efe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码片段实现了用户数据库。实现非常简单。首先，我们定义一个连接到数据库的函数，即<em class="nk"> connect_to_db </em>。如果数据库不存在，这个函数将创建一个数据库，并返回一个连接对象。执行其他数据库操作(CRUD)将需要该对象。<em class="nk"> create_db_table </em>函数连接到数据库并创建表格。用户表包含几个字段，包括user_id(唯一标识符)、名称和电子邮件。当执行<em class="nk">提交</em>功能时，保存对数据库的“更改”。接下来，让我们看看我们的业务逻辑的实现。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="9b2c" class="ne lv iq na b gy nf ng l nh ni">def insert_user(user):<br/>    inserted_user = {}<br/>    try:<br/>        conn = connect_to_db()<br/>        cur = conn.cursor()<br/>        cur.execute("INSERT INTO users (name, email, phone, address,       <br/>                    country) VALUES (?, ?, ?, ?, ?)", (user['name'],   <br/>                    user['email'], user['phone'], user['address'],   <br/>                    user['country']) )<br/>        conn.commit()<br/>        inserted_user = get_user_by_id(cur.lastrowid)<br/>    except:<br/>        conn().rollback()<br/><br/>    finally:<br/>        conn.close()<br/><br/>    return inserted_user</span></pre><p id="59ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码片段定义了一个向数据库表中添加新用户的函数。该函数将用户对象作为参数。用户对象只是一个python字典，如下面的代码片段所示。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="6293" class="ne lv iq na b gy nf ng l nh ni">user = {<br/>    "name": "John Doe",<br/>    "email": "jondoe@gamil.com",<br/>    "phone": "067765434567",<br/>    "address": "John Doe Street, Innsbruck",<br/>    "country": "Austria"<br/>}</span></pre><p id="c2d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，<em class="nk"> user_id </em>没有被插入。这是因为它是自动生成的。<em class="nk">光标</em>对象通常用于执行CRUD操作，因为它有助于遍历/处理数据库记录。此外，我们通过调用另一个返回给定user_id的用户的函数来返回刚刚插入的用户。接下来我们将看到这个函数的实现。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="cc53" class="ne lv iq na b gy nf ng l nh ni">def get_users():<br/>    users = []<br/>    try:<br/>        conn = connect_to_db()<br/>        conn.row_factory = sqlite3.Row<br/>        cur = conn.cursor()<br/>        cur.execute("SELECT * FROM users")<br/>        rows = cur.fetchall()<br/><br/>        # convert row objects to dictionary<br/>        for i in rows:<br/>            user = {}<br/>            user["user_id"] = i["user_id"]<br/>            user["name"] = i["name"]<br/>            user["email"] = i["email"]<br/>            user["phone"] = i["phone"]<br/>            user["address"] = i["address"]<br/>            user["country"] = i["country"]<br/>            users.append(user)<br/><br/>    except:<br/>        users = []<br/><br/>    return users<br/><br/><br/>def get_user_by_id(user_id):<br/>    user = {}<br/>    try:<br/>        conn = connect_to_db()<br/>        conn.row_factory = sqlite3.Row<br/>        cur = conn.cursor()<br/>        cur.execute("SELECT * FROM users WHERE user_id = ?", <br/>                       (user_id,))<br/>        row = cur.fetchone()<br/><br/>        # convert row object to dictionary<br/>        user["user_id"] = row["user_id"]<br/>        user["name"] = row["name"]<br/>        user["email"] = row["email"]<br/>        user["phone"] = row["phone"]<br/>        user["address"] = row["address"]<br/>        user["country"] = row["country"]<br/>    except:<br/>        user = {}<br/><br/>    return user</span></pre><p id="98be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码片段实现了从数据库中检索用户的功能。<em class="nk"> get_user </em>函数从数据库中返回所有用户的列表，而<em class="nk"> get_user_by_id </em>接受一个<em class="nk"> user_id </em>作为参数，并返回与<em class="nk"> user_id </em>匹配的用户记录。接下来让我们看看如何更新用户。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="70cb" class="ne lv iq na b gy nf ng l nh ni">def update_user(user):<br/>    updated_user = {}<br/>    try:<br/>        conn = connect_to_db()<br/>        cur = conn.cursor()<br/>        cur.execute("UPDATE users SET name = ?, email = ?, phone = <br/>                     ?, address = ?, country = ? WHERE user_id =?",  <br/>                     (user["name"], user["email"], user["phone"], <br/>                     user["address"], user["country"], <br/>                     user["user_id"],))<br/>        conn.commit()<br/>        #return the user<br/>        updated_user = get_user_by_id(user["user_id"])<br/><br/>    except:<br/>        conn.rollback()<br/>        updated_user = {}<br/>    finally:<br/>        conn.close()<br/><br/>    return updated_user</span></pre><p id="722c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代码片段实现了更新数据库中用户记录的功能。它接受一个用户对象作为参数，执行一个SQL查询用新值更新用户，最后通过调用前面看到的<em class="nk"> get_user_by_id </em>函数返回更新后的用户。如果我们想从数据库中移除或删除一个用户，该怎么办？让我们看看接下来该怎么做。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="7b70" class="ne lv iq na b gy nf ng l nh ni">def delete_user(user_id):<br/>    message = {}<br/>    try:<br/>        conn = connect_to_db()<br/>        conn.execute("DELETE from users WHERE user_id = ?",     <br/>                      (user_id,))<br/>        conn.commit()<br/>        message["status"] = "User deleted successfully"<br/>    except:<br/>        conn.rollback()<br/>        message["status"] = "Cannot delete user"<br/>    finally:<br/>        conn.close()<br/><br/>    return message</span></pre><p id="20f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码片段实现了删除用户功能。我们定义了一个函数，它接受一个用户id作为参数，从数据库中删除用户(SQL DELETE查询)并返回一条消息。</p><p id="01e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来让我们看看如何通过REST API端点来使用这些函数。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="4d37" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">REST API实现</h1><p id="736d" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">REST api端点公开了在上一节中创建的数据库函数。下表将数据库函数映射到API端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/65800f438c7768afa48d68ff61508e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWKUaR263JumW7Cxub04FA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">具有数据库功能的用户管理API端点</figcaption></figure><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="6b9d" class="ne lv iq na b gy nf ng l nh ni">from flask import Flask, request, jsonify #added to top of file<br/>from flask_cors import CORS #added to top of file</span><span id="3754" class="ne lv iq na b gy nj ng l nh ni">app = Flask(__name__)<br/>CORS(app, resources={r"/*": {"origins": "*"}})<br/><br/>@app.route('/api/users', methods=['GET'])<br/>def api_get_users():<br/>    return jsonify(<strong class="na ir">get_users()</strong>)<br/><br/>@app.route('/api/users/&lt;user_id&gt;', methods=['GET'])<br/>def api_get_user(user_id):<br/>    return jsonify(<strong class="na ir">get_user_by_id(user_id)</strong>)<br/><br/>@app.route('/api/users/add',  methods = ['POST'])<br/>def api_add_user():<br/>    user = request.get_json()<br/>    return jsonify(<strong class="na ir">insert_user(user)</strong>)<br/><br/>@app.route('/api/users/update',  methods = ['PUT'])<br/>def api_update_user():<br/>    user = request.get_json()<br/>    return jsonify(<strong class="na ir">update_user(user)</strong>)<br/><br/>@app.route('/api/users/delete/&lt;user_id&gt;',  methods = ['DELETE'])<br/>def api_delete_user(user_id):<br/>    return jsonify(<strong class="na ir">delete_user(user_id)</strong>)<br/><br/>if __name__ == "__main__":<br/>    #app.debug = True<br/>    #app.run(debug=True)<br/>    app.run() #run app</span></pre><p id="a65d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码片段实现了我们的API端点。首先，我们导入必要的软件包。API端点接收JSON对象作为请求，并返回JSON对象。出于这个原因，我们使用<em class="nk"> jsonify </em>包将Python字典转换成JSON。接下来，我们创建Flask应用程序，并配置该应用程序以允许使用<em class="nk"> CORS </em>从任何ip地址访问我们的端点。</p><p id="7ed3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了创建端点，我们首先定义路由。让我们以第一个端点为例。我们将根定义为<em class="nk"> '/api/users' </em>，并将方法设置为<em class="nk"> GET </em>。默认的方法是<em class="nk"> GET </em>，所以省略方法参数也是可以的。根(或端点)指定一个api函数，即<em class="nk"> api_get_users </em>，它使用数据库函数<em class="nk"> get_user </em>返回我们数据库中的用户列表。注意，返回了一个JSON对象。其他终点很简单。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="36de" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><strong class="ak">测试API </strong></h1><p id="f810" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">实施端点后的下一步是在向公众发布之前对所有端点进行功能测试(前端应用程序)。我们可以通过使用REST API客户端来实现这一点。有很多选择，但我特别喜欢邮递员。它有一个免费的软件包，易于使用，并有大量的伟大功能，如保存和分组端点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/c99fb5f4e8ae7c1fc0552bd569e60155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htxrszv-hx_Dj5P8qpTqAA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">使用Postman启动REST API请求</figcaption></figure><p id="a662" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上图显示了如何使用Postman启动REST API请求。请注意，该请求是对我们的端点的一个<em class="nk"> GET </em>请求，以获取具有匹配的<em class="nk"> user_id </em>(即<em class="nk"> user_id </em> = 1)的用户记录。响应的格式也是JSON。前端应用程序接收这些信息(用户记录)并决定如何呈现给用户。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="c687" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">摘要</h1><p id="94be" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">在本教程中，您已经学习了如何使用Python Flask和SQLite创建RESTful API。我们已经介绍了通过实现用户管理应用程序来实现RESTful API的非常重要的概念和原则。我们已经介绍了全栈应用的前半部分，即后端。我们将创建一个前端web应用程序，它“使用”我们在本教程中创建的API您肯定不想错过下一个教程。</p><p id="b3fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在我的github 上免费获得<a class="ae my" href="https://github.com/effiongcharles/full_stack_web_python_flask_react_bootstrap" rel="noopener ugc nofollow" target="_blank">完整的项目源代码。我希望你已经学到了一些有趣的东西，可以应用到你的项目中。</a></p><p id="9978" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对更多Python编程感兴趣？查看我的其他Python教程。</p><ul class=""><li id="82bb" class="nn no iq kt b ku kv kx ky la np le nq li nr lm ns nt nu nv bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/program-a-networked-tic-tac-toe-game-in-python-30f8826e591d?sk=5366727d6280b6256c79a94b74689aa2">用Python编写一个网络井字游戏</a></li><li id="234e" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/build-a-note-taking-app-with-mysql-backend-in-python-927b4c5fad91?sk=a57e187ba5d8275d8fef32670f9f461d">用Python语言的MySQL后台建立一个笔记应用</a></li><li id="f730" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/learn-python-by-building-a-gui-guessing-game-with-tkinter-9f82291db6?sk=4154727ca3623ac1a98f9aa1dbb4a565">用Tkinter构建GUI猜谜游戏学习Python</a></li><li id="3ab4" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/program-your-first-multiple-user-network-game-in-python-9f4cc3650de2?sk=312059e7967875fdbf4c7b67520bbdc9">用Python编写你的第一个多用户网络游戏</a></li><li id="8911" class="nn no iq kt b ku nw kx nx la ny le nz li oa lm ns nt nu nv bi translated"><a class="ae my" href="http://Learn Python by Building a Multi-user Group Chat GUI Application" rel="noopener ugc nofollow" target="_blank">通过构建多用户群组聊天GUI应用程序学习Python</a></li></ul><p id="c3eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">祝您编码愉快，下一期教程再见。</p><p id="04a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">问候，</p><p id="81f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查尔斯</p></div></div>    
</body>
</html>