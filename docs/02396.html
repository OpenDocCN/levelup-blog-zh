<html>
<head>
<title>Introducing Gretchen: Making Fetch Happen in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Gretchen:在TypeScript中实现Fetch</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introducing-gretchen-making-fetch-happen-in-typescript-87ab0bd66027?source=collection_archive---------17-----------------------#2020-03-10">https://levelup.gitconnected.com/introducing-gretchen-making-fetch-happen-in-typescript-87ab0bd66027?source=collection_archive---------17-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/31abaa0b0f920b25319618731b58e5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6aGqyM8YqjEHTZVAb34-8A.jpeg"/></div></div></figure><blockquote class="kb kc kd"><p id="f28d" class="ke kf kg kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这篇文章最初发表在我们的工程博客上。另外，我们正在招聘。</p></blockquote><p id="e278" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们在Truework使用TypeScript，并且非常依赖前端(React)和后端(Django)之间的异步通信。<code class="fe lh li lj lk b"><a class="ae ld" href="https://github.com/truework/gretchen" rel="noopener ugc nofollow" target="_blank">gretchen</a></code>诞生于对现代<code class="fe lh li lj lk b">fetch</code>抽象的需求，这种抽象与打字稿配合得很好。与大多数代码一样，有几种方法可以做到这一点，并且许多现有的解决方案很可能已经进行了改进，以解决我们现在和未来的用例。然而，改造对我们来说就像是一个不完美且复杂的解决方案，解决了一个相当简单的问题:以类型安全的方式使用<code class="fe lh li lj lk b">fetch</code>。</p><p id="7831" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们还需要解决现代web应用程序中的其他一些常见问题:</p><h2 id="abba" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">🔨带提取的奇偶校验</h2><p id="42ba" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated"><code class="fe lh li lj lk b">fetch</code>应用广泛，大部分dev都很熟悉。我们在现有的代码库中非常依赖它，所以我们希望我们的解决方案保留大部分相同的人体工程学，以实现向后兼容性和熟悉性。</p><h2 id="f6a7" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">👷‍♀️弹性</h2><p id="d073" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">我们很早就知道，我们的解决方案需要能够适应网络错误和从遗留API端点返回的不一致响应等情况。<code class="fe lh li lj lk b">gretchen</code>通过超时处理、可配置的重试逻辑和错误规范化内置了这些问题的解决方案。</p><h2 id="c067" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">⚙️浏览器支持</h2><p id="98ac" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">许多用户仍然依赖IE11进行日常工作。我们没有像一些库建议的那样移植另一个现有的解决方案，而是希望从一开始就构建一个考虑到旧浏览器的解决方案。</p><h1 id="8421" class="mj lm it bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated">走向类型安全提取</h1><p id="e57b" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">大多数现代请求抽象都假设不成功(non <code class="fe lh li lj lk b">2xx</code>或<code class="fe lh li lj lk b">3xx</code>)响应是异常，应该抛出异常。因此，大多数文档会使用<code class="fe lh li lj lk b">async/await</code>语法给出涉及<code class="fe lh li lj lk b">Promise.catch</code>或<code class="fe lh li lj lk b">try/catch</code>的例子。</p><p id="4910" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">然而，抛出的异常很难安全地类型化，并且在许多不成功的情况下，我们通常已经知道我们的错误将会是什么形状。</p><p id="c072" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">第一个最常见的选择是返回可以在其上进行断言的类型化数据结构，从而允许TypeScript编译器理解我们正在处理什么。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9976" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这很好，但是它需要一些额外的样板文件和所有可能的错误类型的内部知识。在Truework，我们致力于错误响应形状的标准化，因此在几乎所有情况下，我们都知道我们将得到一个<code class="fe lh li lj lk b">SomeError</code>类型，并且不想每次都检查它。</p><p id="754b" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">第二个最常见的选项很简单:<strong class="kh iu">不要抛出异常。</strong></p><p id="b413" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这实际上是默认情况下<code class="fe lh li lj lk b">fetch</code>的工作方式，不抛出错误也能很好地处理TypeScript。对于给定的端点，我们希望能够概述我们对成功(<code class="fe lh li lj lk b">2xx</code>)和错误(<code class="fe lh li lj lk b">&gt;= 400</code>)响应的期望。如果我们不抛出异常，这个断言可以被抽象出来并自动完成。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ae00" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">这实际上是函数式语言中的一种常见模式，通常使用<code class="fe lh li lj lk b">Either</code>类型。在TypeScript中，这被称为<em class="kg">区分联合</em>。我们实际上实现了自己的版本<code class="fe lh li lj lk b">Either</code>一段时间，并取得了成功。它看起来有点像这样。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fbb1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">虽然我们喜欢这种模式的稳定性，但对于新人来说，它仍然引入了我们认为可以简化的新范式。我们意识到我们可以提炼出一个更简单的模式，在没有异常的情况下仍然保持类型安全。</p><p id="1beb" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">我们使用另一种常见的模式(类似于Go错误处理)而不是返回一个带有方法的对象来检查被区分的并集的类型，并且简单地将并集的两半作为单独的属性返回:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="98cf" class="mj lm it bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated">格雷奇是新来的</h1><p id="2fa5" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">使用<code class="fe lh li lj lk b">gretchen</code>看起来很像使用原生<code class="fe lh li lj lk b">fetch</code>。而不是像这样:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="876c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">你可以这样做:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="95a1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">非<code class="fe lh li lj lk b">GET</code>请求也应该看起来很熟悉:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c6e1" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">在内部，<code class="fe lh li lj lk b">gretchen</code>处理<code class="fe lh li lj lk b">fetch</code>通常需要的大部分样板文件。对我们来说，它被证明是满足我们需求的适量抽象。我们获得了最大的灵活性以及一些细微之处，例如:</p><h2 id="13a6" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">👉配置JSON主体</h2><p id="3c9b" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated"><code class="fe lh li lj lk b">gretchen</code>当然支持一个<code class="fe lh li lj lk b">body</code>属性，但是如果你正在发送JSON，它通过<code class="fe lh li lj lk b">json</code>属性提供一个简写，如上所示。这将字符串化您传递的对象，并配置用于发送JSON的<code class="fe lh li lj lk b">Content-Type</code>头。</p><h2 id="c33e" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">👉自动重试一些失败的请求</h2><p id="2909" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">请求经常由于网络问题或服务器负载等原因而失败。默认情况下，<code class="fe lh li lj lk b">gretchen</code>将重试两次返回<code class="fe lh li lj lk b">408</code>、<code class="fe lh li lj lk b">413</code>或<code class="fe lh li lj lk b">429</code>的<code class="fe lh li lj lk b">GET</code>请求。您可以使用options对象配置重试次数，以及触发重试的请求方法和状态代码。如果你的服务器返回一个<code class="fe lh li lj lk b">Retry-After</code>头，<code class="fe lh li lj lk b">gretchen</code>也会考虑这个延迟。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="91bc" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">👉处理请求超时</h2><p id="3b8f" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">默认情况下，<code class="fe lh li lj lk b">gretchen</code>会自动将一个请求超时10秒，如果它满足您指定的<code class="fe lh li lj lk b">retry</code>标准，就会重试。你也可以配置超时，比如说，允许上传一个大文件。</p><h2 id="f27c" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">👉解析响应正文</h2><p id="6986" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated"><code class="fe lh li lj lk b">gretchen</code>在所有体接口方法之上提供一个接口:<code class="fe lh li lj lk b">arrayBuffer</code>、<code class="fe lh li lj lk b">blob</code>、<code class="fe lh li lj lk b">formData</code>、<code class="fe lh li lj lk b">json</code>和<code class="fe lh li lj lk b">text</code>。例如，代替这个:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f628" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">您可以这样做:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="2700" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">👉捕捉异常</h2><p id="24a4" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated"><code class="fe lh li lj lk b">gretchen</code>不为失败的HTTP请求抛出异常，但也不会为其他常见的API问题抛出异常，比如端点返回无效的JSON。在这样的边缘情况下，<code class="fe lh li lj lk b">gretchen</code>将保留成功请求的状态，但是用发生的解析异常填充<code class="fe lh li lj lk b">error</code>属性。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="a50d" class="ll lm it bd ln lo lp dn lq lr ls dp lt le lu lv lw lf lx ly lz lg ma mb mc md bi translated">👉提供全局可配置性</h2><p id="d70d" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">除了传递请求级别选项覆盖之外，<code class="fe lh li lj lk b">gretchen</code>还导出了一个<code class="fe lh li lj lk b">create</code>工厂，您可以在其中提供默认选项，如头文件。这也是利用<code class="fe lh li lj lk b">gretchen</code>的<em class="kg">钩子</em>概念的好地方，钩子在请求生命周期的不同部分触发。这些使得为应用程序中的每个请求提供错误记录和调试代码变得容易。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="482e" class="mj lm it bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated">格雷琴+打字稿= 🥰</h1><p id="28fd" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">在TypeScript项目中键入响应和错误对象很简单，只需告诉<code class="fe lh li lj lk b">gretch</code>您所期望的。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4315" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">因为<code class="fe lh li lj lk b">gretchen</code>返回一个<code class="fe lh li lj lk b">error</code>或<code class="fe lh li lj lk b">data</code>，所以您需要做一个检查来提示TypeScript编译器您正在使用哪个对象:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="dadc" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">键入错误响应同样简单，只需将错误类型作为第二个类型参数传递:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e350" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">总的来说，用法如下:</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="2e45" class="mj lm it bd ln mk nn mm lq mn no mp lt mq np ms lw mt nq mv lz mw nr my mc mz bi translated">包扎</h1><p id="5bb1" class="pw-post-body-paragraph ke kf it kh b ki me kk kl km mf ko kp le mg ks kt lf mh kw kx lg mi la lb lc im bi translated">已经有很多很棒的<code class="fe lh li lj lk b">fetch</code>实现了，所以请允许我用这个来总结这篇文章:<code class="fe lh li lj lk b">gretchen</code>对我们有用，也可能对你有用。它为最大的灵活性提供了最小的抽象，同时实现了其弹性和浏览器支持的目标。但是你应该使用你觉得舒服的或者最适合你的项目的东西。</p><p id="928c" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><code class="fe lh li lj lk b">gretchen</code>也处于早期阶段。我们正在Truework的生产中使用它——大约每月600万次请求——但是随着它的成熟，有些事情可能会改变。</p><p id="1c55" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated">如果你想试用或投稿，请访问我们的<a class="ae ld" href="https://github.com/truework/gretchen" rel="noopener ugc nofollow" target="_blank"> Github页面</a>。我们希望收到您的来信:)</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="e615" class="pw-post-body-paragraph ke kf it kh b ki kj kk kl km kn ko kp le kr ks kt lf kv kw kx lg kz la lb lc im bi translated"><strong class="kh iu">附:我们正在招聘！查看我们的<a class="ae ld" href="https://www.truework.com/careers/" rel="noopener ugc nofollow" target="_blank">职业页面</a>。</strong></p></div></div>    
</body>
</html>