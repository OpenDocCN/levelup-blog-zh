<html>
<head>
<title>Dockerized 🐳 Flask Celery RabbitMQ Redis Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">记录在案的🐳烧瓶芹菜兔Redis的应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dockerized-flask-celery-rabbitmq-redis-application-df74c837a0a1?source=collection_archive---------2-----------------------#2021-11-04">https://levelup.gitconnected.com/dockerized-flask-celery-rabbitmq-redis-application-df74c837a0a1?source=collection_archive---------2-----------------------#2021-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/186575edcf88fea90fb5a7ea958d79b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jSKd2tBYO5Ui09dc.gif"/></div></div></figure><p id="11c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这解释了如何配置Flask、Celery、RabbitMQ和Redis以及Docker来构建一个web服务，该服务动态地上传内容并在准备好显示内容时加载该内容。我们将主要关注芹菜和围绕它的服务。Docker更简单一点。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="c7b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">视频解释</p><figure class="ld le lf lg gt jr"><div class="bz fp l di"><div class="lh li l"/></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="830b" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">项目结构</h1><p id="1750" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">完成的项目结构如下:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="d0fe" class="mr lk iq mn b gy ms mt l mu mv">├── Dockerfile<br/>├── docker-compose.yml<br/>├── README.md<br/>├── app<br/>│ ├── app.py<br/>│ ├── tasks.py<br/>│ └── templates<br/>│ ├── download.html<br/>│ └── index.html<br/>├── scripts<br/>│ ├── run_celery.sh<br/>│ └── run_web.sh<br/>└── requirements.txt</span></pre><h1 id="6bec" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">创建Flask应用程序🌶</h1><p id="8a9f" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">首先，我们为我们的应用程序创建一个文件夹。对于本例，我们的文件夹名为“app”。在这个文件夹中，创建一个“app.py”文件和一个名为“templates”的空文件夹，我们的HTML模板将存储在这个文件夹中。</p><p id="44f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的应用程序，我们首先包括一些基本的Flask库，并创建应用程序的一个实例:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="2ab6" class="mr lk iq mn b gy ms mt l mu mv">from io import BytesIO<br/>from flask import Flask, request<br/>from flask import render_template, make_response<br/>APP = Flask(__name__)</span></pre><p id="5ab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们为Flask定义了三个实现路径:一个登录页面，一个嵌入图片的二级页面，以及一个图片本身的路径。我们的图像路径动态地裁剪图像。对于这个例子，它使用“枕头”裁剪图像，并且还包括一些延迟，以便创建图像所花费的时间更明显。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="d3fb" class="mr lk iq mn b gy ms mt l mu mv"><a class="ae nb" href="http://twitter.com/APP" rel="noopener ugc nofollow" target="_blank">@APP</a>.route(‘/’)<br/>def index():<br/>   return render_template(‘index.html’)<br/><a class="ae nb" href="http://twitter.com/APP" rel="noopener ugc nofollow" target="_blank">@APP</a>.route(‘/image_page’)<br/>def image_page():<br/>   job = tasks.get_data_from_strava.delay()<br/>   return render_template(‘home.html’)<br/><a class="ae nb" href="http://twitter.com/APP" rel="noopener ugc nofollow" target="_blank">@APP</a>.route('/result.png')<br/>def result():<br/>   '''<br/>   Pull our generated .png binary from redis and return it<br/>   '''<br/>   jobid = request.values.get('jobid')<br/>   if jobid:<br/>      job = tasks.get_job(jobid)<br/>      png_output = job.get()<br/>      png_output="../"+png_output<br/>      return png_output<br/>   else:<br/>      return 404</span></pre><p id="7250" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们需要打开“templates”文件夹，创建以下两个模板:</p><p id="841e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">index.html</strong></p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="faf3" class="mr lk iq mn b gy ms mt l mu mv">&lt;div id=”imgpl”&gt;&lt;img src=”result.png?{{JOBID}}” /&gt;&lt;/div&gt;</span></pre><p id="7a5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们添加以下代码，然后运行脚本，我们可以加载我们的网页，并测试图像生成。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="048b" class="mr lk iq mn b gy ms mt l mu mv">if __name__ == ‘__main__’:<br/>   APP.run(host=’0.0.0.0')</span></pre><p id="130f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看到我们的页面加载需要一段时间才能完成，因为对“result.png”的请求直到图像生成完成后才返回。</p><h1 id="4691" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">扩展我们的网络应用程序，使用芹菜🥬</h1><p id="451a" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">在我们的“app”目录中，创建包含我们的芹菜任务的“tasks.py”文件。我们添加的必要芹菜包括:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="21b5" class="mr lk iq mn b gy ms mt l mu mv">from celery import Celery, current_task<br/>from celery.result import AsyncResult</span></pre><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b619cd06e4c21c352621cccc5872c72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/0*zgZtNf7st25A-BGL.png"/></div></figure><p id="29e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们的RabbitMQ服务在一个我们可以通过“rabbit”引用的主机上，我们的Redis服务在一个通过“Redis”引用的主机上，我们可以使用下面的代码创建一个Celery的实例:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="3a84" class="mr lk iq mn b gy ms mt l mu mv">REDIS_URL = ‘redis://redis:6379/0’<br/>BROKER_URL = ‘amqp://admin:mypass@rabbit//’CELERY = Celery(‘tasks’,backend=REDIS_URL,broker=BROKER_URL)</span></pre><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/78f16736b7c4beb4935a0b8524e209d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X9b0N6YlQyUixyb0.png"/></div></div></figure><p id="8a73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们需要更改结果的默认序列化程序。芹菜4.0及以上版本使用JSON作为序列化器，不支持二进制数据的序列化。我们可以切换回旧的默认序列化器(pickle ),或者使用支持二进制数据并且非常高效的新MessagePack。</p><p id="b577" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们正在更改序列化程序，所以我们还需要告诉Celery接受来自非默认序列化程序的结果(以及仍然接受来自JSON的结果)。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="e8c4" class="mr lk iq mn b gy ms mt l mu mv">CELERY.conf.accept_content = [‘json’, ‘msgpack’]<br/>CELERY.conf.result_serializer = ‘msgpack’</span></pre><p id="a66b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将实现一个返回给定ID的作业的函数。这使得我们的应用程序和芹菜任务可以相互交流:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="6591" class="mr lk iq mn b gy ms mt l mu mv">def get_job(job_id):<br/> return AsyncResult(job_id, app=CELERY)</span></pre><p id="375c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们定义异步函数，将图像生成代码从“app.py”中移出，并添加允许该方法排队等待执行的函数装饰器:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="e8b4" class="mr lk iq mn b gy ms mt l mu mv"><a class="ae nb" href="http://twitter.com/CELERY" rel="noopener ugc nofollow" target="_blank">@CELERY</a>.task()<br/>def image_demension(img):<br/>   time.sleep(2)<br/>   im = Image.open(img)<br/>   width, height = im.size<br/>   left = 4<br/>   top = height / 5<br/>   right = 154<br/>   bottom = 3 * height / 5<br/>   # Cropped image of above dimension \<br/>   im1 = im.crop((left, top, right, bottom))<br/>   newsize = (300, 300)<br/>   im1 = im1.resize(newsize)<br/>   width, height = im1.size<br/>   location=os.path.join(‘static/worker-img’,’cropped_img.’+im.format.lower())<br/>    im1.save(os.path.join(‘static/worker-img’,’cropped_img.’+im.format.lower()))<br/>   print(width,height)<br/>   print(“pass”)<br/>   return location</span></pre><p id="41b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们没有构建响应，而是返回存储在Redis上的二进制图像。我们还用进度指示器在不同点更新任务，进度指示器可以从Flask应用程序中查询。</p><p id="46f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们向“app.py”添加了一个新的路由，它检查进度并以JSON对象的形式返回状态，这样我们就可以编写一个ajax函数，当最终图像准备就绪时，我们的客户端可以在加载它之前进行查询。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="ef49" class="mr lk iq mn b gy ms mt l mu mv"><a class="ae nb" href="http://twitter.com/APP" rel="noopener ugc nofollow" target="_blank">@APP</a>.route(‘/progress’)<br/>def progress():<br/>   jobid = request.values.get(‘jobid’)<br/>   if jobid:<br/>   job = tasks.get_job(jobid)<br/>   if job.state == ‘PROGRESS’:<br/>   return json.dumps(dict(<br/>      state=job.state,<br/>      progress=job.result[‘current’],<br/>   ))<br/>   elif job.state == ‘SUCCESS’:<br/>   return json.dumps(dict( <br/>      state=job.state,<br/>      progress=1.0,<br/>   ))<br/>return ‘{}’</span></pre><p id="319c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用以下Javascript代码扩展我们的“templates/download.html ”:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="a2ef" class="mr lk iq mn b gy ms mt l mu mv">&lt;script src=”//code.jquery.com/jquery-2.1.1.min.js”&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>function poll() {<br/>   $.ajax(“{{url_for(‘.progress’, jobid=JOBID)}}”, {<br/>      dataType: “json”<br/>     , success: function(resp) {<br/>     if(resp.progress &gt;= 0.99) {<br/>         $(“#wrapper”).html(‘’);<br/>         $.get(“result.png?jobid={{JOBID}}”, function(data, status){<br/>            end_file=data;  <br/>            $(“#imgpl”).html(‘&lt;img src=’+end_file+’&gt;’);<br/>            console.log(“success”)<br/>          });<br/>      return;<br/>     }<br/>     else {<br/>        setTimeout(poll, 500.0);  <br/>     }<br/>   } <br/>  });<br/>}<br/>$(function() {<br/>   var JOBID = “{{ JOBID }}”;<br/>   poll();<br/>});<br/>&lt;/script&gt;</span></pre><p id="e987" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“投票”功能反复要求我们的web应用程序的“进度”路径。当它报告图像已经生成时，它用图像的URL替换占位符中的HTML代码，然后从我们修改的`/result.png '路径动态加载图像:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="ac2d" class="mr lk iq mn b gy ms mt l mu mv"><a class="ae nb" href="http://twitter.com/APP" rel="noopener ugc nofollow" target="_blank">@APP</a>.route(‘/result.png’)<br/>def result():<br/>‘’’<br/>Pull our generated .png and return it<br/>‘’’<br/>   jobid = request.values.get(‘jobid’)<br/>   if jobid:<br/>   job = tasks.get_job(jobid)<br/>   png_output = job.get()<br/>   png_output=”../”+png_output<br/>   return png_output<br/>   else:<br/>   return 404</span></pre><p id="7f89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个阶段，我们有了一个带有异步图像生成的工作web应用程序。</p><p id="b1a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Docker打包我们的应用程序🐳</p><p id="6c61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用程序需要4个独立的容器来容纳我们的每项服务:</p><p id="f947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">烧瓶</p><p id="1242" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">芹菜</p><p id="0438" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-兔子q🐇</p><p id="2d21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-雷迪斯</p><p id="6336" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker为[rabbit MQ](https://hub . docker . com/_/rabbit MQ/)和[Redis](https://hub . docker . com/_/Redis/)提供了预构建的容器。这两个都工作得很好，我们将使用它们。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/d339893f0a1d7826cde19c6db4b231ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VndYfGSp_b-fyCFH.png"/></div></div></figure><p id="3191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于Flask和Celery，我们将从一个简单的“Dockerfile”构建两个相同的容器。</p><p id="5171" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dockerfile文件</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="0df5" class="mr lk iq mn b gy ms mt l mu mv"># Pull the latest version of the Python container.<br/>FROM python:latest<br/># Add the requirements.txt file to the image.<br/>ADD requirements.txt /app/requirements.txt<br/># Set the working directory to /app/.<br/>WORKDIR /app/<br/># Install Python dependencies.<br/>RUN pip install -r requirements.txt<br/># Create an unprivileged user for running our Python code.<br/>RUN adduser — disabled-password — gecos ‘’ app</span></pre><p id="3b9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用Docker组合文件“docker-sdfcompose.yml”将所有这些整合在一起。虽然早期版本的组合文件需要为每个服务提供端口，但我们可以使用“links”关键字将服务链接在一起。“depends”关键字确保我们的所有服务以正确的顺序启动。</p><p id="ae54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">docker-compose.yaml</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="2593" class="mr lk iq mn b gy ms mt l mu mv">version: '3'<br/>services:<br/>  redis:<br/>    image: redis:latest<br/>    hostname: redis<br/>  rabbit:<br/>    hostname: rabbit<br/>    image: rabbitmq:latest<br/>    environment:<br/>      - RABBITMQ_DEFAULT_USER=admin<br/>      - RABBITMQ_DEFAULT_PASS=mypass<br/>  web:<br/>    build:<br/>      context: .<br/>      dockerfile: Dockerfile<br/>    hostname: web<br/>    command: ./scripts/run_web.sh<br/>    volumes:<br/>      - .:/app<br/>    ports:<br/>      - "5000:5000"<br/>    links:<br/>      - rabbit<br/>      - redis<br/>  worker:<br/>    build:<br/>      context: .<br/>      dockerfile: Dockerfile<br/>    command: ./scripts/run_celery.sh<br/>    volumes:<br/>      - .:/app<br/>    links:<br/>      - rabbit<br/>      - redis<br/>    depends_on:<br/>      - rabbit</span></pre><p id="8d9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建和运行容器，请使用:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="e24e" class="mr lk iq mn b gy ms mt l mu mv">docker-compose builddocker-compose up</span></pre><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/123f7db3be6ea41a368933aa43bf611e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IL2cdYjlrjPo1wRd.png"/></div></div></figure><p id="3db5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker的主要好处之一是，如果需要，我们可以运行一个容器的多个实例。要运行芹菜消费者的多个实例，请执行以下操作:</p><p id="0c39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">码头工人-撰写规模工人=N</p><p id="7eb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中N是所需的后端工作节点数。请访问http://localhost:5000 查看我们的完整申请。🥳</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/269b7df5214746120870051f06637fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/0*L7NnGj2-GjiPn79m.png"/></div></figure><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/9eb5c85e9948d23604b171d9d6a5eb18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/0*hmIoltx693On20BL.png"/></div></figure><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e88593173cd1cd1d12cbd1d28187a34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/0*Uqj0pCFJ0QcCA2PM.png"/></div></figure><h1 id="1682" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">github</h1><div class="nh ni gp gr nj nk"><a href="https://github.com/alvisf/Dockerized-Flask-Celery-RabbitMQ-Redis" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">alvisf/dockered-Flask-芹菜-RabbitMQ-Redis</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">这解释了如何配置Flask、Celery、RabbitMQ和Redis以及Docker来构建一个web服务…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jw nk"/></div></div></a></div><h1 id="824f" class="lj lk iq bd ll lm mw lo lp lq mx ls lt lu my lw lx ly mz ma mb mc na me mf mg bi translated">结论🤝</h1><p id="ea36" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">这是一个简单的概念验证，说明如何将所有东西结合在一起使用，并启动和运行异步功能。</p></div></div>    
</body>
</html>