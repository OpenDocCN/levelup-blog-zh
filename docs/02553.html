<html>
<head>
<title>Introduction to GraphQL — Variables and Complex Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL简介—变量和复杂运算</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-graphql-variables-and-complex-operations-2065d8cd2377?source=collection_archive---------7-----------------------#2020-03-21">https://levelup.gitconnected.com/introduction-to-graphql-variables-and-complex-operations-2065d8cd2377?source=collection_archive---------7-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/677794e13df1cb4b689893c1018e63b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8vOKGxji3kvn3KQh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@eprouzet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Eric Prouzet </a>拍摄于<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="93d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphQL是我们的API的一种查询语言，也是一个服务器端运行时，通过使用数据的类型系统来运行查询。</p><p id="e840" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究更复杂的GraphQL操作，包括传入变量、指令、突变等等。</p><h1 id="0370" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">变量</h1><p id="ddba" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在大多数应用程序中，查询的参数需要是动态的。将动态参数直接传递给查询字符串并不是一个好主意。</p><p id="5ac8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，GraphQL允许我们在操作请求中传递变量。</p><p id="69c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c731" class="mq lf it mm b gy mr ms l mt mu">query PersonName($id: Int) {<br/>  person(id: $id) {<br/>    name<br/>  }<br/>}</span></pre><p id="3b3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将一个<code class="fe mv mw mx mm b">$id</code>变量传入我们的<code class="fe mv mw mx mm b">person</code>查询。</p><p id="0238" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过一个对象传入变量来发出请求:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6f29" class="mq lf it mm b gy mr ms l mt mu">{<br/>  "id": 1000<br/>}</span></pre><p id="1361" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会得到这样的结果:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a0fd" class="mq lf it mm b gy mr ms l mt mu">{<br/>  "data": {<br/>    "person": {<br/>      "name": "Jane"<br/>    }<br/>  }<br/>}</span></pre><p id="ff5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为回应。</p><h1 id="edef" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">变量定义</h1><p id="7d71" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">变量定义以前缀为<code class="fe mv mw mx mm b">$</code>的变量名开始，然后是变量的类型。</p><p id="4e94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们用<code class="fe mv mw mx mm b">$id</code>作为变量名，用<code class="fe mv mw mx mm b">Int</code>作为类型。</p><p id="8960" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有声明的变量必须是标量、枚举或其他输入对象类型。</p><p id="af18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想将一个复杂的对象传递到一个字段中，我们需要知道服务器上匹配的输入类型。</p><h1 id="5840" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">默认变量</h1><p id="c525" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以如下设置变量的默认值:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="31f0" class="mq lf it mm b gy mr ms l mt mu">query PersonName($id: Int = 1) {<br/>  person(id: $id) {<br/>    name<br/>  }<br/>}</span></pre><p id="5ce3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe mv mw mx mm b">$id: Int</code>后添加了<code class="fe mv mw mx mm b">= 1</code>，将<code class="fe mv mw mx mm b">$id</code>的默认值设置为1。</p><h1 id="8609" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">指令</h1><p id="9dd5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用指令来动态地改变使用变量的查询的结构和形状。</p><p id="9dab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以包含如下指令，使我们的查询是动态的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="337a" class="mq lf it mm b gy mr ms l mt mu">query Person($id: Int, $withFriends: Boolean!) {<br/>  person(id: $id) {<br/>    name<br/>    friends @include(if: $withFriends) {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="c83b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，如果<code class="fe mv mw mx mm b">$withFriends</code>是<code class="fe mv mw mx mm b">true</code>，我们有<code class="fe mv mw mx mm b">@include(if: $withFriends)</code>指令来有条件地包含<code class="fe mv mw mx mm b">friends</code>。</p><p id="3807" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们使用以下变量进行以下查询:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1717" class="mq lf it mm b gy mr ms l mt mu">{<br/>  "id": 1000,<br/>  "withFriends": false<br/>}</span></pre><p id="e632" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可能会得到这样的结果:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2153" class="mq lf it mm b gy mr ms l mt mu">{<br/>  "data": {<br/>    "person": {<br/>      "name": "Jane"<br/>    }<br/>  }<br/>}</span></pre><p id="bd34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为回应。</p><p id="cfeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">指令可以附加到字段或片段包含中，并且可以以服务器期望的任何方式影响查询的执行。</p><p id="3abf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">核心的GraphQL规范包括两个指令，任何符合规范的GraphQL服务器实现都必须支持这两个指令:</p><ul class=""><li id="da69" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">@include(if: Boolean)</code> —仅在参数if <code class="fe mv mw mx mm b">true</code>时包含该字段。</li><li id="eb58" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe mv mw mx mm b">@skip(if: Boolean)</code> —如果参数为<code class="fe mv mw mx mm b">true</code>，则跳过此字段。</li></ul><p id="747b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它帮助我们摆脱了在查询中添加和删除字段时必须进行字符串操作的情况。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/eec6450ef6b00459e4eee62bc3cd087a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qfTSGUqpUBBJpbDC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@les_photos_de_raph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">raphal Biscaldi</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4243" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">突变</h1><p id="5178" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用突变发送请求来改变服务器上的数据。</p><p id="7bc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们类似于查询，除了它以关键字<code class="fe mv mw mx mm b">mutation</code>开始。</p><p id="405e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下定义突变:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ea06" class="mq lf it mm b gy mr ms l mt mu">mutation CreatePerson($firstName: String, $lastName: String) {<br/>  createPerson(firstName: $firstName, lastName: $lastName) {<br/>    firstName<br/>    lastName<br/>  }<br/>}</span></pre><p id="416a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们进行以下查询:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ebf2" class="mq lf it mm b gy mr ms l mt mu">{<br/>  "firstName": "Joe",<br/>  "lastName": "Smith"<br/>}</span></pre><p id="4336" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能会得到以下回应:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9b07" class="mq lf it mm b gy mr ms l mt mu">{<br/>  "data": {<br/>    "createPerson": {<br/>      "firstName": "Joe",<br/>      "lastName": "Smith"<br/>    }<br/>  }<br/>}</span></pre><p id="57c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在响应中，我们返回请求中指定的<code class="fe mv mw mx mm b">firstName</code>和<code class="fe mv mw mx mm b">lastName</code>字段。</p><p id="1625" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像查询一样，一个变异可以包含多个字段。突变字段连续运行。</p><p id="9415" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着如果我们在一个请求中发送2个<code class="fe mv mw mx mm b">createPerson</code>突变。第一个会在第二个开始之前结束。</p><h1 id="5a6e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">内嵌片段</h1><p id="95be" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用GraphQL请求定义接口和联合类型。</p><p id="d349" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们使用内联片段来访问底层具体类型上的数据。</p><p id="5576" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下查询:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0ae7" class="mq lf it mm b gy mr ms l mt mu">query Thing($id: Int!) {<br/>  person(id: $id) {<br/>    name<br/>    ... on Person{<br/>      gender<br/>    }<br/>    ... on Robot{<br/>      memory<br/>    }<br/>  }<br/>}</span></pre><p id="c322" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的查询中，<code class="fe mv mw mx mm b">...on</code>操作符表示我们在查询中包含了一个内联片段，其中<code class="fe mv mw mx mm b">Person</code>和<code class="fe mv mw mx mm b">Robot</code>是我们的片段。</p><p id="2c69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">命名片段也可以是内联片段，因为它们附加了一个类型。</p><h1 id="077b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">元字段</h1><p id="d911" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以请求一个<code class="fe mv mw mx mm b">__typename</code>字段来获取响应中返回的数据类型。</p><p id="9478" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下查询:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5a61" class="mq lf it mm b gy mr ms l mt mu">{<br/>  search(text: "an") {<br/>    __typename<br/>    ... on Human {<br/>      name<br/>    }<br/>    ... on Robot {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="bfdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可能会从服务器得到以下响应:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6559" class="mq lf it mm b gy mr ms l mt mu">{<br/>  "data": {<br/>    "search": [<br/>      {<br/>        "__typename": "Human",<br/>        "name": "Hans"<br/>      },<br/>      {<br/>        "__typename": "Robot",<br/>        "name": "Jane"<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><h1 id="6e8b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="c4a6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以定义突变来请求改变数据。</p><p id="7931" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使请求动态化，我们可以使用变量来包含变量数据，并使用指令在响应中有条件地包含数据。</p><p id="7371" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以对联合类型使用内联片段，并通过包含<code class="fe mv mw mx mm b">__typename</code>属性在响应中包含返回的数据类型。</p></div></div>    
</body>
</html>