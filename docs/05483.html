<html>
<head>
<title>Build an ARIMA Model to Predict a Stock’s Price</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立一个ARIMA模型来预测股票价格</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-an-arima-model-to-predict-a-stocks-price-c9e1e49367d3?source=collection_archive---------4-----------------------#2020-09-02">https://levelup.gitconnected.com/build-an-arima-model-to-predict-a-stocks-price-c9e1e49367d3?source=collection_archive---------4-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b161" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个博客将教你如何提取必要的数据，并创建一个预测标准普尔500价格的模型！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ab90122b07d41d38583621991b0c97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRuguxwiKgPfAYCpm9qygg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com/s/photos/stock-market?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="987d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">前言</h1><p id="5a2f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你正在读这篇文章，很可能是因为你喜欢解谜。我天生是一个非常好胜的人。谜题的珠穆朗玛峰，在我看来，就是试图通过股市的活跃交易来寻找超额收益。这篇博客是我尝试——希望——登上算法交易的令人生畏的珠穆朗玛峰并盈利的第一篇文章。</p><p id="93b8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我必须赎罪。<strong class="lt iu">我是一个失败的日内交易者。在一个夏天的工作间隙，我尝试了日内交易。我读过的所有东西都告诉我在交易前要有计划，当我真的交易时，不管我的情绪如何，都要坚持我的交易计划。我确信这不成问题。我对自己所有的恶习都了如指掌——不是吗？如果你是人类，那么答案是否定的。不，你无法控制你的恶习。这是老虎钳的字面定义。我太天真了，谢天谢地，我在对我的账户造成任何实际损害之前就退出了。然而，就像飞蛾扑火一样，我不能留下一个好的谜题。我将重返战场，但这次我有一个计划。我计划建立一个纯粹的量化系统，把交易计划中最糟糕的部分(你自己)从等式中去掉。</strong></p><p id="84c0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在你继续说下去之前，让我说这篇博文仅仅是关于ARIMA模型的，这篇序言只是未来完整算法交易系统的一个预告片。如果介绍没有吓退你，让我们从一个简单的ARIMA模型开始，它可以帮助我们预测你选择的任何股票明天的每日收盘价。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="81c7" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">让我们编码</h1><p id="e224" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">ARIMA是首字母缩写，代表自回归综合移动平均线。在这篇博客中，我将分解实施一个成功的ARIMA模式的必要步骤。</p><h2 id="e0c5" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">第一步:获取数据</h2><p id="48ec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于这个例子，我们将使用间谍ETF。SPY是一种模仿S&amp;P500的ETF，后者是一篮子按市值加权的股票。许多ETF模仿标准普尔500，但这是最常见和最具流动性的基金。</p><p id="0028" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了使用它，我们将使用yfinance API。如果你没有安装这个API，在你的Jupyter笔记本上安装一个简单的pip就可以了。如果你想了解更多关于这个API的信息，<a class="ae ky" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank">查看PyPI页面了解更多细节</a>。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="19e2" class="ne la it nr b gy nv nw l nx ny">!pip install yfinance</span></pre><p id="c28d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，让我们将股票“间谍”的全部每日历史放入一个整洁的数据框架中。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="4235" class="ne la it nr b gy nv nw l nx ny">import yfinance as yf<br/>import pandas as pd</span><span id="e0e3" class="ne la it nr b gy nz nw l nx ny">spy = yf.Ticker("SPY")</span><span id="278b" class="ne la it nr b gy nz nw l nx ny"># get stock info<br/>spy.info</span><span id="ae78" class="ne la it nr b gy nz nw l nx ny"># get historical market data as df<br/>hist = spy.history(period="max")</span><span id="c1bc" class="ne la it nr b gy nz nw l nx ny"># Save df as CSV<br/>hist.to_csv('SPY.csv')</span><span id="480f" class="ne la it nr b gy nz nw l nx ny"># Read back in as dataframe<br/>spy = pd.read_csv('SPY.csv')</span><span id="4aa9" class="ne la it nr b gy nz nw l nx ny"># Convert Date column to datetime<br/>spy['Date'] = pd.to_datetime(spy['Date'])</span></pre><p id="862b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你打印出“spy.info ”,你会得到一个包含大量股票额外数据的字典。我们目前担心的只是这款车型的收盘价。对象“hist”是一个数据帧，我们将它发送给CSV以获得一个本地副本。如果你想的话，你可以在每天收盘后运行这个程序，获得最新的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b4a3847813bbc67fb205845cb1ea7657.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*dacAP4_73eNuaEY5MMlTdw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">间谍的价格历史</figcaption></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="5492" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">步骤2:拆分数据</h2><p id="9791" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这段代码直接来自我的笔记本，其中有多个型号，所以数据分割可能看起来有点大材小用。对于纯粹的ARIMA模型，您只需要一个训练和测试数据集。然而，我提供的代码将数据分割成一个训练、测试和验证数据集。在所有的机器学习应用中，拆分数据是非常重要的。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="1894" class="ne la it nr b gy nv nw l nx ny"># Set target series<br/>series = spy['Close']</span><span id="616f" class="ne la it nr b gy nz nw l nx ny"># Create train data set<br/>train_split_date = '2014-12-31'<br/>train_split_index = np.where(spy.Date == train_split_date)[0][0]<br/>x_train = spy.loc[spy['Date'] &lt;= train_split_date]['Close']</span><span id="7efe" class="ne la it nr b gy nz nw l nx ny"># Create test data set<br/>test_split_date = '2019-01-02'<br/>test_split_index = np.where(spy.Date == test_split_date)[0][0]<br/>x_test = spy.loc[spy['Date'] &gt;= test_split_date]['Close']</span><span id="9015" class="ne la it nr b gy nz nw l nx ny"># Create valid data set<br/>valid_split_index = (train_split_index.max(),test_split_index.min())<br/>x_valid = spy.loc[(spy['Date'] &lt; test_split_date) &amp; (spy['Date'] &gt; train_split_date)]['Close']</span><span id="f8f9" class="ne la it nr b gy nz nw l nx ny">#printed index values are: <br/>#0-5521(train), 5522-6527(valid), 6528-6947(test)</span></pre><p id="7bc1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我相当随意地选择了这些日期。你可以随意把它们改成你想要的。现在，让我们画出一幅我们的数据是如何分割的图。下图显示了如何通过区分颜色来分割数据。请记住，我们提取了每日数据，因此每个时间步长相当于1天。图中的数据跨度从1993年1月到2020年9月1日。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0a5c94e0d490b6b9c23fcf1e2ecbaf11.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*XJrZeEMKonyj0Y0g5-9SAA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">截至2020年9月1日的“间谍”ETF历史图</figcaption></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="937c" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">步骤3:测试数据是否稳定</h2><p id="ff9b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我可以省去这一步，告诉你如果你在看一个股票价格，它很可能不会是平稳的。这是因为，一般来说，股票价格会随着时间的推移而上涨。如果您有不稳定的数据，数据的平均值会随着时间的推移而增长，这会导致模型的退化。</p><p id="bb3a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相反，<strong class="lt iu">你应该预测一只股票收盘价的日回报率，而不是实际价格本身。</strong>为了测试数据是否平稳，我们使用了扩展的Dickey-Fuller测试。这里有一段代码可以帮助加速这个过程。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="284d" class="ne la it nr b gy nv nw l nx ny">from statsmodels.tsa.stattools import adfuller</span><span id="3557" class="ne la it nr b gy nz nw l nx ny">def test_stationarity(timeseries, window = 12, cutoff = 0.01):</span><span id="0ce6" class="ne la it nr b gy nz nw l nx ny">#Determing rolling statistics</span><span id="62c7" class="ne la it nr b gy nz nw l nx ny">rolmean = timeseries.rolling(window).mean()</span><span id="c33a" class="ne la it nr b gy nz nw l nx ny">rolstd = timeseries.rolling(window).std()</span><span id="648d" class="ne la it nr b gy nz nw l nx ny">#Plot rolling statistics:</span><span id="8aed" class="ne la it nr b gy nz nw l nx ny">fig = plt.figure(figsize=(12, 8))</span><span id="da1f" class="ne la it nr b gy nz nw l nx ny">orig = plt.plot(timeseries, color='blue',label='Original')</span><span id="d5fd" class="ne la it nr b gy nz nw l nx ny">mean = plt.plot(rolmean, color='red', label='Rolling Mean')</span><span id="b0dd" class="ne la it nr b gy nz nw l nx ny">std = plt.plot(rolstd, color='black', label = 'Rolling Std')</span><span id="ae9b" class="ne la it nr b gy nz nw l nx ny">plt.legend(loc='best')</span><span id="7622" class="ne la it nr b gy nz nw l nx ny">plt.title('Rolling Mean &amp; Standard Deviation')</span><span id="3610" class="ne la it nr b gy nz nw l nx ny">plt.show()</span><span id="a7e2" class="ne la it nr b gy nz nw l nx ny">#Perform Dickey-Fuller test:</span><span id="abbf" class="ne la it nr b gy nz nw l nx ny">print('Results of Dickey-Fuller Test:')</span><span id="5880" class="ne la it nr b gy nz nw l nx ny">dftest = adfuller(timeseries, autolag='AIC', maxlag = 20 )</span><span id="0ae4" class="ne la it nr b gy nz nw l nx ny">dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])</span><span id="09f3" class="ne la it nr b gy nz nw l nx ny">for key,value in dftest[4].items():</span><span id="8ccd" class="ne la it nr b gy nz nw l nx ny">dfoutput['Critical Value (%s)'%key] = value</span><span id="4138" class="ne la it nr b gy nz nw l nx ny">pvalue = dftest[1]</span><span id="a44e" class="ne la it nr b gy nz nw l nx ny">if pvalue &lt; cutoff:</span><span id="24fe" class="ne la it nr b gy nz nw l nx ny">print('p-value = %.4f. The series is likely stationary.' % pvalue)</span><span id="1461" class="ne la it nr b gy nz nw l nx ny">else:</span><span id="40f4" class="ne la it nr b gy nz nw l nx ny">print('p-value = %.4f. The series is likely non-stationary.' % pvalue)</span><span id="2a9d" class="ne la it nr b gy nz nw l nx ny">print(dfoutput)</span></pre><p id="41a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">既然你有了这个函数，让我们来使用它。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="a3e3" class="ne la it nr b gy nv nw l nx ny">test_stationarity(series)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/26d3b0ea5c4c3a6d641f9f21e8b71e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCLmQPiL64b5idEBT6In4g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">test _ stationarity()的输出</figcaption></figure><p id="6924" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">获得的<strong class="lt iu"> p值大于0.05的显著性水平，</strong>和<strong class="lt iu"> ADF检验统计量大于任何临界值。没有理由拒绝零假设。<strong class="lt iu">所以，时间序列是非平稳的</strong></strong></p><p id="80fe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如您所看到的，这个函数为您提供了所有必要的信息，以防您忘记。正如我们所想的，数据不是静止的。为了使数据平稳，<strong class="lt iu">我们需要取数据的一阶差分。这只是用昨天的收盘价减去今天的收盘价的一种奇特的说法。</strong>不出所料，熊猫有一个方便的功能可以帮我们做到这一点。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="4b65" class="ne la it nr b gy nv nw l nx ny"># Get the difference of each Adj Close point<br/>spy_close_diff_1 = series.diff()</span><span id="fabb" class="ne la it nr b gy nz nw l nx ny"># Drop the first row as it will have a null value in this column<br/>spy_close_diff_1.dropna(inplace=True)</span></pre><p id="36e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">既然我们已经尝试让我们的数据集保持稳定，让我们测试它以确保稳定。<strong class="lt iu">重新运行test _ stationary(spy _ close _ diff _ 1)。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/47b81d1dd4cf852cd9767e13b0bd83b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CA-FjzR6jGeLeQ03QFpeEA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">间谍ETF的一阶差分</figcaption></figure><p id="4612" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">获得的<strong class="lt iu"> p值小于显著性水平0.05，</strong>并且<strong class="lt iu"> ADF统计低于任何临界值。我们拒绝零假设。<strong class="lt iu">所以，时间序列实际上是平稳的。</strong>最后，我们的数据是静止的，我们可以继续。在某些情况下，您可能需要多次这样做。</strong></p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="de91" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">步骤3:自相关和偏自相关</h2><p id="13a7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">自相关是时间点t (Pₜ)和点at(Pₜ₋₁).之间的相关性偏自相关是时间t点(Pₜ)和k是任意数量滞后的点(Pₜ₋ₖ)。部分自相关忽略两点之间的所有数据。</p><p id="36ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以一个电影院的票房来说，自相关性决定了今天的票房和昨天的票房的关系。相比较而言，偏相关定义了本周五的门票销售和上周五的门票销售之间的关系。</p><p id="5df2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是绘制自相关和偏自相关的快速方法:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="14a5" class="ne la it nr b gy nv nw l nx ny">from statsmodels.graphics.tsaplots import plot_acf,plot_pacf</span><span id="b712" class="ne la it nr b gy nz nw l nx ny">plot_acf(spy_close_diff_1)<br/>plt.xlabel('Lags (Days)')<br/>plt.show()</span><span id="7f6b" class="ne la it nr b gy nz nw l nx ny"># Break these into two separate cells<br/>plot_pacf(spy_close_diff_1)<br/>plt.xlabel('Lags (Days)')<br/>plt.show()</span></pre><div class="kj kk kl km gt ab cb"><figure class="od kn oe of og oh oi paragraph-image"><img src="../Images/0fa2fd2af983c184f06a11cf2ae00a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*YdUXGj6khdKPI4HfixFVwg.png"/></figure><figure class="od kn oe of og oh oi paragraph-image"><img src="../Images/24b48b35de169dc27a0a4308f591d358.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*QsiY3IdvxBa7EFyJXxBFfw.png"/><figcaption class="ku kv gj gh gi kw kx bd b be z dk oj di ok ol translated">自相关和部分自相关图</figcaption></figure></div><p id="f357" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些图看起来几乎一模一样，但事实并非如此。让我们从自相关图开始。这些图的重要细节是第一个滞后。如果第一个滞后为正，我们使用自回归(AR)模型，如果第一个滞后为负，我们使用移动平均(MA)图。<strong class="lt iu">由于第一个滞后为负，第二个滞后为正，我们将使用第一个滞后作为移动平均点。</strong></p><p id="8249" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于PACF图，由于在滞后1时有显著下降，这是负相关的，我们也将使用AR因子1。如果你很难确定什么样的延迟是最好的，请随意尝试，并观看AIC。AIC越低越好。</p><p id="590c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">ARIMA模型将三个主要输入纳入“顺序”论证。这些参数是AR项的“p”，差分项的“d”，MA项的“q”。我们已经确定我们的数据的最佳模型是阶(1，1，1)。同样，您可以随意更改这些数字，并打印出模型的摘要，以查看哪种变化具有最低的AIC。训练时间比较快。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="e01f" class="ne la it nr b gy nv nw l nx ny"># Use this block to<br/>from statsmodels.tsa.arima_model import ARIMA</span><span id="7841" class="ne la it nr b gy nz nw l nx ny"># fit model<br/>spy_arima = ARIMA(x_train, order=(1,1,1))<br/>spy_arima_fit = spy_arima.fit(disp=0)<br/>print(spy_arima_fit.summary())</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="7037" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">第四步:预测</h2><p id="aec9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然您已经找出了哪个模型具有最好的AIC分数，我将使用order = (1，1，1)。让我们使用这个模型对我们的测试数据集进行预测..现在，我确信一定有更快的方法来完成这件事，但这是我的方法。此单元的运行时间可能需要一些时间。<strong class="lt iu">运行时间很长，因为它一次移动一个数据点，重新调整模型并为第二天创建预测。最后一行代码非常关键，因为它是Jupyter Notebook的一个神奇命令，即使你重启笔记本的内核，它也会存储模型预测。这一行将避免您以后必须重新运行该单元格。</strong></p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="fa62" class="ne la it nr b gy nv nw l nx ny"># Create list of x train valuess<br/>history = [x for x in x_train]</span><span id="532c" class="ne la it nr b gy nz nw l nx ny"># establish list for predictions<br/>model_predictions = []</span><span id="7c23" class="ne la it nr b gy nz nw l nx ny"># Count number of test data points<br/>N_test_observations = len(x_test)</span><span id="40fc" class="ne la it nr b gy nz nw l nx ny"># loop through every data point<br/>for time_point in list(x_test.index):<br/>    model = ARIMA(history, order=(1,1,1))<br/>    model_fit = model.fit(disp=0)<br/>    output = model_fit.forecast()<br/>    yhat = output[0]<br/>    model_predictions.append(yhat)<br/>    true_test_value = x_test[time_point]<br/>    history.append(true_test_value)<br/>MAE_error = keras.metrics.mean_absolute_error(x_test, model_predictions).numpy()<br/>print('Testing Mean Squared Error is {}'.format(MAE_error))</span><span id="c96b" class="ne la it nr b gy nz nw l nx ny">%store model_predictions</span></pre><p id="476d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是如何从Jupyter magic命令重新加载存储变量的代码。保存并重新加载您的模型也是最佳实践。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="6846" class="ne la it nr b gy nv nw l nx ny"># %store model_predictions<br/>%store -r model_predictions</span><span id="232f" class="ne la it nr b gy nz nw l nx ny"># Check to see if it reloaded<br/>model_predictions[:5]</span><span id="16e4" class="ne la it nr b gy nz nw l nx ny"># Load model<br/>from statsmodels.tsa.arima.model import ARIMAResults<br/>loaded = ARIMAResults.load('arima_111.pkl')</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h2 id="8b5e" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">步骤5:可视化你的模型</h2><p id="7050" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">查看模型的输出以了解它如何处理数据中的特定情况总是很重要的。您可能会发现一些可能导致模型进一步改进的特殊行为。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="db16" class="ne la it nr b gy nv nw l nx ny">from sklearn.metrics import mean_absolute_value<br/>arima_mae = mean_absolute_error(x_test,model_predictions)<br/>arima_mae</span></pre><p id="310e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于这个模型，我使用平均绝对误差作为损失函数。我喜欢金融模型的这种损失函数，因为它的单位很容易想象。<strong class="lt iu">ARIMA(1，1，1)模型的损失为2.788。这一损失意味着实际值和模型预测值之间的平均差异为2.79美元。</strong>看看这段时间的波动，我想说2.97美元对于我们测试期间的疯狂波动来说并不算太糟糕。让我们绘制图表，看看进一步检查后会是什么样子。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="a2f1" class="ne la it nr b gy nv nw l nx ny">plt.rcParams['figure.figsize'] = [10, 10]</span><span id="6b29" class="ne la it nr b gy nz nw l nx ny">plt.plot(x_test.index[-100:], model_predictions[-100:], color='blue',label='Predicted Price')<br/>plt.plot(x_test.index[-100:], x_test[-100:], color='red', label='Actual Price')<br/>plt.title('SPY Prices Prediction')<br/>plt.xlabel('Date')<br/>plt.ylabel('Prices')<br/># plt.xticks(np.arange(881,1259,50), df.Date[881:1259:50])<br/>plt.legend()<br/>plt.figure(figsize=(10,6))<br/>plt.show()</span></pre><div class="kj kk kl km gt ab cb"><figure class="od kn oe of og oh oi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/77d7186e3379aeef1a38183b337f8e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*13n6H20jhWDOub-TMXiGEw.png"/></div></figure><figure class="od kn oe of og oh oi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/6d23c3a2f07635448a4096557cdd2232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ceogOMaaxxkYAugI0ZSF3A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk oj di ok ol translated">左边是完整的ARIMA模型预测，右边是放大的部分</figcaption></figure></div><p id="5241" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">模型看起来相当不错！查看完整的测试数据集，您看不到我们的预测和实际值之间有任何差距。<strong class="lt iu">即使在面对更复杂的深度学习模型时，这个模型也表现良好。这个模型优于我在相同数据集上构建和训练的许多深度学习模型。</strong></p><h1 id="f04c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="1d0c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">谢谢你能走到这一步并阅读我的博客！我希望你喜欢它，并从中学到一些东西。在将这个模型应用到交易系统之前，还有很多工作要做。</p><p id="8fa7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">典型的交易系统是输出交易信号的多个模型和数据源的集合。理解如何使用你的模型来产生交易信号是很重要的，然后彻底回测你的模型来计算所有的交易成本。只有到那时，你才应该试着在纸上交易账户上实施你的系统，看看效果如何。</p><p id="cb93" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我还没有达到这些下一阶段，但是当我做到的时候，我一定会分享我的发现！</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="72d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="om">领英:</em></p><p id="691b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="http://www.linkedin.com/in/blakesamaha" rel="noopener ugc nofollow" target="_blank"><em class="om">www.linkedin.com/in/blakesamaha</em></a></p><p id="8438" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="om">个人网站:</em></p><p id="d508" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="http://www.aggressiontothemean.com/" rel="noopener ugc nofollow" target="_blank"><em class="om">aggressiontothemean.com</em></a></p><p id="0f0a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="om">推特:</em></p><p id="0b28" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://twitter.com/Mean_Agression" rel="noopener ugc nofollow" target="_blank"><em class="om">@ Mean _ Agression</em></a></p></div></div>    
</body>
</html>