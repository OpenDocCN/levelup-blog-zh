<html>
<head>
<title>Typescript Features Javascript Devs Often Missed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript开发人员经常忽略的Typescript特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-features-javascript-devs-often-missed-de7af098a364?source=collection_archive---------9-----------------------#2022-11-07">https://levelup.gitconnected.com/typescript-features-javascript-devs-often-missed-de7af098a364?source=collection_archive---------9-----------------------#2022-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="213d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JS开发人员有时很难在Typescript中创建好的类型，并且经常使用著名的<code class="fe ko kp kq kr b">any</code>或<code class="fe ko kp kq kr b">unknown</code>。这篇文章旨在告知一些关于如何使用<code class="fe ko kp kq kr b">Pick</code>、<code class="fe ko kp kq kr b">Omit</code>、<code class="fe ko kp kq kr b">partial</code>、<code class="fe ko kp kq kr b">readonly</code>和智能类型推理的提示，这些将在日常生活中对你有所帮助。</p><p id="1867" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我想说明的是<strong class="js iu">好的打字帮助你少思考，减少检查实现的时间</strong>。在函数式编程中，函数定义也是如此重要。你的类型应该严格定义你的数据结构。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/a97510d49d4b1001400dd8ac95b954e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V97ATCrH3MLi8hBm4aImQw.png"/></div></div></figure><p id="fdf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始吧…</p><h1 id="135d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">挑选和省略</h1><p id="fa8b" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这两个是Typescript附带的关键字的一部分。这些有助于防止每次我们需要类似的东西时重写接口。让我们看一个真实的例子。</p><p id="8c22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们正在创建一个用于某些组件的商店。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="9b29" class="ml lf it kr b gy mm mn l mo mp">interface Stores {<br/>  user: User,<br/>  theme: Theme<br/>  // ... some others<br/>}</span></pre><p id="2175" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想要定义我们的组件的道具，这些道具也带有一些商店，我们不需要像这样复制它:</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="b8c3" class="ml lf it kr b gy mm mn l mo mp">interface AvatarProps {<br/>  user: User,<br/>  rounded: boolean<br/>  // ... some others<br/>}</span></pre><p id="5e1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，我们可以使用这些关键字来防止重复这些类型，并减少一些错误，如为用户属性添加另一种类型。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="ebab" class="ml lf it kr b gy mm mn l mo mp">interface AvatarProps extends Pick&lt;Stores, "user"&gt;{<br/>  rounded: boolean<br/>  // ... some others<br/>}</span></pre><p id="d061" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b"><strong class="js iu">Pick</strong></code> <strong class="js iu">只需创建一个新类型，其密钥与我们传递的第二个类型相匹配</strong>。想象一下这个函数有两个参数，第一个是整个类型，第二个是我们需要“挑选”的名字的联合。请记住，一个联合是两个或更多类型的连接，在这种情况下，我们使用一个固定的字符串来匹配每个键。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="aa53" class="ml lf it kr b gy mm mn l mo mp">interface Foo {<br/>  key1: number,<br/>  key2: number,<br/>  key3: number<br/>}</span><span id="6d8f" class="ml lf it kr b gy mq mn l mo mp">type FooPicked = Pick&lt;Foo , "key1" | "key2"&gt;</span><span id="d9a0" class="ml lf it kr b gy mq mn l mo mp">/*</span><span id="0841" class="ml lf it kr b gy mq mn l mo mp">This will result in a type like that:</span><span id="9ec6" class="ml lf it kr b gy mq mn l mo mp">interface FooPicked {<br/>  key1: number,<br/>  key2: number<br/>}</span><span id="a00f" class="ml lf it kr b gy mq mn l mo mp">*/</span></pre><p id="7be9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b"><strong class="js iu">Omit</strong></code> <strong class="js iu">做同样的事情但顺序相反。我的意思是，它将“忽略”所有与union匹配的键，而不是获取所有与union匹配的键。</strong></p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="c593" class="ml lf it kr b gy mm mn l mo mp">interface Foo {<br/>  key1: number,<br/>  key2: number,<br/>  key3: number<br/>}</span><span id="83bd" class="ml lf it kr b gy mq mn l mo mp">type FooOmited = Omit&lt;Foo , "key1" | "key2"&gt;</span><span id="9fbd" class="ml lf it kr b gy mq mn l mo mp">/*</span><span id="0e22" class="ml lf it kr b gy mq mn l mo mp">This will result in a type like that:</span><span id="eb37" class="ml lf it kr b gy mq mn l mo mp">interface FooOmited {<br/>  key3: number<br/>}</span><span id="b4f4" class="ml lf it kr b gy mq mn l mo mp">*/</span></pre><h1 id="9d1f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">部分的</h1><p id="09da" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们正在谈论商店，所以让我们继续。在这种情况下，让我们考虑行动，突变，或任何会做更新。例如，让我们以React在类中使用的旧setState为例。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="8c7c" class="ml lf it kr b gy mm mn l mo mp">// state<br/>this.state = {<br/>  foo: "foo",<br/>  bar: "bar"<br/>}</span><span id="a847" class="ml lf it kr b gy mq mn l mo mp">// mutation<br/>this.setState({<br/>  foo: "foo"<br/>})</span></pre><p id="b53f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">方法<code class="fe ko kp kq kr b">setState</code>需要接收的只是整个状态的一部分，但是我们不能使用Pick或者省略，因为我们不知道哪个会是被省略的键。因此，对于这些情况，我们需要发送一个“部分接口”,它将与整个接口合并。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="8c02" class="ml lf it kr b gy mm mn l mo mp">// state<br/>interface State {<br/>  foo: string,<br/>  bar: string<br/>}</span><span id="2302" class="ml lf it kr b gy mq mn l mo mp">// mutation<br/>type SetState = (value: Partial&lt;State&gt;) =&gt; State;</span></pre><p id="92b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是这个<code class="fe ko kp kq kr b">Partial</code>在幕后是做什么的，嗯没那么复杂。<strong class="js iu">只是给每个一级属性加了可选。</strong></p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="0277" class="ml lf it kr b gy mm mn l mo mp">// state</span><span id="2c5a" class="ml lf it kr b gy mq mn l mo mp">interface State {<br/>  foo: string,<br/>  bar: string<br/>}</span><span id="97b8" class="ml lf it kr b gy mq mn l mo mp">type PartialState = Partial&lt;State&gt;;</span><span id="58e2" class="ml lf it kr b gy mq mn l mo mp">/*</span><span id="d470" class="ml lf it kr b gy mq mn l mo mp">This will result in a type like that:</span><span id="a59b" class="ml lf it kr b gy mq mn l mo mp">interface PartialState {<br/>  foo?: string,<br/>  bar?: string<br/>}</span><span id="5437" class="ml lf it kr b gy mq mn l mo mp">*/</span></pre><p id="4b8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以找到另一个需要用到它的案例。请记住，只将optional放在第一级属性中，如果您嵌套了一个对象，子属性将不会受到它的影响。</p><h1 id="c067" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">只读的</h1><p id="58c4" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">如果你喜欢处理不可变的数据，也许你会喜欢这个关键字。<strong class="js iu"> Typescript允许你决定你的对象的哪些属性可以修改或者不可以修改。</strong>继续商店，如果您将使用Flux架构，您不希望允许状态被修改，您只想在每个动作中重新创建状态。</p><p id="32d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，对于这些情况，将这些属性设为readonly是有帮助的，因为如果有人试图修改它，它将抛出一个错误。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="bcfc" class="ml lf it kr b gy mm mn l mo mp">interface Stores {<br/>  readonly user: User,<br/>  readonly theme: Theme<br/>  // ... some others<br/>}</span></pre><p id="9ae8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，您可以使用Readonly修饰符</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="e2e8" class="ml lf it kr b gy mm mn l mo mp">type ReadonlyStores = Readonly&lt;Stores&gt;</span></pre><p id="075b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您尝试修改任何值时，将会看到一条错误消息。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="4da8" class="ml lf it kr b gy mm mn l mo mp">const store: ReadonlyStores = {<br/>  user: new User(),<br/>  theme: new Theme(),<br/>  // ... some others<br/>}</span><span id="a270" class="ml lf it kr b gy mq mn l mo mp">stores.user = new User()<br/>// Error: Cannot assign to 'user' because it is a read-only property.</span></pre><p id="e534" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">重要的</strong></p><p id="0d64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">该检查将在编译时抛出错误，但不会像</strong> <code class="fe ko kp kq kr b"><strong class="js iu">const</strong></code> <strong class="js iu">那样在运行时抛出错误。</strong>意思是如果你有一段typescript没有跟踪的代码，它会很容易在运行时修改你的属性。只是防止从文件中跳过typescript规则。</p><h1 id="96bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">推理类型的巧妙运用</h1><p id="436d" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">Typescript有一个非常强大的推理算法。这意味着有时我们不需要明确变量的类型，因为它会直接为你输入。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="a39b" class="ml lf it kr b gy mm mn l mo mp">let a = "a" // Typescript infer that it will be a "string"<br/>a = 3 // It'll throw an error</span><span id="b05b" class="ml lf it kr b gy mq mn l mo mp">// Just need to specify the type if you are not passing a value to the variable<br/>let a: string;<br/>a = "a"</span><span id="125d" class="ml lf it kr b gy mq mn l mo mp">// In another way it will be typed as any<br/>let a; // typescript typed as any (some config will prevent this automatic any type)<br/>a = "a"<br/>a = 3 // it will NOT throw an error</span></pre><p id="8065" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以利用这种超能力为自己谋利。继续我们的商店，而不是创建这样的界面…</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="8918" class="ml lf it kr b gy mm mn l mo mp">interface Stores {<br/>  user: User,<br/>  theme: Theme<br/>  // ... some others<br/>}</span><span id="fa3d" class="ml lf it kr b gy mq mn l mo mp">const stores: Stores = {<br/>  user: new User(),<br/>  theme: new Theme()<br/>}</span></pre><p id="4bab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…我们可以让typescript负责自动创建它。</p><pre class="kt ku kv kw gt mh kr mi mj aw mk bi"><span id="8eb3" class="ml lf it kr b gy mm mn l mo mp">const stores = {<br/>  user: new User(),<br/>  theme: new Theme()<br/>}</span><span id="0d1f" class="ml lf it kr b gy mq mn l mo mp">type Stores = typeof stores;</span></pre><p id="d044" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">常见的<code class="fe ko kp kq kr b">typeof</code>关键字在typescript中有了新的功能。它将返回typescript推断的变量声明的类型。<strong class="js iu">所以两个代码都在做同样的事情。</strong></p><p id="4d38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我喜欢这个特性，因为在这些情况下，类型完全依赖于声明。如果你添加一个新的字段，你只需要把它添加到声明中，它会立即传播到类型。相反，在手动界面创建中，您需要自己传播它，这可能会带来一些错误。</p><h2 id="1c1f" class="ml lf it bd lg mr ms dn lk mt mu dp lo kb mv mw ls kf mx my lw kj mz na ma nb bi translated">延伸阅读:</h2><ul class=""><li id="41b8" class="nc nd it js b jt mc jx md kb ne kf nf kj ng kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/typescript-must-know-fundamentals-for-your-next-tech-interview-or-project-255ae70df0a3"> TypeScript必备基础知识—类型别名和接口</a></li><li id="6067" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-keyof-like-a-pro-56f3a3d06b73">像专业人士一样使用打字键盘</a></li><li id="81d8" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/typescript-classes-from-zero-to-hero-a429a3c96189">打字稿类——从零到英雄</a></li><li id="c559" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/next-level-your-typescript-runtime-type-validation-using-class-and-decorators-ddd2ce3c86f3">使用类和装饰器的下一级Typescript运行时类型验证</a></li><li id="68aa" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/mastering-typescript-generics-the-ultimate-guide-3a62afeff44">掌握类型脚本泛型:终极指南</a></li><li id="c096" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" href="https://bootcamp.uxdesign.cc/typescript-tricks-and-tips-become-a-pro-in-no-time-5390aba151be" rel="noopener" target="_blank">打字技巧和提示:立刻成为专业人士</a></li><li id="f813" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/generics-in-typescript-must-know-fundamentals-stupidly-simplified-e7b4d7ffc0e3">打字稿中的泛型——愚蠢简化的必备基础知识</a></li><li id="c0f9" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/typescript-missed-this-but-you-shouldnt-runtime-type-validation-aa8a81ce4289"> Typescript遗漏了这一点，但你不应该—运行时类型验证</a></li><li id="ff23" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/typescript-enum-pitfalls-and-solutions-must-know-bb971cb0f7d2"> Typescript枚举陷阱和解决方案必须知道</a></li><li id="27e6" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" href="https://bootcamp.uxdesign.cc/mastering-typescript-generics-the-ultimate-guide-essential-interface-techniques-86e793cf1fc" rel="noopener" target="_blank">掌握TypeScript泛型—终极指南—基本接口技术</a></li><li id="bc34" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated"><a class="ae nl" rel="noopener ugc nofollow" target="_blank" href="/mastering-intersection-and-union-types-in-typescript-the-ultimate-guide-essential-techniques-49aa9f6a188a">掌握TypeScript中的交集和并集类型:终极指南和基本技巧</a></li></ul></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="51ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae nl" href="https://medium.com/@caopengau/membership" rel="noopener">链接</a>加入medium，获取我和所有其他优秀作家在medium上发表的所有优质文章。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="68e2" class="le lf it bd lg lh ny lj lk ll nz ln lo lp oa lr ls lt ob lv lw lx oc lz ma mb bi translated">分级编码</h1><p id="1c11" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="3b19" class="nc nd it js b jt ju jx jy kb od kf oe kj of kn nh ni nj nk bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="7d64" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated">📰查看<a class="ae nl" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="9806" class="nc nd it js b jt nm jx nn kb no kf np kj nq kn nh ni nj nk bi translated">🔔关注我们:<a class="ae nl" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae nl" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nl" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="3685" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae nl" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>