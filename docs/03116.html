<html>
<head>
<title>Server Sent Events — Architecture and Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务器发送的事件—架构和实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/server-sent-events-architecture-and-implementation-d4ec3fa7974e?source=collection_archive---------5-----------------------#2020-04-20">https://levelup.gitconnected.com/server-sent-events-architecture-and-implementation-d4ec3fa7974e?source=collection_archive---------5-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="dbd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SSE——一个有趣的架构，已经流行了很长时间。</p><blockquote class="ko"><p id="bab4" class="kp kq it bd kr ks kt ku kv kw kx kn dk translated">那么，什么是SSE呢？</p></blockquote><p id="db9e" class="pw-post-body-paragraph jq jr it js b jt ky jv jw jx kz jz ka kb la kd ke kf lb kh ki kj lc kl km kn im bi translated">通俗地说，SSE是一个服务器发送的事件，其中UI首先发起调用并请求数据，然后服务器在数据可用时将数据发送回调用者(UI)。</p><p id="eb94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当从UI建立HTTP连接时，服务器保持连接，并在从下游APIs源获得事件/数据时用数据进行响应。</p><p id="764b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与服务器立即发回响应并关闭连接的普通HTTP调用不同，在SSE中，服务器将连接保持一段时间，并在响应可用时以流的形式发回响应。它可以通过一个HTTP连接一个接一个地发送数据包。一旦发送完所有数据，服务器就会关闭连接。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/18954f7342b92c1104a374b2f459e5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmvGvHrjHf2k4lCFCV0YOQ.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">图一。服务器发送的事件请求-响应图</figcaption></figure><p id="f15e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上图所示，服务器以数据流的形式发送响应。来自浏览器的单个请求将在同一个HTTP (HTTPS)调用中发出多个响应(JSON类型)。</p><p id="9f30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，浏览器必须将请求实现为来自JavaScript的EventSource对象。默认情况下，这个对象存在于除了Internet Explorer之外的所有主流浏览器中(我知道你对此的感受…！！).</p><blockquote class="ko"><p id="01f4" class="kp kq it bd kr ks kt ku kv kw kx kn dk translated">为什么服务器发送事件？</p></blockquote><p id="3191" class="pw-post-body-paragraph jq jr it js b jt ky jv jw jx kz jz ka kb la kd ke kf lb kh ki kj lc kl km kn im bi translated">服务器发送事件(SSE)用于这样的场景:浏览器不断地从服务器寻找更新，当服务器端有任何可用的东西时，服务器发出响应。浏览器不会一次又一次地发出连续的请求(长轮询),而是只发出一次请求，服务器会在任何可用的时候发回响应。</p><p id="0320" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">长轮询场景:</strong>如果服务器在浏览器请求到来时没有可用的数据，通常它会发回空数据，一段时间后浏览器会再次发出请求，以检查数据是否可用，以及服务器是否做出适当的响应，如果服务器没有数据，这个循环会永远继续下去。</p><p id="31a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相信我，我见过大约25-30次往返调用，在这些场景中，浏览器不断检查服务器上的更新，但运气不佳。这种情况非常消耗资源，而且由于多次调用被重复进行，对浏览器资源来说非常麻烦。</p><p id="c2a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该架构和SSE完全消除了长轮询的概念，在长轮询中，浏览器不断向服务器发出多个请求。</p><p id="15f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，对什么是SSE有了一个基本的了解，让我们稍微挖掘一下编码的观点以及如何实现这一点。</p><p id="1327" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用的技术堆栈:</p><ol class=""><li id="e491" class="lt lu it js b jt ju jx jy kb lv kf lw kj lx kn ly lz ma mb bi translated">用户界面的JavaScript</li><li id="1b9e" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">后端的Java</li><li id="a9a0" class="lt lu it js b jt mc jx md kb me kf mf kj mg kn ly lz ma mb bi translated">作为数据消费者的阿帕奇·卡夫卡</li></ol><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/10780cbcde079250744e25a44137245c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HBWED_On_v6ZfeHlTK94A.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">图2:实时SSE实现</figcaption></figure><blockquote class="ko"><p id="7553" class="kp kq it bd kr ks mh mi mj mk ml kn dk translated">SSE实施:</p></blockquote><p id="d1bc" class="pw-post-body-paragraph jq jr it js b jt ky jv jw jx kz jz ka kb la kd ke kf lb kh ki kj lc kl km kn im bi translated">第一步:<strong class="js iu">浏览器的JavaScript】</strong></p><p id="d492" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览器通过<strong class="js iu"> EventSource对象调用SSE服务器。</strong> EventSource对象是SSE的JavaScript实现。使用EventSource对象，浏览器调用服务器并保持调用，直到服务器终止调用。出于任何原因(ALB超时、网络中断)，如果从UI到后端的连接中断，EventSource对象会自动重新连接到服务器。让我告诉你，这是自动的，不需要额外的手动或编码干预。</p><p id="2092" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SSE的JavaScript代码片段:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/c279c2ecc699ca35e5ca5b360e1db03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ORwKFgjzVpzic59nmQ5SQ.png"/></div></div></figure><p id="ae2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二步:<strong class="js iu">服务器上的SSE(Java)</strong></p><p id="a666" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a.SSE事件以流的形式发送回来。因此，我们必须确保我们的代码/API以“文本/事件流”的响应类型进行响应。</p><p id="9d18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">b.SSE是基于来自UI的连接实现的。当连接请求进来时，服务器需要保持连接，直到获得响应。可以用“EmitterProcessor”用Java实现。这是一种可以和几个用户一起使用的处理器。该发射器处理器是与浏览器保持唯一一次性连接的处理器。</p><p id="899a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">c.发送回浏览器的数据的响应类型是Flux类型。Flux是负责将数据流返回给用户的对象。</p><p id="ec72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Flux和EmitterProcessor都是基于Java的Reactor core Publisher API构建的。<a class="ae mn" href="https://github.com/reactor/reactor-core" rel="noopener ugc nofollow" target="_blank"> Reactor Core </a>是一个Java库，实现了反应式编程模型。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mo"><img src="../Images/f866cee99a5633d89f8b84ac1df5cd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zw_sK7mZ6-2zybYI8aouyg.png"/></div></div></figure><p id="2447" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码描述了GET调用是如何在Java中构建的，以及响应类型如何是事件流值、接收到的连接和发送回调用者(浏览器)的Flux事件。</p><p id="5635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三步:<strong class="js iu"> Kafka消费，发送SSE事件</strong></p><p id="a75c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦建立了连接，服务器就保持连接并等待数据。在这里，我们正在阅读阿帕奇卡夫卡消费者的事件。一旦Kafka生产者为我们的Kafka消费者订阅的主题产生了事件，数据/事件将被我们的消费者消费。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/e926c3aacc57541529f0a7da632d64ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*emaE_dM5sMkKOCLoJz32AA.png"/></div></figure><p id="b3d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">读取数据，如果存在SSE连接，则将数据发送回浏览器。重复这个过程，直到服务器终止连接。</p><p id="f358" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的事项:</p><p id="cdc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用AWS时，从浏览器到服务器的连接会根据应用程序负载平衡器(ALB)超时而断开。如果超时设置为180秒，连接会在180秒后断开，浏览器会自动重新连接到服务器。</p><p id="890a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望我的这篇文章已经帮助您理解了服务器发送事件的概念。快乐编码…！！</p><p id="b226" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这篇文章，请尽可能多地在页面底部拍手。它鼓励我写更多。</p></div></div>    
</body>
</html>