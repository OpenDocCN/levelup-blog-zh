<html>
<head>
<title>Eliding Properties in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">省略TypeScript中的属性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/eliding-properties-in-typescript-b170cd83ee09?source=collection_archive---------2-----------------------#2021-02-14">https://levelup.gitconnected.com/eliding-properties-in-typescript-b170cd83ee09?source=collection_archive---------2-----------------------#2021-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1da0" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://gentille.us/typescript-tips-b74925485b78?sk=4c9067cf57be6406abc26e44cb7fb872" rel="noopener ugc nofollow" target="_blank"> JavaScript和类型脚本提示</a></h2><div class=""/><p id="a41f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">除了重命名之外，有时还需要删除属性并将这些更改合并到一个新对象中。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/1bace0d7ce0410781615aeb0ff0b5a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QBwUkKK9a48wHsRLb4WIg.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">是时候拿出大扳手，打开一些属性了</figcaption></figure><p id="d116" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在上一篇文章中，我们研究了如何重命名一个对象的属性。如果你还没有读过这篇文章，那么它将成为你这次旅程的一个更合理的起点。</p><p id="2c19" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">当你需要以新的方式使用已存在的对象时，总会有一些麻烦制造者，你不想把他们带到旅途中。我们一会儿将深入研究如何正确地输入所有内容。同时，让我们假设在我们的<code class="fe ll lm ln lo b">Letters</code>对象上还有一些属性。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/52e2a8f22f1c86df76f422652a9db6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*WKo_BdaNfgmYTbflBp20CQ.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">扩展的(来自最后一篇文章)字母类型</figcaption></figure><p id="9691" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这一次，我们不仅想将<code class="fe ll lm ln lo b">z</code>重命名为<code class="fe ll lm ln lo b">zed</code>，还想删除<code class="fe ll lm ln lo b">a</code>和<code class="fe ll lm ln lo b">d properties.</code>。下面是删除代码行:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/1193aa8650fbfc5242811d21326c3ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*3fgsLGDtZ9oBUaCbiZS_QQ.png"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">剥离不需要的属性</figcaption></figure><p id="ab64" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们显式地将不需要的属性剥离到胖箭头函数的未使用参数中，然后使用<em class="lr"> rest </em>操作符收集剩余的属性并返回它们。这本身就很有用，但是当你试图找到一种简单的方式来输入所有内容时，事情就变得更有趣了。</p><p id="a646" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">当我第一次定义要操作的属性，然后定义我想要的最终类型时，键入对我来说更直观。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ls"><img src="../Images/2f893fb128a540896c053698f7aa8955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLCjWPs5Rly7_byZpS1jSQ.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">类型，以及先前粗箭头函数的类型化版本</figcaption></figure><p id="153e" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这个代码片段还使用了union运算符。我们取<code class="fe ll lm ln lo b">a</code>和<code class="fe ll lm ln lo b">d</code>的并集，并从<code class="fe ll lm ln lo b">AfterRemoveProps.</code>中省略它们。函数现在是完全类型化的。它接受<code class="fe ll lm ln lo b">Letters </code>并返回一个符合<code class="fe ll lm ln lo b">AfterRemoveProps </code>类型的对象。如果您将鼠标悬停在使用VS代码的类型上，您会看到它包含了<code class="fe ll lm ln lo b">b</code>、<code class="fe ll lm ln lo b">c</code>和<code class="fe ll lm ln lo b">z</code>的属性。</p><p id="f90d" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">现在，让我们结合上一篇文章中的重命名，并将两个操作合并成我们想要的结果。重命名是相同的，但是类型发生了变化。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lt"><img src="../Images/a92274e6206d5b2cd8709d0f7ba63007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzeroAAksTKTVyZbBA-uYA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">使用新的传入类型和返回类型</figcaption></figure><p id="7409" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我不再传入<code class="fe ll lm ln lo b">Letters </code>型，而是我们新的<code class="fe ll lm ln lo b">AfterRemoveProps</code>型。为了清楚起见，我在这里创建了一个名为<code class="fe ll lm ln lo b">UnchangedProps.</code>的临时类型，它省略了所有三个属性，<code class="fe ll lm ln lo b">a,</code> <code class="fe ll lm ln lo b">d,</code>和<code class="fe ll lm ln lo b">z.</code>，它再次通过使用两个类型的联合来做到这一点。<code class="fe ll lm ln lo b">UnchangedProps</code>只有<code class="fe ll lm ln lo b">b</code>和<code class="fe ll lm ln lo b">c.</code>的属性。我们将返回的最后一个对象也有<code class="fe ll lm ln lo b">zed</code>属性，所以我们使用<code class="fe ll lm ln lo b">&amp;</code>操作符来创建包含<code class="fe ll lm ln lo b">b</code>、<code class="fe ll lm ln lo b">c</code>和<code class="fe ll lm ln lo b">zed.</code>的<code class="fe ll lm ln lo b">FinalProps</code>类型</p><p id="9424" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这是一个包含所有代码的测试。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lu"><img src="../Images/53ad5dc3295213c98a5a0740e4617ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wQ8beB2_G-oNgEznZeOkA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">带测试的最终代码</figcaption></figure><p id="2b64" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">如果您想测试您的理解，请颠倒顺序，重写代码，首先进行重命名，最后删除属性。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="4313" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><em class="lr">本文显示的代码是GitHub </em>  <em class="lr">中可用的</em> <a class="ae lk" href="https://github.com/Rolias/blog-posts/blob/b779109c183cb4dc7fcdf86d2bdc8434808c9174/src/spread-rename/spread-delete-rename.test.ts" rel="noopener ugc nofollow" target="_blank"> <em class="lr">。</em></a></p><p id="44fb" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">还有更多<a class="ae lk" href="https://gentille.us/typescript-tips-b74925485b78?sk=4c9067cf57be6406abc26e44cb7fb872" rel="noopener ugc nofollow" target="_blank"> JavaScript和TypeScript技巧文章</a>。</p><p id="4794" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">平静地编码。</p></div></div>    
</body>
</html>