<html>
<head>
<title>Demystifying Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Python装饰者的神秘面纱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/demystifying-python-decorators-726f04963a52?source=collection_archive---------5-----------------------#2020-02-17">https://levelup.gitconnected.com/demystifying-python-decorators-726f04963a52?source=collection_archive---------5-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/43b757ebb5f018d06deeeba7ec37c4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*43oVdHX0SVoCnoiI.jpeg"/></div></div></figure><p id="5c57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将讨论Python Decorators，以及如何使用它们让程序员的生活变得更加轻松。那么，让我们开始吧。</p><h2 id="6174" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">什么是Python Decorators？</h2><p id="24d7" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">Python Decorators的核心是函数、方法和类/对象的包装器。这意味着您可以动态地向现有函数添加额外的功能，而不会影响它的原始行为。这使得遵守<a class="ae lx" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>和拥有真正的面向对象代码变得更加容易。</p><h2 id="8eba" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">如何定义他们？</h2><p id="23f2" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">典型的主流例子是函数执行时间的定时器。所以，我们来做一个，解释一下它的工作原理。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8b9f" class="kz la it md b gy mh mi l mj mk">from time import time<br/>def timed(our_function):<br/>    def our_wrapped_function(*args, **kwargs):<br/>        start = time()<br/>        result = our_function(*args, **kwargs)<br/>        end = time()<br/>        print(f"Time taken is {end-start} seconds.")<br/>        return result<br/>    return our_wrapped_function</span></pre><p id="a423" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们解释一下这是如何工作的。我们创建了一个函数<code class="fe ml mm mn md b">timed</code>，它将函数<code class="fe ml mm mn md b">our_function</code>作为参数。在<code class="fe ml mm mn md b">timed</code>内部，我们创建了一个接受各种参数(位置和关键字参数)的函数，并将这些参数发送给<code class="fe ml mm mn md b">our_function</code>。调用<code class="fe ml mm mn md b">our_function</code>前，记录当前时间，调用<code class="fe ml mm mn md b">our_function</code>后，记录当前时间。最后，<code class="fe ml mm mn md b">start</code>和<code class="fe ml mm mn md b">end</code>的区别就是执行<code class="fe ml mm mn md b">our_function</code>所用的时间，以秒为单位。在我们创建了<code class="fe ml mm mn md b">our_wrapped_function</code>之后，我们将它作为新函数返回来使用。</p><h2 id="7528" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">如何使用它们？</h2><p id="52b2" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">有两种方法(据我所知)可以使用decorators，并且两者是平等的。第一种是在函数签名前使用<code class="fe ml mm mn md b">@</code>符号。它与您有权访问其定义的函数一起工作。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6f04" class="kz la it md b gy mh mi l mj mk">@timed<br/>def my_amazing_calculation(a, b):<br/>    return a + b - b - a</span></pre><p id="a769" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一种方式是</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="2d43" class="kz la it md b gy mh mi l mj mk">def my_amazing_calculation(a, b):<br/>    return a + b - b - a</span><span id="87ea" class="kz la it md b gy mo mi l mj mk">my_amazing_calculation = timed(my_amazing_calculation)</span></pre><p id="7f04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二种方式允许您修改您不能直接访问其定义的函数/方法。比如numpy函数或DataFrame方法</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f88b" class="kz la it md b gy mh mi l mj mk">import seaborn as sns<br/>data = sns.load_dataset('iris')<br/>data.apply = timed(data.apply)</span></pre><p id="8787" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们使用<code class="fe ml mm mn md b">data.apply</code>，它将被计时。(你必须小心，因为每个<code class="fe ml mm mn md b">data.apply</code>调用都会产生这个输出，而且<code class="fe ml mm mn md b">pandas.DataFrame</code>有时会在自己内部调用<code class="fe ml mm mn md b">apply</code>；所以它可能会在你没有明确<code class="fe ml mm mn md b">apply</code>调用的情况下弹出。</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/3fa305f45a83a055c2fa18c05dd6c682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqEbUMHWFKb4jhvaxjkVQw.png"/></div></div></figure><h2 id="3bc3" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">那么，我们还能用它们做什么呢？(更高级的使用案例)</h2><p id="6de8" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">您可以使用它们来跟踪函数的调用次数(有状态装饰器)，并行执行，验证访问，跟踪由函数引起的变化(操作前后数据帧的形状)。我们还可以对同一个函数应用多个装饰器，并向这些装饰器传递参数。让我们试几个。</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/084f5acebbb3943a52fc29f8c233f68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*woasa9malaN9LzYkUfSO4w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">认证和跟踪装饰示例</figcaption></figure><p id="4852" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们创建了两个新的装饰者。第一种方法只使用数据帧(可能还有一个<code class="fe ml mm mn md b">Series</code>)来监控输入数据帧的形状及其内存使用情况，并对操作的输出做同样的事情。第二个decorator根据用户名(也可以添加密码)验证特定用户执行特定操作，并计算他们调用的次数(就像跟踪API令牌一样)。让我们使用它们。</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/570828dae44d4db3ebdeb35fd163ce4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnGA5AwmFcyT6RnlTdoxWA.png"/></div></div></figure><p id="6b38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个函数<code class="fe ml mm mn md b">add_lengths</code>可以被Daniel和Saed访问。但是，第二个只有赛义德能接触到，可怜的丹尼尔:(。让我们执行并看看结果。</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/11eb5039982248a66e05bf3973b3a63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*An8QtJrgZcMhjMECsodgnw.png"/></div></div></figure><p id="262e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，如果我们把<code class="fe ml mm mn md b">add_widths</code>称为<a class="mx my ep" href="https://medium.com/u/102134f9432b?source=post_page-----726f04963a52--------------------------------" rel="noopener" target="_blank">丹尼尔</a>，就会产生一个异常。</p><figure class="ly lz ma mb gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/ed79eebc82d2f3679e3d5e2c2f6ea01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqrLWhVK83ary5QQ3RQoEg.png"/></div></div></figure><h1 id="8aed" class="na la it bd lb nb nc nd le ne nf ng lh nh ni nj lk nk nl nm ln nn no np lq nq bi translated">概述</h1><p id="68cd" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">简而言之，decorators是接受其他函数/方法(可以接受类)作为参数并返回它们的增强版本的函数(它们也可以是类)。而且，他们可以有自己的论点。</p><p id="fc47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这使得代码更容易模块化。它可以在<a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/faster-code-with-python-caching-8da6e8a92ae9">缓存</a>、日志记录、跟踪、并行性(检查<a class="ae lx" href="https://joblib.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> joblib </a>)方面提供很大帮助，最重要的是，不必弄乱一段功能代码。</p><h2 id="b284" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">重要注意事项:</h2><ul class=""><li id="8342" class="nr ns it kd b ke ls ki lt km nt kq nu ku nv ky nw nx ny nz bi translated">当您在原来的调用之上添加更多的调用时，调试变得有点不容易。</li><li id="9219" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated">如果你使用有状态的decorators，你必须小心在内存中存储什么，因为它的大小很容易爆炸。</li><li id="d2f8" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated">Python标准库中已经有一些既定的decorators(例如，<code class="fe ml mm mn md b">decorator</code>、<code class="fe ml mm mn md b">contextmanager</code>、<code class="fe ml mm mn md b">total_ordering</code>、<code class="fe ml mm mn md b">lru_cache</code>、<code class="fe ml mm mn md b">property</code>)，它们在很多情况下确实很有帮助。</li></ul><h2 id="4d74" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">延伸阅读:</h2><ul class=""><li id="d3d4" class="nr ns it kd b ke ls ki lt km nt kq nu ku nv ky nw nx ny nz bi translated"><a class="ae lx" href="https://wiki.python.org/moin/PythonDecorators" rel="noopener ugc nofollow" target="_blank">https://wiki.python.org/moin/PythonDecorators</a></li><li id="13a3" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated"><a class="ae lx" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Decorator_pattern</a></li><li id="5ab3" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated">https://docs.python.org/3/library/functools.html<a class="ae lx" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="687c" class="nr ns it kd b ke oa ki ob km oc kq od ku oe ky nw nx ny nz bi translated"><a class="ae lx" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Single _ respons ibility _ principal</a></li></ul></div></div>    
</body>
</html>