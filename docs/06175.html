<html>
<head>
<title>Adding a blog to your Django website</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Django网站上添加博客</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adding-a-blog-to-your-django-website-46f45f26137b?source=collection_archive---------8-----------------------#2020-10-31">https://levelup.gitconnected.com/adding-a-blog-to-your-django-website-46f45f26137b?source=collection_archive---------8-----------------------#2020-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4e906b3cb9cba2cc96660c3f5af4f664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CCm5JR3Yb2HvYu7T.jpg"/></div></div></figure><p id="3b7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如今，有大量的解决方案可以轻松创建和托管博客。然而，有时你已经有了一个网站，只是想给它添加一个博客，除了手头现有的工具之外，没有使用其他工具。在这篇文章中，我们将介绍用Django创建博客的过程，看看它有多简单明了。这篇文章假设你已经有了一个Django应用程序/站点。如果没有，可以通过遵循<a class="ae kz" href="https://docs.djangoproject.com/en/2.2/intro/tutorial01/" rel="noopener ugc nofollow" target="_blank">官方指令</a>轻松创建一个。使用的Django版本是3.1.2，但是它也可以与Django v2一起使用。</p><p id="cf65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们开始运行一个方便的<strong class="kd iu"> startapp </strong>命令，它将搭建我们的博客应用。这应该从<strong class="kd iu"> manage.py </strong>所在的同一个文件夹中运行:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="8af2" class="lj lk it lf b gy ll lm l ln lo">$ python manage.py startapp blog</span></pre><p id="2ac4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将添加一个具有以下结构的<strong class="kd iu">博客</strong>目录:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="1eda" class="lj lk it lf b gy ll lm l ln lo">blog/<br/>  __init__.py<br/>  admin.py<br/>  apps.py<br/>  migrations/<br/>  __init__.py<br/>  models.py<br/>  tests.py<br/>  views.py</span></pre><p id="beec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一步是将新创建的应用添加到<strong class="kd iu"> settings.py: </strong>中的<strong class="kd iu"> INSTALLED_APPS </strong>列表中</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3d7f" class="lj lk it lf b gy ll lm l ln lo">INSTALLED_APPS = [<br/>     # other apps ...<br/>    'mywebsite.blog'<br/>]</span></pre><p id="6714" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以开始建立博客了。我们首先打开<strong class="kd iu"> models.py </strong>并在那里添加一个<strong class="kd iu"> BlogPost </strong>模型。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="ba2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了预期的<strong class="kd iu">标题</strong>、<strong class="kd iu">图像</strong>、<strong class="kd iu">描述</strong>和<strong class="kd iu">文本</strong>之外，我们还有几个额外的字段，它们将在发布和导航到博客帖子时使用:</p><ul class=""><li id="457c" class="lr ls it kd b ke kf ki kj km lt kq lu ku lv ky lw lx ly lz bi translated"><strong class="kd iu"> slug </strong> —是bog帖子URL的唯一可识别部分。我们正在使用<a class="ae kz" href="https://django-autoslug.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> django-autoslug </a>包，这将使保持字段的唯一性和自动填充变得轻而易举。在这种情况下，我们通过使用<strong class="kd iu"> populate_from </strong> param从<strong class="kd iu">标题</strong>填充slug。</li><li id="41d2" class="lr ls it kd b ke ma ki mb km mc kq md ku me ky lw lx ly lz bi translated"><strong class="kd iu">已发布</strong> —指示帖子何时应该在网站上可见。</li><li id="5aaf" class="lr ls it kd b ke ma ki mb km mc kq md ku me ky lw lx ly lz bi translated"><strong class="kd iu">发布日期</strong> —帖子发布的日期，也用于对帖子进行排序。</li></ul><p id="679d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止一切顺利。然而，当帖子被设置为<strong class="kd iu">已发布</strong>时，自动设置<strong class="kd iu">发布日期</strong>是有意义的。这可以通过扩展Django模型<strong class="kd iu">保存</strong>方法来实现:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="12eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了完成模型设置，我们将向它添加两个实用方法:<strong class="kd iu"> __str__() </strong>，它将用于在整个应用程序中表示模型(特别是在管理中)，以及<strong class="kd iu"> get_absolute_url() </strong>，它将使在视图中检索博客文章的url更加容易。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="8704" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">模型出来后，我们可以继续创建迁移并运行它们。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="e930" class="lj lk it lf b gy ll lm l ln lo"># Create migrations<br/>$ python manage.py makemigrations blog<br/><br/># Apply them<br/>$ python manage.py migrate blog</span></pre><p id="cbdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，将新创建的迁移添加到版本控制中(我似乎总是忘记这一点)并提交/推动进度将是一个好主意。</p><p id="bf32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经有了一个合适的功能正常的<strong class="kd iu"> BlogPost </strong>模型，是时候把它添加到Django的管理中了。考虑到管理员的强大，启用新模型是一项非常快速的工作:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="909d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就是这样！添加了这几行代码后，我们现在可以导航到<a class="ae kz" href="http://localhost:8000/admin/blog/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">http://localhost:8000/admin/blog/</strong></a><strong class="kd iu"/>(默认情况下，Django在端口8000上运行开发服务器)并开始创建博客文章。</p><p id="6c54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过admin添加一些帖子后，下一步自然是在视图中显示它们。我们的博客将有一个按时间顺序排列的所有文章的分页列表视图，以及每个文章的单独详细视图。我们将使用基于<a class="ae kz" href="https://docs.djangoproject.com/en/2.2/topics/class-based-views/" rel="noopener ugc nofollow" target="_blank">类的视图</a>,因为它们允许很好的代码重用，并且能够用最少的代码编写最常见的视图。我们可以像这样在<strong class="kd iu">视图. py </strong>中设置它们:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="83fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">非常简单。注意，在视图中启用分页只需要一行代码。这将为我们提供<strong class="kd iu"> is_paginated </strong>和一些其他有用的上下文变量来呈现模板中的分页。</p><p id="f6be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，我们在两个地方对queryset应用了相同的过滤器。这在这里没什么大不了的，但是在某些情况下，我们希望将这种功能抽象出来。在当前情况下，我们可以将带有自定义<strong class="kd iu"> QuerySet </strong>方法的<a class="ae kz" href="https://docs.djangoproject.com/en/2.2/topics/db/managers/#calling-custom-queryset-methods-from-the-manager" rel="noopener ugc nofollow" target="_blank"> Manager </a>的实例添加到我们的模型中。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="3303" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在在视图中，我们可以使用<strong class="kd iu">blog post . objects . published()</strong>来获取所有发布的博客文章。在这一点上，我们已经得到了大部分的功能，它只需要一堆文件中的几行代码。</p><p id="58de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们可以设置列表和详细信息模板。按照Django惯例，我们将把它们放到<strong class="kd iu">my website/blog/templates/blog/</strong>中。首先，我们将扩展主基础模板，还将添加一个可重用的导航栏模板，将<strong class="kd iu">“blog”</strong>设置为活动标签:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="9664" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意<code class="fe mf mg mh lf b">staticfiles</code>模板标签<a class="ae kz" href="https://docs.djangoproject.com/en/3.0/releases/3.0/#features-removed-in-3-0" rel="noopener ugc nofollow" target="_blank">在Django 3.0 </a>中已经被移除，取而代之的是<code class="fe mf mg mh lf b">static</code>标签。</p><p id="5b2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为参考，<strong class="kd iu">navbar.html</strong>可能是这样的:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="67e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为HTML结构和它的样式不是这篇文章的主要目的，我们将简单的讨论一下。可以用这个HTML设置一个简单的帖子列表:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="ceee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有几件事值得注意:</p><ul class=""><li id="b8b3" class="lr ls it kd b ke kf ki kj km lt kq lu ku lv ky lw lx ly lz bi translated">使用<strong class="kd iu">背景图</strong>代替<strong class="kd iu"> &lt; img/ &gt; </strong>是因为在大多数情况下更容易做出反应。</li><li id="38a2" class="lr ls it kd b ke ma ki mb km mc kq md ku me ky lw lx ly lz bi translated">我们使用添加到模型中的<strong class="kd iu"> get_absolute_url </strong>，在帖子的标题<strong class="kd iu"> href </strong>中轻松地重定向到帖子的详细视图，而不需要在模板中显式传递帖子id。</li><li id="4c81" class="lr ls it kd b ke ma ki mb km mc kq md ku me ky lw lx ly lz bi translated">如前所述，在视图中启用分页会在模板中暴露一堆有用的上下文变量，即<strong class="kd iu"> is_paginated </strong>，用于检查是否必须呈现分页，以及<strong class="kd iu"> page_obj </strong>，包含关于页面编号的信息。</li></ul><p id="7623" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">说到URL，如果我们试图导航到博客文章列表页面，我们将会收到一个<strong class="kd iu"> NoReverseMatch </strong>错误，因为我们还没有为博客设置URL。为了解决这个问题，让我们将<strong class="kd iu"> urls.py </strong>添加到<strong class="kd iu"> blog </strong>应用程序(与<strong class="kd iu"> models.py </strong>和<strong class="kd iu"> views.py </strong>相同级别)并启用必要的路线。注意，Django从版本2开始引入了一个新的用于声明URL的<strong class="kd iu"> path </strong>函数。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="9935" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，我们需要转到root <strong class="kd iu"> urls.py </strong>并在那里添加博客URL:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="349b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样我们就可以导航到<strong class="kd iu"> localhost:8000/blog </strong>并查看我们创建的博客列表。单击文章标题应该会将我们重定向到文章详细信息页面，但是由于我们没有设置它，我们会看到一个空白页面。为了解决这个问题，让我们添加一些简单的HTML来显示帖子:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="f63c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们使用<strong class="kd iu">安全的</strong>模板过滤器来逃避编辑器的HTML markdown。</p><p id="542b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">差不多就是这样！现在我们有了一个功能齐全的个人博客，虽然很简单，但包含了所有必要的CRUD功能。有几种方法可以对它进行样式化和扩展，但这留给读者作为练习:)</p><p id="0355" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">奖励:添加RSS源</strong></p><p id="eea3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管RSS订阅源不像以前那么流行了，但作为一个额外的帖子发布渠道，它仍然很有帮助。此外，添加到Django站点非常容易。</p><p id="32c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一步是将提要视图添加到<strong class="kd iu"> views.py </strong>文件中。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="bdac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，我们给出了我们的提要标题和描述以及链接。提要将显示所有已发布的帖子，此外，我们需要映射要在提要中显示的帖子标题和描述。</p><p id="69d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们将提要url添加到我们的博客URL中。确保提要url在博客详细信息的url之前，因为<code class="fe mf mg mh lf b">slug</code>参数将与<code class="fe mf mg mh lf b">feed</code>匹配，并且将使用<code class="fe mf mg mh lf b">BlogPostDetailView</code>。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure><p id="c49c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们做到了！导航到<code class="fe mf mg mh lf b">localhost:8000/blog/feed</code>后，我们会看到发布的文章的RSS提要。</p></div></div>    
</body>
</html>