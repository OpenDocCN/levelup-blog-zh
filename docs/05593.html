<html>
<head>
<title>L1 vs L2 Regularization and when to use which?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">L1 vs L2正规化，何时使用哪个？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/l1-vs-l2-regularization-and-when-to-use-which-cd3382008774?source=collection_archive---------1-----------------------#2020-09-13">https://levelup.gitconnected.com/l1-vs-l2-regularization-and-when-to-use-which-cd3382008774?source=collection_archive---------1-----------------------#2020-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d6ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经阅读了许多关于这个主题的文章，以找出两者中哪一个更好，以及我应该在我的模型中使用什么。我对它们都不满意，这让我的大脑很困惑，我应该使用哪一个？做了这么多实验后，我终于找到了 <strong class="js iu"> <em class="ko">的所有答案，该使用哪种正则化技术，何时使用？</em> </strong> <em class="ko">让我们用一个回归的例子来说明。</em></p><p id="d571" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有一个基于x轴值预测y轴值的回归模型。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/e1f49c2674bf85641219b8d544e3631b.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*_mNFSRgM_eZHqlzHg5hlfw.jpeg"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">训练数据</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/2f504c2dd959e4c8fe47e0c64da9f0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*FcQcKO4PbnoG9up3ggOP7A.jpeg"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">价值函数</figcaption></figure><p id="40dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在训练模型时，我们总是试图找到成本函数。这里，y是实际输出变量，<strong class="js iu"> ŷ </strong>是预测输出。因此，对于训练数据，我们的成本函数几乎为零，因为我们的预测线完全从数据点通过。</p><p id="4307" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，假设我们的测试数据集如下所示</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lc"><img src="../Images/f572c390f259967318281be6a9e683fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*miNInP8yI6lPgLULv5OqWQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">测试数据集上的模型</figcaption></figure><p id="007c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，很明显我们的预测是在别的地方，预测线指向别的地方。这导致过度拟合。<strong class="js iu">过度拟合表示，对于训练数据集，您得到的误差较低，但是对于测试数据集，您得到的误差较高。</strong></p><blockquote class="lh li lj"><p id="d631" class="jq jr ko js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">请记住，当我们需要创建任何模型时，让它回归，分类等。应该是广义的。</p></blockquote><p id="60bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di">我们</span>可以使用L1和L2正则化使这个过拟合条件基本上是高方差到低方差。一个一般化的模型应该总是具有低偏差和低方差。</p><p id="d678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们试着理解L1和L2正则化是如何帮助减少这种情况的。</p><blockquote class="lh li lj"><p id="ab35" class="jq jr ko js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">我们知道直线的方程是<strong class="js iu"> y=mx+c. </strong></p><p id="5ffc" class="jq jr ko js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">对于多个变量，这条线将转换为<strong class="js iu"> y = m1x1 + m2x2 + ……..+ mn xn。</strong></p></blockquote><p id="5b1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中m1，m2，…，mn是各个变量的斜率，x1，x2，....，xn是变量。</p><p id="bf17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当变量的系数(即斜率)很大时，任何模型都会进入过拟合状态。为什么会这样？原因很简单，系数越高，该特定变量在预测模型中的权重越高。我们知道不是每个变量都有显著的贡献。规则化的工作原理是惩罚大权重。从而使得高度相关的变量具有高权重，而不太相关的变量具有较低的权重。</p><p id="ec5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正则化方法也是一个超参数，这意味着它可以通过交叉验证进行调整。</p><h2 id="a1b7" class="lw lx it bd ly lz ma dn mb mc md dp me kb mf mg mh kf mi mj mk kj ml mm mn mo bi translated">L1正则化或套索回归</h2><p id="87f3" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">使用L1正则化技术的回归模型被称为<strong class="js iu"> <em class="ko">套索回归</em> </strong></p><p id="6123" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">L1正则化通过使用如下误差函数来工作—</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mu"><img src="../Images/f92a9631853575471c3ca3f872105d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yevobpw2kLSW45xRfe3Xsg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">L1正则化的误差函数</figcaption></figure><p id="6af9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了调整我们的模型，我们总是想减少这个误差函数。参数λ会告诉我们我们想要惩罚多少系数。</p><h2 id="efdb" class="lw lx it bd ly lz ma dn mb mc md dp me kb mf mg mh kf mi mj mk kj ml mm mn mo bi translated">0&lt; <strong class="ak">λ&lt;T3<em class="mv">∞</em></strong></h2><p id="9b58" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">如果<strong class="js iu"> λ </strong>大，我们罚很多。如果<strong class="js iu"> λ </strong>小，我们罚的就少。使用交叉验证<strong class="js iu">选择<strong class="js iu"> λ </strong>。</strong></p><p id="4994" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这个误差函数是如何调整我们的模型的？</strong></p><p id="1507" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">早先我们的误差函数(或成本函数<strong class="js iu"> <em class="ko"> ∑ (y -ŷ ) </em> </strong>)完全基于我们的预测变量ŷ.但是现在我们有了<strong class="js iu"> λ(|m1|+|m2|+。。。</strong>+| Mn |)作为附加名词。</p><p id="f4aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">早先的成本函数<strong class="js iu"><em class="ko">∑(y-ŷ)</em></strong>)<strong class="js iu">= 0</strong>，因为我们的线完美地穿过训练数据点。</p><blockquote class="lh li lj"><p id="e30d" class="jq jr ko js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">设λ = 1且|m1|+|m2|+。。。。+ |mn| = 2.8</p><p id="3c89" class="jq jr ko js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated"><strong class="js iu"> <em class="it">误差函数=∑(y-ŷ)</em></strong>)<strong class="js iu">+</strong><strong class="js iu">λ(| m1 |+| m2 |+。。。。+ |mn|) = 0 + 1*2.8 = 2.8 </strong></p></blockquote><p id="3c93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在调整时，我们的模型现在将尝试减少这个2.8的误差。假设现在的值为<em class="ko"> ∑ (y -ŷ ) </em> ) = 0.6，λ = 1并且|m1|+|m2|+。。。+ |mn| = 1.1</p><p id="2a82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，误差函数的新值将是</p><blockquote class="lh li lj"><p id="e592" class="jq jr ko js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated"><strong class="js iu"> <em class="it">误差函数=∑(y-ŷ)</em></strong>)<strong class="js iu">+</strong><strong class="js iu">λ(| m1 |+| m2 |+。。。。+ |mn|) = 0.6 + 1*1.1 = 1.7 </strong></p></blockquote><p id="08a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将迭代多次。为了减小误差函数，我们的斜率将同时减小。在这里我们会看到斜坡会变得越来越不陡。</p><p id="f912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着λ值变得更高，它将更多地惩罚系数，并且线的斜率将更趋向于零。</p><p id="1450" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在由于在公式中取|slope|而导致L1正则化的情况下，<strong class="js iu"> <em class="ko">较小的权重将最终消失并变为0。这意味着L1正则化有助于选择重要的特征，并将其余的特征化为零。它将创建稀疏的权重向量，结果类似于(0，1，1，0，1)。因此，如果我们有大量的特征，这对于特征选择很有用。</em>T49】</strong></p><h2 id="c289" class="lw lx it bd ly lz ma dn mb mc md dp me kb mf mg mh kf mi mj mk kj ml mm mn mo bi translated">L2正则化或岭回归</h2><p id="33c1" class="pw-post-body-paragraph jq jr it js b jt mp jv jw jx mq jz ka kb mr kd ke kf ms kh ki kj mt kl km kn im bi translated">使用L2正则化技术的回归模型被称为<strong class="js iu">岭回归。</strong></p><p id="d94e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">L2正则化通过使用以下误差函数来工作</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mw"><img src="../Images/d5d4248fb67ff43ff5ef1ab36893c4f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGYVXYCppuNbnsZYim0cPA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">L2正则化的误差函数</figcaption></figure><p id="96e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">L2正则化的工作方式类似于上面解释的L1的工作方式。唯一不同的是坡度。在L1正则化中，我们采用<strong class="js iu"> |slope| </strong>，而在这里我们采用<strong class="js iu"> slope </strong>。</p><p id="461f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将类似地工作，它将惩罚系数，线的<strong class="js iu"> <em class="ko">斜率将更趋向于零，但永远不会等于零。</em>T3】</strong></p><p id="1e58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么会这样？</strong></p><p id="0765" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为我们在公式中使用了斜率。该方法将以(0.5，0.3，-0.2，0.4，0.1) 的形式创建<strong class="js iu">权重的稀疏度。让我们通过一个例子来理解这种稀疏性。</strong></p><p id="dcc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑权重(0，1)和(0.5，0.5)</p><blockquote class="lh li lj"><p id="22f9" class="jq jr ko js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">对于权重(0，1) L2 : 0 + 1 = 1</p><p id="c786" class="jq jr ko js b jt ju jv jw jx jy jz ka lk kc kd ke ll kg kh ki lm kk kl km kn im bi translated">对于权重(0.5，0.5) L2 : 0.5 + 0.5 = 0.5</p></blockquote><p id="82b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，L2正则化将优选向量点(0.5，0.5)而不是向量(1，1)，因为这产生更小的平方和，进而产生更小的误差函数。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="2c48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">我们连线上</em><a class="ae ne" href="https://www.linkedin.com/in/ankita-prasad-5a0156137/" rel="noopener ugc nofollow" target="_blank"><em class="ko">LinkedIn</em></a><em class="ko">。你也可以通过ankita2108prasad@gmail.com联系我。</em></p></div></div>    
</body>
</html>