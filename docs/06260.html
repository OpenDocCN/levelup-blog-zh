<html>
<head>
<title>Effective practices for code reviews and merging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码审查和合并的有效实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/effective-practices-for-code-reviews-and-merging-7ccb4f9964f0?source=collection_archive---------9-----------------------#2020-11-09">https://levelup.gitconnected.com/effective-practices-for-code-reviews-and-merging-7ccb4f9964f0?source=collection_archive---------9-----------------------#2020-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cae2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过主动参与保持您的代码库质量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f42f5c1d27ec19ac1874711effd7c261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-XQ-0yLI9rXzRq_NP7E7Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</figcaption></figure><p id="4302" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论你称之为拉取请求、合并请求还是代码审查，都有有效的实践，每个人都可以而且应该去做，这不仅能使它进行得更顺利，而且有助于保持你的代码库的质量。</p><p id="7087" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">养成写干净代码的习惯很重要，但是如果没有定义贡献指南，你的代码库可能会失修。</p><h1 id="1cca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1 -为开发人员定义完成</h1><blockquote class="mn"><p id="0800" class="mo mp it bd mq mr ms mt mu mv mw lt dk translated">你会惊讶地发现，仅仅了解好的实践还不足以采取行动</p></blockquote><p id="0f68" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">如果您的团队不能就这一点达成一致，并且您将最佳实践留给机会，那么您的代码库将会老化得更快。合并是代码质量的最后一道防线，拥有一些把关规则将有助于让您的代码库优雅地老化。</p><p id="34ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">做一个简单的、子弹式的清单，列出签入代码时要做的事情。这听起来很老套，但几年前我们确实把它打印出来，放在我们的每张桌子上作为提醒。这比只有软拷贝形式的列表和所有其他<em class="nc">只写</em>文档要有效得多。清单就在开发人员面前，当他们跳过一个项目时，至少他们必须用一个有效的理由来证明跳过它，而不仅仅是因为他们忘记了。</p><p id="3105" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会惊讶地发现，仅仅了解好的实践还不足以采取行动；显然，人类的大脑喜欢避免额外的工作，有选择地在方便的时候忘记事情，需要被唠叨。</p><h2 id="811e" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">清单示例</h2><p id="4bd7" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">你的清单的内容可能没有事实重要，事实上它是明确定义的，并在团结中实践。如果您对这个列表不感兴趣，请不要担心，但是理想情况下，一个好的开发人员会非常关心至少其中的一些项目:</p><ul class=""><li id="4087" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">需求被实现，没有任何挥之不去的未问问题(至少尝试让<em class="nc">知道</em>未知)</li><li id="276c" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">如果<a class="ae lu" href="https://jeffreybakker.medium.com/defining-and-measuring-software-behaviour-b542370e8b7d" rel="noopener">实践BDD </a>，场景被定义以确保需求是可验证的</li><li id="c9f3" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">如果项目是<a class="ae lu" href="https://jeffreybakker.medium.com/mobile-development-stack-native-vs-xamarin-vs-xamarin-forms-309af0e11ae6" rel="noopener">跨平台的</a>，那么所有的平台都经过了完整性测试</li><li id="c13c" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">添加或更新了针对新功能或已更改功能的单元测试。在这个过程中，现有的单元测试没有被破坏。已经破坏的测试是已知的，并且正在等待某种类型的操作</li><li id="bc99" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">你是否不得不破解一些东西来让它工作？如果它没有被恢复，你用可搜索的代码注释标记了它吗？</li><li id="ebfe" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">对于新文件，使用了代码格式化工具(带有您团队的共享设置)</li><li id="73b1" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><a class="ae lu" href="https://imageoptim.com/mac" rel="noopener ugc nofollow" target="_blank">在提交之前，图像文件被优化</a>为最小无损压缩<em class="nc"/></li><li id="f97a" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">大的二进制文件使用非膨胀的源代码控制扩展来签入(例如使用<a class="ae lu" href="https://git-lfs.github.com/" rel="noopener ugc nofollow" target="_blank"> git lfs </a>、<a class="ae lu" href="https://github.com/jedbrown/git-fat" rel="noopener ugc nofollow" target="_blank"> git fat </a>或<a class="ae lu" href="https://git-annex.branchable.com/" rel="noopener ugc nofollow" target="_blank"> git-annex </a>)</li><li id="6857" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">持续集成:构建任务在CI机器上传递。单元测试在CI机器上通过，而不仅仅是在你的机器上通过</li><li id="ab26" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">从目标分支反向集成(如果在推送之前没有重新建立基础)，解决合并冲突并在CI上重新运行，必要时进行完整性检查</li></ul><p id="4e50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这个列表让你焦虑，那就是这个例子的失败之处。虽然所有这些都是有价值的实践，但是清单很长，没有耐心的开发人员会跳过一些步骤——特别是如果他们不同意或者看不到其中一些的价值。试着将你的团队最看重的代码质量度量按优先级排序，并简洁地写出来。</p><p id="fcf7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我焦虑的是，整个开发团队在没有任何定义的情况下提交代码。</p><h1 id="a4b2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2 -先发制人的自我检讨</h1><p id="4f1a" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">在指定审核人之前，对自己的更改进行自我审核不失为一个好主意。这为您提供了执行以下操作的机会:</p><ul class=""><li id="d6c5" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">捕捉潜在的尴尬错误。例如，打字错误，看起来很乱的空白，你忘记删除的代码，你忘记的代码内注释。</li><li id="65da" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">编写代码评审注释(如果你们没有一起评审的话)来帮助解释可能需要一些评审背景的决策，但是不要要求代码内注释。</li><li id="8495" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">如果您忘记签入一个文件或者签入了一个您不应该签入的文件，这是您再次检查的“最后机会”。不管你有多聪明或多有经验，如果不小心的话，人们还是会犯这个错误，评论者也不总是能发现他们。</li></ul><p id="676f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过做这些基本的检查，您可能会节省一些代码审查的周转时间。</p><h1 id="c3b5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3对复习</h1><p id="d110" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">无论你是屏幕共享还是让另一个程序员坐在你的办公桌前(可能是2020年的前者)，对提议的更改的实时浏览和讨论都显示出对我们将什么放入代码库的更多关注。</p><p id="9a32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种复习也是一种知识传授。我们不应该等到有人离开公司时才发生这种情况。抛砖引玉式的评论通常不会透露太多信息。</p><h1 id="b384" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4 -分支和合并策略</h1><blockquote class="mn"><p id="9a9a" class="mo mp it bd mq mr ms mt mu mv mw lt dk translated">一个永久可发布的代码库要求自己始终处于可靠、健康的状态…</p></blockquote><p id="4eac" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在你的开发机器上，本地个人分支是免费的——做你想做的，只要你不伤害任何人。当需要合并到其他人依赖的分支时，你需要确保他们可以。你的团队应该有一个明确的分支策略。</p><p id="d35a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有不同类型的分支，具有不同的寿命和不同的稳定水平。因此，提交和合并应该以不同的方式处理。本着良好实践的精神，分支被用来阻止将代码直接提交给主/主线/主干，主/主线/主干应该只通过合并接受变更。</p><p id="321d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个永久可发布的代码库要求自己处于一个持续可靠、健康的状态，通过一个分级的分支过程来维护。下面只是如何实现这一点的一个例子，但是有不同的策略来获得相同的效果。有一个结构化的有效的计划，你的团队可以坚持。</p><h2 id="6de7" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">修正分支错误:生命周期短</h2><p id="32f7" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">这些分支只在修复bug并被一个开发人员使用的时候存在。</p><h2 id="2e7b" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">特征分支:中等寿命</h2><p id="dcef" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">根据特征的大小，这些可以一次持续数周。它可能被一个或多个开发人员使用。</p><h2 id="633d" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">功能协作分支:中短生命周期</h2><p id="acc5" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">如果有多个开发人员在一个特性的不同部分工作，您可能希望将特性分支作为一个相对稳定的基线。然后从那里进一步分支，以创建更短生命周期的分支，保持特性分支足够可靠，以供其他开发人员使用，不受中间变更的阻碍。</p><h2 id="f782" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">史诗分支:长寿命</h2><p id="21a6" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">如果一组特性是可能需要几个月才能实现的史诗的一部分，那么保留一个史诗分支可能是有益的。然而，在许多情况下，如果epic中的特性可以单独消化，并且足够独立，可以在没有彼此的情况下工作，那么在特性分支完成时将它们合并到master中可能会更好，而不是在两者之间有一个epic分支。</p><h2 id="8315" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">主分支:永久</h2><p id="26cc" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">主分支机构将拥有整个组织中最大的流量。应该算是“发展稳定”。它可能有用户级的错误，但是应该足够稳定可靠，开发人员可以在任何时候开始工作。</p><ul class=""><li id="305c" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">永远不要直接提交给master(除非有合理的例外)</li><li id="ac80" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">不要将任何不能在CI上编译的东西合并到master中</li><li id="9933" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">不要合并任何破坏或阻碍最基本功能的东西</li><li id="8ff4" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">应该做出合理的努力来保持单元测试顺利通过；故障应该迅速解决</li><li id="edcf" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">UI自动化应该定期从这里运行，如果不是在CI上的话</li><li id="9b95" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">理想情况下没有未完成的工作；通常只有达到开发者定义的完成的特性才应该被合并</li></ul><p id="2e2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在master上打破一条关键路径会花费开发人员一天的时间。所以从理论上讲，如果几十个开发人员都在使用master，你可以很容易地让公司损失一周的生产力。</p><p id="1f81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当有人打破师父时，应该有一些轻松或好玩的羞辱:)没什么太严重的，因为每个人都会犯错误，但我们也不想传达这样的信息，即养成习惯没什么。</p><h2 id="5993" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">稳定分支:永久</h2><p id="5033" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">这是一个更成熟的master版本，因此更适合非开发人员，比如QA。在主分支和发布分支之间有这样的缓冲应该允许“代码冻结”期，而不会阻碍主分支的进展。</p><p id="e5aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可能有一些将主代码升级为稳定代码的标准。健康稳定分支的一些良好指标是:</p><ul class=""><li id="9c7c" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">CI上的单元测试和UI测试不仅都通过了，而且在一段时间内一直都通过了</li><li id="25e0" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">从字面上来说，一个没有严重阻塞缺陷的构建可以在任何一天的任何时间进行QA，以便可以测试最近完成的变更。这减少了从开发团队获得垃圾版本</li><li id="313e" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">未解决的新bug应该减少到相对较低的数量，理想情况下，没有严重的bug</li></ul><p id="7775" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当下一个发行版的所有测试都完成时，稳定版可以升级到发行版。</p><h2 id="3033" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">发布分支:永久</h2><p id="65fb" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">发布候选和发布版本本身可以从一个发布分支中产生。通过最终的质量保证测试和批准，它更经得起考验，而不是稳定。什么构成了发布分支？</p><ul class=""><li id="9671" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">当所有计划发布的功能或修复完成并通过QA和PO验收(和/或UAT)时</li><li id="f111" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">当stable通过QA的全面回归测试时</li></ul><p id="e179" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着你的代码慢慢升级到一个发布分支，你有可能在任何时候为公开发布做一个构建。</p><h2 id="fdf6" class="nd lw it bd lx ne nf dn mb ng nh dp mf lh ni nj mh ll nk nl mj lp nm nn ml no bi translated">命名策略</h2><p id="70e5" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">您的团队也应该遵循一致的分支命名模式。通常以开发人员姓名首字母作为个人分支和/或bug或功能跟踪号的前缀。</p><h1 id="0727" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="94a4" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">最终，代码库不能完全逃脱时间的摧残，但是通过尽职调查和相互参与，你的代码质量可以保持更高更久。</p></div></div>    
</body>
</html>