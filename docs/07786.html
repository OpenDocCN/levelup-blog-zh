<html>
<head>
<title>An overlooked tool in Data Science: Genetic Algorithms (in python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学中被忽视的工具:遗传算法(python语言)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-overlooked-tool-in-data-science-genetic-algorithms-in-python-e40d10afe9c6?source=collection_archive---------5-----------------------#2021-03-10">https://levelup.gitconnected.com/an-overlooked-tool-in-data-science-genetic-algorithms-in-python-e40d10afe9c6?source=collection_archive---------5-----------------------#2021-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1059" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在一天内学会的强大的优化算法绝对值得添加到你的数据科学武库中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a3d42b885321fcffd521cdc13b141d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EkqeUEbVTvDRmSsfV_THGw.png"/></div></div></figure><h1 id="27db" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">介绍</h1><p id="ed86" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">令我惊讶的是，我们今天在人工智能中使用的算法有多少是受生物系统的启发。顾名思义，遗传算法就是一个例子。从本质上来说，遗传算法是一种优化算法，它将“适者生存”的概念应用于我们问题的解决方案，而不是生物物种。</p><p id="94cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将对遗传算法背后的概念进行一个直观的概述(如果你曾经上过生物课，希望你不会花超过几分钟的时间来掌握)，然后我们将从头开始用python实现一个遗传算法来解决<a class="ae md" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">‘旅行推销员’</a>问题。</p><p id="0cb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您刚刚开始学习遗传算法，并希望一口气完全掌握它们，我建议您打开python编辑器，使用此页面分割屏幕，并在阅读概述部分后一节一节地浏览代码。你也可以在这里找到这个项目的<a class="ae md" href="https://gist.github.com/mohdabdin/09242eb84af9f04c1271fe110c5e5378#file-ga-py" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"/></a>的完整代码。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ae3a" class="la lb it bd lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt mp lv lw lx bi translated"><strong class="ak">遗传算法的高级概述</strong></h1><p id="3d93" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">简而言之，遗传算法试图通过使用适应度来获得问题的最佳解决方案，该适应度确定解决方案有多好，并应用“最适合的生存”来帮助我们获得该解决方案。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/781d4bf92d1efc5c282af697b6f69bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/1*m1Jjza-TSa-ZgFHBI0zbUQ.gif"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">图1，流程图</figcaption></figure><p id="cd98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从个体(解)的初始群体开始，每个个体都有相应的适应值。</p><p id="de60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于适应值，我们从群体中选择“2”个个体，并应用交叉来产生新的解决方案。</p><p id="5033" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如图<strong class="js iu"> <em class="mv">图2 </em> </strong>所示，通过在解决方案中选择一个随机点并交换来完成交叉。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mw"><img src="../Images/2e62d553980b3399ea98c64801c5bc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/1*u4HLZokq8MhTzikIUF6rKQ.gif"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">图2，单点交叉</figcaption></figure><p id="ed5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">突变是另一种可以应用于个体以增加群体多样性的算子。变异只是翻转部分解，如图<strong class="js iu"> <em class="mv">图3 </em> </strong>所示。</p><p id="efbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">新的解决方案现在被添加到新的群体中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d2dd121a98897e857d6543a845d65119.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*QsZDB87k9OIDct7t_Ij1cw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">图3，突变</figcaption></figure><p id="e3e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">选择-&gt;交叉-&gt;变异的过程一直进行，直到我们填充了一个新的种群，然后这些步骤重复多次迭代，或者直到我们满足了我们的问题。</p><p id="b26a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">伪代码可能会给你一个更好的想法:</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="699e" class="nd lb it mz b gy ne nf l ng nh">population = initialize_population()<br/>i=0<br/>while i&lt;100 {<br/>    evolved_population = []<br/>    while evolved_population&lt;population_size{<br/>        compute fitness &amp; select parents from current population<br/>        perform crossover -&gt; mutation<br/>        add new solution to evolved_population<br/>    }<br/>    population = evolved_population<br/>    i=i+1<br/>}<br/>return the solution with the highest fitness from the final population</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="9a19" class="la lb it bd lc ld ml lf lg lh mm lj lk ll mn ln lo lp mo lr ls lt mp lv lw lx bi translated">用遗传算法解决“旅行商”问题</h1><h2 id="7592" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">导入和超参数</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9436" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将从导入开始，你会看到我们为什么使用下面列出的每一个库。我们还初始化了我们的超参数，就像机器学习算法一样，这些值是任意的，找到它们的最佳值是另一篇文章的主题。但是让我们检查一下每个超参数:</p><ul class=""><li id="23d7" class="nv nw it js b jt ju jx jy kb nx kf ny kj nz kn oa ob oc od bi translated"><strong class="js iu">人口规模(POP_SIZE): </strong>这是我们希望每一代拥有的候选解的数量。在我们的例子中，人口中的每一个人都是推销员将要走的路线。</li><li id="8021" class="nv nw it js b jt oe jx of kb og kf oh kj oi kn oa ob oc od bi translated"><strong class="js iu">迭代次数(N_ITER): </strong>基本上是返回我们的解之前我们将经历的代数。每一次迭代都有一个不同的群体，这个群体应该比前一个群体有更好的整体适应度。</li><li id="3232" class="nv nw it js b jt oe jx of kb og kf oh kj oi kn oa ob oc od bi translated"><strong class="js iu">精英主义因子(ELITISM_FAC): </strong>如前所述，选择父母为下一个群体繁殖是概率性的，因此有可能丢弃具有最高适应性的个体。Elistism确保了最优秀的个体(在我们的例子中是10个)被自动传递给下一代。</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="be61" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated"><strong class="ak">问题</strong></h2><p id="b5d5" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">一个销售人员想穿过几个城市回到起点城市，所以我们想找到一条他能走的最短距离的最佳路径。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e3b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在用代码编写旅行推销员问题，这里我们定义了一个类对象<strong class="js iu"> travelingSalesman() </strong>我们设置了我们想要访问的城市的数量和范围。我们假设我们的城市使用<strong class="js iu"> (x，y) </strong>坐标绘制在2D图上。xy_range是沿x和y轴的最大距离，所以我们在随机整数生成器中使用这个值来随机化我们城市的坐标。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="4d5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们必须开始定义我们的遗传算法将使用的核心函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5b13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，<strong class="js iu"> generateRoute() </strong>方法生成一条随机路径。这可以简单地通过重新排列城市列表来完成，路线被定义为一个大小为25的列表，其中每一项都是一个城市的元组，因此它们的排序定义了我们要走的路线，所以简单地重新排列城市列表给了我们一个随机化的路线。我们将用它来初始化我们的人口。</p><p id="0e5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> getDistance(route) </strong>使用毕达哥拉斯定理返回给定路线在路线列表中每个相邻城市之间的距离。最后，因为我们希望销售人员返回到他出发的城市，所以我们使用if语句来检查我们是否在路线的最后一个城市。</p><p id="726e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">计算适合度(路线)</strong>适合度是我们试图优化的指标，因此，由于我们试图找到距离最短的路线，所以适合度可以定义为距离的倒数。我使用值100，000作为命名者，而不是1，只是因为这样更容易阅读适应性值，所以我们将得到2.4，而不是0.000024，但它们都是一样的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="4707" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">形象化</h2><p id="839d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">最后，对于我们的<strong class="js iu"> travelingSalesman() </strong>类，我们将添加这两个函数来给我们一个网格和路线的可视化。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7079" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> plotCities() </strong>中，我们只是用matplotlib将城市标为‘蓝色O’。在<strong class="js iu"> plotRoute(route) </strong>中，我们在我们的城市之间绘制线条，以查看我们正在走的道路。我没有花时间实际编号这些线，但它仍然应该是一个有用的可视化，你会看到优化的路径看起来更干净。这是我们的基线图:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/a54889ed85bee6349f83dea2e5fe0620.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*PLNISvIq0PsDVWVscU-TYw.png"/></div></figure><p id="00d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能注意到了，这并不是一条有效的途径。我们从这里得到的距离大约是25，000。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="ec77" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">选择</h2><p id="b2c6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">既然我们已经完成了问题的编码，我们可以从遗传算法开始。首先，我们定义一个选择函数，该函数接受群体，这里群体是一个数据帧，其中一列是实际的个体(解决方案)，第二列是对应于每条路线的“适合度”。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5459" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用轮盘赌技术来选择父母，这些父母将被提供给我们的交叉函数，并返回一个新的个体用于下一代。</p><p id="8194" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">轮盘赌是通过定义一个概率分布来应用的，因此适应度越高，我们选择那个个体的机会就越高。这是通过迭代适应度列表并将每个适应度值除以适应度和来完成的，这样我们的概率分布总计为1。然后，我们使用numpy的random.choice返回基于该分布的个人指数。</p><h2 id="6126" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">杂交(育种)</h2><p id="71d3" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这就是奇迹发生的地方，我们本质上是合并两个解决方案，给我们一个新的个体，它将被传递给下一代。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d799" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了为我们的子解决方案创建染色体，我们从第一个父代中随机选取一部分，附加到染色体的第一部分(child1 ),并使用第二个父代中的城市填充染色体的剩余部分，条件是该项目不在我们的染色体中，因为我们不想在我们的路线中重复出现相同的城市，然后我们将这两部分相加以返回新的个体。</p><h2 id="6920" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">我们模型的基线</h2><p id="5821" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">现在我们可以开始把所有东西放在一起了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="4e8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先初始化我们的<strong class="js iu"> travelingSalesman() </strong>对象，为了获得初始性能的基线，我们生成一条随机路线并使用我们之前定义的可视化函数，然后打印路线的距离。</p><h2 id="0cdf" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">初始化群体</h2><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e88f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，此处的群体是一个包含2列的数据框架，一列用于解决方案/个体，另一列用于与我们的<strong class="js iu"> selectParents() </strong>函数所使用的每个个体相对应的适合度。</p><p id="b0f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们用随机路线的设定群体大小(POP_SIZE)填充我们的数据帧，并计算每条路线的适合度，并将其添加到“适合度”列。最后，我们在保留索引的同时，根据适合度对数据帧进行降序排序。</p><h2 id="c724" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">实现遗传算法</h2><p id="2275" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">最后，我们可以开始迭代寻找最佳解决方案。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5bc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们初始化一个列表evolved_pop，我们将使用<strong class="js iu"> crossover() </strong>函数填充它，直到它达到所需的100个种群大小，之后我们用新的进化种群替换以前的“解决方案”列，重新计算适应值并对数据帧进行排序。</p><p id="e214" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">精英主义在填充进化的一代之前被应用，使得我们的进化列表中的前10个值是来自先前群体的前10个解决方案。</p><p id="f989" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在迭代过程之后，我们从我们的群体数据框架中取出具有最高适合度的解决方案，并将其作为我们的最终解决方案返回。</p><h2 id="c1ec" class="nd lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">结果</h2><p id="9b92" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们从大约25，000的总距离开始，我们的最终解决方案以大约9，000结束。我们也可以看看标绘的路径，它看起来更清晰，比随机的路径更有意义:</p><div class="kp kq kr ks gt ab cb"><figure class="ok kt ol om on oo op paragraph-image"><img src="../Images/a54889ed85bee6349f83dea2e5fe0620.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*PLNISvIq0PsDVWVscU-TYw.png"/></figure><figure class="ok kt ol om on oo op paragraph-image"><img src="../Images/bb4399bd54ff6b244f5d6f192ebd6a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*KNATjkSc38DEBHvIiT5dCg.png"/><figcaption class="mr ms gj gh gi mt mu bd b be z dk oq di or os translated">优化前后的路线</figcaption></figure></div><h1 id="0ef5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论和最终想法</h1><p id="7b76" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">总之，在这篇文章中，我们讨论了遗传算法及其应用，并用python实现解决了“旅行推销员”问题。我第一次接触遗传算法是在我的大学课程中，但并没有真正费心去完全理解它们的机制。在看到它们是如此简单易学，而且被证明是非常强大之后，我决定把它添加到我的“机器学习武库”中。遗传算法肯定有更多有趣的应用，例如使用它们来学习神经网络权重和超参数调整。这可能是我下一篇文章的主题。</p><p id="d930" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你发现理解一个概念有任何困难，我的建议是摆弄一下<strong class="js iu"> </strong> <a class="ae md" href="https://gist.github.com/mohdabdin/09242eb84af9f04c1271fe110c5e5378" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">代码，你可以在这里找到</strong> </a>。希望你发现这篇文章有价值和快乐编码！:)</p></div></div>    
</body>
</html>