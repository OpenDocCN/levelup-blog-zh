<html>
<head>
<title>Flatten Binary Tree to Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将二叉树扁平化为链表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flatten-binary-tree-to-linked-list-ae1969564df4?source=collection_archive---------12-----------------------#2021-10-30">https://levelup.gitconnected.com/flatten-binary-tree-to-linked-list-ae1969564df4?source=collection_archive---------12-----------------------#2021-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="eafb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给定一棵二叉树的<code class="fe ko kp kq kr b">root</code>，将该树展平成一个“链表”:</p><ul class=""><li id="57b4" class="ks kt it js b jt ju jx jy kb ku kf kv kj kw kn kx ky kz la bi translated">“链表”应该使用相同的<code class="fe ko kp kq kr b">TreeNode</code>类，其中<code class="fe ko kp kq kr b">right</code>子指针指向列表中的下一个节点，而<code class="fe ko kp kq kr b">left</code>子指针总是<code class="fe ko kp kq kr b">null</code>。</li><li id="3712" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated">“链表”的顺序应该与二叉树的<a class="ae lg" href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">前序遍历</strong> </a>相同。</li></ul><p id="8645" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">例1: </strong></p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/003462917b5acc9356c5a90204a8efb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FTwaAuO0by8FlDOi.jpg"/></div></div></figure><pre class="li lj lk ll gt lt kr lu lv aw lw bi"><span id="a223" class="lx ly it kr b gy lz ma l mb mc"><strong class="kr iu">Input:</strong> root = [1,2,5,3,4,null,6]<br/><strong class="kr iu">Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]</span></pre><p id="129d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">例二:</strong></p><pre class="li lj lk ll gt lt kr lu lv aw lw bi"><span id="03d8" class="lx ly it kr b gy lz ma l mb mc"><strong class="kr iu">Input:</strong> root = []<br/><strong class="kr iu">Output:</strong> []</span></pre><p id="9f3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">例3: </strong></p><pre class="li lj lk ll gt lt kr lu lv aw lw bi"><span id="6993" class="lx ly it kr b gy lz ma l mb mc"><strong class="kr iu">Input:</strong> root = [0]<br/><strong class="kr iu">Output:</strong> [0]</span></pre><p id="8653" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">约束:</strong></p><ul class=""><li id="d9d7" class="ks kt it js b jt ju jx jy kb ku kf kv kj kw kn kx ky kz la bi translated">树中的节点数在范围<code class="fe ko kp kq kr b">[0, 2000]</code>内。</li><li id="792d" class="ks kt it js b jt lb jx lc kb ld kf le kj lf kn kx ky kz la bi translated"><code class="fe ko kp kq kr b">-100 &lt;= Node.val &lt;= 100</code></li></ul><h1 id="9155" class="md ly it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">解决方案1带堆栈的DFS:</h1><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi na"><img src="../Images/411dec4fe058db90ce7ccfdc6440fe13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbF5d9YWQ9nSOaw5j9IZvg.png"/></div></div></figure><p id="6e04" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间和空间复杂度= O(N)</p><blockquote class="nb nc nd"><p id="e52c" class="jq jr ne js b jt ju jv jw jx jy jz ka nf kc kd ke ng kg kh ki nh kk kl km kn im bi translated"><strong class="js iu">跟进:</strong>你能原地把树放平吗(有<code class="fe ko kp kq kr b">O(1)</code>额外空间)？</p></blockquote><p id="f9b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在O(1)中解决这个问题的前景在开始时可能看起来很棘手，但是您需要知道的是前序遍历是如何工作的。这个解决方案的关键直觉是在我们进行的过程中保持“预定”顺序。</p><p id="0328" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们在沿着树往下走的时候维护一个指针<code class="fe ko kp kq kr b">curr</code>。如果<code class="fe ko kp kq kr b">curr</code>有一个左边的子节点，我们想在保持顺序的情况下将它移到右边。这将是两个步骤的过程。<br/>创建另一个指针<code class="fe ko kp kq kr b">p</code>在左子树中找到最右边的点。然后我们将<code class="fe ko kp kq kr b">curr.right</code>的内容转移到<code class="fe ko kp kq kr b">p.right</code>中。如果你注意的话，我们现在拥有的树(图中的阶段2)仍然给出完全相同的前序遍历。所以现在我们只要把它移到<code class="fe ko kp kq kr b">curr</code>的右边。</p><p id="72b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向右移动<code class="fe ko kp kq kr b">curr</code>并重复。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi ni"><img src="../Images/bb0f6b3b8c775ca06e5c12a2e873d063.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9kUPmwjAGiE_z7tn.png"/></div></div></figure><pre class="li lj lk ll gt lt kr lu lv aw lw bi"><span id="8707" class="lx ly it kr b gy lz ma l mb mc">class Solution:<br/>    def flatten(self, root: TreeNode) -&gt; None:<br/>        curr = root<br/>        <br/>        while curr:<br/>            if curr.left != None:<br/>                p = curr.left<br/>                while p.right != None:<br/>                    p = p.right<br/>                    <br/>                p.right = curr.right<br/>                <br/>                curr.right = curr.left<br/>                curr.left = None<br/>            <br/>            curr = curr.right</span></pre><p id="f775" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">👏想支持我成为一名中等会员吗？点击<a class="ae lg" href="https://machinelearningabc.medium.com/membership" rel="noopener">这里</a>。</strong></p></div></div>    
</body>
</html>