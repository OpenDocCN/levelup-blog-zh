<html>
<head>
<title>Using Extension Methods in C# to Build Fluent Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C#中的扩展方法构建流畅的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-extension-methods-in-c-to-build-fluent-code-1735fbc9b525?source=collection_archive---------2-----------------------#2020-01-18">https://levelup.gitconnected.com/using-extension-methods-in-c-to-build-fluent-code-1735fbc9b525?source=collection_archive---------2-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9822" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">扩展方法是现代。NET和一些。NET的最佳功能，如LINQ。不幸的是，许多开发人员被它们吓住了，不明白在表面下发生了什么，也不知道如何构建新的。在本文中，我将试图揭开扩展方法的神秘面纱，并说明如何使用它们来构建优雅流畅的代码。</p><h1 id="50a7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">基础知识:静态方法</h1><p id="b759" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了讨论扩展方法，我们必须首先讨论静态方法。</p><p id="d0e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">静态方法就是用<code class="fe lr ls lt lu b">static</code>关键字声明的方法。这说明。NET中，该方法不是在特定实例的基础上操作，而是作为一个整体附加到该类。因为这些方法是静态的，所以它们不能访问任何特定实例的状态，除非它作为参数传递给方法(稍后将详细介绍)。</p><p id="4849" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与<code class="fe lr ls lt lu b">String.IsNullOrEmpty</code>一样，<code class="fe lr ls lt lu b">Integer.Parse</code>方法也是一个相当著名的静态方法。</p><p id="ddb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文的整个过程中，我们将构建一个获取图书信息的方法，所以让我们创建一个静态方法来构建图书列表。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/8dea99a4728336a9445e5321f7e0cff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoVbVmKP1BX4RKqHR_6eOw.png"/></div></div></figure><p id="d698" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，要打电话去取我们的书，我们只需这样做:</p><p id="cd97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lr ls lt lu b">var books = Books.GetBooks();</code></p><p id="16ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用起来非常简单。</p><h1 id="1536" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">扩展方法</h1><p id="d5a1" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">接下来让我们把注意力转向扩展方法。</p><p id="6ee8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，扩展方法是专门声明的静态方法，编译器允许您对匹配其签名的对象进行调用。</p><p id="3216" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我告诉你我的意思。</p><p id="59be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有以下静态方法:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mh"><img src="../Images/62017de8a9a0da08bade4a63de0b5926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IzQ7QFhK6O6DY20N"/></div></div></figure><p id="a0c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们可以取任何一个<code class="fe lr ls lt lu b">Book</code>实例，并将其传递给<code class="fe lr ls lt lu b">Books.IsBoring</code>，得到一个布尔响应。</p><p id="e9bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们把这个改成一个扩展方法吧。</p><p id="e4c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于扩展方法只能在静态类(不能被实例化并且只有静态成员的类)中声明，我们需要在我们的类中添加<code class="fe lr ls lt lu b">static</code>关键字。</p><p id="45fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们通过将关键字<code class="fe lr ls lt lu b">this</code>添加到第一个参数中，将<code class="fe lr ls lt lu b">IsBoring</code>方法声明为扩展方法，如下所示:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mh"><img src="../Images/600cada650057a87455415d3e488d574.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yCNW_dkfTSsHyhDL"/></div></div></figure><p id="eecb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lr ls lt lu b">this</code>关键词在说明什么。NET的一个特点是<code class="fe lr ls lt lu b">IsBoring</code>是一个扩展方法，既可以通过静态方法语法调用，如<code class="fe lr ls lt lu b">Books.IsBoring(someBook)</code>，也可以通过扩展方法语法调用，如<code class="fe lr ls lt lu b">someBook.IsBoring()</code>。</p><p id="29dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意扩展方法语法中的<code class="fe lr ls lt lu b">this</code>关键字<em class="mi">只能</em>用于第一个参数，即该方法扩展的类型或接口。</p><p id="1e55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">扩展方法是让编译器将扩展方法样式调用替换为静态方法调用的语法糖。</p><p id="9552" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，最终的结果是扩展方法让你<em class="mi">出现</em>以将新的功能附加到其他类或接口上。这是它们的主要优势，因为扩展方法允许您简化调用语法，代价是模糊了向普通读者声明方法的确切位置。</p><p id="edd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们知道了什么是扩展方法，让我们看看如何使用它们来构建一种流畅的语法或特定于领域的语言。</p><h1 id="db66" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">将扩展方法链接在一起</h1><p id="2830" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">假设您想要创建一本书，并且需要执行一些操作来创建一个有效的书。如果您想提供一个相当灵活和可读的API，您可以使用扩展方法来创建一个小型领域特定语言(DSL)。</p><p id="9906" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我们的最终目标是创建一个根据我们配置的值定制的book对象。</p><p id="f354" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们首先关注最终结果:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mj"><img src="../Images/789fbdaede90b70bdbddf3ce3dd7c2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32BpAaHG2iqIOq0OiW57fQ.png"/></div></div></figure><p id="c2d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那里发生了很多事，但可能没有你想的那么多。</p><p id="592d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从<code class="fe lr ls lt lu b">Books.CreateBook</code>通话开始。这是一个静态方法调用，它接受一个表示书名的字符串，并返回某个神秘对象。</p><p id="f8df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们称这个对象为<code class="fe lr ls lt lu b">BookBuilder</code>，它看起来像这样:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mh"><img src="../Images/65acf6a0650c24c5c89964818ff8ce2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WN6cJc0LmGadD5Y0"/></div></div></figure><p id="2463" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，现在这可能更有意义了。这意味着我们的<code class="fe lr ls lt lu b">CreateBook</code>静态方法看起来像这样:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mh"><img src="../Images/25880b20a457889e399342fc2d6b5d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uyq-7SaDVMycGryG"/></div></div></figure><p id="7c41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一个例子是我们调用<code class="fe lr ls lt lu b">WrittenBy</code>。嗯，<code class="fe lr ls lt lu b">BookBuilder</code>类没有定义这个方法。在一个普通的应用程序中，我们可能只是将方法添加到<code class="fe lr ls lt lu b">BookBuilder</code>，但是这不会让我们在这里使用扩展方法，所以让我们假设<code class="fe lr ls lt lu b">BookBuilder</code>类是由一些我们无法控制和修改的代码定义的。</p><p id="5a34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将通过添加一个扩展方法来处理<code class="fe lr ls lt lu b">WrittenBy</code>方法:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mh"><img src="../Images/f138debc5db4d87ec67678852deb4a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CyxWsw2mvnZU6O3S"/></div></div></figure><p id="187a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个非常简单的方法，但是这里有一些关键的东西。</p><p id="1246" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，由于参数签名中的<code class="fe lr ls lt lu b">this</code>关键字，该方法充当了<code class="fe lr ls lt lu b">BookBuilder</code>实例的扩展方法。</p><p id="355e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二，调用方法时只指定了<strong class="js iu">一个</strong>参数(例如<code class="fe lr ls lt lu b">WrittenBy("Michael Crichton")</code>，因为第一个参数是根据调用扩展方法的<code class="fe lr ls lt lu b">BookBuilder</code>推断出来的。</p><p id="fb65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三，我们正在返回我们得到的同一个<em class="mi">构建器</em>实例。我们返回这个参数的原因完全是为了支持流畅的语法，就像我们在前面的例子中看到的那样，并且允许在前面的扩展方法的返回结果上调用扩展方法。</p><p id="8688" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终的静态类可能如下所示:</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mh"><img src="../Images/af7316dda4d1f7d12bd32462762ee1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ox2E5Xa1z_67tjVm"/></div></div></figure><p id="ff19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能看起来不像你见过的最漂亮的代码，但它可以创建的语法类型可以非常强大和漂亮。</p><h1 id="c722" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">让我们来谈谈LINQ</h1><p id="1c00" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">扩展方法被明确地添加到C#语言中，以便支持在中集成的语言(LINQ)。NET框架3.5。</p><p id="0ba7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就开发人员的生产力而言，LINQ是我最喜欢的C#特性之一，如果没有扩展方法，这一切都不可能实现。</p><p id="2d49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LINQ让你做的事情有:</p><p id="5a49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许这是一个有点傻的例子，但这一切都是通过使用扩展方法来实现的，这些方法接受<code class="fe lr ls lt lu b">IEnumerable&lt;T&gt;</code>或<code class="fe lr ls lt lu b">IQueryable&lt;T&gt;</code>并使用各种<code class="fe lr ls lt lu b">Func</code>签名来过滤、排序或转换集合。</p><p id="84d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，如果你真的想，你可以使用扩展方法，用几乎完全相同的语法编写你自己版本的LINQ。请不要这样做——微软已经做得很好了——但是扩展方法的能力允许你这样做。</p><h1 id="de32" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结束语</h1><p id="62ee" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">希望这能揭开扩展方法、LINQ以及静态和实例方法背后的神秘面纱。</p><p id="66d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我确信扩展方法(以及LINQ的扩展)是生产率提高的关键之一。NET技术，以及像基础类库、公共语言运行库、Visual Studio和泛型这样的东西。</p><p id="79f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然您可能没有创建或者甚至没有考虑过扩展方法，但是它们为我们在现代中所做的许多事情提供了动力。NET和它们提供的灵活性可以成为一个好的工具。</p><p id="3cd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">马特是一线。NET和JavaScript软件工程经理，重点关注指导、架构和软件质量。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="96e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mi">原载于2020年1月18日https://killalldefects.com</em><a class="ae mr" href="https://killalldefects.com/2020/01/18/using-extension-methods-in-c-to-build-fluent-code/" rel="noopener ugc nofollow" target="_blank"><em class="mi"/></a><em class="mi">。</em></p></div></div>    
</body>
</html>