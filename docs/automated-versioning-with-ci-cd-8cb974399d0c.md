# 使用 CI/CD 实现自动化版本控制

> 原文：<https://levelup.gitconnected.com/automated-versioning-with-ci-cd-8cb974399d0c>

## 凹凸版本:2020.12.28.2-dev → 2020.12.28.2

![](img/c777d9f627cf3c3088e3e1688aaa6be6.png)

照片由 [Fotis Fotopoulos](https://unsplash.com/@ffstop?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

在本文中，我将向您展示一个如何使用 CI/CD 基于日期自动化版本控制的例子。我将使用 Bitbucket 和 Bitbucket 管道，但是您可以使用任何 Git 和 CI/CD 工具，只要它们公开 API 端点来创建、批准和合并 pull 请求。我将使用 bump2version 来增加版本号，但是这些原则当然也可以应用于其他工具。

# 版本控制结构

在我们的例子中，我们希望构建类似于`2020.12.28.1`或`2020.12.28.5-dev`的版本，其中前三段组合起来是日期:`year.month.day`，最后一个数字是当天发布的数量，可选地带有一个`dev`(开发)标签，这样您就可以在一天内发布更多的版本。您还可以选择用时间替换这个发布号，这样您的标签看起来就像下面这样:`year.month.day.hour.minute`或`2020.12.28.09.00`。

## 您将需要:

*   存储库中启用的管道。
*   bot 的 Bitbucket 帐户，可以对您的存储库进行写访问。

# 储存库变量

您不希望在管道配置中添加硬编码的 bot 帐户的位存储桶凭据。我们将它们设置为可以在管道中访问的(安全的)存储库变量。在您的存储库设置中，转到存储库变量并添加两个新的存储库变量:

*   名称:**bit bucket _ BOT _ USERNAME**
    值:您刚刚创建的 Bitbucket Bot 帐户的用户名。
*   名称:**bit bucket _ BOT _ PASSWORD**
    值:您刚刚创建的 Bitbucket bot 账户的密码。
    同时勾选`Secured`复选框。

# 添加 Bumpversion 配置

[Bump2version](https://pypi.org/project/bump2version/) 需要一个配置文件(. bumpversion.cfg 或 setup.cfg)，您可以在其中配置您的版本外观以及您希望在版本升级时更新的文件。请将. bumpversion.cfg 或 setup.cfg(我使用的是后者)添加到您的存储库中，其根目录包含以下内容:

`[bumpversion:file:filename]`块表示在版本升级时需要更新哪些文件。它将在文件中寻找当前的标签，在这个例子中是`2020.12.28.1`，并用新的标签替换它，例如`2020.12.28.2`。注意:如果 bumpversion 在这个文件中找不到当前标记，它将抛出一个错误，您的管道将失败。因此，如果您的目录中没有 pyproject.toml，请删除该块，或者用包含当前版本号的另一个文件替换它。请将 version.txt 块保存在该文件中，我们将使用该文件实际创建正确的版本。

# 添加版本文件

将 version.txt 文件添加到存储库的根目录中。作为内容，添加对应于 setup.cfg → `current_version`的值，在我们的例子中是`2020.12.28.1`。请确保 version.txt 只包含版本号，不包含其他信息！

# 添加位桶管道配置文件

将 bitbucket-pipelines.yml 文件添加到项目文件夹的根目录，并添加以下内容。请注意，这是管道的最小设置，不包含任何部署逻辑。我将在下面解释管道中发生的事情。

【2022 年 3 月更新:我们遇到了标签不再包含在构建上下文中的问题。您可能希望在设置`NUMBER_RELEASES`之前手动获取所有标签，使用:

```
git fetch -all -tags
```

## 提升到开发步骤

我将从解释“提升到开发”这一步中发生的事情开始。请注意，我用 3 个点(…)替换了另一个配置，以突出显示该特定步骤，请不要使用下面的代码片段，而是始终使用上面的代码片段。

这是一个手动的步骤(所以你每次都必须按下‘Run’)，可以在将变更引入开发时运行。在我的情况下，我想决定什么时候创建一个新版本。自动化这些步骤还会导致流水线循环，这必须用额外的逻辑来解决。

首先，安装所需的依赖项。jq 需要解析来自 curl 命令的 JSON 响应。实际创建新版本需要 bump2version。

安装完依赖项后，获取 UTC 日期并解析为`year.month.day`。这将在我们的版本中使用。但是我们还需要日期来获取我们当天已经创建的发布量。

我们可以通过执行下面的命令获得从当前日期开始并以`dev`结束的所有 git 标签(因为我们想要部署一个创建开发版本:`git tag -l "v${DATE}*-dev"`)。这将输出如下内容:

```
v2020.12.28.1-dev
v2020.12.28.2-dev
```

然后我们可以计算用`wc -l`输出的`git tag`命令的行数，并将其存储为一个名为`NUMBER_RELEASES`的变量。

```
NUMBER_RELEASES=$(git tag -l "v${DATE}*-dev" | wc -l)
```

我们可以稍后使用这个数字来计算当天的新发布号。
下一步是“试运行”bumpversion 命令(注意`--no-commit --no-tag --allow-dirty`标志)。

这些标志确保该命令不会影响我们的存储库的远程状态，而是临时在管道内本地撞击新版本。然后，通过阅读 version.txt，我们知道我们的新版本是什么，我们可以创建一个包含新版本名称的新发布分支。

这个 release 分支实际上是用来创建新版本和 git 标签的，因为我不想直接在 development 分支上这样做，而且我的 development 分支上总是有写保护。

在检查完管道中的这个发布分支后，我用`git reset — hard HEAD~0`重置了 bumpversion 所做的更改，所以这次我们可以真正创建新版本了。

在转储这个版本之后，我们将更改——提交更新 setup.cfg 文件中指定的版本和新标签——推送到远程存储库。然后我们有了一个新的发布分支，它带有一个用我们的新版本标记的提交。

您接下来可以做的是从我们的新发布分支手动创建一个 pull 请求到开发，但是我也想自动化这个步骤。

**自动合并新版本
下面的代码负责创建一个 pull 请求并合并它。再次注意:我用 3 个点替换了另一个配置。**

您可以使用 Bitbucket API 创建一个端点为`https://api.bitbucket.org/2.0/repositories/${BITBUCKET_REPO_FULL_NAME}/pullrequests`的 pull 请求。这是一个 POST 请求，您必须将 Bitbucket 用户的凭证添加到请求中，同时添加一个请求体(JSON，转义为一行程序)，您可以在下面看到(修饰过的)。

当请求成功时，您将检索一个包含 URL 的响应主体，以合并新创建的 pull 请求。您可以使用 jq 解析响应并检索`.links.merge.href`值。然后，您可以使用这个值(它是一个 URL)发出一个新的 curl 请求。这也是一个 POST 请求。

## 提升到生产步骤

“升级到生产”步骤与“升级到开发”步骤略有不同。

此步骤仅在创建并推送带有`-dev`的版本时可用。这将自动触发标记管道，然后您可以手动触发“升级到生产”步骤。另一个略有不同的是，将有两个合并。

让我们假设我们刚刚创建了版本`2020.12.28.1-dev`。当该版本创建成功并推送到远程时，会触发`pipelines.tags.v*-dev`。

当执行手动步骤“Promote to prod”时，版本将被转移到`2020.12.18.1`(末尾没有-dev)。在此过程中创建的发布分支将被合并到开发中，但是在此之后，开发也将被自动合并到主开发中。

这远远不是一个理想的情况，肯定可以优化，因为它可能会发生，新的功能已被拉入开发，但对我们来说，这将是现在。

您可能希望将发布分支分别拉进开发和主控，而不是在将发布分支拉进开发之后再将开发拉进主控，但是这取决于您自己！

# 自动化部署

示例中不包括自动部署。然而，根据您的需要，您可以在`pipelines.tags.v*`或`pipelines.tags.v*-dev`中添加构建和部署步骤。

# 问题、建议或反馈

如果您对本文有任何问题、建议或反馈，请告诉我！