<html>
<head>
<title>Using CRUD operations with React SWR for mutating REST API cache</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有React SWR的CRUD操作来改变REST API缓存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-crud-operations-with-react-swr-for-mutating-rest-api-cache-3e0d01774aed?source=collection_archive---------1-----------------------#2020-11-20">https://levelup.gitconnected.com/using-crud-operations-with-react-swr-for-mutating-rest-api-cache-3e0d01774aed?source=collection_archive---------1-----------------------#2020-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ce82a7d4a8428ba0788dacab38dcd479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6M53Kj8SusEGCCBd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">弗兰基·查马基在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="5e8c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll">在Twitter上关注我，免费获得这篇文章和其他文章:</em><a class="ae kf" href="https://twitter.com/Not_TheAuthor" rel="noopener ugc nofollow" target="_blank"><em class="ll">@ N</em>ot _ the author</a></p><h1 id="b1a4" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">用于发出获取请求的SWR</strong></h1><p id="f087" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">Vercel过去已经开发了一些很棒的库和框架，所以SWR库会有所不同也就不足为奇了。我将向您展示如何使用Vercel的SWR库从REST API中获取和操作数据。这篇文章对Vercel库做了一个快速的概述，但是如果你想了解更多关于这个库以及它是如何工作的，你可以在这里阅读完整的文档。</p><div class="mp mq gp gr mr ms"><a href="https://swr.vercel.app/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">SWR: React钩子获取数据</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">React钩子库获取数据“SWR”这个名字来源于stale-while-revalidate，一个HTTP缓存失效…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">应用程序</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jz ms"/></div></div></a></div><h1 id="2569" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">什么是SWR？</strong></h1><p id="b62b" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">SWR背后的理念代表着在重新验证时过时，在文件中是这样定义的。SWR是一种策略，首先从缓存返回数据(陈旧)，然后发送获取请求(重新验证)，最后获得最新数据那么这和CRUD有什么关系呢？如果您不知道CRUD是对数据执行的一组操作，它是创建、读取、更新和删除的简写。默认情况下，SWR将通过返回获取请求的结果来为您执行读取部分。但是如果您想要扩展它，您将不得不从该请求中改变缓存。这就是为什么我创建了一个useCrud钩子来帮助我们做到这一点。我还加入了Typescript，以确保在更新缓存时使用正确的键，因此您也需要进行设置。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="fdde" class="lm ln it bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated"><strong class="ak">设置事物</strong></h1><p id="98dc" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">所以第一件事是安装SWR，运行:</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="88ee" class="nv ln it nr b gy nw nx l ny nz">npm install swr<br/>or<br/>yarn add swr</span></pre><p id="855d" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这将把SWR图书馆添加到您的项目中。接下来，我们将为我们的应用程序添加一个配置提供程序。当我们发出请求时，这将为SWR提供全局配置。我有一个上下文文件夹，在那里我存储这样的上下文。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="5a16" class="nv ln it nr b gy nw nx l ny nz">import * as React from ‘react’<br/>import { SWRConfig } from ‘swr’</span><span id="7de3" class="nv ln it nr b gy oa nx l ny nz">const swrConfig = {<br/> revalidateOnFocus: false,<br/> shouldRetryOnError: false<br/>}</span><span id="2894" class="nv ln it nr b gy oa nx l ny nz">export const SWRConfigurationProvider: React.FC = ({ children }) =&gt; &lt;SWRConfig value={swrConfig}&gt;{children}&lt;/SWRConfig&gt;</span></pre><p id="09c3" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这将需要围绕你的应用程序根，对我来说是在pages/_app.tsx文件中，因为我使用NextJS，但它可以在另一个框架中工作，如Gatsby，只要它在全局范围内包装你的应用程序。您可以根据项目需要随意更改设置。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="9304" class="lm ln it bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated">你准备好阅读一些数据了吗？</h1><p id="354e" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">现在我们需要开始实现fetch，这将构成钩子的基础。这里有一个在SWR如何抓取的例子。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="6e3d" class="nv ln it nr b gy nw nx l ny nz">const fetcher = useCallback(<br/> async (url: string) =&gt; {<br/> const response = await fetch(url)<br/> return response as T[]<br/> },<br/> []<br/> )</span><span id="6565" class="nv ln it nr b gy oa nx l ny nz">const { data, error, isValidating, mutate } = useSWR(url, fetcher, {<br/> …fetchOptions<br/> })</span></pre><p id="088f" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">useSWR挂钩非常简单，它接受一个url和一个“获取器”,获取器是执行请求的函数。url被传递给获取器以发出请求，您也可以提供一些漂亮的选项。SWR会返回一些东西给你首先是返回的数据，一个错误状态(如果有的话)，一个变异函数，和一个isValidating布尔值，它会告诉你数据是否是新的。您可以将isValidating标志视为加载指示器；这不是一回事，但对我来说是一回事。</p><p id="5782" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在放置定制钩子的地方创建一个use-crud.tsx文件，并将其添加到start。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="fa20" class="nv ln it nr b gy nw nx l ny nz">import useSWR, { ConfigInterface } from ‘swr’<br/>import { useCallback } from ‘react’</span><span id="768d" class="nv ln it nr b gy oa nx l ny nz">// T is the response type<br/>// K is the request type which defaults to T<br/>export function useCrud&lt;T, K = T&gt;(url: string, key: keyof T, fetchOptions?: ConfigInterface) {<br/> const fetch = useCallback(<br/> async (url: string) =&gt; {<br/> const response = await fetch(url)<br/> return response as T[]<br/> },<br/> []<br/> )</span><span id="2ece" class="nv ln it nr b gy oa nx l ny nz">const { data, error, isValidating, mutate } = useSWR(url, fetch, {<br/> …fetchOptions<br/> })</span><span id="cc28" class="nv ln it nr b gy oa nx l ny nz">return {<br/> fetch: {<br/> data,<br/> error,<br/> loading: isValidating,<br/> mutate<br/> }<br/> }<br/>}</span></pre></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="c633" class="lm ln it bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated">使其对用户友好</h1><p id="152c" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">稍后我将介绍参数和类型，但现在您需要知道的是，我们将能够向这个钩子传递一个url，它将为我们提供数据和方法来对这些数据执行CRUD操作。我遇到了一个问题。有时我的应用程序响应太快，因为我们有缓存的数据可以依靠，所以我添加了一个加载状态和超时，使请求至少需要半秒钟。这将改善用户体验。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="0ac3" class="nv ln it nr b gy nw nx l ny nz">import { useCallback, useEffect, useState } from ‘react’<br/>import useSWR, { ConfigInterface } from ‘swr’</span><span id="39c2" class="nv ln it nr b gy oa nx l ny nz">// T is the response type<br/>// K is the request type which defaults to T<br/>export function useCrud&lt;T, K = T&gt;(url: string, key: keyof T, fetchOptions?: ConfigInterface) {<br/>const [loading, setIsLoading] = useState(true)</span><span id="12b2" class="nv ln it nr b gy oa nx l ny nz">const loadingTimeout = () =&gt; {<br/> setIsLoading(false)<br/> }</span><span id="2299" class="nv ln it nr b gy oa nx l ny nz">const fetch = useCallback(<br/> async (url: string) =&gt; {<br/> const response = await fetch(url)<br/> return response as T[]<br/> },<br/> []<br/> )</span><span id="6b35" class="nv ln it nr b gy oa nx l ny nz">const { data, error, isValidating, mutate } = useSWR(url, fetch, {<br/> …fetchOptions<br/> })</span><span id="3d00" class="nv ln it nr b gy oa nx l ny nz">useEffect(() =&gt; {<br/> if (isValidating) {<br/> setIsLoading(true)<br/> return<br/> }</span><span id="0e77" class="nv ln it nr b gy oa nx l ny nz">setTimeout(loadingTimeout, 500)<br/> }, [isValidating])</span><span id="24e2" class="nv ln it nr b gy oa nx l ny nz">return {<br/> fetch: {<br/> data,<br/> error,<br/> loading,<br/> mutate<br/> }<br/> }<br/>}</span></pre><p id="5a94" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我需要提一下SWR的一个小怪癖。当请求中没有数据时，返回一个空对象；这不是我真正想要的，所以我增加了一个额外的步骤来检查数据是否为空。为此，我将使用lodash，如果您还没有安装它，请继续安装。如果对象是空的，我将返回一个空数组，更新你的导入来添加这个。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="3440" class="nv ln it nr b gy nw nx l ny nz">import { isArray, isEmpty } from ‘lodash’<br/>import { useCallback, useEffect, useMemo, useState } from ‘react’</span></pre><p id="d354" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">稍后我们将需要isArray方法进行CRUD操作，并且我们将记住数据检查的结果。将此添加到return语句的上方。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="49e5" class="nv ln it nr b gy nw nx l ny nz">const memoizedData = useMemo(() =&gt; (!isEmpty(data) ? data : []), [data])</span></pre><p id="a04e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然后返回memoizedData而不是Data。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="7956" class="nv ln it nr b gy nw nx l ny nz">return {<br/> fetch: {<br/> data: memoizedData,<br/> error,<br/> loading,<br/> mutate<br/> }<br/> }</span></pre></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="a38f" class="lm ln it bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated">我在那里做了什么</h1><p id="1d12" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">现在，您一直在等待的时刻到了，我们将开始修改数据，但在此之前，让我解释一下这个函数的Typescript参数。T泛型类型是我们期望得到的数据类型，K泛型类型是我们将用来执行创建操作的数据类型。在大多数情况下，这将是相同的，但如果我们需要在发送数据之前对其执行一些操作，我们将使用不同的类型。如你所见，如果我们不传递任何东西，它默认为T。参数中的键是T类型的键，这意味着可以使用该类型上的任何属性，但是我们需要告诉typescript索引键是什么，以便我们可以从fetch中改变缓存的数据。创建操作将如下所示。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="9546" class="nv ln it nr b gy nw nx l ny nz">const create = useCallback(<br/> async (newObject: K, shouldRevalidate = false) =&gt; {<br/> const response = await fetch(url, {<br/> body: newObject,<br/> method: ‘POST’<br/> })</span><span id="4645" class="nv ln it nr b gy oa nx l ny nz">const result = response as T</span><span id="d2f3" class="nv ln it nr b gy oa nx l ny nz">if (data &amp;&amp; mutate) {<br/> let newData = data<br/> if (isArray(data)) {<br/> newData = data.concat(result)<br/> }</span><span id="73c5" class="nv ln it nr b gy oa nx l ny nz">await mutate([…new Set(newData)], shouldRevalidate)<br/> }</span><span id="cf90" class="nv ln it nr b gy oa nx l ny nz">return result<br/> },<br/> [url, data, mutate]<br/> )</span></pre></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="68a3" class="lm ln it bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated"><strong class="ak">两个比一个好</strong></h1><p id="48f5" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">这将在我们的url post方法中创建一个新对象。如果我们有数据，它将改变它的缓存，如果我们没有，我们将只返回post的结果。还有一个额外的检查，看看数据是否是一个数组，如果是，我们将添加新的对象到数据数组，如果不是，我们将添加一个新的数据集，并跳过重新验证。我继续添加了一个用于重新验证的参数，如果我们需要新数据而不仅仅是缓存，可以覆盖这个参数。这将调用我们之前得到的mutate函数，并允许我们用新数据改变缓存，并返回新数组应该是什么样子的乐观响应；所有这些都不需要再次获取数据。但是这个方法只能创建一个实例，所以我们也需要一个来创建多个对象。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="05bc" class="nv ln it nr b gy nw nx l ny nz">const createMultiple = useCallback(<br/> async (newObjects: K[], shouldRevalidate = false) =&gt; {<br/> const response = await fetch(url, {<br/> body: newObjects,<br/> method: ‘POST’<br/> })</span><span id="5bdd" class="nv ln it nr b gy oa nx l ny nz">const result = response as T[]</span><span id="e9ae" class="nv ln it nr b gy oa nx l ny nz">if (data &amp;&amp; mutate) {<br/> await mutate([…data, …result], shouldRevalidate)<br/> }</span><span id="c848" class="nv ln it nr b gy oa nx l ny nz">return result<br/> },<br/> [url, data, mutate]<br/> )</span></pre><h1 id="e806" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">给我D</h1><p id="8dae" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">这个单独的方法将处理创建多个对象。一个改进是将这些结合起来，但这也是本教程的目的。接下来，我们将处理CRUD的移除操作。函数应该是这样的。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="f084" class="nv ln it nr b gy nw nx l ny nz">const remove = useCallback(<br/> async (body: number, shouldRevalidate = false) =&gt; {<br/> const response = await fetch(url, {<br/> body,<br/> method: ‘DELETE’<br/> })<br/> const result = response as T</span><span id="7023" class="nv ln it nr b gy oa nx l ny nz">if (data &amp;&amp; mutate) {<br/> if (isArray(result)) {<br/> const updatedObjects = […data].filter((current) =&gt; {<br/> const isDeleted = result.find((result) =&gt; result[key] === current[key])<br/> return !isDeleted<br/> })</span><span id="eebf" class="nv ln it nr b gy oa nx l ny nz"> await mutate(result.length === 0 ? [] : updatedObjects, shouldRevalidate)<br/> } else {<br/> const deletedIndex = data.findIndex((object) =&gt; object[key] === result[key])</span><span id="55cd" class="nv ln it nr b gy oa nx l ny nz">if (deletedIndex &gt;= 0) {<br/> const updatedObjects = […data]<br/> updatedObjects.splice(deletedIndex, 1)</span><span id="6158" class="nv ln it nr b gy oa nx l ny nz">        await mutate(updatedObjects, shouldRevalidate)<br/>       }<br/>    }<br/> }</span><span id="92c6" class="nv ln it nr b gy oa nx l ny nz">return result<br/> },<br/> [url, data, key, mutate]<br/> )</span></pre><p id="14f9" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这将为您正在修改的键取一个数字，这样您就可以从最初获取的数据中得到这个数字，并根据您要删除的项解析它。如果这个操作的结果是一个数组，那么我们将在数据中找到与键匹配的每一项，并将其从列表中删除。否则，我们必须找到被删除对象的索引，如果它在列表中，则删除该索引。有一点很重要，每个请求都应该返回被操作对象的值，这样我们就可以更新缓存。移除多个对象非常相似。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="cf86" class="nv ln it nr b gy nw nx l ny nz">const removeMultiple = useCallback(<br/> async (ids: number[], shouldRevalidate = false) =&gt; {<br/> const response = await fetch(url, {<br/> body: ids,<br/> method: ‘DELETE’<br/> })<br/> const results = response as T[]</span><span id="c365" class="nv ln it nr b gy oa nx l ny nz">if (data &amp;&amp; mutate) {<br/> const updatedObjects = […data].filter((current) =&gt; {<br/> const isDeleted = results.find((result) =&gt; result[key] === current[key])<br/> return !isDeleted<br/> })</span><span id="3509" class="nv ln it nr b gy oa nx l ny nz">        await mutate(updatedObjects, shouldRevalidate)</span><span id="1bc7" class="nv ln it nr b gy oa nx l ny nz">        return results<br/>       }<br/>   },<br/> [url, data, key, mutate]<br/> )</span></pre></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="18f0" class="lm ln it bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated">你知道接下来会发生什么</h1><p id="8a7f" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">CRUD的更新部分略有不同，因为如果被更新的行没有不同，SQL server可能会抛出错误。对于这一点，你可能应该在前端进行一些验证，以确保不会发生这种情况，但为了以防万一，我将在这里使用我偷来的方法进行检查。创建一个名为get-object-difference.ts的助手方法，放在一个容易访问的地方。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="09fd" class="nv ln it nr b gy nw nx l ny nz">/*<br/> * Compare two objects by reducing an array of keys in obj1, having the<br/> * keys in obj2 as the initial value of the result. Key points:<br/> *<br/> * — All keys of obj2 are initially in the result.<br/> *<br/> * — If the loop finds a key (from obj1, remember) not in obj2, it adds<br/> * it to the result.<br/> *<br/> * — If the loop finds a key that are both in obj1 and obj2, it compares<br/> * the value. If it’s the same value, the key is removed from the result.<br/> */<br/>export function getObjectDifference(obj1: any, obj2: any) {<br/> const diff = Object.keys(obj1).reduce((result, key) =&gt; {<br/> if (!obj2.hasOwnProperty(key)) {<br/> result.push(key)<br/> } <br/> return result<br/> }, Object.keys(obj2))</span><span id="2454" class="nv ln it nr b gy oa nx l ny nz">return Object.fromEntries(<br/> diff.map((key) =&gt; {<br/> return [key, obj2[key]]<br/> })<br/> )<br/>}</span></pre><p id="80c3" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">此方法将返回两个对象之间差异的对象，否则如果没有，它将返回一个空对象。继续将它导入useCrud文件并添加更新方法。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="f0e3" class="nv ln it nr b gy nw nx l ny nz">const update = useCallback(<br/> async (updatedObject: T, shouldRevalidate = false): Promise&lt;T&gt; =&gt; {<br/> const currentObjectIndex = data.findIndex((object) =&gt; object[key] === updatedObject[key])<br/> const currentObject = data[currentObjectIndex]<br/> const diff = currentObject ? getObjectDifference(currentObject, updatedObject) : null</span><span id="3784" class="nv ln it nr b gy oa nx l ny nz">if (!diff) {<br/> throw new Error(‘Update Failed’)<br/> }</span><span id="298f" class="nv ln it nr b gy oa nx l ny nz">if (isEmpty(diff)) {<br/> return currentObject<br/> }</span><span id="a025" class="nv ln it nr b gy oa nx l ny nz">const response = await fetch(url, {<br/> body: { …diff, id: updatedObject[key] },<br/> method: ‘PATCH’<br/> })</span><span id="b11b" class="nv ln it nr b gy oa nx l ny nz">if (data &amp;&amp; mutate) {<br/> const updatedObjects = […data]<br/> updatedObjects.splice(currentObjectIndex, 1, response)<br/> await mutate(updatedObjects, shouldRevalidate)<br/> }</span><span id="8fd6" class="nv ln it nr b gy oa nx l ny nz">return response as T<br/> },<br/> [url, data, mutate, key]<br/> )</span></pre><p id="8fd2" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这将检查您正在修改的当前对象的缓存，并获得旧对象和新对象之间的差异。如果当前对象不在缓存中，它将抛出一个错误。否则，如果没有差异，它将只返回当前对象，而不执行获取补丁的请求。如果有差异，它会将差异和更新对象的id作为您之前在更新对象上指定的任何键进行传递。然后，它将继续对缓存的数据执行mutate，更新多个对象略有不同。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="468c" class="nv ln it nr b gy nw nx l ny nz">const updateMultiple = useCallback(<br/> async (updatedObjects: T[], shouldRevalidate = false): Promise&lt;T[]&gt; =&gt; {<br/> const currentObjects = data.filter((object) =&gt; updatedObjects.find((updated) =&gt; object[key] === updated[key]))</span><span id="2582" class="nv ln it nr b gy oa nx l ny nz">if (!currentObjects || currentObjects &lt;= 0) {<br/> throw new Error(‘Update Failed’)<br/> }</span><span id="1e05" class="nv ln it nr b gy oa nx l ny nz">const diffs = currentObjects.map((currentObject) =&gt; {<br/> const updatedObject = updatedObjects.find((updated) =&gt; updated[key] === currentObject[key])<br/> return { …getObjectDifference(currentObject, updatedObject), id: updatedObject[key] }<br/> })</span><span id="a14d" class="nv ln it nr b gy oa nx l ny nz">if (diffs.length &lt;= 0) {<br/> return currentObjects<br/> }</span><span id="72a2" class="nv ln it nr b gy oa nx l ny nz">const response = await fetch(url, {<br/> body: { …diffs },<br/> method: ‘PATCH’<br/> })</span><span id="d329" class="nv ln it nr b gy oa nx l ny nz">if (data &amp;&amp; mutate) {<br/> const updatedObjects = […data].map((current) =&gt; {<br/> if (current[key] === response[key]) {<br/> return response<br/> }</span><span id="ddbe" class="nv ln it nr b gy oa nx l ny nz">   return current<br/> })</span><span id="b138" class="nv ln it nr b gy oa nx l ny nz">   await mutate(updatedObjects, shouldRevalidate)<br/> }</span><span id="b200" class="nv ln it nr b gy oa nx l ny nz">return response as T[]<br/> },<br/> [url, data, mutate, key]<br/> )</span></pre><p id="8cc0" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这将在所有对象上运行差异检查，而不是在主体中传递一个对象差异数组。当然，所有这些实现都是特定于我的API路由的，但是它们可以很容易地被修改以适合您的用例。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="b6d0" class="lm ln it bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated">结束这节拼写课</h1><p id="5b5d" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">唷！如果你做到了这一步，我欠你一杯酒，但因为我现在不能给你买一杯，我会给你完整的代码。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="dccf" class="nv ln it nr b gy nw nx l ny nz">import { isArray, isEmpty } from ‘lodash’<br/>import { useCallback, useEffect, useMemo, useState } from ‘react’<br/>import useSWR, { ConfigInterface } from ‘swr’<br/>import { getObjectDifference } from ‘../where-ever-you-put-this-earlier’</span><span id="f293" class="nv ln it nr b gy oa nx l ny nz">// T is the response type<br/>// K is the request type which defaults to T<br/>export function useCrud&lt;T, K = T&gt;(url: string, key: keyof T, fetchOptions?: ConfigInterface) {<br/>const [loading, setIsLoading] = useState(true)</span><span id="13fc" class="nv ln it nr b gy oa nx l ny nz">const loadingTimeout = () =&gt; {<br/>setIsLoading(false)<br/>}</span><span id="77fe" class="nv ln it nr b gy oa nx l ny nz">const fetch = useCallback(<br/>async (url: string) =&gt; {<br/>const response = await fetch(url)<br/>return response as T[]<br/>},[])</span><span id="d2f7" class="nv ln it nr b gy oa nx l ny nz">const { data, error, isValidating, mutate } = useSWR(url, fetch, {…fetchOptions})</span><span id="0102" class="nv ln it nr b gy oa nx l ny nz">useEffect(() =&gt; {<br/>if (isValidating) {<br/>setIsLoading(true)<br/>return<br/>}setTimeout(loadingTimeout, 500)}, <br/>[isValidating])</span><span id="0f99" class="nv ln it nr b gy oa nx l ny nz">const create = useCallback(<br/>async (newObject: K, shouldRevalidate = false) =&gt; {<br/>const response = await fetch(url, {<br/>body: newObject,<br/>method: 'POST'<br/>})</span><span id="0402" class="nv ln it nr b gy oa nx l ny nz">const result = response as T<br/>if (data &amp;&amp; mutate) {<br/>let newData = data<br/>if (isArray(data)) {<br/>newData = data.concat(result)<br/>}</span><span id="1e49" class="nv ln it nr b gy oa nx l ny nz">   await mutate([…new Set(newData)], shouldRevalidate)<br/>  }</span><span id="74fa" class="nv ln it nr b gy oa nx l ny nz">   return result<br/>},[url, data, mutate])</span><span id="4a6b" class="nv ln it nr b gy oa nx l ny nz">const createMultiple = useCallback(async (newObjects: K[], shouldRevalidate = false) =&gt; {<br/>const response = await fetch(url, {<br/>body: newObjects,<br/>method: 'POST'<br/>})</span><span id="6ecc" class="nv ln it nr b gy oa nx l ny nz">const result = response as T[]<br/>if (data &amp;&amp; mutate) {<br/>await mutate([…data, …result], shouldRevalidate)}<br/>return result<br/>},[url, data, mutate])</span><span id="d91d" class="nv ln it nr b gy oa nx l ny nz">const remove = useCallback(async (body: number | unknown, shouldRevalidate = false) =&gt; {<br/>const response = await fetch(url, {<br/>body,<br/>method: 'DELETE'<br/>})</span><span id="b96e" class="nv ln it nr b gy oa nx l ny nz">const result = response as T<br/>if (data &amp;&amp; mutate) {<br/>if (isArray(result)) {<br/>const updatedObjects = […data].filter((current) =&gt; {<br/>const isDeleted = result.find((result) =&gt; result[key] === current[key])<br/>return !isDeleted<br/>})</span><span id="b234" class="nv ln it nr b gy oa nx l ny nz">await mutate(result.length === 0 ? [] : updatedObjects, shouldRevalidate)<br/>} else {</span><span id="4bfb" class="nv ln it nr b gy oa nx l ny nz">const deletedIndex = data.findIndex((object) =&gt; object[key] === result[key])<br/>if (deletedIndex &gt;= 0) {<br/>const updatedObjects = […data]<br/>updatedObjects.splice(deletedIndex, 1)</span><span id="f7a6" class="nv ln it nr b gy oa nx l ny nz">        await mutate(updatedObjects, shouldRevalidate)<br/>      }<br/>   }<br/>}</span><span id="e310" class="nv ln it nr b gy oa nx l ny nz">return result<br/>},[url, data, key, mutate])</span><span id="b1a3" class="nv ln it nr b gy oa nx l ny nz">const removeMultiple = useCallback(async (ids: number[], shouldRevalidate = false) =&gt; {<br/>const response = await fetch(url, {<br/>body: ids,<br/>method: 'DELETE'<br/>})</span><span id="ae50" class="nv ln it nr b gy oa nx l ny nz">const results = response as T[]<br/>if (data &amp;&amp; mutate) {<br/>const updatedObjects = […data].filter((current) =&gt; {<br/>const isDeleted = results.find((result) =&gt; result[key] === current[key])<br/>return !isDeleted<br/>})</span><span id="3b27" class="nv ln it nr b gy oa nx l ny nz">     await mutate(updatedObjects, shouldRevalidate)</span><span id="ab38" class="nv ln it nr b gy oa nx l ny nz">     return results<br/>   }<br/>},<br/>[url, data, key, mutate])</span><span id="bc07" class="nv ln it nr b gy oa nx l ny nz">const update = useCallback(async (updatedObject: T, shouldRevalidate = false): Promise&lt;T&gt; =&gt; {</span><span id="ffe2" class="nv ln it nr b gy oa nx l ny nz">const currentObjectIndex = data.findIndex((object) =&gt; object[key] === updatedObject[key])</span><span id="44ca" class="nv ln it nr b gy oa nx l ny nz">const currentObject = data[currentObjectIndex]<br/>const diff = currentObject ? getObjectDifference(currentObject, updatedObject) : null</span><span id="0648" class="nv ln it nr b gy oa nx l ny nz">if (!diff) {<br/>   throw new Error(‘Update Failed’)<br/>}</span><span id="51d2" class="nv ln it nr b gy oa nx l ny nz">if (isEmpty(diff)) {<br/>   return currentObject<br/>}</span><span id="cca3" class="nv ln it nr b gy oa nx l ny nz">const response = await fetch(url, {<br/>body: { …diff, id: updatedObject[key] },<br/>method: 'PATCH'<br/>})<br/>if (data &amp;&amp; mutate) {<br/>const updatedObjects = […data]<br/>updatedObjects.splice(currentObjectIndex, 1, response)<br/>  await mutate(updatedObjects, shouldRevalidate)<br/>}<br/>return response as T<br/>},[url, data, mutate, key])</span><span id="f853" class="nv ln it nr b gy oa nx l ny nz">const updateMultiple = useCallback(async (updatedObjects: T[], shouldRevalidate = false): Promise&lt;T[]&gt; =&gt; {<br/>const currentObjects = data.filter((object) =&gt; updatedObjects.find((updated) =&gt; object[key] === updated[key]))</span><span id="1883" class="nv ln it nr b gy oa nx l ny nz">if (!currentObjects || currentObjects &lt;= 0) {<br/>  throw new Error(‘Update Failed’)<br/>}</span><span id="7f55" class="nv ln it nr b gy oa nx l ny nz">const diffs = currentObjects.map((currentObject) =&gt; {<br/>  const updatedObject = updatedObjects.find((updated) =&gt; updated[key] === currentObject[key])</span><span id="e1fb" class="nv ln it nr b gy oa nx l ny nz">return { …getObjectDifference(currentObject, updatedObject), id:   updatedObject[key] }<br/>})</span><span id="d14d" class="nv ln it nr b gy oa nx l ny nz">if (diffs.length &lt;= 0) {<br/>  return currentObjects<br/>}</span><span id="0311" class="nv ln it nr b gy oa nx l ny nz">const response = await fetch(url, {<br/>body: { …diffs },<br/>method: 'PATCH'<br/>})</span><span id="862a" class="nv ln it nr b gy oa nx l ny nz">if (data &amp;&amp; mutate) {<br/>  const updatedObjects = […data].map((current) =&gt; {<br/>   if (current[key] === response[key]) {<br/>  return response<br/>}<br/>  return current<br/>})</span><span id="960f" class="nv ln it nr b gy oa nx l ny nz">  await mutate(updatedObjects, shouldRevalidate)<br/>}<br/>  return response as T[]<br/>},[url, data, mutate, key])</span><span id="e753" class="nv ln it nr b gy oa nx l ny nz">const memoizedData = useMemo(() =&gt; (!isEmpty(data) ? filterDeleted&lt;T&gt;(data) : []), [data])</span><span id="21a1" class="nv ln it nr b gy oa nx l ny nz">return {<br/>    create,<br/>    createMultiple,<br/>    fetch: { data: memoizedData, error, loading, mutate },<br/>    remove,<br/>    removeMultiple,<br/>    update,<br/>    updateMultiple<br/>  }<br/>}</span></pre></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="551a" class="lm ln it bd lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf nl mh mi mj bi translated"><strong class="ak">结论</strong></h1><p id="b107" class="pw-post-body-paragraph kn ko it kp b kq mk ks kt ku ml kw kx ky mm la lb lc mn le lf lg mo li lj lk im bi translated">恭喜你已经完成了本教程，这个钩子应该给你提供了使用自定义restful API执行CRUD操作所需的所有功能。这个实现是特定于我的API的，所以您可能需要根据您的使用目的修改它，但是它足够通用，可以在大多数情况下使用。感谢你的加入，我希望你喜欢这些垃圾。</p></div></div>    
</body>
</html>