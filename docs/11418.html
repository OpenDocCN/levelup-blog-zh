<html>
<head>
<title>Understanding Supply Chain Disruption</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解供应链中断</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-supply-chain-disruption-106166e97ffa?source=collection_archive---------28-----------------------#2022-03-14">https://levelup.gitconnected.com/understanding-supply-chain-disruption-106166e97ffa?source=collection_archive---------28-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ff5322cadefd1a226907b3f8436d728a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iK8icPPq61KwPUnv"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">米卡·鲍梅斯特在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="2fd1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">软件工程的观点</p><p id="0a27" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止(Q1 2022)，我们都感受到了世界多样化供应链崩溃的问题。当你买不起新车(或者，事实上，甚至是旧车)的时候。当你不能再准备你最喜欢的菜的时候。我们在个人层面感受到了这一点。</p><p id="4a90" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些供应链中断背后有几个显而易见的原因——Covid、劳动力短缺、能源危机。为了不贬低这些问题的严重性，我想讨论一个不同的原因(事实上，这是我唯一能尝试谈论的原因！):开发供应链软件就是难。</p><p id="9bb1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在花了近十年的时间尝试之后，我开始意识到供应链应用程序的基本原则和心智模型与传统(软件)应用程序非常不同，即:</p><ol class=""><li id="5ec6" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">决定论与概率</li></ol><p id="a45a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传统的应用程序没有处理大多数事件实际上是概率性的这一事实；也就是说，你不确定他们的价值观。</p><p id="294d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设您正在实现一个银行应用程序，它支持一个典型的<em class="lk"> transferFunds(发送者、接收者、数量)</em>操作。当操作被调用时，<em class="lk">数量</em>参数取固定的<em class="lk">值</em>(例如，1000.00美元)。其价值毋庸置疑。它是确定性的。</p><p id="e39f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与客户使用电子商务应用程序订购商品的情况形成对比。电子商务应用程序首先检查履行中心(FC)中是否有足够的库存。与前一种情况类似，这是一种确定性操作。在应用程序确认有足够的库存后，它必须检查在第二天左右在所述FC是否会有足够的工人来处理物品(即，从货架上挑选物品，包装它们，然后将它们放在出站卡车上带到客户家)。根据目前的计划，预计一个FC明天将有100名员工工作，这将足以处理我们客户的订单。然而，我们并不能百分百确定。可能是一些同事明天早上起来生病了，无法工作，或者是有人的轮胎漏气了，或者是，事实上，他们的保姆没有出现，他们不得不在家照顾他们的孩子。电子商务应用程序无法知道。但是仍然必须做出决定，是否应该允许客户订购货物(并且相应地，在一些规定的SLA内完成项目)？</p><p id="f7aa" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电子商务应用程序能做的最好的事情就是考虑不同事件发生的概率，以及它们各自的回报，并做出决定。例如，它可以决定允许购买珠宝是值得的，因为FC没有足够的劳动力来处理小件物品的可能性足够低。但是应用程序也可以决定不值得在繁忙的一天在FC中购买利润很小的大宗商品。无论我们采取哪种方式，应用程序都必须将概率作为其业务逻辑的一部分进行推理。为此，我们需要在软件代码中直接对概率概念建模。</p><p id="d200" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会争辩说，即使是银行应用程序也不是真正确定的，因为底层通信网络可能已经失败，或者支持该应用程序的主机可能已经关闭；虽然这是真的，但这些类型的故障及其处理完全与银行应用程序的业务逻辑无关。事实上，多年来，软件工程已经设计了一整套关于如何以对大多数应用程序代码透明的方式处理容错的实践。</p><p id="9762" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在软件中显式建模概率有什么难的？实际上，这很难。</p><blockquote class="ll lm ln"><p id="00d9" class="kd ke lk kf b kg kh ki kj kk kl km kn lo kp kq kr lp kt ku kv lq kx ky kz la ij bi translated">正如伯特兰·罗素(Bertrand Russel)精辟地指出的那样，“概率是现代科学中最重要的概念，尤其是因为没有人对它的含义有丝毫概念”。</p></blockquote><p id="3ef9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更糟糕的是，当我们谈论供应链中未来事件的概率建模时，正如我们接下来将看到的，我们谈论的是未来的很长一段时间，而不是仅仅几天前。</p><p id="90d7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.即时反馈回路与延迟反馈回路</p><p id="f5b5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">反馈回路很重要。它为我们提供了一种系统测量和改进的方法。延迟是否过高？让我们添加主机。CPU使用率低吗？我们去水垢吧。</p><p id="000a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当反馈或其处理被延迟时会发生什么呢？你有没有想过机场里的笑脸按钮是否有用？当你按下不开心的按钮时，你觉得事情变好了吗？平心而论，你一天后检查了吗？还是一周后？还是一个月后？实际上，你应该什么时候检查？！</p><p id="a030" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个有点愚蠢的反馈信号及其处理之间暂时脱节的例子，突显了供应链反馈回路中问题的本质。考虑一下前一个案例，某一天某个职能部门缺少劳动力。这个场景向计划服务生成反馈信号<em class="lk"> work &gt; labor </em>，计划服务根据这个信号决定我们需要雇佣更多的人，开始一个雇佣工作流。在未来的某个时候，也许是几个月后，新员工开始出现在FC中。但是到那时，客户已经放弃使用这个网站，因为网站无法满足需求(导致需求被抑制)。这意味着规划服务将获得一个新的反馈信号，表明<em class="lk">劳动力&gt;工作</em>，它通过将工作人员重新分配到其他fc来做出反应。然而，在这之前，我们必须给工人一些准备时间，以便他们能够重新安置他们的家庭(或换工作)。与此同时，需求再次上升，因为网站不再抑制它，循环再次开始。</p><blockquote class="ll lm ln"><p id="4911" class="kd ke lk kf b kg kh ki kj kk kl km kn lo kp kq kr lp kt ku kv lq kx ky kz la ij bi translated">反馈循环，如果做得不对，会导致你浪费精力去追逐自己的尾巴。供应链充满了类似的难以建模的反馈回路。</p></blockquote><p id="8b9d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，在短期内，劳务约束了履行服务(即，如果没有劳务，你就不能履行)。从长期来看，履行服务会约束劳动力服务(即，如果没有履行需求，就不需要劳动力)。</p><p id="f786" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复杂？到目前为止，我们从单个节点(或FC)的上下文讨论了这个问题。当我们将此扩大到几个节点时，问题会变得更糟。事实上，它变得如此病态，以至于它已经成为运筹学(和MBA项目)的一个研究课题，被称为<a class="ae jd" href="https://en.wikipedia.org/wiki/Bullwhip_effect" rel="noopener ugc nofollow" target="_blank">牛鞭效应</a>。关于这一点已经有很多文献，所以我将避免在这里解释它；然而，这一现象凸显了这样一个事实，即这些反馈环路可能会变得退化——一个节点或一个时间点的延迟会在整个网络或更长时间内形成更大的恶性循环。例如，假设我们一年中只允许雇佣一次员工。如果我们得到错误的信号，我们需要在接下来的一个月里雇佣更多的员工(就像上一个案例一样)，我们可能会将这个信号放大12倍(错误地),因为我们必须雇佣一整年的员工。</p><p id="ffc0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网络的话题将我们带入下一个主题，我们应该局部优化还是全局优化？</p><p id="337f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.局部优化与全局优化</p><p id="638e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们处理越来越大的系统时，我们越来越依赖它们的分布(跨越来越大的网络)。分配带来了复杂性。为了简化，我们尽可能放松约束，我们知道大多数应用程序可以容忍某种程度的不一致性。为了简化，我们封装、创建有界的上下文，并限制这些上下文或子系统之间的信息共享。</p><p id="422a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅仅从我们到目前为止对问题的简单描述，我们已经定义了一个电子商务子系统和一个履行子系统。(软件工程师的)自然倾向于为供应链的其他大型功能创建单独的子系统，比如(1)制造子系统，供应链从这里开始,( 2)分配子系统，负责将包聚集和分配到(3)履行子系统，履行子系统将包交付给最终完成供应链的消费者。</p><p id="1b28" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直觉上，这一切都很好。我们已经分而治之地解决了供应链问题。每个子系统都由一个或多个双披萨团队实现，他们现在可以敏捷地做自己的事情；当然，前提是我们在API上达成一致。</p><p id="0471" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">双披萨团队要做的第一件事就是优化他们的解决方案。例如，履行子系统可以优化如何调度劳动力以最大化可以履行的包裹数量。同样，分配子系统优化自己的工作，等等。随着系统的增长，我们必须支持越来越多的客户，每个子系统同样会不断改进自己的优化。毕竟，在一个人有限的环境中工作更容易，也更有成效。</p><p id="6a55" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，不能保证每个子系统都尽了最大努力，我们最终会为客户提供最好的(甚至是可接受的)整体解决方案。这很容易看出来。想象一下，你有一个网络，其中上游的一个配送中心(DC)为下游的几个履行中心(FC)提供服务。进一步假设，总体来说，你人手不足。试图在所有节点上统一分配人员是没有意义的(每个节点都尽了最大努力，但集体失败了)；相反，您希望为DC配备全部人员，然后将其余人员统一分配到各个功能区。这是因为DC是瓶颈，它将限制整个系统的吞吐量，不管我们在其他地方使用多少资源。</p><blockquote class="ll lm ln"><p id="bc41" class="kd ke lk kf b kg kh ki kj kk kl km kn lo kp kq kr lp kt ku kv lq kx ky kz la ij bi translated">艾利·M·高德拉特在1984年提出的约束理论认为，任何可管理的系统在实现其目标时都会受到很少几个约束的限制。这类似于常见的习语“链条的强度取决于它最薄弱的一环”。</p></blockquote><p id="f7a7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个概念对我们工程师来说并不陌生。我们在分析应用程序时也做类似的事情。我们寻找代码中最差的热点(例如，一些紧密的循环)，消除它，然后转移到下一个。或者，在负载测试时，我们确定应用程序是受CPU限制的，还是受I/O限制的，还是受磁盘限制的；然后我们试图改善有限的资源。同样，当应用程序因100%的CPU使用率而停止时，添加磁盘是没有意义的。</p><p id="f4a5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，当涉及到跨业务逻辑、跨更大系统的业务功能的优化时，我们似乎完全空白了，并回复到在我们的筒仓内工作。</p><p id="9d12" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对供应链系统来说并不适用，因为根据定义，它们是一系列嵌套和约束的功能。</p><p id="fdff" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有人可能会说，试图进行全局优化类似于试图煮沸海洋(也就是说，太难了，难以处理)。也许这是真的，但这不是重点。我所主张的是，你很快就会陷入这样的境地，在改善你的客户体验(你的系统目标)方面，局部优化是完全无用的；相反，在继续前进之前，您必须后退一步，查看全局环境，并通过消除直接的(系统)瓶颈来进行全局优化。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="5f36" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这些基本差异，供应链的软件系统有些脆弱，难以开发和维护也就不足为奇了。</p><p id="f679" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要另一个数据点，只要考虑一下供应链的开源选项是多么的少。而且，据我所知，没有一个与您拥有的其他已建立的软件应用程序类型处于同一水平，如数据库管理系统、web服务器和大数据引擎；尽管供应链行业领先于这些以IT为中心的应用程序类型。</p><p id="13a2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们做什么呢</p><p id="dd7f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这是软件设计的典型情况，最好的解决方案是将<strong class="kf jh">隐含的复杂性转化为显式的抽象</strong>:</p><ul class=""><li id="9cb5" class="lb lc jg kf b kg kh kk kl ko ld ks le kw lf la ly lh li lj bi translated"><strong class="kf jh">概率</strong> —将带有参数的服务定义为随机变量(即具有潜在概率分布的变量)</li><li id="1d3c" class="lb lc jg kf b kg lz kk ma ko mb ks mc kw md la ly lh li lj bi translated"><strong class="kf jh">延迟反馈循环</strong> —从执行和规划的角度分离服务，然后创建在不同时间粒度上工作的规划服务层(例如，月度规划者提供给周规划者，周规划者提供给日规划者，日规划者提供给执行者服务)</li><li id="d4d5" class="lb lc jg kf b kg lz kk ma ko mb ks mc kw md la ly lh li lj bi translated"><strong class="kf jh">全局优化</strong>——首先选择广度和深度，然后循环改进深度和广度</li></ul><p id="4cdb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些想法是一般化的还是只适用于这个小众？</p><p id="7f81" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一下数据库的情况。<strong class="kf jh"> (Probability) </strong>如果数据库的查询计划返回其预期执行时间的分布(例如，有50%的可能性需要1分钟，有32%的可能性需要2分钟)，那不是很有帮助吗？<strong class="kf jh">(延迟反馈循环)</strong>更好的是，如果为了查询优化，数据库检查其全年的执行历史会怎么样？通过这种方式，它将知道它正在接近峰值(例如圣诞节)，因此应该扩展。<strong class="kf jh">(全局优化)</strong>最后，如果除了检查它的历史执行情况，它还会检查调用它的客户端应用程序的历史执行情况呢？这样，它不仅可以优化流程，还可以考虑客户的执行约束。</p><p id="e1e7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的假设是，这些概念(即，概率、延迟和退化的反馈循环、全局优化)与大多数领域相关——我们只是为了让事情运行而忽略了它们。随着我们对问题理解的提高和我们软件的成熟，我相信我们会开始看到越来越多的这些概念在我们的软件组件中被明确地建模。</p><p id="3520" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">供应链刚好是第一个。</p></div></div>    
</body>
</html>