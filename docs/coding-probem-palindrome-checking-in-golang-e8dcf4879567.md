# 编码问题:Golang 中的回文检查

> 原文：<https://levelup.gitconnected.com/coding-probem-palindrome-checking-in-golang-e8dcf4879567>

## 学习三种解决方案，提高您的编码技能！

![](img/2d137b25737f0215e9015da3f7c28eba.png)

来自 DeepDreamGenerator 上的[伊莎贝尔](https://deepdreamgenerator.com/u/peopleforc137)

回文是一串向前读和向后读一样的字符。检查给定的字符串是否是回文是一个常见的编码面试问题，因此在您的编码工具带中有这个问题的解决方案是很有用的。下面是一个有趣的回文例子:

> "我们几个人，难道不是在前进，前进到新的时代吗？"—苏格拉底·塞塔科斯

在这篇文章中，我们将讨论著名的回文问题的三种解决方案。这将包括在使用我最喜欢的编程语言 Golang 的同时，分析它们不同的时间和空间复杂性！

我们开始吧！

# 字符串连接— O(N)时间，O(N)空间

常见的强力解决方案是以相反的顺序重新创建给定的字符串，然后比较这两个字符串，看它们是否相等。这些最初的解决方案实际上是编码问题的第一步，并向你的面试官表明你在跳到优化之前首先想到了基础。

首先我们初始化一个名为`reversedStr`的空字符串。然后我们将执行一个 for 循环，将索引`i`初始化到数组末尾减一(长度为 30 的数组的最大索引为 29)。当我们以相反的顺序将`i`从字符串的末尾移动到开头时，我们将当前字符`str[i]`与`reversedStr`连接起来。

**注意:**在 Go 中访问一个带索引的数组的元素会给你一个 byte 对象，所以你要先把它转换成 string`string(str[i])`。

最后，我们有另一个 for 循环，其中我们使用函数`range()`让我们的索引`i`遍历字符串`str`的长度。当我们这样做时，我们比较每个字符 if `str`和`reversedS`并检查它们是否相等。如果它们不在任何时间点，我们返回`false`。如果我们遍历了整个字符串，并且所有的字符都相等，那么这个字符串实际上是一个回文，我们返回`true`！

最初你可能认为这个函数是 O(N)时间的，但是要小心！字符串串联实际上是一个 O(N)运算。对于`str`的每个字符，我们将它与`reversedStr`连接起来，这导致 O(N)的时间复杂度。由于我们也将`str`数组的长度存储在`reversedStr`中，所以我们的空间复杂度将是 O(N)。

# 数组追加— O(N)时间，O(N)空间

继续，我们可以使用与第一次尝试非常相似的逻辑，同时改进我们的时间复杂度。我们可以追加到数组中，而不是连接一个字符串。使用编程语言 Go，这一般是一个常数时间操作！

所以首先我们初始化一个名为`result`的空字节数组。然后我们逆序迭代`str`(别忘了初始化`i`到`len(str)-1`！)并将每个字符追加到`result`。

最后，我们简单地比较我们的初始参数`str`和`string(result)`来测试它是否是一个回文。简单！

因为我们在`str`上只有一个 for 循环，而 Go 中的`append()`操作是一个常数时间操作，所以我们得到的时间复杂度为 O(N)。我们仍然存储一个长度为`str`的数组，所以我们的空间复杂度也是 O(N)。

# 相反的索引— O(N)时间，O(1)空间

我们可以做得更好！让我们想一想。我们已经通过前两次尝试解决了这个问题，同时创建了以相反顺序构建的`str`的额外数据结构。我们一定要这么做吗？回文的本质是什么？而是单词的反映是单词本身——更具体地说，字符串的第一个字符等于字符串的最后一个字符。字符串的第二个字符等于字符串的倒数第二个字符，依此类推…

因此，与其以相反的顺序构建字符串，为什么不直接检查字符串中是否存在回文的模式呢？我们可以通过在字符串的开头和结尾初始化两个索引，然后递增地检查字符串，确保字符串的左右两边相等！

这里我们只需要小心我们的索引。我们用`i=0`开始一个 for 循环，并在整个字符串中递增。当我们这样做时，我们设置另一个变量`j=len(str)-1-i`。所以当`i`为 0 时，它是第一个索引，`j`将是最后一个索引。当`i`为 1 时，它将是第二个索引，而`j`将是倒数第二个索引，依此类推。

不错！你能看出其中的复杂性吗？我们有一个单独的 for 循环，它用常量时间操作遍历字符串。所以我们的运行时复杂度是 O(N)。现在我们不存储任何数据结构，我们已经优化了我们的算法，使其具有恒定的空间复杂度 O(1)。

如果你想要一个最终的优化，你可以在`i > (len(str)/2)+1`时终止 for 循环，因为我们只需要字符串的每一半相等。

你能想到其他的解决方法吗？

我希望这篇文章能帮助你理解一个常见的编码问题，同时也学习一些关于在 Go 中编程的技巧。如果你有任何其他的编码问题想要一个教程，或者如果你只是喜欢这篇文章，我鼓励你在下面留下评论！感谢阅读。