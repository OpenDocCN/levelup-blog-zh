<html>
<head>
<title>Mastering Binary Search Tree — BST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握二叉查找树— BST</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mastering-binary-search-tree-bst-e860c1e3ac39?source=collection_archive---------3-----------------------#2020-02-21">https://levelup.gitconnected.com/mastering-binary-search-tree-bst-e860c1e3ac39?source=collection_archive---------3-----------------------#2020-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="ce2f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="088c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="kq iu">二叉查找树(BST)，有序树或排序二进制</strong>是我们正在研究的第一个树数据结构。与线性数据结构的<a class="ae lm" href="https://hurna.io/academy/data_structures/array.html" rel="noopener ugc nofollow" target="_blank">数组</a>、<a class="ae lm" href="https://hurna.io/academy/data_structures/linked_list.html" rel="noopener ugc nofollow" target="_blank">链表</a>、<a class="ae lm" href="https://hurna.io/academy/data_structures/stack.html" rel="noopener ugc nofollow" target="_blank">栈</a>和<a class="ae lm" href="https://hurna.io/academy/data_structures/queue.html" rel="noopener ugc nofollow" target="_blank">队列</a>不同，树<strong class="kq iu">是内在递归的层次(和非线性)数据结构</strong>。不过，BST很容易理解和操作。这是它的样子:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/162434666181a0fd3daf2371b5aabef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kv3gVgJV67WCl9po.png"/></div></div></figure><p id="9c5a" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">使用树的一个原因可能是因为我们想存储自然形成层次结构的信息。另一个是它们非常重要的特性<strong class="kq iu">允许fast — O(log n) —插入、搜索和删除操作</strong>。</p><h1 id="8d7b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">树、二叉树和二分搜索法树(BST)</h1><blockquote class="me mf mg"><p id="1b0e" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">在处理BST之前，精确术语是很重要的，这些术语经常被混淆。</p></blockquote><h2 id="2c54" class="ml jr it bd js mm mn dn jw mo mp dp ka kz mq mr ke ld ms mt ki lh mu mv km mw bi translated">树</h2><p id="faf0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="kq iu">一棵树对每个节点可以拥有的子节点数量没有限制</strong>。<strong class="kq iu">树中最顶端的节点</strong>称为<strong class="kq iu">，根节点</strong>和没有子节点的<strong class="kq iu">称为叶节点</strong>。它们也被称为N元树:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/98dd2f18a71e3a746654b7295ebc7282.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/0*38bSOYtCQ9pg0AhM.png"/></div></figure><blockquote class="me mf mg"><p id="6c7f" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">树的高度是从根部到最深的叶子的边数(这里高度= 3)。</p></blockquote><h2 id="13aa" class="ml jr it bd js mm mn dn jw mo mp dp ka kz mq mr ke ld ms mt ki lh mu mv km mw bi translated">二叉树</h2><p id="a6ec" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">二叉树是一种特殊的基于树的数据结构的一般概念。各种特定类型的二叉树(例如下面的BST)可以基于这个概念用不同的属性来构造。<strong class="kq iu">二叉树的每个节点最多可以有两个子节点</strong>。二叉树中的每个节点包含:<br/> -一个<strong class="kq iu">数据元素</strong>(例如6) <br/> -一个指向“左子”节点(可能是“空”)<br/> -一个指向“右子”节点(可能是“空”)的<strong class="kq iu">指针</strong></p><blockquote class="me mf mg"><p id="dd3a" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">这听起来可能令人惊讶，但莫尔斯电码的组织是一个二叉树。</p></blockquote><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi my"><img src="../Images/997c3aebc531b6782047450742f3ac77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*71buNWSIZhQmoqkx.png"/></div></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mz"><img src="../Images/b2609235386e5307857b3d2bae462383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*khPasrSniIHeXuEt.png"/></div></div></figure><h1 id="5a69" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">二叉树的一些其他应用</h1><ul class=""><li id="b32f" class="na nb it kq b kr ks kv kw kz nc ld nd lh ne ll nf ng nh ni bi translated">用于在计算器中构建数学表达式(语法树)。例如，这就是我们的<a class="ae lm" href="https://demo.hurna.io/#path=equation_solver/quadratic" rel="noopener ugc nofollow" target="_blank">人工智能Globo用来逐步解决你的二次方程</a>的东西。</li><li id="d9bc" class="na nb it kq b kr nj kv nk kz nl ld nm lh nn ll nf ng nh ni bi translated">由编译器构造，用于将表达式解析为计算器(语法树)</li><li id="6c13" class="na nb it kq b kr nj kv nk kz nl ld nm lh nn ll nf ng nh ni bi translated">几乎在每个3D视频游戏中使用，以确定需要渲染什么对象(二进制空间分区)。</li><li id="e478" class="na nb it kq b kr nj kv nk kz nl ld nm lh nn ll nf ng nh ni bi translated">用于压缩算法，如mp3，jpg(霍夫曼编码树)…</li></ul><h2 id="f0d9" class="ml jr it bd js mm mn dn jw mo mp dp ka kz mq mr ke ld ms mt ki lh mu mv km mw bi translated">二叉查找树—英国夏令时</h2><p id="3b3e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后是我们的<strong class="kq iu"> BST </strong>，它是一个二叉树数据结构，有以下两个约束:<br/> - <strong class="kq iu">一个节点的左子树</strong>的所有节点的值<strong class="kq iu">小于或等于该节点的</strong>值。<br/> - <strong class="kq iu">一个节点的右子树</strong>的所有节点的值<strong class="kq iu">大于其父节点的值</strong>。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/e1843fe73ce3de6833e02e6c3f30ddef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z_UUluXMjIbYgCi7.png"/></div></div></figure><blockquote class="me mf mg"><p id="c773" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">右边的二叉树不是二叉查找树，因为节点“3”的右边子树包含一个比它小的值。</p></blockquote><p id="fa5b" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">优点/缺点</p><ul class=""><li id="d16a" class="na nb it kq b kr lz kv ma kz no ld np lh nq ll nf ng nh ni bi translated"><strong class="kq iu"> +对插入、删除和查找操作使用二分搜索法原理，复杂度为O(log n)。</strong></li><li id="b807" class="na nb it kq b kr nj kv nk kz nl ld nm lh nn ll nf ng nh ni bi translated">+通过一个有序遍历得到所有的键。</li><li id="9592" class="na nb it kq b kr nj kv nk kz nl ld nm lh nn ll nf ng nh ni bi translated">+进行订单统计、最接近的较低/较大元素、范围查询等。操作简单。</li><li id="16aa" class="na nb it kq b kr nj kv nk kz nl ld nm lh nn ll nf ng nh ni bi translated">+树是非常灵活的数据，允许以最小的努力移动子树。</li><li id="d957" class="na nb it kq b kr nj kv nk kz nl ld nm lh nn ll nf ng nh ni bi translated">-二叉查找树的形状取决于插入和删除的顺序，并且<strong class="kq iu">可能会变得非常不平衡</strong>(如果不加以控制——进一步详述)。如果树是完全退化的，我们最终得到类似于线性数据结构的东西:链表。</li></ul><h1 id="cbe2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">让我们用一些平和的二叉树分形来休息一下</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/8e76fc435228104e1481d1980fe86258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rQ04d_TWwMf7X-OT.png"/></div></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/95ee3bddb8864f00b8ab824d8d15cb37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c-92q9HtBxhtwCIe.png"/></div></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nr"><img src="../Images/c42be8d66059ed0d13c6b277e0b2e49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hJFyH_u-DI42KA13.png"/></div></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ns"><img src="../Images/092b6d6170892b8631968be59df5cd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FBxL2P55hGL3TEQd.png"/></div></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nt"><img src="../Images/3282b1d3577ffe94c28fceca8722117c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zthzUN_ppUqPx6xJ.png"/></div></div></figure><h1 id="fe61" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">目标</h1><blockquote class="me mf mg"><p id="f7c5" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">操作BST。构建我们自己的BST结构。<br/>将指针和递归付诸实践。<br/>了解平衡采油树的优点/缺点。</p></blockquote><h1 id="f826" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">下一步是什么？</h1><p id="1f61" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你还没有跳到<a class="ae lm" href="https://hurna.io/academy/maze_generator/index.html" rel="noopener ugc nofollow" target="_blank">迷宫生成算法</a>，玩玩它们并使用我们的<a class="ae lm" href="https://demo.hurna.io/#path=maze/binary_generator" rel="noopener ugc nofollow" target="_blank">浏览器</a>会让你对迷宫和树形结构之间的二元性有直观的认识。我们将很快研究更高级的树结构，如红黑树、四叉树和八叉树，它们是划分2D和三维空间的两种非常有用的结构。</p><h1 id="1fab" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">建立我们自己的</h1><p id="48c7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将首先简单地用二叉树定义我们的结构，它包含一个数据，一个指向左子树(节点)的指针，一个指向右子树(节点)的指针。为了便于阅读，代码被简化，请使用<a class="ae lm" href="https://github.com/Hurna/Hurna-Core/blob/master/Modules/DataStructures/binary_search_tree.hxx" rel="noopener ugc nofollow" target="_blank">github链接</a>获取完整版本。</p><pre class="lo lp lq lr gt nu nv nw nx aw ny bi"><span id="15ec" class="ml jr it nv b gy nz oa l ob oc">class BST<br/>  {<br/>    BST(const Value data) : data(data) {}<br/>    ...<br/><br/>  private:<br/>    T data;<br/>    unique_ptr&lt; BST &gt; leftChild;<br/>    unique_ptr&lt; BST &gt; rightChild;<br/>  }</span></pre><blockquote class="me mf mg"><p id="508f" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">代码的语义表明递归在树形数据结构中起着主要作用。实际上，BST的左右节点是也被定义为BST的子树。</p></blockquote><p id="0ff3" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">二分搜索法树支持你能从一个排序数组中得到的一切:有效的搜索，从任何给定元素的有序向前/向后遍历，前一个/后一个元素搜索，和最大/最小查询…</p><blockquote class="me mf mg"><p id="57f3" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">为什么不使用一个简单的排序数组，然后使用二分搜索法呢？</p></blockquote><p id="4ab0" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">拥有一个有序的数组对于很多任务都是有用的，因为它使得<a class="ae lm" href="https://hurna.io/academy/algorithms/search/binary.html" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>能够被用来有效地定位元素:O(log n)。与二分搜索法树相比，排序数组的问题是元素不能被有效地插入和移除。</p><blockquote class="me mf mg"><p id="a04d" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">太好了。既然我们有充分的理由继续，那么让我们定义一个API。</p></blockquote><pre class="lo lp lq lr gt nu nv nw nx aw ny bi"><span id="319f" class="ml jr it nv b gy nz oa l ob oc">// Manipulation<br/>  void Insert(Value data)     // Insert an element<br/>  BST* Remove(Value data)     // Remove an element</span><span id="d4bf" class="ml jr it nv b gy od oa l ob oc">  // Traversal<br/>  Value GetMin()              // Return the minima<br/>  Value GetMax()              // Return the maxima<br/>  List&lt; Value &gt; InOrder()     // Proceed in order traversal <br/>  BST* Search(Value data)     // Find an element</span></pre><p id="9f50" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">这是一个相当大的API，我们将一次一个部分地掌握树操作。我们将从遍历方法到操作方法来解决它们。</p><h1 id="43e0" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">遍历</h1><h1 id="9d1c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">获取最小值/获取最大值</h1><p id="0d8d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它们是最简单的方法，它们允许我们记住BST的属性:<br/> - <strong class="kq iu">一个节点的左子树</strong>的所有节点的值<strong class="kq iu">小于或等于该节点的值</strong>。<br/> - <strong class="kq iu">一个节点的右子树</strong>的所有节点的值<strong class="kq iu">大于其父节点的值</strong>。</p><pre class="lo lp lq lr gt nu nv nw nx aw ny bi"><span id="b69c" class="ml jr it nv b gy nz oa l ob oc">// GetMin is getting the left most child<br/>  const BST* GetMin()<br/>  {<br/>    auto curNode = this;<br/>    while (curNode-&gt;leftChild)<br/>      curNode = curNode-&gt;leftChild;</span><span id="0c61" class="ml jr it nv b gy od oa l ob oc">    return curNode;<br/>  }</span><span id="3fed" class="ml jr it nv b gy od oa l ob oc">  // GetMax is getting the right most child<br/>  const BST* GetMax()<br/>  {<br/>    auto curNode = this;<br/>    while (curNode-&gt;rightChild)<br/>      curNode = curNode-&gt;rightChild;</span><span id="4ea8" class="ml jr it nv b gy od oa l ob oc">    return curNode;<br/>  }</span></pre><p id="7038" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">参见下面的递归版本的说明(更多的内存消耗)。</p><pre class="lo lp lq lr gt nu nv nw nx aw ny bi"><span id="0fd5" class="ml jr it nv b gy nz oa l ob oc">const BST* GetMin() <br/>{ return this-&gt;leftChild ? this-&gt;leftChild-&gt;GetMin() : this; }</span><span id="ecb5" class="ml jr it nv b gy od oa l ob oc">const BST* GetMax() <br/>{ return this-&gt;rightChild ? this-&gt;rightChild-&gt;GetMax() : this; }</span></pre><h1 id="4b0d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">搜索</h1><p id="d9d8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在有序数组中搜索一个值使用与<a class="ae lm" href="https://hurna.io/academy/algorithms/search/binary.html" rel="noopener ugc nofollow" target="_blank">二分搜索法相同的原理。如果<strong class="kq iu">的值小于当前节点的值</strong>，我们可以确定该值在<strong class="kq iu">左子树</strong>、<strong class="kq iu">中，否则</strong>在<strong class="kq iu">右子树</strong>中。</a></p><h1 id="2229" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">有序遍历</h1><p id="e154" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在一个有序遍历中，我们<strong class="kq iu">首先访问左边的子节点</strong>(包括它的整个子树)，然后<strong class="kq iu">访问当前节点</strong>，最后<strong class="kq iu">访问右边的子节点</strong>(包括它的整个子树)。注意，二叉查找树使用了inorder遍历方法来获取按值的升序排列的所有节点。</p><pre class="lo lp lq lr gt nu nv nw nx aw ny bi"><span id="b965" class="ml jr it nv b gy nz oa l ob oc">static void Inorder(const BST* node, List&lt; Value &gt;&amp; result)<br/>  {<br/>    if (!node) return; // end of a branch (no data)</span><span id="1480" class="ml jr it nv b gy od oa l ob oc">    Inorder(node-&gt;leftChild)  // Recurse in left subtree<br/>    result.push(node-&gt;data);  // Get data<br/>    Inorder(node-&gt;rightChild) // Recurse in right subtree<br/>  }</span></pre><h1 id="63d6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">操作</h1><h1 id="70cc" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">插入</h1><p id="ac46" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="kq iu">在正确的位置插入一个值类似于搜索</strong>因为我们要维持左子树小于根，右子树大于根的规则。我们根据值继续向右或向左移动，直到变成一片叶子。然后，我们将新节点(或BST)放在那里。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oe"><img src="../Images/0aec661a64e1e7bcd623fbc14b137602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IVZ6lXqcqX56hSh_ru7GdQ.png"/></div></div></figure><p id="00b9" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">我们可能已经注意到插入的顺序可能会改变BST的形状。这就是前面提到的缺点:我们的树可能会非常不平衡(或者退化)。</p><blockquote class="me mf mg"><p id="bc6f" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">左:我们按顺序[4，2，5，1，3，6] → O(log n) <br/>插入右:我们按顺序[1，2，3，4，5，6] → O(n)插入</p></blockquote><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b11bcfaeea9793cb87bf5e800c02b2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*aTW2azy5GyT9xxNv.png"/></div></figure><p id="0263" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">我们可以看到，算法在二分搜索法树上的运行时间取决于树的形状，而树的形状又取决于键的插入顺序。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi og"><img src="../Images/c2d35b02b700004587d38472b34f6e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WEIGkEtQndEvPVwHAh4aSA.png"/></div></div></figure><blockquote class="me mf mg"><p id="7b1a" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">有一些被称为树平衡的技术可以保持树的平衡。我们将看到它们具有更高级的树数据结构，如红黑树。</p><p id="0b8b" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">但是，如果我们假设数据是以随机顺序插入的，那么对于许多应用程序来说，使用BST是合理的。在这种情况下，我们对n个节点的操作需要大约2 ln n。</p><p id="ef73" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">作为第一个练习，我们可以编写从一个排序数组中产生一个平衡BST的过程。</p></blockquote><h1 id="83d7" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">去除</h1><p id="e824" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将要深入讨论的BST中的最后一个操作是根据给定值删除一个节点。删除比插入更棘手，因为如果节点存在于树中，有三种情况需要考虑:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oh"><img src="../Images/5595359f1787fc5e2649d1a2a5ab674b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TR5FkZ5UuH00l47cJrHnmw.png"/></div></div></figure><blockquote class="me mf mg"><p id="ed6e" class="ko kp mh kq b kr lz kt ku kv ma kx ky mi mb lb lc mj mc lf lg mk md lj lk ll im bi translated">瞧啊。我们现在掌握了BST及其操作，这为我们日常的软件开发打下了坚实的基础。</p></blockquote><h1 id="6d6b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">一些练习</h1><pre class="lo lp lq lr gt nu nv nw nx aw ny bi"><span id="1793" class="ml jr it nv b gy nz oa l ob oc">bool IsBalanced()   // Check if the tree is balanced<br/>int MinHeight()     // Return the smallest branch height<br/>int MaxHeight()     // Return the highest branch height<br/>int Size()          // Return number of nodes composing the tree</span></pre><p id="6469" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated">与更多高级课程保持联系。</p><p id="84de" class="pw-post-body-paragraph ko kp it kq b kr lz kt ku kv ma kx ky kz mb lb lc ld mc lf lg lh md lj lk ll im bi translated"><a class="ae lm" href="https://hurna.io" rel="noopener ugc nofollow" target="_blank">h . urna——面向所有人的科学。</a></p></div></div>    
</body>
</html>