<html>
<head>
<title>Can You Communicate With Databases Without Learning SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不学SQL能和数据库交流吗</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/can-you-communicate-with-databases-without-learning-sql-74fa39b05179?source=collection_archive---------12-----------------------#2021-07-05">https://levelup.gitconnected.com/can-you-communicate-with-databases-without-learning-sql-74fa39b05179?source=collection_archive---------12-----------------------#2021-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c999" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第3部分— Bookshelf.js</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/170d4fe7d690c3125fbae85a10143aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l2MRocMj5r4izFqWBI1Yiw.png"/></div></div></figure><blockquote class="ku kv kw"><p id="3a61" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Bookshelf是Node.js的JavaScript ORM，构建在<a class="ae lu" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex </a> SQL查询构建器上。它具有基于承诺的和传统的回调接口、事务支持、渴望/嵌套渴望关系加载、多态关联以及对一对一、一对多和多对多关系的支持。</p><p id="3441" class="kx ky kz la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="it"> - </em>根据<a class="ae lu" href="https://bookshelfjs.org/" rel="noopener ugc nofollow" target="_blank"> Bookshelf.js官方文档</a></p></blockquote><p id="5cc6" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">为了更好地理解书店的运作，我们将使用<em class="kz">在线购物系统</em>的概念。为了简单起见，我们将只处理以下两个实体，<em class="kz"> i)客户，ii)订单。</em>每个客户可以下一个或多个订单，每个订单属于一个客户。</p><h1 id="e207" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">1)安装</h1><p id="596f" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">你可以用<code class="fe mv mw mx my b">npm</code>安装<em class="kz">书架</em> .js，现在<em class="kz">书架</em>在后台使用<strong class="la iu"> knex SQL查询构建器</strong>作为它的数据库访问层，所以你也需要安装那个。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3fa8" class="nd lz it my b gy ne nf l ng nh"><em class="kz">$ npm install bookshelf knex</em></span></pre><p id="331a" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">您还必须为您选择的数据库手动安装下列驱动程序之一:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="27f2" class="nd lz it my b gy ne nf l ng nh"><em class="kz">$ npm install pg<br/>$ npm install mysql<br/>$ npm install sqlite3</em></span></pre><p id="409b" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">本文中的所有例子都基于MySQL驱动程序，即mysql2。此外，数据库运行在我的本地机器上。</p><h1 id="0b66" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">2)建立数据库连接</h1><p id="5c2f" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">将以下代码放入您的<strong class="la iu">中。/util/database.js </strong></p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="87b7" class="nd lz it my b gy ne nf l ng nh">const knex = require('knex')({<br/>  client: 'mysql',<br/>  connection: {<br/>    host     : '127.0.0.1',<br/>    user     : 'your_username', //replace with your username<br/>    password : 'your_password', //replace with your password<br/>    database : 'your_db_name', //replace with your db name<br/>    charset  : 'utf8'<br/>  }<br/>});<br/><br/>bookshelf = require('bookshelf')(knex);<br/><br/>// Bookshelf supported plugins.<br/>bookshelf.plugin('registry');<br/>bookshelf.plugin('visibility'); <br/><br/>module.exports = bookshelf;</span></pre><p id="3290" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">请记住，使用Bookshelf时，您需要明确地将插件添加到您的对象中，因为它们不是核心Bookshelf模块的一部分。因此，注册表插件用于访问<code class="fe mv mw mx my b">.model()</code>方法，可见性插件用于支持文件的不同可见性模式。</p><h1 id="08d1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">3)定义模型和定义关系</h1><p id="4e66" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">模型是表示数据库中的表的抽象。在bookshelf中，它是通过访问Bookshelf对象上的<code class="fe mv mw mx my b">.model()</code>方法创建的。</p><p id="35e7" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">通过在您的<strong class="la iu">中放置以下代码来定义客户模型。/models/customer.js </strong></p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="f27e" class="nd lz it my b gy ne nf l ng nh">const bookshelf = require('../util/database');<br/><br/>const Customer = bookshelf.model('Customer', {<br/>  tableName: 'customers',<br/>  orders() {<br/>    return this.hasMany("Order")<br/>  }<br/>});<br/><br/>module.exports = Customer;</span></pre><p id="dd2d" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">现在，如果您过去使用过Sequelize或其他一些基于SQL的ORM，您一定会注意到一些非常不同和奇怪的东西。你有吗？因此，我们没有在客户模型的定义中定义任何字段/列，所以Bookshelf不知道我们数据库表的任何内容。这是因为与Sequelize不同，使用Bookshelf，您必须手动创建数据库、表和表中的列。</p><p id="c1ce" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">现在，在我们的例子中，每个客户都有一个<strong class="la iu"> id、</strong>一个<strong class="la iu">名字、</strong>和一个<strong class="la iu">电子邮件</strong>。这代表了客户表的3个字段/列。因此，客户模型通过一个<em class="kz"> hasMany </em>关系与订单模型相关联。<em class="kz">一个客户可以有多个订单。</em></p><p id="4887" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">通过在您的<strong class="la iu">中放置以下代码来定义订单模型。/models/order.js </strong></p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="8c98" class="nd lz it my b gy ne nf l ng nh">const bookshelf = require('../util/database');<br/><br/>const Order = bookshelf.model('Order', {<br/>  tableName: 'orders'<br/>})<br/><br/>module.exports = Order;</span></pre><p id="c47c" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">每个订单将有一个<strong class="la iu"> id </strong>和一个<strong class="la iu">总</strong>购买价格。这表示订单表的两个字段/列。</p><h1 id="8d90" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">4)编写查询</h1><p id="b2e8" class="pw-post-body-paragraph kx ky it la b lb mq ju ld le mr jx lg lv ms lj lk lw mt ln lo lx mu lr ls lt im bi translated">在下面的代码片段中，我们执行以下操作:</p><p id="c396" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">I)插入新客户。</p><p id="18d8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">ii)使用<strong class="la iu"> <em class="kz"> customerId </em> </strong>外键为该客户插入2个新订单。</p><p id="0814" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">iii)选择/获取当前客户的所有订单。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="db24" class="nd lz it my b gy ne nf l ng nh">const Customer = require("./models/customer");<br/>const Order = require("./models/order");<br/><br/>let customerId = null;<br/>Customer.forge({ name: "Joey Tribianni", email: "jt@gmail.com" })<br/>  .save()<br/>  .then((customer) =&gt; {<br/>    customerId = customer.id;<br/>    return Order.forge({ total: 45, customer_id: customerId }).save();<br/>  })<br/>  .then((order) =&gt; {<br/>    return Order.forge({ total: 55, customer_id: customerId }).save();<br/>  })<br/>  .then((order) =&gt; {<br/>    return Customer.where({ id: customerId }).fetch({<br/>        withRelated: ['orders'], require: true<br/>    });<br/>  })<br/>  .then(result =&gt; {<br/>      console.clear();<br/>      console.log("Result is : ", result.toJSON());<br/>  })<br/>  .catch((err) =&gt; {<br/>    console.log(err);<br/>  });</span></pre><p id="9db8" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated">所以，这就是这个有用的Node.js ORM。我希望本文提供的信息对您有价值，并帮助您简化和优化数据库操作。</p><h1 id="b1b7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">其他资源:</h1><ul class=""><li id="f658" class="ni nj it la b lb mq le mr lv nk lw nl lx nm lt nn no np nq bi translated"><a class="ae lu" href="https://bookshelfjs.org/" rel="noopener ugc nofollow" target="_blank"> <em class="kz">了解更多关于书架的信息</em> </a></li><li id="e3d1" class="ni nj it la b lb nr le ns lv nt lw nu lx nv lt nn no np nq bi translated"><a class="ae lu" href="https://github.com/KritikaSharmaKS/Bookshelf-Youtube" rel="noopener ugc nofollow" target="_blank"> <em class="kz">链接到我的GitHub库</em> </a></li></ul></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="1147" class="pw-post-body-paragraph kx ky it la b lb lc ju ld le lf jx lg lv li lj lk lw lm ln lo lx lq lr ls lt im bi translated"><em class="kz">原载于</em><a class="ae lu" href="https://www.theimmigrantprogrammers.com/p/can-you-communicate-with-databases-dce" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://www.theimmigrantprogrammers.com</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>