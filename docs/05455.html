<html>
<head>
<title>Best Practices for Designing Developer-Friendly REST APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计开发人员友好的REST APIs的最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/best-practices-for-building-developer-friendly-rest-apis-e6a419fcbd38?source=collection_archive---------3-----------------------#2020-08-31">https://levelup.gitconnected.com/best-practices-for-building-developer-friendly-rest-apis-e6a419fcbd38?source=collection_archive---------3-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8c93" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">软件体系结构</h2><div class=""/><div class=""><h2 id="0475" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何设计资源、请求和响应，使用版本控制策略，应用安全实践，以及提供优秀的开发人员体验。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e72180192ea876cef59fb30657856354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7_Jq5u8nHBOG51JfJ0oqw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">阿尔瓦罗·雷耶斯在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0f53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">REST APIs可能是通过互联网集成两个应用程序的最简单的方法。大多数web开发人员已经集成或构建了它们。</p><p id="5fb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我写这篇指南是为了帮助开发人员设计和构建更容易集成和维护的REST APIs。它包括我从同事那里借鉴的技巧，我从书籍和文章中学到的想法，以及我自己使用REST APIs的一些经验。因此，您可能会发现这些最佳实践有点固执己见。</p><p id="34c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本指南从REST资源开始，然后研究请求和响应，然后是版本控制、安全性，最后是开发人员体验。这里的所有实践都是与平台和语言无关的。</p><h1 id="222a" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">REST API资源</h1><p id="7612" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">“资源”的概念是REST的基石。将它们看作实体的集合或单个实体是很方便的。</p><h2 id="cee9" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">在资源名称中使用名词</h2><p id="c611" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">命名REST API资源时，使用名词，避免使用动词。</p><p id="d433" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如:</p><ul class=""><li id="53ed" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">/post</code>对于返回博客帖子集合的资源，</li><li id="97ae" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">/me</code>为返回当前用户信息的资源。</li></ul><p id="255a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，REST API需要提供产生一些输出的功能，而不实际公开任何实体，例如翻译或货币转换。您仍然可以在这样的资源名称中使用名词。例如，<code class="fe nv nw nx ny b">/translation</code>表示从一种语言到另一种语言的翻译。或者<code class="fe nv nw nx ny b">/amount</code>用于在货币之间转换金额的资源。</p><p id="02b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我相信总是可以用名词替换资源名称中的动词。稍后我会分享一些实现这一目标的方法。</p><h2 id="c5c9" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">避免深度嵌套的资源</h2><p id="6dbb" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">有时资源必须嵌套。例如，代表博客帖子评论的嵌套资源可以是<code class="fe nv nw nx ny b">/posts/r83fj3/comments</code>。使用嵌套资源时，最好避免深度嵌套。在大多数情况下，示例中的两个级别就足够了。</p><h2 id="edb1" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">使用非顺序资源id</h2><p id="8c70" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">最好对资源使用非顺序的(可能是随机的)id。这将保护您的数据免受枚举攻击，如果您发现您的两个资源必须合并为一个，同时保留实体的id，这也将使合并数据集这样的事情变得更简单。UUIDs或随机字符串就足够了。比如<code class="fe nv nw nx ny b">/posts/r83fj3</code>。</p><h1 id="e9cc" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">要求</h1><h2 id="335f" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">用适当的HTTP动词表示CRUD动作</h2><p id="903f" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">典型的REST API资源支持创建、读取、更新和删除操作。让我们来看看使用<code class="fe nv nw nx ny b">/posts</code>资源管理博客文章的规范方法。</p><p id="a2ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">开发人员应该对这些操作使用这些HTTP请求:</p><ul class=""><li id="8603" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">POST example.com/posts/</code> —创建新的博客文章</li><li id="3a14" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">GET example.com/posts/r83fj3</code> —通过id获取博客文章</li><li id="2dad" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">PATCH example.com/posts/r83fj3</code> —根据博客文章的id更新其特定属性</li><li id="3d6b" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">PUT example.com/posts/r83fj3</code> —用id替换博客文章</li><li id="3454" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">DELETE example.com/posts/r83fj3</code> —删除博客文章</li></ul><p id="ff93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意修补和上传请求之间的区别。</p><h2 id="ae2d" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">避免自定义(非CRUD)操作</h2><p id="11c8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">一些资源可能需要支持不能很好地映射到HTTP动词的动作。例如，一篇博文可能需要<em class="oe">发布</em>和<em class="oe">未发布</em>。</p><p id="59e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一种流行但非RESTful的方法是使用如下URL:</p><ul class=""><li id="6441" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">POST /posts/d92hf73/publish</code></li><li id="0127" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">POST/posts/d92hf73/unpublish</code></li></ul><p id="1bc1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这违背了REST原则，因为<code class="fe nv nw nx ny b">/posts/d92hf73/publish</code>不是资源的URL。让我们看看如何以RESTful方式添加发布和取消发布博客文章的支持。</p><p id="436c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一种RESTful但不是特别优雅的方法是使用如下的<code class="fe nv nw nx ny b">PATCH</code>请求:</p><p id="9850" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">PATCH example.com/posts/d92hf73</code>带<code class="fe nv nw nx ny b">{ “status”: “published” }</code>或<code class="fe nv nw nx ny b">{ “status”: “unpublished” }</code>等参数。</p><p id="e4c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一种方法是引入一个嵌套资源，并将其命名为<code class="fe nv nw nx ny b">commands</code>或<code class="fe nv nw nx ny b">actions</code>，那么请求看起来会像这样:</p><p id="cbd5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">POST example.com/posts/d92hf73/commands { “name”: “publish” }</code></p><p id="98e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">POST example.com/posts/d92hf73/commands { “name”: “unpublish” }</code></p><p id="bd07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一种更RESTful的、也更具可扩展性的方法，因为它允许在不改变接口的情况下向API添加更多的URL。</p><p id="3256" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第三种方法是引入表示“发布”概念的嵌套资源，比如“publication”。我认为这是这三个中最好的选择。</p><ul class=""><li id="998b" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">POST example.com/posts/d92hf73/publication</code>通过创建出版物来发布博客文章。</li><li id="c73b" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">DELETE example.com/posts/d92hf73/publication</code>通过删除出版物来取消发布博客文章。</li></ul><h2 id="3818" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">正确使用HTTP动词</h2><p id="6561" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">根据REST原则，请求的含义应该用HTTP动词来表示。让我们看看它们的意思和它们表达的动作:</p><ul class=""><li id="cfbe" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">POST example.com/posts</code>创造新资源</li><li id="c26d" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">GET example.com/posts/d92hf73</code>检索资源</li><li id="c7a0" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">PATCH example.com/posts/d92hf73</code>T20更新指定的资源属性</li><li id="5d4e" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">PUT example.com/posts/d92hf73</code> <em class="oe">替换</em>资源</li><li id="0874" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">DELETE example.com/posts/d92hf73</code>删除资源</li><li id="ebb1" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><code class="fe nv nw nx ny b">GET example.com/posts</code>检索资源集合</li></ul><p id="a9ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">GET请求应该是幂等的，它们永远不应该改变资源的状态。此外，为了API的最佳性能，GET请求也应该是可缓存的。我将在下面详细讨论缓存。</p><p id="0851" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">PUT</code>和<code class="fe nv nw nx ny b">DELETE</code>请求也应该是等幂的。</p><p id="3a60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">POST</code>和<code class="fe nv nw nx ny b">PATCH</code>不是等幂的——它们改变资源的状态。</p><h2 id="f853" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">考虑使用ETag标题</h2><p id="4df1" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">向API发出<code class="fe nv nw nx ny b">UPDATE</code>请求时，资源可能已经被修改，并且<code class="fe nv nw nx ny b">PUT</code>或<code class="fe nv nw nx ny b">PATCH</code>请求可能会覆盖它。</p><p id="7f60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有一种方法可以用<code class="fe nv nw nx ny b">ETag</code>割台抓住那个箱子。<code class="fe nv nw nx ny b">ETag</code>响应HTTP头是资源的特定版本的标识符。这个头中的值是在服务器端为响应计算的，它可以是资源的散列。</p><p id="cb93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当重新加载同一资源以验证是否需要重新提取该资源时，或者当更新该资源以验证该资源在提取和发送回之间没有改变时，可以将该值发送到服务器。</p><p id="f658" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第一种情况下，该值在<code class="fe nv nw nx ny b">If-None-Match</code>请求头中被发回，如果该值与资源的<code class="fe nv nw nx ny b">ETag</code>相同，API可以用空主体的<code class="fe nv nw nx ny b">304 Not Modified</code>进行响应。如果在服务器上构建资源的成本很高，这将很有帮助。</p><p id="7438" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第二种情况下，API应该检查<code class="fe nv nw nx ny b">ETag</code>值是否仍然相同，否则返回<code class="fe nv nw nx ny b">412 Precondition Failed</code>错误响应。这允许捕捉在另一个请求接收到<code class="fe nv nw nx ny b">POST</code>请求之前资源已经被修改的情况，并防止覆盖数据。</p><h1 id="326b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">反应</h1><p id="7c7d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们已经讨论了资源、请求和动词。现在让我们看看成功和失败请求的响应结构。</p><p id="d0f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当返回一个资源时，最好使用简单的JSON结构，即:</p><pre class="ks kt ku kv gt of ny og oh aw oi bi"><span id="8b63" class="nb mf it ny b gy oj ok l ol om">{<br/>  "id": "d92hf73",<br/>  "title": "Best Practices for Public REST APIs",<br/>  "body": "Foo bar...",<br/>  "createdAt": "2020-08-30 11:17:09 UTC"<br/>}</span></pre><p id="3b80" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个非常简单的结构——它只包含描述资源的属性。如果我们想给这个JSON对象添加更多的信息呢？</p><p id="287d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您熟悉REST架构的HATEOAS组件，那么您可能希望包含到相关实体的链接以及可以在资源上执行的命令。假设我们可以发布或删除一个帖子，并且一个帖子有评论和作者。</p><p id="a95b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有两种方法可以做到这一点:</p><pre class="ks kt ku kv gt of ny og oh aw oi bi"><span id="a15c" class="nb mf it ny b gy oj ok l ol om">{<br/>  "id": "d92hf73",<br/>  "title": "Best Practices for Public REST APIs",<br/>  "body": "Foo bar...",<br/>  "createdAt": "2020-08-30 11:17:09 UTC",<br/>  "commentsUrl": "https://example.com/posts/d92hf73/comments",<br/>  "authorUrl": "https://example.com/author/f9f3ks0",<br/>  "publishUrl": "https://example.com/posts/d92hf73/publication",<br/>  "deleteUrl": "https://example.com/posts/d92hf73"<br/>}</span></pre><p id="7dfc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一种方法是使用“信封”:</p><pre class="ks kt ku kv gt of ny og oh aw oi bi"><span id="faff" class="nb mf it ny b gy oj ok l ol om">{<br/>  "data": {<br/>    "id": "d92hf73",<br/>    "title": "Best Practices for Public REST APIs",<br/>    "body": "Foo bar...",<br/>    "createdAt": "2020-08-30 11:17:09 UTC"<br/>  },<br/>  "links": {<br/>    "commentsUrl": "https://example.com/posts/d92hf73/comments",<br/>    "authorUrl": "https://example.com/author/f9f3ks0",<br/>    "publishUrl": "https://example.com/posts/d92hf73/publication",<br/>    "deleteUrl": "https://example.com/posts/d92hf73"<br/>  }<br/>}</span></pre><p id="214c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对我来说，第一个选项看起来更简洁，因为它没有引入额外的嵌套和与资源无关的结构。</p><p id="9494" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在响应中包含链接允许API客户端开发人员避免在他们的代码中构造URL。这也允许API开发者在不破坏API客户端的情况下更改URL。至少是那些依赖API返回的链接的用户。</p><p id="78ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个有趣的实践是在响应中包含资源的类型和到它自身的链接。在这种情况下，响应可能如下所示:</p><pre class="ks kt ku kv gt of ny og oh aw oi bi"><span id="6373" class="nb mf it ny b gy oj ok l ol om">{<br/>  "id": "d92hf73",<br/>  "self": "https://example.com/posts/d92hf73",<br/>  "type": "Post",<br/>  "title": "Best Practices for Public REST APIs",<br/>  "body": "Foo bar...",<br/>  "createdAt": "2020-08-30 11:17:09 UTC",<br/>  "commentsUrl": "https://example.com/posts/d92hf73/comments",<br/>  "authorUrl": "https://example.com/author/f9f3ks0",<br/>  "publishUrl": "https://example.com/posts/d92hf73/publication",<br/>  "deleteUrl": "https://example.com/posts/d92hf73"<br/>}</span></pre><p id="fefc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">响应JSON中的键的大小写应该总是驼峰式的。因为它是Javascript的标准，而JSON来自Javascript世界。</p><h1 id="48bd" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">收集回应</h1><p id="7544" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">集合响应可以使用信封来包装集合项目。这里有一个例子，博客文章在<code class="fe nv nw nx ny b">data</code>键下返回。本例中的<code class="fe nv nw nx ny b">links</code>键包含指向下一页和上一页文章的URL。</p><p id="1ca6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">GET example.com/api/posts?page=2&amp;limit=10</code></p><pre class="ks kt ku kv gt of ny og oh aw oi bi"><span id="f961" class="nb mf it ny b gy oj ok l ol om">{<br/>  "data": [{<br/>    "id": "d92hf73",<br/>    "title": "Best Practices for Public REST APIs"<br/>  }, {<br/>    "id": "hwp8a2j",<br/>    "title": "REST vs GraphQL"<br/>  }],<br/>  "links": {<br/>    "nextUrl": "<a class="ae lh" href="example.com/posts?page=3&amp;limit=10" rel="noopener ugc nofollow" target="_blank">d92hf73</a>",<br/>    "prevUrl": "example.com/posts"<br/>  }<br/>}</span></pre><p id="f513" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">集合响应不必使用信封。在这种情况下，API可以在HTTP响应头中返回分页URL，如下例所示:</p><p id="4737" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">GET example.com/api/posts?page=2&amp;limit=10</code></p><pre class="ks kt ku kv gt of ny og oh aw oi bi"><span id="f038" class="nb mf it ny b gy oj ok l ol om">[<br/>  {<br/>    "id": "d92hf73",<br/>    "title": "Best Practices for Public REST APIs"<br/>  },<br/>  {<br/>    "id": "hwp8a2j",<br/>    "title": "REST vs GraphQL"<br/>  }<br/>]</span></pre><p id="9387" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">HTTP响应标头:</p><p id="b9d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">Link: &lt;https://example.com/api/posts?page=1&gt;; rel=”prev”, &lt;https://example.com/api/posts?page=3&gt;; rel=”next”, &lt;https://example.com/api/posts?page=34&gt;; rel=”last”, &lt;https://example.com/api/posts&gt;; rel=”first”</code></p><h2 id="579c" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">考虑使用JSON:API</h2><p id="6ec8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果您更愿意使用现有的标准来格式化API中的响应，那么您可能希望使用JSON:API。它相对流行，并提供或多或少的标准响应结构。另一方面，它相当冗长，维护起来可能很耗时。</p><p id="5db9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">参见:<a class="ae lh" href="https://jsonapi.org/" rel="noopener ugc nofollow" target="_blank">https://jsonapi.org/</a></p><h2 id="9ad7" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">对空响应使用有意义的HTTP响应代码</h2><p id="03e2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated"><code class="fe nv nw nx ny b">POST</code>创建资源的请求可能不返回任何内容，而是使用<code class="fe nv nw nx ny b">201 Created</code> HTTP状态并设置<code class="fe nv nw nx ny b">Location</code> HTTP响应头来告诉API客户端如何检索资源。</p><p id="a140" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在一些API<code class="fe nv nw nx ny b">POST</code>、<code class="fe nv nw nx ny b">PATCH</code>、<code class="fe nv nw nx ny b">PUT</code>中，请求可能不返回数据，因为请求处理是异步完成的。在这种情况下，请求可能会返回<code class="fe nv nw nx ny b">202 Accepted</code> HTTP状态，以指示请求已经排队等待处理。</p><p id="59fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当<code class="fe nv nw nx ny b">POST</code>、<code class="fe nv nw nx ny b">PATCH</code>、<code class="fe nv nw nx ny b">PUT</code>、<code class="fe nv nw nx ny b">DELETE</code>请求在语义上不需要返回任何响应时，应该用<code class="fe nv nw nx ny b">204 No content</code> HTTP响应状态进行响应。</p><h2 id="2a4e" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">使用丰富的错误响应</h2><p id="d925" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">错误响应不仅应该表示错误信息，还应该使用正确的HTTP状态代码。如果API客户端发送的数据导致错误，则代码应该是4xx代码之一。如果错误是由服务器端的问题引起的，则应该是5xx代码之一。</p><p id="b6be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">错误响应应该包含足够的信息来为API客户端、API客户端开发人员以及在某些情况下为API客户端用户描述错误。错误响应可能如下所示:</p><p id="e82a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">POST example.com/api/posts</code></p><pre class="ks kt ku kv gt of ny og oh aw oi bi"><span id="8dfc" class="nb mf it ny b gy oj ok l ol om">{<br/>  "errorCode": 123,<br/>  "errorMessage": "Blog post title is too long",<br/>  "developerMessage": "title cannot be longer than 255 characters",<br/>  "info": "https://docs.example.com/api/errors/123"<br/>}</span></pre><p id="5fb4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，在处理API请求时可能会出现许多错误，例如，在验证POST请求主体中发送的数据时。在这种情况下，错误响应可能如下所示:</p><p id="bfeb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">POST example.com/api/posts</code></p><pre class="ks kt ku kv gt of ny og oh aw oi bi"><span id="0c6b" class="nb mf it ny b gy oj ok l ol om">[<br/>  {<br/>    "errorCode": 123,<br/>    "errorType": "validationError",<br/>    "errorMessage": "Blog post title is too long",<br/>    "developerMessage": "title cannot be longer than 255 characters",<br/>    "info": "https://docs.example.com/api/errors/123"<br/>  },<br/>  {<br/>    "errorCode": 123,<br/>    "errorType": "validationError",<br/>    "errorMessage": "Blog post body is too short",<br/>    "developerMessage": "body cannot be empty",<br/>    "info": "https://docs.example.com/api/errors/123"<br/>  }<br/>]</span></pre><p id="f9d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">API开发人员通常从这样的错误响应开始:</p><p id="eb5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">POST example.com/api/posts</code></p><p id="d89c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx ny b">Error message here.</code></p><p id="e3a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是后来它们迁移到<code class="fe nv nw nx ny b">{ "error": "Error message here" }</code>，然后可能是<code class="fe nv nw nx ny b">[{ "error": "Error message here" }, { "error": "Another error message here" }]</code>。因此，从一开始就支持响应中的几个错误可能是个好主意。</p><h1 id="5128" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">API版本控制</h1><p id="872f" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">最好以不需要版本控制的方式来设计和构建REST API。换句话说，API开发者应该不惜一切代价避免破坏性的改变。如果你必须引入大规模的突破性变化，那么你就要发布一个新的API。如果你不得不改变一个特定的资源，以至于它变得与当前版本不兼容，也许那应该是一个新的资源？</p><p id="4777" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，如果您决定引入版本控制，这里有两个策略:</p><ul class=""><li id="6b3a" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated">版本作为URL的一部分，</li><li id="8f10" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated">请求标头中的版本。</li></ul><h2 id="d391" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">作为URL一部分的版本</h2><p id="4fd2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">可以指定版本:</p><ul class=""><li id="13c3" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated"><strong class="lk jd">在领域层面</strong>，即<code class="fe nv nw nx ny b">api2.example.com/posts</code>。优点是版本之间尽可能“远”,并且两个版本可以完全不同地实现。这种方法是最接近API无版本控制的方法。从REST的角度来看，一件好事是资源的URL保持“纯净”，它们不需要包含任何像“v1”这样的片段。他们只指向资源。</li><li id="2f41" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><strong class="lk jd">作为路径片段</strong>，即<code class="fe nv nw nx ny b">example.com/api/v3/posts</code>。这种方式的优点和上一种差不多，只是网址看起来不是特别“纯粹”。但从实用主义的角度来看，这并不总是一个问题。</li><li id="b8e2" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><strong class="lk jd">作为请求参数</strong>，即<code class="fe nv nw nx ny b">example.com/api/posts?version=3</code>。这样做的好处是，在没有明确指定版本的情况下，API开发人员可以选择自动回退到最新或最早的受支持版本。一方面，迁移会“自动”发生，另一方面，如果API开发者引入了突破性的改变，可能会破坏API客户端。</li></ul><h2 id="7564" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">请求标头中的版本</h2><p id="9ab3" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">API客户端还可以使用以下命令指定所需的API版本:</p><ul class=""><li id="d9d7" class="nm nn it lk b ll lm lo lp lr no lv np lz nq md nr ns nt nu bi translated"><strong class="lk jd">自定义HTTP请求头</strong>像<code class="fe nv nw nx ny b">Accepts-version: 23</code>、<code class="fe nv nw nx ny b">Accepts-version: 23</code></li><li id="eeee" class="nm nn it lk b ll nz lo oa lr ob lv oc lz od md nr ns nt nu bi translated"><strong class="lk jd">标准请求头</strong>，如<code class="fe nv nw nx ny b">Accept: application/vnd.example.v23+json</code>或<code class="fe nv nw nx ny b">Accept: application/json; version=23</code></li></ul><p id="983d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果API使用缓存，那么确保在缓存响应时考虑请求头的值是很重要的。</p><h2 id="7827" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">仅使用主要版本号</h2><p id="7c62" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">只使用主要版本号，如v11，不要使用次要版本，如v2.2。</p><h2 id="821f" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">如果没有指定版本，请使用最新版本</h2><p id="5447" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果没有指定版本，请使用最新的版本，因为如果API客户端开发人员在其API客户端进行调用时发现错误，将会提示他们指定所需的版本。默认情况下使用最老的版本，没有办法自动告诉API客户端开发人员有新版本可用。</p><h2 id="49d8" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">在所有API资源中使用一致的版本。</h2><p id="16c5" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">即，用于博客API的<code class="fe nv nw nx ny b">/posts</code>和<code class="fe nv nw nx ny b">/me</code>资源应该总是具有相同的支持版本，即使只有一些资源可能在版本之间发生了变化。</p><h2 id="30d3" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">使用失效响应标题通知资源寿命终止</h2><p id="9790" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">使用<code class="fe nv nw nx ny b">Sunset</code>响应头来表明某个版本的资源将被弃用。另一种方法是随机返回<code class="fe nv nw nx ny b">410 Gone</code> HTTP响应代码，但是这可能会意外地破坏一些客户端。</p><h1 id="dc7b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">证明</h1><p id="40f9" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">最佳实践是使用OAuth2。它被广泛使用，许多开发人员都很熟悉它。不要发明自己的认证机制。通过OAuth，你可以禁止一个特定的客户端访问你的API和特定的应用程序。</p><p id="ffcf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是在某些情况下，您可能允许API客户端使用访问令牌。在这种情况下，API应该允许每个用户有许多令牌。否则，客户不可能在没有任何中断/停机的情况下滚动他们的令牌。</p><h1 id="d4f6" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">API安全性</h1><p id="b800" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">显然，所有API流量都应该通过HTTPS发送，这样就可以在传输过程中加密。</p><h2 id="14c9" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">使用速率限制和节流</h2><p id="643a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">使用每个API客户端的请求速率限制来检测发出过多请求并可能关闭API服务的客户端是很重要的。</p><p id="f4df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个API应该支持429响应代码和标题，比如<code class="fe nv nw nx ny b">Retry-After</code>,以便在请求被重试时提供信息。支持<code class="fe nv nw nx ny b">X-RateLimit-Limit</code>、<code class="fe nv nw nx ny b">X-RateLimit-Remaining</code>和<code class="fe nv nw nx ny b">X-RateLimit-Reset</code>这样的头文件也很棒。希望<code class="fe nv nw nx ny b">RateLimit-*</code>标题将很快成为标准。</p><h2 id="10f0" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">考虑每天或每月的请求数量配额</h2><p id="c102" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">API应该对每个API客户端每月或每天的请求数量有配额。这允许控制单个客户端对API的访问，并防止使用太多的计算资源来服务请求。</p><p id="5bc3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最好不要尝试自己实现速率限制和配额，而使用第三方API网关产品。</p><h1 id="e7e6" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">开发者体验</h1><p id="1313" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">API是为其他开发者使用而构建的。所以API开发者应该让客户端开发者更容易开始使用他们的API。</p><h2 id="5627" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">保持一致性</h2><p id="d148" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">API中的一切都需要一致:命名、错误表示、id、错误代码、状态代码、标题，一切都应该是可预测的。</p><h2 id="e675" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">提供高质量的开发人员文档</h2><p id="9de3" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">流行语言的文档、例子、客户端库应该尽可能地免费提供。看到一个需要开发者注册才能访问文档的API是非常奇怪的。</p><p id="b130" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">文档应该在高层次上描述API，解释每个资源是什么，列出支持的请求以及成功的响应和错误。API产生的每种类型的输出都应该被记录下来，并且应该有看起来真实的例子。</p><p id="72fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">确保你的API文档是最新的。理想情况下，您应该能够从API源代码中生成它们。</p><p id="66e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于开发人员来说，开始使用API的过程应该是非常快速和容易的。也许您可以引入交互式文档，或者编写快速入门指南，或者录制视频演示？</p><h2 id="192f" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">为API客户端开发者提供支持</h2><p id="1db1" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">开发人员在使用您的API时可能会使用各种语言，因此向他们提供使用不同语言的API的示例将是一件非常棒的事情。</p><p id="c2ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更好的是为他们提供GitHub上的开源库，他们可以在自己的项目中使用。</p><p id="e5a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">监控这些GitHub回购是一个好主意，看看开发者是否打开PRs或问题。</p><p id="2b02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">监视像Stack Overflow这样的问答网站也是一个好主意，看看人们是否对你的API提出了问题。客户开发人员联系API开发人员的支持电子邮件地址可能会很有帮助。</p><p id="8468" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你能在GitHub，或者Stack Overflow，或者你自己的网站上围绕你的API创建一个开发者社区，那将是非常棒的，也将允许API客户端开发者互相支持。</p><h2 id="2f95" class="nb mf it bd mg nc nd dn mk ne nf dp mo lr ng nh mq lv ni nj ms lz nk nl mu iz bi translated">考虑提供开发者工具</h2><p id="1081" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">考虑为API用户提供关于他们如何使用API的见解:他们提出了什么请求，他们得到了多少成功和失败的请求，他们离当前计划的极限有多近。它可能不适用于每一个API，但是对于一些调试目的可能非常有用。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="b1e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">差不多就是这样。我们已经讨论了设计资源和请求、成功和错误响应、版本控制、API安全性和开发人员体验的最佳实践。我希望您发现这个小指南很有用，并且能够在设计和构建您的下一个REST API时应用它们。</p><p id="2b36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本指南基于我在2019年11月墨尔本API Meetup上的演讲。你可以在这里找到幻灯片<a class="ae lh" href="https://www.slideshare.net/AndrewGridnev/best-practices-for-public-rest-apis" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>