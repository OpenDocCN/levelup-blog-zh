<html>
<head>
<title>Locking-Based Isolation at SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL Server上基于锁定的隔离</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/locking-based-isolation-at-sql-server-fdfafce9c8e8?source=collection_archive---------20-----------------------#2022-08-03">https://levelup.gitconnected.com/locking-based-isolation-at-sql-server-fdfafce9c8e8?source=collection_archive---------20-----------------------#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/58fc4f28d4efa7af1f71990c9edce768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vofzNX-huS8M_vEIfhFfg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片来自<a class="ae kc" href="https://www.freepik.com/free-vector/gradient-sql-illustration_22112357.htm" rel="noopener ugc nofollow" target="_blank"> Freepik </a></figcaption></figure><h1 id="b0b7" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="4043" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在SQL世界中，事务是一个工作单元，它包括查询或修改数据库数据的单个或多个操作，将数据库从一种一致状态转换为另一种一致状态。</p><p id="d41d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了实现这种一致性并保证数据完整性，事务有四个属性，缩写为<strong class="ld ir"> ACID </strong>。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="856b" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">酸性质一瞥</h1><ul class=""><li id="b06f" class="mq mr iq ld b le lf li lj lm ms lq mt lu mu ly mv mw mx my bi translated"><strong class="ld ir">原子性(A) </strong>:要么事务中的所有操作都成功执行，要么都不执行。</li><li id="bd9f" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated"><strong class="ld ir"> Consistency (C) </strong>:事务通过控制隔离级别和遵守数据库中定义的完整性规则(如主键、外键和唯一约束)，将数据库从一种一致状态转换为另一种一致状态。</li><li id="feed" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated"><strong class="ld ir">隔离(I) </strong>:并发事务只能访问一致的数据，换句话说，事务独立发生，没有干扰，这可以通过控制隔离级别来实现。</li><li id="b0e3" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated"><strong class="ld ir">持久性(D) </strong>:一个成功的事务所做的修改必须存储在永久存储器上，这样即使系统发生故障，它们也能持久保存。</li></ul><p id="ac53" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在本文中，我们将重点关注<strong class="ld ir">隔离</strong>属性，它是如何工作的，它的级别，以及每个级别的异常情况。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="f91a" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">隔离模型(悲观与乐观并发控制)</h1><p id="1eca" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">正如我们提到的，数据库隔离使事务能够独立发生而不受干扰，所以这里的问题是，如何实现这一点？</p><p id="73d5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">SQL Server有两种模型来实现事务之间的隔离:</p><ul class=""><li id="0e61" class="mq mr iq ld b le lz li ma lm ne lq nf lu ng ly mv mw mx my bi translated"><strong class="ld ir">锁定(悲观)</strong>:如果数据的当前状态不一致，读取器被阻塞(<em class="nh">必须等待</em>)，直到数据变得一致。</li><li id="cd38" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated"><strong class="ld ir">行版本控制(乐观)</strong>:如果数据的当前状态不一致，读取器会获得一致数据的旧版本，因此读取器不会被阻塞(<em class="nh">不能等待</em>)。</li></ul><p id="91e0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在本文中，我们将重点介绍基于锁定的<em class="nh">(悲观并发控制)</em>模型。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="933f" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">隔离锁定模式</h1><p id="cec9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">要了解隔离机制在SQL Server中是如何工作的，您必须熟悉两种锁定模式:</p><ul class=""><li id="c7ea" class="mq mr iq ld b le lz li ma lm ne lq nf lu ng ly mv mw mx my bi translated"><strong class="ld ir">独占</strong>:当一个事务修改<em class="nh">(更新、删除或插入)</em>数据时，它请求一个<strong class="ld ir">独占锁</strong>，如果被授予，这个锁将被持有直到事务完成(<em class="nh">整个事务</em>)。之所以称之为“排他锁”，是因为如果一个资源已经有了任何锁模式，就不能获得这个资源上的排他锁；如果一个资源已经有了独占模式，那么在这个资源上就不能获得其他的锁模式。</li><li id="39ed" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated"><strong class="ld ir">共享</strong>:当一个事务读取<em class="nh"> (select) </em>数据时，请求一个<strong class="ld ir">共享锁</strong>，一旦read语句或整个事务完成<em class="nh">(基于隔离级别)</em>。之所以称之为“共享”是因为多个事务可以同时在一个资源上拥有共享锁。</li></ul><p id="e080" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了更清楚起见，请看下表，假设两个事务在同一资源上请求不同的锁模式:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/15776f5c01a8b64dedbfbba1c0703973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWcMueL3NIPiq25l5cncqw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">隔离锁定模式(作者提供照片)</figcaption></figure></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="7f34" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">隔离级别</h1><p id="af02" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">隔离级别是并发事务处理同一资源时的数据一致性级别。隔离级别越高，锁越严格，等待时间越长，这意味着隔离级别越高，一致性越高，并发事务越少。</p><p id="e478" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">隔离级别的主要目标是控制以下影响:</p><ul class=""><li id="9a41" class="mq mr iq ld b le lz li ma lm ne lq nf lu ng ly mv mw mx my bi translated">读者是否请求锁，如果是，锁被持有多长时间。</li><li id="43a5" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated">如果一个事务修改了<em class="nh">(持有独占锁)</em>一个资源，另一个读取器想要读取同一个资源，这种情况下读取器的行为是什么:<br/> -读取未提交的数据。<br/> -读取最后提交的数据。<br/> -阻塞<em class="nh">(等待)</em>直到资源上的独占锁被释放。</li></ul><p id="f553" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">事实上，每个数据库引擎都以不同的方式实现其隔离级别，但是SQL Server支持六个隔离级别，其中四个级别是基于锁定的<em class="nh">(未提交读、提交读、可重复读和可序列化)</em>，两个级别是基于行版本控制的<em class="nh">(快照和提交读快照)。</em></p><blockquote class="nn no np"><p id="7401" class="lb lc nh ld b le lz lg lh li ma lk ll nq mb lo lp nr mc ls lt ns md lw lx ly ij bi translated"><strong class="ld ir"> <em class="iq">在潜入实际例子之前请记住这几点:</em> </strong></p><p id="ae3e" class="lb lc nh ld b le lz lg lh li ma lk ll nq mb lo lp nr mc ls lt ns md lw lx ly ij bi translated">-在较低隔离级别被阻止的任何异常不会在较高级别发生。<br/> -任何已经存在于较高层次的异常，肯定会存在于较低层次。<br/> -在所有隔离级别，任何写入者都必须请求一个独占锁来修改数据，一旦整个事务完成，该锁就会被释放。<br/> -对于单行，如果不显式启动事务，它会隐式启动并提交。<br/> -在较低隔离级别被阻止的任何异常不会在较高级别发生。</p></blockquote></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><blockquote class="nn no np"><p id="baf5" class="lb lc nh ld b le lz lg lh li ma lk ll nq mb lo lp nr mc ls lt ns md lw lx ly ij bi translated"><strong class="ld ir"> <em class="iq">要在您的SQL Server数据库上尝试这些示例，请遵循以下步骤:</em> </strong></p><p id="68f1" class="lb lc nh ld b le lz lg lh li ma lk ll nq mb lo lp nr mc ls lt ns md lw lx ly ij bi translated">1-创建自己的数据库(在我的例子中称为“isolation _ db”)<br/>2-<em class="iq">创建“users”表并插入这个假行:</em></p></blockquote><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><blockquote class="nn no np"><p id="ce91" class="lb lc nh ld b le lz lg lh li ma lk ll nq mb lo lp nr mc ls lt ns md lw lx ly ij bi translated">3-打开到数据库Con1和Con2的两个连接。<br/> 4-遵循图片中显示的步骤。<br/> 5-完成以下任何示例后，提交任何正在运行的事务，然后运行以下语句进行清理:</p></blockquote><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c6bd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">事不宜迟，让我们从最低到最高进入基于锁定的隔离级别:</p><h1 id="4dbb" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1-未提交的读取</h1><h2 id="d7b7" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它是如何工作的</h2><p id="d22d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个级别是最低的隔离级别，在这个级别上，读取器不需要共享锁来读取数据。</p><h2 id="9698" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它解决的异常</h2><p id="c6a3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> -脏写</strong>:如果一个事务更新了一个资源，而另一个事务在第一次完成之前更新了相同的资源，就会发生这种情况。</p><p id="27ef" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这个级别可以通过排他锁冲突来避免这种异常。换句话说，如果一个写线程持有一个独占锁，任何其他写线程都不能同时获得一个独占锁，必须等到另一个独占锁被释放。</p><p id="2a25" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们跳到一个实际的例子来阐明这个级别如何避免肮脏的书写:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/e59e6203e3cad47011fe09d20713e094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JclM6-4mlUHqE790"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/3804fd0ada3a81e08921675f4be3f414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uqwGoK7-loWmwOHN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure><h2 id="cf22" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它的异常之处</h2><p id="87e3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> -脏读</strong>:如果一个事务从另一个未提交的事务中读取更改，就会出现这种情况。</p><p id="4e6c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">出现这种异常是因为这个级别不要求共享锁，所以与任何拥有独占锁的写入者没有冲突，这意味着读取者可以读取未提交的更改。</p><p id="1a69" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">按照这个例子:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/ec6dee70db96eac1ed0354a70a8e05e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8SBk2T0Rf4YW001I"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/7ce5d7ded1c1110ba0c5fc67fc092955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h1wAQQnVUrLOnUlK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="c37f" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">2-已提交读取</h1><h2 id="7069" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它是如何工作的</h2><p id="8d7d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这一级别，读取者必须请求共享锁来读取数据，这意味着如果写入者持有独占锁，而读取者请求共享锁，则该请求将与独占锁冲突。一旦写入方提交事务，读取方就可以获得它的共享锁。此时，读者只读取已提交的更改。</p><p id="b7f8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">您必须知道的另一个重要注意事项是，一旦读取器<em class="nh">(事务语句)</em>完成整个事务，共享锁就会被释放。</p><p id="136a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这个隔离级别是SQL Server的默认级别，您可以通过运行这个语句<code class="fe oj ok ol om b">DBCC useroptions;</code>来获得<code class="fe oj ok ol om b">isolation level</code>选项</p><h2 id="3b53" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它解决的异常</h2><p id="b9ec" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> -脏读</strong></p><p id="aca2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">按照这个例子:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/9e29acb9785d43701ea2b7c57fca9e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QqklyAVrbp7Li6d2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/4fe38b0aeb27422811767b25f398dc40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jJew1l7xL-GnAmRT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure><h2 id="c5ed" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它的异常之处</h2><p id="b18b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> -不可重复读取:</strong>当一个事务多次读取同一个资源，由于被另一个提交的事务改变而得到不同的结果时，就会出现这种情况。</p><p id="ac0e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">因为此级别的共享锁在事务语句完成后立即被释放，而不是整个事务，所以如果我们有两个事务，第二个事务可以在同一资源的第一个事务的多个共享锁之间持有资源<em class="nh">(修改资源)</em>的独占锁。</p><p id="a2c8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们通过例子来澄清这种反常现象:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/8080872ec593ed1d4e95752d62ccfb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fm_XtbI28ngg7mU0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/4eb8f225212a53fc017d821561d4bf16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O4Dj_2LPswIyO-et"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure><p id="39de" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> -更新丢失</strong>:这种情况发生在两个事务读取一个值，将它们读取的内容存储在内存中，然后根据这个存储的值更新一个资源，这意味着第一个事务不知道第二个事务已经更改了资源值。</p><p id="ca0f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">因为此级别的共享锁在事务语句完成后立即释放，而不是在整个事务中释放，所以读取器可以读取资源值，将其存储在内存中，另一个事务可以获得独占锁，并在第一个事务释放共享锁后立即更新资源。</p><p id="734f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果这个解释不清楚，请按照这个例子:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/5d1ff2955c3649654aacc8db039163df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oPV1szfmZlnVkP-g"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/f013c921b63ba98c5715e8a4d6ffd2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pvVgiJuBYjYWAYng"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="2f77" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">3-可重复读取</h1><h2 id="6248" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它是如何工作的</h2><p id="08e9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这个级别，一个读取器必须请求一个共享锁来读取数据，并且这个读取器持有这个锁，直到整个事务结束<em class="nh">(不仅仅是像read committed这样的语句)</em>，这意味着如果一个读取器持有一个共享锁，则没有写入器可以获得一个独占锁来更新这个资源，直到通过完成事务来释放共享锁。</p><h2 id="111d" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它解决的异常</h2><p id="47e6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> -不可重复读取</strong></p><p id="366b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">按照这个例子:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/b8de563db6514928b938b4c3a9d3496b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bUhzFHEaCYZ1_AIa"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/f0b4dcbbd341372b4d57c27284ca413f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IEYT26L4CxqF3rXA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure><p id="38ef" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> -丢失更新</strong></p><p id="2392" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">按照这个例子:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/0d02c5bddedd1ab69a41b830deec1f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ru1SYRHKfjJmfUFV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/89c0044d1ced5a5c1e11d383c86c0815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*89MFhpgGjTRSKcTB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure><h2 id="3cba" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它的异常之处</h2><p id="9c30" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> - Phantom Reads: </strong>一个事务只锁定它在特定过滤器下第一次查询时找到的行，而不锁定可能在这次查询后被另一个事务插入并满足该过滤器的行。换句话说，第一个事务中的第二个查询将返回新行，这些行称为虚行。</p><p id="2fca" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果这个解释不够清楚，请参照这个例子:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/418b3b84503f8f14d02fab3d14fcc60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5nWRz6pG7C989suo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/e4041d3baf819244b490d8b6eb949fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TX6-dNqPEcsOLNdO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="ff1b" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">4-可序列化</h1><h2 id="22d7" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它是如何工作的</h2><p id="c60f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这个级别上，读取器必须请求一个共享锁来读取数据，并且这个读取器持有这个锁，直到整个事务结束，在此之上，读取器锁定符合查询的过滤器的任何行，这意味着读取器不仅锁定已经存在的行，而且锁定将来可能被另一个事务插入以满足查询的过滤器的任何行。</p><h2 id="52d7" class="nv ke iq bd kf nw nx dn kj ny nz dp kn lm oa ob kr lq oc od kv lu oe of kz og bi translated">它解决的异常</h2><p id="3346" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> -幻象读取</strong></p><p id="518d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们通过示例了解该级别如何防止幻像行:</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/5c02431e435750da009c7ea4b31e8bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CdesdSTTkV-_F_mP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连接1(作者照片)</figcaption></figure><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/62f80b74ecb12ddfd07f73a68fe89229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kHL2bZdmqxa_EW1B"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">连线二(作者供图)</figcaption></figure><p id="2c76" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">查看此汇总表，了解隔离级别及其异常情况</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/4294f6f7c34876ae44ee9a83562df938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XsJDnY4XDLlMPAZe"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">隔离级别及其异常情况汇总(作者提供照片)</figcaption></figure></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="237a" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">您应该使用哪种隔离级别？</h1><p id="f088" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">不幸的是，没有放之四海而皆准的解决方案，正如我们所知，选择的隔离级别越高，性能越低，延迟越大，吞吐量越低。所以你不应该盲目地选择可串行化级别，因为完美通常是有代价的。</p><p id="32f3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">作为第一步，您应该知道您的应用的性质以及它将面临的异常情况，并据此决定选择哪种隔离级别。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="1955" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">结论</h1><p id="0fc4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在本文中，我们了解了SQL Server如何控制事务之间的并发性，如何通过选择隔离级别来控制数据一致性级别，以及每个隔离级别的异常情况。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="98af" class="kd ke iq bd kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la bi translated">资源</h1><ul class=""><li id="53d6" class="mq mr iq ld b le lf li lj lm ms lq mt lu mu ly mv mw mx my bi translated">T-SQL基础知识第三版</li><li id="b25f" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated"><a class="ae kc" href="https://docs.microsoft.com/en-us/sql/connect/jdbc/understanding-isolation-levels" rel="noopener ugc nofollow" target="_blank">了解隔离级别</a></li><li id="9897" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated"><a class="ae kc" href="https://begriffs.com/posts/2017-08-01-practical-guide-sql-isolation.html" rel="noopener ugc nofollow" target="_blank">SQL事务隔离实用指南</a></li></ul></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><pre class="nj nk nl nm gt oo om op oq aw or bi"><span id="c00d" class="nv ke iq om b gy os ot l ou ov"><em class="nh">Originally published at </em><a class="ae kc" href="https://blog.mayallo.com/locking-based-isolation-at-sql-server" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://blog.mayallo.com</em></a><em class="nh">.</em></span></pre></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><p id="26e5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="2e0a" class="mq mr iq ld b le lz li ma lm ne lq nf lu ng ly mv mw mx my bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="c2f5" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated">📰查看更多内容请参见<a class="ae kc" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="ffbb" class="mq mr iq ld b le mz li na lm nb lq nc lu nd ly mv mw mx my bi translated">🔔关注我们:<a class="ae kc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kc" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="7aa2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">🚀👉<a class="ae kc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>