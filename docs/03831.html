<html>
<head>
<title>Python3: Mutable, Immutable… everything is an object!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python3:可变的，不可变的…一切都是对象！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python3-mutable-immutable-everything-is-an-object-1c5d8c7ffb76?source=collection_archive---------18-----------------------#2020-05-28">https://levelup.gitconnected.com/python3-mutable-immutable-everything-is-an-object-1c5d8c7ffb76?source=collection_archive---------18-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cca070f6e1d8f5065eafea6992a519a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3JHBTtYBHXKefFbyb2qYw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">欢迎来到python的书呆子伙伴们！</figcaption></figure><p id="fa01" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对编码知识的探索仍在继续，我和我的团队最近进入了一个新的领域，面向对象编程。在过去的3个月里，我一直专注于学习C和函数式编程，但现在是时候学习Python和一切都是对象的思想了。因此，如果你一直在学习自己编程，或者刚刚接触技术，你可能以前就听说过这个想法:“一切都是对象”。那到底是什么意思？</p><p id="f148" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当你在处理一个面向对象的程序时，你可以考虑你代码的每一个单独的部分；无论是变量、函数、类还是数据结构，都可以作为一个对象。与您日常生活中的对象类似，编程中的对象也有特征或属性以及能力或功能。虽然您的咖啡杯可能有高度和容量属性，但它可能包含咖啡或茶，代码中的对象可能有数字id属性，它可能有到另一个对象的链接，或者它内置了执行特定任务的函数。虽然很容易将一个对象(如咖啡杯)的物理属性概念化为与Python中变量的某些属性相关联，但对于更深奥的东西(如链接)来说，最好考虑可以放在对象上的标签。一个过时的概念是，所有python对象都是放入数据的盒子，但当您开始深入了解对象如何以物理盒子永远不会有的方式相互链接和关联时，这可能会妨碍理解。因此，当我们开始进入面向对象编程的兔子洞时，非常重要的内置函数会在这个过程中帮助我们:type()和id()。</p><h1 id="0b23" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">类型()和id()</h1><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mb"><img src="../Images/bc1927d9fbf6537ea15ed9fddc5e99af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tS0HNhKXfghvmstESOsarg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">python解释器和一些对象及其类型和id的视图。</figcaption></figure><p id="62c2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当您开始理解对象和面向对象编程时，类型和id是帮助您找到方向的重要功能。先说类型。Type是一个模块(函数),它会告诉你它所接受的参数的类类型，在这个例子中，是你正在处理的对象。如上图所示，我们有三个名为a、b和c的对象。当我们使用<strong class="kh iu"> type() </strong>时，我们可以看到a是一个整数，b是一个字符串，c是一个列表。虽然这种对我们正在处理的对象类型的检查看起来很简单，但在我早期学习python时，我发现它对错误处理非常有用。例如，当我编写一个模块，希望使用一个整数来执行一些数学运算时，我将运行的第一个检查是对传递给我的模块的数据进行类型检查。如果我的函数被发送了一些不属于int类型的数据，这种类型检查允许我抛出一个TypeError。</p><p id="a3d6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> id() </strong>像<strong class="kh iu"> type() </strong>表面上看是一个相当简单的函数。<strong class="kh iu"> id() </strong>返回给定参数的内存地址。这类似于在C中使用&amp; variable_name，如果您发现在编程中需要指针，也可以有类似的功能。回头参考本节顶部的图片，我们可以看到，当我们在每个对象上调用<strong class="kh iu"> id() </strong>时；a，b和c，它们在内存中有不同的地址。当我们深入研究可变和不可变对象以及python如何处理被赋予相同值的对象时，记住内存地址的概念对我们来说很重要，这样我们就可以检查什么是唯一对象(有自己的内存地址)，什么只是指向相同数据的副本(共享内存地址)</p><h1 id="812b" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">可变对象与不可变对象</h1><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/70243ce22cf4ad33589db9475c246e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/1*2i7dTnVaVPAuxN-uzX76JQ.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">变形多边形当然是可变的</figcaption></figure><p id="7638" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">python中可变对象的最简单解释是这样的:可变对象是在创建后其值可以自由修改的对象。这当然也给了我们什么是不可变对象的简单定义；创建后不能随意更改的对象。那么有哪些可变和不可变对象的可靠例子，以及我们如何使用它们呢？在事物可变的一面，我们有像列表、集合和字典这样的数据类型。所有这三种数据类型都可以修改值，而不必创建新的实例。例如，在下图中，您可以看到我们将要创建一个包含“a”、“b”和“c”的列表，然后将“b”更新为“x ”,而无需创建新列表。当我们对一个不可变的对象做同样的事情，比如一个冻结的集合，一个字符串，或者一个元组，就像下面的例子，我们会得到一个错误。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/3f7e083b3fd064eb68dda8e2961fcf0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W35TcIkK3QCWxcI2dXgqtg.png"/></div></div></figure><p id="c9f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是像string1 = string1 + string2这样的呢？看起来，如果我们连接两个字符串，同时保持第一个字符串的变量名，我们是在修改一个不可变的对象，对吗？是也不是；你改变了string1在这里所指的内容，这意味着你将在内存中有一个新的地址。string1所指向的东西不见了，现在string1和string2的连接版本就是string1的值。在下面的示例中，您可以看到，当我们在串联前后检查str1上的<strong class="kh iu"> id() </strong>时，内存地址是不同的。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/5179ab293cc06ab98b15e3330b76c22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*X-K8rh2V_a-QKZcgbRy_Ug.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">字符串是不可变的，但是如果你把两个连接起来，你会在内存中得到一个新的结果地址</figcaption></figure><p id="0cd8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好的，所以像字符串这样的不可变类型可以被更新，但是它在内存中不再是同一个对象，这是可以理解的，但是像列表元组这样的分层对象呢？好吧，让我们看看下面的例子。如你所见，我可以用列表等对象创建一个元组，列表本身包含字符串对象。然后，我可以在每个列表中添加额外的字符串，在不改变元组的内存地址的情况下，完成一些来自Monty Python和圣杯的侮辱。另一方面，当我试图用一个整数替换第一个列表时，我得到一个错误，让我知道元组不是这样玩的。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/bf2e49f1075e813f86e8b668bf14e571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*PXOOCnyTrTqW8bQXJp-x_g.png"/></div></div></figure><p id="e5e5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么函数呢，它们是如何处理可变和不可变对象的呢？对于不可变对象，这意味着即使是函数也不会修改原始变量的值。不可变对象通过值传递给函数，这意味着原始变量的值不会被更新。另一方面，可变对象通过引用传递，因此可以通过函数中的操作进行更新。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/7628afac97c10578d5d4ffd9359d596f.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/0*wP9aipj4zhL7WBHW.png"/></div></figure><p id="8d39" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么不可变或可变对象有什么好处呢？嗯，不可变对象对于你希望保持其值的变量来说是很好的。由于不能自由修改，它们将保留您最初分配给它们的数据。这有助于维护信息和调试。权衡的结果是，如果您确实需要更新受保护的值，则每次都需要创建一个新的变量，这将降低性能。可变对象总是更适合程序运行时需要更新的数据，因为它可以自由修改。python用来帮助优化性能的一个很好的技巧是，它将预加载小数字，这种数字通常用于计数器和基本数学。这些被称为NSMALLPOSINTS和NSMALLNEGINTS，它们提供了-5到257的范围。</p><p id="56f2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当然，这仅仅是对面向对象编程的一点皮毛，我期待着随着我的学习，通过更多的博客文章深入了解这一点。如果你有想法，评论，指正，请在评论里告诉我，一如既往的快乐学习！</p></div></div>    
</body>
</html>