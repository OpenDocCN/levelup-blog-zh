<html>
<head>
<title>I have made this animations to explain logic gates and Flip-Flops to my students</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我制作了这个动画来向我的学生解释逻辑门和触发器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-does-x-and-x-equal-true-177c87699a14?source=collection_archive---------9-----------------------#2020-06-14">https://levelup.gitconnected.com/when-does-x-and-x-equal-true-177c87699a14?source=collection_archive---------9-----------------------#2020-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="237f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简要介绍逻辑门和触发器</p><p id="bbc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何程序员都会说<code class="fe ko kp kq kr b">x and !x</code>永远是假的。当然，如果<code class="fe ko kp kq kr b">x</code>为真，那么<code class="fe ko kp kq kr b">!x</code>为假，反之亦然。而<code class="fe ko kp kq kr b">1 and 0</code>永远是<code class="fe ko kp kq kr b">0</code>。</p><p id="a56d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我说这不总是对的呢？我是说，不总是假的？此外，在计算机体系结构中，这经常被使用！</p></div><div class="ab cl ks kt hx ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="im in io ip iq"><h2 id="5fe4" class="kz la it bd lb lc ld dn le lf lg dp lh kb li lj lk kf ll lm ln kj lo lp lq lr bi translated">逻辑门基础</h2><h2 id="161f" class="kz la it bd lb lc ld dn le lf lg dp lh kb li lj lk kf ll lm ln kj lo lp lq lr bi translated">不</h2><p id="8c74" class="pw-post-body-paragraph jq jr it js b jt ls jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj lw kl km kn im bi translated">我们将使用两种类型的门:NOT和and。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/b886f6b0a3c4a460793f197885e68ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*zc2GETgTnov9qCBtWVYhvA.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">非门</figcaption></figure><p id="2909" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“非”门接受输入值并将其反转。因此，如果我们将True (1)作为输入，我们将得到False (0)作为输出，反之亦然。换句话说，它是一个<code class="fe ko kp kq kr b">1-x</code>函数。</p><h2 id="75fa" class="kz la it bd lb lc ld dn le lf lg dp lh kb li lj lk kf ll lm ln kj lo lp lq lr bi translated">和</h2><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/2e967ff60ab29505331e8ff93b391a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*X6hI7rBcXaiapkwbfqcDtw.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">真真假假就是假</figcaption></figure><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/4292c92be4aea989d1c45f5e4d470d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*njAn4g8uoGH-swvPEhoe2A.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">假的假的就是假的</figcaption></figure><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/fc3bbac4a111353ab7bacf20f598bbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*MPYgJQTK-OWgzqhPvgEq5w.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">真实和真实是真实的</figcaption></figure><p id="5961" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有当与门的两个输入都为真时，与门才为真。它相当于函数<code class="fe ko kp kq kr b">x*y</code>，因为如果你把0乘以1，或者0乘以0，你得到0。只有当你把1乘以1，你才得到1。</p></div><div class="ab cl ks kt hx ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="im in io ip iq"><h2 id="9d53" class="kz la it bd lb lc ld dn le lf lg dp lh kb li lj lk kf ll lm ln kj lo lp lq lr bi translated">魔力</h2><p id="87a3" class="pw-post-body-paragraph jq jr it js b jt ls jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj lw kl km kn im bi translated">到目前为止够简单了。这是一个理论，这是很多开发者都知道的。开发人员通常不关心这些门的速度:</p><blockquote class="mj mk ml"><p id="cfe8" class="jq jr mm js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">这些门需要时间来处理输入和改变输出。</p></blockquote><p id="e110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看非门动画。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/eee42d11b572e50fe7e174e54d0dc4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/1*Yx1U4IrQOvhrqwxaR1Otlw.gif"/></div></figure><p id="2b91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仔细看。在一小段时间内，当从1切换到0或从0切换回来时，我们在门的两端有相同的值。</p><p id="8ef1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，我们已经有了一些魔法。短时间内我们有<code class="fe ko kp kq kr b">!x==x</code>。</p></div><div class="ab cl ks kt hx ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="im in io ip iq"><h2 id="ff5d" class="kz la it bd lb lc ld dn le lf lg dp lh kb li lj lk kf ll lm ln kj lo lp lq lr bi translated">触发器</h2><p id="b27f" class="pw-post-body-paragraph jq jr it js b jt ls jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj lw kl km kn im bi translated">现在，你可能已经猜到了<code class="fe ko kp kq kr b">x and !x</code>等于True是怎么回事:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/c08595a423e9dcaa34375ca18d33a6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/1*m5hFvtlZqxF9BxGamL4l-Q.gif"/></div></figure><p id="8df1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当输入从0变为1时，非门还没有被触发，与门的两个输入都是1。下一步，非门和与门一起被触发，我们在短时间内得到1。</p><blockquote class="mj mk ml"><p id="cfd4" class="jq jr mm js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">这样，与门的输入为<code class="fe ko kp kq kr b">x</code>和<code class="fe ko kp kq kr b">!x</code>。有时我们会输出一个真值。</p></blockquote><p id="c793" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们仔细看看:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/8a1992bfd88e2f81b45184264d95922b.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/1*f4a2yg8uh82lMGlWmWCI7w.gif"/></div></figure><p id="9861" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种逻辑电路叫做触发器。</p></div><div class="ab cl ks kt hx ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="im in io ip iq"><h2 id="848a" class="kz la it bd lb lc ld dn le lf lg dp lh kb li lj lk kf ll lm ln kj lo lp lq lr bi translated">我们为什么需要它？</h2><p id="fc47" class="pw-post-body-paragraph jq jr it js b jt ls jv jw jx lt jz ka kb lu kd ke kf lv kh ki kj lw kl km kn im bi translated">在每台计算机中，我们都有一个所谓的总线时钟。它是一个以很高的频率将其值从0改变到1以及从0改变到1的单位。在这些转换之间，计算机上的所有导线都被设置为0和1，准备保存到RAM或进行计算。处理器为下一次操作准备操作数，RAM准备要传输给处理器的数据，依此类推。一旦每个人都准备好了，在时钟从0变到1的那一刻，操作就完成了。也就是说，“使能位”被设置为1，这就是我们的触发器连接的地方。这些“使能位”启动操作。当它为零时，主板上的所有设备都在等待和准备，它们不接受任何输入并保持输出，直到时钟说“现在！”。</p><p id="dd29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看这张照片:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/b879790d93293dfdc3cc514ba394de6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*olwzRGm8bDfNuBLxWKZrTg.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">D触发器。图3.26摘自Andrew S. Tanenbaum的《结构化计算机组织》，第五版。</figcaption></figure><p id="7aa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们有一段记忆。为了保存一个新值，我们给<code class="fe ko kp kq kr b">D</code>输入相应的1或0。并且保持它直到左侧的触发器被触发。一旦触发，存储器从<code class="fe ko kp kq kr b">D</code>读取数据并保存。从那一点开始，<code class="fe ko kp kq kr b">Q</code>的值被改变，直到一个新值被保存。</p><p id="06dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设，我们没有这个奇怪的带触发器的时钟。那么你如何知道<code class="fe ko kp kq kr b">D</code>值是我们真正想要保存到内存中的，还是它已经保存了一些其他数据，可能正在被其他寄存器使用？还有，<code class="fe ko kp kq kr b">D</code>输入本身不是内存，它保存要保存的信息，但之后它就失去了它的价值。</p><p id="fbe3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这不是太无聊，你喜欢这篇文章。每个开发人员都应该知道他/她的计算机内部发生了什么。</p></div></div>    
</body>
</html>