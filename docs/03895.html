<html>
<head>
<title>A Simple Method to Calculate Circular Intensity Averages in Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种计算图像圆形灰度平均值的简单方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-simple-method-to-calculate-circular-intensity-averages-in-images-4186a685af3?source=collection_archive---------8-----------------------#2020-06-01">https://levelup.gitconnected.com/a-simple-method-to-calculate-circular-intensity-averages-in-images-4186a685af3?source=collection_archive---------8-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="921c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python确定图像中强度随径向距离的变化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0588b0f4ab2f6f8a80f8046a37b11b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vSlO_tXLl-3viCZ_Oicrg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@thegalaxyshooter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">詹姆斯·托马斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/circle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="9506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实验材料科学中，我们经常得到如下图所示的图像，称为X射线衍射图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/8870ac0791ae6a81e5afe1bac6b702f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*Pj2ywikZZWuALlkG4EmwwQ.png"/></div></figure><p id="f00b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，被测样品的对称性导致图像具有恒定强度的环，称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Powder_diffraction" rel="noopener ugc nofollow" target="_blank">德拜-谢勒环</a>。对我们来说，这是多余的数据，我们需要将此图像简化为径向距离(从所有环的中心)与每个径向距离的强度的简单图表。最简单可行的方法是，取一条从中心开始向外径向延伸的线，记录每个径向点的强度。然而，更可靠的方法是使用整个环的平均强度，以确保可变性得到平均。</p><p id="3a8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来这个做起来很简单！这里显示的例子将使用Python包<code class="fe lw lx ly lz b">numpy</code>完成，并使用<code class="fe lw lx ly lz b">matplotlib</code>可视化。此外，为了导入这个例子中的TIFF文件，我将使用一个名为<code class="fe lw lx ly lz b">tifffile</code>的包，它可以在<a class="ae ky" href="https://pypi.org/project/tifffile/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="357a" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated"><strong class="ak">加载图像</strong></h1><p id="2322" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">首先，我们导入将要使用的包:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="75d3" class="nb mb it lz b gy nc nd l ne nf"># Import packages<br/>import matplotlib.pyplot as plt<br/>import matplotlib as mpl<br/>import numpy as np<br/>from tifffile import imread, imshow</span></pre><p id="3502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以通过使用<code class="fe lw lx ly lz b">tifffile.imread</code>来加载我们的映像。我们的做法如下:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="a999" class="nb mb it lz b gy nc nd l ne nf"># Load our image<br/>img = imread('DiffractionImage.tif')</span></pre><p id="90cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在想展示我们的图像来检查它看起来是什么样子，我们可以使用下面几行代码:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="2e20" class="nb mb it lz b gy nc nd l ne nf"># Show our image<br/>imshow(img)<br/>plt.show()</span></pre><h1 id="507d" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated"><strong class="ak">计算径向距离</strong></h1><p id="0fc8" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">通过检查，我们发现所有圆的中心都在像素值(1242，642)——第1242行和第642列。所以我们要做的第一件事是重新定义像素坐标，使这一点的径向距离为0。这一转变将包括2个步骤:</p><ol class=""><li id="d8fc" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">创建两个网格—一个对应于x坐标，一个对应于y坐标</li><li id="9428" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">使用x和y值计算每个点的径向距离，并创建一个新格网-新格网中的每个点将具有与(1242，642)的径向距离相对应的值</li></ol><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="be1f" class="nb mb it lz b gy nc nd l ne nf"># Image center<br/>cen_x = 642<br/>cen_y = 1242</span><span id="8c19" class="nb mb it lz b gy nu nd l ne nf"># Get image parameters<br/>a = img.shape[0]<br/>b = img.shape[1]</span><span id="f609" class="nb mb it lz b gy nu nd l ne nf"># Find radial distances<br/>[X, Y] = np.meshgrid(np.arange(b) - cen_x, np.arange(a) - cen_y)<br/>R = np.sqrt(np.square(X) + np.square(Y))</span></pre><h1 id="d1f3" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated"><strong class="ak">初始化变量</strong></h1><p id="3fde" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们现在将初始化用于平均计算的变量。这里，我们需要设置平均的分辨率。下面的代码行创建了一个名为<code class="fe lw lx ly lz b">rad</code>的数组，它的径向值从1个像素到网格中的最大径向值。第三个参数定义了我们想要的径向点的密度或稀疏度(在本例中，每1个像素)。该数组将作为我们最终绘图中的x值:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="17cf" class="nb mb it lz b gy nc nd l ne nf">rad = np.arange(1, np.max(R), 1)</span></pre><p id="0b38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们为我们的y值(强度)初始化数组。我们创建了一个长度与<code class="fe lw lx ly lz b">rad</code>相同的0的数组(我们会随着时间的推移而改变)，以及一个名为<code class="fe lw lx ly lz b">index</code>的索引变量，我们将使用它来跟踪我们在哪里改变强度:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="6681" class="nb mb it lz b gy nc nd l ne nf">intensity = np.zeros(len(rad))<br/>index = 0</span></pre><h1 id="0182" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated"><strong class="ak">计算径向平均值</strong></h1><p id="c5cd" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在，我们可以使用一个循环来计算每个径向距离的平均值。这里，我们设置的另一个重要参数是bin大小。这设置了除了我们正在寻找的精确径向距离之外，我们还包括多少像素。在本例中，我们将一个小于或大于我们感兴趣半径1个像素的面元:</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="994c" class="nb mb it lz b gy nc nd l ne nf">bin_size = 1</span></pre><p id="d103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的循环将按以下步骤进行:</p><ol class=""><li id="8cdb" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们使用我们的<code class="fe lw lx ly lz b">bin_size</code>来屏蔽我们的图像——剩下的唯一值将是那些未被屏蔽的值(在我们感兴趣的半径范围内)</li><li id="4445" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">计算屏蔽值的平均值——这给出了给定径向距离处的平均强度</li><li id="612e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">将我们的<code class="fe lw lx ly lz b">intensity</code>数组的索引赋值给在步骤2中计算的平均值</li><li id="ef3e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">重复步骤1–3，直到我们遍历完整个<code class="fe lw lx ly lz b">rad</code>数组</li></ol><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="3bbf" class="nb mb it lz b gy nc nd l ne nf">for i in rad:<br/>  mask = (np.greater(R, i - bin_size) &amp; np.less(R, i + bin_size)<br/>  values = img[mask]<br/>  intensity[index] = np.mean(values)<br/>  index += 1</span></pre><p id="6db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然看起来很简单，但我们现在完成了！</p><p id="f5b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下要做的最后一件事是查看我们新的循环平均图像。我们可以这样做(我改变了一些情节参数，更详细的解释可以参考<a class="ae ky" href="https://towardsdatascience.com/an-introduction-to-making-scientific-publication-plots-with-python-ea19dfa7f51e" rel="noopener" target="_blank">我之前的文章</a>):</p><pre class="kj kk kl km gt mx lz my mz aw na bi"><span id="6472" class="nb mb it lz b gy nc nd l ne nf"># Adjust plot parameters<br/>mpl.rcParams['font.family'] = 'Avenir'<br/>mpl.rcParams['font.size'] = 16<br/>mpl.rcParams['axes.linewidth'] = 2<br/>mpl.rcParams['axes.spines.top'] = False<br/>mpl.rcParams['axes.spines.right'] = False<br/>mpl.rcParams['xtick.major.size'] = 7<br/>mpl.rcParams['xtick.major.width'] = 2<br/>mpl.rcParams['ytick.major.size'] = 7<br/>mpl.rcParams['ytick.major.width'] = 2</span><span id="7d95" class="nb mb it lz b gy nu nd l ne nf"># Create figure and add subplot<br/>fig = plt.figure()<br/>ax = fig.add_subplot(111)</span><span id="5a62" class="nb mb it lz b gy nu nd l ne nf"># Plot data<br/>ax.plot(rad, intensity, linewidth=2)</span><span id="f9e1" class="nb mb it lz b gy nu nd l ne nf"># Edit axis labels<br/>ax.set_xlabel('Radial Distance', labelpad=10)<br/>ax.set_ylabel('Average Intensity', labelpad=10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/60a9e58eb541a8dc3e10f88f54e80dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*GDiSGiqq82xhSW-nZ7AA3A.png"/></div></figure><h1 id="859c" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated"><strong class="ak">最后备注</strong></h1><p id="defb" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我被用几行代码进行循环平均是多么优雅和简单所吸引，所以我想整理出一篇循序渐进的文章来展示——希望你喜欢！这个脚本是我为分析X射线衍射数据开发的一个更大的工具集的一部分，可以在这个<a class="ae ky" href="https://github.com/venkatesannaveen/xray-scattering-tools" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到。</p><p id="7ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！我感谢任何反馈，你可以在<a class="ae ky" href="https://twitter.com/naveenv_92" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上找到我，并在<a class="ae ky" href="https://www.linkedin.com/in/naveenvenkatesan/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，了解更多更新和文章。</p></div></div>    
</body>
</html>