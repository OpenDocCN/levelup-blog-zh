<html>
<head>
<title>Exploring the JavaScript Window Object: documentURI, embeds, and fonts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索JavaScript窗口对象:documentURI、嵌入和字体</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introducing-the-javascript-window-object-document-embeds-and-fonts-5cae7083aec0?source=collection_archive---------13-----------------------#2020-01-14">https://levelup.gitconnected.com/introducing-the-javascript-window-object-document-embeds-and-fonts-5cae7083aec0?source=collection_archive---------13-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fb0af901025c78da88e0960d58a6daf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WVZH903y7QJJdJhU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@goodspleen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandre Chambon </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="5899" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">window</code>对象是一个全局对象，具有与当前DOM文档相关的属性，即浏览器选项卡中的内容。</p><p id="4c3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解一些<code class="fe le lf lg lh b">window.document</code>对象以及如何使用它们，包括<code class="fe le lf lg lh b">documentURI</code>、<code class="fe le lf lg lh b">embeds</code>和<code class="fe le lf lg lh b">fonts</code>属性。</p><h1 id="2bce" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">window.document.documentURI</h1><p id="3de8" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">documentURI</code>是一个返回文档位置的字符串属性。它最初是一个读/写属性，但现在是只读的。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7368" class="mt lj it lh b gy mu mv l mw mx">console.log(document.documentURI);</span></pre><p id="3f94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会得到这样的结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f523" class="mt lj it lh b gy mu mv l mw mx">"<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/documentURI" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/Document/documentURI</a>"</span></pre><p id="f398" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe le lf lg lh b">console.log</code>输出。</p><h1 id="8fe5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">window.document.embeds</h1><p id="0c49" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">embeds</code>属性是一个只读属性，它返回文档中嵌入的<code class="fe le lf lg lh b">object</code>元素的列表。例如，如果我们有下面的<code class="fe le lf lg lh b">embed</code>元素来添加一个视频到我们的网页:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4774" class="mt lj it lh b gy mu mv l mw mx">&lt;embed type="video/webm" src="<a class="ae kf" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4</a>" width="250" height="200"&gt;</span></pre><p id="7a13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在脚本文件中，我们可以使用编写以下代码来获得我们的embed元素:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7128" class="mt lj it lh b gy mu mv l mw mx">console.log(document.embeds);</span></pre><p id="67aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到一个类似HTMLCollection数组的对象，它包含我们视频的<code class="fe le lf lg lh b">embed</code>元素。HTMLCollection对象有一个<code class="fe le lf lg lh b">item</code>方法，让我们通过索引获取HTMLCollection对象中的DOM元素。此外，由于它是一个类似数组的对象，我们可以像下面的代码一样将它与<code class="fe le lf lg lh b">for...of</code>循环一起使用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a4ea" class="mt lj it lh b gy mu mv l mw mx">for (const el of document.embeds) {<br/>  console.log(el);<br/>}</span></pre><p id="5591" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们将得到网页中的<code class="fe le lf lg lh b">embed</code>元素。我们还可以获得<code class="fe le lf lg lh b">embed</code>元素的属性，如以下代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="bc07" class="mt lj it lh b gy mu mv l mw mx">for (const el of document.embeds) {<br/>  const {<br/>    height,<br/>    src,<br/>    type,<br/>    width<br/>  } = el;<br/>  console.log(height, src, type, width);<br/>}</span></pre><p id="1051" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到这样的结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="84e4" class="mt lj it lh b gy mu mv l mw mx">200 <a class="ae kf" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4</a> video/webm 250</span></pre><p id="7d85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有上面的<code class="fe le lf lg lh b">embed</code>元素。这些值与我们传入的属性值相同。我们可以用HTMLCollection对象可用的<code class="fe le lf lg lh b">item</code>方法通过索引获取元素来替换<code class="fe le lf lg lh b">for...of</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f7c6" class="mt lj it lh b gy mu mv l mw mx">console.log(document.embeds);<br/>for (let i = 0; i &lt; document.embeds.length; i++) {<br/>  const {<br/>    height,<br/>    src,<br/>    type,<br/>    width<br/>  } = document.embeds.item(i);<br/>  console.log(height, src, type, width);<br/>}</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/e9510a817f758a4693000f1714060d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yqebv052OtEFaO5h"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@fabiosbruun?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比奥·桑塔尼耶洛·布鲁恩</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="967a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">窗口.文档.字体</h1><p id="c952" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">属性返回一个有各种属性和事件的对象，让我们处理字体的加载。例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cc3e" class="mt lj it lh b gy mu mv l mw mx">console.log(document.fonts);</span></pre><p id="2b47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了<code class="fe le lf lg lh b">FontFaceSet</code>对象。<code class="fe le lf lg lh b">FontFaceSet</code>对象具有以下属性。它有<code class="fe le lf lg lh b">status</code>只读属性，这是一个字符串，表示文档字体的加载状态。该值可以是<code class="fe le lf lg lh b">'loading'</code>或<code class="fe le lf lg lh b">'loaded'</code>。</p><p id="6f04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">FontFaceSet</code>的另一个属性是<code class="fe le lf lg lh b">ready</code>只读属性，这是一个承诺，一旦字体被加载并且布局操作完成，这个承诺就解决了。例如，一旦所有字体都已加载，我们可以编写以下内容来记录“加载的字体”:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c682" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  await document.fonts.ready;<br/>  console.log('fonts loaded');<br/>})()</span></pre><p id="5110" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">document.fonts</code>属性也有3个事件——<code class="fe le lf lg lh b">onloading</code>事件、<code class="fe le lf lg lh b">onloadingdone</code>事件和<code class="fe le lf lg lh b">onloadingerror</code>事件。当loading事件被触发时，调用<code class="fe le lf lg lh b">onloading</code>事件处理程序，表示字体已经开始加载。</p><p id="4463" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当触发类型为<code class="fe le lf lg lh b">loadingdone</code>的事件时，就会调用<code class="fe le lf lg lh b">onloadingdone</code>事件处理程序，这意味着字体集已经成功加载。每当触发<code class="fe le lf lg lh b">loadingerror</code>类型时，就会调用<code class="fe le lf lg lh b">onloadingerror</code>事件处理程序，这表明加载字体集时发生了错误。</p><p id="9f6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用如下代码中的事件处理程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2034" class="mt lj it lh b gy mu mv l mw mx">document.fonts.onloading = () =&gt; {<br/>  console.log('Font is loading');<br/>}</span><span id="80a0" class="mt lj it lh b gy mz mv l mw mx">document.fonts.onloadingdone = () =&gt; {<br/>  console.log('Font successfully loaded');<br/>}</span><span id="97c6" class="mt lj it lh b gy mz mv l mw mx">document.fonts.onloadingerror = () =&gt; {<br/>  console.log('Error loading font');<br/>}</span><span id="77c0" class="mt lj it lh b gy mz mv l mw mx">(async () =&gt; {<br/>  await document.fonts.load("12px Roboto", "A");<br/>})();</span></pre><p id="5e63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在HTML文件中，我们添加:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b990" class="mt lj it lh b gy mu mv l mw mx">&lt;link href='<a class="ae kf" href="https://fonts.googleapis.com/css?family=Roboto:400,700'" rel="noopener ugc nofollow" target="_blank">https://fonts.googleapis.com/css?family=Roboto:400,700'</a> rel='stylesheet' type='text/css'&gt;</span></pre><p id="baf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们运行代码时，我们应该记录“字体正在加载”和“字体成功加载”,因为我们从Google字体CDN加载了字体，首先用<code class="fe le lf lg lh b">link</code>标签将字体包含在我们的网页中，然后我们将事件侦听器附加到字体加载事件。</p><p id="acfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们运行了加载Roboto字体的<code class="fe le lf lg lh b">document.fonts.load</code>方法，这将触发<code class="fe le lf lg lh b">onloading</code>事件和<code class="fe le lf lg lh b">onloadingdone</code>事件处理程序，因为我们已经从Google CDN加载了字体，应该可以加载了。</p><p id="ea30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们上面使用的<code class="fe le lf lg lh b">load</code>方法返回一个承诺，并接受2个字符串参数。第一个是字符串，它使用CSS value语法表示字体大小和名称，如上所述。</p><p id="8fd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是文本，它将字体加载限制为上面字符串中的字符。该范围应该是文本中的一个字符。第二个参数是可选的。</p><p id="a73b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了<code class="fe le lf lg lh b">load</code>方法之外，<code class="fe le lf lg lh b">document.fonts</code>对象中还有一些方法。它包括向字体集添加字体的<code class="fe le lf lg lh b">add</code>方法。</p><p id="5f56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要一个参数，即<code class="fe le lf lg lh b">FontFace</code>对象。我们通过使用带2个参数的<code class="fe le lf lg lh b">FontFace</code>构造函数创建了<code class="fe le lf lg lh b">FontFace</code>对象。</p><p id="dd82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个参数是字体名称的字符串，第二个参数是字体的URL，应该像CSS代码中的URL一样表示。</p><p id="4bea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，要用<code class="fe le lf lg lh b">add</code>方法给我们的文档添加一种字体，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b57f" class="mt lj it lh b gy mu mv l mw mx">const fontFace = new FontFace('Bitter', 'url(<a class="ae kf" href="https://fonts.gstatic.com/s/bitter/v7/HEpP8tJXlWaYHimsnXgfCOvvDin1pK8aKteLpeZ5c0A.woff2)'" rel="noopener ugc nofollow" target="_blank">https://fonts.gstatic.com/s/bitter/v7/HEpP8tJXlWaYHimsnXgfCOvvDin1pK8aKteLpeZ5c0A.woff2)'</a>);<br/>document.fonts.add(fontFace);</span></pre><p id="1615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为<code class="fe le lf lg lh b">loaded</code>属性的<code class="fe le lf lg lh b">FontFace</code>对象，它返回一个承诺，当在<code class="fe le lf lg lh b">FontFace</code>构造函数中指定的字体被加载时，该承诺被解析。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9c4c" class="mt lj it lh b gy mu mv l mw mx">const fontFace = new FontFace('Bitter', 'url(<a class="ae kf" href="https://fonts.gstatic.com/s/bitter/v7/HEpP8tJXlWaYHimsnXgfCOvvDin1pK8aKteLpeZ5c0A.woff2)'" rel="noopener ugc nofollow" target="_blank">https://fonts.gstatic.com/s/bitter/v7/HEpP8tJXlWaYHimsnXgfCOvvDin1pK8aKteLpeZ5c0A.woff2)'</a>);<br/>document.fonts.add(fontFace);<br/>(async () =&gt; {<br/>  await document.fonts.load("12px Bitter", "A");<br/>  const loadedFontFace = await fontFace.loaded;<br/>  console.log(loadedFontFace);<br/>})()</span></pre><p id="1198" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用<code class="fe le lf lg lh b">add</code>方法添加了Bitter字体，并使用<code class="fe le lf lg lh b">load</code>方法加载新添加的字体。最后，我们记录了字体，我们得到了<code class="fe le lf lg lh b">FontFace</code>对象的属性，它应该有如下输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a7c4" class="mt lj it lh b gy mu mv l mw mx">display: "auto"<br/>family: "Bitter"<br/>featureSettings: "normal"<br/>loaded: Promise {&lt;resolved&gt;: FontFace}<br/>status: "loaded"<br/>stretch: "normal"<br/>style: "normal"<br/>unicodeRange: "U+0-10FFFF"<br/>variant: "normal"<br/>weight: "normal"</span></pre><p id="b177" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要检查一个字体是否已经被加载并且可用，我们可以使用<code class="fe le lf lg lh b">check</code>方法，该方法返回一个布尔值，并接受2个参数。</p><p id="6107" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个是带有字体名称的字符串，其属性采用CSS value语法。</p><p id="b3ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是文本，它将字体加载限制为上面字符串中的字符。</p><p id="0304" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该范围应该是文本中的一个字符。第二个参数是可选的。例如，我们可以在下面的代码中使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="48a8" class="mt lj it lh b gy mu mv l mw mx">console.log(document.fonts.check("12px Roboto", "a"));<br/>console.log(document.fonts.check("12px Arial", "a"));</span></pre><p id="993d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个<code class="fe le lf lg lh b">console.log</code>应该输出<code class="fe le lf lg lh b">false</code>，因为我们没有通过编写任何代码来加载Roboto字体。第二个<code class="fe le lf lg lh b">console.log</code>应该是<code class="fe le lf lg lh b">true</code>，因为它是一个无需添加任何代码就可以从外部加载的字体。</p><p id="3903" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">clear</code>方法从字体集中删除所有字体。这不需要争论。例如，我们可以在下面的代码中使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c98d" class="mt lj it lh b gy mu mv l mw mx">const fontFace = new FontFace('Bitter', 'url(<a class="ae kf" href="https://fonts.gstatic.com/s/bitter/v7/HEpP8tJXlWaYHimsnXgfCOvvDin1pK8aKteLpeZ5c0A.woff2)'" rel="noopener ugc nofollow" target="_blank">https://fonts.gstatic.com/s/bitter/v7/HEpP8tJXlWaYHimsnXgfCOvvDin1pK8aKteLpeZ5c0A.woff2)'</a>);<br/>document.fonts.add(fontFace);<br/>(async () =&gt; {<br/>  await document.fonts.load("12px Bitter", "A");<br/>  console.log(document.fonts.check("12px Bitter", "A"));<br/>  const loadedFontFace = await fontFace.loaded;<br/>  document.fonts.clear();<br/>  console.log(document.fonts.check("12px Bitter", "A"));<br/>})()</span></pre><p id="61c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们首先用<code class="fe le lf lg lh b">load</code>方法加载字体，然后用<code class="fe le lf lg lh b">clear</code>方法卸载它，所以第一个<code class="fe le lf lg lh b">console.log</code>应该记录<code class="fe le lf lg lh b">true</code>，因为用<code class="fe le lf lg lh b">load</code>方法加载了字体，第二个应该记录<code class="fe le lf lg lh b">false</code>，因为我们调用了<code class="fe le lf lg lh b">clear</code>方法卸载它。</p><p id="6b53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，还有从字体集中删除字体的<code class="fe le lf lg lh b">delete</code>方法。它将一个<code class="fe le lf lg lh b">FontFace</code>对象作为唯一的参数。例如，我们可以在下面的代码中使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="58cb" class="mt lj it lh b gy mu mv l mw mx">const fontFace = new FontFace('Bitter', 'url(<a class="ae kf" href="https://fonts.gstatic.com/s/bitter/v7/HEpP8tJXlWaYHimsnXgfCOvvDin1pK8aKteLpeZ5c0A.woff2)'" rel="noopener ugc nofollow" target="_blank">https://fonts.gstatic.com/s/bitter/v7/HEpP8tJXlWaYHimsnXgfCOvvDin1pK8aKteLpeZ5c0A.woff2)'</a>);<br/>document.fonts.add(fontFace);<br/>(async () =&gt; {<br/>  await document.fonts.load("12px Bitter", "A");<br/>  console.log(document.fonts.check("12px Bitter", "A"));<br/>  const loadedFontFace = await fontFace.loaded;<br/>  document.fonts.delete(loadedFontFace);<br/>  console.log(document.fonts.check("12px Bitter", "A"));<br/>})()</span></pre><p id="c544" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们首先用<code class="fe le lf lg lh b">load</code>方法加载字体，然后用<code class="fe le lf lg lh b">delete</code>方法卸载它，并传入了<code class="fe le lf lg lh b">loadedFontFace</code>，因此第一个<code class="fe le lf lg lh b">console.log</code>应该记录<code class="fe le lf lg lh b">true</code>，因为用<code class="fe le lf lg lh b">load</code>方法加载了字体，第二个应该记录<code class="fe le lf lg lh b">false</code>，因为我们调用了<code class="fe le lf lg lh b">delete</code>方法，并传入了<code class="fe le lf lg lh b">loadedFontFace</code>来卸载它。</p><p id="a807" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从本系列的第5部分继续，查看了<code class="fe le lf lg lh b">window.document</code>对象的更多属性，包括<code class="fe le lf lg lh b">documentURI</code>、<code class="fe le lf lg lh b">embeds</code>和<code class="fe le lf lg lh b">fonts</code>属性。属性为我们获取当前加载的文档的URL。</p><p id="477a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性获取文档中所有的DOM元素，并让我们看到属性。属性有很多属性可以让我们得到我们加载的字体的状态，它也有一些方法可以让我们根据需要加载和卸载字体。</p><p id="49c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还可以让我们检查您想要加载的字体的状态。对于加载通常不内置于操作系统中的自定义字体，它非常方便，浏览器无需加载即可使用。</p></div></div>    
</body>
</html>