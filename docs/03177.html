<html>
<head>
<title>Basic JavaScript Design Patterns- Object Creation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本JavaScript设计模式——对象创建</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basic-javascript-design-patterns-object-creation-677f21df771d?source=collection_archive---------14-----------------------#2020-04-23">https://levelup.gitconnected.com/basic-javascript-design-patterns-object-creation-677f21df771d?source=collection_archive---------14-----------------------#2020-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7c0798663da7e04b8ea4fdfff4d060b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cZs8jieesMO13FFH"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@fellowferdi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费迪南·斯托尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="bdd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="8a3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了组织我们的代码，我们应该使用一些基本的设计模式。在本文中，我们将研究一些可能用到的基本对象创建模式。</p><h1 id="387f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一个</h1><p id="5b59" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">单例模式是我们创建一个类的单个实例的地方。</p><p id="941c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们可以在JavaScript中创建不带构造函数的对象文字，因此我们可以轻松地创建对象，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e3d4" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  foo: 'bar'<br/>};</span></pre><p id="3c89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">obj</code>也将是一个独立的对象，所以定义一个对象字面量遵循singleton模式。</p><p id="6e69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们创建一个具有相同结构的新对象，我们将得到一个不同的对象。</p><p id="f886" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们创建一个新对象:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b3c7" class="mq lf it mm b gy mr ms l mt mu">const obj2 = {<br/>  foo: 'bar'<br/>};</span></pre><p id="d174" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们写下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="22a7" class="mq lf it mm b gy mr ms l mt mu">obj2 === obj</span></pre><p id="a258" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比较两个对象，然后返回<code class="fe mv mw mx mm b">false</code>,因为它们是不同的引用。</p><h1 id="6dbc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用新的</h1><p id="821c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以创建单例对象，即使我们从构造函数或类中创建它们。</p><p id="667d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6501" class="mq lf it mm b gy mr ms l mt mu">let instance;<br/>class Foo {<br/>  constructor() {<br/>    if (!instance) {<br/>      instance = {<br/>        foo: 'bar'<br/>      };<br/>    }<br/>    return instance;<br/>  }<br/>}</span></pre><p id="409e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们创建2个<code class="fe mv mw mx mm b">Foo</code>实例:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f990" class="mq lf it mm b gy mr ms l mt mu">const foo1 = new Foo();<br/>const foo2 = new Foo();</span></pre><p id="7f05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们比较它们时:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6c63" class="mq lf it mm b gy mr ms l mt mu">console.log(foo1 === foo2);</span></pre><p id="4d7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到<code class="fe mv mw mx mm b">true</code>被记录。</p><p id="94b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们检查<code class="fe mv mw mx mm b">instance</code>是否被创建，如果被创建，就返回它。否则，我们将其设置为一个对象。</p><p id="4760" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe mv mw mx mm b">instance</code>设置后不会改变，所以所有实例都是一样的。</p><p id="f58d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过将变量<code class="fe mv mw mx mm b">instance</code>放入一个生命中来使其私有。</p><p id="ac58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ca8d" class="mq lf it mm b gy mr ms l mt mu">const Foo = (() =&gt; {<br/>  let instance;<br/>  return class {<br/>    constructor() {<br/>      if (!instance) {<br/>        instance = {<br/>          foo: 'bar'<br/>        };<br/>      }<br/>      return instance;<br/>    }<br/>  }<br/>})()</span></pre><p id="fe6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们只能访问返回的实例，而不是查看构造函数。</p><h1 id="3b93" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">静态属性中的实例</h1><p id="5bf0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">或者，我们可以将singleton的实例放在构造函数或类的静态属性中。</p><p id="3abb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d5d1" class="mq lf it mm b gy mr ms l mt mu">class Foo {<br/>  constructor() {<br/>    if (!Foo.instance) {<br/>      Foo.instance = {<br/>        foo: 'bar'<br/>      };<br/>    }<br/>    return Foo.instance;<br/>  }<br/>}</span></pre><p id="509a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们设置类<code class="fe mv mw mx mm b">Foo</code>的公共<code class="fe mv mw mx mm b">instance</code>属性来返回实例，如果它存在的话。否则，它会先创建它。</p><p id="affe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在如果我们写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e804" class="mq lf it mm b gy mr ms l mt mu">const foo1 = new Foo();<br/>const foo2 = new Foo();</span><span id="6938" class="mq lf it mm b gy my ms l mt mu">console.log(foo1 === foo2);</span></pre><p id="9c5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到和以前一样的结果。</p><h1 id="70a1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">闭包中的实例</h1><p id="7798" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以把单例实例放在闭包里。</p><p id="5565" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="153d" class="mq lf it mm b gy mr ms l mt mu">function Foo() {<br/>  const instance = this;<br/>  this.foo = 'bar';<br/>  Foo = function() {<br/>    return instance;<br/>  }<br/>}</span></pre><p id="c540" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写一个构造函数，在函数结束时被重新分配给自己。</p><p id="854a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将让我们在使用<code class="fe mv mw mx mm b">this</code>分配即时变量时返回<code class="fe mv mw mx mm b">instance</code>。</p><p id="0371" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不适用于类语法，因为它是作为常量创建的，所以我们不能给它重新赋值。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/d864433abe5187277b9033bea917b00b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NPGsgzEkIiejTgcw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@joshoy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">彭军欧阳</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="6260" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">工厂</h1><p id="59e7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以创建一个工厂函数来创建对象。</p><p id="fa8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">工厂函数只是一个常规函数，我们可以用它来创建对象。</p><p id="d139" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当设置相似的对象时，这对于执行重复的操作很有用。</p><p id="97c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还为工厂用户提供了一种在编译时无需特定类即可创建对象的方法。</p><p id="a171" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建自己的工厂函数，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cac5" class="mq lf it mm b gy mr ms l mt mu">class Animal {}<br/>class Dog extends Animal {}<br/>class Cat extends Animal {}<br/>class Bird extends Animal {}</span><span id="2111" class="mq lf it mm b gy my ms l mt mu">const AnimalMaker = type =&gt; {<br/>  if (type === 'dog') {<br/>    return new Dog()<br/>  } else if (type === 'cat') {<br/>    return new Dog()<br/>  } else if (type === 'bird') {<br/>    return new Dog()<br/>  }<br/>}</span></pre><p id="ef4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有<code class="fe mv mw mx mm b">AnimalMaker</code>工厂函数。</p><p id="80ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用了<code class="fe mv mw mx mm b">type</code>参数，允许我们在给定<code class="fe mv mw mx mm b">type</code>的情况下创建不同的子类。</p><p id="6c5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以这样称呼它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ee09" class="mq lf it mm b gy mr ms l mt mu">const animal = AnimalMaker('dog');</span></pre><p id="d4f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个<code class="fe mv mw mx mm b">Dog</code>实例。</p><p id="6587" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以随意在类中添加方法:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1916" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  walk() {}<br/>}<br/>class Dog extends Animal {<br/>  bark() {}<br/>}<br/>class Cat extends Animal {}<br/>class Bird extends Animal {}</span><span id="0bb5" class="mq lf it mm b gy my ms l mt mu">const AnimalMaker = type =&gt; {<br/>  if (type === 'dog') {<br/>    return new Dog()<br/>  } else if (type === 'cat') {<br/>    return new Dog()<br/>  } else if (type === 'bird') {<br/>    return new Dog()<br/>  }<br/>}</span></pre><p id="23ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个也行。</p><h1 id="c9e4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f5b6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用一个实例y创建对象，使用对象字面量或者检查类的实例是否存在，如果不存在就创建它。</p><p id="c05f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">工厂函数对于创建相似的对象很有用。</p></div></div>    
</body>
</html>