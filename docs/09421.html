<html>
<head>
<title>Best practices for Accelerating Kubernetes Deployments.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速Kubernetes部署的最佳实践。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/best-practices-for-accelerating-kubernetes-deployments-ece46ccd174c?source=collection_archive---------6-----------------------#2021-08-09">https://levelup.gitconnected.com/best-practices-for-accelerating-kubernetes-deployments-ece46ccd174c?source=collection_archive---------6-----------------------#2021-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8f2ad2af490163f2b1315764fc9e0097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSPb6it5VY9Zc3uz259TEA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Jonathan Chng 在<a class="ae kc" href="https://unsplash.com/s/photos/run?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8447" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">在本教程中，我们将了解用于加速Kubernetes部署的扩展单元、副本控制器和最佳实践。</strong></p><p id="41c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kubernetes部署是对吊舱理想状态的描述。您可以使用部署来推出新的应用程序或微服务，或者更新现有的应用程序或微服务。部署可以扩展副本单元的数量，以可控的方式部署更新的代码，或者在必要时回滚到早期的部署版本。</p><p id="953b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的应用程序是无状态的，您可以水平扩展它。无状态应用程序意味着你的应用程序没有状态，它不写任何本地文件/保存本地会话数据。</p><p id="2737" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有两个pod，其中一个要在本地写东西，那么这两个pod将会不同步。这意味着每个豆荚都有自己的状态，这就是为什么你不能杀死它。如果两个pod总是拥有相同的文件，它们就不会真正拥有自己的状态，并且对一个pod的请求将总是导致与从另一个pod发出请求相同的结果，那么这个pod很可能是无状态的。</p><ul class=""><li id="dba4" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">无状态:</strong>你的应用程序没有<strong class="kf ir">状态。它</strong>不<strong class="kf ir">写</strong>任何本地文件/保持本地会话。</li><li id="706a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">所有传统数据库(MYSQL、PostgreSQL)都是<strong class="kf ir">有状态的。</strong>他们的数据库文件不能在多个实例上拆分。</li></ul><p id="0ed6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数<strong class="kf ir"> web应用</strong>可以变成无状态的:</p><ul class=""><li id="0b3a" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">会话管理需要在容器之外完成。所以，如果你想在你的web应用上获得点击量，你想保存你的访问者的信息，那么你需要使用外部服务，你不能在你的容器中存储这种数据。您可以使用Memcache、Redis甚至数据库来存储您的会话。</li><li id="2543" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">任何需要保存的文件都不能保存在本地容器上，因为如果停止容器并重新启动，文件将会丢失。因此，您需要将任何想要存储在容器外部的文件保存在某个共享存储或外部服务(AWS)上。在AWS上，您可以将其保存在S3对象存储中。</li><li id="322f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">那些有状态的应用程序不能横向扩展，但是你可以在一个容器中运行它们，并且纵向扩展(分配更多的CPU/内存/磁盘)</li></ul><h2 id="49fc" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">Kubernetes中的缩放可以使用复制控制器来完成。</h2><p id="0fb4" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">复制控制器将确保指定数量的<strong class="kf ir"> pod副本</strong>将一直运行。例如，您可以指定五(5)个pod复制副本，它将运行同一个pod，但运行5次。</p><ul class=""><li id="182b" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">用复制控制器创建的pod如果失败、被删除或被终止，将自动被替换。</li></ul><p id="bdc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果您告诉Kubernetes运行五(5)个pod，但只有四个pod在运行，因为一个节点崩溃，那么Kubernetes将在另一个节点上启动该pod的另一个实例。</p><ul class=""><li id="f006" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">如果您只想确保<strong class="kf ir"> 1 pod </strong>始终运行，甚至在重启后，也建议<strong class="kf ir">使用复制控制器</strong>。然后，您可以只使用<strong class="kf ir"> 1个副本运行复制控制器。这确保了即使当节点崩溃时，pod也总是在运行。</strong></li></ul><h2 id="6de7" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">在下面的例子中，我们将应用程序复制了两次:</h2><p id="17c4" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">复制控制器也有一个规范。在这里，我们有2个副本，这是应用程序hello world的复制控制器，这就是为什么我们有选择器<code class="fe mn mo mp mq b">app:helloworld</code>，它将选择带有<code class="fe mn mo mp mq b">app:helloworld.</code>的标签</p><p id="579e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就有了一个pod定义的模板。pod定义也有<code class="fe mn mo mp mq b">metadata</code>我们也有标签，与您在选择器下看到的标签相同。</p><p id="95ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们有<code class="fe mn mo mp mq b">pod specification.</code>,这里我们还有一个容器，名为<code class="fe mn mo mp mq b">docker-demo</code>,图像和我们公开的端口<code class="fe mn mo mp mq b">5000</code></p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="867c" class="lp lq iq mq b gy mz na l nb nc">apiVersion: v1</span><span id="2e2f" class="lp lq iq mq b gy nd na l nb nc">kind: ReplicationController</span><span id="fb4c" class="lp lq iq mq b gy nd na l nb nc">metadata:</span><span id="0708" class="lp lq iq mq b gy nd na l nb nc">name: hello-world-controller</span><span id="fb50" class="lp lq iq mq b gy nd na l nb nc">spec:</span><span id="4655" class="lp lq iq mq b gy nd na l nb nc">  replicas: 2</span><span id="5a0c" class="lp lq iq mq b gy nd na l nb nc">  selector:</span><span id="b6b1" class="lp lq iq mq b gy nd na l nb nc">  app: hello-world</span><span id="2097" class="lp lq iq mq b gy nd na l nb nc">    template:</span><span id="c3ba" class="lp lq iq mq b gy nd na l nb nc">     metadata:</span><span id="8569" class="lp lq iq mq b gy nd na l nb nc">      labels:</span><span id="4bb3" class="lp lq iq mq b gy nd na l nb nc">        app: hello-world</span><span id="d6ed" class="lp lq iq mq b gy nd na l nb nc">    spec:</span><span id="3dd5" class="lp lq iq mq b gy nd na l nb nc">     containers:</span><span id="b051" class="lp lq iq mq b gy nd na l nb nc">     - name: docker-demo</span><span id="8fa2" class="lp lq iq mq b gy nd na l nb nc">    image: tolatemitope/docker-demo</span><span id="d5cb" class="lp lq iq mq b gy nd na l nb nc">    ports:</span><span id="84fd" class="lp lq iq mq b gy nd na l nb nc">    - containerPort: 5000</span></pre><p id="d8f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，复制控制器要做的是，它将运行模板中定义的pod两次。</p><ul class=""><li id="6137" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">完成文件配置后，您可以使用<code class="fe mn mo mp mq b">kubectl create -f replicationcontroller.yaml</code>创建它</li><li id="5b3d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">您可以使用<code class="fe mn mo mp mq b">kubectl get replicationcontroller</code>确认检查您的复制控制器是否正在运行</li><li id="73bf" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">通过这个，你可以看到我们是如何水平缩放pod的。我们有多个pod在运行，您也可以在它前面放置一个服务，如负载平衡器，使您的多个pod可以被其他软件或客户访问。如果您配置的一个pod崩溃，控制器将自动重新安排这些pod。</li><li id="012f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">如果您移除一个<code class="fe mn mo mp mq b">pods,</code>，您会看到复制控制器将创建一个新的pod。</li><li id="ae14" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">您会看到pod已被终止，但一个新的pod正在创建。</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/e42b432d7f276628433dd4c953959ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLWb_m1NWqXge0OXKzt49A.png"/></div></div></figure><ul class=""><li id="5100" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">您可以在下面看到，pod被终止，但是一个新的pod被创建。从下图来看，自从我们删除了最后一个pod之后，又创建了一个新的pod<strong class="kf ir">43s</strong>。</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/fd35b259835dde91365342c5b63d3709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UjQVWomtfMSQzZKEtqtqNA.png"/></div></div></figure><ul class=""><li id="6fa7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">你总是可以缩放那些豆荚，你可以说<code class="fe mn mo mp mq b">kubectl scale --replicas=4 -f (filename.yaml)</code>，你最终会看到你的控制器被缩放。</li><li id="f452" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">回到你的终端，检查你会看到它已经被创建<code class="fe mn mo mp mq b">four pods</code>由于缩放操作。</li><li id="05c1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">另一种扩展方式是使用<code class="fe mn mo mp mq b">kubectl get rc</code>获取复制控制器的名称，然后使用<code class="fe mn mo mp mq b">kubectl scale --replicas=1 rc/helloworld-controller</code>进行扩展，然后它会再次进行扩展。</li><li id="bb7e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">再次检查你的吊舱，你会看到一些已经被终止，只有其中一个正在运行。</li><li id="96e0" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">正如我们前面讨论的，您可以看到，只有当您的pod处于无状态时，您才能进行扩展。如果您有有状态的pod，那么您将无法做到这一点。</li><li id="f9f1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">您可以使用<code class="fe mn mo mp mq b">kubectl delete rc/helloworld-controller</code>删除您的<code class="fe mn mo mp mq b">replication controller</code>，最后一个pod将被终止。</li><li id="8314" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">这些缩放操作都作为后端保存在Kubernetes中<code class="fe mn mo mp mq b">etcd</code>，它保存所有这些设置，比如副本的数量。您并不总是需要在<code class="fe mn mo mp mq b">yaml</code>文件中包含这些内容。</li></ul><h1 id="66fe" class="ng lq iq bd lr nh ni nj lu nk nl nm lx nn no np ma nq nr ns md nt nu nv mg nw bi translated">Kubernetes部署和复制集</h1><ul class=""><li id="bb8d" class="lb lc iq kf b kg mi kk mj ko nx ks ny kw nz la lg lh li lj bi translated"><strong class="kf ir">副本集</strong>是下一代复制控制器。它支持一个新的选择器，可以根据一组<strong class="kf ir">值基于过滤进行选择。</strong>例如，对于您的复制集，环境可以是“开发”或“qa ”,您可以进行更复杂的匹配。</li><li id="ff6b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">部署对象使用的是副本集，而不是复制控制器。</li></ul><p id="5dbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来谈谈Kubernetes中的<strong class="kf ir">部署</strong></p><ul class=""><li id="5414" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">部署是Kubernetes中的声明，允许您进行应用程序部署和更新。当使用部署对象时，您定义应用程序的<strong class="kf ir">状态</strong>。Kubernetes将确保集群与您期望的状态相匹配。</li><li id="ba52" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">仅使用<strong class="kf ir">复制控制器</strong>或<strong class="kf ir">复制集</strong>部署应用可能会<strong class="kf ir">繁琐</strong>。对于您来说，更新和回滚可能需要太多的手动工作。</li><li id="52a4" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">部署对象</strong>更容易使用，并为您提供更多可能性。</li></ul><p id="0b5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么这些可能性是什么:</p><ul class=""><li id="9f6c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><strong class="kf ir">创建</strong>部署(例如，部署应用程序)</li><li id="5865" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">更新</strong>部署(例如部署新版本)</li><li id="e071" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">进行<strong class="kf ir">滚动更新</strong>(零停机部署)</li><li id="c330" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">回滚到以前的版本。</li><li id="724d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><strong class="kf ir">暂停/恢复</strong>部署(例如，仅部署到某个百分比)</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="f43d" class="lp lq iq mq b gy mz na l nb nc">apiVersion: extensions/v1beta1</span><span id="51f1" class="lp lq iq mq b gy nd na l nb nc">kind: Deployment</span><span id="984b" class="lp lq iq mq b gy nd na l nb nc">metadata:</span><span id="4311" class="lp lq iq mq b gy nd na l nb nc">name: helloworld-deployment</span><span id="aa38" class="lp lq iq mq b gy nd na l nb nc">spec:</span><span id="45b7" class="lp lq iq mq b gy nd na l nb nc">  replicas: 3</span><span id="26da" class="lp lq iq mq b gy nd na l nb nc">  template:</span><span id="b86d" class="lp lq iq mq b gy nd na l nb nc">    metadata:</span><span id="de75" class="lp lq iq mq b gy nd na l nb nc">      labels:</span><span id="b8a5" class="lp lq iq mq b gy nd na l nb nc">        app: helloworld</span><span id="49c4" class="lp lq iq mq b gy nd na l nb nc">   spec:</span><span id="19ed" class="lp lq iq mq b gy nd na l nb nc">     containers:</span><span id="22eb" class="lp lq iq mq b gy nd na l nb nc">     - name: docker-demo</span><span id="8667" class="lp lq iq mq b gy nd na l nb nc">    image: tolatemitope/docker-demo</span><span id="4aeb" class="lp lq iq mq b gy nd na l nb nc">    ports:</span><span id="3226" class="lp lq iq mq b gy nd na l nb nc">    - containerPort: 5000</span></pre><p id="f661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们上面的部署，我们给它起了一个名字<code class="fe mn mo mp mq b">helloworld-deployment</code>和<code class="fe mn mo mp mq b">3 replicas</code>。容器规范类似于我们之前用于复制集的规范。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/5be1693f8d6cd6216563ae15496c0860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYrzmUcFggFiOicKfCPrMQ.png"/></div></div></figure><p id="05f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有副本都是最新的，并且运行我们要求它运行的最新的<code class="fe mn mo mp mq b">docker-demo version</code>。</p><ul class=""><li id="0319" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">你也可以用<code class="fe mn mo mp mq b">kubectl get rs</code>得到<code class="fe mn mo mp mq b">replica set</code></li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/ee9c73824c567889b790a0b7a04559bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNUxKYaUBlcpXpNiu53PIw.png"/></div></div></figure><p id="699d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您不需要自己创建副本集，Kubernetes会为您完成。</p><ul class=""><li id="a6d9" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">检查你的豆荚并得到它们。</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/76f953afea4445b2efa254adf9c9eee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LF6kwW6tMmvS6HaYtBwArQ.png"/></div></div></figure><ul class=""><li id="235d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">展示您的豆荚上的标签。</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/38b39211d2c3d83f063027521fe92d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHayRsgbJRmIGrsaZ4CWCg.png"/></div></div></figure><ul class=""><li id="bc11" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">使用<code class="fe mn mo mp mq b">kubectl expose deployment hello-world-deployment — type=NordPort</code>展示您的部署</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/17529024e8a26fd41ccb446d0a7314b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jik7F1E2wfbANVUPp1tbYQ.png"/></div></div></figure><ul class=""><li id="72e9" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">使用<code class="fe mn mo mp mq b">kubectl get service</code>获取服务您将看到新创建的部署的服务。</li></ul><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/e057d5f72e8cea0ce5d805a66f0bf2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aydd0WuY5PIazgAhspN-lw.png"/></div></div></figure><ul class=""><li id="7c9f" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">使用<code class="fe mn mo mp mq b">kubectl set image hello-world-deployment docker-demo=tolatemitope/docker-demo:2</code>设置新图像</li><li id="34f5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">使用<code class="fe mn mo mp mq b">kubectl rollout status hello-world-deployment</code>获取卷展状态</li></ul><h2 id="7aaa" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">用于Kubernetes部署的有用命令。</h2><ul class=""><li id="1422" class="lb lc iq kf b kg mi kk mj ko nx ks ny kw nz la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl get deployments</code> - &gt;获取有关您当前部署的信息。</li><li id="6dc3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl get rs</code> - &gt;获取关于副本集的信息。</li><li id="32b6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl get pods --show-labels</code> - &gt;拿到豆荚，还出示贴在豆荚上的标签。</li><li id="23d0" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl rollout status deployment/(name of deployment)</code> - &gt;获取部署状态。</li><li id="2c4a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl set image deployment/helloworld-deployment docker-demo=docker-demo:2</code> - &gt;使用新的图像标签版本2运行docker-demo。</li><li id="ce5a" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl edit deployment/helloworld-deployment</code> - &gt;编辑部署对象。</li><li id="ddc2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl rollout status deployment/helloworld-deployment</code> - &gt;获取卷展栏的状态。</li></ul><p id="d980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您将映像更新到新版本，那么您可以使用卷展状态来查看部署进度。</p><ul class=""><li id="e617" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl rollout history deployment/helloworld-deployment</code> - &gt;获取首次展示历史。</li></ul><p id="2701" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您发布了一个新版本的应用程序，例如版本3，并且您想要返回到版本2，您可以使用:</p><ul class=""><li id="9c2f" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl rollout undo deployment/helloworld-deployment</code> - &gt;回滚到上一版本。</li></ul><p id="0517" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用以下命令回滚到特定版本:</p><ul class=""><li id="bacb" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe mn mo mp mq b">kubectl rollout undo deployment/helloworld-deployment --to-revision=n</code> - &gt;回滚到更具体的版本。</li></ul><h1 id="db9a" class="ng lq iq bd lr nh ni nj lu nk nl nm lx nn no np ma nq nr ns md nt nu nv mg nw bi translated">谢谢</h1><p id="e961" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">喜欢阅读吗？在下面留下一些“掌声”,以便其他人可以找到这篇文章🙂</p></div></div>    
</body>
</html>