<html>
<head>
<title>Death of Quake 3’s Inverse Square Root Hack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地震3的平方根倒数黑客之死</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/death-of-quake-3s-inverse-square-root-hack-32fd2eadd7b7?source=collection_archive---------7-----------------------#2021-09-07">https://levelup.gitconnected.com/death-of-quake-3s-inverse-square-root-hack-32fd2eadd7b7?source=collection_archive---------7-----------------------#2021-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc8d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">巧妙优化背后的故事，以及为什么它现在只是民间传说</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d89d78c8b2f3be081304c1da2c91b76f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lZvlEy9tUfCLsVtv"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@elladon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾拉·唐</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="7643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于没有听说过这个代码技巧/优化的人来说，前提是，我们需要做“<strong class="lb iu">1/√x”</strong>整整一堆次来渲染3D图形和酷炫的着色器。如果你没有学过向量微积分，或者像我一样只拿到了B+，那么你可能会非常模糊——也许这有所帮助(也可能没有):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/c5439e68211f89d2d1f2ceeb23cbd481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7C6G7vRCqcJDZRB5lBEWpA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">取arb长度的向量，使其正常长度为1。为什么？谁知道呢…享受酷炫的3D吧</figcaption></figure><h1 id="c9a9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">回到过去</h1><p id="c7a5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">很久以前，我们编写了这样的代码来实现平方根倒数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ff01" class="my lx it mu b gy mz na l nb nc"><em class="nd">def</em> isqrt(<em class="nd">l</em>):<br/>    return <em class="nd">l</em> **(-1/2)   # 1/sqrt(l)</span></pre><p id="1bf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">C语言中的编译器和标准库可以有效地运行如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">但是，</strong>这很慢，因为内部的sqrt实现往往是反复试验，利用<a class="ae ky" href="https://en.wikipedia.org/wiki/Newton%27s_method" rel="noopener ugc nofollow" target="_blank">牛顿法</a>。看看苹果的<a class="ae ky" href="https://opensource.apple.com/source/Libm/Libm-47.1/ppc.subproj/sqrt.c.auto.html" rel="noopener ugc nofollow" target="_blank"> sqrt.c </a>的源代码，你会看到一些查找表优化第一步的证明。我测试了这个基础版本，并测量了性能以供参考。</p><h2 id="4412" class="my lx it bd ly ng nh dn mc ni nj dp mg li nk nl mi lm nm nn mk lq no np mm nq bi translated">那么这有多慢呢？</h2><p id="fde8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">嗯，它确实很快，但如果你运行它50，000次，在我的i7 Surface笔记本电脑上需要1.269秒。让我们看看Quake优化的速度有多快，以及它是如何完成的。</p><h1 id="6eb3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">雷神之锤3版本</h1><p id="9a21" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我使用了Python版本的雷神之锤III的优化/破解平方根倒数，这是由艾利克斯·莱利的github帖子提供的。我不会去解释为什么它会起作用，因为它已经被详细解释过很多次了。(但是TLDR；它混合使用一个神奇的起点+数字的原始位表示，以达到1%以内的近似精度[ <a class="ae ky" href="https://medium.com/hard-mode/the-legendary-fast-inverse-square-root-e51fee3b49d9" rel="noopener"> Ref 1 </a> ]。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么到底好了多少呢？使用上述实现方式，大约比<strong class="lb iu">快3-4倍</strong>，但是精度略有损失(&lt; ~1%)。</p><p id="0916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意原始的C代码有更酷的注释，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/6290335ccfd8f2dd5d78933072effb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36GDjRt2IqXWeEJTYNgUpw.png"/></div></div></figure><p id="5acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这方面的历史是有据可查的。简而言之，人们认为这是天才ID创始人约翰·卡马克和他的团队，然后是《汇编与图形的禅》的作者迈克尔·阿布拉什，以及其他几位杰出的程序员，直到线索汇聚到前施乐Parc工程师格雷格·沃什从80年代后期的工作</p><h1 id="8507" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">英特尔终结了乐趣— SSE</h1><p id="d337" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">令人惊讶的是，就在雷神之锤3发布几年后，英特尔发布了x86 SSE扩展，其中<strong class="lb iu">在硬件</strong>中包含了SQRT功能！哇，乐趣结束了！！</p><p id="c765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的语言中，如果你写x**(-1/2) →它不调用一个牛顿例程，它只是调用(在Intel上)RSQRTSS指令，噗它就完成了。</p><h2 id="000a" class="my lx it bd ly ng nh dn mc ni nj dp mg li nk nl mi lm nm nn mk lq no np mm nq bi translated">HW有多快？</h2><p id="d827" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我的系统上，SSE sqrt的运行速度比牛顿方法快10倍，比Quake的方法快3.5倍。LinkedIn 上的一篇很棒的<a class="ae ky" href="https://www.linkedin.com/pulse/fast-inverse-square-root-still-armin-kassemi-langroodi/" rel="noopener ugc nofollow" target="_blank">帖子展示了ASM的样子:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/23043a2cbf883ad03f102f640c403b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9mxesgvcjBlysSSVG1M0Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">今天的编译器利用硬件调用</figcaption></figure><p id="eec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这变得更加有趣，因为最新的英特尔AVX指令进一步优化了向量调用(回想一下你的计算机架构课程中的SIMD和<a class="ae ky" href="https://en.wikipedia.org/wiki/Flynn%27s_taxonomy" rel="noopener ugc nofollow" target="_blank">弗林的分类学</a>)。</p><p id="43b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这个故事的寓意是——优化技术很酷，但最终，硬件会赶上来；)但如果外面的天才们没有挑战极限，那么我们就不会有《雷神之锤3》，谁知道上证综指和AVX会不会发展得如此之快。向外面的黑客们致敬！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/adc70d2de9a1091eaf228ef43dd3d2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/0*kppwqHJI_0PfNkxD.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Quake_(series)#/media/File:Quake_logo.png" rel="noopener ugc nofollow" target="_blank">维基共享雷神之锤</a>标志</figcaption></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="60ba" class="lw lx it bd ly lz ob mb mc md oc mf mg jz od ka mi kc oe kd mk kf of kg mm mn bi translated">参考</h1><ol class=""><li id="fe56" class="og oh it lb b lc mo lf mp li oi lm oj lq ok lu ol om on oo bi translated">关于历史、数学和算法的逐步指南—<a class="ae ky" href="https://medium.com/hard-mode/the-legendary-fast-inverse-square-root-e51fee3b49d9" rel="noopener">https://medium . com/hard-mode/the-legendary-fast-inverse-平方根-e51fee3b49d9 </a></li><li id="48c3" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">Python版本—<a class="ae ky" href="https://github.com/ajcr/ajcr.github.io/blob/master/_posts/2016-04-01-fast-inverse-square-root-python.md" rel="noopener ugc nofollow" target="_blank">https://github . com/ajcr/ajcr . github . io/blob/master/_ posts/2016-04-01-fast-inverse-square-root-python . MD</a></li><li id="239c" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">上证和AVX现代测试—<a class="ae ky" href="https://www.linkedin.com/pulse/fast-inverse-square-root-still-armin-kassemi-langroodi/" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/pulse/fast-inverse-square-root-still-Armin-kassemi-langroodi/</a></li><li id="c7b2" class="og oh it lb b lc op lf oq li or lm os lq ot lu ol om on oo bi translated">好的ppt总结—<a class="ae ky" href="https://www.slideshare.net/maksym_zavershynskyi/fast-inverse-square-root" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/mak sym _ zavershynskyi/fast-inverse-square-root</a></li></ol></div></div>    
</body>
</html>