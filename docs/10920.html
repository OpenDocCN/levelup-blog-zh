<html>
<head>
<title>Preload JSON to load websites faster (Lighthouse, SEO)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预加载JSON来更快地加载网站(灯塔，搜索引擎优化)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/preload-json-to-load-websites-faster-lighthouse-seo-880a31815913?source=collection_archive---------3-----------------------#2022-01-25">https://levelup.gitconnected.com/preload-json-to-load-websites-faster-lighthouse-seo-880a31815913?source=collection_archive---------3-----------------------#2022-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4c1d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用<link rel="”preload”"/>时避免问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/400152154ea06a8da3afe52195c58eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBBZrEVBHzt7deysQX1CIA.png"/></div></figure><h1 id="f510" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">介绍</h1><p id="acdf" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">也许您的web应用程序在打开页面时会加载一个单独的JSON文件(用于配置、动态站点范围的资源等。)这对于单页应用程序来说尤其常见。如果你是为了更快的加载时间而优化它，那么在需要资源之前下载它会有所帮助。</p><p id="36cc" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">考虑一个真实世界的例子:一个(客户端呈现的)Vue.js应用程序绘制了一个导航栏，但是链接是动态的而不是静态的——它们是从后端内容管理系统中检索的。CMS通过<code class="fe mg mh mi mj b">GET /navigation/links</code>提供链接。一旦应用程序的逻辑被加载，它就请求这些链接。让我们在Chrome DevTools中看到它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/7136432611fcd70fabfce9a338f62afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHc1manlQvL5k-BB9MCbWw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Links JSON仅在应用程序逻辑之后下载(见右边的瀑布专栏)</figcaption></figure><p id="7210" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们可以注意到请求是批处理的:</p><ol class=""><li id="8a59" class="mt mu iq lh b li mb ll mc lo mv ls mw lw mx ma my mz na nb bi translated">html文档</li><li id="66e3" class="mt mu iq lh b li nc ll nd lo ne ls nf lw ng ma my mz na nb bi translated">文档请求应用程序逻辑(。js捆绑包)</li><li id="c7e6" class="mt mu iq lh b li nc ll nd lo ne ls nf lw ng ma my mz na nb bi translated">申请请求<code class="fe mg mh mi mj b">/navigation/links</code></li></ol><p id="2d96" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">在我们的例子中，请求并没有在这里结束:文件包含元数据，让应用程序知道它在哪个页面上，以及进一步请求什么资源。因此，之后有第四批请求拉各种其他资源(例如，产品列表，类别信息)和第五批下载图像。有这么多请求阶段的网站会不必要地降低用户体验。</p><h1 id="4664" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">用<link/>预压</h1><p id="ce09" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">无论我们在哪个页面，我们的JSON文件都是必需的，因此我们知道它会一直被使用。这是预压的重要条件。</p><p id="77a3" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们将聪明地使用<code class="fe mg mh mi mj b"><a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload" rel="noopener ugc nofollow" target="_blank">&lt;link rel=”preload”&gt;</a></code>，而不是重新发明轮子。这个声明要求我们指定如何使用资源。我们检查MDN的可靠文档:</p><blockquote class="ni nj nk"><p id="c113" class="lf lg nl lh b li mb jr lk ll mc ju ln nm md lq lr nn me lu lv no mf ly lz ma ij bi translated"><a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload#what_types_of_content_can_be_preloaded" rel="noopener ugc nofollow" target="_blank">可以预加载哪些类型的内容？</a></p><p id="ef9f" class="lf lg nl lh b li mb jr lk ll mc ju ln nm md lq lr nn me lu lv no mf ly lz ma ij bi translated"><code class="fe mg mh mi mj b">audio</code>:音频文件，通常在<code class="fe mg mh mi mj b">&lt;audio&gt;</code>中使用。<br/> <code class="fe mg mh mi mj b">document</code>:由<code class="fe mg mh mi mj b">&lt;frame&gt;</code>或<code class="fe mg mh mi mj b">&lt;iframe&gt;</code>嵌入的HTML文档。<br/> <code class="fe mg mh mi mj b">embed</code>:嵌入<code class="fe mg mh mi mj b">&lt;embed&gt;</code>元素内部的资源。<br/> <code class="fe mg mh mi mj b">fetch</code>:由fetch或XHR请求访问的资源，如ArrayBuffer或JSON文件。<br/> <code class="fe mg mh mi mj b">font</code>:字体文件。<br/> <code class="fe mg mh mi mj b">image</code>:图像文件。<br/> <code class="fe mg mh mi mj b">object</code>:嵌入<code class="fe mg mh mi mj b">&lt;object&gt;</code>元素内部的资源。<br/> <code class="fe mg mh mi mj b">script</code> : JavaScript文件。<br/> <code class="fe mg mh mi mj b">style</code> : CSS样式表。<br/> <code class="fe mg mh mi mj b">track</code> : WebVTT文件。<br/><code class="fe mg mh mi mj b">worker</code>:JavaScript web worker或者共享worker。<br/> <code class="fe mg mh mi mj b">video</code>:视频文件，通常用于<code class="fe mg mh mi mj b">&lt;video&gt;</code>。</p></blockquote><p id="d0ca" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">所以我们用<code class="fe mg mh mi mj b">as="fetch"</code>。</p><p id="3ddd" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们还必须指定CORS行为，不管我们的后端是否托管在同一个域/端口上(source <a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload#cors-enabled_fetches" rel="noopener ugc nofollow" target="_blank"> 1 </a>，<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-crossorigin" rel="noopener ugc nofollow" target="_blank"> 2 </a>)。我们的文件是公共资源，我们设置<code class="fe mg mh mi mj b">crossorigin="anonymous"</code>。</p><p id="504d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">额外赠送<code class="fe mg mh mi mj b">type=”application/json”</code>。</p><p id="64cc" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">现在我们的完整标签是:<code class="fe mg mh mi mj b">&lt;link rel=”preload” href=”[host]/navigation/links” as=”fetch” type=”application/json” crossorigin=”anonymous”&gt;</code>。将其放入文档的<code class="fe mg mh mi mj b">&lt;head&gt;</code>中。再次加载页面。我们得到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi np"><img src="../Images/e03a43433aec9be1074d0e2f3018d2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GihlVrihsu3diVEELlfWCA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">Links JSON现在和Javascript一起下载。下载完成得更早，这意味着应用程序可以立即绘制导航栏。(见瀑布栏。)</figcaption></figure><p id="7fbf" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">太好了！但是当我们请求时，Chrome会使用这个存储的文档吗？</p><h1 id="0848" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">检索问题</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nq"><img src="../Images/26f821b73c3ad0841a4f6d1a67bd626c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdVzppN9Ac3BrXISC9fS9w.png"/></div></div></figure><p id="d9fc" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">检查文件的第二个请求的大小列(底部)。如果文件被缓存，它将显示<em class="nl">内存缓存</em>或<em class="nl">磁盘缓存</em>，而不是其完整的传输大小。这意味着Chrome下载了该文件两次，因此任何有意义的渲染都会被延迟。控制台选项卡向我们发出警告:</p><blockquote class="ni nj nk"><p id="f43b" class="lf lg nl lh b li mb jr lk ll mc ju ln nm md lq lr nn me lu lv no mf ly lz ma ij bi translated">找到了“<a class="ae nh" href="https://localhost:8080/navigation/links'" rel="noopener ugc nofollow" target="_blank">https://localhost:8080/navigation/links”</a>的预加载，但由于请求头不匹配而未使用。</p></blockquote><p id="e380" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们下载两个请求的头(右键单击-&gt;复制-&gt;复制请求头)并区分它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nr"><img src="../Images/7cabbabb6ec4655c2bea2971fc6e2e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WElck9vy9tMJB4PBb9B_OQ.png"/></div></div></figure><p id="48ac" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">标题顺序是混合的，但只有<em class="nl">接受</em>标题不同。</p><p id="c96b" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">我们的应用程序使用了<a class="ae nh" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>，所以覆盖<em class="nl">接受</em>头看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="cd65" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">编译，刷新，它仍然不工作。控制台给我们同样的警告，但是标题现在是一样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nu"><img src="../Images/88ca3b2934612cd43760d2b7d8fce2fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KUG6xNQEpncRxZyU_A1Afg.png"/></div></div></figure><p id="e612" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">Axios由XHR驱动。请注意，在最后一个网络记录中，两个请求具有不同的类型。</p><h1 id="3ea1" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">解决方案</h1><p id="7475" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">修改应用程序以使用本机<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>而不是axios/XHR。Fetch比XHR更新，链接标签的<code class="fe mg mh mi mj b">as=”fetch"</code>属性表明这可能是解决方案。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="686d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">再次点击刷新:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/abe37e37df7bffe6b07e28bd8d0b8bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ddEXnGgWA92evtN8aa09A.png"/></div></div></figure><p id="7f95" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">终于！我们知道它起作用了，因为第三批请求拉取了没有被JSON文件延迟的其他资源(没有显示在所选范围内)。应用程序的实际调用并没有显示为请求。</p><p id="68dd" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">MDN文档建议使用带有<em class="nl"> XHR </em>和<em class="nl"> fetch() </em>的预加载资源的方式相同(特别是在使用<code class="fe mg mh mi mj b">as=”fetch”</code>时)。所以还不清楚问题是什么。这也是不幸的，因为潜在的大量代码将需要重写以使用Fetch(取决于您的情况)。例如，<code class="fe mg mh mi mj b">axios.create()</code>对于保持干燥非常有用，而Fetch没有这样的预配置选项。</p><h1 id="c45d" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">额外:缓存JSON</h1><p id="2db0" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">预加载有助于减少新访客的启动时间。缓存JSON响应可以进一步改善回访者的体验。</p><p id="74f2" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">为此我们包含了一个<a class="ae nh" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" rel="noopener ugc nofollow" target="_blank"> <em class="nl">缓存控制</em> </a>头。因为我们的特定文件对于任何用户都是一样的，所以我们使用了<code class="fe mg mh mi mj b">public</code>指令。更重要的是，我们用<code class="fe mg mh mi mj b">max-age</code>设置了它的生存期(以秒为单位)。不要忘记指令是用逗号分隔的。在Express.js应用程序中，它看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8cbf" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">打开网站，然后刷新:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nv"><img src="../Images/12c3e8ed59d0dd611ebefcabb5e7f098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJKhdJJdnA00IQk8qkQfbA.png"/></div></div></figure><p id="2a7d" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">更好的是，我们完全取消了这个请求。对于较慢的网络来说，这是一个巨大的胜利(本文使用了快速3G节流)。现在，真正重要的请求已经转移到第二批。</p><p id="6cf3" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">对比网络审计结果，我们可以看到JSON文件是如何从在启动的第四个<em class="nl">秒内加载到第一个<em class="nl">秒内加载的。</em></em></p><p id="52d8" class="pw-post-body-paragraph lf lg iq lh b li mb jr lk ll mc ju ln lo md lq lr ls me lu lv lw mf ly lz ma ij bi translated">看到解决方案如此有效，您可能会受到启发，去寻找更多可以预加载和缓存的站点范围的资源。</p><h1 id="62b7" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">额外:使用自签名证书进行测试</h1><p id="c2f9" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你用无效的证书运行HTTPS，Chrome仍然不会缓存你的文件(<a class="ae nh" href="https://stackoverflow.com/a/35328096/3722143" rel="noopener ugc nofollow" target="_blank">来源</a>)。通过HTTP或有效证书验证解决方案。</p><h1 id="1987" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">浏览器</h1><p id="9846" class="pw-post-body-paragraph lf lg iq lh b li lj jr lk ll lm ju ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个解决方案已经在Chrome和Firefox上测试过了。</p></div></div>    
</body>
</html>