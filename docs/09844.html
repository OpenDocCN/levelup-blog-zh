<html>
<head>
<title>How to use Algorand’s Go-SDK with gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Algorand的Go-SDK与gRPC配合使用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-algorands-go-sdk-with-grpc-3da514e4ab11?source=collection_archive---------18-----------------------#2021-09-20">https://levelup.gitconnected.com/how-to-use-algorands-go-sdk-with-grpc-3da514e4ab11?source=collection_archive---------18-----------------------#2021-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cd3f76ac7f2318f8e50a0b2984067024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugNufnLkJ5TF8fYew5rpWA.png"/></div></div></figure><p id="31d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们构建了一个gRPC服务器，它可以与Algorand的Go-SDK进行交互。完整的代码可以在这里找到<a class="ae kw" href="https://github.com/LorenzHW/algo-grpc" rel="noopener ugc nofollow" target="_blank">。该存储库包含一个gRPC服务器，该服务器提供以下功能:</a></p><ul class=""><li id="b895" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">创建一个钱包和一个属于该钱包的帐户</li><li id="56a2" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">获取特定账户的信息(例如:该账户有多少算法等。)</li><li id="85ac" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在两个账户之间进行交易</li><li id="e819" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">获取特定帐户的所有交易</li><li id="bba7" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">获取链上的一个块以及与该块相关联的信息</li></ul><p id="34c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们关注第二个要点:获取特定帐户的信息。</p><p id="1464" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不熟悉Algorand的基础设施，建议你看一下<a class="ae kw" href="https://developer.algorand.org/docs/build-apps/setup/" rel="noopener ugc nofollow" target="_blank">这篇</a>简介。</p><h1 id="0a69" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">运行阿尔格兰德沙盒</h1><p id="876a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">开始使用algrand开发环境的一个简单方法是使用<a class="ae kw" href="https://github.com/algorand/sandbox" rel="noopener ugc nofollow" target="_blank">algrand沙箱</a>。克隆它。在沙盒存储库的根目录中，运行命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="164f" class="mx lm iq mt b gy my mz l na nb">$ ./sandbox up</span></pre><h1 id="6fb2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">为代码生成创建一个原型文件</h1><p id="c18f" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在单独的文件夹中创建项目的根目录:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="eb8a" class="mx lm iq mt b gy my mz l na nb">$ mkdir algo-grpc<br/>$ cd algo-grpc</span></pre><p id="1917" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在根文件夹中，创建一个新文件夹和一个新文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7c11" class="mx lm iq mt b gy my mz l na nb">$ mkdir protos<br/>$ touch protos/algo_service.proto</span></pre><p id="c85c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">gRPC 使用谷歌的协议缓冲区作为接口定义语言(IDL)。让我们创建我们的服务定义:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a17f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng mt b">GetAccountRequest</code>和<code class="fe ne nf ng mt b">GetAccountResponse</code>看起来像这样:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6a0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们准备好生成gRPC服务器了。为了实现这一点，我们需要几个其他的依赖项。打开项目根目录下的终端。执行以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="527c" class="mx lm iq mt b gy my mz l na nb">$ go get google.golang.org/grpc<br/>$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26<br/>$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1</span></pre><p id="2165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装完依赖项后，我们准备生成一些代码。为此，我们使用谷歌的<a class="ae kw" href="https://google.github.io/proto-lens/installing-protoc.html" rel="noopener ugc nofollow" target="_blank">协议编译器</a>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c445" class="mx lm iq mt b gy my mz l na nb">$ protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative protos/algo_service.proto</span></pre><p id="3acc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将生成文件<code class="fe ne nf ng mt b">algo_service.pb.go</code>和<code class="fe ne nf ng mt b">algo_service_grpc.pb.go</code>。这些文件将是我们服务器实现的基础。</p><h1 id="8cfb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">实现服务器</h1><p id="68e1" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在应用程序运行的根目录中:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d98b" class="mx lm iq mt b gy my mz l na nb">$ mkdir server<br/>$ touch server/main.go</span></pre><p id="1c54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还创建了一个与Algorand的SDK交互的文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="05ed" class="mx lm iq mt b gy my mz l na nb">$ touch server/algo_interactor.go</span></pre><p id="9ba2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ne nf ng mt b">main.go</code>内部，我们创建了gRPC服务器:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5d9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ne nf ng mt b">algo_interactor.go</code>使用的是Algorand的SDK。让我们开始吧:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bfe0" class="mx lm iq mt b gy my mz l na nb">$ go get -u github.com/algorand/go-algorand-sdk/...</span></pre><p id="f211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在<code class="fe ne nf ng mt b">algo_interactor.go</code>内部我们定义了<code class="fe ne nf ng mt b">kmdClient</code>、<code class="fe ne nf ng mt b">algodClient</code>和<code class="fe ne nf ng mt b">indexerClient</code>(如果你不熟悉Algorand的架构，可以阅读<a class="ae kw" href="https://developer.algorand.org/docs/build-apps/setup/" rel="noopener ugc nofollow" target="_blank">这个</a>):</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="70ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们启动服务器:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5e46" class="mx lm iq mt b gy my mz l na nb">$ go run ./server/.<br/>Made a kmd client<br/>Made an algodClient<br/>Made an indexerClient<br/>2021/09/01 13:05:33 server listening at [::]:50051</span></pre><h1 id="aeab" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">实现GetAccount</h1><p id="0c0b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在<code class="fe ne nf ng mt b">server/main.go</code>内部，我们实现了函数<code class="fe ne nf ng mt b">GetAccount</code>:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e21f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ne nf ng mt b">server/algo_interactor.go</code>内部，我们使用SDK发出请求:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="d4c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要一个映射器来将数据结构从Algo SDK映射到响应对象:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c042" class="mx lm iq mt b gy my mz l na nb">$ touch server/mapper.go</span></pre><p id="56a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在内部，我们为帐户定义映射:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b306" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以再次重启服务器:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="de3e" class="mx lm iq mt b gy my mz l na nb">$ go run ./server/.</span></pre><h1 id="e341" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建一个客户端来触发GetAccount端点</h1><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8ec6" class="mx lm iq mt b gy my mz l na nb">$ mkdir client<br/>$ touch client/main.go</span></pre><p id="90d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">客户端看起来像这样:</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b9cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第31行，我们指定了一个<code class="fe ne nf ng mt b">AccountAddress</code>。要获得您可以使用的地址列表，您可以在沙盒存储库中运行以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6008" class="mx lm iq mt b gy my mz l na nb">$ ./sandbox goal account list</span></pre><p id="3d91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以提出请求:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="98a3" class="mx lm iq mt b gy my mz l na nb">$ go run ./client/.<br/>2021/09/12 08:45:10 {"account":{"amount":150000,"address":"KU2PUHUOFNTUIEZKIIVHRVRXAH6EISEBA2IZRLQQQOD3626PBVVMW3TCCU"}}</span></pre><h1 id="2d9e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">作为一名软件工程师，我如何研究加密货币</h1><p id="20f5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">沃伦·巴菲特有句名言是这样的:</p><blockquote class="nh ni nj"><p id="14b9" class="jy jz nk ka b kb kc kd ke kf kg kh ki nl kk kl km nm ko kp kq nn ks kt ku kv ij bi translated">永远不要投资你不了解的行业</p></blockquote><p id="8ad5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">加密货币本质上很复杂，不太容易理解。有不同的方法<a class="ae kw" href="https://www.reddit.com/r/CryptoCurrency/comments/lz1taw/a_beginners_guide_to_dyor_do_your_own_research/" rel="noopener ugc nofollow" target="_blank">做自己的研究</a>。对一些人来说，这可能包括阅读硬币的白皮书。</p><p id="e9ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，作为一名软件工程师(他太懒了(也有点太笨了)不看白皮书)，我根据自己能判断的标准来评估一枚硬币。这包括:</p><ul class=""><li id="b19d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir">代码质量:</strong>代码是否干净？函数是否小而易懂？变量的命名是否恰当？</li><li id="0b8c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">文档质量:</strong>是否有足够的文档来开始？代码是否有足够的文档记录？系统的架构有记录吗？</li><li id="b2a9" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">硬币背后的社区:</strong>它是一个“当蓝宝”类型的社区，还是一个提供有趣帖子和讨论的社区？</li><li id="793c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">GitHub上的<strong class="ka ir"> Insights选项卡:</strong>多久添加一次新代码？谁在做贡献？</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/c90d3e1c2401e5c5d597fca2bb192e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xsT3mGvsIqmvjc8_wk9lw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">GitHub上的见解选项卡</figcaption></figure><ul class=""><li id="27e2" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">项目工作人员的教育和LinkedIn资料</li></ul><p id="9433" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我对Algorand和它最近获得的认可感到非常兴奋。我已经在阿尔格兰德工作了几个月，我期待着即将到来的<a class="ae kw" href="https://algorand.foundation/governance/" rel="noopener ugc nofollow" target="_blank">治理</a>。我的目标是参加<a class="ae kw" href="https://algorand.foundation/developers/trailblazer-bounty-program/" rel="noopener ugc nofollow" target="_blank">阿尔格兰德的赏金计划</a>。这将是一个更好地了解区块链并从中获得报酬的好方法。</p></div></div>    
</body>
</html>