<html>
<head>
<title>Design a Least Recently Used Cache in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python设计一个最近最少使用的缓存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-an-least-recently-used-cache-in-python-2f2d4a3fee6d?source=collection_archive---------0-----------------------#2021-03-25">https://levelup.gitconnected.com/design-an-least-recently-used-cache-in-python-2f2d4a3fee6d?source=collection_archive---------0-----------------------#2021-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="72e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于LRU、缓存及其使用哈希表和双向链表的实现细节，您需要了解的一切。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/618862e055532c336aa9efa595551b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3ZAdDKF1NwgpzZS9HC39g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用哈希表和双向链表的LRU缓存</figcaption></figure><h1 id="a280" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">目录</h1><ul class=""><li id="7550" class="lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><a class="ae mi" href="#db52" rel="noopener ugc nofollow">什么是LRU缓存</a></li><li id="aebe" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#5a67" rel="noopener ugc nofollow"> LRU用例</a></li><li id="c285" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#062f" rel="noopener ugc nofollow">实现LRU </a></li><li id="81c3" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#42dd" rel="noopener ugc nofollow">使用代码</a></li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="db52" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated"><strong class="ak">什么是LRU缓存</strong></h1><p id="b548" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated"><strong class="ls iu">缓存的</strong>主要目的是通过减少访问底层较慢存储层的需求来提高数据检索性能。</p><p id="33ba" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated">牺牲容量来换取速度，一个<strong class="ls iu">缓存</strong>通常会暂时存储数据的一个子集，相比之下，数据库的数据通常是完整和持久的。</p><p id="e6ef" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated">一个<strong class="ls iu"> LRU缓存</strong>代表<strong class="ls iu">最近最少使用的</strong>缓存。这是一种高效的缓存数据结构，可用于确定当缓存已满时应该清除什么。它具有以下特点:</p><ul class=""><li id="d349" class="lq lr it ls b lt nn lv no lx ns lz nt mb nu md me mf mg mh bi translated">固定大小<strong class="ls iu"> <em class="nv">缓存容量</em> </strong></li><li id="a00a" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated">项目按照从<em class="nv">最近使用的</em>到<em class="nv">最近最少使用的</em>的顺序组织</li><li id="a7f9" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated">每当一个项目超出容量时，最近最少使用的元素就会被逐出或移除</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="5a67" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">LRU用例</h1><p id="890d" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">在使用macOS Finder时，标题为“<strong class="ls iu"> Recents </strong>”的侧边栏是基于LRU缓存实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f8e8184aef43d336cd499e221b2893d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNnjV9bhXd459SnjDgwReQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">最近侧边栏</figcaption></figure><p id="50e4" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated">它实际上是macOS中的一个“智能文件夹”，用于搜索最近修改或创建的文件。</p><p id="75a8" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated">这意味着您打开的最后一个文件将位于列表的顶部。这对于查找您最近处理过但似乎在其他地方找不到的文档非常有帮助。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="062f" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">实现LRU缓存</h1><p id="273c" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">为了设计和实现最近最少使用(LRU)缓存的数据结构，通常需要对LRU概念有一个基本的理解。</p><div class="nx ny gp gr nz oa"><a href="https://leetcode.com/problems/lru-cache/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">LRU缓存- LeetCode</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">leetcode.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><p id="963f" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated">LRU缓存应满足以下要求:</p><ul class=""><li id="560a" class="lq lr it ls b lt nn lv no lx ns lz nt mb nu md me mf mg mh bi translated">用正的大小<code class="fe op oq or os b">capacity</code>初始化LRU缓存。</li><li id="0180" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><code class="fe op oq or os b"><strong class="ls iu">get(int key)</strong></code>:如果键存在，返回<code class="fe op oq or os b">key</code>的值，否则返回<code class="fe op oq or os b">-1</code>。</li><li id="16b4" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><code class="fe op oq or os b"><strong class="ls iu">put(key, value)</strong></code>:如果<code class="fe op oq or os b">key</code>存在，更新<code class="fe op oq or os b">key</code>的值。否则，将<code class="fe op oq or os b">key-value</code>对添加到缓存中。</li><li id="a5da" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated">如果键的数量超过<code class="fe op oq or os b">capacity</code>，则驱逐最近最少使用的键。</li><li id="3eaa" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated">时间复杂度:<strong class="ls iu">快速访问O(1)和快速更新O(1) </strong></li></ul><p id="b78a" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated">示例:</p><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="d5c5" class="ox kz it os b gy oy oz l pa pb">LRUCache cache = new LRUCache(2);<br/><br/>cache.put(5, 7);<br/>cache.put(8, 20);<br/>cache.get(5);       // returns 7<br/>cache.put(3, 6);    // evicts key 8<br/>cache.get(8);       // returns -1 (not found)<br/>cache.put(4, 12);   // evicts key 5<br/>cache.get(5);       // returns -1 (not found)<br/>cache.get(3);       // returns 6<br/>cache.get(4);       // returns 12</span></pre><h2 id="d5e5" class="ox kz it bd la pc pd dn le pe pf dp li lx pg ph lk lz pi pj lm mb pk pl lo pm bi translated">数据结构的构建块</h2><p id="b338" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">我们使用两种数据结构来实现LRU缓存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/618862e055532c336aa9efa595551b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3ZAdDKF1NwgpzZS9HC39g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用哈希表和双向链表的LRU缓存</figcaption></figure><ol class=""><li id="73c1" class="lq lr it ls b lt nn lv no lx ns lz nt mb nu md pn mf mg mh bi translated"><strong class="ls iu">双向链表</strong></li></ol><p id="eba4" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated"><em class="nv">双向链表</em>用于<strong class="ls iu">维护</strong>的顺序。最近使用的链接节点将靠近尾部，最近最少使用的节点将靠近头部。</p><p id="1180" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated"><strong class="ls iu"> 2。散列表</strong></p><p id="5bbc" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated">Hashmap <strong class="ls iu"> </strong> <em class="nv">将关键字映射到双向链表中节点的地址。</em>一般来说，在链表中查找一个条目需要<em class="nv"> O </em> ( <em class="nv"> n </em>)时间，因为我们需要遍历整个链表。然而，通过使用Hashmap，在缓存的链表中查找一个元素只需要O(1)时间。</p><p id="6376" class="pw-post-body-paragraph na nb it ls b lt nn ju nc lv no jx nd lx np nf ng lz nq ni nj mb nr nl nm md im bi translated">哈希表的最大大小将等于缓存容量。</p><h2 id="dd9c" class="ox kz it bd la pc pd dn le pe pf dp li lx pg ph lk lz pi pj lm mb pk pl lo pm bi translated">Put操作的流程图</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/16ac1f3c14942f9c88a77b794ddf56ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XxWrPV8uDPnMd1Gx.png"/></div></div></figure><ol class=""><li id="89bf" class="lq lr it ls b lt nn lv no lx ns lz nt mb nu md pn mf mg mh bi translated">在哈希映射中查找该键。</li><li id="88c2" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md pn mf mg mh bi translated">如果键在哈希映射中(<strong class="ls iu">缓存命中)，则</strong>找到对应的链表节点，从当前位置解除该节点的链接，并将其移动到列表的尾部。</li><li id="88cd" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md pn mf mg mh bi translated">如果该项不在哈希映射中(“<strong class="ls iu">缓存缺失</strong>”)，则将它加载到缓存中</li><li id="9945" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md pn mf mg mh bi translated">我们的缓存满了吗？如果是这样，我们需要<strong class="ls iu">驱逐一些东西</strong>来腾出空间:获取最近最少使用的缓存项——它将位于链表的头部。通过从链表和哈希映射中移除该项来从缓存中驱逐该项。</li><li id="8339" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md pn mf mg mh bi translated">为该项创建新的链接列表节点。将其插入到链表的尾部。</li><li id="a501" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md pn mf mg mh bi translated">将该项添加到哈希映射中，将新创建的链表节点存储为值。</li></ol><h2 id="b43c" class="ox kz it bd la pc pd dn le pe pf dp li lx pg ph lk lz pi pj lm mb pk pl lo pm bi translated">获取操作流程图</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/48264440cafebc2a404167836b9f44bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mV2MnavVnEktKj8a.jpg"/></div></div></figure><ol class=""><li id="cafb" class="lq lr it ls b lt nn lv no lx ns lz nt mb nu md pn mf mg mh bi translated">在哈希映射中查找该键。</li><li id="e9c3" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md pn mf mg mh bi translated">获取哈希映射键指向的链接节点对象，从当前位置取消该节点的链接，并将其移动到列表的末尾。</li></ol><h1 id="42dd" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">使用代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pp pq l"/></div></figure><h2 id="7258" class="ox kz it bd la pc pd dn le pe pf dp li lx pg ph lk lz pi pj lm mb pk pl lo pm bi translated">其他相关员额</h2><div class="nx ny gp gr nz oa"><a href="https://dzone.com/articles/java-based-simple-cache-lru-eviction" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">使用LRU驱逐策略的Java缓存</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">LRU(或最近最少使用的)是一种缓存驱逐策略，其中如果缓存大小已经达到最大分配…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">dzone.com</p></div></div><div class="oj l"><div class="pr l ol om on oj oo ks oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://krishankantsinghal.medium.com/my-first-blog-on-medium-583159139237" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">如何用HashMap和双向链表实现LRU缓存</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">LRU缓存代表最近最少使用的缓存。其驱逐最近最少使用条目。因为缓存的目的是提供…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">krishankantsinghal.medium.com</p></div></div><div class="oj l"><div class="ps l ol om on oj oo ks oa"/></div></div></a></div></div></div>    
</body>
</html>