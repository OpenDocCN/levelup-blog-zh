<html>
<head>
<title>Erlang-Style Actors in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋里的二郎式演员</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/elixir-style-actors-in-go-64cdeee98420?source=collection_archive---------6-----------------------#2020-03-07">https://levelup.gitconnected.com/elixir-style-actors-in-go-64cdeee98420?source=collection_archive---------6-----------------------#2020-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2a612f38480d9b2c8a55cab44f688bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ibop8M6RwKf1puff"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@dnevozhai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼斯·内沃扎伊</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="2d7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">原载于2020年3月7日</em><a class="ae kc" href="https://preslav.me/2020/03/07/elixir-style-actors-in-golang/" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://preslav . me</em></a><em class="lb">。</em></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="4b3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我对<a class="ae kc" href="https://elixir-lang.org/" rel="noopener ugc nofollow" target="_blank">长生不老药</a>的尝试，让它和围棋之间的相似之处比我最初预期的要多得多。其中之一是两者如何处理并发性。关于这一点，在Go中创建Elixir风格的有状态参与者非常容易。回答这个问题，一个人是否需要它们，或者是否能利用它们，我会留给用户。如果你回过头来对我说，同样的事情可以用一个频道或者一张上面有<code class="fe lj lk ll lm b">sync.Mutex</code>的地图来实现，你(几乎)是对的。然而，探索不同的思维方式是值得的。</p><p id="c5a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些不知道它的人来说，Elixir是一种函数式语言。一切都在不可变的函数范围内运行，没有状态保留在表上。一个函数只能对它所接受的东西起作用。函数驻留在模块中，并在Erlang进程中执行。</p><p id="5f1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抛开技术上的差异，你可以把进程看作是围棋的goroutines的等价物。函数链调用在进程/goroutine内部运行。当最外层的函数返回时，进程/goroutine结束。一个进程/goroutine可以衍生出其他进程/go routine来实现任务的并发执行。Go通过通道进行同步，而Elixir通过内置于每个进程中的消息收件箱进行同步。使用内置的receive关键字，函数的执行会阻塞在一个进程中，直到收到某种类型的消息</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="916d" class="lv lw iq lm b gy lx ly l lz ma">receive do<br/>    # Don't get too caught up on the Elixir syntax.<br/>    # For now, it is only important to know that :message_a is           <br/>    # equivalent to a string with the value of "message_a"<br/>    # Those are called "atoms" and are quite often used in Ruby-like<br/>    # languages <br/>    {:message_a, msg} -&gt;<br/>        do_something_with(msg)<br/>end</span></pre><p id="f310" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从根本上说，这与让<a class="ae kc" href="https://play.golang.org/p/rZkdET2ZhJl" rel="noopener ugc nofollow" target="_blank"> goroutine阻塞它的执行并等待通道</a>是一样的:</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="ad10" class="lv lw iq lm b gy lx ly l lz ma">type message struct {<br/>    val string<br/>}<br/><br/>msgStream := make(chan message)<br/><br/>go func(out chan message) {<br/>    out &lt;- message{val: "hello world"}<br/>}(msgStream)<br/><br/>msg := &lt;-msgStream<br/>fmt.Printf("%+v", msg)</span></pre><p id="3c41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我来说，无论你是在等待一条消息到达你的收件箱，还是明确地设置一个阻塞通道作为一种交流机制，它描述了相同的范例。</p><p id="ad08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">清楚了吗？好吧。我们继续吧。我已经提到过，Elixir是一种函数式语言。传递给函数的一切都是不可变的，改变它的唯一方法是返回它的新版本。这意味着循环结构是不可能的，因为它意味着修改和跟踪计数器变量。函数式语言实现循环效果的方式是通过递归(或者更准确地说是尾部递归):</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="8f36" class="lv lw iq lm b gy lx ly l lz ma">def loop(5) do<br/>    # Elixir uses pattern-matching when choosing which function to call.<br/>    # In our case, as soon as its gets a count == 5, it will stop the loop<br/>    5<br/>end<br/><br/>def loop(count) do<br/>    # Just print the count, but use pipes (|&gt;)<br/>    # instead of wrapping in a function call -&gt; IO.puts(count)<br/>    # Pipes totally save the day, when you have multiple call chains<br/>    count<br/>    |&gt; IO.puts()<br/><br/>    loop(count + 1)<br/>end</span></pre><h1 id="106d" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">从递归到演员</h1><p id="af3a" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果我们把这个递归的例子看作是一个永无止境的循环。对该函数的第一次调用设置了初始状态，并且该函数一直不断地调用自己。</p><p id="2337" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，这就是纯粹的函数式范式被打破的地方。我们已经了解到Erlang允许其他进程与我们通信。这意味着，如果我们的永无止境递归函数从外部接收到一条消息，它可以使用它的有效载荷，用它的初始状态的修改版本来调用它自己。请记住，接收消息是一个阻塞操作，该进程将只是徘徊，不使用任何CPU资源，直到我们的正确消息到达。</p><p id="01f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用相同的消息传递范式来深入了解我们永无止境的函数的状态。由于它运行在一个单独的进程中，唯一的方法就是向它发送一个适当的消息，传递我们当前的进程ID (PID ),并让它向我们发回一个消息。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="b9c0" class="lv lw iq lm b gy lx ly l lz ma">defmodule Calculator do<br/>    def start do<br/>    # creates a separate process with its own internal state<br/>    spawn(fn -&gt; loop(0) end)<br/>    end<br/><br/>    defp loop(current_value) do<br/>    new_value =<br/>        receive do<br/>        # with this type of message, we can fetch the state of our calculator<br/>        {:get, caller_pid} -&gt;<br/>            send(caller_pid, {:response, current_value})<br/>            current_value<br/><br/>        # with this type of message, we can modify the state of our calculator<br/>        {:add, value} -&gt;<br/>            current_value + value<br/>        end<br/><br/>    loop(new_value)<br/>    end<br/>end</span></pre><p id="7aa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们测试一下我们的计算器流程:</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="f636" class="lv lw iq lm b gy lx ly l lz ma">defmodule CalculatorTest do<br/>    def test_calculator do<br/>    calc_pid = Calculator.start()<br/><br/>        # Like `receive`, `send` is built-in and take a PID, as well as a message<br/>        # self() returns the process id (PID) of the current process<br/>        # Like in Go, every piece of Elixir/Erlang code runs in a process<br/>    send(calc_pid, {:get, self()})<br/><br/>        # `receive` will block, until we receive a message,<br/>        # that matches the expected pattern - {:response, value}<br/>    receive do<br/>        {:response, value} -&gt;<br/>        value |&gt; IO.puts()<br/>    end<br/><br/>    send(calc_pid, {:add, 100})<br/><br/>    send(calc_pid, {:get, self()})<br/><br/>    receive do<br/>        {:response, value} -&gt;<br/>        value |&gt; IO.puts()<br/>    end<br/>    end<br/>end</span></pre><p id="6931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，我们永无止境的功能变成了Elixir所说的有状态服务器进程，一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Actor_model" rel="noopener ugc nofollow" target="_blank">角色模型</a>的实现。Actors非常适合隔离关键状态，并允许与它进行并发通信，确保一次只发生一个变化。</p><h1 id="c330" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">从仙丹到外带</h1><p id="feda" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">好了，现在我们知道了仙丹世界的工作原理，在Go上实现同样的事情非常简单。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="4b13" class="lv lw iq lm b gy lx ly l lz ma">func main() {<br/>    in := make(chan message)<br/>    out := make(chan int)<br/>    go newCalculator(0, in, out)<br/><br/>    in &lt;- message{operation: "get"}<br/>    state := &lt;-out<br/>    log.Printf("Current state: %d", state)<br/><br/>    in &lt;- message{operation: "add", value: 100}<br/>    in &lt;- message{operation: "get"}<br/>    state = &lt;-out<br/>    log.Printf("Current state: %d", state)<br/>}<br/><br/>type message struct {<br/>    operation string<br/>    value     int<br/>}<br/><br/>func newCalculator(initialState int, in chan message, out chan int) {<br/>    state := initialState<br/>    for {<br/>        p := &lt;-in<br/>        switch p.operation {<br/>        case "add":<br/>            log.Printf("Adding %d to the current state", p.value)<br/>            state += p.value<br/><br/>        case "get":<br/>            out &lt;- state<br/>        }<br/>    }<br/>}</span></pre><p id="9a33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的一点是，既然我们可以使用无限循环，我们就应该使用它，特别是，根据我的知识，Go并不特别适合长循环递归。但大前提不变。一个函数在某个初始状态下被调用，并返回一个通道。该函数开始一个无限循环，在通道上阻塞。如果我们将一个值推送到该通道，函数将接受它，更新状态并再次阻塞。</p><h1 id="546b" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">私有国家</h1><p id="182c" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">所以，现在我们揭开了演员背后的神秘面纱，讨论他们可能有什么用处是个好主意。</p><p id="01f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我马上想到的一件事是实现全局可访问，但真正私有的同步状态。这目前是通过使用通道<code class="fe lj lk ll lm b">sync.Mutex</code>或新的<code class="fe lj lk ll lm b">sync.Map</code>来实现的。</p><pre class="ln lo lp lq gt lr lm ls lt aw lu bi"><span id="a5bf" class="lv lw iq lm b gy lx ly l lz ma">type SynchronizedMap struct {<br/>    sync.RWMutex<br/>    internal map[string]interface{}<br/>}<br/><br/>func (rm *SynchronizedMap) Store(key string, value interface{}) {<br/>    rm.Lock()<br/>    rm.internal[key] = value<br/>    rm.Unlock()<br/>}</span></pre><p id="28f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的脆弱性来自于Go应用程序中没有真正的私有状态。在上面的例子中，我们命名为<code class="fe lj lk ll lm b">internal</code>的地图只受到外部访问的保护。与我们的<code class="fe lj lk ll lm b">SynchronizedMap</code>在同一个包中的任何一段代码都可以自由地访问和修改它的内部，导致意想不到的后果。虽然在大多数情况下这不应该是一个问题，但在特殊情况下记住这一点绝对是有好处的。</p><h1 id="45cc" class="mb lw iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">有状态自治代理</h1><p id="8370" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">演员模型的亮点在于演员实例系统的编排——自治代理。每个Actor实例都能够改变其状态，对发送给它的消息做出反应。Actor实例可以很容易地衍生出其他Actor实例，只有创建Actor(主管)才能控制这些实例(记住，私有状态)。主管还可以接管他们所负责的参与者的失败，可能会杀死一些参与者，并以干净的状态重新启动它们。举个极端的例子，groroutines相当便宜，人们可以很容易地想象成千上万的Actor实例，在一个深度嵌套的层次结构中，多个级别的监督Actor接管它们的“后代”。这是Erlang的独特销售主张，但正如我希望展示的那样，也可以在Go中复制。</p><p id="aa36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如在开始时所讨论的，我将把关于这种方法的实用性以及它的其他应用的讨论留给读者。我很想听听你的想法。不要犹豫给我留言，或者开始新的讨论。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="bf36" class="mb lw iq bd mc md nd mf mg mh ne mj mk ml nf mn mo mp ng mr ms mt nh mv mw mx bi translated">资源</h1><div class="ni nj gp gr nk nl"><a href="https://www.goodreads.com/book/show/38732242-elixir-in-action" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">长生不老药</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">非常棒的关于长生不老药的书...我已经知道了Erlang，所以更容易跟上...但是这本书仍然做了一个漂亮的…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">www.goodreads.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz jw nl"/></div></div></a></div><p id="add2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于学习长生不老药的最好的书之一，当然，也是启发我写这篇文章的书。SAA juri的解释清晰明了，尤其是像这样复杂的话题。如果你喜欢这个博客，并且愿意支持我阅读伟大书籍的热情，你可以<a class="ae kc" href="https://amzn.to/39AXJ6T" rel="noopener ugc nofollow" target="_blank">使用这个特殊链接</a>在亚马逊上购买。谢谢！</p></div></div>    
</body>
</html>