<html>
<head>
<title>Let/Var/Const + Hoisting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Let/Var/Const +吊装</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/let-var-const-hoisting-91b9c90a6cbe?source=collection_archive---------13-----------------------#2020-01-21">https://levelup.gitconnected.com/let-var-const-hoisting-91b9c90a6cbe?source=collection_archive---------13-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/777d50000b01d1f5840f82e2b881dbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*db_mydC5t3Xm99MXfIgtnQ.png"/></div></div></figure><p id="bb60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">到目前为止，在我申请和面试软件开发职位的过程中，一些最常见的JS问题包括区分<code class="fe kz la lb lc b">let</code>、<code class="fe kz la lb lc b">var</code>和<code class="fe kz la lb lc b">const</code>。同样，许多面试包括某种形式的“描述提升”。所以在这篇文章中，我将讨论<code class="fe kz la lb lc b">let</code> / <code class="fe kz la lb lc b">var</code> / <code class="fe kz la lb lc b">const</code>以及吊装，因为它们往往是齐头并进的。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="3b94" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">let，var，const到底是什么？</h1><p id="1c2e" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated"><code class="fe kz la lb lc b">let</code>、<code class="fe kz la lb lc b">var</code>和<code class="fe kz la lb lc b">const</code>都是在JavaScript中声明变量的不同方式。<code class="fe kz la lb lc b">let</code>和<code class="fe kz la lb lc b">const</code>是ES6推出的，以前，<code class="fe kz la lb lc b">var</code>是唯一的选项。三者之间最大的区别之一是它们各自的作用域。范围——在代码中可以访问变量的地方——可以是局部的，也可以是全局的。这三个都可以全局声明(在函数外声明)，但是<code class="fe kz la lb lc b">var</code>也有函数作用域(在函数内声明)。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/be199dd2d20dc835fb835e6a23755429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5TrkRjsEDsl-yS1OCQkbw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">在此示例中，变量是在函数中定义的，在函数之外调用console.log中的test会返回一个错误，因为它在函数范围之外</figcaption></figure><p id="904a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另外，<code class="fe kz la lb lc b">var</code>变量可以被重新声明或者被认为是可变的。所以代码中前面的<code class="fe kz la lb lc b">var</code>声明可以被重新分配一个不同的值给同一个变量。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/c1b2c0a6f3f18ee758fca43eac12508e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPylA55qRy1aP8x4O0gF6g.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">在上面的例子中，用var声明的变量被重新声明和更新</figcaption></figure><p id="6f62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与<code class="fe kz la lb lc b">var</code>类似，<code class="fe kz la lb lc b">let</code>变量也是可变的，可以改变它的值，但只能在其作用域之外重新声明。你不能使用<code class="fe kz la lb lc b">let</code>在同一个作用域内重新声明一个变量，否则你会得到一个已经被声明的错误。如果声明在不同的作用域中，您可以使用相同的<code class="fe kz la lb lc b">let</code>变量，因为由于不同的作用域实例，它们将被视为不同的变量。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/25d34766de9fee176e44c3e0425b7ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aMBtagIchFfkRtbxH4KVNA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">在第一段代码中，您可以看到尝试重新声明会返回一个错误，但是使用<code class="fe kz la lb lc b">let</code>更新值是可以接受的</figcaption></figure><p id="7ba9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不像<code class="fe kz la lb lc b">var</code>是函数作用域，<code class="fe kz la lb lc b">let</code>是<em class="my">块</em>作用域。<code class="fe kz la lb lc b">let</code>变量不是包含在函数中，而是可以在一组花括号内访问。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/3d5b9bbee54f32493786a2e3385b1712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hu3XrUzzg3aG0MMpiQxKWw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">变量名“sample”可以在两种不同的情况下使用，因为一个在全局范围内，另一个被限制在函数的块范围内</figcaption></figure><p id="c020" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">const</code>与<code class="fe kz la lb lc b">let</code>非常相似，因为它是块范围的，但是<code class="fe kz la lb lc b">const</code>是不可变的。用<code class="fe kz la lb lc b">const</code>声明的变量不能更改或更新。一个声明的<code class="fe kz la lb lc b">const</code>对象可以改变它的<em class="my">属性</em>——只是不能被重新声明。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/4f8e653960f5fb2e89ebb87151cc5858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOx-nHU-0436JeEoiildug.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">在这里，您可以看到尝试重新声明或更新已声明变量的值都会导致错误</figcaption></figure></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h1 id="8813" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">那么吊装呢？</h1><p id="356d" class="pw-post-body-paragraph kb kc it kd b ke mi kg kh ki mj kk kl km mk ko kp kq ml ks kt ku mm kw kx ky im bi translated">在JavaScript中，所有的变量和函数声明在执行之前都被“提升”到它们的作用域的顶部，或者理论上被移动到顶部。不过初始化只针对<code class="fe kz la lb lc b">var</code>进行，这也是var和<code class="fe kz la lb lc b">let</code> / <code class="fe kz la lb lc b">const</code>的另一个区别。<code class="fe kz la lb lc b">var</code>被提升的声明用值<code class="fe kz la lb lc b">undefined</code>初始化，而<code class="fe kz la lb lc b">let</code> / <code class="fe kz la lb lc b">const</code>变量在被提升时不会被初始化，因此会返回一个<code class="fe kz la lb lc b">Reference Error</code>。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/ddadbb525317f1ed4e37562e14a1afa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ivx7eiSQJ6DyilKzEDW59A.png"/></div></div></figure><p id="18ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面使用<code class="fe kz la lb lc b">var</code>的例子中，第一个<code class="fe kz la lb lc b">console.log</code>返回undefined，第二个返回<code class="fe kz la lb lc b">‘hello!’</code>的值。这是由于前面提到的<code class="fe kz la lb lc b">var</code> <code class="fe kz la lb lc b">hello</code>申报的提升。声明被提升到函数的顶部(由于<code class="fe kz la lb lc b">var</code>函数作用域的原因)，由于<code class="fe kz la lb lc b">console.log</code>还没有初始化，所以返回undefined，变量被初始化，最后用第二个<code class="fe kz la lb lc b">console.log</code>返回。</p><p id="9211" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是同样的例子，但是用<code class="fe kz la lb lc b">let</code>代替了<code class="fe kz la lb lc b">var</code>。不像<code class="fe kz la lb lc b">var</code>在被提升时被默认初始化为undefined，<code class="fe kz la lb lc b">let</code>返回一个<code class="fe kz la lb lc b">Reference Error</code>来澄清所请求的变量还没有被定义。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/de1bc161b7b6a9c446d5b84b66226347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5WW7BB5WlwtWGH0HenpjA.png"/></div></div></figure><p id="670f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数提升和变量提升有点不同，因为它提升的是整个函数定义。通过像<code class="fe kz la lb lc b">var</code> / <code class="fe kz la lb lc b">let</code> / <code class="fe kz la lb lc b">const</code>这样的表达式声明的函数不会被提升。在这种情况下，与变量一样，声明本身被提升，但<em class="my">不是</em>函数定义。试图调用一个函数表达式将导致一个<code class="fe kz la lb lc b">Type Error</code>，因为它试图利用一个没有定义的函数。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="c936" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么TL:DR是什么？</p><ul class=""><li id="b874" class="nb nc it kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated">作用域:<code class="fe kz la lb lc b">var</code>声明是函数作用域，<code class="fe kz la lb lc b">let</code> / <code class="fe kz la lb lc b">const</code>是块作用域</li><li id="b24f" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">重新申报:<code class="fe kz la lb lc b">var</code>可以更新和重新申报，<code class="fe kz la lb lc b">let</code>可以更新但不能重新申报，<code class="fe kz la lb lc b">const</code>不能更新或重新申报。</li><li id="d642" class="nb nc it kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">吊装:<code class="fe kz la lb lc b">var</code>吊装，初始化为<code class="fe kz la lb lc b">undefined</code>，<code class="fe kz la lb lc b">let</code> / <code class="fe kz la lb lc b">const</code>吊装，不初始化，返回一个<code class="fe kz la lb lc b">Reference Error</code>。</li></ul><p id="f46e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望这个JS声明方法类型和提升之间的基础和差异的快速运行将帮助您理解这些常见的概念。值得注意的是，我收到的一些个人反馈都是让你的回答尽量简洁。尝试有一个简短的主题定义和一个简短的应用例子。祝你好运，编码快乐！</p></div></div>    
</body>
</html>