<html>
<head>
<title>Design Patterns: Structural Patterns of Design Classes and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:设计类和对象的结构模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-structural-patterns-of-design-classes-and-objects-79d58a6519b?source=collection_archive---------2-----------------------#2020-10-15">https://levelup.gitconnected.com/design-patterns-structural-patterns-of-design-classes-and-objects-79d58a6519b?source=collection_archive---------2-----------------------#2020-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7666" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/thought-programmer" rel="noopener">虽然程序员</a></h2><div class=""/><div class=""><h2 id="da9a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">适配器、装饰器、代理、信息专家、复合、桥接、低耦合、轻量级、受保护的变体和外观</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9eb29d78185112ec89772e033acc06c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQBbxCUNxO7McfVcgL7B3w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">设计类和对象的结构模式</figcaption></figure><p id="cf92" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">结构设计模式关注的是如何组合类和对象，以形成更大的结构。它们使您无需重写或定制代码就能创建系统，因为这些模式为系统提供了增强的可重用性和健壮的功能。</p><blockquote class="md"><p id="7a60" class="me mf it bd mg mh mi mj mk ml mm mc dk translated">每个模式描述了一个在我们的环境中反复出现的问题，然后描述了该问题解决方案的核心，以这样一种方式，你可以使用这个解决方案一百万次，而不必以同样的方式做两次。— <em class="mn">克里斯托弗·亚历山大</em></p></blockquote><p id="14d1" class="pw-post-body-paragraph lh li it lj b lk mo kd lm ln mp kg lp lq mq ls lt lu mr lw lx ly ms ma mb mc im bi translated">有以下10种结构设计模式。</p><ul class=""><li id="9fd4" class="mt mu it lj b lk ll ln lo lq mv lu mw ly mx mc my mz na nb bi translated">适配器模式</li><li id="0d16" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">桥接模式</li><li id="d109" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">复合模式</li><li id="319e" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">装饰图案</li><li id="9ca3" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">低耦合</li><li id="a3e5" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">轻量级模式</li><li id="72f0" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">立面图案</li><li id="d6b2" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">代理模式</li><li id="d677" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">信息专家</li><li id="841c" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">受保护的变化</li></ul><h1 id="6379" class="nh ni it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">ABCD(适配器、桥接、复合、装饰)</h1><h2 id="84bc" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">适配器模式</h2><p id="a65f" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="2561" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">适配器模式是一种结构设计模式，它允许具有不兼容接口的对象协同工作。</p><p id="9a74" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><p id="5d97" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它实现其客户端已知的接口，并提供对其客户端未知的类实例的访问。</p><ul class=""><li id="9558" class="mt mu it lj b lk ll ln lo lq mv lu mw ly mx mc my mz na nb bi translated"><strong class="lj jd"> AdapterClient </strong>:代码客户端。</li><li id="bd6e" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">适配器</strong>:将调用转发给被适配器的适配器类。</li><li id="81ce" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">适配者</strong>:旧代码需要适配。</li><li id="8f07" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">目标</strong>:要支持的新接口。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a1586a021f5332138e9988b07beb285c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hpD88w1qqsHPqHzDcNRlg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">适配器模式</figcaption></figure><p id="9757" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="f4eb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">原电源是220伏，需要适配100伏才能工作。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e227033e4269c5acd5d24c6f5ede198d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gw2KaBMjy4x5k4FM1JRsRQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">现实世界的例子</figcaption></figure><p id="ed0e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面的代码解决了这个问题。它定义了一个<code class="fe op oq or os b">HighVoltagePlug</code>(适配器)，一个<code class="fe op oq or os b">Plug</code>接口(目标)，一个<code class="fe op oq or os b">AdapterPlug</code>(适配器)。</p><p id="1bf5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">目标:Plug.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="a69b" class="nz ni it os b gy ox oy l oz pa">public interface Plug {<br/>    public int recharge();<br/>}</span></pre><p id="38dc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">适应者:HighVoltagePlug.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="9a5e" class="nz ni it os b gy ox oy l oz pa">public class HighVoltagePlug{<br/>    public int recharge() {<br/>        //Power is 220 Voltage<br/>        return 220; <br/>    }<br/>}</span></pre><p id="2579" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">适配器</strong>:AdapterPlug.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="260f" class="nz ni it os b gy ox oy l oz pa">public class AdapterPlug implements Plug {<br/>    @Override<br/>    public int recharge() {<br/>        HighVoltagePlug bigplug = new HighVoltagePlug();<br/>        int v = bigplug.recharge();<br/>        v = v - 120;<br/>        return v;<br/>    }<br/>}</span></pre><p id="bbed" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">适配器客户:AdapterClient.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="a845" class="nz ni it os b gy ox oy l oz pa">public class AdapterClient {<br/>    public static void main(String[] args) {<br/>        HighVoltagePlug oldPlug = new HighVoltagePlug();<br/>        System.out.println(plug.recharge() + " too much voltage");<br/>        <br/>        Plug newPlug = new AdapterPlug();<br/>        System.out.println("Adapter into " + plug.recharge() + " voltage");<br/>    }<br/>}</span></pre><p id="c2ee" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">使用案例</strong></p><p id="4197" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当你想使用一个现有的类，而它的接口与你需要的接口不匹配时。</p><p id="473f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当你想创建一个可重用的类，与不相关的<br/>或不可预见的类合作，这些类不一定有<br/>兼容的接口。</p><p id="d412" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中必须发生多个源之间的接口转换。</p><h2 id="fe30" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">桥接模式</h2><p id="e08c" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="8083" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它将一个复杂的组件分成两个独立但相关的继承层次:功能性的<strong class="lj jd"> <em class="pb">抽象</em> </strong>和内部的<strong class="lj jd"> <em class="pb">实现</em> </strong>。</p><p id="7229" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><p id="b822" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下图显示了一种可能的桥接实现。</p><ul class=""><li id="0da7" class="mt mu it lj b lk ll ln lo lq mv lu mw ly mx mc my mz na nb bi translated"><strong class="lj jd">抽象</strong>:这是抽象组件。</li><li id="0711" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">实现者</strong>:这是抽象实现。</li><li id="4485" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd"> RefinedAbstraction </strong>:这是细化的组件。</li><li id="8ce4" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">具体实现者</strong>:这些是具体实现。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c7061bedc9fd7eb027d62089375b64ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fViusZWf4tVGdQ4BxBHilQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">桥接模式</figcaption></figure><p id="19b7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="3d48" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">不同的人可以穿不同的衣服，比如男人、女人、男孩和女孩。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0cc1e29480b17059ed357e10f79df55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-Omjr5bWSlEtwCtEBfzQA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">现实世界的例子</figcaption></figure><p id="68f8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Person.java，T21</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="1eab" class="nz ni it os b gy ox oy l oz pa">public abstract class Person {<br/><br/>    protected String name;<br/>    protected Clothing cloth;<br/><br/>    public Person(String name) {<br/>        super();<br/>        this.name = name;<br/>    }<br/><br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/><br/>    public Clothing getCloth() {<br/>        return cloth;<br/>    }<br/><br/>    public void setCloth(Clothing cloth) {<br/>        this.cloth = cloth;<br/>    }<br/>}</span></pre><p id="a099" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">实施者</strong>:Clothing.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="6387" class="nz ni it os b gy ox oy l oz pa">public abstract class Clothing {<br/><br/>    protected String name;<br/>    <br/>    public Clothing(String name) {<br/>        super();<br/>        this.name = name;<br/>    }<br/>    public String getName() {<br/>        return name;<br/>    }<br/><br/>    public void setName(String name) {<br/>        this.name = name;<br/>    }<br/>}</span></pre><p id="fb6a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">具体实施者:Jacket.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="5530" class="nz ni it os b gy ox oy l oz pa">public class Jacket extends Clothing {<br/><br/>    public Jacket(String name) {<br/>        super(name);<br/>    }<br/>}</span></pre><p id="82f4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">提炼摘要:Woman.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="47d2" class="nz ni it os b gy ox oy l oz pa">public class Woman extends Person {<br/>    <br/>    public Woman(String name) {<br/>        super(name);<br/>    }<br/><br/>    @Override<br/>    public void dress() {<br/>        System.out.println(name + " wear " + cloth.getName());<br/>    }<br/>}</span></pre><p id="b2d4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">委托人:BridgeClient.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="7b1e" class="nz ni it os b gy ox oy l oz pa">public class BridgeClient {<br/>    public static void main(String[] args) {<br/><br/>        Person woman = new Woman("Woman");<br/><br/>        Clothing jacket = new Jacket("Jacket");<br/><br/>        // a woman wear jacket<br/>        woman.setCloth(jacket); <br/>        woman.dress();<br/>    }<br/>}</span></pre><p id="760d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">使用案例</strong></p><p id="8e6d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">避免抽象和实现之间的永久绑定。</p><p id="24d5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">抽象和它们的实现都应该使用子类来扩展。</p><p id="67b2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">抽象实现的变化不应该对客户产生影响；也就是说，您不必重新编译他们的代码。</p><h2 id="839e" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">复合模式</h2><p id="64d0" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="5a73" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">复合模式使您能够创建不同复杂程度的分层树结构，同时允许结构中的每个元素使用统一的接口进行操作。</p><p id="9512" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><p id="7db5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">复合模式将对象组合成树形结构，以表示整个层次结构或层次结构的一部分。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0c4ce8ac45cc6f39b6212bcce024102f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qUxlkDYSv9MVdNEeVPuDw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">复合模式</figcaption></figure><ul class=""><li id="ea10" class="mt mu it lj b lk ll ln lo lq mv lu mw ly mx mc my mz na nb bi translated"><strong class="lj jd">组件</strong>是叶子和复合物的抽象。它定义了组合中的对象必须实现的接口。</li><li id="c5bd" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">叶子</strong>是没有子对象的对象。它们实现由组件接口描述的服务。</li><li id="7b2a" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">除了实现由组件接口定义的方法之外，<strong class="lj jd">复合</strong>还存储子组件。组合通过委托给子组件来实现组件接口中定义的方法。此外，复合提供了添加、删除以及获取组件的额外方法。</li><li id="3343" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">客户端</strong>使用组件接口操纵层次结构中的对象。</li></ul><p id="08ea" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="1437" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在一个组织中，有总经理，在总经理之下有经理，在经理之下有开发人员。现在可以设置一个树形结构，要求每个节点执行类似<code class="fe op oq or os b">printStructures()</code>的常见操作。</p><p id="314a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">组件</strong>:IEmployee.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="9628" class="nz ni it os b gy ox oy l oz pa">interface IEmployee {<br/>    <br/>    void printStructures();<br/>    int getEmployeeCount();<br/><br/>}</span></pre><p id="7382" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">合成</strong>:CompositeEmployee.java</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="096f" class="nz ni it os b gy ox oy l oz pa">class CompositeEmployee implements IEmployee {<br/><br/>    private int employeeCount=0;<br/>    private String name;<br/>    private String dept;<br/><br/>    //The container for child objects<br/>    private List&lt;IEmployee&gt; controls;<br/><br/>    public CompositeEmployee(String name, String dept){<br/><br/>        this.name = name;<br/>        this.dept = dept;<br/>        controls = new ArrayList&lt;IEmployee&gt;();<br/><br/>    }<br/><br/>    public void addEmployee(IEmployee e){<br/><br/>        controls.add(e);<br/><br/>    }<br/><br/>    public void removeEmployee(IEmployee e){<br/><br/>        controls.remove(e);<br/><br/>    }<br/><br/>    @Override<br/>    public void printStructures(){<br/><br/>        System.out.println("\t" + this.name + " works in  " + this.dept);<br/><br/>        for(IEmployee e: controls){<br/>            e.printStructures();<br/>        }<br/><br/>    }<br/><br/>    @Override<br/>    public int getEmployeeCount(){<br/>        employeeCount=controls.size();<br/>        for(IEmployee e: controls){<br/>            employeeCount+=e.getEmployeeCount();<br/>        }<br/>        return employeeCount;<br/>    }<br/><br/>}</span></pre><p id="60a5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">叶:Employee.java<strong class="lj jd"/></p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="c8cd" class="nz ni it os b gy ox oy l oz pa">class Employee implements IEmployee{<br/><br/>    private String name;<br/>    private String dept;<br/>    private int employeeCount=0;<br/><br/>    public Employee(String name, String dept){<br/><br/>        this.name = name;<br/>        his.dept = dept;<br/><br/>    }<br/><br/>    @Override<br/>    public void printStructures(){<br/>        System.out.println("\t\t"+this.name + " works in  " + this.dept);<br/>    }<br/><br/>    @Override<br/>    public int getEmployeeCount(){<br/>        return employeeCount;<br/><br/>    }<br/><br/>}</span></pre><p id="c5c8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">用例</strong></p><p id="8717" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您希望表示对象的整个层次结构或层次结构的一部分；其中客户能够忽略对象的组成和单个对象之间的差异。</p><p id="0037" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可以将这种模式应用于任何复杂程度的结构。</p><h2 id="f624" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">装饰图案</h2><p id="bf4c" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="41e8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">装饰模式使您能够添加或删除对象功能，而不改变对象的外观或功能。</p><p id="8744" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/06f52fee27576445febae480f5258a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMtzsvYbWYueZi2_1qQa-g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">装饰图案</figcaption></figure><p id="cdb6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它通过使用将操作委托给原始对象的原始类的子类的实例，以对其客户端透明的方式更改对象的功能。</p><ul class=""><li id="c049" class="mt mu it lj b lk ll ln lo lq mv lu mw ly mx mc my mz na nb bi translated"><strong class="lj jd">组件</strong>是一个对象接口，可以动态地为其添加职责。</li><li id="5a49" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd"> ConcreteComponent </strong>定义了一个可以添加额外职责的对象。</li><li id="b9ba" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">装饰器</strong>维护一个组件对象的引用，并定义一个符合组件接口的接口。</li><li id="ae54" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">混凝土装饰者通过添加状态或行为来扩展组件的功能。</li></ul><p id="396d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="ee1c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你已经有房子了。现在你决定在它的上面再建一层楼。您可能希望在不影响现有架构的情况下更改新添加楼层的架构设计，例如不要更改底层(或现有楼层)的架构。</p><p id="12dd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">使用案例</strong></p><p id="f4a5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当动态透明地向单个对象添加职责时，不会影响其他对象。</p><p id="1e0b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当您想要将责任添加到将来可能要更改的对象时。</p><p id="29ee" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其中通过静态子类化的扩展是不切实际的。</p><h1 id="9e91" class="nh ni it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">F2P(轻量级，门面，代理)</h1><h2 id="4ead" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">轻量级模式</h2><p id="5805" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="b5c5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Flyweight模式通过共享对象减少了系统中低级、详细对象的数量。</p><p id="3ec1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><p id="b55a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下图显示了从池中返回的flyweight对象，为了运行，它需要将外部状态作为参数传递。</p><ul class=""><li id="ba05" class="mt mu it lj b lk ll ln lo lq mv lu mw ly mx mc my mz na nb bi translated"><strong class="lj jd">客户</strong>:客户代码。</li><li id="81c3" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">FlyweightFactory :如果flyweights不存在，这将创建它们，如果它们存在，则从池中返回它们。</li><li id="39a8" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd"> Flyweight </strong>:抽象的Flyweight。</li><li id="cf3a" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated"><strong class="lj jd">ConcreateFlyweight</strong>:flyweight被设计为与它的对等体共享状态。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0a0863e806939ae1a966409da40f0ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71BoJ6z40DNVCHCKcPfcUw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">轻量级模式</figcaption></figure><p id="180a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="2c2f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这种用法的一个典型例子是在文字处理器中。这里，每个角色都是一个共享渲染所需数据的flyweight对象。因此，只有文档中字符的位置会占用额外的内存。</p><p id="0e8d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">用例</strong></p><p id="8e78" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当以下所有情况都成立时，您应该使用Flyweight模式。</p><ul class=""><li id="b45e" class="mt mu it lj b lk ll ln lo lq mv lu mw ly mx mc my mz na nb bi translated">该应用程序使用大量的对象。</li><li id="9724" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">由于物品的数量，存储成本很高。</li><li id="599b" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">应用程序不依赖于对象标识。</li></ul><h2 id="03a4" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">立面图案</h2><p id="f017" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="49ed" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">外观模式为子系统中的一组接口提供了统一的接口。</p><p id="520c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><p id="e311" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它定义了一个更高级别的接口，使得子系统更容易使用，因为您只有一个接口。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/717042b20a4b01fbd2f248906487ad64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXOdKZ9BnVZzjmLAgnXzHg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">立面图案</figcaption></figure><p id="57b4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="b8e0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Facade为子系统定义了一个统一的、更高级别的接口，使其更易于使用。消费者从目录中订购时会遇到一个门面。消费者拨打一个号码，与客服代表通话。客户服务代表充当门面，为订单执行部门、计费部门和运输部门提供接口。</p><p id="c866" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">使用案例</strong></p><p id="54cd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当您想为复杂的子系统提供一个简单的接口时。</p><p id="58de" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果客户和抽象的实现类之间有许多依赖关系</p><p id="ef4e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当你想把你的子系统分层的时候。</p><h2 id="4672" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">代理模式</h2><p id="36d3" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated">代理模式的实现有几种类型，远程代理和虚拟代理是最常见的。</p><p id="041a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="b105" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">代理模式提供了一个代理或占位符对象来控制对原始对象的访问。</p><p id="c298" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/7eddd6cc24156298fb5d951e3ef344b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nak08MGZrTUImZyG28zWUg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">代理模式</figcaption></figure><p id="7747" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="f03e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一个真实世界的例子可以是支票或信用卡是我们银行账户的代理。它可以代替现金使用，并在需要时提供一种获取现金的方式。这正是代理模式所做的——“控制和管理对它们所保护的对象的访问”。</p><p id="63e2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">用例</strong></p><p id="d3c8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你需要一个比简单指针更通用或更复杂的对象引用。</p><h1 id="d610" class="nh ni it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">抓取模式</h1><p id="7b20" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated">掌握名称并描述分配职责的基本原则。</p><h2 id="f431" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">信息专家</h2><p id="00b9" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated">我们看专家模式(或信息专家模式)。这个非常简单，但却非常重要。</p><p id="5831" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="9895" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">给对象分配责任的基本原则是什么？</p><p id="be98" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><p id="a1c4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将责任分配给拥有履行责任所需信息的班级。</p><p id="1823" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="803a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">以垄断游戏为例。假设一个对象想要引用一个给定名称的正方形。谁负责知道这个广场，鉴于它的名字？</p><blockquote class="md"><p id="947e" class="me mf it bd mg mh mi mj mk ml mm mc dk translated">最有可能的候选是棋盘，因为它是由正方形组成的。</p></blockquote><p id="b3cf" class="pw-post-body-paragraph lh li it lj b lk mo kd lm ln mp kg lp lq mq ls lt lu mr lw lx ly ms ma mb mc im bi translated">因为棋盘是由方块组成的，所以给定方块的名称，它是最适合产生特定方块的对象——棋盘是信息专家，它拥有履行这一职责所需的所有信息。</p><p id="81e7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">用例</strong></p><p id="7167" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将设计模型中的对象视为您管理的工作人员。如果你有一项任务要分配，你会把它交给谁？</p><ul class=""><li id="ec84" class="mt mu it lj b lk ll ln lo lq mv lu mw ly mx mc my mz na nb bi translated">你把它交给最了解这项任务的人。</li><li id="fd76" class="mt mu it lj b lk nc ln nd lq ne lu nf ly ng mc my mz na nb bi translated">偶尔，完成任务的知识会分散到几个对象上<br/>通过几个消息交互来完成工作，但是通常只有一个对象负责完成任务。</li></ul><h2 id="d198" class="nz ni it bd nj oa ob dn nn oc od dp nr lq oe of nt lu og oh nv ly oi oj nx iz bi translated">受保护的变化</h2><p id="ba4d" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated"><strong class="lj jd">意图</strong></p><p id="876c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如何设计对象、子系统和系统，使得这些元素的变化或不稳定性不会对其他元素产生不良影响？</p><p id="1a85" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">解决方案</strong></p><p id="30c5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">确定预测的变化或不稳定点，分配责任以围绕它们创建稳定的界面。</p><p id="df12" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">“不要和陌生人说话”原则，该原则规定对象的方法应该只发送它直接熟悉的对象的消息(即使用方法)。</p><div class="pc pd gp gr pe pf"><a rel="noopener  ugc nofollow" target="_blank" href="/the-law-of-demeter-4bd40aa21cbe"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jd gy z fp pk fr fs pl fu fw jc bi translated">德米特里定律</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">它经常被遗忘或忽视😔</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt lb pf"/></div></div></a></div><p id="6ff7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">现实世界的例子</strong></p><p id="f67c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据封装、接口、多态性、间接性和标准都是由受保护的变体驱动的。</p><p id="e135" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">用例</strong></p><p id="b09a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">受保护的变化是激励编程和设计中的大多数机制和模式的根本原则，以提供灵活性并保护数据、行为、硬件、软件组件、操作系统等的变化。</p><h1 id="6a36" class="nh ni it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">结论</h1><p id="39fc" class="pw-post-body-paragraph lh li it lj b lk ok kd lm ln ol kg lp lq om ls lt lu on lw lx ly oo ma mb mc im bi translated">结构模式以多种方式影响应用程序，例如，适配器模式使两个不兼容的系统能够通信，而外观模式使您能够向用户呈现一个简化的界面，而无需删除系统中所有可用的选项。</p><p id="4a7a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很简单，对吧？</p></div></div>    
</body>
</html>