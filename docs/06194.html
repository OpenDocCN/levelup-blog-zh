<html>
<head>
<title>5 Tricks That Will Help You Debug Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助你调试Python代码的5个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-tricks-that-will-help-you-debug-python-code-7ac10f7837a3?source=collection_archive---------11-----------------------#2020-11-02">https://levelup.gitconnected.com/5-tricks-that-will-help-you-debug-python-code-7ac10f7837a3?source=collection_archive---------11-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/72c15d6ecf842f7c1e98a2571a353f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wld7NH_r9FFYhVfPSa6uBA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Unsplash上的<a class="ae kf" href="https://unsplash.com/@joszczepanska" rel="noopener ugc nofollow" target="_blank"> @joszczepanska </a></figcaption></figure><p id="0f0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调试是程序员的一项基本技能，它是一门手艺，我们需要练习才能做得更好。在这里，我总结了调试Python代码的有用技巧和工具。</p><h1 id="8a32" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">#1查看函数或对象的源代码</h1><p id="bc60" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">了解实现的细节在调试中至关重要。在调试Python代码时，您可能想知道模块、类、方法、函数、回溯、帧或代码对象的源代码。<strong class="ki iu"> <em class="mh">视</em> </strong>模块将帮助您:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="85e6" class="mr lf it mn b gy ms mt l mu mv">import inspect<br/>def add(x, y):<br/>    return x + y</span><span id="8404" class="mr lf it mn b gy mw mt l mu mv">class Dog:<br/>    kind = 'dog'         # class variable shared by all instances<br/>    def __init__(self, name):<br/>        self.name = name    # instance variable unique to each instance</span><span id="be61" class="mr lf it mn b gy mw mt l mu mv">    def eat(food):<br/>        print("eating ..." + food)</span><span id="3acd" class="mr lf it mn b gy mw mt l mu mv">print(inspect.getsource(add))    <br/>print(inspect.getsource(Dog))<br/>print(inspect.getsource(Dog.eat))</span></pre><h1 id="5d36" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">#2将日志打印到文件中</h1><p id="bc6e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><em class="mh">日志</em>是我们理解代码运行时最重要的线索。打印日志是跟踪程序执行流程的一种有用方式。</p><p id="5308" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，Python中的<em class="mh"> print </em>只输出到一个终端。对于复杂的故障排除，尤其是对于服务器端应用程序来说，这还远远不够理想。</p><p id="2a6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python 3中的<em class="mh"> print </em>函数要强大得多，因为它可以接受更多的参数，指定一些参数可以将print的内容输出到一个日志文件中。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e3e2" class="mr lf it mn b gy ms mt l mu mv">with open('test.log', mode='w') as f:<br/>    print('hello, python', file=f, flush=True)</span></pre><p id="051c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个有用且灵活的模块是<em class="mh">日志</em>，我们可以设置输出文件名、日志格式等..</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b5c9" class="mr lf it mn b gy ms mt l mu mv">import logging</span><span id="42ca" class="mr lf it mn b gy mw mt l mu mv">logging.basicConfig(filename='app.log', filemode='w', <br/>		format='%(name)s - %(levelname)s - %(message)s')<br/>a = 5<br/>b = 0<br/>try:<br/>  c = a / b<br/>except Exception as e:<br/>  logging.exception("Exception occurred")</span></pre><p id="4426" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多用法请参考<a class="ae kf" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">日志记录— Python日志记录工具— Python 3.9.0文档</a></p><h1 id="f283" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">#3跟踪执行时间</h1><p id="3ecb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于性能问题，我们需要计算函数的运行时间。您可能会这样实现它:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f212" class="mr lf it mn b gy ms mt l mu mv">import time</span><span id="e29f" class="mr lf it mn b gy mw mt l mu mv">start = time.time()<br/># run the function<br/>end = time.time()</span><span id="5b59" class="mr lf it mn b gy mw mt l mu mv">print(end-start)</span></pre><p id="2244" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一个名为<em class="mh"> timeit </em>的内置模块，我们可以用它来跟踪时间，只需一行代码:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1abd" class="mr lf it mn b gy ms mt l mu mv">import time<br/>import timeit</span><span id="9c08" class="mr lf it mn b gy mw mt l mu mv">def run_sleep(second):<br/>    print(second)<br/>    time.sleep(second)</span><span id="e1f0" class="mr lf it mn b gy mw mt l mu mv">print(timeit.timeit(lambda :run_sleep(2), number=1))</span></pre><h1 id="fde6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">#4交互式调试</h1><p id="2234" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">REPL支持增量的、交互式的开发风格，交互式调试是一种更有效的方式。理想的工作流程是编辑-运行的重复过程。</p><p id="76d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要用交互式会话调用程序，我们需要添加<em class="mh">-I</em>选项:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="142f" class="mr lf it mn b gy ms mt l mu mv">python -i demo.py</span></pre><p id="e49b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让您的生活更轻松，<em class="mh">import lib . reload(module)</em>是避免重新启动交互会话的合适方法。</p><p id="398b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子，假设我们正在运行一个名为demo的函数，为了解决一个问题，我们需要对这个函数进行一些修改，然后<em class="mh"> reload(module) </em>将加载修改后的demo版本，而无需重启我们的会话:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5c91" class="mr lf it mn b gy ms mt l mu mv">&gt;&gt;&gt; from importlib import reload<br/>&gt;&gt;&gt; import demo from module<br/>&gt;&gt;&gt; demo()<br/>"The result of demo..."</span><span id="e241" class="mr lf it mn b gy mw mt l mu mv"># Make some changes to "demo"<br/>&gt;&gt;&gt; demo()<br/>"The result of demo..."  # The Outdated result<br/>&gt;&gt;&gt; reload(module)  # Reload "module" after changes made to "demo"<br/>&gt;&gt;&gt; demo()<br/>"This will be the new result..."</span><span id="c2d8" class="mr lf it mn b gy mw mt l mu mv">&gt;&gt;&gt; # repeat the circle of fix-and-retry</span></pre><p id="44cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将为调试节省大量时间。</p><h1 id="ccc7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">#5使用pdb</h1><p id="0281" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Python有一个模块叫做<strong class="ki iu"> <em class="mh"> pdb </em> </strong>支持交互式源代码调试器。它支持设置断点，在线级单步执行。另外，<strong class="ki iu"> <em class="mh"> pdb </em> </strong>打印检查堆栈帧、变量值、检查源代码等。</p><p id="e099" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用调试器启动程序，请添加-m <strong class="ki iu"> pdb </strong>选项来调用脚本:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bc1e" class="mr lf it mn b gy ms mt l mu mv">user@coderscat:~/snippets$ python3.7 -m pdb demo.py <br/>&gt; /home/user/snippets/demo.py(1)&lt;module&gt;()<br/>-&gt; import inspect<br/>(Pdb) l<br/>  1  -&gt; import inspect<br/>  2  <br/>  3     def gcd(a,b):<br/>  4         if(b==0):<br/>  5             return a<br/>  6         else:<br/>  7             return gcd(b,a%b)<br/>  8  <br/>  9  <br/> 10     print(gcd(34, 34))<br/>[EOF]<br/>(Pdb) b demo.py:3<br/>Breakpoint 1 at /home/user/snippets/demo.py:3<br/>(Pdb) c<br/>&gt; /home/user/snippets/demo.py(3)&lt;module&gt;()<br/>-&gt; def gcd(a,b):<br/>(Pdb) step<br/>&gt; /home/user/snippets/demo.py(10)&lt;module&gt;()<br/>-&gt; print(gcd(34, 34))<br/>(Pdb)</span></pre><p id="b235" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从正在运行的程序中断调试器的另一个典型用法是插入:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3225" class="mr lf it mn b gy ms mt l mu mv">import pdb; pdb.set_trace()<br/></span></pre><p id="9b70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一些有用的<em class="mh"> pdb </em>命令</p><ul class=""><li id="80ae" class="mx my it ki b kj kk kn ko kr mz kv na kz nb ld nc nd ne nf bi translated">list(l):显示Python解释器当前所在的代码行</li><li id="b9b4" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">步骤:继续逐行执行，单步执行函数</li><li id="dce6" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">next(n):继续下一行代码</li><li id="8175" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">break(b):在当前行设置新的断点</li><li id="d4cc" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">继续(c):继续执行，直到下一个断点</li></ul><p id="3072" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在大多数情况下，我们不需要遵循执行中的每一步，<em class="mh"> pdb </em>是调试Python程序的终极工具。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="f44c" class="le lf it bd lg lh ns lj lk ll nt ln lo lp nu lr ls lt nv lv lw lx nw lz ma mb bi translated">结论</h1><p id="0f15" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当您调试Python代码时，尝试一下这些技巧和工具。提高你的调试技巧，熟能生巧！</p></div></div>    
</body>
</html>