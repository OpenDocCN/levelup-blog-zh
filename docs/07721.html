<html>
<head>
<title>Handle 404 pages for nested routes in react-router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">react-router中嵌套路由的404页处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handle-404-pages-for-nested-routes-in-react-router-2b31572a5b2f?source=collection_archive---------13-----------------------#2021-03-07">https://levelup.gitconnected.com/handle-404-pages-for-nested-routes-in-react-router-2b31572a5b2f?source=collection_archive---------13-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/16a3f2aa4435d592a29eab99cfa54b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mE038tUxsvyLiDBz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">埃里克·麦克林在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1242" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React路由器是React社区中使用最多的路由器之一。</p><p id="985b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它允许我们以嵌套的形式写“路线”。路由只不过是反应组件。当我们想要基于条件显示页面的子部分时，嵌套路由有优势。嵌套路由还会导致更少的重新装载，因为只有嵌套路由的内容会再次装载。</p><p id="b6bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我们为什么需要嵌套路由</strong></p><p id="8f9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有这样一个路线系统:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0304" class="lk ll iq lg b gy lm ln l lo lp">&lt;Router&gt;</span><span id="dc3b" class="lk ll iq lg b gy lq ln l lo lp">&lt;Route path="/checkout/passengerdetails"&gt;&lt;ComponentA /&gt;&lt;/Route&gt;</span><span id="fe3a" class="lk ll iq lg b gy lq ln l lo lp">&lt;Route path="/checkout/baggage"&gt;&lt;ComponentB /&gt;&lt;/Route&gt;</span><span id="a11e" class="lk ll iq lg b gy lq ln l lo lp">&lt;/Router&gt;</span></pre><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lr"><img src="../Images/47b3186495af9d31560eb5a6c0cd1eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfDImcOgqDLUx1CU4CBZSA.png"/></div></div></figure><p id="54a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们没有嵌套路由，整个“ComponentA”将被卸载，而“ComponentB”将被装载。</p><h1 id="0b6b" class="ls ll iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">这样好吗？</h1><p id="0f21" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">嗯，是你对性能的热爱超过了对写作的轻松程度。我可以肯定地说，这种写路线的方式既简单又直接。</p><p id="5c4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这种路由存在什么问题呢？</p><p id="56c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的图中，我给了组件颜色，请注意两条路线之间的公共颜色框。两条路线之间只有中间部分发生了变化。</p><p id="8a7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从“/checkout/passengerdetails”到“/ check out/laugh”的路线改变导致所有组件的完全卸载，即使对于不需要随着路线改变的组件也是如此。</p><p id="b020" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这正是嵌套路由非常有用的情况。</p><p id="a489" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写如下路径来防止卸载整个页面:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="bc16" class="lk ll iq lg b gy lm ln l lo lp">function SomeComponent() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;CommonUI /&gt;<br/>      &lt;Switch&gt;<br/>        &lt;Route path="passengerdetails"&gt;<br/>          &lt;PassengerDetails /&gt;<br/>        &lt;/Route&gt;<br/>        &lt;Route path="baggage"&gt;<br/>          &lt;Baggage /&gt;<br/>        &lt;/Route&gt;<br/>      &lt;/Switch&gt;<br/>      &lt;Footer /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span><span id="2ae1" class="lk ll iq lg b gy lq ln l lo lp">function App() {<br/>  return (<br/>    &lt;Router&gt;<br/>      &lt;Route path="/checkout"&gt;<br/>        &lt;SomeComponent /&gt;<br/>      &lt;/Route&gt;<br/>    &lt;/Router&gt;<br/>  );<br/>}</span></pre><p id="6e40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，在上面的例子中，当路由改变时,‘common ui’和‘footer’不会卸载。</p><p id="74a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是嵌套路由可以实现的简单要点。</p><h1 id="c8b2" class="ls ll iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">嵌套路由挑战</strong></h1><p id="181c" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">嵌套路由的主要挑战之一是处理“未找到”页面。现在，由于路由是嵌套的，所以没有一个位置来保存“未找到”路由。您必须将未找到的路由放在嵌套路由的最末端。</p><p id="c363" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">见下图了解更多。</p><p id="5e1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们目前有以下路由结构。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/ed22f456dd6033e9d0b7f99cd473fbc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qEUuy58uaADdE48blG8yTQ.png"/></div></div></figure><p id="c43f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们假设我们点击了类似如下的URL:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/514b92ca0ddcf6215056f547786104b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpNJTJfa9EqdNlplLKs8gA.png"/></div></div></figure><p id="2cf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有匹配的路由，您将如何处理这些路由以显示404自定义屏幕？</p><p id="9601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在树形图中的每个分支的末尾添加“NotFound”组件。下图展示了:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5cdc3fcd8129f2436e5562d3213d5025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-12BrxQsEp_H6yBwHFHsw.png"/></div></div></figure><p id="8999" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种解决方案可以工作，但它不是最好的，因为它有一个主要缺点:</p><p id="cceb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你引入的任何新的路线分支，你都必须在最后加上“没有找到”的成分。所以表面积越大，出错的机会就越多。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><blockquote class="ne nf ng"><p id="6849" class="kd ke nh kf b kg kh ki kj kk kl km kn ni kp kq kr nj kt ku kv nk kx ky kz la ij bi translated"><strong class="kf ir">我们能做些什么来解决这个问题？。我们的目标如下:</strong></p></blockquote><p id="45f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.一种集中处理404页的方式。</p><p id="cf0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.应该不需要手动添加“未找到”路线。</p><h2 id="da53" class="lk ll iq bd lt nl nm dn lx nn no dp mb ko np nq mf ks nr ns mj kw nt nu mn nv bi translated"><strong class="ak">解决方案</strong></h2><p id="f75a" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">如果我们能编写一个自定义的`自定义开关'组件，在每个路由分支的末尾自动添加一个`未找到'路由，我们就能做到这一点。因此，我们将在任何地方使用“自定义开关”,而不是react-router-dom中的“开关”组件</p><p id="6b6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个简单的组件将如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3a76" class="lk ll iq lg b gy lm ln l lo lp">import { Switch, useRouteMatch } from "react-router-dom";</span><span id="fdc6" class="lk ll iq lg b gy lq ln l lo lp">function NotFoundPage({ CustomNotFoundPage }) {<br/>  const history = useHistory();<br/>  useEffect(() =&gt; {<br/>    history.push("/notfoundpage");<br/>  }, []);<br/>  return null;<br/>}</span><span id="5f8c" class="lk ll iq lg b gy lq ln l lo lp">function CustomSwitch(props) {<br/>  const { children } = props;<br/>  return (<br/>    &lt;Switch&gt;<br/>      {children}<br/>      &lt;NotFoundPage /&gt;<br/>    &lt;/Switch&gt;<br/>  );<br/>}</span></pre><p id="1a5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及在我们的应用程序中所有路由的顶部的“未找到”路由。最好是你渲染基本路线的地方。</p><p id="1d28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以在组件中使用“useRouteMatch”来检查是否呈现“未找到”。</p><h2 id="d724" class="lk ll iq bd lt nl nm dn lx nn no dp mb ko np nq mf ks nr ns mj kw nt nu mn nv bi translated"><strong class="ak">总结一下:</strong></h2><p id="1b70" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">CustomSwitch将在每个“Switch”块的末尾添加“Notfound”路由。无需手动添加未找到的路线。由于我们在NotFound组件中编写的逻辑，无论何时呈现一个Not found组件，它都将重定向到“/notfoundpage”</p><p id="fb87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是示例的codesandbox链接:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d7ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在同一级别上有两个“CustomSwitch”组件会怎么样？那么第一个“自定义开关”可能会把你扔到“未找到”页面。但是这个场景，我在做应用的时候从来没有遇到过。为了清楚起见，在这里指出来。</p><p id="edf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前就这些。当我写这篇文章的时候，有一个我可以想到的解决方法。</p><p id="d407" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢谢，请在评论中告诉我你喜欢什么，不喜欢什么。</p></div></div>    
</body>
</html>