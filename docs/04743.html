<html>
<head>
<title>The Principles Behind MobX and Reactive Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MobX和反应式编程背后的原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-principles-behind-mobx-and-reactive-programming-4c43e73742e7?source=collection_archive---------12-----------------------#2020-07-12">https://levelup.gitconnected.com/the-principles-behind-mobx-and-reactive-programming-4c43e73742e7?source=collection_archive---------12-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="faae" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">MobX是一个久经考验的库，它通过透明地应用函数式反应式编程使状态管理变得简单和可伸缩。</p></blockquote><p id="bb70" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">为了理解mobx的核心概念，我们应该首先深入了解函数式反应式编程。</p><h1 id="d1a5" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">功能反应式编程</h1><p id="1709" class="pw-post-body-paragraph jq jr iq jt b ju lq jw jx jy lr ka kb kp ls ke kf kq lt ki kj kr lu km kn ko ij bi translated"><strong class="jt ir">函数式编程</strong>是使用<strong class="jt ir">纯函数</strong>和<strong class="jt ir">不可变数据结构</strong>开发应用程序的范例，并且没有<strong class="jt ir">副作用</strong>。纯函数总是为相同的给定输入返回相同的输出，并且不对其函数范围之外的变量进行操作。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9924" class="me kt iq ma b gy mf mg l mh mi"><strong class="ma ir">// Pure function</strong><br/>function result(a, b){<br/>  return a + b<br/>}</span><span id="7601" class="me kt iq ma b gy mj mg l mh mi">result(3,5); </span><span id="bff7" class="me kt iq ma b gy mj mg l mh mi"><strong class="ma ir">// Impure function</strong><br/>const c = 6;</span><span id="e4f5" class="me kt iq ma b gy mj mg l mh mi">function result(a,b){<br/>   return a + b + c;<br/>}</span><span id="31d8" class="me kt iq ma b gy mj mg l mh mi">result(3,5)</span></pre><p id="562c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">函数式编程是一种理想的编程解决方案，它提供了可预测性，并且不容易出错。</p><p id="bf12" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">然而，如果没有可变的数据结构和副作用，很难构建真实世界的程序。如果一个行为的影响超出了它发生的范围，我们称之为副作用。典型的副作用可能是渲染、网络请求、文件操作、CLI / log输出等。我们可以使用<strong class="jt ir">函数式反应编程</strong>来有效地控制副作用，同时仍然在一定程度上保留函数式编程原则。</p><blockquote class="mk"><p id="dc07" class="ml mm iq bd mn mo mp mq mr ms mt ko dk translated">反应式编程是关于控制副作用的</p></blockquote><p id="40ba" class="pw-post-body-paragraph jq jr iq jt b ju mu jw jx jy mv ka kb kp mw ke kf kq mx ki kj kr my km kn ko ij bi translated"><strong class="jt ir">函数式反应式编程</strong>的本质是在声明的时候完全指定一个值的动态行为。让我们考虑一个电子表格应用程序。在电子表格中，变量是单元格。如果电子表格中的任何单元格发生更改，引用该单元格的任何单元格也会随之更改。</p><h1 id="675c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">被动编程与反应式编程</h1><p id="9426" class="pw-post-body-paragraph jq jr iq jt b ju lq jw jx jy lr ka kb kp ls ke kf kq lt ki kj kr lu km kn ko ij bi translated">在被动编程中，两个组件之间的关系是一个组件通常控制另一个组件。</p><figure class="lv lw lx ly gt na gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/59da91dd96148ed2ee625623a2bb2f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*51rr-6H6bTN3bc9HmudRPg.jpeg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">被动编程。参考:<a class="ae nh" href="http://dontpanic.42.nl/2016/07/reactive-programming.html" rel="noopener ugc nofollow" target="_blank">http://dontpanic.42.nl/2016/07/reactive-programming.html</a></figcaption></figure><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="3076" class="me kt iq ma b gy mf mg l mh mi">Car.prototype.turnKey = <strong class="ma ir">function</strong>() {   <br/>  <strong class="ma ir">this</strong>.engine.fireUp(); <br/>}</span></pre><p id="d9be" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在反应式编程中，这种关系是相反的。组件本身负责控制它的值和行为。</p><figure class="lv lw lx ly gt na gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/04aca3d6e42d1c3947530348c28014d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*c6h9Kjohc5OFpdvLnd6WDQ.jpeg"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">无功编程，参考:<a class="ae nh" href="http://dontpanic.42.nl/2016/07/reactive-programming.html" rel="noopener ugc nofollow" target="_blank">http://dontpanic.42.nl/2016/07/reactive-programming.html</a></figcaption></figure><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="524d" class="me kt iq ma b gy mf mg l mh mi">Engine.listenToKey = <strong class="ma ir">function</strong>(car) {   <br/>  car.onKeyTurned(() =&gt; {     <br/>    <strong class="ma ir">this</strong>.fireUp();   <br/>  }); <br/>}</span></pre><h1 id="07b6" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">观察者模式</h1><p id="eaf7" class="pw-post-body-paragraph jq jr iq jt b ju lq jw jx jy lr ka kb kp ls ke kf kq lt ki kj kr lu km kn ko ij bi translated">以这种模式。我们有一个<strong class="jt ir">制作人</strong>来保存订阅它的听众列表。<strong class="jt ir">每当生产者的状态改变时，监听器</strong>被通知。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="da9d" class="me kt iq ma b gy mf mg l mh mi">function Producer(){<br/> this.listeners = [];<br/>}</span><span id="782b" class="me kt iq ma b gy mj mg l mh mi">Producer.prototype.add = function(listener){<br/> this.listeners.push(listener);<br/>}</span><span id="a8a1" class="me kt iq ma b gy mj mg l mh mi">Producer.prototype.remove = function(listener){<br/> var index = this.listeners.indexOf(listener);<br/> this.listeners.splice(index,1);<br/>}</span><span id="cffa" class="me kt iq ma b gy mj mg l mh mi">Producer.prototype.notify = function(message){<br/> this.listeners.forEach(function(listener){<br/>  listener.update(message);<br/>})<br/>}</span><span id="b120" class="me kt iq ma b gy mj mg l mh mi">var listener1 = {<br/> update: function(message){<br/>  console.log('message')<br/> }<br/>}</span><span id="6b9d" class="me kt iq ma b gy mj mg l mh mi">var notifier = new Producer();<br/>notifier.add(listener1);<br/>notifer.notify("Hello World");</span></pre><h1 id="b743" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">可观察量</h1><p id="6e41" class="pw-post-body-paragraph jq jr iq jt b ju lq jw jx jy lr ka kb kp ls ke kf kq lt ki kj kr lu km kn ko ij bi translated">一个可观察对象按顺序发出它的值，但是不是消费者请求下一个值，而是可观察对象在它们变得可用时推给消费者。即。发出值并将它们推送给它的侦听器。可观察是一个序列，其项目随着时间的推移变得可用。当一个观察者订阅一个可观察对象时，它将收到序列中的值，因为它们变得可用，而不必请求它们。下面是一个使用<a class="ae nh" href="https://github.com/Reactive-Extensions/RxJS" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> RxJS库</strong> </a> <strong class="jt ir">的可观察的例子。</strong></p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="e688" class="me kt iq ma b gy mf mg l mh mi">var source = Rx.Observable.fromEvent(document.body, 'mousemove');</span><span id="0746" class="me kt iq ma b gy mj mg l mh mi">source.subscribe(val =&gt; console.log(val),<br/> e =&gt; console.log(e),<br/> () =&gt; console.log('completed')<br/>);</span><span id="32db" class="me kt iq ma b gy mj mg l mh mi">source.subscribe(val =&gt; {<br/>  console.log(`x: ${val.offsetX} &amp; y: ${val.offsetY}`)<br/>  },<br/>  e =&gt; console.log(e),<br/> () =&gt; console.log('completed')<br/>);</span></pre><p id="0ef2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们可以创建<strong class="jt ir">鼠标移动</strong>事件序列的可观察对象，监听观察者变化的观察者可以对事件做出反应。</p><h1 id="6e58" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">MobX</h1><blockquote class="mk"><p id="238b" class="ml mm iq bd mn mo mp mq mr ms mt ko dk translated"><em class="ni">任何可以从应用程序状态派生的东西，都应该被派生。自动地。</em></p></blockquote><figure class="nk nl nm nn no na gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nj"><img src="../Images/4e844dcc1056b749f3a36c43700984d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_if0WfJ6sJZyKvh5M8rvA.png"/></div></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">MobX流程图</figcaption></figure><div class="lv lw lx ly gt ab cb"><figure class="nt na nu nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><img src="../Images/a929a962c3f34655f6869e1f2aafdd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*Olx98eZaQokUPEMPPQjK6Q.png"/></div></figure><figure class="nt na nz nv nw nx ny paragraph-image"><img src="../Images/8d2565861a6c0abcbcdd664c1d39ff05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*77ml_ZxuXoSQnGgZqotX8w.png"/><figcaption class="nd ne gj gh gi nf ng bd b be z dk oa di ob oc translated">MobX Flow Ref:<a class="ae nh" href="https://www.packtpub.com/sites/default/files/downloads/MobXQuickStartGuide_ColorImages.pdf" rel="noopener ugc nofollow" target="_blank">https://www . packtpub . com/sites/default/files/downloads/MobXQuickStartGuide _ color images . pdf</a></figcaption></figure></div><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9943" class="me kt iq ma b gy mf mg l mh mi">const { observable, autorun } = require("mobx");</span><span id="ac69" class="me kt iq ma b gy mj mg l mh mi">const todoStore = observable({<br/>/* some observable state */<br/>  todos: [],<br/>  /* a derived value */<br/>  <strong class="ma ir">get</strong> computedCount() {<br/>    <strong class="ma ir">return this</strong>.todos.filter((todo) =&gt; todo.completed).length;<br/>  },<br/>});</span><span id="b57f" class="me kt iq ma b gy mj mg l mh mi">/* a function that observes the state */<br/>autorun(<strong class="ma ir">function</strong> () {<br/>  console.log(<br/>    `Completed ${todoStore.computedCount} of  ${todoStore.todos.length}`);<br/>});</span><span id="b1a5" class="me kt iq ma b gy mj mg l mh mi">/* ..and some actions that modify the state */<br/>todoStore.todos[0] = {<br/>  title: "Take walk",<br/>  completed: false<br/>};<br/>// synchronously prints 'Completed 0 of 1 items'</span><span id="19eb" class="me kt iq ma b gy mj mg l mh mi">todoStore.todos[0].completed = true;<br/>// synchronously prints 'Completed 1 of 1 items'</span></pre><ol class=""><li id="6264" class="od oe iq jt b ju jv jy jz kp of kq og kr oh ko oi oj ok ol bi translated"><strong class="jt ir">定义状态并使其可观察</strong></li></ol><p id="b36e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们可以用<code class="fe om on oo ma b">observable</code>的方法把我们的状态变成可观测的变量。它为我们的状态对象创建了一个<strong class="jt ir">代理对象</strong>,它可能有任何嵌套层次。正在跟踪通过代理对对象的访问，包括读和写。可观察到的<code class="fe om on oo ma b">todos</code>如下所示:</p><figure class="lv lw lx ly gt na gh gi paragraph-image"><div class="gh gi op"><img src="../Images/12d34d04cb45f03d48f450a764190930.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*_FU18GZDAsfYxIqnN7-0Fg.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">普通todos阵列</figcaption></figure><figure class="lv lw lx ly gt na gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ff3eb914a2ef554db1bfa9a0d899b945.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*6hRZ7smT7ShoXzBn3FWgnA.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">使用代理对象可观察到的todos</figcaption></figure><p id="4d70" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">注意:</strong><code class="fe om on oo ma b">Proxy</code>对象包装另一个对象并拦截操作，比如读/写属性和其他，可选地自己处理它们，或者透明地允许对象处理它们。您可以在本文中学习编写代理对象的实际用例:<br/><a class="ae nh" href="https://czaplinski.io/blog/make-your-own-mobx/" rel="noopener ugc nofollow" target="_blank">https://czaplinski.io/blog/make-your-own-mobx</a></p><p id="0b4f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">2.<strong class="jt ir">处理派生</strong></p><p id="5321" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">任何可以从状态中导出而不需要任何进一步相互作用的东西都是导出。如果影响它的任何值发生变化，上面示例中的计算值将自动从状态中导出。</p><p id="351d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">3.<strong class="jt ir">使用动作改变状态</strong></p><p id="e0e8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">动作是改变状态的任何一段代码。</p><p id="eb95" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">4.<strong class="jt ir">处理副作用</strong></p><p id="07c0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在这个例子中，存储更新的副作用是在<code class="fe om on oo ma b">autorun</code>方法中执行的。autorun方法会在每次更新存储值时自动运行。</p><figure class="lv lw lx ly gt na gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi or"><img src="../Images/b7a020175ed0c284e900f3b4b1c0f8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*2YaxRQRzmV9T4wVgtGK71Q.jpeg"/></div></div></figure><h1 id="ff2c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">与Redux的差异</h1><p id="56b0" class="pw-post-body-paragraph jq jr iq jt b ju lq jw jx jy lr ka kb kp ls ke kf kq lt ki kj kr lu km kn ko ij bi translated">Redux实现不可变存储。redux中的操作负责对存储进行更改。还原器是纯函数，每次状态改变时总是返回一个新的状态。</p><p id="90c0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">相反，mobx实现了带有数据更改传播的可变存储。这些操作负责对商店进行更改。然而，商店可以直接变异，没有行动。MobX遵循可观察的可变数据结构来实现状态生命周期和跟踪变化。</p><h2 id="62cb" class="me kt iq bd ku os ot dn ky ou ov dp lc kp ow ox lg kq oy oz lk kr pa pb lo pc bi translated"><strong class="ak">参考文献</strong></h2><ul class=""><li id="fcd2" class="od oe iq jt b ju lq jy lr kp pd kq pe kr pf ko pg oj ok ol bi translated">https://mobx.js.org<a class="ae nh" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"/></li><li id="f1a7" class="od oe iq jt b ju ph jy pi kp pj kq pk kr pl ko pg oj ok ol bi translated"><a class="ae nh" href="https://pragprog.com/titles/smreactjs5/" rel="noopener ugc nofollow" target="_blank">通过Packt用RxJS </a>进行反应式编程</li><li id="61d6" class="od oe iq jt b ju ph jy pi kp pj kq pk kr pl ko pg oj ok ol bi translated"><a class="ae nh" href="https://www.youtube.com/watch?v=NBYbBbjZeX4" rel="noopener ugc nofollow" target="_blank"> Michel Weststrate — MobX与可预测性和速度的独特共生关系</a></li><li id="fc6c" class="od oe iq jt b ju ph jy pi kp pj kq pk kr pl ko pg oj ok ol bi translated"><a class="ae nh" href="https://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming" rel="noopener ugc nofollow" target="_blank">什么是(函数式)反应式编程？</a></li><li id="81c8" class="od oe iq jt b ju ph jy pi kp pj kq pk kr pl ko pg oj ok ol bi translated"><a class="ae nh" href="http://dontpanic.42.nl/2016/07/reactive-programming.html" rel="noopener ugc nofollow" target="_blank">后MVC第6部分:反应式编程</a></li></ul><p id="8277" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">谢了。如果你有反馈，请在评论中告诉我。</p></div></div>    
</body>
</html>