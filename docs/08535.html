<html>
<head>
<title>The Heart of Blockchains — Hash Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链的心脏——哈希函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-heart-of-blockchains-hash-functions-501d0b32762b?source=collection_archive---------0-----------------------#2021-05-10">https://levelup.gitconnected.com/the-heart-of-blockchains-hash-functions-501d0b32762b?source=collection_archive---------0-----------------------#2021-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edf6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">哈希函数是区块链技术的核心。为什么它们如此重要，它们是如何工作的？使用了什么散列函数什么是Merkle树？开门见山，这就是我们要看的。</h2></div><h2 id="5b47" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">不变性和信任引擎:散列函数</h2><p id="71f3" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">我们在以前的文章中已经讨论过，区块链是一个分布式和不可变的数据库，但是这是如何实现的呢？</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/7905d1c40ed7ab0deac257eed11cda84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*fhyt7UbNb27GWaUGuNa1aA.png"/></div></figure><p id="16b7" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">区块链中的每个块通过散列机制</strong>链接到前一个块。每个块包含前一个块中数据的<strong class="lg iu">散列</strong>，创建了一个相互链接的块链。不能改变块的顺序或改变任何数据，因为如果块被改变，块的散列将改变，将其标记为无效。这就是区块链不变性的来源。任何更改都会被自动检测到并失效，因为它与哈希不匹配。</p><p id="6036" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">每个块在块头中包含前一个块散列(包括前一个块事务)。<strong class="lg iu">此外，块还包含块中包含的事务，通常以Merkle树的形式。这个Merkle树散列包含在块头中。</strong>交易可以是金融交易，也可以是事件，即交易不一定需要转移价值。它可以是资产的转移或简单的数据转移。</p><h2 id="aaee" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Merkle根</h2><p id="4d06" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">hashMerckeRoot是区块链大多数街区使用的田地。Merkle根就像块中所有事务的指纹。它来自梅克尔树。它们在密码学中被广泛使用，在区块链发明之前就已经被使用了。1979年，这些树以拉尔夫·默克尔的名字命名。它们是验证共享数据未被更改、破坏或篡改的基本方法。</p><p id="8a45" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">Merkle树也是一种验证区块链中数据有效性的轻量级方法。例如，如果你在手机上使用比特币钱包，你的钱包不需要下载所有的区块链交易来验证它们。带有Merkle根的Merkle树将验证所有以前的事务。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/0c4c438013e93522721969bd71952987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*dETS0am9TeI76asBOY1Jyw.png"/></div></figure><p id="daa3" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">Merkle树结果或Merkle根基本上是所有事务的散列的散列。你可以把它想象成一棵树，树叶就是区块链的交易。这些叶子被散列成分支，这些分支被散列到根。Merkle树是递归构建的，即它是由Merkle树中的叶子的散列产生的，这些叶子又对应于事务。</p><p id="3d64" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">Merkle根是通过散列这些被称为叶子的单个事务来求解的。附加的叶对被散列以创建可以对应于区块链网络中的事务的附加叶节点。</p><p id="8fa4" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">虽然Merkle树可以从大量的事务中创建，但是<strong class="lg iu"> Merkle根总是对应于32字节的字符串或256位的</strong>(例如，SHA256散列算法总是输出32字节的固定长度，而不管输入的大小)。<strong class="lg iu">这样，我们可以使用小到32字节的东西来验证一些事务——可能是数千个——是不可变的。</strong></p><h2 id="3a10" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">哈希函数特征</h2><p id="1e16" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">散列函数接受任何大小的输入值，并创建固定长度的输出。无论输入有多大，输出总是有相同的大小。如果输入值有任何变化，输出会自动改变。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/ca47cd21f73aced2d6cf5a77c3d74e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*NXvnIca9U5IYzaMl_QBzgg.png"/></div></figure><p id="23b0" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">任何东西都可以被散列。区块链交易，威廉莎士比亚全集，阿特拉斯耸耸肩，一个图像或者一个文档，hash输出总是一样的大小，有特定的特征。SHA-256、SHA-3和Keccak在几个区块链中被广泛使用，它产生256位(32字节)大小的散列(输出)。</p><p id="abc7" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">让我们来看看哈希函数的特征:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/9de09679bab473e30baef7c0c641bc5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*dAekp6ClVAIkIwLZ4oiXpg.png"/></div></figure><p id="6930" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">计算效率</strong>:计算或验证一个hash不需要很多计算资源。</p><p id="33c3" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">确定性</strong>:只要输入相同，hash的输出总是相同的。如果我将一张特定的猫照片哈希1000000次，输出将始终相同。然而，如果我改变猫照片中的一个像素，输出(散列字符串)将完全不同。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/2cbedb6009249d3a26a4a75deba71c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*_lIXougaUsl2WI9Bf8QJWQ.png"/></div></figure><p id="bc8c" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">在这个截图中，我们检查一个句子的SHA256散列输出是什么。您可以看到，改变句子中的一个字母会完全改变散列输出。</p><p id="da95" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">抗冲突</strong>:两个不同的输入极不可能有相同的散列输出。SHA256有2个⁵⁶结果，这是一个非常大的数字:</p><p id="3d2f" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi">2²⁵⁶ = 11579208923731619542357098500868790785326998466564039457584007913129639936</p><p id="0ffb" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">那是一个75位数的数字！发现碰撞的几率是115万分之一。宇宙“仅仅”在大爆炸发生的4351968000000000秒前被创造出来。</p><p id="2b63" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">2⁵⁶2.66⁵⁵比宇宙的年龄大多少秒😂</p><p id="e6eb" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">抗前镜像:</strong>无法将哈希的输出转换为输入。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/b14bc92e565ad4568b0a866a78e765f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*-0rkHY7aUnKAyYjd9V9uIQ.png"/></div></figure><p id="d6bc" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">散列的输出并不揭示输入的任何信息。目前不可能发现某个散列输出的输入是什么。即使是量子计算机也会发现这项任务非常困难。</p><p id="9196" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">消化什么是散列，散列是散列函数返回的输出。无论文件、文本或输入哈希函数的事务有多大，输出总是有固定的长度。如果输入改变了一个字母，输出散列将会不同。</p><h1 id="f40a" class="ml kj it bd kk mm mn mo kn mp mq mr kq jz ms ka ku kc mt kd ky kf mu kg lc mv bi translated">哈希算法…变得非常严肃</h1><p id="b8ce" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">SHA —安全散列算法</p><p id="df72" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">我告诉过你我喜欢这个杂碎吗？在本文中，我们已经简要介绍了哈希算法，但是现在让我们来分解主要的哈希算法。</p><p id="9fdb" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">SHA对应于美国NIST国家标准与技术研究所开发的几种算法。SHA哈希算法具有哈希算法需要具备的主要特征。它们是抗前映像的，这意味着很难(或不可能)将散列的输出反转为原始输入。比如“我爱在公园里跳的狗”这句话的SHA1 hash是03d 6 FD 883 EDC 045071 efb F5 e 48 f 56811090 fdad 4，但是我们永远无法单独从hash输出中得到输入。在每个哈希算法中，这个n位哈希总是具有相同的长度，这是一个单向的抗冲突机制，这意味着从两个不同的输入中获得相同的哈希是极不可能的。SHA哈希算法用于签署包括比特币在内的区块链交易，并在计算机科学中有多种用途，如证书签名。一些散列算法对于输入消息可能具有限制大小，并且所有这些算法将总是具有相同大小的消息摘要，即散列结果。</p><p id="58af" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu"> SHA-0 </strong></p><p id="4f00" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">Sha-0是最初的Sha系列哈希算法。它的摘要大小为160位。它很快被SHA-1取代，虽然也是160位，但更安全。加密密钥中不再使用SHA-0</p><p id="dc2c" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu"> SHA-2 </strong></p><p id="1394" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">SHA-1发布后不久，SHA-2就开始标准化不同的输出大小。来自沙-224，SHA-256，沙-12和其他。</p><p id="91b0" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu"> SHA-256 </strong></p><p id="8934" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">SHA-256允许更大的最大消息大小，即2⁶⁴比特、256比特的摘要大小、512比特的块大小和32比特的字大小。别担心，这比哈希<em class="mw">莎士比亚全集</em>、<em class="mw">阿特拉斯耸耸肩</em>和<em class="mw">悲惨世界</em>加起来那么大的几千本书绰绰有余。SHA-256硬限制允许最多2097152的输入。SHA-256有一个32位输出。普通计算机一直使用SHA-256，这也是比特币和许多其他区块链背后的基础哈希算法之一。</p><p id="6a42" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu"> SHA-384和沙-513 </strong></p><p id="3242" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">这两个SHA的最大消息大小为2个⁸位，比SHA-256更好，需要更多的计算能力。最大块大小为1024位，字长为64位。它们使用64位进行计算，使用与SHA-256和SHA-224几乎相同的操作，并且它们执行80轮运算。</p><p id="0b83" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu"> SHA-3 </strong></p><p id="cca6" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">SHA-3创建于2015年，它允许224、256、384和512位的不同大小。以太坊中使用的Keccak算法是SHA-3家族的一部分。SHA-3可以根据需要提供不同大小的输出，块大小根据摘要大小而变化，从576位到1152位。SHA-3能打24发子弹。</p><p id="3ef0" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">现在让我们仔细观察并分解SHA-256，它可能是区块链使用最广泛的散列算法。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/ee69c52a49659be844ba90341b692300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*3NplJqgY2rmn7N8Ey0LUKw.png"/></div></figure><p id="59b3" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">正如我们之前看到的，哈希算法将任何输入转换为固定长度的字符串。该字符串不能转换回初始输出，这意味着哈希函数是抗前映像的。</p><p id="5437" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">加密哈希函数采用任意数据块并返回固定大小的位串。我们将在下面看到如何将M(消息)转换成哈希值，也称为摘要或简称为哈希。</p><p id="53db" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">让我们手动散列一些东西，好吗？您可以在下面看到从消息处理到散列计算所需的步骤。所以…让我们一步一步地散列某个输入。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/2a0b7ad802d147e649da7f8a65a2ae47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*dGZsDQP-2-IF5wejUsQc4Q.png"/></div></figure><p id="a3ad" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">让我们来看看产生SHA-256弦的幕后发生了什么。</p><p id="3398" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">步骤1:填充消息</strong></p><p id="840a" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">SHA-256首先将消息转换为二进制数，并获得长度l。这种填充的目的是在哈希计算开始之前准备好消息。填充确保填充的消息是512位的倍数。</p><p id="9a51" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">我想将消息“M = Moky”转换成8位二进制表示。Moky是我的狗的名字，也是我17年来最好的朋友。</p><p id="59ea" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw">M = 01001101 o = 01101111k = 01101011y = 01111001</em></p><p id="7f5e" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">然后，在消息M的末尾添加1位</p><p id="13f9" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw">M = 01001101 01101111 01101011 011111001+1位</em></p><p id="871e" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw">长度= l = 32位(即原始报文的长度)</em></p><p id="3147" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">现在，将K个零比特添加到消息中，使其成为512的倍数，并将长度为I的64比特表示添加到字符串的末尾(我们需要用K个零填充它，以完成算法所需的比特大小)</p><p id="c13d" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">计算要追加的0位数:</p><p id="dbdb" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw"> K = 512 — (l+1) — 64 </em></p><p id="c381" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">现在将l转换为输入消息长度的64位表示形式:</p><p id="b2eb" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw">M = 01001101 01101111 01101011 01111001+1位+ (k个零位)+ I为64位bin newLenght = l + 1 + {k个零位} + (64位i) = 512 </em></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/e8227eeb85e58603b36a8730dc300445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*CXvUA4YSD2ddBvxT7I3YZQ.png"/></div></figure><p id="4df8" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">我们的填充应该是什么样子的图形表示。</p><p id="0db5" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">填充后，我们的消息如下所示:</p><p id="abb5" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw"/></p><p id="1881" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">第二步:解析消息</strong></p><p id="84c4" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">现在我们将解析填充的消息。在消息填充之后，我们现在需要将消息解析成512位的块，然后才能开始哈希计算。</p><p id="6888" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">为了进行解析，我们将取每组8位，并将元素(即每4组8位)转换为十六进制值。我们将用16 * 32位W形成512位W(0)字段，每个W代表4组8位。当您看到“0x”时，这意味着它是一个十六进制值。</p><p id="d9ea" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw">01001101 01101111 01101011 01111001 = W(0)0 = 0x 4d 6 F6 b 79</em></p><p id="a5e5" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw">10000000000000000000000000000 = W(0)1 = 0x 8000000000</em></p><p id="0749" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw">000000000000000000000000000000 = W(0)2…14 = 0x 00000000000</em></p><p id="69cd" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><em class="mw">000000000000000000000000000000000 = W(0)15 = 0x 00000000060</em></p><p id="bf1b" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">步骤3:初始化哈希值</p><p id="738f" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">我们的SHA-256将需要一些额外的初始值来工作。</p><p id="ccc7" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">初始哈希值如下:</p><p id="73f5" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">W(0)代表我们的信息。这是我们在步骤1和2中生成的内容:</p><p id="3e0d" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">W(0) 0 = 0x4D6F6B79</p><p id="9d35" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">W(0) 1 = 0x80000000</p><p id="88ba" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">W(0) 2…14 = 0x00000000</p><p id="bc5f" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">W(0) 15 = 0x00000060</p><p id="4775" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H(0)是前8个素数的平方根的小数部分的前32位。这些值称为初始哈希值，是SHA-256算法提供的常量。这些也是我们工作变量的一部分:</p><p id="5363" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H0 = 0x6a09e667</p><p id="1d41" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H1 = 0xbb67ae85</p><p id="ed1f" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H2 = 0x3c6ef372</p><p id="880d" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H3 = 0xa54ff53a</p><p id="c770" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H4 = 0x510e527f</p><p id="b730" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H5 = 0x9b05688c</p><p id="a51e" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H6 = 0x1f83d9ab</p><p id="b4d7" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">H7 = 0x5be0cd19</p><p id="f18e" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">K(0)代表立方根的前64个素数(即从2到311)的前32位。这些值是常量，由SHA-256码提供，并且始终相同，因为它们是加密标准的一部分:</p><p id="6e72" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">k[0..63] = 0x428a2f98，0x71374491，0xb5c0fbcf，0xe9b5dba5，0x3956c25b，0x59f111f1，0x923f82a4，0xab1c5ed5，0xd807aa98，0x12835b01，0x243185be，0x550c7dc3，0x72be5d74，0x80deb1fe，0x9bdc06a7</p><p id="e217" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">第四步:SHA-256哈希计算</strong></p><p id="a75d" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">散列算法然后将执行必要的计算，包括创建散列的迭代。现在，我们将之前准备好的初始化哈希值输入到算法中。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/7171bb2879d088163f0416310395040d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*eL9ibIeiJvVEdFHasFtukA.png"/></div></figure><p id="96d6" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">对于哈希函数计算，该算法将获取被分成块的消息，并对其进行64轮操作。每一轮中获得的输出作为下一轮计算的输入。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/2a74c8f63f2a768df40e70111fa2ff43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*zhdZL1RDpL7I6ufPLRwn2g.png"/></div></figure><p id="e02d" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">在此图中，我们可以看到将在512位消息中执行的64轮操作。输入W(消息块)和K(质数)在每一轮中被发送。前16个将把512位的消息分解成16个32位的部分，我们需要在每一步计算W。</p><p id="7fc4" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">W(i) = Wⁱ⁻ ⁶ + σ⁰ + Wⁱ⁻⁷ + σ其中，</p><p id="c18c" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">σ⁰ = (Wⁱ⁻ ⁵ ROTR⁷(x))异或(Wⁱ⁻ ⁵罗特⁸(x))异或(Wⁱ⁻ ⁵ SHR (x))</p><p id="bdf9" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">σ=(wⁱ⁻·罗特·⁷(x))异或(wⁱ⁻·罗特·⁹(x))异或(wⁱ⁻·什尔·⁰(x))</p><p id="4756" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">ROTRⁿ(x) =将“x”向右循环旋转“n”位</p><p id="17e3" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">SHRⁿ(x) =将“x”循环右移“n”位</p><p id="fd43" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">现在我们能够为所有64轮创建W(i)</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/1156a2ff2f2b555e4f11efc5212ae879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*-EWb_zxNZ6h8t2NfZoqpRQ.png"/></div></figure><p id="04aa" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">该图像说明了每一轮/迭代中发生的情况。一旦所有迭代完成，我们就可以完成散列过程。</p><p id="edcd" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">阿沙-2族压缩函数的一次迭代。蓝色组件执行以下操作:</p><p id="66b5" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">Ch(E，F，G) = (E和F) XOR((非E和G)</p><p id="02b1" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">Ma(A，B，C) = (A和B) XOR (A和C) XOR (B和C)</p><p id="8066" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">∑(A) = (A &gt;&gt;&gt; 2)异或(A &gt;&gt;&gt; 13)异或(A &gt;&gt;&gt; 22)</p><p id="d35c" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">∑(E) = (E &gt;&gt;&gt; 6)异或(E &gt;&gt;&gt; 11)异或(E &gt;&gt;&gt; 25)</p><p id="036a" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">+ =加法模<br/> <br/>紫色方框是SHA-256的加法模2。</p><p id="9f35" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">在所有的迭代之后，我们得到了所有的散列，并得到一个256位的值，该值将最终转化为最终的散列。搞定了。</p><p id="d25d" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">“Moky”的哈希是:278282 c 6 C4 fa 7a 2 a3 a 3 DCA 4d 08721 e 17 e 9 b 8 ca 491 D5 bb 1a 5 FB fc 9 e 6 adfefde</p><p id="e30b" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">SHA-256是最广泛使用的算法之一，虽然不可行破解，但计算非常简单。我知道这看起来有很多步骤，但是对于计算机来说，执行这些计算是相当简单的。专家们对SHA-256的安全性仍有分歧，但现实是破解阿沙-256…嗯，这几乎是不可能的，因为这需要几十亿年的时间。</p><p id="868d" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated">你有什么想法？将来我们需要升级区块链来使用不同种类的散列函数吗？</p><p id="bd85" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">🚀关注我，也查看我的🧱·区块链的书和课程:</strong></p><p id="950b" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">👨‍🎓</strong> <a class="ae my" href="https://www.udemy.com/course/fintech-technologies-cloud-and-cybersecurity/?referralCode=F1D4EA005A2881735A36" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Fintech、云和网络安全课程</strong> </a></p><p id="86f9" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">📖</strong> <a class="ae my" href="https://www.amazon.com/dp/B091CYTX37/ref=sr_1_1?dchild=1&amp;keywords=unblockchain&amp;qid=1617186443&amp;s=digital-text&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">取消连锁图书— Kindle和Paperbac </strong> </a> <strong class="lg iu"> k </strong></p><p id="efde" class="pw-post-body-paragraph le lf it lg b lh mf ju lj lk mg jx lm kr mh lo lp kv mi lr ls kz mj lu lv lw im bi translated"><strong class="lg iu">👨‍🎓</strong> <a class="ae my" href="https://www.udemy.com/course/blockchain-deep-dive-from-bitcoin-to-ethereum-to-crypto/?referralCode=B8463EE382E6D313304B" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu">解除封锁</strong> </a></p></div></div>    
</body>
</html>