<html>
<head>
<title>JavaScript Best Practices — Browser Differences, Performance, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—浏览器差异、性能等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-browser-differences-performance-and-more-25f704f1bb25?source=collection_archive---------12-----------------------#2020-02-06">https://levelup.gitconnected.com/javascript-best-practices-browser-differences-performance-and-more-25f704f1bb25?source=collection_archive---------12-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eebde0a939f1ae46f169f8251df90909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jquZMsi0_5hsYOdM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@macauphotoagency?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">澳门图片社</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="cd91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何其他编程语言一样，JavaScript有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript有很多棘手的部分，所以我们应该避免降低代码质量的事情。通过遵循最佳实践，我们可以创建优雅且易于管理的代码，任何人都可以轻松使用。</p><p id="4701" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何优雅地支持旧浏览器，避免大量嵌套，各种优化，并检查我们的程序中的数据。</p><h1 id="082b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">渐进增强</h1><p id="9388" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">进步增强意味着当某些技术不可用时，我们应该优雅地降级我们的应用程序。这意味着我们应该检查某些技术是否在我们想要支持的所有浏览器中都得到支持，如果不支持，就让我们的应用程序以某种方式工作。</p><p id="7f9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以添加polyfills来增加对新技术的支持，这些新技术是我们所支持的旧浏览器所不具备的。</p><p id="82ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想使用Internet Explorer 11中没有的新数组方法，但我们的应用程序仍然支持浏览器，那么我们必须为它添加一个polyfill或检查它是否存在，并做一些不同的事情而不是崩溃。</p><h1 id="82a2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免大量嵌套</h1><p id="efc3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在代码中有大量的嵌套使得它们很难阅读。这是因为很难理解代码的逻辑。</p><p id="612c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嵌套条件语句和循环应该保持在最低限度。</p><p id="fdca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="556b" class="mq lf it mm b gy mr ms l mt mu">const items = {<br/>  foo: [1, 2, 3],<br/>  bar: [1, 2, 3],<br/>  baz: [1, 2, 3]<br/>};</span><span id="0a69" class="mq lf it mm b gy mv ms l mt mu">const parentUl = document.createElement('ul');<br/>for (const item of Object.keys(items)) {<br/>  const parentLi = document.createElement('li');  <br/>  const childUl = document.createElement('ul');<br/>  for (const num of items[item]){<br/>    const childLi = document.createElement('li');<br/>    childLi.textContent = num;<br/>    childUl.appendChild(childLi);    <br/>  }<br/>  parentLi.textContent = item;<br/>  parentLi.appendChild(childUl);  <br/>  parentUl.appendChild(parentLi);<br/>}<br/>document.body.appendChild(parentUl);</span></pre><p id="413a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就创建了一个嵌套列表，读和写都很混乱。我们应该通过将列表创建分离到一个函数中并调用该函数来减少嵌套:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b9b2" class="mq lf it mm b gy mr ms l mt mu">const items = {<br/>  foo: [1, 2, 3],<br/>  bar: [1, 2, 3],<br/>  baz: [1, 2, 3]<br/>};</span><span id="c2bd" class="mq lf it mm b gy mv ms l mt mu">const createUl = (items) =&gt; {<br/>  const ul = document.createElement('ul');<br/>  for (const item of items) {<br/>    const li = document.createElement('li');<br/>    li.textContent = item;<br/>    ul.appendChild(li);<br/>  }<br/>  return ul;<br/>}</span><span id="815f" class="mq lf it mm b gy mv ms l mt mu">const parentUl = createUl(Object.keys(items));<br/>const parentLis = parentUl.querySelectorAll('li');<br/>for (const parentLi of parentLis) {<br/>  const childUl = createUl(items[parentLi.textContent]);<br/>  parentLi.appendChild(childUl);<br/>}<br/>document.body.appendChild(parentUl);</span></pre><p id="c3b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，上面的代码没有任何嵌套循环，这使得代码更容易阅读。此外，我们有一个<code class="fe mw mx my mm b">createUl</code>函数来创建包含条目的<code class="fe mw mx my mm b">ul</code>元素，并返回<code class="fe mw mx my mm b">ui</code>元素对象。</p><p id="b3a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以随后将它附加到文档或HTML元素中。</p><h1 id="4ab0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">优化循环</h1><p id="e136" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该在单个变量中缓存每个文献中使用的值。</p><p id="f9e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为每次我们这样做时，CPU必须一次又一次地访问内存中的项目来计算结果。</p><p id="fb38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该尽可能少地这样做。</p><p id="e19f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个循环，我们不应该写如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3df7" class="mq lf it mm b gy mr ms l mt mu">for (let i = 0; i &lt; arr.length; i++) {</span><span id="6bd1" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><p id="4c62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2d2f" class="mq lf it mm b gy mr ms l mt mu">let length = arr.length;<br/>for (let i = 0; i &lt; length; i++) {</span><span id="e3d9" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><p id="b8a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，<code class="fe mw mx my mm b">arr.length</code>在我们的循环中只被引用一次，而不是在每次迭代中访问它。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/fd0a8ba788a8c8da217154788bd17c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u_AQyKMw5f5YqqA3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@adriencesard?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adrien céSARD</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7fb9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将DOM访问保持在最低限度</h1><p id="d924" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">DOM操作是一项CPU和内存密集型操作。因此，我们应该努力把它保持在最低限度。</p><p id="ff5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们必须保持页面尽可能简单，并且只在必要时才进行DOM操作。任何静态样式都应该在CSS中，而不是用JavaScript动态添加。</p><p id="d6f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该在HTML中保留任何静态元素，而不是通过操纵DOM来创建它们。</p><p id="1457" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该创建创建元素并在需要时调用它们的函数，而不是在代码的顶层不断地进行DOM操作。</p><h1 id="2d5b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为所有浏览器编写代码</h1><p id="d957" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的代码应该对所有浏览器一视同仁。我们不应该编写hacks来适应各种浏览器，因为当浏览器改变版本时，这些hacks会很快被破坏。</p><p id="1395" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该坚持被接受为标准的代码，或者使用像Modernizr这样的库来处理不同浏览器的问题。</p><p id="997a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以添加polyfills来添加各种浏览器中缺少的任何功能，因此我们可以让我们的应用程序在不同的浏览器上运行，即使它们可能不支持某些现成的功能。</p><h1 id="cbe6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要相信任何数据</h1><p id="3219" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该检查用户输入的任何数据。HTML5有很多表单验证功能来检查有效输入。我们可以用HTML5和普通JavaScript来实现。</p><p id="2767" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们检查了输入的数据，我们还需要检查变量中的数据和函数返回的数据。因为JavaScript是一种动态类型语言，我们必须检查这些东西。</p><p id="cef2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于原始值，我们可以使用<code class="fe mw mx my mm b">typeof</code>操作符来检查数据的数据类型。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="466d" class="mq lf it mm b gy mr ms l mt mu">let x = 1;</span></pre><p id="bc0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mw mx my mm b">typeof x</code>会返回<code class="fe mw mx my mm b">'number'</code>。其他原始数据类型，如布尔型、字符串型、未定义型等。是一样的。</p><p id="9298" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的例外是<code class="fe mw mx my mm b">null</code>，它有object类型。</p><p id="62eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该经常检查像<code class="fe mw mx my mm b">null</code>或<code class="fe mw mx my mm b">undefined</code>这样的值，因为它们可能会使我们的程序崩溃。我们可以通过分别写<code class="fe mw mx my mm b">x === null</code>和<code class="fe mw mx my mm b">typeof x === 'undefined'</code>来实现。</p><p id="44be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该小心JavaScript进行的类型强制，比如在条件语句和函数调用中。例如，<code class="fe mw mx my mm b">Math.min</code>方法在被调用时会将其参数转换成数字。在返回结果之前,<code class="fe mw mx my mm b">==</code>操作符将所有操作数转换为相同的类型。</p><p id="848a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于对象，我们可以通过使用<code class="fe mw mx my mm b">instanceof</code>操作符来检查它们的类型，看看它们是从哪个构造函数创建的。例如，如果我们有一个数组:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f07f" class="mq lf it mm b gy mr ms l mt mu">let arr = [];</span></pre><p id="2327" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mw mx my mm b">[] instanceof Array</code>将会是<code class="fe mw mx my mm b">true</code>。数组还有一个静态的<code class="fe mw mx my mm b">isArray</code>方法来检查数据类型。</p><p id="5276" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道，在JavaScript代码中，我们应该意识到我们的应用程序支持的不同浏览器之间的差异。这意味着检查我们想要使用的方法是否存在，并添加polyfills来添加旧浏览器缺少的功能。</p><p id="57d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该缓存在循环中重复访问的变量和属性，这样它们就不必在每次循环运行时都被访问。</p><p id="7538" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还应该避免深度嵌套，以保持代码清晰易懂。</p><p id="f2ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，由于DOM操作是一种开销很大的操作，所以应该尽量减少。静态样式和元素应该分别在CSS和HTML中。</p><p id="4ba1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们不应该相信应用程序中的数据。必须检查输入的格式和有效性，并且应该检查变量和值中的数据的类型，包括<code class="fe mw mx my mm b">null</code>或<code class="fe mw mx my mm b">undefined</code>。</p></div></div>    
</body>
</html>