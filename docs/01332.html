<html>
<head>
<title>Querying geographic raster data in BigQuery the brute force way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以强力方式查询地理栅格数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/querying-geographic-raster-data-in-bigquery-the-brute-force-way-1da46799d65f?source=collection_archive---------8-----------------------#2019-12-14">https://levelup.gitconnected.com/querying-geographic-raster-data-in-bigquery-the-brute-force-way-1da46799d65f?source=collection_archive---------8-----------------------#2019-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1fe6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用多边形表示每个像素！别担心。BigQuery可以处理。</h2></div><p id="e40c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的一周里，我多次收到这个问题的变体:“我有栅格地理数据。有没有办法转换一下，让我可以用BigQuery GIS？”原因是人们希望能够使用良好的旧SQL将地理空间影像与其他GIS数据集连接起来。</p><p id="0fd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种可能是获取网格化数据，对其进行等值线绘制，并将等值线作为多边形存储在BigQuery中。然后，我们可以结合其他地理类型的等高线。这似乎是合理的，但是我从经验中知道绘制一个网格区域的轮廓并不简单。首先，像<a class="ae lb" href="https://en.wikipedia.org/wiki/Marching_squares" rel="noopener ugc nofollow" target="_blank">行进正方形</a>这样的算法会产生方方正正、不自然的轮廓。试图通过在绘制等值线之前平滑区域来解决这个问题会导致精度损失。其次，有必要在不同的等值面上创建等高线，如果所讨论的场由连续值组成，等高线表示又会有损耗。</p><p id="f15a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有没有更好的办法？</p><h2 id="d5de" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">在BigQuery中将每个像素存储为多边形</h2><p id="6188" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">好吧，BigQuery可以处理Pb级的数据集，那么如果我们做一些蛮力的事情呢？人们通常回避的事情，因为他们的工具不能处理它？如果我们取网格中的每个像素，并将其存储为多边形，会怎么样？</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/3396a911bc3d370d1fd60ee5bb5acac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*1Jho3xZxmd5pwEvUvSEvLQ.png"/></div></figure><p id="4484" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">美国宇航局发布了一个全球<a class="ae lb" href="https://neo.sci.gsfc.nasa.gov/view.php?datasetId=SEDAC_POP" rel="noopener ugc nofollow" target="_blank">网格人口密度</a>，看起来像这样:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/605f300e241078b5358ec102bc2e373f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tpnvpbp0ZlI0lp9W"/></div></div></figure><p id="06a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将人口密度数据下载为ASCII文本文件，该文件由1800行和3600列组成，其中每个像素对应0.1度的纬度和经度。</p><p id="4261" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我做的第一件事是<a class="ae lb" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/blogs/popdensity/convert_to_geo.py" rel="noopener ugc nofollow" target="_blank">将下载的文本文件转换成JSON文件</a>，其中像素由像素边界的多边形表示:</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="5ebc" class="lc ld iq mo b gy ms mt l mu mv">       # represent each pixel by a polygon of its corners<br/>       top = ORIGIN_LAT - rowno * LATRES<br/>       bot = ORIGIN_LAT - (rowno+1) * LATRES<br/>       left = ORIGIN_LON + colno * LONRES<br/>       right = ORIGIN_LON + (colno+1) * LONRES<br/>       poly = 'POLYGON(({:.2f} {:.2f}, {:.2f} {:.2f}, {:.2f} {:.2f}, {:.2f} {:.2f}, {:.2f} {:.2f}))'.format(<br/>                 left, top,  # topleft<br/>                 left, bot,  # botleft<br/>                 right, bot, # botright<br/>                 right, top, # topright<br/>                 left, top   # same as first point<br/>              )<br/>       center = 'POINT({:2f} {:2f})'.format( (left+right)/2, (top+bot)/2 )<br/>       pixel = {<br/>          'rowno': rowno,<br/>          'colno': colno,<br/>          'location': center,<br/>          'bounds': poly,<br/>          'population_density': value<br/>       }</span></pre><p id="72e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成的JSON文件有如下几行:</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="fbfb" class="lc ld iq mo b gy ms mt l mu mv">{"rowno": 64, "colno": 1451, "location": "POINT(-34.850000 83.550000)", "bounds": "POLYGON((-34.90 83.60, -34.90 83.50, -34.80 83.50, -34.80 83.60, -34.90 83.60))", "population_density": 1.04}</span></pre><p id="2dce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，地理类型以WellKnownText (WKT)形式表示。</p><p id="a89c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以写出模式:</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="a821" class="lc ld iq mo b gy ms mt l mu mv">[<br/>  {<br/>    "description": "row number",<br/>    "mode": "REQUIRED",<br/>    "name": "rowno",<br/>    "type": "INTEGER"<br/>  },<br/>  {<br/>    "description": "column number",<br/>    "mode": "REQUIRED",<br/>    "name": "colno",<br/>    "type": "INTEGER"<br/>  },<br/>  {<br/>    "description": "centroid location",<br/>    "mode": "REQUIRED",<br/>    "name": "location",<br/>    "type": "GEOGRAPHY"<br/>  },<br/>  {<br/>    "description": "polygon representing boundary of pixel",<br/>    "mode": "REQUIRED",<br/>    "name": "bounds",<br/>    "type": "GEOGRAPHY"<br/>  },<br/>  {<br/>    "description": "population density (persons per sq km)",<br/>    "mode": "REQUIRED",<br/>    "name": "population_density",<br/>    "type": "FLOAT"<br/>  }<br/>]</span></pre><p id="6432" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，使用以下命令将其加载到BigQuery中:</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="a40e" class="lc ld iq mo b gy ms mt l mu mv">bq load --source_format=NEWLINE_DELIMITED_JSON \<br/>        advdata.popdensity popdensity_geo.json.gz schema.json</span></pre><p id="649b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，数据被载入，它是一个精确的表示。但是我们真的能有效地查询这个怪物吗？</p><h2 id="cae7" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">查询性能和数据可视化</h2><p id="a793" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">让我们看看…下面是一个查询，它将我们的人口密度栅格数据与城市区域的公共数据集相关联，以查找华盛顿州人口最密集的区域:</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="8f6e" class="lc ld iq mo b gy ms mt l mu mv">WITH urban_populations AS (<br/>SELECT <br/>   lsad_name<br/>   , SUM(ST_AREA(bounds)/1000000) AS area_sqkm<br/>   , COUNT(1) AS num_pixels<br/>   , AVG(population_density) AS pop_density<br/>FROM advdata.popdensity, `bigquery-public-data.geo_us_boundaries.urban_areas`<br/>WHERE ST_INTERSECTS(bounds, urban_area_geom) <br/>      AND STRPOS(lsad_name, ', WA') &gt; 0<br/>GROUP BY lsad_name<br/>)</span><span id="cc13" class="lc ld iq mo b gy mw mt l mu mv">SELECT <br/>   *, (area_sqkm * pop_density / 1000000) AS population_millions<br/>FROM urban_populations<br/>ORDER BY area_sqkm DESC<br/>LIMIT 10</span></pre><p id="a68f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的查询相当复杂-它动态地计算像素的面积，并在每个像素多边形和每个城市区域多边形之间进行相交检查-所以如果这有效地工作，我们应该处于良好的状态。</p><p id="cb97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现该查询处理500 MB，仅用4秒钟就返回:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mx"><img src="../Images/f187a016b93d35a712c4a30587005874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qYHm1DMR6JKdlfaMDH3McA.png"/></div></div></figure><p id="42fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来是正确的(2020年西雅图的地铁人口为370万，因此2000年的317万似乎是合理的)。使用按需定价的500 MB查询将花费大约1/4美分，因此它也是划算的。</p><p id="c016" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用一点可视化来抽查我们的转换是否正确。让我们转到<a class="ae lb" href="https://bigquerygeoviz.appspot.com/" rel="noopener ugc nofollow" target="_blank"> BigQuery GeoViz </a>网站，查询美国1000个人口最密集的网格单元:</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="5309" class="lc ld iq mo b gy ms mt l mu mv">SELECT <br/>   location, population_density, bounds<br/>FROM advdata.popdensity, <br/>     `bigquery-public-data`.utility_us.us_border_area<br/>WHERE ST_WITHIN(location, us_border_geom)<br/>ORDER BY population_density DESC<br/>LIMIT 1000</span></pre><p id="6071" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将<code class="fe my mz na mo b">bounds</code>指定为要可视化的几何列，并放大美国西南部的四角区域:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nb"><img src="../Images/2905e6d6f9d85002dedb4ed5782712e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ITaR0AWrbVuVfSlg"/></div></div></figure><p id="44ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。</p><h2 id="a52a" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">100倍的数据</h2><p id="8175" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们从美国宇航局下载的数据“已经过缩放和重新采样……可能不适合严格的科学使用”。不使用NASA发布的大约10km分辨率的数据，如果我们使用1km分辨率的像素会怎么样？全球人口密度的原始数据可以从哥伦比亚大学获得<a class="ae lb" href="https://sedac.ciesin.columbia.edu/data/set/gpw-v4-population-density-rev11/data-download" rel="noopener ugc nofollow" target="_blank">，所以我注册并下载了他们2020年的最高分辨率数据:</a></p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nc"><img src="../Images/b55380a7f9f3d4a81e5f522f0b85e527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfD9fy4LM0DMqc5elgbNVQ.png"/></div></div></figure><p id="d778" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1公里分辨率数据集是美国宇航局数据集的100倍。让我们看看BigQuery是否能够应对挑战。</p><p id="bda9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转换数据并将其加载到BigQuery中需要更长的时间，因为数据要多100倍。数据现在也足够大了，我把它存放在谷歌云存储中，而不是直接从我的笔记本电脑加载到BigQuery中。当然，我可以并行化代码来创建GeoJSON，但我没有这样做。</p><p id="324b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我做的一个改变是添加了一个列，指定像素来自的图块。然后，我在BigQuery表中将tile指定为一个<a class="ae lb" href="https://cloud.google.com/bigquery/docs/clustered-tables" rel="noopener ugc nofollow" target="_blank">聚类列</a>:</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="07e3" class="lc ld iq mo b gy ms mt l mu mv">bq load --replace \<br/>   --source_format NEWLINE_DELIMITED_JSON \<br/>   <!-- -->--time_partitioning_type DAY<!-- --> \<br/>   <strong class="mo ir">--clustering_fields tile</strong> \<br/>   advdata.popdensity $GCSFILE schema.json</span></pre><p id="3396" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚类有助于提高查询性能并降低查询成本。这很重要，因为1公里的全球网格是52 GB！按照SEDAC数据的设置方式，大多数查询只需处理一两个切片即可完成:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nd"><img src="../Images/e18ff1d3f8d2b001d133215d57ec57b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEAlB7zAzZBvMSvQOBD_mQ.png"/></div></div></figure><p id="ca71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，整个华盛顿州都在1号分块中，因此我可以在WHERE子句中指定这一点:</p><pre class="mb mc md me gt mn mo mp mq aw mr bi"><span id="f194" class="lc ld iq mo b gy ms mt l mu mv">WITH urban_populations AS (<br/>SELECT <br/>   lsad_name<br/>   , SUM(ST_AREA(bounds)/1000000) AS area_sqkm<br/>   , COUNT(1) AS num_pixels<br/>   , AVG(population_density) AS pop_density<br/>FROM advdata.popdensity, `bigquery-public-data.geo_us_boundaries.urban_areas`<br/>WHERE <br/>  <strong class="mo ir">tile = 'gpw_v4_population_density_rev11_2020_30_sec_1.asc'</strong><br/>  AND ST_INTERSECTS(bounds, urban_area_geom)<br/>  AND STRPOS(lsad_name, ', WA') &gt; 0<br/>GROUP BY lsad_name<br/>)</span><span id="f534" class="lc ld iq mo b gy mw mt l mu mv">SELECT <br/>   *, (area_sqkm * pop_density / 1000000) AS population_millions<br/>FROM urban_populations<br/>ORDER BY area_sqkm DESC<br/>LIMIT 10</span></pre><p id="033e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是华盛顿市区的结果(注意，现在像素数更多了，因为我们使用的是1千米分辨率的数据):</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ne"><img src="../Images/885388b51a20f476ec50ddb35503e849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o9Z_eBGzHNSkDpXJRCTRNw.png"/></div></div></figure><p id="5d05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对1km分辨率数据的查询处理5.8 GB(成本:2.5c)但仍然只需要6秒钟！</p><p id="b9f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是GeoViz——注意我必须放大多远才能获得密集的像素:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nf"><img src="../Images/02828f691988b43c462dffe12a839432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hq68CKUIO4Oof-PE6weovQ.png"/></div></div></figure><p id="3507" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这完全出乎我的意料。可以在BigQuery中强力查询栅格GIS数据。又快，又便宜，又准。太神奇了！</p><p id="2979" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">下一步:</strong></p><ul class=""><li id="123d" class="ng nh iq kh b ki kj kl km ko ni ks nj kw nk la nl nm nn no bi translated">完整代码见我的GitHub repo:<a class="ae lb" href="https://github.com/GoogleCloudPlatform/training-data-analyst/tree/master/blogs/popdensity" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Google cloud platform/training-data-analyst/tree/master/blogs/pop density</a></li><li id="8534" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">阅读本文，通过利用游程编码，获得将栅格数据加载到BigQuery的更有效方法:<a class="ae lb" href="https://medium.com/google-cloud/how-to-query-geographic-raster-data-in-bigquery-efficiently-b178b1a5e723" rel="noopener">https://medium . com/Google-cloud/how-to-query-geographic-raster-data-in-big query-efficient-b 178 B1 a5e 723</a></li></ul></div></div>    
</body>
</html>