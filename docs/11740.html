<html>
<head>
<title>Angular: Get Control in ControlValueAccessor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:在ControlValueAccessor中获取控制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-get-control-in-controlvalueaccessor-b7f09a485fba?source=collection_archive---------4-----------------------#2022-04-12">https://levelup.gitconnected.com/angular-get-control-in-controlvalueaccessor-b7f09a485fba?source=collection_archive---------4-----------------------#2022-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="d2e4" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">角形</h2><div class=""/><div class=""><h2 id="3ef9" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">如何在不创建新组件的情况下获取对传递给自定义组件的控件的引用。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/659fbd08d1fa65256d2163eb8f82f43f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WN9_4GYMWACSNfYGa08cA.jpeg"/></div></div></figure><p id="b37d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是一篇关于在Angular中将控件放入<em class="lw"> ControlValueAccessor </em>的更新和改进文章。(<a class="ae lx" href="https://medium.com/@toha.marko/get-actual-control-in-controlvalueaccessor-e5bb3bb6710" rel="noopener">老一</a>)</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="f299" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当你必须用Angular处理表单时，实际上，你不能没有<em class="lw"> ControlValueAccessor </em>练习，因为它的灵活性和功能性。您可以从应用程序中的任何元素创建控件。这就是力量。</p><blockquote class="mf mg mh"><p id="b48c" class="la lb lw lc b ld le ka lf lg lh kd li mi lk ll lm mj lo lp lq mk ls lt lu lv ij bi translated">组件变成控件有一个简单的迭代:提供<em class="iq"> NG_VALUE_ACCESSOR </em>令牌值，并在其中实现<em class="iq"> ControlValueAccessor </em>接口。</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">具有ControlValueAccessor接口的控件组件</figcaption></figure><p id="e1be" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">该组件现在可以在<em class="lw">表单组</em>中使用，或者简单地作为应用程序中的独立控件。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="eea8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这就是这篇文章的重点——我们如何将控件注入到组件中？</p><p id="6e8b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先，让我们找出可以传递给组件的控制指令的类型:</p><ul class=""><li id="26ec" class="mr ms iq lc b ld le lg lh lj mt ln mu lr mv lv mw mx my mz bi translated"><strong class="lc ja">表单控件</strong></li><li id="234a" class="mr ms iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="lc ja">表单控件名</strong></li><li id="5383" class="mr ms iq lc b ld na lg nb lj nc ln nd lr ne lv mw mx my mz bi translated"><strong class="lc ja"> NgModel </strong></li></ul><p id="39fa" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，我们如何在组件中获得这些控件？解决方法很简单，只需注入<em class="lw"> NgControl </em>参考。但是，如果你试图在<em class="lw"> </em>构造函数中直接注入<em class="lw">ng control</em><em class="lw"/>，你会得到一个错误:“<em class="lw">错误:NG0200:检测到DI中的循环依赖……”</em>。</p><p id="fe1f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">怎么才能解决这个问题？没错，我们可以通过<em class="lw">注入器</em>将<em class="lw"> NgControl </em>注入到<em class="lw"> OnInit </em>生命周期钩子中，不会出现任何错误。</p><p id="64c3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">棱角分明超级灵活！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">向组件正确注入NgControl</figcaption></figure><p id="14c5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在让我们认识到我们所拥有的那种控制。为此，我为注入类的构造函数定义创建了一个switch语句:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">ControlValueAccessor组件中正确注入和配置的控件</figcaption></figure><p id="4bfe" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">最后，让我们的组件结构更具逻辑性和美观性——将所有这些逻辑放在一个单独的方法中。这里的最后一个组件:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">具有ControlValueAccessor的最终实现组件</figcaption></figure><p id="8e08" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">今天到此为止。感谢您的关注。</p></div></div>    
</body>
</html>