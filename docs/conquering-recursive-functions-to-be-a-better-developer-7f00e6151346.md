# 征服递归函数成为更好的开发者

> 原文：<https://levelup.gitconnected.com/conquering-recursive-functions-to-be-a-better-developer-7f00e6151346>

理解这么多开发者在纠结什么。

![](img/0e27a07b7b02811c4bbedcc3d48b5240.png)

你真的应该关心学习递归吗？答案是“*是*”。**因为到处都是老老实实**。如果你写 JavaScript，那么`JSON.parse()`或者`JSON.stringify()`就用它。所以 DOM 遍历算法和`getElementById()`。是编码面试中突然冒出来的东西。

我甚至没有提到更复杂的数据结构，或者它如何简化一些循环操作。

术语*递归，或者*也许*递归函数*你可能听起来很熟悉。这是计算机科学课上突然出现的编码策略之一。或者甚至是一些围绕网络的挑战。

这是一个棘手的概念。但是我保证**一旦你真正理解它，它就会变成你的第二天性。**

## **什么是递归？**

让我们先从递归解决一个问题的*的表面来分析一下递归。*

> “递归地面对一个问题意味着一遍又一遍地执行同一套动作，直到满足一个特定的条件”。

让我们改写这句话来定义一个*递归函数。你编写函数来执行独立的任务。有点像这样:*

你的函数总是执行相同的任务。但是，输出会根据您提供给它们的参数而有所不同。像上面例子中的`num`。为了递归地编写这个函数*和*，你必须一遍又一遍地执行相同的动作，直到满足一个条件。

首先，在这种情况下你应该执行什么样的动作？

*   嗯，这很简单，你只需要从传入的正数中减去`1`。
*   直到什么？直到那个数字变成`1`本身。

所以你有要执行的动作和停止执行它们的条件。你是如何一遍又一遍地表演它们的？这实际上是最简单的部分。**就让函数自己调用:**

这一开始可能会让你头疼。但是记住你在上面读到的。要递归地编写这个函数*，*，你只需要输入之前建立的代码。

*   **反复执行相同的动作**:对于每个传入的数字，减去`1.`，在我们的例子中是`num--;`。然后通过调用`countDown(num)`再次执行这个操作
*   **让我们这样做，直到什么**？直到 num 实际上是`1`。这就是我们函数`if (num === 1) return num;`开始时条件的需要

## 幕后发生了什么？

要真正掌握这个概念，你必须掌握 Javascript 中的*调用栈*是什么。为什么？因为这使得*递归*成为可能*。*

几乎每种编程语言背后，都有一个*数据结构*来管理被调用的函数调用。那是因为函数调用必须被组织起来。它们不是随机发生的。如果一个函数正在调用另一个函数，而那个函数也在调用一个新的函数，那该怎么办？*调用栈*负责管理 JavaScript 中的这种机制。

就像一堆盘子。每次调用一个函数，它都被放在*调用栈的顶部。就像你会把最后一个洗干净的盘子放在一堆盘子上。*

当`return`发生在一个函数中，或者当一个函数结束时，编译器将从堆栈中移除顶部的项目。有点像一堆盘子，对吧？如果你把它们一个叠在另一个上面，你第一个拿出来吃的就是上面的那个。这种机制被称为“ [*后进先出*](https://it.wikipedia.org/wiki/LIFO) ”。

下面是这种情况的一个演示:

事情是这样的:

1.  我们第一次调用`first()`，它的调用首先被放入调用栈。目前，这个电话是唯一的项目。
2.  现在我们调用`second()`，它被放在调用堆栈的顶部。以上`first()`。
3.  当`second()`调用`intruder()`时也是如此。我们现在在调用堆栈中有三个项目，其中`intruder()`位于顶部。
4.  `intruder()`返回，所以它只是弹出调用堆栈。现在我们处于和列表中第二点相同的状态。
5.  现在`second()`也返回了，从调用堆栈中弹出，让我们回到与第一点相同的状态——列表中只有一项。
6.  `third()`最后被调用，一个新的项被放在调用栈上，一旦`third()`返回，它立即被弹出，`first()` one 也返回。导致相同的效果发生在堆栈中的项目上。

**请注意:**在 Chrome developer 的工具里面，你会发现，在执行代码和放置断点的时候，有一个叫做 Call-Stack 的部分。它将直观地呈现刚才所说的内容。

## 将调用堆栈逻辑应用到我们的示例中

这需要解释吗？因为现在你可以以一种更低层次的方式理解，在我们的`countDown()`例子中发生了什么。每当我们一次又一次地调用这个函数时，一个新的调用就被放在栈顶。一旦我们在`num === 1`时点击 return，调用栈将弹出其中的每个调用。产生了我们的最终结果。

```
countDown(3)is called              ---------> +1 call on the stack
countDown(3) returns countDown(2)  ---------> +1 call on the stack countDown(2) returns countDown(1)  ---------> +1 call on the stack
countDown(1) returns countDown(0)  ---------> +1 call on the stackBase condition is hit. Functions will return from inner to outer
For every return we see a -1 on the call stack.
```

## 写递归函数的时候应该记住什么？

你已经完全准备好在下一个编码问题中应用*递归*。但是请记住，要编写正确的*递归函数*，需要遵循一些严格的规则。或者更好，他们要求的两个强制性特征。

*   用不同的输入调用自身:没有对自身的调用，你的函数就不是递归的。用相同的参数调用自身会导致堆栈溢出错误。这意味着*调用栈*已经耗尽了函数调用的空间。
*   基本条件:这是结束*递归循环*的条件。如果你没有，那么你永远不会离开这个函数，所以会出现一个无限循环。

回顾如何避免常见陷阱或*递归陷阱:*

*   你是否有一个终止递归循环的基本条件？

*   当你的函数调用自己时，你总是传递不同的参数吗？
*   你是否从你的电话中回复了一些东西，这是正确的数据吗？

如果是这样，那么你可以走了。

## 常见的递归问题

倒数到 1 是一个简单的例子，我用来展示递归是如何工作的。使用递归可能解决的其他常见问题有

*   **阶乘计算**

*   **字符串反转**

还可以用于查找最短路径、确定模式匹配、查找单词组合等。

## **现在怎么办？**

一旦你学会了解决问题的新方法，新的大门就会在你的脑海中打开。这并不意味着你必须处处使用递归 T21。但是如果你真的理解了它，当你面对挑战时，你的脑海中会有一个小小的回声。

*   "试试递归方法怎么样？"
*   “这会让这个循环更容易吗？这代码多简洁？”

如果你觉得有必要练习，可以在很多网站上找到递归挑战:

*   [技术开发](https://skilled.dev/course/recursion)
*   代码大战。
*   [主厨](https://www.codechef.com/tags/problems/recursion)。
*   [编码游戏](https://www.codingame.com/learn/recursion)。
*   [常见递归面试问题](https://www.byte-by-byte.com/12-recursion-questions/)。

## 结论

如何解决问题的新窗口已经打开。您现在已经了解了递归机制及其好处。这将真正有助于你的下一次面试、代码挑战，甚至日常编程任务。

— *皮耶罗*

## 资源

*   [CodeWars 递归挑战](https://www.codewars.com/collections/recursion-1)。
*   [编码面试的递归](https://skilled.dev/course/recursion)。
*   [后进先出](https://it.wikipedia.org/wiki/LIFO)。
*   [美丽图标 8 中的所有图标。](https://icons8.it/)
*   [从 Chrome 开发者工具调用堆栈](https://umaar.com/dev-tips/23-debugger-shortcuts/)。
*   [厨师长](https://www.codechef.com/tags/problems/recursion)。
*   编码名。
*   [常见递归面试问题](https://www.byte-by-byte.com/12-recursion-questions/)。