<html>
<head>
<title>Event-Driven Architecture Demo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件驱动的架构演示</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/event-driven-architecture-demo-29f5649144b7?source=collection_archive---------9-----------------------#2021-03-06">https://levelup.gitconnected.com/event-driven-architecture-demo-29f5649144b7?source=collection_archive---------9-----------------------#2021-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b64c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个单柱架构，有Kafka和GraphQL</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/884a7ffd2bc2a166ab73cc5565e315bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K49MTlqNdJs5K5N4t2qIaQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=143832" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae le" href="https://pixabay.com/users/lobostudiohamburg-13838/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=143832" rel="noopener ugc nofollow" target="_blank">托马斯·乌尔里希</a></figcaption></figure><p id="7371" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章是关于一个包含以下特性的演示Web应用程序:</p><ol class=""><li id="cb03" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><strong class="js iu">事件驱动</strong>。应用程序状态是作为处理事件的结果来维护的。只有一个暴露的突变端点，一个接受事件有效负载的<code class="fe lo lp lq lr b">POST</code>。该端点由专用事件服务器提供服务。</li><li id="e091" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><strong class="js iu">命令和事实事件</strong>:登记的事件属于两类事件。I)命令和ii)事实事件。前者传达更新业务模型状态的意图/请求，而后者传达状态已经被更新的事实。</li><li id="b758" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><strong class="js iu">事件持续性</strong>。事件被持久存储在<a class="ae le" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>中。他们永远生活在那里，随时可以被任何消费者消费。</li><li id="0e9a" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><strong class="js iu"> GraphQL查询</strong>。应用程序从其对应的应用程序服务器(不同于事件服务器)读取其状态。使用GraphQL加载整个状态。</li><li id="e90f" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><strong class="js iu">CQRS——命令查询责任分离</strong>:命令和查询的信息路径是分开的。或者换句话说，有一个命令模型和一个不同的读取模型。应用程序将命令作为命令事件发送到事件服务器，并使用Graphql查询从读取模型中读取其状态。</li><li id="6aa4" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><strong class="js iu">实时更新</strong>。应用程序正在使用Web套接字获取有关其状态的实时更新。</li></ol><h1 id="d0be" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">架构图</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/03f0044239f8fc4c1f6f0cb31b67cbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIfizeV8iwd3kpBhrFOkuQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">演示的架构图</figcaption></figure><p id="48b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上图描述了组成演示的组件。</p><p id="73fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这应该是一个订单管理应用程序，实现了以下用例:</p><ul class=""><li id="9fc8" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn mw ll lm ln bi translated">新秩序</li><li id="690c" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated">订单列表</li></ul><p id="9f11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该图显示了组件之间的信息流。特别是:</p><ol class=""><li id="f323" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">订单管理Web应用程序正在向事件服务器发送一个<code class="fe lo lp lq lr b">POST /events</code>请求。有效负载包含关于需要创建的订单的信息。正是指挥事件<code class="fe lo lp lq lr b">CreateOrder</code>。</li><li id="8fd4" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">事件服务器验证事件并将其发布到Apache Kafka中。</li><li id="8fb7" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">属于订单管理服务器的Kafka命令事件消费者监听事件。</li><li id="54cd" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">一旦事件到达，它就在数据库中创建订单。RDBMS数据库保存订单管理应用程序的状态。</li><li id="4e9e" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">随着订单在数据库中的成功创建，Kafka命令事件消费者使用<code class="fe lo lp lq lr b">POST /events</code>端点来创建事实事件<code class="fe lo lp lq lr b">OrderCreated</code>。</li><li id="bef0" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">事件服务器验证事件并将其发布到Apache Kafka。</li><li id="d4a6" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">另一个卡夫卡事实事件消费者正在收听<code class="fe lo lp lq lr b">OrderCreated</code>事实事件。一出版就消费。</li><li id="6a4e" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">Kafka事实事件消费者所做的只是将更新发布到Redis发布/订阅队列，该队列为Web应用程序的推送更新提供服务。</li><li id="b490" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">创建的新订单的电报消息被推送给所有订户，因此我们实现了运行订单管理应用程序的Web浏览器的实时更新。</li></ol><p id="66db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，您可以看到Web应用程序通过使用GraphQL从订单服务器获取订单来引导它们在浏览器中的状态。</p><h1 id="3d5a" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">使用的工具</h1><p id="1d0a" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">我们使用的工具列表如下:</p><ol class=""><li id="94e0" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><a class="ae le" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇卡夫卡</a>。分布式事件流平台，允许应用程序通过使用事件进行通信并建立状态。</li><li id="c6a2" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><a class="ae le" href="https://rubygems.org/gems/rails" rel="noopener ugc nofollow" target="_blank"> Rails </a> API。用于事件服务器实现<code class="fe lo lp lq lr b">POST</code>端点。以及应用程序服务器服务于GraphQL查询和维护应用程序的持久状态。</li><li id="8ae2" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><code class="fe lo lp lq lr b"><a class="ae le" href="https://rubygems.org/gems/ruby-kafka" rel="noopener ugc nofollow" target="_blank">ruby-kafka</a></code> gem:在事件服务器中，它用于向kafka发布事件。</li><li id="15b2" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><code class="fe lo lp lq lr b"><a class="ae le" href="https://rubygems.org/gems/rack-cors" rel="noopener ugc nofollow" target="_blank">rack-cors</a></code> gem:它同时用于事件服务器和应用服务器，以允许浏览器发出跨站点请求。</li><li id="53f8" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">gem:它在应用服务器中用于响应GraphQL查询。</li><li id="b1e5" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><code class="fe lo lp lq lr b"><a class="ae le" href="https://rubygems.org/gems/karafka" rel="noopener ugc nofollow" target="_blank">karafka</a></code> gem:在应用服务器中使用它来构建事件的消费者。</li><li id="ac9e" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><code class="fe lo lp lq lr b"><a class="ae le" href="https://rubygems.org/gems/redis" rel="noopener ugc nofollow" target="_blank">redis</a></code> gem:用于与Redis服务器接口，使用<a class="ae le" href="https://rubygems.org/gems/actioncable" rel="noopener ugc nofollow" target="_blank"> ActionCable </a>和Web sockets实现浏览器的实时更新。</li><li id="32b5" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><code class="fe lo lp lq lr b"><a class="ae le" href="https://gist.github.com/pmatsinopoulos/4017d8ac36021492c529d585062ec0cd" rel="noopener ugc nofollow" target="_blank">typhoeus</a></code> gem:它用于从Ruby内部发送POST请求。</li><li id="6f41" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated">Redis服务器:它用于存储ActionCable实现的消息。</li><li id="5d88" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><a class="ae le" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>:浏览器层使用的JavaScript库，用于构建应用表示层。</li><li id="7f71" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><a class="ae le" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux for React </a>:为React应用程序提供<a class="ae le" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>状态管理功能的React组件。</li><li id="5dd9" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn lk ll lm ln bi translated"><a class="ae le" href="https://react-bootstrap.github.io/" rel="noopener ugc nofollow" target="_blank"> React Bootstrap </a>:一组JavaScript组件，包装Twitter Bootstrap，允许在Web上快速开发漂亮的响应应用程序页面。</li></ol><h1 id="b1b0" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">源代码库</h1><ul class=""><li id="4999" class="lf lg it js b jt mx jx my kb nc kf nd kj ne kn mw ll lm ln bi translated"><a class="ae le" href="https://github.com/pmatsinopoulos/events-server" rel="noopener ugc nofollow" target="_blank">接收事件以创建订单的事件服务器</a></li><li id="f1c8" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated"><a class="ae le" href="https://github.com/pmatsinopoulos/orders-app-server" rel="noopener ugc nofollow" target="_blank">与Kafka消费者</a>的订单管理服务器。</li><li id="7d50" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated"><a class="ae le" href="https://github.com/pmatsinopoulos/order-entry" rel="noopener ugc nofollow" target="_blank">允许用户创建订单和查看订单列表的网络应用</a></li></ul><h1 id="2cda" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">如何在本地运行它</h1><h2 id="2f34" class="nf ly it bd lz ng nh dn md ni nj dp mh kb nk nl ml kf nm nn mp kj no np mt nq bi translated">阿帕奇卡夫卡</h2><ol class=""><li id="daba" class="lf lg it js b jt mx jx my kb nc kf nd kj ne kn lk ll lm ln bi translated">从这里下载</li></ol><p id="1fb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.然后，解压缩下载的文件。这将创建文件夹<code class="fe lo lp lq lr b">kafka_2.12-2.7.0</code>(取决于你下载的版本)。</p><p id="2dbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.移至该文件夹(<code class="fe lo lp lq lr b">cd kafka_2.12–2.70</code>)。</p><p id="db1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.启动动物园管理员</p><p id="227c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bin/zookeeper-server-start.sh config/zookeeper.properties</code></p><p id="1f66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.开始卡夫卡</p><p id="b614" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开另一个终端窗口，使用以下命令启动kafka:</p><p id="b351" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bin/kafka-server-start.sh config/server.properties</code></p><p id="27e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.创建<code class="fe lo lp lq lr b">events_commands</code>主题</p><p id="797a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个名为<code class="fe lo lp lq lr b">events_commands</code>的主题。这将用于存储命令事件。</p><p id="a8b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开另一个终端窗口，运行以下命令创建它:</p><p id="6cb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bin/kafka-topics.sh --create --topic events_commands --bootstrap-server localhost:9092</code></p><p id="e794" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">7.创建<code class="fe lo lp lq lr b">events_facts</code>主题</p><p id="be14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个名为<code class="fe lo lp lq lr b">events_facts</code>的主题。这将用于存储事实事件。</p><p id="706f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开另一个终端窗口，运行以下命令创建它:</p><p id="d2a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bin/kafka-topics.sh --create --topic events_facts --bootstrap-server localhost:9092</code></p><p id="be0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">8.启动控制台消费者</p><p id="868b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一步不是必需的，但是很高兴看到Kafka附带的用于调试目的的标准消费者是如何消费事件的。</p><p id="13f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开另一个终端，使用以下命令启动命令事件的控制台使用者:</p><p id="cd55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bin/kafka-console-consumer.sh --topic events_commands --from-beginning --bootstrap-server localhost:9092</code></p><p id="c660" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开另一个终端，使用以下命令启动事实事件的控制台消费者:</p><p id="f960" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bin/kafka-console-consumer.sh --topic events_facts --from-beginning --bootstrap-server localhost:9092</code></p><p id="f8a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">9.Redis服务器</p><p id="cfd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果已经运行了Redis服务器，可以跳过这一步。否则，在本地下载、安装并运行<a class="ae le" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis服务器</a>。</p><p id="6c89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">10.Postgres</p><p id="0aa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你已经运行了Postgres，你可以跳过这一步。否则，在本地下载、安装并运行Postgres服务器。如果你在Mac上工作，我强烈推荐<a class="ae le" href="https://postgresapp.com/" rel="noopener ugc nofollow" target="_blank"> Postgres.app </a>。</p><p id="1062" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">11.启动事件服务器</p><p id="b1c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还没有这样做，您需要在本地克隆<a class="ae le" href="https://github.com/pmatsinopoulos/events-server" rel="noopener ugc nofollow" target="_blank"> Rails事件服务器</a> repo。</p><p id="4cd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">克隆后，移动到repo的根文件夹，<code class="fe lo lp lq lr b">bundle</code>然后可以用命令启动服务器:</p><p id="010d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bundle exec rails -p 3002</code></p><p id="ffc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">12.启动订单应用服务器</p><p id="1853" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还没有这样做，您需要在本地克隆<a class="ae le" href="https://github.com/pmatsinopoulos/orders-app-server" rel="noopener ugc nofollow" target="_blank">订单应用服务器</a> repo。</p><p id="0d54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">克隆后，移动到存储库的根文件夹，并</p><ul class=""><li id="7a9f" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn mw ll lm ln bi translated"><code class="fe lo lp lq lr b">$ bundle</code></li><li id="4348" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated"><code class="fe lo lp lq lr b">$ bundle exec rake db:create</code></li><li id="5fbb" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated"><code class="fe lo lp lq lr b">$ bundle exec rake db:migrate</code></li></ul><p id="6a5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后使用以下命令启动订单应用服务器:</p><p id="bd49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bundle exec rails s -p 3001</code></p><p id="5569" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">13.启动卡夫卡消费者</p><p id="6cd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在同一个订单应用服务器中，使用一个新的终端窗口，需要启动Kafka消费者。卡夫卡的消费者依赖<code class="fe lo lp lq lr b">karafka</code>:</p><p id="cf01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ bundle exec karafka server</code></p><p id="af59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">14.启动订单管理应用程序</p><p id="3c2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还没有这样做，您需要在本地克隆<a class="ae le" href="https://github.com/pmatsinopoulos/order-entry" rel="noopener ugc nofollow" target="_blank">订单管理应用程序</a> repo。</p><p id="c919" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在repo的根文件夹中，运行<code class="fe lo lp lq lr b">yarn install</code>来安装必要的软件包。</p><p id="1382" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以使用以下命令启动应用程序:</p><p id="15d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">$ yarn start</code></p><p id="6134" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将启动一个浏览器，在地址<code class="fe lo lp lq lr b"><a class="ae le" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code>本地运行应用程序</p><p id="6046" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">15.使用应用程序</p><p id="a170" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切都已设置好，您可以使用该应用程序来创建订单。在浏览器窗口上创建订单时，在此处<a class="ae le" href="http://localhost:3000/orders/new" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/orders/new</a>:</p><ul class=""><li id="60c8" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn mw ll lm ln bi translated">你可以在这里打开另一个浏览器窗口:<a class="ae le" href="http://localhost:3000/orders" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/orders</a>。你会看到新的订单进来。</li><li id="278c" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated">你将会看到Kafka控制台消费者也在他们自己的终端窗口中消费的事件。</li></ul><h2 id="60af" class="nf ly it bd lz ng nh dn md ni nj dp mh kb nk nl ml kf nm nn mp kj no np mt nq bi translated">观看视频</h2><p id="f8f5" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">您可以观看此视频，了解演示应用程序的运行情况:</p><p id="e428" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://youtu.be/9AJnCHci55g" rel="noopener ugc nofollow" target="_blank">https://youtu.be/9AJnCHci55g</a></p><h1 id="7d3d" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">有趣的代码部分</h1><h2 id="cd59" class="nf ly it bd lz ng nh dn md ni nj dp mh kb nk nl ml kf nm nn mp kj no np mt nq bi translated">事件服务器</h2><p id="0992" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">事件服务器是一个非常简单的服务器，它只响应一个<code class="fe lo lp lq lr b">POST /events</code>端点。它已经使用Ruby on Rails实现，并使用gem <code class="fe lo lp lq lr b"><a class="ae le" href="https://rubygems.org/gems/ruby-kafka" rel="noopener ugc nofollow" target="_blank">ruby-kafka</a></code>与Apache Kafka集成。</p><ol class=""><li id="5572" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">卡夫卡的初始化</li></ol><p id="286d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">gem使得初始化Kafka客户端变得非常容易。我们在文件<code class="fe lo lp lq lr b">config/initializers/kafka_init.rb</code>中这样做</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e4e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.事件建模</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/fd61c222cd23cb510c6613cb61e5f67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cO0u6546Nd8dp-Mx7mEy8Q.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">事件建模</figcaption></figure><p id="ed54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们决定将这些事件分为两大类。</p><ul class=""><li id="586d" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn mw ll lm ln bi translated">命令事件:这些事件揭示了改变业务实体状态的意图。例如，当需要创建新的<code class="fe lo lp lq lr b">Order</code>时，会发布一个<code class="fe lo lp lq lr b">CreateOrder</code>事件。消费者对这些事件感兴趣，因为他们负责维护企业实体的状态。</li><li id="12bc" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated">事实事件:这些是描述已经发生的事件的事件，它是一个<em class="nu">事实</em>。例如，事实事件可以是<code class="fe lo lp lq lr b">OrderCreated</code>。也可能是<code class="fe lo lp lq lr b">ActionButtonClicked</code>。这些事件通常用于通知消费者，他们想要对已经承诺、已经发生的事情采取行动。例如，如果我们有一个计算特定按钮点击次数的消费者，这个消费者可能对事件<code class="fe lo lp lq lr b">ActionButtonClicked</code>感兴趣。</li></ul><p id="7634" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nu">参考</em>:如果你想了解更多为什么把命令事件和事实事件分开是有益的，你可以阅读标题为“<a class="ae le" href="https://opencredo.com/blogs/events-and-commands-two-faces-of-the-same-coin/" rel="noopener ugc nofollow" target="_blank">事件和命令:一枚硬币的两面？</a>”。</p><p id="235f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.处理传入事件</p><p id="f908" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示应用程序使用最简单的方法构建事件并将其发送给Kafka:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">向阿帕奇卡夫卡发布事件</figcaption></figure><p id="d2ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了便于演示，这种方法非常简单。例如，根据输入的<code class="fe lo lp lq lr b">event_class</code>，主题名称可以是<code class="fe lo lp lq lr b">events_commands</code>或<code class="fe lo lp lq lr b">events_facts</code>。</p><p id="88b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，接受事件的端点将请求体解析为JSON编码的有效负载，并期望找到:</p><ul class=""><li id="5eba" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn mw ll lm ln bi translated"><code class="fe lo lp lq lr b">event_class</code>:这需要有一个值<code class="fe lo lp lq lr b">Command</code>或<code class="fe lo lp lq lr b">Fact</code>。</li><li id="c5f1" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated"><code class="fe lo lp lq lr b">event_type</code>:带<code class="fe lo lp lq lr b">CreateOrder</code>或<code class="fe lo lp lq lr b">OrderCreated</code>中的一个。</li><li id="510f" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated"><code class="fe lo lp lq lr b">payload</code>:实际事件有效载荷。</li></ul><p id="1a5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.已发布事件的结构</p><p id="3e2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，Kafka接受各种形式的实际发布事件。我们决定使用普通字符串。然而，我们所做的是使用<code class="fe lo lp lq lr b">ActiveSupport::JSON.encode(event)</code>命令对Ruby事件实例进行JSON编码。</p><p id="0f68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示应用程序中使用的事件实例是<code class="fe lo lp lq lr b">Events::Commands::CreateOrder</code>或<code class="fe lo lp lq lr b">Events::Commands::OrderCreated</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b897" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">两者都源自基类<code class="fe lo lp lq lr b">Events::Base</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4c73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于事件是<code class="fe lo lp lq lr b">Events::Commands::CreateOrder</code>或<code class="fe lo lp lq lr b">Events::Commands::OrderCreated</code>的实例，并且<code class="fe lo lp lq lr b">data</code>和<code class="fe lo lp lq lr b">event_id</code>属性源自<code class="fe lo lp lq lr b">Events::Base</code>，这意味着实际事件将是一个JSON对象，例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="19fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个非常简单的设计，在实际的生产应用中，人们需要彻底考虑事件的设计和主题的设计。</p><h2 id="d68a" class="nf ly it bd lz ng nh dn md ni nj dp mh kb nk nl ml kf nm nn mp kj no np mt nq bi translated">订单管理服务器</h2><p id="6ad2" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">这是另一个Ruby on Rails服务器，作为一个卡夫卡消费者，使用<code class="fe lo lp lq lr b"><a class="ae le" href="https://rubygems.org/gems/ruby-kafka" rel="noopener ugc nofollow" target="_blank">karafka</a></code>宝石与Apache卡夫卡集成。</p><ol class=""><li id="1ff4" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated"><code class="fe lo lp lq lr b">karafka</code>配置</li></ol><p id="7904" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以通过各种方式来实现，但是一个简单的方法可以在文件<code class="fe lo lp lq lr b">karafka.rb</code>中实现，我们已经将它放在了<a class="ae le" href="https://github.com/pmatsinopoulos/orders-app-server/blob/main/karafka.rb" rel="noopener ugc nofollow" target="_blank">项目</a>的根文件夹中。</p><p id="d833" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中最重要的部分是卡夫卡的消费者将会从事件中听到的主题的配置。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="94eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上图所示，我们正在建立2个消费群，每个消费群分别来自<code class="fe lo lp lq lr b">events_commands</code>和<code class="fe lo lp lq lr b">events_facts</code>主题。</p><p id="a3b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">消费者的实现在Ruby中实现如下:</p><p id="682f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.<code class="fe lo lp lq lr b">events_commands</code>话题消费者</p><p id="502c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lo lp lq lr b">events_commands</code>主题事件的消费者是<code class="fe lo lp lq lr b">::Commands::EventsConsumer</code>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1b7ab9a3dd18d70ab416a63cd2f2a6ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*7Fvm2bFyFPk5p1NmBTkKXQ.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">events_confumer.rb</figcaption></figure><p id="ece0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们看到它的实际代码之前，让我们确保您理解这个消费者的责任。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0a02ecb6df24fbc11478c3dd02418d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*coLyqWiW3oon4WpPhBkqeA.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">卡夫卡指令消费者的责任</figcaption></figure><p id="89f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">I)卡夫卡命令消费者需要处理来自主题<code class="fe lo lp lq lr b">events_commands</code>的命令事件。</p><p id="ede3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ii)需要在Postgres数据库的<code class="fe lo lp lq lr b">orders</code>表中创建订单。</p><p id="18fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些足以处理命令事件，但是在这个演示应用程序中，创建订单的卡夫卡消费者想告诉世界其他地方这个成功的信息提交。为了实现这一点，它会发布回一个事实事件<code class="fe lo lp lq lr b">OrderCreated</code>。因此，这是它的第三项责任:</p><p id="34cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ii)发布事实事件<code class="fe lo lp lq lr b">OrderCreated</code>以使任何利害关系方知晓。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/896fd761015bc37a4167887df318283c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*dfTDVX6k2SifTKtNqb0QFA.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">卡夫卡指令消费者的第三责任</figcaption></figure><p id="7595" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上图中可以看出，我们已经决定使用发布事件的端点来发布<code class="fe lo lp lq lr b">OrderCreated</code>事实事件，即事件服务器中的<code class="fe lo lp lq lr b">POST /events</code>，尽管我们可以直接发布回Kafka。但是，我们希望为事件的创建提供一个单一的入口点，这样我们就可以应用验证和其他特性，比如身份验证和授权。</p><p id="8c3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">了解了Kafka command消费者的责任之后，现在让我们来看看其背后的实际代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7afb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在第6行清楚地看到订单的创建。对T2的争论来自T3。这种便利是由<code class="fe lo lp lq lr b">karafka</code>宝石提供给我们的。</p><p id="bceb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第7行调用方法<code class="fe lo lp lq lr b">send_reponse_with()</code>。该方法在超类<code class="fe lo lp lq lr b">ApplicationConsumer</code>中实现如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这非常简单，并且遵循将响应委托给相应的<code class="fe lo lp lq lr b">Responder</code>对象的模式。换句话说，<code class="fe lo lp lq lr b">Commands::EventsConsumer</code>通过调用<code class="fe lo lp lq lr b">#respond</code>方法将响应委托给<code class="fe lo lp lq lr b">Commands::EventsResponder</code>对象。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e0d33d8b7c71e12190d079f59280c5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*Rs6M2lUqRDbCn6l2dlctwg.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">命令::事件消费者委派对命令的响应::事件响应者</figcaption></figure><p id="6dd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.响应命令事件</p><p id="c845" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">响应者位于<code class="fe lo lp lq lr b">responders</code>文件夹中:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/b54bcd3766a1099a0f6804dd75dfcbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0s34TdggaGajgPQMmmyCA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">响应者的位置</figcaption></figure><p id="a77a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种特殊情况下，响应者将负责请求创建事实事件<code class="fe lo lp lq lr b">OrderCreated</code>。下面是它的实现代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9c84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它用事实事件的细节准备请求体，并通过调用方法<code class="fe lo lp lq lr b">post_message</code>进行post。该方法在<code class="fe lo lp lq lr b">ApplicationResponder</code>超类中实现。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="8a78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们只是向事件服务器发出一个<code class="fe lo lp lq lr b">POST</code>请求。请求是在宝石<code class="fe lo lp lq lr b"><a class="ae le" href="https://gist.github.com/pmatsinopoulos/4017d8ac36021492c529d585062ec0cd" rel="noopener ugc nofollow" target="_blank">typhoeus</a></code>的帮助下完成的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/8613de9e0ae462550391c038895b1baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3aFmT13J2aepxHrgsSq0g.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">响应者发布到事件服务器</figcaption></figure><p id="889f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.<code class="fe lo lp lq lr b">events_facts</code>话题消费者</p><p id="f2e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的演示应用程序中，我们还设置了另一个消费者，一个用于到达<code class="fe lo lp lq lr b">events_facts</code>主题的事实事件。这个消费者生活在订单管理服务器中，但是它也可能生活在另一个服务器中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/c3e5dc52cb385e71b301f0a69fd2d740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEpwv3VruIfDtdr2Y-oAoA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">事实事件消费者的位置</figcaption></figure><p id="23e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">消费者的责任是将新订单的详细信息推送到浏览器中运行的应用程序，即客户端应用程序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/d3739e232dceffb15f56def45833eb90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hauJhjQnhlPeXqHDDF7Qjg.jpeg"/></div></div></figure><p id="9984" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您从上图中看到的，它通过将订单的细节作为一条<code class="fe lo lp lq lr b">ActionCable</code>消息进行广播来消费<code class="fe lo lp lq lr b">OrderCreated</code>事实事件。换句话说，新订单的细节通过Web套接字被推送到浏览器。</p><p id="0f8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的实际代码可能会让事情变得更清楚:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dfc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.GraphQL请求处理程序</p><p id="a990" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，订单管理服务器处理GraphQL请求。它使用<code class="fe lo lp lq lr b"><a class="ae le" href="https://rubygems.org/gems/graphql" rel="noopener ugc nofollow" target="_blank">graphql</a></code> gem来提供这一功能并公开一个GraphQL API。</p><p id="7da1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示应用程序只公开了一个查询，即获取订单列表。当用户访问URL <code class="fe lo lp lq lr b">/orders</code>时，订单管理Web应用程序使用它来引导其状态。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/c3fe8df931a707837ae202042498aac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*yYOvuxrVnrOt3xgXgRKN7Q.jpeg"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">GraphQL API公开的订单列表</figcaption></figure><p id="1342" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里给出了<code class="fe lo lp lq lr b">query_type.rb</code>的实现:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="541a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而<code class="fe lo lp lq lr b">order_type.rb</code>本身就很简单:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="a3e2" class="nf ly it bd lz ng nh dn md ni nj dp mh kb nk nl ml kf nm nn mp kj no np mt nq bi translated">订单管理Web应用程序</h2><p id="c090" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">这是通过使用</p><ul class=""><li id="12b8" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn mw ll lm ln bi translated">反应</li><li id="c2f9" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated">Redux(反应-还原)</li><li id="b301" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated">带<code class="fe lo lp lq lr b">@rails/actioncable</code>的Web Sockets客户端。</li></ul><ol class=""><li id="1d52" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">设置</li></ol><p id="633b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切都从<code class="fe lo lp lq lr b"><a class="ae le" href="https://github.com/pmatsinopoulos/order-entry/blob/main/src/App.js" rel="noopener ugc nofollow" target="_blank">src/App.js</a></code>文件开始</p><ul class=""><li id="e5b7" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn mw ll lm ln bi translated">设置redux存储</li><li id="bebd" class="lf lg it js b jt ls jx lt kb lu kf lv kj lw kn mw ll lm ln bi translated">我们订阅了<code class="fe lo lp lq lr b">application_messages</code>通道，按照惯例，它需要在浏览器/JavaScript层被称为<code class="fe lo lp lq lr b">ApplicationMessageChannel</code>。</li></ul><p id="ebad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当新消息作为实时更新从服务器传入时，流程从<code class="fe lo lp lq lr b">received</code>处理程序的实现开始。</p><p id="c780" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用redux <code class="fe lo lp lq lr b">dispatch</code>方法来分派正确的动作。</p><p id="2cd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.<code class="fe lo lp lq lr b">Orders</code>反应组分</p><p id="8300" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lo lp lq lr b"><a class="ae le" href="https://github.com/pmatsinopoulos/order-entry/blob/main/src/pages/orders/Orders.js" rel="noopener ugc nofollow" target="_blank">src/pages/orders/Orders.js</a></code>中实现的<code class="fe lo lp lq lr b">Orders</code>组件已经将其属性绑定到redux状态。因此，当<code class="fe lo lp lq lr b">dispatch</code>发生时，该组件知道有新的东西进来并更新其状态。</p><p id="6545" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，组件使用<code class="fe lo lp lq lr b">useEffect</code>钩子，以便使用GraphQL从服务器获取订单列表。</p><h1 id="1f01" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">单柱</h1><p id="5c8c" class="pw-post-body-paragraph jq jr it js b jt mx jv jw jx my jz ka kb mz kd ke kf na kh ki kj nb kl km kn im bi translated">我们不知道你是否注意到了，但是这个演示提出了一个全世界只有一个POST端点的架构。你能做到这种思维转变吗？你有没有想过只用一个POST端点来实现你的新项目？一个只接受事件的端点。我们觉得这个想法很吸引人。你呢？</p><p id="bfe5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">— — — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="0ee0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在的我:我在<a class="ae le" href="https://getlavanda.com/" rel="noopener ugc nofollow" target="_blank">拉万达</a>工作，有很棒的同事和很棒的项目。我是后端工程师的成员。此外，我在<a class="ae le" href="https://www.paneion-odeio.gr/" rel="noopener ugc nofollow" target="_blank">帕宁音乐学院学习音乐。当我不工作时，我尝试软件工程中的新事物，我弹钢琴，阅读音乐，阅读文学作品(大部分是历史)，我看电影，我和我的狗玩耍，和我的家人过着可爱的生活。</a></p></div></div>    
</body>
</html>