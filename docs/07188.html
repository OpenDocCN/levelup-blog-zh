<html>
<head>
<title>An easy and practical approach to structuring Golang applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种简单实用的构造Golang应用程序的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-practical-approach-to-structuring-go-applications-7f77d7f9c189?source=collection_archive---------0-----------------------#2021-01-31">https://levelup.gitconnected.com/a-practical-approach-to-structuring-go-applications-7f77d7f9c189?source=collection_archive---------0-----------------------#2021-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/e61dfe2c5b922dfffdaa7f8c2add0c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*oZ1j-s22SCUMZamIyVeQtQ.jpeg"/></div></figure><p id="27ec" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi kv translated"><span class="l kw kx ky bm kz la lb lc ld di"> 2022 </span>更新。在写这篇更新的时候，距离我发表这篇文章已经一年多了。在这篇文章的最后，我保证第二部分，我必须承认，可能永远不会来了，原因有几个。我不再使用这种结构(我仍然认为这篇文章给了人们一些帮助，但希望在某一点上更新它。我建议你去看看这个<a class="ae le" href="https://github.com/bnkamalesh/goapp" rel="noopener ugc nofollow" target="_blank">回购</a>。其次，关于集成测试，我刚刚发布了一篇关于它的长篇文章，你可以在这里找到<a class="ae le" href="https://medium.com/p/b57a22cac567" rel="noopener"/>。</p><p id="bf51" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="lf">这个帖子也可以在我自己的网站</em> <a class="ae le" href="https://mortenvistisen.com/posts/practical-approach-to-structuring-go-apps" rel="noopener ugc nofollow" target="_blank"> <em class="lf">这里</em> </a> <em class="lf">。</em></p><p id="e840" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">围棋是一门神奇的语言。它很简单，容易推理，并且为您提供了许多现成的工具。然而，当我开始使用Go时，我努力想出如何以一种不使用“企业化”方法的方式来构建我的应用程序。这是我对构建Golang应用程序的看法，这些应用程序开始时很简单，但具有增长的灵活性，这也是我在开始使用Go时想要的。</p><h2 id="498f" class="lg lh it bd li lj lk dn ll lm ln dp lo ki lp lq lr km ls lt lu kq lv lw lx ly bi translated">放弃</h2><p id="8f1f" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">本文基于以下人物(链接到他们的推特):<a class="ae le" href="https://twitter.com/matryer" rel="noopener ugc nofollow" target="_blank">马特·瑞尔、</a> <a class="ae le" href="https://twitter.com/kasiazien" rel="noopener ugc nofollow" target="_blank">凯特·齐恩</a>、<a class="ae le" href="https://twitter.com/joncalhoun" rel="noopener ugc nofollow" target="_blank">乔恩·卡尔霍恩</a>和<a class="ae le" href="https://twitter.com/unclebobmartin" rel="noopener ugc nofollow" target="_blank">罗伯特·马丁</a>。</p><p id="b8ad" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">上面提到的所有人都有自己令人惊叹的文章和教程，你绝对应该去看看。</p><p id="2809" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您只想查看本文项目的代码，请查看<a class="ae le" href="https://github.com/MBvisti/weight-tracker-article" rel="noopener ugc nofollow" target="_blank"> Github库</a>。</p><h1 id="cd46" class="me lh it bd li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu bi translated">项目和工具</h1><p id="3452" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">学习一门新语言总是令人沮丧，而且不得不一遍又一遍地创建相同的待办事项应用程序。因此，我们将制作一个应用程序，允许人们创建一个帐户，在那里他们可以跟踪他们的体重并计算他们的营养需求(受锁定期间体重增加的启发)。您可以随意添加您认为合适的功能到这个应用程序中。</p><p id="caa9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我假设您对Golang和编程有一定的了解，因为这是一个如何构建Go应用程序的实际例子。我们将使用以下内容:</p><ul class=""><li id="114a" class="mv mw it jz b ka kb ke kf ki mx km my kq mz ku na nb nc nd bi translated">Gin Web框架</li><li id="d2eb" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">Go版本1.15以上</li><li id="5b90" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">一种数据库系统</li><li id="2127" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">golang-迁移</li><li id="3a63" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">你最喜欢的IDE(可能是Goland或者VS code——我强烈推荐Goland，它太棒了)</li></ul><h1 id="01f5" class="me lh it bd li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu bi translated">健壮且可扩展的结构的元素</h1><p id="4e3d" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">花一些时间在软件开发上，你会很快了解到程序有时是脆弱的，有时是僵化的。因此，我在我的应用程序结构中寻找这三样东西:</p><ul class=""><li id="4f6c" class="mv mw it jz b ka kb ke kf ki mx km my kq mz ku na nb nc nd bi translated">易测性</li><li id="789c" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">可读性</li><li id="160d" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">适应性</li></ul><p id="581b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以一种使编写测试变得容易的方式编写程序会极大地影响开发人员的生产力。除了可读性，它不仅使您更容易维护和改进旧代码。您还可以让新人更容易地添加到项目中，因为他们在更改或添加代码时会感到有些安全，因为您已经有了测试。最后，具有适应性意味着您的项目可以适应不断变化的需求和复杂性。</p><p id="90fb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">尽可能简单地开始，这样做的好处是你可以快速地重复新的想法，从一开始就解决实际的问题。大多数开发人员在开始新项目时不需要考虑领域驱动的开发，在大多数情况下这可能是浪费时间(当然，除非你在大公司工作，但是你为什么要阅读一篇面向初级Go开发人员的文章)。</p><p id="e6e8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本教程分为三个部分:</p><ul class=""><li id="ce9d" class="mv mw it jz b ka kb ke kf ki mx km my kq mz ku na nb nc nd bi translated">应用程序结构</li><li id="5c94" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">用户服务实现</li><li id="c21b" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">重量服务的TDD实现</li></ul><p id="2491" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这应该有望给你一个总体结构的概述，一个如何添加服务的逐步指南，以及最后用TDD编写测试和开发是多么容易。</p><h1 id="def2" class="me lh it bd li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu bi translated">应用程序结构</h1><p id="21e1" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">好了，说够了，我们走吧。在您想要存储项目的地方创建一个名为<code class="fe nj nk nl nm b">weight-tracker</code>的新文件夹，并在文件夹中运行以下命令:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="9fde" class="lg lh it nm b gy nv nw l nx ny">go mod init weight-tracker</span></pre><p id="752e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该应用程序将遵循如下所示的结构:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="3f06" class="lg lh it nm b gy nv nw l nx ny">weight-tracker<br/>- cmd<br/>  - server<br/>    main.go<br/>- pkg<br/>  - api<br/>    user.go<br/>    weight.go<br/>  - app<br/>    server.go<br/>    handlers.go<br/>    routes.go<br/>  - repository<br/>    storage.go</span></pre><p id="47d5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">继续在您指定的文件夹中创建上面的结构。</p><p id="bc1a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">大多数go项目似乎都遵循一个惯例，即拥有一个<code class="fe nj nk nl nm b">cmd</code>和一个<code class="fe nj nk nl nm b">pkg</code>目录。<code class="fe nj nk nl nm b">cmd</code>将是程序的入口点，让你可以灵活地以多种方式与程序互动。<code class="fe nj nk nl nm b">pkg</code>目录将包含所有其他内容:路线、数据库交互、服务等。</p><p id="c284" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将使用四个包:</p><ul class=""><li id="8e40" class="mv mw it jz b ka kb ke kf ki mx km my kq mz ku na nb nc nd bi translated">主要的</li><li id="77e8" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">美国石油学会(American Petroleum Institute)</li><li id="38f8" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">应用</li><li id="34cc" class="mv mw it jz b ka ne ke nf ki ng km nh kq ni ku na nb nc nd bi translated">仓库</li></ul><p id="b1ac" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你以前做过golang编程，那么这个包应该是不言自明的。我们所有的服务，即<code class="fe nj nk nl nm b">user</code>和<code class="fe nj nk nl nm b">weight</code>服务，都将和一个<code class="fe nj nk nl nm b">definitions</code>文件一起放入<code class="fe nj nk nl nm b">api</code>包中，该文件将包含我们所有的结构(我们将在后面创建)。在<code class="fe nj nk nl nm b">app</code>包中，我们将拥有<code class="fe nj nk nl nm b">server</code>、<code class="fe nj nk nl nm b">handlers</code>和<code class="fe nj nk nl nm b">routes.</code>最后，我们拥有<code class="fe nj nk nl nm b">repository</code>，它将包含我们所有与数据库操作相关的代码。</p><p id="9356" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">打开<code class="fe nj nk nl nm b">main.go</code>并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="676b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你现在应该有很多错误显示在你的IDE中，我们马上会修复这些错误。但首先，让我解释一下这里发生了什么。在我们的<code class="fe nj nk nl nm b">func main()</code>中，我们调用一个名为<code class="fe nj nk nl nm b">run</code>的方法，该方法返回一个错误(如果没有错误，则返回零)。如果<code class="fe nj nk nl nm b">run</code>返回一个错误，我们的程序退出并给出一个错误信息。以这种方式设置我们的<code class="fe nj nk nl nm b">main</code>函数允许我们测试它，从而遵循健壮的服务结构的元素，可测试性。这种设置主函数的方式来自Mat Ryer，他在他的<a class="ae le" href="https://pace.dev/blog/2020/02/12/why-you-shouldnt-use-func-main-in-golang-by-mat-ryer.html" rel="noopener ugc nofollow" target="_blank">博客文章</a>中谈到了更多。</p><p id="1711" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来我们需要讨论的两个主题是<strong class="jz iu">清洁架构</strong>和<strong class="jz iu">依赖注入</strong>。你可能听说过清洁建筑的另一个名字，因为大约在同一时间有一些人写了它。我的大部分灵感来自于<a class="ae le" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">罗伯特·c·马丁</a>，所以这就是我要提到的人。</p><p id="8a7f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们不会严格遵循干净的架构，而是主要采用依赖规则的思想。看看下面的图片:</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/3b02f5bc6ce234bc8129f416096a0bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5WeMzRt5aCVxXNWLlxAJw.png"/></div></div><figcaption class="og oh gj gh gi oi oj bd b be z dk translated">来源:罗伯特·c·马丁的博客——Clean Coder博客</figcaption></figure><p id="a6d3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">罗伯特·马丁文章中的一段引文有助于定义这一规则:</p><blockquote class="ok ol om"><p id="a447" class="jx jy lf jz b ka kb kc kd ke kf kg kh on kj kk kl oo kn ko kp op kr ks kt ku im bi translated"><em class="it">这个规则说源代码依赖只能向内指向。内圈的任何东西都不可能了解外圈的任何东西。</em></p></blockquote><p id="d955" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">粗略地说，内层不应该知道外层。这允许我们实际上改变我们使用的数据库。假设我们正在从PostgreSQL转换到MySQL，或者通过gRPC而不是HTTP来公开我们的API。您很可能永远不会这样做，但这确实说明了这个概念的适应性。</p><p id="086a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了实现这一点，我们将使用依赖注入(简称DI)。基本上，DI是服务应该在创建时接收它们的依赖关系的想法。它允许我们将服务依赖项的创建与服务本身的创建分离开来。这将有助于我们测试代码。如果你想了解更多关于DI的内容，我推荐这篇<a class="ae le" href="https://blog.drewolson.org/dependency-injection-in-go" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="8609" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我通过查看实际代码学习得最好，所以让我们从添加一些缺失的代码开始，这将使<code class="fe nj nk nl nm b">main.go</code>中的代码更有意义。打开<code class="fe nj nk nl nm b">storage.go</code>并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="77f4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这允许我们随时随地创建一个新的存储组件，只要它接收到一个有效的<code class="fe nj nk nl nm b">*sql.DB</code>类型的db参数。</p><p id="e72e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可能已经注意到，我们有一个小写和大写版本的<code class="fe nj nk nl nm b">storage</code>，一个是结构，一个是接口。我们将在小写版本的存储上定义任何方法(如CRUD操作),并在大写版本中定义方法。通过这样做，我们现在可以轻松地模仿<code class="fe nj nk nl nm b">storage</code>进行单元测试。此外，当我们在没有实现方法的情况下向存储接口添加方法时，我们现在可以从IDE获得一些好的建议。</p><p id="27e3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，让我们建立一个服务的基础结构，<code class="fe nj nk nl nm b">user.go</code>。这应该让您对API包将如何构造服务有一个感觉。对于<code class="fe nj nk nl nm b">weight.go</code>服务，您也必须重复这个步骤。只需复制粘贴<code class="fe nj nk nl nm b">user.go</code>的内容，更改命名即可。打开<code class="fe nj nk nl nm b">user.go</code>并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="bcb1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">请注意，我们的用户服务具有存储库依赖性。稍后我们将在这里定义存储库方法(即数据库操作)，但重要的是我们只定义我们需要的方法。因为我们对这些方法的实现不感兴趣，只对行为感兴趣，所以我们可以编写适合给定测试用例的模拟函数。</p><p id="b032" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这可能现在看起来有点模糊，但是现在请容忍我，以后会有意义的。让我们得到一个运行的应用程序，我们可以将实际的逻辑添加到服务中。</p><p id="27f8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">打开<code class="fe nj nk nl nm b">server.go</code>并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d9f0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，打开<code class="fe nj nk nl nm b">routes.go</code>并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8df2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将利用gin的组功能，这样我们就可以根据端点打算服务的资源轻松地对端点进行分组。接下来，让我们添加一个处理程序，这样我们就可以实际调用状态端点并验证我们的应用程序正在运行。打开<code class="fe nj nk nl nm b">handlers.go</code>:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ae07" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此时，我们只需要同步几个依赖项:Gin Web Framework和PostgreSQL的驱动程序。继续在您的终端中键入以下内容:<code class="fe nj nk nl nm b">go get github.com/gin-contrib/cors </code>、<code class="fe nj nk nl nm b">go get github.com/gin-gonic/gin</code>和<code class="fe nj nk nl nm b">go get github.com/lib/pg</code>。</p><p id="7c94" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在一切都应该准备好了，所以进入你的终端，写下:<code class="fe nj nk nl nm b">go run cmd/server/main.go</code>，访问<code class="fe nj nk nl nm b">http://localhost:8080/v1/api/status</code>，你应该会收到一条消息，大意如下:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4f88" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你没有得到上面的消息，请回到前面的步骤，看看你是否遗漏了什么，或者检查一下附带的<a class="ae le" href="https://github.com/MBvisti/weight-tracker-article" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><h1 id="657e" class="me lh it bd li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu bi translated">用户服务实现</h1><p id="31c7" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">至此，我们已经准备好开始构建应用程序的主体了。为此，我们可能需要建立一个包含表和关系的数据库。为此，我们将使用库<code class="fe nj nk nl nm b"><a class="ae le" href="https://github.com/golang-migrate/migrate/" rel="noopener ugc nofollow" target="_blank">golang-migrate</a></code>。我个人喜欢这个库，因为它有一个CLI工具来添加迁移，这使我能够做一些事情，如添加Makefile命令来创建迁移。我鼓励你看一下这个库的文档，这是一个了不起的项目。</p><p id="76e2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">由于文章太长，我不会介绍如何设置它。现在，进入您的终端，确保您在<code class="fe nj nk nl nm b">repository</code>文件夹中并运行:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="2a6d" class="lg lh it nm b gy nv nw l nx ny">git clone <a class="ae le" href="https://gist.github.com/ed090d782dc6ebb35e344ff82aafdddf.git" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ed090d782dc6ebb35e344ff82aafdddf.git</a></span></pre><p id="c093" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这克隆了项目所需的迁移。您现在应该也有了一个名为<code class="fe nj nk nl nm b">ed090d782dc6ebb35e344ff82aafdddf</code>、<strong class="jz iu"> </strong>的文件夹，让我们通过运行以下命令将其更改为迁移:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="6999" class="lg lh it nm b gy nv nw l nx ny">mv ed090d782dc6ebb35e344ff82aafdddf migrations</span></pre><p id="0e50" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在需要做的最后一件事是将<code class="fe nj nk nl nm b">RunMigrations</code>方法添加到<code class="fe nj nk nl nm b">storage.go</code>中:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2bb2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要运行迁移，打开<code class="fe nj nk nl nm b">main.go</code>并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8e7a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在数据库中应该有两个表:user和weight。让我们开始编写一些实际的业务逻辑。</p><p id="ba93" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们想让人们通过我们的API创建一个帐户。让我们从定义用户请求开始，在API文件夹<code class="fe nj nk nl nm b">definitions.go</code>下创建一个名为的文件，并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8be3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们正在定义一个新的用户请求应该是什么样子。请注意，这可能与用户结构看起来不同，我们将结构定义为只包含我们需要的数据。接下来，打开<code class="fe nj nk nl nm b">user.go</code>及以下的<code class="fe nj nk nl nm b">UserService</code>和<code class="fe nj nk nl nm b">UserRepository</code>:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="4c23" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我们在我们的<code class="fe nj nk nl nm b">UserService</code>上定义了一个名为<code class="fe nj nk nl nm b">New</code>的方法，在用户存储库上定义了一个名为<code class="fe nj nk nl nm b">CreateUser</code>的方法。还记得我们之前讨论过的依赖规则吗？这就是<code class="fe nj nk nl nm b">UserRepository</code>上的<code class="fe nj nk nl nm b">CreateUser</code>方法所发生的事情，我们的服务不知道该方法的实际实现，它是什么类型的数据库等等。只是有一个叫做<code class="fe nj nk nl nm b">CreateUser</code>的方法接受一个<code class="fe nj nk nl nm b">NewUserRequest</code>并返回一个错误。这样做的好处是双重的:我们从我们的IDE得到一些指示，一个方法丢失了(打开<code class="fe nj nk nl nm b">main.go</code>并检查<code class="fe nj nk nl nm b">api.NewUserService</code>)以及它需要什么，并且它允许我们容易地编写单元测试。您还应该在<code class="fe nj nk nl nm b">user.go</code>中看到一个来自<code class="fe nj nk nl nm b">NewUserService</code>的错误，告诉我们缺少一个方法。让我们解决这个问题，添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8fd5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们做了一些基本的验证和标准化，但这种方法肯定可以改进。我们仍然需要添加<code class="fe nj nk nl nm b">CreateUser</code>方法，因此打开<code class="fe nj nk nl nm b">storage.go</code>并将下面的<code class="fe nj nk nl nm b">CreateUser</code>方法添加到<code class="fe nj nk nl nm b">Storage</code>接口:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="e910" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，这使得<code class="fe nj nk nl nm b">main.go</code>中的错误消失，但是导致了<code class="fe nj nk nl nm b">NewStorage</code>函数中的新错误。我们需要实现这个方法，就像我们对<code class="fe nj nk nl nm b">UserService</code>所做的那样。在<code class="fe nj nk nl nm b">RunMigrations</code>下面加上这个:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ea96" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同样，这段代码可能需要一些改进，但我会尽量简短。</p><p id="ab7b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，剩下要做的就是通过HTTP公开它，这样人们就可以开始使用我们的API并创建他们的帐户。打开handlers.go并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d83d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将接受一个带有JSON有效负载的请求，并使用gin的ShouldBindJSON方法提取数据。去试试吧！</p><p id="63a0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这花了一些时间，所以让我给你看一个我一直在说的好处:<strong class="jz iu">可测试性</strong>。</p><p id="9a6a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在API文件夹下创建一个名为<code class="fe nj nk nl nm b">user_test.go</code>的文件，并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="9695" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里发生了很多事情，所以让我们一步一步来看。</p><p id="bbe8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们首先创建一个名为<code class="fe nj nk nl nm b">mockUserRepo</code>的结构。我们的<code class="fe nj nk nl nm b">UserService</code>知道它需要一个<code class="fe nj nk nl nm b">UserRepository</code>，方法如下:<code class="fe nj nk nl nm b">CreateUser</code>。然而，它确实关心所述方法的实际实现，这允许我们以任何我们想要的方式模仿行为。在这种情况下，我们说当请求的名称等于“已经创建的测试用户”(我知道这是一个不好的名称，但希望您明白这一点)时，返回一个错误，如果不是，就返回nil。这允许我们模拟数据库的行为，使其适合不同的情况，并测试我们的逻辑是否以我们期望的方式处理它。</p><p id="b18d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，我们创建一个名为<code class="fe nj nk nl nm b">mockUserRepo</code>类型的<code class="fe nj nk nl nm b">mockRepo</code>的新变量，然后创建一个<code class="fe nj nk nl nm b">mockUserService</code>并将<code class="fe nj nk nl nm b">mockRepo</code>传递给它，我们就可以开始了！实际的测试是所谓的表驱动测试。我不会详细讨论它，因为这超出了本文的范围，但是如果你想知道更多，可以看看戴夫·邱晨关于it的文章。</p><p id="e89b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，每当我们向<code class="fe nj nk nl nm b">UserRepository</code>添加一个方法时，我们也必须将它添加到这里，在我们的<code class="fe nj nk nl nm b">mockUserRepo</code>中。我们当然也想进行一些集成测试，但是我真正想通过这篇文章展示的是如何进行单元测试，因为这些测试既便宜又容易编写。</p><p id="9494" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从根目录运行<code class="fe nj nk nl nm b">go test ./...</code>，所有测试都应该通过。</p><h1 id="c16f" class="me lh it bd li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu bi translated">重量服务的TDD实现</h1><p id="3dc1" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">我们的申请现在没什么价值。我们只能创建一个用户，但不能跟踪我们的体重或计算我们需要的热量。让我们改变这一切！</p><p id="03a2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的申请现在没什么价值。我们只能创建一个用户，但不能跟踪我们的体重或计算我们需要的卡路里数。让我们改变这一切！<br/>我是测试驱动开发(TDD)的忠实粉丝，这个应用程序的构造方式让它非常容易使用。我们的权重服务需要三个方法:New、<code class="fe nj nk nl nm b">CalculateBMR</code>和<code class="fe nj nk nl nm b">DailyIntake</code>，我们的存储库中需要两个方法:<code class="fe nj nk nl nm b">CreateWeightEntry</code>和GetUser。打开<code class="fe nj nk nl nm b">weight.go</code>并将以下内容添加到<code class="fe nj nk nl nm b">WeightService</code>和<code class="fe nj nk nl nm b">WeightRepository</code>:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b10d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，我们需要向定义文件中添加三个结构:<code class="fe nj nk nl nm b">´NewWeightRequest</code>、<code class="fe nj nk nl nm b">Weight</code>和<code class="fe nj nk nl nm b">User</code>。打开<code class="fe nj nk nl nm b">weight.go</code>并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d014" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，您将在<code class="fe nj nk nl nm b">NewWeightService</code>上看到一个关于缺少方法的错误。我们还不想写实际的实现，因为我们正在做TDD，所以现在，只需在下面添加这个<code class="fe nj nk nl nm b">NewWeightService</code>:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="029c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">打开<code class="fe nj nk nl nm b">main.go</code>，你会看到我们也有一些被传递给<code class="fe nj nk nl nm b">api.NewWeightService</code>的存储方法。打开<code class="fe nj nk nl nm b">storage.go</code>并添加这些:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b481" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们添加我们将需要的测试，在API文件夹中创建一个名为<code class="fe nj nk nl nm b">weight_test.go</code>的文件，并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="f1be" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">测试的实际内容并不重要，重要的是我们可以快速编写测试并模仿外部依赖，比如与数据库交互的方法。</p><p id="98f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">从根目录运行<code class="fe nj nk nl nm b">go test ./...</code>，您应该会收到很多失败的测试。我们将通过实现这些方法的逻辑来解决这个问题，从我们的<code class="fe nj nk nl nm b">WeightService</code>中的三个开始。将此添加到<code class="fe nj nk nl nm b">NewWeightService</code>下方:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b903" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有了这些方法，所有的测试都应该通过了。</p><p id="dd79" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要做的最后一件事是添加与数据库交互所需的方法。打开<code class="fe nj nk nl nm b">storage.go</code>并添加以下内容:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d560" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们没有以真正的TDD风格来做这件事，但是，它应该再次描绘出我们如何使用TDD来构建Go应用程序并开发它们的画面。请随意重新实现这一部分，并按照真正的TDD风格来做:创建一个测试，让它通过，创建下一个，等等。</p><p id="48da" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在需要的几乎都有了。我们需要做的最后一件事是添加routes和一个处理器来为给定的用户创建一个权重条目。我将把这留给读者去实现，因为构建模块应该已经就位。如果你觉得懒，你可以查看一下附带的Github库。</p><h1 id="ed86" class="me lh it bd li mf mg mh ll mi mj mk lo ml mm mn lr mo mp mq lu mr ms mt lx mu bi translated">结束了</h1><p id="c326" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated">希望本教程能让您对如何构建Golang应用程序有所了解。我知道这很长，但希望你没有浪费时间。在第二部分中，我将展示如何添加Makefile命令、集成测试和轻松部署应用程序。如果您有任何问题或批评，请随时联系我们。</p><p id="0b66" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我的<a class="ae le" href="https://mortenvistisen.com" rel="noopener ugc nofollow" target="_blank">网站</a>、<a class="ae le" href="https://twitter.com/mbvisti" rel="noopener ugc nofollow" target="_blank"> twitter </a>和<a class="ae le" href="https://github.com/mbvisti" rel="noopener ugc nofollow" target="_blank"> github </a>。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="b135" class="me lh it bd li mf ox mh ll mi oy mk lo ml oz mn lr mo pa mq lu mr pb mt lx mu bi translated">资源</h1><p id="1222" class="pw-post-body-paragraph jx jy it jz b ka lz kc kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku im bi translated"><a class="ae le" href="https://github.com/MBvisti/weight-tracker-article" rel="noopener ugc nofollow" target="_blank">项目GitHub </a> <br/> <a class="ae le" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">清洁架构</a><br/><a class="ae le" href="https://github.com/golang-migrate/migrate/" rel="noopener ugc nofollow" target="_blank">Golang-migrate</a><br/><a class="ae le" href="https://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go" rel="noopener ugc nofollow" target="_blank">表驱动测试</a></p></div></div>    
</body>
</html>