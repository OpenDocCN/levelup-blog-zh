<html>
<head>
<title>gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-2c281d2837c3?source=collection_archive---------7-----------------------#2022-12-14">https://levelup.gitconnected.com/grpc-2c281d2837c3?source=collection_archive---------7-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/056f21dceaffb13b135a0f575c18109f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HarOJJ-AaxVPApmnKNI2_Q.png"/></div></div></figure><p id="e450" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我以前的帖子中，我写了一些异步和同步通信。如果你想全面了解沟通类型，我强烈建议你看看下面给出的。</p><p id="c93f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">异步通信</strong></p><div class="kw kx gp gr ky kz"><a rel="noopener  ugc nofollow" target="_blank" href="/apache-kafka-with-java-7c3a0dafd7f5"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">阿帕奇卡夫卡与Java</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">我想讨论的另一种异步通信方式是消息流及其众所周知的平台Apache…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><div class="kw kx gp gr ky kz"><a rel="noopener  ugc nofollow" target="_blank" href="/rabbitmq-with-java-fe4390be6e87"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">使用Java的RabbitMQ</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">有两种不同的通信方式，即同步和异步通信。今天，我想讨论一下异步…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="li l"><div class="lo l lk ll lm li ln jw kz"/></div></div></a></div><p id="6cf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">同步通信</strong></p><div class="kw kx gp gr ky kz"><a rel="noopener  ugc nofollow" target="_blank" href="/restful-with-java-6ff632931d6f"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">用Java实现RESTful</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">在之前的帖子中，我试图解释两个异步通信的例子，Rabbitmq和Kafka。</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="li l"><div class="lp l lk ll lm li ln jw kz"/></div></div></a></div><div class="kw kx gp gr ky kz"><a rel="noopener  ugc nofollow" target="_blank" href="/graphql-with-java-afee21e205ef"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">带Java的GraphQL</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">另一种同步方法是GraphQL。像往常一样，我想更多地关注实现或提供代码。所以，我会提供一个…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="li l"><div class="lq l lk ll lm li ln jw kz"/></div></div></a></div><p id="ddf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我想解释另一种同步方法gRPC(它也可以异步工作)。</p><p id="c397" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是由Google开发的，是一个RPC(远程过程调用)框架。今天，我想提供一些关于gRPC的信息，以便更好地理解它。我会努力为gRPC找到一些问题的答案。然而，如果你想深入研究，在页面底部有很好的参考链接。</p><h2 id="c107" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">远程过程调用</h2><p id="dd57" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">为了更好地理解gRPC，我们应该首先理解RPC。远程过程调用是一种构建分布式系统的技术。基本上，它允许一台机器上的程序调用另一台机器上的子程序，而不知道它是远程的。RPC不是一种传输协议:相反，它是一种以透明的方式使用现有通信特性的方法。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/e42dae5efbf0d06124d031287c8fd0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/0*16xtrq-Z0WvHCTD5.jpg"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">图片来源:<a class="ae my" href="https://www.ibm.com/docs/en/aix/7.1?topic=call-rpc-model" rel="noopener ugc nofollow" target="_blank"> IBM </a></figcaption></figure><h1 id="9fbd" class="mz ls iq bd lt na nb nc lw nd ne nf lz ng nh ni mc nj nk nl mf nm nn no mi np bi translated">gRPC是什么？</h1><p id="dddf" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">gRPC是一个独立于环境的现代开源高性能远程过程调用(RPC)框架。它允许客户端和服务器应用程序透明地通信，并开发连接的系统。这个框架使用HTTP/2、协议缓冲区和其他现代技术栈来确保最大的API安全性、性能和可伸缩性。许多领先的科技公司都使用gRPC，比如谷歌、网飞、Square等等。</p><h1 id="0300" class="mz ls iq bd lt na nb nc lw nd ne nf lz ng nh ni mc nj nk nl mf nm nn no mi np bi translated">gRPC概念</h1><p id="66a2" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">gRPC之所以大放异彩，是因为它的开发和使用领先技术的成功，这些技术比JSON和XML性能更好，并提供了更高的API安全性。gRPC的一些特征如下。</p><h2 id="e25e" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">协议缓冲区</h2><p id="f785" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">Protobuf是Google的序列化/反序列化协议。它用于客户端和远程服务之间的数据交换。gRPC使用这个协议作为他们的接口定义语言(IDL)和序列化工具集。</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d5544ec974d93ebe522f39f5802e0231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*l6uSNeNwGe8Jwl2W.jpg"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">图片来源:<a class="ae my" href="https://www.wallarm.com" rel="noopener ugc nofollow" target="_blank">https://www.wallarm.com</a></figcaption></figure><p id="08ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Protobuf提供了比JSON和XML更多的好处。使用Protobuf进行解析需要的CPU资源更少，因为数据被转换为二进制格式，并且编码的消息更小。</p><h2 id="6d43" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">流动</h2><p id="7b94" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">流是gRPC的另一个关键概念，许多进程可以在一个请求中发生。HTTP/2的多路复用能力(通过一个TCP连接发送多个响应或接收多个请求)使之成为可能。以下是主要的流类型:</p><ul class=""><li id="91de" class="nr ns iq ka b kb kc kf kg kj nt kn nu kr nv kv nw nx ny nz bi translated">一元(无流)</li><li id="9e6b" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">客户端到服务器的流式传输</li><li id="3269" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">服务器到客户端的流式传输</li><li id="4b28" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">双向流</li></ul><h2 id="e612" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">HTTP/2</h2><p id="a723" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">gRPC基于<a class="ae my" href="https://www.wallarm.com/what/what-is-http-2-and-how-is-it-different-from-http-1" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a>开发，于2015年发布，克服了HTTP/1.1的局限性。虽然它与HTTP/1.1兼容，但HTTP/2带来了许多高级功能，例如:</p><ul class=""><li id="ba8b" class="nr ns iq ka b kb kc kf kg kj nt kn nu kr nv kv nw nx ny nz bi translated"><strong class="ka ir">二进制成帧层:</strong>与HTTP/1.1不同，HTTP/2请求/响应被分成小消息，以二进制格式成帧，使得消息传输高效。通过二进制成帧，HTTP/2协议使得请求/响应多路复用成为可能，而不会阻塞网络资源。</li><li id="cd89" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated"><strong class="ka ir">流:</strong>双向全双工流，客户端可以请求，服务器可以同时响应。</li><li id="e367" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated"><strong class="ka ir">流量控制:</strong>HTTP/2中使用了流量控制机制，可以对用于缓冲传输中消息的内存进行详细控制。</li><li id="99e3" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated"><strong class="ka ir">头压缩:</strong>HTTP/2中的所有内容，包括头，在发送之前都进行了编码，显著提高了整体性能。使用HPACK压缩方法，HTTP/2只共享与以前的HTTP头信息包不同的值。</li><li id="18fa" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated"><strong class="ka ir">处理:</strong>使用HTTP/2，gRPC支持同步和异步处理，可以用来执行不同类型的交互和流式RPC。</li></ul><p id="14c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">HTTP/2的所有这些特性使gRPC能够使用更少的资源，从而减少运行在云中的应用和服务之间的响应时间，并延长运行移动设备的客户端的电池寿命。‍</p><h2 id="dc12" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">gRPC的优势</h2><p id="1fc1" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">gRPC通过在某些操作中提供许多好处，为旧的RPC设计方法提供了一个新的视角。gRPC的一些优势使其越来越多地被采用，这些优势如下:</p><ol class=""><li id="6101" class="nr ns iq ka b kb kc kf kg kj nt kn nu kr nv kv of nx ny nz bi translated"><strong class="ka ir">性能</strong></li></ol><p id="2fd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">gRPC提供了比REST+JSON通信快10倍的性能和API安全性，因为它使用了Protobuf和HTTP/2。</p><p id="2d32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。互操作性</strong></p><p id="345d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">gRPC工具和库旨在与多种平台和编程语言一起工作，包括Java、JavaScript、Go、C#等。由于Protobuf二进制有线格式和几乎所有平台的高效代码生成，程序员可以开发高性能的应用程序，同时仍然使用完全的跨平台支持。</p><p id="7b89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。安全性</strong></p><p id="15b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">gRPC通过TLS端到端加密连接使用HTTP/2来确保API安全性。gRPC鼓励使用SSL/TLS来验证和加密客户端和服务器之间交换的数据。</p><p id="873e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4。可用性和生产力</strong></p><p id="2b4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于gRPC是一个一体化的RPC解决方案，它可以无缝地跨各种语言和平台工作。此外，它还具有优秀的工具，自动生成许多所需的样板代码。这节省了大量时间，并使开发人员能够更多地关注业务逻辑。‍</p><h2 id="1bb4" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">gRPC的弱点</h2><p id="ea8b" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">和其他技术一样，gRPC也有以下缺点，当您选择它来开发应用程序时，需要注意这些缺点。</p><ol class=""><li id="b1f7" class="nr ns iq ka b kb kc kf kg kj nt kn nu kr nv kv of nx ny nz bi translated"><strong class="ka ir">缺乏浏览器支持</strong></li></ol><p id="8007" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于gRPC大量使用HTTP/2，目前不可能直接从web浏览器调用gRPC服务。没有一种现代浏览器能够提供对web请求的控制，以支持gRPC客户端。</p><p id="8d08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。非人类可读格式</strong></p><p id="3eda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Protobuf将gRPC消息压缩成非人类可读的格式。这个编译器需要文件中消息的接口描述来正确地反序列化。因此，开发人员需要额外的工具，比如gRPC命令行工具，来分析网络上的Protobuf有效负载，编写手动请求，并执行调试。</p><p id="f78f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。无缓存</strong></p><p id="a0db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然HTTP支持边缘缓存的中介，但gRPC调用使用POST方法，这对API安全性是一个威胁。响应不能通过中介缓存。此外，gRPC规范没有做出任何规定，甚至指出了对服务器和客户机之间的缓存语义的期望。</p><p id="6c7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4。陡峭的学习曲线</strong></p><p id="bd96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">学习gRPC比休息稍微更有挑战性；熟悉Protobuf并寻找处理HTTP/2的工具需要一些时间。这是用户喜欢尽可能长时间依赖REST的常见原因。</p><h2 id="ecb5" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">何时使用gRPC</h2><p id="8507" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">用gRPC代替REST的条件是什么？</p><ul class=""><li id="7ec5" class="nr ns iq ka b kb kc kf kg kj nt kn nu kr nv kv nw nx ny nz bi translated">实时通信服务，您可以在其中处理流式通话</li><li id="d08e" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">当高效沟通是一个目标时</li><li id="dad5" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">在多语言环境中</li><li id="92b1" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">对于内部API，您不必将技术选择强加给客户端</li><li id="3645" class="nr ns iq ka b kb oa kf ob kj oc kn od kr oe kv nw nx ny nz bi translated">作为转换现有RPC API的一部分的新构建可能不值得</li></ul><h2 id="e851" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">采用gRPC的微服务</h2><p id="cbe0" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在我之前的一家公司，我们在内部微服务之间使用gRPC。我们更喜欢它是因为两点:它的高性能和它的多语言特性。</p><p id="5412" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务的最大优势之一是能够为每个独立的服务使用不同的技术。微服务必须就交换数据的API、数据格式、错误模式、负载平衡等达成一致。gRPC允许以二进制格式描述服务合同，程序员可以用一种标准的方式来指定这些合同，独立于任何语言，这确保了互操作性。</p><p id="a525" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的建筑看起来如下:</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/3f63c586c14bf212cc3e02c666b52546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TS_hWu1aV3yVeOEmySYFAg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">在GW和微服务之间使用gRPC</figcaption></figure><p id="9229" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读。</p><p id="8dce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望有帮助。</p><p id="c364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一篇帖子再见…</p><p id="22d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="oh">参考文献:</em> </strong></p><div class="kw kx gp gr ky kz"><a href="https://www.ibm.com/docs/en/aix/7.1?topic=concepts-remote-procedure-call" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">远程过程得</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">远程过程调用(RPC)是一个协议，它提供了在操作系统中使用的高级通信范例</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">www.ibm.com</p></div></div></div></a></div><p id="c85f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae my" href="https://www.w3.org/History/1992/nfs_dxcern_mirror/rpc/doc/Introduction/WhatIs.html" rel="noopener ugc nofollow" target="_blank">https://www . w3 . org/History/1992/NFS _ dx CERN _ mirror/RPC/doc/Introduction/what is . html</a></p><div class="kw kx gp gr ky kz"><a href="https://grpc.io/" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">gRPC</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">gRPC了解更多gRPC是一个现代的开源高性能远程过程调用(RPC)框架，可以运行在任何…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">grpc.io</p></div></div><div class="li l"><div class="oi l lk ll lm li ln jw kz"/></div></div></a></div><div class="kw kx gp gr ky kz"><a href="https://www.altexsoft.com/blog/what-is-grpc/" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">什么是gRPC:主要概念、优缺点、用例</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">编程是为了解决问题。我们通常构建API来解决两个(或两个)非常具体的问题之一…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">www.altexsoft.com</p></div></div><div class="li l"><div class="oj l lk ll lm li ln jw kz"/></div></div></a></div><div class="kw kx gp gr ky kz"><a href="https://www.wallarm.com/what/the-concept-of-grpc" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">gRPC是什么？概念、优势和劣势、架构🔆</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">gRPC是一个健壮的开源RPC(远程过程调用)框架，用于构建可扩展的快速API。它允许…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">www.wallarm.com</p></div></div><div class="li l"><div class="ok l lk ll lm li ln jw kz"/></div></div></a></div><div class="kw kx gp gr ky kz"><a href="https://developers.google.com/protocol-buffers/docs/javatutorial" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">协议缓冲区基础:Java |协议缓冲区| Google开发者</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">本教程为Java程序员提供了使用协议缓冲区的基本介绍。走过…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">developers.google.com</p></div></div><div class="li l"><div class="ol l lk ll lm li ln jw kz"/></div></div></a></div><div class="kw kx gp gr ky kz"><a href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">语言指南(proto3) |协议缓冲区| Google开发者</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">本指南描述了如何使用协议缓冲区语言来构建您的协议缓冲区数据，包括。原型…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">developers.google.com</p></div></div><div class="li l"><div class="om l lk ll lm li ln jw kz"/></div></div></a></div></div></div>    
</body>
</html>