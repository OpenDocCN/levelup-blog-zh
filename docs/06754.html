<html>
<head>
<title>Be Careful With Java Parallel Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小心Java并行流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/be-careful-with-java-parallel-streams-3ed0fd70c3d0?source=collection_archive---------2-----------------------#2020-12-28">https://levelup.gitconnected.com/be-careful-with-java-parallel-streams-3ed0fd70c3d0?source=collection_archive---------2-----------------------#2020-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cd1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Java Stream API很牛逼。这是自Java 8以来最大的改进之一。它允许我们以声明的方式在集合上构建复杂的查询。此外，流API为并行执行提供了一种简单的方法。只需添加<code class="fe kl km kn ko b">parallel()</code>语句或者用<code class="fe kl km kn ko b">parallelStream()</code>函数构造流即可。但是如果您不想处理意外的bug，那么有一个警告是您应该知道的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/82fed636ae7c420fb581f2d242c4bd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*13KeTGV7l558awbAQvNGnQ.png"/></div></figure><p id="fe19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们需要将给定的一组数字相乘，Stream API可以派上用场。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">减流</figcaption></figure><p id="1112" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果是<code class="fe kl km kn ko b">524490120</code>。假设这个数也要乘以5。没问题。我们只需替换归约的身份。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">不同身份的流减少</figcaption></figure><p id="6a3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答案是<code class="fe kl km kn ko b">2622450600</code>。一切按预期运行。</p><p id="7924" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果数据流包含成百上千个数字会怎样？顺序执行可能太慢。让我们使流并行，并测试结果是否相等。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">不同身份的并行流缩减</figcaption></figure><p id="6f74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人惊讶的是，我机器上的结果是<code class="fe kl km kn ko b">40975790625000</code>。那肯定跟<code class="fe kl km kn ko b">2622450600</code>不搭。</p><p id="1149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是怎么回事？Java并行流有bug吗？实际上，一切正常。让我们更深入地了解一下并行流是如何工作的。</p><h2 id="95fd" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">ForkJoinPool</h2><p id="e1fe" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Java流使用<a class="ae mb" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html" rel="noopener ugc nofollow" target="_blank"> ForkJoinPool </a>来启动并行执行。描述这个执行器的细节超出了本文的范围。但是主要思想是任务递归地分成多个块，然后每个块可以独立计算。</p><p id="59ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，这是<code class="fe kl km kn ko b">Stream.reduce</code>顺序执行的示意图。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/e763eecc19efaa6f5e5617911f11b3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oDLXJrrifSQlPNnbh_NJ8g.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">顺序还原</figcaption></figure><p id="14df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，算法非常简单。假设，我们想要并行执行。为了简单起见，让我们假设这个任务只分成两部分。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mh"><img src="../Images/24ef51ca7480b1b0b9611b0d5db3c970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcR9wIK6Ljhd2sYAMZXfCw.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">平行还原</figcaption></figure><p id="a2f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个块都被乘以5。因为这就是平行流的工作方式。它为每个确定的块应用给定的身份。</p><p id="446b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何解决这个问题？我们需要做的就是将<code class="fe kl km kn ko b">5</code>放在<code class="fe kl km kn ko b">reduce</code>函数的外面。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">无错误并行流减少</figcaption></figure><p id="3656" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乘以<code class="fe kl km kn ko b">1</code>不影响结果。所以不管有多少块。</p><p id="5832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据给出的例子，我可以给你一些设计你的流API案例的建议。</p><h2 id="bafe" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">减少应分裂</h2><p id="b578" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果您不确定流是否是顺序的(例如，它是作为函数参数来的)，那么<code class="fe kl km kn ko b">reduce</code>函数的<code class="fe kl km kn ko b">identity</code>不应该影响单个块的结果。这意味着，求和函数在与函数<code class="fe kl km kn ko b">1</code>相乘时必须接受<code class="fe kl km kn ko b">0</code>。</p><h2 id="f402" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">也许你不需要平行流</h2><p id="748e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">不是所有流操作都应该并行化。例如，<code class="fe kl km kn ko b">map</code>、<code class="fe kl km kn ko b">flatMap</code>和<code class="fe kl km kn ko b">filter</code>是很好的候选，因为他们是无国籍的。另一方面，<code class="fe kl km kn ko b">sorted</code>、<code class="fe kl km kn ko b">distinct</code>和<code class="fe kl km kn ko b">limit</code>可能不会显示出良好的性能增强。</p><p id="f4d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不仅如此，并行化的有效性很大程度上取决于流的来源。一个<code class="fe kl km kn ko b">ArrayList</code>、一个数组或者<code class="fe kl km kn ko b">IntStream.range</code>支持随机访问，这意味着它们可以很容易地分开。但是<code class="fe kl km kn ko b">LinkedList</code>需要<code class="fe kl km kn ko b">O(n)</code>时间来分解。另外<code class="fe kl km kn ko b">Stream.iterate</code>和<code class="fe kl km kn ko b">BufferedReader</code>也不是一个好的选择，因为它们在开头都有一个未知的长度，所以很难估计何时拆分源。</p><h2 id="5c60" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">编写单元测试</h2><p id="ee9d" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们已经看到，每个并行流不仅是潜在的性能优势，也是漏洞所在。因此，每次用并行流替换顺序流时，都要确保功能没有被破坏。</p><h2 id="e7de" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">结论</h2><p id="4467" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们可以看到，Stream API并没有看起来那么明显。我想推荐一本书，它不仅完美地描述了Stream API及其注意事项，而且完全描述了Java 8 lambdas。是“<a class="ae mb" href="https://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming-ebook/dp/B00J3B3J3C" rel="noopener ugc nofollow" target="_blank"> Java 8 Lambdas:实用函数式编程</a>”。如果您有任何问题或建议，请在下面写下您的意见。感谢阅读！</p></div></div>    
</body>
</html>