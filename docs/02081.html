<html>
<head>
<title>Algorithms and Data Structures in Swift: Big-O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的算法和数据结构:Big-O符号</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/algorithms-and-data-structures-in-swift-big-o-notation-579fdd38f3d8?source=collection_archive---------12-----------------------#2020-02-17">https://levelup.gitconnected.com/algorithms-and-data-structures-in-swift-big-o-notation-579fdd38f3d8?source=collection_archive---------12-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="09cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始使用Swift中的算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6bad57e930eba80d080853181fc86bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Scrn99wIUMVhaEqIM1ic0w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·Ku在<a class="ae ky" href="https://unsplash.com/s/photos/time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="b0af" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="55c5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们将深入研究Big-O符号，编写我们的第一个算法，并通过Swift标准库中的一个具体示例来说明算法运行时间增长的重要性。</p><p id="6bd5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">理解Big-O符号对于算法的比较和设计是必不可少的，因此对于后面的文章也是必不可少的，所以我认为这是一个很好的起点。</p><p id="733f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们走吧。</p><h1 id="9512" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是大O记数法？</h1><p id="eecf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Big-O符号是一种度量标准，我们用它来判断随着输入大小的增加，算法运行时间的增长率。这叫做<strong class="lt iu">时间复杂性。</strong></p><p id="968e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还可能关心算法需要的内存量，或者在进行递归调用时关心堆栈空间。这叫<strong class="lt iu">空间复杂度</strong>，也是用Big-O来描述的。</p><p id="d00a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，我们最感兴趣的是算法的时间复杂度，这也是我在进一步的分析中要提到的。</p><h2 id="7140" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">渐近时间</h2><p id="7795" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当谈到时间复杂性时，Big-O时间通常被称为算法的渐近运行时间。这意味着什么呢？这非常重要，我想先谈谈这个问题。</p><p id="b3d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">渐近复杂性使用<strong class="lt iu"> <em class="ne">主导项</em> </strong>表达算法的增长。为了理解这一点，考虑一个例子:</p><p id="a2cf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们有两个算法，姑且称之为a <em class="ne">算法A </em>和<em class="ne">算法B </em>，运行时间分别为<em class="ne"> O(n) </em>和<em class="ne"> O(2n) </em>。两者中哪一个渐进地更有效？</p><p id="c8d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你可能会认为算法A更有效，因为n小于2n。然而，这是不正确的。事实是，它们在渐近上是同样有效的。</p><p id="8bae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是因为唯一的主导项是n。一旦n变得足够大，就会主导算法的增长率，让2变得无关紧要。由此我们可以得出两个重要的事实:</p><ol class=""><li id="a093" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">当计算渐近效率时，常数因子和非主导项可以被丢弃，因为它们对算法的长期增长率没有影响。在上面的例子中，将n乘以常数2只会使运行时间增加该常数因子。<strong class="lt iu">算法还是会线性增长。</strong>像O(n + n)这样的运行时也是如此，其中唯一的主导项是n，所以变成O(n)。</li><li id="c021" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">渐近效率不关心一个算法需要运行多长时间。它关心算法如何扩展。当然，算法B将需要更长的时间来运行，但总体增长率将与算法a相同。</li></ol><h1 id="c46f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">大O、大θ和大ω</h1><p id="9dfb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我希望到目前为止一切都说得通，因为我想让你更加困惑。</p><p id="52e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以区分三种记谱法。它们是Big-O、Big-ω(大ω)和Big-θ(大θ)。对于每一个，我将从它的正式定义开始，然后我们将检查它们在实践中的含义。</p><h2 id="b2f5" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">大O:</h2><p id="a1ac" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Big-O给出了函数的一个<em class="ne">渐近上界</em>。</p><p id="f762" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正式定义如下:</p><blockquote class="nt nu nv"><p id="9a62" class="lr ls ne lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">对于给定的函数g(n)，我们用O(g(n))表示函数集:</p><p id="710e" class="lr ls ne lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">O(g(n)) = { f(n):存在正常数c和nₒ使得0 ≤ f(n) ≤ c * g(n)对于所有n ≥ nₒ }</p></blockquote><p id="95d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">那么这意味着什么呢？这可能过于简单，但是为了用一句简单的话来解释以上内容，我们可以说，Big-O意味着<strong class="lt iu">函数的增长率永远不会比这个更差。</strong></p><p id="7cf4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在一个实际的例子:下面我们将编写我们的第一个算法，插入排序，它(剧透警报)的运行时间为O(n)。</p><p id="bf8d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这也意味着它的运行时间为O(n)，O(n⁴等。因为绝对不会比这些差。</p><p id="63d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如图1所示，f(n)的值总是位于c*g(n)之上或之下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/fd961430cae537ab46e106bfeeef2e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*sbMC0Kw0ZakQk5FI0CnTjQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb">图1:大O符号</strong></figcaption></figure><h2 id="3cb1" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">大ω(大ω):</h2><p id="d44a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">big-ω给出了函数的一个<em class="ne">渐近下界</em>。</p><p id="df34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正式定义如下:</p><blockquote class="nt nu nv"><p id="2cb1" class="lr ls ne lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">对于给定的函数g(n)，我们用ω(g(n))表示函数集:</p><p id="fc91" class="lr ls ne lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">ω(g(n))= { f(n):存在正常数c和nₒ使得0 ≤ c*g(n) ≤ f(n)对于所有n ≥ nₒ }</p></blockquote><p id="9401" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">把我们用Big-O的逻辑反过来，我们可以说，用Big-ω，我们的意思是<strong class="lt iu">函数的运行时间永远不会比这更好。</strong></p><p id="410d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当数组已经排序时，插入排序的最佳运行时间为<em class="ne">ω(n)</em>。写<em class="ne">ω(log n)</em>和<em class="ne">ω(1)</em>也是正确的，因为<strong class="lt iu">算法永远不会像这样快。</strong></p><p id="28c6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如图1所示，f(n)的值总是位于c*g(n)之上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/aa73caa90564d64039df54f7b2e8b075.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*s8jIxdXLDAsF6MExRRDqZg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb">图2:大-<em class="ob">ω符号</em> </strong></figcaption></figure><h2 id="260e" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">大θ(大θ):</h2><p id="a5dc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Big-θ给出了函数的一个<em class="ne">渐近紧界</em>。</p><p id="01f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正式定义如下:</p><blockquote class="nt nu nv"><p id="1607" class="lr ls ne lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">对于给定的函数g(n)，我们用θ(g(n))表示函数集:</p><p id="a7a3" class="lr ls ne lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">θ(g(n)) = {f(n):存在正常数c₁，c₂和nₒ使得0 ≤ c₁*g(n) ≤ f(n) ≤ c₂*g(n)对于所有n ≥ nₒ }</p></blockquote><p id="8d0e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简而言之，Big-θ意味着<strong class="lt iu">一个同时为O和<em class="ne">ω的运行时。</em>T29】</strong></p><p id="48e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们看到的，插入排序是O(n)和ω(n ),因此，它是θ(n)。</p><blockquote class="nt nu nv"><p id="1785" class="lr ls ne lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">“在工业界(因此在采访中)，人们似乎已经把θ和O融合在一起了。业界对大O的定义更接近于学术界对θ的定义，因为将打印数组描述为O(n)被认为是不正确的。行业只会说这是O(n)。”— <em class="it">破解编码采访:盖尔·拉克曼·麦克道尔</em></p></blockquote><p id="1762" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以在图3中看到渐近紧界是什么样子的。<em class="ne"> f(n) </em>的值总是落在<em class="ne"> c₁*g(n) </em>和<em class="ne"> c₂*g(n) </em>之间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/7a82d9f7a546f92307b965b6e0bc0473.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*DqizqSqZWnTKg59um3qeqA.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb">图3:大θ符号</strong></figcaption></figure><h1 id="5203" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">最常见的运行时</h1><p id="8472" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在深入研究代码之前，让我们回顾一下您将遇到的一些最常见的运行时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/89bd8b0d49c67868713b201e641cf420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYHpQ4AMflp2OBpkXGyIVA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd lb">图4:最常见的运行时间</strong></figcaption></figure><p id="e1d6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> O(1): </strong>这就是所谓的<em class="ne">常数</em>时间。无论n的大小如何，执行该操作所需的时间总是相同的。这是你能拥有的最好的时间复杂度，但也是非常罕见的。</p><p id="3f6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> O(log n) </strong>:这个叫<em class="ne">对数</em>时间。O(log n)仍然是一个相当高效的运行时。O(log n)时间算法的一个例子是二分搜索法。</p><p id="3b4e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> O(n) </strong>:这叫<em class="ne">线性</em>时间。运行时间最多随着输入的大小线性增加。打印数组中所有值的算法的时间为O(n ),因为它所需的时间与n的大小成正比。</p><p id="1ff1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> O(n log n) </strong>:这就是所谓的<em class="ne">线性算法</em>时间。这个运行时的两个例子是合并排序和堆排序。</p><p id="71c6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> O(n ) </strong>:这个叫<em class="ne">二次</em>时间。这通常被认为是一个非常糟糕的运行时。插入排序就是一个例子。</p><h1 id="6a18" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">插入排序</h1><p id="ee8c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们对时间复杂性有了一些了解，是时候将我们的知识付诸实践了。</p><p id="5d03" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们要构造的算法叫做<em class="ne">插入排序</em>。像所有排序算法一样，它解决了排序问题:</p><blockquote class="nt nu nv"><p id="fa97" class="lr ls ne lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated"><em class="it">给定一个由n个数字组成的序列(a₁，a₂，…安)，返回该序列的一个排列，使得aٰ₁ ≤ aٰ₂ ≤ … ≤ aٰn. </em></p></blockquote><p id="45f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">插入排序是一个非常简单的算法，它就地对输入数组进行排序。对于较小的输入大小，这可能是一个不错的选择，但是一旦n变得足够大，其他算法就会胜过它。</p><p id="6a81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">解释插入排序的老方法是把它比作一手扑克牌的排序。</p><p id="a2f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们有一手n张扑克牌，一张一张地拿出每张牌，通过从左到右与每张牌进行比较来确定它的正确位置。这就是这个名字的由来，因为我们取出物品并把它们放回正确的位置。</p><p id="a8f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">图5展示了对一个包含6个元素的数组进行插入排序的操作。紫色矩形表示当前从数组中取出的元素，灰色矩形表示与之比较的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/9203594377e5d8a84049e7d0d25d7eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9hPiMQpPmRXL8kSH2tadA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图5:插入排序的操作</figcaption></figure><ul class=""><li id="2f8c" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm of nl nm nn bi translated">我们迭代数组中的每个元素，跳过第一个元素，因为它已经是一个排序的子数组。</li><li id="ea96" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">该元素从右到左与排序后的子数组中的每一项进行比较。</li><li id="89db" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">当一个值大于当前元素时，它向右移动一个位置。</li><li id="a5bd" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">如果有一个更小的项目或者到达了子数组的末尾，当前项目将被插入到该槽中。</li></ul></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="fc26" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们动手写一些代码吧！</p><p id="d0f5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想编码，现在是在Xcode中创建一个新游戏场的最佳时机。</p><p id="5e9c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我们喜欢<a class="ae ky" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干代码(<em class="ne">不要重复</em> ) </a>代码，讨厌湿代码(<em class="ne">我们喜欢打字</em>)代码，所以我们将使我们的插入排序算法通用化。这样，我们只需编写一次函数，就能够对符合<a class="ae ky" href="https://developer.apple.com/documentation/swift/comparable" rel="noopener ugc nofollow" target="_blank"> Comparable </a>的任何类型进行排序。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="b7bd" class="ms la it oo b gy os ot l ou ov">func insertionSort &lt;T: Comparable&gt;(array: inout [T]) {<br/>    //...<br/>}</span></pre><p id="d82c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">到目前为止，这相当简单:</p><ul class=""><li id="953e" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm of nl nm nn bi translated">我们创建一个新函数，并声明一个符合Comparable的泛型变量。</li><li id="8f61" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">我们将输入指定为包含通用元素的数组。</li><li id="281e" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">因为我们之前说过插入排序会对数组进行排序，所以我们的输入必须是一个<a class="ae ky" href="https://stackoverflow.com/a/34486086/10706839" rel="noopener ugc nofollow" target="_blank"> inout </a>参数。</li></ul><p id="88e6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们要做的第一件事是检查传入的数组是否为空。如果是，我们就返回。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="04d6" class="ms la it oo b gy os ot l ou ov">if array.isEmpty {<br/>   return<br/>}</span></pre><p id="b3c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们必须按照上面简单例子中的步骤实现我们的算法。</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="4183" class="ms la it oo b gy os ot l ou ov">for i in 1..&lt;array.count {<br/>    var pos = i<br/>    let temp = array[i]</span><span id="5655" class="ms la it oo b gy ow ot l ou ov">while pos &gt; 0 &amp;&amp; array[pos - 1] &gt; temp {<br/>       array[pos] = array[pos - 1]<br/>       pos -= 1<br/>    }<br/>    array[pos] = temp<br/>}</span></pre><p id="30a7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看看这里发生了什么:</p><ul class=""><li id="98f2" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm of nl nm nn bi translated">我们迭代数组，从第二个元素开始。</li><li id="b474" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">我们创建一个变量来存储当前的索引。</li><li id="a795" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">我们创建一个变量来临时存储从数组中取出的当前元素。</li><li id="d23c" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">然后，当元素比我们的临时变量大的时候，当我们不在数组的末尾的时候，我们想继续向右移动元素。</li><li id="5205" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">如果上述先决条件为真，我们将元素推到右边，并将<em class="ne"> pos </em>的值减1。这样，当while循环再次执行时，它将检查左边的下一个元素。</li><li id="eecd" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated">当一个元素不大于我们的临时变量时，或者当到达数组的末尾时，我们将临时变量插入到发生这种情况的索引中。</li></ul><p id="527b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个过程的结果是一个排序后的数组。</p><p id="1fb9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要测试我们的代码:</p><pre class="kj kk kl km gt on oo op oq aw or bi"><span id="6e9e" class="ms la it oo b gy os ot l ou ov">var array = [6, 3, 5, 7, 2, 4]<br/>insertionSort(array: &amp;array)<br/>print(array) //[2, 3, 4, 5, 6, 7]</span></pre><p id="bef6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是整个算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h2 id="2ce2" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">插入排序分析</h2><p id="946a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在分析时间复杂性时，一般情况往往与最坏情况相同。这里，最坏的情况发生在数组顺序相反的时候，所以这就是我们要关注的。</p><p id="cefb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们假设执行上面的每一行代码需要恒定的时间。一行可能比另一行花费不同的时间，但是为了简化我们的分析，让我们假设为一个元素运行我们的for循环花费<em class="ne"> c </em>时间。</p><p id="4e98" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们必须将每个元素<em class="ne">数组【I】</em>与整个排序后的子数组进行比较。</p><p id="e519" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们插入一个有<em class="ne"> k </em>个元素的子数组，在第一次调用<em class="ne"> k=1 </em>，然后<em class="ne"> k=2 </em>一直到<em class="ne"> k=n-1 </em>。</p><p id="02a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这使我们的总时间为:</p><p id="5b08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">c*1 + c*2 + … c*n-1=c*(1+2+…(n-1))</p><p id="8623" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是一个上升到n-1的<a class="ae ky" href="https://www.mathwords.com/a/arithmetic_series.htm" rel="noopener ugc nofollow" target="_blank">等差数列</a>。使用算术级数的公式，我们最终得到:</p><p id="fe3e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">cn . 2-cn . 2</p><p id="8f6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们现在丢弃非主导项和常数因子，我们最终得到的是θ(n)。</p><h1 id="d187" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">实际例子</h1><p id="ff28" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这一切都很好，但现在你可能想知道当涉及到构建iOS应用程序的日常工作时，所有这些有什么实际用途。的确，你可以在不了解所有这些的情况下构建应用程序。</p><p id="6027" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，在结束本文之前，我想给出一个实际的例子，在这个例子中，这种类型的知识非常有用。</p><p id="6643" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设您必须检查一个元素是否包含在一个非常大的元素池的集合中。(如果你在一家大公司工作，这是一个完全可以想象的场景。)</p><p id="66ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">细节可以单独作为一篇文章来讨论，我们先不说细节，只说测试成员资格的集合是数组还是集合非常重要。</p><p id="636a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">集合是用哈希表实现的，它本质上是一个只存储键的字典。查找一个值需要恒定的时间。</p><p id="73b7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相比之下，在数组中查找值需要线性时间。</p><p id="5547" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以你有<em class="ne"> O(1) </em> vs. <em class="ne"> O(n) </em>。例如，如果您必须在100万用户的集合中找到某个用户，那么两个运行时之间的差异就会变得非常大。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="6f56" class="kz la it bd lb lc oz le lf lg pa li lj jz pb ka ll kc pc kd ln kf pd kg lp lq bi translated">结论</h1><p id="fd67" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们回顾了渐近效率的基本概念，了解了一些最常见的运行时，实现并分析了我们的第一个算法，并探索了Big-O重要性的真实示例。</p><p id="211b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">感谢你阅读这篇文章，我希望你从中获得价值。如果您有任何问题或想法，请随时回复。</p><p id="cb83" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">资源:</p><ul class=""><li id="2501" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm of nl nm nn bi translated"><a class="ae ky" href="https://gist.github.com/lajosdeme/379b4c951529d501f9e0c684b88b78ae" rel="noopener ugc nofollow" target="_blank">插入排序</a></li><li id="a72f" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated"><a class="ae ky" href="http://Introduction to Algorithms" rel="noopener ugc nofollow" target="_blank">算法介绍</a></li><li id="3ba4" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated"><a class="ae ky" href="https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850/ref=sr_1_1?crid=7YIYYRFDVXQV&amp;keywords=cracking+the+coding+interview&amp;qid=1581365610&amp;sprefix=cracking+the+cod%2Caps%2C279&amp;sr=8-1" rel="noopener ugc nofollow" target="_blank">破解编码面试</a></li><li id="916a" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm of nl nm nn bi translated"><a class="ae ky" href="https://www.mathwords.com/a/arithmetic_series.htm" rel="noopener ugc nofollow" target="_blank">等差数列</a></li></ul></div></div>    
</body>
</html>