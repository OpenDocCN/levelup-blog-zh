<html>
<head>
<title>Securing a Microservice in Quarkus with OpenID Connect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenID Connect保护Quarkus中的微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/securing-a-microservice-in-quarkus-with-openid-connect-505204d1c9a9?source=collection_archive---------11-----------------------#2020-08-17">https://levelup.gitconnected.com/securing-a-microservice-in-quarkus-with-openid-connect-505204d1c9a9?source=collection_archive---------11-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6fb49c66d79742ed96c472ea435de593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDMv3nzRaYsgklB02Z0t8Q.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">杰森·登特在<a class="ae kc" href="https://unsplash.com/s/photos/safe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="46e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">这是用Quarkus、Kotlin和Debezium从头开始构建微服务系列的第四部分。该服务用于发送短信。</p><p id="7ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一部分中，我们构建了基本框架并添加了持久性。在<a class="ae kc" href="https://medium.com/@changeant/implementing-the-transactional-outbox-pattern-with-debezium-in-quarkus-f2680306951" rel="noopener">第二部分</a>中，我们使用CDC从持久化的SMS消息中生成事件。我们构建了一个消息处理程序来处理发送到Kafka主题的消息。在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-resilient-microservice-with-quarkus-and-wiremock-de59b2a4fac7">第三部分</a>中，我们添加了几个SMS提供者和一个路由器，它根据简单的随机算法将消息发送给第三方提供者。测试使用wiremock来剔除来自提供者的响应。</p><p id="430b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务的当前状态使端点对任何调用方完全开放。我们需要增加安全性，只允许授权用户或客户访问服务。将授权委托给第三方(如Okta、Google、Auth0)或使用现成的解决方案(如Keycloak或Gluu)越来越常见。我们将使用OpenID Connect来获取一个访问令牌，并确保只接受来自我们列入白名单的提供商的令牌。为了测试，我们将使用Keycloak，为了运行真正的服务，我们将使用Okta。</p><h2 id="4530" class="lk ll iq bd lm ln lo dn lp lq lr dp ls ko lt lu lv ks lw lx ly kw lz ma mb mc bi translated">OpenID连接(OIDC)</h2><p id="12c4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi lb translated">O penID是建立在OAuth 2.0之上的身份层。它允许用户向提供商进行身份验证，并以JWT的形式获得访问令牌。该协议允许客户端通过ID令牌和/或userinfo端点获取有关用户的信息。jwt包含嵌入在访问令牌中的标准<a class="ae kc" href="https://tools.ietf.org/html/rfc7519#page-9" rel="noopener ugc nofollow" target="_blank">声明</a>，如<strong class="kf ir"> sub </strong>和<strong class="kf ir"> iss </strong>，它们标识了谁发布了令牌以及谁是令牌的持有者。</p><p id="4c4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">兼容的OIDC提供者必须提供一个<a class="ae kc" href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig" rel="noopener ugc nofollow" target="_blank">配置</a>发现端点，允许应用程序发现所有必要的端点和公钥位置信息。</p><p id="727c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下代码片段显示了响应中可能出现的一些属性:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7e2c" class="lk ll iq mn b gy mr ms l mt mu">"issuer": "https://server.example.com",<br/>"authorization_endpoint":<br/>     "https://server.example.com/connect/authorize",<br/>"token_endpoint":<br/>     "https://server.example.com/connect/token",<br/>"token_endpoint_auth_methods_supported":<br/>     ["client_secret_basic", "private_key_jwt"],<br/>"token_endpoint_auth_signing_alg_values_supported":<br/>     ["RS256", "ES256"],<br/>"userinfo_endpoint":<br/>     "https://server.example.com/connect/userinfo",<br/>"check_session_iframe":<br/>     "https://server.example.com/connect/check_session",<br/>"end_session_endpoint":<br/>     "https://server.example.com/connect/end_session",<br/>"jwks_uri":<br/>     "https://server.example.com/jwks.json",<br/>"registration_endpoint":<br/>     "https://server.example.com/connect/register"</span></pre><h2 id="0577" class="lk ll iq bd lm ln lo dn lp lq lr dp ls ko lt lu lv ks lw lx ly kw lz ma mb mc bi translated">签署和验证jwt</h2><p id="f197" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">T</span>OIDC提供者负责使用非对称签名算法对JWT进行签名。私钥由提供商持有，公钥提供给客户，以便他们可以验证JWT的签名。</p><p id="3641" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JWT的报头部分包含查找公钥并对其进行验证所需的信息。即</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e1d8" class="lk ll iq mn b gy mr ms l mt mu">{<br/>  "kid": "T_B6HlPCcu8jZjbWVZDi8s2l6euVEFTewiZba_zSd4E",<br/>  "typ": "JWT",<br/>  "alg": "RS256"<br/>}</span></pre><p id="8620" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过使用JSON Web Key Set (JWKS)可以获得公钥，这是IETF <a class="ae kc" href="https://tools.ietf.org/html/rfc7517" rel="noopener ugc nofollow" target="_blank">标准</a>。密钥通常缓存在客户端以最小化延迟，并在服务器端定期轮换。</p><p id="ed82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是来自jwks端点的典型响应，显示了用于签署JWT的算法以及公钥的模数和指数。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4016" class="lk ll iq mn b gy mr ms l mt mu">{<br/> "keys"[ <br/>  {<br/>   "kty":"RSA",<br/>   "alg":"RS256",<br/>   "kid":"T_B6HlPCcu8jZjbWVZDi8s2l6euVEFTewiZba_zSd4E",<br/>   "use":"sig",<br/>   "e":"AQAB",<br/>   "n":"osU_UWAPB27w4vqfy7c_iRqB3JpFUMnK3w34fU0hoRVeWnMYzk-lwEbOPeghndyaEpKGJZZ3Md7qmQ7gFmKaAcNxtbtyC0Bq4sKkPJlLc-QbZ46AfVv36zzUC_dWVLTUXEVGF8fAISG660WKzQqLgx0UQHtnR3ht4F0rgXOYZ5n4K8dHZt3q7kR-2V_j0ornNjiID9F_GF1XmeMSES4uRHlTYtTTKeV69y8c7-F8SKz97pnJdeZDsYjDM1jsG-UEeVk54GSfOuVe2hMkluIWnpoIzlH8-AheqVf6GVdL6E-gyjfErqG2oedojo1zN_9RTgs6vaMf0Sut7j5UjqExxQ"<br/>  }<br/> ]<br/>}</span></pre><p id="1574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们的微服务接收到一个包含JWT的请求时，首先检查缓存的键，在头中找到kid的匹配项。如果没有匹配，那么它将需要向JWKS端点请求最新的密钥集。只有当它找到与孩子匹配的密钥时，它才能尝试验证JWT的签名。如果一个我们无法验证的JWT到达，那么访问将被拒绝。</p><h2 id="1011" class="lk ll iq bd lm ln lo dn lp lq lr dp ls ko lt lu lv ks lw lx ly kw lz ma mb mc bi translated">增加Quarkus的安全性</h2><p id="5870" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了跟随代码，你可以拉动分支</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a1c7" class="lk ll iq mn b gy mr ms l mt mu">git clone <a class="ae kc" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:iainporter/sms-service.git<br/>git checkout part_four</span></pre><p id="39d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要向POM.xml添加OIDC扩展</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e885" class="lk ll iq mn b gy mr ms l mt mu">&lt;dependency&gt;<br/>  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>  &lt;artifactId&gt;quarkus-oidc&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="62dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在已经添加了依赖项，我们可以将安全注释添加到我们希望保护的每个端点。我们现在应该预料到对这些端点的任何测试都会因401未授权而失败。</p><p id="af30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，对于这个实现，我们所关心的是调用者有一个有效的JWT。我们不检查角色或权限。这是下一篇文章的主题。然而，为了审计的目的，最好能捕获谁调用了服务，所以让我们注入JWT(第2行)并从JWT中提取子声明，并将其与消息一起保存(第7行)。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="1dbd" class="lk ll iq bd lm ln lo dn lp lq lr dp ls ko lt lu lv ks lw lx ly kw lz ma mb mc bi translated">单元测试JWT验证</h2><p id="7c49" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了通过测试，我们必须生成一个应用程序可以验证的JWT。我们需要做到以下几点:</p><ul class=""><li id="8752" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">生成RSA密钥对</li><li id="cf13" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">使用密钥对的私钥生成JWT</li><li id="48e3" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">存根OIDC已知端点返回一个指向wiremock实例的URI</li><li id="5c55" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">在我们的wiremock实例中存根JWKS端点，以返回密钥对的公钥</li><li id="0183" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">包括JWT作为请求报头中的承载令牌</li></ul><p id="3daf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了帮助完成这些任务，我们可以使用光轮库</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5257" class="lk ll iq mn b gy mr ms l mt mu">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.nimbusds&lt;/groupId&gt;<br/>  &lt;artifactId&gt;nimbus-jose-jwt&lt;/artifactId&gt;<br/>  &lt;version&gt;8.20&lt;/version&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="b925" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">利用Quarkus中的QuarkusTestResourceLifecycleManager类，我们可以设置wiremock服务，并在Quarkus完成启动之前添加必要的存根。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bdb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试子类可以使用私有密钥(第9行)通过下面的方法生成一个JWT</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6f62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">OIDC配置存根是完整的，但是我们的服务在测试中唯一需要的部分是jwks_uri来获取公钥</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3bc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">被模仿的jwks_uri需要返回我们上面生成的密钥对的公钥部分。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1a12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要的最后一部分是使用密钥对中的私钥生成一个令牌，以便在测试中使用。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8400" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以测试传递有效令牌会导致成功的post，不传递令牌会导致401，而传递来自未知提供者的令牌会导致403。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="b125" class="lk ll iq bd lm ln lo dn lp lq lr dp ls ko lt lu lv ks lw lx ly kw lz ma mb mc bi translated">使用Keycloak进行组件测试</h2><p id="78a3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在之前的文章中，我们在testcontainers的帮助下编写了组件测试，以确保所有部分(微服务、数据库、kafka、wiremock)能够协同工作。我们可以为Keycloak创建一个容器，并用为测试设置的领域播种实例。</p><p id="a81c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，用户不会直接调用sms微服务。它将被其他微服务用作涉及发送SMS消息的工作流的一部分。对于这个微服务，我们可以使用客户端凭证授权来获取访问令牌。这意味着我们需要在keycloak中设置一个领域，并添加一个可以使用客户端凭证授权登录的客户端。完成后，我们可以导出该领域，并将其作为docker容器设置的一部分进行引用，从而为测试播种实例。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4ee9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在运行测试之前，我们可以使用领域中已配置的客户端详细信息来获取一个可以在测试中使用的访问令牌</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="b1ff" class="lk ll iq bd lm ln lo dn lp lq lr dp ls ko lt lu lv ks lw lx ly kw lz ma mb mc bi translated">以Okta作为OIDC提供商运行服务</h2><p id="078c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">您可以使用任何OIDC提供商，但是我们将演示如何使用Okta作为提供商。</p><p id="6835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你还没有注册，你可以在<a class="ae kc" href="https://developer.okta.com/signup/" rel="noopener ugc nofollow" target="_blank">https://developer.okta.com/signup/</a>注册一个免费的开发者账户</p><p id="1070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注册后，在以下位置添加授权服务器</p><p id="66db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">API -&gt;授权服务器-&gt;添加授权服务器</p><p id="5a1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些属性</p><p id="4b81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">名称:短信授权服务器<br/>受众:<a class="ae kc" href="https://api.porterhead.com/sms" rel="noopener ugc nofollow" target="_blank">https://api.porterhead.com/sms</a></p><p id="02a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加范围:sms(设为默认)</p><p id="72dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个应用程序并设置一个客户端，以便使用客户端凭据登录</p><p id="d245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将服务器url和客户端id属性添加到config/application.properties文件中</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8b40" class="lk ll iq mn b gy mr ms l mt mu">quarkus.oidc.auth-server-url=&lt;Your Okta server url&gt;<br/>quarkus.oidc.client-id=&lt;your client-id&gt;</span></pre><p id="1f5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保其余属性设置为与SMS提供商对话。参见<a class="ae kc" href="https://github.com/iainporter/sms-service" rel="noopener ugc nofollow" target="_blank">自述文件</a>。</p><p id="408a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从根目录构建服务</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2c36" class="lk ll iq mn b gy mr ms l mt mu">mvn install</span></pre><p id="8de6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用docker-compose启动一切</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bc63" class="lk ll iq mn b gy mr ms l mt mu">cd sms-service<br/>docker-compose up -d</span></pre><p id="350d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为kafa-connect安装sms连接器</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0b43" class="lk ll iq mn b gy mr ms l mt mu"><br/>curl 'localhost:8083/connectors/' -i -X POST \<br/>-H "Accept:application/json" -H "Content-Type:application/json" \<br/>-d '{"name": "sms-connector", "config": {"connector.class": "io.debezium.connector.postgresql.PostgresConnector", "database.hostname": "postgres-db", "database.port": "5432", "database.user": "postgres", "database.password": "postgres", "database.dbname" : "sms", "database.server.name": "smsdb1", "table.whitelist": "public.outboxevent", "transforms" : "outbox","transforms.outbox.type" : "io.debezium.transforms.outbox.EventRouter", "transforms.OutboxEventRouter.event.key": "aggregate_id", "transforms.outbox.table.fields.additional.placement": "type:header:eventType"}}'    </span></pre><p id="ec0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">登录到您在上面配置的OIDC提供商，并获取访问令牌。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a565" class="lk ll iq mn b gy mr ms l mt mu">curl -i --request POST \<br/>  --url <a class="ae kc" href="https://dev-638098.okta.com/oauth2/ausnk7ixdxwQWONYR4x6/v1/token" rel="noopener ugc nofollow" target="_blank">&lt;</a>your okta server url&gt; \<br/>  --header 'accept: application/json' \<br/>  --header 'authorization: Basic &lt;your client-id:secret&gt;' \<br/>  --header 'cache-control: no-cache' \<br/>  --header 'content-type: application/x-www-form-urlencoded' \<br/>  --data 'grant_type=client_credentials&amp;scope=sms'</span></pre><p id="7cf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发送消息</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9679" class="lk ll iq mn b gy mr ms l mt mu">curl 'http://localhost:8080/v1/sms' -i -X POST  \<br/>   -H 'Content-Type: application/json'  \<br/>    -H 'authorization: Bearer &lt;your access token&gt;'<br/>   -d '{"text":"Foo Bar!", "fromNumber": "+1234567890", "toNumber": "+&lt;your mobile number&gt;"}'</span></pre><p id="73a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">期待这样的回应</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7687" class="lk ll iq mn b gy mr ms l mt mu">HTTP/1.1 202 Accepted<br/>Content-Length: 0<br/>Location: <a class="ae kc" href="http://localhost:8080/v1/sms/e307458a-a0a8-4f13-9635-f9b27b4da0e5" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/sms/e307458a-a0a8-4f13-9635-f9b27b4da0e5</a></span></pre><p id="7bf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用位置头来获取消息细节</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1a77" class="lk ll iq mn b gy mr ms l mt mu">curl 'http://localhost:8080/v1/sms/<a class="ae kc" href="http://localhost:8080/v1/sms/e307458a-a0a8-4f13-9635-f9b27b4da0e5" rel="noopener ugc nofollow" target="_blank">e307458a-a0a8-4f13-9635-f9b27b4da0e5</a>' -i -X GET  \<br/>   -H 'Content-Type: application/json'  \<br/>   -H 'authorization: Bearer &lt;your access token&gt;'</span></pre><p id="5594" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果消息成功传递，结果应该如下所示</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="15ef" class="lk ll iq mn b gy mr ms l mt mu">HTTP/1.1 200 OK<br/>Content-Length: 194<br/>Content-Type: application/json<br/>{<br/>"createdAt":"2020-07-16T16:43:59.43561Z",<br/>"fromNumber":"+1234567890",<br/>"id":"b3a20fac-2d00-49d2-b3ef-b3a3e5ac02ca",<br/>"status":"DELIVERED",<br/>"text":"Foo Bar!",<br/>"provider": "Twilio",<br/>"principal": "backend-service",<br/>"toNumber":"+1234567891",<br/>"updatedAt":"2020-07-16T16:44:00.432926Z"<br/>}</span></pre><p id="ac9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务现已完成。我们发布了一个使用OpenAPI的API。消息保存在Postgres数据库中。Debezium连接器跟踪Postgres WAL日志，并将更改事件发送给Kafka。消费者正在收听这些事件，并将它们路由到SMS提供商，以便将消息发送到用户的移动设备。该服务使用OpenId Connect进行保护。我们有适当的单元测试和组件测试，以确保一切连接正确，并能对故障做出适当的响应。本系列的最后一篇文章将把服务部署为GraalVM中的本机可执行文件。</p><p id="d006" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的源代码可以在<a class="ae kc" href="https://github.com/iainporter/sms-service" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="c706" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该系列的其他部分包括:</p><ul class=""><li id="884b" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-microservice-from-the-ground-up-with-quarkus-kotlin-and-debezium-83ae5c8a8bbc">第一部分:构建框架并添加持久性</a></li><li id="698f" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/implementing-the-transactional-outbox-pattern-with-debezium-in-quarkus-f2680306951">第二部分:使用Kafka Connect和Debezium实现CDC</a></li><li id="8266" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-resilient-microservice-with-quarkus-and-wiremock-de59b2a4fac7">第三部分:连接到第三方API并用Wiremock进行测试</a></li><li id="4cee" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" href="https://medium.com/@changeant/running-a-microservice-in-quarkus-on-graalvm-52d6b42a5840" rel="noopener">第五部分:使用GraalVM本机运行</a></li><li id="c81f" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" href="https://medium.com/@changeant/containerizing-your-microservice-in-quarkus-with-jib-fae0f62bd57e" rel="noopener">第六部分:用Jib封装你的微服务</a></li><li id="d5b0" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-ci-pipeline-for-a-microservice-in-quarkus-with-circleci-11e9b679423f">第七部分:使用CircleCI为微服务构建CI管道</a></li></ul></div></div>    
</body>
</html>