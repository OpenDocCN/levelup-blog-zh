<html>
<head>
<title>Handling user authentication and authorization after load balancing your web app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在对您的web应用程序进行负载平衡后，处理用户身份验证和授权</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-user-authentication-and-authorization-after-load-balancing-your-web-app-c87ccba35a75?source=collection_archive---------0-----------------------#2020-11-21">https://levelup.gitconnected.com/handling-user-authentication-and-authorization-after-load-balancing-your-web-app-c87ccba35a75?source=collection_archive---------0-----------------------#2020-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3bec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di"> L </span>负载平衡您的web应用程序是在预期或经历大量流量时要走的路，但是当涉及到设计认证和授权流时，它在后端会变得更加复杂。</p><h1 id="178e" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">为什么要负载平衡？</h1><p id="d6b2" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在高流量情况下，例如托管社交网站、热门博客、API或互联网上几乎任何有大量有效传入请求的应用程序，物理服务器处理所有这些请求并产生所需的响应可能会不堪重负。</p><p id="8a61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我将讨论将由您的web服务器处理的身份验证和授权流(<strong class="jp ir"> <em class="lx"> auth </em> </strong>从现在开始)扩展到一个不能保证来自同一客户端的后续请求将由同一服务器处理的系统的明显和更深层的含义。</p><h1 id="8a85" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在我们开始之前…</h1><p id="a54a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">如果你正在读这篇文章，你可能已经知道了什么是负载平衡，但是为了这篇文章，我觉得有必要确保我们都在同一页上。</p><h2 id="b5dc" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated"><strong class="ak">什么是负载均衡？</strong></h2><p id="d926" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">简而言之，负载平衡是使用特定的负载平衡算法在多个不同的服务器实例之间分配流量的过程。想象一下，一个警察站在收费广场前，指引你去排队最少的收费站。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/6bb7a7be8d1982eb30a5b2310160f15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*-1jiIZ2CSAlGHkBkOUyo3w.jpeg"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">收费广场，由tribuneindia.com提供(<a class="ae mw" href="https://cmsimages.tribuneindia.com/gallary_content/2020/4/2020_4$largeimg_1893155391.jpg" rel="noopener ugc nofollow" target="_blank">https://CMS images . tribune India . com/gallary _ content/2020/4/2020 _ 4＄large img _ 1893155391 . jpg</a>)</figcaption></figure><p id="6233" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设，在等待响应的体验变得令人沮丧之前，您的托管平台提供的原始服务器每秒最多可以处理1，000个请求。你正在蓬勃发展，用户开始越来越多地使用你的应用程序，因此流量增加。你不希望他们变得沮丧，是吗？</p><p id="3715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那你是做什么的？您实现了一个负载平衡器。您要么为AWS提供的实例或您使用的任何服务付费，要么花时间配置您自己的实例。但是负载平衡器不会像变魔术一样自己工作。您需要多个服务器，以便平衡器知道将您的请求重定向到哪里，以便处理它，当涉及到auth flow时，这成为您的新问题。为什么？看一看:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/bb772cd153dacaeefb5aa5e7a3644e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zACMdeoJoQHVBAvXusTnaw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">负载平衡API</figcaption></figure><p id="491f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，即使Bob在很短的时间间隔内向同一个API发送了两个请求，他的响应仍然由不同的服务器实例处理。这个例子表明，您绝对无法预测哪个实例将最终处理客户的请求。即使你能做到，我也怀疑你能否用一个能正常工作的负载均衡器可靠地做到这一点。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="d71f" class="ku kv iq bd kw kx nj kz la lb nk ld le lf nl lh li lj nm ll lm ln nn lp lq lr bi translated">认证和授权</h1><h2 id="67f9" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated">当然是JWT</h2><p id="9c88" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在这个人人都可以建网站的时代，以易于实现而闻名的JWT被广泛用于认证。</p><p id="5221" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘿，它工作正常吗？嗯，是的，它的工作，它的速度很快，有点可靠。点击这里阅读更多关于JWT如何工作的信息。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi no"><img src="../Images/5a8d90e9aaf971483df79634470fa5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e1fM3oaH859rTJEUByJrFA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><a class="ae mw" href="https://jwt.io" rel="noopener ugc nofollow" target="_blank"> jwt.io </a></figcaption></figure><p id="5e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，您可能会认为这是解决我们所有问题的显而易见的方法，无论负载平衡与否。我看到了。我的意思是，JWT不需要太多的后端工作来验证和授权，用户信息直接嵌入在令牌中，减少了数据库访问的需要，所有数据都存储在客户端，节省了您非常需要的服务器内存。很聪明，对吧？有，但是没有。</p><p id="bcdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你开始设计你的用户认证功能时，问题已经开始变得明显，因为你建立了你的“<em class="lx">重置密码</em>”功能。到目前为止，JWT的优点是在认证或授权时不必通过数据库检查信息的有效性。现在吗？没有那么多。当您的应用程序的用户因为忘记密码或其他原因而决定重置密码时，您需要一种方法来注销用户已经登录的所有其他设备。</p><p id="61b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何让用户的jwt过期，而不用等待它们自己退出？一个快速的方法是改变你的加密密钥。但是等等，那会让你所有用户的令牌都过期…哇哦。好吧，好吧，我有个主意。也许集成一个保存所有过期密钥的数据库，并对照它进行检查？或者所有有效的密钥？我的意思是这很简单，首先检查JWT本身是否有效，然后对照数据库检查它是否不在黑名单中。但是等等，这不是让JWT的<em class="lx">更快了吗，不需要数据库检查，快速验证</em>指出了窗口？有点像，不是吗？您可能会说，集成缓存以减少数据库访问。好的，这是可行的，但是请记住，缓存也必须在多个web服务器实例之间共享，并且您的实现必须是容错的，特别是对于用户安全特性，例如<em class="lx">重置密码</em>示例。</p><p id="9d54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果故事到此结束，你是幸运的。如果一切顺利，这不会是你最后一次升级你的应用程序。您的下一步将是添加另一个负载平衡器和另一个web服务器集群，甚至可能是地理路由，以将请求发送到最近的负载平衡器，从而减少延迟。您准备好保证多个分布式缓存之间的一致性了吗？这是最令人头疼的问题。</p><p id="c65c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你准备好并且愿意，你比我更像一个男人。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="d469" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated">粘性会话</h2><p id="fd6d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">当设计你的网站使用sessions时，你已经超越了JWTs可能让你兴奋的“没有后端工作”的梦想。</p><p id="6c32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用会话时，服务器给客户机一个唯一的标识符(让我们称之为<em class="lx">键</em>)，用户在后续请求中传递这个键，这样服务器就知道它在和谁说话。密钥最好存储在仅支持HTTP的安全cookies中。服务器将有关用户的信息存储在生成的键下的查找表中，当发送请求时，它只使用该键来检索与期望响应的客户机相关联的数据。您可能会在这里看到问题。您有多台web服务器。<strong class="jp ir">你如何保证所有负载均衡服务器之间的会话是相同的？</strong></p><p id="3234" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">粘滞会话试图通过强制负载平衡器将所有以下请求发送到同一个web服务器来解决这个问题。这在某种程度上可能行得通，但除了明显懒惰(在正常情况下)之外，它还有几个缺点:</p><ul class=""><li id="71b2" class="np nq iq jp b jq jr ju jv jy nr kc ns kg nt kk nu nv nw nx bi translated">你的服务器上的负载<strong class="jp ir">将</strong>不均衡。有些用户会比其他人在你的网站上花更多的时间。</li><li id="3b0c" class="np nq iq jp b jq ny ju nz jy oa kc ob kg oc kk nu nv nw nx bi translated">负载平衡器不会读取和处理请求，那不是它的工作。因此，它可以识别请求来自哪里的唯一方法是通过IP，我不认为我需要告诉你有多少人使用他们的移动电话数据，然后在咖啡馆里切换到wi-fi。这将导致会话失败。简单来说:<strong class="jp ir">不一致</strong>。</li></ul></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="9338" class="ly kv iq bd kw lz ma dn la mb mc dp le jy md me li kc mf mg lm kg mh mi lq mj bi translated">分布式会话</h2><p id="9f39" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">这场竞赛中另一个有价值的竞争者是分布式缓存+会话状态=分布式会话。在当前上下文中，竞争实际上是在<strong class="jp ir"> JWT </strong>和<strong class="jp ir">分布式会话状态</strong>之间，因为分布式缓存必须在负载平衡环境中为两者实现。</p><p id="8850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者至少应该在负载平衡的环境中为这两者实现分布式缓存，因为任何其他解决方案效率较低，实现起来也比较麻烦。我不认为您会希望在每台服务器上保存相同缓存数据的副本，并在发生变化时更新几个服务器实例。</p><p id="1e85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我告诉你为什么在大规模应用中这可能比JWT实现得更好更有效之前，让我们先来看看它是如何工作的。</p><p id="46a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想你已经明白了，但是什么是分布式缓存呢？分布式缓存只是可由多方访问的缓存。它在您的所有服务器之间提供了一致的数据层。它的使用方式相当简单:服务器寻找一些信息，如果它被缓存，它就使用它，故事结束。如果不是，那么它从一个永久的数据源(数据库)获得它，缓存它以便将来可以更快地访问它，然后使用它。特别是在存储会话状态时，缓存的数据有一个滑动的过期时间，这样当它不被使用时就不会停留在那里。如果它在20分钟内没有被访问，就会被删除。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi od"><img src="../Images/66ac2fc67e7afd7d0ddaa48234756018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4XUrt8DxIjjSqHTvm-ThNg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">使用会话状态和分布式缓存实现快速数据检索的简单示例</figcaption></figure><p id="dc80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这如何与会话配对？很简单，您将用户的会话保存在分布式缓存中，而不是本地缓存中。他们发出请求，他们的会话被创建并存储在缓存服务器中。对于任何后续请求，如果它们被重定向到另一个实例，web服务器可以通过从分布式缓存中获取它们的会话状态来访问客户端的会话。当用户执行任何对其数据有影响的操作时，会记录更改，并更新数据库和缓存。如果像这样的数据库更改是异步完成的，那么最终用户在页面加载时间上不会受到任何影响。</p><p id="a394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，但是JWT黑名单缓存方法提供了同样的好处:更少的数据库查询和缓存数据使得响应非常快。<strong class="jp ir">是什么让分布式会话独占鳌头？</strong>几个原因:</p><p id="4304" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的说法是，jwt并不是为这样使用而构建的。它们应该是可移植的、快速的和易于验证的。通过使用数据存储(黑名单或白名单)添加另一层验证就像实现分布式会话状态一样，但不是将用户的信息很好地打包并隐藏在数据存储中，而是将其暴露在客户端cookie中，并在数据存储中保留一份JWT的副本。即使数据不被认为是<em class="lx">的秘密</em>，当你已经将用户信息打包远离公众访问时，为什么还要将它们留在客户端？</p><p id="065d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，实现服务器端会话状态为进一步实现更多功能提供了更多空间。您可以开始处理关于客户端会话的更微妙的数据，以加强更严格的会话劫持安全性(如最后授权IP、位置等。).如果你有一个便利贴应用程序，在会话状态下存储笔记内容是一种比数据库查询更快的检索方法。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="59ab" class="ku kv iq bd kw kx nj kz la lb nk ld le lf nl lh li lj nm ll lm ln nn lp lq lr bi translated">结论</h1><p id="5322" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">对需要认证和授权的庞大服务进行负载平衡？缓存为王。不仅仅是为了auth。</p><p id="1919" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说真的，尽可能把所有东西都藏起来。</p><p id="623e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个进入<strong class="jp ir">分布式会话状态</strong>。</p></div></div>    
</body>
</html>