<html>
<head>
<title>4 tips when developing GraphQL APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发GraphQL APIs的4个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-things-to-consider-in-graphql-development-5fd6e4e2c73f?source=collection_archive---------15-----------------------#2020-04-10">https://levelup.gitconnected.com/4-things-to-consider-in-graphql-development-5fd6e4e2c73f?source=collection_archive---------15-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="39b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解开发后端服务的最佳实践</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/129f579a2628d7c12bf5597562c0f94a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a6Yugli-qCLw9wv8.png"/></div></div></figure><p id="2b1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQL是一种强大的查询语言，因为它避免了与REST API相关的经典的过度提取问题。在REST中，端点决定返回数据的类型和数量。在许多情况下，服务器返回的数据超过了用户的需求。然而，GraphQL允许高度特定的客户端查询，只返回所请求的数据。</p><p id="6530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开发GraphQL服务时，我们将不得不处理定义模式、保护服务、构造模式、构造解析器和处理性能等的最佳方式。，在这篇文章中，我们将研究这些主题及其实现。</p><h1 id="4e82" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">保护GraphQL</h1><p id="4eae" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在构建过程中的某个时候，我们必须确定谁可以看到GraphQL服务中的数据并与之交互。</p><blockquote class="ma"><p id="cf90" class="mb mc iq bd md me mf mg mh mi mj kk dk translated">身份验证是确定用户是否已登录并被允许访问服务。</p><p id="93fc" class="mb mc iq bd md me mf mg mh mi mj kk dk translated">授权是确定用户是否有权访问数据。</p></blockquote><h2 id="0c8a" class="mk ky iq bd kz ml mm dn ld mn mo dp lh jy mp mq ll kc mr ms lp kg mt mu lt mv bi translated">使用JWT令牌的认证</h2><p id="315f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在任何身份验证方案中，JWT都是一种常见的实现，它允许以安全的方式表示用户数据声明。我们可以使用JWT令牌并通过在服务中验证它来保护我们的服务。</p><p id="e9f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的代码片段中，我使用Okta作为身份和访问管理解决方案。它可以是custom、Okta、Auth0或任何其他实现中的任何一个。</p><p id="1daa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正在验证HTTP authorization头中的登录令牌，以检查它是否是有效的令牌，是否可以被允许访问服务。然后，从JWT令牌返回的用户声明被放入一个可以在代码中的所有<code class="fe mw mx my mz b">resolvers</code>中使用的上下文中。对于任何令牌验证失败，都将返回身份验证错误。</p><p id="2903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以根据实现从令牌或数据库中获取角色和其他用户信息。</p><h2 id="6e7a" class="mk ky iq bd kz ml na dn ld mn nb dp lh jy nc mq ll kc nd ms lp kg ne mu lt mv bi translated">解析器中的授权</h2><p id="aa41" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">解析器是解析模式中的类型或字段的值的函数。解析器可以返回对象或标量，如字符串、数字、布尔值等。</p><p id="cf6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解析器中的授权可以通过上下文中的用户声明来实现。我们可以对以下内容进行粒度授权</p><ul class=""><li id="6259" class="nf ng iq jp b jq jr ju jv jy nh kc ni kg nj kk nk nl nm nn bi translated">如果用户已登录，则返回数据(或)</li><li id="f8a4" class="nf ng iq jp b jq no ju np jy nq kc nr kg ns kk nk nl nm nn bi translated">如果用户已登录并具有管理员角色，则返回数据。</li></ul><p id="345c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我们可以返回有效用户的数据</p><p id="3672" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，如果用户是有效的并且角色是管理员，我们可以返回数据(我们应该只返回管理员的所有用户数据)</p><h2 id="c3f9" class="mk ky iq bd kz ml na dn ld mn nb dp lh jy nc mq ll kc nd ms lp kg ne mu lt mv bi translated">使用自定义指令进行授权</h2><p id="3479" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">另一种授权方式是在模式中使用自定义指令。<code class="fe mw mx my mz b">directive @</code>可以直接在类型上调用，或者在字段上调用，或者在查询上调用。</p><p id="12fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现一个模式指令，我们需要创建一个<code class="fe mw mx my mz b">SchemaDirectiveVisitor</code>的子类，并覆盖一个或多个方法。然后可以在<code class="fe mw mx my mz b">schemaDirectives</code>模式类中引用该子类。</p><h1 id="10b7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结构化模式和解析器</h1><p id="78d5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">随着GraphQL服务复杂性的增加，模式和解析器文件将会大幅增长。为了扩展代码和服务，我们需要模块化并组织模式和解析器代码。</p><h2 id="60a6" class="mk ky iq bd kz ml na dn ld mn nb dp lh jy nc mq ll kc nd ms lp kg ne mu lt mv bi translated">(计划或理论的)纲要</h2><p id="ce8e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在下面的例子中，模式包含<code class="fe mw mx my mz b">User</code>和<code class="fe mw mx my mz b">Group</code>类型。随着模式的增长，维护代码会变得很困难。我们可以将整个代码拆分成单独的文件，而不是将整个代码放在一个文件中。</p><p id="74d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nt">在我们拆分</em>中的代码之前<code class="fe mw mx my mz b"><em class="nt">schema.js</em></code></p><p id="95dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nt">我们拆分了</em>中的代码后<code class="fe mw mx my mz b"><em class="nt">schema.js</em></code></p><h2 id="5035" class="mk ky iq bd kz ml na dn ld mn nb dp lh jy nc mq ll kc nd ms lp kg ne mu lt mv bi translated">分解器</h2><p id="9ff5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们可以在解析器中通过分割成多个文件来做同样的事情。</p><h1 id="1a44" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">避免多次后端或数据库调用</h1><p id="fe3a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Resolver是一个特定于字段的函数，它在服务器中返回请求的数据。服务器处理查询，解析器返回每个字段的数据，直到获取了查询中的所有数据。在某些情况下，使用多个解析器的单个查询会导致对数据库的多次往返调用。</p><p id="f5cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的查询中，我们希望使用分页获得15个故事。假设用户和评论有他们自己的解析器，对数据库的初始调用将返回15个故事。然后，它对DB进行额外的往返调用，以获取每个故事的作者和评论。如果我们决定从评论中获取用户的详细信息，复杂性就会增加。这种对数据库的额外往返调用是一种开销，会导致性能下降。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1f2cd47bf7030f204bd38c7b32bf2b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*jYnin5Q92Y4a2JOxTeBczw.png"/></div></figure><p id="044b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以考虑使用数据加载器，让你批处理和缓存数据库调用。如果数据加载器确定一个查询正在进行多个数据库调用，它会将所有调用一起批处理。这将大大减少对数据库的调用。</p><h1 id="2374" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">缓存以提高性能</h1><p id="3e97" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了在生产中扩展应用程序，GraphQL服务上的缓存实现至关重要。正如我们从上面学到的，单个查询将导致运行多个解析器，每个解析器都有不同的语义。Apollo服务器提供了使用<code class="fe mw mx my mz b">@cachecontrol</code>指令在字段级定义缓存控制的能力</p><p id="ff1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码片段中，<code class="fe mw mx my mz b">likes</code>字段可以缓存30秒。默认情况下，查询和突变是用<code class="fe mw mx my mz b">maxAge: 0</code>配置的，我们可以在创建服务器时更改默认配置，如下所示</p><pre class="km kn ko kp gt nv mz nw nx aw ny bi"><span id="9277" class="mk ky iq mz b gy nz oa l ob oc">const server = new ApolloServer({<br/>  // ...<br/>  cacheControl: {<br/>    defaultMaxAge: 5,<br/>  },<br/>}));</span></pre><p id="a30e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不同级别实现缓存控制，包括考虑Memcached或Redis，将有助于提高服务的性能。</p><h1 id="97bc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">概述</h1><ol class=""><li id="a3b0" class="nf ng iq jp b jq lv ju lw jy od kc oe kg of kk og nl nm nn bi translated">在GraphQL上实现安全控制有助于保护API</li><li id="79dc" class="nf ng iq jp b jq no ju np jy nq kc nr kg ns kk og nl nm nn bi translated">模块化模式和解析器的代码结构将有助于提高代码的可读性</li><li id="7071" class="nf ng iq jp b jq no ju np jy nq kc nr kg ns kk og nl nm nn bi translated">实现批处理将减少不必要的数据库调用</li><li id="1f67" class="nf ng iq jp b jq no ju np jy nq kc nr kg ns kk og nl nm nn bi translated">实现缓存将会提高性能</li></ol></div></div>    
</body>
</html>