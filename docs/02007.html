<html>
<head>
<title>What are Higher-Order Functions in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的高阶函数是什么？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-are-higher-order-functions-in-javascript-e22924b39483?source=collection_archive---------12-----------------------#2020-02-11">https://levelup.gitconnected.com/what-are-higher-order-functions-in-javascript-e22924b39483?source=collection_archive---------12-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2b379e05a0fe7ea3a6222d20a387ea42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AxUZKVSjHvfYldr4"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@micheile?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Micheile Henderson @ Micheile 010//视觉故事【nl】</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="0d53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，高阶函数被用在很多地方。因此，知道它们是什么很重要。</p><p id="b5d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解什么是高阶函数，以及如何在JavaScript中使用它们。</p><h1 id="3f66" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">高阶函数的定义</h1><p id="34da" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">高阶函数是以其他函数作为自变量或返回函数作为结果的函数。作为参数接受的函数也叫做回调函数。</p><p id="7e4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么函数可以接受其他函数作为参数或者返回函数？这是因为JavaScript函数像JavaScript中的任何其他实体一样是对象。作为对象的函数称为一级函数。</p><p id="44ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一级函数和其他变量一样对待。在JavaScript中就是这样，所以JavaScript函数是一级函数。</p><p id="5836" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，我们可以将函数赋给变量:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e444" class="mq lf it mm b gy mr ms l mt mu">let foo = () =&gt; 1;</span></pre><p id="c0fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们给<code class="fe mv mw mx mm b">foo</code>变量分配了一个简单的匿名函数。</p><p id="cb5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过运行来调用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="821a" class="mq lf it mm b gy mr ms l mt mu">foo();</span></pre><p id="9a5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以向它添加属性，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="05b2" class="mq lf it mm b gy mr ms l mt mu">foo.bar = 1;</span></pre><p id="54d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码是不好的实践，因为它令人困惑，因为函数通常是通过添加属性来调用而不是操作的。</p><p id="74a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们由此知道JavaScript函数是对象。它还有一个原型，包含像<code class="fe mv mw mx mm b">apply</code>、<code class="fe mv mw mx mm b">bind</code>和<code class="fe mv mw mx mm b">call</code>这样的方法，可以修改用<code class="fe mv mw mx mm b">function</code>关键字声明的常规函数的行为。</p><p id="3630" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们想对数字、字符串和对象等其他变量做的任何事情，都可以用函数来做。</p><h1 id="ee81" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">作为函数参数的函数</h1><p id="7184" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为JavaScript函数只是常规对象，所以我们可以在调用函数时将它们作为参数传入。这被用在很多地方，比如数组函数和承诺回调。</p><p id="572e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个简单的例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7d93" class="mq lf it mm b gy mr ms l mt mu">const addOrMultiply = (addFn, multiplyFn, a, b) =&gt; {<br/>  if (Math.random() &gt; 0.5) {<br/>    return addFn(a, b);<br/>  }<br/>  return multiplyFn(a, b);<br/>}</span><span id="0e86" class="mq lf it mm b gy my ms l mt mu">const add = (a, b) =&gt; a + b;<br/>const multiply = (a, b) =&gt; a * b;<br/>const result = addOrMultiply(add, multiply, 1, 2);</span></pre><p id="7d80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们定义了<code class="fe mv mw mx mm b">addOrMultiply</code>函数，它接受一个将两个数相加的函数、一个将两个数相乘的函数和两个数作为参数。</p><p id="f4b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数中，如果<code class="fe mv mw mx mm b">Math.random()</code>返回一个大于0.5的数字，那么我们调用<code class="fe mv mw mx mm b">addFn(a, b)</code>。不然我们叫<code class="fe mv mw mx mm b">multiplyFn(a, b)</code>。</p><p id="585d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们定义了<code class="fe mv mw mx mm b">add</code>和<code class="fe mv mw mx mm b">multiply</code>函数分别对2个数进行加法和乘法运算。</p><p id="a970" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们通过传入<code class="fe mv mw mx mm b">add</code>和<code class="fe mv mw mx mm b">multiply</code>函数以及数字1和2来调用<code class="fe mv mw mx mm b">addOrMultiply</code>函数。</p><p id="e4ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们传入的函数就可以用<code class="fe mv mw mx mm b">a</code>和<code class="fe mv mw mx mm b">b</code>来调用。这并不意味着我们传入的函数必须与<code class="fe mv mw mx mm b">addOrMultiply</code>函数内部的函数调用签名相匹配。JavaScript不关心我们传入的函数的签名。然而，我们必须传递能得到预期结果的函数。</p><p id="7cc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据我们提到的高阶函数的定义，<code class="fe mv mw mx mm b">addOrMultiply</code>符合它的定义。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/f7702cfd2deafbfce1d0ef7d78564476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eIRwkPwsAGh-0vKZ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@gregjeanneau?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Greg Jeanneau </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="5514" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">高阶函数的例子</h1><h2 id="060d" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">Array.prototype.forEach</h2><p id="b4ee" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">forEach</code>方法遍历数组的每个元素。它接受一个回调函数作为参数。回调将当前正在处理的数组条目、正在处理的数组的索引以及数组本身作为参数。</p><p id="1cac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">索引和数组参数是可选的。然而，我们知道JavaScript并不关心我们用于回调的函数的函数签名，所以我们必须小心。</p><p id="f2e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以编写以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e9d5" class="mq lf it mm b gy mr ms l mt mu">const arr = [1, 2, 3];<br/>arr.forEach((a, i) =&gt; console.log(`arr[${i}] is ${a}`))</span></pre><p id="93d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该看到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="88ca" class="mq lf it mm b gy mr ms l mt mu">arr[0] is 1<br/>arr[1] is 2<br/>arr[2] is 3</span></pre><p id="f252" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe mv mw mx mm b">console.log</code>记录。</p><h2 id="a02b" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">Array.prototype. <strong class="ak">地图</strong></h2><p id="29f3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">map</code>数组方法采用与<code class="fe mv mw mx mm b">forEach</code>相同的回调函数。它用于将被调用的数组的数组条目映射到通过回调函数操作每个条目而返回的值。它返回一个新的数组。</p><p id="e197" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4282" class="mq lf it mm b gy mr ms l mt mu">const arr = [1, 2, 3];<br/>arr.map((a, i) =&gt; a**2)</span></pre><p id="02da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2a7d" class="mq lf it mm b gy mr ms l mt mu">[1, 4, 9]</span></pre><h2 id="e44e" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">设置超时</h2><p id="1a58" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">setTimeout</code>函数将我们传递给它的回调函数中的代码的执行延迟了一段指定的时间。</p><p id="2cdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="84c1" class="mq lf it mm b gy mr ms l mt mu">setTimeout(() =&gt; {<br/>  console.log('hi');<br/>}, 1000)</span></pre><p id="30b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将在调用<code class="fe mv mw mx mm b">setTimeout</code>函数1秒后记录<code class="fe mv mw mx mm b">'hi'</code>。</p><p id="d57a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">setTimeout</code>将回调中的代码推迟到下一次事件循环迭代，这样我们就可以在不影响整个程序的情况下延迟回调中代码的执行。</p><p id="3837" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种延迟代码是异步的。我们延迟代码执行，而不挂起主执行线程来等待它的执行完成。</p><p id="f693" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模式在很多异步代码中都很常见，包括承诺回调、事件监听器和其他异步代码。</p><p id="4a35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们不能一行一行地执行异步代码，回调更加重要，因为这是在不确定的时间内运行一个函数的唯一方法。</p><h2 id="635a" class="mq lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">事件处理程序</h2><p id="9751" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">DOM元素和Node.js中的事件处理程序也使用回调，因为有些代码只有在事件被触发时才会被调用。</p><p id="c83e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以将一个简单的点击监听器附加到<code class="fe mv mw mx mm b">document</code>对象，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fbef" class="mq lf it mm b gy mr ms l mt mu">document.addEventListener('click', () =&gt; {<br/>  console.log('clicked');<br/>})</span></pre><p id="a5d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，每当我们点击页面，我们就会得到<code class="fe mv mw mx mm b">'clicked'</code>记录。</p><p id="461d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，高阶函数在JavaScript中非常有用。它允许我们创建回调函数来传递给其他函数。它被同步代码和异步代码广泛使用。</p><p id="44f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同步回调的例子包括我们传递给数组方法的回调。</p><p id="0f18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步回调包括事件处理程序、<code class="fe mv mw mx mm b">setTimeout</code>、承诺回调等等。它广泛用于异步代码，因为代码不是逐行运行的，所以我们需要回调来运行需要在不确定的时间内运行的代码。</p></div></div>    
</body>
</html>