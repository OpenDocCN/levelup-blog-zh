<html>
<head>
<title>Versioning Thy Infra: Tagging AWS Resources with Git Commit Hash in CICD pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">版本控制Thy Infra:在CICD管道中用Git提交哈希标记AWS资源</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/versioning-thy-infra-tagging-aws-resources-with-git-commit-hash-in-cicd-pipelines-75bb4a21f359?source=collection_archive---------17-----------------------#2022-03-07">https://levelup.gitconnected.com/versioning-thy-infra-tagging-aws-resources-with-git-commit-hash-in-cicd-pipelines-75bb4a21f359?source=collection_archive---------17-----------------------#2022-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b6ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用AWS CodePipeline，CloudFormation，Lambda和Python。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae936e6707d0576b2863407d4c78ed30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jOQefPDBIiQjNdwC"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">埃里克·范·迪克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="eb11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的团队遵循领先的DevOps实践，那么您很有可能将基础设施作为代码(IaC)来维护。IaC方法加快了基础架构及其配置的一致且可重复的部署。IaC特别有用的一个用例是在CICD管道中，您的代码在发布到生产环境之前会经历一系列阶段，例如构建、测试和部署。通常在这样的管道中，在测试变更的地方使用一个暂存环境/帐户。这种暂存帐户通常在本质上是短暂的，即作为发布周期的一部分，暂存帐户中的资源被供应(使用IaC)，针对供应的资源执行测试，并且基于测试的结果，确定将更改分级到生产环境/帐户是否安全。</p><p id="a7f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有这些和许多其他场景中，你的IaC也在进化。例如，您可以从初始版本的S3桶配置开始，并将IaC(例如使用CloudFormation、CDK或Terraform等)存储在您的版本控制系统(例如Git)中。经过一两次冲刺后，您发现需要改变S3铲斗的配置。因此，您将更新您的IaC脚本/模板，并将更新的版本推/提交给Git。如果现在调配了基础架构，您的环境中将有一个更新的S3存储桶，它可以是您执行测试所依据的堆栈的一部分。现在，在任何时候，如果您想要确定您的基础架构的状态，即您当前的基础架构配置基于哪个版本的代码，这可能会变得很棘手。当然，您可以通过您的CICD工具跟踪过去的部署，以确定哪个最新的Git commit代码被部署到您的基础设施中。然而，如果你能以一种快速简单的方式收集这些信息，它会特别有帮助。例如，仅通过查看您的基础设施资源(例如，通过标记)，如果您能够确定它们对应于哪个Git提交，它可以帮助您理解预期的行为，并且还可以在需要时帮助进行故障排除或回滚。Git提交在概念上代表了提交时特定时间点的代码版本(在这里阅读更多关于这个<a class="ae ky" href="https://www.mikestreety.co.uk/blog/the-git-commit-hash/" rel="noopener ugc nofollow" target="_blank">的内容</a>)。</p><p id="2524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将介绍如何通过Amazon原生服务在AWS中实现这一切。具体来说，我将介绍如何在CICD管道中用Git提交散列来标记您的资源。如果您希望在部署管道期间将标记动态地应用到您所提供的资源，那么您可以将这里的概念用于类似的用例。</p><p id="ac3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，该流程由以下步骤组成:</p><ul class=""><li id="a26b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Lamba函数将从CICD管道的“源”级检索提交散列。该函数将把它作为一个参数存储在亚马逊系统管理器(SSM)中。</li><li id="5170" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在云形成模板中，SSM参数将在资源的“标签”属性中被引用。这将导致用更新的提交散列来添加/更新资源的标签。</li><li id="a418" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">CodePipeline将用于协调CICD管道的不同阶段。从技术上来说，由于我不是在构建代码或运行测试用例，所以它不完全是一个CI管道，但为了简单起见，我在本文中使用CICD关键字。</li></ul><p id="2508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看该解决方案中涉及的组件的详细信息:</p><h1 id="7950" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">代码管道:</h1><p id="a2ee" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">AWS代码管道中的管道应如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/d79fda62177677a9373387039b8e5478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYFEKKj4LVMCBeQwy1RKqQ.png"/></div></div></figure><p id="7b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键点:</p><ul class=""><li id="3886" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">它包括三个阶段。第一个阶段是“源代码”阶段，代表源代码所在的位置。在这种情况下，它的Github。我已经将它配置为连接到我的Github repo，它指向那里的一个特定分支(主)。这是通过CodeStar完成的(更多细节<a class="ae ky" href="https://docs.aws.amazon.com/codepipeline/latest/userguide/connections-github.html" rel="noopener ugc nofollow" target="_blank">在这里</a></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/a0aed2f291cc971c4ab9d0a9640096f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DNm-ijstnJ-scI-12I3yw.png"/></div></div></figure><ul class=""><li id="f2dc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第二阶段(UpdateCommitHash)由一个调用现有Lambda函数的操作组(RunCommitHashLambda)组成。这个Lambda函数(代码将在本文后面介绍)负责从CodePipeline事件中检索提交散列，并将其存储为SSM参数。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/fb922cb374a03562674831eebcf5164a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1PxWipdB47UZh3WgQbk7w.png"/></div></div></figure><ul class=""><li id="b2e1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第三阶段(Deploy)也由单个操作组(StorageLayer)组成，并使用CloudFormation来部署资源。Cloudformation模板位于Git中我的代码库(aws-devops/s3_bucket.yaml)中，它是在这个阶段指定的:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/acbcc91583356ffa97cd5cd1c63a8c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-t0lgGGqgYuku7Hc4GEZg.png"/></div></div></figure><h1 id="302f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">λ函数:</h1><p id="b545" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">逻辑的核心是在Lambda函数中实现的。它的代码看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码通过注释和docstring被完整地记录下来，因此应该是不言自明的。几个要点:</p><ul class=""><li id="6e50" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">从CodePipeline传递给Lambda函数的事件如下所示:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="01c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，InputArtifacts部分中的“revision”表示提交散列。</p><ul class=""><li id="6fc8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果像这样的Lambda函数打算与CodePipeline一起使用，那么使用CodePipeline boto3客户端来相应地更新作业的状态(即，将作业标记为成功或失败)是很重要的。如果没有完成，CodePipeline中的作业将停留在“进行中”状态，必须手动停止。即使Lambda函数执行失败，它也不会在CodePipeline中注册，您必须在异常处理逻辑中将CodePipeline作业状态显式更新为fail。这就是为什么您会注意到代码中使用了<em class="nm">code pipeline _ client . put _ job _ failure _ result()</em>和<em class="nm">code pipeline _ client . put _ job _ success _ result()</em>方法调用。</li><li id="fd7d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">请确保您的Lambda函数有权更新SSM参数和代码管道作业状态。您可以配置附加到Lambda函数的IAM角色的IAM策略。否则，您将得到AccessDenied错误。</li></ul><h1 id="9c7d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">云的形成:</h1><p id="d45a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">拼图的最后一块是CloudFormation模板，它引用了资源标签属性中的SSM参数。这是一个简单的云形成模板，它部署了一个S3桶:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d70f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键点:</p><ul class=""><li id="4cab" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在第7–9行，我定义了一个SSM类型的云形成参数。此外，我在“默认”值，我正在传递SSM参数的名称，其中Lambda函数存储更新的提交哈希。</li><li id="0dac" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在第32–33行，我指的是S3桶的标签属性部分中的云形成参数。这将在创建时将标签应用到S3存储桶。</li></ul><h1 id="abd2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">灯光、摄像机、动作:</h1><p id="63e2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当所有的难题都解决后，当您运行代码管道时，您将会看到想要的结果:</p><p id="bac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我对我的repo进行提交，我的提交散列将按如下方式生成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/4471259c53937aa5ae3bbdee42b0be48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCCx0aPomOpuf5vE3Ld39g.png"/></div></div></figure><p id="1c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于CodePipeline与Github的完美集成，它自动触发我的管道，并成功完成每个阶段:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/059701698f77d12daf5c088e3046114f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfXTg_JAM-U8DLhOwptPDw.png"/></div></div></figure><p id="f864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以从Cloudwatch验证Lambda函数得到了执行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/74d8f98b22b185e93b4aa9b5d9ff29c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4eNL9unFPSLq_A57GQjCA.png"/></div></div></figure><p id="f16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SSM参数用提交散列值更新:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/f179a308bc0b806509042e5bfb48175a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*abCtm3fmzzT55iqVgP0EDw.png"/></div></div></figure><p id="23fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建了一个CloudFormation堆栈，它部署了我的资源(S3存储桶通过逻辑ID“RawPayloadBucket”表示):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/0320e9e717c6bf267f358713fcdaea6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8LKa16meWJjDWTpFZMmFJw.png"/></div></div></figure><p id="e34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是，创建的bucket具有所需的标记:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/30888c62581f95fca6a68b89445658a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*woWAPnVDhV8bcJOdBZEcJw.png"/></div></div></figure><p id="cf5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令人惊奇不是吗？</p><p id="b0cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你能从这种方法中学到一些东西。你可以以此为基础，实现很多有趣的事情。AWS CodePipeline与AWS服务进行了本机集成，无缝集成Lambda和CloudFormation的能力帮助我们实现了很大的灵活性。</p><p id="9059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>