<html>
<head>
<title>Hash Tables in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的哈希表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hashtable-in-kotlin-d5027f1f95c7?source=collection_archive---------4-----------------------#2020-01-31">https://levelup.gitconnected.com/hashtable-in-kotlin-d5027f1f95c7?source=collection_archive---------4-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/78e6d69fe7c56ccf9ce992ef10330bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kD-Tll0jpe3rOal6"/></div></div></figure><p id="a7fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据结构在任何类型的软件开发中都是重要的主题，但是围绕它们的大多数解释都是基于Java的。Android开发的优势在于它最初是用Java完成的，但在最近几年，Kotlin已经成为开发的首选语言。由于这个原因，理解并把经典和广泛的Java知识应用到现代编程语言中是很重要的。这一点很重要，原因有很多，其中我们可以提一下:了解数据结构为我们提供了强大的编程基础，使编码更容易，帮助我们优化执行时间和内存，而且它们通常会在技术面试中被问到！</p><h1 id="911e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">基础</h1><p id="8f52" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如上所述，Kotlin基于Java的数据结构。Java本身的大量版本中有一个对<a class="ae mc" href="https://developer.android.com/reference/kotlin/java/util/Hashtable" rel="noopener ugc nofollow" target="_blank">散列表</a>的实现，还有一个对<a class="ae mc" href="https://developer.android.com/reference/kotlin/java/util/HashMap" rel="noopener ugc nofollow" target="_blank">散列表</a>的实现。另一方面，科特林决定使用<a class="ae mc" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-map/index.html" rel="noopener ugc nofollow" target="_blank">散列表</a>，因为它们大致相当。</p><blockquote class="md me mf"><p id="f742" class="kb kc mg kd b ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ky im bi translated">HashMap类大致相当于Hashtable，除了它是不同步的并且允许空值。</p><p id="b0e5" class="kb kc mg kd b ke kf kg kh ki kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ky im bi translated"><a class="ae mc" href="https://developer.android.com/reference/kotlin/java/util/HashMap" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Android HashMap文档</em> </a></p></blockquote><p id="7978" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要注意的重要一点是，这个HashMap类有一个恒定的时间性能，在O-notation中称为O(1)，但在最坏的情况下，它可能达到O(N)。尽管值得注意的是，一些哈希映射的实现使用了自平衡二分搜索法树，并且在最坏的情况下是O(log N ),但是Kotlin实现不是这种情况。</p><h1 id="6f2b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">KVP:键值对</h1><p id="83ea" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">术语“键-值对”经常在软件开发中使用，但是由于有如此多的首字母缩略词，知道KVP在上下文中提到这个术语的大多数时间是很重要的。简而言之，它表示您有两个关联的对象，一个表示键，另一个表示关联的值。这给出了这种数据结构的一个非常重要的优点:当你有一个键和一个值时，没有必要在内存中的特定位置存储条目，因为只要你引用这个键，你就会得到这个值。从最后一点得出，同样重要的是要知道项目永远不会按顺序排列。</p><p id="cfda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了使上面的内容更清楚，比较HashMap数据结构和数组是很重要的。如果您了解这种数据结构，您将知道项目是基于零索引存储的，这意味着每个项目将由一个从零开始的数值表示。在数组的情况下，索引号就是键，它们将按顺序存储在内存中，否则，键每次都会给你一个不同的值。</p><h1 id="5fe4" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">表现</h1><p id="f248" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Kotlin表示HashMap的方式非常简单:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9d04" class="mt la it mp b gy mu mv l mw mx"><em class="mg">HashMap&lt;key, value&gt;</em> or<em class="mg"> HashMap&lt;K, V&gt;</em></span></pre><h1 id="2bb9" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">构造器</h1><p id="8956" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在Kotlin HashMap中有4个构造函数:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="df05" class="mt la it mp b gy mu mv l mw mx">HashMap() <br/>HashMap(initialCapacity: Int, loadFactor: Float) HashMap(initialCapacity: Int) <br/>HashMap(original: Map &lt;out K, V&gt; )</span></pre><p id="ed9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于第一个，不需要添加任何东西。只要一个空的构造函数，你就有了你的地图，kvp可以在以后添加。</p><p id="04ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个和第三个有两个参数:</p><ol class=""><li id="4e63" class="my mz it kd b ke kf ki kj km na kq nb ku nc ky nd ne nf ng bi translated">initialCapacity:如果你知道从一开始你需要多少物品，你可以指定。</li><li id="753b" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">loadFactor:它定义了您希望散列表增长的速率。如果您从4个项目开始，加载因子0.50将意味着一旦这4个项目中的2个被填满，大小将增加。</li></ol><p id="8363" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于最后一个，您从地图创建了一个散列表，因此您可以对它进行操作。</p><h1 id="77bc" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">HashMap示例</h1><p id="220d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">假设你拥有一家黑胶店(我知道！老歌！)，而客户很难找到书名，所以你给每个书名分配一个编号，从编号最低到最高排序。然后创建一个散列表来搜索它们。代码将如下所示:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0f49" class="mt la it mp b gy mu mv l mw mx">package com.evanamargain.hashmap </span><span id="ea3f" class="mt la it mp b gy nm mv l mw mx">fun main() { <br/>    val records = HashMap&lt;String, Int&gt;() </span><span id="2e08" class="mt la it mp b gy nm mv l mw mx">    records["Michael Jackson"] = 30 <br/>    records["The Beatles"] = 20       <br/>    records["Rolling Stones"] = 70 </span><span id="1a16" class="mt la it mp b gy nm mv l mw mx">    for ((k, v) in items) { <br/>        println("$k = $v") <br/>    } <br/>}</span></pre><h1 id="d5ac" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">用HashMaps可以解决什么样的算法问题？</h1><ol class=""><li id="47d8" class="my mz it kd b ke lx ki ly km nn kq no ku np ky nd ne nf ng bi translated">知道一个数组是否是另一个数组的子集</li><li id="1718" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">寻找具有某种特征的最大子阵列</li><li id="5139" class="my mz it kd b ke nh ki ni km nj kq nk ku nl ky nd ne nf ng bi translated">对数字对求和</li></ol><p id="966c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，HashMaps是Kotlin中简单而有用的开发工具，如果您已经是一名开发人员，您很可能会想到过去曾经使用过几次。否则，你现在就可以开始做了。</p><p id="aab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这个帖子的内容，请跟我来。访问我的网页<a class="ae mc" href="http://evanamargain.com" rel="noopener ugc nofollow" target="_blank">evanamargain.com</a>或者更具体地访问我的<a class="ae mc" href="http://evanamargain.com/blog" rel="noopener ugc nofollow" target="_blank">博客</a>。你也可以<a class="ae mc" href="https://www.buymeacoffee.com/evana" rel="noopener ugc nofollow" target="_blank">给我买杯咖啡</a>支持我！</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/82745c463c9f3fc381e9a13cdee82722.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*JKyJlywuCXZV3NQktGjAiw.gif"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated"><a class="ae mc" href="https://www.buymeacoffee.com/evana" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/evana</a></figcaption></figure><p id="2c0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下次见！</p><p id="bde5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">埃娃娜·马尔甘·普伊格</p><p id="795f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您需要任何有关移动应用程序的服务，请访问我的网页，<a class="ae mc" href="http://evisoft.mx" rel="noopener ugc nofollow" target="_blank"> evisoft.mx </a>或给我留言contacto@evisoft.mx。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="b5fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mg">原载于2020年1月31日http://www.evanamargain.com</em><a class="ae mc" href="http://www.evanamargain.com/blog/android/hashtable-in-kotlin/" rel="noopener ugc nofollow" target="_blank"><em class="mg"/></a><em class="mg">。</em></p></div></div>    
</body>
</html>