<html>
<head>
<title>GraphQL with Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Java的GraphQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-with-java-afee21e205ef?source=collection_archive---------9-----------------------#2022-09-02">https://levelup.gitconnected.com/graphql-with-java-afee21e205ef?source=collection_archive---------9-----------------------#2022-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7296b3d42bf3aa853b4bb249a6522e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_I8GN_OHNw30FYfd.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:https://graphql.org/</figcaption></figure><p id="d311" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一种同步方法是GraphQL。像往常一样，我想更多地关注实现或提供代码。因此，我将提供一个简短的信息。然而，如果你想深入研究，在页面底部有很好的参考链接。</p><h1 id="cd38" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">这是什么？</h1><h2 id="0421" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">概观</h2><p id="195f" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">GraphQL是一种用于API的查询语言和服务器端运行时，它为API中的数据提供了完整且可理解的描述，使客户能够准确地要求他们所需要的东西，并使API随着时间的推移而发展变得更加容易，并支持强大的开发工具。与SQL或其他查询语言不同，您不使用GraphQL来查询特定的数据存储。它可以用于不同的源。</p><p id="cb29" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GraphQL旨在使API快速、灵活。它甚至可以部署在一个叫做GraphiQL的IDE中。作为REST的替代方案，GraphQL允许开发人员在一个API调用中构造从多个数据源提取数据的请求。</p><p id="bd7c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，GraphQL为API维护人员提供了在不影响现有查询的情况下添加或删除字段的灵活性。</p><h2 id="7d0d" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">GraphQL术语</h2><p id="b9c6" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">开发人员使用GraphQL创建一个<strong class="ke ir">模式</strong>来描述客户端可以通过该服务查询的所有可能的数据。GraphQL模式由对象类型组成，对象类型定义了您可以请求哪种对象以及它拥有哪些字段。</p><p id="ccfa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着<strong class="ke ir">查询</strong>的到来，GraphQL根据模式验证查询。然后，GraphQL执行经过验证的查询。</p><p id="75da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">开发人员将模式中的每个字段附加到一个名为<strong class="ke ir">解析器</strong>的函数上。在执行过程中，会调用解析程序来产生值。</p><p id="dea0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最常见的GraphQL操作可能是<strong class="ke ir">查询</strong>和<strong class="ke ir">突变</strong>。如果我们从CRUD模型的角度来考虑它们，查询将等同于<em class="mp"> read </em>。所有其他的(<em class="mp">创建、更新、</em>和<em class="mp">删除</em>)由突变处理。</p><h2 id="b2df" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">优势</h2><ul class=""><li id="db1f" class="mq mr iq ke b kf mk kj ml kn ms kr mt kv mu kz mv mw mx my bi translated">减少终点。</li><li id="c5d9" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">GraphQL模式在GraphQL应用程序中设置了单一的真实来源。许多不同的人可以访问同一个资源。</li><li id="6a17" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">GraphQL调用在一次往返中处理。</li><li id="9063" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">强定义的数据类型减少了客户机和服务器之间的错误通信。</li><li id="8f22" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">GraphQL是自省的。客户端可以请求可用数据类型的列表。这是自动生成文档的理想选择。</li><li id="773b" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">GraphQL允许应用程序API在不破坏现有查询的情况下发展。</li><li id="d661" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">GraphQL是独立于应用程序架构的。它没有规定任何特定的体系结构。它可以与REST APIs一起工作。</li></ul><h2 id="23a1" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">不足之处</h2><ul class=""><li id="6f27" class="mq mr iq ke b kf mk kj ml kn ms kr mt kv mu kz mv mw mx my bi translated">踏步机学习曲线比REST APIs。</li><li id="7cd0" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">增加了服务器端的复杂性。</li><li id="5f83" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">缓存比REST更复杂，因为它的结构更动态。</li></ul><h2 id="c094" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">履行</h2><p id="378f" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">现在我想提供一些代码部分来展示实现部分。</p><h2 id="32c2" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">概观</h2><p id="7196" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">该项目由以下人员开发:</p><ul class=""><li id="8094" class="mq mr iq ke b kf kg kj kk kn ne kr nf kv ng kz mv mw mx my bi translated">Java 17</li><li id="4a9c" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">带有嵌入式H2数据库的Spring Boot</li><li id="d7d1" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">一个GraphQL Java实现</li><li id="0718" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">龙目岛</li><li id="d2bf" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">专家</li></ul><h2 id="3882" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">GraphQL结构</h2><p id="093d" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我在资源文件夹下创建了graphql文件夹，并添加了两个类，分别是<em class="mp"> book.graphqls </em>和<em class="mp"> query.graphqls </em>。</p><p id="461c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> book.graphqls </strong>:我定义了我的实体，输入和输出模型。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="85b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">query.graphqls :我定义了查询和突变方法。这些操作之前都提到过。</p><p id="fbb4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我给两者都添加了两个方法。</p><ul class=""><li id="c5da" class="mq mr iq ke b kf kg kj kk kn ne kr nf kv ng kz mv mw mx my bi translated">用于查询；allBook(检索所有书籍)和getBookByTitle()</li><li id="27dc" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">对于突变:newBook(用于创建新书)和deleteBook</li></ul><p id="4872" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mp">注意:请注意正确使用结构。否则，您将得到一个错误。</em></p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4d0c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我在<em class="mp">域</em>文件夹下开发了<em class="mp">图书</em>实体如下。因为我在这里使用了Jpa和H2数据库。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9dc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我创建了三个DTO类，分别是<em class="mp"> BookInput </em>、<em class="mp"> BookOutput </em>和<em class="mp"> NewBook </em>。谨记在心。DTO或者你的实体类应该和你在graphls中的定义一致(比如我的是<strong class="ke ir"> book.graphqls) </strong>定义。</p><p id="4f62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="mp"> BookInput </em>、<em class="mp"> BookOutput </em>和<em class="mp"> NewBook </em>类相同。所以，我只是在这里加了<em class="mp">BookInput</em><em class="mp">。</em></p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fdcc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完成定义后，我创建了一个存储库类。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9154" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我在<em class="mp">解析器</em>文件夹下创建了两个类。实际上，这些是我们从REST中熟知的经典控制器类。只是，我需要在这里为graphql使用一些注释，比如<strong class="ke ir"> @QueryMapping </strong>，<strong class="ke ir"> @MutationMapping </strong>和<strong class="ke ir"> @Argument </strong></p><p id="a9ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> @QueryMapping: </strong>批注查询将一个handler方法映射到GraphQL中的一个字段。</p><p id="947d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> @Argument: </strong>用于访问绑定到更高级别类型化对象的命名字段参数</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5959" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> @MutationMapping: </strong>注释变异将一个handler方法映射到GraphQL中的一个字段。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="eb88" class="ly lb iq bd lc lz ma dn lg mb mc dp lk kn md me lo kr mf mg ls kv mh mi lw mj bi translated">邮递员测试</h2><p id="f510" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">开发完应用程序后，我用Postman进行了测试。</p><p id="e83f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我的应用程序运行在8090端口上。</p><p id="7945" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创作一本新书；</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/86131ff3b1337691130050606b09e5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*6ILqzPneOVlmkyHu6Td3Vw.png"/></div></div></figure><p id="d9af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果看起来像这样；</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/60a3b470a3fb9197a3fd3ffa343cbf57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*li-UfqWVPOVvdvhEWLB13w.png"/></div></figure><p id="e41f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我调用了获取所有书籍的查询。它成功地返回了我之前创建的数据。</p><figure class="nh ni nj nk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/f5734fb678c11d79dd1d78fb63130814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whJOCchJHS2YhuAwQwhOkw.png"/></div></div></figure><p id="9533" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我今天试图通过给出一些代码来讨论graphQL。</p><p id="8618" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望对了解graphQL是什么，是如何开发的有所帮助。</p><p id="2b05" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完整的代码可以在我的<a class="ae nq" href="https://github.com/atesibrahim/graphql/tree/master/graphql" rel="noopener ugc nofollow" target="_blank"> Github </a>页面上找到。</p><p id="6356" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读。</p><p id="aa2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">参考文献:</strong></p><div class="nr ns gp gr nt nu"><a href="https://www.howtographql.com/basics/1-graphql-is-the-better-rest/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">GraphQL与REST的比较</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">在过去的十年中，已经成为设计web APIs的标准(尽管还很模糊)。它提供了一些很棒的想法…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.howtographql.com</p></div></div><div class="od l"><div class="oe l of og oh od oi jw nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://blog.api.rakuten.net/graphql-vs-rest/" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">GraphQL与REST——全面的比较</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">REST一直是设计API(应用程序编程接口)的流行架构风格，但最近…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">blog.api.rakuten.net</p></div></div><div class="od l"><div class="oj l of og oh od oi jw nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://github.com/swathisprasad/graphql-with-spring-boot" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">GitHub-swathisprasad/graphql-with-spring-boot:带有graph QL和Spring Boot的示例应用程序</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">github.com</p></div></div><div class="od l"><div class="ok l of og oh od oi jw nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://www.graphql.com/articles/4-years-of-graphql-lee-byron" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">GraphQL四年的经验教训</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">自从GraphQL四年前在脸书诞生，并于一年前公开发布以来，GraphQL社区已经…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.graphql.com</p></div></div><div class="od l"><div class="ol l of og oh od oi jw nu"/></div></div></a></div><div class="nr ns gp gr nt nu"><a href="https://www.redhat.com/en/topics/api/what-is-graphql" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">GraphQL是什么？</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">GraphQL是一种应用程序编程接口(API)的查询语言和服务器端运行时</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.redhat.com</p></div></div><div class="od l"><div class="om l of og oh od oi jw nu"/></div></div></a></div></div></div>    
</body>
</html>