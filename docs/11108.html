<html>
<head>
<title>How to Get a Perfect Deep Copy in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中获得完美的深度拷贝？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-pure-javascript-to-get-a-perfect-deep-copy-5fdc2d9e3d42?source=collection_archive---------10-----------------------#2022-02-16">https://levelup.gitconnected.com/use-pure-javascript-to-get-a-perfect-deep-copy-5fdc2d9e3d42?source=collection_archive---------10-----------------------#2022-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现大约20行的几乎完美的深度复制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/219c5f9ef79b455651b71357e9043317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oQc4gS1lfXZQlCE3"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">你好我是尼克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="0eb4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">先验知识</h1><p id="d000" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Javascript中的数据类型可以分为基元值类型和引用值类型。当我们进行数据操作时，它们会有一些差异。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="1184" class="ms la it mo b gy mt mu l mv mw">let primitiveValue = 1;<br/>const copyPrimitiveValue = primitiveValue;</span><span id="6bb9" class="ms la it mo b gy mx mu l mv mw">primitiveValue = 2;<br/>console.log('primitiveValue: ', primitiveValue); // 2<br/>console.log('copyPrimitiveValue: ', copyPrimitiveValue); // 1</span><span id="f581" class="ms la it mo b gy mx mu l mv mw">const referenceValue = { value: 1 };<br/>const copyReferenceValue = referenceValue;</span><span id="e6e5" class="ms la it mo b gy mx mu l mv mw">referenceValue.value = 2;<br/>console.log('referenceValue: ', referenceValue); // { value: 2 }<br/>console.log('copyReferenceValue: ', copyReferenceValue); // { value: 2 }</span></pre><p id="771b" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">看上面的代码，不难发现，当原值类型改变时，其复制的变量不会有任何影响；但是当引用值类型改变时，其复制的变量也会改变。为了解释这一点，我们必须首先了解数据在Javascript中是如何存储的。</p><p id="1ddc" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如上所述，数据类型可以分为两种。原始值类型包括undefined、null、number、string、boolean、symbol和bigint引用值类型包括从对象、函数对象等派生的数组对象。基元值类型直接存储在堆栈上，而引用值类型存储在堆上，堆栈上有一个地址指向它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/c83143487499db546fb56ab5e0949f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhUd9Da7RGjG39viK_21yg.png"/></div></div></figure><p id="3fa0" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">这样，我们就可以解释上述现象了。对于原始值类型，直接复制副本，对于引用值类型，复制地址，这导致reference value和copyReferenceValue都指向堆上的同一块数据。换句话说，这两个地址都可以改变堆上的同一块数据。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="ba8e" class="kz la it bd lb lc nl le lf lg nm li lj jz nn ka ll kc no kd ln kf np kg lp lq bi translated">浅拷贝</h1><p id="c5f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">浅拷贝是指只拷贝对象的一层，对象的深层直接拷贝一个地址。Javascript中有很多原生方法是浅层拷贝。例如，使用<code class="fe nq nr ns mo b">Object.assign</code> API或spread操作符。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="22e9" class="ms la it mo b gy mt mu l mv mw">const target = {};<br/>const source = { a: { b: 1 }, c: 2 };</span><span id="5abb" class="ms la it mo b gy mx mu l mv mw">Object.assign(target, source);<br/>source.a.b = 3;<br/>source.c = 4;</span><span id="3594" class="ms la it mo b gy mx mu l mv mw">console.log(source); // { a: { b: 3 }, c: 4 }<br/>console.log(target); // { a: { b: 3 }, c: 2 }</span><span id="f36c" class="ms la it mo b gy mx mu l mv mw">// Same effect as Object.assign<br/>const target1 = { ...source };</span></pre><h1 id="fe99" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">深层拷贝</h1><p id="1262" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">深度拷贝意味着克隆两个相同的对象，但彼此之间没有任何联系。</p><p id="2f7c" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><strong class="lt iu"> 1。JSON.stringify API </strong></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e741" class="ms la it mo b gy mt mu l mv mw">const source = { a: { b: 1 } };<br/>const target = JSON.parse(JSON.stringify(source));</span><span id="512c" class="ms la it mo b gy mx mu l mv mw">source.a.b = 2;<br/>console.log(source); // { a: { b: 2 } };<br/>console.log(target); // { a: { b: 1 } };</span></pre><p id="1f20" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">嗯，看起来JSON.stringify可以实现深度复制，但是有一些缺陷。例如，它不能复制函数、未定义的、日期、不能复制不可枚举的属性、不能复制循环引用的对象等等。你可以在<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description" rel="noopener ugc nofollow" target="_blank"> <em class="nt"> MDN </em> </a>上查看详细描述。</p><p id="876c" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><strong class="lt iu"> 2。近乎完美的深度复制</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="32ef" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">上面的代码是最后的结果，我来解释一下它是怎么来的。</p><ol class=""><li id="b807" class="nw nx it lt b lu my lx mz ma ny me nz mi oa mm ob oc od oe bi translated">首先，我们使用WeakMap作为哈希表来解决循环引用问题，可以有效防止内存泄漏。可以在<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank"> <em class="nt"> MDN </em> </a>上查看WeakMap的描述。</li><li id="d39c" class="nw nx it lt b lu of lx og ma oh me oi mi oj mm ob oc od oe bi translated">对于特殊类型Date和RegExp，将直接生成并返回一个新实例。</li><li id="a51b" class="nw nx it lt b lu of lx og ma oh me oi mi oj mm ob oc od oe bi translated">使用<code class="fe nq nr ns mo b">Object.getOwnPropertyDescriptors</code>获取当前对象的所有属性描述，使用<code class="fe nq nr ns mo b">Object.getPrototypeOf</code>获取当前对象的原型。将这两项作为参数传递给<code class="fe nq nr ns mo b">Object.create</code> API，创建一个具有相同原型和相同属性的新对象。</li><li id="1365" class="nw nx it lt b lu of lx og ma oh me oi mi oj mm ob oc od oe bi translated">使用<code class="fe nq nr ns mo b">Reflect.ownKeys</code>迭代当前对象的所有属性，包括不可枚举属性和符号属性，以及普通属性。这样，深层的值就可以在循环和递归中不断地复制到当前的新对象中。</li><li id="c201" class="nw nx it lt b lu of lx og ma oh me oi mi oj mm ob oc od oe bi translated">在循环判断中，除了函数是直接赋值的，其他都是通过递归重新复制的。</li></ol><p id="fcaf" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">接下来，我们可以使用测试代码来验证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok nv l"/></div></figure><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6dd8" class="ms la it mo b gy mt mu l mv mw">const symbolKey = Symbol('symbolKey');<br/>const originValue = {<br/>  num: 0,<br/>  str: '',<br/>  boolean: true,<br/>  unf: void 0,<br/>  nul: null,<br/>  obj: { name: 'object', id: 1 },<br/>  arr: [0, 1, 2],<br/>  func() {<br/>    console.log('function');<br/>  },<br/>  date: new Date(0),<br/>  reg: new RegExp('/regexp/ig'),<br/>  [symbolKey]: 'symbol',<br/>};<br/>Object.defineProperty(originValue, 'innumerable', {<br/>  // writable is true to ensure that the assignment operator can be used<br/>  writable: true,<br/>  enumerable: false,<br/>  value: 'innumerable',<br/>});</span><span id="98d2" class="ms la it mo b gy mx mu l mv mw">// Create circular reference<br/>originValue.loop = originValue;<br/>// Deep Copy<br/>const clonedValue = deepClone(originValue);<br/>// Change original value<br/>originValue.arr.push(3);<br/>originValue.obj.name = 'newObject';<br/>// Remove circular reference<br/>originValue.loop = '';<br/>originValue[symbolKey] = 'newSymbol';</span><span id="98e8" class="ms la it mo b gy mx mu l mv mw">console.log('originValue: ', originValue);<br/>console.log('clonedValue: ', clonedValue);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/808b062882250d267b5c8a2e7399c371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSAr9mWiFFSYCa5ndKi6Ug.png"/></div></div></figure><p id="a2cb" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">太好了，它似乎工作得很完美！接下来，我们来看另一个解决方案。</p><p id="d04c" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated"><strong class="lt iu"> 3。结构化克隆API </strong></p><p id="4f13" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">感谢<a class="om on ep" href="https://medium.com/u/486eaf1c976?source=post_page-----5fdc2d9e3d42--------------------------------" rel="noopener" target="_blank"> Andrew Wooldridge </a>在回复区提到了<code class="fe nq nr ns mo b">structuredClone</code> API。我发现它可以原生实现深度复制，但是只能克隆<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="nt">结构化-可克隆类型</em> </a> <em class="nt">。</em>例如，函数对象不能被克隆，会抛出DataCloneError异常。它也不克隆setters、getters和类似的类似元数据的特性。</p><p id="be83" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">这是一个非常新的API，我们可以期待它的未来发展。在chrome 98版本已经支持，可以在<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone" rel="noopener ugc nofollow" target="_blank"> <em class="nt"> MDN </em> </a>上查看使用情况，在<a class="ae ky" href="https://caniuse.com/?search=structuredClone" rel="noopener ugc nofollow" target="_blank"> <em class="nt">上查看兼容性，可以使用</em> </a>。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="ac20" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">就这样，很棒，不是吗？在这个阶段，使用选项2允许我们在Javascript中有一个几乎完美的深层副本。</p><p id="c0f0" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">今天就到这里。我是Zachary，我会继续输出与web开发相关的故事，如果你喜欢这样的故事并想支持我，请考虑成为 <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nt">中级会员</em> </a> <em class="nt">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nt">我的链接</em> </a> <em class="nt">报名，我会得到一点佣金。</em></p><p id="0c03" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">你的支持对我来说非常重要——谢谢。</p></div></div>    
</body>
</html>