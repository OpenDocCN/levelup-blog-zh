<html>
<head>
<title>Big O Notation and Time Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号和时间复杂性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/big-o-notation-and-time-complexity-22743c188364?source=collection_archive---------5-----------------------#2020-07-09">https://levelup.gitconnected.com/big-o-notation-and-time-complexity-22743c188364?source=collection_archive---------5-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/68aede154a0b41884639f14fa7e9c02a.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*vEQ3MXjfYGXn3LhF6zS3GQ.jpeg"/></div></figure><p id="371f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">大O符号是对算法效率的简化分析。大O符号以输入大小n的形式给出了算法的复杂度，它提供了一种从运行算法或代码的机器/计算机中提取算法或代码效率的方法。我们不关心我们的机器有多强大，而是关心代码的基本步骤。我们可以用大O来分析时间和空间。我将以Ruby为例，介绍如何使用Big O来度量时间复杂度。</p><p id="09c5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">测量类型</strong></p><p id="a59f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有几种方法可以考察算法的效率。我们可以检查最坏情况、最好情况和一般情况。当我们研究大O符号时，我们通常着眼于最差的情况。这并不是说其他案件不重要。</p><p id="e7bf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">一般规则</em></p><ol class=""><li id="134a" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">忽略常数</li></ol><p id="2637" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">5n -&gt;O(n)</p><p id="db3f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">大O符号忽略常量。例如，如果你有一个运行时间为5n的函数，我们说这个函数运行在N的大O的数量级上，这是因为随着N变大，5不再重要。</p><p id="bee4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">2.与N增长的方式相同，某些术语“支配”其他术语</p><p id="a1d0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里有一个列表:</p><p id="e8fc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">o(1)&lt;o(logn)&lt;o(n)&lt;o(nlogn)&lt;o(n)&lt;o(2^n)&lt;o(n！)</strong></p><p id="34eb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当低阶项受高阶项支配时，我们忽略低阶项。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lf"><img src="../Images/991b2b690f8b1869fc0d6480d553291f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RNEzpv6-2rcHkulA.jpeg"/></div></div></figure><p id="1007" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">常数时间:O(1) </strong></p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/01ffa994da9bdd7fbc516b19eb41fcaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*rsLWvDt1uLWVRfsL7R6E1Q.png"/></div></figure><p id="f13f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个基本语句计算x，并且不以任何方式依赖于输入大小。这与输入大小n无关，我们说这是一个“1的大O”或常数时间。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/ff740c1bfa13a528b82d58df92de54ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*Mfi9gWF8DoEKRaafCZJKbQ.png"/></div></figure><p id="d20e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">总时间= O(1) + O(1) + O(1) = <strong class="jz iu"> O(1) </strong></p><p id="7b77" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当我们有一系列语句时会发生什么？请注意，所有这些都是常数时间。我们如何计算这个代码块的大O？我们简单地将他们的时间相加，得到3 * O(1)。但是记住我们去掉了常数，所以这仍然是1的大O。</p><p id="92d1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">线性时间:O(n) </strong></p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/ff19743b459880ed100cb9d4b27c5198.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*CsMVSnfguPvxXpiOH9cOYQ.png"/></div></figure><p id="d659" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该方法的运行时间是线性的或O(n)。我们在这个方法中有一个循环，它遍历数组并输出元素。该循环执行的操作数量将根据数组的大小而变化。例如，大小为6的数组将只需要6次迭代，而18个元素的数组将需要3倍的时间。随着输入大小的增加，运行时也会增加。</p><p id="3d60" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">指数(二次)时间:O(n ) </strong></p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/768e29dc62be5443ac8f970d22390a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*zmx54PhaaxxauNrysO3OMg.png"/></div></figure><p id="0a63" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当我们有嵌套循环时，通常我们的运行时间是指数级的，即O(n)。当我们在嵌套循环中时，外部循环将进行第一次迭代，然后内部循环将在返回外部循环的第二次迭代之前进行完全迭代。当您处理大型数组时，这将变得非常低效，因为这些程序的运行时变得越来越长。该循环将根据输入大小计算迭代次数的平方。数组大小为10将需要100次迭代。</p><p id="ae22" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">对数时间:O(log n) </strong></p><p id="a7d7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对数运行时间是一个非常有效的符号。与其解释对数函数是如何工作的(因为我数学很差)，举个例子可能更容易。一直使用对数时间的例子有<strong class="jz iu"> <em class="kv">二分搜索法</em> </strong>。假设我们有一个已排序的数字数组:</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/c75a5bd94aee2b63be2bf63173fbfa67.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*-5fDZ7EMHkHA4IaOnDOPQg.png"/></div></figure><p id="c21d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们被告知搜索数字14，我们可以遍历整个数组，直到找到14(线性时间)。二分搜索法从集合的中间开始，比较它旁边的两个值，使这变得更容易。假设我们从9点开始。我们会考虑数字14是在数字9的右边还是左边。然后我们忽略9的左边，因为14比9高。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/71a2fb0ee04a9e3c76ac2ee26bd132b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*_Fddh9TbERLf7oZiBSZhNA.png"/></div></figure><p id="974e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要做的就是继续同样的模式，直到我们达到目标。</p><figure class="lg lh li lj gt ju gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/1d402131dd37d4fe9d6a26be92bff021.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*AAIUr5ljZtQx9rHqQ0SRvQ.png"/></div></figure><p id="e1da" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">根据您开始值搜索的位置，我们可以在这里结束操作！我们只需要进行3-4次搜索，而不是14次迭代。</p><p id="3fd8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">结论</strong></p><p id="4b43" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在处理算法时，知道我们为什么使用大O符号是很重要的。我们可以开发高效的算法，从而减少代码(空间复杂度)并提高程序速度。我没有检查任何高于二次时间的东西，但是我知道这些运行时间非常慢。实际上，要注意你的算法需要多长时间。根据您正在使用的应用程序，可伸缩且干净的代码通常会带来更好的程序。始终留意最佳情况和最坏情况的运行时间！</p></div></div>    
</body>
</html>