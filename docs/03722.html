<html>
<head>
<title>Message Queuing with RabbitMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RabbitMQ的消息队列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/message-queuing-with-rabbitmq-7e4682146e39?source=collection_archive---------14-----------------------#2020-05-24">https://levelup.gitconnected.com/message-queuing-with-rabbitmq-7e4682146e39?source=collection_archive---------14-----------------------#2020-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/89f904ad915417d7454680d0ad87f0ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HvJ7oQ21H4D79n1QT188A.jpeg"/></div></div></figure><p id="ca42" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated">abbitMQ是一个开源的消息代理软件，最初实现了高级消息队列协议(AMQP)。正如他们的官方网站<strong class="kd iu">中提到的，RabbitMQ是部署最广泛的开源消息代理。</strong>在深入RabbitMQ之前，让我们试着理解什么是消息代理，以及我们为什么需要它们。</p><h1 id="6872" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是消息代理</h1><p id="5e74" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated"><strong class="kd iu">消息代理</strong>是一种通信技术，用于应用程序之间的通信。在处理两个或多个应用程序之间的通信时，它们充当中间平台。那么什么时候我们需要在我们的软件系统中使用消息代理呢？我们可以在许多用例中使用消息代理。我在下面列出了一些常见的用例。</p><ul class=""><li id="c1cd" class="ml mm it kd b ke kf ki kj km mn kq mo ku mp ky mq mr ms mt bi translated">将单个应用程序解耦，这样，通过消息代理进行通信，可以在多个应用程序中执行功能，而不是在单个应用程序中执行功能。</li><li id="e878" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">处理异步任务，这可能需要更多的CPU时间，以便主应用程序不会被阻塞或获得更少的资源。</li><li id="3acd" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">通过控制正在处理的请求数量来处理流量高峰，并确保即使在应用程序离线时请求最终也能得到处理。</li><li id="f0a7" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">事务排序，保证事务执行，并确保事务执行只发生一次。</li></ul><p id="d52f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面提到的用例只是您可以在系统中使用消息代理的一小部分用例。现在我们对在哪些场景中需要使用消息代理有了基本的了解。但是RabbitMQ是我们唯一可以使用的消息代理吗？答案是<strong class="kd iu">否</strong>。下面是社区中其他一些广泛使用的消息代理。</p><ul class=""><li id="b1d0" class="ml mm it kd b ke kf ki kj km mn kq mo ku mp ky mq mr ms mt bi translated">ActiveMQ</li><li id="78ad" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">卡夫卡</li><li id="d3fd" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">AWS SQS</li><li id="d908" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">ZeroMQ</li><li id="c090" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">RocketMQ</li></ul><p id="a112" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，目前社区中有如此多的消息代理，每一个都有自己的优点和缺点。在这篇文章中，我不打算对它们进行比较。我选择写RabbitMQ是因为它是最常用的消息代理之一，如果您是消息代理的初学者，使用RabbitMQ很容易理解消息队列概念。</p><p id="e7e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，既然现在我们知道我们要谈论什么，让我们深入研究RabbitMQ。</p><h2 id="1fa0" class="mz lj it bd lk na nb dn lo nc nd dp ls km ne nf lw kq ng nh ma ku ni nj me nk bi translated">RabbitMQ安装</h2><p id="9f29" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">关于如何安装RabbitMQ的详细文档可以在https://www.rabbitmq.com/download.html的官方网站上找到。他们提供了许多不同的方法，可以在不同的环境中下载和安装rabbit-mq。</p><p id="da2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是他们提供的最常见的安装选项。</p><ul class=""><li id="fd31" class="ml mm it kd b ke kf ki kj km mn kq mo ku mp ky mq mr ms mt bi translated">使用安装文件安装(windows\Linux或mac)</li><li id="6574" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">使用Docker安装</li><li id="d6fd" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">作为云服务提供商提供的服务使用</li></ul><p id="6a24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，让我们试着用docker安装rabbit-mq，因为如果你有一台安装了docker的机器，这是最简单的方法。rabbit-mq的Docker图像可从https://registry.hub.docker.com/_/rabbitmq/获得。</p><p id="21d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要从docker hub中提取图像，并在容器中运行它。下面是运行rabbit-mq映像的命令。(该命令不会启动rabbit-mq仪表板，如果您不想手动启动仪表板，我将在下面提供自动启动仪表板的命令)。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="eb30" class="mz lj it nr b gy nv nw l nx ny">docker run -d --hostname rabbit-server --name rabbit-                                                                                                             service rabbitmq:3</span></pre><p id="9a6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">确保提供一个<strong class="kd iu">主机名</strong>，因为RabbitMQ根据它所谓的<strong class="kd iu">节点名</strong>存储数据，默认为主机名。如果我们不提供主机名，docker将自动创建一个随机字符的主机名。</p><p id="2811" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，现在我们有了一个运行在docker容器中的rabbit-mq实例。rabbit-mq将映射到的默认端口是5672。RabbitMQ使用amqp协议进行通信，而不是TCP。我们需要做的第一件事是启用rabbit-mq仪表板。为此，我们需要进入容器并启用rabbitmq_management插件</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="30f7" class="mz lj it nr b gy nv nw l nx ny">docker exec -it rabbit-service bash</span></pre><p id="c871" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的命令将带我们进入与rabbit-mq容器的交互会话。要启用仪表板插件，请发出以下命令。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="d5f7" class="mz lj it nr b gy nv nw l nx ny">rabbitmq-plugins enable rabbitmq_management</span></pre><p id="1459" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将启用管理插件，并为仪表板显示端口15672。不用进入容器，我们也可以使用docker run命令来启用插件。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="96eb" class="mz lj it nr b gy nv nw l nx ny">docker run -d --hostname rabbit-server --name rabbit-                                                                                                             service rabbitmq:3<!-- -->-management</span></pre><p id="20de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在转到localhost:15672，仪表板应该是可用的。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/7f5ee1077c0268ad9d35454b85cc997d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*jCj1eMOyxBoQKu0apv6xYQ.png"/></div></figure><p id="5caf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认用户名和密码应该是<strong class="kd iu"> guest </strong>和<strong class="kd iu"> guest </strong>。登录仪表板时，请确保创建新用户和密码。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/ecd6fa14619e4820dd00563a3aa99f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_6DEAN1pPit6KV3Nwh_hg.png"/></div></div></figure><p id="f677" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以从<strong class="kd iu">管理</strong>选项卡创建新帐户。创建新用户后，默认用户将没有任何权限。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/27432aa4c52e5de50217074ee797c8a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*iE0meGV9rt8SvXjZi9M0fQ.png"/></div></figure><p id="f08f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要确保用户可以访问虚拟主机。为此，单击用户，然后单击<strong class="kd iu">设置权限</strong>。这将设置新用户的权限。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/14bcda017be41316adcb4a5bddd6e4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*jI-JasawM-86O4diBcFhlw.png"/></div></figure><p id="d29e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想让你们进入容器内部的原因是为了大致了解容器内部发生了什么，因为将来我们可能需要进行一些配置。docker镜像安装rabbitmq的默认位置是<strong class="kd iu"> /opt/rabbitmq </strong>。在那里，如果你去<strong class="kd iu"> sbin </strong>文件夹，我们可以找到一些可执行文件，我们可以用它们来配置rabbit-mq。他们是</p><ul class=""><li id="0bf4" class="ml mm it kd b ke kf ki kj km mn kq mo ku mp ky mq mr ms mt bi translated">rabbit MQ-默认值</li><li id="07da" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">rabbitmq诊断</li><li id="088a" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">rabbitmq-env</li><li id="11e8" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">rabbit MQ-插件</li><li id="911e" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">rabbitmq队列</li><li id="6676" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">rabbit MQ-服务器</li><li id="fdcb" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">rabbit MQ-升级</li><li id="97aa" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">rabbitmqctl</li></ul><p id="cef3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由此我们已经使用了<strong class="kd iu"> rabbitmq-plugins </strong>来启用我们的仪表板插件。如果你进入</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="9e33" class="mz lj it nr b gy nv nw l nx ny">rabbitmq-plugins list</span></pre><p id="f098" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将列出所有可用的插件以及当前启用的插件。<strong class="kd iu"> rabbitmq-server </strong>是启动rabbit-mq服务器的可执行文件。从<strong class="kd iu"> rabbitmqctl </strong>我们可以进行各种配置，比如创建队列、删除队列等..</p><p id="50b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们看看如何在我们的应用程序中使用rabbit-mq。下面我使用Node.js，但是你可以使用任何你想要的语言。rabbit-mq已经支持大多数广泛使用的语言。</p><h2 id="4cff" class="mz lj it bd lk na nb dn lo nc nd dp ls km ne nf lw kq ng nh ma ku ni nj me nk bi translated">连接到RabbitMQ服务器</h2><p id="4bbb" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">在连接到rabbit-mq之前，我们需要在我们的项目中添加amqplib。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="55a7" class="mz lj it nr b gy nv nw l nx ny">npm i amqplib --save</span></pre><p id="5df0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，为了连接到服务器，我们需要提供用户凭证。让我们首先创建一个配置文件来存储我们的rabbit配置细节。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="8b32" class="mz lj it nr b gy nv nw l nx ny">module.exports = env {<br/>   rabbitmq : {<br/>        domain : 'amqp://localhost',<br/>        user : 'admin',<br/>        password : 'pwd'<br/>   }<br/>}</span></pre><p id="8d3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个rabbitmqConnection文件，并在那里编写连接rabbit-mq的代码。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="b8b9" class="mz lj it nr b gy nv nw l nx ny">const amqp = require('amqplib/callback_api')<br/>const {env} = require('./env')</span><span id="a4d4" class="mz lj it nr b gy od nw l nx ny">const {domain, user, password} = env.rabbitmq<br/>const opt = {credentials: require('amqplib').credentials.plain(user, password)</span><span id="119f" class="mz lj it nr b gy od nw l nx ny">amqp.connect(domain, opt, (err, connection) =&gt; {<br/> if (error) {<br/>    throw error;<br/>  }</span><span id="f41e" class="mz lj it nr b gy od nw l nx ny">  //use connection</span><span id="3e0e" class="mz lj it nr b gy od nw l nx ny">})</span></pre><p id="d4f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是连接到我们的rabbit-mq服务器的方法。现在我们有了一个连接，以后可以用它来对rabbit-mq进行其他配置。下一步是创建一个通道，以便与我们的rabbit-mq服务器进行通信。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="f0aa" class="mz lj it nr b gy nv nw l nx ny">connection.createChannel((err, channel) =&gt; {<br/>  if (err) {<br/>    throw err;<br/>  }</span><span id="6dc3" class="mz lj it nr b gy od nw l nx ny">  //use channel</span><span id="32db" class="mz lj it nr b gy od nw l nx ny">})</span></pre><p id="cb65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了可以与rabbit-mq服务器通信的通道。建议每个客户端只打开一个通道。现在我们要做的是创建队列。在创建队列之前，让我们先看看rabbit-mq提供了什么样的队列路由。为此，让我们看看rabbit-mq如何将消息发布到队列中。</p><p id="946a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在rabbit-mq中，消息不直接发布到队列中。相反，它们首先被送到一个叫做<strong class="kd iu">交易所</strong>的地方。Exchange负责哪个队列将获得哪个邮件。那么这个交换如何知道我们的队列呢？为了做到这一点，我们需要将我们的队列绑定到这个交换。Exchange为我们提供了4种将邮件发布到队列的方法，称为路由选项。</p><ul class=""><li id="ccd4" class="ml mm it kd b ke kf ki kj km mn kq mo ku mp ky mq mr ms mt bi translated">直接汇兑</li><li id="682f" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">扇出交换机</li><li id="e42c" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">话题交流</li><li id="dab7" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">标题交换</li></ul><p id="3897" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">直接交换</strong></p><p id="4b39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">直接交换根据邮件路由关键字将邮件传递到队列。路由关键字是由生产者添加到消息头的消息属性。在本文中，我们将使用这个路由选项，我们的关键字是队列名称。</p><p id="faa5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">扇出交换</strong></p><p id="e43f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">扇出交换将接收到的消息复制并路由到与其绑定的所有队列，而不考虑路由关键字或模式匹配。当相同的消息需要被发送到多个队列以得到不同的处理时，这种类型的路由非常有用。</p><p id="3675" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">话题交流</strong></p><p id="29de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主题交换根据路由关键字和路由模式之间的通配符匹配将邮件路由到队列。这些模式是在我们绑定队列时在交换中定义的</p><p id="730c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">割台交换</strong></p><p id="5645" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">头交换基于包含头和可选值的参数来路由邮件。头交换与主题交换非常相似，但是基于头值而不是路由关键字来路由消息</p><h2 id="1fd5" class="mz lj it bd lk na nb dn lo nc nd dp ls km ne nf lw kq ng nh ma ku ni nj me nk bi translated">正在创建Exchange</h2><p id="535f" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">下面的代码在直接模式下创建我们的交换。我们将durable指定为true，以便在交换之外保持。我将在后面更多地谈论这种耐久性。assertExchange方法所做的是检查是否存在具有我们提供的名称的交换，如果不存在，它将创建这个交换。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="f24d" class="mz lj it nr b gy nv nw l nx ny">let exchange = 'exchange name'</span><span id="56ae" class="mz lj it nr b gy od nw l nx ny">channel.assertExchange=(exchange, 'direct'{<br/>  durable : true<br/>})</span></pre><p id="a763" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面完成的相同配置也可以使用仪表板来完成。要从仪表板创建交易所，请转到<strong class="kd iu">交易所</strong>选项卡，并在那里添加交易所。一定要把耐久性做的经久耐用。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/adaad8bfe568ac6ef7bc645c0a53a82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qzr06OVlostyF7PtEGAPBA.png"/></div></div></figure><h2 id="49a2" class="mz lj it bd lk na nb dn lo nc nd dp ls km ne nf lw kq ng nh ma ku ni nj me nk bi translated">创建队列</h2><p id="e184" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">现在，我们已经创建了我们的交换，让我们现在创建我们的队列。就像上面一样，我们使用assertQueue方法来创建我们的队列，传递一个队列名称和选项durable为true，它告诉使队列持久。下一步是将我们创建的队列绑定到我们之前创建的交换。这里，在bindQueue方法中，第三个参数应该是路由键，我们在这里指定队列名。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="6d6f" class="mz lj it nr b gy nv nw l nx ny">let queueName = 'queueName'</span><span id="e00e" class="mz lj it nr b gy od nw l nx ny">channel.assertQueue(queueName, {durable: true}, (err, q) =&gt; {<br/>    channel.bindQueue(q.queue, exchange, queueName)</span><span id="a176" class="mz lj it nr b gy od nw l nx ny">   //use q.queue</span><span id="a64f" class="mz lj it nr b gy od nw l nx ny">})</span></pre><p id="b01e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，我们从代码中进行的相同配置也可以使用仪表板来完成。从仪表板添加队列，并转到<strong class="kd iu">队列</strong>选项卡。在那里，我们可以提供一个名称，使持久性成为持久的，并创建一个队列。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi of"><img src="../Images/cefac9bf4f1b1c8a71b0c3428ff1e6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cplZPSOEI4KYJmZ1XJDwRQ.png"/></div></div></figure><p id="e4bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一个任务是将这个队列绑定到我们的exchange。为此，单击队列并选择树项目上的绑定。在这里，我们需要提供交换名称和路由密钥。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/3aeac41ab0cb6eca7b5947c9604ee426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DQWatdUquhPBJ3DWorrqg.png"/></div></div></figure><p id="747c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们的队列被绑定到exchange，路由关键字为queueName。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/8634e249ad0247a7f1c0e253ecafd8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMCrhl5LzRQML47JPdiu3A.png"/></div></div></figure><h2 id="925a" class="mz lj it bd lk na nb dn lo nc nd dp ls km ne nf lw kq ng nh ma ku ni nj me nk bi translated">创造消费者</h2><p id="af1c" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们现在已经创建了我们的队列。现在，下一个任务是为这个队列创建消费者。消费者将接受这条消息，并执行我们在应用程序中定义的所需功能。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="c234" class="mz lj it nr b gy nv nw l nx ny">let queueName = 'queue-name'</span><span id="96f0" class="mz lj it nr b gy od nw l nx ny">channel.assertQueue(queueName, {durable: true}, (err, q) =&gt; {</span><span id="3aac" class="mz lj it nr b gy od nw l nx ny">   channel.consume(q.queue, (msg) =&gt; {<br/>       let message = JSON.parse(msg.content.toString())<br/>       //process message<br/>       channel.ack(msg, false)</span><span id="600c" class="mz lj it nr b gy od nw l nx ny">       //channel.nack(msg, false)<br/>    })</span><span id="0e67" class="mz lj it nr b gy od nw l nx ny">})</span></pre><p id="f011" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们有了一个与我们的交换绑定的队列和一个将使用我们队列中的消息的消费者。但是谁将向我们的队列发布消息呢？这些将是生产者。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="ed35" class="mz lj it nr b gy nv nw l nx ny">connection.createChannel((err, channel) =&gt; {<br/>  if (err) {<br/>    throw err;<br/>  }</span><span id="87c9" class="mz lj it nr b gy od nw l nx ny">  let message= 'message we want to send'  </span><span id="32ca" class="mz lj it nr b gy od nw l nx ny">  channel.publish(exchangeName, queueName, Buffer.from(JSON.stringify(message), {persistent : true} )</span><span id="364b" class="mz lj it nr b gy od nw l nx ny">})</span></pre><p id="523e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码展示了生产者如何将消息发布到队列中。记得我说过生产者不是直接向队列发布消息，而是向交换发布消息。这就是为什么我们把exchange作为上面的第一个参数传递。第二个参数是路由键，在我们的例子中是队列名。第三个参数是消息本身。</p><p id="1b50" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于生产者发布消息和消费者使用消息的整个生命周期来说，这基本上就是队列。但是在结束这篇文章之前，我想讨论几个概念。</p><h2 id="196a" class="mz lj it bd lk na nb dn lo nc nd dp ls km ne nf lw kq ng nh ma ku ni nj me nk bi translated">消息确认</h2><p id="1840" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">默认情况下，当消息从队列发送到消费者时，rabbit-mq会将其标记为已消费的消息，并从队列中删除。但是通过使用消息确认，我们可以延迟它，直到消费者将msg.ack发送回队列。这有助于在使用者中处理错误，并在失败时重试消息。我们可以通过将否定确认(msg.nack)发送回队列来实现这一点，这使得消息被发送回队列。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="7684" class="mz lj it nr b gy nv nw l nx ny">channel.consume(q.queue, (msg) =&gt; {<br/>       let message = JSON.parse(msg.content.toString())<br/>       //process message<br/>       if(sucess)<br/>          channel.ack(msg, false)<br/>       else<br/>          channel.nack(msg, false)</span><span id="ad89" class="mz lj it nr b gy od nw l nx ny">})</span></pre><p id="a201" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过将第二个参数设为true，我们可以选择同时发送多个确认。到那时，它会将到那时为止所有未确认的消息都确认为已确认。</p><h2 id="c73b" class="mz lj it bd lk na nb dn lo nc nd dp ls km ne nf lw kq ng nh ma ku ni nj me nk bi translated">消息预取</h2><p id="f007" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">预取是限制消费者在给定时间可以使用的消息数量的方法。使用来自该消费者的未确认消息的数量来标识当前正在处理的消息的数量。当我们想限制消费者不要使用太多资源和崩溃时，这就很有用了。预取是根据通道设置的。因此，如果多个用户使用一个通道，预取将在全局范围内对所有用户进行设置。在这种情况下，如果我们希望每个消费者的每个预取在下面的代码中为第二个参数设置false值。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="866d" class="mz lj it nr b gy nv nw l nx ny">channel.prefetch(limit, true)</span></pre><h2 id="1444" class="mz lj it bd lk na nb dn lo nc nd dp ls km ne nf lw kq ng nh ma ku ni nj me nk bi translated">坚持</h2><p id="2cc9" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">我们需要坚持，因为这样我们才能处理失败和恢复。当我们考虑失败时，我们需要考虑两种类型的失败场景。</p><ul class=""><li id="42f6" class="ml mm it kd b ke kf ki kj km mn kq mo ku mp ky mq mr ms mt bi translated">Rabbit-mq服务器失败</li><li id="98b9" class="ml mm it kd b ke mu ki mv km mw kq mx ku my ky mq mr ms mt bi translated">我们的消费者(应用程序)失败</li></ul><p id="32f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先我们来谈谈rabbit-mq服务器故障。如果rabbit服务器出现故障，我们将丢失所有的交换和队列配置。但幸运的是，我们可以在创建这些组件时通过给出{durable: true}选项来使它们持久。通过使它们持久，rabbit-mq将把配置写到磁盘上。因此，在失败的情况下，当rabbit-mq服务器重启时，它将从存储中获取所有的配置细节，并创建我们的交换和队列。</p><p id="f9ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个失败场景是我们的应用程序失败。在这种情况下，在我们的应用程序重新启动后，应该使用已经使用的任何消息(这意味着它们还没有被确认)。为此，当我们向队列发布消息时，我们使消息持久化。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="5f05" class="mz lj it nr b gy nv nw l nx ny">channel.publish(exchangeName, queueName, Buffer.from(JSON.stringify(message), {persistent : true} )</span></pre><p id="f190" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是为了使消息持久，我们还必须确保队列也被创建为持久的。因此，在创建需要持久保存消息的队列时，请确保使队列像上面所示的那样持久。</p><p id="83c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个帖子到此为止。在使用消息代理制作企业应用程序之前，我们还应该了解很多其他的概念。但我想这已经给了你基本的概念。感谢您阅读这篇文章，我们将在下一篇文章中再见。</p></div></div>    
</body>
</html>