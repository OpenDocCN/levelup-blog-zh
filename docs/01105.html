<html>
<head>
<title>A Simple 3D Engine in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振中的简单三维发动机</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-simple-3d-engine-in-flutter-cc4a7edc943e?source=collection_archive---------1-----------------------#2019-11-10">https://levelup.gitconnected.com/a-simple-3d-engine-in-flutter-cc4a7edc943e?source=collection_archive---------1-----------------------#2019-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于无法访问GPU，我们将不得不用这种老办法。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/04139eb289430777aa6defbff0c369aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8RrCvVOxrOfFztdxS2siyQ.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">一个简单的大脑3D模型，在颤动中渲染</figcaption></figure><p id="e15c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">80年代末90年代初，我第一次在雅达利st上学习编程。当时，我们没有像OpenGL或Metal这样的框架；没有<em class="kx">“接近直接访问图形处理单元。”</em>所以，就像我们的前辈一样，我们用数学从零开始，艰难地制造了3D引擎。</p><p id="f9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然Flutter使用OpenGL来呈现其小部件，但它并没有为我们提供访问底层硬件的API。如果我们不能使用GPU，我们将不得不在CPU上进行计算。</p><p id="32f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个CPU渲染器不会很快，但它简单易懂，易于构建，仍然可以用于一些有趣的效果。</p><p id="ed65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始吧。</p><h2 id="fee5" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">首先，我们需要一个3D模型</h2><p id="b83f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">虽然3D数据有<em class="kx">多</em>种文件格式，但最简单的可能是<a class="ae lw" href="https://en.wikipedia.org/wiki/Wavefront_.obj_file" rel="noopener ugc nofollow" target="_blank">波前对象格式</a>。它包含；一个点列表，一个面列表，以及一些对颜色和纹理的引用，所有这些都是人类可读的文本。</p><p id="3681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将包含一个对象(。obj)和材料(。mtl)文件，然后我们使用<a class="ae lw" href="https://flutter.dev/docs/development/ui/assets-and-images#loading-text-assets" rel="noopener ugc nofollow" target="_blank"> Flutter的全局根包</a>将它们作为字符串加载。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">使用Flutter的全局根包加载资源</figcaption></figure><p id="9c94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们有了字符串，我们将把它们解析成对象。结果是3D空间中的点列表和引用这些点的三角形列表。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">解析波前。OBJ文件</figcaption></figure><h2 id="37aa" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">现在我们需要一些数学知识</h2><p id="b9b0" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们已经有了模型。现在我们需要旋转、缩放和变换它。互联网上有很多关于3D图形的教程，我不会在这里面面俱到，但基本内容是这样的:</p><p id="c64c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们模型中的每一个点，我们围绕它的原点旋转、平移和缩放它。然后，我们根据人脸离相机的距离对它们进行分类，并从距离最远的开始绘制。</p><p id="4851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在有状态小部件的<code class="fe lz ma mb mc b">paint()</code>方法中完成所有这些工作，该小部件扩展了<code class="fe lz ma mb mc b">CustomPainter()</code>类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">每一帧我们都重新绘制画布</figcaption></figure><p id="79c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里批判的称呼是<code class="fe lz ma mb mc b">_calcVertex()</code>；它是做大量数学运算的人。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">旋转、平移和缩放顶点</figcaption></figure><p id="89dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用一个4x4的矩阵来旋转、平移和缩放我们的顶点。除了一些光照计算，这个项目中所有的矢量数学都使用Dart <a class="ae lw" href="https://pub.dev/packages/vector_math" rel="noopener ugc nofollow" target="_blank">矢量数学库</a>。</p><h2 id="cbbc" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">我们准备好画我们的模型了</h2><p id="970a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们终于准备好了。对于每个面，我们计算光照，根据其亮度导出颜色值，并使用Dart的<code class="fe lz ma mb mc b">Path()</code>命令绘制面。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">在画布上渲染一个面</figcaption></figure><h2 id="b699" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">添加用户控件</h2><p id="12f5" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们最后的任务是允许用户旋转模型。Flutter通过其<code class="fe lz ma mb mc b">dragUpdateHandler</code>让这一切变得简单。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">使用Flutter的dragUpdateHandler拖动以旋转模型</figcaption></figure><h2 id="3629" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">最后的想法</h2><p id="1027" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这篇文章不是一个3D引擎的严肃尝试，更像是一个学习更多关于Flutter和Dart的练习。我在这里分享它，以回应一些论坛帖子的类似要求。</p><p id="cb78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到完整的代码:</p><div class="md me gp gr mf mg"><a href="https://github.com/RichardCubed/flutter_demo_3d" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">RichardCubed/flutter_demo_3d</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">有什么比快速3D引擎更好的学习框架的方法呢？这个项目是作为技术高峰的一部分而创建的…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">github.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu kr mg"/></div></div></a></div></div></div>    
</body>
</html>