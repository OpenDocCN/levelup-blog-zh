<html>
<head>
<title>Implement PiP mode in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中实现画中画模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-simple-steps-to-implement-picture-in-picture-mode-in-the-android-app-65b7ee09587d?source=collection_archive---------5-----------------------#2022-10-18">https://levelup.gitconnected.com/5-simple-steps-to-implement-picture-in-picture-mode-in-the-android-app-65b7ee09587d?source=collection_archive---------5-----------------------#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ec03" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过5个简单的步骤在Android上实现画中画模式</h2></div><p id="db1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> P </span>画中画(PiP)模式将android应用程序内容缩小到一个小的浮动窗口中，这样用户就可以在使用设备上的其他应用程序的同时，继续从PiP窗口中使用应用程序的内容</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/045c036900f30e2107221b7ea4a38c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VAfvoY_Eg2oPXjIZ"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">雅各布·欧文在<a class="ae ma" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="03e5" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">简要概述</h2><p id="0352" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">PiP利用Android 7.0中提供的多窗口API来提供固定的视频叠加窗口。画中画窗口出现在屏幕的最顶层，在系统选择的角落。查看下面的截图:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mz"><img src="../Images/f3751aa1715a3da8c2a15e8322f115db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxwI9bDmjpFObajm4n8_1w.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">资料来源:https://developer.android.com</figcaption></figure><h2 id="74f5" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">履行</h2><p id="e7a0" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">要为应用程序添加PiP支持，您需要在build.gradle文件中将<strong class="kh ir"> minSdk </strong>版本设置为<strong class="kh ir"> API 26 </strong>。我将PiP的实施分成了5个简单的步骤。让我们来看看下面这些:</p><h2 id="8059" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">1.为您的活动启用PiP支持</h2><p id="0446" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">通过在Manifest文件中将属性<code class="fe na nb nc nd b">android:supportsPictureInPicture</code>设置为<code class="fe na nb nc nd b">true</code>，为您的活动启用PiP支持。此外，指定您的活动处理布局配置更改，以便在发生PiP模式转换时您的活动不会重新启动。</p><pre class="ll lm ln lo gt ne nd nf ng aw nh bi"><span id="0178" class="mb mc iq nd b gy ni nj l nk nl">&lt;activity android:name="MainActivity"<br/>    android:supportsPictureInPicture="true"<br/>    android:configChanges=<br/>        "screenSize|smallestScreenSize|screenLayout|orientation"/&gt;</span></pre><h2 id="dd38" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">2.在活动中设置PictureInPictureParams值</h2><p id="d242" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated"><code class="fe na nb nc nd b">PictureInPictureParams</code>用于配置画中画窗口的各种属性，如纵横比、<code class="fe na nb nc nd b">sourceRectHint</code>、自定义动作等。然后我们可以使用<code class="fe na nb nc nd b">setPictureInPictureParams</code>方法将这些参数设置为活动</p><ul class=""><li id="aba2" class="nm nn iq kh b ki kj kl km ko no ks np kw nq la nr ns nt nu bi translated">使用<code class="fe na nb nc nd b">Rational</code>类设置自定义纵横比。参见下面的代码</li><li id="fa54" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated">当用户使用手势导航向上滑动到主屏幕时，使用<code class="fe na nb nc nd b">setAutoEnterEnabled</code>提供更平滑的PiP过渡。</li></ul><p id="7f88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意:</strong>当<code class="fe na nb nc nd b">setAutoEnterEnabled</code>使能时，不需要在<code class="fe na nb nc nd b">onUserLeaveHint</code>中显式调用<code class="fe na nb nc nd b">enterPictureInPictureMode</code>。还有，这个方法只有Android 12及以上版本才有</p><pre class="ll lm ln lo gt ne nd nf ng aw nh bi"><span id="1ec0" class="mb mc iq nd b gy ni nj l nk nl">val aspectRatio = Rational(16, 9)// Rational(1, 1) for square window<br/>setPictureInPictureParams(new PictureInPictureParams.Builder()<br/>    .setAspectRatio(aspectRatio)<br/>    .setAutoEnterEnabled(true)<br/>    .build());</span></pre><h2 id="3a7d" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">3.切换到画中画模式</h2><p id="8583" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">调用<code class="fe na nb nc nd b">enterPictureInPictureMode(android.app.PictureInPictureParams)</code>方法会将您的活动切换到画中画模式。此方法可以在单击按钮或任何其他类型的用户操作时调用。</p><p id="1f22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果希望您的活动切换到PiP模式，而不是进入后台，那么您可以覆盖方法<code class="fe na nb nc nd b">onUserLeaveHint()</code>,该方法在活动根据用户选择将要进入后台时被调用。</p><pre class="ll lm ln lo gt ne nd nf ng aw nh bi"><span id="c456" class="mb mc iq nd b gy ni nj l nk nl">override fun onUserLeaveHint() {<br/>    if (shouldShowPip()) {<br/>        enterPictureInPictureMode()<br/>    }<br/>}</span></pre><p id="0e28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意:<br/> </strong>根据我在测试中观察到的情况，<strong class="kh ir"> </strong> <code class="fe na nb nc nd b">onUserLeaveHint()</code>方法似乎有一点问题，因为它被调用，即使当活动由于一些系统对话框出现在它上面而进入暂停状态时</p><p id="77d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安卓文档说:</p><blockquote class="oa ob oc"><p id="df88" class="kf kg od kh b ki kj jr kk kl km ju kn oe kp kq kr of kt ku kv og kx ky kz la ij bi translated"><code class="fe na nb nc nd b">onUserLeaveHint()</code>只有当用户的动作导致活动即将在后台运行时才被调用。</p></blockquote><p id="8be4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要注意的关键是，只有当某个活动由于某些用户操作而将要在后台运行时，系统才应该调用该方法。但是即使我们触发了一些隐含的意图或者启动了一个应用程序选择器，它还是会被调用。所以需要一些额外的检查来忽略对<code class="fe na nb nc nd b">onUserLeaveHint()</code>方法的无效调用(如果有的话)</p><h2 id="c785" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">4.画中画切换时处理用户界面</h2><p id="1a83" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">当活动进入或退出画中画模式时，您可能希望修改应用程序的UI。为了实现这一点，我们可以覆盖活动或片段的<code class="fe na nb nc nd b">onPictureInPictureModeChanged(boolean, android.content.res.Configuration) </code>方法。我们可以检查应用程序的当前状态，如果它是在画中画或全屏，并做出用户界面的修改</p><pre class="ll lm ln lo gt ne nd nf ng aw nh bi"><span id="3ff9" class="mb mc iq nd b gy ni nj l nk nl">override fun onPictureInPictureModeChanged(isInPictureInPictureMode: Boolean, newConfig: Configuration) {<br/>    if (isInPictureInPictureMode) {<br/>      // Hide elements which are not needed in PiP<br/>    } else {<br/>        // Restore the full-screen UI.<br/>    }<br/>}</span></pre><h2 id="57db" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">5.在画中画窗口上添加自定控制</h2><p id="c31e" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated">PiP窗口可以显示用户可以与之交互的自定义控件。当应用程序处于画中画模式时，您可以使用<code class="fe na nb nc nd b">RemoteAction</code>设置用户可用的自定义操作列表</p><p id="b18b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">远程动作由以下属性定义:<br/> <strong class="kh ir"> —图标<br/> —标题<br/> —内容描述<br/> —待定意向</strong></p><p id="20f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是我们如何添加构建远程操作的示例:</p><pre class="ll lm ln lo gt ne nd nf ng aw nh bi"><span id="bdbe" class="mb mc iq nd b gy ni nj l nk nl">val remoteAction = RemoteAction(<br/>    Icon.createWithResource(context, R.drawable.icon),<br/>    "Previous", "Previous Song",<br/>    PendingIntent.getBroadcast(context, requestCode, Intent("com.myapp.customcotrol.action124"), PendingIntent.FLAG_IMMUTABLE))</span></pre><p id="2534" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以根据应用程序的当前状态动态更改控件。这意味着我们可以根据应用程序的业务逻辑隐藏或添加控件。为了实现这一点，我们可以用一组新的远程动作调用<code class="fe na nb nc nd b">setPictureInPictureParams</code></p><pre class="ll lm ln lo gt ne nd nf ng aw nh bi"><span id="848c" class="mb mc iq nd b gy ni nj l nk nl">val actions: ArrayList&lt;RemoteAction&gt; = ArrayList()<br/>actions.add(remoteAction)<br/>val params = PictureInPictureParams.Builder()<br/>    //Set the list of actions to the params<br/>    .setActions(actions)<br/>    .build()<br/>setPictureInPictureParams(<!-- -->params<!-- -->)</span></pre><p id="4b94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">处理点击自定义控件:</strong></p><p id="fb60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用户点击我们在PiP窗口添加的自定义控件时，Android系统将发送广播。这个广播将具有我们在上面的<code class="fe na nb nc nd b">RemoteAction</code>对象中添加的相同动作。</p><p id="3f20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了在用户点击自定义控件时获得回调，您必须注册一个BroadcastReceiver并检查您在<code class="fe na nb nc nd b">RemoteAction</code>实例中添加的动作</p><p id="74eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经涵盖了在android应用程序中实现PiP模式的所有方面。此外，请查看下面列出的最佳实践和要点</p><h2 id="ab39" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">要注意的要点和要遵循的最佳实践</h2><ol class=""><li id="516c" class="nm nn iq kh b ki mu kl mv ko oh ks oi kw oj la ok ns nt nu bi translated">在您的应用程序使用PiP之前，请通过调用<code class="fe na nb nc nd b">hasSystemFeature(PackageManager.FEATURE_PICTURE_IN_PICTURE)</code>来检查以确保它可用</li><li id="1726" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la ok ns nt nu bi translated">Android 12增加了<code class="fe na nb nc nd b">setSeamlessResizeEnabled</code>标志，当调整PiP窗口中非视频内容的大小时，它提供了更加平滑的交叉渐变动画。以前，在PiP窗口中调整非视频内容的大小会产生不和谐的视觉假象。<br/>为了向后兼容，默认情况下<code class="fe na nb nc nd b">setSeamlessResizeEnabled</code>标志被设置为<code class="fe na nb nc nd b">true</code>。对于视频内容，将此设置保留为<code class="fe na nb nc nd b">true</code>，对于非视频内容，将其更改为<code class="fe na nb nc nd b">false</code>。</li><li id="5433" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la ok ns nt nu bi translated">画中画窗口上的自定义控件总是以白色背景显示。使用不同颜色的图标不会有任何效果</li></ol><p id="4cce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个如何在Android中实现画中画模式的简要总结，因为你已经到达了页面的底部，不要忘记点击拍手图标</p><h2 id="f77e" class="mb mc iq bd md me mf dn mg mh mi dp mj ko mk ml mm ks mn mo mp kw mq mr ms mt bi translated">参考资料:</h2><p id="b80c" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko mw kq kr ks mx ku kv kw my ky kz la ij bi translated"><a class="ae ma" href="https://developer.android.com/develop/ui/views/picture-in-picture#declaring" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/develop/ui/views/画中画</a></p></div></div>    
</body>
</html>