<html>
<head>
<title>Create a Chat Application in Golang with Redis and ReactJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Redis和ReactJS创建一个Golang聊天应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-a-chat-application-in-golang-with-redis-and-reactjs-c75611717f84?source=collection_archive---------2-----------------------#2022-11-11">https://levelup.gitconnected.com/create-a-chat-application-in-golang-with-redis-and-reactjs-c75611717f84?source=collection_archive---------2-----------------------#2022-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a4df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Golang中功能丰富的聊天应用程序，使用Redis作为完整的解决方案。Redis用于存储所有用户数据、聊天、联系人列表和许多其他内容。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5fd438cf9bbac00e7071911fdeb46ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCApZ6b5j3odv-c8NVYcbQ.png"/></div></div></figure><p id="1020" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">聊天应用的名字是<strong class="jp ir"> Kayee。</strong>这是你在贾巴尔普尔市听到的俚语，意思是发生了什么事！</p><h1 id="8fa2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="01a5" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在本教程中，您将在Golang中创建一个聊天应用程序，Redis作为数据库层，ReactJS与Chakra UI一起作为前端。</p><p id="2b75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们了解一下您将在这个应用程序中构建什么。</p><ol class=""><li id="a9af" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir"> Redis存储库:</strong>简单存储库管理所有Redis操作。</li><li id="94c8" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir"> HTTP服务器:</strong>一个REST API服务器，提供特定于用户的功能，比如注册和登录。</li><li id="1c44" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir"> WebSocket服务器:</strong>即时反应变化的实时服务器。</li><li id="3d6d" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">前端(客户端):</strong>一个带有Chakra UI组件的ReactJS应用程序。</li></ol><h2 id="5cd9" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">聊天功能</h2><ol class=""><li id="383a" class="ma mb iq jp b jq lv ju lw jy na kc nb kg nc kk mf mg mh mi bi translated">一对一的聊天</li><li id="c0c9" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">注册用户</li><li id="3042" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">登录用户</li><li id="8918" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">添加联系人</li><li id="96a3" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">联系人列表</li></ol><p id="7d15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用的Redis堆栈</strong></p><ol class=""><li id="1940" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">设置</li><li id="69d4" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">排序集合</li><li id="20a0" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">雷迪森</li><li id="a7c0" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">再研究</li></ol></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><blockquote class="nm"><p id="d60e" class="nn no iq bd np nq nr ns nt nu nv kk dk translated">您可以在文章末尾找到完整的GitHub项目链接。</p></blockquote></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="8905" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated">体系结构</h1><p id="cdfa" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">用户将使用HTTP服务器注册并登录聊天应用程序。实时消息将通过WebSocket服务器发送并保存到Redis。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ob"><img src="../Images/88a7a4509444fadbf71ef07e74e38ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJwh3fjE-98Fl-Dy98NeMg.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated"><strong class="bd kz">基础架构</strong></figcaption></figure><p id="203c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">WebSocket流程图:用户1和用户2之间的活动连接将是活动的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi og"><img src="../Images/88c431167aef15966b4005accfa3cec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oeMFPLGyg7pRrumQ8sD7sw.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">Websocket流程图</figcaption></figure><h2 id="6d75" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">特征的数据结构</h2><p id="357f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在这个应用程序中，有两个域，用户和聊天。所有的功能都围绕着它。Redis提供了广泛的数据类型，通过Redis Stack，它现在支持复杂的数据类型，如JSON，以及Redisearch等功能，在Redisearch中，您可以查询JSON和Hashes数据类型。</p><p id="1df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是每个域使用的Redis堆栈:</p><ol class=""><li id="2116" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir">用户:</strong> RedisJSON，SET，SortedSET，Key-Value对(功能:注册，登录，验证联系人，联系人列表)</li><li id="b931" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">聊天:</strong> RedisJSON，Redisearch(功能:新聊天，聊天记录)</li></ol></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="946e" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated">先决条件</h1><p id="b7f4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在开始开发工作之前，请确保您已经安装了以下先决条件:</p><ol class=""><li id="1323" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir"> Golang编译器v1.17以上</strong>(我用的是v1.17.11) <a class="ae oh" href="https://go.dev/dl/" rel="noopener ugc nofollow" target="_blank">下载链接</a></li><li id="3be7" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir"> Nodejs v16.13或以上</strong>(我用的是v 16 . 13 . 2)ReactJS需要。<a class="ae oh" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">下载链接</a></li><li id="099f" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">安装Redis CLI </strong>(我用的是v7.0.4) <a class="ae oh" href="https://redis.io/docs/getting-started/installation/" rel="noopener ugc nofollow" target="_blank">下载链接</a></li><li id="f98a" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir"> Redis云账号</strong> <a class="ae oh" href="https://redis.com/try-free/" rel="noopener ugc nofollow" target="_blank">链接</a> Redis云是Redis提供的云服务。创建一个免费账户，不需要信用卡。默认情况下，Redis Cloud中所有类似RedisJSON和Redisearch的模块都是可用的。我们将使用<code class="fe oi oj ok ol b">redis-cli</code>连接Redis Cloud。</li></ol><blockquote class="om on oo"><p id="6906" class="jn jo op jp b jq jr js jt ju jv jw jx oq jz ka kb or kd ke kf os kh ki kj kk ij bi translated"><strong class="jp ir"> Redis Stack是Redis的扩展，增加了现代数据模型和处理引擎，以提供完整的开发人员体验。</strong>支持redis的所有redis特性，支持可查询的JSON文档、全文搜索、时序数据(摄取&amp;查询)、图形数据、概率数据结构。<br/> RedisJSON、Redisearch和other是Redis栈的模块。您必须单独安装这些模块才能使用它。它不包含在redis-cli中。</p></blockquote><h2 id="691f" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">Redis云帐户设置</h2><p id="8f38" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在Redis Cloud中创建一个帐户，并使用免费订阅设置一个<strong class="jp ir"> Redis Stack </strong>类型的DB。在免费订阅下，你将免费获得30MB的数据存储空间。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ot"><img src="../Images/a55c57eacf5a338d59dacbab093aa159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uP-a0PVaDhQ28zZis4tNCw.png"/></div></div></figure><p id="3907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择DB，并在配置下找到公共端点。这个公共端点是您可以用来连接到Redis云的端点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ou"><img src="../Images/02345e2ee7380596e4bf6a7448919008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCUB-TJ-7C9ItB8DN2CVoQ.png"/></div></div></figure><p id="91c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向下滚动到安全部分。连接到此数据库实例需要此用户口令。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ov"><img src="../Images/3888507b25284c1fe9292cfd98926ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeJ9Xv3_q8DPz8_-O4pNZQ.png"/></div></div></figure><p id="73ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制此端点和密码。这是下一节需要的。</p><blockquote class="om on oo"><p id="e96a" class="jn jo op jp b jq jr js jt ju jv jw jx oq jz ka kb or kd ke kf os kh ki kj kk ij bi translated">这些凭据不再有效。</p></blockquote></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="dcdb" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated">项目结构</h1><p id="2c44" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们将保持项目结构简单。创建一个新目录<code class="fe oi oj ok ol b">gochatapp</code>。</p><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="d622" class="mo ky iq ol b gy pa pb l pc pd"><strong class="ol ir">gochatapp</strong><br/><strong class="ol ir">|- client </strong>// react application<strong class="ol ir"><br/>|- model  </strong>// schema<strong class="ol ir"><br/>  |- chat.go <br/>|- pkg    </strong>// business logic<strong class="ol ir"><br/>  |- httpserver<br/>    |- chathandler.go<br/>    |- httpserver.go<br/>  |- redisrepo </strong>// data base layer<strong class="ol ir"><br/>    |- client.go<br/>    |- deserialise.go<br/>    |- key.go<br/>    |- redismethod.go<br/>  |- ws  </strong>// websocket<strong class="ol ir"><br/>    |- websocket.go<br/>|- .env<br/>|- main.go</strong></span></pre><ul class=""><li id="fdeb" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated"><strong class="jp ir">客户:</strong> ReactJS申请。我们将在ReactJS部分展开<code class="fe oi oj ok ol b">client</code>目录。</li><li id="4efe" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">模型:</strong>聊天和用户模式</li><li id="d48b" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir"> pkg: </strong> httpserver、redisrepo、ws(WebSocket)会控制应用的业务逻辑。</li><li id="528a" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">。env: </strong> Redis凭证</li><li id="b21e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir"> main.go: </strong>应用入口点</li></ul><h2 id="24da" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">项目设置</h2><p id="9b58" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">打开<code class="fe oi oj ok ol b">gochatapp</code>目录下的CLI。您将首先启动一个go模块并安装所有的依赖项。</p><p id="25c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">初始化</strong></p><p id="b156" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将创建两个文件，<code class="fe oi oj ok ol b">go.mod</code>和<code class="fe oi oj ok ol b">go.sum</code>来保存所有的依赖引用和它们使用的版本。</p><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="feb6" class="mo ky iq ol b gy pa pb l pc pd">go mod init gochatapp</span></pre><p id="6dd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安装第三方库</strong></p><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="b53d" class="mo ky iq ol b gy pa pb l pc pd">go get github.com/gorilla/mux</span><span id="8a5f" class="mo ky iq ol b gy pf pb l pc pd">go get github.com/gorilla/websocket</span><span id="3736" class="mo ky iq ol b gy pf pb l pc pd">go get github.com/joho/godotenv</span><span id="901f" class="mo ky iq ol b gy pf pb l pc pd">go get github.com/rs/cors</span><span id="5644" class="mo ky iq ol b gy pf pb l pc pd">go get github.com/go-redis/redis/v8</span></pre><p id="5216" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe oi oj ok ol b">mux</code>用于HTTP服务器，<code class="fe oi oj ok ol b">websocket</code>用于WebSocket，<code class="fe oi oj ok ol b">godotenv</code>用于读取<code class="fe oi oj ok ol b">.env</code>，<code class="fe oi oj ok ol b">cors</code>用于解决CORS问题，<code class="fe oi oj ok ol b">redis</code>用于连接Redis。</p><p id="28fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望您已经创建了项目目录结构并安装了所有的依赖项。</p><p id="eeb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在VS代码编辑器或任何您喜欢的编辑器中打开项目。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="a6b9" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated">模型</h1><p id="5fbe" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">打开<code class="fe oi oj ok ol b">model/chat.go</code>粘贴以下内容。我们使用了两种模式<strong class="jp ir">聊天</strong>和<strong class="jp ir">联系人列表</strong>。</p><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="29b5" class="mo ky iq ol b gy pa pb l pc pd">package model</span><span id="c322" class="mo ky iq ol b gy pf pb l pc pd">type Chat struct {<br/>  ID        string `json:"id"`<br/>  From      string `json:"from"`<br/>  To        string `json:"to"`<br/>  Msg       string `json:"message"`<br/>  Timestamp int64  `json:"timestamp"`<br/>}</span><span id="0d7b" class="mo ky iq ol b gy pf pb l pc pd">type ContactList struct {<br/>  Username     string `json:"username"`<br/>  LastActivity int64  `json:"last_activity"`<br/>}</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><blockquote class="nm"><p id="c1b2" class="nn no iq bd np nq pg ph pi pj pk kk dk translated">注意:我对各个<code class="fe oi oj ok ol b">pkg</code>的所有文件使用一个gist文件。因为在介质中很难进行代码格式化。我首先解释文件内容，然后嵌入要点。提示:使用两个窗口，在第一个窗口阅读文件描述，在第二个窗口保持要点开放供参考。</p></blockquote></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="08cb" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated">Redis操作</h1><p id="017d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">让我们首先创建所有需要的Redis操作。</p><p id="cca6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<code class="fe oi oj ok ol b">.env</code>文件，配置Redis云公共端点和密码。</p><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="0cac" class="mo ky iq ol b gy pa pb l pc pd"># Paste public endpoint as it is with port<br/>REDIS_CONNECTION_STRING=public_endpoint</span><span id="3f17" class="mo ky iq ol b gy pf pb l pc pd"># Paste password from Security Section<br/>REDIS_PASSWORD=user_default_password</span></pre><h2 id="cd08" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">client.go</h2><p id="f104" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><code class="fe oi oj ok ol b">InitialiseRedis</code>将连接到Redis实例，并将连接客户端保存在<code class="fe oi oj ok ol b">redisClient</code>全局变量中。</p><h2 id="8429" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">钥匙，去吧</h2><p id="8cea" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">理想的做法是创建函数来返回Redis键，而不是在使用它们时对它们进行硬编码或格式化。它增加了使用错误密钥的可能性。</p><p id="2033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe oi oj ok ol b">key.go</code>文件中，我们将创建返回Redis键的函数。</p><p id="823a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，<code class="fe oi oj ok ol b">chatKey</code>函数为每条聊天消息生成一个唯一的密钥。<code class="fe oi oj ok ol b">chat#1661360942123</code></p><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="df08" class="mo ky iq ol b gy pa pb l pc pd">func chatKey() string {<br/>  return fmt.Sprintf("chat#%d", time.Now().UnixMilli())<br/>}</span></pre><h2 id="8685" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">redismethod.go</h2><ul class=""><li id="c789" class="ma mb iq jp b jq lv ju lw jy na kc nb kg nc kk pe mg mh mi bi translated"><strong class="jp ir"> RegisterNewUser: </strong>对于唯一用户，我们使用<strong class="jp ir"> SET </strong>数据类型。SET只存储唯一的值。如果该项目已经存在于集合中，它将返回一个错误。这个函数首先将<code class="fe oi oj ok ol b">username</code>和<code class="fe oi oj ok ol b">password</code>保存为一个键值对。接下来，它使用<code class="fe oi oj ok ol b">SADD</code>命令将用户名保存在集合中。如果在将它保存到SET中时发生了错误，那么它将返回一个错误并删除键-值对。我们在API级别检查用户是否存在。</li><li id="f78d" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">isuserrexist:</strong>验证用户名是否存在。它使用<code class="fe oi oj ok ol b">SISMEMBER</code>命令检查集合中的用户名。</li><li id="3172" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">isuseauthentic:</strong>验证所提供的用户名和密码是否正确。</li><li id="42f4" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir"> UpdateContactList: </strong>为了保存联系人列表，我们使用了<strong class="jp ir"> SORTEDSET </strong>数据类型。如果不存在，此函数添加或用更新的时间戳更新联系人。该时间戳是用户与联系人交互的标识符。当联系人向用户发送消息时，它将双向工作，反之亦然。</li><li id="19d1" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir"> CreateChat: </strong>首先会调用<code class="fe oi oj ok ol b">chatKey</code>函数生成聊天密钥。为了简单起见，我们使用以毫秒为单位的<code class="fe oi oj ok ol b">chat#&lt;millisecond timestamp&gt;</code>时间戳作为唯一的id。接下来，将聊天结构转换为[]字节，以字符串格式保存。然后，使用<code class="fe oi oj ok ol b">JSON.SET</code>命令，将JSON保存在Redis中。以下示例解释了语法以及如何在不同级别保存数据。如果它是嵌套的JSON，并且您想在第一级保存，请使用<code class="fe oi oj ok ol b">$.</code>。每升一级增加<code class="fe oi oj ok ol b">.</code>。一旦聊天被保存，它将更新发件人和收件人的联系人列表。</li></ul><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="a84a" class="mo ky iq ol b gy pa pb l pc pd">Syntax<br/><strong class="ol ir">JSON.SET key root-path($) json-in-string-format</strong></span><span id="67f1" class="mo ky iq ol b gy pf pb l pc pd">($)Root Level {</span><span id="59f0" class="mo ky iq ol b gy pf pb l pc pd">  ($.)First Level {</span><span id="dcfa" class="mo ky iq ol b gy pf pb l pc pd">    ($..) Second Level {<br/>     } <br/>  }<br/>}<br/></span></pre><ul class=""><li id="16ca" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated"><strong class="jp ir">createfetchchatweenindex:</strong>要使用Redisearch，首先，我们必须创建一个<strong class="jp ir">索引</strong>，它将用于理解数据集中的查询和搜索。<code class="fe oi oj ok ol b">FT.CREATE</code>命令将创建一个索引。接下来是索引键<code class="fe oi oj ok ol b">idx#chats</code>。Redisearch支持<strong class="jp ir">hash</strong>和<strong class="jp ir">redi dison</strong>，所以你必须提到这个索引将创建的数据类型<code class="fe oi oj ok ol b">ON JSON</code>。<code class="fe oi oj ok ol b">PREFIX 1 chat#</code>这个前缀键要考虑<code class="fe oi oj ok ol b">chat#</code>是键而<code class="fe oi oj ok ol b">1</code>是前缀的个数。<code class="fe oi oj ok ol b">SCHEMA</code>定义索引哪个字段。<code class="fe oi oj ok ol b">$.from AS from TAG</code> $。来自第一级字段<code class="fe oi oj ok ol b">AS from</code>是<code class="fe oi oj ok ol b">$.from</code>的别名，<strong class="jp ir">标签</strong>是重搜索查询语言的数据类型。当你想要精确匹配时，使用标签。同样，<strong class="jp ir">数字</strong>是数值。要对索引字段进行排序，我们必须使用<strong class="jp ir"> SORTABLE </strong>关键字使其可排序。</li><li id="0e69" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">获取聊天记录:</strong>这个函数将获取两个用户之间的聊天记录。为此，我们使用<a class="ae oh" href="https://redis.io/docs/stack/search/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">再搜索</strong> </a> <strong class="jp ir"> </strong>模块。将此数据集视为NoSQL，像任何其他NoSQL数据库一样，使用基本查询，我们可以从数据集中提取数据。我们需要用户1发送给用户2的聊天记录，反之亦然。所以，在这种情况下，两者都可以是from和to。<strong class="jp ir"> Deserialise </strong>将Redis输出转换为Golang地图，而<strong class="jp ir"> DeserialiseChat </strong>将其转换为Chat结构，稍后将详细介绍。</li></ul><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="a882" class="mo ky iq ol b gy pa pb l pc pd">Syntax: <strong class="ol ir">FT.SEARCH index query<br/>FT.SEARCH idx#chats '@from:{user2|user1} @to:{user1|user2} @timestamp:[0 +inf] SORTBY timestamp DESC'</strong></span><span id="a143" class="mo ky iq ol b gy pf pb l pc pd">Query Explanation: All @ are in AND<br/><strong class="ol ir">@from:{user2|user1} <br/> - @from: on field from<br/> - {}: curly bracket is used for TAG<br/> - user2|user1: user2 OR user1</strong></span><span id="0997" class="mo ky iq ol b gy pf pb l pc pd">Same for @to except user1 | user2</span><span id="b022" class="mo ky iq ol b gy pf pb l pc pd"><strong class="ol ir">@timestamp:[0 +inf] <br/> - []: sqaure bracket is used for Numeric<br/> - 0 +inf: zero to +infinity</strong></span><span id="3a9c" class="mo ky iq ol b gy pf pb l pc pd"><strong class="ol ir">SORTBY timestamp DESC - sort the timestamp in Descending</strong></span></pre><ul class=""><li id="758d" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated"><strong class="jp ir"> FetchContactList: </strong>获取登录用户的联系人列表。它包括发送给用户和由用户接收的所有消息。它将返回一个按联系人的最后活动排序的列表。SORTEDSET是一个数组，所以我们必须显式定义开始和结束索引。由于我们需要完整的列表，开始索引将是<strong class="jp ir"> 0，</strong>，结束索引将是<strong class="jp ir"> -1 </strong>。SortedSet按升序排序。要逆序获取联系人列表，请将<strong class="jp ir"> REV </strong>标志设置为true。最后，Redis输出将使用<strong class="jp ir"> DeserialiseContactList进行反序列化。</strong></li></ul><h2 id="9814" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">deserialise.go</h2><p id="0446" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这些函数将Redis响应转换为应用程序模式。</p><ul class=""><li id="7a02" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated"><strong class="jp ir"> Deserialise: </strong>这是一个特殊的功能，你甚至可以在其他使用Redisearch的应用程序中使用它。Redisearch返回一个接口，它是接口类型的数组。我们正在将这个响应转换成一个定制的<strong class="jp ir">文档</strong>结构。</li><li id="67f2" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir"> DeserialiseChat: </strong>该函数将<strong class="jp ir">文档</strong>转换为<strong class="jp ir">模型。Chat </strong>模式并返回一个model.Chat数组</li><li id="7498" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">DeserialiseContactList:</strong>sorted set返回成员和分数格式的数据。该函数会将其转换为model.ContactList。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pl nl l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="1c90" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated">HTTP服务器</h1><p id="1473" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">HTTP服务器将提供聊天应用程序的5个功能。</p><ol class=""><li id="2191" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated"><strong class="jp ir">注册:</strong>创建新用户</li><li id="917c" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">登录:</strong>使用用户名和密码登录用户</li><li id="1557" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">验证联系人:</strong>验证联系人是否存在</li><li id="4b4e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">聊天记录:</strong>获取两个用户之间的聊天记录</li><li id="2b52" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir">联系人列表:</strong>获取登录用户的联系人列表</li></ol><p id="10e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe oi oj ok ol b">chathandler.go</code>和<code class="fe oi oj ok ol b">httpserver.go</code>都是不言自明的。</p><p id="f8cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe oi oj ok ol b">httpserver.go</code>中，它将首先初始化Redis实例。之后，它会在索引之间创建一个获取聊天。稍后它将启动服务器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pl nl l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="d4f4" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated"><strong class="ak"> WebSocket服务器</strong></h1><p id="0925" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">WebSocket是一种运行在单一TCP连接上的通信协议。这是一个双向连接，这意味着服务器和客户端都可以发送和接收数据。不像HTTP，客户端可以请求，服务器可以发送响应。</p><p id="47b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">WebSocket连接作为HTTP连接启动，然后升级到TCP连接。</p><p id="ee58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦建立了WebSocket连接，它将一直处于活动状态，直到其中一方显式关闭它或者不再处于活动状态。</p><h2 id="00f0" class="mo ky iq bd kz mp mq dn ld mr ms dp lh jy mt mu ll kc mv mw lp kg mx my lt mz bi translated">websocket.go</h2><ul class=""><li id="5fe5" class="ma mb iq jp b jq lv ju lw jy na kc nb kg nc kk pe mg mh mi bi translated"><strong class="jp ir">客户端:</strong>客户端结构将存储用户的WebSocket连接地址和用户名。</li><li id="17d2" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">消息:</strong>消息结构将存储；消息的<code class="fe oi oj ok ol b">type</code>，<code class="fe oi oj ok ol b">user</code>是用户名，<code class="fe oi oj ok ol b">chat</code>是型号。这是从ReactJS应用程序收到的消息。就像有人给某人发信息一样。可以有两种消息类型；1.<code class="fe oi oj ok ol b">bootup</code>和2。其他的一切。当客户端第一次连接到WebSocket服务器时，这一次客户端发送<code class="fe oi oj ok ol b">type</code>作为带有<code class="fe oi oj ok ol b">username</code>的<code class="fe oi oj ok ol b">bootup</code>，以将连接映射到用户名。</li><li id="9025" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">客户端:</strong>这是一个存储所有连接到应用程序的客户端的映射。</li><li id="e818" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">广播:</strong>接收到客户端的消息后，将消息广播给所有<strong class="jp ir">连接的客户端的通道。</strong></li><li id="360e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">升级者:</strong> WebSocket升级配置。</li><li id="ad6a" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated">serveWs: 它是一个HTTP处理程序，将连接升级为TCP连接。成功升级后，它会将新客户端添加到<code class="fe oi oj ok ol b">clients</code>图中。稍后，它开始使用<code class="fe oi oj ok ol b">receiver</code>功能监听连接。一旦从<code class="fe oi oj ok ol b">receiver</code>函数中出来，就意味着连接断开，客户端不再活动。<code class="fe oi oj ok ol b">delete</code>功能将从<code class="fe oi oj ok ol b">clients</code>图中删除不活动的客户端。</li><li id="9e5b" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir"> receiver: </strong>它是一个无限<code class="fe oi oj ok ol b">for</code>循环，一直监听客户端的连接。当它接收到一个消息时，它检查它是否是一个<code class="fe oi oj ok ol b">bootup</code>消息。在消息中，它将客户端的连接映射到用户名。对于普通消息，它在Redis中创建一个聊天并广播它。以便它的接收用户可以在连接后立即收到消息。</li><li id="ae71" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir"> broadcaster: </strong>这是一个无限的<code class="fe oi oj ok ol b">for</code>循环，它一直监听<code class="fe oi oj ok ol b">broadcast</code>频道。在这里，broadcaster过滤消息中涉及的客户，如to和from，然后将消息发送给他们。如果广播公司将此消息发送给所有客户端，则<code class="fe oi oj ok ol b">clients</code>表现为一个组。在下一部分中，我们将实现群聊。</li><li id="fb82" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated">StartWebsocketServer: 它首先初始化Redis实例。它在一个单独的go例程中启动广播器，然后设置路由并启动WebSocket服务器。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pl nl l"/></div></figure><h1 id="cb72" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">App起点main.go</h1><p id="ec00" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">该应用程序有两个服务器，一个HTTP和一个WebSocket。我们使用基于标志的方法来启动服务器。有两个标志，<code class="fe oi oj ok ol b">http</code>和<code class="fe oi oj ok ol b">websocket</code>。</p><p id="843f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">命令将是；</p><pre class="km kn ko kp gt ow ol ox oy aw oz bi"><span id="dc2b" class="mo ky iq ol b gy pa pb l pc pd">// to start http server<br/>go run main.go --server=http</span><span id="aa68" class="mo ky iq ol b gy pf pb l pc pd">// to start websocket server<br/>go run main.go --server=websocket</span></pre><p id="6921" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以使用goroutines在一个命令中启动两个服务器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pl nl l"/></div></figure><h1 id="ddfa" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">客户端(ReactJS应用)</strong></h1><p id="23b4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">前端是使用<code class="fe oi oj ok ol b">create-react-app</code>项目和ChakraUI react组件创建的。</p><p id="277a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该项目使用的是<strong class="jp ir"> react-router-dom v6。</strong></p><p id="79ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用程序具有如下基本特性</p><ul class=""><li id="2cda" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated">带有注册和登录表单的登录页面。</li><li id="8877" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated">聊天页面有添加联系人、联系人列表和聊天历史组件。</li></ul><p id="214d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个文件的概述:</p><ul class=""><li id="0534" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated"><strong class="jp ir"> socket-connection.js: </strong>这里客户端连接到WebSocket连接。连接创建一个事件监听器，监听不同的事件，如<strong class="jp ir"> onopen </strong>表示连接成功建立，<strong class="jp ir"> onmessage </strong>表示收到新消息。<strong class="jp ir"> sendMsg </strong>函数将消息以字符串格式发送给WebSocket服务器。<strong class="jp ir"> mapConnection </strong>在连接上发送第一个启动类型消息。</li></ul><p id="e50d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释完整的ReactJS代码超出了本教程的范围。请按照下面的说明设置ReactJS应用程序并启动它。</p><ul class=""><li id="feb0" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated"><strong class="jp ir">步骤1: </strong>转到客户端文件夹，运行<code class="fe oi oj ok ol b">npm install</code>安装所有依赖项。</li><li id="d69a" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">第二步:</strong>运行<code class="fe oi oj ok ol b">npm start</code>启动应用程序。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pm"><img src="../Images/542872c84575b5b9b6bd3006881301a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Wow6lpYltiNLH040WBmYaQ.gif"/></div></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="5d23" class="kx ky iq bd kz la nw lc ld le nx lg lh li ny lk ll lm nz lo lp lq oa ls lt lu bi translated">结论</h1><p id="5911" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">请在<a class="ae oh" href="https://github.com/schadokar/go-chat-app" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的项目。创建这个应用程序是为了探索Redis的功能。这是一个教育项目，不要用于生产。</p><p id="b770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只用Redis创建这个应用程序对我来说是一个很好的体验。创建这样的架构和代码既有挑战性又很有趣。我希望你会像我一样喜欢创造它。</p><h1 id="ae12" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Redis命令词汇表</h1><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="pl nl l"/></div></figure><h1 id="a868" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">改进</h1><p id="47b8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">改进此应用程序的功能建议。</p><ul class=""><li id="c5ee" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated"><strong class="jp ir">会话管理:</strong>使用Redis TTL管理登录会话。生成JWT令牌来验证用户，并使用TTL将其保存在Redis中。</li><li id="8996" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">注销:</strong>用户注销。</li><li id="f24e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">聊天搜索:</strong>使用Redisearch在聊天中搜索。消息字段是文本类型。</li><li id="0827" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">块用户:</strong>在联系人列表结构中添加一个新参数作为块。</li><li id="df6d" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">输入:</strong>当另一个用户正在输入时，显示输入……为此使用WebSocket。</li><li id="773e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><strong class="jp ir">在线状态:</strong>通过WebSocket向客户端发送周期性的用户在线状态。在用户的联系人列表和客户地图上添加过滤器。</li></ul><p id="2918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会随着时间的推移不断更新这个建议，我会尝试给应用程序添加更多的功能。</p><p id="327c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><blockquote class="nm"><p id="cc59" class="nn no iq bd np nq pg ph pi pj pk kk dk translated"><a class="ae oh" href="https://github.com/schadokar/go-chat-app" rel="noopener ugc nofollow" target="_blank"> GitHub项目</a>链接</p></blockquote></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><blockquote class="nm"><p id="273b" class="nn no iq bd np nq pg ph pi pj pk kk dk translated">这篇文章是与Redis合作的。</p></blockquote><p id="feec" class="pw-post-body-paragraph jn jo iq jp b jq pn js jt ju po jw jx jy pp ka kb kc pq ke kf kg pr ki kj kk ij bi translated"><strong class="jp ir">了解详情:</strong></p><ul class=""><li id="cd85" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk pe mg mh mi bi translated"><a class="ae oh" href="https://redis.info/3NBGJRT" rel="noopener ugc nofollow" target="_blank">免费试用Redis云</a></li><li id="3ab5" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><a class="ae oh" href="https://redis.info/3LC4GqB" rel="noopener ugc nofollow" target="_blank"> Redis开发者中心——关于Redis的工具、指南和教程</a></li><li id="e627" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk pe mg mh mi bi translated"><a class="ae oh" href="https://redis.info/3wMR7PR" rel="noopener ugc nofollow" target="_blank"> RedisInsight桌面图形用户界面</a></li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div></div>    
</body>
</html>