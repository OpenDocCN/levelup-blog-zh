<html>
<head>
<title>Binary Serch in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的二进制搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/list-order-in-python-made-easy-e63d863f030f?source=collection_archive---------21-----------------------#2021-06-27">https://levelup.gitconnected.com/list-order-in-python-made-easy-e63d863f030f?source=collection_archive---------21-----------------------#2021-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="21a8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你不需要记住二分搜索法是如何工作的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/116fa01bc0bf054ea7f93dde32398942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7l5lHyZmg-Qwb9hp"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">安德烈·泰森在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1b7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我看到涉及排序列表的问题时，我总是很焦虑，因为我知道这将不可避免地涉及到使用二分搜索法。</p><p id="de1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种恐惧是完全不理智的，我总是为自己有这种感觉而自责，因为二分搜索法很美。给定一个排序列表，你可以在log(N)时间内找到任何值的索引，因为每次查找你都可以将搜索空间减半。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/4e85a24f3dfe7148a20b8a687832aded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c_1yOvINHAH4W333.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">【geeksforgeeks.org/binary-search T4】</figcaption></figure><p id="87f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">准确地说，这种操作使得排序列表在解决需要查找的问题以及确定有多少条目大于或小于目标值时在空间和时间上都非常高效。</p><p id="b80b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你想利用你的排序列表，你可能会想写你自己的二分搜索法并插入函数，就像我到目前为止所做的那样，不可避免地要尝试几次才能让它正常工作。谢天谢地，有一个内置的库已经做了同样的事情，只用一行代码就完成了，而且速度更快。</p><h1 id="b0dd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">把…分为两个部分</h1><p id="705e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">二分库很小，但它做了两件事，而且做得很好；<strong class="ky ir">搜索</strong>和<strong class="ky ir">插入</strong>。</p><p id="c28f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于搜索，我们有<strong class="ky ir">对分_左</strong>和<strong class="ky ir">对分_右</strong>，这两个函数<strong class="ky ir"> </strong>执行二分搜索法，以找到在我们的目标的右侧或左侧之前插入值的位置。在<strong class="ky ir">二等分_右</strong>的情况下，它将超出一个索引，以显示您应该在哪里插入新值来保持顺序。</p><p id="862e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">列表:[1，2，3，4，5]，目标= 4</p><blockquote class="mq mr ms"><p id="0454" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">平分_左:</em></strong><em class="iq">【1，2，3】</em><strong class="ky ir"><em class="iq">_</em></strong><em class="iq">，4，5】index = 3</em></p><p id="f6bd" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="iq">平分_右:</em></strong><em class="iq">【1，2，3，4】</em><em class="iq">_</em><em class="iq">，5】index = 3+1</em></p></blockquote><p id="c22f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于插入，我们有<strong class="ky ir"> insort_left </strong>和<strong class="ky ir"> insort_right </strong>，它们<strong class="ky ir"> </strong>执行二进制插入，在目标的左边或右边插入我们的值，并就地操作我们的列表。</p><blockquote class="mq mr ms"><p id="ce51" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir"><em class="iq">insort _ left:</em></strong><em class="iq">【1，2，3】 <strong class="ky ir"> <em class="iq"> 4 </em> </strong> <em class="iq">，4，5】插入索引= 3 </em></em></p><p id="598f" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir"><em class="iq">insort _ right:</em></strong><em class="iq">【1，2，3，4，</em> <strong class="ky ir"> <em class="iq"> 4 </em> </strong> <em class="iq">，5】插入索引= 3+1 </em></p></blockquote><p id="962e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<strong class="ky ir">二等分</strong>和<strong class="ky ir"> insort </strong>在功能上分别等同于<strong class="ky ir">二等分_右</strong>和<strong class="ky ir">insort _右</strong>中的<strong class="ky ir">、</strong>外，这些是该库中仅有的可用功能。然而，它们完全取代了为查找和插入编写自己的函数的需要。</p><h1 id="ccdc" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">平分很快</h1><p id="cc06" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">以下是我对二分搜索法的基本实现</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="69f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是它和平分之间的二元竞赛。我们将寻找值0，因为讽刺的是，它将花费最长的时间来寻找二分搜索法，因为0从不在任何事情中间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><blockquote class="mq mr ms"><p id="bd81" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">搜索在1.6927719116210938e-05秒内在索引0处找到0<br/>平分在2.6266701171875 e-06秒内在索引0处找到0</p></blockquote><p id="60b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们可以看到，二等分比我的实现快6倍</p><p id="0ff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为等分是在C中实现的，所以速度更快，尽管两个函数使用完全相同的算法。Python只是在数字加法上比C慢很多，因为Python中的所有数字实际上都是整数类，而整数类又需要时间来调用它们的加法函数，而在C中，整数只是4字节的数据类型，由CPU非常高效地处理。当您开始按顺序执行许多查找或插入时，时间上的差异会开始复合成性能上的显著提升。</p><h2 id="11f0" class="mz lu iq bd lv na nb dn lz nc nd dp md lf ne nf mf lj ng nh mh ln ni nj mj nk bi translated">结论</h2><p id="3b75" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">section是一个小而有用的库，它帮助维护列表中的排序顺序，并以快速有效的方式提供查找。知道它的存在可以节省实现和运行时间，对于很多编码面试来说，它是一个不可或缺的工具，因为关于排序列表的问题经常会出现。</p></div></div>    
</body>
</html>