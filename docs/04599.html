<html>
<head>
<title>9 Tips For Writing Safer Shell Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更安全的Shell脚本的9个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/9-tips-for-writing-safer-shell-scripts-b0c185da9bae?source=collection_archive---------13-----------------------#2020-07-05">https://levelup.gitconnected.com/9-tips-for-writing-safer-shell-scripts-b0c185da9bae?source=collection_archive---------13-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="59ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">改进和保护我们脚本的简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/527af3627d76db5db59a50d194d94ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nIiKlwZPLTlE7SpqbnsGng.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">奥斯卡·西尔万在<a class="ae ky" href="https://unsplash.com/s/photos/shells?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了WSL，Shell脚本是一个在所有平台上都可用的强大工具，甚至是Windows。但是很容易犯错误。这里有一些改善我们的脚本和避免许多问题的技巧。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2ed4" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">TABLE OF CONTENTS</strong></span><span id="5d6d" class="ma mb it lw b gy mg md l me mf">#1: <a class="ae ky" href="#379c" rel="noopener ugc nofollow">Better Shell Options</a><br/>#2: <a class="ae ky" href="#1cc6" rel="noopener ugc nofollow">It's a TRAP</a><br/>#3: <a class="ae ky" href="#9b7b" rel="noopener ugc nofollow">Check Requirements</a><br/>#4: <a class="ae ky" href="#2f63" rel="noopener ugc nofollow">Temporary Files &amp; Directories</a><br/>#5: <a class="ae ky" href="#729e" rel="noopener ugc nofollow">Quoting (almost) everything</a><br/>#6: <a class="ae ky" href="#3831" rel="noopener ugc nofollow">Linting with ShellCheck</a><br/>#7: <a class="ae ky" href="#751d" rel="noopener ugc nofollow">Doin' it in Style</a><br/>#8: <a class="ae ky" href="#610f" rel="noopener ugc nofollow">Targeting the Right Shell</a><br/>#9: <a class="ae ky" href="#cf97" rel="noopener ugc nofollow">Don't Use Shell Script</a></span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="379c" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#1:更好的外壳选项</h1><p id="21aa" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">所有shells都有可配置的选项，可用于启用行为。其中许多被认为比shell缺省值更安全。</p><h2 id="e551" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">出错时失败</h2><p id="c07a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一个绝对不需要动脑筋的选择是<code class="fe nv nw nx lw b">set -e</code>。</p><p id="ec58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用此选项，任何返回非零状态的命令都将退出整个脚本，并且不再执行任何命令。</p><p id="8798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，不管出现任何错误，shell脚本都会完全运行:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="271c" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu"><em class="ny">&lt;&lt; INPUT &gt;&gt;</em></strong></span><span id="461c" class="ma mb it lw b gy mg md l me mf">#!/usr/bin/env bash</span><span id="57a7" class="ma mb it lw b gy mg md l me mf"># Non-existing command<br/>non-existent<br/>echo "Will still be echoed"</span><span id="965d" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"><br/><em class="ny">&lt;&lt; OUTPUT &gt;&gt;</em></strong></span><span id="d42c" class="ma mb it lw b gy mg md l me mf">line 4: non-existent: command not found<br/>Will still be echoed</span></pre><p id="9a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过设置<code class="fe nv nw nx lw b">-e</code>我们可以防止<code class="fe nv nw nx lw b">echo</code>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1dc1" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu"><em class="ny">&lt;&lt; INPUT &gt;&gt;</em></strong></span><span id="b306" class="ma mb it lw b gy mg md l me mf">#!/usr/bin/env bash<br/>set -e</span><span id="83d5" class="ma mb it lw b gy mg md l me mf"># Non-existing command<br/>non-existent<br/>echo "Won't still be echoed"</span><span id="6c97" class="ma mb it lw b gy mg md l me mf"><br/><strong class="lw iu"><em class="ny">&lt;&lt; OUTPUT &gt;&gt;</em></strong></span><span id="38b7" class="ma mb it lw b gy mg md l me mf">line 5: non-existent: command not found</span></pre><p id="9289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使它实际上更有用，有一些例外:</p><ul class=""><li id="d9fd" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe nv nw nx lw b">||</code>命令列表:将对整个列表进行评估，如有必要，随后将失败:</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1164" class="ma mb it lw b gy mc md l me mf"># The command list will evaluate to true, so<br/># we can use set -e, and circumvent it, if necessary<br/>non-existent || true</span></pre><ul class=""><li id="9db1" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">测试条件允许失败，如<code class="fe nv nw nx lw b">if</code>、<code class="fe nv nw nx lw b">while</code>、<code class="fe nv nw nx lw b">until</code>:</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a3f4" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu"><em class="ny">&lt;&lt; INPUT &gt;&gt;</em></strong></span><span id="760e" class="ma mb it lw b gy mg md l me mf">if non-existent; then<br/>    echo "success"<br/>else<br/>    echo "failure"<br/>fi<br/>echo "after the failure"</span><span id="d956" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"><em class="ny">&lt;&lt; OUTPUT &gt;&gt;</em></strong></span><span id="d717" class="ma mb it lw b gy mg md l me mf">failure<br/>after the failure</span></pre><h2 id="a98d" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">未设置变量时失败</h2><p id="8305" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">再也不要被未设置的变量绊倒了！</p><p id="c008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe nv nw nx lw b">set -u</code>，脚本将使用一个未设置的变量退出:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6c1e" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&lt;&lt; INPUT &gt;&gt;</strong></span><span id="cf47" class="ma mb it lw b gy mg md l me mf">#!/usr/bin/env bash<br/>set -u</span><span id="6921" class="ma mb it lw b gy mg md l me mf"># Non-existing variable<br/>echo "${NOT_SET}"<br/>echo "Won't be echoed"</span><span id="4c9f" class="ma mb it lw b gy mg md l me mf"><br/><strong class="lw iu">&lt;&lt; OUTPUT &gt;&gt;</strong></span><span id="ece5" class="ma mb it lw b gy mg md l me mf">line 5: NOT_SET: unbound variable</span></pre><p id="1560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，规则也有一些例外:</p><ul class=""><li id="88f1" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">特殊参数<code class="fe nv nw nx lw b">@</code>和<code class="fe nv nw nx lw b">*</code>仍然允许。</li><li id="9791" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">可以设置默认值:</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="616f" class="ma mb it lw b gy mc md l me mf">ACTUAL_PATH=${MAYBE_SET_PATH:-~/home/$USER}</span></pre><p id="093d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，有一点需要注意。如果为空，则空数组被认为是未设置的。</p><h2 id="6954" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">更安全的管道</h2><p id="c4fd" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">默认情况下，管道的退出代码由最后一个命令确定，而不考虑任何先前的非零状态代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ee0f" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&lt;&lt; INPUT &gt;&gt;</strong></span><span id="fcfe" class="ma mb it lw b gy mg md l me mf">#!/usr/bin/env bash</span><span id="960a" class="ma mb it lw b gy mg md l me mf">non-existent | echo -e "last command"<br/>echo $?</span><span id="e64e" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"><br/>&lt;&lt; OUTPUT &gt;&gt;</strong></span><span id="7be1" class="ma mb it lw b gy mg md l me mf">last command<br/>bash: non-existent: command not found<br/>0</span></pre><p id="4bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nv nw nx lw b">set -o pipefail</code>，如果所有部件都成功退出，管道仅返回零状态。</p><p id="9c22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不会影响管道的所有部分都将被执行。但是现在我们可以用管道来使用<code class="fe nv nw nx lw b">set -e</code>。</p><h2 id="d646" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">最好是空球</h2><p id="29f9" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">文件名扩展，又称<a class="ae ky" href="https://en.wikipedia.org/wiki/Glob_(programming)" rel="noopener ugc nofollow" target="_blank"><em class="ny"/></a>，可以是很多bug的根源。</p><p id="ed68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个特别的<em class="ny">有问题的</em>缺省是对<em class="ny">空扩展</em>的处理。</p><p id="e5c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果通过扩展glob没有找到文件，默认情况下，它将“按原样”(passglob)传递，而不是一个空变量:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4434" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&lt;&lt; INPUT &gt;&gt;</strong></span><span id="9c89" class="ma mb it lw b gy mg md l me mf">#!/usr/bin/env bash</span><span id="ff38" class="ma mb it lw b gy mg md l me mf">for f in *.log; do<br/>    echo "$f"<br/>done</span><span id="7e00" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&lt;&lt; OUTPUT if no log files found &gt;&gt;</strong></span><span id="5c3c" class="ma mb it lw b gy mg md l me mf">*.log</span></pre><p id="cdbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个行为可以被<code class="fe nv nw nx lw b">shopt -s nullglob</code>禁用，这在一些非bash shells中已经是默认的了:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a008" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&lt;&lt; INPUT &gt;&gt;</strong></span><span id="797b" class="ma mb it lw b gy mg md l me mf">#!/usr/bin/env bash</span><span id="1ee9" class="ma mb it lw b gy mg md l me mf">shopt -s nullglob</span><span id="66d9" class="ma mb it lw b gy mg md l me mf">for f in *.log; do<br/>    echo "$f"<br/>done</span><span id="ba90" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&lt;&lt; NO OUTPUT if no log files found &gt;&gt;</strong></span></pre><h2 id="5ca3" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">禁用全球绑定</h2><p id="65fe" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">选项<code class="fe nv nw nx lw b">set -f</code>完全禁用文件名扩展。如果我们的脚本不需要globing并防止任何意外的扩展，这是一个好主意。</p><h2 id="50ca" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">调试输出</h2><p id="399c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">选项<code class="fe nv nw nx lw b">set -x</code>启用跟踪模式，在实际执行之前将每个命令打印到<code class="fe nv nw nx lw b">stdout</code>。</p><p id="7033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，所有选项也可以从外部设置:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f201" class="ma mb it lw b gy mc md l me mf">bash -x my-script.sh</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="1cc6" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#2:这是个陷阱</h1><p id="ad3f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们的脚本通常不是无状态的，这就产生了某种清理的需要。尤其是在错误提前退出的情况下，我们需要一种得到通知的方式。</p><p id="0330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用内置的<code class="fe nv nw nx lw b">trap</code>功能，我们可以为特定的<a class="ae ky" href="https://man7.org/linux/man-pages/man7/signal.7.html" rel="noopener ugc nofollow" target="_blank">信号</a>注册要执行的命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a46c" class="ma mb it lw b gy mc md l me mf"># trap &lt;command&gt; &lt;signals&gt;</span></pre><p id="aa52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以直接使用函数或命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ab54" class="ma mb it lw b gy mc md l me mf">function cleanup() {<br/>    # ...<br/>}</span><span id="fa7f" class="ma mb it lw b gy mg md l me mf">trap cleanup EXIT</span><span id="54a7" class="ma mb it lw b gy mg md l me mf">trap 'rm command.lock' ERR</span></pre><p id="ed3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过使用<code class="fe nv nw nx lw b">$LINENO</code>来改进错误处理，从而真正知道问题出在哪里。</p><h2 id="523b" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">资源</h2><ul class=""><li id="01c4" class="nz oa it lb b lc nf lf ng li on lm oo lq op lu oe of og oh bi translated"><a class="ae ky" href="https://www.linuxjournal.com/content/bash-trap-command" rel="noopener ugc nofollow" target="_blank">Bash Trap命令</a> (Linux日志)</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="9b7b" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#3:尽早检查需求</h1><p id="b16d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如果我们的脚本依赖于默认安装中通常找不到的外部程序，我们应该首先检查它们是否存在。或者我们在后来的脚本中遇到了问题:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1356" class="ma mb it lw b gy mc md l me mf"># from one of my internal scripts<br/>REQUIREMENTS=(jq ssh sed nc column)<br/>for APP in "${REQUIREMENTS[@]}"; do<br/>    command -v "$APP" &gt; /dev/null 2&gt;&amp;1<br/>    if [[ $? -ne 0 ]]; then<br/>      &gt;&amp;2 echo "Required '$APP' is not installed"<br/>      exit 1<br/>    fi<br/>done</span></pre><p id="09bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个小片段有助于确保所有需求都是可用的，或者在第一个不可用的命令出现时退出。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="2f63" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#4:临时文件和目录</h1><p id="729c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">需要临时文件的原因有很多:下载、原子操作等。</p><p id="8949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">临时文件或目录的随机名称是强制性的，否则我们可能会不小心覆盖某些内容。shell帮助我们使用<code class="fe nv nw nx lw b">mktemp</code>，在<code class="fe nv nw nx lw b">/tmp</code>中创建文件和目录:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3c9e" class="ma mb it lw b gy mc md l me mf"># Random filename<br/>mktemp</span><span id="608b" class="ma mb it lw b gy mg md l me mf"># Custom filename (X = random char)<br/>mktemp -t foo.XXXXXX</span><span id="b6a2" class="ma mb it lw b gy mg md l me mf"># Random directory<br/>mktemp -d</span><span id="1388" class="ma mb it lw b gy mg md l me mf"># Custom directory (X = random char)<br/>mktemp -d -t foo.XXXXXX</span></pre><p id="b2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令创建文件或目录，而不仅仅是返回一个随机的名称/路径。它有一个<code class="fe nv nw nx lw b">--dry-run / -u</code>选项，但被认为不安全。</p><p id="8b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有更多选项可以定制生成的文件名/路径，查看其<a class="ae ky" href="https://www.gnu.org/software/autogen/mktemp.html" rel="noopener ugc nofollow" target="_blank">手册页</a>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="729e" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#5:引用(几乎)所有内容</h1><p id="185b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">始终使用引号。引用太多总比引用不够好。</p><p id="ae02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所示，自动参数扩展可能是许多bug的来源。为了保留字符串的字面意义，我们需要引用它。</p><p id="d65c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个字符串包含空格或星号，它就是一个定时炸弹:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f808" class="ma mb it lw b gy mc md l me mf">FILENAME="This contains spaces"<br/>touch $FILENAME<br/># Creates 3 files:<br/># - This<br/># - contains<br/># - spaces</span></pre><p id="e388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在展开变量时引用变量，我们可以确保结果将作为单个参数传递:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e87e" class="ma mb it lw b gy mc md l me mf">FILENAME="This contains spaces"<br/>touch "$FILENAME"<br/># Creates 1 file:<br/># - This contains spaces</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3831" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#6:林挺与谢尔克斯</h1><p id="2398" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">很容易将我们的脚本与350种不同的规则进行对比！</p><p id="98a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.shellcheck.net/" rel="noopener ugc nofollow" target="_blank">https://www.shellcheck.net/</a></p><p id="cff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ee8e" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">&lt;&lt; INPUT &gt;&gt;</strong></span><span id="6fdf" class="ma mb it lw b gy mg md l me mf">#!/bin/sh<br/>## Example: a typical script with several problems<br/>for f in $(ls *.m3u); do<br/>    grep -qi hq.*mp3 $f \<br/>    &amp;&amp; echo -e 'Playlist $f contains a HQ file in mp3 format'<br/>done<br/></span><span id="e2f4" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">&lt;&lt; OUTPUT &gt;&gt;</strong></span><span id="a5a3" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">Line 3:</strong><br/>for f in $(ls *.m3u); do<br/>         <strong class="lw iu">^-- SC2045</strong>: Iterating over ls output is fragile. Use globs.<br/>              <strong class="lw iu">^-- SC2035</strong>: Use ./*glob* or -- *glob* so names with dashes won't become options.<br/> <br/><strong class="lw iu">Line 4:</strong><br/>  grep -qi hq.*mp3 $f \<br/>           <strong class="lw iu">^-- SC2062</strong>: Quote the grep pattern so the shell won't interpret it.<br/>                   <strong class="lw iu">^-- SC2086</strong>: Double quote to prevent globbing and word splitting.</span><span id="b6b6" class="ma mb it lw b gy mg md l me mf">Did you mean: (apply this, apply all SC2086)<br/>  grep -qi hq.*mp3 "$f" \<br/> <br/><strong class="lw iu">Line 5:</strong><br/>    &amp;&amp; echo -e 'Playlist $f contains a HQ file in mp3 format'<br/>            <strong class="lw iu">^-- SC2039</strong>: In POSIX sh, echo flags are undefined.<br/>               <strong class="lw iu">^-- SC2016</strong>: Expressions don't expand in single quotes, use double quotes for that.</span></pre><p id="eda7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ShellCheck突出显示了检测到的问题，向我们展示了到底是哪里出了问题，所以可以很容易地修复它。它可以在大多数Linux发行版的仓库中获得，也可以集成到许多编辑器中，比如<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=timonwong.shellcheck" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="751d" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#7:做得有格调</h1><p id="24ad" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/better-programming/habit-driven-development-and-finding-your-own-style-32786e1eb8c8" rel="noopener">我在</a>之前已经讨论过为我们的首选语言使用风格指南，以建立一个良好的基线。</p><p id="a2ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提到最多的shell脚本样式指南是Google的“<a class="ae ky" href="https://google.github.io/styleguide/shellguide.html" rel="noopener ugc nofollow" target="_blank"> Shell Style Guide </a>”。</p><p id="e2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个广泛的阅读，但值得。但是像往常一样，不要强求不适合的。例如，我强烈支持使用4个空格和大约110个空格的行长度。没有时尚指南会让我改变主意。但如果项目需要，我愿意适应。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="2c36" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#8:瞄准正确的外壳</h1><p id="ae18" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">有多种shells可供使用，有不同的选项。</p><p id="ddb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尤其是在容器时代，我们遇到一个成熟的bash shell已经不再是一件理所当然的事情。</p><p id="0400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我们应该努力选择正确的shell类型，而不要过于依赖特定于shell的行为。至少如果我们不能绝对确定我们正在哪个环境中运行。</p><blockquote class="oq or os"><p id="900c" class="kz la ny lb b lc ld ju le lf lg jx lh ot lj lk ll ou ln lo lp ov lr ls lt lu im bi translated"><a class="ae ky" href="https://www.howtogeek.com/68563/htg-explains-what-are-the-differences-between-linux-shells/" rel="noopener ugc nofollow" target="_blank">Bash、Zsh和其他Linux Shells有什么区别？</a>(如何极客)</p></blockquote><p id="400d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不确定，一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank"> <em class="ny"> shebang </em> </a>告诉正在执行的shell脚本应该如何运行:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="effd" class="ma mb it lw b gy mc md l me mf">#!/bin/bash</span></pre><p id="7225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe nv nw nx lw b">/bin</code>里没有<code class="fe nv nw nx lw b">bash</code>而是有<code class="fe nv nw nx lw b">/usr/bin</code>呢？我们可以利用<code class="fe nv nw nx lw b">env</code>通过返回<code class="fe nv nw nx lw b">$PATH</code>中的第一个事件来获得正确的位置:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b576" class="ma mb it lw b gy mc md l me mf">#!/usr/bin/env bash</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="cf97" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">#9:不要使用外壳脚本</h1><p id="f7a7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">作为开发人员的一个重要方面是了解语言和工具的局限性。不是所有东西都应该是shell脚本。许多高级语言一开始就提供了更安全、更简洁的环境。</p><p id="e73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了shebangs，我们可以在脚本中使用许多不同的语言，只要有合适的解释器:</p><ul class=""><li id="9189" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><a class="ae ky" href="https://kevingimbel.de/blog/2017/01/writing-nodejs-cli-tools/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a></li><li id="094e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://www.python.org/dev/peps/pep-0394/" rel="noopener ugc nofollow" target="_blank">巨蟒</a></li><li id="395e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://openjdk.java.net/jeps/330" rel="noopener ugc nofollow" target="_blank"> Java 11+ </a></li><li id="aa68" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://gist.github.com/posener/73ffd326d88483df6b1cb66e8ed1e0bd" rel="noopener ugc nofollow" target="_blank">戈朗</a></li><li id="352a" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="http://manpages.ubuntu.com/manpages/bionic/man1/lua-any.1.html" rel="noopener ugc nofollow" target="_blank"> Lua </a></li><li id="4489" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">还有更多，只需谷歌"<language> shebang "</language></li></ul><p id="0d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以一直使用“编译成单二进制”风格的语言，比如<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang </a>或<a class="ae ky" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>。它们还支持交叉编译，因此很容易不仅仅针对我们自己的平台。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="51ea" class="mo mb it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="e130" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Shell脚本非常棒。从自动化一个微小的任务，到像<a class="ae ky" href="https://github.com/aristocratos/bashtop" rel="noopener ugc nofollow" target="_blank"> bashtop </a>这样成熟的TUI应用，几乎一切皆有可能。</p><p id="6fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是与高级语言相比，语法有点不同寻常。错误很容易被引入，即使只是一个打字错误。</p><p id="25ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设置正确的选项和林挺我们的脚本将有助于首先避免问题的共同来源。它们易于使用并集成到我们的工作流中，不应该因为方便而被忽略，尤其是如果其他人不得不使用我们的脚本。</p><p id="782a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于更好的shell脚本，您最喜欢的技巧和诀窍是什么？</p><h2 id="64a4" class="ma mb it bd mp nk nl dn mt nm nn dp mx li no np mz lm nq nr nb lq ns nt nd nu bi translated">资源</h2><ul class=""><li id="7d4b" class="nz oa it lb b lc nf lf ng li on lm oo lq op lu oe of og oh bi translated"><a class="ae ky" href="https://www.gnu.org/software/bash/manual/bash.html" rel="noopener ugc nofollow" target="_blank"> Bash参考手册</a>(Gnu.org)</li><li id="9642" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md" rel="noopener ugc nofollow" target="_blank">bash中安全做事的方法</a></li><li id="0e7a" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://google.github.io/styleguide/shellguide.html" rel="noopener ugc nofollow" target="_blank">外壳风格指南</a>(谷歌)</li><li id="114b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><a class="ae ky" href="https://www.shellcheck.net/" rel="noopener ugc nofollow" target="_blank">外壳检查</a></li></ul></div></div>    
</body>
</html>