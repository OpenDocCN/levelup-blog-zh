<html>
<head>
<title>Build a GraphQL + React App with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建一个GraphQL + React应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-graphql-react-app-with-typescript-9661f908b26?source=collection_archive---------0-----------------------#2019-12-03">https://levelup.gitconnected.com/build-a-graphql-react-app-with-typescript-9661f908b26?source=collection_archive---------0-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2708" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用调用SpaceX GraphQL API的TypeScript从头开始创建React应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/442f02987f82a0f8252fe081374244d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FFDim9td9xU0fmcr"/></div></div></figure><p id="20c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GraphQL和TypeScript都在采用中爆炸了，当两者与React结合时，它们创造了理想的开发人员体验。</p><p id="1b97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GraphQL改变了我们对API的看法，并利用直观的键/值对匹配，客户端可以请求在网页或移动应用程序屏幕上显示所需的准确数据。TypeScript通过向变量添加静态类型来扩展JavaScript，从而导致更少的错误和更可读的代码。</p><p id="bf06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将带您通过React和Apollo构建一个客户端应用程序，使用公共的SpaceX GraphQL API来显示关于发射的信息。我们将为我们的查询自动生成TypeScript类型，并使用React钩子执行这些查询。</p><p id="f718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将假设您对React、GraphQL和TypeScript有所了解，并将重点放在集成它们以构建一个正常运行的应用程序上。</p><p id="1866" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你在任何一点卡住了，可以参考<a class="ae lq" href="https://github.com/treyhuffine/graphql-react-typescript-spacex" rel="noopener ugc nofollow" target="_blank">源代码</a>或者看<a class="ae lq" href="https://spacex-graphql.netlify.com/" rel="noopener ugc nofollow" target="_blank">直播app </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/50dc0c99d5c0e8c7a20424c995eb8252.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*mSjmWFa4YR4gl3lh"/></div></figure><h1 id="cd41" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">为什么是GraphQL + TypeScript？</h1><p id="80a4" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">GraphQL API需要是强类型的，并且数据是从单个端点提供的。通过在这个端点上调用GET请求，客户机可以接收一个完全自我记录的后端表示，其中包含所有可用的数据和相应的类型。</p><p id="f01e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<a class="ae lq" href="https://github.com/dotansimha/graphql-code-generator" rel="noopener ugc nofollow" target="_blank"> GraphQL代码生成器</a>，我们扫描web应用程序目录以查找查询文件，并将它们与GraphQL API提供的信息进行匹配，从而为所有请求数据创建类型脚本类型。通过使用GraphQL，我们可以免费自动输入React组件的属性。这导致你的产品更少的错误和更快的迭代速度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><p id="c0da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建和维护一份简历并不有趣。相反，让我们为你生成一份令人敬畏的简历:)<a class="ae lq" href="https://gitconnected.com/resume-builder" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">简历生成器&gt; </strong> </a></p><div class="mq mr gp gr ms mt"><a href="https://gitconnected.com/resume-builder" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">软件工程师简历生成器和示例| gitconnected</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">一份有价值的简历模板，使用您个人资料中的详细信息构建。从你的投资组合网站链接到你的简历或…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">gitconnected.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh ks mt"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h1 id="7266" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">入门指南</h1><p id="bfce" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们将使用create-react-app和TypeScript设置来引导我们的应用程序。通过执行以下命令初始化您的应用程序:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2acb" class="nn lt it nj b gy no np l nq nr">npx create-react-app graphql-typescript-react --template typescript<br/>// NOTE - you will need Node v8.10.0+ and NPM v5.2+</span></pre><p id="a71b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用<code class="fe ns nt nu nj b">--typescript</code>标志，CRA将生成您的文件和<code class="fe ns nt nu nj b">.ts</code>和<code class="fe ns nt nu nj b">.tsx</code>，并且它将创建一个<code class="fe ns nt nu nj b">tsconfig.json</code>文件。</p><p id="a8ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">导航到应用程序目录:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="d96b" class="nn lt it nj b gy no np l nq nr">cd graphql-typescript-react</span></pre><p id="b29d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以安装额外的依赖项了。我们的应用程序将使用Apollo来执行GraphQL API请求。阿波罗需要的附加库是<code class="fe ns nt nu nj b">@apollo/client</code>和<code class="fe ns nt nu nj b">graphql</code>。</p><p id="f0e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ns nt nu nj b">@apollo/client</code>包含在浏览器中运行GraphQL所需的工具。它允许我们查询API并将数据缓存在本地内存中，并构建我们的查询文档。<code class="fe ns nt nu nj b">graphql</code>是一个提供GraphQL实现细节的对等依赖。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="33c8" class="nn lt it nj b gy no np l nq nr">yarn add @apollo/client graphql</span></pre><p id="e7ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ns nt nu nj b">graphql-code-generator</code>用于自动化我们的打字稿工作流程。我们将安装codegen CLI来生成我们需要的配置和插件。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c55f" class="nn lt it nj b gy no np l nq nr">yarn add -D @graphql-codegen/cli</span></pre><p id="d3c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过执行以下命令来设置codegen配置:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0cd4" class="nn lt it nj b gy no np l nq nr">npx graphql-codegen init</span></pre><p id="d323" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将启动CLI向导。请执行以下步骤:</p><ol class=""><li id="624b" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">用React构建的应用程序。</li><li id="a0d4" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">该模式位于<code class="fe ns nt nu nj b"><a class="ae lq" href="https://spacexdata.herokuapp.com/graphql" rel="noopener ugc nofollow" target="_blank">https://spacexdata.herokuapp.com/graphql</a></code>。</li><li id="38fc" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">将您的操作和片段位置设置为<code class="fe ns nt nu nj b">./src/components/**/*</code>。<code class="fe ns nt nu nj b">{ts,tsx}</code>这样它将在我们所有的TypeScript文件中搜索查询声明。</li><li id="d336" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">使用默认插件“TypeScript”、“TypeScript Operations”、“TypeScript React Apollo”</li><li id="546a" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">使用目的地<code class="fe ns nt nu nj b">src/generated/graphql.tsx</code>(。react-apollo插件需要tsx)。</li><li id="94d8" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">不要生成自省文件。</li><li id="25b9" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">使用默认的<code class="fe ns nt nu nj b">codegen.yml</code>文件。</li><li id="2c7c" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">制作您的运行脚本<code class="fe ns nt nu nj b">codegen</code>。</li></ol><p id="9bce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，通过在CLI中运行<code class="fe ns nt nu nj b">yarn</code>命令，安装CLI工具添加到<code class="fe ns nt nu nj b">package.json</code>中的插件。</p><p id="8d55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还将对我们的<code class="fe ns nt nu nj b">codegen.yml</code>文件进行一次更新，这样它也可以通过添加<code class="fe ns nt nu nj b">withHooks: true</code>配置选项来生成类型化的React Hook查询。您的配置文件应该如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="5532" class="nn lt it nj b gy no np l nq nr">overwrite: true<br/>schema: 'https://spacexdata.herokuapp.com/graphql'<br/>documents: './src/components/**/*.ts'<br/>generates:<br/>  src/generated/graphql.tsx:<br/>    plugins:<br/>      - 'typescript'<br/>      - 'typescript-operations'<br/>      - 'typescript-react-apollo'<br/>    config:<br/>      withHooks: true</span></pre><h1 id="a33b" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">编写GraphQL查询和生成类型</h1><p id="433d" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">GraphQL的一个主要好处是它利用了声明性数据提取。我们能够编写与使用它们的组件共存的查询，并且UI能够准确地请求它需要呈现的内容。</p><p id="1c75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用REST APIs时，我们需要找到可能是最新的也可能不是最新的文档。如果REST有任何问题，我们将需要对API和控制台发出请求。</p><p id="d849" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">GraphQL解决了这个问题，它允许您访问URL，查看完整定义的模式，并对其执行请求，所有这些都在UI中完成。去https://spacexdata.herokuapp.com/graphql看看你将会处理哪些数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/150c9086ee83f943f8e2e6153835406f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NAfD0Undr8pKCN54"/></div></div></figure><p id="a5f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我们有大量的SpaceX数据可供我们使用，但我们只会显示有关发射的信息。我们将有两个主要组件:</p><ol class=""><li id="590c" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">用户可以点击<code class="fe ns nt nu nj b">launches</code>列表来了解更多信息。</li><li id="23e2" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">单个<code class="fe ns nt nu nj b">launch</code>的详细简介。</li></ol><p id="4012" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我们的第一个组件，我们将查询<code class="fe ns nt nu nj b">launches</code>键并请求<code class="fe ns nt nu nj b">flight_number</code>、<code class="fe ns nt nu nj b">mission_name</code>和<code class="fe ns nt nu nj b">launch_year</code>。我们将在一个列表中显示这些数据，当用户点击其中一个项目时，我们将通过<code class="fe ns nt nu nj b">launch</code>键查询该火箭的更多数据。让我们在GraphQL playground中测试我们的第一个查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/01b215d9d0c33b9169a146d6c5d97863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H_TGepTiPfq88_ND"/></div></div></figure><p id="70e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了编写我们的查询，我们首先创建一个<code class="fe ns nt nu nj b">src/components</code>文件夹，然后创建一个<code class="fe ns nt nu nj b">src/components/LaunchList</code>文件夹。在这个文件夹中，创建<code class="fe ns nt nu nj b">index.tsx</code>、<code class="fe ns nt nu nj b">LaunchList.tsx</code>、<code class="fe ns nt nu nj b">query.ts</code>和<code class="fe ns nt nu nj b">styles.css</code>文件。在<code class="fe ns nt nu nj b">query.ts</code>文件中，我们可以从操场传输查询，并将其放在一个<code class="fe ns nt nu nj b">gql</code>字符串中。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="603f" class="nn lt it nj b gy no np l nq nr">import { gql } from '<a class="ae lq" href="http://twitter.com/apollo/client" rel="noopener ugc nofollow" target="_blank">@apollo/client</a>';</span><span id="7ea5" class="nn lt it nj b gy ok np l nq nr">export const QUERY_LAUNCH_LIST = gql`<br/>  query LaunchList {<br/>    launches {<br/>      flight_number<br/>      mission_name<br/>      launch_year<br/>    }<br/>  }<br/>`;</span></pre><p id="5152" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的另一个查询将获得基于<code class="fe ns nt nu nj b">flight_number</code>的单次启动的更详细的数据。由于这将由用户交互动态生成，我们将需要使用<a class="ae lq" href="https://graphql.org/learn/queries/#variables" rel="noopener ugc nofollow" target="_blank"> GraphQL变量</a>。我们还可以在操场上用变量测试查询。</p><p id="43a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在查询名称旁边，指定变量，并在前面加上一个<code class="fe ns nt nu nj b">$</code>及其类型。然后，在主体内部，可以使用变量。对于我们的查询，我们通过向其传递类型为<code class="fe ns nt nu nj b">String!</code>的<code class="fe ns nt nu nj b">$id</code>变量来设置启动的<code class="fe ns nt nu nj b">id</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/f6fb2e3f588d52cb15f4453d2517df04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*97aG4oti42n3mInh"/></div></div></figure><p id="70c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将<code class="fe ns nt nu nj b">id</code>作为变量传入，它对应于来自<code class="fe ns nt nu nj b">LaunchList</code>查询的<code class="fe ns nt nu nj b">flight_number</code>。<code class="fe ns nt nu nj b">LaunchProfile</code>查询还将包含嵌套的对象/类型，我们可以通过指定括号内的键来获取值。</p><p id="0281" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，发布包含一个<code class="fe ns nt nu nj b">rocket</code>定义(类型<code class="fe ns nt nu nj b">LaunchRocket</code>),我们将要求<code class="fe ns nt nu nj b">rocket_name</code>和<code class="fe ns nt nu nj b">rocket_type</code>。为了更好地理解<code class="fe ns nt nu nj b">LaunchRocket</code>的可用字段，您可以使用旁边的模式导航器来理解可用数据。</p><p id="c659" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们将这个查询转移到我们的应用程序中。用<code class="fe ns nt nu nj b">index.tsx</code>、<code class="fe ns nt nu nj b">LaunchProfile.tsx</code>、<code class="fe ns nt nu nj b">query.ts</code>和<code class="fe ns nt nu nj b">styles.css</code>文件创建一个<code class="fe ns nt nu nj b">src/components/LaunchProfile</code>文件夹。在<code class="fe ns nt nu nj b">query.ts</code>文件中，我们粘贴来自操场的查询。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="259f" class="nn lt it nj b gy no np l nq nr">import { gql } from '@apollo/client';<br/><br/>export const QUERY_LAUNCH_PROFILE = gql`<br/>  query LaunchProfile($id: String!) {<br/>    launch(id: $id) {<br/>      flight_number<br/>      mission_name<br/>      launch_year<br/>      launch_success<br/>      details<br/>      launch_site {<br/>        site_name<br/>      }<br/>      rocket {<br/>        rocket_name<br/>        rocket_type<br/>      }<br/>      links {<br/>        flickr_images<br/>      }<br/>    }<br/>  }<br/>`;</span></pre><p id="13df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经定义了查询，您终于能够生成您的TypeScript接口和类型化挂钩了。在您的终端中，执行:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="71dd" class="nn lt it nj b gy no np l nq nr">yarn codegen</span></pre><p id="9714" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ns nt nu nj b">src/generated/graphql.ts</code>中，您将找到定义应用程序所需的所有类型，以及获取GraphQL端点以检索数据的相应查询。</p><p id="c460" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个文件往往很大，但其中充满了有价值的信息。我建议花点时间浏览一下，理解我们的codegen完全基于GraphQL模式创建的所有类型。</p><p id="2963" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，inspect <code class="fe ns nt nu nj b">type Launch</code>，它是GraphQL中<code class="fe ns nt nu nj b">Launch</code>对象的类型脚本表示，我们在操场上与它交互。还可以滚动到文件的底部，查看专门为我们将要执行的查询生成的代码——它已经创建了组件、hoc、类型化的props/query和类型化的hooks。</p><h1 id="fc29" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">初始化阿波罗客户端</h1><p id="cf3b" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在我们的<code class="fe ns nt nu nj b">src/index.tsx</code>中，我们需要初始化Apollo客户端，并使用<code class="fe ns nt nu nj b">ApolloProvider</code>组件添加我们的<code class="fe ns nt nu nj b">client</code>来反应的上下文。我们还需要<code class="fe ns nt nu nj b">ApolloProviderHooks</code>组件来启用钩子中的上下文。</p><p id="7e31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们初始化一个<code class="fe ns nt nu nj b">new ApolloClient</code>并给它我们的GraphQL API的URI，然后我们在上下文提供者中包装我们的<code class="fe ns nt nu nj b">&lt;App /&gt;</code>组件。您的索引文件应该如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="98ab" class="nn lt it nj b gy no np l nq nr">import * as React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import { ApolloClient, ApolloProvider, InMemoryCache } from '@apollo/client';<br/>import './index.css';<br/>import App from './App';<br/><br/>const client = new ApolloClient({<br/>  uri: 'https://spacexdata.herokuapp.com/graphql',<br/>  cache: new InMemoryCache(),<br/>});<br/><br/>ReactDOM.render(<br/>  &lt;ApolloProvider client={client}&gt;<br/>  &lt;App /&gt;  <br/>  &lt;/ApolloProvider&gt;,<br/>  document.getElementById('root'),<br/>);</span></pre><h1 id="5ca5" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">构建我们的组件</h1><p id="12a9" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">现在，我们已经准备好了通过Apollo执行GraphQL查询所需的一切。</p><p id="9292" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ns nt nu nj b">src/components/LaunchList/index.tsx</code>内部，我们将创建一个使用生成的<code class="fe ns nt nu nj b">useLaunchListQuery</code>钩子的函数组件。查询挂钩返回<code class="fe ns nt nu nj b">data</code>、<code class="fe ns nt nu nj b">loading</code>和<code class="fe ns nt nu nj b">error</code>值。我们将检查容器组件中的<code class="fe ns nt nu nj b">loading</code>和<code class="fe ns nt nu nj b">error</code>，并将<code class="fe ns nt nu nj b">data</code>传递给我们的表示组件。</p><p id="d75a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将通过使用这个组件作为容器/智能组件来保持关注点的分离，并且我们将把数据传递给一个表示/哑组件，该组件仅仅显示它已经被给予的内容。我们还将显示等待数据时的基本加载和错误状态。</p><p id="a554" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的容器组件应该如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="de13" class="nn lt it nj b gy no np l nq nr">import * as React from 'react';<br/>import { useLaunchListQuery } from '../../generated/graphql';<br/>import LaunchList from './LaunchList';<br/><br/>const LaunchListContainer = () =&gt; {<br/>  const { data, error, loading } = useLaunchListQuery();<br/><br/>  if (loading) {<br/>    return &lt;div&gt;Loading...&lt;/div&gt;;<br/>  }<br/><br/>  if (error || !data) {<br/>    return &lt;div&gt;ERROR&lt;/div&gt;;<br/>  }<br/><br/>  return &lt;LaunchList data={data} /&gt;;<br/>};<br/><br/>export default LaunchListContainer;</span></pre><p id="e3d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的表示组件将使用我们的类型化的<code class="fe ns nt nu nj b">data</code>对象来构建UI。我们用<code class="fe ns nt nu nj b">&lt;ol&gt;</code>创建一个有序列表，并映射我们的启动以显示<code class="fe ns nt nu nj b">mission_name</code>和<code class="fe ns nt nu nj b">launch_year</code>。</p><p id="8466" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe ns nt nu nj b">src/components/LaunchList/LaunchList.tsx</code>会是这样的:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="50d9" class="nn lt it nj b gy no np l nq nr">import * as React from 'react';<br/>import { LaunchListQuery } from '../../generated/graphql';<br/>import './styles.css';</span><span id="3ed1" class="nn lt it nj b gy ok np l nq nr">interface Props {<br/>  data: LaunchListQuery;<br/>}</span><span id="6f13" class="nn lt it nj b gy ok np l nq nr">const className = 'LaunchList';</span><span id="6a19" class="nn lt it nj b gy ok np l nq nr">const LaunchList: React.FC&lt;Props&gt; = ({ data }) =&gt; (<br/>  &lt;div className={className}&gt;<br/>    &lt;h3&gt;Launches&lt;/h3&gt;<br/>    &lt;ol className={`${className}__list`}&gt;<br/>      {!!data.launches &amp;&amp;<br/>        data.launches.map(<br/>          (launch, i) =&gt;<br/>            !!launch &amp;&amp; (<br/>              &lt;li key={i} className={`${className}__item`}&gt;<br/>                {launch.mission_name} ({launch.launch_year})<br/>              &lt;/li&gt;<br/>            ),<br/>        )}<br/>    &lt;/ol&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="76eb" class="nn lt it nj b gy ok np l nq nr">export default LaunchList;</span></pre><p id="fb8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用的是VS代码，IntelliSense将准确显示可用的值，并提供一个自动完成列表，因为我们使用的是TypeScript。它还会警告我们正在使用的数据可能是<code class="fe ns nt nu nj b">null</code>或<code class="fe ns nt nu nj b">undefined</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/8cd5f83412edd5079844672ef1c08da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*voCkMaa3xkBi0zKx"/></div></div></figure><p id="3d08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">说真的，这有多神奇？我们的编辑将为我们编码。同样，如果你需要一个类型或者函数的定义，你可以<code class="fe ns nt nu nj b">Cmd + t</code>，用鼠标悬停它，它会给你所有的细节。</p><p id="132e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还将添加一些CSS样式，这将显示我们的项目，并允许它们在列表溢出时滚动。在<code class="fe ns nt nu nj b">src/components/LaunchList/styles.css</code>内，添加以下代码:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="26d3" class="nn lt it nj b gy no np l nq nr">.LaunchList {<br/>  height: 100vh;<br/>  overflow: hidden auto;<br/>  background-color: #ececec;<br/>  width: 300px;<br/>  padding-left: 20px;<br/>  padding-right: 20px;<br/>}</span><span id="5f83" class="nn lt it nj b gy ok np l nq nr">.LaunchList__list {<br/>  list-style: none;<br/>  margin: 0;<br/>  padding: 0;<br/>}</span><span id="83dc" class="nn lt it nj b gy ok np l nq nr">.LaunchList__item {<br/>  padding-top: 20px;<br/>  padding-bottom: 20px;<br/>  border-top: 1px solid #919191;<br/>  cursor: pointer;<br/>}</span></pre><p id="686a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们将构建我们的profile组件来显示关于发布的更多细节。这个组件的<code class="fe ns nt nu nj b">index.tsx</code>文件基本上是相同的，除了我们使用了<code class="fe ns nt nu nj b">Profile</code>查询和组件。我们还为启动的<code class="fe ns nt nu nj b">id</code>向React钩子传递了一个变量。现在，我们将把它硬编码到<code class="fe ns nt nu nj b">'42'</code>中，一旦我们的应用程序设计好了，我们就会添加动态功能。</p><p id="62eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ns nt nu nj b">src/components/LaunchProfile/index.tsx</code>内部，添加以下代码:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="3088" class="nn lt it nj b gy no np l nq nr">import * as React from 'react';<br/>import { useLaunchProfileQuery } from '../../generated/graphql';<br/>import LaunchProfile from './LaunchProfile';</span><span id="fe97" class="nn lt it nj b gy ok np l nq nr">const LaunchProfileContainer = () =&gt; {<br/>  const { data, error, loading } = useLaunchProfileQuery(<br/>    { variables: { id: '42' } }<br/>  );</span><span id="66b6" class="nn lt it nj b gy ok np l nq nr">  if (loading) {<br/>    return &lt;div&gt;Loading...&lt;/div&gt;;<br/>  }</span><span id="61c0" class="nn lt it nj b gy ok np l nq nr">  if (error) {<br/>    return &lt;div&gt;ERROR&lt;/div&gt;;<br/>  }</span><span id="d235" class="nn lt it nj b gy ok np l nq nr">  if (!data) {<br/>    return &lt;div&gt;Select a flight from the panel&lt;/div&gt;;<br/>  }</span><span id="059d" class="nn lt it nj b gy ok np l nq nr">  return &lt;LaunchProfile data={data} /&gt;;<br/>};</span><span id="b541" class="nn lt it nj b gy ok np l nq nr">export default LaunchProfileContainer;</span></pre><p id="87df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在需要创建我们的表示组件。它将在UI顶部显示启动名称和详细信息，然后在描述下面有一个启动图像网格。</p><p id="1841" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ns nt nu nj b">src/components/LaunchProfile/LaunchProfile.tsx</code>组件将如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6d3e" class="nn lt it nj b gy no np l nq nr">import * as React from 'react';<br/>import { LaunchProfileQuery } from '../../generated/graphql';<br/>import './styles.css';</span><span id="7fcb" class="nn lt it nj b gy ok np l nq nr">interface Props {<br/>  data: LaunchProfileQuery;<br/>}</span><span id="46e4" class="nn lt it nj b gy ok np l nq nr">const className = 'LaunchProfile';</span><span id="7a06" class="nn lt it nj b gy ok np l nq nr">const LaunchProfile: React.FC&lt;Props&gt; = ({ data }) =&gt; {<br/>  if (!data.launch) {<br/>    return &lt;div&gt;No launch available&lt;/div&gt;;<br/>  }</span><span id="814a" class="nn lt it nj b gy ok np l nq nr">  return (<br/>    &lt;div className={className}&gt;<br/>      &lt;div className={`${className}__status`}&gt;<br/>        &lt;span&gt;Flight {data.launch.flight_number}: &lt;/span&gt;<br/>        {data.launch.launch_success ? (<br/>          &lt;span className={`${className}__success`}&gt;Success&lt;/span&gt;<br/>        ) : (<br/>          &lt;span className={`${className}__failed`}&gt;Failed&lt;/span&gt;<br/>        )}<br/>      &lt;/div&gt;<br/>      &lt;h1 className={`${className}__title`}&gt;<br/>        {data.launch.mission_name}<br/>        {data.launch.rocket &amp;&amp;<br/>          ` (${data.launch.rocket.rocket_name} | ${data.launch.rocket.rocket_type})`}<br/>      &lt;/h1&gt;<br/>      &lt;p className={`${className}__description`}&gt;{data.launch.details}&lt;/p&gt;<br/>      {!!data.launch.links &amp;&amp; !!data.launch.links.flickr_images &amp;&amp; (<br/>        &lt;div className={`${className}__image-list`}&gt;<br/>          {data.launch.links.flickr_images.map(image =&gt;<br/>            image ? &lt;img src={image} className={`${className}__image`} key={image} /&gt; : null,<br/>          )}<br/>        &lt;/div&gt;<br/>      )}<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="c591" class="nn lt it nj b gy ok np l nq nr">export default LaunchProfile;</span></pre><p id="5a38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一步是用CSS样式化这个组件。将以下内容添加到您的<code class="fe ns nt nu nj b">src/components/LaunchProfile/styles.css</code>文件中:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="49be" class="nn lt it nj b gy no np l nq nr">.LaunchProfile {<br/>  height: 100vh;<br/>  max-height: 100%;<br/>  width: calc(100vw - 300px);<br/>  overflow: hidden auto;<br/>  padding-left: 20px;<br/>  padding-right: 20px;<br/>}</span><span id="68c3" class="nn lt it nj b gy ok np l nq nr">.LaunchProfile__status {<br/>  margin-top: 40px;<br/>}</span><span id="f7de" class="nn lt it nj b gy ok np l nq nr">.LaunchProfile__title {<br/>  margin-top: 0;<br/>  margin-bottom: 4px;<br/>}</span><span id="9645" class="nn lt it nj b gy ok np l nq nr">.LaunchProfile__success {<br/>  color: #2cb84b;<br/>}</span><span id="ff1c" class="nn lt it nj b gy ok np l nq nr">.LaunchProfile__failed {<br/>  color: #ff695e;<br/>}</span><span id="1c33" class="nn lt it nj b gy ok np l nq nr">.LaunchProfile__image-list {<br/>  display: grid;<br/>  grid-gap: 20px;<br/>  grid-template-columns: repeat(2, 1fr);<br/>  margin-top: 40px;<br/>  padding-bottom: 100px;<br/>}</span><span id="c98e" class="nn lt it nj b gy ok np l nq nr">.LaunchProfile__image {<br/>  width: 100%;<br/>}</span></pre><p id="7891" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经完成了组件的静态版本，我们可以在UI中查看它们。我们将在<code class="fe ns nt nu nj b">src/App.tsx</code>文件中包含我们的组件，并将<code class="fe ns nt nu nj b">&lt;App /&gt;</code>转换成一个函数组件。我们使用一个功能组件来简化它，并允许我们在添加点击功能时使用钩子。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="ed92" class="nn lt it nj b gy no np l nq nr">import React from 'react';<br/>import LaunchList from './components/LaunchList';<br/>import LaunchProfile from './components/LaunchProfile';</span><span id="a62b" class="nn lt it nj b gy ok np l nq nr">import './App.css';</span><span id="1f69" class="nn lt it nj b gy ok np l nq nr">const App = () =&gt; {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;LaunchList /&gt;<br/>      &lt;LaunchProfile /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="8c3b" class="nn lt it nj b gy ok np l nq nr">export default App;</span></pre><p id="f646" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了得到我们想要的样式，我们将把<code class="fe ns nt nu nj b">src/App.css</code>改为如下:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="31cc" class="nn lt it nj b gy no np l nq nr">.App {<br/>  display: flex;<br/>  width: 100vw;<br/>  height: 100vh;<br/>  overflow: hidden;<br/>}</span></pre><p id="6a91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的终端中执行<code class="fe ns nt nu nj b">yarn start</code>，在您的浏览器中导航到<code class="fe ns nt nu nj b">http://localhost:3000</code>，您应该会看到您的应用程序的基本版本！</p><h1 id="af32" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">添加用户交互</h1><p id="fe46" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">现在，我们需要添加功能，以便在用户单击面板中的项目时获取完整的启动数据。我们将在<code class="fe ns nt nu nj b">App</code>组件中创建一个钩子来跟踪航班ID，并将其传递给<code class="fe ns nt nu nj b">LaunchProfile</code>组件来重新获取发射数据。</p><p id="185f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的<code class="fe ns nt nu nj b">src/App.tsx</code>中，我们将添加<code class="fe ns nt nu nj b">useState</code>来维护和更新ID的状态。我们还将使用名为<code class="fe ns nt nu nj b">handleIdChange</code>的<code class="fe ns nt nu nj b">useCallback</code>作为点击处理程序，当用户从列表中选择一个时更新ID。我们将<code class="fe ns nt nu nj b">id</code>传递给<code class="fe ns nt nu nj b">LaunchProfile</code>，将<code class="fe ns nt nu nj b">handleIdChange</code>传递给<code class="fe ns nt nu nj b">&lt;LaunchList /&gt;</code>。</p><p id="d636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更新后的<code class="fe ns nt nu nj b">&lt;App /&gt;</code>组件应该如下所示:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="a8fe" class="nn lt it nj b gy no np l nq nr">const App = () =&gt; {<br/>  const [id, setId] = React.useState(42);<br/>  const handleIdChange = React.useCallback(newId =&gt; {<br/>    setId(newId);<br/>  }, []);</span><span id="8aeb" class="nn lt it nj b gy ok np l nq nr">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;LaunchList handleIdChange={handleIdChange} /&gt;<br/>      &lt;LaunchProfile id={id} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="fda5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ns nt nu nj b">LaunchList.tsx</code>组件中，我们需要为<code class="fe ns nt nu nj b">handleIdChange</code>创建一个类型，并将其添加到我们的props析构中。然后，在我们的<code class="fe ns nt nu nj b">&lt;li&gt;</code>航班项目上，我们将执行<code class="fe ns nt nu nj b">onClick</code>回调中的函数。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1b29" class="nn lt it nj b gy no np l nq nr">export interface OwnProps {<br/>  handleIdChange: (newId: number) =&gt; void;<br/>}</span><span id="676e" class="nn lt it nj b gy ok np l nq nr">interface Props extends OwnProps {<br/>  data: LaunchListQuery;<br/>}</span><span id="4464" class="nn lt it nj b gy ok np l nq nr">// ...<br/>const LaunchList: React.FC&lt;Props&gt; = ({ data, handleIdChange }) =&gt; (<br/>  <br/>// ...<br/>&lt;li<br/>  key={i}<br/>  className={`${className}__item`}<br/>  onClick={() =&gt; handleIdChange(launch.flight_number!)}<br/>&gt;</span></pre><p id="66ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe ns nt nu nj b">LaunchList/index.tsx</code>内部，一定要导入<code class="fe ns nt nu nj b">OwnProps</code>声明来键入要传递给容器组件的<code class="fe ns nt nu nj b">props</code>，然后将道具展开到<code class="fe ns nt nu nj b">&lt;LaunchList data={data} {...props} /&gt;</code>中。</p><p id="effc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一步是在<code class="fe ns nt nu nj b">id</code>改变时<code class="fe ns nt nu nj b">refetch</code>数据。在<code class="fe ns nt nu nj b">LaunchProfile/index.tsx</code>文件中，我们将使用<code class="fe ns nt nu nj b">useEffect</code>，它管理React生命周期，并在<code class="fe ns nt nu nj b">id</code>改变时触发获取。以下是实现提取所需的唯一更改:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="5fc2" class="nn lt it nj b gy no np l nq nr">interface OwnProps {<br/>  id: number;<br/>}</span><span id="5ba4" class="nn lt it nj b gy ok np l nq nr">const LaunchProfileContainer = ({ id }: OwnProps) =&gt; {<br/>  const { data, error, loading, refetch } = useLaunchProfileQuery({<br/>    variables: { id: String(id) },<br/>  });<br/>  React.useEffect(() =&gt; {<br/>    refetch();<br/>  }, [id]);</span></pre><p id="b9ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们已经将表示从数据中分离出来，所以我们不需要对我们的<code class="fe ns nt nu nj b">&lt;LaunchProfile /&gt;</code>组件做任何更新；我们只需要更新<code class="fe ns nt nu nj b">index.tsx</code>文件，这样当选择的<code class="fe ns nt nu nj b">flight_number</code>改变时，它可以重新提取完整的启动数据。</p><p id="a266" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你有了！如果您遵循这些步骤，您应该有一个功能完整的GraphQL应用程序。如果您在任何地方迷路了，您可以在<a class="ae lq" href="https://github.com/treyhuffine/graphql-react-typescript-spacex" rel="noopener ugc nofollow" target="_blank">源代码</a>中找到工作解决方案。</p><h1 id="ea32" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">结论</h1><p id="fbfc" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">一旦配置好app，我们可以看到开发速度快得不可思议。我们可以轻松地构建一个数据驱动的UI。GraphQL允许我们定义我们在组件中需要的数据，并且我们可以无缝地在我们的组件中使用它作为道具。生成的TypeScript定义对我们编写的代码给予了极高的信任。</p><p id="2400" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您希望更深入地了解项目，下一步将是使用API中的附加字段添加分页和更多的数据连接。要对启动列表进行分页，您需要获取当前列表的长度，并将<code class="fe ns nt nu nj b">offset</code>变量传递给<code class="fe ns nt nu nj b">LaunchList</code>查询。</p><p id="41cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我鼓励您更深入地探索它，并编写您自己的查询，这样您就可以巩固所介绍的概念。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><div class="kj kk kl km gt mt"><a href="https://gitconnected.com/portfolio-api" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">组合API -轻松发展您的编码事业| gitconnected</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">消除在每个不同地点手动更新您的详细信息的痛苦。只需在您的中更改一次数据…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">gitconnected.com</p></div></div><div class="nc l"><div class="os l ne nf ng nc nh ks mt"/></div></div></a></div></div></div>    
</body>
</html>