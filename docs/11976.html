<html>
<head>
<title>Merge Conflicts… WTH?!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并冲突… WTH？！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/merge-conflicts-wth-d9f50ea1db0e?source=collection_archive---------1-----------------------#2022-05-04">https://levelup.gitconnected.com/merge-conflicts-wth-d9f50ea1db0e?source=collection_archive---------1-----------------------#2022-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cb97" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释发布示例中的Git分支合并和冲突</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6e1e038c08e1a35309142a4a817e4dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dsx8JUDYNv6A7_etF681A.png"/></div></div></figure><h1 id="4e61" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="f69e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Git是一个强大的版本管理工具，多年来一直被广泛采用。但是有些概念可能不是很好理解。我们最近在发布分支合并中遇到了合并冲突。通过深入研究，它帮助我揭开神秘面纱，并获得一些关于<em class="mf"> Git / Github </em> merge如何工作的见解。我觉得很有趣，很乐意分享这个故事。</p><h1 id="d9bf" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">Git分支的关键概念</h1><p id="dba3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们从一些关于分支和合并的关键概念开始。它们是我的理解，所以不是规范的定义:)</p><h2 id="1714" class="mg ks iq bd kt mh mi dn kx mj mk dp lb ls ml mm ld lw mn mo lf ma mp mq lh mr bi translated">1.分支只是提交的一个名称标签</h2><blockquote class="ms mt mu"><p id="2d19" class="lj lk mf ll b lm mv jr lo lp mw ju lr mx my lu lv mz na ly lz nb nc mc md me ij bi translated"><em class="iq">分支简单来说就是</em> <em class="iq">只是一个</em> <strong class="ll ir"> <em class="iq">名称标签，指向一个提交</em> </strong> <em class="iq">(不像cvs、subversion等其他VCS。)</em></p></blockquote><p id="5a58" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">例如分支<em class="mf">主</em>只是一个指向<em class="mf">提交b6362 </em>的名称标签。分支<em class="mf">开发</em>指向<em class="mf">提交60d31。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/b5018e00c104812d6b0ec2f27b398101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*ppT9KTsmG2J33tdBLOCjQQ.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">图一。Git分支</figcaption></figure><h2 id="341f" class="mg ks iq bd kt mh mi dn kx mj mk dp lb ls ml mm ld lw mn mo lf ma mp mq lh mr bi translated">2.“在分支上”是什么意思</h2><blockquote class="ms mt mu"><p id="ca10" class="lj lk mf ll b lm mv jr lo lp mw ju lr mx my lu lv mz na ly lz nb nc mc md me ij bi translated"><em class="iq">一个提交是</em>“在分支上”<em class="iq">意味着该提交是一个</em> <strong class="ll ir"> <em class="iq">祖先</em> </strong> <em class="iq">，或者是从分支名称指向的提交通过父链</em>  <em class="iq">可到达的</em> <strong class="ll ir"> <em class="iq">。</em></strong></p></blockquote><p id="755b" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">以上图为例，我们可以说:</p><ul class=""><li id="15cb" class="ni nj iq ll b lm mv lp mw ls nk lw nl ma nm me nn no np nq bi translated">提交<em class="mf"> b6362(C2) </em>在分支<em class="mf">开发者</em>上，因为该提交是<em class="mf"> 60d31(C3) </em>的祖先提交，分支<em class="mf">开发者</em>指向该提交</li><li id="6a12" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated">提交<em class="mf"> 38a9c(C1) </em>在<em class="mf">主</em>和<em class="mf">开发</em>分支上，因为它在提交<em class="mf">b 6362(C2/主)</em>和提交<em class="mf">60d 31(C3/开发)</em>的父链上</li></ul><h2 id="9cfb" class="mg ks iq bd kt mh mi dn kx mj mk dp lb ls ml mm ld lw mn mo lf ma mp mq lh mr bi translated">3.“合并分支”是什么意思</h2><blockquote class="ms mt mu"><p id="b525" class="lj lk mf ll b lm mv jr lo lp mw ju lr mx my lu lv mz na ly lz nb nc mc md me ij bi translated">“将分支A合并到分支B”<em class="iq">意味着将分支</em> A <em class="iq"> </em> <strong class="ll ir"> <em class="iq">上的所有提交也合并到分支</em> B </strong> <em class="iq">上。</em></p></blockquote><p id="c575" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">有两种合并，我们将深入研究每一种。</p><ul class=""><li id="69f8" class="ni nj iq ll b lm mv lp mw ls nk lw nl ma nm me nn no np nq bi translated"><strong class="ll ir">快进</strong> <strong class="ll ir">合并</strong></li><li id="4ab6" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated"><strong class="ll ir">创建合并提交</strong>(又名<strong class="ll ir">三向合并</strong>)</li></ul><h1 id="184f" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">快进合并</h1><p id="2a19" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当“将分支<em class="mf"> A </em>合并到分支<em class="mf"> B </em>时”，分支<em class="mf"> B </em>指向<strong class="ll ir">的提交已经在分支<em class="mf">A</em>T83】上。</strong></p><p id="67d7" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">应用于实例:将分支<em class="mf">developer(A)</em>合并到分支<em class="mf"> master(B) </em>时，<em class="mf"> master(B) </em>指向的提交已经在分支<em class="mf"> developer(A) </em>上。现在运行:</p><p id="989c" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated"><strong class="ll ir"> <em class="mf"> git结账大师<br/> git合并开发</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/3310652ceb565eb6cffeaf6c9194d78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*yUcDwtB7xaOYFqdI2JY8BA.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">快进合并设置</figcaption></figure><p id="0b9a" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">回想一下“合并分支”的实际含义:</p><blockquote class="ms mt mu"><p id="450e" class="lj lk mf ll b lm mv jr lo lp mw ju lr mx my lu lv mz na ly lz nb nc mc md me ij bi translated">“将分支A合并到分支B”意味着将分支A <strong class="ll ir">上的所有提交也合并到分支B </strong>上。</p></blockquote><p id="895c" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">为了让分支<em class="mf">上的所有提交也在分支<em class="mf">主</em>上开发</em>。最简单的方法是将分支名称<em class="mf"> master </em>移动到<em class="mf"> develop </em>分支指向的同一个<em class="mf"> commit(C3) </em>，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a8cf5c05d42f796dbac31eec42c9324c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*MNQYdhg9mLrBsIhhfOXsbA.png"/></div></figure><p id="f82d" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">现在我们实现了我们的目标:让分支<em class="mf">上的所有提交也在分支<em class="mf">主</em>上开发</em>。注意，Git中的实现有点反直觉，因为我们实际上并没有将<em class="mf">开发</em>提交转移到<em class="mf">主</em>中。相反，我们只是将主<em class="mf">分支</em>的名称标签向前移动。因此这种操作被命名为<em class="mf">快进合并</em>。</p><p id="d90d" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">在发布管理的一个简单版本中，我们使用<em class="mf">主</em>分支作为发布分支，所有特性工作都交给<em class="mf">开发</em>分支。在发布的时候，我们只是把<em class="mf">开发</em>合并成<em class="mf">主</em>。如果我们继续使用<em class="mf">提交C4 </em>进行下一个发布周期，它将看起来像这样。诸如此类。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/ce6f499c6c12d5d4f2723286c97dfbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*C1OfPfetKGZ0qA-4nVGsWA.png"/></div></figure><h2 id="fd31" class="mg ks iq bd kt mh mi dn kx mj mk dp lb ls ml mm ld lw mn mo lf ma mp mq lh mr bi translated">GitHub的细微差别</h2><p id="4bce" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">理解了普通版本的<em class="mf">快进合并</em>的工作原理后，如果你使用任何基于Git的托管服务，比如<em class="mf"> GitHub </em>，它可能会有自己的细微差别。在<em class="mf"> Github </em>中，所有的分支合并都默认带有参数<strong class="ll ir"><em class="mf">-no-ff "</em></strong>，表示“不快进”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a865f594934f14111e69a01a3c96dff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*r6T4eJK-0qGtMLTQ4sRr5w.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">Github命令的副本</figcaption></figure><p id="1e4e" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated"><em class="mf"> Github </em>想要维护一个分支拓扑，所以它阻止了<em class="mf">快进</em>操作。所以所有的合并都会创建一些<strong class="ll ir">新合并提交</strong>作为结果。这实际上引出了第二种类型的合并:创建合并提交。</p><h1 id="d4eb" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">创建合并提交(三向合并)</h1><p id="c7ee" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">由于有了<em class="mf"> - no-off </em>参数，<em class="mf"> Github </em>将为<em class="mf">主</em>创建一个新的<em class="mf">合并提交(C4) </em>以从<em class="mf">开发</em>进行合并。注意<em class="mf"> C4 </em>是一个新提交，但是它的快照与<em class="mf"> C3 </em>完全相同。还要注意，<em class="mf"> develop </em>分支上的所有提交现在也在<em class="mf"> master上，</em>因此合并成功<em class="mf">。</em>(有一个关于<em class="mf">三向提交</em>的细节，我在这里省略了，但是当我们进入下一个发布周期时，我们会用一个完整的提交链设置来补充这个细节)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b760e17d4d7afd58575924174d532d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*WrkYx5qzL6LcbUxQObdWsA.png"/></div></figure><p id="3406" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">由于新功能<em class="mf"> (C5，C6) </em>仍然被添加到开发分支，我们将到达这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/53f154109cc658092e23d70814f3173c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Glk9GNkZFHf1qW4oyl6l8Q.png"/></div></div></figure><p id="9e29" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">现在，发布:<strong class="ll ir"> <em class="mf"> <br/> git结账大师<br/> git合并-无-ff开发</em> </strong></p><p id="2341" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">这是<em class="mf">三路合并</em>的经典设置。Git将执行以下操作来实现它。</p><ul class=""><li id="9c3d" class="ni nj iq ll b lm mv lp mw ls nk lw nl ma nm me nn no np nq bi translated">Git将寻找最接近的公共祖先提交，它在两个合并分支上。换句话说，这个祖先提交可以从两个分支到达。这个祖先被称为<em class="mf">合并基础</em>。</li><li id="39d9" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated">然后Git将计算从<em class="mf">合并基础</em>到两个分支的<strong class="ll ir"> 2差异</strong></li><li id="1afc" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated"><strong class="ll ir">将两种差异</strong>应用于<em class="mf">合并基础</em>。如果成功，创建一个新的合并提交。如果失败，报告冲突。</li></ul><p id="ecd1" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">在示例中，我们想要合并<em class="mf">主</em>(原本在<em class="mf"> C4 </em>)和<em class="mf">开发(C6) </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/52de8b056dcef4b1b5ecaf13a47dce8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HR5vzEBTRYGL_tO8yVG1Pg.png"/></div></div></figure><ul class=""><li id="e219" class="ni nj iq ll b lm mv lp mw ls nk lw nl ma nm me nn no np nq bi translated">他们最近的共同祖先是<em class="mf"> C3(合并基地)</em>。</li><li id="8e43" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated">C3和C4的不同之处在于之前的合并。所以这里没有区别。</li><li id="bfda" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated">C3与C6的差异<em class="mf"/></li><li id="c4a3" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated">将两种差异应用到<em class="mf">合并基础(C3) </em>。因为<em class="mf"> C3-C4 </em>之间没有真正的差异，Git只需要应用<em class="mf"> C3-C6 </em>的差异。因此创建了一个新的提交<em class="mf"> C7 </em>。由于这是从<em class="mf">开发</em>到<em class="mf">主</em>的合并，Git将<em class="mf">主</em>分支名称移动到<em class="mf"> C7 </em>。合并操作成功。(另请注意，<em class="mf"> C7 </em>的快照内容也与<em class="mf"> C6 </em>相同)</li></ul><p id="dde4" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">现在我们也看到了为什么取名为“三合”。因为Git执行合并涉及到三个重要的提交。</p><h1 id="3a81" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">热修复和合并冲突</h1><p id="b3fa" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在我们已经明白了两种类型的Git分支合并(<em class="mf">快进</em> &amp; <em class="mf">三向</em>)是什么意思。让我们回到<strong class="ll ir">最初促使我下去调查的事件</strong>:</p><blockquote class="ms mt mu"><p id="6271" class="lj lk mf ll b lm mv jr lo lp mw ju lr mx my lu lv mz na ly lz nb nc mc md me ij bi translated">当我们管理我们的应用程序版本(Android项目)时，我们意识到每当我们将<em class="iq">热修复</em>添加到<em class="iq">主</em>分支(发布分支)并将其合并回<em class="iq">开发</em>分支(主干分支)时，如果我们在Github  上使用<strong class="ll ir"> <em class="iq">挤压或rebase merge，下一次我们发布时，Git总是会告诉我们关于<strong class="ll ir">冲突</strong>，即使我们已经合并了所有内容WTH？！</em></strong></p></blockquote><h2 id="4d41" class="mg ks iq bd kt mh mi dn kx mj mk dp lb ls ml mm ld lw mn mo lf ma mp mq lh mr bi translated">热修复方案</h2><p id="d822" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">比方说，我们需要在master上安装一个<em class="mf">热补丁</em>。提交<em class="mf"> C4 </em>就是为此创建的，然后我们用提交<em class="mf"> C5 </em>更新了应用版本。现在师父指向C5。同时，在开发分支上，<em class="mf"> C6 </em>作为一个新特性被添加。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/930d94d8631f01617ea3c42ae309d546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULqRx_at9ZNf6Y7iL1ABIA.png"/></div></div></figure><h2 id="e013" class="mg ks iq bd kt mh mi dn kx mj mk dp lb ls ml mm ld lw mn mo lf ma mp mq lh mr bi translated">场景#1:创建一个合并提交(三向)来合并回</h2><p id="a745" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了将<em class="mf">热修复</em>和版本更新带回<em class="mf">开发</em>，我们需要通过创建一个合并提交将<em class="mf">开发</em>合并到<em class="mf">主</em>。同样，基于三向合并的工作方式，Git将执行以下操作并创建C7作为结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/1ed9769b611c7665a752bb1fc1de155b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oaBoPnbIGXTqSg9OEkwPQ.png"/></div></div></figure><p id="13cd" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">在这个合并逻辑中，Git发现<em class="mf"> C2 </em>作为共同的祖先和合并基础，同时应用两个diff(<em class="mf">C2-C5</em>&amp;<em class="mf">C2-C6</em>)。假设没有冲突(意味着同一文件的同一行中有2个不同的更改)，将创建一个新的合并提交<em class="mf"> C7 </em>。<em class="mf">主</em>修改回<em class="mf">现在开发</em>。这个发布周期就完成了！</p><p id="3cb6" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">值得注意的是:在Github中，有3个合并动作可用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/1c139f8a995c182caae6bd180548a84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*UHcsYWIC41801XbIv-qd9g.png"/></div></figure><p id="29d1" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">我们希望确保<strong class="ll ir">创建一个合并提交</strong>。它将变得很重要。原因如下:稍后，当我们有了<em class="mf">上的<em class="mf">C8</em>develop</em>并准备好下一个版本时:<strong class="ll ir">git merge develop(HEAD on master)</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/ca09931d340a23002e3b89db4994ce54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3zewFl7OUZxtoPiG2zAMg.png"/></div></div></figure><p id="c01b" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">Git将在这里执行另一个3路合并。问题，你能指出<em class="mf">主(C5) </em>和<em class="mf">发展(C8) </em>分支的共同祖先吗？</p><p id="4be9" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">答案是他们的<strong class="ll ir">共同祖先是…<em class="mf">C5</em>T35】。原因是<em class="mf"> C5 </em>已经在主节点上，<em class="mf"> C5 </em>也在<em class="mf">开发</em>分支上，这要感谢<em class="mf"> C5 &amp; C7 </em>之间的链接(上面用红色标出)。</strong></p><p id="a1a5" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">从<em class="mf"> C5 </em>开始，Git将应用2个diffs。<em class="mf"> C5 </em>到<em class="mf">主</em>的差为零。所以Git只需要应用<em class="mf"> C5-C8 </em>的diff。因为没有冲突，所以保证了成功的合并提交。在这种情况下，创建<em class="mf"> C9 </em>并将<em class="mf">主</em>标签移动到<em class="mf"> C9 </em>。结果如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/0f77c5f0618755e8570500e3fc864d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1dTmi6dosLTK0Sg3fqaloA.png"/></div></div></figure><h2 id="d01c" class="mg ks iq bd kt mh mi dn kx mj mk dp lb ls ml mm ld lw mn mo lf ma mp mq lh mr bi translated">场景#2:挤压或重定基础合并以应对未来的冲突</h2><p id="ab5a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">之前，在<em class="mf"> Github </em>上，我们为<em class="mf">主</em>创建了一个三向合并提交，以返回到<em class="mf">开发</em>。但是如果我们做了<strong class="ll ir">挤压</strong>或者<strong class="ll ir">重置基础合并</strong>，下一个发布周期的结果将会不同。让我们玩到底。</p><p id="854b" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">当合并回热修复程序时，如果我们选择<strong class="ll ir">挤压或重设基础合并</strong> …</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c1cf7bf8f816afc1048d2d5b3a1b3467.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*ot-vQUxKd9lhkeC2HwggXw.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/c6a458af9b6a357334d85947bcfdc2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kV_1b5zkGtMWASbM8CaV6w.png"/></div></div></figure><p id="09d6" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated"><em class="mf">提交C7 </em>将作为<strong class="ll ir">挤压或重置</strong>的结果而创建。注意<em class="mf">C5&amp;C7</em>T77】之间没有<strong class="ll ir">链接。</strong></p><p id="7fc7" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">在下一个发布周期，当我们想要将<em class="mf"> develop </em>合并到<em class="mf"> master </em>时，git tree将会是这样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/e8ecb73a47a6ece3af23026c3ee0998f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2LEOn9-Ec2zRMtbeaSRFpg.png"/></div></div></figure><p id="7590" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">这种情况下的共同祖先在哪里？由于<em class="mf"> C5 &amp; C7 </em>之间缺少联系，<strong class="ll ir">共同祖先</strong>现在竟然在<strong class="ll ir"><em class="mf">【C2</em></strong>，这是上一个发布周期的分叉点。在这种情况下，Git将如何执行合并呢？</p><p id="9a5a" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">假设我们在一个配置文件中定义了一个发布版本号。</p><ul class=""><li id="d544" class="ni nj iq ll b lm mv lp mw ls nk lw nl ma nm me nn no np nq bi translated">在<em class="mf"> C2(合并基础)</em>，版本为<strong class="ll ir"><em class="mf">v 1.0</em></strong><em class="mf"/>(之前版本)</li><li id="229f" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated">在<em class="mf"> C5(主)</em>时，是<strong class="ll ir"> <em class="mf"> v1.1 </em> </strong>(热修复)</li><li id="e7ca" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated">在<em class="mf"> C8(开发)</em>时，是<strong class="ll ir"><em class="mf">v 2.0</em></strong><em class="mf"/>(下次发布)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/2d5a0cfffdce9a568b441656a463d0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YP7LdmB6gfRr2sUv_Feig.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">冲突</figcaption></figure><ul class=""><li id="2766" class="ni nj iq ll b lm mv lp mw ls nk lw nl ma nm me nn no np nq bi translated"><em class="mf"> C2 &amp; C5 </em>的区别是将<strong class="ll ir">版本从<em class="mf"> v1.0更新到v 1.1</em>T35】</strong></li><li id="3d7b" class="ni nj iq ll b lm nr lp ns ls nt lw nu ma nv me nn no np nq bi translated"><em class="mf"> C2 &amp; C8 </em>的区别是将<strong class="ll ir">从<em class="mf"> v1.0 </em>更新为<em class="mf">v 2.0</em>T43】</strong></li></ul><p id="3ec6" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">当Git在<em class="mf"> C2(合并基础)</em>上应用两种差异时，Git在同一文件的同一行上有<strong class="ll ir">两种不同的更新。Git不知道应用哪个diff，所以它通过说<strong class="ll ir">合并冲突</strong>来认输。</strong></p><p id="6a41" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">现在，这个难题被解决了:当我们在上一个发布周期合并热修复时，不同类型的合并方法会在下一个发布周期开始时导致不同的结果。</p><p id="359f" class="pw-post-body-paragraph lj lk iq ll b lm mv jr lo lp mw ju lr ls my lu lv lw na ly lz ma nc mc md me ij bi translated">当然，冲突并不是世界末日，仍然可以手动解决。但是如果我们理解了根本原因并相应地设置了分支规则，我们就可以防止常规的麻烦发生，这对于大型开发团队来说尤其重要。</p><h1 id="9157" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结束</h1><p id="b287" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我从这个练习中学到了不少关于<em class="mf">GIT</em>&amp;<em class="mf">Github</em>的东西。我相信<strong class="ll ir"> </strong>因为它们都是事物如何运作的基本概念和机制，<strong class="ll ir"> </strong>它们应该也适用于解决许多其他相关的<em class="mf"> Git </em>难题。希望这篇文章能有助于更深入的理解，这样我们就能在日常工作中更舒适、更自信地使用Git。</p></div></div>    
</body>
</html>