# 改变我职业生涯的 5 个设计原则

> 原文：<https://levelup.gitconnected.com/5-design-principles-that-changed-my-career-6966be5a4f74>

## 以及如何应用它们

![](img/1494ba6e5550d6e548b5617c3b7222c4.png)

内森·杜姆劳在 [Unsplash](https://unsplash.com/s/photos/building-blocks?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

程序员在他们的职业生涯中会学到很多概念，但是很少会有一个关键的时刻，在这个时刻，你以后看到的一切都会以不同的眼光看待。几年前我就发现了其中的一个时刻，它太好了，不能不分享。也许，那是因为我目睹了没有它的痛苦，我也经历了*如何释放*它可以。没有这些原则，有时感觉就像“回到笼子里”。

我所指的痛苦是可预防的技术债务、维护噩梦和不可测试的代码带来的致命危险。对于大多数面向对象的代码库来说，这是一种太常见的可能性。

如果你作为一名企业开发人员已经工作了足够长的时间，你可能已经注意到在某些时候，代码库的某些区域没有人愿意靠近。你可能也见过你的开发团队成员玩“打地鼠”来修复 bug。一定量的这种情况是常见的，但是太多的这种情况可能非常不健康——对于产品和它的开发者来说都是如此。

您的普通[编程反模式](https://medium.com/the-innovation/anti-patterns-are-common-yet-shouldnt-be-considered-normal-dac648576fa7)使这成为必然。有时一个代码库需要很多年才能变得笨拙。然而，设计不良的软件架构可以显示出未来两年内会发生什么可怕事情的早期迹象。

## 如果你不想这样工作，那就继续读吧

我之前提到过坚实的原则如何通过防止这些情况的发生而改变了我的职业生涯，今天，我将最终详细阐述一下。这五条原则可以帮助你从绝望中解脱出来，同时让你自己更加认识到:

*   一个班级负责什么
*   类之间的依赖关系
*   隔离用于单元测试的组件
*   长期对象的范围和生命周期

有许多文章专门讨论每一个坚实的原则，只需要谷歌搜索一下，所以我不可能在这篇文章中写得如此透彻。我提供的是如何使用它们的真实故事。

编程语言可能在策略上略有不同，但这只是实现细节。我已经在 C#、C++、Java 和 Objective-C 中应用了以下概念，但是它们通常可以应用于 OOP 语言。为了简化语法，一些代码片段将在 C#中显示。

# 1.单一责任原则

单一责任原则说一个类应该有单一功能的责任。如果一个类在做很多事情，即使都是相关的，也有太多的理由让这个类随着时间而改变。

## 不要做什么

你是否曾经在代码库中发现过一个`ThingManager`，它“管理”着几乎所有关于`Things`的事情？

`CreateThing()`
`AddThing()`
`CopyThing()`
`RemoveThing()`
`MutateThing()`
`VerifyThing()`
`DoSomethingVeryConvolutedWithThings()`

`ListAllThings()`
`ExportAllThings()`
`ShareThing()`
`DownloadAllThings()`
`UploadAllThings()`

鉴于对使用`Thing`对象可以完成的所有事情的要求，我们*可能*只是天真地将那些小方法都塞进了`ThingManager`。可能一开始，这个`ThingManaer`类只有几百行代码。我们很多人已经看到了这是如何结束的。有时候这些文件几年后就是几千行。到那时，它们的内部就变得深奥了，而且耦合得太紧，以至于以后无法分解。

当最初的开发者离开后，没有人真正知道它是如何工作的——代码可读性很差。

## 取而代之做什么

如果我们把责任划分给不像经理那样模糊的阶层会怎么样？

*   `Thing`
*   `ThingCollection`
*   `ThingVerifier`
*   `ThingMutator`
*   `LocalThingStorage`
*   `CloudThingStorage`或`ThingUploader`和`ThingDownloader`
*   `ThingExporter`
*   `ThingSharer`

现在我们有了几个与事物相关的类，它们明确定义了职责。这些是小的，但是有形的，可测试的工作单元。它们可以彼此独立地改变，除非它们的接口发生了变化。在未来很长一段时间内，对于这些职业的作用不会有任何混淆。

# 2.开/关原则

[打开/关闭原则](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)规定模块应打开以进行扩展，但关闭以进行修改。实际的推理是，您可以向类中添加字段和新方法，但不能改变现有的行为。

## 不要做什么

除非你想让人们讨厌你，否则不要改变已经预料到的事情。例如，假设在你的`Thing`类中有一个`Mutate()`方法，它返回一个`Thing`的对象。

不要先返回一个新的变异的**在一个版本中复制`Thing`对象的**，然后在一年后的下一个版本中，变异调用者并返回一个对**相同的** `Thing`对象(调用者)的引用。那会造成大混乱。界面完全相同，但新的行为不受欢迎。

## 取而代之做什么

如果只有一个`Thing`类，您可以提供一个不同的`MutateInPlace()`方法，该方法被明确地记录为返回一个对调用对象的引用，该对象已经发生了变化。

然而，如果您想了解可变性与不可变性，您可能应该创建一个`MutableThing`类，其中 Mutate()函数对可变对象(调用者)进行操作，并将 return-a-copy 版本留在原始的`Thing`类中。我跑题了；我们继续吧。

## 你还能做什么(但我没有)

我曾经有一个同事告诉我一个故事，一个开发团队严格遵循不应该修改任何类。有虫吗？创建一个子类或者写一个扩展方法来修复它，但是不要修改类文件本身。真的吗？是的，如果它已经在野外，一个 bug 可能是客户的预期行为；修好它，你就破坏了他们的设置。

## 我认为最有价值的地方

如果你正在提供一个 SDK 或 Web API(内部或外部)，你肯定希望保持你面向公众的接口的一致性——不仅仅是为了不破坏代码，也是为了保持不同版本间预期行为的一致性。这就是为什么随着时间的推移，许多公共 API 用做几乎完全相同事情的新方法取代旧方法。

如果你正在做一个还没见天日的新项目，限制自己是没有意义的。在第一次发布之后，你就要开始小心了。

# 3.利斯科夫替代原理

[利斯科夫替换原则](https://en.wikipedia.org/wiki/Liskov_substitution_principle)通俗地说，允许你将一个子类型的对象替换为另一个，而不破坏现有/预期的行为。按子类型，不一定派生自同一个基类；只要这些类型实现相同的接口。

## 示例#1

假设您有一个`AppleThingStorage`和一个`AndroidThingStorage`，但是每个平台都有特定的 API 来存储数据。

不需要`#ifdef`你的代码去改变调用点来处理不同的方法签名。相反，他们可以继承或实现一个平台无关的`LocalThingStorage`接口(你可以从方法参数中抽象出特定于平台的类型)。这样`AppleThingStorage`和`AndroidThingStorage`可以互换。

## 实施例 2

即使在一个平台上，你可能*仍然*想要不同的实现来存储一个`Thing`。你可以为`LocalThingStorage`和`CloudThingStorage`做一个通用接口的`ThingStorageBase`。

## 不要做什么

不要用这个来代替做完全不同事情的类，预期的行为完全不在考虑范围内。

替换一个类型不应该破坏任何单元测试或用户测试，这可能是有争议的，但是没有硬性的规则。如果您的`*ThingStorage`测试的验证步骤不是特定于平台或特定于存储介质的，那么测试将通过。否则，您可能需要对每个子类型进行一系列测试。

# 4.接口隔离原则(ISP)

根据[接口分离原则](https://en.wikipedia.org/wiki/Liskov_substitution_principle)，一个类不应该依赖于它不使用的方法。这有助于多重继承成为 OOP 的一个特性。接口是一个完美的抽象机制。

一个接口不需要将一个类做的所有事情都公开给依赖它(部分)的其他人。无论如何，你可能不希望其他类依赖于具体的实现——因为这将两个具体的类耦合在一起，在依赖方面。

## 不要做什么

不要让一个类有很多方法，如果其他类只需要使用它的一个更小的方法子集，就把它的一个对象作为其他类的依赖来传递。

一个更极端的例子是，当类是一个整体时，你将它的上帝对象实例传递给许多其他类，它们现在都有一个对上帝对象的引用，可以做任何事情。这违反了最小特权的[原则。](https://en.wikipedia.org/wiki/Principle_of_least_privilege)

## 取而代之做什么

如果你遵循 SRP，这个类无论如何都不会有太多的成员，但是你可能仍然想把接口减少到只有它的依赖者需要的。或者，如果类的不同依赖项需要不同的方法，您可以使用多重继承来实现两个或更多接口。

而现在其他类可以依赖`IDoThis`或者`IDoThat`等等。

## 进一步做什么

当创建任何类时，首先要考虑它应该提供给其他人的接口。然后，考虑如何对接口进行单元测试:每个方法期望和返回什么，它变异了哪些成员或触发了哪些事件，以及赋予它的参数有什么不同。

理想情况下，这将在您进入实现之前发生，因为它可以通知实现关于需求的信息。相反，有时实现可以通知接口，可以在最终确定接口之前对其进行修改。

对于不能直接进行单元测试的类(例如，需要一个真实的环境)，如何对接口进行存根化/模仿/伪造，以便依赖于它的其他类仍然可以进行单元测试。

## 真实世界的例子

在现代的 UI 代码中(如果你想让 UI 很爽快，永远不挂起)，当从一个异步事件或者从另一个线程回调回来的时候，有必要在 UI 线程上执行来更新 UI 元素。在 Xamarin 之前。Forms 提供了一个跨平台、集中的地方来运行 UI 线程中的代码块，下面是我所做的。

每个 Android 开发者都知道 a `MainActivity`是什么，它是从`Activity`派生出来的，它是从`Context`派生出来的，后两者包含了大量的方法，而前者是在你的控制之下的。通常，你会从你的活动中调用`void RunOnUIThread(Action action)`，但是你不想把你的`Activity`原样传递给每个人，因为它“有太多的访问权”。您可以简单地用与`RunOnUIThread`完全相同的方法签名创建一个接口`IRunOnUiThread`，并声明`MainActivity`实现了这个接口。你实际上不需要实现这个方法，因为它已经被继承了。如果您将您的`MainActivity`对象作为`IRunOnUiThread`传递给其他人，它只能访问那一个方法。

在 iOS 端，任何`NSObject`都可以调用`void BeginInvokeOnMainThread(Action action)`，因此您可以编写一个小类来实现`IRunOnUiThread`接口并包装`NSOjbect.BeginInvokeOnMainThread()`调用。

依赖注入对象实现任何 MVC 控制器的接口，瞧！您拥有平台无关的 UI 代码，可以在运行并发任务后回到 UI 线程上。它需要对`Activity`或`NSObjects`一无所知*。*

# 5.依存倒置原则

[依赖倒置原则](https://en.wikipedia.org/wiki/Dependency_inversion_principle)，有时被称为控制倒置，颠倒了典型的依赖图。它会让你更明确地考虑依赖设计和构成产品主干的长期对象的范围。

## 不要做什么

不要让你的类创建其他类的实例来提供它们自己的依赖——即使你的类是其他类的唯一依赖。这就是*看似无辜的*特性嫉妒代码味道产生的潜在原因，在极端情况下，这也是神级反模式产生的原因。

这个例子看起来并不特别过分；乍看之下很无辜，因为这里的一切都与保存有关`Things`(至少我们在这一点上使用了 SRP)

仔细观察，注意我们还创建了几个其他的实用程序类，它们不仅有可能被`OtherThingSaver`使用，而且依赖于真实环境或运行时，并会影响单元的可测试性。想象一下，当这种自我依赖解决模式到处都在使用，然后您开始跨不同的特性使用类。上面只是一个微妙的例子，但是在任何地方使用这种模式将保证你在几年后的大型项目中出现问题。

特性嫉妒(或对象嫉妒)是指当你调用的站点必须通过多个对象使用访问器来访问一个属性或方法。例如`foo = godObject.featureA.managerB.getFoo()`

当您开始需要将依赖项公开为公共属性，以便外部的其他类现在也可以依赖它时，就会出现这种情况。

**反模式
随着时间的推移，其他类将需要引用这些依赖项，以便访问它所封装的功能。鉴于它在对象层次结构中的位置非常高，授予其他人访问它的权限会被认为是潜在的滥用权力。**

当您采用上面的例子，并将它应用到更广的范围，跨特性时，就会发生这种情况。

## 取而代之做什么

不是一个类创建它自己的依赖项，而是让你的依赖项从外部进来。回到 SRP，`ThingSaver`不再有责任知道如何解决它自己的依赖性。而用 ISP，它并不关心需要哪些具体类型；只要它所依赖的接口得到满足。`ThingSaver`对其他职业了解得越少越好。

这也更加有利于单元测试。您可以挑选从您的`ThingSaverTests`内部传递到`ThingSaver`中的具体类型，在这里您可以练习使用 Liskov 替换来替换/模仿/伪造您的依赖项。

至于实例化所需的对象并将它们传递给 ThingSaver 构造函数，您可以使用`Factory Pattern`，或者更进一步…

## 进一步做什么

将依赖者的责任倒置是一个很好的第一步。那么你就有了另一个“现在谁拥有这个责任”的挑战。这就是反转控制容器的用武之地。

用容器，你用它注册一个接口或者类型，当稍后被询问时，它会返回你想要的类型。出于项目结构的目的，这个主题可以很容易地成为它自己的一篇文章，但是我可以给你的关于模式的关键提示是，每个特性库应该有它自己的 IoC“模块”来自注册特性的类型。

您的 head 项目将有一个模块自注册它自己的类型(比如注入到您的 MVC 控制器、`IUIThreadRunner`或其他特定于运行时的组件中的视图)。head 项目也将是开始通过所有特性的容器模块解析对象并将它们连接起来的地方。

您可以使用 head 项目来解析它在哪个平台上运行，并选择如何将特定于平台的位注册到容器中。好的一面是，您还可以将现有对象注册到容器中，或者提供一个在运行时返回实例的闭包。

这里要注意的重要一点是，您的应用程序可以有几个对象生存期范围。您还可以选择将对象作为容器范围内的单例对象，或者在需要解析类型的任何时候返回一个单独的实例。这是思考的开始，如果你以前没有给予足够的思考，这可能会很难。到目前为止，您的对象生命周期可能是临时的，而不是明确定义的。

幸运的是，大多数 IoC 容器支持嵌套或父子关系，但是这种关系只能以一种方式工作:在子作用域中，您可以解析位于父作用域中的依赖关系，但是因为父作用域比子作用域长，所以它不能解析来自父作用域的依赖关系。是否定义多个作用域取决于您自己的判断。

你几乎可以在任何 OOP 编程语言中找到 IoC 容器，可能大多数都是基于*构造函数注入*而不是*属性注入*，但是有些会支持两者。

## 还有什么不能做的

拥有一个理智的、可预测的对象依赖图的最大敌人之一是[单例类模式](https://hackernoon.com/singleton-pattern-the-root-of-all-evil-e4r3up7)。并不是说 singleton *instances* 本身就有什么问题；问题是创建实例化自身静态成员的类。

使用单例对象的类通常会对单元测试覆盖率不利。另一件事是，如果您有十几个引用 singleton 类的类，可能并不完全清楚 singleton 的生命周期何时改变——这完全取决于其最早的调用者——这可能会随着代码库的生命周期而改变。对于随时间携带状态的单例来说，这可能是不可预测性的来源。

幸运的是，可以使用可靠的原则重构单例类:可以将实例依赖注入到使用它的类中。在为了进行单元测试而必须用 Liskov 替换来替换 singleton 的情况下，也可以使用接口隔离。

# 超越实体:项目结构

一个产品的特性通常是在不同的组件下实现的，一些特性必须与另一个交互或依赖于另一个。根据编程语言的不同，无论你称它们为程序集、库、模块还是包，你都应该能够帮助你的依赖树的一部分变平，并减少循环依赖难题的机会。

每个特性可以由一个实现库和一个“[契约](https://en.wikipedia.org/wiki/Design_by_contract)”库组成。实现库将包含具体的类，这些类包含特性的实现。契约库将专门由接口、事件(或委托声明)、轻量级消息和与特性相关的类型支持组成。

一个功能库只对另一个功能的契约库感兴趣，目的是通过消息队列发出命令，从另一个功能订阅事件(使用命令查询责任分离)，并能够识别在这些事件中定义的类型。一个特性不会直接使用另一个特性的契约接口；这些接口旨在让 *head* 项目(包含主可执行文件)通过依赖反转来使用。这是实现低耦合和高内聚的好方法。

`FeatureA`库不会依赖于`FeatureB`库；这将取决于`FeatureBContracts`。如果`FeatureB`依赖`FeatureCContracts`，而`FeatureC`依赖`FeatureAContracts`，就不会有循环依赖。当你开始有几十个特征库的时候，你会很欣赏这一点。只有 head 项目需要直接引用特性的实现库。

这允许多个特性引用其他特性的接口，而不必依赖于其他特性的具体类型。一切都是基于需要知道的原则。只要接口满足契约(特性的客户可以从它那里得到什么)，提供实现就与客户无关。

# 最后的想法

坚实的设计原则帮助我成为一个更负责、更彻底、更有思想的开发人员。实践这些原则需要时间来学习，还需要一点额外的时间来精心编写代码，但是最终的结果是，从长远来看，投资会得到数倍的回报。

在较小的项目中使用 SOLID 可能会被认为是过度的架构，但是对于中等规模或更大规模的持久的多开发人员产品来说，它使得代码库有天壤之别。

然而，它不是万灵药；此外，还有其他很好的编程实践可以遵循——编写干净、可测试、持久的代码。以后关注我获取更多建议。