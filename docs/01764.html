<html>
<head>
<title>A Friendly Guide to Promise.all</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个友好的承诺指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-friendly-guide-to-promise-all-68e7cd57b65d?source=collection_archive---------4-----------------------#2020-01-28">https://levelup.gitconnected.com/a-friendly-guide-to-promise-all-68e7cd57b65d?source=collection_archive---------4-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="290e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">加速您的异步JavaScript</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/674601a94b3c3c1c346469b88b2292e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_GOeRBOqmwA4SypSxI1vg.png"/></div></div></figure><p id="6efb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我来说，这似乎是异步JS之旅的最后一步。首先你学习<a class="ae lq" href="https://medium.com/@mostlyfocusedmike/promises-promises-understanding-the-basics-of-js-promise-objects-dd5c656f2db4" rel="noopener">什么是承诺</a>，它让你<a class="ae lq" href="https://itnext.io/that-data-looks-so-fetching-on-you-understanding-the-js-fetch-api-880eae0c8d25" rel="noopener ugc nofollow" target="_blank">使用fetch </a>，然后你用async/await 清理<a class="ae lq" href="https://itnext.io/a-beginners-guide-to-async-await-in-javascript-97750bd09ffa" rel="noopener ugc nofollow" target="_blank">。但是在你的旅程中还有最后一个小问题:同时处理多个承诺。</a></p><h1 id="fbab" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">我们能重复一下承诺吗？</h1><p id="e8d3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">假设你想抓住一群特定的用户。你知道数组方法不能和 <code class="fe mo mp mq mr b"><a class="ae lq" href="https://dev.to/jhalvorson/how-do-i-use-async-await-with-array-map-1h3f" rel="noopener ugc nofollow" target="_blank">await</a></code>一起工作，但是你想:“不管怎样，我会遍历它们。”</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="fd1a" class="mw ls it mr b gy mx my l mz na"><em class="nb">const</em> <strong class="mr iu">specificUserIds</strong> = [...];<br/><em class="nb">for</em> (<em class="nb">let</em> <strong class="mr iu">i</strong> = 0; <strong class="mr iu">i</strong> &lt; <strong class="mr iu">specificUserIds</strong>.length; <strong class="mr iu">i</strong>++) {<br/>  <em class="nb">const</em> <strong class="mr iu">user</strong> = <em class="nb">await</em> <strong class="mr iu">User</strong>.getOne(<strong class="mr iu">specificUsers</strong>[<strong class="mr iu">i</strong>];<br/>  ...</span></pre><p id="d20a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可惜的是，在短绒喊声中，<a class="ae lq" href="https://eslint.org/docs/rules/no-await-in-loop" rel="noopener ugc nofollow" target="_blank"> <em class="nb">没有</em> </a> <code class="fe mo mp mq mr b"><a class="ae lq" href="https://eslint.org/docs/rules/no-await-in-loop" rel="noopener ugc nofollow" target="_blank"><em class="nb">await</em></a></code> <a class="ae lq" href="https://eslint.org/docs/rules/no-await-in-loop" rel="noopener ugc nofollow" target="_blank"> <em class="nb">出现了一个for循环！</em> </a>“然而，这是一个“性能”问题，有时人们过于关心性能<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/dear-for-loop-fans-let-us-use-array-methods-in-peace-af851ca9e85f"/>，你能忽略这个警告吗？</p><h1 id="784c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">号码</h1><p id="5b5f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">性能牺牲太大，真是<em class="nb">严重</em>打击。为了演示，让我们假设api需要0.2秒的响应时间，并且您想要6个用户。用<code class="fe mo mp mq mr b">Promise.all</code>，大概需要0.2秒。使用<code class="fe mo mp mq mr b">for</code>循环？现在需要一秒多的时间，你自己看:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="4732" class="mw ls it mr b gy mx my l mz na"><em class="nb">const</em> <strong class="mr iu">getUser</strong> = (<strong class="mr iu">id</strong>) =&gt; <em class="nb">new</em> <strong class="mr iu">Promise</strong>(<br/>  (<strong class="mr iu">resolve</strong>) =&gt; <strong class="mr iu">setTimeout</strong>(() =&gt; <strong class="mr iu">resolve</strong>({<strong class="mr iu">id</strong><strong class="mr iu">}</strong>), 200)<br/>);</span><span id="8d7b" class="mw ls it mr b gy nc my l mz na">const <strong class="mr iu">specificIds</strong> = [1, 2, 3, 4, 5, 6];</span><span id="9848" class="mw ls it mr b gy nc my l mz na"><em class="nb">const</em> <strong class="mr iu">loop</strong> = <em class="nb">async</em> () =&gt; {<br/>  const <strong class="mr iu">users</strong> = [];<br/>  <em class="nb">for</em> (<em class="nb">let</em> i = 0; <strong class="mr iu">i</strong> &lt; <strong class="mr iu">specificIds</strong>.length; <strong class="mr iu">i</strong>++) {<br/>    const <strong class="mr iu">user</strong> = <em class="nb">await</em> <strong class="mr iu">getUser</strong>(<strong class="mr iu">i</strong>);<br/>    <strong class="mr iu">users</strong>.push(<strong class="mr iu">user</strong>);<br/>  }<br/>  <strong class="mr iu">console</strong>.log('<em class="nb">loop done</em>');<br/>};</span><span id="8718" class="mw ls it mr b gy nc my l mz na">const <strong class="mr iu">all</strong> = <em class="nb">async</em> () =&gt; {<br/>  <em class="nb">const</em> <strong class="mr iu">promises</strong> = <strong class="mr iu">specificIds</strong>.map((<strong class="mr iu">id</strong>) =&gt; getUser(id));<br/>  <em class="nb">const</em> <strong class="mr iu">users</strong> = <em class="nb">await</em> Promise.all(<strong class="mr iu">promises</strong>);<br/><strong class="mr iu">  console</strong>.log('<em class="nb">.all done</em>');<br/>};</span><span id="6f54" class="mw ls it mr b gy nc my l mz na"><strong class="mr iu">loop</strong>();<br/><strong class="mr iu">all</strong>();</span></pre><p id="f7ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除非每个连续的承诺<strong class="kw iu">需要</strong>前一个解析值，否则您应该使用<code class="fe mo mp mq mr b">Promise.all</code>。</p><h1 id="7c94" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">为什么会快这么多？</h1><p id="cb88" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><code class="fe mo mp mq mr b">await</code>的伟大之处也在于它的失败:它让我们的代码<em class="nb">等待</em>:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="7acf" class="mw ls it mr b gy mx my l mz na"><em class="nb">const</em> <strong class="mr iu">user</strong> = <em class="nb">await</em> <strong class="mr iu">User</strong>.getOne(<strong class="mr iu">params</strong>.userId);<br/><em class="nb">const</em> <strong class="mr iu">username</strong> = <strong class="mr iu">user</strong>.name;</span></pre><p id="edeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mo mp mq mr b">user</code>对象解析之前，我们实际上<em class="nb">不能</em>分配用户名。在这种情况下，我们<em class="nb">需要</em>等待，这是逻辑的一部分。然而，当我们从数据库加载一群不相关的用户时，情况就不一样了。在加载用户2之前，没有任何实际理由等待用户1完全加载。这意味着我们可以解决<em class="nb">并行</em>中的承诺，整个事情只需要最慢的承诺，而不是所有承诺的总和。</p><h1 id="8b28" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">承诺.一切都解释清楚了</h1><p id="4385" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们在前面看到了它的作用，但是<code class="fe mo mp mq mr b">Promise.all</code>背后的思想是，我们将所有被调用的，但是<strong class="kw iu"> <em class="nb">未解析的</em> </strong>承诺捆绑到一个数组中，然后<code class="fe mo mp mq mr b">.all</code>获取它们，并在<em class="nb">并行</em>中等待它们的所有解析，直到最后按照<strong class="kw iu">原始数组的顺序解析一个数组的值。</strong></p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="64ff" class="mw ls it mr b gy mx my l mz na"><em class="nb">1|</em> const <strong class="mr iu">specificUserIds</strong> = [1, 3, 4, 7];<br/><em class="nb">2|</em> <br/><em class="nb">3| const</em> <strong class="mr iu">promises</strong> = <strong class="mr iu">specificUserIds</strong>.map(<br/><strong class="mr iu">4|</strong>   <strong class="mr iu">id</strong> =&gt; <strong class="mr iu">User</strong>.getOne(<strong class="mr iu">id</strong>),<br/><em class="nb">5|</em> );<br/><em class="nb">6|</em> <br/><em class="nb">7|</em> const <strong class="mr iu">specificUsers</strong> = <em class="nb">await</em> <strong class="mr iu">Promise</strong>.all(<strong class="mr iu">promises</strong>);<br/>// specificUsers is:<br/>// [<br/>//   { id: 1 },<br/>//   { id: 3 },<br/>//   { id: 4 },<br/>//   { id: 7 },<br/>// ]</span></pre><p id="6981" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，我们不是在<code class="fe mo mp mq mr b">line 4</code>对承诺进行<code class="fe mo mp mq mr b">await</code>或<code class="fe mo mp mq mr b">.then</code>，我们只是将调用的承诺传递到我们的<code class="fe mo mp mq mr b">promises</code>数组中。还有别忘了<code class="fe mo mp mq mr b">await</code>这个<code class="fe mo mp mq mr b">Promise.all</code>！</p><blockquote class="nd ne nf"><p id="f58c" class="ku kv nb kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">promises[0]可能不会先<strong class="kw iu"> <em class="it">解析</em> </strong>，但其解析值<strong class="kw iu"> <em class="it">将始终为</em> </strong> specificUsers[0]</p></blockquote><h1 id="78d9" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">处理拒绝</h1><p id="c270" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们有6个承诺，但如果一个(或更多)拒绝呢？整个事情失败了:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="3f12" class="mw ls it mr b gy mx my l mz na">const promises = [<br/>  new Promise((resolve) =&gt; setTimeout(() =&gt; resolve('ok'), 100)),<br/>  new Promise((r, reject) =&gt; setTimeout(() =&gt; reject('bad'), 300)),<br/>]</span><span id="706b" class="mw ls it mr b gy nc my l mz na">Promise.all(promises)<br/>  .catch(console.log); <br/>// logs out the string: 'bad'</span></pre><p id="1578" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使被拒绝的承诺在好的之后<em class="nb">解决，<code class="fe mo mp mq mr b">Promise.all</code>也不在乎。我们只得到<em class="nb">单个</em>剔除值，需要用一个<code class="fe mo mp mq mr b">.catch </code>或者一个<code class="fe mo mp mq mr b">await</code>和<code class="fe mo mp mq mr b">try/catch</code>来处理。</em></p><h1 id="08aa" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">接受拒绝</h1><p id="09f1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果我们想要数组，不管失败与否，那么我们需要<code class="fe mo mp mq mr b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" rel="noopener ugc nofollow" target="_blank">Promise.allSettled</a></code>。该函数返回一个由<em class="nb">对象、</em>和<code class="fe mo mp mq mr b">status</code>键组成的数组:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="20ad" class="mw ls it mr b gy mx my l mz na"><em class="nb">const</em> <strong class="mr iu">promises</strong> = [<br/>  <em class="nb">new</em> <strong class="mr iu">Promise</strong>((<strong class="mr iu">resolve</strong>) =&gt; <strong class="mr iu">setTimeout</strong>(() =&gt; <strong class="mr iu">resolve</strong>('<em class="nb">ok</em>'), 100)),<br/>  <em class="nb">new</em> <strong class="mr iu">Promise</strong>((<strong class="mr iu">r</strong>, <strong class="mr iu">reject</strong>) =&gt; <strong class="mr iu">setTimeout</strong>(() =&gt; <strong class="mr iu">reject</strong>(new Error('<em class="nb">bad</em>')), 300)),<br/>]</span><span id="2967" class="mw ls it mr b gy nc my l mz na">const <strong class="mr iu">values</strong> = <strong class="mr iu">Promise</strong><br/>  .<strong class="mr iu">allSettled</strong>(promises) <br/>  .<strong class="mr iu">then</strong>(console.log)<br/>//logs:<br/>//[ <br/>//  <!-- -->{status: ”fulfilled”, value: ”ok},<br/>//  {status: ”rejected”, reason: Error "bad"} <br/>//]</span></pre><h1 id="c35d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">承诺数组到承诺数组</h1><p id="1648" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><code class="fe mo mp mq mr b">Promise.all</code>看起来有点不靠谱，因为它打破了你大概<em class="nb">刚</em>学完的<code class="fe mo mp mq mr b">await</code>风格。但是您所做的只是将一堆承诺放入一个数组，然后使用一个特殊的函数来跟踪它们的返回值。每当你发现自己有不连续的承诺时，这是一个完美的工具。</p><p id="75aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="5501" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>