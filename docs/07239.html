<html>
<head>
<title>A 1000 Foot Overview of Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从1000英尺的高度俯瞰库伯内特斯</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-1000-foot-overview-of-kubernetes-c00e410b1983?source=collection_archive---------14-----------------------#2021-02-02">https://levelup.gitconnected.com/a-1000-foot-overview-of-kubernetes-c00e410b1983?source=collection_archive---------14-----------------------#2021-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b9a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么它是部署和管理软件的新标准</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/98e835adac456ab74c518b877dbb07b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YECeOxlko9KoOJNw8RNm3A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">艾莉娜·格鲁布尼亚克在<a class="ae ky" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a5d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是由Google开发的开源编排工具(它是他们的<a class="ae ky" href="https://en.wikipedia.org/wiki/Borg_(cluster_manager)" rel="noopener ugc nofollow" target="_blank"> Borg </a>项目的一个分支),用于跨分布式节点集群管理微服务或容器化应用。正如kubernetes.io解释的那样，</p><blockquote class="lv lw lx"><p id="7ee1" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">Kubernetes是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便了声明式配置和自动化</p></blockquote><p id="b02c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入挖掘之前，首先理解为什么要引入Kubernetes是很重要的。</p><h1 id="3b70" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">那么，为什么是Kubernetes？</h1><p id="2796" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在过去，软件部署艰难、耗时且成本高昂。这主要是因为我们需要根据这些应用程序的需求购买大量的物理机。几年后，虚拟化变得非常普遍，并允许共享CPU和内存。这节省了一些成本，因为一个强大的裸机服务器可以托管多台机器。在现代，机器可以被分割成比虚拟服务器更小的部分，称为容器。这是虚拟机与容器的区别:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/d95092e02d4347aea072d1e0bab984f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0YFHUtWUblMrfXzEZwN2Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">虚拟机与容器。作者图片</figcaption></figure><p id="a095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，容器为应用程序启用了虚拟操作系统。通过Linux内核特性，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Cgroups" rel="noopener ugc nofollow" target="_blank"> cgroups </a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Chroot" rel="noopener ugc nofollow" target="_blank"> chroot </a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/UnionFS" rel="noopener ugc nofollow" target="_blank"> UnionFS </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="noopener ugc nofollow" target="_blank">名称空间</a>，容器能够实现文件系统、进程和网络隔离。这意味着您只需为一台物理主机付费，安装一个操作系统，并运行您的硬件所能处理的尽可能多的容器。减少您需要在同一台主机上运行的操作系统数量意味着更少的存储、内存和CPU浪费。</p><p id="0506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种在同一个操作系统上以容器(或流程)的形式运行完整服务的能力是革命性的。Docker是2010年推出的一款产品，利用容器进行软件部署。但它也带来了一些其他需要解决的问题:</p><ol class=""><li id="6f70" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">在这种基于微服务的架构中，通过添加容器来添加功能非常简单，但管理起来却很麻烦。</li><li id="741f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">升级时，您需要确保不会导致整个应用程序停止运行。相反，我们需要一种方法来以受控和系统化的方式进行升级，确保应用程序始终处于运行状态。手动操作既复杂又容易出错</li><li id="560d" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">为了实现高可用性，您需要为每个组件创建多个容器。这就产生了谁来响应客户请求的问题。</li><li id="cbf0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">负载平衡</li><li id="9b18" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">集装箱崩溃时的恢复</li><li id="65b2" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">其他问题，如向适当的主机分发容器、发现、流量路由等。</li></ol><p id="4aa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些问题都需要一个指挥者。库伯内特斯出场了。Kubernetes为您完成所有的编排工作，比如容器调度、容器管理、管理服务端点等。让我们不要深入了解库伯内特斯的成分</p><h1 id="23e2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">容器</h1><p id="f954" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">虽然解释得有点早，但让我试着详细解释一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/135fe2bc2520e2ffdf0fbafcb8754fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*opNYVi9zQMqkNKUWLEjodA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">集装箱。作者图片</figcaption></figure><p id="5ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器提供了一种逻辑打包机制，应用程序可以从它们实际运行的环境中抽象出来。这种分离允许基于容器的应用程序被容易地、一致地部署，而不考虑目标机器。它包含所需的代码和任何运行时、应用程序和系统库，以及任何重要设置的默认值。</p><h1 id="d029" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分离舱</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/904e31e188bb22b5b01c7cac20e9c39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*EndsTPo1F3hVlpOn1sHUsg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">荚的例子。作者图片</figcaption></figure><p id="7bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pod封装了一个或多个相关的容器，是可以在集群中部署和管理的最小单元。pod中的容器共享端口号、Linux内核名称空间和网络堆栈设置。容器可以很容易地与同一个pod中的其他容器通信，就像它们在同一台机器上一样，同时保持与其他容器的一定程度的隔离。</p><p id="745c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们可以在一个pod中有多个容器，但是最佳实践是尽可能少地捆绑。因为单元是作为一个单元向上和向下扩展的，所以单元中的所有容器必须一起扩展，而不管它们各自的需求。这可能会造成资源浪费。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="2168" class="nv md it nr b gy nw nx l ny nz">kubectl get all</span><span id="dfa1" class="nv md it nr b gy oa nx l ny nz">NAME         READY     STATUS    RESTARTS   AGE<br/>pod/PodA     1/1       Running   0          2d21h <em class="ly"># 1 container</em><br/>pod/PodB     2/2       Running   0          2d21h <em class="ly"># 2 containers</em></span></pre><p id="03aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现高可用性和容错，建议为同一个pod创建多个副本(或复制品)。Kubernetes可以配置为在必要时部署pod的新副本。</p><p id="586b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然可以独立部署pod，但不建议直接部署pod。相反，建议使用<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>等工作负载资源来创建它们</p><h1 id="9eac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署</h1><p id="2306" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">部署是描述应用程序生命周期的控制类型，例如应用程序使用哪些图像，应该有多少个窗格，以及更新它们的方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6dd43a63442862748514c3d8b4e03776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*Hui5P8D3s_ZMJmFxCcMt9w.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">部署。作者图片</figcaption></figure><p id="d0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">手动更新<a class="ae ky" href="https://www.redhat.com/en/topics/containers/what-is-kubernetes-deployment" rel="noopener ugc nofollow" target="_blank">容器化应用</a>的过程可能会非常耗时和乏味。将服务升级到下一个版本需要启动新版本的pod，停止旧版本的pod，等待并验证新版本是否已成功启动，并且有时在失败的情况下将其全部回滚到以前的版本。</p><p id="8a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">手动执行上述步骤可能会导致人为错误，而正确地编写脚本可能需要大量的工作，这两者都可能使发布过程成为瓶颈。部署通过协调这些步骤来帮助管理这些问题。</p><h1 id="9081" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">卷</h1><p id="998b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以将卷视为pod中的容器可以访问的目录。主要有两种基本类型的卷:</p><p id="5bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">短命<br/> </strong>短命卷种类有一生一个荚。因此，当pod崩溃时，该卷中的所有数据都会丢失。如果您打算管理一个有状态的pod(像一个数据库)，您需要在重启和崩溃之间持久化数据。</p><p id="e85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">持久卷</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/78ed3a57de13f4d64dd276e47c80e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*zgiuMxz0B-qPWS74jxFNag.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">持久卷。作者图片</figcaption></figure><p id="61f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，这些数据在pod重新启动后保持不变，并且存在于pod的生命周期之外。这可以被认为是使用外部硬盘进入集群。当一个pod出现故障时，卷完好无损，新的pod会出现并挂接到同一个卷。这就是所谓的pod粘性，当跨重新调度的pod需要一个持久标识符时，通常使用<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank">有状态集</a>(类似于部署)。</p><h1 id="9104" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">服务</h1><p id="f591" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">服务可以被定义为一组逻辑单元，并且是单元顶部的抽象，它提供了可以访问单元的单个IP地址和DNS名称。依赖于POD IP不是一个非常好的主意，因为它会在每次POD重新启动时改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ed038f558d622e637d3cf99410c1e775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*4PfHyvZKJNv--Bl02_C0Ew.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Kubernetes的服务。作者图片</figcaption></figure><p id="0991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在ServiceSpec中指定类型，可以以不同的方式公开服务:</p><ol class=""><li id="32f2" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><strong class="lb iu">集群IP </strong>:【默认】在集群的内部IP上公开服务</li><li id="b829" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">节点端口</strong> —使用NAT在集群中每个选定节点的同一端口上公开服务</li><li id="6387" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">负载平衡器</strong> —与云提供商一起创建外部负载平衡器，并将外部IP分配给服务和LB</li><li id="cfa0" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><strong class="lb iu">外部名称</strong> —将服务映射到DNS名称。使pods能够使用非容器化服务</li></ol></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="131d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上是Kubernetes及其基本组件的1000英尺视图。这是一个简化的版本，但应该足够好开始。了解这些基本成分将有助于更深入地了解Kubernetes。</p><p id="b256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多信息，最简单的方法是在本地安装Kubernetes，然后到处玩。以下内容应该会有很大帮助:</p><div class="ol om gp gr on oo"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-use-kubernetes-and-minikube-to-set-up-a-relational-database-locally-1ea04ba6cb7f"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">如何使用Kubernetes和Minikube在本地建立关系数据库</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">一步一步的过程中，所有的例子</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div></div></div>    
</body>
</html>