<html>
<head>
<title>Migrating From WCF to gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从WCF迁移到gRPC</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/migrating-from-wcf-to-grpc-69464adc8140?source=collection_archive---------4-----------------------#2020-03-27">https://levelup.gitconnected.com/migrating-from-wcf-to-grpc-69464adc8140?source=collection_archive---------4-----------------------#2020-03-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="bc8b" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">并在Node.js客户端和C# Windows服务之间进行跨平台通信</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/7676ee9e542b6e063c0eda927c8abeb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wvEgABVtqatE4wOsRiN-w.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">加里·本迪格在<a class="ae kz" href="https://unsplash.com/s/photos/migrate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c9fb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">微软Windows通信基金会(WCF)一直是我在Windows上的首选通信框架。</p><p id="4fa8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我喜欢通过配置来改变协议和格式。</p><ul class=""><li id="cc02" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">您是否需要与其他系统和语言的最广泛的互操作性？您使用WsHttpBinding。</li><li id="92f0" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">同一台机器上的两个进程之间需要最高速度吗？您使用NetNamedPipeBinding。</li></ul><p id="7fc3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，令我遗憾的是，微软没有将WCF迁移到。Net核心平台。的。Net核心平台是跨平台的，微软将WCF与Windows操作系统紧密耦合。这种紧密的耦合使它们很难迁移WCF。</p><p id="ae47" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我将描述我如何以及为什么从WCF迁移到gRPC。由于gRPC是跨平台的，我将展示一个在. Net核心服务和Node.js客户端之间通信的例子。</p><p id="2216" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我使用Visual Studio 2019来创建ASP.Net核心gRPC服务和Node.js客户端的Visual Studio代码。</p><p id="0e85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在文章的最后，我将列出gRPC的替代方案。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="bda9" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">你为什么要移民？</h1><p id="1cba" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">离开WCF的原因很简单。<a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/standard/choosing-core-framework-server" rel="noopener ugc nofollow" target="_blank">微软推荐</a>使用。Net核心为所有新的应用程序开发。作为微软。Net Core不支持WCF，你必须迁移。</p><p id="6a71" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以决定根本不迁移，继续使用Microsoft。Net框架。一个有效的选择，但你不会帮你自己。微软在未来的投资。网会在。网芯。</p><p id="04b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">微软<a class="ae kz" href="https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/" rel="noopener ugc nofollow" target="_blank">推荐</a> gRPC作为WCF的替代品。网芯。</p><p id="fa80" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有其他选择吗？是的，您可以使用HTTP APIs或Websockets。但是请注意，HTTP APIs的性能较差，Websockets需要手动进行消息序列化。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="9e8a" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">WCF和gRPC有什么区别？</h1><p id="88a7" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">WCF和gRPC之间最显著的区别在于以下几个方面:</p><ul class=""><li id="a7bd" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">接口定义</li><li id="a7ef" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">协议和格式</li><li id="aedd" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">错误处理</li><li id="ad2b" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">安全性</li></ul><h2 id="32c8" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">接口定义</h2><p id="8da1" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">使用WCF，你可以通过一个C#接口来描述你的服务接口。WCF服务器在运行时通过反射生成WSDL。客户端生成器使用WSDL为服务创建客户端。</p><p id="fba6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">gRPC使用协议缓冲区来描述接口。所以，你必须使用这个协议缓冲定义语言来定义你的通信接口。你必须将它存储在一个<code class="fe oa ob oc od b">.proto</code>文件中。有各种各样的生成器可以使用<code class="fe oa ob oc od b">.proto</code>文件来生成客户机和服务器存根。</p><p id="d1dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">协议缓冲区是一种自定义语言。这使得gRPC独立于一个平台和语言。每个平台和语言都可以开发生成器来生成客户端和服务存根。</p><h2 id="fa6c" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">协议和格式</h2><p id="21a0" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">通过WCF，您可以使用配置来选择不同的通信协议和格式。例如，HTTP、TCP、MSMQ或命名管道。使用绑定来指定协议和格式，例如NetTcp绑定。</p><p id="32ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">gRPC使用HTTP/2作为网络协议和二进制消息格式。gRPC提供与WCF NetTcp绑定相同的速度和效率。在某些情况下，甚至更高的速度。</p><h2 id="be7e" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">错误处理</h2><p id="5365" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">使用WCF，您可以使用<code class="fe oa ob oc od b">FaultException&lt;TDetail&gt;</code>来提供符合SOAP错误标准的错误信息。</p><p id="2f76" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">gRPC没有这种扩展的错误处理。gRPC使用状态代码和元数据。下表显示了最常用的状态代码。</p><ul class=""><li id="79e0" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><code class="fe oa ob oc od b">GRPC_STATUS_UNIMPLEMENTED</code>该方法尚未实施</li><li id="5322" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe oa ob oc od b">GRPC_STATUS_UNAVAILABLE</code>服务出现一般性问题，不可用。</li><li id="f402" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe oa ob oc od b">GRPC_STATUS_INTERNAL</code>服务在编码/解码消息时出现问题。</li><li id="219a" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe oa ob oc od b">GRPC_STATUS_UNAUTHENTICATED</code>服务器上的认证失败</li><li id="4e95" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe oa ob oc od b">GRPC_STATUS_PERMISSION_DENIED</code>客户端无权执行请求的操作</li><li id="64ac" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><code class="fe oa ob oc od b">GRPC_STATUS_CANCELLED</code>客户取消了通话</li></ul><h2 id="dafd" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">安全性</h2><p id="99da" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">有了WCF，你有很多安全选项。您希望使用消息级加密还是值加密？您想要哪种身份验证？活动目录集成、Kerberos、LDAP等。</p><p id="cb4f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">gRPC使用HTTP/2。尽管可以在HTTP/2上使用未加密的数据，但所有主流浏览器都只支持TLS上的HTTP/2。所以HTTP/2将总是使用TLS加密。gRPC也会。</p><p id="d082" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以使用客户端和服务器证书进行身份验证。如果想使用调用级授权，可以使用令牌，例如JSON Web令牌(JWT)。</p><p id="4000" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们来看看什么是gRPC。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="d11c" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">gRPC是什么？</h1><p id="4916" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">通用远程过程调用(gRPC)是Google最初开发的一个<a class="ae kz" href="https://github.com/grpc" rel="noopener ugc nofollow" target="_blank">开源</a>通信框架。不，g不代表谷歌。它使用Google的协议缓冲区来描述通信接口。</p><p id="3c06" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">协议缓冲区是一种用于序列化数据的跨平台机制。</p><p id="549c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您必须在. proto文件中描述通信接口。的。proto文件包含所有消息类型的定义。gRPC包括许多不同语言的生成器，例如:</p><ul class=""><li id="5693" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">Java 语言(一种计算机语言，尤用于创建网站)</li><li id="2bb6" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">计算机编程语言</li><li id="b1d7" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">目标-C</li><li id="97a9" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">C++</li><li id="7f19" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">镖</li><li id="ed96" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">去</li><li id="7160" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">红宝石</li><li id="c719" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">C#</li></ul></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="b49e" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">gRPC示例</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/70a70b9d3a49472f1c430f2617ba69cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHaWqzITWnNhMBO2IJOSVw.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@ptrikutam?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pavan Trikutam </a>在<a class="ae kz" href="https://unsplash.com/s/photos/communication?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1f04" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看一个例子。的。下面的proto文件定义了一个名为Graph DefinitionService的服务。该服务包含两种方法。一个用于检索单个图形定义，另一个用于读取所有图形定义。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="of og l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">GraphDefinitionService.proto</figcaption></figure><p id="6cc9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一行定义了您想要使用的原型的<code class="fe oa ob oc od b">syntax </code>。有两个版本可用，“proto2”和“proto3”。我推荐使用版本3，因为它支持更多的语言。</p><p id="eba4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第三行包含一个<code class="fe oa ob oc od b">option</code>语句。这些陈述是特定于一种语言的。在这种情况下，对于C#，所以当使用java生成器时，<code class="fe oa ob oc od b">charp_</code>选项被忽略。</p><p id="86fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第五行中的<code class="fe oa ob oc od b">package </code>定义是必不可少的。它定义了服务的名称。</p><h2 id="2859" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">服务方法</h2><p id="09df" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">第七行的<code class="fe oa ob oc od b">service</code>语句启动了将在您的服务中可用的方法。每种方法都以<code class="fe oa ob oc od b">rpc</code>开头。您可以将此与WCF服务的OperationContract进行比较。</p><p id="d8cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">gRPC服务上的每个方法都接受一条消息并返回一条消息。不可能只有一个整数参数或返回一个空值。</p><h2 id="fd3d" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">消息定义</h2><p id="a8fc" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">消息定义以关键字message开始。例如，在第12行中，定义了消息GetRequest。该消息包含一个名为int32类型的graphDefinitionId的字段。</p><p id="0e38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">协议缓冲区支持多种本机数据类型，如int32、double和string。没有可用的UUID数据类型的本机GUID，我经常将它用作ID字段。解决这个问题的最好方法是使用字符串。</p><p id="beaf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在消息定义中的每个字段之后，都有一个唯一的编号。这个数字标识二进制消息中的字段。因此，如果您的消息类型正在使用中，您应该分配一个号码，并且永远不要更改它。</p><p id="8b8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即使不再需要某个字段，也可以删除该字段，但不应该重用字段号。留空隙就好。</p><h2 id="0cbd" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">创建gRPC服务</h2><p id="f19f" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">虽然可以使用Visual Studio代码创建gRPC服务，但我将使用Visual Studio 2019。Visual Studio 2019让这个过程变得简单多了。</p><p id="4856" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Visual Studio包含一个用于创建gRPC服务的项目模板。此模板生成ASP.NET核心3.1项目。它包含一个服务和一个示例<code class="fe oa ob oc od b">.proto</code>文件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/065b5469f4bd29555b38a744e4731035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YcSdUM4__v6okO9Cq5MF9g.png"/></div></div></figure><p id="460a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Visual Studio在构建期间用虚方法将<code class="fe oa ob oc od b">.proto</code>文件翻译成C #分部类。您可以从这些分部类派生，并通过重写来实现服务方法。有关GraphDefinitionService的示例实现，请参见下文。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="of og l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">图形定义服务. cs</figcaption></figure><p id="ae1b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">完整的解决方案可在<a class="ae kz" href="https://github.com/PatrickKalkman/WCF2gRPC" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h2 id="f8bb" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">创建. Net核心gRPC客户端</h2><p id="77d7" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">我先用Visual Studio 2019创建一个gRPC客户端。我使用一个. Net核心控制台项目。</p><p id="c43d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后使用Visual Studio中的包管理器控制台安装以下Nuget包。</p><ul class=""><li id="3ba2" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">安装包Grpc。Net客户端</li><li id="b4cc" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">安装包谷歌。原蟾蜍</li><li id="60a6" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">安装包Grpc。工具</li></ul><p id="df55" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将GraphDefinitionService.proto复制或链接到客户端程序。选择原型文件并设置正确的编译属性。确保gRPC子类属性仅适用于客户端。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oi"><img src="../Images/6aae03a01b79fa2cbf26a5e7e75fdc1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YVaUyopkI9ckWNYQm_97QA.png"/></div></div></figure><p id="1314" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的程序连接到GraphDefinitionService gRPC服务并调用<code class="fe oa ob oc od b">GetAsync </code>方法。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="of og l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">GraphDefinitionService的C# gRPC客户端</figcaption></figure><h2 id="e82e" class="no ms iu bd mt np nq dn mx nr ns dp nb lj nt nu nd ln nv nw nf lr nx ny nh nz bi translated">创建Node.js gRPC客户端</h2><p id="6896" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">为了展示跨平台能力，我还实现了一个Node.js gRPC客户端。</p><p id="6b5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Node.js客户端需要以下两个NPM包。</p><p id="4398" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe oa ob oc od b">npm install grpc @grpc/proto-loader</code></p><p id="850c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它还需要访问<code class="fe oa ob oc od b">graphdefinitionservice.proto</code>文件，以便能够生成存根类。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="of og l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">Node.js gRPC客户端</figcaption></figure><p id="3a94" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与C#不同，Node.js gRPC库在运行时生成通信存根。在第16行，加载了proto文件，Node.js生成了一个存根。客户机在第18行创建了到服务的实际连接。</p><p id="f5bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第23行，客户端实际调用服务。完整的源代码可以在<a class="ae kz" href="https://github.com/PatrickKalkman/WCF2gRPC" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="e6c4" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">从WCF迁移到gRPC</h1><p id="c343" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">gRPC可以是WCF的一个很好的替代品。但是由于你可能在WCF服务上投入了大量的时间和精力。您可能对自动迁移您的WCF服务的可能性感兴趣。</p><p id="854d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="http://www.visualreco.com/" rel="noopener ugc nofollow" target="_blank"> Visual ReCode </a>是一个商业Visual Studio插件，可以帮助您将WCF服务迁移到gRPC。Visual ReCode扫描解决方案中的项目，并通过扫描<code class="fe oa ob oc od b">[OperationContract]</code>属性来搜索所有WCF接口。</p><p id="ad71" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，您可以选择要迁移的WCF接口。选择后，它为每个接口创建:</p><ul class=""><li id="e713" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">基于原始WCF接口的原型文件</li><li id="c6b3" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">实现原型文件并调用原始代码的gRPC服务</li><li id="9426" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">能够调用gRPC服务的所有方法的gRPC客户端。</li></ul><p id="75fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管如此，你还是需要做一些手工工作。但是如果你需要迁移大量的WCF服务，我建议你去看看Visual ReCode。有试用版。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="3b7f" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">结论和替代方案</h1><p id="feb4" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">在这篇文章中，我们看到微软不支持WCF。网芯。您可以使用gRPC，它是创建高速服务的有效替代方法。其他选项有基本的HTTP APIs和Websockets。</p><p id="a3c8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们实现了一个gRPC ASP。NET核心服务和Node.js客户端。该源代码可在<a class="ae kz" href="https://github.com/PatrickKalkman/WCF2gRPC" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="f528" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您想将WCF服务迁移到gRPC，您可以手动完成或使用工具。尤其是如果你有很多WCF服务，像Visual ReCore这样的工具会有所帮助。</p><p id="2438" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我之前没有提到的WCF的另一个选择是T2核心WCF T3。核心WCF是Windows通信框架(WCF)的一个开源端口。网芯。目前，它还不能用于生产。但在未来，它可能是一个可以运行WCF服务的替代品。网芯。</p><p id="7968" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在您开始将您的WCF服务转换为gRPC之前，我想分享两件事。在撰写本文时，还不能在IIS中运行gRPC。IIS不支持HTTP/2。</p><p id="f624" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Azure App服务也是如此。他们使用IIS，所以还不支持gRPC。我怀疑微软会在今年晚些时候增加支持。</p><p id="dc91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读，并保持安全。</p></div></div>    
</body>
</html>