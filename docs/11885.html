<html>
<head>
<title>UML in C Language — Class Diagrams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C语言中的UML类图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/uml-in-c-language-class-diagrams-6ed11aa34d9b?source=collection_archive---------0-----------------------#2022-04-25">https://levelup.gitconnected.com/uml-in-c-language-class-diagrams-6ed11aa34d9b?source=collection_archive---------0-----------------------#2022-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/45095d0f33f61c4a4cbbf370264afe4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GlJWHe-blPJO5pi43iBZoQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="f644" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">将类图翻译成C源代码。</h2></div><p id="026d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi lm translated">写软件需要创造力和方法。虽然确实应该避免过度工程化，但另一方面，在没有任何路线图的情况下乱搞代码很可能会使我们的项目走上危险的道路。<br/>这就是为什么每个程序员都应该在他们的工具箱中包含一些通用的(然而强大的)软件工程技术，其中最著名的可能是面向对象编程。</p><p id="fb72" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">许多天生支持OOP的语言确实存在。然而，在一些现实世界的场景中，我们没有为给定的软件系统选择编程语言的特权:遗留的嵌入式系统就是这种情况，它们通常是用普通的C语言编写的，这是一种所谓的“过程化”或“结构化”语言。</p><h2 id="33ae" class="lv lw jb bd lx ly lz dn ma mb mc dp md kz me mf mg ld mh mi mj lh mk ml mm mn bi translated"><em class="mo">今天讨论的目的是提供关于如何根据C程序中的类进行推理的基本概念，以及如何使用标准UML(统一建模语言)类图静态地表示您的软件。</em></h2></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="2180" class="mw lw jb bd lx mx my mz ma na nb nc md kh nd ki mg kk ne kl mj kn nf ko mm ng bi translated">什么是类图？</h1><p id="9131" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di">一个</span>类图是一个系统的静态<em class="nm">表示。因此，它侧重于一个软件模块的形状，但它并没有告诉一个系统的逻辑。换句话说，我们通常在类图中发现的是一个系统所做的事情的综合。它不包含(或包含很少)关于<em class="nm">如何实现</em>功能的信息。</em></p><h1 id="61a9" class="mw lw jb bd lx mx nn mz ma na no nc md kh np ki mg kk nq kl mj kn nr ko mm ng bi translated">我们为什么要关心这个？</h1><p id="adba" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di">作为</span>软件工程师，我们迟早会意识到OOP并不真的是关于<em class="nm">“通过软件表示真实世界的对象”。相反，面向对象设计是一种使软件尽可能灵活和可维护的方法，通过将系统分割成具有明确职责的子模块，并让它们相互作用来实现所需的功能。</em></p><p id="e191" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">类图帮助我们在深入实现的本质(即编写代码)之前对我们的软件架构进行推理。这种表示清楚地显示了子模块是什么，简要地陈述了它们的职责，并且还提供了关于与其他模块的关系的信息。</p><h1 id="4b83" class="mw lw jb bd lx mx nn mz ma na no nc md kh np ki mg kk nq kl mj kn nr ko mm ng bi translated">它们与C代码有什么关系？</h1><p id="a0eb" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi lm translated">好吧，但是……我们是C语言开发人员！没有人给我们提供花哨的关键字来显式声明一个<em class="nm">抽象类</em>或者一个<em class="nm">接口</em>。什么是<em class="nm">方法</em>？</p><p id="3668" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">虽然C没有包含任何实现OOP的习语，但是这些概念在这里仍然有效。我们<em class="nm">可以</em>实现封装和多态:我们只需要更加清楚我们在做什么。</p><p id="e9a0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在接下来的部分中，我们将看到如何有效地使用结构和函数<em class="nm"> </em>来代替类。此外，我们将展示纯虚拟类(即。<em class="nm">接口</em>)可以通过函数指针实现，写一个普通的C函数如何转化为实现一个接口。<br/>最后，我们将看到对象如何通过使用组合和依赖机制来相互交互。</p><p id="ca35" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好吧，我们继续！</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="cdf5" class="mw lw jb bd lx mx my mz ma na nb nc md kh nd ki mg kk ne kl mj kn nf ko mm ng bi translated">1.大盒子又名混凝土类</h1><p id="0b97" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi lm translated">在UML中，一个盒子被用来表示一个类。这可以是一个<em class="nm">具体</em>类，一个<em class="nm">抽象</em>类，或者一个<em class="nm">接口</em>。这里我们将介绍具体的类和接口。</p><p id="ee52" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在纯面向对象语言中，类是组成程序的原子。高级功能是通过允许一组函数对一组数据进行操作来实现的。话虽如此，具体的类不过是相关函数和数据的容器。</p><p id="d5ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">UML具体类的基本演示如图1.1所示。<code class="fe ns nt nu nv b">Rectangle</code>类公开了函数<code class="fe ns nt nu nv b">area()</code>和两个属性，即<code class="fe ns nt nu nv b">width</code>和<code class="fe ns nt nu nv b">height</code>。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/772cfa032e5adf1db6dc4263b87cbf7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*HA4cdLmm5hr4QgrpRsFdqA.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图1.1:UML中的矩形类</figcaption></figure><p id="2061" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在C语言中，这可以用图1.2中的清单来表示。你可能已经知道，C语言没有提供习语来声明一个类。因此，<code class="fe ns nt nu nv b">Rectangle_Area()</code>没有明确地绑定到<code class="fe ns nt nu nv b">Rectangle</code>数据结构。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/620209e4a4e59f4e4d2bcd38bc8e9c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*ZdzsSjiKZLonjLp5fQWAiw.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图1.2:矩形类列表</figcaption></figure><p id="a66a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我认为展示如何在<code class="fe ns nt nu nv b">Rectangle</code>实例上调用方法也是有用的。清单示例如图1.3所示。值得一提的是，如果我们选择Java或C++作为语言，最后一行应该等于<code class="fe ns nt nu nv b">r.area()</code>。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f038dc4016cb76c4aa2f4e49199a1471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*jXjFcORk54oLqc3vnWJ0Mg.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图1.3:矩形类的用法</figcaption></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="9ccf" class="mw lw jb bd lx mx my mz ma na nb nc md kh nd ki mg kk ne kl mj kn nf ko mm ng bi translated">2.进入界面</h1><p id="2f79" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated">有时候以统一的方式操作不同的对象是很有用的。作为一个著名的例子，考虑不同几何形状的面积计算:每个形状都应该提供一个<code class="fe ns nt nu nv b">area()</code>方法，尽管使用不同的数据集。我们的用户代码可以合理地期望从形状列表中检索区域，而不管它们的具体细节。这种情况如图2.1所示。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e3f3b8982a3670ac7a0ea00d641a4664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*eWc7ytGJgF8FePYhkzx8Xw.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图2.1:操作形状的用户代码</figcaption></figure><p id="2655" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我建议关注第一行和最后一个<code class="fe ns nt nu nv b">for</code>循环:声明一个<code class="fe ns nt nu nv b">Shape</code>指针数组，在代码的后面，对每个对象调用<code class="fe ns nt nu nv b">area()</code>方法(通过<code class="fe ns nt nu nv b">Shape_Area()</code>函数调用)，不管它是<code class="fe ns nt nu nv b">Rectangle</code>还是<code class="fe ns nt nu nv b">Circle</code>。</p><p id="2fa6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">情况可能是我们的<code class="fe ns nt nu nv b">Shape</code>类提供了一组函数(即方法)但不实现它们中的任何一个:在这种情况下，我们说<code class="fe ns nt nu nv b">Shape</code>是一个<em class="nm">接口</em>。用于接口的UML符号类似于用于具体类的符号，除了我们必须使用所谓的<em class="nm">原型</em>(除了用引号括起来的单词之外什么都没有)来表示我们的类是一个接口，并且每个未实现的方法都必须用斜体书写。</p><p id="c17c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">看一下图2.2。“interface”原型放在类名的上方，而<code class="fe ns nt nu nv b">area()</code>方法用斜体书写。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/38dad9db4e6cb397bee3aed65c2e09be.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*AeAq2ynro4sQB6sp-j6RVw.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图2.2:UML中的形状界面</figcaption></figure><p id="d08c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了在C语言中实现这一点，我们使用了一个保存函数指针的结构(见图2.3)。<code class="fe ns nt nu nv b">AreaFn</code>只是类型<code class="fe ns nt nu nv b">double(void *)</code>的函数指针的语法糖，而<code class="fe ns nt nu nv b">ShapeInterface</code>为<code class="fe ns nt nu nv b">Shape</code>公开的每个方法保存一个函数指针。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c5cd154370af629589e20b5c84a63ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*WyowT_ERhFvc4aLgeXdkeQ.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图2.3: ShapeInterface结构定义</figcaption></figure><p id="2c01" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这听起来不错，但是我们仍然缺少一些东西，使我们能够调用<code class="fe ns nt nu nv b">Shape_Area()</code>，正如我们在图2.1中看到的。我们需要的是一个既存储接口函数又存储相关数据的结构(即一个<code class="fe ns nt nu nv b">struct Rectangle</code>实例和矩形相关的方法)。我们正在寻找的解决方案如图2.4所示。这里，instance将保存一个<code class="fe ns nt nu nv b">Rectangle</code>或<code class="fe ns nt nu nv b">Circle</code>数据结构(这是使用<code class="fe ns nt nu nv b">void *</code>数据类型的一个优点)。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/bf7ac0a3ae9b61469385422e69bc4399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*yaVc78x0LaO1IWYGx_K1kA.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图2.4:形状结构定义</figcaption></figure><p id="444c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在是时候解释如何使用一种<em class="nm">类型的</em>构造函数来构造一个<code class="fe ns nt nu nv b">Shape</code>。图2.5指向了一个<code class="fe ns nt nu nv b">Rectangle</code>的创建:注意在最后四行中，<code class="fe ns nt nu nv b">Rectangle</code>数据及其相关方法是如何放入<code class="fe ns nt nu nv b">Shape</code>包装器中的。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/2c45e2f09b3b25ba009362070fbb875c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yO1MlPI0ibC2f2Uq3Chvug.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图2.5:矩形构造器</figcaption></figure><p id="57df" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以这一节结束，这里是<code class="fe ns nt nu nv b">Shape_Area()</code>的非常简单的代码。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi om"><img src="../Images/f8bd8ab7b6c3ac4785a580117cb9153d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lE-atAtsHYbo874kgy4-zA.png"/></div></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图2.6:形状面积函数</figcaption></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="879a" class="mw lw jb bd lx mx my mz ma na nb nc md kh nd ki mg kk ne kl mj kn nf ko mm ng bi translated">3.钻石箭又名继承</h1><p id="18df" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated">箭头用于表示类之间的关系。主要有三种关系:<em class="nm">继承</em>、<em class="nm">组成</em>、<em class="nm">依赖</em>。尽管存在差异，但每种关系都强调了一个类了解另一个类的事实。</p><p id="ea7b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在UML中，菱形箭头用于表示类之间的继承。回想我们之前的例子，我们说<code class="fe ns nt nu nv b">Rectangle</code> <em class="nm">继承</em> <code class="fe ns nt nu nv b">Shape</code>:其实实现一个接口和继承它<em class="nm">是完全一样的事情</em>。类图如图3.1所示。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi on"><img src="../Images/b50185fc0b79968781f79b76a0bd2b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*WZz4L8qB3c1TheUL4UtOfA.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图3.1:使用继承关系的形状层次结构</figcaption></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="1baa" class="mw lw jb bd lx mx my mz ma na nb nc md kh nd ki mg kk ne kl mj kn nf ko mm ng bi translated">4.组成和依赖关系</h1><p id="54a6" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated">在OOP中，对象需要相互交互。在典型的客户机/服务器应用程序中，客户机需要有一种与服务器交互的方式，反之亦然。然而，这种关系并不局限于网络应用程序:如果A类的对象使用了属于B类的对象，那么A就是B的客户端(或<em class="nm">用户</em>)。</p><p id="c5f6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">回想一下图2.1所示的清单。现在假设代码在一个<code class="fe ns nt nu nv b">GeometryApp</code>类中，它通过<code class="fe ns nt nu nv b">Shape</code>接口使用矩形和圆形。在这种情况下，我们说<code class="fe ns nt nu nv b">GeometryApp</code>和<code class="fe ns nt nu nv b">Shape</code>之间有一个<em class="nm">成分</em>关系。值得一提的是，连接不是双向的:换句话说，<code class="fe ns nt nu nv b">GeometryApp</code>知道<code class="fe ns nt nu nv b">Shape</code>类的存在，但是<code class="fe ns nt nu nv b">Shape</code>完全独立于<code class="fe ns nt nu nv b">GeometryApp</code>。</p><p id="1bab" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">UML组合通过直箭头表示，如图4.1所示。您可能已经注意到,<code class="fe ns nt nu nv b">GeometryApp</code>的属性正在对组合做出“反应”: shapes数组可以被视为关系的副产品。此外，靠近箭头的<code class="fe ns nt nu nv b">N_SHAPES</code>标签用于传达所谓的<em class="nm">多重性</em>，其简单地阐明了每个用户对象知道多少服务器对象(在这种情况下，每个<code class="fe ns nt nu nv b">GeometryApp</code>对象存储指向<code class="fe ns nt nu nv b">Shape</code>对象的<code class="fe ns nt nu nv b">N_SHAPES</code>指针)。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f087b6d07df67bfec78f5f1e70621e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*4R5ikAdpaTjqmYcYxm9XgQ.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图4.1:合成示例</figcaption></figure><p id="8982" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后，我想提一下一个对象开始了解另一个对象，但不把它作为属性的情况。例如，考虑一个作为参数传递给函数<code class="fe ns nt nu nv b">F</code>的<code class="fe ns nt nu nv b">Rectangle</code>对象。在这些情况下，我们说<code class="fe ns nt nu nv b">F</code>对<code class="fe ns nt nu nv b">Rectangle</code>类有一个<em class="nm">依赖关系</em>。看一下图4.2，其中<code class="fe ns nt nu nv b">F</code>被放到了<code class="fe ns nt nu nv b">A</code>类中。</p><figure class="nx ny nz oa gt is gh gi paragraph-image"><div class="gh gi op"><img src="../Images/27f190d5c55082ec2306b8e8460efa65.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*JiQgSTfPTAXy1G00686eJg.png"/></div><figcaption class="ob oc gj gh gi od oe bd b be z dk translated">图4.2:依赖示例</figcaption></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="ee33" class="mw lw jb bd lx mx my mz ma na nb nc md kh nd ki mg kk ne kl mj kn nf ko mm ng bi translated">包扎</h1><p id="951e" class="pw-post-body-paragraph kq kr jb ks b kt nh kc kv kw ni kf ky kz nj lb lc ld nk lf lg lh nl lj lk ll ij bi translated">今天到此为止。我希望这篇阅读有助于阐明UML类图背后的主要概念，以及如何使用C语言应用它们。然而，统一建模语言有更多的功能，特别是对于动态建模。我希望能够很快带给你一个关于将序列图和交互图应用到C编程中的讨论，这是我在所有项目中经常做的事情！</p><p id="2019" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">非常感谢你的关注。对于任何问题，只要你觉得更合适，随时联系我。下次见！😊</p></div></div>    
</body>
</html>