<html>
<head>
<title>Java libraries to increase your productivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java库来提高您的生产力</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-libraries-to-increase-your-productivity-79093535a371?source=collection_archive---------2-----------------------#2021-04-06">https://levelup.gitconnected.com/java-libraries-to-increase-your-productivity-79093535a371?source=collection_archive---------2-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0422318459ccce0d59c69ccbec869ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0g9pHa_SpBLfUPWAN3qEQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@schmaendels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd je">安德里亚斯·克拉森</strong>T3】在</a><a class="ae jd" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="ec10" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">编写样板代码或实际上不需要的代码会浪费很多时间。java有一个很大的社区，它创建了许多库，通过消除编写样板代码的需要或为常见的Java问题提供实用程序，帮助您提高生产率。在本文中，我们将探索其中的一些库。</p><h1 id="7694" class="lc ld jh bd je le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> <em class="lz"> 1)龙目岛项目</em> </strong></h1><p id="ff35" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">厌倦了只有getters、setters、constructors、overridden equals方法等样板方法的文件？好吧，那龙目岛是给你的。大多数IDE只需点击一下按钮就能自动生成getter和setter方法，但不同之处在于IDE在java文件本身中生成这些方法，而Lombok直接在类文件中生成所有方法。不仅如此，Lombok还帮助我们删除了其他样板代码。让我们通过一些例子来更好地理解这一点。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9ce6" class="mo ld jh mk b gy mp mq l mr ms">public class StudentServiceWithoutLombok implements IStudentService{<br/>private static final Logger log = Logger.getLogger(StudentServiceWithLombok.class);</span><span id="b698" class="mo ld jh mk b gy mt mq l mr ms"><a class="ae jd" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/> public void method1() {<br/>  log.info("In method1 ");<br/> }</span><span id="29cf" class="mo ld jh mk b gy mt mq l mr ms">}</span></pre><p id="52b5" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">上面的代码没有Lombok，现在让我们用Lombok框架写同样的代码。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="729d" class="mo ld jh mk b gy mp mq l mr ms">@Log4j<br/>public class StudentServiceWithLombok implements IStudentService{</span><span id="9845" class="mo ld jh mk b gy mt mq l mr ms"><a class="ae jd" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/> public void method1() {<br/>  log.info("In method1 ");<br/> }</span><span id="6889" class="mo ld jh mk b gy mt mq l mr ms">}</span></pre><p id="7dfb" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">您现在可以看到，我们不必在这个文件中初始化logger变量，它只是一行，但在有数千个文件的较大项目中，您不必一次又一次地编写相同的行，相反，您可以专注于您的业务逻辑。下面再给你举个例子就是多了一个没有龙目岛的班级。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c6d6" class="mo ld jh mk b gy mp mq l mr ms">public class Student{<br/>  <br/>    private Integer rollNumber;<br/>    private String name;<br/>  <br/>    public Student(Integer rollNumber, String name)<br/>    {<br/>        super();<br/>        this.rollNumber = rollNumber;<br/>        this.name = name;<br/>    }<br/>  <br/>    public Integer getRollNumber()<br/>    {<br/>        return rollNumber;<br/>    }<br/>  <br/>    public void setRollNumber(Integer rollNumber)<br/>    {<br/>        this.rollNumber = rollNumber;<br/>    }<br/>  <br/>    public String getName()<br/>    {<br/>        return name;<br/>    }<br/>  <br/>    public void setName(String name)<br/>    {<br/>        this.name = name;<br/>    }<br/>  <br/>    <br/>    <a class="ae jd" href="http://twitter.com/Override" rel="noopener ugc nofollow" target="_blank">@Override</a><br/>    public String toString()<br/>    {<br/>        return "Student ["<br/>            + "rollNumber=" + rollNumber<br/>            + ", name=" + name + ", "<br/>            + "]";<br/>    }<br/>}</span></pre><p id="a237" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在，如果我必须用Lombok编写相同的代码，它将如下所示:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="bce2" class="mo ld jh mk b gy mp mq l mr ms">@AllArgsConstructor<br/>@Data<br/>public class Student{<br/>    private Integer rollNumber;<br/>    private String name;<br/>}</span></pre><p id="c51a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">震惊？嗯，Lombok的代码没有任何样板代码，更容易阅读。</p><p id="ba76" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">Lombok可以删除大量样板代码，您可以专注于业务逻辑，代码看起来也会更整洁。Lombok还有比我们在这篇文章中讨论的更多的东西，你可以从他们的官方网站<a class="ae jd" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank">查看Lombok项目的所有酷功能。</a></p><h1 id="e4b2" class="lc ld jh bd je le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> <em class="lz"> 2) MapStruct </em> </strong></h1><p id="5054" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">你在你的java项目中使用多层架构了吗？如果是，那么你肯定应该考虑使用MapStruct。在多层体系结构中，应用程序的所有层都是松散耦合的，因此有时您必须将一层中的对象映射到另一层对象，一个常见的例子是驻留在持久层中的实体将被映射到应用层中的d to。将简单的POJO映射到另一个POJO可能需要大量样板代码。考虑下面两个类，这里我们必须将学生的实体类与其DTO进行映射。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8d93" class="mo ld jh mk b gy mp mq l mr ms">@Entity<br/>@Data<br/>public class Student{<br/>    private Integer rollNumber;<br/>    private String name;<br/>}</span><span id="1b68" class="mo ld jh mk b gy mt mq l mr ms">@Data<br/>public class StudentDTO{<br/>    private Integer rollNumber;<br/>    private String name;<br/>}</span></pre><p id="9bcf" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如果你必须映射两个类，那么你可能要写一个转换器类，它有一个函数，将Student作为输入，将StudentDTO作为输出，如下所示</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="b92d" class="mo ld jh mk b gy mp mq l mr ms">public class StudenttoStudentDTOconvertor<br/>{<br/>  public StudentDTO convert(Student student)<br/> {<br/>    StudentDTO studentDTO = new StudenDTO();<br/>    studentDTO.setName(student.getName);<br/>    studentDTO.setRollNo(student.getRollNo());<br/>    return studentDTO;<br/> }<br/>}</span></pre><p id="a71a" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">学生是一个简单的类，只有2个字段，然后你也可以看到，我们必须写4行代码，如果这个类有大量的字段，代码行数的转换器也将增加。为了避免编写这种简单的样板代码，我们使用了MapStruct来自动生成代码。现在让我们用MapStruct重写转换器类代码。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="de57" class="mo ld jh mk b gy mp mq l mr ms">@Mapper <br/>public interface StudenttoStudentDTOMapper <br/>{ <br/>    StudentDTO map(Student student);     <br/>}</span></pre><p id="1aed" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">嗯，真的是这样。你真的不需要实现这个接口，MapStruct会自动为你实现。万一将来你决定在实体类中添加一个新的字段，比如父亲的名字，那么你可以在DTO中添加相同的字段，你真的不需要在映射器类中做任何改变。Co，ol没有？要了解更多关于MapStruct的其他酷功能，请查看他们的官方网站。</p><h1 id="d4ac" class="lc ld jh bd je le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">T3)3)番石榴T5】</strong></h1><p id="4169" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">我无法比在guava的GitHub库中更好地解释它了。这是我刚刚从Github复制的定义:</p><blockquote class="mu mv mw"><p id="1d6b" class="ke kf mx kg b kh ki kj kk kl km kn ko my kq kr ks mz ku kv kw na ky kz la lb ij bi translated">Guava是Google的一组核心Java库，包括新的集合类型(如multimap和multiset)、不可变集合、一个图形库，以及用于并发、I/O、哈希、缓存、原语、字符串等的实用程序！它在Google的大多数Java项目中被广泛使用，也被许多其他公司广泛使用。</p></blockquote><p id="bec3" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">番石榴听起来很酷吧？番石榴有实用程序，不仅可以帮助你解决java中的简单问题，也可以解决非常复杂的问题。不理解我吗？让我们用一个例子来理解</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="76dd" class="mo ld jh mk b gy mp mq l mr ms">public void checkAge(int age) {<br/>      if(age&lt;0)<br/>      {<br/>        throw new IllegalArgumentException(“age id invalid”);<br/>      }<br/>    }</span></pre><p id="ee72" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">同样的程序可以用番石榴库写成:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6b28" class="mo ld jh mk b gy mp mq l mr ms">public void checkAge(int age) {<br/>      <!-- -->Preconditions.<!-- -->checkArgument(age &gt; 0, “Invalid Age”);<br/>    }</span></pre><p id="4769" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这两个程序做着同样的工作，但是利用番石榴库的代码更干净。它可能看起来不多，但在番石榴中有更多。我们再举一个例子。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0cd7" class="mo ld jh mk b gy mp mq l mr ms">public void example() {<br/>    // Initialising Guava LinkedHashMap Collection<br/>    Map&lt;String, String&gt; myMap = Maps.newLinkedHashMap();<br/>    myMap.put(“name”, “abc”);<br/>    myMap.put(“rollno”, “123”);<br/>    String delimiter = “&amp;”;<br/>    String separator = “=”;<br/>    String result = Joiner.on(delimiter).withKeyValueSeperator(separator).join(myMap);<br/>    String expected = “name=abc&amp;rollno=123”;<br/>    assertThat(result, expected);<br/>}</span></pre><p id="f165" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">从上面的程序中，您可以看到使用guava将地图转换为字符串是多么容易，如果您在java中遇到任何问题，无论是与缓存、并发还是任何其他领域相关的问题，大多数情况下您都可以在guava库中找到解决方案。要了解更多关于番石榴库的信息，别忘了查看他们的Github repo。</p><h1 id="3316" class="lc ld jh bd je le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> <em class="lz"> 4)假装</em> </strong></h1><p id="387b" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">如果您是一名java开发人员，您肯定会遇到必须调用一些REST API的情况。有许多像<em class="mx"> OkHttpClient </em>这样的HTTP客户端可以用来调用rest API，但是它们通常需要大量的代码，这些代码对我们的业务需求没有任何帮助，如果您调用多个REST API，您的代码也会重复。在HTTP客户端库之上，我们还有像RestTemplate这样的包装器库，让我们的生活变得更简单。用<em class="mx"> OkHttpClient编写的示例代码将如下所示。</em></p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="cd3b" class="mo ld jh mk b gy mp mq l mr ms">OkHttpClient okHttpClient = new OkHttpClient();<br/>Request request = new Request.Builder()<br/>    .url("<a class="ae jd" href="https://jsonplaceholder.typicode.com/posts/1" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1/posts/1</a>")<br/>    .build();<br/>Call call = okHttpClient.newCall(request);<br/>try (Response response = call.execute();<br/>     ResponseBody body = response.body()) {</span><span id="3ac1" class="mo ld jh mk b gy mt mq l mr ms">String string = body.string();<br/>  System.out.println(string);<br/>} catch (IOException e) {<br/>  throw new RuntimeException(e);<br/>}</span></pre><p id="6f43" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">请注意我们必须如何处理异常，我们还必须将响应转换为我们的对象，以便我们可以使用它。你不觉得我们为了调用一个简单的Rest API写了很多代码吗？让我们看看使用RestTemplate时代码会是什么样子。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="b311" class="mo ld jh mk b gy mp mq l mr ms">final String uri = "<a class="ae jd" href="https://jsonplaceholder.typicode.com/posts/1" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1/posts/1</a>"<br/>RestTemplate restTemplate = new RestTemplate();<br/>PostDTO result = restTemplate.getForObject(uri,PostDTO.class);</span></pre><p id="bfec" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在RestTemplate中非常简单，你的响应也被转换成我们可以使用的对象，对吗？但是，如果我们在每个API中调用多个REST API，我们必须从属性中获取URL并以编程方式调用Rest API，我甚至没有提到我们仍然必须进行错误处理。有两种方法可以处理错误:1是简单地编写try-catch，但必须为每个调用编写相同的代码，另一个选项是异常处理程序，但在这两种情况下，我们都必须编写更多的代码。现在让我们看看如何使用feign调用Rest API。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="90f0" class="mo ld jh mk b gy mp mq l mr ms"><em class="mx">@FeignClient(name="content-service", url="127.0.0.1")</em><br/>public interface ContentService {<br/>  @RequestLine("GET posts/{postNumber}")<br/>  String getDocumentByType(@Param("contentType") String postNumber);<br/>}</span></pre><p id="d6c4" class="pw-post-body-paragraph ke kf jh kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">信不信由你，就是这样。Feign将自动生成代码来调用Rest API，我们作为开发人员将无需担心任何事情。如果需要添加更多的API，我们可以添加方法，而不必重写代码来调用REST API，很酷吧？如果你想在某些特定错误的情况下重试一些API，我们可以通过改变配置来轻松地改变URL，feign可以很容易地帮你做到这一点。如果你使用feign，测试你的代码是非常容易的。从他们的GitHub <a class="ae jd" href="https://github.com/OpenFeign/feign#why-feign-and-not-x" rel="noopener ugc nofollow" target="_blank"> repo </a>中查看更多关于feign的酷功能。</p><h1 id="a02d" class="lc ld jh bd je le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> <em class="lz"> 5)冬眠</em> </strong></h1><p id="8a96" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">嘿，你讨厌在你的代码中写SQL查询吗？您有时会忘记在运行查询后关闭数据库连接吗？那这个图书馆就是为你准备的。当您尝试访问数据库时，会涉及到大量的样板代码，您必须打开连接、运行查询、将结果集转换为实体、关闭连接，除此之外，您还必须编写高效的查询。如果你使用hibernate，你就不必担心上述任何事情，你可以专注于你的业务而不是这些。你可以从<a class="ae jd" href="https://medium.com/javarevisited/top-5-hibernate-online-training-courses-for-beginners-and-advance-java-programmers-469460596b2b" rel="noopener">这里</a>了解更多关于hibernate的知识。</p><h1 id="dde9" class="lc ld jh bd je le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> <em class="lz">结论</em> </strong></h1><p id="8e04" class="pw-post-body-paragraph ke kf jh kg b kh ma kj kk kl mb kn ko kp mc kr ks kt md kv kw kx me kz la lb ij bi translated">在编程的世界里，你希望尽量减少应用程序中的样板代码，也不希望重新发明轮子，因为当你编写越来越多的代码时，你将需要创建测试用例来测试每一行，并且总是有可能引入一些bug。在Java中，有多个库有助于消除样板代码，有些库提供了很好的生产就绪实用程序，这样您就不必重新发明轮子了。</p></div></div>    
</body>
</html>