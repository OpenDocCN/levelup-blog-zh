<html>
<head>
<title>Scala Beginner Series (3) : Functional Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala初学者系列(3):函数式Scala</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-beginner-series-3-functional-scala-eedd9090a3ac?source=collection_archive---------20-----------------------#2020-10-06">https://levelup.gitconnected.com/scala-beginner-series-3-functional-scala-eedd9090a3ac?source=collection_archive---------20-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4deadaf8dfa988e3986864cbcc14a2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o6E6YJdnCWR8NHC9.png"/></div></div></figure><blockquote class="jy jz ka"><p id="4f7d" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">这个系列完全是关于Scala的品味。<br/>最适合所有Scala新手。</em></p><p id="4df9" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">你可能也喜欢:<br/> </em> <a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-1-basics-d1dae1f3458d"> <em class="iq"> Scala初学者系列(1):基础知识</em></a><em class="iq"><br/></em><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-2-object-oriented-scala-4e2496ec2e9f"><em class="iq">Scala初学者系列(2):面向对象Scala </em> </a></p></blockquote><p id="226d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-2-object-oriented-scala-4e2496ec2e9f">的上一部分</a>中，我们介绍了:</p><ul class=""><li id="a055" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">类、构造函数、继承和抽象类</li><li id="ddb8" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">特征和匿名类</li><li id="4f9b" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">单例对象和伴随对象</li><li id="f0e6" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">案例类和案例对象</li></ul><p id="bde1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">本文将介绍Scala语言的函数性质。</p><h1 id="6223" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">纯函数</h1><p id="6d57" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">函数式Scala的第一个基本概念是纯函数。</p><p id="7ec2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这里有一个非常严格的纯度定义:</p><ul class=""><li id="a354" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">如果给定相同的参数，它将返回相同的结果</li><li id="25d6" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">它不会引起任何明显的副作用</li></ul><h1 id="9630" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">在Scala中充当一等公民</h1><p id="e93b" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">在Scala中，函数是一等公民，因为我们可以用它们做以下事情:</p><ul class=""><li id="8754" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">我们可以用函数作为值或者像正态变量。这可以表现为:</li></ul><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/ca659de0f487c36c0fc25aa2b1261ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*2DQ500L61PygCBse7346sA.png"/></div></figure><ul class=""><li id="bac3" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">我们可以给一个变量指定一个匿名函数，也就是一个函数文字。这可以表现为:</li></ul><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/287ae3cb9b5327b85702c1f628c27a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*xXEnLBeC6VmE8qQD0vn0wg.png"/></div></figure><ul class=""><li id="06da" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">我们可以将一个或多个函数作为参数传递给另一个函数。</li><li id="5944" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">我们可以从一个函数返回另一个函数</li></ul><p id="d256" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">让我们深入研究上面提到的最后两点的细节。这两个功能是由Scala中的高阶函数提供的。</p><h1 id="e529" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">高阶函数</h1><p id="8521" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">高阶函数将其他函数作为参数，或者返回一个函数作为结果。换句话说，我们可以说一个与函数一起工作的函数叫做高阶函数。</p><p id="99e7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">高阶函数允许你创建函数组合，lambda函数或匿名函数等。</p><p id="2aeb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">下面演示了一个在函数中将函数作为参数传递的示例:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/dfeb045bf8da121bf7f54fb211e874bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*_HWp03zcIOmGheFFNRNgHw.png"/></div></figure><p id="b8c6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">从函数返回函数的示例如下所示:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/040186ecb277778f448774633af50ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*LG0iqjC0sH5pjMFM5atmmQ.png"/></div></figure><p id="b9e4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">有一些经典的Hof我们用的很多，有<code class="fe nd ne nf ng b">map</code>、<code class="fe nd ne nf ng b">flatMap</code>和<code class="fe nd ne nf ng b">filter</code>。让我们依次以它们为例。</p><h2 id="5890" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lb nm nn mg lc no np mk ld nq nr mo ns bi translated">映射方法</h2><p id="9333" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">集合的<code class="fe nd ne nf ng b">map</code>方法将一个函数作为参数，并返回一个新的集合，其中包含该函数在每个元素上的应用。它可以表现为:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3c289ceb47038ec48847e8339d2093ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*IyGtAX6eVnoK2-AY15sq1A.png"/></div></figure><h2 id="09a3" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lb nm nn mg lc no np mk ld nq nr mo ns bi translated">平面图方法</h2><p id="3375" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">集合的<code class="fe nd ne nf ng b">flatMap</code>方法将一个函数作为参数，将其应用于集合中的每个元素，并为每个元素返回一个新的集合。<code class="fe nd ne nf ng b">flatMap</code>方法实质上是先运行<code class="fe nd ne nf ng b">map</code>方法，然后运行<code class="fe nd ne nf ng b">flatten</code>方法的组合。它可以表现为:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ba940b2b4ea1da77c79a896a26259b21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*rCxcWRuFsduYPJvWYkS9ZA.png"/></div></figure><h2 id="5405" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lb nm nn mg lc no np mk ld nq nr mo ns bi translated">该过滤方法</h2><p id="87cd" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">集合的<code class="fe nd ne nf ng b">filter</code>方法将一个函数作为参数，并返回一个新的集合，该集合只包含该函数返回true的元素。它可以表现为:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e8ac47ffc3ef0628f376a41b99c5cc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*9H3ecgESSnaq_Py25wS7hQ.png"/></div></figure><p id="6c51" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">因此，我们不是遍历集合并手动构造值，而是通过它们的高阶函数来操作现有的集合。</p><h1 id="5ed2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">Currying</h1><p id="093d" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Currying是将带有多个参数的函数转换成带有一个参数的函数序列的过程。每个函数返回另一个使用以下参数的函数。</p><p id="c39f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">以下是一个约定函数的示例:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/63ee03cca39b0ebe7ed431b95aebaf10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*ze0U4s5mtBk2el8UCIFqdA.png"/></div></figure><h1 id="43ea" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">部分应用的功能</h1><p id="705d" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">部分应用的函数是没有应用于由所述函数定义的所有自变量的函数，即，当调用函数时，我们可以提供一些自变量，并且在需要时提供左边的自变量。</p><p id="2974" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">部分应用功能的示例如下所示:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/ba0f8720cf70b4a8cdc18dfbc85ab149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6W_MgI5DcQAsHuyBi4NWQ.png"/></div></div></figure><h1 id="c676" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">尾部递归</h1><p id="eb95" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">Scala提供了尾部递归优化，以降低递归函数导致堆栈溢出错误的风险。</p><p id="0127" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">尾递归函数优化的递归函数，其递归调用是该函数执行的最后一个操作，当函数返回时，不需要保存任何操作。</p><p id="a048" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">Scala提供了<code class="fe nd ne nf ng b">@tailrec</code>注释来检查递归是否是尾递归。</p><p id="be60" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">尾部递归函数的一个例子如下所示:</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/9774c7bd11b6eddf50fb2ef089243771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*EmdGhJFfES4txjk2Cl3T7g.png"/></div></figure><h1 id="ddf2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="e338" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">如果想入门函数式编程，输入Scala。</p><p id="6d37" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">当今大多数流行的编程语言都是从面向对象开始的，现在随着需求的增长，集成了越来越多的函数式编程的特性。而Scala从第一天起就准备集成这两者。</p><p id="6702" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">Scala为您提供了足够多的面向对象编程，让您感觉似曾相识。同时，这也是按照自己的进度了解函数式编程的一个很好的方式。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><h1 id="3234" class="ls lt iq bd lu lv of lx ly lz og mb mc md oh mf mg mh oi mj mk ml oj mn mo mp bi translated">类似文章-</h1><p id="08bd" class="pw-post-body-paragraph kb kc iq ke b kf mq kh ki kj mr kl km lb ms kp kq lc mt kt ku ld mu kx ky kz ij bi translated">你也可以查看我在<em class="kd"> Scala初学者系列</em>的其他文章</p><ul class=""><li id="39f6" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-1-basics-d1dae1f3458d"> Scala初学者系列(1):基础知识</a></li><li id="8a82" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated"><a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/scala-beginner-series-2-object-oriented-scala-4e2496ec2e9f"> Scala初学者系列(2):面向对象的Scala </a></li></ul></div></div>    
</body>
</html>