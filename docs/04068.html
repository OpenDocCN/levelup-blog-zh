<html>
<head>
<title>Inject Objects into your Components with Angular Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角度依赖注入将对象注入到组件中</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/inject-objects-into-your-component-with-angular-dependency-injection-17c867e890dc?source=collection_archive---------11-----------------------#2020-06-08">https://levelup.gitconnected.com/inject-objects-into-your-component-with-angular-dependency-injection-17c867e890dc?source=collection_archive---------11-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c649544df9c9e21a35db16d9c04d8cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LcQajVnIo4iv3t9H4--Dnw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com/s/photos/order?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@zmachacek?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">zdenk macha ek</a>拍摄的照片</figcaption></figure><p id="c8b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">依赖注入是一种常见的处理依赖的设计模式。当您需要依赖项时，您不必自己创建依赖项实例，而是将此任务留给依赖项注入机制。这种机制在需要时实例化依赖关系，并允许您访问这些实例，以避免创建和处理同一事物的太多实例。</p><p id="7909" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Angular是一个完整的JavaScript框架，它有自己的依赖注入机制。大多数时候，我们所说的依赖是服务。要了解更多关于如何注入服务的信息，你可以查看这篇文章。但是依赖注入并不局限于服务。你可以用它来注入(几乎)任何你喜欢的东西，比如物体。然而，虽然语法快捷方式使得注入服务非常直接，但是在注入其他类型的对象时会有更多的工作。</p><p id="3a6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将展示如何通过将web存储注入到Angular服务中来实现这一点。</p><h1 id="169f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将Web存储与Angular一起使用</h1><p id="3dd1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">localStorage</code>和<code class="fe mh mi mj mk b">sessionStorage</code>是窗口属性，您可以在Angular代码中像在控制台中一样访问它们。但是通常更好的做法是将对外部API的访问包装在服务中。这样，如果API发生变化，或者如果您决定为您的本地属性使用另一个存储，您只需要适应一个地方。这样的服务可能如下所示:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8222" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，您将通过您的<code class="fe mh mi mj mk b">PersistenceService</code>从<em class="mr"> localStorage </em>中存储和检索属性，而不是直接存储和检索。</p><p id="b70e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是这样做，你仍然对浏览器API有一个隐含的依赖。如果缺少该API(例如，如果您在服务器上渲染)或在测试时，可能会导致问题。</p><p id="3a70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更干净的选择是为Web存储创建一个依赖注入(DI)令牌，并将其注入到我们的持久性服务中。</p><h1 id="91c2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">依赖注入令牌</h1><p id="931a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当您在组件中注入服务时，您将传递一个<em class="mr"> DI令牌</em>给组件注入器。默认情况下，令牌是服务的类名，因此您可以编写如下代码:</p><pre class="ml mm mn mo gt ms mk mt mu aw mv bi"><span id="bb02" class="mw lf it mk b gy mx my l mz na">@Component({<br/>  selector: 'app-test', <br/>  templateUrl: './test.component.html', <br/>  styleUrls: ['./test.component.scss'],<br/>  providers: [TestService]<br/>})</span></pre><p id="459c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但这只是Angular让你走的一条舒适的捷径。提供程序数组的完整语法如下:</p><pre class="ml mm mn mo gt ms mk mt mu aw mv bi"><span id="a9d0" class="mw lf it mk b gy mx my l mz na">providers: [{ provide: TestService, useClass: TestService }]</span></pre><p id="e14d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">provider对象定义了如何获取与阿迪令牌相关联的依赖关系。在上面的例子中，我们告诉Angular在请求由“name”<code class="fe mh mi mj mk b">TestService</code>标识的依赖项时使用类<code class="fe mh mi mj mk b">TestService</code>。服务的令牌是它们自己的类名，这导致了冗余，这也是Angular允许捷径的原因。对象没有类名，要注入一个对象，我们必须首先为它创建阿迪令牌。</p><h1 id="6998" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用注入令牌注入存储</h1><p id="2300" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可能会想到使用接口名<code class="fe mh mi mj mk b">Storage</code>作为令牌，但这只能用于具有运行时表示的对象。Web存储API <code class="fe mh mi mj mk b">Storage</code>是一个<strong class="ki iu">接口</strong>，它只存在于TypeScript中，但是在代码被传给JavaScript之后。因此我们不能直接注射。</p><p id="f6f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这种情况，您必须使用构造函数创建一个<code class="fe mh mi mj mk b">InjectionToken</code>对象。当创建我们的令牌时，我们指定一个工厂函数，它将返回一个类型为<code class="fe mh mi mj mk b">Storage</code>的对象:属性<code class="fe mh mi mj mk b">localStorage</code>。这将是默认值。</p><p id="5afa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用<code class="fe mh mi mj mk b">@Inject</code>装饰器注入存储。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="8f64" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重写提供程序中的注入标记</h1><p id="d837" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">以这种方式注入<code class="fe mh mi mj mk b">Storage</code>接口还有另一个好处。您可以用不同的存储注入<code class="fe mh mi mj mk b">PersistenceService</code>。假设有这样一种情况，您希望将数据存储在<code class="fe mh mi mj mk b">sessionStorage</code>而不是<code class="fe mh mi mj mk b">localStorage</code>中。你可以在你想要的组件中使用一个提供者，并在请求使用<code class="fe mh mi mj mk b">STORAGE</code>时返回<code class="fe mh mi mj mk b">sessionStorage</code>。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b629" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，组件将拥有自己的<code class="fe mh mi mj mk b">PersistenceService</code>实例，它使用<code class="fe mh mi mj mk b">sessionStorage</code>作为存储，而同一服务的其他实例将使用<code class="fe mh mi mj mk b">localStorage</code>。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="8281" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从Angular 6.0.0开始，可以通过在装饰器中声明<code class="fe mh mi mj mk b">providedIn: 'root'</code>来在<code class="fe mh mi mj mk b">root</code>中提供服务。手动在一个模块、另一个服务或组件中提供一个服务已经变得越来越少，因为在<code class="fe mh mi mj mk b">root</code>中提供一个服务对于大多数用例来说已经足够了。但是你几乎可以注入任何东西，不仅仅是服务，在某些情况下，比如<code class="fe mh mi mj mk b">localStorage</code>这是一种让你的代码更干净、更易维护的方式。要注入一个对象，您必须创建自己的DI令牌。然后，您将能够使用<code class="fe mh mi mj mk b">@Inject</code>装饰器注入您的对象，并在<code class="fe mh mi mj mk b">providers</code>数组中提供它。</p></div></div>    
</body>
</html>