<html>
<head>
<title>Drawing on the HTML5 Canvas with a Mouse</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用鼠标在HTML5画布上绘图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/drawing-on-the-html5-canvas-with-a-mouse-d92c7d57fb7c?source=collection_archive---------3-----------------------#2021-06-14">https://levelup.gitconnected.com/drawing-on-the-html5-canvas-with-a-mouse-d92c7d57fb7c?source=collection_archive---------3-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db57" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用画布作为艺术工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12800994aa540f6ab82d248be6f9ac45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QOwpaBJaMRaL-vxM"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Justyn Warner 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HTML5中的canvas元素是一个非常棒的多功能工具，允许创建2D和3D图形。用于从托管<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Using_images" rel="noopener ugc nofollow" target="_blank">图片</a>到直接<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript" rel="noopener ugc nofollow" target="_blank">游戏</a>的一切，其应用中不缺乏创意。</p><p id="642a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一些普通的JavaScript，可以给出一个真正的空白画布来绘制。设置笔的颜色和宽度的额外控制将允许额外的创作自由</p><h1 id="178f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置HTML</h1><p id="4169" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在深入JavaScript之前，需要建立HTML框架。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5a7a" class="mx lw it mt b gy my mz l na nb">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;Title&gt;Sketch-A-Thing&lt;/Title&gt;<br/>        &lt;link rel="stylesheet" type="text/css" href="sketch.css" media="screen"/&gt;<br/>    &lt;/head&gt;</span></pre><p id="fedf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，一个单独的CSS文件将被链接以给canvas元素一个边框。CSS代码将在下一节中提供。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e326" class="mx lw it mt b gy my mz l na nb">&lt;body&gt;</span><span id="d8d8" class="mx lw it mt b gy nc mz l na nb">    &lt;!-- Create a Header --&gt;<br/>    &lt;div&gt;<br/>        &lt;center&gt;<br/>            &lt;h1&gt;Sketch-A-Thing!&lt;/h1&gt;<br/>        &lt;/center&gt;<br/>    &lt;/div&gt;</span><span id="4bfa" class="mx lw it mt b gy nc mz l na nb">    &lt;!-- Create the Canvas Element --&gt;<br/>    &lt;div&gt;<br/>        &lt;center&gt;<br/>            &lt;canvas id = "sketchCanvas" width = "900" height = "450"&gt;&lt;/canvas&gt;<br/>        &lt;/center&gt;<br/>    &lt;/div&gt;</span></pre><p id="6126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在快速创建了一个标题之后，画布就在它自己的div元素中创建了。请注意，画布需要一个惟一的id。此外，宽度和高度是手动设置的。</p><p id="1afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要使用相对度量来设置画布的宽度和高度，例如“%”或“vh/vw”单位。这将为画布提供一组不同于页面其余部分的坐标，确保任何鼠标移动都不会与画布不成比例。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4a42" class="mx lw it mt b gy my mz l na nb">    &lt;div&gt;<br/>        &lt;center&gt;<br/>            &lt;label for="penColor"&gt;Pen Color:&lt;/label&gt;<br/>            &lt;input type="color" id="penColor" value="#000000"&gt;<br/>            &lt;label for="lineWidth"&gt;Pen Width:&lt;/label&gt;<br/>            &lt;input type="range" min="1" max="10" value="2" id="lineWidth"&gt;<br/>        &lt;/center&gt;<br/>    &lt;/div&gt;<br/>&lt;/body&gt;</span></pre><p id="f10b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面创建了设置钢笔颜色和钢笔宽度的控件。使用“color”类型的输入元素实际上会创建一个健壮的颜色选择工具，它甚至允许输入定制的RGB值。value属性设置默认颜色，在本例中是黑色。</p><p id="7b0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“范围”类型的输入元素将创建一个滑块。最小值和最大值分别设置为1到10。甚至比10更大的尺寸也是可能的，但是任何更大的尺寸都不能清晰地绘制。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d26c" class="mx lw it mt b gy my mz l na nb">&lt;script src="sketch.js"&gt;&lt;/script&gt;   <br/>&lt;/html&gt;</span></pre><p id="54df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了结束，链接到JavaScript文件。</p><h1 id="3020" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">CSS注释</h1><p id="ca92" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">CSS是严格可选的，但它确实创建了一个更整洁的外观，并且使用边框来描绘画布与背景的分离</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8ff6" class="mx lw it mt b gy my mz l na nb">body {<br/>    font-family: Verdana, sans-serif;<br/>}<br/>canvas {<br/>    border-style: solid;<br/>    border-width: 2px;<br/>    border-radius: 8px;<br/>    margin: 0;<br/>}</span></pre><p id="a370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加了无衬线字体后，画布上又添加了一个快速的圆形边框。最终结果应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b0e1c1da67c50509f308238111fc8461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mlhUSVs5pumzTxxqYp7YQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这将是用户交互的主要界面。图由作者制作。</figcaption></figure><p id="da4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这看起来很好，但它仍然缺乏任何真正的功能。</p><h1 id="1d01" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用JavaScript绘图</h1><p id="57fa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了在画布上绘图，将使用三种方法创建一个类:startDrawing、drawSketch和stopDrawing。第一个方法应该在用户单击鼠标并升起一个标志开始对画布进行更改时触发。第二个方法应该在鼠标移动并在画布上创建一条线时触发。最后，最后一个方法应该在释放鼠标时触发，并产生一个标志来停止对画布的所有更改。</p><p id="6649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看实现:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3a44" class="mx lw it mt b gy my mz l na nb">// Create a class for the canvas, including attributes for the id, // draw boolean, and coordinates<br/>class Canvas {<br/>    constructor(canvas_id, draw, coord) {          <br/>        this.canvas_id = canvas_id; <br/>        this.draw = draw;<br/>        this.coord = coord<br/>    }</span></pre><p id="bdb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">画布的类由三个属性构成。第一个属性只是画布ID，如HTML文档中定义的那样。draw属性是指示是否可以对画布进行更改的标志。coord属性表示鼠标在画布上的当前坐标。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0087" class="mx lw it mt b gy my mz l na nb">    // Sets draw to true and gets the mouse coordinates on the event<br/>    startDrawing(event) {<br/>        this.draw = true;<br/>        let canvas = document.getElementById(this.canvas_id); <br/>        this.coord.x = (event.clientX - canvas.getBoundingClientRect().left);<br/>        this.coord.y = (event.clientY - canvas.getBoundingClientRect().top);<br/>    }</span></pre><p id="890a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个方法，startDrawing，重置draw标志，使其为真，表示可能对画布进行了更改。然后，它重置x和y坐标，以匹配相对于画布元素的当前鼠标位置。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="837d" class="mx lw it mt b gy my mz l na nb">    // The actual function that will draw on event (mousemove)<br/>    drawSketch(event) {<br/>        // If the draw boolean isn't true, terminate the function<br/>         early<br/>        if (!this.draw) {<br/>            return 0;<br/>        }</span></pre><p id="2b86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个方法drawSketch首先检查draw属性以确保它已经被设置为true。如果没有，该函数将通过简单地返回0而提前终止，并且不对画布进行任何额外的更改。这很重要，因为它会在鼠标移动的任何时候被激活，无论鼠标是否被点击。这一步确保了只有当用户准备好时才会对画布进行更改。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b52b" class="mx lw it mt b gy my mz l na nb">        // Select the canvas and get its context<br/>        let canvas = document.getElementById(this.canvas_id);<br/>        let ctx = canvas.getContext('2d');</span></pre><p id="560e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两行简单地抓住了画布和它的上下文。对画布进行任何更改都需要这些步骤。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d12b" class="mx lw it mt b gy my mz l na nb">        // Start the line<br/>        ctx.beginPath();<br/>        <br/>        // Pull from the color and width from the associated <br/>        // controls. The line cap is hardcoded to be rounded,<br/>        // because it looks more natural for a drawing application<br/>        ctx.strokeStyle = document.getElementById("penColor").value;<br/>        ctx.lineWidth = document.getElementById("lineWidth").value;<br/>        ctx.lineCap = "rounded";</span></pre><p id="5c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一组线实际上开始了创建线的过程。线条的颜色称为strokeStyle，直接取自HTML中选择的任何颜色。同样，线宽从滑块中拉出。</p><p id="caea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外一个参数lineCap是硬编码的。这将使线的末端看起来很圆，比有硬边的看起来更自然。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9677" class="mx lw it mt b gy my mz l na nb">        // Start moving to the coordinates determined by mouse <br/>        // movement. The position is updated as the cursor moves<br/>        ctx.moveTo(this.coord.x, this.coord.y);<br/>        this.coord.x = (event.clientX - canvas.getBoundingClientRect().left);<br/>        this.coord.y = (event.clientY - canvas.getBoundingClientRect().top);<br/>        <br/>        // Specify where the line ends<br/>        ctx.lineTo(this.coord.x , this.coord.y);<br/>        <br/>        // Draw the line<br/>        ctx.stroke();<br/>    }</span></pre><p id="c01a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再一次，鼠标相对于画布的坐标被获取并用于确定线条的终点。一旦完成，界限就划定了。随着线条的绘制，该方法结束。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="78cf" class="mx lw it mt b gy my mz l na nb">    // Sets draw to false on event (mouseup)<br/>    stopDrawing(event) {<br/>        this.draw = false;<br/>    }<br/>}</span></pre><p id="be83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个方法只是将draw属性设置回false。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1ca6" class="mx lw it mt b gy my mz l na nb">// Write the main function that will execute on load<br/>function main() {<br/>    // Initialize the main object, canvas<br/>    let canvas = new Canvas("sketchCanvas", false, {x:0 , y:0});</span></pre><p id="c8da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为个人偏好，我喜欢将任何在启动时改变web应用程序的函数放在主函数中，并单独调用它。这样，创建了一个名为canvas的新对象，它使用canvas ID并将draw属性设置为false，默认情况下将坐标设置为(0，0)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b187" class="mx lw it mt b gy my mz l na nb">    // Add event listeners for the mousedown, mouseup, and <br/>    // mousemove. <br/>    document.addEventListener('mousedown', function(e){<br/>        canvas.startDrawing(e);<br/>        });<br/>    document.addEventListener('mouseup', function(e){<br/>        canvas.stopDrawing(e);<br/>        });<br/>    document.addEventListener('mousemove', function(e){<br/>        canvas.drawSketch(e);<br/>        });</span><span id="972c" class="mx lw it mt b gy nc mz l na nb">}</span></pre><p id="08b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加了三个事件处理程序来访问新创建对象的方法:</p><ol class=""><li id="0835" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">mousedown:当鼠标被按下时，它激活startDrawing方法，该方法允许对画布进行更改。</li><li id="7794" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">mouseup:当释放鼠标时，调用stopDrawing方法，这将停止画布的所有活动。</li><li id="cb4f" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">mousemove:每当移动鼠标时，都会调用drawSketch方法，该方法在画布上绘制线条。</li></ol><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2569" class="mx lw it mt b gy my mz l na nb">// Wait until the page is loaded before applying the main function<br/>window.addEventListener("DOMContentLoaded", ()=&gt;{        <br/>    main();<br/>});</span></pre><p id="256a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管HTML文档非常简单，但作为最佳实践，只有在DOM完全加载后才会调用main函数。</p><h1 id="1d3b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">决赛成绩</h1><p id="11ca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果一切顺利，最终结果将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/4416c38c8aa4b26b53d2ee88b8b745c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PACHW90uEvk4K-AWAMoXsA.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者制作的视频。</figcaption></figure><p id="8fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以演示笔颜色和笔宽度的进一步验证:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/d6db9015c579e96b8b83f8e6a49570dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Sxlv0GRQGcjqM8Uq2HsMQw.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者制作的视频</figcaption></figure><h1 id="a7cd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="c832" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">创建一个绘图工具可以让web开发的初学者通过一个有趣的、有创意的项目看到canvas元素的直接效用和威力。它的应用超越了简单的虚拟白板，可以用于签名或简单的照片编辑。</p></div></div>    
</body>
</html>