<html>
<head>
<title>Unit Test with PyTest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTest的单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-test-with-pytest-d6f53919a19a?source=collection_archive---------5-----------------------#2022-10-20">https://levelup.gitconnected.com/unit-test-with-pytest-d6f53919a19a?source=collection_archive---------5-----------------------#2022-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d70c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用PyTest介绍Python中的单元测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94d325339b3b46a50e548f43f2eaa7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-oFlHz_u4ksnO2rJPCNaA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Pytest徽标。<a class="ae kv" href="https://en.wikipedia.org/wiki/Pytest" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="0bca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过测试来检查代码是否工作正常。单元测试是一种软件测试方法，它检查一段代码(系统中的一个单元)是否正常工作。理想情况下，即使是最小的一段代码也应该被测试，没有测试的代码是不会被发布的。</p><p id="02ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个程序的测试过程包括不同的层次。每个级别都有自己的动态。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/ac8504a135b4271bd5382d9c8bc3bc6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joXE4p2RyvpgoXZrkcsViA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">测试金字塔。<a class="ae kv" href="https://anymindgroup.com/news/tech-blog/15053/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="b0bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在底部，最基本的层次是单元测试。如上所述，每个单元都经过测试。这个单元可以是一个方法，也可以是一个类等等。更高的层次是一起测试多个组件。它正在测试这些单元的集成互操作性。顶部是UI测试(也称为系统测试，或端到端测试)。现在，在这一层，整个建筑被测试用例。这里测试的是用例是否被满足。在这些阶段之后，是用户验收测试阶段。这部分是用户完成的。</p><p id="ec72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">较低层次的测试越详细、越多，较高层次所需的测试强度就越小。也就是说，较低层次的成功有助于上述任务。</p><p id="3451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，较低级别的测试更快(应该更快)。由于较低层次的测试数量太大，如果这些测试很慢，就会出现积压。随着你的上升，测试的数量会减少，但是持续时间会增加。与此同时，更高级别的考试费用也更高。</p><p id="f4b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">较低级别的测试旨在防止错误。以上测试检测bug。</p><p id="b624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">是什么单位？</strong>就面向对象编程而言，单位是类。对于函数式编程，它是一个函数。一个类也由多个方法组成。在面向对象的情况下，我们是接受类作为一个单元，还是接受它们的每个方法，实际上取决于我们的观点。两个都可以。</p><p id="8553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个写得好的测试清楚地展示了一个结构的解剖。</p><blockquote class="lt lu lv"><p id="65aa" class="kw kx lw ky b kz la jr lb lc ld ju le lx lg lh li ly lk ll lm lz lo lp lq lr ij bi translated">“编写单元测试的行为与其说是验证，不如说是设计。这与其说是核实，不如说是记录。编写单元测试的行为关闭了大量的反馈回路，其中最少的是与功能验证相关的回路。”罗伯特·马丁。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ma"><img src="../Images/a51b262973d4966b1153c05c1656f42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R17tQdTma2T6JfKjXeNL9w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">罗伯特·马丁。来源:<a class="ae kv" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><ul class=""><li id="548e" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated"><strong class="ky ir">测试覆盖率</strong>表示一个程序被测试的程度。当然，我们希望这个比例很高。低表示质量差，高不直接表示一切都很棒。</li><li id="7c66" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated"><strong class="ky ir"> SUT </strong>:被测系统。我们测试的任何类都是SUT。</li><li id="75e0" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated"><strong class="ky ir">文档</strong>:对组件的依赖。我们测试的组件所依赖的其他组件(依赖关系)。</li><li id="7e89" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated"><strong class="ky ir">嘲讽</strong>:我们必须将被测试的组件与其依赖项隔离开来。我们必须删除SUT中的文档。这样，bug将只属于SUT。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/25cbaa957b34c46e789b177c02f359a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhfgnYebsHyso3luNgQicQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">嘲讽。<a class="ae kv" href="https://www.accenture.com/us-en/blogs/software-engineering-blog/to-mock-or-not-to-mock-is-that-even-a-question" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="1f90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代替依赖，我们放入模拟它们的构造。</p><ul class=""><li id="9002" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated"><strong class="ky ir">测试用例</strong>:测试一个用例。</li><li id="ca48" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated"><strong class="ky ir">测试套件</strong>:许多测试用例组合在一起。</li><li id="e061" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated"><strong class="ky ir">测试方法&amp;类</strong>:测试用例经常需要测试方法，测试套件经常需要测试类。</li><li id="73a2" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">AAA: 安排，行动，断言。单元测试的阶段。安排:准备考试，准备考试，设置。Act:练习测试。断言:验证结果。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/1ac4583bcc3bac134da4dbd827d3d019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/1*QY0NxGkSwBLNJBQPK1Lqyw.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">AAA。<a class="ae kv" href="http://xunitpatterns.com/Test%20Stub.html" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><ul class=""><li id="291c" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated"><strong class="ky ir">白盒&amp;黑盒:</strong>一个单元测试就是一个白盒测试。内部结构可见。相反，系统测试是黑盒测试。系统的内部结构是不可见的，系统通过API进行测试。</li><li id="6235" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">回归:这些测试揭示了当一个单元发生变化时，系统是否会出现中断。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/40777d921bae2eee1d0b23fa9c4b2166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjYhxNWDSRqQCZS5A9Ze7A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">DALLE:一种在每一个软件上执行完整单元测试的python。(奥托·迪克斯风格)</figcaption></figure><h1 id="51b6" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">PyTest</h1><p id="8e85" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Pytest是一个单元测试框架。Python有许多不同的单元测试库，例如，unittest是一个内置库。然而，PyTest是最受欢迎的单元测试库之一，因为它有许多特性。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="dc65" class="nt ms iq np b gy nu nv l nw nx">pip install pytest</span></pre><p id="3b04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在命令行中键入<em class="lw"> pytest -h </em>以列出您可以使用的所有方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/59d3ed8f552d038d6ae71236b7918c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oihX8kqMvRyi_kdoiQ2fJg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">救命啊。图片由作者提供。</figcaption></figure><p id="12b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从简单的开始。我有一个<em class="lw"> foo </em>和一个<em class="lw"> boo </em>要测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/07e6063734df826e9a2614f6eb0e5bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0ROAt7UiX_f5q_22HMyug.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">foo和boo函数。图片由作者提供。</figcaption></figure><p id="c9cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试这些，我创建了一个名为<strong class="ky ir"><em class="lw">test</em></strong><em class="lw">_ unittest _ example . py</em>的文件。我在命名时使用了'<em class="lw"> test_ </em>'前缀，因为Pytest会自动检测带有'<em class="lw"> test </em>'前缀的文件。当我命名测试方法时，我会这样做。</p><p id="d2e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为<em class="lw"> foo </em>和<em class="lw"> boo </em>编写两个测试函数。这些函数也将以'<em class="lw"> test_' </em>前缀开始。我将在测试中使用断言构造。嘿，等一下，不管断言是什么，你都可以在继续之前记住它们。</p><div class="oa ob gp gr oc od"><a href="https://python.plainenglish.io/defensive-programming-in-python-af0266e65dfd" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">Python中的防御性编程</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">断言和异常处理</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">python .平原英语. io</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/792b9fc6f8c391693f9a9c1f5f5fcb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9So30eGv1RzkZhYOrkCZhg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">试验</figcaption></figure><p id="f414" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了运行测试，我们将在测试脚本所在的shell中运行一个命令。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="73ba" class="nt ms iq np b gy nu nv l nw nx">xxx-MacBook-Air codes % <strong class="np ir">pytest test_unittest_example.py</strong></span><span id="3696" class="nt ms iq np b gy ot nv l nw nx">OR</span><span id="095a" class="nt ms iq np b gy ot nv l nw nx">xxx-MacBook-Air codes % <strong class="np ir">py.test<br/></strong>#this will detect the test py files automatically in the folder, that's why I named the test py files and functions with the 'test' prefix.</span></pre><p id="af12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当两个测试都通过时，输出显示在shell中。您还可以在打印输出中看到测试的覆盖率(100%)以及完成它们需要多长时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/f58b1fb7ca0f39e3373cb651fceffcd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXanK0It9SWbk2j5lWk58w.png"/></div></div></figure><p id="61e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们犯一个错误，看看输出会发生什么。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="f9e4" class="nt ms iq np b gy nu nv l nw nx">#instead of<br/>#assert ue.boo(12) == 4</span><span id="a186" class="nt ms iq np b gy ot nv l nw nx">assert ue.boo(12) == 8</span></pre><p id="7b95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们有一个失败的测试和一个通过的测试。它给出了关于断言失败的信息(在我的VScode中用红色表示)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/0cc8f06bd3f0fb5ee91683923e9eee01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MqsJF9jugKy_f3Imv7KDw.png"/></div></div></figure><h2 id="5c0a" class="nt ms iq bd mt ow ox dn mx oy oz dp nb lf pa pb nd lj pc pd nf ln pe pf nh pg bi translated">选择</h2><p id="aaad" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们可以在运行shell命令时使用标志来使用PyTest的其他属性。</p><p id="9580" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> v : Verbose，</strong>显示附加信息。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="f191" class="nt ms iq np b gy nu nv l nw nx">xxx-MacBook-Air codes % pytest test_unittest_example.py<strong class="np ir"> -v</strong></span><span id="f623" class="nt ms iq np b gy ot nv l nw nx">OR </span><span id="920b" class="nt ms iq np b gy ot nv l nw nx">xxx-MacBook-Air codes % py.test<strong class="np ir"> -v</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/5aa1b4b8449a27666d22ff495f9c5f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8K_oB9XNdR9ifgM-1yh7Sg.png"/></div></div></figure><p id="89da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以看到哪些测试通过了，哪些没有通过的细节。</p><p id="1eb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为运行求和的<em class="lw"> foo </em>函数添加了另一个测试。因此，根据Python的本质，它可以将两个字符串连接在一起，我不希望这种情况发生。那么让我写一个单独的测试来检查这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/b37d3b5d59ee17574cd24add9725b58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*irDjBY04-KjMjVqzm8Bv_g.png"/></div></div></figure><p id="4e7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">失败了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/d4e4534e7d086ed9de2183e614590445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NE4qJh3SDin54lESlXL0hg.png"/></div></div></figure><p id="2bdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> -q </strong>获取简短信息。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="3061" class="nt ms iq np b gy nu nv l nw nx">py.test <strong class="np ir">-q</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/3b8523a7b0d2e6634ecd5a05a3e81a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72CJSG3pKRjGBs6IAe-QEw.png"/></div></div></figure><p id="e1ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> :: </strong>只运行测试文件中声明的测试。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="336b" class="nt ms iq np b gy nu nv l nw nx">pytest test_unittest_example.py<strong class="np ir">::test_foo</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/1fde0c3649e07f8b428e04880275aefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzzzS6EJpOvFA6JYZNlctQ.png"/></div></div></figure><p id="3ae8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> -k " " </strong>仅运行名称中包含您给出的短语的测试。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="19dc" class="nt ms iq np b gy nu nv l nw nx">pytest test_unittest_example.py -v <strong class="np ir">-k "foo"</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/caf03d08357e79fb6be8e96a04f1255d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32_ingKLrH8U5FLkOk1nLg.png"/></div></div></figure><p id="93c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们甚至可以添加逻辑运算(<em class="lw"> add，或者</em>):</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="a857" class="nt ms iq np b gy nu nv l nw nx">pytest test_unittest_example.py -v <strong class="np ir">-k "boo or input"</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/8f4f0892841e0fc52d78cdb048bc8104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtaxFEufLL9C5KDbF0CAZA.png"/></div></div></figure><p id="3893" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> -m </strong>标记表达式。类似地，我们可以用pytest装饰器标记任何测试，并且只运行它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/a90293c59244c92d9f978223fd7d53db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-W7o91pkbw7u4I9TY-rGPw.png"/></div></div></figure><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="d68a" class="nt ms iq np b gy nu nv l nw nx">py.test -v <strong class="np ir">-m num</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/8c440993e0fa3053ce4c96fc055ad01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iswR0NDF3TNFhPBYRHAw4A.png"/></div></div></figure><p id="773f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> -x </strong>提前停止。每当第一次失败发生时，pytest将终止该进程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/9f1698708a56076cd879b54862a3c1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvS7MwD7uBlxZzk498S02g.png"/></div></div></figure><p id="5653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">—-max fail = 2</strong>；n次失败后，pytest将终止该进程。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="f133" class="nt ms iq np b gy nu nv l nw nx">py.test -v --maxfail=1</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/fd1e4274cb77009e1457fa81a86f0f0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oz7ef2cKCoNz_5dGLLpHzw.png"/></div></div></figure><p id="3914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">———TB =否</strong>故障详情不会显示。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="3014" class="nt ms iq np b gy nu nv l nw nx">py.test -v -x <strong class="np ir">--tb=no</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/a0c8d11e97fe2f3c362b3b862abed474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9o3_C11LJ993W5ubqBFbog.png"/></div></div></figure><p id="01cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以定义跳过特定测试的理由。因此，我们可以为不同的目的组织测试过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/ffb92074281f54a416871e8ce27d8ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JctImc2lndZNmzU-wAC8Nw.png"/></div></div></figure><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="70cd" class="nt ms iq np b gy nu nv l nw nx">pytest -v -rsx</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/cca2d2a02428b4305e58af93706908d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfP6n7ClRyMxQ9XNBghtQw.png"/></div></div></figure><p id="1fb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">mark.skipif我们可以添加跳过的条件。下面，它检查Python版本，如果满足条件，就运行测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/d0829bb5938d43fc32062474103a8631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UPmJT6CxgS_hvFKwf4sjqw.png"/></div></div></figure><p id="f2cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> -s </strong>或<strong class="ky ir"> — -capture=no </strong>显示测试功能中的打印语句。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="0263" class="nt ms iq np b gy nu nv l nw nx">py.test -v <strong class="np ir">-s</strong></span><span id="2561" class="nt ms iq np b gy ot nv l nw nx">or</span><span id="5ac9" class="nt ms iq np b gy ot nv l nw nx">py.test -v --capture=no</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/2bd393950022331052d7a83ec4a5be18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZELy_WPsJdvHj7H9RPuZMA.png"/></div></div></figure><h2 id="9124" class="nt ms iq bd mt ow ox dn mx oy oz dp nb lf pa pb nd lj pc pd nf ln pe pf nh pg bi translated">参数化</h2><p id="806f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们可以使用Pytest的parametrize decorator来参数化测试用例。这样，我们不需要为同一个测试编写多个断言或函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/7db787910314b64d96f87b9f1d7e7c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdc7X9OsSJnoOjl4Lk38xg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/808cf7fd0a0189df9b9fca7fe4772642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDxd8MHCAm8PUSLzLDSivw.png"/></div></div></figure><h2 id="cc13" class="nt ms iq bd mt ow ox dn mx oy oz dp nb lf pa pb nd lj pc pd nf ln pe pf nh pg bi translated">固定装置</h2><p id="23b7" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">假设您有一个连接到数据库的测试用例。连接和提取数据总是很耗时。让下面的简单类结构代表数据库:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/37dcefded9ce47aa1b43683466049bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDekTDJfvCiN5X0EUX3gJw.png"/></div></div></figure><p id="4bb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们相应地编写两个不同的测试用例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/644e41d0ffc23797701430f73da007a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDH-Fd3uyDNlIEfodritdw.png"/></div></div></figure><p id="da41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，这里有重复的过程。在这两个测试中，我们从一开始就连接到数据库。相反，我们可以通过在测试过程的开始和结束时识别公共操作来消除重复。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/6f354c12fdac11375854ead00069f266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jw1pEsKAwpgneutwdm4ZlQ.png"/></div></div></figure><p id="3325" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lw"> setup_module </em>功能在测试模块第一次启动时运行。<em class="lw"> teardown_module </em>函数在测试模块结束时运行。Pytest会自动检测到它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/9391a47999162effef9f9746ea830e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u963jIkBVR8czEzuN2ujHA.png"/></div></div></figure><p id="8acf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们连接数据库，并且只关闭一次连接。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/783218d27390d6f6d9a8f95860759818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Byb7Jh1SU1hm-_eZ_0zMw.png"/></div></div></figure><p id="37e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种处理方法是使用Pytest的<em class="lw"> fixture </em> decorator。我们定义了一个包含安装和拆卸部分的函数。我们用关键字<em class="lw"> yield </em>返回<em class="lw"> db </em>对象。<em class="lw">屈服</em>之后，剩下的就是拆机部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/74888e30aa8739d5d9b55ed9c054f857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iT4nWe0MJMWisqdwHm351w.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/6c6ebbccf04fcfcd4d20d26fdf1cfcae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A-DCjIy6a7M4siLJSytZUA.png"/></div></div></figure><p id="12a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看另一个例子。在下面的例子中，有一个飞机类(<em class="lw"> Flight </em>)和一个客户数据库类(<em class="lw"> CustomerDb </em>)。我们可以将乘客添加到<em class="lw">航班</em>班，得到乘客名单，得到乘客总数，计算总收入。<em class="lw">客户数据库</em>根据客户的会员身份确定折扣率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr ps l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">班级</figcaption></figure><p id="80ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们测试以这种方式设计的应用程序的各种情况。</p><ul class=""><li id="172d" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">能不能无缝加乘客？</li><li id="03cb" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">我们添加的乘客是否包含在乘客列表中？</li><li id="3360" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">当飞机满员时，我们不能增加新的乘客，这是必要的，有什么措施来应对这种情况吗？</li><li id="b360" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">我们能正确计算总收入吗？</li></ul><p id="77db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一个一个地做这些测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr ps l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">测试</figcaption></figure><p id="f849" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始时，我们在某种程度上设置测试，防止我们在夹具的帮助下陷入重复。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/03b66f74d4533ff38c04d2b91aa93a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7GQqmVHI12f6-xmFfQ4aQ.png"/></div></div></figure><p id="8f7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们在fixture中返回了两个变量，所以我们得到了一个tuple。因此，为了访问<em class="lw"> Flight </em>对象，我们需要获取第0个索引。我们已经增加了3名乘客。卢克&amp;布鲁诺成为第四名乘客。</p><h2 id="adb9" class="nt ms iq bd mt ow ox dn mx oy oz dp nb lf pa pb nd lj pc pd nf ln pe pf nh pg bi translated"><strong class="ak">捕捉抛出的错误</strong></h2><p id="8450" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果容量已满，我们想要添加另一个乘客，请记住我们引发了一个<em class="lw"> OverflowError。</em></p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="4834" class="nt ms iq np b gy nu nv l nw nx">if booked == <em class="lw">self</em>.capacity:<br/>     raise <em class="lw">OverflowError</em>("Flight is fully booked!")</span></pre><p id="c213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以捕捉测试中发送的错误，并做出相应的调整。例如，在下面的测试中，由于<em class="lw"> OverflowError </em>是我预期的错误，所以我确保如果遇到这种情况，它不会给出错误。在带有关键字的<em class="lw">行之后，我可以发出任何我想要的命令。<br/>但是，如果我尝试添加3个新乘客而不是2个新乘客，测试将不会通过，因为这个过程将在带有</em>表达式的<em class="lw">之上。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/9a65afde437496bdc427835efbef6cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SCNrZutDhFsTItRnk9y1WQ.png"/></div></div></figure><h2 id="893a" class="nt ms iq bd mt ow ox dn mx oy oz dp nb lf pa pb nd lj pc pd nf ln pe pf nh pg bi translated">嘲弄的</h2><p id="6387" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">您可能还记得，模仿过程是在消除依赖性。第一个测试不是嘲笑。在这个测试中，处理直接在数据库上完成。如果我们希望测试独立于数据库(我们不希望数据库的变化影响测试)，我们可以应用mocking。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="9ac8" class="nt ms iq np b gy nu nv l nw nx">from unittest.mock import Mock</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/e7e7071e8a3722ae32e4e6c1e0a99df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UBczrkz4XcFxUVc4WAbHiQ.png"/></div></div></figure><p id="6819" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当调用数据库对象的<em class="lw">get _ customer _ membership</em>方法时，返回值将是一个常量(在我们的例子中是1)。</p><p id="a85f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，我们还可以用一个使用副作用的函数来定义模拟操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/425fdda7a7a9a16bd44d68e455e53673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg08dmmcZbKa0sPe-_x3Ew.png"/></div></div></figure><p id="3cc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在shell中运行pytest命令来检查测试结果:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="546c" class="nt ms iq np b gy nu nv l nw nx">pytest -v</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/2cc0d1b2da5cf43e9d82f7f82779db99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTUZjy2jEqDSwrMNI6MC_Q.png"/></div></div></figure><h2 id="1fc0" class="nt ms iq bd mt ow ox dn mx oy oz dp nb lf pa pb nd lj pc pd nf ln pe pf nh pg bi translated">集成测试(REST API)</h2><p id="af8f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">最后，让我们对REST API做一个集成测试案例研究。为此，我们将使用<a class="ae kv" href="https://todo.pixegami.io/docs" rel="noopener ugc nofollow" target="_blank">https://todo.pixegami.io/</a>站点。一个简单的应用程序，我们可以满足REST API请求。</p><p id="51e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到来自<a class="ae kv" href="https://todo.pixegami.io/docs" rel="noopener ugc nofollow" target="_blank">的文档。</a></p><p id="5e98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lw"> TaskUtility </em>类包含端点方法。我们在这里用静态方法执行API操作。<em class="lw"> new_task_payload </em>:为新记录创建数据。由于有了<em class="lw"> uuid </em>库，<em class="lw"> user_id </em>和<em class="lw"> content </em>被随机化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr ps l"/></div></figure><p id="091b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们检查测试用例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/e373d0b54b12b9dc3cdb5519343b0584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2mSJ1dfOHyjvtl7bVioMQ.png"/></div></div></figure><p id="5853" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果请求成功，我们需要获得200状态代码。</p><p id="d6e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个测试中，首先，我们创建一个新的任务记录，并根据响应的状态代码检查它是否成功。然后，我们使用带有任务id号的<em class="lw"> get </em>方法提取新创建的数据，并检查它是否与我们最初创建新记录时使用的内容相同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/b8518e1f3ae13cc37679b9a287e694d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xRymerLvn-IkAp5MzDHYLQ.png"/></div></div></figure><p id="f850" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新过程的类似步骤…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/d79a747bd95f5843ea957fd212213b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNrgQaNMC6b6mxhZdXFkaQ.png"/></div></div></figure><p id="97f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创造了n个新记录。然后我们根据<em class="lw"> user_id </em>拉取所有记录。我们比较数字。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/33cd58b8b274ce56aceb3ab8ce453153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXAo3i6KPnmedhKPWE9Z6A.png"/></div></div></figure><p id="4b28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似的操作…注意我们用404代码检查我们删除的记录是否真的被删除了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/7b0b9892aa9d6c1e65688a1f24d1d00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUNoCtHekZaLRcl8u4PgWQ.png"/></div></div></figure><p id="4c17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试过程对于质量代码和质量系统非常重要。在快速开发环境、时间限制和资源缺乏的情况下，它可能会被忽略或得不到必要的关注。然而，不应该跳过测试过程，尤其是当与TDD一起考虑时。</p><p id="12bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多为Python编写的测试库(包括内置的unittest库)。Pytest是业内广泛使用并得到广泛认可的库。它有许多特点。在这篇简短的博文中，我试图谈论一些关键问题。谢谢你读到这里。</p><h2 id="7e19" class="nt ms iq bd mt ow ox dn mx oy oz dp nb lf pa pb nd lj pc pd nf ln pe pf nh pg bi translated">阅读更多内容…</h2><div class="oa ob gp gr oc od"><a href="https://medium.com/@okanyenigun/test-driven-development-in-python-49fa22cb95d4" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">Python中的测试驱动开发</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">关于TDD和Python实现的细节</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="pw l oo op oq om or kp od"/></div></div></a></div><div class="oa ob gp gr oc od"><a rel="noopener  ugc nofollow" target="_blank" href="/restful-django-django-rest-framework-8b62bed31dd8"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">RESTful Django — Django REST框架</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">让我们开发一个RESTful Django项目</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="om l"><div class="px l oo op oq om or kp od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://python.plainenglish.io/defensive-programming-in-python-af0266e65dfd" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">Python中的防御性编程</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">断言和异常处理</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">python .平原英语. io</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://towardsdev.com/software-developing-requirements-35c91413c088" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">软件开发需求</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">开发需求概念的介绍</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdev.com</p></div></div><div class="om l"><div class="py l oo op oq om or kp od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://towardsdev.com/functional-programming-characteristics-8a75c38dbf1f" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">函数式编程特征</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">Scala函数式编程简介</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdev.com</p></div></div><div class="om l"><div class="pz l oo op oq om or kp od"/></div></div></a></div><h2 id="687e" class="nt ms iq bd mt ow ox dn mx oy oz dp nb lf pa pb nd lj pc pd nf ln pe pf nh pg bi translated">参考</h2><p id="2c90" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated"><a class="ae kv" href="https://pytest.org/" rel="noopener ugc nofollow" target="_blank">https://pytest.org/</a></p><p id="66d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/unittest.html</a></p><p id="b442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://realpython.com/pytest-python-testing/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/pytest-python-testing/</a></p><p id="3454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=YbpKMIUjvK8&amp;t=1055s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=YbpKMIUjvK8&amp;t = 1055s</a></p><p id="dc83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">https://www.youtube.com/watch?v=_QtM7QGuj1A&amp;list = pls 1 qulwo 1 rianfuz 4 zrztwlcjgkpxht-H</p><p id="4d6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">https://www.youtube.com/watch?v=7dgQRVqF1N0&amp;t = 1558s</p></div></div>    
</body>
</html>