<html>
<head>
<title>Implementing Recursion with the Y Combinator in any Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在任何语言中用Y组合子实现递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-recursion-with-the-y-combinator-in-any-language-9e83fa369ca?source=collection_archive---------2-----------------------#2019-06-19">https://levelup.gitconnected.com/implementing-recursion-with-the-y-combinator-in-any-language-9e83fa369ca?source=collection_archive---------2-----------------------#2019-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6261c79c34f6460e6aba6b2276890b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mL6-YwTZjy1GTOUMuSm18A.png"/></div></div></figure><p id="473b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对<strong class="kd iu">λ演算</strong>的新认识？我建议在继续之前阅读JavaScript中的<a class="ae kz" href="https://medium.com/openmindonline/lambda-calculus-in-javascript-1ee947cadb21" rel="noopener"> <strong class="kd iu"> Lambda演算</strong> </a>！</p><p id="1325" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Y组合子是一个<strong class="kd iu">定点高阶函数</strong>，用于在任何本身不支持递归的编程语言中实现递归。它是由数学家和逻辑学家哈斯克尔·库里在20世纪40年代提出的，被认为是编程和逻辑中最美妙的想法之一。我们将看到如何用6种编程语言实现这段令人惊叹的代码:</p><ul class=""><li id="6ce7" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu"> JavaScript </strong></li><li id="0819" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">哈斯克尔</li><li id="6637" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu"> Java </strong></li><li id="1b20" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">球拍</strong></li><li id="d361" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu"> Python </strong></li><li id="8b6b" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu"> C </strong></li></ul><h1 id="0fd3" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">λ演算中的原始Y组合子</h1><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/c6b6630abec295ebfde4fda99d20a73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCVchKYoBTNSzFh6q3EVBw.png"/></div></div></figure><p id="d0ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们刚刚用不到30个字符表达了计算机科学中最强大的概念之一。<br/>你可能已经猜到了，我们只是写下了<code class="fe mr ms mt mu b">Y</code> <strong class="kd iu">抽象</strong>。它的实际应用是什么？<br/>让我们使用典型的<strong class="kd iu">阶乘</strong>例子。</p><p id="fc1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个数<code class="fe mr ms mt mu b">n</code>的阶乘是<code class="fe mr ms mt mu b">0</code>和<code class="fe mr ms mt mu b">n</code>之间所有正整数的乘积。<br/>我们可以很容易地用递归来求任意正整数的阶乘(用伪代码):</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/ab0d647a50d2fad1e8a7b66435666a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vq5Rb7AAzA1Fuv_Ou76iMA.png"/></div></div></figure><p id="7816" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以让我们假设我们必须计算<code class="fe mr ms mt mu b">3</code>的阶乘；采用上面的解决方案，我们将以如下方式执行我们的函数:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/0ccb86082ad83a84a8ee181d09faf3cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2XUU_-1yzeV4vJlTOBIaw.png"/></div></div></figure><p id="9aa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，我们在<code class="fe mr ms mt mu b">factorial</code>函数内部调用了<code class="fe mr ms mt mu b">factorial</code>函数。这是递归如何工作的一个简单例子，并不是每种语言都支持这种编程风格！</p><p id="6550" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Y组合器</strong>来了。让我们从用JavaScript实现它开始:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/878d98ad6f67e9f07d595458dc75d8af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16LcZF_R6paVxuJiF5w6uQ.png"/></div></div></figure><p id="60f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其实挺简单的！如你所见，这非常接近我们上面用<strong class="kd iu"> Lamba Calculus </strong>符号写的代码！现在，我们需要实现我们的函数，它将计算给定整数的阶乘:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/5536567fe88894ce77df3267ae6e2653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5h_a1omZQU5gPThSjWMeMg.png"/></div></div></figure><p id="1cd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了！如您所见，我们没有将整数作为第一个参数，而是创建了一个返回匿名函数的函数，该函数将整数作为唯一的参数。这样，我们对<code class="fe mr ms mt mu b">f</code>调用进行了参数化，这将在我们的<code class="fe mr ms mt mu b">Y</code>实现中使用。</p><p id="cccc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们使用我们刚刚在上面写的<strong class="kd iu"> Y组合子</strong>调用<code class="fe mr ms mt mu b">factorial</code>函数，这里是:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/67f4809469fe72d3dc2248490f2627cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDqbZFkWJL71stChILvWdg.png"/></div></div></figure><p id="71de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以调用我们的<strong class="kd iu"> Y组合子</strong>内部的任何递归函数，避免<a class="ae kz" href="https://medium.com/openmindonline/js-monday-06-adopting-memory-safe-recursion-d26dcee409c9" rel="noopener"> <strong class="kd iu">运行时内存异常</strong> </a>！</p><h1 id="74a1" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Haskell中的y组合子</h1><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/a9016730ec1449a7a87a90b734d9c88b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3d1f17EJJuogU_K-iDuSWQ.png"/></div></div></figure><p id="dd33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，当你来自于λ演算符号时，在Haskell中编写Y组合子抽象是非常容易的！<br/>顺便说一下，这段代码不会编译，因为<code class="fe mr ms mt mu b">(x x)</code>需要一个无限类型。<br/>因此，我们必须选择是采用<strong class="kd iu">不安全强制</strong>并使其生效，还是改变方法:</p><p id="abc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">使用不安全胁迫(unsafe): </strong></p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/9c723715382ed5db91d6b4d356137b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UenRSx6nmv_XGEUgzxQ5Rw.png"/></div></div></figure><p id="06d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">采用非递归解决方案(安全):</strong></p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/6500dbf2191a90d7d6f891e44a8cf17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxX_OynhJg2yStydWcGKOA.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated"><a class="ae kz" href="https://stackoverflow.com/questions/4273413/y-combinator-in-haskell/5885270#5885270" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/4273413/y-combinator-in-haskell/5885270 # 5885270</a></figcaption></figure><p id="4538" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了简单起见，我们将使用<strong class="kd iu">不安全的</strong>版本，它更容易展示和解释。让我们在<strong class="kd iu"> Haskell </strong>中实现阶乘函数吧！</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/57155bb635d2eee4b01b2d3250866ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0TVuKfhlPLW3A-V1BVLEA.png"/></div></div></figure><p id="4278" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以使用之前定义的<strong class="kd iu"> Y组合子</strong>调用阶乘函数:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/cab0ef0808497bb03bdbbe464735677a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13G6eO9GA2jFrzjS8iKV1w.png"/></div></div></figure><p id="2af8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其实挺酷的！但是我发现在Haskell 中实现这种解决方案更“概念性”，Haskell已经对递归有了惊人的支持。</p><h1 id="f382" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Java中的y组合子</h1><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/f06894992ba8170402860575d80496bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBmv040v28M07O5Y24qZeQ.png"/></div></div></figure><p id="7835" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我不得不承认:我不是Java专家，这实际上是我写过的最复杂的代码……但它确实有效！它向您展示了Java中传统的命令式/面向对象方法的替代方法。<br/>我并不是说每次在Java中使用递归解决问题时都应该使用这种方法:相反，我坚信上面的例子向您展示了<strong class="kd iu"> Lambda演算</strong>实际上可以像<strong class="kd iu">图灵机</strong>一样完整，这是命令式和面向对象语言(如Java)的基础！</p><h1 id="bd9b" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">球拍中的y组合子</h1><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/fedd75272add735bdf70b321363d784f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*efef8MAb3vIOC0HZ6dizGQ.png"/></div></div></figure><p id="5810" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">拍</strong>实现基本上与<strong class="kd iu">λ演算</strong>一模一样！它们实际上非常相似，这种语言显示了它与λ演算符号有多接近，λ演算符号是任何LISP编程语言的基础！</p><h1 id="abed" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Python中的y组合子</h1><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/43ae38cc521a18ccfe3316808ef0c2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9MsTMHir2Ij9kazzAhLoQ.png"/></div></div></figure><p id="6b51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python中的Y组合子实际上很容易实现，但是因为它的lambda语法有点“混乱”。它的工作方式是显而易见的，使用Python的开发人员肯定会理解<strong class="kd iu"> Y组合子</strong>是如何工作的！</p><h1 id="84da" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">C语言中的y组合子</h1><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/4770ec2a495507e0e8074b869a2b6c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zb1t6AzbwsYm3vIdaWtkow.png"/></div></div></figure><p id="2e46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这可能是我一生中最糟糕的想法。尽管如此，看到一个基本上100%基于<strong class="kd iu">图灵机</strong>的语言仍然可以实现这样一个从<strong class="kd iu">λ演算</strong>中派生出来的抽象概念，还是很令人满意的！</p><p id="6961" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">纯C </strong>解决方案甚至不接近<strong class="kd iu"> Lambda演算</strong>的定义，但做了同样的工作，表现出色！</p><h1 id="f686" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="e2a1" class="pw-post-body-paragraph kb kc it kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">正如我们在Java和C的例子中所看到的，<strong class="kd iu"> Lambda Calculus </strong>概念仍然可以用与它们的核心完全不同的语言来表达。Lambda微积分是一个令人惊奇的话题，完全值得花些时间去学习。其实是思想转变！</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><a href="https://github.com/sponsors/micheleriva"><div class="gh gi nf"><img src="../Images/e05f00ed2cddfd2907284cb397168c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAIiY1uBKSNdw12oq2BbjA.png"/></div></a></figure></div></div>    
</body>
</html>