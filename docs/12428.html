<html>
<head>
<title>Adding Encryption-at-Rest to Your Web App with Mrs. Jeggers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Jeggers夫人一起向您的Web应用程序添加静态加密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adding-encryption-at-rest-to-your-web-app-with-mrs-jeggers-f50b037fbc54?source=collection_archive---------9-----------------------#2022-06-10">https://levelup.gitconnected.com/adding-encryption-at-rest-to-your-web-app-with-mrs-jeggers-f50b037fbc54?source=collection_archive---------9-----------------------#2022-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7f9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我写了一篇<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/why-would-a-web-app-need-encryption-at-rest-3efd10c145e1">的前一篇文章，解释了为什么你会想把静态加密</a>添加到一个<a class="ae kl" href="https://offlinefirst.org/" rel="noopener ugc nofollow" target="_blank">离线优先</a>的网络应用中。</p><p id="39a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">快速回答“为什么？”</strong>:您通常从web服务访问的数据将从永久存储器中取出，以允许离线访问。也许这些数据是敏感的，值得保护。在上一篇文章中，我还谈到了一些攻击媒介以及在哪里安全地存储解密密钥的问题。</p><p id="dc7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将解释一个简单的体系结构，它将使您的离线数据保持合理的安全性，并满足大多数用例。该架构与您选择的web应用框架无关，例如React、Vue、Angular等。，但将假设运行Javascript的单页应用程序(SPA)。重要的是，这里没有发明新的加密算法或协议。我遵循了PKCS第五期关于基于密码的加密的建议。</p><p id="9e60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">展示静态加密的完整web应用程序演示在这里是<a class="ae kl" href="https://seespacelabs.com/enc-at-rest/" rel="noopener ugc nofollow" target="_blank"/>以及在Github 上提供的<a class="ae kl" href="https://github.com/erikh2000/encryption-at-rest-poc" rel="noopener ugc nofollow" target="_blank">完整源代码。<strong class="jp ir">在重用这个源码之前，请，请，阅读我在文章末尾的警告。</strong></a></p><p id="5f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 7/9/22更新:</strong>我已经发布了<a class="ae kl" href="https://www.npmjs.com/package/web-enc-at-rest" rel="noopener ugc nofollow" target="_blank"> web-enc-at-rest NPM包</a>，它极大地简化了创建一个像本文中描述的应用程序。</p><h1 id="c8cd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">杰格斯夫人</h1><p id="05ac" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我不可能写出这样的东西而脑子里没有听到声音。质问我。评判我。对我提出令人痛苦的有效观点。</p><p id="c7bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在这篇文章中展现我的七年级英语老师，杰格斯女士，来代表这些批评的声音。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/fea9bc534bc83096f4487ee2487efee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjlJWQTUqTclZrADiUCqHw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">啊，杰格斯太太——她是一位令人敬畏的教育家。就像玛丽·波平斯和西蒙·考威尔合二为一。</figcaption></figure><p id="469f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有进一步的告别，我介绍…</p><h1 id="3b66" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">静态加密体系结构</h1><p id="956d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">哦，天啊。我说得好像这是件大事。这是我想到的:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mf"><img src="../Images/6eb2a15ab6f62e8bdf5aea2ef6c2673b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRWLebCSOS68b1_5YdnBEA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">地貌</figcaption></figure><ul class=""><li id="44f6" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">网络浏览器 —对，就是个网络浏览器。但它也可以被认为是应用程序代码、持久存储、域对象模型(DOM)和进程内存的容器。</li><li id="7edc" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">对称加密/解密</strong> —实现对称加密的库，如NaCl Secretbox (Salsa20)、Web Crypto (AES)。</li><li id="2f92" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">内存存储</strong> —以方便的方式为您的web应用程序代码存储明文(解密数据)的内存数据结构，例如Redux或MobX存储。</li><li id="48fd" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir"> Keygen数据</strong> —它保存了少量明文数据，用于从用户的密码中导出一个密钥。这些数据存储在浏览器永久存储器中，例如IndexedDB或LocalStorage。</li><li id="4a67" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">加密的应用数据</strong> —它在浏览器永久存储器中保存你想要加密的敏感应用数据。</li><li id="85e3" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">普通应用数据</strong> —它保存你不需要加密的应用数据。这些数据存储在浏览器的永久存储器中。</li></ul><p id="3c5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意“<em class="mu">明文</em>”适用于所有类型的数据，而不仅仅是文本。它只是意味着未加密的数据。反之，“<em class="mu">密文</em>是加密的数据。</p><h1 id="144e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">我的堆栈选择</h1><p id="3620" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">除了这篇文章，我还写了一个概念验证(POC) web应用程序。以下是我选择的堆栈:</p><ul class=""><li id="672c" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><strong class="jp ir"> React/Typescript </strong> —这些框架无论如何都不是架构的基础。我目前只是精通它们。</li><li id="84b2" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Crypto" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Web Crypto</strong></a>—具体来说，我用了Web Crypto的AES-GCM(对称加密)和PBKDF2(密钥派生)。这是一个内置的API <a class="ae kl" href="https://caniuse.com/?search=web%20crypto" rel="noopener ugc nofollow" target="_blank">，可以在所有流行的浏览器</a>中使用。</li><li id="c4c3" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">indexed db</strong></a>—indexed db是存储大量数据(数百兆字节)和支持所有流行浏览器的明确选择。</li></ul><p id="2893" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我起草了一堆关于<a class="ae kl" href="https://tweetnacl.js.org/#/" rel="noopener ugc nofollow" target="_blank"> TweetNaCl.js </a>的东西，把它比作网络加密。但是我认为这些内容属于另一篇文章。现在，我只想说我喜欢TweetNaCl.js，它工作得很好。但是我更喜欢使用Web Crypto的AES-GCM(和其他加密特性)的本地实现来获得更快的速度。还有其他原因，我拒绝在这里没有支持的论点。</p><h1 id="f1c7" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">POC应用程序</h1><p id="ae60" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我的概念验证(POC)应用程序非常简单。它只有两个屏幕。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mv"><img src="../Images/8420f87d8cd1a3b01b6d406d479c39c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIsscIpgtNXgQ-sWQKboOA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">你可以登录，做一些事情，然后退出。</figcaption></figure><p id="3e7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在“登录屏幕”上，输入一些凭证，然后单击“登录”或“创建帐户”按钮。在应用程序中没有执行实际的身份验证，(为了简单起见，省略了)，但提供的密码必须正确，才能成功解密数据。</p><p id="f793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到达主屏幕后，来自IndexedDB的加密数据被检索并显示在“敏感数据”文本框中。您可以编辑并重新保存它。</p><p id="58c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更改密码将重新加密敏感数据，以便您将来可以使用新密码。</p><p id="952c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注销将清除内存中的任何敏感数据，并返回到登录屏幕。</p><p id="61ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将更详细地介绍上面的每个用例。</p><h1 id="18e6" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">用例:登录</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mw"><img src="../Images/e511dcdda66e0e6649359dd4696966cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqbQWxeZyyzOe9eiRoHzYQ.png"/></div></div></figure><p id="36b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.用户提供身份认证所需的凭据。</p><p id="746b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.App检查Keygen数据(IndexedDB)中的现有salt值。如果没有，App将创建一个新的随机值并存储在那里。</p><p id="5315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.App使用密码和salt作为输入，使用PBKDF2导出凭证密钥。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mx"><img src="../Images/a94ea853ac492a6d76b5b8998322c95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmapaNDWrZlxRs7CN0igxw.png"/></div></div></figure><p id="2015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.App从IndexedDB加载加密的App数据为IV +密文(加密数据)。该数据有一个前缀，其中包括之前用于加密数据密文部分的IV。(每个单独的加密使用一个唯一的IV。)</p><p id="2ba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.App使用密文和IV前缀作为输入，通过AES-GCM对加密的App数据进行解密。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi my"><img src="../Images/1e8e03a4dc7b121dc1219bccb4b3f25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tI9YUM6HUFg5U5U9o4H7ew.png"/></div></div></figure><p id="6d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.应用程序将新解密的数据复制到内存存储中，现在应用程序可以轻松使用这些数据。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/e039c4718700e18a2a68555ed7ab67fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYhMdqHn6VHSIUicI_J5Ug.png"/></div></div></figure><h1 id="637b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">为密钥派生重用相同的Salt值(我知道我知道我知道…)</h1><p id="8e76" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">对于几乎所有基于密码的加密(PBE)用例，每次都必须从相同的输入中获得相同的密钥。否则，该密钥将无法解密同一用户使用同一密码在之前的会话中生成的密文。</p><p id="d5b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">毫无疑问，你以前用过PBE。有人发给你一个需要你输入密码的ZIP文件吗？当您输入密码时，将从中导出一个密钥，用于解密存档。如果那个密钥和用来加密的密钥不一样，那么…你将不能进入存档。</p><p id="3c85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重用的salt仅限于用PBKDF2派生一个密钥。派生的密钥只保存在浏览器的进程内存中(不保存到存储中)。盐是为应用程序的每个用户随机生成的。因此，具有相同密码的两个用户将得到两个不同的密钥。</p><p id="3f67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在某些系统中，重复使用的salt可能允许重放攻击。上述“登录”用例不包括网络通信，也不包括攻击者有机会向系统组件发送重放消息的系统。例外情况是，攻击者可以查看浏览器进程内存或在浏览器中执行任意代码。但是在这些情况下，攻击者可以广泛地访问许多有价值或者更有价值的东西，比如用户输入的密码(例如键盘记录器)或者加载到内存中的数据本身。</p><p id="d6d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重复使用的盐会暴露另一种攻击媒介。假设攻击者可以使用相同的加密过程和salt来生成大量的加密值。如果这些攻击者的加密之一与应用程序加密的数据匹配，那么攻击者将知道应用程序使用的明文值输入。我的特定用例不受这种攻击的影响，因为没有应用程序加密的值(派生密钥)可供攻击者进行比较。同样，我在上一段中描述了相同的浏览器进程/执行任意代码警告。</p><p id="4c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这里的密钥保护原则是，我们从不将凭证密钥(从密码派生的密钥)存储在除内存之外的任何地方。</p><p id="3123" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要更好地解释为什么我们在密码学中使用salt，请参阅Ricardo Baylon的<a class="ae kl" href="https://ricardobaylon.wordpress.com/2013/10/06/salt-and-iv-explained/" rel="noopener ugc nofollow" target="_blank"> Salt and IV Explained </a>文章。有关针对基于密码的加密的潜在攻击的更多信息和一组经过充分研究的建议，请阅读针对PKCS#5的<a class="ae kl" href="https://datatracker.ietf.org/doc/html/rfc2898/" rel="noopener ugc nofollow" target="_blank"> IETF的RFC 2898 </a>。</p><h1 id="2e7c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">用例:保存应用程序数据</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi na"><img src="../Images/33cc694b73703ecaae1cad92add304c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SmGpWYoC2cboZ7kb_jaQpA.png"/></div></div></figure><ol class=""><li id="99fb" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk nb mm mn mo bi translated">用户对数据进行更改，并开始在UI中保存数据。</li><li id="a23f" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nb mm mn mo bi translated">App将数据作为明文存储在内存存储中。</li><li id="d3f5" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nb mm mn mo bi translated">App使用凭证密钥、新的随机IV和明文作为输入，通过AES-GCM将数据加密为密文。</li><li id="1577" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk nb mm mn mo bi translated">App将IV+密文值写入加密的App数据(IndexedDB)。</li></ol><p id="ccdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对每次加密都使用唯一的IV值。如果攻击者获得了用户设备文件系统的访问权限，我们的应用程序数据的密文将是可用的。在这种情况和其他一些情况下，如果我没有唯一的IV值，那么寻找/生成匹配密文来推断明文的攻击就可能成功。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nc"><img src="../Images/92425699334e6c0854c216fdec7be9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-QBgISSOSqOZQrIkg847w.png"/></div></div></figure><p id="3d9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">杰格斯太太，没事的。内存存储没什么特别的。它只是web应用程序通常用来操作的任何数据结构。内存中的存储可以是React的<code class="fe nd ne nf ng b">useState()</code>钩子、Redux存储、模块中声明的全局变量，或者对工程师来说方便的任何东西。并且数据必须是明文。因为它将由应用程序使用，无需进一步翻译。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/bb1c25ec81e242841b201602b0029769.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnH8HjmMTHB1NHD_WOCiNw.png"/></div></div></figure><h1 id="68c9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">用例:更改密码</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nh"><img src="../Images/9f287ed9df5d1193834616b04062ae9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QHi--RGMg7qCS4-Z0r67yA.png"/></div></div></figure><p id="a2fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.用户更改他们的密码。</p><p id="cc45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.App使用来自内存的凭据密钥和来自加密的App数据的IV+密文作为输入，通过AES-GCM对加密的App数据进行解密。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ni"><img src="../Images/064e4a51ae43d58daf57d075b414661b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZXYuuCPvJx8946DybDtYg.png"/></div></div></figure><p id="bb28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.App从Keygen数据(IndexedDB)中检索salt值。</p><p id="bfc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.App使用新密码和salt作为输入，通过PBKDF2导出新的凭据密钥。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mf"><img src="../Images/e6f57f93054c7f91c0071f9fa5f44ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lutgFkr8fSP-ylf7_WDwYA.png"/></div></div></figure><p id="4a8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.App使用凭证密钥、新的随机IV和明文作为输入，通过AES-GCM将数据加密为密文。</p><p id="c8d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.App将一个salt +密文值写入加密的App数据(IndexedDB)。</p><p id="f2a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">以上步骤中缺失:</strong>任何与认证web服务或其他来源的交互对用户凭证的真实性。这超出了我的概念验证范围。但是请注意，在继续其他步骤之前，步骤1应该已经成功完成。并且实现应该适当地中止/回滚，以使应用程序处于良好状态，用户在登录后仍然可以访问他们的加密应用程序数据。</p><p id="2ace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个基于PBE的架构中，密码与访问数据紧密相关。假设在您的实现中，您不能保证用户的密码总是与数据加密相匹配。最糟糕的情况就像丢失了你的比特币钱包的密码。加密的数据被分块存储——在这一点上实际上毫无价值。你所能做的就是重新创建应用程序数据。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/7d0769b81414b4c3841e7708b9faf6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2mFENA1M7X5zuLvdd5y0A.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">不要把你的用户数据做成砖块。</figcaption></figure><p id="405a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一些方法可以防止数据被阻塞，但是它们会使体系结构变得复杂。加上杰格夫人的插话，这篇文章已经够长了。简而言之，您可以拥有一个身份验证web服务，该服务生成密钥，并在身份验证成功后在服务响应中将它们提供给应用程序。这种集中化允许您将密钥与密码分离开来。</p><p id="ef89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我决定不在每次用户更改密码时重新生成salt。它没有提供安全优势。在某些情况下，它的缺点是会向攻击者提供用户何时更改了密码的信息。</p><h1 id="ff92" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">用例:注销</h1><p id="0a16" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这是一个简单的问题，但是不能忘记。当用户注销时，只需从内存中清除所有秘密。这肯定包括凭证密钥，它可以让攻击者访问IndexedDB中的所有现在和将来的数据。但也可能清除内存存储。</p><h1 id="0f8e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">更快的解密=我们可以存储更敏感的数据</h1><p id="4807" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在我的架构中，解密速度是可以访问多少敏感数据的实际限制。当应用程序加载时，它需要从IndexedDB中解密所有敏感数据，并将其作为明文放入内存存储中。如果我在解密数据时打开加载屏幕10秒钟，那么这个解决方案可能比不上从web服务加载数据。</p><p id="e38b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以当我看到我的弱酱2015 MacBook以每兆13毫秒的速度解密时，我松了一口气。</p><p id="27f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不止是如释重负。我很开心！</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/096d9c51870da239d7771ec0c0a96a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-q9vcUJcPpyI93lFzH5PQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">总有快乐的时候。不要欺骗自己。</figcaption></figure><p id="4692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有大量数据的测试遵循线性函数，例如o(n)。想解密百兆？那将是1.3秒的等待。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nj"><img src="../Images/330a8de2ccbd64109654ff94f96a183f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jKaxZx9HDQAliorO85AXRg.png"/></div></div></figure><p id="40b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是使用网络加密的AES-GCM。TweetNaCl.js要慢得多，可能是由于非本机实现。我将在另一篇文章中保存基准数据和更仔细的比较。</p><h1 id="b762" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">速度的普通应用程序数据</h1><p id="ccdc" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">因此，AES-GCM的网络加密足够快，足以证明定期加密和解密数百兆字节的数据。但是我想尽可能避免延误，你也应该这样。</p><p id="2d4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我从一开始就计划在IndexedDB存储(RDBMS术语中的“表”)的粒度上将数据分为“敏感的”和“公共的”。然后就是不要加密“公共”数据。</p><h1 id="5e7c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">明文===公共</h1><p id="7e36" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">“公共”是一个很好的数据分类名称，可以提醒您哪些内容存在风险。</p><p id="079d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设你所有的网络应用程序的持久存储的明文将会被发布在网络的某个黑暗的角落，让世界上所有的坏人都可以看到。结果会怎样？</p><p id="106c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的用户被doxxed了吗？你为一次社会攻击提供了可信的细节吗？有没有发布看似无害的数据，可以结合其他数据或者很好的猜测来学习敏感数据？</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/1b55fab2b29643353d91cb8678ad237a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceNkJSEYduBU5y10GNXbRQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">就在今年，我已经接到两个骗子的电话，他们利用我的个人信息。</figcaption></figure><h1 id="1972" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">将凭证密钥放在不好的地方的诱惑</h1><p id="9494" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果你有一个网站，在典型的<a class="ae kl" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">微前端架构</a>中包含多个网络应用，那么有一个很大的陷阱需要避免。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nk"><img src="../Images/6b942c03f2012c991b53044458fb373f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4nJ_Qmevd-owWPrncfUnA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">当DOM重新加载时，您不再拥有凭证密钥。</figcaption></figure><p id="155c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您在SPA web应用程序之间切换时，DOM将会重新加载，您将会丢失凭据密钥。您可能已经有了一个完全独立于静态加密web应用程序的auth web应用程序。在这种情况下，在auth web应用程序从自身导航到您的web应用程序或其他地方后，您将会丢失凭据密钥。</p><p id="d977" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者你可能有网页的服务器端渲染——常见于WordPress、其他CMS或pre-SPA web应用。</p><p id="fade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个关键的概念是，每次DOM重新加载时，您都会丢失凭证密钥。</p><p id="d1ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一些可怕的事情，你应该<em class="mu">而不是</em>去应对:</p><ul class=""><li id="01e8" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><strong class="jp ir">不要把证书密钥放在饼干里。</strong></li><li id="1f59" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">不要</strong>将凭证密钥放在querystring参数中。</li><li id="9100" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">不要</strong>将凭证密钥放在任何浏览器永久存储器中。(IndexedDB、LocalStorage、WebSQL等。)</li><li id="5624" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><strong class="jp ir">不要</strong>将凭证密钥放在SessionStorage中。(大概吧。下面看到更多细致入微的想法。)</li></ul><p id="a0e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您跨越web应用程序边界时，您可以重新获得凭据密钥的一些好方法:</p><ul class=""><li id="8890" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">再次提示用户输入凭据并重新生成凭据密钥。<strong class="jp ir">或……</strong></li><li id="400b" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">需要时，使用auth web服务请求凭据密钥。<strong class="jp ir">或……</strong></li><li id="d85b" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">使用容器页面将SPA web应用程序加载到其中，而无需重新加载DOM。(复杂。本文就不赘述了。)</li></ul><p id="956e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" rel="noopener ugc nofollow" target="_blank">会话存储</a>吗？老实说，我不确定。假设浏览器实现(Brave、Firefox、Chrome等)将凭证密钥写入磁盘。然后，攻击者可以在与会话相关联的浏览器选项卡仍然打开时从文件系统中获取密钥。所以乍一看，SessionStorage似乎风险太大。为了让自己放心，我必须在某处阅读一个实现标准，该标准对SessionStorage提出了一些约束。</p><p id="cb8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">凭证密钥需要是短暂的。它不应该在磁盘上。当您关闭浏览器选项卡或注销时，它需要从内存中消失。</p><h1 id="75ce" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">索引b考虑事项</h1><p id="82ad" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我的POC代码直接调用IndexedDB API。但是我不得不说，这个令人费解的API只是<em class="mu">乞求</em>包装起来。如果你想要和IndexedDB一样的特性，但是有一个更好的基于承诺的界面，试试Jake Archibald的IDB。如果你想要一个简单的键/值API来处理<code class="fe nd ne nf ng b">get()</code>和<code class="fe nd ne nf ng b">set()</code>，我可以推荐我在<a class="ae kl" href="https://github.com/erikh2000/chirp" rel="noopener ugc nofollow" target="_blank"> Chirp </a>中使用的<a class="ae kl" href="https://www.npmjs.com/package/localforage" rel="noopener ugc nofollow" target="_blank">local feed</a>，一个离线优先的开源web应用。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nl"><img src="../Images/46842dc2189d2bf16cb23702039926c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uny4tbdMJKYkAqLyzyVvJw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">黑客对Chrome开发工具内部敏感数据的看法。</figcaption></figure><p id="333b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，即使有这种静态enc体系结构的保护，攻击者仍然可以了解到以下情况:</p><ul class=""><li id="f155" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">IndexedDB存储(表)的名称。</li><li id="ee88" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">存储中对象(行)的数量。</li><li id="4e0e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">对象中字段的名称。</li><li id="0500" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">对象的键路径(主键)值。</li></ul><p id="c67d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以混淆其中的一些东西，例如把所有的字段放入一个blob中，使用无意义的存储/字段名称。但是请记住，当您将web应用程序部署到网站时，您的web应用程序的源代码就是公开的。这将淡化混淆。</p><h1 id="c3fd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">网络加密和供应链攻击</h1><p id="56b2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我不喜欢基于节点的web应用程序带来的所有这些可传递依赖性的风险。上次我运行create-react-app时，这个“空”生成的应用程序附带了1380个NPM包。如果1380个NPM软件包中有这样的代码会怎么样呢？</p><pre class="lq lr ls lt gt nm ng nn no aw np bi"><span id="500e" class="nq kn iq ng b gy nr ns l nt nu">async function _hackedEncrypt(algorithm, key, data) {<br/>   return data; // "encrypted" to plaintext<br/>}<br/><br/>const subtle = global.crypto.subtle;<br/>subtle.encrypt = _hackedEncrypt;</span></pre><p id="a2a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，函数替换肯定会劫持内置API。我测试过了。</p><p id="98d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的防止函数替换的解决方案可以在POC中找到。另外，我发现一个代码兄弟也在担心同样的事情。他做了这个<a class="ae kl" href="https://github.com/WebReflection/safer-crypto" rel="noopener ugc nofollow" target="_blank">安全加密项目</a>，看起来很有前途。我还没机会深入复习。</p><h1 id="1125" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">你和我的鞋枪</h1><p id="50e1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">Web Crypto的创建者将几乎所有的API放在一个名为“微妙”的对象下是有原因的。你可以用它来搬起石头砸自己的脚，这种方式非常微妙。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/ad93fc9f357c5f8d89338942430153a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYM2Mqi2XFMaPKpozT1TaA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">鞋枪…危险，是的。不切实际，当然。但是不可否认的性感。</figcaption></figure><p id="e7d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我将自己的POC代码投入生产使用之前，我希望有更多的同行评审来发现任何问题。今年我可能会带着更多的发现和改进回来。(<strong class="jp ir"> 7/9/22更新:</strong>见我的<a class="ae kl" href="https://www.npmjs.com/package/web-enc-at-rest" rel="noopener ugc nofollow" target="_blank"> web-enc-at-rest NPM包</a>关于这个)需要澄清的是，我没有在加密领域发明任何新的算法、原语或协议。对于基于密码的加密，我基本上遵循了<a class="ae kl" href="https://datatracker.ietf.org/doc/html/rfc2898/" rel="noopener ugc nofollow" target="_blank">PKCS 5号推荐标准</a>，并考虑了一些特定于网络应用的因素。</p><p id="8ff8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是更多的思考和回顾是必要的。很容易把事情搞砸。</p><p id="babb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代码兄弟和代码姐妹</strong>，在抓取<a class="ae kl" href="https://github.com/erikh2000/encryption-at-rest-poc" rel="noopener ugc nofollow" target="_blank">我的代码</a>粘贴到重要的东西之前，请考虑我的警告。如果你对我提出的东西有建设性的批评，(不只是路过的鹬鸟)我会听的。我也很高兴听到与我正在做的项目重叠的现有项目。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/9fa863890d420872caae88e8733f7316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1pv-h4J_vOrt1-beMk8yQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">杰格斯太太…我做了什么？我说了什么？</figcaption></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nv"><img src="../Images/aaa23a4dd8606c45d0e02a21a2691770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3ShOMdFqTI54vh4p.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">* * * <a class="ae kl" href="https://medium.com/@ErikH2000/where-my-media-comes-from-59761dc4be7" rel="noopener">媒体学分</a> * * * <a class="ae kl" href="https://medium.com/@ErikH2000/yes-i-can-help-you-get-an-it-job-b0b51fee4c95" rel="noopener">想要一份工作？</a> * * * <a class="ae kl" href="https://www.linkedin.com/in/erikhermansen" rel="noopener ugc nofollow" target="_blank"> LinkedIn个人资料</a> * * *</figcaption></figure></div></div>    
</body>
</html>