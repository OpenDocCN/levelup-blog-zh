<html>
<head>
<title>Replacing If-Else With Commands and Handlers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用命令和处理程序替换If-Else</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/replacing-if-else-with-commands-and-handlers-527e0abe2147?source=collection_archive---------0-----------------------#2020-09-24">https://levelup.gitconnected.com/replacing-if-else-with-commands-and-handlers-527e0abe2147?source=collection_archive---------0-----------------------#2020-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f504" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">更好的软件设计</h2><div class=""/><div class=""><h2 id="78db" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何轻松替换if-else语句？不，开关不是合适的替代品。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6d5a9f5d8abcc0436741dc32e9d9ecc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xW6mq7hfBwi2sbMy6fN21Q.png"/></div></div></figure><p id="8eae" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你想了解我如何使用命令和处理程序来保持代码整洁，请继续阅读。不是说<em class="lz">避开</em> <code class="fe ma mb mc md b">if-elseif-else</code>。而是找到更合适的方法。</p><p id="ee28" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请记住，没有一种方法能够摆脱传统的基于分支的编程。你需要建立一个可供借鉴的技术库。</p><p id="22db" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们现在要介绍的方法只是众多方法中的一种。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="63e0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从本质上来说，T1还不错。这仅仅是我们正在进行的一场激烈的斗争。在编程101中，你将学习条件语句，除此之外，许多开发人员从未使他们的实践成熟。</p><p id="7c6a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是，<code class="fe ma mb mc md b">if-else</code>和<code class="fe ma mb mc md b">switch</code>往往不理想。更好的方法，比如多态执行和字典，通常会被忽略。</p><h2 id="858d" class="ml mm it bd mn mo mp dn mq mr ms dp mt lm mu mv mw lq mx my mz lu na nb nc iz bi translated">我们希望避免传统的、有条件的分支。</h2><p id="fb93" class="pw-post-body-paragraph ld le it lf b lg nd kd li lj ne kg ll lm nf lo lp lq ng ls lt lu nh lw lx ly im bi translated">我写过一篇文章，提出了一种用多态执行取代条件分支的方法<a class="ae ni" rel="noopener ugc nofollow" target="_blank" href="/if-else-is-a-poor-mans-polymorphism-ab0b333b7265">。为了获得一些背景信息，在我们深入研究命令和处理程序之前，我将简单地重复一些以前的文章示例。</a></p><p id="24a8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面是我们想要避免的例子:讨厌的、难以扩展的、离散值上的分支。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nj"><img src="../Images/b8b5885551df85c02ef9b2035868d164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zj5R3Q2HqvRjhVn23i-X6g.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">复杂、令人头痛的分支</figcaption></figure><p id="a96c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">除了奇怪地使用<code class="fe ma mb mc md b">if-elseif-else</code>，主要问题是你需要为每个新的更新原因添加一个分支。明显违反了开放/封闭和单一责任原则。</p><p id="0dd8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每个分支基本上都可以转换成自己的命令和相应的处理程序。</p><p id="b6d7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们来看看这是如何实现的。</p><p id="f974" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">🔔想要更多这样的文章？在这里签名。</p><h1 id="ca6f" class="no mm it bd mn np nq nr mq ns nt nu mt ki nv kj mw kl nw km mz ko nx kp nc ny bi translated">使用命令和处理程序来简化应用程序。</h1><p id="9f93" class="pw-post-body-paragraph ld le it lf b lg nd kd li lj ne kg ll lm nf lo lp lq ng ls lt lu nh lw lx ly im bi translated"><a class="ae ni" href="https://github.com/NMillard/replace-if-else" rel="noopener ugc nofollow" target="_blank">📝GitHub回购</a></p><p id="278f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我不会宣扬什么是命令、查询和处理程序的理论。关于这个主题有很多资源。相反，我列出了一个简短的清单，列出了可能的优势。</p><ol class=""><li id="33d3" class="nz oa it lf b lg lh lj lk lm ob lq oc lu od ly oe of og oh bi translated">测试变得非常容易。<br/>你不需要更新现有的测试来解释新的特性。如果一个命令需要额外的处理，您可以创建另一个处理程序，并单独进行测试。</li><li id="7c26" class="nz oa it lf b lg oi lj oj lm ok lq ol lu om ly oe of og oh bi translated">多个处理程序可以处理一个命令。<br/>正如您可能已经注意到的，分派一个命令可能会调用一个或多个处理程序。通过这种方式，您可以在不影响现有代码的情况下添加新功能。</li><li id="57fe" class="nz oa it lf b lg oi lj oj lm ok lq ol lu om ly oe of og oh bi translated">愚蠢，简单的类。<br/>命令是一包没有设置器的属性。这里不会出什么差错。同样，对于一个处理程序，它是一个只有一个公共方法的类。</li><li id="a4a5" class="nz oa it lf b lg oi lj oj lm ok lq ol lu om ly oe of og oh bi translated">控制器动作遵循请求-委托-响应模式。<br/>它们不包含任何业务或持久性逻辑。</li></ol><p id="34ae" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你正在练习<a class="ae ni" href="https://www.eventstorming.com/" rel="noopener ugc nofollow" target="_blank">事件风暴</a>，我确信你已经完全理解了为什么命令和处理程序如此棒。</p><p id="57cc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我结束了之前提到的文章中的<a class="ae ni" rel="noopener ugc nofollow" target="_blank" href="/if-else-is-a-poor-mans-polymorphism-ab0b333b7265">，暗示了如何使用</a><a class="ae ni" href="https://medium.com/swlh/dynamic-command-dispatching-in-c-d3abe21b3d1b" rel="noopener">动态命令分派</a>来消除不必要的分支。现在，您将看到一种实现命令和处理程序的方法。</p><h1 id="4267" class="no mm it bd mn np nq nr mq ns nt nu mt ki nv kj mw kl nw km mz ko nx kp nc ny bi translated">最后，一些代码！</h1><p id="034d" class="pw-post-body-paragraph ld le it lf b lg nd kd li lj ne kg ll lm nf lo lp lq ng ls lt lu nh lw lx ly im bi translated">为了遵循这一准则，让我很快地向你们概括一下，从一般意义上来说，我们想要实现什么。</p><p id="c23d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们想说，“好吧，需要有所行动。以下是这些值。我不在乎谁来处理，只要让我知道什么时候完成就行了”。</p><p id="d0f8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们需要满足三个验收标准:</p><ol class=""><li id="2fb7" class="nz oa it lf b lg lh lj lk lm ob lq oc lu od ly oe of og oh bi translated">可以在调用者不知道具体处理程序的情况下分派命令。</li><li id="f0ed" class="nz oa it lf b lg oi lj oj lm ok lq ol lu om ly oe of og oh bi translated">需要执行与命令匹配的每个处理程序。</li><li id="13c1" class="nz oa it lf b lg oi lj oj lm ok lq ol lu om ly oe of og oh bi translated">新命令或处理步骤不需要您修改现有代码。</li></ol><h2 id="99ef" class="ml mm it bd mn mo mp dn mq mr ms dp mt lm mu mv mw lq mx my mz lu na nb nc iz bi translated">我们将从最外层开始，一步步深入。</h2><p id="be4e" class="pw-post-body-paragraph ld le it lf b lg nd kd li lj ne kg ll lm nf lo lp lq ng ls lt lu nh lw lx ly im bi translated">从控制器的角度出发，了解具体的处理程序甚至接口是不相关的。该操作应该只关注数据。</p><p id="8684" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为此，我们希望控制器动作就像下面这样简单。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/1892a63ec994a065fc4fd29b419a10fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UR8zylnKZLmdjXqVCn_9A.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">更新电子邮件端点</figcaption></figure><p id="1c43" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">即使这是C# aspnetcore，你也应该明白它的要点。简单地说，这是一个控制器动作——端点及其实现。</p><p id="955f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我知道您在想什么:“错误处理在哪里？!"。别担心。你说得对。应该在那里。但是为了简洁起见，我省略了这一部分，这样我们可以专注于调度命令的概念。</p><p id="f716" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">控制器依赖于一个<code class="fe ma mb mc md b">CommandDispatcher</code>。我们等会儿再去上课。dispatcher类只有一个方法<code class="fe ma mb mc md b">DispatchAsync(command)</code>。现在你只需要知道这些。</p><p id="3c8d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这允许我们的控制器只关心验证它接收的数据的正确性和发送命令。<em class="lz">调度后如何处理</em>数据与控制器完全无关。</p><p id="dbfe" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每个“更新原因”都需要有自己的端点，有自己的数据形状，即要发送的命令。</p><p id="0de9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此时，实现诸如“更新用户名”之类的新特性就像创建一个新端点并发送命令一样简单。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/69f79d7f88f39fd295583425f03741f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTX5NsR-9363zRoX9R6wXw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">更新用户名端点</figcaption></figure><p id="6de5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用这种方法时，创建端点变得非常简单。这是件好事。</p><p id="f2ca" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的目标现在基本上完成了。<br/>那么，我们继续吧。</p><h2 id="a073" class="ml mm it bd mn mo mp dn mq mr ms dp mt lm mu mv mw lq mx my mz lu na nb nc iz bi translated">命令和处理程序是所有业务逻辑所在的地方。</h2><p id="b3de" class="pw-post-body-paragraph ld le it lf b lg nd kd li lj ne kg ll lm nf lo lp lq ng ls lt lu nh lw lx ly im bi translated">对于命令，您本质上只想关心两件事:不变性和数据正确性。</p><p id="b36a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它们只是普通的、古老的普通班级。一点也不花哨。看看这个<code class="fe ma mb mc md b">ChangeEmailCommand</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/97d9abde14cdd518c662fbc6a53883bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzLPwjcKZExQtq_OVOgQdw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">普通的老式指挥班</figcaption></figure><p id="a1ce" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">显然，这个命令类做的不多。这才是重点。它的目的是传递给一个处理程序。</p><p id="3fd6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这就把我们带到了负责人那里。花几个通读下面的代码。我试着描述一下之后的情况。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/24aef8170679b92de89366437b27d6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRHuZszX-g1zr6d51aSsbQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">简单、可测试的命令处理程序。</figcaption></figure><p id="d171" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，我们有一个所有命令处理程序都需要实现的接口。当您需要动态类型发现时，接口很重要。我们一会儿就会谈到这一点。</p><p id="4115" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">第二，我创建了一个简单的处理程序，它知道如何处理<code class="fe ma mb mc md b">ChangeEmailCommand</code>。ICommandHandlerAsync的泛型参数告诉我们，“每当发送‘更改电子邮件命令’时，都需要调用这个处理程序。”</p><p id="34c0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你感觉到这个类的可测试性了吗？这才是重点。这应该很容易测试。上课很专注。一种方法，一种依赖。</p><p id="4be9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你习惯于“服务”类，你就会知道构造函数有时有多疯狂。这种方法完全消除了构造函数膨胀。</p><h2 id="03da" class="ml mm it bd mn mo mp dn mq mr ms dp mt lm mu mv mw lq mx my mz lu na nb nc iz bi translated">调度员本身。难以置信的简单和强大。</h2><p id="1d34" class="pw-post-body-paragraph ld le it lf b lg nd kd li lj ne kg ll lm nf lo lp lq ng ls lt lu nh lw lx ly im bi translated">您已经看到了dispatcher界面。干净简单。但是让我们再一次唤起你的记忆。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/477a4506ca71929c555bfd57fd8c24cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEznT0PeEhVMCl6Z49Z9RQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">指挥调度程序的公共接口</figcaption></figure><p id="7073" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在被实现分散注意力之前，让我重申一下我们需要用<code class="fe ma mb mc md b">CommandDispatcher</code>实现什么。</p><p id="a872" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们想说，“这里有一个命令，去获取所有匹配的处理程序，并将命令传递给每个处理程序。”</p><p id="c528" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这意味着，对于每个命令类，我们需要一个匹配命令处理程序的列表。在代码中，我们可以用字典来表达这种意图，其中关键是命令的类型，值是处理程序的列表。</p><p id="9e30" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">花点时间来通读这篇文章。面向对象的人可能会发现这非常容易，而其他人不会。我会在代码下面描述我们的进展。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/580952b8d0228337cb377be2771af732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jA1kZH9joSeavWYCWSS26w.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">带字典查找的命令调度程序</figcaption></figure><p id="ef90" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不要太花哨。只是一点反思。这可能会吓跑一些非OOP的人。不要担心，在函数式语言中，您很可能很容易找到实现这一点的方法。</p><p id="4c52" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">描述实际代码无关紧要。只是普通的C#。重要的是意图。</p><p id="55ef" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最重要的部分是要有一个将命令和处理程序联系起来的机制。为此，我使用字典。</p><p id="f328" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每个键都是一种命令类型。对应的值是实现<code class="fe ma mb mc md b">ICommandHandlerAsync&lt;commandType&gt;</code>的处理程序列表。</p><p id="6a61" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当您调用例如<code class="fe ma mb mc md b">DispatchAsync(ChangeEmailCommand)</code>时，调度程序试图在字典中找到“Type: CommandHandler”的键，并返回已注册的处理程序的列表。</p><p id="bed6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后调用每个处理程序。</p><p id="8a8d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">仅此而已。很简单的东西。</p><h2 id="2bcc" class="ml mm it bd mn mo mp dn mq mr ms dp mt lm mu mv mw lq mx my mz lu na nb nc iz bi translated">用动态类型发现将它们连接起来。</h2><p id="c3aa" class="pw-post-body-paragraph ld le it lf b lg nd kd li lj ne kg ll lm nf lo lp lq ng ls lt lu nh lw lx ly im bi translated">在这一点上，没有什么是真正起作用的。</p><p id="6953" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您需要将字典提供给某个地方的命令调度程序。</p><p id="3a5d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">理想情况下，在应用程序启动时创建命令调度程序及其字典，并将其注册到依赖注入框架中。</p><p id="bddc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你还记得我们的第三个验收标准吗？也就是说，新的特性/需求不应该要求我们修改现有的代码？</p><p id="6753" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果手动向字典注册新的命令和处理程序，实际上是在修改现有的代码。可能完全没问题。大多数时候是这样的。</p><p id="81e5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是，如果您想要推动自己并提高，那么您应该尝试给动态类型发现一个旋转。</p><p id="ccd7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样，我们得到了一堆与描述完全不相关的C#代码，但有些人可能会感兴趣。</p><p id="3974" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">只需知道这段代码将找到所有的命令处理程序，将它们注册到依赖容器中，构建一个字典，并在每次控制器需要一个<code class="fe ma mb mc md b">CommandDispatcher</code>时将该字典传递给命令调度程序的一个新实例。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/37d3e47e4359940ba9a85f717b2e540e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r7tzK7GGM96eO_g-J9B1AQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">应用程序启动时的动态类型发现</figcaption></figure><p id="441b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">有了这个，就不需要动你现有的代码了。即使创建新的命令或处理程序也不行。在应用程序启动时，一切都已连接好。</p><p id="5535" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当然，它看起来很乱，你最初的想法可能是这将成为维护的噩梦。</p><p id="a8dd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我故意这样写代码。很自然，你会想做一些方法提取重构来使它不那么令人讨厌。出于演示目的，完全没问题。</p><p id="972f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">关键是，你只需写一次，所有的准备工作就完成了。写一些单元测试，你就会一切顺利。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><pre class="ks kt ku kv gt ot md ou ov aw ow bi"><span id="7d2f" class="ml mm it md b gy ox oy l oz pa"><strong class="md jd">Resources for the curious</strong><br/>-------------------------</span><span id="b473" class="ml mm it md b gy pb oy l oz pa"><a class="ae ni" href="https://github.com/NMillard/replace-if-else" rel="noopener ugc nofollow" target="_blank">GitHub repository</a> by the author</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/745b6019f001879654cae7d29d306420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LZ0-rAawOB4iv6uI.png"/></div></div></figure><p id="cc49" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> Nicklas Millard </strong>是一名软件开发工程师，供职于一家发展最快的银行，负责构建任务关键型金融服务基础设施。</p><p id="7bfa" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此前，他是Big4的高级技术顾问，为商业客户和政府机构开发软件。</p><blockquote class="pd pe pf"><p id="71d7" class="ld le lz lf b lg lh kd li lj lk kg ll pg ln lo lp ph lr ls lt pi lv lw lx ly im bi translated"><a class="ae ni" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank">新的YouTube频道(@Nicklas Millard) </a></p><p id="f1a4" class="ld le lz lf b lg lh kd li lj lk kg ll pg ln lo lp ph lr ls lt pi lv lw lx ly im bi translated"><em class="it">连接上</em> <a class="ae ni" href="https://www.linkedin.com/in/nicklasmillard/" rel="noopener ugc nofollow" target="_blank"> <em class="it"> LinkedIn </em> </a></p></blockquote><h1 id="4a4f" class="no mm it bd mn np nq nr mq ns nt nu mt ki nv kj mw kl nw km mz ko nx kp nc ny bi translated">分级编码</h1><p id="31bc" class="pw-post-body-paragraph ld le it lf b lg nd kd li lj ne kg ll lm nf lo lp lq ng ls lt lu nh lw lx ly im bi translated">感谢您成为我们社区的一员！<a class="ae ni" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae ni" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf jd"> Skilled.dev编码面试课程</strong> </a>。</p><div class="pj pk gp gr pl pm"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">编写面试问题</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">掌握编码面试的过程</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">技术开发</p></div></div><div class="pv l"><div class="pw l px py pz pv qa lb pm"/></div></div></a></div></div></div>    
</body>
</html>