# 如何建立一个安全，无服务器，持久和实时的单页聊天

> 原文：<https://levelup.gitconnected.com/multichat-a-secure-serverless-persistent-and-real-time-chat-proof-of-concept-22d3dddc0345>

## 使用 WebRTC、PeerJS、Vue 和 javascript vanilla cookies 不到 3 个小时

![](img/928d9a720f3e3a4e724bd3098b4d5df2.png)

今天的互联网基础设施依赖于数据中心，而数据中心有着**成本**和**环境影响**。更具体地说，[数据中心负责大约。4%的世界能源消耗](https://www.climatechangenews.com/2017/12/11/tsunami-data-consume-one-fifth-global-electricity-2025/)，并且还在增长。但是，如果没有你每天的狂看点播电视，你会怎样度过你的一天呢？

> 如果我们可以在不需要服务器的情况下通信/交换数据会怎么样？如果个人数据可以存储在本地，远离大公司的数据中心，会怎么样？

幸运的是，由于点对点连接是互联网的基础，有些人比我更早想到这一点；这导致了[***WebRTC***](https://webrtc.org/)的发展。在本文中，我将介绍 WebRTC 的优势，并通过一个简单、易用、安全、几乎无服务器、持久的实时聊天概念验证来展示它的威力。但是，WebRTC 的也有自己的局限性；但这是另一个后来的故事。

> 我能理解这篇文章吗？

在本文中，我涵盖了大型全栈开发主题，这些主题需要一些互联网通信、javascript 数据、状态管理以及 HTML/CSS 方面的知识。如果你没有全部，你会学到一些有用的技巧和窍门！

# 挑战

该项目的目标是简化和演示浏览器中无服务器数据交换的*功能、安全性/保密性*和*持久性*。以下是我选择的标准的完整列表:

*   带有用户名的基本聊天应用程序
*   任何用户必须能够加入任何其他用户(在聊天室)
*   安全:数据交换必须加密
*   **持续性:**数据必须在整个会话期间保存(用户名、聊天)
*   无服务器:数据必须在不需要服务器的情况下在对等体之间交换
*   简单:任何人都必须能够在没有任何知识的情况下使用这个项目

# 解决方案

我设计了最简单的解决方案来满足前面的要求，使用:

*   [](https://webrtc.org/)**WebRTC，用于安全、可靠、无服务器的数据交换**
*   **[**Vue.js**](https://vuejs.org/) ，用于快速&轻量级动态渲染和状态管理**
*   **[**PeerJS**](https://peerjs.com) ，用于简化 WebRTC 上的开发**
*   **[**【materialiecss】**](https://materializecss.com/)，用于快速现代设计**
*   **[**JavaScript local storage**](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)，用于数据持久性**

**WebRTC 是谷歌浏览器内对等通信的开源基础，使用 [QUIC 协议](https://en.wikipedia.org/wiki/QUIC)(最新的、快速的&可靠的[传输层](https://en.wikipedia.org/wiki/Transport_layer) [网络协议](https://en.wikipedia.org/wiki/Network_protocol))。几乎每一个像样的浏览器都支持它，它提供了一种在支持任何类型数据(包括实时音频和视频)的两个浏览器(对等体)之间建立数据通道的方法。**

**PeerJS 提供了一种将客户机连接到服务器端点的方法，等待来自其他客户机的对等连接。一旦建立了连接，两个对等体就通过 WebRTC 数据通道进行通信，只有它们可以读/写。**

# **代码**

**让我们从创建网页的框架开始:因为我们想要一个单页面应用程序，我们将在一个 index.html 文件中编写所有的 CSS 代码**和** JS 代码。我们还需要在 html 中导入每个依赖项。我们的主体将包含一个主 *#app* div。**

**主应用程序框架**

**然后，我们需要为用户管理两个屏幕:登录屏幕和聊天屏幕(因为我们不希望用户在登录后更改用户名)。为此，我选择在应用程序的状态中存储一个屏幕变量，该值指示要显示的屏幕。**

> **你不应该这样做！通常，我们为 2 个不同的屏幕创建 2 个不同的组件，并使用 Vue 的路由器在它们之间切换。为了简单起见，我选择简单地创建一个组件来允许我直接访问我的应用程序的所有状态！**

**因此，我们可以创建两个屏幕，放在我们的 *#app* 中:**

**index.html 渲染**

**如果您忽略所有的样式类和图标，您会发现一些在我们的屏幕中使用的 Vue 变量和函数:**

*   ***屏幕*:包含显示屏幕名称的变量**
*   ***用户名输入*:用户输入的用户名(登录后必须保持不变)**
*   ***peerError* :发生错误时显示的消息**
*   ***加载*:一个布尔值，表示应用是否正在加载**
*   ***targetIdInput* :输入要连接的目标用户名**
*   **peerIds :我们所连接的对等 id 列表**
*   ***聊天*:聊天对象列表(发送者、消息)**
*   ***聊天消息输入*:用户当前输入的聊天消息**
*   ***submitLogin* :在提交登录表单时调用，触发适当的 javascript 事件**
*   ***submitConnection* :连接表单提交时调用，连接目标客户端( *targetIdInput* )**
*   ***submitChat* :发送聊天消息时调用(通过聊天表单提交)**

**有了这些变量和函数，我们就能够运行我们的应用程序了。让我们来编写应用程序的实例化和渲染逻辑！首先，我们需要考虑它将如何工作:**

*   **每个用户都有一个用户名，每个对等方(浏览器)都有一个 id，用于在信令服务器上唯一地标识它，由对等方使用。使用用户名和对等 id 会很方便。但是为了确保规模上的唯一性和可用性(信令服务器不仅仅由我们使用)，我们必须为每个用户名添加一个唯一的前缀，这样我们就可以获得一个几乎唯一的对等 id。为了做到这一点，我们简单地编写了两个 util 函数，我们可以用它们将对等 id 转换成用户名，反之亦然。我们将它们作为 Vue 组件的方法来编写，以便能够在渲染时使用它们。**
*   **我们想要一个持久的聊天，我们已经选择将数据保存为 cookies。不幸的是，cookies 只允许保存字符串。
    真巧，JavaScript 天生允许我们序列化和反序列化 JSON 对象！让我们从“聊天”cookie 中读取之前存储的聊天内容。最后，我们还可以使用 cookies 来存储我们以前使用的用户名，以便在我们的下一次会话中启动它(这就是下面要做的！)**
*   **我们希望每当收到新的聊天消息时，我们的聊天框自动向下滚动:每当 *chats* 变量更新时，我们需要将我们的聊天框滚动到它的最大位置。为此，我们使用 Vue 的观察器，将观察器命名为 *chats()***

**index.html Vue 应用程序行为和渲染逻辑**

## **快到了！**

**让我们通过实现我们的应用程序的后台逻辑、实例化和连接对等体来完成这个简单的应用程序。但首先，让我们想一想:**

*   **我们必须跟踪我们拥有的每一个活动连接，并将它们映射到它们对应的远程对等体 id。
    *但是我们已经存储了活动连接的远程对等体 id！这不是多余的吗？* 不幸的是，Vue 没有提供一种直接的方法来跟踪赋予 Vue 数据对象的任何新属性。我的选择是将远程对等 id 映射到它们在 Vue 数据对象中对应的连接(*连接*)，以及在另一个 Vue 数据数组中独立的远程对等 id(*peer ids*)(更新触发 Vue 组件渲染)。另一种选择是注册我们添加到*连接的属性(每次添加连接时使用[*vue . set*](https://vuejs.org/v2/api/#Vue-set)*)*，这将触发组件呈现。***
*   **我们必须考虑对等连接；为了简单起见，我们在这里没有接受/拒绝连接。
    让我们考虑一下**爱丽丝**和**大家**在聊天室 **A** 和**鲍勃**和**卡罗尔**在聊天室 **B** 。连接过程简单来说就是:**

1.  **来自聊天室 **A** 的爱丽丝向来自聊天室 **B** 的鲍勃发送一份要约，其中包含聊天室**A**(**所有人**)中已连接用户的列表**
2.  ****鲍勃**回答**爱丽丝**的提议，并将提议发送给聊天室**A**鲍勃未连接到的**每个人**，并列出聊天室**B**(**Carole**)中已连接的用户列表**
3.  ****Alice** 现在连接到 **Bob** 并向 **Carole** 发送要约，其中包含 Alice 连接到的用户列表( **Bob，Everyone** )**
4.  ****每个人**回答**鲍勃**的提议，以及每个人所连接的用户列表(**爱丽丝**)**
5.  **Carole 回答 Alice 的提议，以及 Carole 连接到的用户列表([ **Bob** )**
6.  ****Carole** 现在连接到 **Alice** 并向 **Everyone** 发送要约，其中包含 Carole 连接到的用户列表([ **Alice，Bob** ])**
7.  ****Everyone** 回答 **Carole** 的提议，以及 Everyone 与**的用户列表( **Alice，Bob** )****
8.  **Carole 现在连接到**每个人**(字面意思)**

*   **最后，我们必须为我们的对等通信建立一种数据格式。
    对于这个项目来说，只说任何传递的数据必须包含一个*类型*属性就足够了。根据这个属性的值，我们将以不同的方式查询数据。**

> **总是考虑两个通信端点之间的数据格式是一个有用的习惯，这样您就有了弹性的行为/解释。您不希望查询一个意外抛出错误的 API！
> 另外:如果你需要来自同一个端点的不同行为，也许你应该把你的端点分成两个不同的端点，每个端点都有自己的原子角色！**

**您将在下面找到我们的主要 Vue 组件中缺少的方法列表，这些方法允许完全实现上述逻辑:**

*   ***initiateConnection* 在提供连接时被调用。
    它必须实现已连接用户的初始列表发送(作为连接元数据)！**
*   ***配置连接*在提供**和**应答连接时被调用(用于注册数据和行为监听器)
    它必须使用接收到的连接用户列表(作为连接元数据)实现连接初始化！**
*   **createPeer 还处理对等点配置，它本质上实现了当接收到提议时的自动应答(如果我们想要实现接受/拒绝屏幕，我们会停用它)**

> **因此，我们已经建立了一个持久的实时聊天 webapp，但如果我们仍然需要一个信令服务器来建立连接，它是如何做到无服务器的呢？怎么才算真正安全？**

# **WebRTC 当然不是无服务器的！**

**该解决方案的优势在于其简单性和安全性:**

*   **任何用户都可以用用户名登录，并加入它认识的任何其他朋友**
*   **任何用户都可以完全访问其聊天记录**
*   **数据交换是完全加密的，不能被中间人破解(更多信息请参见[WebRTC 安全性研究](https://webrtc-security.github.io/)**

**然而，类似的无服务器应用程序的许多方面仍有待讨论和重新思考:**

*   **你不会使用将数据存储为 javascript cookies 的应用程序！**
*   **仍然需要一个服务器来建立对等连接(参见 [WebRTC: the ICE Framework，STUN and TURN Servers](/webrtc-the-ice-framework-stun-and-turn-servers-10b2972483bb) 了解更多原因)。在我们的例子中，我们默认使用高级 PeerJS 信令服务器，而不是低级 STUN 服务器(我们可以使用低级代码)**
*   **交换的数据只能由对等体读取和写入，这就是为什么这个解决方案甚至不适合交换(例如)游戏数据(任何用户都可能作弊！)**

**这一点，以及 WebRTC 和更一般的此类无服务器应用程序所具有的所有限制，将在后面的故事中讨论！**

**你可以在这里找到这个应用程序的在线版本[，在](https://multichat.milon.dev) [GitHub](https://github.com/Rubilmax/peerjs-multichat) 上可以找到这个项目的资源库。**