<html>
<head>
<title>Cross Platform Mobile and Web Development with C++ Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++进行跨平台移动和Web开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cross-platform-mobile-and-web-development-with-c-explained-7076b84c425b?source=collection_archive---------14-----------------------#2020-05-26">https://levelup.gitconnected.com/cross-platform-mobile-and-web-development-with-c-explained-7076b84c425b?source=collection_archive---------14-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5ff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第6部分:添加SQLite对离线和数据操作的支持</h2></div><p id="a3d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你要编写复杂的软件，你很有可能需要数据存储和操作。我们很幸运SQLite是为我们准备的，它有一个小的二进制代码，可移植，并且完全成熟。让我向您展示如何通过简单的设置从C++代码中使用它。更好的是:无需编写任何SQL。</p><p id="da30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本教程的代码可在https://github.com/skonstant/xptuto/tree/part6_sqlite获得</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/fe50b96cf2892a3a132a71a8d747c8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lDn1OnuwG3USyP_TA2fhw.png"/></div></div></figure><h1 id="bd54" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">SQLite:满载但小巧</h1><p id="7836" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated"><a class="ae lb" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> SQLite </a>是一个<em class="ml">关系数据库管理系统</em>，它支持SQL-92，提供了很多很酷的东西:全文搜索、JSON、分层、递归查询等等。</p><p id="5ad9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是一个嵌入式数据库，而不是一个服务器系统，非常适合我们的需要，我们将把它包含在我们的构建中。许多主要玩家也在他们自己的包中使用它。</p><p id="ae44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他系统将使用他们所谓的<a class="ae lb" href="https://www.sqlite.org/amalgamation.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">合并</strong> </a> <strong class="kh ir">。</strong>SQLite的所有代码都在一个单独的<strong class="kh ir">中。c </strong>文件，虽然很大，但是用我们的<strong class="kh ir"> ccache </strong>设置编译时间不成问题。</p><p id="a0af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">XCode将SQLite作为其iOS库的一部分，Mac OS也是(与CMake一起工作)，Android NDK没有——令人惊讶的是，因为它从一开始就是Android上SQL存储的主干，所以它没有在NDK中公开。Web/Emscripten当然没有。</p><p id="a147" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的iOS项目，让我们只是在构建阶段添加它🡲链接二进制与库，并添加<strong class="kh ir"> libsqlite3.tbd. </strong>完成，头是可见的，链接工作。</p><p id="715b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的CMake项目(Android、本地计算机和Emscripten)，我们使用CMake <strong class="kh ir"> find_package() </strong>命令。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="65c3" class="mr lp iq mn b gy ms mt l mu mv">find_package (<strong class="mn ir">SQLite3</strong>)<br/><strong class="mn ir">if </strong>(<strong class="mn ir">SQLITE3_FOUND</strong>)<br/>    include_directories(<strong class="mn ir">${SQLITE3_INCLUDE_DIRS}</strong>)<br/><strong class="mn ir">else </strong>(<strong class="mn ir">SQLITE3_FOUND</strong>)<br/>    <em class="ml"># add amalgamation code and include<br/>    </em>set(<strong class="mn ir">SRC ${SRC} sqlite-amalgamation-3310100/sqlite3.c</strong>)<br/>    include_directories(<strong class="mn ir">sqlite-amalgamation-3310100</strong>)<br/><strong class="mn ir">endif </strong>(<strong class="mn ir">SQLITE3_FOUND</strong>)</span></pre><p id="3c62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是它的全部内容，现在我们的构建中已经有了它，可以开始在内存中处理数据和SQL了，只是到目前为止，因为我们需要解决文件存储问题。</p><h2 id="114e" class="mr lp iq bd lq mw mx dn lu my mz dp ly ko na nb ma ks nc nd mc kw ne nf me ng bi translated">存储问题</h2><p id="5405" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">为了保存数据，我们需要能够写入文件。在Android和iOS上，我们可以访问只有我们的应用程序才能使用的文件夹，我们将在两者上选择缓存文件夹，因为这只是为了缓存。请注意，应用程序的缓存文件夹中的数据可能会随时消失。如果你需要更可靠的东西，使用文件目录。无论哪种方式，这些都是你的应用程序私有的，不需要特别的许可。</p><p id="2ae7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，默认情况下，文件文件夹会备份到Google或Apple cloud，您可以在配置中选择退出。</p><p id="80ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在Xptuto make_instance()工厂方法中添加了一个文件路径参数。对于Android，我们做到了:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="dced" class="mr lp iq mn b gy ms mt l mu mv">Xptuto.makeInstance(<br/>    <strong class="mn ir">new </strong>JavaHttpClient(getApplicationContext()),<br/>    <strong class="mn ir">new </strong>AndroidThreads(),<br/>    getCacheDir().getAbsolutePath()); // or getFilesDir() </span></pre><p id="5957" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于iOS，我们做到了:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="c11a" class="mr lp iq mn b gy ms mt l mu mv"><strong class="mn ir">auto</strong> cacheDirectory = [NSSearchPathForDirectoriesInDomains(<br/>    NSCachesDirectory, NSUserDomainMask, <strong class="mn ir">true</strong>) lastObject];<br/>// or NSApplicationSupportDirectory </span><span id="326d" class="mr lp iq mn b gy nh mt l mu mv">x = Xptuto::make_instance(<br/>        std::make_shared&lt;AppleHttpClient&gt;(), <br/>        std::make_shared&lt;AppleThreads&gt;(),<br/>        djinni::String::toCpp(cacheDirectory));</span></pre><p id="0212" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于web来说，难度更大。浏览器没有我们的文件系统，emscript有<a class="ae lb" href="https://emscripten.org/docs/api_reference/Filesystem-API.html#filesystem-api-persist-data" rel="noopener ugc nofollow" target="_blank"> <em class="ml">文件系统API </em> </a>有点不连贯。为了创建您需要的文件系统，您需要在Javascript层做一些事情。</p><p id="0ed3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的初始化代码中，我们做到了:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="7a5a" class="mr lp iq mn b gy ms mt l mu mv"><strong class="mn ir">var <em class="ml">Module </em></strong>= {<br/>  onRuntimeInitialized: <strong class="mn ir">function</strong>() {<br/>    FS.mkdir(<strong class="mn ir">'/cache'</strong>);<br/>    FS.mount(IDBFS, {}, <strong class="mn ir">'/cache'</strong>);<br/>    FS.syncfs(<strong class="mn ir">true</strong>, <strong class="mn ir">function </strong>(err) {<br/>      <strong class="mn ir"><em class="ml">window</em></strong>.<strong class="mn ir">xptuto </strong>= <strong class="mn ir"><em class="ml">Module</em></strong>.createInstance();<br/>    });<br/>  }<br/>};</span><span id="d161" class="mr lp iq mn b gy nh mt l mu mv">// then in C++<br/>xptuto::Xptuto::make_instance(<br/>    std::make_shared&lt;WebHttpClient&gt;(),<br/>    std::make_shared&lt;WebThreads&gt;(), <strong class="mn ir">"/cache"</strong>);</span></pre><p id="9d09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来很简单。问题还在后面:如果我们写文件，我们需要手动同步。在我们的例子中，当我们写入数据库时。我们可以随时同步，即使没有它，应用程序也可以工作，如果我们没有同步就离开网页，更改将会丢失，记住这一点。并且我们不能在<em class="ml"> onbeforeunload </em>中同步，因为FS.syncfs()是异步的。可以使用各种策略来克服这个问题。在我的例子中，我在回调中同步。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="f0c4" class="mr lp iq mn b gy ms mt l mu mv"><strong class="mn ir">callback </strong>= <strong class="mn ir">new <em class="ml">Module</em></strong>.JSGetReposCb({<br/>    on_error: (error) =&gt; <strong class="mn ir"><em class="ml">console</em></strong>.error(error),<br/>    on_success: (repos, user) =&gt; {<br/>       ... <br/>       FS.syncfs(<strong class="mn ir">function </strong>(err) {});</span></pre><p id="92e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我觉得，这并不伟大，但这是一个很小的代价。</p><h1 id="1431" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">保持面向对象:使用ORM</h1><p id="3486" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">尽管我喜欢SQL，但我不喜欢在代码中使用字符串。我发现对象关系映射器非常有用:我们使用C++，所以我们可以利用我们的工具在部署之前检查我们的代码，并且我们确信生成的SQL总是有效的。</p><p id="a74a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用一个只有头文件的C++17库，非常容易集成和使用。下面是我们对用户表的定义:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="6b9c" class="mr lp iq mn b gy ms mt l mu mv">make_storage(dbFile,<br/>    make_table(<strong class="mn ir">"users"</strong>,<br/>        make_column(<strong class="mn ir">"id"</strong>, &amp;User::id, primary_key()),<br/>        make_column(<strong class="mn ir">"login"</strong>, &amp;User::login, unique()),<br/>        make_column(<strong class="mn ir">"avatar_url"</strong>, &amp;User::avatar_url),<br/>        make_column(<strong class="mn ir">"created_at"</strong>, &amp;User::created_at))</span></pre><p id="a6cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它从我们的字段类型中推导出SQLite类型，我自己添加了对<strong class="kh ir"> std::chrono::time_point </strong>的支持(我从epoch开始将它们作为毫秒传递)。就像我们的JSON库一样，它提供了模板方法，我们只是专门为我们的自定义类型。</p><p id="8447" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们在一个表中有了用户，让我们写一个小测试:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="39f0" class="mr lp iq mn b gy ms mt l mu mv"><strong class="mn ir">TEST_F</strong>(Xptuto, OrmTest) {<br/>    <strong class="mn ir">auto </strong>instance = std::make_shared&lt;XptutoImpl&gt;(<br/>                        stubHttp,stubThreads, std::nullopt);<br/>    stubHttp-&gt;path = <strong class="mn ir">"/responses/users_aosp.json"</strong>;<br/><br/>    <strong class="mn ir">auto </strong>user = instance-&gt;get_user_sync(<strong class="mn ir">"aosp"</strong>);<br/><br/>    <strong class="mn ir">auto </strong>storage = SQLStorage(<strong class="mn ir">":memory:"</strong>);<br/>    storage.store_user(user.value());<br/>    <strong class="mn ir">auto </strong>u = storage.get_user(<strong class="mn ir">"aosp"</strong>);<br/>    <strong class="mn ir">EXPECT_EQ</strong>(u.created_at, user-&gt;created_at);<br/>    <strong class="mn ir">EXPECT_EQ</strong>(u.login, <strong class="mn ir">"aosp"</strong>);<br/>}</span><span id="8a0e" class="mr lp iq mn b gy nh mt l mu mv">// get_user():<br/>User SQLStorage::get_user(<strong class="mn ir">const </strong>std::string &amp;login) {<br/>    <strong class="mn ir">auto </strong>allUsersList = <br/>        storage.get_all&lt;User, std::vector&lt;User&gt;&gt;(<br/>            where(c(&amp;User::login) == login));<br/>    <strong class="mn ir">return </strong>allUsersList.at(0);<br/>}</span></pre><p id="ddd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这么简单，没有SQL字符串。SQLite Orm当然可以做更复杂的查询，最后，它让你写原始的SQL。注意，对于测试，我们使用<strong class="kh ir"> ":memory:" </strong>作为数据库文件，这告诉SQLite使用内存中的数据库。</p><p id="eaa5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这个方法中选择返回找到的用户或throw，因此使用了<strong class="kh ir"> std::vector:::at() </strong>。我发现异常很有意义，有时比返回空值更有意义。</p><blockquote class="ni nj nk"><p id="f2f6" class="kf kg ml kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">Q <!-- -->先不说这个:出于“优化”的原因，默认情况下，在Emscripten中异常是禁用的。在我看来，这是优化的错误地方，C++标准库充满了抛出异常的API，这是一种比崩溃更干净的获得错误的方式。因此，通过向所有编译和链接标志添加<strong class="kh ir">-s DISABLE _ EXCEPTION _ CATCHING = 0</strong>来启用异常。在其他平台上，默认情况下会启用异常。</p></blockquote><p id="dab4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还在一个表中定义了我的Repo对象，并为用户提供了一个外键。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="2ee7" class="mr lp iq mn b gy ms mt l mu mv">make_table(<strong class="mn ir">"repos"</strong>,<br/>           make_column(<strong class="mn ir">"id"</strong>, &amp;Repo::id, primary_key()),<br/>           make_column(<strong class="mn ir">"name"</strong>, &amp;Repo::name),<br/>           make_column(<strong class="mn ir">"full_name"</strong>, &amp;Repo::full_name),<br/>           make_column(<strong class="mn ir">"owner"</strong>, &amp;Repo::owner),<br/>           make_column(<strong class="mn ir">"priv"</strong>, &amp;Repo::priv),<br/>           make_column(<strong class="mn ir">"descr"</strong>, &amp;Repo::descr),<br/>           make_column(<strong class="mn ir">"created_at"</strong>, &amp;Repo::created_at),<br/>           foreign_key(&amp;Repo::owner).references(&amp;User::id)));<br/>// get repos for a user:<br/>storage.get_all&lt;Repo, std::vector&lt;Repo&gt;&gt;(<br/>                 where(c(&amp;Repo::owner) == user.id));</span></pre><p id="6a54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以极大地改进我们的get_user()方法(以及所有其他get…方法。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="1dd4" class="mr lp iq mn b gy ms mt l mu mv"><strong class="mn ir">void </strong>XptutoImpl::get_user(<strong class="mn ir">const </strong>std::string &amp;login,<br/>         <strong class="mn ir">const </strong>std::shared_ptr&lt;GetUserCb&gt; &amp;cb) {<br/>    <strong class="mn ir">auto </strong>me = shared_from_this();<br/><br/>    threads-&gt;create_thread(<strong class="mn ir">"get_user"</strong>, <br/>            std::make_shared&lt;ThreadFuncImpl&gt;([me, cb, login]() {<br/>        <strong class="mn ir">try </strong>{<br/>            <strong class="mn ir">try </strong>{<br/>                <strong class="mn ir">auto </strong>user = me-&gt;storage.get_user(login);<br/>                me-&gt;threads-&gt;run_on_main_thread(<br/>                    std::make_shared&lt;ThreadFuncImpl&gt;([cb, user]() {<br/>                        cb-&gt;on_success(user);<br/>                }));<br/>            } <strong class="mn ir">catch </strong>(...) {<br/>                <strong class="mn ir">auto </strong>user = me-&gt;get_user_sync(login);<br/>                <strong class="mn ir">if </strong>(!user) {<br/>                    me-&gt;threads-&gt;run_on_main_thread(<br/>                        std::make_shared&lt;ThreadFuncImpl&gt;([cb]() {<br/>                          cb-&gt;on_error(<strong class="mn ir">"could not load user"</strong>);<br/>                    }));<br/>                } <strong class="mn ir">else </strong>{<br/>                    me-&gt;storage.store_user(user.value());<br/>                    me-&gt;threads-&gt;run_on_main_thread(<br/>                     std::make_shared&lt;ThreadFuncImpl&gt;([cb, user]() {<br/>                        cb-&gt;on_success(user.value());<br/>                    }));<br/>                }<br/>            }<br/>        } <strong class="mn ir">catch </strong>(...) {<br/>            me-&gt;threads-&gt;run_on_main_thread(<br/>                  std::make_shared&lt;ThreadFuncImpl&gt;([cb]() {<br/>                cb-&gt;on_error(<strong class="mn ir">"could not load user"</strong>);<br/>            }));<br/>        }<br/>    }));<br/>}</span></pre><ol class=""><li id="5078" class="no np iq kh b ki kj kl km ko nq ks nr kw ns la nt nu nv nw bi translated">尝试从本地数据库🡲success回拨获取用户</li><li id="8524" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">尝试从网络和存储到数据库🡲成功回拨</li><li id="56a7" class="no np iq kh b ki nx kl ny ko nz ks oa kw ob la nt nu nv nw bi translated">错误回调。</li></ol><p id="ec90" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有回调都在主线程上调用。</p><h1 id="1959" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">示例应用</h1><h2 id="0e8e" class="mr lp iq bd lq mw mx dn lu my mz dp ly ko na nb ma ks nc nd mc kw ne nf me ng bi translated">反应</h2><p id="bc9a" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这次我们创建了一些小的示例应用程序，所以你可以测试一下。对于web，我创建了一个小小的React应用程序，这是用户视图:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="9a7d" class="mr lp iq mn b gy ms mt l mu mv"><strong class="mn ir">class </strong>UserView <strong class="mn ir">extends <em class="ml">React</em></strong>.Component {<br/><br/>    render() {<br/>        <strong class="mn ir">const </strong>user = <strong class="mn ir">this</strong>.<strong class="mn ir">props</strong>.<strong class="mn ir">user</strong>;<br/>        <strong class="mn ir">if </strong>(user) {<br/>            <strong class="mn ir">return </strong>(<br/>                &lt;<strong class="mn ir">div className="userDetails"</strong>&gt;<br/>                    &lt;<strong class="mn ir">p</strong>&gt;Name: {user.login}&lt;/<strong class="mn ir">p</strong>&gt;<br/>                    &lt;<strong class="mn ir">p</strong>&gt;Created on: {<strong class="mn ir">new <em class="ml">Date</em></strong>(user.created_at.millis()).toLocaleDateString()}&lt;/<strong class="mn ir">p</strong>&gt;<br/>                    &lt;<strong class="mn ir">p</strong>&gt;&lt;<strong class="mn ir">img className="avatar" alt="avatar" src=</strong>{user.avatar_url}/&gt;&lt;/<strong class="mn ir">p</strong>&gt;<br/>                &lt;/<strong class="mn ir">div</strong>&gt;<br/>            );<br/>        } <strong class="mn ir">else </strong>{<br/>            <strong class="mn ir">return null</strong>;<br/>        }<br/>    }<br/>}</span></pre><p id="da36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一值得注意的是，我们从毫秒开始创建日期。</p><p id="8756" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用户是从表单加载的:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="cd1b" class="mr lp iq mn b gy ms mt l mu mv"><strong class="mn ir">if </strong>(!<strong class="mn ir">this</strong>.<strong class="mn ir">callback</strong>) {<br/>    <em class="ml">// eslint-disable-next-line no-undef<br/>    </em><strong class="mn ir">this</strong>.<strong class="mn ir">callback </strong>= <strong class="mn ir">new <em class="ml">Module</em></strong>.JSGetReposCb({<br/>        on_error: (error) =&gt; <strong class="mn ir"><em class="ml">console</em></strong>.error(error),<br/>        on_success: (repos, user) =&gt; {<br/>            <strong class="mn ir">this</strong>.<strong class="mn ir">props</strong>.<strong class="mn ir">onUserChange</strong>(user);<br/>            <strong class="mn ir">this</strong>.<strong class="mn ir">props</strong>.<strong class="mn ir">onReposChange</strong>(repos);<br/><br/>            <em class="ml">// eslint-disable-next-line no-undef<br/>            </em>FS.syncfs(<strong class="mn ir">function </strong>(err) {<br/>                ...<br/>            });<br/><br/><br/>        }<br/>    });<br/>}<br/><br/><strong class="mn ir"><em class="ml">window</em></strong>.<strong class="mn ir">xptuto</strong>.get_repos_for_user_name(<br/>                <strong class="mn ir">this</strong>.<strong class="mn ir">state</strong>.<strong class="mn ir">value</strong>,<strong class="mn ir">this</strong>.<strong class="mn ir">callback</strong>);</span></pre><p id="256b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里也没什么特别的，工作是在C++层完成的，视图层不知道后台发生了什么。唯一要记住的是同步伪文件系统。注意，头像是通过设置图像的<strong class="kh ir"> src </strong>属性自动加载的。</p><p id="f57a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，WebAssembly模块中可用的类和函数对Javascript工具(这里是eslint和Babel)是不可见的，所以我们需要在使用它们时禁用检查，也许在某些时候工具将能够找到embind公开的内容，谁知道呢。</p><h2 id="dd3c" class="mr lp iq bd lq mw mx dn lu my mz dp ly ko na nb ma ks nc nd mc kw ne nf me ng bi translated">机器人</h2><p id="340d" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">对于Android，我做了两个活动，一个用于用户搜索和细节，另一个用于列出存储库。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="6c13" class="mr lp iq mn b gy ms mt l mu mv">x.getUser(v.getText().toString(), <strong class="mn ir">new </strong>GetUserCb() {<br/>    @<strong class="mn ir">Override<br/>    public void </strong>onSuccess(User user) {<br/>        if(!isFinishing() &amp;&amp; !isDestroyed()){<br/>            progressBar.hide();<br/>            details.setVisibility(View.VISIBLE);<br/>            userName.setText(user.login);<br/>            creationDate.setText(DateFormat.getDateInstance(<br/>                DateFormat.MEDIUM,<br/>                Locale.getDefault()).format(user.createdAt));<br/>            avatar.setImageDrawable(<strong class="mn ir"><em class="ml">null</em></strong>);<br/>            Glide.with(MainActivity.this)<br/>                .load(user.avatarUrl).into(avatar);<br/>        }<br/>    }<br/><br/>    @<strong class="mn ir">Override<br/>    public void </strong>onError(String error) {<br/>        if(!isFinishing() &amp;&amp; !isDestroyed()){<br/>            progressBar.hide();<br/>            notFound.setVisibility(View.VISIBLE);<br/>        }<br/>    }<br/>});</span></pre><p id="fefd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">又轻松了。我们使用Java的<strong class="kh ir"> Dateformat </strong>以本地化的方式格式化日期。<a class="ae lb" href="https://bumptech.github.io/glide/" rel="noopener ugc nofollow" target="_blank"> Glide </a>用来加载头像图片，那是安卓最好的图片加载库。</p><p id="2320" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当打开list活动时，我们只需在intent中传递用户名，因为我们将用户存储在存储中，我们可以从那里检索它。我有几次被发现在一个Intent或Bundle中传递了太多的数据，最好传递一个标识符。</p><h2 id="2986" class="mr lp iq bd lq mw mx dn lu my mz dp ly ko na nb ma ks nc nd mc kw ne nf me ng bi translated">ios</h2><p id="8355" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">与Android类似，这次有两个ViewControllers，一个包含搜索表单和细节，一个包含存储库列表，下面是我们如何获取用户:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="876b" class="mr lp iq mn b gy ms mt l mu mv"><strong class="mn ir">__weak auto </strong>welf = self;<br/><br/><strong class="mn ir">auto </strong>x = Xptuto::get_instance();<br/><br/>x-&gt;get_user(djinni::String::toCpp(_userInput.text), std::make_shared&lt;GetUserCbImpl&gt;(<br/>        [welf](<strong class="mn ir">const </strong>User &amp;user) {<br/>            [welf.progress stopAnimating];<br/>            [welf showDetails:user];<br/>        }, [welf](<strong class="mn ir">const </strong>std::string &amp;error) {<br/>            [welf.progress stopAnimating];<br/>            welf.notFoundLabel.hidden = <strong class="mn ir">false</strong>;<br/>        }));</span></pre><p id="1db5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单易行。我们使用一个指向viewcontroller的弱指针，这样我们的回调就不会占用它。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oc"><img src="../Images/5fb6102851a483b834856ea28d60e663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Em8UddOwQisTEF-_D7j-hw.png"/></div></div></figure><h1 id="afe5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="bc59" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我已经向您展示了离线和复杂的数据操作只是一个编译的距离，您可以掸掉您的数据库建模书籍，并去实现您的便携式设备上的数据缓存现在，没有借口。</p><p id="63ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不需要尝试从手机或模拟器中取出SQLite数据粘贴文件等有趣的东西，您可以在计算机上、内存中或文件中运行您的代码，将其加载到SQLite浏览器GUI中，它将在Web、iOS和Android上以完全相同的方式运行。</p><div class="od oe gp gr of og"><a href="https://sqlitebrowser.org/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">SQLite的数据库浏览器</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">DB Browser for SQLite (DB4S)是一个高质量的可视化开源工具，用于创建、设计和编辑数据库文件…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">sqlitebrowser.org</p></div></div></div></a></div><h1 id="28d1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">参考</h1><div class="od oe gp gr of og"><a href="https://www.pearson.com/us/higher-education/program/Connolly-Database-Systems-A-Practical-Approach-to-Design-Implementation-and-Management-6th-Edition/PGM116956.html" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">数据库系统:设计、实施和管理的实用方法，第6版</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">Thomas Connolly Carolyn Begg第1部分背景1第1章数据库简介3 1.1简介4 1.2…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.pearson.com</p></div></div><div class="op l"><div class="oq l or os ot op ou lm og"/></div></div></a></div><h1 id="cd90" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">另请参阅:</h1><h1 id="8110" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><a class="ae lb" href="https://medium.com/@stephane_21545/cross-platform-mobile-and-web-development-with-c-explained-aac9952b4f8c" rel="noopener">简介:</a></h1><p id="5dfe" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们提出我们的技术选择。</p><h1 id="920e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">1.<a class="ae lb" href="https://medium.com/@stephane_21545/cross-platform-mobile-and-web-development-with-c-explained-8d2ab1224c0a" rel="noopener">项目设置</a></h1><p id="d65c" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们将配置一个在iOS/Xcode、Android Studio和Emscripten/CMake上编译和运行的项目，并展示如何运行和调试其中的3个项目。</p><h1 id="38db" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><a class="ae lb" href="https://medium.com/@stephane_21545/cross-platform-mobile-and-web-development-with-c-explained-587a235cbb0b" rel="noopener"> 2。传递周围的物体</a></h1><p id="103e" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在这个例子中，我们将展示如何将对象从业务逻辑层传递到不同的视图层。</p><h1 id="ace3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><a class="ae lb" href="https://medium.com/swlh/cross-platform-mobile-and-web-development-with-c-explained-8fb5fb916d35" rel="noopener"> 3。单元测试</a></h1><p id="9457" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这里，我们使用常用的<strong class="kh ir"> Google Test </strong>框架在C++代码中设置单元测试。</p><h1 id="85fb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><a class="ae lb" href="https://medium.com/swlh/cross-platform-mobile-and-web-development-with-c-explained-e8cd420665af" rel="noopener"> 4。休息客户端</a></h1><p id="9ae9" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们使用平台HTTP实现实现了一个最小的ReST客户端。</p><h1 id="d4cb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/cross-platform-mobile-and-web-development-with-c-explained-94e112d31351"> 5。多线程</a></h1><p id="8cb1" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">是的，你可以以可移植的方式在所有三种环境中使用线程！</p><blockquote class="ni nj nk"><p id="6a19" class="kf kg ml kh b ki kj jr kk kl km ju kn nl kp kq kr nm kt ku kv nn kx ky kz la ij bi translated">下次我们将谈论OpenGL。</p></blockquote></div></div>    
</body>
</html>