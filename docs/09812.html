<html>
<head>
<title>Python: Salting Your Password Hashes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:加盐你的密码散列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-salting-your-password-hashes-3eb8ccb707f9?source=collection_archive---------0-----------------------#2021-09-17">https://levelup.gitconnected.com/python-salting-your-password-hashes-3eb8ccb707f9?source=collection_archive---------0-----------------------#2021-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee13" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高您的哈希对密码破解的抵抗力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eca44b76eb084e7fe77a1f5ef3de4a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZVjRhGU9O56SEwNy2i2vA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz"> cottonbro </strong> </a>来自<a class="ae ky" href="https://www.pexels.com/photo/person-seasoning-green-beans-with-salt-3298782/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kz"> Pexels </strong> </a></figcaption></figure><p id="8913" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在之前的<a class="ae ky" href="https://blog.devgenius.io/password-hashing-with-python-f3148692e8b9" rel="noopener ugc nofollow" target="_blank">文章</a>中，我分享了如何保护用户的密码。那篇文章假设散列用户的明文密码可以保护他们。</p><div class="lw lx gp gr ly lz"><a href="https://blog.devgenius.io/password-hashing-with-python-f3148692e8b9" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">使用Python进行密码散列</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">即使用户密码被破解，也要保证其安全。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">blog.devgenius.io</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div><p id="ab49" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">嗯，那只是半个事实。散列密码并不能完全保护它们。简单地将明文密码转换成无形的、不可逆的字符串并不能完全保护它们。但是，与在数据库中以明文形式存储用户密码相比，哈希密码仍然是安全的。</p><p id="fe24" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">散列密码是不可逆的，也是混乱的，但它们仍然容易受到暴力攻击和彩虹表攻击。</p><p id="f9ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在暴力攻击中，攻击者从不同的计算机字符组合中生成散列，希望与数据库中的散列相匹配。</p><p id="db90" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">考虑在您的数据库中有一个包含相应的<code class="fe mo mp mq mr b">sha256</code>哈希值的密码表。未经授权访问您的数据库并拥有包含密码<code class="fe mo mp mq mr b">Harry03</code>和<code class="fe mo mp mq mr b">tiPsy</code>的密码字典的攻击者将成功生成匹配的哈希。用户现在可以使用密码<code class="fe mo mp mq mr b">Harry03</code>和<code class="fe mo mp mq mr b">tiPsy</code>访问两个用户的数据</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用户名和相应的sha256哈希表</figcaption></figure><p id="5bd6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在彩虹表攻击中，攻击者预先计算并生成一个明文密码及其相应哈希的表。攻击者接下来试图将他的表散列与存储在数据库中的散列进行匹配。预先计算的散列使得彩虹表攻击比暴力和字典攻击更快和更有效。但不要担心，我们会学习如何减轻这一点。</p><h1 id="9bc3" class="mu mv it bd kz mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">用盐强化密码散列</h1><p id="b6df" class="pw-post-body-paragraph la lb it lc b ld nl ju lf lg nm jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">密码<a class="ae ky" href="https://en.wikipedia.org/wiki/Salt_(cryptography)" rel="noopener ugc nofollow" target="_blank">盐</a>降低了密码被破解的风险。在您的密码中添加盐会使攻击者在生成匹配散列时更加复杂。要破解每个salt散列，他必须知道与明文密码一起散列的唯一salt。只知道明文密码是不够的。</p><p id="53db" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">加盐密码散列降低了攻击者的成功率，无论攻击是预先计算的攻击还是暴力攻击。</p><p id="7707" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">salt是添加到明文密码中的随机字符串，它们被哈希在一起以生成不可逆的哈希。不知道salt的攻击者不能生成匹配的散列。</p><p id="e2d1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在Python中，<a class="ae ky" href="https://docs.python.org/3/library/hashlib.html" rel="noopener ugc nofollow" target="_blank"> hashlib </a>模块提供了一个关键的衍生函数(KDF ),我们可以用它来实现这一点。KDF是散列函数，通过使散列的生成在计算上缓慢，被设计为健壮的并且抵抗强力攻击。KDF函数有一个成本因素，它决定了哈希的生成速度应该有多慢。更高的成本系数意味着哈希函数需要更长的时间和更多的CPU能力来生成哈希。成本因素所做的是，它延迟了攻击者试图破解您的密码散列的努力。在强力攻击中长时间生成散列可能会让攻击者望而却步，或者如果及时引起您的注意，至少会给您一个对攻击做出反应的机会。</p><blockquote class="nq nr ns"><p id="2b5e" class="la lb nt lc b ld le ju lf lg lh jx li nu lk ll lm nv lo lp lq nw ls lt lu lv im bi translated">OWASP <a class="ae ky" href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank">将</a>salt定义为唯一的随机字符串。每个密码都用一个唯一的随机salt字符串散列。这加倍了攻击者的努力。攻击者必须知道他试图破解每个密码的唯一salt。</p></blockquote></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="2e68" class="mu mv it bd kz mw oe my mz na of nc nd jz og ka nf kc oh kd nh kf oi kg nj nk bi translated">hashlib.pbkdf2_hmac(hash_name，password，salt，iterations，dklen=None)</h1><p id="c916" class="pw-post-body-paragraph la lb it lc b ld nl ju lf lg nm jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated">这个函数是基于密码的密钥派生函数2(PBKDF2)的Python实现。这是一种强大而安全的KDF散列函数。我们将使用这个函数生成一个加盐散列密码。</p><p id="bf04" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个函数的签名有5个参数，并返回生成的散列的摘要。</p><h2 id="94a7" class="oj mv it bd kz ok ol dn mz om on dp nd lj oo op nf ln oq or nh lr os ot nj ou bi translated">因素</h2><p id="4cdc" class="pw-post-body-paragraph la lb it lc b ld nl ju lf lg nm jx li lj nn ll lm ln no lp lq lr np lt lu lv im bi translated"><code class="fe mo mp mq mr b">hash_name</code>第一个参数是用于生成哈希的哈希算法。SHA-2算法作为参数被支持。</p><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="c123" class="oj mv it mr b gy oz pa l pb pc">'sha224', 'sha384', 'sha512', 'sha256'</span></pre><p id="5a61" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mo mp mq mr b">password</code>第二个参数是明文密码，我们必须将它加盐并散列成无形的不可逆散列。需要编码的字节字符串。</p><p id="4e72" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mo mp mq mr b">salt</code>第三个参数是添加到<code class="fe mo mp mq mr b">password</code>中的唯一字符串，然后使用我们特定的哈希算法进行哈希处理，以生成健壮的哈希。该值也必须是编码的字节字符串。NIST <a class="ae ky" href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf" rel="noopener ugc nofollow" target="_blank">建议</a>salt的长度必须至少为32字节或256位，唯一且可任意生成。与此一致，我们将使用Python的<code class="fe mo mp mq mr b">os.urandom(...)</code>方法生成我们独特的任意salt。</p><p id="fd21" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mo mp mq mr b">iteration</code>第四个参数有时被称为成本系数或工作系数。简单来说，就是哈希算法被调用的次数。例如，迭代3意味着，指定的哈希函数将对<code class="fe mo mp mq mr b">password</code>和<code class="fe mo mp mq mr b">salt</code>进行哈希运算，随后对生成的哈希进行另一次哈希运算，然后对第二次生成的哈希进行第三次哈希运算。</p><p id="f34c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第五个参数是可选的。它表示生成的摘要或哈希值的长度。如果没有提供，哈希的长度等于用于生成哈希的哈希函数的长度。</p><p id="a101" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">让我们使用散列名称</strong> <code class="fe mo mp mq mr b"><strong class="lc iu">sha256</strong></code> <strong class="lc iu">为明文密码</strong> <code class="fe mo mp mq mr b"><strong class="lc iu">hellow0rld</strong></code> <strong class="lc iu">生成一个加盐散列。您可以使用我前面列出的任何哈希算法。</strong></p><ul class=""><li id="7092" class="pd pe it lc b ld le lg lh lj pf ln pg lr ph lv pi pj pk pl bi translated">首先，我们将使用<code class="fe mo mp mq mr b">os.urandom</code>生成我们独特的任意销售，以符合NIST推荐的最小salt长度32字节</li></ul><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="82df" class="oj mv it mr b gy oz pa l pb pc">import os</span><span id="a9b3" class="oj mv it mr b gy pm pa l pb pc">salt = os.urandom(32)</span></pre><p id="b775" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">生成一个随机的32字节长度的salt，如下所示</p><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="5d43" class="oj mv it mr b gy oz pa l pb pc">\xa9\x84\x01\x96\xa4\t\xadP\x1e\xf3:\x94[\xb7\x9c=\xfebI\x03\xa2\x05\xd5\x9a\x19\x9b\xabhO\x13\xb8\x83</span></pre><ul class=""><li id="2cf4" class="pd pe it lc b ld le lg lh lj pf ln pg lr ph lv pi pj pk pl bi translated">我们还将使用Python的<code class="fe mo mp mq mr b">str</code>对象上的<code class="fe mo mp mq mr b">encode()</code>方法将我们的明文或密码<code class="fe mo mp mq mr b">hellow0rld</code>编码成字节。</li></ul><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="db1b" class="oj mv it mr b gy oz pa l pb pc">plaintext = 'hellow0rld'.encode()</span></pre><ul class=""><li id="98bd" class="pd pe it lc b ld le lg lh lj pf ln pg lr ph lv pi pj pk pl bi translated">同样，对于迭代，我们将使用迭代计数<code class="fe mo mp mq mr b">10000</code>，这是推荐的最小计数。根据您的服务器的计算能力以及您希望对用户的身份验证体验产生的明显影响，您可能需要增加这个值。过高的数字会降低攻击者执行暴力攻击的速度，但同样会降低用户的身份验证体验。因此，应该考虑合理的迭代次数。</li><li id="5168" class="pd pe it lc b ld pn lg po lj pp ln pq lr pr lv pi pj pk pl bi translated">我们将保持摘要长度为哈希算法的长度。</li><li id="4ebf" class="pd pe it lc b ld pn lg po lj pp ln pq lr pr lv pi pj pk pl bi translated">准备好所有的函数依赖项后，我们将使用哈希算法<code class="fe mo mp mq mr b">sha256</code>生成一个哈希</li></ul><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="7696" class="oj mv it mr b gy oz pa l pb pc">import hashlib</span><span id="23c9" class="oj mv it mr b gy pm pa l pb pc">digest = hashlib.pbkdf2_hmac('sha256', plaintext, salt, <!-- -->10000)</span></pre><ul class=""><li id="a390" class="pd pe it lc b ld le lg lh lj pf ln pg lr ph lv pi pj pk pl bi translated"><code class="fe mo mp mq mr b">digest</code>变量保存返回的摘要对象。这个hash对象公开了一系列操作生成的hash的方法。为了简化本文，我们将只考虑如何检索人类友好的十六进制格式的散列，以及一个字节串。</li><li id="eb5d" class="pd pe it lc b ld pn lg po lj pp ln pq lr pr lv pi pj pk pl bi translated">使用<code class="fe mo mp mq mr b">digest.hex()</code>将哈希作为友好的十六进制字符串进行检索</li></ul><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="6688" class="oj mv it mr b gy oz pa l pb pc">hex_hash = digest.hex()<br/>print(hex_hash)</span></pre><p id="048b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输出:</p><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="7065" class="oj mv it mr b gy oz pa l pb pc">83665efbba86a7bc431c118732a3833ba6f1ddac0b9bab1ee5f5403459347678</span></pre><ul class=""><li id="6b9c" class="pd pe it lc b ld le lg lh lj pf ln pg lr ph lv pi pj pk pl bi translated">在字节串中检索散列，我们将使用方法<code class="fe mo mp mq mr b">digest.fromhex()</code>。该方法将十六进制字符串作为参数。</li></ul><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="3daa" class="oj mv it mr b gy oz pa l pb pc">byte_hash = digest.fromhex(digest.hex())<br/>print(byte_hash)</span></pre><p id="f244" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">输出:</p><pre class="kj kk kl km gt ov mr ow ox aw oy bi"><span id="72e7" class="oj mv it mr b gy oz pa l pb pc">\x83f^\xfb\xba\x86\xa7\xbcC\x1c\x11\x872\xa3\x83;\xa6\xf1\xdd\xac\x0b\x9b\xab\x1e\xe5\xf5@4Y4vx</span></pre><p id="0095" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">完整代码</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用pbkdf2_sha256生成salted hash的完整代码</figcaption></figure></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="eb9a" class="oj mv it bd kz ok ol dn mz om on dp nd lj oo op nf ln oq or nh lr os ot nj ou bi translated">参考</h2><ul class=""><li id="c26a" class="pd pe it lc b ld nl lg nm lj ps ln pt lr pu lv pi pj pk pl bi translated"><a class="ae ky" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf" rel="noopener ugc nofollow" target="_blank">基于密码的密钥派生推荐标准第1部分:存储应用</a></li><li id="548a" class="pd pe it lc b ld pn lg po lj pp ln pq lr pr lv pi pj pk pl bi translated"><a class="ae ky" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-107r1.pdf" rel="noopener ugc nofollow" target="_blank">使用批准的哈希算法的应用推荐</a></li><li id="c3cb" class="pd pe it lc b ld pn lg po lj pp ln pq lr pr lv pi pj pk pl bi translated"><a class="ae ky" href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank"> OWASP密码存储备忘单</a></li><li id="5dc3" class="pd pe it lc b ld pn lg po lj pp ln pq lr pr lv pi pj pk pl bi translated"><a class="ae ky" href="https://docs.python.org/3/library/hashlib.html" rel="noopener ugc nofollow" target="_blank"> Python hashlib模块</a></li></ul></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="6292" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">希望这篇文章对你有所帮助。</p><p id="a204" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="nt">作为中级会员，您可以无限制地访问无限制的有用内容。使用</em> <a class="ae ky" href="https://ofelix03.medium.com/membership" rel="noopener"> <em class="nt">我的推荐链接</em> </a> <em class="nt">加入今天只为</em><strong class="lc iu"><em class="nt">【5】</em></strong><em class="nt">。通过</em> <a class="ae ky" href="https://ofelix03.medium.com/membership" rel="noopener"> <em class="nt">加盟Medium </em> </a> <em class="nt">，你也是在支持我的写作，因为我在你使用</em> <a class="ae ky" href="https://ofelix03.medium.com/membership" rel="noopener"> <em class="nt">我的推荐链接</em> </a> <em class="nt">的时候赚了一点佣金。这项佣金不会增加你的额外费用。</em></p><div class="lw lx gp gr ly lz"><a href="https://ofelix03.medium.com/membership" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">通过我的推荐链接加入媒体-费利克斯·奥托</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">ofelix03.medium.com</p></div></div><div class="mi l"><div class="pv l mk ml mm mi mn ks lz"/></div></div></a></div></div></div>    
</body>
</html>