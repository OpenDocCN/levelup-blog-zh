<html>
<head>
<title>JavaScript Event Handlers: ondragstart and ondrop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序:ondragstart和ondrop</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-events-handlers-ondragstart-and-ondrop-3367288a67ff?source=collection_archive---------4-----------------------#2019-12-19">https://levelup.gitconnected.com/javascript-events-handlers-ondragstart-and-ondrop-3367288a67ff?source=collection_archive---------4-----------------------#2019-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ca1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解JavaScript中拖放事件的工作原理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53f263f24af0917cf3d2b5712f327ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cvfBh6HCqRKlwVAr"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·汉森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="faad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事情触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。</p><p id="b175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以为事件分配事件处理程序，这样当事件被触发时，我们就可以执行一个动作。发生在DOM元素上的事件可以通过为相应事件的DOM对象的属性分配一个事件处理程序来处理。在本文中，我们将看看<code class="fe lv lw lx ly b">ondragstart</code>和<code class="fe lv lw lx ly b">ondrop</code>事件处理程序。</p><h1 id="66ee" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">ondragstart事件</h1><p id="75ba" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">HTML元素的<code class="fe lv lw lx ly b">ondragstart</code>属性让我们为当用户开始拖动元素或文本选择时触发的<code class="fe lv lw lx ly b">dragstart</code>事件分配一个事件处理程序。例如，如果我们想跟踪一个元素何时开始被拖动，何时被放下，我们可以编写下面的HTML代码:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="0d89" class="na ma it ly b gy nb nc l nd ne">&lt;p id='drag-start-tracker'&gt;<br/>&lt;/p&gt;</span><span id="026f" class="na ma it ly b gy nf nc l nd ne">&lt;div id='drag-box' draggable="true"&gt;<br/>&lt;/div&gt;</span><span id="90e0" class="na ma it ly b gy nf nc l nd ne">&lt;div id='drop-zone'&gt;<br/>&lt;/div&gt;</span></pre><p id="e3b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有一个<code class="fe lv lw lx ly b">p</code>元素来显示什么时候被拖动，以及被拖动元素的ID。我们有一个ID为<code class="fe lv lw lx ly b">drag-box</code>的元素正在被拖动。在它下面，我们有一个ID为<code class="fe lv lw lx ly b">drop-</code>的<code class="fe lv lw lx ly b">div</code>区域，它将接受任何被拖放到其中的元素。然后，我们可以添加以下CSS来样式化我们在上面添加的HTML元素:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="2d49" class="na ma it ly b gy nb nc l nd ne">#drag-box {<br/>  width: 100px;<br/>  height: 100px;<br/>  background-color: red;<br/>}</span><span id="280c" class="na ma it ly b gy nf nc l nd ne">#drop-zone {<br/>  width: 200px;<br/>  height: 200px;<br/>  background-color: purple<br/>}</span></pre><p id="2a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到<code class="fe lv lw lx ly b">drag-box</code>是红色的<code class="fe lv lw lx ly b">drop-zone</code>是紫色的<code class="fe lv lw lx ly b">drop-zone</code>比<code class="fe lv lw lx ly b">drag-box</code>大。接下来，我们可以将自己的事件处理函数分配给代表<code class="fe lv lw lx ly b">drag-box</code>元素的DOM对象的<code class="fe lv lw lx ly b">ondragstart</code>属性，以便在它被拖动时对其进行跟踪，并更新我们的<code class="fe lv lw lx ly b">drag-start-tracker</code> <code class="fe lv lw lx ly b">p</code>元素，以显示<code class="fe lv lw lx ly b">drag-box</code>正在被拖动，代码如下:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="a07f" class="na ma it ly b gy nb nc l nd ne">const dragBox = document.getElementById('drag-box');<br/>const dropZone = document.getElementById('drop-zone');<br/>const dragStartTracker = document.getElementById('drag-start-tracker');</span><span id="db40" class="na ma it ly b gy nf nc l nd ne">dragBox.ondragstart = (e) =&gt; {<br/>  dragStartTracker.innerHTML = `Element with ID ${e.target.id} is being dragged.`;<br/>};</span><span id="7d51" class="na ma it ly b gy nf nc l nd ne">dragBox.ondragend = (e) =&gt; {<br/>  dragStartTracker.innerHTML = '';<br/>  dropZone.appendChild(e.srcElement);<br/>};</span></pre><p id="a0a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们可以看到在拖动<code class="fe lv lw lx ly b">drag-box</code>元素时,“带有ID的元素拖动框正在被拖动”,当我们停止拖动框并将其放入<code class="fe lv lw lx ly b">drop-zone</code>元素时，我们应该会看到文本消失了，而<code class="fe lv lw lx ly b">drag-box</code>元素停留在<code class="fe lv lw lx ly b">drop-zone</code>元素内。它的工作原理是，当我们第一次开始拖动<code class="fe lv lw lx ly b">drag-box</code>元素时，<code class="fe lv lw lx ly b">dragstart</code>事件将被触发，而<code class="fe lv lw lx ly b">dragBox.ondragstart</code>将被传入的<code class="fe lv lw lx ly b">DragEvent</code>对象调用，该对象具有<code class="fe lv lw lx ly b">e.target.id</code>属性，我们引用该属性来获取<code class="fe lv lw lx ly b">drag-box</code>元素的ID。</p><p id="e28e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在<code class="fe lv lw lx ly b">drag-box</code>位于<code class="fe lv lw lx ly b">drop-zone</code>上方时释放鼠标按钮，我们分配给<code class="fe lv lw lx ly b">ondragend</code>事件处理程序的事件处理程序被调用，因为<code class="fe lv lw lx ly b">dragend</code>事件是通过释放鼠标按钮触发的，结束了<code class="fe lv lw lx ly b">drag-box</code>的拖动。</p><p id="9853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数内部，我们有一个在函数被调用时传入的<code class="fe lv lw lx ly b">DragEvent</code>对象，我们可以使用<code class="fe lv lw lx ly b">srcElement</code>来获取被拖动元素的DOM元素对象，所以我们可以使用<code class="fe lv lw lx ly b">dropZone</code>对象的<code class="fe lv lw lx ly b">appendChild</code>方法来追加<code class="fe lv lw lx ly b">drag-box</code>元素，这是我们通过将<code class="fe lv lw lx ly b">srcElement</code>属性添加到<code class="fe lv lw lx ly b">drop-zone</code>元素中所得到的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/43b917a4377c4b96bed9f1b46f0e8637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xVgGft1pVG8DlrJ7"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@xusanfeng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Levi XU </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="e0fe" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">ondrop事件</h1><p id="5b32" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们可以设置DOM元素的<code class="fe lv lw lx ly b">ondrop</code>属性来处理该元素的<code class="fe lv lw lx ly b">drop</code>事件。当一个元素或文本选择被放入一个有效的放置目标时，触发<code class="fe lv lw lx ly b">drop</code>事件。例如，我们可以用它来制作一个可以拖到两个不同盒子的<code class="fe lv lw lx ly b">div</code>元素，并使用<code class="fe lv lw lx ly b">ondrop</code>事件处理程序来处理拖放操作。首先，我们添加以下HTML代码来制作可拖动的<code class="fe lv lw lx ly b">div</code>元素和2个<code class="fe lv lw lx ly b">div</code>元素，我们可以将可拖动的<code class="fe lv lw lx ly b">div</code>元素放到以下代码中:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="662c" class="na ma it ly b gy nb nc l nd ne">&lt;div id='drag-box' draggable="true"&gt;<br/>&lt;/div&gt;</span><span id="4572" class="na ma it ly b gy nf nc l nd ne">&lt;div id='drop-zones'&gt;<br/>  &lt;div id='drop-zone'&gt;<br/>  &lt;/div&gt;</span><span id="5655" class="na ma it ly b gy nf nc l nd ne">&lt;div id='drop-zone-2'&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="da5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以添加一些CSS代码，用下面的代码来样式化<code class="fe lv lw lx ly b">div</code>元素:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="0500" class="na ma it ly b gy nb nc l nd ne">#drag-box {<br/>  width: 100px;<br/>  height: 100px;<br/>  background-color: red;<br/>}</span><span id="2d99" class="na ma it ly b gy nf nc l nd ne">#drop-zone {<br/>  width: 200px;<br/>  height: 200px;<br/>  background-color: purple<br/>}</span><span id="0f76" class="na ma it ly b gy nf nc l nd ne">#drop-zone-2 {<br/>  width: 200px;<br/>  height: 200px;<br/>  background-color: green<br/>}</span><span id="9cc6" class="na ma it ly b gy nf nc l nd ne">#drop-zones {<br/>  display: flex;<br/>}</span></pre><p id="e68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们通过添加一个ID为<code class="fe lv lw lx ly b">drop-zones</code>的<code class="fe lv lw lx ly b">div</code>来包含其中的2个<code class="fe lv lw lx ly b">div</code>元素，从而使<code class="fe lv lw lx ly b">drop-zone</code> <code class="fe lv lw lx ly b">div</code>元素并排。我们使用<code class="fe lv lw lx ly b">display: flex</code> CSS代码并排显示<code class="fe lv lw lx ly b">drop-zone</code>和<code class="fe lv lw lx ly b">drop-zone-2</code>元素。然后我们改变每个div的背景颜色，这样我们就可以区分它们。接下来，我们添加JavaScript代码来处理<code class="fe lv lw lx ly b">drag-box</code> <code class="fe lv lw lx ly b">div</code>元素的拖放，并使用我们用以下代码定义的with <code class="fe lv lw lx ly b">ondrop</code>事件处理程序将其放入<code class="fe lv lw lx ly b">drop-zone</code>元素中:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="9a80" class="na ma it ly b gy nb nc l nd ne">const dragBox = document.getElementById('drag-box');</span><span id="84b4" class="na ma it ly b gy nf nc l nd ne">dragBox.ondragstart = (e) =&gt; {<br/>  e<br/>    .dataTransfer<br/>    .setData('text/plain', event.target.id);<br/>};</span><span id="5844" class="na ma it ly b gy nf nc l nd ne">document.ondragover = (e) =&gt; {<br/>  e.preventDefault();<br/>};</span><span id="ca1b" class="na ma it ly b gy nf nc l nd ne">document.ondrop = (e) =&gt; {<br/>  const id = e<br/>    .dataTransfer<br/>    .getData('text');<br/>  e.srcElement.appendChild(document.getElementById(id));<br/>}</span></pre><p id="3df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码通过处理<code class="fe lv lw lx ly b">ondragstart</code>事件处理程序来获取被拖动元素的ID。当用户开始拖动<code class="fe lv lw lx ly b">drag-box</code> <code class="fe lv lw lx ly b">div</code>时，调用<code class="fe lv lw lx ly b">ondragstart</code>处理程序。在我们定义的<code class="fe lv lw lx ly b">ondragstart</code>事件处理函数中，我们调用了<code class="fe lv lw lx ly b">e.dataTransfer.setData</code>方法来设置<code class="fe lv lw lx ly b">DataTransfer</code>对象的<code class="fe lv lw lx ly b">'text'</code>属性，稍后当我们将<code class="fe lv lw lx ly b">drag-box</code>放入<code class="fe lv lw lx ly b">drop-zone</code>或<code class="fe lv lw lx ly b">drop-zone-2</code> <code class="fe lv lw lx ly b">div</code>元素中时，我们需要用到它。非常重要的是，我们拥有:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="b83d" class="na ma it ly b gy nb nc l nd ne">document.ondragover = (e) =&gt; {<br/>  e.preventDefault();<br/>};</span></pre><p id="4546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这阻止了<code class="fe lv lw lx ly b">ondragover</code>事件处理程序处理事件，因为一旦它被那个事件处理程序处理，那么<code class="fe lv lw lx ly b">drop</code>事件就不会被触发，我们的<code class="fe lv lw lx ly b">ondrop</code>事件处理程序也不会运行。这样一来，我们可以定义我们的<code class="fe lv lw lx ly b">ondrop</code>事件处理程序，然后将它分配给<code class="fe lv lw lx ly b">document.ondrop</code>属性来处理<code class="fe lv lw lx ly b">document</code>的<code class="fe lv lw lx ly b">drop</code>事件。</p><p id="459b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件处理函数有一个<code class="fe lv lw lx ly b">e</code>参数，它是一个<code class="fe lv lw lx ly b">DragEvent</code>对象，它有一些有用的属性，我们可以用它们来处理<code class="fe lv lw lx ly b">drag-box </code>元素的删除。在该事件处理程序中，我们通过调用带有<code class="fe lv lw lx ly b">'text'</code>字符串的<code class="fe lv lw lx ly b">e.dataTransfer.getData</code>方法来获取我们正在拖动的元素的ID。</p><p id="eb64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以使用<code class="fe lv lw lx ly b">e</code>对象的<code class="fe lv lw lx ly b">srcElement</code>属性来获取我们的<code class="fe lv lw lx ly b">drag-box</code> <code class="fe lv lw lx ly b">div</code>正在被删除的DOM元素，并使用<code class="fe lv lw lx ly b">document.getElementById(id)</code>参数对其调用<code class="fe lv lw lx ly b">appendChild</code>，其中<code class="fe lv lw lx ly b">id</code>应该是<code class="fe lv lw lx ly b">'drag-box'</code>，因为这是从<code class="fe lv lw lx ly b">e.dataTransfer.getData(‘text’);</code>返回的内容，因为我们在<code class="fe lv lw lx ly b">dragBox.ondragstart</code>事件处理程序中设置了<code class="fe lv lw lx ly b">drag-box</code>元素的ID。</p><h1 id="509c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包裹</h1><p id="5094" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">ondragstart</code>和<code class="fe lv lw lx ly b">ondrop</code>属性对于在我们的网页中制作拖放功能非常有用。属性让我们为<code class="fe lv lw lx ly b">dragstart</code>事件分配一个事件处理程序，当用户开始拖动一个元素或文本选择时就会触发这个事件。我们可以设置DOM元素的<code class="fe lv lw lx ly b">ondrop</code>属性来处理该元素的<code class="fe lv lw lx ly b">drop</code>事件。当一个元素或文本选择被放入一个有效的放置目标时，触发<code class="fe lv lw lx ly b">drop</code>事件。</p><p id="3171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们已经为<code class="fe lv lw lx ly b">document</code>的<code class="fe lv lw lx ly b">ondragover</code>属性设置了一个事件处理函数，并在函数内部调用<code class="fe lv lw lx ly b">e.preventDefault()</code>来阻止<code class="fe lv lw lx ly b">ondragover</code>事件处理函数处理<code class="fe lv lw lx ly b">dragover</code>事件，从而阻止<code class="fe lv lw lx ly b">drop</code>事件的触发。这样一来，我们可以为<code class="fe lv lw lx ly b">ondrop</code>属性分配一个事件处理程序，将draggable元素作为子元素添加到drop target元素中。</p></div></div>    
</body>
</html>