# 为什么我们不再为人类写代码了？

> 原文：<https://levelup.gitconnected.com/why-are-we-no-longer-writing-code-for-humans-48ab96a89e84>

> 任何傻瓜都能写出计算机能理解的代码。优秀的程序员写出人类能理解的代码
> 马丁·福勒

![](img/246e761a1912c7782e1351aa19fb47b6.png)

在实现可爱的问题解决方案和林挺代码时，我们迷失了方向。

每当我看到用 React、JavaScript 甚至 C#编写的代码库时，我发现很难理解开发人员想要表达的意思。

为了理解一个简单的工作流程，我最终在 IDE 中打开了 10 到 20 个文件。为了理解一段代码，你需要知道太多的“隐藏”区域。

严格说前端代码，我们一致接受事件驱动的工作流。但是事情从来都不是对人类友好的，不是吗？当你试图阅读某人的代码时，过度依赖于了解所有的事件发送者和订阅者会扼杀所有的节奏。

复杂工作流的一个简单示例如下:

假设你想写一个接受产品订单的程序。在一个非常简化的工作流程中，程序应该通过执行以下步骤来创建订单:

1.  接受产品以创建订单
2.  检查库存的可用性
3.  写入订单队列或表格
4.  向用户确认订单

为了理解整个工作流，我必须打开一个 OrderProcessor 文件，并查看四个方法，这些方法正在做这些事情:

**BeginOrderProcessing(product id)；
检查库存(product id)；
CreateOrder(productId，…other info)；
NotifyOrderSuccessful()；**

我不需要打开任何其他文件就可以在很高的层面上理解工作流程。如果我想知道这些过程的细节，我会直接去实现。

但是当我查看一些代码时，我几乎总是发现有人将 **CreateOrder** 放在 **CheckInventory** 中，将 **NotifyOrderSuccessful** 放在 **CreateOrder** 中，让我忘记了实际的工作流程。这并不像预期的功能不会工作。它会的，就像这里的**电脑**的指令没有问题一样，但是向**人类**传达意图的过程中被牺牲了。

让我们成为人类，为人类写代码。