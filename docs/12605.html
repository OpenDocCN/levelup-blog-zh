<html>
<head>
<title>C++ Library-oriented debugging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向C++库的调试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-library-oriented-debugging-c97390165818?source=collection_archive---------7-----------------------#2022-06-22">https://levelup.gitconnected.com/c-library-oriented-debugging-c97390165818?source=collection_archive---------7-----------------------#2022-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6d0f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您的C++应用程序如何享受静态链接的好处，同时在运行时保持动态链接的开发灵活性？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5bd978619d2a1b286ab08a188fb04563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*snNEWGg1wd_ID2LO"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">链接！玛利亚·李森科在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d0eb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动机</h1><p id="3e71" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">成熟的实时应用程序很难使用。随着范围的扩大、特性的增加以及依赖关系的逐渐耦合，开发周期变得越来越慢。在本文中，我提供了一个非常基本的概念，“T4”rapid CPP，用于缩短开发周期。</p><p id="7e9d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">想象一下，一个衡量你在设置环境、索引IDE、配置、编译、链接和测试应用上花费的时间的指标，实际上与你的市场革新特性直接相关。这个指标是一个组织的无声杀手——一种不断增加的隐形税，它的利息由你的组织每天支付。</p><p id="dae8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这种税基本上是可以避免的。</p><p id="9c12" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">以我的经验来看，最痛苦的是为了测试一个微小的变化而重置设置。有时痛苦在于花几个小时重新编译我没有编辑过的源代码。有时甚至从未见过。</p><p id="4957" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">通常，面向性能的应用程序从静态链接开始。有道理。动态链接要复杂得多，需要运行时开销，并且可能容易出现非常微妙的问题(例如，不正确的符号解析、不同的版本控制以及对执行环境的依赖)。随着时间的推移，这种决策会持续下去，因为大多数开发人员不会每天都处理项目结构，因此，应用程序blob会变得越来越大。</p><p id="777e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">但是我在这里并不是要推广动态链接在实时生产环境中的使用。还有其他人证明做这件事是正当的。<br/>我希望在<strong class="lq ir">开发</strong> <strong class="lq ir">环境</strong>中推广使用动态链接。</p><h1 id="6992" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Rapidcpp</h1><p id="395e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">激励我的想法是一些被调试组件的静态和动态库之间的可互换性的概念。<br/>一些依赖项被链接，但是链接的方法<strong class="lq ir">静态</strong>或<strong class="lq ir">动态</strong>对大多数来说意义不大。然而，它确实在实际意义上发挥了作用。</p><p id="afa9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">由于实时应用程序中的大多数链接都是静态的，因此修改函数是不可能的。另一方面，动态链接允许我们在运行时进行符号解析，并用修改后的实现覆盖当前的函数指针。</p><p id="097a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这似乎是一个开始。</p><p id="67a7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了实现可互换性，<em class="mk"> Rapidcpp </em>应牢记以下目标:</p><ol class=""><li id="5c0a" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj mv mw mx my bi translated">支持应该尽可能透明的调试基础结构。</li><li id="92e1" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">原始代码应该保持不变。</li><li id="8350" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">调试模式应该从构建系统触发，而不是从代码触发。</li><li id="ac5c" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">启用现有功能符号的替代。</li><li id="1243" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">对性能的影响尽可能小。</li></ol><h1 id="1509" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">两种动态链接</h1><p id="d3da" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe ne nf ng nh b">ldd</code>是Linux中列出二进制动态依赖关系的常用工具。在链接结束时，符号不能保持未定义状态。每个未定义的符号必须静态链接或标记为动态符号。当检测到一个符号属于一个动态链接时，动态库的名称将被列在ELF文件中，并在<code class="fe ne nf ng nh b">ldd</code>中被列为一个依赖项。这就是<strong class="lq ir">动态链接。</strong></p><p id="c0a9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这种类型对我们的情况来说是有问题的:符号解析不能撤销，覆盖函数符号是不可能的。</p><p id="3db9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">第二种类型的动态链接，<strong class="lq ir">动态加载，</strong>受约束较少，只在运行时发生。<code class="fe ne nf ng nh b">dlopen</code>和<code class="fe ne nf ng nh b">dlclose</code>是允许运行时搜索库名并从中提取符号信息的函数。</p><p id="f69c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir"> Rapicpp </strong>正在使用<strong class="lq ir">动态加载</strong>来满足我们的要求。从现在开始，这个特性将被称为“动态调试”。</p><h1 id="d286" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动态调试的实现</h1><h2 id="a81c" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">现在看着我让这个符号消失</h2><p id="5143" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记住，调用点必须保持不变。但是根据前面<strong class="lq ir">动态链接</strong>的解释，这是矛盾的:原代码是在调用函数，也就是符号。正如用<code class="fe ne nf ng nh b">ldd</code>解释的，调用函数是为了防止动态库和它们相应的符号从进程内存中被驱逐。例如，下面描述了在我们的<em class="mk"> rapidcpp_shared </em>二进制文件中使用动态库<em class="mk"> liblang1_shared.so </em>中的符号:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/f48dfd3bf373fa72b28c6d4ccf1249df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eIPF9sFmm4Dd4AqBpSIew.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">不像你不交房租，libliblang1_shared.so不会被0x0006f1ad2c5b000驱逐，即使你真的希望它被驱逐。</figcaption></figure><p id="cf89" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这种对<code class="fe ne nf ng nh b">libliblang1_shared.so</code>的依赖应该删除。这里使用了一些技巧来保持代码完整，但实际上避免了符号的显式使用。</p><p id="a58f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">编译器不能将每个函数都视为一个符号。您现在可能正在猜测我们需要使用一些预处理魔法。</p><p id="e30b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">例如，<em class="mk"> libliblang1_shared </em>有这样的函数定义:</p><pre class="kg kh ki kj gt nv nh nw nx aw ny bi"><span id="f5e9" class="ni kx iq nh b gy nz oa l ob oc">void echoHelloWorldEnglish(int x);</span></pre><p id="9e70" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">第一步是混淆符号本身。这可以通过以下方式实现:</p><pre class="kg kh ki kj gt nv nh nw nx aw ny bi"><span id="1b70" class="ni kx iq nh b gy nz oa l ob oc">using func_int_t = void (*)(int);</span><span id="28fa" class="ni kx iq nh b gy od oa l ob oc">#define echoHelloWorldEnglish(…) CALL_DEBUG_FUNC(func_int_t, echoHelloWorldEnglish, (int), __VA_ARGS__)</span></pre><p id="1f15" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">一旦符号“消失”，我们需要调用函数，而不需要编译符号。为此，我们需要将函数名映射到函数指针:</p><pre class="kg kh ki kj gt nv nh nw nx aw ny bi"><span id="c76b" class="ni kx iq nh b gy nz oa l ob oc">map&lt;string_view, void *&gt; gDynamicSymbols = {</span><span id="c0ee" class="ni kx iq nh b gy od oa l ob oc">{“echoHelloWorldEnglish(int)”, nullptr}};<br/></span><span id="352d" class="ni kx iq nh b gy od oa l ob oc">#define CALL_DEBUG_FUNC(TYPE, FUNC, PARAMS_TYPE, …) <br/>((TYPE)(gDynamicSymbols[#FUNC #PARAMS_TYPE]))(__VA_ARGS__)</span></pre><p id="809c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/fd56a8f831809688688565a9dbf7fc55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ud5GPnnFPFVT8U27LhYXHw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">拜拜库依赖</figcaption></figure><p id="191b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">该解决方案通过在停用的动态调试环境中定义CALL_DEBUG_FUNC来保持原始状态:</p><pre class="kg kh ki kj gt nv nh nw nx aw ny bi"><span id="a03c" class="ni kx iq nh b gy nz oa l ob oc">#define CALL_DEBUG_FUNC(TYPE, FUNC, PARAMS_TYPE, …) <br/>(FUNC)(__VA_ARGS__)</span></pre><p id="a0d8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">它像以前一样直接使用符号。</p><p id="a494" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了说明所描述的过程，让我们以函数“foo”为例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/691669e651775867775e39dd354e4e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mT0Xp3U_t_ov5BdyzGpbIg.jpeg"/></div></div></figure><h2 id="2ec7" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">刚刚发生了什么？！哪里消失了！？</h2><p id="961a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">该符号不再存在，已被存储在<code class="fe ne nf ng nh b">gDynamicSymbols</code>中的函数指针所取代，当程序首次执行时或在调试会话过程中，需要存储该函数指针的值。</p><p id="72e7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">首先，程序将通过打开每个动态库来设置这些动态符号。对于每个库，使用<code class="fe ne nf ng nh b">dlsym</code>查询函数符号名称。(这个机制后面会讲到)。</p><p id="d68b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在初始设置之后，当所有的依赖库和它们的符号都被加载后，程序就可以正常执行了。</p><h2 id="1cba" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">亲爱的，你不在名单上</h2><p id="0b7b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，有一个假设，即符号函数名等同于实际的函数名。但是<code class="fe ne nf ng nh b">echoHelloWorldEnglish</code>这个功能的符号名称是不同的。</p><p id="4e53" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">原因是<strong class="lq ir">名不符实。</strong></p><p id="1306" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">显示名称篡改完整范围的一个例子是<code class="fe ne nf ng nh b">std::thread::detach</code>函数。<br/>代码中使用的<strong class="lq ir">函数名</strong>为<code class="fe ne nf ng nh b">detach</code>。<br/> <code class="fe ne nf ng nh b">_ZNSt6thread6<strong class="lq ir">detach</strong>Ev@@GLIBCXX_3.4.11</code>是<strong class="lq ir">错位的名字。<br/> </strong> <code class="fe ne nf ng nh b">std::thread::<strong class="lq ir">detach</strong>()@@GLIBCXX_3.4.11</code>是<strong class="lq ir">的解缠名称</strong>。</p><p id="cb4a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当使用<code class="fe ne nf ng nh b">dlsym</code>在动态库中搜索函数指针时，符号由<strong class="lq ir">损坏的名称</strong>而不是<strong class="lq ir">函数名称</strong>查看。</p><p id="4a99" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">名称mangling 只与C++编译的代码相关。它接受任何函数的上下文和签名，并将其翻译成唯一的C符号。这需要考虑函数返回类型、参数类型和名称空间层次结构，并且允许相同的函数名在不同的签名中重用。<br/> <code class="fe ne nf ng nh b">dlsym</code>仅使用一个字符串搜索函数符号，但完全忽略所需的上下文和签名。<br/>这就是必须手动处理的原因。</p><p id="80ad" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b">echoHelloWorldEnglish</code>是一个C++函数，编译时没有任何extern“C”。如前所述，用<code class="fe ne nf ng nh b">dlsym</code>按原样搜索是徒劳的。因为这个函数的名字被改成了<code class="fe ne nf ng nh b">_Z21echoHelloWorldEnglishi</code>(在不同的编译器中可能会有所不同)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe ne nf ng nh b">echoHelloWorldEnglish? No, I am sorry you don't appear on nm.</code></figcaption></figure><p id="43eb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">一旦在<code class="fe ne nf ng nh b">dlsym</code>中搜索并找到被破坏的名称，它就被存储在<code class="fe ne nf ng nh b">gDynamicSymbols</code>中，后者将每个函数的<strong class="lq ir"> de </strong>被破坏的名称映射到它的函数名。只能通过将函数名转换为解混淆的函数名来进行调用。</p><p id="9fbb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了结束这个过程，任何时候调用一个函数，都需要将<strong class="lq ir">函数名</strong>转换成<strong class="lq ir">解混淆名</strong>。只有用它，才能调用它的函数指针。<br/>首先要初始化/重新加载函数——应该是<strong class="lq ir">损坏的名称</strong>。</p><p id="135a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">综上所述，命名混淆是造成“函数名”和“符号名”不同的原因。当不涉及名称混淆时(在C代码或指定的extern“C”修饰符中)，函数名匹配解混淆的名称(当然还有混淆的名称)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/514f78bd8195309eb7945bd86daa633c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*EW-ERd8j6OjUBxyqxNFnnA.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">存储新函数指针的流程和执行函数的流程</figcaption></figure><h2 id="8a06" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">功能覆盖？函数重载！</h2><p id="350f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有了这个简单的机制，流程现在支持运行时“函数重载”。一旦开发人员修改了函数实现，就可以在运行时将其重新加载到流程中并进行测试。</p><p id="7d69" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这个输出中，重载可以通过<em class="mk"> rapidcpp </em>来演示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7e74b3d348db6b44d948e25a3ff502db.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*fd57HArWHVxC8vqzfPlmlQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">程序的输出显示了在其宿主库被重新打开之前和之后执行函数“1”的结果。功能“1”输出从“Hello World <strong class="bd ky"> 5 </strong>变为“Hello World <strong class="bd ky"> 15 </strong>”。这是刚刚描述的机制的结果。</figcaption></figure><h2 id="6772" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">导出全局变量</h2><p id="1435" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当在静态链接中链接所有库和主模块时，全局变量被定义并链接到一个模块中。链接后，只要找到全局变量的声明，就可以在过程中的任何地方使用这些变量。</p><p id="c220" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在动态链接的情况下，不同模块唯一知道的符号是<code class="fe ne nf ng nh b">.dynsym </code> ELF部分列出的符号。在编译动态库时，在<code class="fe ne nf ng nh b">dynsym </code>中导出全局符号是微不足道的，这也需要在主模块中显式地完成。</p><p id="a7a6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">主模块可以用<code class="fe ne nf ng nh b">--export-dynamic</code>编译，或者只使用CMake将主可执行属性设置为<code class="fe ne nf ng nh b">ENABLE_EXPORTS 1</code>，以便导出全局符号。</p><h1 id="d7cd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">透明的基础设施</h1><p id="77d7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">前面的函数描述了如何在保留流程原始语义的同时进行动态调试。在下文中，构建系统和架构的角色将演示rapidcpp在任何项目中的设置和使用。</p><h2 id="8f2d" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">CMake</h2><p id="fe1f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，本文描述了如何执行函数重载，以及实现如何通过静态链接仍然支持原始部署。但是如何使用构建系统来实现这一点的知识仍然是隐藏的。</p><p id="7c73" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">CMake方法定义了两个变量，可用于编译代码以包含动态调试支持(作为激活模式或不作为激活模式)。</p><p id="c4bc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b">PROJECT_DEBUG=”SHARED” or “STATIC”</code>。</p><p id="6e53" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b">PROJECT_DEUBG_SHARED (only if PROJECT_DEBUG=”SHARED”)</code></p><p id="ffca" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">使用两个只是为了代码的可读性。使用C++17 <code class="fe ne nf ng nh b">if constexpr</code>语法，可以用<code class="fe ne nf ng nh b">strcmp</code>编译代码并对预处理程序符号执行编译时字符串比较。(可惜GCC 9.4支持，Clang 10不支持)。但是<code class="fe ne nf ng nh b">if constexpr</code>只能像<code class="fe ne nf ng nh b">if</code>语句一样使用。有时候，动态调试的代码并没有嵌套在函数中或者允许<code class="fe ne nf ng nh b">if</code>的地方。这就是用<code class="fe ne nf ng nh b">PROJECT_DEBUG_SHARED</code>的原因。</p><p id="498f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe ne nf ng nh b">PROJECT_DEBUG </code>将在每个库中使用:</p><pre class="kg kh ki kj gt nv nh nw nx aw ny bi"><span id="a17f" class="ni kx iq nh b gy nz oa l ob oc">add_library(liblang1 ${PROJECT_DEBUG} ${SOURCE_FILES})</span></pre><p id="5ba8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这将为设置生成所需的库类型。</p><p id="22ee" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，如果您的项目相对较小并且编译时间不成问题，您可以同时生成带动态调试和不带动态调试的二进制文件(在rapidcpp POC中，还创建了第三个二进制文件—根本没有rapidcpp)</p><h2 id="8569" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">仅标题</h2><p id="09c8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所描述的机制可以通过包含具有所需组件的头文件来使用。标题内容受<code class="fe ne nf ng nh b">PROJECT_DEBUG_SHARED </code>和include保护。在不使用动态调试的情况下，这种包含实际上是无操作的。</p><p id="ecdc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这种方式<em class="mk"> rapidcpp </em>从原始程序中提取了额外的开销。这里有一个很强的解耦，只是被包含的头显式地注意到。</p><p id="dde3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这种代码解耦不是一个问题，但是库管理是一个更值得考虑的问题。</p><h1 id="faa9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在C++程序中应用rapidcpp</h1><ol class=""><li id="3dfd" class="mq mr iq lq b lr ls lu lv lx ok mb ol mf om mj mv mw mx my bi translated">应支持动态调试的所有函数的列表。</li><li id="a455" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">所有库的列表和库到其函数符号的映射及其导出。</li><li id="ac6c" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">每个函数符号签名和上下文:返回类型、参数列表、嵌套命名空间，都是extern“C”。</li></ol><p id="13fc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些可以自动生成，但目前，<em class="mk"> rapidcpp </em>手动更新它们。</p><h1 id="7664" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">成本分析</h1><p id="6946" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mk"> rapidcpp </em>将相同的代码编译成三个进程:</p><ul class=""><li id="d597" class="mq mr iq lq b lr ml lu mm lx ms mb mt mf mu mj on mw mx my bi translated"><em class="mk"> rapidcpp_shared </em> —进程编译时激活了动态调试支持</li><li id="b931" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj on mw mx my bi translated"><em class="mk"> rapidcpp_static </em> —进程编译时支持动态调试，但动态调试被禁用</li><li id="5643" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj on mw mx my bi translated">rapidcpp  —流程编译和链接不支持动态调试(即原始代码)</li></ul><p id="5851" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">就时间和空间而言，很容易画出非常快的高光:</p><h2 id="5e70" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">时间复杂度</h2><p id="f446" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">很容易画一些本地测试来比较那些库上的函数调用的执行情况。</p><p id="0a3d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">对于rapidcpp_shared，似乎每个调用需要大约6000–16000纳秒(C函数调用需要的时间略少)。平均大约10微秒(10K纳秒)</p><p id="a870" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">静态调用时间在2000到13500之间，平均值很低:4K纳秒。</p><p id="b9c8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">rapidcpp显示与rapidcpp_static相同的运行时结果。</p><p id="ccc8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">调用时间的增加可以用以下装配差异来解释:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/42944f5b702c33b1ab6124a3a08fb54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWipG-w9HIWH1juoJa3AjA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">左边是rapidcpp_static，右边是rapidcpp_shared。很容易看出rapidcpp_shared调用的开销大约是基准测试的3倍。</figcaption></figure><h2 id="f3e7" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">空间复杂性</h2><p id="f356" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mk"> rapidcpp </em>，不支持动态调试，二进制大小约218K字节。<br/> <em class="mk"> rapidcpp_static </em>稍高，238K字节。<br/> <em class="mk"> rapidcpp_shared </em>变得比较大:858K字节！</p><p id="93e2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><em class="mk"> rapidcpp </em>和<em class="mk"> rapidcpp_shared </em>之间的区别由符号部分中的附加调试信息解释。运行<code class="fe ne nf ng nh b">strip</code>时，该信息被丢弃，二进制大小变得相等。</p><p id="ea64" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">共享的rapidcpp的大小是由支持动态调试所需的代码和数据段的大小增加来解释的——大约140K的额外信息。随着更多的函数/库需要动态调试支持，这个大小可能会增加。</p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><p id="36ac" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">到目前为止，我们讨论了使rapidcpp按预期工作的主要概念。</p><p id="eb3d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">至此，接下来的部分将讨论我在开发rapidcpp时经历的一些设计和想法。</p><h1 id="25df" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动态调试控制</h1><p id="1c8c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mk"> rapidcpp </em>最小POC只是一个用户通过标准输入控制的开关语句。一些命令调用实际的程序依赖函数。其他选项允许动态调试操作:关闭/打开/重新加载库。</p><p id="0699" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在实际程序中，更有可能假设“动态调试”操作将具有客户机/服务器关系，在逻辑线程上具有客户机和服务器，开发者与它们交互以调试应用程序。<em class="mk"> rapidcpp </em>没有这种支持。目前，实际的程序只是一个单线程的switch语句，其中一些操作在它们的动态依赖关系中调用函数，而另一些是“动态调试”操作。</p><h1 id="7dfe" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">热插拔功能替换</h1><p id="9393" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mk"> rapidcpp </em>不支持热插拔——如果在动态库升级期间调用函数，在函数句柄上执行的线程可能会崩溃:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/ffef15f6ae7e0f9e348a724058b92de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2kwPZIub80HzM-xU"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">不要惊慌！</figcaption></figure><p id="b4cc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><em class="mk"> rapidcpp </em>可以通过使用双缓冲技术和切换索引来解决这个问题。通过这种方式，我们可以在不中断已经执行的调用的情况下过渡到新的实现<br/>,更简单但更具侵入性的方式是使用互斥体。<br/> <em class="mk"> rapidcpp </em>都不实现(调用函数和替换其底层lib不能同时执行)。</p><p id="3943" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">替换库实现被认为是一种罕见的事件，最多每分钟发生一次。</p><p id="02a0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，两个逻辑线程的存在可能会对流程本身产生不利影响，需要根据流程架构考虑它们的相似性和执行细节。</p><p id="8d52" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">事实上，为了获得最健壮的解决方案，您需要维护一个呼叫者计数器，但这似乎有些矫枉过正。功能应该最多在几秒钟内执行，而不是无限期地拖延。库在动态调试中预计每隔几分钟就要被替换一次，对于旧函数的返回来说，时间绰绰有余。</p><h1 id="5850" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">一级/多级调试</h1><p id="9879" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">所描述的内容允许主模块很容易地在其他动态库中重新定义函数。但是它也不允许动态库被动态调试。当这些库有相互交织的依赖关系时，会有一些挑战。</p><p id="5d2a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了澄清问题，假设main依赖于lib1和lib2，但是lib1使用lib2。在这种情况下，lib2定义可以通用于main和lib1，也可以由用户单独手动定义。甚至在此之前，lib1可能根本没有动态调试功能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/40344df7685918298dc5a2f2fb4f6e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*-MLYXW5S1-paMPQffsN9_A.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一级/多级调试图解</figcaption></figure><p id="c24d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">第一个流程是通用函数表。lib1始终只调用lib2v1，因为lib出现在lib1的ldd中。对于lib1，lib2实现是固定的。</p><p id="cafc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">第二个流程描述了一个流程，其中每个库维护它们自己的动态调试机制，因此允许在更窄的范围内进行精确调试。接下来的两个字幕解释了这个流程的难点。</p><h2 id="a332" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">动态调试库</h2><p id="b709" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">动态库可以不使用动态调试头作为主模块来链接。在这种情况下，如前所述，任何对其他库的依赖都将在<code class="fe ne nf ng nh b">ldd</code>中考虑，并且在运行时替换它的实现是不可能的。</p><p id="2c0e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">动态库可以像主模块一样包含动态lib头文件，但是它应该对正在导出的函数调用执行一个<code class="fe ne nf ng nh b">#undef</code>。上面显示的方案支持函数的调用，但不支持它的声明。</p><p id="4ffc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">注意:添加<code class="fe ne nf ng nh b">#undef</code>是为了防止动态库的原始代码保持不变。</p><h2 id="3867" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">通用/分布式功能符号</h2><p id="128e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为动态调试选择的设计是中心的:在主模块中，动态调试只需要一个数据结构的副本。这种设计的败笔在于，除了加载的函数之外，动态库不能有不同的函数实现。但是，每个动态库可以使用特定的映射。在这种情况下，动态调试设计变成分布式的。来自该设计的挑战是为每个模块分派动态调试命令，并使该事务可靠。</p><p id="894c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">分布式模型甚至被测试了一段时间，但由于简单的原因而被忽略了:开发人员的认知负荷，他们的长时间动态调试会话变得难以跟踪。坦率地说，我实现的调度尝试并没有很好地工作，经过努力并在头脑中有了第一个原因后，我不得不放弃它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/6fff4db7d255ac80e54eeda5b22958a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/0*-Q3GLYxVIdl3YB6a.jpg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">无论如何，动态库间的交流从来没有困扰过我，但是我必须承认玩条件变量很有趣</figcaption></figure><h1 id="8ae5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">小问题:编译器支持</h1><p id="29aa" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="mk"> rapidcpp </em>同时支持GCC和Clang，但有细微的区别。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz oh l"/></div></figure><p id="8cf0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">常量char *上的<code class="fe ne nf ng nh b">strcmp </code>的结果在Clang 10上没有被检测到不是常量表达式，而GCC接受这一点。对于clang编译器，这里的成本是额外的。</p><p id="f60e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">不得不提的是，VSCode + CMake插件使得编译器之间的过渡过于平滑，令人难以置信。</p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><h1 id="d547" class="kw kx iq bd ky kz pa lb lc ld pb lf lg jw pc jx li jz pd ka lk kc pe kd lm ln bi translated">最后的话</h1><p id="00c4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Rapidcpp的潜力仍有待发掘。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/759245b2302405b5ec1a54afd12bbd19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qWEIGa-hP_J8bPk3"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">rapidcpp的秘密还隐藏着。约翰·诺比在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="320c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">感谢阅读这篇文章。这个兼职项目作为一个概念已经在我的脑海中存在了近几年，并且在总共两个月的时间里实现了它。我试着让你感受一下我脑海中突出的问题。你可以在这里公开分享你的想法，问任何你想问的问题。</p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><h1 id="1248" class="kw kx iq bd ky kz pa lb lc ld pb lf lg jw pc jx li jz pd ka lk kc pe kd lm ln bi translated">分级编码</h1><p id="96e4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae kv" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>。<br/>跟随:<a class="ae kv" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae kv" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae kv" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="lq ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae kv" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>