<html>
<head>
<title>Mocha .skip Doesn’t Skip Everything</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">摩卡。跳过不跳过一切</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mocha-skip-doesnt-skip-everything-251affc19239?source=collection_archive---------5-----------------------#2020-02-22">https://levelup.gitconnected.com/mocha-skip-doesnt-skip-everything-251affc19239?source=collection_archive---------5-----------------------#2020-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="012b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://gentille.us/b3601fb73472?sk=0dc73c81df810c0f181c432c9db3e085" rel="noopener ugc nofollow" target="_blank"> JavaScript和类型脚本测试</a></h2><div class=""/><div class=""><h2 id="1e40" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">你不仅需要知道<code class="fe ko kp kq kr b">.only</code>和<code class="fe ko kp kq kr b">.skip</code>修改器做什么，你还需要知道它们<strong class="ak">不</strong>做什么。</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/70d700daab7f81a4e01954ab68bd59dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-kdscAOE-qM1B1Es2b3xg.jpeg"/></div></div></figure><p id="2fcd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这个<strong class="lg ja"> <em class="ma">不是</em> </strong>是关于学习在<code class="fe ko kp kq kr b">describe</code>和<code class="fe ko kp kq kr b">it</code>关键词上使用<code class="fe ko kp kq kr b">.only</code>和<code class="fe ko kp kq kr b">.skip</code>修饰语的帖子。它<strong class="lg ja"> <em class="ma">是</em> </strong>关于获得那两个修饰语做什么，更重要的是他们不做什么的更深入的理解。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="f7a9" class="mi mj iq bd mk ml mm mn mo mp mq mr ms kf mt kg mu ki mv kj mw kl mx km my mz bi translated"><strong class="ak">惊喜</strong></h1><p id="c735" class="pw-post-body-paragraph le lf iq lg b lh na ka lj lk nb kd lm ln nc lp lq lr nd lt lu lv ne lx ly lz ij bi translated">很容易想到，如果您编写一个测试块，其中最外层的<code class="fe ko kp kq kr b">describe</code>有一个<code class="fe ko kp kq kr b">.skip</code>修饰符，如下所示:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="7e5d" class="nj mj iq kr b gy nk nl l nm nn">describe.skip (`My test context`, ()=&gt;{<br/> console.log(`Does this show up?")<br/> it (...</span></pre><p id="9bb6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您将永远看不到console.log消息。你会的。去试试吧，我等着。这在文档中有解释，但是很容易错过或者不真正理解所说的内容。这是文档中的关键句子，并加了强调。</p><blockquote class="np nq nr"><p id="297d" class="le lf ma lg b lh li ka lj lk ll kd lm ns lo lp lq nt ls lt lu nu lw lx ly lz ij bi translated"><em class="iq">注意</em>:被跳过的套件中，放置在钩子或测试之外的代码<strong class="lg ja">仍然在执行</strong>，因为mocha仍然会调用套件函数来构建可视化的套件结构。</p></blockquote><p id="e775" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这意味着，如果该日志语句在<code class="fe ko kp kq kr b">before()</code>或<code class="fe ko kp kq kr b">beforeEach()</code>甚至是<code class="fe ko kp kq kr b">it()</code>中，它就不会被执行。但是如果它在套件中，但是在这些钩子之外，它就会运行。</p><h1 id="dd6a" class="mi mj iq bd mk ml nv mn mo mp nw mr ms kf nx kg mu ki ny kj mw kl nz km my mz bi translated"><strong class="ak">为什么您应该关注</strong></h1><p id="0a28" class="pw-post-body-paragraph le lf iq lg b lh na ka lj lk nb kd lm ln nc lp lq lr nd lt lu lv ne lx ly lz ij bi translated">有时，昂贵的操作，尤其是集成或功能测试，可以在套件内部运行，但不能在钩子中运行。<a class="ae no" href="https://mochajs.org/#dynamically-generating-tests" rel="noopener ugc nofollow" target="_blank">动态生成的测试</a>可能是这类代码的主要来源。</p><p id="b57b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因此，如果您在describe上放置了一个<code class="fe ko kp kq kr b">.only</code>,并且您的测试启动和运行的时间比您想象的要长，那么您可能是测试套件中代码的受害者，而不是钩子中的代码。</p><h1 id="cc70" class="mi mj iq bd mk ml nv mn mo mp nw mr ms kf nx kg mu ki ny kj mw kl nz km my mz bi translated">你能做些什么呢</h1><p id="7c4e" class="pw-post-body-paragraph le lf iq lg b lh na ka lj lk nb kd lm ln nc lp lq lr nd lt lu lv ne lx ly lz ij bi translated">一个部分的解决方案是对你运行的测试进行选择。这里有两种方法与组织源文件和测试文件的两种方式相对应。</p><h2 id="19cc" class="nj mj iq bd mk oa ob dn mo oc od dp ms ln oe of mu lr og oh mw lv oi oj my iw bi translated">1.与源位于同一位置的测试</h2><p id="3084" class="pw-post-body-paragraph le lf iq lg b lh na ka lj lk nb kd lm ln nc lp lq lr nd lt lu lv ne lx ly lz ij bi translated">我喜欢把我的测试放在我的被测单元旁边，所以我更喜欢使用命名约定。我在最外层描述的开头添加了一个类似“单元测试:…”的字符串。允许我使用单个默认的<code class="fe ko kp kq kr b">.mocharc.js</code>配置文件，然后为每种类型的测试编写一个npm脚本。单元测试脚本如下所示:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="b335" class="nj mj iq kr b gy nk nl l nm nn">"test:unit": "mocha -g UNIT"</span></pre><h2 id="edc5" class="nj mj iq bd mk oa ob dn mo oc od dp ms ln oe of mu lr og oh mw lv oi oj my iw bi translated">2.测试和源代码在不同的文件夹中</h2><p id="7d38" class="pw-post-body-paragraph le lf iq lg b lh na ka lj lk nb kd lm ln nc lp lq lr nd lt lu lv ne lx ly lz ij bi translated">如果您喜欢将源代码从测试文件中分离出来，您可以将单元、集成和功能测试分离到它们自己的文件夹中。然后，您可以编写npm脚本，使用匹配的配置文件运行每种类型的测试，类似于:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="c777" class="nj mj iq kr b gy nk nl l nm nn">"test:unit": "mocha --config .mocharc.unit.js" </span></pre><p id="5bc7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">每个配置文件都会指定要运行的测试的文件夹。如果您的测试位于文件夹路径<code class="fe ko kp kq kr b">test/unit</code>中，并以扩展名<code class="fe ko kp kq kr b">test.tst</code>命名，配置文件将会有这样一行:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="eb1b" class="nj mj iq kr b gy nk nl l nm nn">"spec":[</span><span id="8ae3" class="nj mj iq kr b gy ok nl l nm nn">"./test/unit/*.test.ts",</span><span id="fad4" class="nj mj iq kr b gy ok nl l nm nn">]</span></pre><h1 id="be19" class="mi mj iq bd mk ml nv mn mo mp nw mr ms kf nx kg mu ki ny kj mw kl nz km my mz bi translated">摘要</h1><p id="5e69" class="pw-post-body-paragraph le lf iq lg b lh na ka lj lk nb kd lm ln nc lp lq lr nd lt lu lv ne lx ly lz ij bi translated">如果你的单元测试花费了比应该花费的时间更长的时间，那么可能是时候找出测试和挂钩之外的代码了，并且应用上面的技术来加速你的流程。</p><p id="b3d0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">还有更多<a class="ae no" href="https://gentille.us/b3601fb73472?sk=0dc73c81df810c0f181c432c9db3e085" rel="noopener ugc nofollow" target="_blank"> JavaScript/TypeScript测试</a>技巧文章。</p><p id="73f7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">平静地编码。</p></div></div>    
</body>
</html>