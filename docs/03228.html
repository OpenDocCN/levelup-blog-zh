<html>
<head>
<title>What is ‘this’ in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的‘this’是什么？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-this-in-javascript-5d9bea7f3f06?source=collection_archive---------13-----------------------#2020-04-26">https://levelup.gitconnected.com/what-is-this-in-javascript-5d9bea7f3f06?source=collection_archive---------13-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/04a4332ff6fa2ea6db6eb29f34247cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FciPu9Yi6t4lfDAM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@alexleegdp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">李东旻</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="72dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">this</code>的值是JavaScript中最令人困惑的部分之一。根据它所处的位置，它可以呈现不同的值。</p><p id="fef2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看<code class="fe le lf lg lh b">this</code>在哪里使用，它可以取什么值。</p><h1 id="b82a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">最高级的</h1><p id="d06c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们在顶层使用<code class="fe le lf lg lh b">this</code>，那么我们应该得到全局对象作为<code class="fe le lf lg lh b">this</code>的值，因为它不在任何主机对象中。</p><p id="5a47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1449" class="mt lj it lh b gy mu mv l mw mx">console.log(this)</span></pre><p id="047b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在浏览器脚本的顶层，我们应该看到记录为<code class="fe le lf lg lh b">this</code>值的<code class="fe le lf lg lh b">window</code>对象。我们可以通过以下方式验证这一点:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="509e" class="mt lj it lh b gy mu mv l mw mx">console.log(this === window)</span></pre><h1 id="bbe0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">顶级函数内部</h1><p id="77ea" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们定义一个常规函数并引用<code class="fe le lf lg lh b">this</code>，那么我们可能会得到2个不同的值，这取决于我们的脚本是否开启了严格模式。</p><p id="e6a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">this</code>如果不是在严格模式下就是<code class="fe le lf lg lh b">window</code>。然而，如果一个脚本使用严格模式，那么它将是<code class="fe le lf lg lh b">undefined</code>。</p><p id="5c67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c512" class="mt lj it lh b gy mu mv l mw mx">'use strict';</span><span id="183b" class="mt lj it lh b gy my mv l mw mx">function foo() {<br/>  console.log(this);<br/>}<br/>foo();</span></pre><p id="6d4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们看到<code class="fe le lf lg lh b">this</code>就是<code class="fe le lf lg lh b">undefined</code>。</p><p id="4c94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9b20" class="mt lj it lh b gy mu mv l mw mx">function foo() {<br/>  console.log(this);<br/>}<br/>foo();</span></pre><p id="8940" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们从<code class="fe le lf lg lh b">console.log</code>看到<code class="fe le lf lg lh b">this</code>的值是<code class="fe le lf lg lh b">window</code>。</p><h1 id="0f36" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内部对象</h1><p id="f0e7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在一个对象内部，<code class="fe le lf lg lh b">this</code>当它在一个对象的常规方法内部时，应该接受宿主对象的值。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4c13" class="mt lj it lh b gy mu mv l mw mx">function fullName() {<br/>  return `${this.firstName} ${this.lastName}`;<br/>}</span><span id="5a36" class="mt lj it lh b gy my mv l mw mx">const jane = {<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  fullName<br/>};<br/>const alex = {<br/>  firstName: 'Alex',<br/>  lastName: 'Smith',<br/>  fullName<br/>};</span><span id="42f6" class="mt lj it lh b gy my mv l mw mx">console.log(jane.fullName());<br/>console.log(alex.fullName());</span></pre><p id="b672" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个名为<code class="fe le lf lg lh b">fullName</code>的常规函数，它引用<code class="fe le lf lg lh b">this.firstName</code>和<code class="fe le lf lg lh b">this.lastName</code>返回它的组合。</p><p id="7142" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们定义<code class="fe le lf lg lh b">jane</code>和<code class="fe le lf lg lh b">alex</code>对象，并将<code class="fe le lf lg lh b">fullName</code>函数放入其中，并像上面那样调用它们，我们将得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="72b4" class="mt lj it lh b gy mu mv l mw mx">Jane Smith</span></pre><p id="1719" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从第<code class="fe le lf lg lh b">console.log</code>和:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1d5e" class="mt lj it lh b gy mu mv l mw mx">Alex Smith</span></pre><p id="7b81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从第二个<code class="fe le lf lg lh b">console.log</code>开始。</p><p id="27b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为如果<code class="fe le lf lg lh b">this</code>位于宿主对象的方法的顶层，它就会接受宿主对象的值。</p><h1 id="64f0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内部构造函数</h1><p id="f0dd" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，构造函数是使用<code class="fe le lf lg lh b">new</code>操作符创建新实例来改变<code class="fe le lf lg lh b">this</code>属性的函数。</p><p id="6d07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们在没有严格模式的情况下运行以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a1eb" class="mt lj it lh b gy mu mv l mw mx">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="5f07" class="mt lj it lh b gy my mv l mw mx">Person('Joe', 'Smith');<br/>const {<br/>  firstName,<br/>  lastName<br/>} = window;<br/>console.log(firstName, lastName);</span></pre><p id="9e3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会看到<code class="fe le lf lg lh b">Joe Smith</code>从<code class="fe le lf lg lh b">console.log</code>登录，因为<code class="fe le lf lg lh b">this</code>是<code class="fe le lf lg lh b">window</code>如果我们的脚本不使用严格模式并且在顶层。</p><p id="767d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<code class="fe le lf lg lh b">this</code>是<code class="fe le lf lg lh b">window</code>，所以添加<code class="fe le lf lg lh b">firstName</code>和<code class="fe le lf lg lh b">lastName</code>作为<code class="fe le lf lg lh b">window</code>的属性。</p><p id="1795" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们需要严格模式的一个原因。我们不想通过给<code class="fe le lf lg lh b">window</code>附加属性而意外附加新的全局变量。</p><p id="1ffc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们以严格模式运行上面的代码，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5779" class="mt lj it lh b gy mu mv l mw mx">'use strict';<br/>function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="5fcd" class="mt lj it lh b gy my mv l mw mx">Person('Joe', 'Smith');<br/>const {<br/>  firstName,<br/>  lastName<br/>} = window;<br/>console.log(firstName, lastName);</span></pre><p id="cbfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会得到一个错误，说“无法设置未定义的属性‘first name ’”,因为在严格模式下<code class="fe le lf lg lh b">this</code>会是<code class="fe le lf lg lh b">undefined</code>。</p><p id="7117" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该做的是使用<code class="fe le lf lg lh b">new</code>操作符来调用构造函数。例如，我们应该创建一个新的<code class="fe le lf lg lh b">Person</code>实例，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9967" class="mt lj it lh b gy mu mv l mw mx">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="9387" class="mt lj it lh b gy my mv l mw mx">const person = new Person('Joe', 'Smith');</span></pre><p id="15af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6c80" class="mt lj it lh b gy mu mv l mw mx">{<br/>  "firstName": "Joe",<br/>  "lastName": "Smith"<br/>}</span></pre><p id="e22d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为<code class="fe le lf lg lh b">person</code>的值。</p><p id="6581" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们用<code class="fe le lf lg lh b">new</code>操作符调用构造函数，那么<code class="fe le lf lg lh b">this</code>引用构造函数的当前实例。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/90823f8169cc6e5d8bb2b14a21c4d3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sa60nbtYBo5LrpUI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@srz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> sydney Rae </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="9c8e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">课堂内部</h1><p id="af4b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">由于JavaScript类只是构造函数的语法糖，我们上面看到的构造函数都适用于类。</p><p id="9c68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，下面的示例将得到与上一个示例相同的结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4c04" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>}</span><span id="b2bf" class="mt lj it lh b gy my mv l mw mx">const person = new Person('Joe', 'Smith');</span></pre><p id="8207" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">person</code>应该是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3d11" class="mt lj it lh b gy mu mv l mw mx">{<br/>  "firstName": "Joe",<br/>  "lastName": "Smith"<br/>}</span></pre><p id="4eca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">constructor</code>的参数与构造函数中的参数相同。</p><p id="8b9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果我们试图在没有<code class="fe le lf lg lh b">new</code>操作符的情况下调用<code class="fe le lf lg lh b">Person</code>类，我们将会得到一个错误。</p><p id="cf28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是使用类而不是构造函数的一个很好的特性。</p><h1 id="8a86" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">内部箭头功能</h1><p id="7ceb" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">箭头函数没有绑定到<code class="fe le lf lg lh b">this</code>，所以上面的结果对箭头函数来说是不一样的</p><p id="9ef1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，无论是否启用严格模式，顶级箭头函数都将<code class="fe le lf lg lh b">window</code>作为<code class="fe le lf lg lh b">this</code>的值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="abd9" class="mt lj it lh b gy mu mv l mw mx">const foo = () =&gt; {<br/>  console.log(this);<br/>}<br/>foo();</span></pre><p id="78fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的例子，将为我们获取每个<code class="fe le lf lg lh b">console.log</code>的<code class="fe le lf lg lh b">undefined undefined</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="05f1" class="mt lj it lh b gy mu mv l mw mx">const fullName = () =&gt; {<br/>  return `${this.firstName} ${this.lastName}`;<br/>}</span><span id="f923" class="mt lj it lh b gy my mv l mw mx">const jane = {<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  fullName<br/>};<br/>const alex = {<br/>  firstName: 'Alex',<br/>  lastName: 'Smith',<br/>  fullName<br/>};<br/>console.log(jane.fullName());<br/>console.log(alex.fullName());</span></pre><p id="8199" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，箭头函数不会设置<code class="fe le lf lg lh b">this.firstName</code>和<code class="fe le lf lg lh b">this.lastName</code>的值。<code class="fe le lf lg lh b">this</code>正如我们所见只是<code class="fe le lf lg lh b">window</code>而不是宿主对象，所以两者都是<code class="fe le lf lg lh b">undefined</code>。</p><h1 id="96fb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="2642" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">this</code>如果在用传统函数定义的方法中，则接受主机类或主机对象的值。箭头函数没有绑定到<code class="fe le lf lg lh b">this</code>，所以我们不能像传统函数那样引用它。</p><p id="cf8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很容易像普通函数一样意外调用构造函数。如果这样做了，而我们没有使用严格模式，那么我们会意外地给<code class="fe le lf lg lh b">window</code>添加新的属性。因此，使用类更好，因为没有<code class="fe le lf lg lh b">new</code>我们不能调用类。构造函数和类是等价的。</p></div></div>    
</body>
</html>