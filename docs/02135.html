<html>
<head>
<title>Asynchronous Javascript Part 2: The Event Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步Javascript第2部分:事件循环</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-javascript-part-2-26ac20fc5ad7?source=collection_archive---------14-----------------------#2020-02-20">https://levelup.gitconnected.com/asynchronous-javascript-part-2-26ac20fc5ad7?source=collection_archive---------14-----------------------#2020-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5e85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是关于异步Javascript的四篇系列文章的第2部分。可以在这里查看 <a class="ae km" href="https://medium.com/@kabir4691/asynchronous-javascript-part-1-b87f263a353a" rel="noopener"> <em class="kl">第一部</em> </a> <em class="kl">。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="e522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在上一篇文章中看到的，Javascript总是跳转到调用堆栈顶部的函数执行。当一个新的函数被添加/移除到堆栈中时，Javascript如何得到通知？它如何知道何时暂停当前函数的执行，并跳转到新函数的执行？所有这一切都是可能的，因为Javascript的一个组件叫做<strong class="jp ir">事件循环</strong>。</p><h1 id="3616" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">事件循环</h1><p id="66e5" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">事件循环是Javascript最重要的组件之一，我们需要了解它才能完全理解执行流程。顾名思义，它是一个反复运行的循环，检查调用堆栈中是否至少有一个函数，如果有，就将程序执行跳转到调用堆栈顶部的函数。</p><p id="791f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过一个例子来更好地理解事件循环</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="3ff5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出:</p><pre class="ko kp kq kr gt me mf mg mh aw mi bi"><span id="e494" class="mj la iq mf b gy mk ml l mm mn">4<br/>3<br/>1<br/>5<br/>2</span></pre><p id="3a4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对执行的顺序感到困惑，请继续阅读。正如您所看到的，我们有三个函数声明以及一些语句和函数调用。让我们一行一行地执行程序。在程序开始时，Javascript的事件循环被创建并启动。事件循环首先检查调用堆栈中是否有任何函数。我们的调用堆栈目前如下所示:</p><pre class="ko kp kq kr gt me mf mg mh aw mi bi"><span id="0166" class="mj la iq mf b gy mk ml l mm mn">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|             |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="8cac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于调用栈是空的，程序继续执行到第1行，这里定义了函数<em class="kl"> sayOne </em>。由于这只是一个定义，程序只是将函数的代码保存在一个名为<em class="kl"> sayOne </em>的变量中，然后继续运行。此时，事件循环再次检查调用堆栈中是否有函数。因为调用栈仍然是空的，所以程序移动到下一行，即6。这里，重复相同的操作步骤，保存<em class="kl"> sayTwo </em>的函数定义，然后事件循环再次检查调用堆栈。然后程序移动到第10行，对功能<em class="kl"> sayThree </em>重复相同的步骤。</p><p id="3956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后程序运行到第14行，第一次遇到一条语句。请记住，在这个阶段，调用堆栈仍然是空的。在执行console.log语句将“4”打印到控制台之前，事件循环检查调用堆栈是否为空。既然是这样，程序就继续执行，并将4打印到控制台上。然后程序移动到第15行，在那里它看到<em class="kl"> sayOne </em>函数已经被调用。因此，它立即将这个函数添加到调用堆栈中，现在看起来像这样。</p><pre class="ko kp kq kr gt me mf mg mh aw mi bi"><span id="4fa8" class="mj la iq mf b gy mk ml l mm mn">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|  sayOne()   |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="f2e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在转到第16行之前，再次触发事件循环来检查调用堆栈是否非空。由于调用堆栈现在不为空，程序于是决定执行调用堆栈顶部的函数，即<em class="kl"> sayOne </em>。当运行<em class="kl"> sayOne </em>的代码时，在第2行，我们看到<em class="kl"> sayThree </em>函数被调用，因此它被添加到调用堆栈中。</p><pre class="ko kp kq kr gt me mf mg mh aw mi bi"><span id="a031" class="mj la iq mf b gy mk ml l mm mn">|             |<br/>|             |<br/>|             |<br/>|  sayThree() |<br/>|  sayOne()   |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="bc10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在移动到<em class="kl"> sayOne </em>函数中的第3行之前，事件循环被再次触发，以检查堆栈是否非空。当它发现它是，它在这个时候做两个动作。它首先检索堆栈顶部的函数，然后检查当前运行的函数是否与它相同。如果相同，则继续执行当前函数。如果它们不相同(在我们的例子中，它们不相同)，那么程序暂停当前函数的执行，并跳转到最顶层函数的执行(在这个例子中是<em class="kl"> sayThree </em>)。因此，在第11行，在执行console.log语句之前，事件循环再次检查非空堆栈，检索最顶层的函数，发现它与当前运行的函数相同，因此继续执行它的代码。调用第11行(这导致console.log语句在控制台上输出“3”。因为我们已经到达了函数<em class="kl"> sayThree </em>的末尾，所以它现在被从调用堆栈中移除。</p><pre class="ko kp kq kr gt me mf mg mh aw mi bi"><span id="5e66" class="mj la iq mf b gy mk ml l mm mn">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|  sayOne()   |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="6599" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">程序的执行现在返回到前一个函数，即<em class="kl"> sayOne </em>函数。在这一点上，我们应该注意到这个函数的执行是从我们离开的地方恢复的，就在第3行之前。事件循环再次被触发，并发现堆栈非空。它发现堆栈中最顶层的函数与当前运行的函数<em class="kl"> sayOne </em>相同，因此继续运行。调用第3行，将“1”打印到控制台上。我们已经到达函数<em class="kl"> sayOne </em>的末尾，它会立即从调用堆栈中移除。</p><pre class="ko kp kq kr gt me mf mg mh aw mi bi"><span id="9c7c" class="mj la iq mf b gy mk ml l mm mn">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|             |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="1055" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后程序执行返回到它离开前一个函数的地方(在这种情况下是全局上下文)。所以，程序现在返回到第16行之前。现在事件循环再次被触发，它发现调用堆栈是空的。因此，它继续执行第16行，将“5”打印到控制台上。</p><p id="9e9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">程序的其余部分像我们到目前为止讨论的那样进行。在第17行，<em class="kl"> sayTwo </em>函数被添加到调用堆栈中。</p><pre class="ko kp kq kr gt me mf mg mh aw mi bi"><span id="fab0" class="mj la iq mf b gy mk ml l mm mn">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|  sayTwo()   |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="d404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件循环检查调用堆栈并运行sayTwo函数。这会将“2”打印到控制台上。然后从调用堆栈中移除sayTwo 函数。</p><pre class="ko kp kq kr gt me mf mg mh aw mi bi"><span id="6fc6" class="mj la iq mf b gy mk ml l mm mn">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|             |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="57f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件循环再次被触发，当它看到堆栈为空时，它会检查当前函数中是否还有要运行的代码。因为没有，程序最终终止。</p><p id="fb19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，本系列中，我们只讨论了Javascript中同步代码的执行。Javascript为我们提供了异步函数，比如<code class="fe mo mp mq mf b">setTimeout</code>函数，用来延迟一段代码的执行。我们将在本系列的第3部分中看到它是如何融入执行流程的。</p></div></div>    
</body>
</html>