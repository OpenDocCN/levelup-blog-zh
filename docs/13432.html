<html>
<head>
<title>Nasty Things a Class Constructor Can Tell You about Code Design in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中，类构造函数会告诉你一些关于代码设计的令人讨厌的事情</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nasty-things-a-class-constructor-can-tell-you-about-code-design-in-c-87e8f76d9013?source=collection_archive---------1-----------------------#2022-09-04">https://levelup.gitconnected.com/nasty-things-a-class-constructor-can-tell-you-about-code-design-in-c-87e8f76d9013?source=collection_archive---------1-----------------------#2022-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道如何快速发现代码库中的设计味道。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dfdc940f84e3ba057410fc9e17049796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4C0xL5TPSei2K3hm"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nateggrant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内特·格兰特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b3be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在具有许多实现的特性和业务规则的复杂代码库中，也有精确的位置可以帮助您快速识别设计问题。一个这样的地方是构造函数，或者更确切地说是它的依赖项，对它的分析可以引导您创建技术债单来重新设计或重构您的应用程序的部分。</p><p id="c887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于代码设计，构造函数依赖分析至少能告诉你以下4点:</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5d5a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你遗漏了一些抽象概念</h1><p id="a586" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对构造函数依赖关系的分析可以帮助识别设计中的<em class="mz">缺失抽象</em>问题。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="fa83" class="nf md it nb b be ng nh l ni nj">public class EmailService<br/>{<br/>    private IPriceCalculator _priceCalculator;<br/>    private IDiscountCalculator _discountCalculator;<br/>    <br/>    public EmailService(<br/>         IPriceCalculator priceCalculator,<br/>         IDiscountCalculator discountCalculator)<br/>    {<br/>        _priceCalculator = priceCalculator;<br/>        _discountCalculator = discountCalculator;<br/>    }<br/>    <br/>    public void Send()<br/>    {<br/>        double price = _priceCalculator.Calculate();<br/>        double finalPrice = _discountCalculator.Apply(price);<br/>        <br/>        SendEmail($"You should pay {finalPrice}$");<br/>    }<br/>}</span></pre><p id="1982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在通过电子邮件发送给用户之前，<code class="fe nk nl nm nb b">EmailService</code>类注入几个依赖项来计算价格。</p><p id="fb49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的主要问题是，价格是通过按要求的顺序调用几个方法来获得最终值的。如果其他应用程序服务也需要计算相同的最终价格，以便在数据库中存储一个值或生成一个PDF报告，该怎么办？他们还必须注入<code class="fe nk nl nm nb b">IPriceCalculator</code>和<code class="fe nk nl nm nb b">IDiscountCalculator</code>依赖项。</p><p id="b361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这是一个问题？</p><ul class=""><li id="1632" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">每个需要计算最终价格的应用程序服务都需要复制并粘贴第16行和第17行。如果计算最终价格的逻辑改变了呢？开发人员将不得不在几个地方改变逻辑。</li><li id="313b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">当不同的服务以自己的方式实现相同的逻辑时，在最终价格的计算中出现错误和不一致的风险很高。</li></ul><p id="21aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的产生是因为缺乏抽象性。在上面的例子中，代码缺少像<code class="fe nk nl nm nb b">IFinalPriceCalculator</code>这样的抽象，它必须处理<code class="fe nk nl nm nb b">IDiscountCalculator</code>和<code class="fe nk nl nm nb b">IPriceCalculator</code>的依赖关系。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="cb2f" class="nf md it nb b be ng nh l ni nj">public class FinalPriceCalculator<br/>{<br/>    private IPriceCalculator _priceCalculator;<br/>    private IDiscountCalculator _discountCalculator;<br/>    <br/>    public FinalPriceCalculator(<br/>         IPriceCalculator priceCalculator,<br/>         IDiscountCalculator discountCalculator)<br/>    {<br/>        _priceCalculator = priceCalculator;<br/>        _discountCalculator = discountCalculator;<br/>    }<br/>    <br/>    public decimal GetFinalPrice()<br/>    {<br/>        double price = _priceCalculator.Calculate();<br/>        double finalPrice = _discountCalculator.Apply(price);<br/>        return finalPrice;<br/>    }<br/>}</span></pre><p id="10f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个应用服务现在只需要注入<code class="fe nk nl nm nb b">IFinalPriceCalculator</code>服务，并通过调用单个<code class="fe nk nl nm nb b">GetFinalPrice</code>方法简单地获得最终价格。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ab80" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你违反了单一责任原则</h1><p id="2c78" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">分析构造函数的依赖列表可以帮助您发现对单一责任原则(SRP)的违反。</p><p id="c592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个类有大量(10，20，…)依赖项的情况下，SRP违规是立即可见的。许多依赖关系通常意味着一个类只做许多事情。按照单一责任原则，将如此大的班级分成更小的单一目的班级是一种选择。</p><p id="6961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在依赖关系的数量很少的情况下，SRP的违反乍看起来可能并不明显。但是对依赖性的性质进行稍微更详细的分析可以帮助识别SRP的违反。让我们看一个例子:</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="c686" class="nf md it nb b be ng nh l ni nj">public class TaxCalculator<br/>{<br/>    private IPdfGenerator _pdfGenerator;<br/><br/>    public TaxCalculator(IPdfGenerator pdfGenerator)<br/>    {<br/>        _pdfGenerator = pdfGenerator;<br/>    }<br/><br/>    public void CalculateAndSave()<br/>    {<br/>        double tax = CalculatedTax();<br/>        _pdfGenerator.Save(tax);<br/>    }<br/>}</span></pre><p id="fb85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，<code class="fe nk nl nm nb b">TaxCalculator</code>类负责计算一些税收，它只有一个依赖项<code class="fe nk nl nm nb b">IPdfGenerator</code>。它说除了计算税收，<code class="fe nk nl nm nb b">TaxCalculator</code>类还知道生成PDF文件的逻辑。即使<code class="fe nk nl nm nb b">TaxCalculator</code>类本身没有实现PDF生成逻辑，SRP仍然被违反。</p><p id="8f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">混合使用<code class="fe nk nl nm nb b">TaxCalculator</code>和<code class="fe nk nl nm nb b">IPdfGeneratory</code>会使在完全不需要PDF生成逻辑的不同场景/功能/环境中重用税务计算逻辑变得非常困难。因此，对于任何复杂的应用程序来说，将<code class="fe nk nl nm nb b">IPdfGenerator</code>依赖从<code class="fe nk nl nm nb b">TaxCalculator</code>转移到另一个抽象层次是必要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="01b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">你有隐含的依赖</h1><p id="9c7f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在类构造函数中声明的依赖被称为<em class="mz">显式依赖</em>。他们有优势:</p><ul class=""><li id="d9b3" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">如果不提供构造函数所需的所有依赖项，并且拥有一个部分初始化的对象，就不可能实例化一个类。</li><li id="d9c8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">从维护的角度来看，显式依赖很方便:开发人员可以简单地查看类的构造函数，以了解正在使用哪些依赖。</li><li id="f249" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">显式依赖关系(当它们是具有虚方法的接口或类时)可以很容易地被模仿用于单元测试目的。</li></ul><blockquote class="ob oc od"><p id="d690" class="kz la mz lb b lc ld ju le lf lg jx lh oe lj lk ll of ln lo lp og lr ls lt lu im bi translated">当一个构造函数很少或者没有依赖项时，这可能意味着该类使用隐式依赖项。</p></blockquote><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="fd10" class="nf md it nb b be ng nh l ni nj">public class OrderService<br/>{<br/>    private IOrderRepository _orderRepository;<br/><br/>    public OrderService(IOrderRepository orderRepository)//Explicit dependency<br/>        _orderRepository = orderRepository;<br/>    }<br/><br/>    public void SaveOrder(Order order)<br/>    {<br/>        var validator = new OrderValidator(); //Implicit dependency<br/>        ...<br/>    }<br/>}</span></pre><p id="913d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与显式依赖不同，隐式依赖通常用于类中的任何地方，任何代码行。</p><p id="5394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">隐式依赖通常是对静态方法或非静态类的调用，它们是用<code class="fe nk nl nm nb b">new</code>关键字创建的。在这两种情况下，它在类之间创建了一个紧密的耦合，使得代码重用、维护和单元测试更加困难，或者在没有重构的情况下是不可能的。</p><p id="84f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果在您的类中发现了隐式依赖，请考虑将它们重构为显式依赖。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d71" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">您可以使用其他依赖注入技术</h1><p id="79f3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">构造函数注入并不是将依赖项注入到类中的唯一技术。</p><p id="1521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖项也可以通过类的属性或方法注入。</p><pre class="kj kk kl km gt na nb nc bn nd ne bi"><span id="f524" class="nf md it nb b be ng nh l ni nj">public class OrderService<br/>{<br/>    //property<br/>    public IEmailService EmailService { get; set; }<br/><br/>    //constructor    <br/>    public OrderService() <br/>    {<br/>    }<br/><br/>    //method<br/>    public void GenerateOrder(PdfGenerator pdfGenerator)<br/>    {<br/>        ...<br/>    }<br/>}<br/><br/>//---<br/>var orderService = new OrderService();<br/>orderService.EmailService = new EmailService(); //property injection<br/>orderService.GenerateOrder(new PdfGenerator()); //method injection</span></pre><p id="1b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性或方法注入模式实际上是我们前面讨论过的隐式依赖。因此，它们应该只在真正必要的时候使用，例如，在类<code class="fe nk nl nm nb b">OrderService</code>被实例化时依赖项不存在的情况下。</p><p id="282e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不必要地使用属性或方法注入，忽略构造函数依赖技术会导致不必要的设计复杂性。因此，尽可能考虑使用构造函数注入技术。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e05c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6fc9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">定期查看各种类构造函数的依赖项列表可以帮助您发现与可接受的代码设计的偏差。您可以在调查一些错误、实现特性或审查代码时快速完成这项工作。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="dc2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="oh oi gp gr oj ok"><a href="https://betterprogramming.pub/5-ways-to-implement-factory-design-pattern-in-c-382c0992a3ff" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">在C#中实现工厂设计模式的5种方法</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">静态、异步、参数化、内部和抽象工厂</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">better编程. pub</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><p id="e7e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉订阅我的<a class="ae ky" href="https://t.me/sd_daily" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">软件开发日报</strong> </a>电报频道，从我这里获取实用的编程技巧，供您日常工作使用。</p><p id="48ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有，考虑成为<a class="ae ky" href="https://esashamathews.medium.com/membership" rel="noopener">中员</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e12f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分级编码</h1><p id="edd2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="a16e" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="d3de" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">📰查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="8dfb" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="7f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>