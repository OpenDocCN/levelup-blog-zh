# 按位编程技巧

> 原文：<https://levelup.gitconnected.com/hacks-on-bitwise-programming-bc8100545c8e>

## 思维程序员

## JavaScript 中的事实和技巧

![](img/0567a470f2c7f645d1c9027a550327b1.png)

谢尔盖·佐尔金在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

在编程中，我们可以有效地使用位。首先，让我们看看每个位操作的定义，然后转移到解决问题的不同技术上。基本上，每种语言都支持六种操作符来进行位操作:`&` (AND)、`|` (OR)、`^` (XOR)、`<<`(左移)、`>>`(右移)和`~`(补码)。

# 按位编程的事实

## 按位 AND

按位 AND 测试两个二进制数，并在两个数都为 1 的位置返回位值 1，在两个数都不为 1 的位置返回位值 0。

```
// a = 10 (in binary)
var a = 2// b = 11 (in binary)
var b = 3// a & b = 10 & 11 = 10 (in binary) = 2 (in decimal)
a & b
<< **2**
```

## 按位或

按位 OR 测试两个二进制数，并返回位值为 1 的位置，其中一位或两位都为 1，只有当两位都为 0 时，结果才为 0。

```
// a | b = 10 | 11 = 11 (in binary) = 3(in decimal)
a | b
<< **3**
```

## 按位异或

按位异或测试两个二进制数，并为两位不同的位置返回位值 1；如果它们相同，则结果为 0。

```
// a ^ b = 10 ^ 11 = 01 (in binay) = 1 (in decimal)
a ^ b
<< **1**
```

## 按位左移

按位左移将数字中的所有位向左移动，并用 0(左移)或 1(无符号左移)填充空出的位位置。

```
// c = 0101 (in binary)
var c = 5// bitwise left shift: c << 1 = 1010 (in binary) = 10 (in decimal)
c << 1
<< **1**
```

## 按位右移

按位右移将数字中的所有位向右移动。

```
// c >> 1 = 010 (in binary) = 2 (in decimal)
c >> 1
<< **2**
```

## 逐位补码

按位补码反转单个二进制数中的位。

```
// ~c -> 1010 (in binary) -> 10 (in decimal), 2’s compliment of 10 will be -6.
~c
<< **-6**
```

# 按位编程技巧

## 检查数字是否是 2 的幂

给定一个数`n`，要检查这个数是否为`2^n`形式，我们可以用表达式:`if(n & n — 1 == 0)`。

```
// n = 10000
var n = 16 // 2⁴// n — 1 = 15 (in decimal) = 01111
// n & (n — 1) = 10000 & 01111 = 0
n & (n — 1)
<< **0**
```

## 将数字乘以 2 的幂

对于一个给定的数`n`，用`2^k`乘以这个数我们可以用表达式:`n ≪ k` *。*

```
var n = 16// 16*(2^1) = 32
n << 1
<< **32**
```

## 将数除以 2 的幂

对于一个给定的数`n`，用`2^k`除这个数，我们可以用表达式:`n ≫ k`。

```
var n = 16// 16/(2²) = 4
n >> 2
<< **4**
```

## 执行无除法平均

有没有一种稍微有点无聊的算法可以用更快的东西来代替`mid = (low + high) / 2`(用于二分搜索法和归并排序)？

我们可以用`mid = (low + high) >> 1`。

## 寻找给定数字的模

对于一个给定的数字`n`，要找到`%8`我们可以使用表达式:`n & 0x7`。类似地，要找到`%32`，使用表达式:`n & 0x1F`。

```
var n = 20// 20%8 = 4
n & 0x7
<< **4**
```

同样，我们可以找到任何数字的模值。

## 检查第 K 位是否置位

我们假设给定的数字是`n`。然后，为了检查`K-th`位，我们可以使用表达式:`n & (1 ≪ K 1)`。如果表达式为真，那么我们可以说`K-th` 位被设置(这意味着设置为 1)。

```
// n = 01001011 (in binary)
var n = 75
var k = 4// 1 << k — 1 = 00001000 (in binary)
// n & (1 << k — 1) = 01001011 & 00001000 = 00001000 = 8 (in decimal)n & (1 << k — 1)
<< **8**
```

## 设置第 K 位

对于给定的数字`n`，要设置`K-th`位，我们可以使用表达式:`n | 1 ≪ (K — 1)`。假设我们需要设置 n 的第 3 位。

```
// n = 01001011 (in binary)
var n = 75
var k = 3// 1 << k — 1 = 00000100 (in binary)
// n | (1 << k — 1) = 01001011 | 00000100 = 01001111 (in binary) = 79 (in decimal)
n | (1 << k — 1)
<< **79**
```

## 清除第 K 位

要清除给定数字`n`的`K-th`位，我们可以使用表达式:`n & ~(1 ≪ K — 1)`。

```
// n = 01001011 (in binary)
var n = 75
var k = 3// 1 << k — 1 = 00000100 (in binary)
// n & (1 << k — 1) = 01001011 & 00000100 = 0 (in binary) = 0 (in decimal)
n & (1 << k — 1)
<< **0**
```

## 切换数字的第 k 位

对于给定的数字`n`，如果`k-th`位为`0`，则将其切换到`1`，如果为`1`，则将其切换到`0`。我们可以用这样的表达:`n ^(1 ≪ k –1)`。

```
// n = 01001011 (in binary) -> toggle(n, k) = 01001111
var n = 75
var k = 3// 1 << k — 1 = 00000100 (in binary)
// n ^ (1 << k — 1) = 01001011 ^ 00000100 = 01001111 (in binary) = 79 (in decimal)
n ^ (1 << k — 1)
<< **79**
```

## 切换最右边的一位

对于给定的数字`n`，为了切换最右边的一位，我们可以使用表达式:`n & n — 1`。

```
// n = 01001011 (in binary)
var n = 75// n — 1 = 74 = 01001010
// n & n — 1 = 01001011 & 01001010 = 01001010 = 74
n & n — 1
<< **74**
```

感谢阅读😘，再见👋，别忘了👏最多 50 次并跟随！