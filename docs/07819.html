<html>
<head>
<title>A Cure for Primitive Obsession</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">治愈原始痴迷的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-cure-for-primitive-obsession-8661c6b7ee51?source=collection_archive---------2-----------------------#2021-03-13">https://levelup.gitconnected.com/a-cure-for-primitive-obsession-8661c6b7ee51?source=collection_archive---------2-----------------------#2021-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a178434d35cf144f116b80e7e0928940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47qAUCsjit9Vcfwq-4GBaA.jpeg"/></div></div></figure><h1 id="8528" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是原始执念？</h1><p id="a231" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先，原语是大多数语言中可用的基本数据类型。这些数据类型包括字符串、数字(int、floats)和布尔值。</p><p id="ce91" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">原始痴迷是一种代码味道，其中原始数据类型被过度使用来表示您的数据模型。原语的问题在于它们非常通用。例如，一个字符串可以代表一个名字、一个地址，甚至一个ID。为什么这是一个问题？</p><ul class=""><li id="48ae" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">它们不能包含任何特定于模型的逻辑或行为，这意味着任何逻辑都必须存储在包含类中。这意味着你最终会得到包含许多不相关逻辑的类，这违反了单一责任原则。</li><li id="933d" class="lz ma iq ky b kz mj ld mk lh ml ll mm lp mn lt me mf mg mh bi translated">它们失去了类型安全。字符串就是字符串。编译器不知道你传递给它的是一个代表名字还是地址的字符串。这意味着很容易意外地将一个值赋给错误的字段，代码将运行和编译良好，并且您可能直到数据完全混乱时才注意到。</li></ul><h1 id="b521" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">治愈原始执念</h1><p id="c70d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面是一个患有原始强迫症的人的例子:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c319" class="mx jz iq mt b gy my mz l na nb">public class Person<br/>{<br/>    public Person(string id, string firstName, string lastName, string address, string postcode, string city, string country)<br/>    {<br/>        // initialisation logic<br/>    }</span><span id="e493" class="mx jz iq mt b gy nc mz l na nb">    public string Id { get; set; }</span><span id="18e3" class="mx jz iq mt b gy nc mz l na nb">    public string FirstName { get; set; }<br/>    public string LastName { get; set; }</span><span id="a98d" class="mx jz iq mt b gy nc mz l na nb">    public string Address { get; set; }<br/>    public string PostCode { get; set; }<br/>    public string City { get; set; }<br/>    public string Country { get; set; }</span><span id="202c" class="mx jz iq mt b gy nc mz l na nb">    public void ChangeAddress(string address, string postcode, string city, string country)<br/>    {<br/>        // change address logic<br/>    }<br/>}</span></pre><p id="e6db" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里出了什么问题？我们有一个完全由字符串属性组成的类。构造函数由一长串字符串参数组成——我可以保证，在某个时候，错误的值将被赋给错误的参数槽！我们也有一个方法来改变地址，但实际上这个逻辑不应该是Person类的责任。最后，ID也是一个字符串，所以可能会意外地用作其他类型的ID。</p><p id="a184" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">那么我们能做什么呢？</p><p id="0b73" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们首先要看的是，有没有什么属性可以归为一类？一个很好的测试是询问，这些属性中的哪些可能会一起更新？在我们的例子中，很明显，地址、邮政编码、城市和国家字段应该分组(如果你搬家，很可能所有或大部分这些属性将一起更新)。让我们将这些属性重构到它们自己的类中。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="be52" class="mx jz iq mt b gy my mz l na nb">public class Address<br/>{<br/>    public Address(string address, string postCode, string city, string country)<br/>    {<br/>        // initialisation logic<br/>    }</span><span id="af26" class="mx jz iq mt b gy nc mz l na nb">    public string Address { get; set; }<br/>    public string PostCode { get; set; }<br/>    public string City { get; set; }<br/>    public string Country { get; set; }<br/>}</span><span id="c0ad" class="mx jz iq mt b gy nc mz l na nb">public class Person<br/>{<br/>    public Person(string id, string firstName, string lastName, Address address)<br/>    {<br/>        // initialisation logic<br/>    }</span><span id="4f7b" class="mx jz iq mt b gy nc mz l na nb">    public string Id { get; set; }</span><span id="fcef" class="mx jz iq mt b gy nc mz l na nb">    public string FirstName { get; set; }<br/>    public string LastName { get; set; }</span><span id="5246" class="mx jz iq mt b gy nc mz l na nb">    public Address Address { get; set; }<br/>}</span></pre><p id="0a3d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们的人类已经看起来好多了。与地址相关的所有逻辑现在都封装在address类中，我们已经设法从构造函数中消除了许多字符串参数。</p><p id="aa75" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可能已经注意到，总的来说，我们仍然有相同数量的字符串属性。这很好，因为最终很可能需要将数据存储在原语中。避免原语困扰的重要部分是将这些原语封装到定义良好的对象中，这些对象实际上代表了它们的含义。</p><p id="d67a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要处理的下一件事是ID。为了将类型安全带回ID，我们可以创建所谓的强类型ID。简而言之，这只是包装在特定于该实体的容器对象中的原始值。例如，PersonId对象的实现可能看起来像(改编自<a class="ae mi" href="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/" rel="noopener ugc nofollow" target="_blank">这里是</a>):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5116" class="mx jz iq mt b gy my mz l na nb">public readonly struct PersonId : IComparable&lt;PersonId&gt;, IEquatable&lt;PersonId&gt;<br/>{<br/>    public string Value { get; }</span><span id="a12a" class="mx jz iq mt b gy nc mz l na nb">public PersonId(string value)<br/>    {<br/>        Value = value;<br/>    }</span><span id="9d9a" class="mx jz iq mt b gy nc mz l na nb">public static PersonId New() =&gt; new PersonId(Guid.NewGuid().ToString());</span><span id="3a35" class="mx jz iq mt b gy nc mz l na nb">public bool Equals(PersonId other) =&gt; this.Value.Equals(other.Value);<br/>    public int CompareTo(PersonId other) =&gt; Value.CompareTo(other.Value);</span><span id="f2d8" class="mx jz iq mt b gy nc mz l na nb">public override bool Equals(object obj)<br/>    {<br/>        if (ReferenceEquals(null, obj)) return false;<br/>        return obj is PersonId other &amp;&amp; Equals(other);<br/>    }</span><span id="e6a7" class="mx jz iq mt b gy nc mz l na nb">    public override int GetHashCode() =&gt; Value.GetHashCode();<br/>    public override string ToString() =&gt; Value.ToString();</span><span id="1e57" class="mx jz iq mt b gy nc mz l na nb">    public static bool operator ==(PersonId a, PersonId b) =&gt; a.CompareTo(b) == 0;<br/>    public static bool operator !=(PersonId a, PersonId b) =&gt; !(a == b);<br/>}</span><span id="ead6" class="mx jz iq mt b gy nc mz l na nb">public class Person<br/>{<br/>    public Person(PersonId id, string firstName, string lastName, Address address)<br/>    {<br/>        // initialisation logic<br/>    }</span><span id="1f1d" class="mx jz iq mt b gy nc mz l na nb">    public PersonId Id { get; set; }</span><span id="ed63" class="mx jz iq mt b gy nc mz l na nb">    public string FirstName { get; set; }<br/>    public string LastName { get; set; }</span><span id="f549" class="mx jz iq mt b gy nc mz l na nb">    public Address Address { get; set; }<br/>}</span></pre><p id="e5d3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这很好，因为现在Person类使用自己的PersonId作为Id。它不可能被意外地用作另一个类型的ID，因为它有自己的强类型ID。</p><p id="5c33" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是，您可能已经注意到这个PersonId定义有点大，如果必须为您希望创建的每个强类型Id声明这个定义，会很麻烦。老实说，这个障碍可能是强类型id在C#开发中仍然不常见的原因。</p><p id="311f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">幸运的是，在C# 9中，我们有了新的记录类型，使得定义强类型id变得更加容易，所以希望它的使用会变得更加普遍(你可以在这里阅读更多关于记录<a class="ae mi" href="https://samwalpole.com/exciting-new-features-in-net-5" rel="noopener ugc nofollow" target="_blank">)。</a></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bb11" class="mx jz iq mt b gy my mz l na nb">// PersonId as a record<br/>public record PersonId(string Value);</span><span id="5613" class="mx jz iq mt b gy nc mz l na nb">// how to initialise<br/>var personId = new PersonId("my-id");</span></pre><p id="8f8c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对，就是字面意思。这声明了一个PersonId记录，它有一个名为Value的字符串属性，可以通过构造函数传递。记录自动基于它们的属性值进行相等，因此不需要在声明中添加任何其他内容。</p><h1 id="7be9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">F#中的原始执念</h1><p id="1178" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">尽管本文主要关注的是C#，并且上面应用的所有原则都可以在F#中使用，但我认为F#中有一个独特的特性值得注意。</p><p id="d106" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">区别联合是F#中的一种数据类型(以及许多其他语言，但不是C#)，它允许根据情况返回不同类型的数据(要了解更多关于区别联合的信息，请参见<a class="ae mi" href="https://samwalpole.com/a-brief-introduction-to-f-for-object-oriented-developers" rel="noopener ugc nofollow" target="_blank">这里</a>)。一个常见的用例是错误处理:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4725" class="mx jz iq mt b gy my mz l na nb">type Result&lt;'a&gt; =<br/>    | Data of 'a<br/>    | Error of string</span></pre><p id="28aa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">上面的例子允许一个函数返回一些通用的数据类型，但是如果有错误，返回一个字符串。</p><p id="2e02" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是，单例鉴别联合可以充当基元类型的包装，并为您的函数提供类型安全。例如，我们可能有这个人的记录:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2e54" class="mx jz iq mt b gy my mz l na nb">type Person = {<br/>    FirstName: string;<br/>    LastName: string;<br/>    EmailAddress: string;<br/>}</span></pre><p id="ebc5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里的问题是，电子邮件地址实际上不仅仅是一个字符串——它们有特定的格式，因此我们可能需要为它设计一些特定的验证逻辑。正因为如此，最好将其封装在自己的类型中。对于个案歧视工会，这很容易做到:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="683f" class="mx jz iq mt b gy my mz l na nb">type EmailAddress = EmailAddress of string</span><span id="2197" class="mx jz iq mt b gy nc mz l na nb">type Person = {<br/>    FirstName: string;<br/>    LastName: string;<br/>    EmailAddres: EmailAddress;<br/>}</span></pre><p id="47e2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，人员记录将只接受email address类型的电子邮件地址。</p><h1 id="f443" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="e230" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我介绍了原始执念的概念，它可能会导致什么问题，以及如何解决这些问题。希望您可以从中提取一些信息，并在您自己的代码库中使用它们来创建更安全、更易维护的代码。</p><p id="a9a3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我发布的大部分内容都是关于全栈的。NET和Vue web开发(很快可能会有更多的F#内容！).为了确保你不会错过任何帖子，请关注这个博客并<a class="ae mi" href="https://samwalpole.com" rel="noopener ugc nofollow" target="_blank">订阅我的简讯</a>。如果你觉得这篇文章有帮助，请喜欢它并分享它。你也可以在<a class="ae mi" href="https://twitter.com/dr_sam_walpole" rel="noopener ugc nofollow" target="_blank">推特</a>上找到我。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="404c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">【https://samwalpole.com】最初发表于<a class="ae mi" href="https://samwalpole.com/a-cure-for-primitive-obsession" rel="noopener ugc nofollow" target="_blank"><em class="nk"/></a><em class="nk">。</em></p></div></div>    
</body>
</html>