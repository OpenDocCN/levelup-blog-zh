<html>
<head>
<title>Monitoring gRPC Uptime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">监控gRPC正常运行时间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/monitoring-grpc-uptime-89f6d49e3c34?source=collection_archive---------8-----------------------#2020-07-09">https://levelup.gitconnected.com/monitoring-grpc-uptime-89f6d49e3c34?source=collection_archive---------8-----------------------#2020-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7ae0e697e43c33399432d52fb14f8939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M__lQERQbub7aqdws0WnSg.png"/></div></div></figure><p id="2416" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">gRPC的正常运行时间监控不能用传统的HTTP检查来完成。随着<a class="ae kw" href="https://asserted.io" rel="noopener ugc nofollow" target="_blank">断言</a>，您可以使用gRPC客户端和Mocha编写复杂的外部健康检查。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><blockquote class="le lf lg"><p id="214b" class="jy jz lh ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated"><em class="iq">上的例子</em> <a class="ae kw" href="https://github.com/assertedio/grpc-uptime" rel="noopener ugc nofollow" target="_blank">上的<em class="iq"> GitHub </em>上的</a></p></blockquote><p id="017d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">gRPC是一个开源的高性能RPC框架，它使用协议缓冲区在服务器和客户端之间高效地序列化数十种语言的结构化数据。</p><p id="631f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">专用的交换格式使它具有很高的性能，这也意味着gRPC服务器通常需要专用的客户机来进行通信，因为常规的HTTP库无法工作。因此，Asserted非常适合提供外部监控gRPC正常运行时间和稳定性所需的定制环境。</p><p id="3b32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本演练中使用的示例代码主要基于此处<a class="ae kw" href="https://github.com/grpc/grpc/tree/v1.30.0/examples/node" rel="noopener ugc nofollow" target="_blank">提供的节点示例</a>。</p><h1 id="8a83" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">示例服务器</h1><p id="d3b3" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">该服务器将使用的原型定义如下所示，直接取自上面提到的官方gRPC节点示例。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ec6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">示例测试将运行的gRPC服务器在<a class="ae kw" href="https://github.com/assertedio/grpc-uptime/blob/master/route_guide/route_guide_server.js" rel="noopener ugc nofollow" target="_blank">文件</a>中有描述。它太大了，无法在这里完整地展示，但是我将总结主要的元素。</p><p id="e698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务器公开四个RPC:</p><ul class=""><li id="51c0" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">获取单个对象的简单RPC</li><li id="d926" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">用于检索列表的服务器端流式RPC</li><li id="6fa6" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">记录一系列事件的客户端流式RPC</li><li id="dcd8" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">和一个双向RPC来提供简单的聊天功能</li></ul><h1 id="eca0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">常规配置</h1><p id="4bd9" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><strong class="ka ir"> routine.json </strong>利用了<a class="ae kw" href="https://docs.asserted.io/reference/included-dependencies#custom-dependencies" rel="noopener ugc nofollow" target="_blank">自定义依赖关系</a>。付费计划中提供了自定义依赖项，这里我们使用该选项来包含套接字。我们测试中的IO客户端库。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="57e8" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">例程包. json</h1><p id="e1f6" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">例程的<strong class="ka ir"> package.json </strong>(在。asserted directory)在这种情况下与缺省值略有不同。在这种情况下，我们添加了一些方便的库以及<strong class="ka ir"> @grpc/proto-loader </strong>、<strong class="ka ir"> google-protobuf </strong>和<strong class="ka ir"> grpc </strong>。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="4489" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">持续集成测试</h1><p id="f3af" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">首先，我们基于与服务器相同的原型创建一个gRPC客户机。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5c2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们使用该客户端对我们之前定义的四个RPC中的每一个执行测试。</p><p id="b139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单的RPC只是检索单个对象，并断言它与预期的相匹配。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从客户端来看，list RPC(服务器端的流)看起来非常类似于上面的简单RPC。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="060e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">客户端流RPC向服务器发送许多点，并断言结果。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c6a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，双向RPC向服务器发送一系列通知，一旦呼叫结束，服务器就做出响应。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="da3e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">后续步骤</h1><p id="ef69" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">虽然这里显示的示例<a class="ae kw" href="https://github.com/assertedio/grpc-uptime" rel="noopener ugc nofollow" target="_blank">可以在没有帐户的情况下在本地克隆和运行，但是如果您想要创建自己的断言例程来在生产中集成测试您的API，您将需要执行一些额外的步骤。</a></p><ol class=""><li id="46b3" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv ni na nb nc bi translated">创建一个<a class="ae kw" href="https://asserted.io" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">断言账户</strong> </a>。很洒脱。</li><li id="58ce" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv ni na nb nc bi translated">完成2分钟的入职培训，确保您的环境准备就绪。也可以在 这里引用<a class="ae kw" href="https://docs.asserted.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">的单据。</strong></a></li><li id="a4e7" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv ni na nb nc bi translated">开始在prod中编写和运行测试！</li></ol></div></div>    
</body>
</html>