<html>
<head>
<title>If-Else Is a Poor Man’s Polymorphism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">If-Else是穷人的多态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/if-else-is-a-poor-mans-polymorphism-ab0b333b7265?source=collection_archive---------0-----------------------#2020-08-24">https://levelup.gitconnected.com/if-else-is-a-poor-mans-polymorphism-ab0b333b7265?source=collection_archive---------0-----------------------#2020-08-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="737b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">更好的软件设计</h2><div class=""/><div class=""><h2 id="1c29" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过用对象替换if-then-else和switch，将6行变成92行的艺术——变得更好。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/50519598321a69b84b5b523b1c203c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_I1Jk4Sl03er2SHvUHABwg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">鸣谢:作者</figcaption></figure><p id="a5a8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当然，<code class="fe md me mf mg b">if-else</code>和<code class="fe md me mf mg b">switch</code>有助于精简简单的代码。但是你的软件不应该包含尽可能少的行，牺牲可读性、可维护性或灵活性。</p><p id="6e03" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我看到枚举或其他离散值上发生了很多分支。当被告知不要使用<code class="fe md me mf mg b">if-then-else</code>时，一些开发者甚至变得愤怒。</p><p id="a8a9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是，你认为在你的<code class="fe md me mf mg b">if-then-else</code>语句中使用枚举的后果是什么？</p><p id="34a6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">离散值上的分支使得你的软件很难改变。每一个新特性都要求你追踪分支发生的地方，并相应地修改你现有的代码。</p><p id="01ce" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="mh">快速补充:如果你是视觉学习者，你可以跟随</em> <a class="ae mi" href="https://youtu.be/ufeZazqrHjM" rel="noopener ugc nofollow" target="_blank"> <em class="mh">这段新视频，它解释了消除if-else和switch cases </em> </a> <em class="mh">的不同方法。</em></p><p id="c4d2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这绝对不是我们想要开发伟大软件的方式。这也许是让你的代码工作的完美的第一步。但是，当你进展到<a class="ae mi" href="https://medium.com/@nmillard/the-principles-of-software-development-7415e7c5a156" rel="noopener">让你的代码变得更好的时候</a>，<code class="fe md me mf mg b">switch</code>和<code class="fe md me mf mg b">if-then-else</code>肯定早就消失了。</p><blockquote class="mj"><p id="40e5" class="mk ml it bd mm mn mo mp mq mr ms mc dk translated">使用if-else和switch进行分支的传统方法已经过时。它不是实心的。不灵活。</p><p id="1143" class="mk ml it bd mm mn mo mp mq mr ms mc dk translated">太可怕了。</p></blockquote><p id="1d9d" class="pw-post-body-paragraph lh li it lj b lk mt kd lm ln mu kg lp lq mv ls lt lu mw lw lx ly mx ma mb mc im bi translated">传统的方法肯定没有面向对象的东西。但是，它正在蓬勃发展。这是有道理的，因为学生们被打得认为这是正确的，甚至是最佳实践。</p><p id="337b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当然，代码正在运行，但你知道你可以做得更好。目标应该是通过创建新的类来实现新的需求。</p><h2 id="e397" class="my mz it bd na nb nc dn nd ne nf dp ng lq nh ni nj lu nk nl nm ly nn no np iz bi translated">让我想象一下这个问题。</h2><p id="4f38" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">假设由于某种原因，您必须实现一种更新用户的方法。为了简单起见，一个用户只有两个理由在你的系统中被更新。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nv"><img src="../Images/aeef22c8ccea3c0b00d52234913e0ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uU7V-Ct4NsbPl_tzD7iepw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">最初的一组需求</figcaption></figure><p id="d9d5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您在下面的代码片段中实现了这两种简单的情况。</p><p id="a5bf" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请花点时间阅读这段设计糟糕的代码。毫无疑问，许多高级开发人员对此做着噩梦，甚至可能被认为是PTSD的触发因素。</p><p id="4a96" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">是的，我在野外见过这样疯狂的代码。这是一个难以置信的天真的实现，它假设用户再也没有更多的理由去改变。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/2311389d082d37dd77a00488b0cb4e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lY16ZNnE58tlb_oqe8nqCQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">无用的if-else指令的可怕代码示例</figcaption></figure><p id="8c23" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">关于这段代码，唯一值得一提的是它试图实现一种半CQS式的设计模式。</p><p id="0db6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你倾向于说“这应该是一个开关！”你应该花一点时间来思考软件开发中什么是重要的。<code class="fe md me mf mg b">Switch</code>超过<code class="fe md me mf mg b">if-else</code>完全不相干。</p><h2 id="6dc1" class="my mz it bd na nb nc dn nd ne nf dp ng lq nh ni nj lu nk nl nm ly nn no np iz bi translated">你会受到新需求的冲击。一直都是。</h2><p id="61e2" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">新的需求随之而来。谁能想到呢？你那么确定什么都不会发生。</p><p id="82b9" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">说你现在的需求是这样的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nv"><img src="../Images/58af2838b967a6cbbe45ba97b9a67a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0GchpgTk_af-tQ8JY-cnA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">额外要求</figcaption></figure><p id="7e2e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">问题是，您真的打算通过添加额外的枚举值和添加两个额外的<code class="fe md me mf mg b">else-if</code>来实现这两个更新用户的新理由吗？</p><p id="7fbd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你决定走上错误的道路，看起来会是这样。这段代码读起来不太好。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/16eddce2c3274116181f3f4a8efa9b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDA_wsV9Y9_0_WDSZtQq9w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">复杂、令人头痛的分支</figcaption></figure><p id="7cca" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这种实现本质上是穷人的多态。</p><p id="df04" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">除了必须不断添加额外的分支(这本身就是一种有问题的做法)之外，每当您必须调试或执行bug修复时，您都会被完全不相关的代码包围。</p><p id="f037" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">还有一个问题。这个方法签名对我们撒谎，因为它不仅仅是更新一个用户。它还根据更新原因选择执行哪个算法，甚至知道每个实现。到目前为止，每个人都很清楚这个方法有无数的责任。</p><p id="d3eb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我敢肯定这个例子固化了<code class="fe md me mf mg b">if-else</code>和<code class="fe md me mf mg b">switch</code>的一切可怕之处。</p><p id="1f0d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们来看看如何避免这种讨厌的方法。</p><h2 id="fea0" class="my mz it bd na nb nc dn nd ne nf dp ng lq nh ni nj lu nk nl nm ly nn no np iz bi translated">重构多态执行非常容易。</h2><p id="e3ab" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">您将把杂乱的基于分支的代码重构为内聚的、简单的类，这些类与实际需求保持一致。</p><p id="77d7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在有人对使用类感到恐惧之前，让我先澄清一件事。实例化新类的成本通常可以忽略不计。不要试图优化你的代码，在它成为一个被证实的瓶颈之前。</p><p id="a136" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好吧，我们继续。</p><p id="6c0a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我前面提到我们可以做得更好。我所说的更好，是指编写1)可读，2)可维护，3)灵活的代码。</p><p id="142a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过用多态执行代替传统的分支，在类和它管理的需求之间有一个清晰的关系。简单、高度内聚、职责明确的类易于维护。检测和纠正缺陷变得轻而易举。</p><p id="e74b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最重要的是，您的软件可以轻松地容纳新的特性，而不必修改现有的类。</p><h2 id="2a45" class="my mz it bd na nb nc dn nd ne nf dp ng lq nh ni nj lu nk nl nm ly nn no np iz bi translated">让重构开始吧</h2><p id="f992" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">你会看到没有一个<code class="fe md me mf mg b">if-then-else</code>或<code class="fe md me mf mg b">switch</code>我们能走多远。</p><p id="9dc6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe md me mf mg b">UpdateAsync(Reason, User)</code>现在已经变得这么简单了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/2ae6a999b5a0ac867f211c0b0dcc1e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SA_DMQSvuKKGPCqFim0FCQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">简化的UpdateAsync方法实现</figcaption></figure><p id="b142" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请注意，您现在采用的是接口参数，而不是枚举。现在，该方法将了解如何执行更新的责任委托给了一个专门化的对象。</p><p id="4420" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">具体实现看起来是这样的。我将关于构造函数参数和方法实现的细节留给您去想象。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/60a25be6f069d753896e3709b0293a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MA4nAdhcDJr1YvY-bsacgw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">UpdateReason接口及其具体实现</figcaption></figure><p id="baca" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">每个类都完全符合它所管理的需求。与可怕的过时方法相比，调试、修复错误和测试现在要容易得多。</p><p id="9a7b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这种情况下，任何新的需求都会产生一个专门的类。</p><p id="da2f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以很容易地在这里停下来，到此为止。您重构了讨厌的分支，并用多态性替换了它。您的代码现在是面向对象的，非常容易维护。干得好。</p><h2 id="baa0" class="my mz it bd na nb nc dn nd ne nf dp ng lq nh ni nj lu nk nl nm ly nn no np iz bi translated">但是，还有最后一个问题。</h2><p id="da2d" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">你的<code class="fe md me mf mg b">UpdateAsync(Reason, User)</code>现在有些多余了。</p><p id="500f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了解决这个问题，我们不再进行重构。我们正着手重新设计系统的各个部分。</p><p id="8897" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这种情况下，创建命令对象和命令处理程序是有意义的。这将简化调用代码，因为它只需发送一个像<code class="fe md me mf mg b">UpdateUserAddress</code>这样的命令，就会调用相应的处理程序的动作。</p><p id="11de" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我有一篇文章发表在2020年6月的<a class="ae mi" href="https://blog.jetbrains.com/dotnet/2020/06/05/net-annotated-monthly-june-2020/" rel="noopener ugc nofollow" target="_blank"> JetBrains上。NET简讯</a>正是关于这一点。下面是链接。</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/swlh/dynamic-command-dispatching-in-c-d3abe21b3d1b" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">C#中的动态命令调度</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">如何动态分派命令并调用相应的处理程序操作。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo lb oa"/></div></div></a></div><p id="8803" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/replacing-if-else-with-commands-and-handlers-527e0abe2147">更新:这是一篇较新的文章，我在其中描述了命令和处理程序方法。</a></p><h1 id="bf44" class="op mz it bd na oq or os nd ot ou ov ng ki ow kj nj kl ox km nm ko oy kp np oz bi translated">你的主要外卖。</h1><p id="1256" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">总之，在发现更合适的多态方法之前，传统的分支通常是学生的工具。</p><p id="02ae" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe md me mf mg b">if-then-else</code>和<code class="fe md me mf mg b">switch</code>使得你的代码更难阅读、维护和调整。</p><p id="fd7c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下一次，当您使用传统的多路分支实现一个特性时，花点时间分析一下如何利用多态性和现代方法。</p></div><div class="ab cl pa pb hx pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="im in io ip iq"><pre class="ks kt ku kv gt ph mg pi pj aw pk bi"><span id="4064" class="my mz it mg b gy pl pm l pn po"><strong class="mg jd">Resources for the curious</strong><br/>-------------------------</span><span id="b5fc" class="my mz it mg b gy pp pm l pn po"><a class="ae mi" href="https://app.pluralsight.com/library/courses/e9690e73-567d-4b35-91c0-4aae3e3be06e/table-of-contents" rel="noopener ugc nofollow" target="_blank">Making Your C# More Object-Oriented</a> by Zoran Horvat</span><span id="d215" class="my mz it mg b gy pp pm l pn po"><a class="ae mi" href="https://medium.com/swlh/creating-configurable-classes-that-are-easy-to-use-69d78d6881a2" rel="noopener">Creating Highly Configurable Code in Three Simple Steps</a> by the Author</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/745b6019f001879654cae7d29d306420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LZ0-rAawOB4iv6uI.png"/></div></div></figure><p id="cc49" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd"> Nicklas Millard </strong>是一名软件开发工程师，供职于一家发展最快的银行，负责构建任务关键型金融服务基础设施。</p><p id="7bfa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">此前，他是Big4的高级技术顾问，为商业客户和政府机构开发软件。</p><blockquote class="pr ps pt"><p id="71d7" class="lh li mh lj b lk ll kd lm ln lo kg lp pu lr ls lt pv lv lw lx pw lz ma mb mc im bi translated"><a class="ae mi" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank">新的YouTube频道(@Nicklas Millard) </a></p><p id="f1a4" class="lh li mh lj b lk ll kd lm ln lo kg lp pu lr ls lt pv lv lw lx pw lz ma mb mc im bi translated"><em class="it">连接上</em> <a class="ae mi" href="https://www.linkedin.com/in/nicklasmillard/" rel="noopener ugc nofollow" target="_blank"> <em class="it"> LinkedIn </em> </a></p></blockquote><h1 id="1d8c" class="op mz it bd na oq or os nd ot ou ov ng ki ow kj nj kl ox km nm ko oy kp np oz bi translated">分级编码</h1><p id="da18" class="pw-post-body-paragraph lh li it lj b lk nq kd lm ln nr kg lp lq ns ls lt lu nt lw lx ly nu ma mb mc im bi translated">感谢您成为我们社区的一员！<a class="ae mi" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jd">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae mi" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jd"> Skilled.dev编码面试课程</strong> </a>。</p><div class="nx ny gp gr nz oa"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">编写面试问题</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">掌握编码面试的过程</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">技术开发</p></div></div><div class="oj l"><div class="px l ol om on oj oo lb oa"/></div></div></a></div></div></div>    
</body>
</html>