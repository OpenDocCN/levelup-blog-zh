<html>
<head>
<title>Create a quick .NET Core CLI with System.CommandLine, Logging and Dependency Injection.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个快速。NET核心CLI与系统。命令行、日志记录和依赖注入。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-a-quick-net-core-cli-with-system-commandline-logging-and-dependency-injection-e369b4491f78?source=collection_archive---------6-----------------------#2021-06-01">https://levelup.gitconnected.com/create-a-quick-net-core-cli-with-system-commandline-logging-and-dependency-injection-e369b4491f78?source=collection_archive---------6-----------------------#2021-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3202" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写一个成熟的客户端。网芯不一定要难。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54c7d21612031a782a72110845faa9c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2doBF3eEw_mHMbeJBpuQg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@codestorm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">萨法尔·萨法罗夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="122d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一天，我需要创建一个简单的命令行应用程序来做一些数据库管理工作。我有点完美主义(哼哼)所以对我来说，一个简单的CLI应该至少有以下特点:</p><ul class=""><li id="7775" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">强大的参数解析和验证</li><li id="5e47" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">记录</li><li id="d024" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">易测性</li></ul><p id="efd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个，<em class="mj">可测性</em>，对我来说几乎就是<em class="mj">依赖注入</em>的同义词。我喜欢DI如何帮助以模块化的方式建立东西，因此允许你为你所做的一切编写适当的、隔离的单元测试。</p><p id="21e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">。NET Core附带了一个非常简单的DI框架。虽然有些人说它不够“强大”(不管那是什么意思)，但我没有找到转换到另一个框架的理由。</p><p id="24f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们深入DI(正如您将看到的，它将使日志记录变得微不足道)之前，让我们解决第一个需求:健壮的参数解析和验证。为此，我们求助于<a class="ae ky" href="https://github.com/dotnet/command-line-api" rel="noopener ugc nofollow" target="_blank">(在写作时，实验性的)系统。命令行</a>包。</p><h2 id="7ccb" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">创建我们的CLI</h2><p id="d954" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我可以写几段关于什么系统的文章。命令行是什么，它能做什么，但是我给你演示一下怎么样？</p><p id="f3f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个基本的控制台应用程序开始。在任何终端中(我强烈推荐新的<a class="ae ky" href="https://github.com/microsoft/terminal" rel="noopener ugc nofollow" target="_blank"> Windows终端</a>，如果你在Windows上)，创建一个新项目:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="dc37" class="mk ml it nj b gy nn no l np nq">mkdir ohmy-cli<br/>cd ohmy-cli<br/>dotnet new console</span></pre><p id="fb5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给了我们一个标准。NET核心命令行应用程序。也管用！只需在项目的根目录下输入<code class="fe nr ns nt nj b">dotnet run</code>，瞧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/77e425ed086decaef050fb760eaaeeea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEKbNWJvSUIN-wCNBmoljQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">你好世界！</figcaption></figure><p id="bae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它甚至可以接受参数。但是离“健壮的参数解析和验证”还有很长的路要走。让我们改变这一点。</p><p id="fbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，添加系统。命令行包:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="d052" class="mk ml it nj b gy nn no l np nq">dotnet add package System.CommandLine --prerelease</span></pre><p id="e187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意到<code class="fe nr ns nt nj b">--prerelease</code>参数了吗？这是必要的，因为系统。CommandLine仍处于测试阶段。</p><p id="9d28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用下面的代码替换<code class="fe nr ns nt nj b">Main</code>方法和(我将在下面解释):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">添加系统。命令行</figcaption></figure><p id="401a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<strong class="lb iu">第3–9行</strong>中，我们创建了CLI的根，并添加了一个必需的参数<code class="fe nr ns nt nj b">--folder</code>。我们还添加了一个别名<code class="fe nr ns nt nj b">-f</code>和一个描述。</p><p id="4b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<strong class="lb iu">第11行</strong>上，我们向我们的应用程序添加了一个描述。</p><p id="0a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<strong class="lb iu">第13 </strong>行，我们指定哪个方法将处理我们的输入，这是在<strong class="lb iu">第18–21</strong>行定义的<code class="fe nr ns nt nj b">RunApplication</code>方法。</p><p id="34b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在第<strong class="lb iu">行第15 </strong>行，我们用提供给我们的<code class="fe nr ns nt nj b">Main</code>方法的参数运行程序。</p><p id="3524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe nr ns nt nj b">dotnet run</code>运行这个函数时，我们得到的是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/73b1ebf694fddd9346b9424043e86c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwbFlN5-t3IlNJfX4WyLCQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">你好CLI！</figcaption></figure><p id="b62d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那不是很漂亮吗？我们不仅得到了已定义选项<code class="fe nr ns nt nj b">--folder</code>的处理、验证和文档，还得到一种获得应用程序版本和<code class="fe nr ns nt nj b">--help</code>选项的方法(其输出与上面完全相同)。</p><p id="36dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供所需的参数<code class="fe nr ns nt nj b">--folder</code>，我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/ebdaf7214d1742ff3fe86712b48a2d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrMrriQaxi2HmtG_jtPNNw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Hello CLI，带— folder参数。</figcaption></figure><p id="d0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这还没有那么多，但证明了我们处理<code class="fe nr ns nt nj b">--folder</code>参数很好。</p><p id="83d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅使用目前的代码，我们就可以构建一个令人印象深刻的CLI。例如，您可以添加<a class="ae ky" href="https://github.com/dotnet/command-line-api/blob/main/docs/How-To.md#Add-a-subcommand" rel="noopener ugc nofollow" target="_blank">子命令</a>或<a class="ae ky" href="https://github.com/dotnet/command-line-api/blob/main/docs/Features-overview.md#Suggestions" rel="noopener ugc nofollow" target="_blank">制表完成</a>。</p><p id="e498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是随着你的程序变得越来越大(它会变得越来越大)，可测试性很快就会成为一个问题。事实上，我认为这从一开始就应该是一个问题，在它变好之前…一个问题。正如我在介绍中提到的，对我来说，可测试性实际上是依赖注入的同义词。这是因为依赖注入允许你孤立地测试程序的各个组件。让我们接下来解决这个问题。</p><h2 id="d739" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">添加依赖注入</h2><p id="a447" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">首先我们需要添加微软的<a class="ae ky" href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection" rel="noopener ugc nofollow" target="_blank">。扩展. DependencyInjection </a>包:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0cb2" class="mk ml it nj b gy nn no l np nq">dotnet add package Microsoft.Extensions.DependencyInjection </span></pre><p id="a0c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在您的<code class="fe nr ns nt nj b">Main</code>方法的顶部，添加:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="acf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这构建了将存储我们的依赖项并调用<code class="fe nr ns nt nj b">ConfigureServices</code>来添加它们的服务提供者。</p><p id="312f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并添加了<code class="fe nr ns nt nj b">ConfigureServices</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第3行</strong>向服务提供者注册了<code class="fe nr ns nt nj b">App</code>，这样我们以后就可以检索它了。</p><p id="4135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，将创建<code class="fe nr ns nt nj b">CommandHandler</code>的行替换为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="70ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第1行</strong>从serviceprovider检索已注册的<code class="fe nr ns nt nj b">App</code>实例。然后我们将<code class="fe nr ns nt nj b">Run</code>方法传递给<strong class="lb iu">行3 </strong>中的commandhandler。</p><p id="f213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这负责设置依赖注入。然而，当我们运行应用程序时，我们得到一个关于未定义<code class="fe nr ns nt nj b">App</code>的错误。让我们解决这个问题。</p><p id="9b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在使用DI将<code class="fe nr ns nt nj b">App</code>注入我们的程序。所以让我们创建一个新文件<code class="fe nr ns nt nj b">App.cs</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以从<code class="fe nr ns nt nj b">Program.cs</code>中移除<code class="fe nr ns nt nj b">RunApplication</code>方法。</p><p id="2599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是依赖注入。这就给我们留下了<em class="mj">日志</em>，我保证这将是微不足道的。让我们开始吧。</p><h2 id="0abb" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">添加日志记录</h2><p id="ebda" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">添加<a class="ae ky" href="https://www.nuget.org/packages/Microsoft.Extensions.Logging" rel="noopener ugc nofollow" target="_blank">微软。扩展. Logging </a>包和分别记录到<a class="ae ky" href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console/" rel="noopener ugc nofollow" target="_blank">控制台</a>和<a class="ae ky" href="https://www.nuget.org/packages/Microsoft.Extensions.Logging.Debug/" rel="noopener ugc nofollow" target="_blank">调试</a>流的包:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="9cf0" class="mk ml it nj b gy nn no l np nq">dotnet add package Microsoft.Extensions.Logging<br/>dotnet add package Microsoft.Extensions.Logging.Console<br/>dotnet add package Microsoft.Extensions.Logging.Debug</span></pre><p id="e333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，改变<code class="fe nr ns nt nj b">ConfigureServices</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="313f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第4–9行</strong>配置我们的日志记录提供程序来记录调试消息，并写入控制台和调试流。</p><p id="9e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将日志注入<code class="fe nr ns nt nj b">App.cs</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d8d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第9–14行</strong>分别定义、注入和初始化我们的Logger属性。在第<strong class="lb iu">行的第18 </strong>行，我们将文件夹参数的值写入日志。</p><p id="f673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，运行我们的应用程序，我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c263feb6a52648f24f7ff0cc2a6366ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIQj2nku0g7EbWYWWdGd8w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Hello CLI，带日志记录。</figcaption></figure><p id="31c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将把格式化输出作为一个练习留给您。为什么不去看看<a class="ae ky" href="https://www.nuget.org/packages/Serilog" rel="noopener ugc nofollow" target="_blank">系列日志</a>？这是我的结构化日志记录包。</p><p id="e2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了。用. net编写的功能全面的CLI。NET核心，带有依赖注入和日志记录。相信我，创建应用程序比撰写本文花费的时间要少得多；)</p><p id="8c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这能帮助你节省一些样板代码的时间(让我们承认这一点)，这样你就可以专注于实现你所想的任何令人惊叹的功能。</p><p id="61fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="9ce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是技术文章的作者，并且使用GitHub Gists(您应该这样做)，下面的故事可能对您有用。</p><div class="oh oi gp gr oj ok"><a href="https://erikbrgr.medium.com/using-multi-file-github-gists-in-medium-f4e40bb9e283" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">在媒体中使用多文件GitHub Gists</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">在Medium中使用多文件GitHub Gists是完全可能的，尽管有点麻烦。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">erikbrgr.medium.com</p></div></div></div></a></div><p id="5b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用VSCode(我在本文中使用了vs code)编写代码，您可能会喜欢这个故事:</p><div class="oh oi gp gr oj ok"><a href="https://erikbrgr.medium.com/essential-extensions-for-visual-studio-code-32eaec6c6054" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">Visual Studio代码的基本扩展(还有一个好处！)</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">专注于你的代码，别无他求。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">erikbrgr.medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>