<html>
<head>
<title>Kadane’s Algorithm — Solving for Maximum Subarray in O(n) Time and O(1) Space</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kadane算法——在O(n)时间和O(1)空间求解最大子阵</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kadanes-algorithm-solving-for-maximum-subarray-in-o-n-time-and-o-1-space-776290910090?source=collection_archive---------1-----------------------#2021-08-28">https://levelup.gitconnected.com/kadanes-algorithm-solving-for-maximum-subarray-in-o-n-time-and-o-1-space-776290910090?source=collection_archive---------1-----------------------#2021-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e8c8d72ab8060a10dd9bf5c7ab5c1e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X51jYPje7rn5j8kUiP1_7A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">pc: <a class="ae kc" href="https://unsplash.com/@christinhumephoto" rel="noopener ugc nofollow" target="_blank"> @christinhumephoto </a></figcaption></figure><h1 id="6908" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="e118" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Kadane的算法能够找到一个运行时间为O(n)的数组中相邻子数组的最大和。众所周知，这种算法能够优雅地解决最大子阵列问题及其变体(参见<a class="ae kc" href="https://leetcode.com/problems/maximum-subarray/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>)。</p><p id="b36f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果你的工作遇到基因组<a class="ae kc" href="https://en.wikipedia.org/wiki/Sequence_analysis" rel="noopener ugc nofollow" target="_blank">序列分析</a>和<a class="ae kc" href="https://en.wikipedia.org/wiki/Computer_vision" rel="noopener ugc nofollow" target="_blank">计算机视觉</a>，你可能会遇到工业中的最大子阵列问题。</p><h1 id="4c6a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">要旨</h1><p id="852d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Kadane的算法为结束于每个索引的所有子阵列找到可以从子阵列产生的最大值。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f0aef156cb4fb3645d23cb03b838bdfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*zu60pGk2f9ZQww_k_-P95Q.png"/></div></figure><p id="2f20" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">例如，在本例中，蓝色括号<strong class="ld ir"> [] </strong>表示正在评估的子阵列。</p><p id="71e3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">第一行是原始的给定数组。第二行是仅保存值-2的第一个子阵列。第三行是保存值-2和1的另一个子数组。</p><p id="8983" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这个序列将继续下去，直到我们到达数组的末尾，值为4，索引为8，在这里我们将理想地找到我们的问题的解决方案。</p><h1 id="d04b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">逻辑大纲</h1><p id="b48e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们到达一个新的指数，同时仍然试图找到结束于该指数的最大和时，我们有两个选项可以考虑来实现我们的目标:</p><ol class=""><li id="0b7c" class="mj mk iq ld b le lz li ma lm ml lq mm lu mn ly mo mp mq mr bi translated">取在前一个索引处结束的最大和，并加上当前数(<strong class="ld ir"> current_max_sum + num </strong>)</li><li id="71b8" class="mj mk iq ld b le ms li mt lm mu lq mv lu mw ly mo mp mq mr bi translated">或者仅使用当前号码(<strong class="ld ir"> num </strong>)</li></ol><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a41c5cb538a4a27585ac4559cff4a2cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*ED8RYw9wTS1n7pxTAzo9vQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">两个选项的alt表示:current_max_sum是任一选项的最大值</figcaption></figure><p id="9c0a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">从上面的例子开始:<strong class="ld ir"> [-2，1，-3] </strong>，4，-1，2，1，-5，4]</p><p id="5620" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> current_max_sum </strong>为-4(从-2 + 1 + -3导出),下一个索引处的<strong class="ld ir"> num </strong>为4。如果我们选择选项1，新的最大和将是0(-4+4)；因此，不值得添加到当前数字，因此我们将选择第二个选项，并继续使用当前数字(4)。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/9fc7fc0f82b109ece8f2cddc3f599e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*jx1OQdj73IeOGzKBQShLqQ.png"/></div></figure><p id="3be1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">未来的迭代如所讨论的那样继续，以最终找到子阵列[4，-1，2，1]具有最大和6。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="c7a2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">到目前为止，我们正在跟踪基于子阵列末端的当前最大总和。但最终，我们试图完成的是从子数组中找到最大和。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/58cb9f74b3d420a2859b5777017a6da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*XFjf1qKwZhfKaAHSGP43aQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">两个选项的alt表示:两个选项的最终和是最大的</figcaption></figure><p id="e421" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">继续同一个例子:[-2，1，-3，<strong class="ld ir">【4，-1，2，1】</strong>，-5，4]</p><p id="3951" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在这个迭代<strong class="ld ir">中，最终_最大_总和</strong>是6，(4 + -1 + 2 + 1)，并且在前一个索引(4 + -1 + 2) <strong class="ld ir">中，当前_最大_总和</strong>是5。因为6大于5，所以在最近的迭代中，<strong class="ld ir">最终_最大_总和值</strong>被更新为6。</p><h1 id="796c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">代码</strong></h1><p id="560d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">像所有算法一样，Kadane的算法是语言不可知的，但是这里有一个Python3的实现例子，它结合了上面讨论的两个公式。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="e2c3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">快乐编码(:</p></div></div>    
</body>
</html>