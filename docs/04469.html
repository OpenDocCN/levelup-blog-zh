<html>
<head>
<title>JavaScript Problems — Click Events, Unit Tests, Page Load, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题——点击事件、单元测试、页面加载等等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problems-click-events-unit-tests-page-load-and-more-4951d1c5b1c6?source=collection_archive---------13-----------------------#2020-06-28">https://levelup.gitconnected.com/javascript-problems-click-events-unit-tests-page-load-and-more-4951d1c5b1c6?source=collection_archive---------13-----------------------#2020-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/68a782b98e016da2a91d6c6deaa5c1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gK3pkrCIzwu0x-Ww"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2371" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="d281" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript代码单元测试工具</h1><p id="94a3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有许多用JavaScript应用程序创建和运行单元测试的测试运行程序。</p><p id="f018" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">艾娃</strong>是一个快速的测试运行程序，它让我们可以运行单元测试。它支持承诺和ES6语法。此外，每个文件的环境都是独立的。</p><p id="3567" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还支持生成器和异步函数。也支持可观测量。堆栈跟踪比其他跑步者更容易阅读，因为它是干净的。</p><p id="354b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Buster.js </strong>是另一个试跑者。它是跨平台的，可以在Windows、Mac和Linux上运行。测试从浏览器上运行，没有标题。多个客户端可以同时运行测试。也可以测试节点应用。可以编写xUnit或BDD风格的测试。</p><p id="f6f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">支持多种JavaScript测试框架。这是SinonJS附带的。测试在保存时自动运行。</p><p id="8b51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Jasmine </strong>是一个BDD测试框架。它的语法看起来像RSpec语法，用于测试Ruby和Rails应用程序。</p><p id="4157" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">QUnit 让我们测试JavaScript前端代码。它主要基于jQuery、jQuery UI和jQuery Mobile。</p><p id="8302" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Sinon是另一个测试工具。这是一个简单的测试运行程序，让我们模拟代码并运行它们。</p><p id="23be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它没有依赖关系。</p><p id="5b5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Jest </strong>是另一个强大的测试框架，内置了测试运行器和许多工具来帮助我们做测试。它支持所有现代语法，它支持异步和模块，包括模仿它们。</p><h1 id="26a6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript静态变量</h1><p id="c877" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过将属性直接附加到构造函数来添加静态变量。</p><p id="1c05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4872" class="mq lf it mm b gy mr ms l mt mu">function MyClass () {<br/>  //...<br/>}</span></pre><p id="56d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="117d" class="mq lf it mm b gy mr ms l mt mu">MyClass.staticProp  = "baz";</span></pre><p id="7712" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们直接把<code class="fe mv mw mx mm b">staticProp</code>附加到<code class="fe mv mw mx mm b">MyClass</code>上。</p><h1 id="d078" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查数字是浮点数还是整数</h1><p id="510d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当一个数被1除时，我们可以通过使用余数运算符得到它的余数来检查它是否是一个整数。</p><p id="cb0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如，我们可以写；</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="56e5" class="mq lf it mm b gy mr ms l mt mu">const isInt = (n) =&gt; {<br/>  return n % 1 === 0;<br/>}</span></pre><p id="d5f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果是整数，那么就是<code class="fe mv mw mx mm b">true</code>。</p><p id="4303" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过将<code class="fe mv mw mx mm b">===</code>改为<code class="fe mv mw mx mm b">!==</code>来检查它是否是浮点数。我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="658e" class="mq lf it mm b gy mr ms l mt mu">const isFloat = (n) =&gt; {<br/>  return n % 1 !== 0;<br/>}</span></pre><h1 id="9c36" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查键盘上的哪个键被按下</h1><p id="022f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用按键事件的<code class="fe mv mw mx mm b">keyCode</code>或<code class="fe mv mw mx mm b">which</code>属性。</p><p id="10b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都有被按下的键盘键的整数代码。</p><p id="e213" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3429" class="mq lf it mm b gy mr ms l mt mu">const code = e.keyCode || e.which;<br/>if(code === 13) { <br/>  //Do something<br/>}</span></pre><p id="a091" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们检查是否是13来检查回车键。</p><h1 id="3de8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">window.onload vs document.onload</h1><p id="2b41" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">window.onload</code>和<code class="fe mv mw mx mm b">document.onload</code>是有区别的。</p><p id="0dae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">window.onload</code>在整个页面加载时被触发，包括图像、CSS、脚本等所有内容。</p><p id="199f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">documebt.onload</code>在DOM准备就绪时调用，这可以在加载图像和其他外部内容之前。</p><h1 id="2c6a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象文字中的自引用</h1><p id="3b90" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mv mw mx mm b">this</code>来引用<code class="fe mv mw mx mm b">this</code>当前所在的对象。</p><p id="fdcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8e72" class="mq lf it mm b gy mr ms l mt mu">const foo = {<br/>  a: 1,<br/>  b: 2,<br/>  get c() {<br/>    return this.a + this.b;<br/>  }<br/>}</span></pre><p id="3d25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mv mw mx mm b">this.a</code>是1<code class="fe mv mw mx mm b">this.b</code>是2，那么<code class="fe mv mw mx mm b">c</code>就是3。</p><p id="7440" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只能用顶级方法做到这一点，包括getters和setters。</p><p id="aa91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，<code class="fe mv mw mx mm b">this</code>的值可能会不同。</p><h1 id="f6d3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">addEventListener vs onclick</h1><p id="2468" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要将一个点击监听器附加到一个元素上，我们有几种方法。</p><p id="bb49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mv mw mx mm b">'click'</code>事件调用<code class="fe mv mw mx mm b">addEventListener</code>。</p><p id="b7d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以将<code class="fe mv mw mx mm b">onclick</code>属性添加到元素中。</p><p id="0299" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以获取元素并将回调设置为<code class="fe mv mw mx mm b">onclick</code>属性的值。</p><p id="7ed4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9b00" class="mq lf it mm b gy mr ms l mt mu">element.addEventListener('click', onClick, false);</span></pre><p id="b78a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">onClick</code>是一个函数。</p><p id="2ac5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">false</code>禁用从根元素向下传播事件的捕获模式。</p><p id="dcd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="eac0" class="mq lf it mm b gy mr ms l mt mu">&lt;a href="#" onclick="alert('hello');"&gt;click me&lt;/a&gt;</span></pre><p id="eef9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有带有属性<code class="fe mv mw mx mm b">onclick</code>的<code class="fe mv mw mx mm b">a</code>元素，其中包含JavaScript表达式。</p><p id="9e34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e7cb" class="mq lf it mm b gy mr ms l mt mu">element.onclick = () =&gt; { <br/>  //...<br/>};</span></pre><p id="e762" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们为DOM元素对象的<code class="fe mv mw mx mm b">onclick</code>方法设置了一个监听器函数。</p><p id="dd1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们做同样的事情。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/8d457a4c7ad632d91c7a26a3f50699a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CXKFn-3olSS9mDIV"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@heftiba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托阿·海夫蒂巴</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="35dd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="3e8a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用各种方式附加点击监听器，</p><p id="c1c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用<code class="fe mv mw mx mm b">this</code>在顶级方法中引用它自己。</p><p id="5472" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有很多工具可以为JavaScript应用编写和运行单元测试。</p></div></div>    
</body>
</html>