<html>
<head>
<title>Lazy Loading Images in React for Better Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中延迟加载图像以获得更好的性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lazy-loading-images-in-react-for-better-performance-5df73654ea05?source=collection_archive---------3-----------------------#2020-06-16">https://levelup.gitconnected.com/lazy-loading-images-in-react-for-better-performance-5df73654ea05?source=collection_archive---------3-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/15f45b43cea6e57a40cbb3e8db186df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7tyJK7OMnUVJfX8Z"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@filisantillan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Filiberto Santillán </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3ce5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些情况下，我们需要在一个页面上加载一个包含大量图像的列表。大部分的图片在加载时甚至在屏幕上看不到。我们需要向下滚动才能看到它们。默认情况下，当我们打开页面时，浏览器会加载并请求页面上的所有图像，不管它在视窗中是否可见。这在某些情况下完全没问题，但是当我们有很多在视口中不可见的图像并同时加载它们时，这可能会导致性能问题。</p><p id="6b91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，最好<strong class="ki iu">只</strong> <strong class="ki iu">加载</strong>视窗上<strong class="ki iu">出现的图像。它提高了性能，因为浏览器将延迟加载视口下方的图像，直到用户滚动页面并到达图像。</strong></p><h1 id="52bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我们开始吧</h1><p id="128d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有几种方法可以实现延迟加载，包括本地方法，但是当我写这篇文章时，本地延迟加载只在基于Chromium的浏览器和Firefox中受支持。所以为了更广泛的浏览器支持，我们将使用<code class="fe mh mi mj mk b">react-lazyload</code>和<code class="fe mh mi mj mk b">styled-components</code>进行延迟加载。您可以从安装这些软件包开始:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="83d9" class="mt lf it mk b gy mu mv l mw mx">npm install --save react-lazyload styled-components</span><span id="1fd1" class="mt lf it mk b gy my mv l mw mx">// or if you prefer yarn:</span><span id="ca56" class="mt lf it mk b gy my mv l mw mx">yarn add react-lazyload <!-- -->styled-components</span></pre><h1 id="a6bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建LazyImage组件</h1><p id="7c54" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们想延迟加载图像时，我们将使用这个组件。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">LazyImage组件</figcaption></figure><p id="c70a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">LazyImage组件包含<code class="fe mh mi mj mk b">ImageWrapper</code>、<code class="fe mh mi mj mk b">Placeholder</code>、<code class="fe mh mi mj mk b">LazyLoad</code>和<code class="fe mh mi mj mk b">StyledImage</code>。任何在<code class="fe mh mi mj mk b">LazyLoad</code>里面的东西直到它出现在视窗中才会被载入，这就是为什么我们把<code class="fe mh mi mj mk b">StyledImage</code>放在里面。</p><p id="e664" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Placeholder</code>只是一个空的<code class="fe mh mi mj mk b">div</code>，用动画表示图像仍在加载。当图像最终加载时，我们调用<code class="fe mh mi mj mk b">removePlaceholder</code>从DOM中移除<code class="fe mh mi mj mk b">Placeholder</code>。我使用<code class="fe mh mi mj mk b">refs</code>来做这件事，而不是更新状态，以防止不必要的重新渲染。如果你对React中的<code class="fe mh mi mj mk b">refs</code>不熟悉，你可以在这里了解更多<a class="ae kf" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4e89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在<code class="fe mh mi mj mk b">Placeholder</code>中创建微光或者设置旋转器，但是我在这里用动画背景使它变得简单。将<code class="fe mh mi mj mk b">Placeholder</code>尺寸设置为与图像尺寸相同，这样过渡会更平滑。在上面的例子中，<code class="fe mh mi mj mk b">Placeholder</code>和<code class="fe mh mi mj mk b">StyledImage</code>的大小将跟随<code class="fe mh mi mj mk b">ImageWrapper</code>的大小。</p><p id="903f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能想使用<code class="fe mh mi mj mk b">react-lazyload</code>占位符道具来放置<code class="fe mh mi mj mk b">Placeholder</code>,如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a2aa" class="mt lf it mk b gy mu mv l mw mx">&lt;LazyLoad placeholder={&lt;Placeholder /&gt;}&gt;<br/>  ...<br/>&lt;/LazyLoad&gt;</span></pre><p id="7b34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当我尝试这样做时，当我滚动页面时，即使图像还没有完全加载，当它到达视窗时,<code class="fe mh mi mj mk b">Placeholder</code>会立即消失，因此我把它放在外面并用<code class="fe mh mi mj mk b">onLoad</code>和<code class="fe mh mi mj mk b">onError</code>事件来管理它。</p><h1 id="3212" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让我们试试吧</h1><p id="d5fc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在App.js中，我们将使用来自<a class="ae kf" href="https://picsum.photos/" rel="noopener ugc nofollow" target="_blank"> Picsum Photos </a>的虚拟图像来演示和查看<code class="fe mh mi mj mk b">LazyImage</code>是如何工作的。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在App.js中使用LazyImage</figcaption></figure><p id="b256" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不建议对键使用索引，这也被认为是<a class="ae kf" href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" rel="noopener">反模式</a>。我在这个例子中这样做只是为了简单明了地关注延迟加载。</p><p id="0714" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行应用程序时，它看起来像这样:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/481e5119644df9826f8850e05da06a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/1*nIlHO2wlnSEI1TMX1OrC5A.gif"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">结果呢</figcaption></figure><p id="35c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您从上面的gif中看到的，图像直到出现在视窗中才会加载，这提高了性能并减少了带宽消耗。这种方法在服务器端渲染中也能很好地工作。</p><p id="0873" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您仍然可以通过在出现错误时添加不同的渲染元素/样式来改进它，或者在图像出现时创建淡入动画，我让您来尝试。</p><p id="5d1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我把代码放在Codesandbox上，你可以在这里尝试使用它。</p><p id="dcd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望这篇帖子对你有帮助！感谢阅读！</p></div></div>    
</body>
</html>