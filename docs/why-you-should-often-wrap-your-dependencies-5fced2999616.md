# 为什么您应该(经常)包装您的依赖项

> 原文：<https://levelup.gitconnected.com/why-you-should-often-wrap-your-dependencies-5fced2999616>

![](img/917f8f0e861073866e7cb3878d6e62d4.png)

一个好的包装器隐藏了最美味的实现细节

# 如何包装你的依赖将使你免于未来的痛苦

几个月前，我和团队中的一名开发人员聊天，不知怎么的，我们聊到了我认为我在过去几年中在我们公司学到的最多的东西。我已经做了 6 年的软件开发员，在 [Resource](http://www.resource.io) 工作了 2 年多。

“收起你的依赖吧，”我告诉我的同事，眼神有些憔悴，这是一个头发花白的老兵会有的表情。

尽管我已经写了五年多的软件，但直到最近我才学到这一课。在 Resource 工作之前，我在一家公司工作，在前端使用 Vue.js，在后端使用 Django。在那里工作期间，我主要处理来自 [PyPI](https://pypi.org/) 的依赖项，偶尔也会处理 [npm](https://www.npmjs.com/) 生态系统，以添加组件库或小型实用程序库。当我开始在 Resource 工作时，这一切都改变了。当我最初加入时，代码库是用 MeteorJS 编写的。在我开始之后不久，我们迁移到了 React/Node 堆栈。没过多久，我就意识到朋友和同事告诉我的关于 npm 包质量的很多事情都是真的:很多包都是垃圾。

从历史上看，我倾向于成为那种尽可能使用现有包的开发人员。我厌恶重新发明轮子，厌恶 NIH 综合症。然而，当我日复一日地在 npm 生态系统中工作时，这种态度无疑给我带来了一些痛苦。

在花费了比我自豪地承认的多得多的时间来应对这种痛苦之后，我们开始采用一种策略，这种策略将使我们免于许多痛苦:我们决定开始在我们的代码中包装第三方依赖。

> 注意:我在这篇文章中使用包装器这个词来描述一组设计模式，这些模式涉及到在代码和第三方依赖之间添加一些抽象。人们有时使用“适配器”或“外观”这样的词来表示带有某种意图的包装代码。这段代码需要调整它的参数来与其他代码交互吗，或者我在其他模块前面创建了一个门面来简化它的接口？当我在本文的其余部分提到“包装器”时，我将它作为一个包罗万象的术语，它包括了这些模式，并且不太担心意图。

# 设置

你第一次后悔没有包装你的依赖项可能会像下面这样。有一天，你需要一些你怀疑存在于第三方库中的通用功能。你尽职尽责地搜索 npm，直到找到一个库，比如 [*request*](https://www.npmjs.com/package/request) ，它提供了一个简单的 API 来进行 HTTP 请求。你把它加到你的项目里，并没有真正去思考它。

几个月或者几年后，不可思议的事情发生了；请求已被否决，没有计划添加任何新功能，也不保证会合并错误修复或安全补丁。

![](img/156a21e229e858eac8a7823a93a06fcb.png)

你读了你的图书馆后被弃用了

啊哦。这可不好。我想你最好找个替代品。你选择了一个似乎很流行的 HTTP 库， [*交叉获取*](https://www.npmjs.com/package/cross-fetch) 。

不幸的是，*请求*和*交叉获取*的 API 完全不同。*请求*对每个 HTTP 方法都有方便的方法，而*交叉获取*需要一个 url 和一个带有`method`键的配置对象。*请求*接受一个`json`参数，而*交叉获取*希望您在响应中调用`.json()`。这样的例子不胜枚举。

如果你有好的工具，并且没有对你的构建系统做任何疯狂的事情，这可能不是一个太困难的改变。你可以从某种形式的粗略查找和替换开始，然后开始手动检查所有你以前使用过*请求*的地方。在大型代码库中，这可能是一场噩梦，而且风险很大。

这是包装依赖关系的最好理由之一:它使得替换依赖关系变得更加容易。

## 两次进口的故事

现在想象一下，当您第一次决定需要一个 HTTP 库时，您用自己的模块包装了 *request* 库。你可以想象它看起来像下面这样。

起初，这看起来像是一个相当无用的模块。在功能上，它做同样的事情，但是现在不是在我们的代码库中写一个像`import request from 'request'`这样的导入，而是写`import myRequest from 'myrequest.js'`。

最终，当那一天到来时，您需要用*、*交叉获取来替换*请求*，现在您只需要在这一个文件中进行更改。您只需要修改*请求* API 接受的参数，并将它们转换成*交叉获取*期望的形状。以下要点显示了这可能是什么样子。

写那个代码肯定有点痛苦。但是这比试图找到代码库中所有发出 HTTP 请求的地方并更新它们以符合*交叉获取*的 API 要容易得多。也安全很多。

现在，您不仅能够在必要时(例如出于安全原因)替换这种依赖关系，而且还可以出于其他原因灵活地替换它。也许您发现这些代码路径中的一个对您的产品非常关键，而且太慢了。你去检查 npm，发现有一个执行得更好的抓取库，可以被交换进来。

或者，当库的维护者休假时，您可能会遇到一个 bug。理想情况下，您应该修复库本身源代码中的 bug，并向项目提交一个 pull 请求。但是如果您需要立即进行修复，您可以很容易地在包装器的源代码中对其进行修补。

然而，能够轻松替换第三方依赖并不是使用包装器带来的唯一好处。

## 当好的测试变坏时

在没有包装器的场景中，您可能会注意到在替换所有调用站点以使用*交叉获取* API 时的其他情况。您进行了更改，然后看到一堆测试中断。这是因为一堆测试在嘲笑*请求*依赖，但是现在正在尝试使用*交叉获取*。现在，您陷入了更新大量测试代码的困境，尽管您并没有改变发出 HTTP 请求的实际业务逻辑。

有一句谚语经常提到测试:不要嘲笑你不拥有的东西。这个想法是，如果你不维护某个东西的源代码，你就不应该嘲笑它。

通过在测试中嘲笑 *request* 库，这条格言被打破了，你正在为此付出代价。现在你必须去更新所有模拟*请求*的调用，而不是模拟*交叉获取*。呃。

在使用包装器的场景中，您可以通过简单地模仿包装器来避免这种痛苦。而不是如下所示的应用程序代码:

您只需在应用程序代码中引用包装器:

在测试中，您现在可以用类似于`jest.mock('./wrappers/request.js')`的语句模拟包装器。如果你采用这种方法，当用*请求*依赖关系替换*交叉获取*时，你不会破坏任何测试。

这应该会引起一些人的注意……如果你在嘲笑包装器，测试会不会检测不出包装器是否错误地将*请求* API 改编为*交叉获取* API？

没错。

这就是为什么您必须为包装器编写集成测试。理想情况下，您希望为包装器编写不模仿任何东西的测试，并验证用一个第三方实现替换另一个不会破坏任何东西。在某些情况下，这比其他情况更可行。当编写 HTTP 客户端包装器时，如本例所示，您可以使用类似于 [pollyjs](https://netflix.github.io/pollyjs/) 的东西来模仿 HTTP 层的一切，而不是模仿第三方依赖。

在嘲笑第三方依赖时，还有另一个更阴险的场景。想象一个没有包装器的场景，你已经模拟出了*请求*，而不是试图用*交叉获取*替换*请求*，你只是希望将*请求*从版本`2.81.0`升级到版本`2.82.0`。

你撞库，运行测试，一切都通过了。太好了！您合并代码并推向生产，只是为了看着一切都失控。

那是因为`2.82.0`引入了一个突破性的改变，但是因为你嘲笑了*请求*库，并且在测试中没有执行它的任何代码，所以它们成功通过了。

同样，这是一个可以通过包装依赖性并为包装器编写集成测试来避免的场景。在这种情况下，模仿包装器的测试会愉快地通过，而集成测试会由于突破性的改变而严重失败。

## 为了形成更完善的 API

使用包装器的一个难以量化的好处是，您可以根据应用程序的实际需求更准确地设计 API。尽管第三方依赖节省了实现时间，但它们不能代替设计。在许多情况下，第三方依赖者已经通过大量的实战测试发现了它的 API。但是您通常会发现，您的应用程序具体需要如何使用它，与库的设计略有不同。

让我们回过头来看看*请求*。对于这个例子，我们将了解如何设置一个需要指定不同代理配置集的抓取应用程序。

让我们假设您有许多想要使用的不同刮擦“配置文件”。每个配置文件都将配置一些东西，比如要使用的代理服务器、一些特定的 HTTP 头和一些特定的认证凭证。例如，您将有一个 US-EAST 配置文件，它需要一个用于该代理的特定授权头，还有一个 US-WEST 配置文件，它需要一个不同的授权头。

要求调用代码在任何需要发出 HTTP 请求的地方指定特定于配置文件的授权头并不理想。相反，您可以在包装文件中定义每个概要文件的名称和配置。然后您将修改包装 API 来接受一个`profile`参数。这样，每个调用站点都不需要担心 HTTP 头的具体细节，而是可以指定一个特定的配置文件来使用。

结果是一个更适合用例的 API，这意味着测试将更容易，并且对调用代码的修改应该耦合得更少。更好的是，系统有更清晰的边界，这样任何关于如何处理概要文件的实现问题都不会泄露到测试中。

# 只有西斯工程师处理绝对的事情

![](img/0c943e73b810d97a8448666b05e0eecc.png)

你要么和包装纸在一起，要么就是他们的敌人

当然，就像软件设计中的任何选择一样，使用包装器总会有所取舍。对于每一种情况，您都会想问自己几个问题，以确定为依赖关系构建包装器是否真的值得。

至少，添加包装器总是会增加额外的工作。有额外的间接性，现在开发人员不能只是去阅读依赖关系的文档来理解它是如何工作的。他们可能需要查看包装器的源代码，以真正理解包装器 API 提供了什么契约。好的工具可以帮你很多。使用一个全功能的 IDE 将会提供像带有参数和文档字符串的工具提示这样的东西。

添加包装器通常也需要添加更多的文档。因为您不直接处理第三方包，所以查看这些文档可能会产生误导，这取决于您的包装器中实现了什么。对于现代工具，我不认为这有什么大不了的。使用像 Typescript 或 Flow 这样的静态分析工具，将大大有助于告诉您是否试图做一些太愚蠢的事情。

正如我前面提到的，您总是希望确保测试这个包装器，这是添加到您的代码库的另一个负担。

那么这个负担什么时候不值得呢？我通常会问自己几个问题。

*这段代码与我的核心业务逻辑有多接近？使用这种依赖或包装的代码可能会改变吗，或者我的需求可能会改变吗？*

我对我所需要的 API 契约理解得越少，我就越不可能马上提交一个包装器。否则，当我发现我实际上需要完全不同的东西时，可能会有很多浪费的工作被扔掉。

*这是“商品”库吗？是否有其他库在相同的抽象层次上提供类似的服务？*

一般来说，一个图书馆越是“商品”，我就越有可能包装它。如果许多库在同一抽象层次上工作，很有可能它是大致正确的，包装将允许我替换或扩展抽象以适应我的应用程序。

*这是实施细节吗？这仅仅是对 Lodash 这样的函数库的数据操作调用吗？*

可能不值得包装。

*包装起来会不会太复杂/困难/不可行？*

对于像 ORM 这样的东西，我可能会通过试图包装一个现有的 ORM 来有效地实现一个内部 ORM。实际上，代码库很少决定用一个 ORM 替换另一个 ORM，所以好处很少。

*这是不是一个 API 客户端库，像 Github 的*[*octo kit*](https://github.com/octokit/rest.js/)*？*

选择在这里编写包装器取决于几个因素。以 octokit 为例，如果您计划支持多个 git 托管提供者，那么几乎可以肯定的是，您最好编写一个抽象，位于可以处理多个提供者的特定库之上。但是如果您只是使用一个库来获取数据，而没有更好的抽象，那么包装它可能是多余的。但是，包装它仍然可以防止您不小心嘲笑它和处理假阳性测试。

我想到的适合包装的例子有:日志记录、HTTP 请求、ui 元素/组件、通用字符串实用程序或事务性电子邮件发送。

> 您可能已经注意到，我建议包装“商品”库，比如进行 HTTP 调用，并且我还建议设计更多特定于应用程序的 API 作为包装的好处。我们如何包装一个相当通用的操作，同时使它的 API 更符合我们应用程序的需求呢？再加一层包装就行了！算是吧。如果您发现自己有一个不完全正确抽象的包装器 API，请随意将包装器下移。例如，如果您的应用程序有一个总是添加特定头的 HTTP 包装器，然后您发现在一个地方，您需要在没有那个头的情况下进行 HTTP 调用，那么从您的初始包装器中取出一个较低级别的包装器是完全可以的，它可以在不需要额外头的地方重用。重要的部分是确保您仍然只在一个地方导入第三方依赖项。

# "实施细节"

在我们的案例中，我们发现实现这一策略的最佳方式是利用 [yarn workspaces](https://yarnpkg.com/features/workspaces) 并构建提供清晰边界的内部包装器包。这使得它们易于打包并在我们维护的多个项目之间分发。

如果您不熟悉，yarn 工作区提供了一种在同一个存储库中轻松管理多个包的方法。即使您不打算将这些包发布到包注册中心，通过工作区加强一些隔离也有助于确保离散组件之间没有太多的耦合。

要开始使用 HTTP 包装器，我们所要做的就是向 monorepo 添加一个新的包:`@resource/http`。现在，我们只在想要进行 HTTP 调用的地方导入`@resource/http`。如果我们再次发现自己需要为不同的 HTTP 库交换实现，而不是必须到处更新调用点，我们只需要更新`@resource/http`来强制我们的包装 API 到新交换的实现。这也意味着我们可以编写模拟`@resource/http`的测试，我们不必担心 API 签名会改变，因为我们控制着它。

这里重要的是，我们有自由和控制权来修补、修复、替换和改变我们进行 HTTP 调用的方式，而不必修改我们代码库中的所有调用站点。

# 就这样结束了

尽管您不应该总是包装您的依赖项，但是在编写代码时，您应该使用您的判断来确定这是否是正确的步骤。在决定我是否应该包装一些东西时，我总是问自己:

*   这是一个“商品”图书馆吗？
*   我是否很好地理解了我的应用程序需要什么样的抽象？
*   我能确定这种依赖不是太耦合或者太多的实现细节吗？

如果我可以自信地对这三个问题回答是，这是一个很好的指标，包装的额外工作将是值得的。