<html>
<head>
<title>Code to Interface: An Example in Laravel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码到接口:Laravel中的一个例子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/code-to-interface-an-example-in-laravel-a8a5ec0a859b?source=collection_archive---------6-----------------------#2020-05-27">https://levelup.gitconnected.com/code-to-interface-an-example-in-laravel-a8a5ec0a859b?source=collection_archive---------6-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f623" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">接口代码指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a9683417a990b5c6d7ebe5d8a056ab3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S4AANWhfeBADk_4J.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用<a class="ae ky" href="https://carbon.now.sh" rel="noopener ugc nofollow" target="_blank">碳</a>制作的图像</figcaption></figure><p id="d7c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口代码是编程中使用的一种技术，在这种技术中，您基于抽象(接口)而不是具体(类)来构建应用程序。</p><p id="f58a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一名程序员，那么你可能听说过这样的短语，如<strong class="lb iu">代码到接口，而不是实现</strong>，<strong class="lb iu">程序到接口</strong>，<strong class="lb iu">使用抽象而不是具体化</strong>等等。</p><p id="4fbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">都是指同一件事。我们应该以这样一种方式编码我们的应用程序，它应该依赖于抽象(接口)而不是具体化(类)。</p><h1 id="9ded" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么？</h1><p id="f94d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是我第一次听到这个短语时的确切反应。为什么我要使用接口而不是类？即使我创建了一个接口，我也需要创建一个实现该接口的类。这不是浪费时间吗？</p><p id="f479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然<strong class="lb iu">没有</strong>！</p><p id="74da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个世界上唯一不变的是变化本身，或者换句话说，<strong class="lb iu">变化</strong>是唯一不变的<strong class="lb iu"/>。</p><p id="0809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编程的情况下，这个规则也没有例外。业务需求随着时间而变化，我们的代码也是如此。</p><p id="f8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们的代码必须灵活。</p><p id="8c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码到接口使我们的代码松散耦合且灵活。</p><h1 id="b7a9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">怎么会？</h1><p id="7e87" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">考虑下面的代码示例。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1067" class="mx lw it mt b gy my mz l na nb">class Logger {<br/><br/>    public function log($content) <br/>    {<br/>        //Logs content to file.<br/>        echo "Log to file";<br/>    }<br/>}</span></pre><p id="17e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的类，将内容记录到一个文件中。我们可以在控制器中使用它。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="59e0" class="mx lw it mt b gy my mz l na nb">class LogController extends Controller<br/>{<br/>    public function log()<br/>    {<br/>        $logger = new Logger;<br/>        $logger-&gt;log('Log this');<br/>    }<br/>}</span></pre><p id="c789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们想登录多个目标，如<code class="fe nc nd ne mt b">db</code>、<code class="fe nc nd ne mt b">file</code>、<code class="fe nc nd ne mt b">cloud</code>等，该怎么办呢？</p><p id="f0ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以改变我们的<code class="fe nc nd ne mt b">LogController</code>类和<code class="fe nc nd ne mt b">Logger</code>类来适应这些变化。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0898" class="mx lw it mt b gy my mz l na nb">class Logger {<br/><br/>    public function logToDb($content) <br/>    {<br/>        //Logs content to db.<br/>    }<br/><br/>    public function logToFile($content) <br/>    {<br/>        //Logs content to file.<br/>    }<br/><br/>    public function logToCloud($content) <br/>    {<br/>        //Logs content to cloud.<br/>    }<br/>    <br/>}</span></pre><p id="7e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe nc nd ne mt b">LogController</code>改为</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ffd0" class="mx lw it mt b gy my mz l na nb">class LogController extends Controller<br/>{<br/>    public function log()<br/>    {<br/>        $logger = new Logger;<br/><br/>        $target = config('log.target');<br/><br/>        if ($target == 'db') {<br/>            $logger-&gt;logToDb($content);<br/>        } elseif ($target == 'file') {<br/>            $logger-&gt;logToFile($content);<br/>        } else {<br/>            $logger-&gt;logToCloud($content);<br/>        }<br/>    }<br/>}</span></pre><p id="f3b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们可以登录不同的目标了。但是，如果我们想向一个<code class="fe nc nd ne mt b">redis</code>服务器添加另一个目标，比如log，该怎么办呢？我们将最终修改<code class="fe nc nd ne mt b">Logger</code>类和<code class="fe nc nd ne mt b">LogController</code>类。</p><p id="50c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，这很快脱离了我们的控制，代码变得混乱。<code class="fe nc nd ne mt b">Logger</code>级很快成为一个庞然大物。这是一场噩梦。</p><p id="2eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们需要分东西。遵循坚实的原则，我们可以将责任转移到相应的类中。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4dde" class="mx lw it mt b gy my mz l na nb">class DBLogger<br/>{<br/>    public function log()<br/>    {<br/>        //log to db<br/>    }<br/>}<br/><br/>class FileLogger<br/>{<br/>    public function log()<br/>    {<br/>        //log to file<br/>    }<br/>}<br/><br/>class CloudLogger<br/>{<br/>    public function log()<br/>    {<br/>        //log to cloud<br/>    }<br/>}</span></pre><p id="21a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且控制器被改变为</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4e9e" class="mx lw it mt b gy my mz l na nb">class LogController extends Controller<br/>{<br/>    public function log()<br/>    {<br/>        $target = config('log.target');<br/><br/>        if ($target == 'db') {<br/>            (new DBLogger)-&gt;log($content);<br/>        } elseif ($target == 'file') {<br/>            (new FileLogger)-&gt;log($content);<br/>        } else {<br/>            (new CloudLogger)-&gt;log($content);<br/>        }<br/>    }<br/>}</span></pre><p id="804a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了。现在，如果我们想为日志添加其他目标，我们可以创建一个新的类，并将其添加到控制器中的<code class="fe nc nd ne mt b">if-else</code>。</p><p id="651a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们的控制器负责选择一个记录器。对于控制器来说，它不需要知道不同的记录器并在它们之间进行选择。它只需要一个带有<code class="fe nc nd ne mt b">log()</code>方法的logger类来记录内容。</p><h1 id="ef25" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">胜利的界面</h1><p id="5796" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是使用接口的恰当情况。那么什么是<a class="ae ky" href="https://www.cs.utah.edu/~germain/PPS/Topics/interfaces.html" rel="noopener ugc nofollow" target="_blank">接口</a>？</p><blockquote class="nf"><p id="647b" class="ng nh it bd ni nj nk nl nm nn no lu dk translated"><em class="np">接口是一个对象可以做的动作的描述。</em></p></blockquote><p id="ba1a" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">回到我们的例子，控制器只需要一个带有<code class="fe nc nd ne mt b">log()</code>方法的logger类。所以我们的接口必须描述它必须有一个<code class="fe nc nd ne mt b">log()</code>动作。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ffa0" class="mx lw it mt b gy my mz l na nb">interface Logger<br/>{<br/>    public function log($content);<br/>}</span></pre><p id="0b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，它只包含函数声明，而不包含它的实现，这就是它被称为<code class="fe nc nd ne mt b">abstraction</code>的原因。</p><p id="b873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现接口时，实现接口的类必须提供接口中定义的抽象方法的实现细节。</p><p id="5031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，任何实现了<code class="fe nc nd ne mt b">Logger</code>接口的类都必须提供抽象方法<code class="fe nc nd ne mt b">log()</code>的实现细节。</p><p id="e727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以在控制器中输入这个接口的类型提示。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b807" class="mx lw it mt b gy my mz l na nb">class LogController extends Controller<br/>{<br/>    public function log(Logger $logger)<br/>    {<br/>        $logger-&gt;log($content);<br/>    }<br/>}</span></pre><p id="5e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在控制器不关心哪种类型的记录器被传递给它。它只需要知道它必须实现<code class="fe nc nd ne mt b">Logger</code>接口。</p><p id="3348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们需要修改我们的日志类来实现这个接口。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9b90" class="mx lw it mt b gy my mz l na nb">class DBLogger implements Logger<br/>{<br/>    public function log()<br/>    {<br/>        //log to db<br/>    }<br/>}<br/><br/>class FileLogger implements Logger<br/>{<br/>    public function log()<br/>    {<br/>        //log to file<br/>    }<br/>}<br/><br/>class CloudLogger implements Logger<br/>{<br/>    public function log()<br/>    {<br/>        //log to cloud<br/>    }<br/>}</span></pre><p id="bed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以在不接触现有代码的情况下添加更多的记录器。我们所要做的就是创建一个实现我们的<code class="fe nc nd ne mt b">Logger</code>接口的新类。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c70e" class="mx lw it mt b gy my mz l na nb">class RedisLogger implements Logger<br/>{<br/>    public function log()<br/>    {<br/>        //log to redis<br/>    }<br/>}</span></pre><p id="485d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的代码现在是灵活和松散耦合的。我们可以在任何时候交换实现，而不需要修改现有的代码。</p><h1 id="6042" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">依赖注入</h1><p id="3985" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当使用像Laravel这样的框架时，我们可以利用它的<a class="ae ky" href="https://laravel.com/docs/7.x/container" rel="noopener ugc nofollow" target="_blank">服务容器</a>来自动注入接口的实现。</p><p id="a311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Laravel支持<a class="ae ky" href="https://laravel.com/docs/7.x/controllers#dependency-injection-and-controllers" rel="noopener ugc nofollow" target="_blank">方法注入</a>开箱即用，我们只需要<a class="ae ky" href="https://laravel.com/docs/7.x/container#binding-interfaces-to-implementations" rel="noopener ugc nofollow" target="_blank">将接口绑定到它的实现</a>。</p><p id="a8c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要为记录器创建一个配置文件。所以创建一个文件<code class="fe nc nd ne mt b">config/log.php</code></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ce6d" class="mx lw it mt b gy my mz l na nb">&lt;?php<br/><br/>return [<br/>    'default' =&gt; env('LOG_TARGET', 'file'),<br/><br/>    'file' =&gt; [<br/>        'class' =&gt; App\Log\FileLogger::class,<br/>    ],<br/><br/>    'db' =&gt; [<br/>        'class' =&gt; App\Log\DBLogger::class,<br/>    ],<br/><br/>    'redis' =&gt; [<br/>        'class' =&gt; App\Log\RedisLogger::class,<br/>    ]<br/>];</span></pre><p id="6dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且在你的<code class="fe nc nd ne mt b">AppServiceProvider.php</code>里面<code class="fe nc nd ne mt b">app/Providers</code>添加下面的代码。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="22ca" class="mx lw it mt b gy my mz l na nb">class AppServiceProvider extends ServiceProvider<br/>{<br/>    public function register()<br/>    {<br/>        $default = config('log.default');<br/>        $logger = config("log.{$default}.class");<br/><br/>        $this-&gt;app-&gt;bind(<br/>            App\Contracts\Logger::class, // the logger interface<br/>            $logger<br/>        );<br/>    }<br/>}</span></pre><p id="f38b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它从配置文件中读取默认日志，并将其绑定到<code class="fe nc nd ne mt b">Logger</code>接口。因此，每当我们请求<code class="fe nc nd ne mt b">Logger</code>接口时，容器都会解析它并返回默认的logger实例。</p><p id="eb10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于默认的记录器是使用<code class="fe nc nd ne mt b">env()</code>助手指定的，我们可以在不同的环境中使用不同的记录器，比如在<code class="fe nc nd ne mt b">local</code>环境中的<code class="fe nc nd ne mt b">file</code>和在<code class="fe nc nd ne mt b">production</code>环境中的<code class="fe nc nd ne mt b">db</code>。</p><h1 id="d95b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="c206" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接口允许我们创建松散耦合的代码，同时提供一定程度的抽象。它允许我们在任何时候改变我们的实现，而不改变它们被使用的上下文。因此，请始终将应用程序中的所有可变部分编码到一个接口中。</p><h1 id="b13e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ol class=""><li id="4176" class="nv nw it lb b lc mn lf mo li nx lm ny lq nz lu oa ob oc od bi translated"><a class="ae ky" href="https://www.php.net/manual/en/language.oop5.interfaces.php" rel="noopener ugc nofollow" target="_blank">接口</a></li><li id="2682" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><a class="ae ky" href="https://laravel.com/docs/7.x/container" rel="noopener ugc nofollow" target="_blank">服务容器</a></li></ol></div></div>    
</body>
</html>