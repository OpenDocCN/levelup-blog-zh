<html>
<head>
<title>Naive Pattern Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朴素模式搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/naive-pattern-search-78bb4a8b8315?source=collection_archive---------11-----------------------#2020-04-12">https://levelup.gitconnected.com/naive-pattern-search-78bb4a8b8315?source=collection_archive---------11-----------------------#2020-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d5be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">简单模式搜索</strong>是一种在字符串中搜索特定模式或子字符串的方法。它通过检查模式字符串中的所有字符来做到这一点。在本文中，我们探索了一种使用JavaScript实现它的方法。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="5cda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们想找出一个模式在一个字符串中出现的次数。我们的函数必须接受两个参数:我们要搜索的<strong class="jp ir">字符串</strong>和我们要在主字符串中搜索的由<strong class="jp ir">模式</strong>组成的字符串。设置为计数器的变量也需要在函数的开头定义。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/cf78706cb738a868ef8d1813bb77b0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*ZtebT8BOiEn6aG6dMPoUBg.png"/></div></figure><p id="0eac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从迭代第一个字符串开始，在这个循环中，我们将迭代第二个字符串(模式)。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi la"><img src="../Images/a5a7d63f1486603ac9bc177a9082c473.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*-C_peYtSDYvtoLI-RqkfJQ.png"/></div></figure><p id="26e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个<em class="lb"> for </em>循环的目的是遍历我们的模式，逐个字母地比较，看它是否与字符串匹配。我们从字符串的第一个字符开始。如果它确实匹配我们模式的第一个字符，我们就继续。这个想法是不断检查，直到满足两个条件:</p><ol class=""><li id="c676" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">字符不匹配，在这种情况下，我们将不得不跳出循环，继续前进到字符串的下一个字符(由于字符不匹配，这次迭代将不会产生我们的模式的一个实例)。</li><li id="8dfe" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">我们已经达到了模式的长度，因此所有的字符都匹配，我们在字符串中找到了模式的一个实例。在这种情况下，我们将增加我们的计数器。</li></ol><p id="3bef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是逻辑的样子:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/d8567e47294cb86a2a480503132138d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*A78tL549wj7FZH7-W7eVVw.png"/></div></figure><p id="4050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里开始，我们可以简单地在函数的末尾返回计数器，给出模式在字符串中出现的次数。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/522df319e8f8bc65fefd73705e225831.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*6QHFhWHMM2JdUBGBqN1EUw.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">我们天真的搜索功能</figcaption></figure><p id="f614" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数的时间复杂度是O( <em class="lb"> n * m </em>，其中<em class="lb"> n </em>是字符串的长度，<em class="lb"> m </em>是模式的长度。此外，该函数假设模式的长度小于字符串的长度。如果我们想检查边缘情况，我们必须检查以确保模式的长度确实小于函数开头的字符串的长度。</p></div></div>    
</body>
</html>