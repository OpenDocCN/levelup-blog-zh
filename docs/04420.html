<html>
<head>
<title>JavaScript Best Practices — Objects, Functions, and Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—对象、函数和数组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-objects-functions-and-arrays-44ea9cc67096?source=collection_archive---------12-----------------------#2020-06-25">https://levelup.gitconnected.com/javascript-best-practices-objects-functions-and-arrays-44ea9cc67096?source=collection_archive---------12-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/10bbeef68a4a3ab4426dc2d28e506fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i8bT-vkiVUseV0sr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@lastnameeaster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉-Rel复活节</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="00e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="f35f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象和类中的Getter和Setter对</h1><p id="5d77" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的对象中应该有getter和setter对。</p><p id="01e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有getters，属性就无法读取，所以就不用了。</p><p id="2f5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="88f9" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  set a(value) {<br/>    this.val = value;<br/>  }<br/>};</span></pre><p id="e21d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ea8c" class="mq lf it mm b gy mr ms l mt mu">const obj = {<br/>  set a(value) {<br/>    this.val = value;<br/>  },</span><span id="09de" class="mq lf it mm b gy mv ms l mt mu">  get a() {<br/>    return this.val;<br/>  }<br/>};</span></pre><h1 id="cb6d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在开始后和结束数组括号前换行</h1><p id="84b5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在左括号和右括号前换行。</p><p id="bbea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于长数组，使用它们会更清楚</p><p id="2390" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="70da" class="mq lf it mm b gy mr ms l mt mu">const arr= [1, 2, 3, 4, 5];</span></pre><p id="6985" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="91e8" class="mq lf it mm b gy mr ms l mt mu">const arr = [<br/>  1, 2, 3, 4, 5<br/>];</span></pre><h1 id="ff90" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">括号内的空格</h1><p id="7bf4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在括号内不加空格。</p><p id="2368" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="07ae" class="mq lf it mm b gy mr ms l mt mu">const arr = ['foo', 'bar'];</span></pre><p id="fdbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且读起来很清楚。</p><h1 id="9c8f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数组方法回调中的Return语句</h1><p id="97b4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们总是需要在数组方法中返回一些东西。</p><p id="2122" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法有<code class="fe mw mx my mm b">reduce</code>、<code class="fe mw mx my mm b">Array.from</code>、<code class="fe mw mx my mm b">filter</code>、<code class="fe mw mx my mm b">map</code>、<code class="fe mw mx my mm b">some</code>、<code class="fe mw mx my mm b">every</code>等。在方法中返回东西。</p><p id="917d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="333f" class="mq lf it mm b gy mr ms l mt mu">const indexes = arr.reduce((foo, item, index) =&gt; {<br/>  foo[item] = index;<br/>}, {});</span></pre><p id="6a2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="80b2" class="mq lf it mm b gy mr ms l mt mu">const foo = Array.from(elements, (element) =&gt; {<br/>  if (element.tagName === "DIV") {<br/>    return true;<br/>  }<br/>});</span></pre><p id="7798" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b39b" class="mq lf it mm b gy mr ms l mt mu">const sum = arr.reduce((a, b) =&gt; a + b, 0);</span></pre><p id="d1c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mw mx my mm b">reduce</code>返回值的组合结果。</p><p id="16c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7a35" class="mq lf it mm b gy mr ms l mt mu">const foo = Array.from(elements, (element) =&gt; {<br/>  if (element.tagName === "DIV") {<br/>    return true;<br/>  }<br/>  return false;<br/>});</span></pre><p id="7f5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像<code class="fe mw mx my mm b">forEach</code>这样的一些方法不需要返回一些东西，因为我们不能对返回值做太多事情。</p><p id="349a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们可以提前返回到下一个迭代:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1aa8" class="mq lf it mm b gy mr ms l mt mu">arr.forEach((item) =&gt; {<br/>  if (item &lt; 0) {<br/>    return;<br/>  }<br/>  doSomething(item);<br/>});</span></pre><h1 id="7df9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数组元素之间的换行符</h1><p id="4944" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在数组中放置长表达式。</p><p id="b184" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="399e" class="mq lf it mm b gy mr ms l mt mu">const arr = [<br/>  function foo() {<br/>    doWork();<br/>  },<br/>  function bar() {<br/>    doWork();<br/>  }<br/>];</span></pre><p id="c33c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有两个很长的函数，所以我们把它们放在自己的行中。</p><h1 id="6d44" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">箭头函数体中的大括号</h1><p id="1741" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">箭头函数体中的大括号有助于增加清晰度。</p><p id="1091" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ae9f" class="mq lf it mm b gy mr ms l mt mu">const foo = () =&gt; {<br/>  return 0;<br/>};</span></pre><p id="c98b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="39b5" class="mq lf it mm b gy mr ms l mt mu">const foo = () =&gt; 0;</span></pre><p id="423a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道我们肯定会用关键字<code class="fe mw mx my mm b">return</code>返回一些东西。</p><h1 id="2579" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">箭头函数参数中的括号</h1><p id="9772" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">括号对于分隔参数很有用。</p><p id="26ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="43dc" class="mq lf it mm b gy mr ms l mt mu">(a) =&gt; {}</span></pre><p id="ee28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使读取参数更容易。</p><h1 id="54e7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">箭头函数的箭头之前或之后的空格</h1><p id="1bc4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该在箭头函数的箭头之间放置空格。</p><p id="f4b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9717" class="mq lf it mm b gy mr ms l mt mu">(a)=&gt;{}</span></pre><p id="9776" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7bce" class="mq lf it mm b gy mr ms l mt mu">a=&gt; a;</span></pre><p id="c709" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="053d" class="mq lf it mm b gy mr ms l mt mu">(a) =&gt; {}</span></pre><h1 id="cb66" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将变量视为块范围</h1><p id="f988" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们使用<code class="fe mw mx my mm b">var</code>来声明变量，它们应该被用作块范围的变量。</p><p id="04f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7a53" class="mq lf it mm b gy mr ms l mt mu">function doIf() {<br/>  if (true) {<br/>    var build = true;<br/>  }</span><span id="e5ea" class="mq lf it mm b gy mv ms l mt mu">  console.log(build);<br/>}</span></pre><p id="135c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0477" class="mq lf it mm b gy mr ms l mt mu">function doIfElse() {<br/>  if (true) {<br/>    var build = true;<br/>  } else {<br/>    var build = false;<br/>  }<br/>}</span></pre><p id="5b28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="70de" class="mq lf it mm b gy mr ms l mt mu">const doIf = () =&gt; {<br/>  var build;</span><span id="884b" class="mq lf it mm b gy mv ms l mt mu">  if (true) {<br/>    build = true;<br/>  }</span><span id="b5b8" class="mq lf it mm b gy mv ms l mt mu">  console.log(build);<br/>}</span></pre><p id="526a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c2a4" class="mq lf it mm b gy mr ms l mt mu">const doIfElse = () =&gt; {<br/>  var build;</span><span id="11d1" class="mq lf it mm b gy mv ms l mt mu">  if (true) {<br/>    build = true;<br/>  } else {<br/>    build = false;<br/>  }<br/>}</span></pre><p id="b2d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该使用<code class="fe mw mx my mm b">var</code>的非块范围特性，比如在函数的块外提升或访问<code class="fe mw mx my mm b">var</code>变量。</p><p id="b6e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们只是欺骗了很多人。</p><h1 id="a3b2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">打开块之后和关闭块之前块内部的空间</h1><p id="c302" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最好在块内留有空格，以便于阅读。</p><p id="05bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cb3f" class="mq lf it mm b gy mr ms l mt mu">function foo() {return false;}</span></pre><p id="a650" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="96c1" class="mq lf it mm b gy mr ms l mt mu">function foo() { return false; }</span></pre><p id="64b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开头和结尾留有空格会更清晰。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/ad04e057508f4446c151f2a04d421ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wAEIBdADU2JjV8lE"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@egnaro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">里克·梅森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="b9f3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="c069" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">单个空格和额外的行有利于可读性。</p><p id="ea35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该按照预期的方式使用数组方法。</p></div></div>    
</body>
</html>