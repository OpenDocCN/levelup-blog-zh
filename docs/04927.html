<html>
<head>
<title>C++ Detection Idiom explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++检测习语解释道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-detection-idiom-explained-5cc7207a0067?source=collection_archive---------2-----------------------#2020-07-24">https://levelup.gitconnected.com/c-detection-idiom-explained-5cc7207a0067?source=collection_archive---------2-----------------------#2020-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b1af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍流行的元编程模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2b281de8de7ea9885321e714a3c1e4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8PGd8DJ6RZGoMNMJEiTX6w.jpeg"/></div></figure><h1 id="5fa8" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">介绍</h1><p id="d3ba" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">模板是一个有用的特性，通过它我们可以定义一个通用的函数或者一个通用的类，它可以用于不同的类型。在你可以用模板做的所有其他很酷的事情中，有一个流行的模板技术叫做“检测习语”。</p><p id="3688" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">检测习语是一种带有模板的模式，可以在编译时检测特定表达式对于给定类型是有效的还是格式不良的。人们经常用它来有选择地在模板函数的不同实现之间进行选择。例如，假设你正在开发一个库，你有一个函数可以创建一个给定参数的副本，并对它进行如下处理。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="54b3" class="mo kr it mk b gy mp mq l mr ms">template &lt;class T&gt;<br/>void Func(const T&amp; arg) {<br/>  // 1. Create a copy of arg.<br/>  T copy(arg);</span><span id="092c" class="mo kr it mk b gy mt mq l mr ms">  // 2. Do some process with the copy.<br/>}</span></pre><p id="9521" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">作为库开发人员，您希望该函数的用户能够将它用于任何类型，因此您将它定义为模板函数。到目前为止一切看起来都很好。</p><p id="3ecb" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">然而，在你发布了这个库之后，你意识到有些类型定义了一个特殊的<code class="fe mu mv mw mk b">Clone()</code>函数，在创建类型的副本时应该使用这个函数，而不是像函数中的<code class="fe mu mv mw mk b">T copy(arg)</code>那样使用它的复制构造函数。下面的代码详细描述了它。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="1619" class="mo kr it mk b gy mp mq l mr ms">class Foo {<br/> public:<br/>  Foo * Clone() const {   <strong class="mk iu">// User defined special clone function.</strong><br/>    return new Foo(*this);<br/>  }<br/>};</span><span id="4e58" class="mo kr it mk b gy mt mq l mr ms">int main() {<br/>  Foo foo;<br/>  Func(foo); <strong class="mk iu">// When the template function is instantiated with  <br/>             // type Foo, It should use Foo::Clone() to copy itself.<br/>  </strong>return 0;<br/>}</span></pre><p id="5932" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">所以我们需要让编译器选择使用<code class="fe mu mv mw mk b">Clone()</code>函数的<code class="fe mu mv mw mk b">Func(const T&amp; arg)</code>的不同实现，如果给定类型有函数的话。下面是解释问题的伪代码。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0b0c" class="mo kr it mk b gy mp mq l mr ms"><strong class="mk iu">//// What we want to do in pseudocode ////</strong></span><span id="f5f0" class="mo kr it mk b gy mt mq l mr ms"><strong class="mk iu">// For the type without Clone() function.</strong><br/>template &lt;class T&gt;<br/>void Func(const T&amp; arg) {<br/>  <strong class="mk iu">T copy(arg);</strong></span><span id="26ee" class="mo kr it mk b gy mt mq l mr ms">// 2. Do some process with the copy.<br/>}</span><span id="2072" class="mo kr it mk b gy mt mq l mr ms"><strong class="mk iu">// For the type with Clone() function.</strong><br/>template &lt;class T&gt;<br/>void Func(const T&amp; arg) {<br/>  <strong class="mk iu">T * copy = arg.Clone();</strong></span><span id="aeda" class="mo kr it mk b gy mt mq l mr ms">// 2. Do some process with the copy.<br/>}</span></pre><p id="1f19" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这个问题的解决方案大体上可以分为两步。</p><ol class=""><li id="e127" class="mx my it lk b ll me lo mf lr mz lv na lz nb md nc nd ne nf bi translated">检查给定类型是否有<code class="fe mu mv mw mk b">Clone()</code>功能。</li><li id="cff0" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nc nd ne nf bi translated">根据第一步的结果，让编译器选择合适的<code class="fe mu mv mw mk b">Func(const T &amp;arg)</code>实现。</li></ol><h1 id="f01c" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">第一步。检查给定类型是否具有<code class="fe mu mv mw mk b">Clone()</code>功能。</h1><p id="1d4b" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现第一步，我们可以使用“检测习语”。正如我之前所写的，检测习语是一种带有模板的模式，可以检测编译时特定表达式对于给定类型是有效的还是格式不良的。检测习语的实现经常利用SFINAE规则。</p><p id="0d19" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们看看如何将习语应用到我们的案例中。下面的代码是检测习语的实现。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="f385" class="mo kr it mk b gy mp mq l mr ms">template &lt;class T1, class T2 = void&gt;<br/>struct HasClone : false_type {};</span><span id="1355" class="mo kr it mk b gy mt mq l mr ms">template &lt;class T1&gt;<br/>struct HasClone&lt;T1, std::void_t&lt;decltype(std::declval&lt;T1&gt;().Clone())&gt;&gt; : true_type {};</span><span id="6c07" class="mo kr it mk b gy mt mq l mr ms"><br/>// Simplified definition!<br/>struct false_type {<br/>    static constexpr bool value = false;<br/>};</span><span id="58ed" class="mo kr it mk b gy mt mq l mr ms">struct true_type {<br/>    static constexpr bool value = true;<br/>};</span></pre><p id="c5c6" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这里，我们定义了一个名为<code class="fe mu mv mw mk b">HasClone</code>的模板类(struct)。第一个定义是<code class="fe mu mv mw mk b">HasClone</code>的主模板定义。它需要2个模板参数T1，T2和T2有一个默认参数<em class="nl"> void </em>。它继承自具有静态成员变量<em class="nl">值</em>的false_type，其中类型<em class="nl"> bool </em>被初始化为<em class="nl"> false </em>。</p><p id="3b77" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">第二种定义是部分专门化的定义，只把T1作为一个参数。它继承自true_type⁴，具有静态成员变量<em class="nl">值</em>，类型<em class="nl"> bool </em>初始化为<em class="nl"> true </em>。</p><p id="bd8c" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这里，我们想要实现的是让编译器选择</p><ul class=""><li id="e6dd" class="mx my it lk b ll me lo mf lr mz lv na lz nb md nm nd ne nf bi translated">如果给定类型不具有<code class="fe mu mv mw mk b">Clone()</code>功能，那么<code class="fe mu mv mw mk b">HasClone</code>的第一个(主要)定义<code class="fe mu mv mw mk b">HasClone::value</code>为<em class="nl">假</em></li><li id="5d99" class="mx my it lk b ll ng lo nh lr ni lv nj lz nk md nm nd ne nf bi translated">第二个定义如果给定类型有<code class="fe mu mv mw mk b">Clone()</code>功能。因此，<code class="fe mu mv mw mk b">HasClone::value</code>是<em class="nl">真</em></li></ul><p id="c201" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这样，我们可以稍后使用编译时间常数<code class="fe mu mv mw mk b">HasClone::value</code>来选择性地选择不同的<code class="fe mu mv mw mk b">Func()</code>实现(第二步，稍后描述)。</p><p id="422c" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如果你看一下<code class="fe mu mv mw mk b">HasClone</code>的第二个定义，第二个参数被指定为<code class="fe mu mv mw mk b">std::void_t&lt;decltype(std::declval&lt;T1().Clone())&gt;</code>。</p><p id="d457" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们一步一步地调查它。首先，<code class="fe mu mv mw mk b">std::void_t</code> ⁵是一个别名模板，它将任何给定的类型序列映射到一个类型void。可以实现如下。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="2f53" class="mo kr it mk b gy mp mq l mr ms">template&lt; class... &gt;<br/>using void_t = void;</span></pre><p id="f28e" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">乍一看，它似乎很没用。对于任何给定的类型，<code class="fe mu mv mw mk b">void_t&lt;class...&gt;</code>只是变成void类型(<code class="fe mu mv mw mk b">class...</code>是可变template⁶参数的表达式，允许任意数量的模板参数)。但是，当与SFINAE规则结合使用时，它会非常有用。</p><p id="5230" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这里的关键点是，无论给定的类型是什么，都必须是格式良好的，才能使<code class="fe mu mv mw mk b">void_t&lt;class...&gt;</code>本身成为格式良好的别名(在这种情况下，对于类型<em class="nl"> void </em>)。如果任何一个给定的类型是错误的，别名<code class="fe mu mv mw mk b">void_t&lt;class...&gt;</code>本身也是错误的。</p><p id="c955" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">同时，SFINAE规则允许编译器在用给定类型替换模板参数后，忽略包含不良表达式的模板类/函数。</p><p id="c8f3" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">在典型的检测习语实现中，它利用<code class="fe mu mv mw mk b">void_t&lt;class...&gt;</code>的行为和SFINAE规则，让编译器在不满足某个条件时忽略某个模板。</p><p id="4d98" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">在我们的例子中，如果给定的类型没有<code class="fe mu mv mw mk b">Clone()</code>函数，我们需要让编译器忽略第二个<code class="fe mu mv mw mk b">HasClone</code>定义，并让它选择主模板定义。</p><p id="fd17" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">接下来，让我们看看<code class="fe mu mv mw mk b">void_t&lt;class...&gt;.</code>的论证</p><p id="9a1c" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如您所见，<code class="fe mu mv mw mk b">decltype(std::declval&lt;T1&gt;().Clone())</code>被指定为<code class="fe mu mv mw mk b">void_t&lt;class...&gt;</code>的模板参数。std::declval⁷是模板元编程中经常使用的函数模板。它返回一个给定类型的引用，所以不用实际创建一个对象，你可以假设你有一个给定类型的对象。在这种情况下，它用于形成调用给定类型的<code class="fe mu mv mw mk b">Clone()</code>成员函数的表达式。decltype⁸是返回表达式或实体类型的关键字。在这种情况下，它试图返回给定类型的<code class="fe mu mv mw mk b">Clone()</code>成员函数的返回类型。</p><p id="0f8d" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在，让我们看看当我们给<code class="fe mu mv mw mk b">HasClone</code>模板一个具体类型时会发生什么。基本上有两种情况。(1)给定类型有<code class="fe mu mv mw mk b">Clone()</code> , (2)给定类型没有<code class="fe mu mv mw mk b">Clone()</code>。</p><p id="5632" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">让我们先看看情况(2 ),因为它更容易理解。</p><p id="6ee5" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如果给定的类型没有<code class="fe mu mv mw mk b">Clone()</code>函数，<code class="fe mu mv mw mk b">std::declval&lt;T1&gt;().Clone()</code>就会变成病态。<code class="fe mu mv mw mk b">decltype(std::declval&lt;T1&gt;().Clone())</code>也是如此，因此我们可以使<code class="fe mu mv mw mk b">void_t&lt;class...&gt;</code>的模板参数格式不良。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="c4cf" class="mo kr it mk b gy mp mq l mr ms">template &lt;class T1&gt;<br/>struct HasClone&lt;T1, std::void_t&lt;<strong class="mk iu"><em class="nl">Ill-formed</em></strong>&gt; : std::true_type {};</span></pre><p id="3875" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">结果，<code class="fe mu mv mw mk b">void_t</code>本身也变得不良，由于SFINAE规则，编译器忽略第二个<code class="fe mu mv mw mk b">HasClone</code>定义。最终，它选择了唯一剩下的主定义。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="2fee" class="mo kr it mk b gy mp mq l mr ms">class Bar {<br/>// Without Clone() function.<br/>}</span><span id="6260" class="mo kr it mk b gy mt mq l mr ms">HasClone&lt;Bar&gt;::value <strong class="mk iu">// </strong>value is<strong class="mk iu"> false</strong></span></pre><p id="1c4a" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">接下来，我们来看案例(1)。与情况(2)相反，<code class="fe mu mv mw mk b">HasClone</code>的主模板定义和第二模板定义都被编译器认为是很好的候选。然而，由于rule⁹的偏序，选择了比第一个定义更专业的第二个定义。</p><p id="fea1" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">需要注意的一点是，要使这种机制工作，主模板中的默认模板参数必须是一个<em class="nl"> void </em>类型。为了理解，我们必须看看当<code class="fe mu mv mw mk b">Foo</code>被严格指定时会发生什么。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="5cb7" class="mo kr it mk b gy mp mq l mr ms">class Foo {<br/> public:<br/>  Foo * Clone() const { <br/>    return new Foo(*this);<br/>  }<br/>};</span><span id="be15" class="mo kr it mk b gy mt mq l mr ms">HasClone&lt;Foo&gt;<!-- -->::value // value is<strong class="mk iu"> true</strong></span></pre><p id="3db0" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">当给定<code class="fe mu mv mw mk b">Foo</code>时，编译器试图用模板参数T1替换给定的参数<code class="fe mu mv mw mk b">Foo</code>,用于两个模板。两个模板用<code class="fe mu mv mw mk b">Foo</code>替换T1都没有问题。但不同的是，替换后，第二个模板定义中的<code class="fe mu mv mw mk b">std::void_t&lt;decltype(std::declval&lt;Foo&gt;().Clone())&gt;</code>被翻译成了<em class="nl"> void </em>，整个定义变成了如下所示:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="5755" class="mo kr it mk b gy mp mq l mr ms">template &lt;class T1&gt;<br/>struct HasClone&lt;T1, void&gt; : std::true_type {};</span></pre><p id="a7c9" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">这将第二个参数T2明确指定为<em class="nl"> void </em>。</p><p id="2d78" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">同时，作为一个单独的步骤，由于主模板定义有一个默认的模板参数<em class="nl"> void </em>，编译器在实例化时将<code class="fe mu mv mw mk b">HasClone&lt;Foo&gt;</code>翻译成<code class="fe mu mv mw mk b">HasClone&lt;Foo, void&gt;</code>。然后，偏序规则开始生效。由于第二个模板明确地将第二个参数指定为<em class="nl"> void </em>，因此它被认为比主定义更专业，也更受青睐。</p><h1 id="a416" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">第二步。让编译器选择合适的<code class="fe mu mv mw mk b">Func(const T &amp;arg)</code>实现</h1><p id="6716" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们已经实现了一种机制来检查给定的类型是否具有<code class="fe mu mv mw mk b">Clone()</code>功能。最后，我们可以使用它让编译器选择合适的<code class="fe mu mv mw mk b">Func(const T&amp; arg)</code>实现。</p><p id="efa2" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">基本上，我们在这里再次使用SFINAE，就像我们在第一步中做的那样。</p><p id="629e" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">实现如下所示:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="c031" class="mo kr it mk b gy mp mq l mr ms">template&lt;class T, class = std::enable_if_t&lt;HasClone&lt;T&gt;::value&gt;&gt;<br/>void Func(const T&amp; arg) {<br/>   T* copy = arg.Clone();</span><span id="c498" class="mo kr it mk b gy mt mq l mr ms">  // 2. Do some process with the copy.<br/>}</span><span id="49cd" class="mo kr it mk b gy mt mq l mr ms">template&lt;class T,  class = std::enable_if_t&lt;!HasClone&lt;T&gt;::value&gt;&gt;<br/>int Func(const T&amp; arg) {<br/>  T copy(arg);<br/>  <br/>  // 2. Do some process with the copy.<br/>}</span></pre><p id="6bed" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">如您所见，它使用步骤1中的<code class="fe mu mv mw mk b">HasClone</code>将其值赋予std::enable_if_t ⁰.如果给定值为<em class="nl"> true </em>，则std::enable_if_t转换为良构类型<em class="nl"> void </em>。另一方面，如果给定值为<em class="nl">假</em>，则该值是病态的。该实现利用了这种行为，让编译器忽略一个模板实现，同时保持另一个依赖于<code class="fe mu mv mw mk b">HasClone&lt;T&gt;::value</code>，因此依赖于给定类型是否有<code class="fe mu mv mw mk b">Clone()</code>。</p><p id="e4b2" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">就是这样。但是为了更进一步的考虑，我们可能想要使用相同的技术或者使用提供的特性std::is_copy_constructible来检查它是否是可复制构造的。</p><h1 id="807d" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">摘要</h1><p id="a844" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我们讨论了流行的模板元编程模式，“检测习语”。使用该模式，我们可以实现能够检测给定类型是否有特定成员的工具。然后，我们可以使用实现的工具进行进一步的模板元编程。沃尔特·e·布朗有一个关于这个话题的精彩演讲。“现代模板元编程:概要，第二部分”我推荐观看它以了解更多信息。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="4a73" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">[1]:<a class="ae nu" href="https://en.wikipedia.org/wiki/Prototype_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Prototype_pattern</a></p><p id="393c" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">【2】:<a class="ae nu" href="https://en.cppreference.com/w/cpp/language/sfinae" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/sfinae</a></p><p id="9f26" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">http://www.cplusplus.com/reference/type_traits/false_type/</p><p id="df09" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">[4]:<a class="ae nu" href="http://www.cplusplus.com/reference/type_traits/true_type/" rel="noopener ugc nofollow" target="_blank">http://www.cplusplus.com/reference/type_traits/true_type/</a></p><p id="9ba4" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">【5】:【https://en.cppreference.com/w/cpp/types/void_t T2】</p><p id="3a90" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">[6]:【https://en.cppreference.com/w/cpp/language/parameter_pack T4】</p><p id="09b5" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">【7】:<a class="ae nu" href="https://en.cppreference.com/w/cpp/utility/declval" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/utility/declval</a></p><p id="3274" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">【8】:<a class="ae nu" href="https://en.cppreference.com/w/cpp/language/decltype" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/language/decltype</a></p><p id="3a2b" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">[9]:<a class="ae nu" href="https://en.cppreference.com/w/cpp/language/partial_specialization" rel="noopener ugc nofollow" target="_blank">https://en . CP preference . com/w/CPP/language/partial _ specialization</a></p><p id="7ae2" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">[10]:<a class="ae nu" href="https://en.cppreference.com/w/cpp/types/enable_if" rel="noopener ugc nofollow" target="_blank">https://en.cppreference.com/w/cpp/types/enable_if</a></p><p id="d599" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">[11]:<a class="ae nu" href="https://en.cppreference.com/w/cpp/types/is_copy_constructible" rel="noopener ugc nofollow" target="_blank">https://en . CP preference . com/w/CPP/types/is _ copy _ constructible</a></p><p id="ddbc" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">[12]:<a class="ae nu" href="https://youtu.be/a0FliKwcwXE" rel="noopener ugc nofollow" target="_blank">https://youtu.be/a0FliKwcwXE</a></p></div></div>    
</body>
</html>