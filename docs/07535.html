<html>
<head>
<title>Find the Location of the Max Element in an Unsorted Array Using Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用二分搜索法查找未排序数组中Max元素的位置</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/find-the-location-of-the-max-element-in-an-unsorted-array-using-binary-search-96b6d2c9a547?source=collection_archive---------4-----------------------#2021-02-23">https://levelup.gitconnected.com/find-the-location-of-the-max-element-in-an-unsorted-array-using-binary-search-96b6d2c9a547?source=collection_archive---------4-----------------------#2021-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><p id="776f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这篇文章中，我将解释我最近遇到的一个最有趣的算法问题的解决方案。与此同时，消除对二分搜索法的普遍误解(BS)。</p><p id="47d1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">问题陈述</strong> <br/>有一个大小为<strong class="jw ir"> n </strong> ( 2 ≤ <strong class="jw ir"> n </strong> ≤ 10⁵).的<strong class="jw ir">未排序</strong>数组该数组包含不同的整数值。给你一个数组<strong class="jw ir"> n </strong>的大小，你的任务是找到数组中最大元素的<strong class="jw ir">索引</strong> ( 1 ≤ <strong class="jw ir">索引</strong> ≤n)。您还可以访问一个<strong class="jw ir">对象</strong>，从中您可以使用方法格式、<strong class="jw ir"> object.query(left，right)、</strong>(<strong class="jw ir">1≤left&lt;right≤n</strong>)查询原始数组的任意子数组【T17【left，right】中第二个最大元素的位置。您最多只能进行<strong class="jw ir"> 20 </strong>次查询。你的任务是完成下面的功能。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="8dfa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">问题陈述说明<br/>T27】1。你的任务是写一个函数，找到数组中最大值的位置或索引，并返回(<strong class="jw ir"> 1 ≤ index ≤ n </strong>)。请注意，该数组没有排序。还要注意，这个问题不是问最大元素，而是问它在数组中的位置(不是从零开始的索引)。<br/> 2。数组是固定的，单个测试用例的所有查询结果都来自同一个数组，因此max元素在数组中的位置是固定的。<br/> 3。您可以查询原始数组的特定子数组中第二个最大元素的<strong class="jw ir">索引</strong>最多<strong class="jw ir"> 20 </strong>次。对于对象查询方法的参数，<strong class="jw ir">右</strong>和<strong class="jw ir">左</strong>参数之差必须大于或等于1。</strong></p><blockquote class="kz la lb"><p id="7e1a" class="ju jv lc jw b jx jy jz ka kb kc kd ke ld kg kh ki le kk kl km lf ko kp kq kr ij bi translated">这个问题最近出现在一次编程大赛上。这个问题引起了我的兴趣，所以我决定分享解决方案，并澄清一些关于BS的误解。我修改了这个问题，以适应这篇文章的目的，因为它是一个互动的问题。</p></blockquote><p id="09ab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你读到这里，我相信你会思考这个问题以及如何用BS来解决它。我一直相信BS只能应用在一个排序的数组上。不过最近了解到，BS应用并不依赖于搜索到的数组(或空间)是否排序。<strong class="jw ir">它实际上取决于被搜索数组的已知属性/特征</strong>。<br/>更正式的说法是，二分搜索法，顾名思义，<em class="lc">是一种通过不断将搜索空间一分为二，在对数时间内高效找到目标元素的搜索技术</em>。为了使BS工作，<strong class="jw ir">在被搜索的数组</strong>之内或之外必须存在某种知识/信息，这使得在单次移动之后精确地将搜索的空间减少几乎一半成为可能。<strong class="jw ir">知道</strong>一个数组被排序就足够<strong class="jw ir">信息</strong>来应用BS，因为我们知道，在一个排序的数组中，每个<code class="fe lg lh li lj b">i &lt; j</code>、<code class="fe lg lh li lj b">ai &lt;= aj</code>或<code class="fe lg lh li lj b">ai ≥ aj</code>。但是，可能存在对数组的不同了解(在排序之外),这使得在单次移动之后将搜索的数组减少一半成为可能。其他几个问题也在未排序的数组上使用BS。关于BS说得够多了，让我们回到最初的问题，看看如何用BS来解决它。</p><p id="8cf7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">解决方案:方法1 </strong>(超过的查询数)<br/>让我们考虑可用于在我们的“神秘”数组中找到最大元素的信息。我用了“神秘”这个词，因为我们实际上对数组值一无所知。如果是，我们如何找到最大元素的位置？<br/>原来，通过最多询问2次关于数组中第2个最大值元素或其子数组(对我们可用)的位置，我们就可以知道最大值元素位于数组的哪一侧。这样，我们就能够在进行一些查询后将数组分成两半，并最终到达最大元素的位置。</p><p id="6191" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">步骤</strong> <br/> <strong class="jw ir"> 1 </strong>。设<code class="fe lg lh li lj b">left</code>和<code class="fe lg lh li lj b">right</code>为当前搜索空间的第一个和最后一个索引。找到数组的中间索引，即<code class="fe lg lh li lj b">mid = (left+right)/2</code>。现在，<code class="fe lg lh li lj b">mid</code>已经将当前搜索空间分成了两半:<code class="fe lg lh li lj b">[left,mid]</code>和<code class="fe lg lh li lj b">[mid,right]</code>。</p><p id="7b37" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 2 </strong>。找到第二个最大元素在<code class="fe lg lh li lj b">left</code>和<code class="fe lg lh li lj b">right</code>索引之间的位置(即当前搜索空间中的第二个最大元素)，即<br/> <code class="fe lg lh li lj b">smax_all = object.query(left,right)</code>，其中<code class="fe lg lh li lj b">object</code>是要求我们完成的函数中给出的查询对象。</p><p id="0792" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> 3 i </strong>。如果整个当前搜索空间中的第二个最大值元素位于数组的后半部分(即<code class="fe lg lh li lj b">mid &lt;= smax_all</code>)，则查找后半部分的第二个最大值元素(即<code class="fe lg lh li lj b">smax_2nd = object.query(mid, right)</code>)。如果整个数组中的第二个max元素和数组后半部分中的第二个max元素相等(即<code class="fe lg lh li lj b">smax_all == smax_2nd</code>，那么数组中的最大元素必须在后半部分，因此用<code class="fe lg lh li lj b">mid</code>指针替换<code class="fe lg lh li lj b">left</code>指针。然而，如果<code class="fe lg lh li lj b">smax_all != smax_2nd</code>，那么最大元素不在后半部分，因此用<code class="fe lg lh li lj b">mid</code>指针替换<code class="fe lg lh li lj b">right</code>指针。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lk"><img src="../Images/2255e979990c447d814b2af1ff1a7a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VeHvZvDJIs4CBFiQlip4Q.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">3i)当<strong class="bd lv"> mid ≤ smax_all </strong>时</figcaption></figure><p id="ac98" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">三世。</strong>如果当前搜索空间的第二个最大值元素位于数组的前半部分(即<code class="fe lg lh li lj b">mid &gt; smax_all</code>)，则查找前半部分的第二个最大值元素(即<code class="fe lg lh li lj b">smax_1st = object.query(left, mid)</code>)。如果整个数组中的第二个max元素和数组前半部分中的第二个max元素相等(即<code class="fe lg lh li lj b">smax_all == smax_1st</code>，那么数组中的最大元素必须在前半部分，因此通过用<code class="fe lg lh li lj b">mid</code>指针替换<code class="fe lg lh li lj b">right</code>索引来丢弃后半部分。然而，如果<code class="fe lg lh li lj b">smax_all != smax_1st</code>，那么最大元素不在前半部分，因此通过用<code class="fe lg lh li lj b">mid</code>指针替换<code class="fe lg lh li lj b">left</code>指针来丢弃前半部分。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lw"><img src="../Images/bf0c70010a9c881be8d1185c97d87f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMveLkQQ62_vsdEUjjYIhQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">3ii)当<strong class="bd lv">中期&gt; smax_all </strong>时</figcaption></figure><p id="0dff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">至此，搜索到的数组减少了一半。递归/迭代地应用上述步骤，直到<code class="fe lg lh li lj b">left</code>和<code class="fe lg lh li lj b">right</code>指针之间的差变为1，然后返回最近没有更新的指针。下面是上述步骤的代码实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">第一种方法的代码实现(Java)</figcaption></figure><p id="9c43" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">方法1的分析</strong> <br/>显然，由于我们使用了BS，所以上述方法的时间复杂度为<code class="fe lg lh li lj b">O(logn)</code>。然而，我们的解决方案是根据我们的查询次数来评估的。由于使用了BS，如果数组大小是输入上限10⁵，则需要17次分裂(即lo <code class="fe lg lh li lj b">g(10^5) = 17 ,</code> log以2为基数)才能找到最大元素。然而，每次我们将搜索空间分成两个部分时，我们使用了两个查询。基于方法1，在最坏的情况下，将需要总共34次(即2 * 17)查询来找到大小为10⁵的数组中的max元素。这显然违反了问题陈述中给出的约束(即最多20个查询)。我们能做得比这更好吗？我们能做到每一步都没有2个查询吗？</p><p id="094e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">方法2 </strong> —查询数量少于允许的最大查询数量<br/>在第一种方法中，我们在每一步使用2个查询来分割搜索空间。我们真的需要两次查询来决定在每一步中丢弃数组的哪一半吗？<br/>让我们理解为什么我们在每一步都需要两个查询。第一个查询(<code class="fe lg lh li lj b">smax_all</code>)用于识别当前搜索空间中第二个最大元素的索引，而第二个查询(<code class="fe lg lh li lj b">smax_1st</code>或<code class="fe lg lh li lj b">smax_2nd</code>)用于验证基于第一个查询的结果丢弃当前搜索空间的哪一半。这意味着第二个查询依赖于第一个查询的结果。然而，只有第二个查询的结果实际上有助于当前搜索空间的分裂。我们可以不在每一步都进行第一次查询吗？是啊！我们可以。</p><p id="c3fc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们知道每一步中第二个max元素的位置，就不需要第一个查询。注意，在每一步之后，搜索空间中的第二个最大值元素或者改变(即减小)或者保持不变。例如，考虑数组<code class="fe lg lh li lj b">[1,2,8,4,9,3,40,21]</code>。在BS的第一步之后，搜索的数组减少到<code class="fe lg lh li lj b">[9,3,40,21]</code>，并且第二最大元素(即<code class="fe lg lh li lj b">21</code>)不变，因为最大元素和第二最大元素都在数组的相同一半上。然而，在该阵列<code class="fe lg lh li lj b">[1,40,3,4,9,5,20,10]</code>中，第二个最大元素在BS的第一步之后改变(即<code class="fe lg lh li lj b">[1,40,3,4] — second max changed from 20 to 4</code>)。我们如何防止第二个最大值元素在每一步都发生变化，我们如何从中受益？让我们考虑两种情况；</p><p id="6417" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">第一种情况</strong> —当原始数组中的第二个最大元素是包含最大元素的子数组中的第一个元素时(即<code class="fe lg lh li lj b">[smax_all,right])</code>)。在应用BS之前，<code class="fe lg lh li lj b">left</code>指针等于<code class="fe lg lh li lj b">smax_all</code>。我们如何利用这种安排？ <br/>由于我们已经知道第二个最大元素的位置，所以只需要一次查询，即<code class="fe lg lh li lj b">object.query(smax_all, mid)</code>，就可以将搜索空间缩小一半。任何时候查询结果等于<code class="fe lg lh li lj b">smax_all</code>，那么max元素必须位于子数组<code class="fe lg lh li lj b">[left, mid]</code>中，我们可以丢弃另一半<code class="fe lg lh li lj b">[mid, right]</code>。如果查询的结果不等于<code class="fe lg lh li lj b">smax_all</code>，那么max元素必须位于子数组<code class="fe lg lh li lj b">[mid, right]</code>中，我们可以从搜索空间中排除<code class="fe lg lh li lj b">[left, mid]</code>。我们在搜索的空间<code class="fe lg lh li lj b">[left, right]</code>上重复应用BS，找到<code class="fe lg lh li lj b">mid</code>并总是查询<code class="fe lg lh li lj b">[smax_all, mid]</code>上的第二个max元素，因为它也包含左半部分(即<code class="fe lg lh li lj b">[left, mid]</code>)。当<code class="fe lg lh li lj b">right</code>和<code class="fe lg lh li lj b">left</code>指针之差变为1时，我们返回<code class="fe lg lh li lj b">right</code>，因为它将指向max元素。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lx"><img src="../Images/ab8dcd250cd97b3df239ae8ff3620f88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O90F82NvbuZ054i4WaxVJQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">当smax是包含max元素的子阵列中的第一个元素时</figcaption></figure><p id="5d1c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">第二种情况</strong> <br/>当原数组中的<strong class="jw ir">第二个max </strong>元素是包含最大元素的子数组中的<strong class="jw ir">最后一个</strong>元素时(即<code class="fe lg lh li lj b">[left,smax_all]</code>)。在应用BS之前，<code class="fe lg lh li lj b">right</code>指针等于<code class="fe lg lh li lj b">smax_all</code>。<br/>这种安排与第一种情况类似，但方向相反。我们只需要一个查询就可以在每一步将搜索空间减半。<br/>如果<code class="fe lg lh li lj b">object.query(mid , smax_all) == smax_all</code>，那么max元素必须位于<code class="fe lg lh li lj b">[mid, right]</code>中，我们丢弃<code class="fe lg lh li lj b">[left , mid]</code>，否则我们丢弃<code class="fe lg lh li lj b">(mid, right]</code>。当<code class="fe lg lh li lj b">right</code>指针和<code class="fe lg lh li lj b">left</code>指针之差变为1时，我们返回<code class="fe lg lh li lj b">left</code>指针。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ly"><img src="../Images/83c498883acdc1309778d8812b95bb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CasI1PEncDMC8r70FO7Gw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">当smax是包含max元素的子阵列中的最后一个元素时</figcaption></figure><p id="046f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你读到这里，恭喜你！顺便问一下，你注意到第二种方法的问题了吗？回想一下，第一种方法使用了比所需更多的查询(最多34个查询，而不是20个)。因此，第二种方法应该可以解决查询过多的问题。我们已经讨论了可以应用第二种方法的两个场景，但是您可能已经注意到，任何输入数组都不太可能在第一个或最后一个位置放置第二个max元素。在这种情况下，如果数组中的第二个max元素既不在第一个位置也不在最后一个位置，那么我们如何应用第二种方法呢？<br/>事实证明，我们只用两个查询就可以解决这个问题。怎么会？下面的伪代码解释了；</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="ff41" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">对第二种方法的分析</strong> <br/>我们已经成功地在BS的每个步骤中消除了2个查询的使用。<br/>然而，我们还引入了额外的2个查询来确定采用哪种场景。总的来说，当数组大小为输入上限的10^5时，最多需要<strong class="jw ir"> 2 + Log(10^5) = 2 + 17 = 19 </strong>次查询。下面是第二种方法的Java代码实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">第二种方法的Java代码实现</figcaption></figure><p id="552a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">结论<br/> </strong>我还想补充一点，如果数组中的max元素不是唯一的(也就是说，如果数组包含非唯一值)，上述方法仍然会返回max元素之一的索引。如果您有兴趣尝试这个问题，我已经创建了大量随机生成的输入测试案例来测试您的解决方案。还包括用Java实现SecondMaximum蓝图。</p><p id="1fc1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这真的是一篇很长(也许很难)的帖子，我相信，到目前为止，你已经喜欢它了，并且可能学到了一些关于二分搜索法的新东西。在您的下一次搜索旅程中，我建议您通过研究被搜索数组的属性或其他可用信息(即使您的数组没有排序)来检查使用BS解决问题的方法。在我接下来的文章中，我将会写一些其他的算法问题，这些问题可以很容易地用BS来解决，即使还不清楚是否可以使用BS。感谢你花时间阅读这篇文章。我希望你学到了或重新学到了一些东西。</p><p id="7054" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">威尔逊·丘克斯:-)</p></div></div>    
</body>
</html>