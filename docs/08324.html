<html>
<head>
<title>TypeScript: 5 Areas to Master</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿:需要掌握的5个领域</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-beginners-here-are-the-5-areas-you-must-master-75aee5cd4483?source=collection_archive---------7-----------------------#2021-04-21">https://levelup.gitconnected.com/typescript-beginners-here-are-the-5-areas-you-must-master-75aee5cd4483?source=collection_archive---------7-----------------------#2021-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="69f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在漫威世界中我们最喜爱的英雄和反派的帮助下，让我们一起来看看需要掌握的5个关键领域</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d0b4bfc4bfdbfa33c6b327aed46b1669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CU82OxU6U2l7FBb60U4kZw.jpeg"/></div></div></figure><p id="019b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript很受欢迎。最近由T2 Stack Overflow进行的一项调查显示，TypeScript是仅次于Rust的第二受欢迎的语言。这比2019年的评级上升了8位。</p><p id="39ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更重要的是，如果你正在使用它，你是一个很好的公司。TypeScript目前被微软、Asana、Lyft、Slack、所有Angular 2+开发者、许多React &amp; Vue.js开发者以及<a class="ae lq" href="https://stackshare.io/typescript" rel="noopener ugc nofollow" target="_blank">数千家其他公司</a>使用，因此它已经并将继续经受考验。</p><p id="fa4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我是80/20法则的信徒，我认为有一个例子可以证明，对20%的语言有很好的理解可以让你解决你遇到的80%的日常问题。</p><p id="23f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在漫威宇宙中我们最喜爱的英雄和反派的帮助下，让我们一起来看看占80%的5个需要掌握的关键领域。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1a90" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 1。确定类型</strong></h1><p id="38c0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在我们进一步讨论之前，让我们先讨论一下TypeScript中的类型，它通常被分为两类——<strong class="kw iu">原始类型</strong>和<strong class="kw iu">复杂类型</strong>。</p><p id="f2b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TypeScript支持JavaScript中所有的<strong class="kw iu">原始数据类型</strong>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="fa51" class="na lz it mw b gy nb nc l nd ne">let Bool: boolean = CaptainMarvel.name === "Carol Danvers";</span><span id="7bef" class="na lz it mw b gy nf nc l nd ne">let Number: number = 2022; <br/><strong class="mw iu">// Planned release for Captain Marvel 2</strong></span><span id="ceab" class="na lz it mw b gy nf nc l nd ne">let String: string = "Binary Ignition";<br/><strong class="mw iu">// Captain Marvels superpower</strong></span><span id="ecdf" class="na lz it mw b gy nf nc l nd ne">let Undefined: undefined = undefined;<br/><strong class="mw iu">// Like where she was for most of EndGame</strong></span><span id="e6ff" class="na lz it mw b gy nf nc l nd ne">let Null: null = null;   <br/><strong class="mw iu">// Like Captain Marvels Weaknesses</strong></span><span id="e481" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// Yet to ever use these, but when the days comes, I'll be ready</strong><br/>let bigInt: bigint = 9007199254740993n<br/>let Symbol: symbol = Symbol('foo');</span></pre><h2 id="c278" class="na lz it bd ma ng nh dn me ni nj dp mi ld nk nl mk lh nm nn mm ll no np mo nq bi translated"><strong class="ak">推断并显式声明类型</strong></h2><p id="05c5" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们在上面看到的是我们在一个值和冒号后声明类型。这些是显式类型。如果没有显式声明类型，Typescript将为您推断类型。这是什么意思？嗯，看下面…</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="72ee" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">// The qoute that broke a million hearts</strong></span><span id="3e6b" class="na lz it mw b gy nf nc l nd ne">let string = "I love you"<br/>string = "3000"<br/>// Error: Type 'string' is not assignable to type 'number</span></pre><p id="a7e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没错，Typescript正在后台做一些奇怪的事情，并且在您不需要做任何事情的情况下为您执行一些类型检查。</p><p id="5c21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住显式类型和推断类型，这非常有帮助，但也会让你挠头想知道错误从何而来。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="10dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正是在<strong class="kw iu">复杂类型</strong>中，一些真正的奇迹发生了。让我们看看我们遇到的最常见的一个。</p><h2 id="ac77" class="na lz it bd ma ng nh dn me ni nj dp mi ld nk nl mk lh nm nn mm ll no np mo nq bi translated"><strong class="ak">对象类型</strong></h2><p id="13fe" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在JavaScript中，我们分组和传递数据的基本方式是通过对象。在TypeScript中，我们通过<em class="nr">对象类型</em>来表示那些。我们可以通过将一些原始类型放在一起来实现这一点。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b305" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">// We can represent an object type like this</strong></span><span id="6f28" class="na lz it mw b gy nf nc l nd ne">avenger:{name:string; superhuman:boolean}</span><span id="e58b" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// Or we could use the type alias, which when dealing with larger objects you may deam necessary</strong></span><span id="4989" class="na lz it mw b gy nf nc l nd ne">type Avenger: {<br/>  name:string;<br/>  superhuman:boolean;<br/>}</span><span id="ec65" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// this allows us to do do exciting stuff like this</strong></span><span id="04df" class="na lz it mw b gy nf nc l nd ne">const isSuperHuman = (avenger: <strong class="mw iu">Avenger</strong>) =&gt; {<br/>  console.log( avenger.name + (avenger.superhuman ? " is" : " is           <br/>  not") + " superhuman");<br/>}</span></pre><h2 id="e6d5" class="na lz it bd ma ng nh dn me ni nj dp mi ld nk nl mk lh nm nn mm ll no np mo nq bi translated"><strong class="ak">任何</strong></h2><p id="7496" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><code class="fe ns nt nu mw b">any</code>类型允许我们将任何特定的值赋给那个变量，在某种程度上模拟普通的Javascript。当没有其他选项，或者没有类型定义可用时，这很有用。例如，第三方API或您正在使用的软件包。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="edc4" class="na lz it mw b gy nb nc l nd ne">let infinityStones:string = "Six"<br/>infinityStones = 6<br/><em class="nr">// Error: Type 'number' is not assignable to type 'string'</em></span><span id="d1ac" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// No longer a problem when I exchange string for an any type</strong><br/>let infinityStones:any = "Six"<br/>infinityStones = 6</span></pre><p id="d539" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">数组和元组</strong></p><p id="2ae2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更难理解的事情之一是Typescript中元组的概念。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0402" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">// This is an array</strong><br/>let hero: string[] = ['Ironman', '49', 'true', '3000'];</span><span id="912e" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// This is a tuple</strong><br/>let hero: [string, number, boolean, number] = ['Ironman', 49, true, 3000];</span></pre><p id="37d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">具有固定数量的按特定顺序排列的值类型的数组称为元组。</p><p id="2a26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">元组保持严格的长度和排序。我喜欢把元组想象成我创建的它们自己的严格和独特的类型。我<strong class="kw iu">不能</strong>像扩展数组类型那样扩展它们。</p><p id="7269" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像给一个数组戴上手铐，他们就拿不出别的东西了。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="9377" class="na lz it mw b gy nb nc l nd ne">let hero: [string, number, boolean, number] = ['Hulk', 49, true, 3000];</span><span id="cbcb" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// A tuple can even keep the Hulk under control</strong><br/>hero[3] = 'Smash';   // Error: Type 'string' is not assignable to type 'number'</span></pre><p id="d1e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我需要解开手铐并扩展数组，会发生什么呢？使用<code class="fe ns nt nu mw b">concat</code>方法是可能的。这将把你的元组变成一个<code class="fe ns nt nu mw b">any[]</code>类型。这显然没有那么严格，但总比编译器错误好，对吗？</p><p id="32d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nr">对我来说，我想知道我什么时候把我的元组的类型改成any[]。因为如果我的元组没有足够的可扩展性来覆盖我需要的模式，也许我应该重新考虑我的元组，或者也许我根本不应该使用元组？</em></p><p id="631e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管怎样，我认为这里有健康辩论的空间。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d23f" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">// This is a tuple</strong><br/>const ThanosFavoriteThings: [ string, number, string] = ['Gamora', 6, 'Infinity Stones'];</span><span id="16a8" class="na lz it mw b gy nf nc l nd ne">ThanosFavoriteThings[3] = 'Power'<br/><em class="nr">// Error: Type '"Power"' is not assignable to type 'undefined'<br/>// Error: Tuple type '[string, number, string]' of length '3' has no element at index '3'.</em></span><span id="d9d5" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// Calling .concat() on a tuple returns an array with a type of any[]</strong><br/>const AllThingsThanosLikes = ThanosFavoriteThings.concat(['Power']);</span><span id="c8d7" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// An array is expandable</strong><br/>AllThingsThanosLikes[5] = 'Gardening';</span><span id="41fe" class="na lz it mw b gy nf nc l nd ne">console.log(AllThingsThanosLikes);<br/><strong class="mw iu">// This will print ["Gamora", 6, "Infinity Stones", "Power", "Gardening"]</strong></span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ac17" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 2。Enums的喜悦</strong></h1><p id="5e56" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">来自传统服务器端语言的人可能已经使用了一段时间。在类型可以接受任何预定义值集的任何地方使用枚举是一种好的做法。</p><p id="7e76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想想“<strong class="kw iu">北，南，东，西”</strong>或<strong class="kw iu">“男性，女性，非二元”</strong>或“<strong class="kw iu">复仇者联盟，奥创时代，无限战争，残局”</strong>。我喜欢在创建多选下拉菜单或复选框选择的解决方案时使用它们。</p><p id="496f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">枚举具有自动递增或可以设置为字符串或整数的枚举器。我通常更喜欢使用字符串值，尽管它们不会自动递增，但它们在调试时很有帮助，提高了可读性。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="acf3" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">// Auto Increment</strong><br/>enum Movies {<br/>  TheAvengers       // '0': "The Avengers "<br/>  AgeOfUltron       // '1': "Age of Ultron"<br/>  InfinityWar       // '2': "Infinity War "<br/>  Endgame           // '3': "Endgame "<br/>}</span><span id="1df8" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// Set Integer Value<br/></strong>enum MovieRelease {<br/>  TheAvengers  = 2012<br/>  AgeOfUltron  = 2015<br/>  InfinityWar  = 2018<br/>  Endgame      = 2019<br/>}</span><span id="a0a1" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// Set String Value</strong><br/>enum MovieName {<br/>  TheAvengers   = "The Avengers"<br/>  AgeOffUltron  = "Age of Ultron"<br/>  InfinityWar   = "Infinity War"<br/>  Endgame       = "Endgame"<br/>}</span><span id="f988" class="na lz it mw b gy nf nc l nd ne">const MovieName: MovieName = MovieName.InfinityWar<br/>const MovieRelease: MovieRelease = MovieName.InfinityWar</span><span id="7dcd" class="na lz it mw b gy nf nc l nd ne">console.log(`${MovieName} was released in ${MovieRelease}`)<br/><strong class="mw iu">// Logs "Infinity War was released in 2018"</strong></span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="526b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 3。当你需要更多的灵活性时</strong></h1><p id="c10d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当使用现有的Javascript时，您可能希望重新分配现有的变量。Typescript为我们提供了两种解决方案。</p><p id="f593" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ns nt nu mw b">any</code>类型，我们之前提到过，可以赋给任何变量。</p><p id="51e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者可以通过在类型之间添加管道来创建的联合类型。它允许我们做一些非常有趣的事情</p><p id="64f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像这样…</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="998a" class="na lz it mw b gy nb nc l nd ne">let Thor: string | number | boolean;<br/>Thor = 'Mjolnir';   <strong class="mw iu">// Thors famous hammer</strong><br/>Thor = 8;           <strong class="mw iu">// The number of marvel movies he has featured<br/></strong>Thor = 'Avengers 4'<strong class="mw iu"> // The next movie Thor has a role in<br/></strong>Thor = Thor &gt; Hulk  <strong class="mw iu">// The great debate continues</strong></span></pre><p id="ed8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者这个…</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7d78" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">// Lets create a mini battle game, working of the following pretence</strong></span><span id="1ca5" class="na lz it mw b gy nf nc l nd ne">Scarlet Witch &gt; Dr. Strange <br/><strong class="mw iu">// I think Scarlet Witch beats Strange, since she nearly bet Thanos on her own</strong></span><span id="c88b" class="na lz it mw b gy nf nc l nd ne">Dr. Strange &gt; Dormmamu <br/><strong class="mw iu">// He's already managed to outsmart the ruler of the dark dimension once</strong></span><span id="0a52" class="na lz it mw b gy nf nc l nd ne">Dormmamu &lt; Scalet Witch <br/><strong class="mw iu">// Dormmamu kicks ass here, In fairness I think he beats most</strong></span><span id="8e56" class="na lz it mw b gy nf nc l nd ne">--------------------------------------------------------------------</span><span id="7d34" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// This is a union of string literal types<br/></strong>type BattleCharacter = 'Scarlet Witch' | 'Dormmamu' | 'Dr. Strange';</span><span id="8b10" class="na lz it mw b gy nf nc l nd ne">const Battle = (choice: BattleCharacter): void =&gt; {<br/>  let result: string = '';<br/>  switch (choice) {<br/>    case 'Scarlet Witch':<br/>      result = 'Dormmamu';<br/>      break;<br/>    case 'Dormmamu':<br/>      result = 'Dr. Strange';<br/>      break;<br/>    case 'Dr. Strange':<br/>      result = 'Scarlet Witch';<br/>      break;<br/>  }<br/>console.log('Me: ', result);<br/>}</span><span id="6753" class="na lz it mw b gy nf nc l nd ne">const number = Math.floor(Math.random()*3);</span><span id="0539" class="na lz it mw b gy nf nc l nd ne">let BattleCharacter: [BattleCharacter, BattleCharacter, BattleCharacter] = ['Scarlet Witch' | 'Dormmamu' | 'Dr. Strange'];</span><span id="b906" class="na lz it mw b gy nf nc l nd ne">Battle(choices[number]);</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e67c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 4。缩放我们新发现的控件</strong></h1><p id="1109" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">接口定义了由我们到目前为止所看到的所有类型组成的对象。</p><p id="1616" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正是有了接口，我们才能真正开始控制我们现在对对象模态值的控制，使用它们来确保将正确的数据传递给属性和函数。</p><p id="d76d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这很好，但更好的是接口是可组合的。TypeScript允许您在一个接口中嵌套接口或从另一个接口继承。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b4dc" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">// We can turn this...</strong></span><span id="f517" class="na lz it mw b gy nf nc l nd ne">interface Avenger {<br/>  id: number;<br/>  name: string;<br/>  stats: {<br/>    weapon: string;<br/>    stength: number;<br/>    superHuman: boolean;<br/>  }<br/>  movies: {<br/>    [filmId: string]: {<br/>      name: string;<br/>      releaseDate: number;<br/>      rating: number;<br/>    }<br/>  }<br/>}</span><span id="6c71" class="na lz it mw b gy nf nc l nd ne"><strong class="mw iu">// into this...</strong></span><span id="1700" class="na lz it mw b gy nf nc l nd ne">interface Avenger {<br/>  id: number;<br/>  name: string;<br/>  stats: Stats;<br/>  movies: { [filmId: string] : Movie}}</span><span id="b5ed" class="na lz it mw b gy nf nc l nd ne">interface Stats {<br/>  weapon: string;<br/>  stength: number;<br/>  superHuman: boolean;<br/>}</span><span id="55e6" class="na lz it mw b gy nf nc l nd ne">interface Movie {<br/>  name: string;<br/>  releaseDate: number;<br/>  rating: number;<br/>}</span></pre><p id="d632" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果代码有点长，但是我们用一个大的接口解决了问题。现在，我们可以更容易地阅读带有命名类型的代码，并且可以在代码的其他地方重用较小的接口。</p><p id="3033" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将类型组合在一起是保持代码有组织性和灵活性的基本方法。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3bb0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak"> 5。将所有这些放在一起看函数</strong></h1><p id="f8d4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">函数是任何Javascript应用程序的基本构建块，因此自然地，它们将在Typescript中扮演重要的角色，我们将首先使用它来实现可读性、类型检查、调试和防止错误。</p><h2 id="d9a2" class="na lz it bd ma ng nh dn me ni nj dp mi ld nk nl mk lh nm nn mm ll no np mo nq bi translated"><strong class="ak">参数类型</strong></h2><p id="8f9c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">Typescript允许我们为传递给函数的参数提供类型注释，这意味着它还需要能够处理可选参数。</p><p id="07a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了表明参数是有意可选的，我们在它的名字后面添加了一个<code class="fe ns nt nu mw b">?</code>操作符。这告诉TypeScript该参数是允许未定义的，并不总是必须提供。如果没有选择参数，它将推断参数类型，同样的方式推断初始化变量的类型与其初始值的类型相同。</p><h2 id="8703" class="na lz it bd ma ng nh dn me ni nj dp mi ld nk nl mk lh nm nn mm ll no np mo nq bi translated"><strong class="ak">函数返回类型</strong></h2><p id="f04f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">所以我们可以检查进入函数的内容，你最好相信我们可以对输出的内容做同样的事情。同样，如果你不声明函数的返回类型，Typescript会推断出函数的返回类型，否则，我们可以显式地为函数指定返回类型，包括不返回任何东西的函数。</p><p id="d86c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是通过类型值<code class="fe ns nt nu mw b">void</code>完成的。</p><p id="3e78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">空有点像<code class="fe ns nt nu mw b">any</code>的反义词，是完全没有任何类型。您通常会将此视为不返回值的函数的返回类型。通常，如果一个函数没有return语句，你可能会想使用它。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0708" class="na lz it mw b gy nb nc l nd ne">class Avenger {<br/>  <br/>  constructor(obj: Avenger){<br/>    this.name = obj.name;<br/>    this.stats = obj.stats;<br/>    this.movies = obj.movies;<br/>  }<br/>  <br/>  attack():void {<br/>    const x = this.stats.superHuman ?<br/>    this.stats.strength * 2 : this.stats.strength</span><span id="7862" class="na lz it mw b gy nf nc l nd ne">    alert(this.name + ' can use ' + this.stats.weapon + 'to cause'      + x + 'damage')<br/>  }</span><span id="5f2c" class="na lz it mw b gy nf nc l nd ne">  bestMovie(): string {<br/>    const movie = this.movies.reduce((prev, movie) =&gt; {<br/>      return (prev === undefined || movie.rating &gt; prev.rating) ?<br/>        movie : prev<br/>    })<br/>    return movie.name<br/>  }<br/>}</span><span id="8c50" class="na lz it mw b gy nf nc l nd ne">const IronMan = new Avenger({<br/>  name: "Tony Stark",<br/>  stats: {<br/>    weapon: "Rockets",<br/>    strength: 8,<br/>    superHuman: false<br/>  },<br/>  movies: [<br/>    { name: "Iron Man", releaseDate: 2008, rating: 7.9 },<br/>    { name: "Iron Man 2", releaseDate: 2010, rating: 7.0 },<br/>    { name: "Iron Man 3", releaseDate: 2013, rating: 7.2 }<br/>  ]<br/>})</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="45a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了。我希望你已经发现这是有用的。感谢您的阅读。如果你喜欢复仇者联盟这个主题，你可能也会喜欢我们在<a class="ae lq" href="https://www.notnotnerdy.com/" rel="noopener ugc nofollow" target="_blank">创造的一些东西！！书呆子</a></p></div></div>    
</body>
</html>