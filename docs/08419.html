<html>
<head>
<title>Learning TypeScript: The TypeScript Data Types (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习TypeScript:TypeScript数据类型(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-typescript-the-typescript-data-types-part-2-4f38b7dfd5bc?source=collection_archive---------7-----------------------#2021-04-30">https://levelup.gitconnected.com/learning-typescript-the-typescript-data-types-part-2-4f38b7dfd5bc?source=collection_archive---------7-----------------------#2021-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7463b2f3826218cc63a9e93be96550a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iuy1jetL5jVZriQi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a647" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文是讨论TypeScript程序中可用的各种数据类型的系列文章的第二部分。第一条是<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/learning-typescript-the-data-types-of-typescript-part-1-fe49a966ccc7">此处</a>。本文主要关注更传统的数据类型，比如数字、字符串、布尔值，以及产生对象的类型，比如普通对象、数组和元组，后者是JavaScript和TypeScript中较新的数据类型。</p><h1 id="d045" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">布尔类型</h1><p id="d8be" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">boolean</code>类型用于存储真值和假值。TypeScript可以从赋值中推断出<code class="fe mh mi mj mk b">boolean</code>类型，并且您可以明确地将一个变量声明为<code class="fe mh mi mj mk b">boolean</code>类型。你也可以声明一个变量是一个特定的<code class="fe mh mi mj mk b">boolean </code>类型(或者是<code class="fe mh mi mj mk b">true</code>或者是<code class="fe mh mi mj mk b">false</code>)并且这个变量不能被赋予另一个<code class="fe mh mi mj mk b">boolean</code>值。</p><p id="b52d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是一些例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="24a0" class="mt lf it mk b gy mu mv l mw mx">let flag = true // boolean type inferred<br/>let negative = false // boolean type inferred<br/>let flag :boolean = true // boolean type annotated<br/>const t = true // an inferred type literal<br/>let alwaysTrue :true = true // an annotated type literal<br/>let alwaysFalse :false = false // an annotated type literal</span></pre><p id="aba5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您熟悉其中的许多赋值，但可能不熟悉那些引用类型文字的赋值。一个<em class="my">类型的文字</em>使用一个特定的值作为数据类型，你可以在TypScript中用<code class="fe mh mi mj mk b">true</code>和<code class="fe mh mi mj mk b">false</code>来实现。一旦用类型文本声明了变量，该变量就不能保存任何其他值。这里有一个例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bc68" class="mt lf it mk b gy mu mv l mw mx">let t :true = true<br/>t = false</span></pre><p id="63dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我试图编译这段代码时，我得到以下错误消息:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cd8a" class="mt lf it mk b gy mu mv l mw mx">test.ts:2:1 - error TS2322: Type 'false' is not assignable to type 'true'.</span><span id="fce9" class="mt lf it mk b gy mz mv l mw mx">2 t = false<br/>  ~</span><span id="9e9a" class="mt lf it mk b gy mz mv l mw mx">Found 1 error.</span></pre><p id="3f6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量<code class="fe mh mi mj mk b">t</code>现在是一个真正的类型文字，它不能保存其他值。</p><p id="6bc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些情况下，类型文字是您可以在程序中提供的额外的类型安全层。</p><h1 id="73bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数字类型</h1><p id="16b7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">number</code>型是用来存储数字的。与其他强类型语言不同，TypeScript只为数字数据提供了<code class="fe mh mi mj mk b">number</code>类型。不能为整数、浮点数、长整型等指定。</p><p id="5248" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">number</code>类型允许对其进行常见的数字运算，例如加、减、乘、除和取模，并且<code class="fe mh mi mj mk b">Math</code>库中有许多数学函数也可以处理数字数据。</p><p id="e7a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与其他数据类型一样，<code class="fe mh mi mj mk b">number</code>类型可以通过类型注释来推断或指定，如下例所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="27cb" class="mt lf it mk b gy mu mv l mw mx">let salary = 20000 // number type is inferred<br/>const PI = 3.14159 // number type is inferred<br/>let hours :number = 40 // number type is annotated<br/>const e :number = 2.71828 // number type is annotated</span></pre><p id="06a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以对数值数据使用类型文本:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2f4f" class="mt lf it mk b gy mu mv l mw mx">let pi :3.14159 = 3.14159<br/>let standardHours :40 = 40</span></pre><p id="c66b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">pi</code>和<code class="fe mh mi mj mk b">standardHours</code>的值现在是类型文字，不能更改。这很像创建常量，您可能应该避免以这种方式使用类型文字，而应该使用常量。</p><h1 id="645e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">bigint类型</h1><p id="fa8c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">数字数据类型的大小限制是253。如果你需要存储一个大于这个数的数，你必须使用<code class="fe mh mi mj mk b">BigInt</code>类型，它在TypeScript中表示为<code class="fe mh mi mj mk b">bigint</code>。</p><p id="338b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe mh mi mj mk b">bigint</code>类型初始化变量有几种方法。以下是一些例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cffa" class="mt lf it mk b gy mu mv l mw mx">let n = 4567n <br/>// an integer with n after it is a BigInt and the type is inferred<br/>const x = 230000n // bigint type is inferred<br/>let z :bigint = 100000n<br/>let s :100n = 100n // a bigint type literal</span></pre><p id="a3b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">bigint</code>类型可以与标准算术运算符(+、-、*、/)一起使用，但模数除外，BigInts可以与关系运算符一起使用。例如:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f430" class="mt lf it mk b gy mu mv l mw mx">let x :bigint = 100n<br/>let y :bigint = 200n<br/>let c :bigint = x * y</span></pre><h1 id="ef8c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">字符串类型</h1><p id="da41" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">string</code>类型用于文本数据，可以包含数字。字符串是通过在要作为字符串键入的文本周围加上单引号或双引号而形成的。唯一对字符串起作用的操作符是串联(+)操作符，还有许多函数可以调用来对字符串进行操作，比如<code class="fe mh mi mj mk b">substr</code>、<code class="fe mh mi mj mk b">slice</code>、<code class="fe mh mi mj mk b">length</code>等等。</p><p id="ce2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是一些如何创建新字符串变量的示例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="74ef" class="mt lf it mk b gy mu mv l mw mx">let name = "Billy"<br/>let greeting = 'Hello'<br/>let id = '28348'<br/>let last :string = "Pyle"<br/>let firstFiveLetters = "a"+"b"+"c"+"d"+'e'<br/>let fn :mike = "Mike" // a type literal</span></pre><p id="9e75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与往常一样，您应该让TypeScript从分配的数据中推断字符串类型，而不是在程序中对该类型进行批注。</p><h1 id="a3b6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">符号类型</h1><p id="a9b5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">symbol</code>类型是JavaScript中相对较新的数据类型。该类型的主要目的是将对象和映射属性定义为唯一的实体，以便错误地使用一些其他字符串值，这导致JavaScript创建一个具有该名称的新属性。</p><p id="befe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">Symbol</code>功能创建一个<code class="fe mh mi mj mk b">symbol</code>类型的变量。你不用这个函数调用关键字<code class="fe mh mi mj mk b">new</code>，只用带值的函数名。以下是一些用<code class="fe mh mi mj mk b">symbol</code>类型声明变量的例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="50a6" class="mt lf it mk b gy mu mv l mw mx">let first_name = Symbol("first_name")<br/>let last_name :symbol = Symbol("last_name")</span></pre><p id="288a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以让TypeScript推断出<code class="fe mh mi mj mk b">symbol</code>类型，也可以用您的声明对其进行注释。</p><p id="ff75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以将变量声明为唯一的<code class="fe mh mi mj mk b">symbol</code>类型，如下例所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6273" class="mt lf it mk b gy mu mv l mw mx">const sym :unique symbol = Symbol("unique")</span></pre><p id="2ed4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的<code class="fe mh mi mj mk b">symbol</code>是完全唯一的，除了它自己之外，不能与任何其他<code class="fe mh mi mj mk b">symbol</code>相等。</p><h1 id="7ee4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对象类型</h1><p id="648c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">object</code>类型用于描述对象的形状，我的意思是TypeScript关心对象的属性，而不是对象的名称。例如，下面的代码创建两个不同的对象:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="306e" class="mt lf it mk b gy mu mv l mw mx">let student = {<br/>  name : "John Doe",<br/>  major : "Art"<br/>}</span><span id="8dc8" class="mt lf it mk b gy mz mv l mw mx">let dog = {<br/>  name : "Fido",<br/>  speak : "Woof!"<br/>}</span><span id="a664" class="mt lf it mk b gy mz mv l mw mx">console.log(typeof(student)) // displays object<br/>console.log(typeof(dog)) // displays object</span></pre><p id="9dbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但两个对象的类型都只是object，而不是每个对象的具体“种类”。这种分型叫做<em class="my">结构分型</em>。</p><p id="e838" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用<code class="fe mh mi mj mk b">objec</code> t类型注释，但是这会导致奇怪的行为:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a301" class="mt lf it mk b gy mu mv l mw mx">let person :object = {<br/>  name: 'Terri'<br/>}<br/>console.log(person.name) // error message: Property name does<br/>                         // not exist on type object</span></pre><p id="f7ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果让TypeScript推断数据类型:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="31e8" class="mt lf it mk b gy mu mv l mw mx">let person = {<br/>  name: 'Terri'<br/>}<br/>console.log(person.name) // displays Terri</span></pre><p id="6326" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript将person识别为对象，将name识别为对象的属性。</p><h1 id="e5ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数组类型</h1><p id="432a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">数组实际上不是数据类型，而是一种特殊类型的<code class="fe mh mi mj mk b">object</code>。在JavaScript中，数组可以包含任何类型的值，给数组一种狂野西部的感觉，因为在大多数编程语言中，数组是同构的，这意味着只能在其中存储一种类型的数据。然而，TypeScript为我们提供了一些加强同质性的选项。</p><p id="ddcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们看看如果我们像在JavaScript中那样在TypeScript中创建数组会发生什么。以下是一些示例代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8b83" class="mt lf it mk b gy mu mv l mw mx">let values = []<br/>values.push(1)<br/>values.push("hello")<br/>values.push(true)<br/>console.log(values) // displays [1, "hello", true]</span></pre><p id="d606" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以把任何我们想要的数据值放入数组。</p><p id="c642" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在TypeScript中使用类型注释来在数组上强制使用单一数据类型。我们可以使用以下通用语法指定数组的数据类型:</p><p id="1210" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="my">let array-name:data-type[]=[将可选初始值放在此处或留空] </em></p><p id="ad9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这种类型注释的一个工作示例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="476a" class="mt lf it mk b gy mu mv l mw mx">let numbers :number[] = []<br/>numbers.push(100)<br/>numbers.push(200)<br/>numbers.push("hello")// error: Argument of type 'string' is not<br/>                     // assignable to parameter of type 'number'</span></pre><p id="3f08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还可以通过用至少一个值初始化数组，让TypeScript推断数组的数据类型，如下例所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8e0b" class="mt lf it mk b gy mu mv l mw mx">let numbers = ["one"]<br/>numbers.push("two")<br/>numbers.push(3) // error: Argument of type 'number' is not<br/>                //assignable to parameter of type 'string'</span></pre><p id="09e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您想要(但愿不会这样)一个混合数据类型的数组，该怎么办呢？您可以用<code class="fe mh mi mj mk b">any</code>类型注释数组:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f2e9" class="mt lf it mk b gy mu mv l mw mx">let values :any[] = []<br/>values.push(1)<br/>values.push("two")<br/>value.push(false)</span></pre><p id="4f19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码运行时没有任何错误消息。然而，请记住，当你以这种方式声明数组时，你实际上冒着在你的程序中出现奇怪结果的风险。</p><p id="962c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以通过用您希望允许的数据类型的值初始化数组来限制数组可以容纳的类型。例如，如果我想要一个只保存数字和字符串的数组，我可以这样初始化这个数组:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b2f2" class="mt lf it mk b gy mu mv l mw mx">let values = [1, "two"]</span></pre><p id="978c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在如果我试着写下以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="05bb" class="mt lf it mk b gy mu mv l mw mx">values.push(false)</span></pre><p id="1fea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我收到以下错误消息:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ae34" class="mt lf it mk b gy mu mv l mw mx">Argument of type 'boolean' is not assignable to parameter of type 'string | number'.</span></pre><p id="a56f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我所做的基本上是创建一个类型为<code class="fe mh mi mj mk b">number</code>或<code class="fe mh mi mj mk b">string</code>的数组。这两种类型的值都可以放入数组，但不允许放入其他数据类型。</p><h1 id="e233" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">元组</h1><p id="16b1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">元组是一种数组，其中元素的长度和元素的数据类型是固定的。以下是元组声明示例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="343b" class="mt lf it mk b gy mu mv l mw mx">let dept :[string, string, string, string] =<br/>          ['Raymond', 'Mike', 'Mayo', 'Danny']</span></pre><p id="60d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大小固定为四个元素，元组的类型为<code class="fe mh mi mj mk b">[string, string, string, string]</code>。</p><p id="53f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我尝试向元组中添加一个元素:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="43e1" class="mt lf it mk b gy mu mv l mw mx">dept = ['Raymond', 'Mike', 'Mayo', 'Danny', 'Cynthia']</span></pre><p id="b7da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我得到一个错误消息，指出类型<code class="fe mh mi mj mk b">[string, string, string, string, string]</code>不可分配给类型<code class="fe mh mi mj mk b">[string, string, string, string]</code>。</p><p id="b106" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于JavaScript数组的灵活性，元组提供了数组无法提供的大量类型安全性。在许多应用程序中，应该优先使用元组，而不是使用数组。</p><p id="33ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在元组中提供可选元素，以便元组的元素可以包含可选数量或更少，但不能更多。例如:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5128" class="mt lf it mk b gy mu mv l mw mx">let grades  :[number, number, number, number, number?] =<br/>  [81, 77, 85, 98, 100]<br/>console.log(grades) // displays 81, 77, 85, 98, 100<br/>grades = [75, 82, 68, 88]<br/>console.log(grades) // displays 75, 82, 68, 88</span></pre><p id="abdb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果我试着给元组分配一个第六等级:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8e9d" class="mt lf it mk b gy mu mv l mw mx">grades = [71, 73, 83, 88, 91, 99]</span></pre><p id="1747" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我得到一个错误消息，指出类型<code class="fe mh mi mj mk b">[number, number, number, number, number, number]</code>不可分配给类型<code class="fe mh mi mj mk b">[number, number, number, number, [number | undefined]</code>。</p><p id="8e54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，一个元组可以包含rest元素，这样您就可以定义一个元组的最小大小，但是元组的最终大小是可选的。例如:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="13b3" class="mt lf it mk b gy mu mv l mw mx">let numbers :[number, ...number[]] = [1,2,3]<br/>numbers = [1,2]<br/>numbers = [1]<br/>numbers = [1,2,3,4,5,6,7,8,9,10]</span></pre><p id="12a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如本例所示，通过键入带有rest参数的元组，元组可以包含3个元素、2个元素、1个元素，甚至10个元素。使用rest参数为表示元组的元素数量提供了最大的灵活性。</p><h1 id="50aa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">只读数组和元组</h1><p id="de20" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript允许您通过使用<code class="fe mh mi mj mk b">readonly</code>关键字来创建不可变的数组或元组。当数组或元组被声明为只读时，不能在结构中添加或删除数据(当然，元组的大小是固定的)，如果要这样做，必须使用赋值来进行更改，或者使用非可变函数。</p><p id="1b40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是一些例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2e51" class="mt lf it mk b gy mu mv l mw mx">let numbers :readonly number[] = [1,2,3]<br/>//numbers.push(4) // not allowed because numbers is readonly<br/>numbers = [1,2,3,4] // can assign new data on readonly array<br/>numbers = numbers.concat(5) // can use concat with assignment<br/>console.log(numbers) // displays [1, 2, 3, 4, 5]<br/>// numbers.pop() // not allowed because numbers is readonly<br/>numbers = numbers.slice(0,4)<br/>console.log(numbers) // displays [1, 2, 3, 4]</span></pre><p id="6bfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的TypeScript类型介绍的第2部分到此结束。在第3部分中，我将介绍剩余的TypeScript类型，以便我们可以继续使用这些类型来解决有趣的计算问题。</p><p id="5020" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请回复这篇文章或发邮件给我，告诉我您的意见和建议。</p></div></div>    
</body>
</html>