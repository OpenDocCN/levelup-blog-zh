<html>
<head>
<title>Golang for Java Developers — Pointers, Error Handling, and Concurrency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Java开发人员的Golang指针、错误处理和并发性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-for-java-devs-pointers-error-handling-and-concurrency-493dad0c5129?source=collection_archive---------11-----------------------#2021-04-06">https://levelup.gitconnected.com/go-for-java-devs-pointers-error-handling-and-concurrency-493dad0c5129?source=collection_archive---------11-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb8f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从Java角度看Go编程语言—第2部分</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/73e124459102cb94eb3dfef69193e47a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*gausz1aacOvPJT1MEuBDTA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作者糟糕的草图</figcaption></figure><p id="bf19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本系列的第一篇文章中，我将自己描述为一名资深Java工程师，最近决定尝试一下。尽管我将永远热爱Java，但我知道继续学习语言很重要。我选择Go是因为它是一种静态类型的编译语言，不会面临Java面临的一些问题(比如编译时间和启动时间慢)。</p><p id="d1ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个系列不是要让Java和Go对立起来。两者都是强势语言，各有优缺点。相反，这是我作为Java开发人员对Go的第一次观察。鉴于我仍在学习Go，如果任何读者认为我误解了Go(或者Java，就此而言)，我欢迎任何反馈。</p><p id="5c9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至此，让我们进入一些真正区别于Java的领域:指针、错误处理和并发性。</p><h1 id="7d70" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">两颗北极指极星</h1><p id="ed29" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在Java中，当我们将一个对象传递给一个方法时，我们传递的是一个指向该对象的指针。但是当我们传递一个原语(比如int或double)时，我们实际上传递的是该原语的一个副本(这就是为什么，如果我将<code class="fe mo mp mq mr b">int myInt = 2</code>传递给一个方法:<code class="fe mo mp mq mr b">void quadruple(int i) { i = i * 4; }</code><code class="fe mo mp mq mr b">myInt</code>本身的值仍然是<em class="ms">2</em>；它的方法作用域<em class="ms">副本</em>将会翻两番。)</p><p id="31bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go有结构，没有对象。在使用Go时，您很快就会了解到，默认情况下，Go对待结构体的方式与Java对待原语的方式相同。也就是说，当您将结构作为函数参数传递时，或者当您从函数返回结构时，将复制整个结构。所以在下面的代码块中:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="fb07" class="mx ls it mr b gy my mz l na nb">type Person struct {<br/>  name string<br/>}</span><span id="6d37" class="mx ls it mr b gy nc mz l na nb">person := Person{"Pat"}</span><span id="c089" class="mx ls it mr b gy nc mz l na nb">func changeName(p Person) {<br/>  p.name = "Chris"<br/>}</span><span id="163f" class="mx ls it mr b gy nc mz l na nb">changeName(person)</span><span id="7d4e" class="mx ls it mr b gy nc mz l na nb">log.Println("Person's name is %s", person.name)</span><span id="dcae" class="mx ls it mr b gy nc mz l na nb">// prints:   Person's name is Pat</span></pre><p id="626b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mo mp mq mr b">person</code>变量的名字仍然是Pat仅<em class="ms">副本的名称</em> ( <code class="fe mo mp mq mr b">p</code>)被更改。这不是我们对Java对象的期望。同样，如果我做了这样的事情:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="5fca" class="mx ls it mr b gy my mz l na nb">type Org struct {<br/>  leader Person<br/>}</span><span id="42df" class="mx ls it mr b gy nc mz l na nb">func (o Org) getLeader() Person {<br/>  return o.leader<br/>}</span><span id="5eba" class="mx ls it mr b gy nc mz l na nb">org := Org{ Person{"Pat"} }</span><span id="e304" class="mx ls it mr b gy nc mz l na nb">o.getLeader().name = "Chris"</span><span id="5ad4" class="mx ls it mr b gy nc mz l na nb">log.Println("Org leader's name is %s", org.leader.name)</span></pre><p id="54a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那我就不会真的改变<code class="fe mo mp mq mr b">org</code>领导人的名字。相反，我会更改从<code class="fe mo mp mq mr b">getLeader()</code>函数返回给我的<em class="ms">副本</em>的名称。同样，这也不是我们这些习惯于使用Java对象的人所期望的。</p><p id="50ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，Go <em class="ms">通过允许我们显式地传递和返回指向函数的<em class="ms">指针</em>来允许我们复制Java对象的行为。</em></p><h2 id="daa1" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">指针？😳</h2><p id="664a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">提到<em class="ms">指针</em>，你可能会有这样的反应:</p><ol class=""><li id="b999" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">我要离开这里！我曾经在C/c++/C --无论什么语言中做过指针操作，那简直是一场噩梦！</li><li id="4df1" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">我要离开这里！我听说过其他语言中的指针，它们听起来就像一场噩梦！</li></ol><p id="f221" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你的反应符合上面的1或2，不用担心。与C语言系列相比，Go中指针的使用要简单得多，更容易理解，也更不容易出错。尽管如此，我还是遇到了一些在Go中使用指针的麻烦。</p><h2 id="d933" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">围棋中我们如何传递指针？</h2><p id="0faa" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果你在基于C的语言中使用过指针，那么Go的语法应该看起来非常熟悉。本质上，我们只是使用星号(<code class="fe mo mp mq mr b">*</code>)来告诉Go我们想要传递指针，我们使用&amp;符号(<code class="fe mo mp mq mr b">&amp;</code>)来获取指针。在这个街区:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="b9be" class="mx ls it mr b gy my mz l na nb">org := Org{ ... }<br/>per := Person{...}</span><span id="4fc1" class="mx ls it mr b gy nc mz l na nb">func (o *Org) setLeader(p *Person) *Org {<br/>  o.leader = p<br/>  return o<br/>}</span><span id="9247" class="mx ls it mr b gy nc mz l na nb">(&amp;org).setLeader(&amp;per)</span></pre><p id="c3ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经定义了一个函数，它接受一个指向<code class="fe mo mp mq mr b">Person</code>的指针，并返回一个指向<code class="fe mo mp mq mr b">Org</code>的指针。注意，这是一个<em class="ms">接收器功能。</em>因为我们想修改接收器本身，我们声明接收器也必须<em class="ms">和</em>作为指针传递。</p><p id="e955" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go的一个好处是我们不需要为记住解引用指针而纠结。以这个代码示例为例:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="f9bc" class="mx ls it mr b gy my mz l na nb">person := Person{ "Sal" }<br/>org2 := org.setLeader(&amp;person)<br/>log.Println("Org 2's leader is %s", org2.getLeader())</span></pre><p id="edcd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从技术上讲，<code class="fe mo mp mq mr b">org2</code>变量指的是一个指针——当然不包含<code class="fe mo mp mq mr b">getLeader()</code>方法——而不是一个<code class="fe mo mp mq mr b">Org</code>结构。然而，Go有助于识别我们打算在指针引用的<em class="ms">结构</em>上调用<code class="fe mo mp mq mr b">getLeader()</code>。</p><h2 id="9ae4" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">一些简单的准则</h2><p id="2a21" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在决定是否在Go中传递指针或值时，有一些简单的准则:</p><ul class=""><li id="c0d6" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp oc nu nv nw bi translated">正如我们已经讨论过的，如果你想直接改变值，那么你需要使用指针</li><li id="02f5" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">指针有时被认为比传递值更有效，因为它们避免了复制整个结构的开销。然而，情况并非总是如此，因为Go在从函数返回指向对象的指针之前必须执行<a class="ae lq" href="https://en.wikipedia.org/wiki/Escape_analysis" rel="noopener ugc nofollow" target="_blank">转义分析</a>，以确定它是否可以在当前堆栈上为该结构分配空间，或者它是否必须使用堆。</li><li id="96d8" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">你的API应该以一致性为目标。将指针和直接值混合在一起会导致API混乱。这也会导致我们接下来要讨论的问题</li></ul><h2 id="eaec" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">一环断掉，整个链条都毁了</h2><p id="bd79" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">正如我提到的，我发现在Go中理解和使用指针相对容易。但是我被绊倒了。</p><p id="5cb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我开发了一个在内存中存储数据的小型web应用程序。我的结构层次是这样的:</p><ul class=""><li id="7a24" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp oc nu nv nw bi translated">一个<code class="fe mo mp mq mr b">Org</code>包含多个<code class="fe mo mp mq mr b">Event</code></li><li id="ad71" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">一个<code class="fe mo mp mq mr b">Event</code>包含多个<code class="fe mo mp mq mr b">Participant</code></li><li id="af4a" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">一个<code class="fe mo mp mq mr b">Participant</code>包含一个<code class="fe mo mp mq mr b">count</code>(一个<code class="fe mo mp mq mr b">int</code>变量)</li></ul><p id="2e91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当一个特定的请求进来时，我想增加给定的<code class="fe mo mp mq mr b">Event</code>内所有<code class="fe mo mp mq mr b">Participant</code>的<code class="fe mo mp mq mr b">count</code>值。</p><p id="d293" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你可能猜到的，我的第一次尝试失败了。原因很清楚:我返回的是结构的副本，而不是指针。所以我改变了(我认为是)所有涉及获取相关<code class="fe mo mp mq mr b">Participant</code>的函数的签名。但是通过记录和调试，我发现我最终还是以某种方式获取了那些<code class="fe mo mp mq mr b">Participant</code>的副本进行修改。搞清楚这一点并不容易，我不得不到处传递和返回指针(最终导致我重新思考我的整个设计)。</p><h1 id="a74b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">错误处理</h1><p id="7dc5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Go通过利用函数可以返回多个值的事实，提供了一种有趣的处理错误的方式。任何可能遇到错误条件的函数都返回两个值:函数预期返回的值和一个<em class="ms">错误</em>。<code class="fe mo mp mq mr b">error</code>实际上是一个接口，定义了一个方法:</p><p id="ed33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mo mp mq mr b">type error interface { Error() string }</code></p><p id="3a87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以函数的签名看起来是这样的:<br/> <code class="fe mo mp mq mr b">func doSomething(arg string) (string, error)</code></p><p id="d505" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果调用函数时没有出错，那么函数返回想要的结果(这里是一个<code class="fe mo mp mq mr b">string</code>)和<code class="fe mo mp mq mr b">nil</code>。如果出错，该函数将返回一个任意字符串(通常是<code class="fe mo mp mq mr b">“”</code>)和一个非零值<code class="fe mo mp mq mr b">error</code>。</p><p id="6a8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，一个通常不会返回值的函数会简单地声明它返回<code class="fe mo mp mq mr b">error</code>，并在没有错误的情况下返回<code class="fe mo mp mq mr b">nil</code>。</p><p id="6a45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当调用这样一个函数时，我们必须——至少——指定一个变量来捕捉错误。否则，代码将无法编译。一旦我们这样做了，如果错误不是<code class="fe mo mp mq mr b">nil</code>，我们应该采取适当的行动。</p><p id="f11a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一些调用Go的文件系统API的代码:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="aa61" class="mx ls it mr b gy my mz l na nb">var fname string = getFilename()<br/>// below, values for 'file' and 'err' are returned. <br/>// err's value might be nil<br/>file, err := fs.Open(fname)<br/>if (err != nil) {<br/>  log.Printf("Could not open file %s", fname);<br/>} else {<br/>  // read file, etc<br/>}</span></pre><p id="becc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们试着这样写:<br/> <code class="fe mo mp mq mr b">file := fs.Open(fname)</code> <br/>我们的代码不会编译。我们必须抓住错误。当然，我们可以选择忽略<code class="fe mo mp mq mr b">err</code>并假设没有错误发生(并且，很可能，冒着运行时异常的风险)。事实上，Go提供了“空白标识符”(用下划线或<code class="fe mo mp mq mr b">_</code>表示)，它允许我们显式地忽略返回值:<br/> <code class="fe mo mp mq mr b">file, _ = fs.Open(fname)</code> <br/>。然而，在这一点上，我们已经有意识地决定这样做了。</p><p id="7200" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种方法不同于Java和许多其他语言采用的try/catch方法。(如果有什么不同的话，那就是在使用RxJava之类的反应式框架或Scala之类的函数式语言所采用的<a class="ae lq" href="https://www.freecodecamp.org/news/a-survival-guide-to-the-either-monad-in-scala-7293a680006/" rel="noopener ugc nofollow" target="_blank">或</a>时，感觉更类似于<a class="ae lq" href="https://www.baeldung.com/rxjava-error-handling" rel="noopener ugc nofollow" target="_blank">的错误处理。)</a></p><p id="dba4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Java的try/catch机制因许多原因而受到批评；其中包括:</p><ul class=""><li id="da2e" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp oc nu nv nw bi translated">我们必须将异常定义为运行时异常(这使得它们很容易被忘记并且无法正确处理)或检查异常(这鼓励了繁琐的方法签名或琐碎的错误处理)。</li><li id="40c5" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">它鼓励开发人员偷懒，简单地将他们的代码包装在粗粒度的try/catch块中，并一次性处理所有错误。</li></ul><p id="459b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，Go的方法强迫(或者至少强烈鼓励)工程师在错误出现时处理它们。没有运行时异常和检查异常:每个错误都以相同的优先级处理。</p><p id="1484" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么哪个更好呢？我不能肯定地说。据我所知，整个行业也是如此。在比较了Java和Go的方法之后，我唯一能说的是，永远不会有处理错误的完美解决方案。</p><h2 id="9383" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">好人</h2><p id="3efa" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">孤立地看，Go的方法是有道理的。对于任何给定的函数，我们很清楚这个函数可能会导致某种错误情况。在这些情况下，检测和处理错误相对简单。如果我们确信可以安全地忽略错误，那么忽略错误就更简单了(同样，如果没有明确的决定，几乎没有办法忽略错误)。</p><p id="6ce1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go的错误本身相对简单:它们只是任何符合<code class="fe mo mp mq mr b">error</code>接口的结构。除此之外——与Java异常不同——它们没有什么神奇之处。事实上，从技术上讲，我可以声明，如果一个错误条件发生，我的函数返回任何东西。</p><p id="9e82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Java中，方法可以声明它可能会遇到多种类型的错误:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="d925" class="mx ls it mr b gy my mz l na nb">public void parse(String filename) <br/>   throws FileNotFoundException, EncodingEception</span></pre><p id="6164" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们可能希望在代码中不同地处理每种类型的异常。在Java中这样做相对简单；我们简单地为每种类型实现一个<code class="fe mo mp mq mr b">catch</code>块。</p><p id="2e99" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我意识到在围棋上，我们做不到这一点。然而，考虑到声明一个函数返回一个错误并没有什么神奇的，我意识到我们可以扩展函数的接口来返回多个错误指示器:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="2ecb" class="mx ls it mr b gy my mz l na nb">func Parse(fname string) (File, notFoundError, encodingError)</span></pre><p id="3dd0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，<code class="fe mo mp mq mr b">notFoundError</code>和<code class="fe mo mp mq mr b">encodingError</code>需要表示接口，以使<code class="fe mo mp mq mr b">nil</code>能够在它们的位置返回。那会有用的。但缺点是它的非标准性质可能会让工程师感到困惑。</p><p id="f06d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我了解到惯用的方法是打开错误的具体类型:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="22df" class="mx ls it mr b gy my mz l na nb">func Parse(fname string) (File, error)</span><span id="2f85" class="mx ls it mr b gy nc mz l na nb">...</span><span id="5112" class="mx ls it mr b gy nc mz l na nb">file, err := Parse("file.txt")<br/>if (err != nil) {<br/>  switch err.(type) {<br/>    case *NotFoundError:<br/>      // handle not found errors<br/>    case *EncodingError:<br/>      // handle encoding error<br/>  }<br/>}</span></pre><h2 id="863b" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">坏事</h2><p id="8d54" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">从更大的角度来看，Go的错误处理可能相当痛苦。可能没有什么地方比编写数据库访问代码时更渴望Java的try/catch方法了。人们很容易忘记(也应该忘记)即使是一个简单的数据库操作也有许多部分会产生异常:打开连接、启动事务、执行查询、提交(或回滚)事务、关闭连接等。用Go写的时候，需要添加错误处理代码。因为。每个。还有。每一个。操作。</p><p id="17d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你可能猜到的，这变得相当乏味，相当快。</p><p id="2ea3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">公平地说，我应该注意到Go确实提供了一点语法上的好处，有助于减少我们输入的行数。我们可以将错误检查与函数调用本身结合起来，如下所示:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="00ed" class="mx ls it mr b gy my mz l na nb">if file, err := Parse("file.txt"); err != nil {<br/>  log.Printf("Error parsing file: %s", err.Error())<br/>} else {<br/>  // ... do something with `file`<br/>}</span></pre><p id="6ced" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于Go的错误处理方法，还有一件事让我感到困扰，尽管这主要是个人的小毛病。Go的方法迫使我们做以下事情:</p><ul class=""><li id="3f2b" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp oc nu nv nw bi translated">在编写函数时，我们经常需要在出错时返回一个变量的一次性实例。如果我们的函数的返回值是<code class="fe mo mp mq mr b">(File, error)</code>并且发生了错误，那么我们将需要返回类似于<br/> <code class="fe mo mp mq mr b">File{}, NotFoundError(“File not found”)</code></li><li id="6858" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">当使用这样的函数时，我们需要执行零检查</li></ul><p id="2c28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对我来说，每一个都是难闻的气味。</p><p id="bf5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种错误处理方法不允许的另一件事是错误会冒泡到main方法的调用堆栈。这实际上在某些环境中是有用的，比如web服务器，其中主控制器可以等待捕捉任何意外的异常并将它们翻译成500个响应代码。</p><p id="9b74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原来Go也提供这个功能…通过<code class="fe mo mp mq mr b">panic</code> s。</p><h2 id="1776" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">不要慌！好吧，好吧，继续恐慌吧。</h2><p id="6804" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">恐慌实际上非常类似于Java异常…至少是RuntimeExceptions。如果出现运行时错误(nil指针引用在Go中与在Java中一样糟糕！)那么就会出现恐慌。或者，我们可以明确地引起恐慌:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="087c" class="mx ls it mr b gy my mz l na nb">if (somethingBadHappened == true) {<br/>  panic("Something bad happened!")<br/>}</span></pre><p id="f586" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管是哪种情况，恐慌都会沿着调用堆栈向上蔓延。如果到达顶部，应用程序将崩溃并打印一个stacktrace。</p><p id="9e0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，正如我们可以<code class="fe mo mp mq mr b">catch</code> Java运行时异常一样，我们也可以<code class="fe mo mp mq mr b">recover</code>避免Go死机:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="6a42" class="mx ls it mr b gy my mz l na nb">defer func() {<br/>  if err := recover(); err != nil {<br/>    Log.printf("Recovering from panic: %s", err)<br/>  }<br/>}()</span></pre><p id="a391" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们从一个<em class="ms">延迟函数</em>中调用<code class="fe mo mp mq mr b">recover()</code>(在下一节中描述)时，它将返回一个传递给初始调用<code class="fe mo mp mq mr b">panic()</code>(按照惯例通常是一个<code class="fe mo mp mq mr b">string</code>)的实例。或者，如果应用程序当前没有出现紧急情况，则返回<code class="fe mo mp mq mr b">nil</code>。不管怎样，我们都可以在那时恢复正常运作。</p><h1 id="8ac1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">并发</h1><p id="daa0" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当Java第一次出现时，它经常吹嘘的一个好处是它比C或C++中的并发性容易得多。从那以后，Java的并发产品变得更加健壮，也更易于使用。</p><p id="7602" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管如此，Go的并发性对Java来说就像Java对C和C++的感觉一样。</p><p id="b96a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go最初的既定设计目标之一是强大而简单的并发性。基于Go提供的并发原语，这种设计已经被满足了。</p><p id="739c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看其中的一些原语</p><h2 id="eb8e" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">戈鲁廷斯</h2><p id="3c0a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">一个goroutine(这个名字是对术语<a class="ae lq" href="https://en.wikipedia.org/wiki/Coroutine" rel="noopener ugc nofollow" target="_blank">协程</a>的一种玩法)是一个代码单元(例如一个函数)，它可以与其他代码单元同时运行。Goroutines可能看起来像线，它们是相似的…但是更好。Goroutines的重量比线程轻得多，在内存方面的成本也低得多(通常只需要几千字节的堆栈，并且可以根据需要增加或减少大小)。</p><p id="2f7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">[来源:<a class="ae lq" href="https://golangbot.com/goroutines/" rel="noopener ugc nofollow" target="_blank">https://golangbot.com/goroutines/</a></p><p id="3e80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就旋转一台机器所需的代码而言，它们的成本也低得多；我们只需要在函数调用前加上<code class="fe mo mp mq mr b">go</code>关键字。让我们看一个例子:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="d7d7" class="mx ls it mr b gy my mz l na nb">go log.Printf("I am running in a goroutine!")</span></pre><p id="d0ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有…大概就是这样了！上面的代码行启动了一个新的goroutine，logs语句在其中运行。</p><h2 id="909a" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">频道</h2><p id="4c11" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Java的一个问题是跨线程通信。当然，多线程修改同一数据实例是可能的，但是这很容易导致争用情况和难以预料的调试结果。还有<a class="ae lq" href="https://www.geeksforgeeks.org/inter-thread-communication-java/" rel="noopener ugc nofollow" target="_blank">线程间通信</a>(你知道，这种技术使用<code class="fe mo mp mq mr b">wait()</code>和<code class="fe mo mp mq mr b">notify()</code>，并捕捉<code class="fe mo mp mq mr b">InterruptedException</code> s)，实现起来很痛苦。有像<code class="fe mo mp mq mr b">synchronized</code>这样的结构，它们可以工作，但是会导致性能瓶颈。还有第三方解决方案(演员系统之类的)。</p><p id="9b9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go提供了<em class="ms">频道</em>作为开箱即用的构造。通道为一个goroutine有效地向另一个通道发送消息提供了一种机制。打个比喻，我认为渠道是老式的锡罐电话系统；当我们发射goroutine时，我们将其中一个锡罐传递到goroutine中，并挂在另一个罐上，以便我们可以交流。</p><p id="1187" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从某种程度上来说，在我看来，通道介于前面提到的Java线程间通信和非常精简的actor系统之间。然而，通道本身并不是一个重量级的结构；相反，它是一个简单的<code class="fe mo mp mq mr b">chan</code>原语。</p><p id="ba4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要使用通道，我们只需通过调用<code class="fe mo mp mq mr b">make()</code>来创建它。Go是强类型的，通道也是强类型的，所以我们指示要通过通道发送的消息的数据类型。然后，我们将通道传递给将在另一个goroutine中运行的函数。我们使用箭头操作符(<code class="fe mo mp mq mr b">&lt;-</code>)向通道发送消息，并从通道接收消息。箭头操作符很有帮助，因为它总是显示通信的流向。也就是上面的<br/> <code class="fe mo mp mq mr b">ch &lt;- “Hello”</code> <br/>，我们正在向<code class="fe mo mp mq mr b">ch</code>频道发送“你好”的消息。在上面的<br/> <code class="fe mo mp mq mr b">msg := &lt;- ch</code> <br/>中，我们正在接收来自<code class="fe mo mp mq mr b">ch</code>通道的消息，并将其分配给<code class="fe mo mp mq mr b">msg</code>。</p><p id="fd7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子，它展示了使用通道是多么简单:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="7f64" class="mx ls it mr b gy my mz l na nb">func speak(anim Animal, ch chan string) {<br/>  // below, send a string message through the channel<br/>  ch &lt;- Sprintf("%s says '%s'. ", anim.Name(), anim.Speech())<br/>}</span><span id="92bb" class="mx ls it mr b gy nc mz l na nb">func main() {<br/>  dog := Animal{name:"Dog", speech:"Woof"}<br/>  cat := Animal{name:"Cat", speech:"Meow"}<br/>  // below, we create the channel, which will accept string messages<br/>  animalSpeechChannel := make(chan string)<br/>  // then we call speak() twice, passing the channel<br/>  go speak(dog, animalSpeechChannel)<br/>  go speak(cat, animalSpeechChannel)<br/>  // Then we block until we receive two messages via the channel<br/>  a1, a2 := &lt;- animalSpeechChannel, &lt;- animalSpeechChannel</span><span id="d987" class="mx ls it mr b gy nc mz l na nb">  fmt.Println(a1, a2) // Dog says 'Bark'. Cat says 'Meow'. <br/>}</span></pre><p id="b810" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管使用起来很简单，但是通道提供了更强大的构造，并且可以服务于更复杂的用例。例如:</p><ul class=""><li id="c905" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp oc nu nv nw bi translated">使用通道进行请求/响应类型的通信(即有效地调用一个函数并接收一个返回值，但是跨goroutines)。这可以很容易地完成，通过跨通道发送消息，并在该消息(需要是自定义数据类型)中提供第二个<em class="ms">响应通道</em>。</li><li id="3b2a" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">频道可以被取消，并且可以通知它们的接收器它们的取消。</li><li id="40b1" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">信道可以被缓冲，保存固定数量的元素，即使不存在接收元素的接收器。</li><li id="455d" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated">通道支持<a class="ae lq" href="https://www.toolbox.com/tech/enterprise-software/blogs/design-principles-fan-in-vs-fan-out-050407/" rel="noopener ugc nofollow" target="_blank">扇出和扇入</a>。</li></ul><h2 id="1f06" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">推迟</h2><p id="bf7b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">推迟就像一小片魔法。实际上，任何以关键字<code class="fe mo mp mq mr b">defer</code>开头的代码块都不会被执行，直到周围的函数将要返回。作为一个半人为的例子:</p><pre class="ki kj kk kl gt mt mr mu mv aw mw bi"><span id="ce38" class="mx ls it mr b gy my mz l na nb">func update(data string) {<br/>  conn, err := openConnection()<br/>  if (err != nil) {<br/>    log.Printf("Error opening connection")<br/>    return<br/>  }<br/>  defer conn.close()<br/>  // now, our connection will be closed no matter what<br/>  entity, err := conn.get(data.Id())<br/>  if (err != nil) {<br/>    log.Printf("Error getting entity")<br/>    return<br/>  }<br/>  err := conn.update(entity, data)<br/>  if (err != nil) {<br/>    log.Printf("Error updating entity")<br/>  }<br/>}</span></pre><p id="7864" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这对于强制清理任务非常有用，例如关闭连接，否则这些任务可能无法运行。正如在别处提到的，它让我们从恐慌中恢复过来。</p><h2 id="eb27" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">其他并发原语</h2><p id="96d1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Go还提供了其他并发原语，包括:</p><ul class=""><li id="6ce3" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp oc nu nv nw bi translated"><a class="ae lq" href="https://gobyexample.com/waitgroups" rel="noopener ugc nofollow" target="_blank"> Waitgroup </a>，允许我们轻松阻塞，直到给定数量的优秀goroutines完成</li><li id="1644" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp oc nu nv nw bi translated"><a class="ae lq" href="https://tour.golang.org/concurrency/9" rel="noopener ugc nofollow" target="_blank">互斥</a>，它提供了与Java的<code class="fe mo mp mq mr b">synchronized</code>构造相似的功能。</li></ul><p id="fb16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的并发原语都被设计为协同工作，允许我们轻松地开发极其复杂的并发应用程序。</p><h1 id="ac8b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">让我们继续前进</h1><p id="f333" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在本系列的<a class="ae lq" href="https://medium.com/p/672597c19ae4" rel="noopener">下一篇也是最后一篇文章</a>中，我们将从Go编码的本质上后退一步，讨论Go的编译和启动时间，包和模块如何帮助组织代码和依赖关系，以及内置于Go核心的一些高级功能。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="5171" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">觉得这个故事有用？想多读点？只需<a class="ae lq" href="https://dt-23597.medium.com/subscribe" rel="noopener">在此订阅</a>即可将我的最新故事直接发送到您的收件箱。</p><p id="de6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天<a class="ae lq" href="https://dt-23597.medium.com/membership" rel="noopener">成为媒体会员</a>，你也可以支持我和我的写作，并获得无限数量的故事。</p></div></div>    
</body>
</html>