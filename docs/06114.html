<html>
<head>
<title>A Telegram Bot using Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用朱莉娅的电报机器人</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-telegram-bot-using-julia-c302ff2614d2?source=collection_archive---------3-----------------------#2020-10-27">https://levelup.gitconnected.com/a-telegram-bot-using-julia-c302ff2614d2?source=collection_archive---------3-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/189cb44f64dd474a8049d037365665b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*voMo3KnFbQ4KrKA-"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@aideal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾迪尔·华</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="3ed2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我将向你展示如何使用Julia语言创建一个简单的机器人。</p><p id="1b06" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要描述的这个机器人非常通用，它可以读取消息，回复和存储与多个用户的对话状态。</p><p id="1a51" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将使用Telegram，因为它可以方便地访问API(【https://core.telegram.org/bots】T4)。</p><p id="b680" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当与机器人交互的用户可能处于对话的不同阶段时，我们将它们称为<strong class="kf jh">状态</strong>。这些状态需要被存储，所以我们会给机器人一个交互的记忆。</p><p id="57c6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将要描述的机器人将一些用户状态存储在一个数据库中，这个数据库可以是一个简单的文件，也可以是一个更复杂的数据库。</p><h1 id="0cde" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">机器人眼睛:解析消息</h1><p id="b7b0" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">电报API以JSON格式返回消息。幸运的是，Julia提供了一个<a class="ae jd" href="https://juliapackages.com/p/json" rel="noopener ugc nofollow" target="_blank"> JSON解析器</a>。当我们有消息时，我们可以简单地检索用户id(出于隐私原因，我不会读取或存储任何更多的信息，因为在这一点上它们是不必要的)。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2fdd" class="mo ld jg mk b gy mp mq l mr ms">function parse_message(message)<br/>    id = message["message"]["from"]["id"]<br/>    update_contact_list(message)<br/>    state = get_state(id)<br/><br/>    if (state == 0) | (message["message"]["text"]=="/start")<br/>        send_welcome(message["message"]["from"])<br/>        set_state(id, 1)<br/>    elseif (state == 1) | (message["message"]["text"]=="/cook")<br/>        ask_program(message["message"]["from"])<br/>        set_state(id, 2)<br/>    elseif state == 3<br/>        send_bye(message["message"]["from"])<br/>        set_state(id, 1)<br/>    end<br/>end</span></pre><h1 id="de95" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">bot内存:创建一个数据库</h1><p id="6016" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">使用<a class="ae jd" href="https://github.com/JuliaDatabases/PostgreSQL.jl" rel="noopener ugc nofollow" target="_blank">PostgreSQL</a>模块可以创建一个数据库</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1998" class="mo ld jg mk b gy mp mq l mr ms">function init_db()<br/>    conn = LibPQ.Connection("dbname=dname user=bot password=supersecret host=database")<br/><br/>    result = execute(conn, """<br/>        CREATE TABLE IF NOT EXISTS dname (<br/>            id    integer PRIMARY KEY,<br/>            state   integer,<br/>            program varchar(10)<br/>        );<br/>    """)<br/>    close(conn)<br/>end</span></pre><p id="438e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并与它建立联系。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="d751" class="mo ld jg mk b gy mp mq l mr ms">function get_connection()<br/>    global conn<br/>    if conn == -1<br/>        conn = LibPQ.Connection("dbname=dname user=bot password=supersecret host=database")<br/>    end<br/>    return conn<br/>end</span></pre><h1 id="5670" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">机器人交互:存储的密钥</h1><p id="499b" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们将在这里构建的机器人可以为每个用户存储一个或多个信息。为了可用性和可移植性，我将创建两个函数<em class="lb"> get_key </em>和<em class="lb"> set_key </em>，每个函数都能够读取和存储一些与用户相关的值。特别是，机器人可以存储<strong class="kf jh">状态</strong>键，它包含与用户对话的当前状态。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fd92" class="mo ld jg mk b gy mp mq l mr ms">function get_key(id, key)<br/>    res = execute(conn, "SELECT * from pizza_bot WHERE id=$id;")<br/>    data = columntable(res)<br/>    keys = Dict("id"=&gt;data[1][1], "state"=&gt;data[2][1], "program"=&gt;data[3][1])<br/>    return keys[key]<br/>end<br/><br/>function set_key(id, key, value)<br/>    res = execute(conn, "UPDATE pizza_bot SET $(key)='$value' WHERE id=$id;")<br/>end</span></pre><h1 id="5e1d" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">机器人说话:发送信息</h1><p id="4588" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在Julia中,<a class="ae jd" href="https://github.com/JuliaWeb/HTTP.jl" rel="noopener ugc nofollow" target="_blank"> HTTP </a>包提供了向Telegram API发送数据和发送消息的方法。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9778" class="mo ld jg mk b gy mp mq l mr ms">function send_message(params)    <br/>    req = HTTP.request("POST",string(url,key,"/sendMessage"),["Content-Type" =&gt; "application/json"],JSON.json(params))<br/>end</span></pre><h1 id="d5c4" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">机器人生活:组装起来运行</h1><p id="54af" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">机器人现在可以阅读、说话和记忆东西，我们只需要从消息服务中<em class="lb">/get updates</em>et voilà交互就已经设置好了！</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="784b" class="mo ld jg mk b gy mp mq l mr ms">function run()<br/>    offset = -1<br/><br/>    println("ready!")<br/>    while true<br/>        if offset &gt;= 0<br/>            params = Dict("offset"=&gt;offset)<br/>        else<br/>            params = Dict()<br/>        end<br/>        req = HTTP.request("GET", string(url,key,"/getUpdates"), ["Content-Type" =&gt; "application/json"],JSON.json(params))<br/>        body = String(req.body)<br/>        result = JSON.Parser.parse(body)<br/><br/>        if length(result["result"]) &lt; 1<br/>            continue<br/>        end<br/>        offset = result["result"][end]["update_id"] + 1<br/>        for message in result["result"]<br/>           parse_message(message)<br/>        end<br/>        sleep(0.1)<br/>    end<br/>end</span></pre><h1 id="e699" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">密码</h1><p id="5ec0" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">一个简单机器人的完整代码可以从我在https://github.com/fvalle1/pizza_bot的仓库中获得</p></div></div>    
</body>
</html>