<html>
<head>
<title>Isometric Views in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的等轴测视图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/isometric-viewmodifier-aafcaee1c9a?source=collection_archive---------6-----------------------#2020-08-14">https://levelup.gitconnected.com/isometric-viewmodifier-aafcaee1c9a?source=collection_archive---------6-----------------------#2020-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d7b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于使用自定义视图修改器将2D视图和图像转换为等轴测视图的SwiftUI教程。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21142b075bb8b5a2cfdd0bd4db6b055d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EqxTSN6wdRUBTGdG.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">等距SwiftUI视图</figcaption></figure><p id="a901" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前几天，我开始在Figma中将2D的设计转换成等距视图。我认为在SwiftUI中创建一个做同样事情的<code class="fe lu lv lw lx b">ViewModifier</code>可能会很棒。在<a class="ae ly" href="https://twitter.com/TrailingClosure/status/1292525094481219585?s=20" rel="noopener ugc nofollow" target="_blank"> twitter </a>上发布了我的工作截图后，我决定写这篇教程。</p><h2 id="c4f0" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">概观</h2><p id="d889" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我把教程分成了两部分(都在下面):</p><ol class=""><li id="770d" class="mx my it la b lb lc le lf lh mz ll na lp nb lt nc nd ne nf bi translated">将等轴测变换应用于视图</li><li id="c396" class="mx my it la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">拉伸等轴测视图</li></ol><blockquote class="nl nm nn"><p id="b51d" class="ky kz no la b lb lc ju ld le lf jx lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">在开始之前，请考虑使用这个<a class="ae ly" href="https://trailingclosure.com/signup/?utm_source=trailing_closure&amp;utm_medium=blog_post&amp;utm_campaign=isometric_viewmodifier" rel="noopener ugc nofollow" target="_blank">链接</a>订阅，如果你没有在<a class="ae ly" href="https://trailingclosure.com/?utm_source=trailing_closure&amp;utm_medium=blog_post&amp;utm_campaign=isometric_viewmodifier" rel="noopener ugc nofollow" target="_blank">TrailingClosure.com</a>上阅读这篇文章，请随时来看看我们！</p></blockquote><p id="807c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在整个教程中，你会看到我最好的2D方形西瓜片图。是的…我提前道歉，但是当我写这个教程的时候，有一个正坐在我的前面，所以那就是你将要得到的图像…😊</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f030fe62a1bbef3fd4a8c845b5f6edd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/0*2jascsmoErXckDaK.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">假装是西瓜片…</figcaption></figure><h2 id="d882" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">将2D视图转换为等轴测视图</h2><p id="c9fa" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">变换2D视图的最简单的方法之一是旋转它<code class="fe lu lv lw lx b">45°</code>，然后按因子<code class="fe lu lv lw lx b">0.5</code>缩放它的高度。简单旋转收缩！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/7a8c3e3c98cc14e20cdd5989813e68a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jSwZIwuFobxHvk6k.png"/></div></div></figure><h2 id="18c4" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">写成自定义<code class="fe lu lv lw lx b">ViewModifier</code></h2><p id="f077" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">现在我们可以采取上面的步骤，将它转换成一个定制的SwiftUI <code class="fe lu lv lw lx b">ViewModifier</code>，如下所示:</p><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="278f" class="lz ma it lx b gy ny nz l oa ob">struct IsometricViewModifier: ViewModifier {<br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            .rotationEffect(Angle(degrees: 45), anchor: .center)<br/>            .scaleEffect(x: 1.0, y: 0.5, anchor: .center)<br/>    }<br/>}</span></pre><p id="0f79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当设计师想要在真实设备上模拟他们的UI设计时，这种技术被广泛使用。下面你可以看到它是如何在我的另一个教程的设计中使用的。这真的就像旋转和缩放高度一样简单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/9e1670b8d86a48f83d0bf28e8ed42733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nOtHte5d-dV1Coeh.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">典型的用户界面设计模型</figcaption></figure><p id="1e3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">反向反向！</strong></p><p id="440a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在实体模型图像上颠倒上述步骤，那么我们得到的是等距变换前的原始图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/4d4c38a0348b3f66e4e02a2d6c268c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*080xMAhOGZCnXvuB.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">预等距变换</figcaption></figure><h2 id="6fc1" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">拉伸等轴测视图</h2><p id="cc72" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">现在是最难的部分。我们的等距视图缺少的是深度。对于下一个零件，我们将创建等轴测视图的拉伸基础。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/9399ab0382650a395cbabf1091920975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*an9gFNlZY-n6q9GZ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">平面与拉伸等轴测视图</figcaption></figure><blockquote class="nl nm nn"><p id="8f7c" class="ky kz no la b lb lc ju ld le lf jx lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">请注意，本节提供了非圆角矩形视图的拉伸技术。我仍然在用潜在的方法来应用等距变换，并用圆角挤出视图。在像Figma这样的设计程序中，这可能很容易，但是将这个过程转换成代码却很困难。</p></blockquote><h2 id="d0b5" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">模拟挤压</h2><p id="23f8" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">为了创建一个完美的视图，我们需要从外面(前面两个等轴测的边)取颜色，并沿着等轴测的z轴向下延伸。我实现这一点的方法是沿着x或y轴缩放所提供的内容，然后将其裁剪到正确的大小和形状。这使我们能够从图像和渐变等视图中保留精确的颜色。</p><p id="5db2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这种技术，我将挤出分解为两个部分:左前侧和右前侧。在代码中，它们实际上是2D等轴测视图上的两个单独的覆盖图。</p><h2 id="4335" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">自定义<code class="fe lu lv lw lx b">ExtrudeModifier</code></h2><p id="7cb4" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">这里是<code class="fe lu lv lw lx b">ExtrudeModifier</code>结构的模板。下面我将通过一组图片来展示挤压前左侧。然后我简单的把同样的过程复制到对面，完成挤压。</p><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="9d94" class="lz ma it lx b gy ny nz l oa ob">struct ExtrudeModifier&lt;Texture: View&gt; : ViewModifier {<br/>    <br/>    var depth: CGFloat // Extrusion Depth<br/>    var texture: Texture<br/>    <br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            // Front Left Side<br/>            .overlay(<br/>            	// Content (Texture) here<br/>            , alignment: .center)<br/>            <br/>            // Front Right Side<br/>            .overlay(<br/>                // Content (Texture) here<br/>            , alignment: .center)<br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6a5382c26916762e455517e830a0d35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3mhXVoMp6i3NK_9r.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/d0ae22c8e66a306f155295b9c54a0561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lMidaKbrGV5w6jq9.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/cab3a42906d6a4080cc9f5d810bfafcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T06kM-dVqBBttKwM.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/bc6f56e85bee15c62991540862cfba77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Bxsn-zCcgX6zzwnm.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/58b52a4b31d00756b48ea1cff9c62a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MAKq-GdPIoIUf3PQ.png"/></div></div></figure><p id="a39a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面代码中的步骤引用</p><p id="f33c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面我评论了我为创建挤压的前半部分所采取的步骤。</p><blockquote class="nl nm nn"><p id="7220" class="ky kz no la b lb lc ju ld le lf jx lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">注意:上面的照片已经申请了<code class="fe lu lv lw lx b">offset(x: 0, geo.size.height)</code>。我这样做是为了帮助读者在我浏览代码时直观地看到这些步骤。</p></blockquote><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="ba69" class="lz ma it lx b gy ny nz l oa ob">struct ExtrudeModifier&lt;Texture: View&gt; : ViewModifier {<br/>    <br/>    var depth: CGFloat<br/>    var texture: Texture<br/>    <br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            // Front Left Side<br/>            .overlay(<br/>                GeometryReader { geo in<br/>                    texture // Step 2<br/>                        .brightness(-0.05)<br/>                        .scaleEffect(x: 1, y: geo.size.height * geo.size.height, anchor: .bottom) // Step 3<br/>                        .frame(height: depth, alignment: .top) // Step 4<br/>                        .mask(Rectangle())<br/>                        .rotation3DEffect(<br/>                            Angle(degrees: 180),<br/>                            axis: (x: 1.0, y: 0.0, z: 0.0),<br/>                            anchor: .center,<br/>                            anchorZ: 0.0,<br/>                            perspective: 1.0<br/>                        )<br/>                        .projectionEffect(ProjectionTransform(CGAffineTransform(a: 1, b: 0, c: 1, d: 1, tx: 0, ty: 0))) // Step 5<br/>                        .offset(x: 0, y: geo.size.height)<br/>                        <br/>                }<br/>                , alignment: .center)<br/>            <br/>            // Front Right Side<br/>            .overlay(<br/>            	// TO DO    <br/>            , alignment: .center)<br/>                <br/>    }<br/>}</span></pre><p id="fc6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">现在另一侧</strong> <br/>现在我将同样的技巧应用到等轴测视图的另一侧。</p><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="1b59" class="lz ma it lx b gy ny nz l oa ob">struct ExtrudeModifier&lt;Texture: View&gt; : ViewModifier {<br/>    <br/>    var depth: CGFloat<br/>    var texture: Texture<br/>    <br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            // Front Left Side<br/>            .overlay(<br/>           		// See code from before...<br/>            , alignment: .center)<br/>            <br/>            // Front Right Side<br/>            .overlay(<br/>                GeometryReader { geo in<br/>                    texture<br/>                        .brightness(-0.1)<br/>                        .scaleEffect(x: geo.size.width * geo.size.width, y: 1.0, anchor: .trailing)<br/>                        .frame(width: depth, alignment: .leading)<br/>                        .clipped()<br/>                        .rotation3DEffect(<br/>                            Angle(degrees: 180),<br/>                            axis: (x: 0.0, y: 1.0, z: 0.0),<br/>                            anchor: .leading,<br/>                            anchorZ: 0.0,<br/>                            perspective: 1.0<br/>                        )<br/>                        .projectionEffect(ProjectionTransform(CGAffineTransform(a: 1, b: 1, c: 0, d: 1, tx: 0, ty: 0)))<br/>                        .offset(x: geo.size.width + depth, y: 0 + depth)<br/>                }<br/>                , alignment: .center)<br/>                <br/>    }<br/>}</span></pre><p id="f322" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">你为什么要改变两边的亮度？</strong></p><p id="0377" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你注意到上面，我修改了两个叠加的亮度，使它们更暗。这有助于模拟等轴测视图的三维特性。没有它，视图在屏幕上看起来会很简单，很平坦。在下面的比较中，请注意这有多么大的不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/69cf3df9ed6b8f2fd80ffcb363c19c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AVm1HKHO8o3eoISC.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">亮度无变化与变化</figcaption></figure><h2 id="5901" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">把所有的放在一起</h2><p id="7229" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">如果你愿意，你可以创建一个定制的<code class="fe lu lv lw lx b">IsometricView</code>组件，利用上面的<code class="fe lu lv lw lx b">ExtrudeModifier</code>和<code class="fe lu lv lw lx b">IsometricViewModifier</code>。此自定义组件为开发人员提供了动态更改视图是否等轴测以及拉伸深度的选项。</p><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="3445" class="lz ma it lx b gy ny nz l oa ob">struct IsometricView&lt;Content: View&gt;: View {<br/>    <br/>    var active: Bool<br/>    var content: Content<br/>    var extruded: Bool<br/>    var depth: CGFloat<br/>    <br/>    init(active: Bool, extruded: Bool = false, depth: CGFloat = 20, @ViewBuilder content: ()-&gt; Content) {<br/>        self.active = active<br/>        self.extruded = extruded<br/>        self.depth = depth<br/>        self.content = content()<br/>    }<br/>    <br/>    @ViewBuilder var body: some View {<br/>        if active {<br/>            if extruded {<br/>                content<br/>                    .modifier(ExtrudeModifier(depth: depth, background: content))<br/>                    .modifier(IsometricViewModifier(active: active))<br/>                    .animation(.easeInOut)<br/>            } else {<br/>                content<br/>                    .modifier(IsometricViewModifier(active: active))<br/>                    .animation(.easeInOut)<br/>            }<br/>        } else {<br/>            content<br/>                .animation(.easeInOut)<br/>        }<br/>        <br/>    }<br/>}</span></pre><h2 id="57d1" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">示例使用</h2><p id="62a6" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">一旦你开始玩<code class="fe lu lv lw lx b">IsometricViewModifier</code>和<code class="fe lu lv lw lx b">ExtrudeModifier</code>，你就可以做出一些有趣的东西。下面我有一个浮动等距视图，另一个有两个不同的挤出纹理，也有一个图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/da7ab82e38a5755f8f7915964b390483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*9ElrcNlf9jufCneM.gif"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/4d5339b34229718ca8e874f3e84cb684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3kF76UWc55AxqoWw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a2d764ac474a8350ea683c23fd499ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3Dt_tKGBF-AgXDwO.png"/></div></div></figure><h2 id="4977" class="lz ma it bd mb mc md dn me mf mg dp mh lh mi mj mk ll ml mm mn lp mo mp mq mr bi translated">让我们看看你做了什么！</h2><p id="f2a5" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">我们想看看你用这个教程做了什么！给我们发照片！在Twitter <a class="ae ly" href="https://twitter.com/TrailingClosure" rel="noopener ugc nofollow" target="_blank"> @TrailingClosure </a>、insta gram<a class="ae ly" href="https://www.instagram.com/trailingclosure/" rel="noopener ugc nofollow" target="_blank">上找到我们，或者发邮件到howdy@TrailingClosure.com<!-- -->联系我们<!-- -->。</a></p></div></div>    
</body>
</html>