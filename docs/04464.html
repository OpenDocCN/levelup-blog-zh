<html>
<head>
<title>Practical Use Cases of Sets in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中集合的实际用例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-use-cases-of-sets-in-javascript-bb0a3309675?source=collection_archive---------8-----------------------#2020-06-28">https://levelup.gitconnected.com/practical-use-cases-of-sets-in-javascript-bb0a3309675?source=collection_archive---------8-----------------------#2020-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jp jq jr js gh gi paragraph-image"><div class="gh gi jo"><img src="../Images/842686e09505b4f25a8ad71f2defe083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5ZPPJFvdo16Z2CUbzlcyGg.jpeg"/></div></figure><p id="44a0" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">对于不熟悉<code class="fe kt ku kv kw b">Set</code>的开发人员来说，它只是一组明确的、不同的对象。通俗地说，集合就是一组无序的唯一元素。把<code class="fe kt ku kv kw b">Set</code>想象成一个数组，但是只包含唯一的值。</p><p id="ed8d" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated"><em class="kx">由于集合的实现是基于哈希表的，所以它们具有O(1)的常数时间运算。</em></p><p id="78c8" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated"><em class="kx">用Javascript创建集合:</em></p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="8995" class="lg lh iq kw b gy li lj l lk ll"><em class="kx">let arr = [1,2,3,4,4];<br/>const set = new Set(arr)</em></span></pre><figure class="ky kz la lb gt js gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lm"><img src="../Images/39813ac077507dc3e463636f01a0e7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQTyVMxVl6YcGR3yMUGEaw.png"/></div></div></figure><p id="6141" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">所以我们看到set从数组中删除了重复项(这本身就是一个非常方便的用例)。</p><p id="aefe" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">现在我们来看我自己已经多次使用过的实际用例。</p><p id="5c10" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated"><strong class="jx ir">用例1 </strong> : <em class="kx">你有一个1000000个元素的数组。检查数组是否包含重复项？</em></p><p id="cc12" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">首先，让我们创建一个包含1000000个元素的数组。</p><figure class="ky kz la lb gt js gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lr"><img src="../Images/01756b156626790d749bc5d89195348c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5-kFjYP4x1CSI1CAU81Zg.png"/></div></div></figure><p id="d7d2" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">现在我们的<code class="fe kt ku kv kw b">largeArray</code>变量包含了一个由1000000个原语组成的数组。我们还在10000点索引处添加了一个副本。</p><p id="bb56" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">我们有我们的数据，我们需要确定是否有任何重复存在。我们将讨论两种方法(有和没有器械包),并检查哪种方法花费的时间更多。第一种方法我们将使用lodash的<a class="ae ls" href="https://lodash.com/docs/4.17.15#uniq" rel="noopener ugc nofollow" target="_blank"> <strong class="jx ir"> _。uniq </strong> </a> <strong class="jx ir"> </strong>方法<strong class="jx ir">。</strong></p><p id="74b0" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">我们还将使用<code class="fe kt ku kv kw b">console.time()</code>来记录这个函数所花费的时间。</p><figure class="ky kz la lb gt js gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lt"><img src="../Images/faaa187aea5093ad20e7a50258114a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LKvBt_oHwQk4Hh23Gb9FxQ.png"/></div></div></figure><p id="824b" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">该功能执行10次后的<code class="fe kt ku kv kw b">console.time()</code>结果如下:</p><figure class="ky kz la lb gt js gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lu"><img src="../Images/b751030426a896971ae25048b4cbb9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7qsbEqU8a04foi9zx3f9Q.png"/></div></div></figure><p id="1460" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">现在是我们第二种方法的时候了:</p><figure class="ky kz la lb gt js gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lv"><img src="../Images/4344efc86619d3bde155d68babc19ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4ywA5jYJeuopTs3EgaW2Q.png"/></div></div></figure><figure class="ky kz la lb gt js gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lw"><img src="../Images/e31a28236cc6de28efee489a7f3a52d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZyv2eRAB4tK95FT8g_a4w.png"/></div></div></figure><p id="0b24" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">所以看起来10次中有10次<code class="fe kt ku kv kw b">Set</code>打败了<code class="fe kt ku kv kw b">uniq</code>。</p><p id="d045" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated"><strong class="jx ir">用例2: </strong> <em class="kx">给定两个数组，返回第三个数组中包含的两个数组的所有唯一值。</em></p><p id="dc10" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">听起来很熟悉对吧。您可能在面试环境中听说过它，甚至在合并两个列表并从一个数组中删除重复项时发现了它的必要性。</p><p id="b4b2" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">这是使用集合的解决方案。</p><figure class="ky kz la lb gt js gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lx"><img src="../Images/c25153295f57950b5d12026903d8eccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSYWTSdlfPhQduwJVqHSIg.png"/></div></div></figure><p id="e8de" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated">我们得到的结果看起来像这样。</p><figure class="ky kz la lb gt js gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi ly"><img src="../Images/918577e250c396a984626001a19bbc3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYnXGJNYplUgc8pugYg_Fw.png"/></div></div></figure><p id="9f5a" class="pw-post-body-paragraph jv jw iq jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ij bi translated"><code class="fe kt ku kv kw b">Set</code>对象支持插入、删除、包含检查，时间复杂度均为O(1)。使用这些内置方法，可以实现其他基本设置。这些将使我们能够实现具有快速唯一性的算法。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><div class="ky kz la lb gt mg"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">编写面试问题</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">掌握编码面试的过程</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">技术开发</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu jt mg"/></div></div></a></div></div></div>    
</body>
</html>