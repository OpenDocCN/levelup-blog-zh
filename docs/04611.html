<html>
<head>
<title>What is Docker Series: Part 2— Images and Dockerfiles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Docker系列:第2部分—图像和Docker文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-docker-series-part-2-images-and-dockerfiles-141c15eaca0f?source=collection_archive---------25-----------------------#2020-07-05">https://levelup.gitconnected.com/what-is-docker-series-part-2-images-and-dockerfiles-141c15eaca0f?source=collection_archive---------25-----------------------#2020-07-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="dcb8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">你能跑什么和你需要什么开始。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c4f7bf62a9621139b523d9509c0238f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHZ-bVe_DRxLZOY0Dvmbwg.jpeg"/></div></div></figure><p id="1176" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">图像是Docker包含并运行在计算机上的内容。这是容器在数据持久化或发生变化之前运行的基础。运送给客户的每个集装箱都从这个基础映像开始。Docker的基础是在每个主机操作系统上拥有相同的环境。</p><p id="ed30" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">让我们回顾一下，讨论一下Docker是如何运行它的容器和进程的。</p><h2 id="662e" class="lr ls iu bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">概观</h2><p id="29ea" class="pw-post-body-paragraph kv kw iu kx b ky mk jv la lb ml jy ld le mm lg lh li mn lk ll lm mo lo lp lq in bi translated">Docker是以客户机-服务器的方式设计的。客户机(每个Docker容器)与服务器(Docker守护进程)进行对话，服务器负责提取、构建和运行容器。</p><h2 id="d4f1" class="lr ls iu bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">守护进程</h2><p id="ac8a" class="pw-post-body-paragraph kv kw iu kx b ky mk jv la lb ml jy ld le mm lg lh li mn lk ll lm mo lo lp lq in bi translated">Docker守护进程(<code class="fe mp mq mr ms b">dockerd</code>)可以在主机上运行，也可以将Docker客户端连接到远程守护进程。守护程序/客户端通信使用UNIX套接字或网络接口通过REST API进行对话。</p><h2 id="20f9" class="lr ls iu bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">客户</h2><p id="99b2" class="pw-post-body-paragraph kv kw iu kx b ky mk jv la lb ml jy ld le mm lg lh li mn lk ll lm mo lo lp lq in bi translated">Docker客户端(<code class="fe mp mq mr ms b">docker</code>)是开发人员直接与守护进程交互的方式。Docker命令使用Docker API，可以与多个守护进程通信。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj mt"><img src="../Images/e4441033f1fdf77ca6e77fc202353431.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*ImxdtYzU76tXuO-G.png"/></div><figcaption class="mu mv gk gi gj mw mx bd b be z dk translated">摘自<a class="ae my" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank">码头工人概述</a>。</figcaption></figure><h1 id="ed21" class="mz ls iu bd lt na nb nc lw nd ne nf lz ka ng kb mc kd nh ke mf kg ni kh mi nj bi translated">Docker对象</h1><h2 id="2b97" class="lr ls iu bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">形象</h2><p id="c5a4" class="pw-post-body-paragraph kv kw iu kx b ky mk jv la lb ml jy ld le mm lg lh li mn lk ll lm mo lo lp lq in bi translated">图像是一个只读模板，包含创建容器的说明。有时候这个图像是从另一个图像延伸出来的。一个真正的起点。</p><p id="66d0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">要创建一个图像，你需要创建一个<code class="fe mp mq mr ms b">Dockerfile</code>(更多内容见下文)。</p><h2 id="c17b" class="lr ls iu bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">容器</h2><p id="f3b2" class="pw-post-body-paragraph kv kw iu kx b ky mk jv la lb ml jy ld le mm lg lh li mn lk ll lm mo lo lp lq in bi translated">这些是图像的可运行实例。您可以使用“Docker容器”来构建、启动、停止、移动或删除容器。</p><p id="5500" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">一个容器可以和其他容器一起添加到网络中，否则，它就和系统完全隔离了。此外，除非数据在容器被移除或停止时在系统上是持久的，否则所有数据都将丢失。</p><h2 id="54ab" class="lr ls iu bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">服务</h2><p id="d484" class="pw-post-body-paragraph kv kw iu kx b ky mk jv la lb ml jy ld le mm lg lh li mn lk ll lm mo lo lp lq in bi translated">服务赋予Docker跨多个守护进程扩展的能力，然后这些守护进程在一个集群中通过网络相互通信。群中的每个成员都是一个守护进程，都与Docker API通信。</p><p id="38f5" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在我们已经讨论了docker的概念，让我们来看看一些图像、Docker文件和docker-compose文件，看看我们可以运行什么，以及我们可以在哪里创建自己的文件。</p></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nr"><img src="../Images/6077ff5d628bd8cd51898bca2fbb75a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kt9yWxus-H7jofvn"/></div></div><figcaption class="mu mv gk gi gj mw mx bd b be z dk translated">奥斯卡·伊尔迪兹在<a class="ae my" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="a82c" class="mz ls iu bd lt na nb nc lw nd ne nf lz ka ng kb mc kd nh ke mf kg ni kh mi nj bi translated">码头文件</h1><p id="0c60" class="pw-post-body-paragraph kv kw iu kx b ky mk jv la lb ml jy ld le mm lg lh li mn lk ll lm mo lo lp lq in bi translated">在我的GitHub Actions帖子(<a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/how-to-write-github-actions-30b54ddf6f52">链接</a>)中，我举了一个类似<code class="fe mp mq mr ms b">Dockefile</code>的例子:</p><pre class="kk kl km kn gu ns ms nt nu aw nv bi"><span id="20c0" class="lr ls iu ms b gz nw nx l ny nz">FROM python:3<br/>COPY script_name.py /script_name.py<br/>ENTRYPOINT ['python', 'script_name.py</span></pre><p id="ec96" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这个映像表示我们正在从<code class="fe mp mq mr ms b">python</code>映像<code class="fe mp mq mr ms b">:(tag)3</code>中提取，将文件<code class="fe mp mq mr ms b">script_name.py</code>复制到映像中的<code class="fe mp mq mr ms b">/script_name.py</code>，然后运行<code class="fe mp mq mr ms b">python</code> CLI并使用脚本。</p><p id="07c9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在另一个使用NodeJS和NPM的项目中，我想仅通过SSH克隆repo，因此将一个网络密钥传递到将运行的映像的<code class="fe mp mq mr ms b">id_rsa</code>密钥中，因此在构建映像的任何时候都可以克隆repo(主要是在运行GitHub动作来测试<code class="fe mp mq mr ms b">npm test</code>输出的结果时)。</p><pre class="kk kl km kn gu ns ms nt nu aw nv bi"><span id="adaf" class="lr ls iu ms b gz nw nx l ny nz">FROM alpine/git:latest as clone<br/>MAINTAINER Spencer Pollock "<a class="ae my" href="mailto:spencer@spollock.ca" rel="noopener ugc nofollow" target="_blank">spencer@spollock.ca</a>"</span><span id="ea53" class="lr ls iu ms b gz oa nx l ny nz">WORKDIR /root</span><span id="b6e8" class="lr ls iu ms b gz oa nx l ny nz">RUN mkdir /root/.ssh/<br/>ADD id_rsa /root/.ssh/id_rsa<br/>RUN chmod 600 /root/.ssh/id_rsa<br/>RUN touch /root/.ssh/known_hosts<br/>RUN ssh-keyscan -t rsa github.com &gt;&gt; /root/.ssh/known_hosts<br/>RUN chown -R root:root /root/.ssh</span><span id="67e2" class="lr ls iu ms b gz oa nx l ny nz">RUN git clone --progress --verbose <a class="ae my" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:srepollock/typescript-bootstrap.git &gt; /dev/null</span><span id="17bc" class="lr ls iu ms b gz oa nx l ny nz">#</span><span id="626c" class="lr ls iu ms b gz oa nx l ny nz">FROM node:13.8.0-alpine<br/>MAINTAINER Spencer Pollock "<a class="ae my" href="mailto:spencer@spollock.ca" rel="noopener ugc nofollow" target="_blank">spencer@spollock.ca</a>"</span><span id="3fce" class="lr ls iu ms b gz oa nx l ny nz">WORKDIR /root</span><span id="4530" class="lr ls iu ms b gz oa nx l ny nz">COPY --from=clone /root/typescript-bootstrap/ /root/</span><span id="fd20" class="lr ls iu ms b gz oa nx l ny nz">RUN npm i &amp;&amp; \<br/>    npm run bundle &amp;&amp; \<br/>    npm run test</span></pre><p id="6e3a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">最后，我们可以得到一个Ubuntu 20.04容器，您可以通过以下步骤与它交互并运行:</p><p id="953e" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">创建一个<code class="fe mp mq mr ms b">Dockerfile</code>:</p><pre class="kk kl km kn gu ns ms nt nu aw nv bi"><span id="afee" class="lr ls iu ms b gz nw nx l ny nz">FROM ubuntu:20.04<br/>RUN apt-get update<br/>RUN apt-get install -y<br/>CMD ["/bin/bash"]</span></pre><p id="415a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在<code class="fe mp mq mr ms b">Dockerfile</code>的文件夹中建立镜像:</p><p id="8db4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe mp mq mr ms b">docker build -t [dockerhub_username]/ubuntu-20_04 .</code></p><p id="a9b7" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">运行映像直到停止:</p><p id="d13c" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe mp mq mr ms b">docker run -d [dockerhub_username]/ubuntu-20_04 sleep inifinitly</code></p><p id="3828" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">获取容器ID:</p><p id="be6a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe mp mq mr ms b">docker ps</code></p><p id="0bf9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">使用ID在Docker容器中交互运行以下命令:</p><p id="28b4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe mp mq mr ms b">docker exec -it [container_id] bash</code></p><p id="34de" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在你有一个正在运行的Ubuntu实例可以玩了！存储不是持久的，但我们会谈到这一点。</p><p id="384a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">无论如何，在你自己的工作流程中尝试一下。要开始使用它们，将<code class="fe mp mq mr ms b">Dockerfile</code>中的行添加到项目根文件夹中，运行<code class="fe mp mq mr ms b">docker build -t [dockerhub_username]/[project_name] .</code>就可以构建容器了。然后运行<code class="fe mp mq mr ms b">docker run [dockerhub_username/proejct_name]</code>，您将开始运行图像！所有的<code class="fe mp mq mr ms b">stdout</code>文本都会出现在你的控制台上。</p></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/a837ccfe174dc0c5b6f7d80efdd08c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J3jnDaVY2FIfu4fI"/></div></div><figcaption class="mu mv gk gi gj mw mx bd b be z dk translated">Anthony Tori 在<a class="ae my" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="31e0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">既然我们已经有了三个不同的<code class="fe mp mq mr ms b">Dockerfiles</code>示例，并且还有更多关于<a class="ae my" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank">hub.docker.com</a>的示例供您使用，在本系列的下一部分，我们将使用Docker Compose添加另一个层次的复杂性。</p><blockquote class="oc"><p id="0803" class="od oe iu bd of og oh oi oj ok ol lq dk translated">走出去，用你刚刚获得的知识做些事情。建造一些有用和伟大的东西！</p></blockquote></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><h1 id="1eb1" class="mz ls iu bd lt na om nc lw nd on nf lz ka oo kb mc kd op ke mf kg oq kh mi nj bi translated">什么是Docker系列:</h1><ul class=""><li id="8010" class="or os iu kx b ky mk lb ml le ot li ou lm ov lq ow ox oy oz bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/what-is-docker-series-part-1-1e419c28f951">第一部分</a></li></ul></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><p id="dd09" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">感谢您抽出时间阅读。我希望您在这个过程中对Docker有了更多的了解。在接下来的几天里，我会继续写这些帖子。</p><p id="f5de" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">祝一切顺利，保持安全——斯潘塞</p></div><div class="ab cl nk nl hy nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="in io ip iq ir"><h2 id="2169" class="lr ls iu bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">参考文献</h2><p id="81bf" class="pw-post-body-paragraph kv kw iu kx b ky mk jv la lb ml jy ld le mm lg lh li mn lk ll lm mo lo lp lq in bi translated">许多参考资料都取自于<a class="ae my" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank">码头工人</a> <a class="ae my" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">文档资料</a> <a class="ae my" href="https://docs.docker.com/reference/" rel="noopener ugc nofollow" target="_blank">发现</a> <a class="ae my" href="https://docs.docker.com/engine/reference/builder/#run" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>