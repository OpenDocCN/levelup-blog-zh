<html>
<head>
<title>Kotlin Coroutines-Async/Await (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin协同程序-异步/等待(第3部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kotlin-coroutines-async-await-part-3-6108bf6be5c4?source=collection_archive---------4-----------------------#2020-07-19">https://levelup.gitconnected.com/kotlin-coroutines-async-await-part-3-6108bf6be5c4?source=collection_archive---------4-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/341be7546ba7157f3bf56e6b897815b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cpNKyXdasccl1U9X"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Leandra Bischofberger 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ab5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://medium.com/@faizanwar027/kotlin-coroutines-suspended-functions-part-2-8e9044f2959c?sk=049afec66bb694d70ccbdb89f201edd8" rel="noopener">之前的</a>文章中，我们了解了协程提供的暂停函数以及它们给代码带来的价值。我们还了解了协程和挂起函数如何携手工作来桥接线程和执行异步任务，而无需我们创建通知机制。在处理异步编程时，我们在java中都面临的一个主要挑战是能够从一个独立线程上计算的函数返回值。系统将永远不知道何时返回，因为不存在在两个不同线程之间进行协调的机制。来自不同领域的程序员已经开发了几种机制来处理这种情况。让我们深入了解一下他们的情况。</p><h1 id="c175" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">javascript中有前途的值</h1><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e62c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺结构顾名思义——承诺得到一个值，这个值可能存在，也可能不存在。它们的工作方式是接受一个函数调用，并将相应的对象存储在一个构造中。这里提供的神奇特性之一是，这些承诺可以非常优雅地<strong class="kf ir">链接</strong>到其他承诺。这里我们有两个主要的函数<em class="mf"> then() </em>和<em class="mf"> catch()。</em>前一个函数完成返回值或将值链接到其他承诺的工作，而后一个函数是在遇到错误时捕捉错误的后备函数。</p><p id="8a11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺的一个缺点是它不能直接给你一个值，因为它可能存在也可能不存在，它给你的只是一个承诺。它们还要求我们依赖类似调用链的结构，因为它们绑定到单线程范围。这使得他们在android中的适应性很渺茫。此外，如果我们有多个功能流，我们必须在最初的承诺内处理它们。因为我们在最外层的承诺中将响应返回给用户，所以我们必须将所有情况传播给内部承诺。这往往是笨重的，往往需要大量的实用程序类，只是为了掩盖多余的代码。承诺最糟糕的部分是，如果我们忘记从一个链接的调用中返回值，整个链的下半部分将无法继续，因为它没有任何值可消费。</p><h1 id="f14b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">java的未来模式</h1><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="efb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">java中的期货行为非常类似于承诺。当我们创造未来时，我们并不承诺未来会有价值，因为承诺很容易被打破。我们在这里仅仅意味着一种价值可能存在，否则我们将不得不面对一些后果。与承诺相比，打破未来并不容易，因为承诺不会带来回报，从而打破通话链。在这里，必须声明只有返回类型的函数，否则我们会遇到编译问题。</p><p id="e78a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ExecutorService API的引入是为了替代直接处理线程。它们能够独立运行异步任务，还能管理线程池，这样我们就不必手动创建它们来减轻系统开销。除了Runnable executors还支持另一种叫做Callable的任务。它们与Runnable非常相似，但关键区别在于它们返回值。当callable被传递给executor服务时，它们返回一个future对象，该对象可用于在以后的某个时间点检索实际结果。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="ace6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在这个例子中看到的，我们首先将可调用对象提交给executor，并检查future是否已经被执行，当它返回false时，我们调用<strong class="kf ir"> get() </strong>函数，该函数阻塞当前线程并等待，直到可调用对象完成。</p><p id="262f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想进行并行调用，我们可以创建多个线程供未来使用，从而使它们能够同时运行多个任务。它们允许我们拥有清晰控制流逻辑，因为产生的值可以在顺序代码中使用，且还消除了对回调/链接调用的需要。遗憾的是，这种方法的唯一缺点是以阻塞的方式接收值，当我们有用户界面要呈现时，这对我们android开发者来说是非常昂贵的。</p><h1 id="83f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">需要克服的问题</h1><p id="7c0c" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">上面讨论的两种方法都很棒，在很大程度上解决了异步编程的挑战。然而，如果我们不正确地管理后台线程，急切地等待值会有冻结应用程序中UI的风险。尽管说起来容易做起来难。如果我们等待的值永远不会返回，就有很大的风险会产生死锁。</p><p id="24db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们在Kotlin协程中有一种称为async/await的模式，它依赖于挂起函数来减轻阻塞代码的需要，并且在管理许多后台线程时会弄脏我们的手。</p><h1 id="9a85" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用异步/等待</h1><p id="f586" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">Kotlin中的Async返回给我们一个类似于Future &lt; T &gt;的<strong class="kf ir">Deferred&lt;T&gt;T1】对象。那么得到一个未来的对象和等待一个结果的到来不是同一个概念吗？我们可以这么说，但关键的区别是等待结果这里不是阻塞，因为它发生在一个挂起的函数中，当前线程的底层协同程序被挂起，当前线程可以自由地继续它的任务。aync/await模式之所以如此，是因为要使用它们，我们需要两个函数调用——async()来准备和包装值，await()来请求使用值。</strong></p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="4ae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上面的例子中所看到的，我们甚至不用挂起函数也能达到同样的效果。如前所述，它创建了一个协程并用延迟的<t>值屏蔽它。通过接口，您可以访问该值，因为接口公开了await()。每个async()块返回一个延迟的<t>。这是驱动Coroutines API的核心机制，理解它的工作方式非常重要。</t></t></p><h1 id="acc8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">延期值</h1><p id="74fe" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">当我们调用async()时，该函数返回Deferred，这是通过创建DeferredCoroutine或LazyDeferredCoroutine来完成的。有趣的是，这个协程也有延续<t>接口，允许拦截执行流，将值一直传递到调用点，类似于挂起的函数。</t></p><p id="9f9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦创建了协程，代码就会在我们在dispatcher中声明的线程上执行。执行完成后，结果存储在内部，并在调用await()时返回，await()将是一个挂起的调用，创建新的继续和执行流。所以解释什么是延迟对象的一个好方法是——一个有结果的作业对象。这个作业非常强大，它可以并行运行，可能产生也可能不产生结果值，并且可以被取消并与其他作业合并。为了更好地理解它，让我们看一个简单的例子。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="e2ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在本例中看到的，我们创建了两个作业，并以连续的方式将这些作业添加到数据库中。当两个作业都完成时，调用saveToDatabase()并插入各自的数据。我们有效地创建了一个悬挂两个函数的悬挂点。快乐之路看起来真的很好，但是当其中一个作业失败或者我们想要取消这些作业(可能因为它们运行时间很长)时会发生什么呢？知道如何使我们的协程代码具有良好的结构和协作性非常重要。</p><h1 id="b1d4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">润色你的协程</h1><p id="a087" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">在我们开始构建这样的系统之前，重要的是要记住，这些作业在任何给定的时刻都应该是可取消的。想象一下这样一种情况，父作业被取消了，但实际需要的作业却没有被取消。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="d7cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果在块开始执行之后，从launch()中取消作业，会发生什么情况呢？即使父作业被取消，getUserSuspended()仍将运行三秒钟并返回一个值。这导致了计算时间和资源的浪费，这些时间和资源用在其他地方会更好。这就是为什么Jetbrains想出了<strong class="kf ir">结构化并发</strong>和<strong class="kf ir">合作代码</strong>的想法。其思想是编写反映调用者状态的代码，并构建依赖于其父状态的协程。简单来说，如果父作业被取消，其子作业也应该被取消。</p><p id="c992" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">建立合作社的正确方式应该是这样的。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="5076" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该函数现在接受父CoroutineScope实例作为参数，并从那里启动一个异步块。此外，它从父作业中检查isActive，这样，如果父作业被取消，它就不必继续执行。如果我们再次从上面启动main()，传入父作用域，代码将只打印出从模拟网络获取用户，而不会取消，之后，它不会继续等待三秒钟，向已终止的协程返回值。</p><p id="2cc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如何保证您用来启动协程的协程作用域是正确的呢？通过自己实现接口！《协作代码和结构并发性指南》指出，您应该将您的协同程序限制在具有明确定义的<strong class="kf ir">生命周期</strong>的对象上，比如Android应用程序环境中的活动。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="01e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您有兴趣解决的第二个问题是编写可能永远不会返回值的异步块。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mg me l"/></div></figure><p id="c72c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里使用<strong class="kf ir"> scope.isActive() </strong>非常关键。如果不这样做，最终会无限期地暂停启动块。当条件断路器中缺少范围检查时，取消作业范围仍会冻结UI。请注意，Jetbrains团队已经用协程程序添加了更好的取消功能，所以UI不会冻结，但是安全总比后悔好。所以，与你的代码合作吧！</p><h1 id="0b20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">上岸点</h1><p id="98a1" class="pw-post-body-paragraph kd ke iq kf b kg mh ki kj kk mi km kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">非常感谢你加入我的旅程。我相信我们已经学习了大量的协程API，我们准备从基于回调的代码迁移到协程支持的函数，并做一些更有趣的事情，比如编写并行运行多个函数的代码，将它们的结果合并到一个函数调用中。祝您编码愉快，并祝您未来的学习之旅一切顺利！</p></div></div>    
</body>
</html>