<html>
<head>
<title>Getting started with GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-graphql-31e28b8f3f8a?source=collection_archive---------11-----------------------#2020-05-16">https://levelup.gitconnected.com/getting-started-with-graphql-31e28b8f3f8a?source=collection_archive---------11-----------------------#2020-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/5876461436bfb5b10a1a63f56b3d901a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*RHWi_Erl7eAzfsiDf3sanQ.png"/></div></figure><p id="bcc2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">很长一段时间以来，API的世界一直依赖于REST和SOAP。简单对象访问协议(SOAP)于1998年发明，而表述性状态转移(REST)于2000年出现。这两者已经统治了应用程序编程接口将近15年。2015年，脸书发布了GraphQL。这已经成为查询数据的新方式，可以被认为是SOAP和REST的一个有竞争力的替代方案。</p><p id="803f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">GraphQL在定义API方面开创了一个新时代，但是和所有技术一样，在一些特定的情况下，REST可能会做得更好。</p><p id="cfd2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">GraphQL以更简单、更快、更高效而闻名，允许用户准确地获取他们需要的数据。此外，GraphQL既是一种查询语言，也是一个执行引擎，可以绑定到任何后端服务、数据源，包括REST本身。</p><p id="2d54" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇文章中，我将提供一个简单的GraphQL介绍和一个<a class="ae kv" href="https://skimaql.com/sign" rel="noopener ugc nofollow" target="_blank">工具</a>，它可以简化你的学习或者你可以在未来的工作中使用。</p><blockquote class="kw kx ky"><p id="5c5c" class="jx jy kz jz b ka kb kc kd ke kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ku im bi translated">使用GraphQL开发API需要一个模式来定义它将要操作的资源。为了访问或修改这些资源，您需要创建一个将被发送到服务器的<code class="fe ld le lf lg b">Query</code>或<code class="fe ld le lf lg b">Mutation</code>类型。资源定义、查询和变异这三者都可以根据语言偏好在一个文件中定义。GraphQL文件的扩展名为(。gql或者。graphql) c cn</p></blockquote><p id="ed32" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里的代码输出也可以从<a class="ae kv" href="https://skima.com" rel="noopener ugc nofollow" target="_blank">https://skimaql.com</a>中创建。</p><p id="cffa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">每一个GraphQL实现都是对它可以返回什么类型的对象的描述(GraphQL类型系统)，并且是GraphQL模式中最关键的部分。类型系统只是对与对象相关的特征或属性的一种解释。让我们假设我们正在构建一个twitter克隆体(包含用户、帖子和评论)。</p><p id="23b6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">用户对象可以包含[唯一标识用户的id、姓名、电子邮件、密码、电话]所有这些都可以在GraphQL类型的系统中表示。</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="0b78" class="lp lq it lg b gy lr ls l lt lu">type User {</span><span id="fd64" class="lp lq it lg b gy lv ls l lt lu">       id: ID!</span><span id="baf8" class="lp lq it lg b gy lv ls l lt lu">       name: String</span><span id="3ca9" class="lp lq it lg b gy lv ls l lt lu">       phone: String</span><span id="d833" class="lp lq it lg b gy lv ls l lt lu">       email: String! <strong class="lg iu">#Cannot be null</strong></span><span id="789a" class="lp lq it lg b gy lv ls l lt lu">       password: String! <strong class="lg iu">#Cannot be null</strong></span><span id="7c99" class="lp lq it lg b gy lv ls l lt lu">}</span></pre><p id="349d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是一个简单的定义，对吗？GraphQL支持标量类型<code class="fe ld le lf lg b">String</code>、<code class="fe ld le lf lg b">Int</code>、<code class="fe ld le lf lg b">Float</code>、<code class="fe ld le lf lg b">Boolean</code>和<code class="fe ld le lf lg b">ID</code>，因此您可以使用这些直接确定GraphQL要存储或检索的数据类型。</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="da44" class="lp lq it lg b gy lr ls l lt lu"><strong class="lg iu">Boolean</strong>, true or false</span><span id="b37c" class="lp lq it lg b gy lv ls l lt lu"><strong class="lg iu">Int</strong>, a signed 32‐bit numeric non‐fractional value</span><span id="ce00" class="lp lq it lg b gy lv ls l lt lu"><strong class="lg iu">Float</strong>, a signed double‐precision fractional values</span><span id="2dd7" class="lp lq it lg b gy lv ls l lt lu"><strong class="lg iu">String</strong>, a sequence of UTF‐8 characters</span><span id="166b" class="lp lq it lg b gy lv ls l lt lu"><strong class="lg iu">ID</strong>, a unique identifier</span></pre><p id="6b57" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">确实存在其他类型<code class="fe ld le lf lg b">Date, Datetime</code>，但这超出了本文的范围。您可能不需要额外的类型，因为即使使用默认类型，也存在大量的变通方法。</p><p id="09c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">默认情况下，每种类型都是可空的——将<code class="fe ld le lf lg b">null</code>作为任何标量类型返回都是合法的。我们用感叹号来表示一个类型不能为空，所以<code class="fe ld le lf lg b">String!</code>是一个不可为空的字符串。在我们的示例中，如果没有电子邮件和密码，就不能添加用户。</p><p id="344f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">此时，您可以为帖子和评论创建类型定义。按照惯例，您将使用单数形式的类型名称<em class="kz">(例如user而不是users或者post而不是posts)。</em></p><p id="30c0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你想在一个用户和文章之间建立一个关系呢？您可能没有注意到这一点，但是<code class="fe ld le lf lg b">String</code>、<code class="fe ld le lf lg b">Int</code>、<code class="fe ld le lf lg b">Float</code>、<code class="fe ld le lf lg b">Boolean</code>和<code class="fe ld le lf lg b">ID</code>是标量类型，我们刚刚创建了一个类型用户。</p><p id="a043" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> GraphQL类型可以引用其他类型。</strong>这意味着一个用户类型可以引用一个文章类型，<strong class="jz iu"> <em class="kz">，这是在GraphQL中创建关系的基础。</em> </strong></p><p id="7817" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">GraphQL可以用来创建几种关系；</p><ol class=""><li id="3e63" class="lw lx it jz b ka kb ke kf ki ly km lz kq ma ku mb mc md me bi translated"><strong class="jz iu">一对一</strong></li></ol><p id="2652" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一对一关系将约束置于两种类型之间的关系中，并在架构中通过引用每种类型都有一个指向另一种类型的字段来表示。</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="7c38" class="lp lq it lg b gy lr ls l lt lu">type User {</span><span id="7043" class="lp lq it lg b gy lv ls l lt lu">     id: ID!</span><span id="8407" class="lp lq it lg b gy lv ls l lt lu">     name: String</span><span id="da6d" class="lp lq it lg b gy lv ls l lt lu">     email: String!</span><span id="49fe" class="lp lq it lg b gy lv ls l lt lu">     password: String!</span><span id="b80d" class="lp lq it lg b gy lv ls l lt lu">     phone: String</span><span id="c38d" class="lp lq it lg b gy lv ls l lt lu">     post: Post</span><span id="5eef" class="lp lq it lg b gy lv ls l lt lu">    <strong class="lg iu"> location: Location</strong></span><span id="2af2" class="lp lq it lg b gy lv ls l lt lu">}</span><span id="1228" class="lp lq it lg b gy lv ls l lt lu">type Location {</span><span id="e6fd" class="lp lq it lg b gy lv ls l lt lu">     id: ID!</span><span id="b1e4" class="lp lq it lg b gy lv ls l lt lu">     address: String!</span><span id="e284" class="lp lq it lg b gy lv ls l lt lu">     country: String</span><span id="8d1c" class="lp lq it lg b gy lv ls l lt lu">     <strong class="lg iu">user: User</strong></span><span id="b847" class="lp lq it lg b gy lv ls l lt lu">}</span></pre><p id="43ac" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">2.<strong class="jz iu">一对多或多对一</strong></p><p id="e28f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一对多关系只对关系的一方施加约束。它在GraphQL模式中由两种类型表示，其中源有一个指向目标类型的数组字段，而目标类型有一个指向源类型的非数组字段。这是我们需要链接用户和文章的关系，如下所示:—</p><pre class="lh li lj lk gt ll lg lm ln aw lo bi"><span id="55bf" class="lp lq it lg b gy lr ls l lt lu">type User {</span><span id="2c8d" class="lp lq it lg b gy lv ls l lt lu">       id: ID!</span><span id="8902" class="lp lq it lg b gy lv ls l lt lu">       name: String</span><span id="8e11" class="lp lq it lg b gy lv ls l lt lu">       email: String!</span><span id="f4dd" class="lp lq it lg b gy lv ls l lt lu">       password: String!</span><span id="9b6c" class="lp lq it lg b gy lv ls l lt lu">       phone: String</span><span id="0f5b" class="lp lq it lg b gy lv ls l lt lu">       <strong class="lg iu">post: Post  ==&gt; One</strong></span><span id="f3ef" class="lp lq it lg b gy lv ls l lt lu">}</span><span id="0415" class="lp lq it lg b gy lv ls l lt lu">type Post {</span><span id="65bb" class="lp lq it lg b gy lv ls l lt lu">     id: ID!</span><span id="582b" class="lp lq it lg b gy lv ls l lt lu">     createdAt: String</span><span id="c10d" class="lp lq it lg b gy lv ls l lt lu">     title: String</span><span id="452f" class="lp lq it lg b gy lv ls l lt lu">     message: String!</span><span id="dee8" class="lp lq it lg b gy lv ls l lt lu">     <strong class="lg iu">user: [User]  ==&gt; Many represented by [] //An array</strong></span><span id="c6fe" class="lp lq it lg b gy lv ls l lt lu">}</span></pre><p id="b99f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu"> 3。多对多</strong></p><p id="c721" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">多对多关系对关系的双方都有约束。它在GraphQL模式中由两种类型表示，每种类型都有相互指向对方的字段，其中所有字段都是数组。</p><p id="3db1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">至此，您已经有了足够的信息来开始使用GraphQL</p><p id="90f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您知道基本类型、关系以及如何创建它们。这些只是GraphQL的基础，你可以随时去https://skimaql.com的<a class="ae kv" href="https://skimaql.com" rel="noopener ugc nofollow" target="_blank">轻松完成所有这些。</a></p><p id="5b24" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在下一篇文章中，我将帮助您了解如何获取数据以及如何发布/更新或删除数据</p><figure class="lh li lj lk gt ju gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/36a9400f2b4f06e8e91159d7cac05970.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*G1MR6upWYlTUFKwk5YmvYA.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">https://skimaql.com制造的汽车</figcaption></figure></div></div>    
</body>
</html>