<html>
<head>
<title>OAuth 2.0 in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的OAuth 2.0</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oauth-2-0-in-go-846b257d32b4?source=collection_archive---------2-----------------------#2020-09-14">https://levelup.gitconnected.com/oauth-2-0-in-go-846b257d32b4?source=collection_archive---------2-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/35ed5b97e46fc06a1d2d0920460cdd52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbK_V_EkCTGEUkpONyzOWw.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">吉祥物归功于golang.org</figcaption></figure><div class=""/><p id="fd70" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在Go中访问安全的HTTP服务</p><p id="5549" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">OAuth 2.0是第三方应用程序在云中访问用户数据的方式。规范是这样描述的:“OAuth 2.0授权框架使第三方应用程序能够获得对HTTP服务的有限访问。”因此，你需要理解它，以编程方式访问现在存储在各种在线服务中的几乎所有用户数据:亚马逊、谷歌、GitHub、脸书、LinkedIn、Strava和无数其他服务。在本文中，我们将在Go中构建一个OAuth 2.0客户端应用程序，并使用它在多个服务中访问我们的用户数据。</p><p id="ca1a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">核心规范，<a class="ae ld" href="https://tools.ietf.org/html/rfc6749" rel="noopener ugc nofollow" target="_blank"> RFC 6749 </a>，实际上可读性非常好，所以不要被大量的等宽文本吓倒。尽管要记住核心规范只是<a class="ae ld" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank">旅程的开始</a>，一些部分现在已经过时了，这些年来已经有了一些<a class="ae ld" href="https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/" rel="noopener ugc nofollow" target="_blank">的补充和澄清</a>。特别是现在，你会想要阅读本地应用的RFC 8252规范。</p><p id="f411" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有基于委员会的规范都有自己的行话，因此我们将首先深入其中，以设置上下文。</p><h2 id="d125" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">授权类型</h2><p id="8e12" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">核心规范概述了使用OAuth 2.0的五种不同方式，称为“授权类型”</p><ul class=""><li id="de38" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated"><a class="ae ld" href="https://tools.ietf.org/html/rfc6749#section-4.1" rel="noopener ugc nofollow" target="_blank"> 4.1 </a>。授权码授予</li><li id="7d5b" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><a class="ae ld" href="https://tools.ietf.org/html/rfc6749#section-4.2" rel="noopener ugc nofollow" target="_blank"> 4.2 </a>。隐性资助(现为遗产，不鼓励)</li><li id="6608" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><a class="ae ld" href="https://tools.ietf.org/html/rfc6749#section-4.3" rel="noopener ugc nofollow" target="_blank"> 4.3 </a>。授予资源所有者口令身份证明(现在保留，不鼓励)</li><li id="9f56" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><a class="ae ld" href="https://tools.ietf.org/html/rfc6749#section-4.4" rel="noopener ugc nofollow" target="_blank"> 4.4 </a>。客户端凭据授予</li><li id="0fe8" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><a class="ae ld" href="https://tools.ietf.org/html/rfc6749#section-4.5" rel="noopener ugc nofollow" target="_blank"> 4.5 </a>。推广赠款</li></ul><p id="a4cb" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此后的几个扩展现在是最佳实践:</p><ul class=""><li id="ee63" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated"><a class="ae ld" href="https://tools.ietf.org/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> PKCE </a>授权码授予的扩展，已经成为所有公共应用的首选流程</li><li id="5393" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><a class="ae ld" href="https://tools.ietf.org/html/rfc8628#section-3.4" rel="noopener ugc nofollow" target="_blank">设备代码</a>是没有浏览器的受限设备的扩展</li></ul><h2 id="16bf" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">客户端类型和配置文件</h2><p id="2924" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">核心规范定义了两种不同类型的应用程序，机密应用程序和公共应用程序，主要区别在于公共应用程序无法保持其凭证的机密性(客户端机密)。在此基础上，它继续列出一些应用程序角色:</p><ul class=""><li id="6af0" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated"><strong class="kh jj"> Web应用</strong>:运行在Web服务器上的机密客户端。这是传统的基于服务器的web客户端访问用户数据，授权码授权是推荐的流程。授权服务器可以允许或不允许扩展授权在访问令牌到期后刷新它。客户端凭证授权对于客户端获取有关其自身的数据非常有用，与特定用户无关。在这种情况下，客户端必须能够仅使用它已经安全存储的凭证或者通过与授权服务器的某种预先安排来认证自己。</li><li id="5552" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><strong class="kh jj">基于用户代理的应用</strong>:从web服务器下载代码和凭证的公共客户端。单页应用程序就属于这种角色。核心规范推荐这个角色的隐式流程，但是这已经被否决了，现在推荐使用PKCE的授权代码授权。</li><li id="808b" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><strong class="kh jj">原生应用</strong>:在设备上安装并执行代码的公共客户端，应用可能安全也可能不安全，但被认为是不安全的。移动和本地应用程序都属于这一角色，再次建议使用PKCE授权码授权。对于无浏览器或输入受限的设备，建议使用设备代码流，其工作原理在概念上类似于授权代码授权，但要求用户在验证URI(如令牌端点)手动输入用户代码(如客户端密码)以检索访问令牌。</li></ul><h2 id="cdee" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">角色</h2><p id="f435" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">该规范确定了OAuth舞蹈中的几个角色，称为“<a class="ae ld" href="https://tools.ietf.org/html/rfc6749#section-1.1" rel="noopener ugc nofollow" target="_blank">角色</a>，它们对于保持流程顺畅非常重要。</p><ul class=""><li id="cd8c" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated"><strong class="kh jj">资源所有者</strong>:拥有被访问数据的用户</li><li id="dd91" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><strong class="kh jj">资源服务器</strong>:提供用户数据的api服务器</li><li id="d8bb" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><strong class="kh jj">客户端</strong>:使用api获取用户数据的第三方app</li><li id="e956" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><strong class="kh jj">授权服务器</strong>:代表资源所有者(用户)发放令牌以授权访问数据的服务。这可能与资源服务器共存，也可能不共存，这并不重要。</li><li id="debe" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">出于本文的目的，我将再添加一个人，创建第三方客户端的<strong class="kh jj">开发人员</strong></li></ul><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/acd78922dc703e8ea8636fc545165974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lS0qwIOCTPtj0mCLeAPPQ.png"/></div></div></figure><h2 id="9050" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">端点</h2><p id="103e" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">有几个“端点”需要建立。对你我来说，这些只是完成事情的URI。客户端需要知道在哪里请求授权、令牌和刷新令牌。授权服务器需要知道将信息发送回客户端的位置。</p><ul class=""><li id="35b7" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated"><strong class="kh jj">授权端点</strong>:授权服务器上的URI，提供授权和授权码</li><li id="9789" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><strong class="kh jj">令牌端点</strong>:授权服务器上的URI，它将短期授权码交换为长期访问令牌或刷新令牌</li><li id="9d84" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated"><strong class="kh jj">重定向端点</strong>:客户端上的URI，从授权服务器接收令牌</li></ul><h2 id="fbf4" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">授权码授予</h2><p id="00dc" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">在本文中，我们将重点关注授权代码授权。这一切都可以归结为一条简化的快乐之路来解锁我们的api:</p><ul class=""><li id="2d7e" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated">资源所有者(用户)在客户机上发起一个动作，向授权服务器请求授权</li><li id="c29d" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">授权服务器验证资源所有者和访问范围</li><li id="983d" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">授权服务器向客户端发回一次性授权码</li><li id="0637" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">客户端将授权码换成一个具有过期时间的长期访问令牌</li><li id="c23a" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">客户端检查到期时间，如果有效，则使用访问令牌通过api请求用户数据；如果到期，则客户端请求刷新令牌或重新进行身份验证。</li></ul><p id="3001" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">具体来说，这具有以下模式:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/f86cb720ec5c1fc7d16405576b070b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PDQAqtHNte1SEIIV4xkWg.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">授权码授权和扩展授权流程</figcaption></figure><h2 id="7040" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">开发者</h2><p id="66d1" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">作为一名客户端开发人员，一开始您必须做几件事情:</p><ul class=""><li id="60e4" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated">在授权服务器上设置用户和应用程序帐户</li><li id="d902" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">输入申请信息</li><li id="b701" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">输入重定向URI和/或回拨域</li><li id="3a68" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">获取客户Id</li><li id="8716" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">获取客户端机密(PKCE不需要)</li></ul><p id="1ac7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些信息建立了客户端和授权服务器之间的握手。</p><h1 id="f0fc" class="mw lf ji bd lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj nk nl lv nm bi translated">例子</h1><p id="0b19" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">那么这实际上是如何工作的呢？好吧，让我们假设您，开发人员，正在构建一个简单的Web客户端，并且您想通过OAuth 2.0访问用户数据。我们将使用Strava OAuth 2.0服务api作为一个例子来构建上面在Go中展示的整个流程。</p><h2 id="c846" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">第一步:帐户设置</h2><p id="8205" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">首先，我们将设置我们的应用程序。在Strava，这很简单:</p><ol class=""><li id="941c" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc nn mi mj mk bi translated">前往<a class="ae ld" href="https://www.strava.com/" rel="noopener ugc nofollow" target="_blank">Strava.com</a>，如果你还没有账户的话，建立一个账户。</li><li id="fc6e" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc nn mi mj mk bi translated">转到<a class="ae ld" href="https://www.strava.com/settings/profile" rel="noopener ugc nofollow" target="_blank">https://www.strava.com/settings/profile</a></li><li id="45f2" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc nn mi mj mk bi translated">单击我的API应用程序来设置您的应用程序:</li></ol><ul class=""><li id="5f68" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated">遗憾的是，你需要上传一个<a class="ae ld" href="https://www.cleanpng.com/png-go-programming-language-computer-programming-progr-1659140/download-png.html" rel="noopener ugc nofollow" target="_blank">图标</a>来编辑设置</li><li id="701b" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">输入您的应用程序名称</li><li id="0b76" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">选择一个类别</li><li id="c629" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">暂时忽略俱乐部</li><li id="51ec" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">进入你的网站，为这个演示输入<a class="ae ld" href="https://www.strava.testapp.com" rel="noopener ugc nofollow" target="_blank"><strong class="kh jj">https://www.strava.testapp.com</strong></a></li><li id="3d78" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">输入您的授权回调域，对于这个演示，输入<strong class="kh jj"> localhost </strong>(顺便说一下，localhost总是有效的)。</li></ul><p id="ebf4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意以下项目，您将在下面需要这些项目(您可以随时回来查看):</p><ul class=""><li id="509d" class="mc md ji kh b ki kj km kn kq me ku mf ky mg lc mh mi mj mk bi translated">客户端ID</li><li id="1d96" class="mc md ji kh b ki ml km mm kq mn ku mo ky mp lc mh mi mj mk bi translated">客户机密</li></ul><p id="8cb0" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Strava概要文件还显示了一个初始访问令牌和刷新令牌，您可以立即使用，但是它们只在几个小时内有效(注意过期时间)，所以我们将通过代码以正确的方式获取它们。</p><p id="738d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以扩展这个示例，在<a class="ae ld" href="https://www.linkedin.com/developers/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae ld" href="https://developer.spotify.com/" rel="noopener ugc nofollow" target="_blank"> Spotify </a>和<a class="ae ld" href="https://developer.github.com/program/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中设置应用程序帐户。</p><h2 id="dfd0" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">步骤2:请求授权</h2><p id="90bc" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">现在我们开始写代码。我们将组装一个简单的web客户端来演示从授权服务器的往返，然后扩展它。首先，我们需要在授权服务器上打开授权页面。我们将使用一个按钮来启动它，该按钮使用一个查询字符串在访问端点上执行GET。</p><p id="ba06" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/main.go:</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="e5f9" class="le lf ji np b gy nt nu l nv nw">package main</span><span id="c438" class="le lf ji np b gy nx nu l nv nw">import (<br/>    "fmt"<br/>    "html/template"<br/>    "log"<br/>    "net/http"<br/>    "os"<br/>    "path"<br/>)</span><span id="5a57" class="le lf ji np b gy nx nu l nv nw">func main() {<br/>    port := os.Getenv("PORT")<br/>    if port == "" {<br/>        port = "8000"<br/>    }</span><span id="a590" class="le lf ji np b gy nx nu l nv nw">http.HandleFunc("/", HomePageHandler)</span><span id="1c87" class="le lf ji np b gy nx nu l nv nw">fmt.Println("&gt;&gt;&gt;&gt;&gt;&gt;&gt; OClient started at:", port)<br/>    log.Fatal(http.ListenAndServe(":"+port, nil))<br/>    return<br/>}</span><span id="d151" class="le lf ji np b gy nx nu l nv nw">func HomePageHandler(w http.ResponseWriter, r *http.Request) {</span><span id="8783" class="le lf ji np b gy nx nu l nv nw">    fp := path.Join("templates", "home.html")<br/>    tmpl, err := template.ParseFiles(fp)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }</span><span id="b4bb" class="le lf ji np b gy nx nu l nv nw">    if err := tmpl.Execute(w, nil); err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>    }<br/>}</span></pre><p id="4d97" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/templates/home.html</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="160a" class="le lf ji np b gy nt nu l nv nw">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>    &lt;head&gt;<br/>        &lt;meta charset="UTF-8"&gt;<br/>        &lt;title&gt;OClient&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;OClient&lt;/h1&gt;<br/>        &lt;br&gt;</span><span id="d7ae" class="le lf ji np b gy nx nu l nv nw">        &lt;button onclick="window.location.href='<a class="ae ld" href="https://www.strava.com/oauth/authorize?client_id=40022&amp;response_type=code&amp;redirect_uri='" rel="noopener ugc nofollow" target="_blank">https://www.strava.com/oauth/authorize?client_id=40022&amp;response_type=code&amp;redirect_uri='</a> + window.location.origin + '/redirect&amp;approval_prompt=force&amp;scope=activity:read_all&amp;state=foo'"&gt;Authorize&lt;/button&gt;</span><span id="99de" class="le lf ji np b gy nx nu l nv nw">    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e57c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">编译并运行:</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="19e0" class="le lf ji np b gy nt nu l nv nw">cd oclient<br/>go install<br/>oclient</span></pre><p id="e945" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在localhost:8000上打开浏览器</p><p id="1a65" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">点击授权按钮</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/686b4fc1d7f46beb5b765596edfc25ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abr24lBAdYsfx2E2ucsNQA.png"/></div></div></figure><p id="6056" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">果然，显示了Strava授权页面。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/96331e54c84d1b0117beb0055d2c7cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNH8rtOOylL6VsFdiXJ9XQ.png"/></div></div></figure><p id="e7f1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们在home.html中分解查询字符串，注意其中一些是必需的，一些是可选的，一些是特定于服务的。</p><p id="a497" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://www.strava.com/oauth/authorize?client_id=40022&amp;response_type=code&amp;redirect_uri='" rel="noopener ugc nofollow" target="_blank"><strong class="kh jj"/></a><strong class="kh jj"/>这是Strava授权端点。[必需]</p><p id="6d91" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://www.strava.com/oauth/authorize?client_id=40022&amp;response_type=code&amp;redirect_uri='" rel="noopener ugc nofollow" target="_blank"><strong class="kh jj">Client _ id = 40022</strong></a>这是Strava为应用程序提供的(我的)唯一客户端Id，您的将会不同。我们真的不需要保护它，因为它只回复到我们注册的域和redirect_uri(好吧，也许你可以在localhost上搞乱它——但我不在乎)。[必需]</p><p id="176b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://www.strava.com/oauth/authorize?client_id=40022&amp;response_type=code&amp;redirect_uri='" rel="noopener ugc nofollow" target="_blank"><strong class="kh jj">response _ type = Code</strong></a>这告诉授权服务器我们正在请求授权代码授权。[必需]</p><p id="8148" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://www.strava.com/oauth/authorize?client_id=40022&amp;response_type=code&amp;redirect_uri='" rel="noopener ugc nofollow" target="_blank"><strong class="kh jj">redirect _ uri = '</strong></a><strong class="kh jj">+window . location . origin+'/redirect</strong>这是我们的重定向端点。请注意，域必须与我们在上面的设置配置文件(localhost)中提供给Strava的相匹配—这就是为什么我们不关心这个查询字符串是公共的。所以这告诉授权服务器我们将在<a class="ae ld" href="http://localhost:8000/redirect." rel="noopener ugc nofollow" target="_blank">http://localhost:8000/redirect收到代码。</a>【可选，但大多数服务都需要】</p><p id="7cf1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj"> approval_prompt=force </strong>这是谷歌特有的参数，其他人已经采用了。如果为“强制”，则用户每次访问应用程序时都会被提示进行授权，如果为“自动”，则只会在第一次时被提示。[可选，服务特定]</p><p id="b4a1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj">scope = activity:read _ all</strong>这告诉授权服务器您请求的访问范围。有效负载是特定于供应商的，因为它表示特定的服务访问，但是查询是标准的。它是一系列以空格分隔、区分大小写的字符串。在我们的例子中，我们请求读取用户的Strava活动数据。[可选，但大多数服务都需要]</p><p id="e4b1" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh jj"> state=foo </strong>该值特定于客户端，对授权服务器不透明。它将被一字不差地发送回客户端的重定向端点。您可以使用它来维护初始客户端授权码请求和后续服务器回调之间的状态。还强烈建议使用state参数作为随机生成的“绑定值”，客户端可以用它来验证服务器的回调，以减少跨站点请求伪造(CSRF)。(我们稍后会这样做)[可选，但推荐]</p><h2 id="4c7f" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">步骤3:接收授权码</h2><p id="5a07" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">现在让我们扩展我们的程序，从授权服务器接收授权代码(下面以粗体显示)。我们将在重定向URI: /redirect设置一个新的处理程序。</p><p id="6839" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/main.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="e3de" class="le lf ji np b gy nt nu l nv nw">package main</span><span id="e64a" class="le lf ji np b gy nx nu l nv nw">import (<br/>    "fmt"<br/>    "html/template"<br/>    "log"<br/>    "net/http"<br/>  <strong class="np jj">  "net/url"</strong><br/>    "os"<br/>    "path"<br/>)</span><span id="bfd9" class="le lf ji np b gy nx nu l nv nw">func main() {</span><span id="5581" class="le lf ji np b gy nx nu l nv nw">port := os.Getenv("PORT")<br/>    if port == "" {<br/>        port = "8000"<br/>    }</span><span id="eeb4" class="le lf ji np b gy nx nu l nv nw">//pages<br/>    http.HandleFunc("/", HomePageHandler)<br/>    <strong class="np jj">http.HandleFunc("/redirect", RedirectHandler)</strong></span><span id="65a9" class="le lf ji np b gy nx nu l nv nw">fmt.Println("&gt;&gt;&gt;&gt;&gt;&gt;&gt; OClient started at:", port)<br/>    log.Fatal(http.ListenAndServe(":"+port, nil))<br/>    return<br/>}</span><span id="d685" class="le lf ji np b gy nx nu l nv nw">func HomePageHandler(w http.ResponseWriter, r *http.Request) {<br/>fp := path.Join("templates", "home.html")<br/>    tmpl, err := template.ParseFiles(fp)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }</span><span id="e296" class="le lf ji np b gy nx nu l nv nw">    if err := tmpl.Execute(w, nil); err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>    }<br/>}</span><span id="cd1d" class="le lf ji np b gy nx nu l nv nw"><strong class="np jj">func RedirectHandler(w http.ResponseWriter, r *http.Request) {<br/>    m, err := url.ParseQuery(r.URL.RawQuery)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    code := m.Get("code")<br/>    scope := m.Get("scope")<br/>    fmt.Fprintln(w, "Code: ", code, " Scope: ", scope)<br/>}</strong></span></pre><p id="2064" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">编译并再次运行它</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="dadd" class="le lf ji np b gy nt nu l nv nw">go install<br/>oclient</span></pre><p id="cba6" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">和以前一样，当您点击OClient中的Authorize按钮时，将会显示Strava Authorize页面。这一次单击Strava页面中的Authorize按钮。您应该看到授权代码和范围:</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="7c7f" class="le lf ji np b gy nt nu l nv nw">Code:  7160d4a21b495bf6e371db6d6aa85ca656c587be  Scope:  read,activity:read_all</span></pre><h2 id="026c" class="le lf ji bd lg lh li dn lj lk ll dp lm kq ln lo lp ku lq lr ls ky lt lu lv lw bi translated">步骤4:用授权码交换访问令牌</h2><p id="c4e4" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">我们现在有了授权码，但它只告诉我们授权发生了，我们不能用它来获取数据。我们必须用它来交换一个访问令牌，所以让我们通过向令牌端点发送一个POST来实现这一点。</p><p id="32d7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/main.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="7e36" class="le lf ji np b gy nt nu l nv nw">package main</span><span id="b6cc" class="le lf ji np b gy nx nu l nv nw">import (<br/><strong class="np jj">    "bytes"<br/>    "encoding/json"</strong><br/>    "fmt"<br/>    "html/template"<br/>   <strong class="np jj"> "io/ioutil"</strong><br/>    "log"<br/>    "net/http"<br/>    "net/url"<br/>    "os"<br/>    "path"<br/>)</span><span id="81e6" class="le lf ji np b gy nx nu l nv nw">func main() {<br/>    port := os.Getenv("PORT")<br/>    if port == "" {<br/>        port = "8000"<br/>    }<br/>    http.HandleFunc("/", HomePageHandler)<br/>    http.HandleFunc("/redirect", RedirectHandler)</span><span id="2f37" class="le lf ji np b gy nx nu l nv nw">fmt.Println("&gt;&gt;&gt;&gt;&gt;&gt;&gt; OClient started at:", port)<br/>    log.Fatal(http.ListenAndServe(":"+port, nil))<br/>    return<br/>}</span><span id="1acd" class="le lf ji np b gy nx nu l nv nw">func HomePageHandler(w http.ResponseWriter, r *http.Request) {</span><span id="2d62" class="le lf ji np b gy nx nu l nv nw">    fp := path.Join("templates", "home.html")<br/>    tmpl, err := template.ParseFiles(fp)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }</span><span id="4198" class="le lf ji np b gy nx nu l nv nw">    if err := tmpl.Execute(w, nil); err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>    }<br/>}</span><span id="f6c5" class="le lf ji np b gy nx nu l nv nw">func RedirectHandler(w http.ResponseWriter, r *http.Request) {<br/>    m, err := url.ParseQuery(r.URL.RawQuery)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    code := m.Get("code")<br/>    scope := m.Get("scope")<br/>    fmt.Fprintln(w, "Code: ", code, " Scope: ", scope)<br/>    <strong class="np jj">token := getAccessToken(w, r, code)<br/>    fmt.Fprintln(w, "Token: ", token)</strong><br/>}</span><span id="3781" class="le lf ji np b gy nx nu l nv nw"><strong class="np jj">const (<br/>    ClientId      = "40022"<br/>    ClientSecret  = "BlahBlahBlahBlahBlahBlahBlahBlahBlahBlah"<br/>    TokenEndpoint = "</strong><a class="ae ld" href="https://www.strava.com/oauth/token" rel="noopener ugc nofollow" target="_blank"><strong class="np jj">https://www.strava.com/oauth/token</strong></a><strong class="np jj">"<br/>)</strong></span><span id="1e5f" class="le lf ji np b gy nx nu l nv nw"><strong class="np jj">func getAccessToken(w http.ResponseWriter, r *http.Request, code string) (result string) {<br/>    requestBody, err := json.Marshal(map[string]string{<br/>        "client_id":     ClientId,<br/>        "client_secret": ClientSecret,<br/>        "code":          code,<br/>        "grant_type":    "authorization_code",<br/>    })<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>    }<br/>    resp, err := http.Post(TokenEndpoint, "application/json",   bytes.NewBuffer(requestBody))<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>    }<br/>    defer resp.Body.Close()</strong></span><span id="d340" class="le lf ji np b gy nx nu l nv nw"><strong class="np jj">    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>    }<br/>    result = string(body)<br/>    return<br/>}</strong></span></pre><p id="bbfc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">编译并再次运行它</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="3b72" class="le lf ji np b gy nt nu l nv nw">go install<br/>oclient</span></pre><p id="8e88" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">单击OClient和Strava授权按钮。现在，除了授权代码和范围之外，您还会看到访问令牌，类似于:</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="abcf" class="le lf ji np b gy nt nu l nv nw">Token: {"token_type":"Bearer","expires_at":1594843861,"expires_in":19430,"refresh_token":"9ec0cedf070a8b3832f7be43b5acca8bc976deae","access_token":"a16bffde2871928071e98fbff5674b12d4fd0198","athlete":{"id":24336962,"username":null,"resource_state":2,"firstname":"Eric","lastname":"Lang","city":"Seattle","state":"Washington","country":"United States","sex":"M","premium":false,"summit":false,"created_at":"2017-08-19T18:38:37Z","updated_at":"2020-07-07T20:09:26Z","badge_type_id":0,"profile_medium":"https://dgalywyr863hv.cloudfront.net/pictures/athletes/23376952/7221532/1/medium.jpg","profile":"https://dgalywyr863hv.cloudfront.net/pictures/athletes/23376952/7221532/1/large.jpg","friend":null,"follower":null}}</span></pre><p id="ae48" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这就是我们的情况。我们已经从授权服务器请求了一个授权码，在我们的重定向端点收到了授权码，并将其交换为一个访问令牌，我们现在可以用它来访问安全API。</p><p id="c3e4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，我们正在使用包含client_id、client_secret、code和grant_type的JSON有效负载向Strava令牌端点进行POST。这安全吗？可以，只要客户端和认证服务器使用TLS (HTTPS)。OAuth的安全性已经过彻底审查，并且<a class="ae ld" href="https://tools.ietf.org/html/rfc6819" rel="noopener ugc nofollow" target="_blank">已记录</a>。现在，您可以看到我们将client_id和client_secret放在源代码中，这不是一个好主意，在实际系统中，您会将它们放在环境变量中，就像上面对“PORT”所做的那样。我们将在下一个版本中这样做。</p><p id="4dfc" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">授权码是一次性使用的代码，现在已被“使用”，如果您再次尝试使用，您会发现它已过期。要获得新的访问令牌，您要么必须从头开始重新授权，要么获得刷新令牌。</p><p id="2e66" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在可以使用不记名令牌来直接访问Strava api并获取用户信息。例如用简单的卷曲命令。</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="7764" class="le lf ji np b gy nt nu l nv nw">curl -X GET https://www.strava.com/api/v3/athlete -H 'Authorization: Bearer <!-- -->a16bffde2871928071e98fbff5674b12d4fd0198<!-- -->'</span><span id="b075" class="le lf ji np b gy nx nu l nv nw">{"id":23318762,"username":null,"resource_state":2,"firstname":"Eric","lastname":"Lang","city":"Seattle","state":"Washington","country":"United States","sex":"M","premium":false,"summit":false,"created_at":"2017-08-19T18:38:37Z","updated_at":"2020-07-25T14:51:31Z","badge_type_id":0,"profile_medium":"https://dgalywyr863hv.cloudfront.net/pictures/athletes/23376952/7221532/1/medium.jpg","profile":"https://dgalywyr863hv.cloudfront.net/pictures/athletes/23376952/7221532/1/large.jpg","friend":null,"follower":null}</span></pre><p id="407d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Done，那就是基本OAuth 2.0授权码授予的全端-端。尽管我们还没有解决令牌更新、PKCE或服务之间的一些细微差别。我们现在就去做。</p><h1 id="8d42" class="mw lf ji bd lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj nk nl lv nm bi translated">OAuth 2.0客户端包</h1><p id="334a" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">现在我们将把这个简单的例子扩展成一个通用工具，我们可以用它来访问任何OAuth 2.0服务。我们将首先构建一些我们需要的助手。</p><p id="df8d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们希望我们的库支持任何和多个api服务器，所以让我们建立一个配置文件来保存我们的服务数据。请注意，实际的client_id和client_secret将以文件中给出的名称从环境变量中加载，我们不会将它们存储在普通的源文件中。您可以扩展该文件以包含任何新的OAuth 2.0服务。我在Strava、LinkedIn、Spotify和GitHub上设置了api帐户来测试代码。</p><p id="c2d4" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/oclient/services.json</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="4695" class="le lf ji np b gy nt nu l nv nw">{<br/>    "strava": {<br/>        "client_id":          "STRAVA_CLIENT_ID",                                    <br/>        "client_secret":      "STRAVA_CLIENT_SECRET",<br/>        "authorize_endpoint": "<a class="ae ld" href="https://www.strava.com/oauth/authorize" rel="noopener ugc nofollow" target="_blank">https://www.strava.com/oauth/authorize</a>",<br/>        "redirect_uri":       "<a class="ae ld" href="http://localhost:8000/redirect" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/redirect</a>",<br/>        "scope":              "activity:read_all",<br/>        "prompt":             "&amp;approval_prompt=force",<br/>        "token_endpoint":     "<a class="ae ld" href="https://www.strava.com/oauth/token" rel="noopener ugc nofollow" target="_blank">https://www.strava.com/oauth/token</a>",<br/>        "post_type":          "json",<br/>        "refresh_allowed":    "true"<br/>    },<br/>    "linkedin": {<br/>        "client_id":          "LINKEDIN_CLIENT_ID",  <br/>        "client_secret":      "LINKEDIN_CLIENT_SECRET", <br/>        "authorize_endpoint": "<a class="ae ld" href="https://www.linkedin.com/oauth/v2/authorization" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/oauth/v2/authorization</a>",<br/>        "redirect_uri":       "<a class="ae ld" href="http://localhost:8000/redirect" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/redirect</a>",<br/>        "scope":              "r_liteprofile%20r_emailaddress",<br/>        "prompt":             "",<br/>        "token_endpoint":     "<a class="ae ld" href="https://www.linkedin.com/oauth/v2/accessToken" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/oauth/v2/accessToken</a>",<br/>        "post_type":          "form",<br/>        "refresh_allowed":    "false"<br/>    },<br/>    "spotify": {<br/>        "client_id":          "SPOTIFY_CLIENT_ID", <br/>        "client_secret":      "SPOTIFY_CLIENT_SECRET", <br/>        "authorize_endpoint": "<a class="ae ld" href="https://accounts.spotify.com/authorize" rel="noopener ugc nofollow" target="_blank">https://accounts.spotify.com/authorize</a>",<br/>        "redirect_uri":       "<a class="ae ld" href="http://localhost:8000/redirect" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/redirect</a>",<br/>        "scope":              "user-top-read%20user-read-email%20playlist-modify-public",<br/>        "prompt":             "",<br/>        "token_endpoint":     "<a class="ae ld" href="https://accounts.spotify.com/api/token" rel="noopener ugc nofollow" target="_blank">https://accounts.spotify.com/api/token</a>",<br/>        "post_type":          "form",<br/>        "refresh_allowed":    "true"<br/>    },<br/>    "github": {<br/>        "client_id":          "GITHUB_CLIENT_ID", <br/>        "client_secret":      "GITHUB_CLIENT_SECRET", <br/>        "authorize_endpoint": "<a class="ae ld" href="https://github.com/login/oauth/authorize" rel="noopener ugc nofollow" target="_blank">https://github.com/login/oauth/authorize</a>",<br/>        "redirect_uri":       "<a class="ae ld" href="http://localhost:8000/redirect" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/redirect</a>",<br/>        "scope":              "repo",<br/>        "prompt":             "",<br/>        "token_endpoint":     "<a class="ae ld" href="https://github.com/login/oauth/access_token" rel="noopener ugc nofollow" target="_blank">https://github.com/login/oauth/access_token</a>",<br/>        "post_type":          "json",<br/>        "refresh_allowed":    "true"<br/>    }<br/>}</span></pre><p id="fa2f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将这些读入服务映射[字符串]映射[字符串]字符串，以便我们可以按服务和数据类型进行查找。在我们解组文件之后，我们通过从环境变量中读取client_id和client_secret名称，将它们转换为真实值，这些变量将在本地或服务器环境中设置。</p><p id="0a20" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/oclient/oclient.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="6356" class="le lf ji np b gy nt nu l nv nw">func InitOclient() error {<br/>    return loadConfig("oclient/services.json", &amp;services)<br/>}</span><span id="9700" class="le lf ji np b gy nx nu l nv nw">//== Services</span><span id="9a80" class="le lf ji np b gy nx nu l nv nw">var services map[string]map[string]string</span><span id="5999" class="le lf ji np b gy nx nu l nv nw">func loadConfig(fname string, config *map[string]map[string]string) (err error) {<br/>    file, err := os.Open(fname)<br/>    if err != nil {<br/>        return<br/>    }<br/>    defer file.Close()<br/>    byteValue, err := ioutil.ReadAll(file)<br/>    if err != nil {<br/>        return<br/>    }<br/>    json.Unmarshal([]byte(byteValue), config)<br/>    for k, v := range *config {<br/>        v["client_id"] = os.Getenv(v["client_id"])<br/>        if v["client_id"] == "" {<br/>            err = errors.New("Missing service client_id for " + k)<br/>            return<br/>        }<br/>        v["client_secret"] = os.Getenv(v["client_secret"])<br/>        if v["client_secret"] == "" {<br/>            err = errors.New("Missing service client_secret for " + k)<br/>            return<br/>        }<br/>    }<br/>    return<br/>}</span></pre><p id="f1db" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在第一个例子中，回想一下我们在home.html对授权请求进行了硬编码。这不是很好，原因有很多。我们必须在web客户端发起调用，但是让它对web服务器完全不透明是不好的。此外，如果我们想要使用推荐的状态来验证回调，那么我们必须以某种方式让web服务器知道它。因此，我们将在web服务器上生成状态和请求链接，并将其作为api提供给web客户端。干净多了。</p><p id="f805" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">州验证码至少应该是32个随机字节，但是因为我们需要PKCE支持，所以我们可以使用PKCE(128)验证器来验证我们的州代码。让我们建立我们的PKCE助手。PKCE是代码交换的验证密钥，如上所述，它现在是任何不安全(公共)客户端的授权代码授权的推荐扩展。它的工作原理是生成一个随机秘密(验证者)，然后对它进行SHA256哈希运算(挑战)。质询首先在对授权码的初始请求中发送。在授权服务器使用授权码进行回调之后，您可以在下一次对授权服务器的调用中发送验证器而不是客户端密码，以将授权码交换为访问令牌。服务器检查挑战是否与您之前发送的SHA256哈希验证器匹配，如果一切正常，您将获得一个访问令牌。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/043b28094d77efbc8f10955c916abf47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Su0Ye16ewHPd06y4-m0DAA.png"/></div></div></figure><p id="ead7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">根据<a class="ae ld" href="https://tools.ietf.org/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> RFC 7636 </a>，PKCE验证器可以是来自[a-z，a-z，0–9，...，的43到128字节的随机文本。，_，~]字符集。PKCE挑战是验证器的base64-URL编码的SHA256散列。</p><p id="75cd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/oclient/oclient.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="b5ad" class="le lf ji np b gy nt nu l nv nw">package oclient</span><span id="8cf3" class="le lf ji np b gy nx nu l nv nw">import (<br/>    "bytes"<br/>    "crypto/sha256"<br/>    "encoding/base64"<br/>    "encoding/json"<br/>    "errors"<br/>    // "fmt"<br/>    "io"<br/>    "io/ioutil"<br/>    "math/rand"<br/>    "net/http"<br/>    "net/url"<br/>    "os"<br/>    "strings"<br/>    "sync"<br/>    "time"<br/>)</span><span id="d392" class="le lf ji np b gy nx nu l nv nw">const (<br/>    STRAVA    = "strava"<br/>    LINKEDIN  = "linkedin"<br/>    SPOTIFY   = "spotify"<br/>    GITHUB    = "github"<br/>    AUTHORIZE = "authorization_code"<br/>    REFRESH   = "refresh_token"<br/>    SECRET    = "secret"<br/>    PKCE      = "pkce"<br/>)</span><span id="faa0" class="le lf ji np b gy nx nu l nv nw">func InitOclient() error {<br/>    PkceInit()<br/>    return loadConfig("oclient/services.json", &amp;services)<br/>}</span><span id="6edf" class="le lf ji np b gy nx nu l nv nw">//== PKCE</span><span id="ddb8" class="le lf ji np b gy nx nu l nv nw">func PkceInit() {<br/>    rand.Seed(time.Now().UnixNano())<br/>}</span><span id="5a88" class="le lf ji np b gy nx nu l nv nw">//string of pkce allowed chars<br/>func PkceVerifier(length int) string {<br/>    if length &gt; 128 {<br/>        length = 128<br/>    }<br/>    if length &lt; 43 {<br/>        length = 43<br/>    }<br/>    const charset = "abcdefghijklmnopqrstuvwxyz" +<br/>        "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"<br/>    b := make([]byte, length)<br/>    for i := range b {<br/>        b[i] = charset[rand.Intn(len(charset))]<br/>    }<br/>    return string(b)<br/>}</span><span id="cbb1" class="le lf ji np b gy nx nu l nv nw">//base64-URL-encoded SHA256 hash of verifier, per rfc 7636<br/>func PkceChallenge(verifier string) string {<br/>    sum := sha256.Sum256([]byte(verifier))<br/>    challenge := base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(sum[:])<br/>    return (challenge)<br/>}</span></pre><p id="c8c6" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为我们需要临时存储初始客户端请求和服务器回调之间的状态，所以我们将构建一个小型的内存状态管理系统。这可以通过持久存储或其他类似redis的存储系统来实现，但是所需的存储时间窗口足够短，我们可以构建自己的存储系统并保持其简单性。它确实需要互斥保护，因为多个客户端可以访问它。我们将让查找键成为州代码，有效负载将是一个包含过期时间戳、服务名、授权类型以及PKCE验证器和质询的结构，我们最终将需要它来支持PKCE。</p><p id="3c2c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当客户端向授权服务器发出代码请求时，可能会出现一个问题，授权服务器会生成一个保存到我们的地图中的状态代码，但是由于某种原因，用户没有完成授权，所以回调永远不会发生，所以状态代码永远不会从我们的地图中删除。这就是为什么State结构包含CreatedAt字段，以及为什么我们需要经常启动垃圾收集来清理映射。我们不需要cron它，我们可以偷懒，只检查我们是否应该在setState()函数中进行GC。这种泄漏对普通用户来说应该很少，所以我们不想给系统增加过多的负担，但我们需要足够频繁地清理以防范恶意攻击，如果我们达到了存储限制，我们需要积极地进行清理。因此，我们检查对setState的每个调用，寻找对垃圾收集限制(GcPeriod)的理想超越，以及对状态映射所允许的最大大小(MaxState)的不太理想的超越。这两种情况都会触发垃圾收集。垃圾收集例程以InitAuthTimeout的理想到期开始，并在每次迭代中将它减半，直到它回到MaxState之下。在输入时使用验证码也有助于防范恶意。您可以根据自己的具体应用随意更改这些常数。</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="ba98" class="le lf ji np b gy nt nu l nv nw">//== State Management</span><span id="78bd" class="le lf ji np b gy nx nu l nv nw">const (<br/>    GcPeriod        = 60  //minutes - minimum ideal time between GC runs (unless MaxState)<br/>    InitAuthTimeout = 10  //minutes - amount of time user has to complete Authorization and get Access Code from Authorization Server<br/>    MaxState        = 400 //max allowed length of state map, to prevent malicious memory overflow<br/>)</span><span id="691a" class="le lf ji np b gy nx nu l nv nw">type State struct {<br/>    CreatedAt     time.Time<br/>    Service       string<br/>    AuthType      string<br/>    PkceVerifier  string<br/>    PkceChallenge string<br/>}</span><span id="af4b" class="le lf ji np b gy nx nu l nv nw">var state = make(map[string]*State)<br/>var lastGc = time.Now().UTC()<br/>var mutex = &amp;sync.Mutex{}</span><span id="32aa" class="le lf ji np b gy nx nu l nv nw">//get the payload for a state, check expiration, and delete<br/>func getState(key string) (value *State) {<br/>    mutex.Lock()<br/>    v, exists := state[key]<br/>    if exists {<br/>        n := time.Now().UTC()<br/>        if n.After(v.CreatedAt.Add(InitAuthTimeout * time.Minute)) {<br/>            value = nil //don't accept expired state<br/>        } else {<br/>            value = v<br/>        }<br/>        delete(state, key)<br/>    } else {<br/>        value = nil<br/>    }<br/>    defer mutex.Unlock()<br/>    return<br/>}</span><span id="53a8" class="le lf ji np b gy nx nu l nv nw">//set the payload for a state, set expiration, do gc as needed<br/>func setState(key string, value *State) {<br/>    mutex.Lock()<br/>    n := time.Now().UTC()<br/>    value.CreatedAt = n<br/>    state[key] = value<br/>    //gc<br/>    authTimeout := InitAuthTimeout * time.Minute //type Duration<br/>    gcTime := lastGc.Add(GcPeriod * time.Minute)<br/>    if n.After(gcTime) || len(state) &gt;= MaxState {<br/>        for ok := true; ok; ok = len(state) &gt;= MaxState { //keep going till below MaxState, 1/2 each cycle<br/>            for k, v := range state {<br/>                expiresAt := v.CreatedAt.Add(authTimeout)<br/>                if n.After(expiresAt) {<br/>                    delete(state, k)<br/>                }<br/>            }<br/>            authTimeout /= 2<br/>        }<br/>        lastGc = time.Now().UTC()<br/>    }<br/>    defer mutex.Unlock()<br/>    return<br/>}</span></pre><p id="a8b2" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们成功地从授权服务器接收到一个访问令牌时，我们希望将它存储在某个地方，以便我们可以在将来的api调用中使用它，直到它过期。我们将为每项服务提供一个令牌。同样，我们可以使用一些持久存储数据库，但我们也可以只是让它成为一个安全的cookie。注意，对于本地主机测试，我们将Secure设置为false，将SameSite设置为http。但是当我们部署到服务器时，我们将把Secure设置为true，把SameSite设置为http.SameSiteStrictMode。</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="a14f" class="le lf ji np b gy nt nu l nv nw">//== Cookie Helpers</span><span id="8462" class="le lf ji np b gy nx nu l nv nw">const CookiePrefix = "_OClient"</span><span id="a737" class="le lf ji np b gy nx nu l nv nw">func cookieName(service string) string {<br/>    return (CookiePrefix + service)<br/>}</span><span id="28b2" class="le lf ji np b gy nx nu l nv nw">//generic cookie setter<br/>func setCookie(w http.ResponseWriter, token string, cookieName string) {<br/>    tok64 := base64.StdEncoding.EncodeToString([]byte(token))<br/>    cookie := http.Cookie{<br/>        Name:     cookieName,<br/>        Value:    tok64,<br/>        HttpOnly: true,<br/>        Secure:   false, //use true for production<br/>        Path:     "/",<br/>        SameSite: http.SameSiteLaxMode,<br/>    }<br/>    http.SetCookie(w, &amp;cookie)<br/>    return<br/>}</span><span id="ceab" class="le lf ji np b gy nx nu l nv nw">//generic cookie getter<br/>func getCookie(r *http.Request, cookieName string) (token string, err error) {<br/>    cookie, err := r.Cookie(cookieName)<br/>    if err != nil {<br/>        return<br/>    }<br/>    tokb, err := base64.StdEncoding.DecodeString(cookie.Value)<br/>    if err != nil {<br/>        return<br/>    }<br/>    token = string(tokb)<br/>    return<br/>}</span></pre><p id="d693" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要一个API助手来创建基于特定服务的请求链接。我们的助手将利用json文件加载的服务地图来查找特定服务的正确信息。注意，我们在最后调用setState()，将State作为一个键——所以当我们从授权服务器获得state时，我们可以很容易地检查有效性并查找有效负载。</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="1c29" class="le lf ji np b gy nt nu l nv nw">//== API Helpers</span><span id="688a" class="le lf ji np b gy nx nu l nv nw">//build service Code Authorize Link and save state as pkceVerifier (128)<br/>func AuthLink(r *http.Request, authtype string, service string) (result string) {<br/>    stData := State{Service: service, AuthType: authtype}<br/>    st := PkceVerifier(128)<br/>    result = services[service]["authorize_endpoint"]<br/>    result += "?client_id=" + services[service]["client_id"]<br/>    result += "&amp;response_type=code&amp;redirect_uri="<br/>    result += services[service]["redirect_uri"]<br/>    result += "&amp;scope=" + services[service]["scope"]<br/>    result += services[service]["prompt"]<br/>    if authtype == PKCE {<br/>        stData.PkceVerifier = PkceVerifier(128)<br/>        stData.PkceChallenge = PkceChallenge(stData.PkceVerifier)<br/>        result += "&amp;code_challenge=" + stData.PkceChallenge<br/>        result += "&amp;code_challenge_method=S256"<br/>    }<br/>    result += "&amp;state=" + st<br/>    setState(st, &amp;stData)<br/>    return<br/>}</span></pre><p id="42c6" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，在我们的main中，我们将构建一个带有API endpoint/authlink/{ authtype }/{ service }的小服务器，它返回上面我们的服务器生成的链接。{authtype}可以是“secret ”,用于基于普通客户端秘密的授权码授予，或者可以是“pkce ”,用于PKCE扩展。{service}可以是我们支持的任何服务的名称，目前包括“strava”、“linkedin”、“spotify”、“github”..以及您添加到services.json文件中的任何其他内容。我为每一个都添加了常量以减少错误，但这不是必需的。</p><p id="9c2d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/main.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="37d9" class="le lf ji np b gy nt nu l nv nw">package main</span><span id="c8bd" class="le lf ji np b gy nx nu l nv nw">import (<br/>    "github.com/exyzzy/oclient/oclient"<br/>    "fmt"<br/>    "github.com/gorilla/mux"<br/>    "html/template"<br/>    "io/ioutil"<br/>    "log"<br/>    "net/http"<br/>    "net/url"<br/>    "os"<br/>    "path"<br/>)</span><span id="98c6" class="le lf ji np b gy nx nu l nv nw">func main() {<br/>    err := oclient.InitOclient()<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    port := os.Getenv("PORT")<br/>    if port == "" {<br/>        port = "8000"<br/>    }<br/>    r := mux.NewRouter()<br/>    r.HandleFunc("/", PageHomeHandler)<br/>    r.HandleFunc("/page/api", PageApiHandler)<br/>    r.HandleFunc("/authlink/{authtype}/{service}", AuthlinkHandler)<br/>    r.HandleFunc("/redirect", RedirectHandler)<br/>    r.HandleFunc("/strava/get/athlete", StravaGetAthleteHandler)<br/>    r.HandleFunc("/strava/get/activities", StravaGetActivitiesHandler)<br/>    r.HandleFunc("/linkedin/get/me", LinkedinGetMeHandler)<br/>    r.HandleFunc("/spotify/get/me", SpotifyGetMeHandler)<br/>    r.HandleFunc("/spotify/get/newreleases", SpotifyGetNewReleasesHandler)<br/>    r.HandleFunc("/spotify/put/rename", SpotifyPutRenameHandler)<br/>    r.HandleFunc("/github/get/user", GithubGetUserHandler)<br/>    http.Handle("/", r)<br/>    fmt.Println("&gt;&gt;&gt;&gt;&gt;&gt;&gt; OClient started at:", port)<br/>    log.Fatal(http.ListenAndServe(":"+port, nil))<br/>    return<br/>}</span><span id="b49b" class="le lf ji np b gy nx nu l nv nw">func PageHomeHandler(w http.ResponseWriter, r *http.Request) {<br/>    pageHandler(w, r, nil, "templates", "home.html")<br/>}</span><span id="3c7f" class="le lf ji np b gy nx nu l nv nw">func PageApiHandler(w http.ResponseWriter, r *http.Request) {<br/>    pageHandler(w, r, nil, "templates", "api.html")<br/>}</span><span id="fe91" class="le lf ji np b gy nx nu l nv nw">func pageHandler(w http.ResponseWriter, r *http.Request, data interface{}, dir string, filenames ...string) {<br/>    var files []string<br/>    for _, file := range filenames {<br/>        files = append(files, path.Join(dir, file))<br/>    }<br/>    tmpl, err := template.ParseFiles(files...)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    if err := tmpl.Execute(w, data); err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>}</span><span id="a2f9" class="le lf ji np b gy nx nu l nv nw">func AuthlinkHandler(w http.ResponseWriter, r *http.Request) {<br/>    vars := mux.Vars(r)<br/>    authtype := vars["authtype"]<br/>    service := vars["service"]<br/>    authlink := oclient.AuthLink(r, authtype, service)<br/>    fmt.Fprintln(w, authlink)<br/>}</span></pre><p id="ffe3" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">再次注意，我们在前端不需要任何硬编码的请求链接，因为我们创建了一个api来根据需要动态生成链接。一个小的JS函数调用Axios来为我们的客户端检索链接。我们只生成一个新的链接，并在实际用户点击时设置状态。</p><p id="d02a" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/templates/home.html</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="68c0" class="le lf ji np b gy nt nu l nv nw">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>    &lt;head&gt;<br/>        &lt;meta charset="UTF-8"&gt;<br/>        &lt;title&gt;OClient&lt;/title&gt;<br/>        &lt;style&gt;<br/>            body {<br/>              background-color: lightgray;<br/>            }<br/>        &lt;/style&gt;<br/>        <br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;OClient Authorize&lt;/h1&gt;<br/>        &lt;br&gt;<br/>        &lt;button onclick="getLink(`secret`, `strava`)"&gt;Code Authorize Strava&lt;/button&gt;<br/>        &lt;button onclick="getLink(`secret`,`linkedin`)"&gt;Code Authorize LinkedIn&lt;/button&gt;<br/>        &lt;button onclick="getLink(`pkce`,`linkedin`)"&gt;PKCE Authorize LinkedIn&lt;/button&gt;<br/>        &lt;button onclick="getLink(`pkce`,`spotify`)"&gt;PKCE Authorize Spotify&lt;/button&gt;<br/>        &lt;button onclick="getLink(`secret`,`github`)"&gt;Code Authorize Github&lt;/button&gt;</span><span id="b214" class="le lf ji np b gy nx nu l nv nw">&lt;script src="<a class="ae ld" href="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js</a>"&gt;&lt;/script&gt;<br/>        &lt;script&gt;</span><span id="88e9" class="le lf ji np b gy nx nu l nv nw">           function getLink(type, service) {<br/>                console.log(type, service)<br/>            // Make a request for a user with a given ID<br/>                axios.get('/authlink/'+ type + '/' + service)<br/>                .then((response) =&gt; {<br/>                    console.log(response.data)<br/>                    window.location.href=response.data<br/>                })<br/>                .catch(function (error) {<br/>                    console.log(error);<br/>                });<br/>            }<br/>        &lt;/script&gt;</span><span id="73a0" class="le lf ji np b gy nx nu l nv nw">&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="c674" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">既然我们成功地请求了授权代码并显示了服务提示，我们需要构建重定向端点来接收回调并交换代码。我们从服务收到的访问令牌是json，所以对我们来说它是map[string]interface{}。</p><p id="2569" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">getToken()函数通过构建一个字符串化的map[string][string]参数来完成繁重的工作，该map[string][string]参数是服务期望在令牌端点接收的post参数。根据服务偏好，它可以作为application/JSON(" post _ type ":" JSON ")或application/x-www-form-urlencoded(" post _ type ":" form ")发布。OAuth 2.0指定了表单编码，但是大多数服务将接受json。最后，它执行post，ExchangeCode()将返回的令牌保存为cookie。</p><p id="fa7d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">令人惊讶的是，有些服务在令牌上根本没有到期时间，有些使用expires_in而不是expires_at。我们将所有这些都统一在getToken()中，并将所有内容转换为“expires_at ”,以使刷新更容易处理。</p><p id="fda8" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/oclient/oclient.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="a021" class="le lf ji np b gy nt nu l nv nw">//== Access Token</span><span id="c4c2" class="le lf ji np b gy nx nu l nv nw">//exchange the Authorization Code for Access Token<br/>func ExchangeCode(w http.ResponseWriter, r *http.Request, code string, state string) (err error) {<br/>    statePtr := getState(state)<br/>    if statePtr == nil {<br/>        err = errors.New("State Key not found")<br/>        return<br/>    }<br/>    token, err := getToken(w, r, statePtr.Service, AUTHORIZE, code, statePtr.AuthType, statePtr.PkceVerifier)<br/>    if err != nil {<br/>        return<br/>    }<br/>    setCookie(w, token, cookieName(statePtr.Service)) //note: must set cookie before writing to responsewriter<br/>    return<br/>}</span><span id="d770" class="le lf ji np b gy nx nu l nv nw">//wrapper to set accept header<br/>func jsonPost(url string, body io.Reader) (resp *http.Response, err error) {<br/>    var client = &amp;http.Client{<br/>        Timeout: time.Second * 10,<br/>    }<br/>    req, err := http.NewRequest("POST", url, body)<br/>    if err != nil {<br/>        return nil, err<br/>    }<br/>    req.Header.Set("Content-Type", "application/json")<br/>    req.Header.Set("Accept", "application/json")<br/>    return client.Do(req)<br/>}</span><span id="ab2d" class="le lf ji np b gy nx nu l nv nw">//subtract a small delta from exires_at to account for transport time<br/>const DELTASECS = 5</span><span id="9cb4" class="le lf ji np b gy nx nu l nv nw">//get a token from authorization endpoint<br/>func getToken(w http.ResponseWriter, r *http.Request, service string, tokType string, code string, authType string, verifier string) (result string, err error) {<br/>    rParams := map[string]string{<br/>        "client_id":    services[service]["client_id"],<br/>        "redirect_uri": services[service]["redirect_uri"],<br/>    }<br/>    switch tokType {<br/>    case AUTHORIZE:<br/>        rParams["code"] = code<br/>        rParams["grant_type"] = AUTHORIZE<br/>    case REFRESH:<br/>        rParams["refresh_token"] = code<br/>        rParams["grant_type"] = REFRESH<br/>    default:<br/>        err = errors.New("Unknown tokType")<br/>        return<br/>    }<br/>    switch authType {<br/>    case SECRET:<br/>        rParams["client_secret"] = services[service]["client_secret"]<br/>    case PKCE:<br/>        rParams["code_verifier"] = verifier<br/>    default:<br/>        err = errors.New("Unknown authType")<br/>        return<br/>    }<br/>    var resp *http.Response<br/>    switch services[service]["post_type"] {<br/>    case "json":<br/>        var requestBody []byte<br/>        requestBody, err = json.Marshal(rParams)<br/>        if err != nil {<br/>            return<br/>        }<br/>        resp, err = jsonPost(services[service]["token_endpoint"], bytes.NewBuffer(requestBody))<br/>        if err != nil {<br/>            return<br/>        }</span><span id="4cba" class="le lf ji np b gy nx nu l nv nw">    case "form":<br/>        vals := url.Values{}<br/>        for k, v := range rParams {<br/>            vals.Set(k, v)<br/>        }<br/>        resp, err = http.PostForm(services[service]["token_endpoint"], vals)<br/>        if err != nil {<br/>            return<br/>        }<br/>    default:<br/>        err = errors.New("Unknown post_type")<br/>        return<br/>    }<br/>    defer resp.Body.Close()<br/>    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        return<br/>    }<br/>    if resp.StatusCode != 200 {<br/>        err = errors.New(string(body))<br/>        return<br/>    }<br/>    //check for expires_at<br/>    var tokMap map[string]interface{}<br/>    decoder := json.NewDecoder(strings.NewReader(string(body)))<br/>    decoder.UseNumber()<br/>    err = decoder.Decode(&amp;tokMap)<br/>    if err != nil {<br/>        err = errors.New("decoder.Decode: " + err.Error())<br/>        return<br/>    }<br/>    expire, exists := tokMap["expires_at"]</span><span id="2ed8" class="le lf ji np b gy nx nu l nv nw">    if exists {<br/>        result = string(body)<br/>        return<br/>    }<br/>    var expiresIn int64<br/>    expire, exists = tokMap["expires_in"]<br/>    if !exists { //no expiration, so make it a year<br/>        expiresIn = 31536000<br/>    } else {<br/>        expiresIn, err = expire.(json.Number).Int64()<br/>    }<br/>    tokMap["expires_at"] = epochSeconds() + expiresIn - DELTASECS<br/>    b, err := json.Marshal(tokMap)<br/>    if err != nil {<br/>        err = errors.New("json.Marshal: " + err.Error())<br/>        return<br/>    }<br/>    result = string(b)<br/>    return<br/>}</span></pre><p id="c122" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们已经在上面为它添加了路由，现在让我们填充处理程序。</p><p id="f06c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/main.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="67a6" class="le lf ji np b gy nt nu l nv nw">func RedirectHandler(w http.ResponseWriter, r *http.Request) {<br/>    m, err := url.ParseQuery(r.URL.RawQuery)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    code := m.Get("code")<br/>    state := m.Get("state")<br/>    err = oclient.ExchangeCode(w, r, code, state) //do not write to w before this call<br/>    if err != nil {<br/>        http.Error(w, "Exchange Failed: "+err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    // fmt.Fprintln(w, "Code: ", code, " Scope: ", scope)<br/>    http.Redirect(w, r, "/page/api", 302)<br/>}</span></pre><p id="297b" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在有了访问令牌，我们将构建一些助手来对我们的服务api进行api调用，为服务添加正确的承载令牌。我们的setHeader()函数将检查过期的AccessToken，并在允许的情况下自动刷新它。</p><p id="ae22" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/oclient/oclient.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="3ca2" class="le lf ji np b gy nt nu l nv nw">//make call to a resource api, add oauth bearer token<br/>func ApiRequest(w http.ResponseWriter, r *http.Request, service, method, url string, data map[string]interface{}) (response *http.Response, err error) {<br/>    var client = &amp;http.Client{<br/>        Timeout: time.Second * 10,<br/>    }<br/>    var body io.Reader<br/>    if data == nil {<br/>        body = nil<br/>    } else {<br/>        var requestBody []byte<br/>        requestBody, err = json.Marshal(data)<br/>        if err != nil {<br/>            return<br/>        }<br/>        body = bytes.NewBuffer(requestBody)<br/>    }<br/>    request, err := http.NewRequest(method, url, body)<br/>    if err != nil {<br/>        return<br/>    }<br/>    err = setHeader(w, r, service, request)<br/>    if err != nil {<br/>        err = errors.New("Unable to set Header: " + err.Error())<br/>        return<br/>    }<br/>    response, err = client.Do(request)<br/>    return<br/>}</span><span id="1bdd" class="le lf ji np b gy nx nu l nv nw">func epochSeconds() int64 {<br/>    now := time.Now()<br/>    secs := now.Unix()<br/>    return secs<br/>}</span><span id="6ede" class="le lf ji np b gy nx nu l nv nw">//get Access Token via cookie, refresh if expired, set header bearer token<br/>func setHeader(w http.ResponseWriter, r *http.Request, service string, newReq *http.Request) (err error) {<br/>    token, err := getCookie(r, cookieName(service))<br/>    if err != nil {<br/>        return<br/>    }<br/>    var tokMap map[string]interface{}</span><span id="fcbd" class="le lf ji np b gy nx nu l nv nw">    // err = json.Unmarshal([]byte(token), &amp;tokMap)<br/>    // normally as above, but we want numbers as ints vs floats<br/>    decoder := json.NewDecoder(strings.NewReader(token))<br/>    decoder.UseNumber()<br/>    err = decoder.Decode(&amp;tokMap)</span><span id="3b49" class="le lf ji np b gy nx nu l nv nw">expiresAt, err := tokMap["expires_at"].(json.Number).Int64()<br/>    if err != nil {<br/>        return<br/>    }<br/>    if epochSeconds() &gt; expiresAt { //token has expired, refresh it<br/>        if services[service]["refresh_allowed"] == "false" {<br/>            err = errors.New("Non-refreshable Token Expired, Re-authorize")<br/>            return<br/>        }<br/>        refresh, exists := tokMap["refresh_token"]<br/>        if !exists {<br/>            err = errors.New("Refresh Token Not Found")<br/>            return<br/>        }<br/>        var newToken string<br/>        newToken, err = getToken(w, r, service, REFRESH, refresh.(string), SECRET, "")<br/>        if err != nil {<br/>            return<br/>        }<br/>        setCookie(w, newToken, cookieName(service)) //note: must set cookie before writing to responsewriter<br/>        decoder = json.NewDecoder(strings.NewReader(newToken))<br/>        decoder.UseNumber()<br/>        tokMap = make(map[string]interface{})<br/>        err = decoder.Decode(&amp;tokMap)<br/>        if err != nil {<br/>            return<br/>        }<br/>    }<br/>    newReq.Header.Add("Authorization", "Bearer "+tokMap["access_token"].(string))<br/>    newReq.Header.Set("Content-Type", "application/json")<br/>    newReq.Header.Set("Accept", "application/json")<br/>    return<br/>}</span></pre><p id="f66c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们完成了基本的管道工程。接下来，我们将在services.json配置中实际练习各种OAuth服务api。我们将首先设置服务api处理程序。我将只设置几个来演示每个服务，但是在这里您可以使用ApiRequest()和任何应用程序/业务逻辑层对服务进行任何调用。</p><p id="7cc7" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/main.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="904b" class="le lf ji np b gy nt nu l nv nw">//== API</span><span id="6b1e" class="le lf ji np b gy nx nu l nv nw">func StravaGetAthleteHandler(w http.ResponseWriter, r *http.Request) {</span><span id="af9f" class="le lf ji np b gy nx nu l nv nw">    url := "<a class="ae ld" href="https://www.strava.com/api/v3/athlete" rel="noopener ugc nofollow" target="_blank">https://www.strava.com/api/v3/athlete</a>"<br/>    resp, err := oclient.ApiRequest(w, r, oclient.STRAVA, "GET", url, nil)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    defer resp.Body.Close()<br/>    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    fmt.Fprintln(w, string(body))<br/>}</span><span id="fb1f" class="le lf ji np b gy nx nu l nv nw">func StravaGetActivitiesHandler(w http.ResponseWriter, r *http.Request) {</span><span id="d674" class="le lf ji np b gy nx nu l nv nw">    url := "<a class="ae ld" href="https://www.strava.com/api/v3/athlete/activities?page=1&amp;per_page=30" rel="noopener ugc nofollow" target="_blank">https://www.strava.com/api/v3/athlete/activities?page=1&amp;per_page=30</a>"<br/>    resp, err := oclient.ApiRequest(w, r, oclient.STRAVA, "GET", url, nil)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    defer resp.Body.Close()<br/>    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    fmt.Fprintln(w, string(body))<br/>}</span><span id="5078" class="le lf ji np b gy nx nu l nv nw">func LinkedinGetMeHandler(w http.ResponseWriter, r *http.Request) {</span><span id="8566" class="le lf ji np b gy nx nu l nv nw">    url := "<a class="ae ld" href="https://api.linkedin.com/v2/me" rel="noopener ugc nofollow" target="_blank">https://api.linkedin.com/v2/me</a>"<br/>    resp, err := oclient.ApiRequest(w, r, oclient.LINKEDIN, "GET", url, nil)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    defer resp.Body.Close()<br/>    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    fmt.Fprintln(w, string(body))<br/>}</span><span id="5e1b" class="le lf ji np b gy nx nu l nv nw">func SpotifyGetMeHandler(w http.ResponseWriter, r *http.Request) {</span><span id="37a9" class="le lf ji np b gy nx nu l nv nw">    url := "<a class="ae ld" href="https://api.spotify.com/v1/me" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/me</a>"<br/>    resp, err := oclient.ApiRequest(w, r, oclient.SPOTIFY, "GET", url, nil)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    defer resp.Body.Close()<br/>    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    fmt.Fprintln(w, string(body))<br/>}</span><span id="27c2" class="le lf ji np b gy nx nu l nv nw">func SpotifyGetNewReleasesHandler(w http.ResponseWriter, r *http.Request) {</span><span id="2c0c" class="le lf ji np b gy nx nu l nv nw">    url := "<a class="ae ld" href="https://api.spotify.com/v1/browse/new-releases" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/browse/new-releases</a>"<br/>    resp, err := oclient.ApiRequest(w, r, oclient.SPOTIFY, "GET", url, nil)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    defer resp.Body.Close()<br/>    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    fmt.Fprintln(w, string(body))<br/>}</span><span id="72eb" class="le lf ji np b gy nx nu l nv nw">func SpotifyPutRenameHandler(w http.ResponseWriter, r *http.Request) {</span><span id="a53c" class="le lf ji np b gy nx nu l nv nw">    data := map[string]interface{}{<br/>        "name":        "Updated Playlist Name",<br/>        "description": "Updated playlist description",<br/>        "public":      false,<br/>    }</span><span id="b014" class="le lf ji np b gy nx nu l nv nw">    //specific playlist, yours will be different<br/>    url := "<a class="ae ld" href="https://api.spotify.com/v1/playlists/2RmnrZSPoYtVyjou7DU8We" rel="noopener ugc nofollow" target="_blank">https://api.spotify.com/v1/playlists/2RmnrZSPoYtVyjou7DU8We</a>"<br/>    resp, err := oclient.ApiRequest(w, r, oclient.SPOTIFY, "PUT", url, data)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    defer resp.Body.Close()<br/>    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    fmt.Fprintln(w, string(body))<br/>}</span><span id="0044" class="le lf ji np b gy nx nu l nv nw">func GithubGetUserHandler(w http.ResponseWriter, r *http.Request) {</span><span id="78cb" class="le lf ji np b gy nx nu l nv nw">    url := "<a class="ae ld" href="https://api.github.com/user" rel="noopener ugc nofollow" target="_blank">https://api.github.com/user</a>"<br/>    resp, err := oclient.ApiRequest(w, r, oclient.GITHUB, "GET", url, nil)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    defer resp.Body.Close()<br/>    body, err := ioutil.ReadAll(resp.Body)<br/>    if err != nil {<br/>        http.Error(w, err.Error(), http.StatusInternalServerError)<br/>        return<br/>    }<br/>    fmt.Fprintln(w, string(body))<br/>}</span></pre><p id="63ae" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，一个小的api页面，带有调用我们已经公开的这些服务api的按钮。服务授权成功后，主页将重定向到此处。</p><p id="4bc6" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient/templates/api.html</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="d2f5" class="le lf ji np b gy nt nu l nv nw">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>    &lt;head&gt;<br/>        &lt;meta charset="UTF-8"&gt;<br/>        &lt;title&gt;OClient API&lt;/title&gt;<br/>        &lt;style&gt;<br/>            body {<br/>              background-color: lightgray;<br/>            }<br/>        &lt;/style&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;OClient API&lt;/h1&gt;<br/>        &lt;br&gt;<br/>        &lt;a href="/"&gt;Home Page&lt;/a&gt;<br/>        &lt;br&gt;&lt;br&gt;<br/>        &lt;button onclick="window.location.href=window.location.origin + '/strava/get/athlete'"&gt;Get Strava Athlete&lt;/button&gt;<br/>        &lt;button onclick="window.location.href=window.location.origin + '/strava/get/activities'"&gt;Get Strava Activities&lt;/button&gt;<br/>        &lt;button onclick="window.location.href=window.location.origin + '/linkedin/get/me'"&gt;Get Linkedin Profile&lt;/button&gt;<br/>        &lt;button onclick="window.location.href=window.location.origin + '/spotify/get/me'"&gt;Get Spotify Profile&lt;/button&gt;<br/>        &lt;button onclick="window.location.href=window.location.origin + '/spotify/get/newreleases'"&gt;Get Spotify New Releases&lt;/button&gt;<br/>        &lt;button onclick="window.location.href=window.location.origin + '/spotify/put/rename'"&gt;Spotify Put Rename&lt;/button&gt;<br/>        &lt;button onclick="window.location.href=window.location.origin + '/github/get/user'"&gt;Github Get User&lt;/button&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="af8c" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">好了，让我们克隆、编译并运行它。请注意，当您这样做时，您必须为您的服务设置环境变量，以匹配您在oclient/services.json中为<strong class="kh jj"> client_id和client_secret </strong>设置的名称——在您这样做之前，它不会运行。如果您愿意，还可以添加不同的服务api，并更改auth/api调用。此外，我的演示在oclient/main.go中有一个硬编码的spotify播放列表id(特定于我)，只是为了测试和演示一个PUT调用。</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="2305" class="le lf ji np b gy nt nu l nv nw">go get github.com/exyzzy/oclient<br/>go install $GOPATH/src/github.com/exyzzy/oclient<br/>oclient</span></pre><p id="cd80" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当您在localhost:8000上打开浏览器时，您应该会看到:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/d78c4d9e0eb0d7cfc35822ae1d3c06a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajwIZEAOu0TU-9AMg8wrrw.png"/></div></div></figure><p id="6809" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当你点击一个按钮时，应该会弹出该服务的授权页面。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/7c8d0cbe08a9778cda6058013615bdef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bs4_uSLoWbBYYIq_tWTiDA.png"/></div></div></figure><p id="0129" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当您授权时，您应该被重定向回服务api页面。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/0ae50e086750fbef0b21212e540ddcbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOrBCEYSpyKbxWNn4W9Jhg.png"/></div></div></figure><p id="ea0d" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以单击任何按钮来启动特定的api并查看返回值。但是如果您还没有这样做，您必须返回到主页并首先对它们进行授权。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/3eae4af3ccfaf7068423a2a9485d0e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFRrbc1d4Zre7AHZ6QJzYg.png"/></div></div></figure><p id="174e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您检查应用程序cookie，您会看到它将我们的状态存储在每个服务的_OClient* cookie下。</p><h1 id="104b" class="mw lf ji bd lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj nk nl lv nm bi translated">后续步骤</h1><p id="307d" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">我们已经建立了一个很好的小通用和可扩展的OAuth 2.0客户端库，可以用于任何第三方服务。虽然它还没有在生产环境中测试过，但是它应该会给你一个很好的开端。</p><p id="7a4e" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以在这里找到所有的代码。玩得开心。</p><div class="is it gp gr iu of"><a href="https://github.com/exyzzy/oclient" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jj gy z fp ok fr fs ol fu fw jh bi translated">GitHub - exyzzy/oclient:在Go中访问安全的HTTP服务</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在Go中访问安全的HTTP服务。在GitHub上创建一个帐户，为exyzzy/oclient开发做出贡献。</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ja of"/></div></div></a></div><h1 id="3208" class="mw lf ji bd lg mx my mz lj na nb nc lm nd ne nf lp ng nh ni ls nj nk nl lv nm bi translated">附录</h1><p id="1bb6" class="pw-post-body-paragraph kf kg ji kh b ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky mb la lb lc im bi translated">自从写这篇文章以来，我遇到了几个需要支持基本认证的新网站，它们已经被添加到github repo中。</p><p id="f0cd" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">oclient.go</p><pre class="mr ms mt mu gt no np nq nr aw ns bi"><span id="b20b" class="le lf ji np b gy nt nu l nv nw">func basicAuth(username, password string) string {<br/>   auth := username + ":" + password<br/>   return base64.StdEncoding.EncodeToString([]byte(auth))<br/>}</span><span id="0248" class="le lf ji np b gy nx nu l nv nw">func basicPost(url string, body io.Reader, ba string) (resp *http.Response, err error) {<br/>   var client = &amp;http.Client{<br/>      Timeout: time.Second * 10,<br/>   }<br/>   req, err := http.NewRequest("POST", url, body)<br/>   if err != nil {<br/>      return nil, err<br/>   }<br/>   req.Header.Add("Authorization", "Basic "+ba)<br/>   req.Header.Set("Content-Type", "application/x-www-form-urlencoded")<br/>   req.Header.Set("Accept", "application/json")<br/>   return client.Do(req)<br/>}</span><span id="2fd1" class="le lf ji np b gy nx nu l nv nw">func getToken(w http.ResponseWriter, r *http.Request, service string, tokType string, code string, authType string, verifier string) (result string, err error) {</span><span id="03ab" class="le lf ji np b gy nx nu l nv nw">...</span><span id="9bff" class="le lf ji np b gy nx nu l nv nw">case "basic":<br/>   form := url.Values{}<br/>   for k, v := range rParams {<br/>      form.Set(k, v)<br/>   }<br/>   basic := basicAuth(rParams["client_id"], rParams["client_secret"])<br/>   resp, err = basicPost(services[service]["token_endpoint"], strings.NewReader(form.Encode()), basic)<br/>   if err != nil {<br/>      return<br/>   }<br/>   </span><span id="a29a" class="le lf ji np b gy nx nu l nv nw">...</span></pre><p id="1278" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">与本文最相似的代码版本是:【https://github.com/exyzzy/oclient<a class="ae ld" href="https://github.com/exyzzy/oclient" rel="noopener ugc nofollow" target="_blank"/></p><p id="295f" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，代码的最新(最好)版本是一个新的包版本:</p><div class="is it gp gr iu of"><a href="https://github.com/exyzzy/oauth2" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jj gy z fp ok fr fs ol fu fw jh bi translated">GitHub - exyzzy/oauth2: oauth2用于go的包</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">用于Go的OAuth 2.0客户端包见Medium文章:然而，这只是核心OAuth 2包的例子…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot ja of"/></div></div></a></div><p id="3b91" class="pw-post-body-paragraph kf kg ji kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里是它的示例代码:</p><div class="is it gp gr iu of"><a href="https://github.com/exyzzy/oclient2" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jj gy z fp ok fr fs ol fu fw jh bi translated">GitHub-exy zzy/o client 2:oauth 2包的客户端示例</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">oauth2包的客户端示例。通过在GitHub上创建帐户，为exyzzy/oclient2开发做出贡献。</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot ja of"/></div></div></a></div></div></div>    
</body>
</html>