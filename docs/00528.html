<html>
<head>
<title>Chrome Extension Tutorial — Replace Images in Any Website with Pikachu</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chrome扩展教程—用皮卡丘替换任何网站中的图像</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/chrome-extension-tutorial-replace-images-in-any-website-with-pikachu-de2a6e3548bb?source=collection_archive---------0-----------------------#2019-04-11">https://levelup.gitconnected.com/chrome-extension-tutorial-replace-images-in-any-website-with-pikachu-de2a6e3548bb?source=collection_archive---------0-----------------------#2019-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/1e51598724d623ed07ae7101ce397d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*vmWE3vsfXHKDKDGW9HAZMQ.gif"/></div></figure><p id="0636" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有什么比用皮卡丘图片让网页更可爱更好的方法来学习如何制作Chrome扩展？</p><p id="1b77" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在本教程中，我将向您展示如何创建一个简单的Chrome扩展，用皮卡丘图片替换网站上的图片。我们将讨论Chrome扩展中的内容脚本、后台脚本和脚本间消息等主题。</p><p id="1c4f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本教程的代码可从<a class="ae kv" href="https://github.com/shahednasser/pikachu-everywhere" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl kw kx hx ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="im in io ip iq"><p id="c2c7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">创建任何chrome扩展时，你需要做的第一件事就是在扩展目录的根目录下创建一个<strong class="jz iu"> manifest.json </strong>文件。目前，该文件将只保存关于您的扩展的以下基本信息:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="aaf4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以下是该文件中所有内容的含义:</p><ol class=""><li id="13b7" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated"><strong class="jz iu">名称:</strong>分机的名称。我将这个扩展命名为“无处不在的皮卡丘”</li><li id="8937" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">版本</strong>:这是扩展的版本。当你在Chrome网络商店发布扩展并需要更新时，你必须增加版本号，所以最好从低版本号开始。</li><li id="490c" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">描述:(可选)</strong>对您的扩展的描述</li><li id="cdbc" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu"> manifest_version </strong>:从Chrome 18开始，开发者被要求使用清单版本2，因为清单版本1现在已经被弃用。</li><li id="9172" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">图标:(可选)</strong>这里我们指定扩展的图标。这个图标会出现在你浏览器的工具栏，Chrome网上商店，以及任何其他需要显示它的地方。因此，包含不同大小的图标是有好处的。我使用了<a class="ae kv" href="https://www.freeiconspng.com/img/17360" rel="noopener ugc nofollow" target="_blank">免费图标PNG </a>中的一个图标，并使用<a class="ae kv" href="https://resizeimage.net/" rel="noopener ugc nofollow" target="_blank">https://resizeimage.net/</a>调整了图标的大小(你可以在<a class="ae kv" href="https://github.com/shahednasser/pikachu-everywhere" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到图片)。为这些图像指定的路径是相对于扩展的根的。</li></ol><p id="8143" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">有了这个，我们就拥有了任何Chrome扩展的核心。接下来，我们将向浏览器添加扩展。</p><p id="164b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">转到<!-- --> chrome://extensions <!-- -->。在那里，你可以在右上角切换开发者模式。一旦你这样做了，一个新的工具栏会出现，有三个按钮:“加载解包”、“打包扩展”和“更新”点击“Load unpacked ”,选择你的扩展目录。</p><p id="938d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦你这样做了，你会看到你的新的chrome扩展现在可以工作了。是的，它什么也没做，但是它在工作。</p><p id="1f73" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在Chrome扩展中，有两种类型的脚本可以使用。有后台脚本和内容脚本。后台脚本(显然)在后台运行。需要时加载，空闲时卸载。它们被用来监听你的Chrome扩展中的某些事件。</p><p id="ccfc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">内容脚本是在您打开网站并将其注入网站后加载的脚本。一旦你打开一个网站，它们就会像网站上的其他脚本一样开始运行。关闭网站后，该网站上的内容脚本也将停止运行。</p><p id="cd68" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于我们的扩展，我们希望用皮卡丘图像替换每个网站上的每个图像。为了做到这一点，我们需要指定一个内容脚本，它在每次打开网页时都有效。</p><p id="553a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们在<code class="fe lx ly lz ma b">assets/js/contentScript.js</code>中创建我们的内容脚本，并包含以下脚本来测试我们的扩展是否工作:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="8df6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要做的另一件事是告诉Chrome我们需要运行哪个脚本作为内容脚本。将以下几行添加到<strong class="jz iu"> manifest.json </strong></p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="ba38" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里我们使用<code class="fe lx ly lz ma b">content_scripts</code>作为键，值作为数组。数组中所有内容的含义如下:</p><ol class=""><li id="b7e8" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated"><strong class="jz iu">匹配</strong>:在这里你可以指定内容脚本应该在哪个URL上运行。在我们的例子中，我们希望我们的内容脚本在所有页面上运行。因此，我们使用占位符“&lt; all_urls &gt;”来指定。</li><li id="7a6f" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu"> all_frames </strong>:该键用于允许扩展指定JavaScript和CSS文件是应该注入到所有符合指定URL要求的框架中，还是只注入到一个标签中最上面的框架中。</li><li id="f16f" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated">js: 在这里，我们指定想要作为内容脚本运行的脚本。您可以指定多个脚本，因此值必须是一个数组</li></ol><p id="fa24" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们准备测试我们的内容脚本。</p><p id="e496" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但在此之前，我们需要迈出一小步。为了通知chrome我们更新了chrome扩展，我们需要返回到chrome://extensions，转到我们的扩展，然后按下reload图标。</p><p id="9342" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要测试我们的内容脚本是否正常工作，请转到您想要的任何网页，重新加载该页面(如果它之前已经打开)，然后右键单击并按Inspect。在DevTools中，打开控制台选项卡。您将在控制台中看到预期的内容:</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/4dc1d7541625578f97e338530b00ee7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOe3zZsKjSRt89ouayh71g.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">网页的控制台</figcaption></figure><p id="debf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我们可以验证我们的内容脚本正在工作。尝试重新加载页面，内容脚本将再次执行。尝试打开另一个网页，内容脚本将在该网页上独立执行。</p><p id="0243" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们知道如何在任何网页上注入一个脚本，通过这个脚本我们可以完成我们的工作。</p><p id="958d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在我们的例子中，我们需要用随机的皮卡丘图片替换任何网站中的所有图片。为此，我们将使用<a class="ae kv" href="https://some-random-api.ml/img/pikachu" rel="noopener ugc nofollow" target="_blank">这个API </a>，它将为我们提供一个包含皮卡丘图片链接的JSON对象。对该API的每个请求看起来都像这样:</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ccadee9665fd3c951025be8e17d85026.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*mwJ1wpqutThZDIKn3sIoCQ.png"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">API调用的结果</figcaption></figure><p id="3762" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这个API的帮助下，实现我们所需要的步骤如下:</p><ol class=""><li id="fac6" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated">获取网页上的所有图像元素。</li><li id="8619" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated">对API执行GET请求以检索一个随机的皮卡丘图片链接。</li><li id="530d" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated">用我们检索的链接替换图像元素的属性。</li></ol><p id="ee03" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这听起来很好也很容易，但是有一个复杂之处:Chrome扩展中的内容脚本不能执行跨源请求。</p><p id="2548" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那么我们如何从API中获取图片URL呢？我们将需要使用一个背景脚本。</p><p id="f89a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正如我们之前所指出的，后台脚本在Chrome的后台运行。它们不依赖于任何网页。</p><p id="fce9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Chrome扩展中的脚本是相互隔离的。然而，它们通过<a class="ae kv" href="https://developer.chrome.com/extensions/api_index" rel="noopener ugc nofollow" target="_blank"> Chrome API </a>共享一种通信方式。</p><p id="186e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们要做的是，我们将监听从<strong class="jz iu">内容</strong>脚本发送的<strong class="jz iu">背景</strong>脚本中的消息。每当网页打开时，我们的内容脚本就会运行，向后台脚本发送一条请求图像URL的消息。然后，后台脚本将执行对Pikachu API的异步调用，检索链接并将其发送回内容脚本。</p><p id="4598" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这一开始听起来可能很复杂，但实际上是以一种非常简单的方式完成的。</p><p id="5391" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们首先从创建后台脚本开始，看看它的运行情况。用以下内容创建<code class="fe lx ly lz ma b">assets/js/background.js</code>:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="4db4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，我们需要告诉Chrome，我们刚刚创建的文件将成为我们的后台脚本。为此，我们需要返回到我们的<strong class="jz iu"> manifest.json </strong>并添加以下内容:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="b7cc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以下是一切的含义:</p><ol class=""><li id="7ce2" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated"><strong class="jz iu">脚本:</strong>一个数组，保存我们将用作后台脚本的脚本的路径。在我们的情况下，它只是一个。</li><li id="30db" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu"> persistent </strong>:应该总是false，除非扩展使用Chrome的Web Request API来阻止或修改网络请求。</li></ol><p id="7565" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，Chrome将知道我们的后台脚本。它会在需要的时候加载，空闲的时候卸载。</p><p id="102d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了测试我们的后台脚本，我们需要像前面一样重新加载我们的扩展。</p><p id="4d6b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦你这样做了，你会看到一个新的链接出现在你的扩展的信息框中，文本为“检查视图背景页”:</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ml"><img src="../Images/3bae85a413467c161679f0f0884a953a.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*3Tk7iKH9BC_I8v_A3Oe9Ig.png"/></div></div></figure><p id="0536" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您单击它，将会打开一个新的DevTool，在控制台中您会看到:</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mm"><img src="../Images/8197fbee57942d4d485f8d52b28262b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27V4jQrNU0MtNAnM13Zx1Q.png"/></div></div></figure><p id="125c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在可以确认我们的后台脚本正在工作。即使您关闭任何其他网页或重新加载任何网页，后台脚本中也不会发生任何变化。</p><p id="5e57" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们再次回到我们的目标。我们现在需要在后台脚本中监听消息，并在收到新消息时从Pikachu API获取URL。</p><p id="8104" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了监听消息，我们将在Chrome的API中使用以下方法:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="c533" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要传递一个函数给<code class="fe lx ly lz ma b">addListener</code>。该功能将在收到任何新消息时执行。该函数有三个参数:</p><ol class=""><li id="1ee5" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated"><strong class="jz iu">消息:</strong>任意类型发送的消息。</li><li id="34a9" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">发送方:<a class="ae kv" href="https://developer.chrome.com/extensions/runtime#type-MessageSender" rel="noopener ugc nofollow" target="_blank">类型的</a></strong>消息发送方</li><li id="2cf8" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu"> senderResponse: </strong>有响应时调用(最多一次)的回调函数。该函数由发送者在发送消息时发送。</li></ol><p id="3f28" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是我们的<strong class="jz iu"> background.js </strong>文件现在的样子:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="5cd0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在我们的后台脚本已经准备好接收消息，但是没有消息被发送。</p><p id="4e6e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如前所述，每次页面打开时，我们的内容脚本将遍历网页中的图像元素，并向后台脚本发送消息以获取Pikachu图像链接。</p><p id="80bb" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了发送消息，我们需要使用Chrome API中的以下方法:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="7215" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正在发送的参数如下:</p><ol class=""><li id="065d" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated"><strong class="jz iu"> extensionId:(可选)</strong>我们要向其发送消息的扩展的Id。如果省略，消息将被发送到我们自己的分机。</li><li id="c1bc" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">消息:</strong>我们正在发送的任何类型的消息。</li><li id="5dcc" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">选项:可选</strong></li><li id="e271" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu"> responseCallback: </strong>接收消息后调用的函数。这是我们之前看到的方法中的<strong class="jz iu"> senderResponse </strong>参数。</li></ol><p id="7b1c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，我们将在内容脚本中使用该方法向后台脚本发送一条消息，以从API获取Pikachu URL。我们的内容脚本现在应该是这样的:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="bb1e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面是我们在上面的代码中所做的事情:</p><ol class=""><li id="c714" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated"><strong class="jz iu">第1行:</strong>获取网页上的所有图片元素。</li><li id="0bcd" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">第2–6行:</strong>遍历图像元素。对于每个元素，我们向后台脚本发送一条消息。正如你所看到的，我们省略了可选的<strong class="jz iu"> extensionId </strong>和<strong class="jz iu"> options </strong>参数。第一个参数是我们正在发送的<strong class="jz iu">消息</strong>，第二个参数是我们希望后台在获取图像链接后执行的回调函数。</li></ol><p id="4aae" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们正在将对象<strong class="jz iu"> {msg: 'image '，index: i} </strong>发送到我们的扩展。这个对象有两个属性。第一个是指定我们的信息是关于什么的。在我们的扩展中，这可能不是很有帮助，但是当您的扩展使用不同类型的消息时，区分每条消息的用途是个好主意。第二个属性是指定链接在<strong class="jz iu">图像</strong>数组中的图像索引。这背后的原因是替换图像的回调函数将被异步调用，所以在它被执行时，<strong class="jz iu"> i </strong>可能指向另一个索引。</p><p id="3643" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">回调函数接收一个具有两个属性的对象。<strong class="jz iu">数据</strong>将是从API调用接收的数据，<strong class="jz iu">索引</strong>将是数组<strong class="jz iu">图像</strong>中图像的索引。一旦被调用，它会将<strong class="jz iu">图像</strong>中<strong class="jz iu">索引</strong>处的图像设置为<strong class="jz iu">数据</strong>的链接属性。</p><p id="2513" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，每当内容脚本发送消息时，我们需要从后台脚本中的API获取数据。我们可以这样做:</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="bd3a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">事情是这样的:</p><ol class=""><li id="f206" class="lj lk it jz b ka kb ke kf ki ll km lm kq ln ku lo lp lq lr bi translated"><strong class="jz iu">线路1: </strong>收听我们分机里的留言</li><li id="15cc" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">第2行:</strong>检查消息是否是获取图片URL。这将使用我们在<strong class="jz iu">内容脚本</strong>中发送消息时传递的<strong class="jz iu">消息</strong>属性</li><li id="ffda" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">第3–8行:</strong>如果<strong class="jz iu">第2行</strong>中的条件为真，则从API中获取数据。在第一个<code class="fe lx ly lz ma b">Promise</code>中，我们获取响应文本，然后在第二个<code class="fe lx ly lz ma b">Promise</code>中，我们解析JSON对象并调用<strong class="jz iu"> senderResponse </strong>，这是消息发送者指定的回调函数。我们用它传递一个带有参数<strong class="jz iu">数据</strong>(通过API调用接收的数据)和<strong class="jz iu">索引</strong>(发送者发送的图像的索引)的对象。</li><li id="bd25" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">第9行:</strong>对可能出现的任何错误的简单处理。</li><li id="cf32" class="lj lk it jz b ka ls ke lt ki lu km lv kq lw ku lo lp lq lr bi translated"><strong class="jz iu">第10行</strong>:如果发送方指定了一个回调函数，它必须在监听方停止执行之前被调用，否则将抛出一个错误。在我们的例子中，我们必须等到收到来自API的异步响应，所以我们返回true来指定它将被异步调用。</li></ol><p id="70aa" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好了，我们的剧本准备好了。只剩下一件事——我们需要在我们的<strong class="jz iu"> manifest.json: </strong>中给予API许可</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="e7b3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你现在需要做的就是在<!-- --> chrome://extensions <!-- -->中重新加载扩展，然后打开任意页面，到处都能看到皮卡丘！</p><p id="a145" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当然，这个扩展不会取代背景图片。这可以通过遍历元素，检查它们是否有背景图像，并以同样的方式替换它们来实现。</p></div></div>    
</body>
</html>