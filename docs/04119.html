<html>
<head>
<title>How to make a Queue — Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作队列—类型脚本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-make-a-queue-typescript-853fa1e03302?source=collection_archive---------2-----------------------#2020-06-10">https://levelup.gitconnected.com/how-to-make-a-queue-typescript-853fa1e03302?source=collection_archive---------2-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="34a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">还有，这对什么有好处</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7021821cac11051bf7129fbc661d8aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejbVapqJkxQd-8KTZDSYtA.jpeg"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><p id="871a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">队列是一种低级数据结构。它是如此普遍，以至于我们每天都可以在周围的世界中看到它。因此，如果你想用计算机建模，这是最重要的结构之一。</p><p id="c684" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是编码面试的一个常见主题，如果你知道要寻找什么，它将帮助你在日常基础上构建好的程序。</p><h1 id="654f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">它是如何工作的？</h1><p id="c103" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">简而言之，队列是<strong class="ld iu">任何</strong>结构或现象，它将对象按照它们进入该结构的相关顺序进行排序。否则称为<strong class="ld iu">先进先出。</strong></p><p id="99f8" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">最常见的例子可能是你在车管所看到的。你走进设施，你拿一张票，然后你在柜台被看到，按照你到达设施的顺序。</p><p id="f4a3" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果你在一个队列中，在你前面的每个人都被看到之前，你不会离开队列。</p><p id="0876" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当你到达队列时，你将从后面进入队列，当人们离开队列时，你将更靠近队列的前面。</p><p id="42ca" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当人们在你之后进入队列时，他们将按顺序集合，在你后面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/a27e6a3020109320bb7cfba84a27a474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUCFBzRC0s-UmKq_ongLQA.jpeg"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><p id="7251" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">但是，你们不是来这里学习车管所如何工作的，而是来这里学习如何用电脑模拟。</p><p id="2a04" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">队列的应用比这篇博客所能列举的要多，但是举几个例子来说，票务网站每天都使用队列来确定他们什么时候卖光了票。</p><p id="0ab0" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">任何电子商务网站都可以使用队列来确定产品何时售罄。</p><p id="7fea" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">像A*这样的路径算法使用队列按照值的顺序来排序执行。</p><p id="3b5a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">许多优先排序系统使用队列来确定什么时候需要处理事情。(任务管理)</p><p id="d198" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">广度优先搜索使用队列来确保搜索一次执行一个深度。</p><p id="611e" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这样的例子不胜枚举。</p><h1 id="78fd" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">我们如何制造一个？</h1><p id="544d" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">有很多不同的方法。如果你很着急，你可以只做一个数组，并且总是分别使用unshift方法和pop方法。它的功能类似于队列，并且满足创建使用队列的系统所需的逻辑。</p><p id="fe8b" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">但是，数组对于这个应用程序来说并不理想，也不应该过于依赖，因为数组是严格有序的列表。它们被设计成对列表中的每一项进行数字查找。为了保持这种行为，每次在列表中添加或删除项目时，他们都需要移动整个列表。</p><p id="450c" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这严重破坏了你的时间复杂度。如果你有一个100万项长的队列，从列表中插入或弹出一些项可能需要20秒，但是如果你用引用逻辑(或者如果你选择的语言有一个内置的队列)来创建队列，删除和插入应该只需要O(3)操作或少于<strong class="ld iu">。</strong></p><p id="da76" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在一天结束的时候，你应该用参考逻辑或者其他一些时间有效的等价物来创建你的队列，除非你有一些特殊的理由不这样做。</p><h1 id="d3ca" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">我们是这样做的</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c6c8" class="na ly it mw b gy nb nc l nd ne">class qNode {</span><span id="cea0" class="na ly it mw b gy nf nc l nd ne">constructor(</span><span id="aaa5" class="na ly it mw b gy nf nc l nd ne">public value:number,</span><span id="d6f8" class="na ly it mw b gy nf nc l nd ne">public next?:qNode</span><span id="56a3" class="na ly it mw b gy nf nc l nd ne">){}</span><span id="7f74" class="na ly it mw b gy nf nc l nd ne">}</span><span id="7576" class="na ly it mw b gy nf nc l nd ne">class queue{</span><span id="83cf" class="na ly it mw b gy nf nc l nd ne">constructor(</span><span id="7dd8" class="na ly it mw b gy nf nc l nd ne">public head?:qNode,</span><span id="5af7" class="na ly it mw b gy nf nc l nd ne">public tail?:qNode</span><span id="bed9" class="na ly it mw b gy nf nc l nd ne">){}</span><span id="b682" class="na ly it mw b gy nf nc l nd ne">public pop = ():number|void =&gt;{</span><span id="5037" class="na ly it mw b gy nf nc l nd ne">if(this.head){</span><span id="4b06" class="na ly it mw b gy nf nc l nd ne">let tempOut:qNode|undefined = this.tail</span><span id="eca6" class="na ly it mw b gy nf nc l nd ne">this.tail = this.tail?.next</span><span id="c675" class="na ly it mw b gy nf nc l nd ne">return tempOut?.value</span><span id="adda" class="na ly it mw b gy nf nc l nd ne">} else {</span><span id="b9d3" class="na ly it mw b gy nf nc l nd ne">console.log("queue is empty")</span><span id="d71f" class="na ly it mw b gy nf nc l nd ne">}</span><span id="5ec0" class="na ly it mw b gy nf nc l nd ne">}</span><span id="dde1" class="na ly it mw b gy nf nc l nd ne">public insert = (node:qNode):void =&gt;{</span><span id="6600" class="na ly it mw b gy nf nc l nd ne">if(this.head){</span><span id="ff6d" class="na ly it mw b gy nf nc l nd ne">this.head.next = node</span><span id="67cd" class="na ly it mw b gy nf nc l nd ne">this.head = node</span><span id="2b81" class="na ly it mw b gy nf nc l nd ne">} else {</span><span id="24c5" class="na ly it mw b gy nf nc l nd ne">this.head = node</span><span id="4d82" class="na ly it mw b gy nf nc l nd ne">this.tail = node</span><span id="ddff" class="na ly it mw b gy nf nc l nd ne">}</span><span id="d44b" class="na ly it mw b gy nf nc l nd ne">}</span><span id="91a9" class="na ly it mw b gy nf nc l nd ne">}</span></pre><p id="d6cb" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在编程中，我们经常需要对比字符串或数字稍微复杂一点的东西建模。</p><p id="6915" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">大多数时候，我们用一个对象或对象的组合来建模这些更复杂的东西。</p><p id="1fa9" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这就是我在这里所做的。我将对象分为两种类型，称为qNode和queue。</p><p id="21ae" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">qNodes只是引用另一个对象和一个值的对象。</p><p id="107d" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">队列是对象的另一种分类，这些对象有一个头和一个尾，还有两个处理弹出和插入功能的类函数。</p><p id="f23c" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一旦我实例化了一个队列并将7个节点放入其中，它就变成了一组对象，结构如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ac7e11a9464d72f5f49fb0b38c6a531c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5BR2TlnEDpUaw-FIWPuaWQ.jpeg"/></div></div></figure><p id="2baf" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在我开始之前，我想描述一下我的队列是如何建立起来的。</p><p id="7bde" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">秘密在于我的pop和insert函数。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="99c9" class="na ly it mw b gy nb nc l nd ne">public pop = ():number|void =&gt;{</span><span id="9d4a" class="na ly it mw b gy nf nc l nd ne">if(this.head){</span><span id="cc17" class="na ly it mw b gy nf nc l nd ne">let tempOut:qNode|undefined = this.tail</span><span id="3dda" class="na ly it mw b gy nf nc l nd ne">this.tail = this.tail?.next</span><span id="19f6" class="na ly it mw b gy nf nc l nd ne">return tempOut?.value</span><span id="e2be" class="na ly it mw b gy nf nc l nd ne">} else {</span><span id="1dcc" class="na ly it mw b gy nf nc l nd ne">console.log("queue is empty")</span><span id="2560" class="na ly it mw b gy nf nc l nd ne">}</span><span id="3d90" class="na ly it mw b gy nf nc l nd ne">}</span></pre><p id="03cb" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我的pop first检查头部是否有效。如果头有效，则队列不为空，阻塞可以继续进行。</p><p id="fdfd" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">然后，它将尾部分配给临时变量，将尾部在队列中下移，并返回临时变量。</p><p id="060a" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这将从队列内部的引用中删除temp，新的尾部现在被分配给该行前面的节点。这是可视化操作的另一种方式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/c5a0c379249046f726b2cfb34a7de0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEux5kTUdk29Ewfy2i6NHg.jpeg"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="dd37" class="lx ly it bd lz ma ni mc md me nj mg mh jz nk ka mj kc nl kd ml kf nm kg mn mo bi translated">在我们的插页上</h1><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="28ba" class="na ly it mw b gy nb nc l nd ne">public insert = (node:qNode):void =&gt;{</span><span id="aa73" class="na ly it mw b gy nf nc l nd ne">if(this.head){</span><span id="7b56" class="na ly it mw b gy nf nc l nd ne">this.head.next = node</span><span id="7c59" class="na ly it mw b gy nf nc l nd ne">this.head = node</span><span id="451a" class="na ly it mw b gy nf nc l nd ne">} else {</span><span id="4a68" class="na ly it mw b gy nf nc l nd ne">this.head = node</span><span id="ac72" class="na ly it mw b gy nf nc l nd ne">this.tail = node</span><span id="13af" class="na ly it mw b gy nf nc l nd ne">}</span><span id="c27f" class="na ly it mw b gy nf nc l nd ne">}</span></pre><p id="5589" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">插页与我们的pop相似，只是我们看的是头部。</p><p id="f1e5" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">它首先验证头部的存在。然后，它让旧的头部查看插入的节点，并将头部引用设置为新的节点。</p><p id="14db" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">想象成这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/0501065dd3a07cbc24bc5c8ec9b366cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1bIqRGdlklcSAGsq0H_9jg.jpeg"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="3941" class="lx ly it bd lz ma ni mc md me nj mg mh jz nk ka mj kc nl kd ml kf nm kg mn mo bi translated">就这些了。就是这么简单，伙计们</h1><p id="a6d2" class="pw-post-body-paragraph lb lc it ld b le mp ju lg lh mq jx lj lk mr lm ln lo ms lq lr ls mt lu lv lw im bi translated">现在我们有了。我们有一个在固定时间弹出和插入的工作队列。我们可以将它扩展到数百万个条目，它可以同样高效地弹出和插入。</p><p id="cc8b" class="pw-post-body-paragraph lb lc it ld b le lf ju lg lh li jx lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">而且，我们都用类型定义在typescript中做过。我鼓励你亲自尝试一下，因为这肯定会在一些面试中出现，并且可以用来解决无数的工程问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/aef935eadc204f727beb7f5c4284a4af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NNq_PivvrjWJxf_e9DoheQ.jpeg"/></div></div></figure></div></div>    
</body>
</html>