<html>
<head>
<title>TypeScript Types Explained — A Mental Model to Help You Think in Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript类型解释—帮助您用类型思考的心智模型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-types-explained-a-mental-model-to-help-you-think-in-types-1126dd0b3625?source=collection_archive---------15-----------------------#2020-08-03">https://levelup.gitconnected.com/typescript-types-explained-a-mental-model-to-help-you-think-in-types-1126dd0b3625?source=collection_archive---------15-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="98c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章最初发表在<a class="ae ko" href="https://leandrotk.github.io/tk/2020/07/a-mental-model-to-think-in-typescript/index.html" rel="noopener ugc nofollow" target="_blank"> TK的博客</a>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/78240efdc1f3b81fbd15db2c7455342e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0DtU8xf6oTDxv8P8"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@yukato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yu Kato </a></figcaption></figure><p id="72e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一天，我看到拉里·马扎的一条推文</p><blockquote class="lf lg lh"><p id="9f61" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated"><em class="it">“我能提个建议吗？当你在生活中只使用过JS，突然不得不学习TypeScript时，类型是很难理解的</em></p></blockquote><p id="c7c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一个最先学习Python、Ruby、Javascript、Clojure的软件工程师，当我尝试C++的时候，简直就是一部恐怖电影。我做不了多少事，所以适得其反，令人沮丧。也许是因为我什么都做错了，我没有正确理解类型。</p><p id="19ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是即使我有这么多问题，我也能实现一堆算法和数据结构。</p><p id="b97b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我在日常工作中使用越来越多的打字稿，我的副业项目也越来越多，我觉得我更有准备面对打字。实际上，不是对抗，而是让他们为我所用。</p><p id="7ecb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章是我试图帮助开发人员更多地考虑类型并理解这种心智模型。</p><h1 id="f00b" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">JavaScript类型</h1><p id="6098" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">如果你在这里，你可能听说过Typescript是Javascript的超集。如果没有，很好，你今天刚刚学到了一些新东西。耶！</p><p id="7ad5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Typescript是一个超集，因为从语法上讲，任何Javascript代码在Typescript中都是有效的。根据Typescript编译器的配置，它可能会也可能不会编译。但是就语法而言，它工作得很好。这就是为什么您可以通过用<code class="fe mp mq mr ms b">.ts</code>替换<code class="fe mp mq mr ms b">.js</code>扩展名来逐步将Javascript迁移到Typescript。一切都将没有类型声明(T2类型)，但那是另一个故事。</p><p id="2c93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，如果您用Javascript或任何其他编程语言编写代码，您可能会考虑类型:</p><ul class=""><li id="aba0" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">嗯，这是一个整数列表，所以我只需要过滤偶数并返回一个新的列表</li><li id="da41" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">"这是一个对象，但我只需要从属性X中获取这个字符串值. "</li><li id="30d5" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">该函数接收两个参数。A和B都是整数，我想对它们求和"</li></ul><p id="2d3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，你明白了。我们用类型来思考。但它们只是在我们的脑海中。我们不断地考虑它们，因为我们需要知道如何处理、解析或修改数据。我们需要知道在这个对象类型中允许使用哪些方法。</p><p id="7b98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举个更具体的例子，假设你想把所有产品的价格加起来。产品对象看起来像这样:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="0466" class="nl ln it ms b gy nm nn l no np">const product = {<br/>  title: 'Some product',<br/>  price: 100.00,<br/>};</span></pre><p id="1a8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是现在有了产品清单:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="e78d" class="nl ln it ms b gy nm nn l no np">const products = [<br/>  {<br/>    title: 'Product 1',<br/>    price: 100.00,<br/>  },<br/>  {<br/>    title: 'Product 2',<br/>    price: 25.00,<br/>  },<br/>  {<br/>    title: 'Product 3',<br/>    price: 300.00,<br/>  }<br/>];</span></pre><p id="f817" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧！现在我们需要一个函数来计算所有产品的价格。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="6ce0" class="nl ln it ms b gy nm nn l no np">function sumAllPrices(products) {<br/>  return products.reduce((sum, product) =&gt; sum + product.price, 0);<br/>};</span><span id="b85c" class="nl ln it ms b gy nq nn l no np">sumAllPrices(products); // 425</span></pre><p id="024f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只接收产品作为参数，降低所有产品价格。Javascript工作得很好。但是在构建这个函数的时候，你开始考虑数据以及如何正确地处理它。</p><p id="b1df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一部分:产品作为论据。这里你只需要想:“嗯，我们正在接收一些对象的列表”。是的，在我们的头脑中，产品是一个列表。这就是为什么我们可以想到使用<code class="fe mp mq mr ms b">reduce</code>方法。它是来自<code class="fe mp mq mr ms b">Array</code>原型的一个方法。</p><p id="4623" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们可以详细地思考这个物体。我们知道产品对象有一个<code class="fe mp mq mr ms b">price</code>属性。这个属性是一个数字。这就是为什么我们可以用累加器做<code class="fe mp mq mr ms b">product.price</code>和求和。</p><p id="baab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">概述:</p><ul class=""><li id="220e" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated"><code class="fe mp mq mr ms b">products</code>是物体的列表。</li><li id="8215" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">作为一个列表，我们可以使用<code class="fe mp mq mr ms b">reduce</code>方法，作为<code class="fe mp mq mr ms b">Array</code>原型的一个成员。</li><li id="0e55" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe mp mq mr ms b">produce</code>对象有一些属性。其中一个是<code class="fe mp mq mr ms b">price</code>，是一个数字。</li><li id="9158" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">作为一个数字属性，我们可以用它和reduce累加器求和。</li><li id="cdb8" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">我们想返回一个数字，所有产品价格的总和。</li></ul><p id="fbca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们总是在考虑数据类型，我们只需要添加类型注释使其更加明确，并向编译器寻求帮助。我们的记忆是有限的，编译器是来帮助我们人类的。</p><p id="33b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型系统不仅会使我们的数据更加一致，而且它还可以为数据类型提供自动完成功能。它知道类型，所以它可以显示数据的成员。我们稍后将研究这个想法。在这里，我只是想展示我们在头脑中思考类型。</p><h1 id="5fdd" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">简单类型和简单用途</h1><p id="860b" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">所以我们准备使用一些强类型编程语言，比如Typescript。我们只需要显式地将类型注释添加到数据结构中。很简单。但有时并不那么容易(通常当你来自动态类型语言时并不容易。你觉得没有生产力。感觉是和类型的战斗。这里的想法是让这个学习曲线变得更加平滑和有趣)。</p><p id="d25f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们会看到很多如何在Typescript中使用类型的例子。我们从简单和愚蠢的例子开始，在设计思维模型以进行类型思考时，逐步使其变得更加复杂。</p><p id="47fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和Javascript一样，Typescript也有基本的数据类型，如<code class="fe mp mq mr ms b">number</code>、<code class="fe mp mq mr ms b">string</code>、<code class="fe mp mq mr ms b">boolean</code>、<code class="fe mp mq mr ms b">null</code>等。在<a class="ae ko" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank">类型脚本文档</a>中可以找到所有的基本数据类型。</p><p id="63c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些数据单元，我们可以使我们的程序更有用。为了更实际，我们举一个简单的例子。一个<code class="fe mp mq mr ms b">sum</code>功能。</p><p id="af6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它在Javascript中是如何工作的？</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="2e65" class="nl ln it ms b gy nm nn l no np">function sum(a, b) {<br/>  return a + b;<br/>}</span></pre><p id="7eaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切都好吗？好的。</p><p id="4d5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们使用它:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="8192" class="nl ln it ms b gy nm nn l no np">sum(1, 2); // 3<br/>sum(2, 2); // 4<br/>sum(0, 'string'); // '0string'   WTF!</span></pre><p id="1a6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前两个调用是我们期望在我们的系统中发生的。但是Javascript非常灵活，它允许我们为这个函数提供任何值。最后一个电话很奇怪。我们可以用字符串调用，但是会返回意外的结果。它在开发中不会中断，但在运行时会导致奇怪的行为。</p><p id="46dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想要什么？我们想给函数添加一些约束。它只能接收数字。这样，我们就减少了出现意外行为的可能性。而且函数返回类型也是数字。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="e46c" class="nl ln it ms b gy nm nn l no np">function sum(a: number, b: number): number {<br/>  return a + b;<br/>}</span></pre><p id="3b11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！这很简单。让我们再次打电话。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="2129" class="nl ln it ms b gy nm nn l no np">sum(1, 2); // 3<br/>sum(2, 2); // 4<br/>sum(0, 'string'); // Argument of type '"string"' is not assignable to parameter of type 'number'.</span></pre><p id="0262" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们对函数进行类型注释时，我们向编译器提供信息以查看是否一切都正确。它将遵循我们添加到函数中的约束。</p><p id="9e52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以前两个调用和Javascript中的一样。它将返回正确的计算结果。但是最后一个我们在编译时有一个错误。这很重要。错误现在发生在编译时，防止我们将不正确的代码发布到产品中。它说<code class="fe mp mq mr ms b">string</code>类型不是<code class="fe mp mq mr ms b">number</code>类型的值集合的一部分。</p><p id="859b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于基本类型，我们只需要添加一个冒号，后跟类型定义。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="ecf6" class="nl ln it ms b gy nm nn l no np">const isTypescript: boolean = true;<br/>const age: number = 24;<br/>const username: string = 'tk';</span></pre><p id="53f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们增加挑战。还记得我们用Javascript写的产品对象代码吗？让我们再次实现它，但是现在使用类型脚本思维。</p><p id="8064" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住我们正在谈论的内容:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="1527" class="nl ln it ms b gy nm nn l no np">const product = {<br/>  title: 'Some product',<br/>  price: 100.00,<br/>};</span></pre><p id="fa2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是产品价值。它有一个作为<code class="fe mp mq mr ms b">string</code>的<code class="fe mp mq mr ms b">title</code>和作为<code class="fe mp mq mr ms b">number</code>的<code class="fe mp mq mr ms b">price</code>。目前，这是我们需要知道的。</p><p id="baef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对象类型类似于:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="2bbb" class="nl ln it ms b gy nm nn l no np">{ title: string, price: number }</span></pre><p id="12a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们用这种类型来注释我们的函数:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="7fd9" class="nl ln it ms b gy nm nn l no np">const product: { title: string, price: number } = {<br/>  title: 'Some product',<br/>  price: 100.00,<br/>};</span></pre><p id="f29c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这种类型，编译器将知道如何处理不一致的数据:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="0678" class="nl ln it ms b gy nm nn l no np">const wrongProduct: { title: string, price: number } = {<br/>  title: 100.00, // Type 'number' is not assignable to type 'string'.<br/>  price: 'Some product', // Type 'string' is not assignable to type 'number'.<br/>};</span></pre><p id="7f0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里它分解成两种不同的属性:</p><ul class=""><li id="00cf" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated"><code class="fe mp mq mr ms b">title</code>是一个<code class="fe mp mq mr ms b">string</code>并且不应该接收一个<code class="fe mp mq mr ms b">number</code>。</li><li id="373d" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe mp mq mr ms b">price</code>是一个<code class="fe mp mq mr ms b">number</code>并且不应该接收一个<code class="fe mp mq mr ms b">string</code>。</li></ul><p id="e2eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译器帮助我们捕捉这样的类型错误。</p><p id="ea42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过使用一个叫做<code class="fe mp mq mr ms b">Type Aliases</code>的概念来改进这种类型注释。这是为特定类型创建新名称的一种方式。</p><p id="e34a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，产品类型可以是:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="600c" class="nl ln it ms b gy nm nn l no np">type Product = {<br/>  title: string;<br/>  price: number;<br/>};</span><span id="f58c" class="nl ln it ms b gy nq nn l no np">const product: Product = {<br/>  title: 'Some product',<br/>  price: 100.00,<br/>};</span></pre><p id="4cc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最好将类型可视化，添加语义，也许可以在我们的系统中重用。</p><p id="8e83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了这个产品类型，我们可以用它来键入产品列表。语法是这样的:<code class="fe mp mq mr ms b">MyType[]</code>。在我们这里，<code class="fe mp mq mr ms b">Product[]</code>。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="b57e" class="nl ln it ms b gy nm nn l no np">const products: Product[] = [<br/>  {<br/>    title: 'Product 1',<br/>    price: 100.00,<br/>  },<br/>  {<br/>    title: 'Product 2',<br/>    price: 25.00,<br/>  },<br/>  {<br/>    title: 'Product 3',<br/>    price: 300.00,<br/>  }<br/>];</span></pre><p id="c487" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在功能<code class="fe mp mq mr ms b">sumAllPrices</code>。它将接收产品并返回一个数字，即所有产品价格的总和。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="f22a" class="nl ln it ms b gy nm nn l no np">function sumAllPrices(products: Product[]): number {<br/>  return products.reduce((sum, product) =&gt; sum + product.price, 0);<br/>};</span></pre><p id="c115" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很有意思。当我们输入产品时，当我们写下<code class="fe mp mq mr ms b">product.</code>，它将显示我们可以使用的可能属性。在产品类型的情况下，将显示属性<code class="fe mp mq mr ms b">price</code>和<code class="fe mp mq mr ms b">title</code>。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="9ea9" class="nl ln it ms b gy nm nn l no np">sumAllPrices(products); // 425<br/>sumAllPrices([]); // 0<br/>sumAllPrices([{ title: 'Test', willFail: true }]); // Type '{ title: string; willFail: true; }' is not assignable to type 'Product'.</span></pre><p id="a5ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传递<code class="fe mp mq mr ms b">products</code>将产生值<code class="fe mp mq mr ms b">425</code>。空列表将产生值<code class="fe mp mq mr ms b">0</code>。如果我们传递一个不同结构的对象——Typescript有一个结构类型系统，我们稍后将深入探讨这个主题——编译器将抛出一个类型错误，告诉我们该结构不是<code class="fe mp mq mr ms b">Product</code>类型的一部分。</p><h1 id="c493" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结构分型</h1><p id="d519" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">结构类型化是一种类型兼容性。这是一种基于结构(特性、成员、属性)来理解类型之间兼容性的方法。一些语言具有基于类型名称的类型兼容性，这被称为名义类型。</p><p id="267b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如在Java中，即使不同的类型有相同的结构，也会抛出编译错误，因为我们是用不同的类型来实例化和定义一个新的实例。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="0cb7" class="nl ln it ms b gy nm nn l no np">class Person {<br/>  String name;<br/>}<br/> <br/>class Client {<br/>  String name;<br/>}<br/> <br/>Client c = new Person();  // compiler throws an error<br/>Client c = new Client();  // OK!</span></pre><p id="260c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在名义类型系统中，类型的相关部分是名称，而不是结构。</p><p id="6231" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，Typescript验证结构兼容性以允许或不允许特定数据。它的类型系统基于结构类型。</p><p id="8312" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Java中崩溃的同一代码实现在Typescript中也能工作。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="a31a" class="nl ln it ms b gy nm nn l no np">class Person {<br/>  name: string;<br/>}</span><span id="0da9" class="nl ln it ms b gy nq nn l no np">class Client {<br/>  name: string;<br/>}</span><span id="2a10" class="nl ln it ms b gy nq nn l no np">const c1: Client = new Person(); // OK!<br/>const c2: Client = new Client(); // OK!</span></pre><p id="7fd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想使用<code class="fe mp mq mr ms b">Client</code>类型，它有属性<code class="fe mp mq mr ms b">name</code>，指向<code class="fe mp mq mr ms b">Person</code>类型。它还具有属性类型。因此Typescript将理解这两种类型具有相同的形状。</p><p id="5f12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但它不仅仅是关于类的，它对任何其他“对象”都有效。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="b55e" class="nl ln it ms b gy nm nn l no np">const c3: Client = {<br/>  name: 'TK'<br/>};</span></pre><p id="8516" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码也可以编译，因为我们有相同的结构。typescript类型系统不关心它是一个类，还是一个对象文字，如果它有相同的成员，它将是灵活的和可编译的。</p><p id="3e87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是现在我们将添加第三种类型:<code class="fe mp mq mr ms b">Customer</code>。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="ae83" class="nl ln it ms b gy nm nn l no np">class Customer {<br/>  name: string;<br/>  age: number;<br/>};</span></pre><p id="60a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它不仅有<code class="fe mp mq mr ms b">name</code>属性，还有<code class="fe mp mq mr ms b">age</code>。如果我们在类型为<code class="fe mp mq mr ms b">Customer</code>的常量中实例化一个<code class="fe mp mq mr ms b">Client</code>实例会发生什么？</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="9d7e" class="nl ln it ms b gy nm nn l no np">const c4: Customer = new Client();</span></pre><p id="78c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译器不会接受这一点。我们想用有T5和T6的T4。但是我们正在实例化只有<code class="fe mp mq mr ms b">name</code>属性的<code class="fe mp mq mr ms b">Client</code>。所以它没有相同的形状。这将导致一个错误:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="54fd" class="nl ln it ms b gy nm nn l no np">Property 'age' is missing in type 'Client' but required in type 'Customer'.</span></pre><p id="5dab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">反过来也可以，因为我们需要<code class="fe mp mq mr ms b">Client</code>，而<code class="fe mp mq mr ms b">Customer</code>拥有来自<code class="fe mp mq mr ms b">Client</code>的所有属性(<code class="fe mp mq mr ms b">name</code>)。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="8c99" class="nl ln it ms b gy nm nn l no np">const c5: Client = new Customer();</span></pre><p id="c986" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">工作正常！</p><p id="6296" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以继续列举、对象文字和任何其他类型，但是这里的思想是理解类型的结构是相关的部分。</p><h1 id="348f" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">运行时和编译时</h1><p id="8528" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">在编程语言理论中，这是一个复杂得多的话题，但是我想举一些不同的运行时和编译时的例子。</p><p id="83fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，运行时就是一个程序的执行时间。想象一下，您的后端从前端表单页面接收数据，处理这些数据，并保存它。或者当您的前端从服务器请求数据以呈现口袋妖怪产品列表时。</p><p id="6bd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译时基本上是编译器在源代码中执行操作以满足编程语言要求的时候。例如，它可以包括作为操作的类型检查。例如，Typescript中的编译时错误与我们之前编写的代码密切相关:</p><ul class=""><li id="a4c0" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">当类型缺少属性:<code class="fe mp mq mr ms b">Property 'age' is missing in type 'Client' but required in type 'Customer'.</code></li><li id="aea2" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">类型不匹配时:<code class="fe mp mq mr ms b">Type '{ title: string; willFail: true; }' is not assignable to type 'Product'.</code></li></ul><p id="89b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一些例子来更好地理解。</p><p id="f56e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想写一个函数来获取被传递的编程语言的一部分的索引。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="2b13" class="nl ln it ms b gy nm nn l no np">function getIndexOf(language, part) {<br/>  return language.indexOf(part);<br/>}</span></pre><p id="3f9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它接收我们将寻找以获取索引的<code class="fe mp mq mr ms b">language</code>和<code class="fe mp mq mr ms b">part</code>。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="488e" class="nl ln it ms b gy nm nn l no np">getIndexOf('Typescript', 'script'); // 4<br/>getIndexOf(42, 'script'); // Uncaught TypeError: language.indexOf is not a function at getIndexOf</span></pre><p id="de3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当传递一个字符串时，它工作得很好。但是传递一个数字，我们得到一个运行时错误<code class="fe mp mq mr ms b">Uncaught TypeError</code>。因为一个数字没有<code class="fe mp mq mr ms b">indexOf</code>功能，所以我们并不能真正的使用它。</p><p id="0cd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们给编译器类型信息，在编译时，它会在运行代码前抛出一个错误。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="4867" class="nl ln it ms b gy nm nn l no np">function getIndexOf(language: string, part: string): number {<br/>  return language.indexOf(part);<br/>}</span></pre><p id="1969" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的程序知道它需要接收两个字符串并返回一个数字。当我们在运行前遇到类型错误时，编译器可以使用这些信息来抛出错误。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="0bd4" class="nl ln it ms b gy nm nn l no np">getIndexOf('Typescript', 'script'); // 4<br/>getIndexOf(42, 'script'); // Argument of type '42' is not assignable to parameter of type 'string'.</span></pre><p id="3a4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许，对于小项目(或像我们这样的小功能)，我们真的看不到太多的好处。在这种情况下，我们知道我们需要传递一个字符串，所以我们不会向函数传递一个数字。但是当代码库增长或者你有很多人添加代码和更多的复杂性时，我很清楚类型系统可以帮助我们在将代码交付到产品之前在编译时发现错误。</p><p id="0184" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">起初，我们需要所有的学习曲线来理解类型和所有的心理模型，但是过一会儿，你将更习惯于类型注释，并最终与编译器成为朋友。这将是一个<em class="li">助手</em>，而不是一个<em class="li">叫喊者</em>。</p><p id="fafc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们学习编译时和运行时的基本区别时，我认为区分类型和值是很重要的。</p><p id="2d06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将在这里展示的所有示例都可以被复制并在<a class="ae ko" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank"> Typescript Playground </a>中运行，以理解编译器和编译过程的结果(也称为<em class="li">“Javascript”</em>)。</p><p id="b00a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Typescript中，我们有两个不同的领域:值空间和类型空间。类型空间是定义和使用类型的地方，使编译器能够完成所有伟大的工作。值空间是程序中的值，比如变量，常量，函数，值，以及运行时的东西。</p><p id="b10f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理解这个概念是有好处的，因为在Typescript中，我们不能在运行时使用类型检查。它在类型检查和编译过程之间有一个非常清晰的分离。</p><p id="eab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Typescript有一个对源代码类型进行类型检查的过程，检查所有内容是否正确和一致。然后它可以编译成Javascript。因为这两个部分是分开的，所以我们不能在运行时使用类型检查。仅在“编译时”。如果你试图使用一个类型作为值，它会抛出一个错误:<code class="fe mp mq mr ms b">only refers to a type, but is being used as a value here</code>。</p><p id="c40e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看这个想法的例子。</p><p id="79cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想写一个名为<code class="fe mp mq mr ms b">purchase</code>的函数，在这里我们接收一个支付方法，并基于这个方法，我们想做一些动作。我们有信用卡和借记卡。让我们在这里定义它们:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="28bb" class="nl ln it ms b gy nm nn l no np">type CreditCard = {<br/>  number: number;<br/>  cardholder: string;<br/>  expirationDate: Date;<br/>  secutiryCode: number;<br/>};</span><span id="fcbc" class="nl ln it ms b gy nq nn l no np">type DebitCard = {<br/>  number: number;<br/>  cardholder: string;<br/>  expirationDate: Date;<br/>  secutiryCode: number;<br/>};</span><span id="a10f" class="nl ln it ms b gy nq nn l no np">type PaymentMethod = CreditCard | DebitCard;</span></pre><p id="3ecf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些类型在<em class="li">类型空间</em>中，所以它只在编译时有效。在对这个函数进行类型检查之后，编译器会移除所有的类型。</p><p id="6e5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您在Typescript Playground中添加这些类型，输出将只是一个严格的定义<code class="fe mp mq mr ms b">"use strict";</code>。</p><p id="58a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的想法是真正理解类型存在于<em class="li">类型空间</em>中，并且在运行时不可用。所以在我们的函数中，不可能这样做:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="13dc" class="nl ln it ms b gy nm nn l no np">const purchase = (paymentMethod: PaymentMethod) =&gt; {<br/>  if (paymentMethod instanceof CreditCard) {<br/>    // purchase with credit card<br/>  } else {<br/>    // purchase with debit card<br/>  }<br/>}</span></pre><p id="35bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">In编译器抛出错误:<code class="fe mp mq mr ms b">'CreditCard' only refers to a type, but is being used as a value here.</code>。</p><p id="90aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译器知道这两个空间之间的区别，并且知道类型<code class="fe mp mq mr ms b">CreditCard</code>位于<em class="li">类型空间</em>中。</p><p id="a032" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">playground是一个非常酷的工具，可以用来查看您的类型脚本代码的输出。如果您创建一个新的信用卡对象，如下所示:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="389d" class="nl ln it ms b gy nm nn l no np">const creditCard: CreditCard = {<br/>  number: 2093,<br/>  cardholder: 'TK',<br/>  expirationDate: new Date(),<br/>  secutiryCode: 101<br/>};</span></pre><p id="fd58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译器将对其进行类型检查，并完成所有的魔术，然后将类型脚本代码转换成Javascript。我们有这个:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="1017" class="nl ln it ms b gy nm nn l no np">const creditCard = {<br/>    number: 2093,<br/>    cardholder: 'TK',<br/>    expirationDate: new Date(),<br/>    secutiryCode: 101<br/>};</span></pre><p id="5123" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相同的对象，但现在只有值，没有类型。</p><h1 id="6979" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">约束和类型收缩</h1><blockquote class="lf lg lh"><p id="8a56" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">当我们限制我们能做什么时，就更容易理解我们能做什么。</p></blockquote><p id="7673" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用类型作为约束来限制程序中的错误。为了理解这个概念，我从Lauren Tan关于类型系统的演讲中偷了一个例子。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="9cc6" class="nl ln it ms b gy nm nn l no np">const half = x =&gt; x / 2;</span></pre><p id="70ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数有多少种失效方式？想象一些可能的输入:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="d0f3" class="nl ln it ms b gy nm nn l no np">[<br/>  null,<br/>  undefined,<br/>  0,<br/>  '0',<br/>  'TK',<br/>  { username: 'tk' },<br/>  [42, 3.14],<br/>  (a, b) =&gt; a + b,<br/>]</span></pre><p id="06dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输入的结果是什么:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="e23e" class="nl ln it ms b gy nm nn l no np">half(null); // 0<br/>half(undefined); // NaN<br/>half(0); // 0<br/>half('0'); // 0<br/>half('TK'); // NaN<br/>half({ username: 'tk' }); // NaN<br/>half([42, 3.14]); // NaN<br/>half((a, b) =&gt; a + b); // NaN</span></pre><p id="7305" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里有不同的和意想不到的结果。很明显，我们需要一个数字作为函数<code class="fe mp mq mr ms b">half</code>，进行计算，很好，完成了！但有时我们无法控制输入，或者代码库很大，或者是新的/不熟悉的，我们会犯这些小错误。</p><p id="7102" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向我们的代码添加约束的想法是缩小一系列类型的可能性。在这种情况下，我们希望将输入类型限制为<code class="fe mp mq mr ms b">number</code>类型。这是我们唯一关心的类型来做半计算。通过类型收缩，我们再次向编译器提供类型信息。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="89bb" class="nl ln it ms b gy nm nn l no np">const half = (x: number) =&gt; x / 2;</span></pre><p id="5779" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些新信息，如果我们再次调用测试用例的函数，我们会得到不同的结果:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="7738" class="nl ln it ms b gy nm nn l no np">half(null); // Argument of type 'null' is not assignable to parameter of type 'number'.<br/>half(undefined); // Argument of type 'undefined' is not assignable to parameter of type 'number'.(<br/>half(0); // 0<br/>half('0'); // Argument of type '"0"' is not assignable to parameter of type 'number'.<br/>half('TK'); // Argument of type '"TK"' is not assignable to parameter of type 'number'.<br/>half({ username: 'tk' }); // Argument of type '{ username: string; }' is not assignable to parameter of type 'number'.<br/>half([42, 3.14]); // Argument of type 'number[]' is not assignable to parameter of type 'number'.<br/>half((a, b) =&gt; a + b); // Argument of type '(a: any, b: any) =&gt; any' is not assignable to parameter of type 'number'.</span></pre><p id="63fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上编译器会告诉我们，只有数字类型，在这种情况下，<code class="fe mp mq mr ms b">0</code>值，是一个有效的输入，它会编译，并允许运行代码。我们缩小了输入类型，只允许我们真正想要的值用于这个函数。</p><p id="7075" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是还有其他方法来缩小Typescript中的类型。假设我们有一个函数，它接收的参数可以是字符串或数字。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="b784" class="nl ln it ms b gy nm nn l no np">type StringOrNumber = string | number;</span><span id="633c" class="nl ln it ms b gy nq nn l no np">function stringOrNumber(value: StringOrNumber) {}</span></pre><p id="2265" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在函数体中，编译器不知道我们可以为这个类型使用哪些方法或属性。是字符串还是数字？我们只知道运行时的值。但是我们可以使用<code class="fe mp mq mr ms b">typeof</code>来缩小类型:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="4c63" class="nl ln it ms b gy nm nn l no np">function stringOrNumber(value: StringOrNumber) {<br/>  if (typeof value === 'string') {<br/>    // value.<br/>		// your ide will show you the possible methods from the string type<br/>		// (parameter) value: string<br/>    value<br/>  }</span><span id="0cad" class="nl ln it ms b gy nq nn l no np">if (typeof value === 'number') {<br/>    // value.<br/>		// your ide will show you the possible methods from the number type<br/>		// (parameter) value: number<br/>    value<br/>  }<br/>}</span></pre><p id="31a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了<code class="fe mp mq mr ms b">if</code>语句和<code class="fe mp mq mr ms b">typeof</code>，我们可以给编译器更多的信息。现在它将知道每个<code class="fe mp mq mr ms b">if</code>主体的具体类型。</p><p id="fc3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">IDE知道为特定类型显示什么。运行时，当值为字符串时，会转到第一条<code class="fe mp mq mr ms b">if</code>语句，编译器会推断出类型为字符串:<code class="fe mp mq mr ms b">(parameter) value: string</code>。</p><p id="81aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当值是一个数字时，它将转到第二个<code class="fe mp mq mr ms b">if</code>语句，编译器将推断一个类型是一个数字:<code class="fe mp mq mr ms b">(parameter) value: number</code>。</p><p id="fa22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr ms b">if</code>语句可以成为编译器的助手。</p><p id="b3e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个例子是当我们在一个对象中有一个可选属性，但是在一个函数中，我们需要返回一个基于这个可选值的值。</p><p id="a46f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象我们有这种类型:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="b2b6" class="nl ln it ms b gy nm nn l no np">type User = {<br/>  name: string;<br/>  address: {<br/>    street: string;<br/>    complement?: string;<br/>  }<br/>};</span></pre><p id="faeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很简单的<code class="fe mp mq mr ms b">User</code>型。让我们把注意力集中在<code class="fe mp mq mr ms b">complement</code>房产上。它是可选的(仔细看看<code class="fe mp mq mr ms b">?</code>符号)，这意味着它可以是<code class="fe mp mq mr ms b">string</code>或<code class="fe mp mq mr ms b">undefined</code>。</p><p id="9f69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们要构建一个函数来接收用户并获取地址补码的长度。这个呢？</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="3d6f" class="nl ln it ms b gy nm nn l no np">function getComplementLength(user: User): number {<br/>  return user.address.complement.length;<br/>	// (property) complement?: string | undefined<br/>  // Object is possibly 'undefined'.<br/>}</span></pre><p id="b06a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们前面看到的，<code class="fe mp mq mr ms b">complement</code>可以是<code class="fe mp mq mr ms b">string</code>或<code class="fe mp mq mr ms b">undefined</code>。<code class="fe mp mq mr ms b">undefined</code>其实并没有一个叫做<code class="fe mp mq mr ms b">length</code>的属性:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="72ba" class="nl ln it ms b gy nm nn l no np">Uncaught TypeError: Cannot read property 'length' of undefined</span></pre><p id="5e09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以做出这样的东西:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="fdae" class="nl ln it ms b gy nm nn l no np">function getComplementLength(user: User) {<br/>  return user.address.complement?.length;<br/>}</span></pre><p id="4524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe mp mq mr ms b">complement</code>有一个字符串值，我们可以调用<code class="fe mp mq mr ms b">length</code>，否则将返回<code class="fe mp mq mr ms b">undefined</code>。所以这个函数有两种可能的返回类型:<code class="fe mp mq mr ms b">number | undefined</code>。但是我们想确保我们只返回<code class="fe mp mq mr ms b">number</code>。所以我们使用一个<code class="fe mp mq mr ms b">if</code>或三元条件来缩小类型。它只会在有实值的时候(或者不是<code class="fe mp mq mr ms b">undefined</code>的时候)调用<code class="fe mp mq mr ms b">.length</code>。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="5f79" class="nl ln it ms b gy nm nn l no np">function getComplementLength(user: User): number {<br/>  return user.address.complement<br/>    ? user.address.complement.length<br/>    : 0;<br/>}</span></pre><p id="4b5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果是<code class="fe mp mq mr ms b">undefined</code>，我们返回最小长度:<code class="fe mp mq mr ms b">0</code>。现在，我们可以使用正确类型设计的函数，无论有没有补码。没有编译和运行时错误。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="29cd" class="nl ln it ms b gy nm nn l no np">getComplementLength({<br/>  name: 'TK',<br/>  address: {<br/>    street: 'Shinjuku Avenue'<br/>  }<br/>}); // 0</span><span id="e5e6" class="nl ln it ms b gy nq nn l no np">getComplementLength({<br/>  name: 'TK',<br/>  address: {<br/>    street: 'Shinjuku Avenue',<br/>    complement: 'A complement'<br/>  }<br/>}); // 12</span></pre><p id="46ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将从第一次函数调用中得到<code class="fe mp mq mr ms b">0</code>，从第二次调用中得到<code class="fe mp mq mr ms b">12</code>。</p><p id="2560" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个<code class="fe mp mq mr ms b">if</code>概念，我们也可以用其他的帮手来做同样的事情。我们可以使用<code class="fe mp mq mr ms b">in</code>操作符来验证对象的属性，使用<code class="fe mp mq mr ms b">Array.isArray</code>来验证数组，或者使用<code class="fe mp mq mr ms b">instanceof</code>来验证任何其他的类类型。</p><p id="8f2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以使用更高级的概念，比如断言函数或类型保护，但是我会在以后的文章中介绍这些概念。</p><p id="49e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想深入研究这个<em class="li">约束</em>主题的一点是不变性。</p><p id="46b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Javascript和Typescript中，我们有可变对象的概念。如果你在一个变量中定义了一个值，我们可以在以后给它重新赋值。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="78c0" class="nl ln it ms b gy nm nn l no np">let email = 'harry.potter@mail.com';<br/>email // 'harry.potter@mail.com'<br/>email = 'hermione.granger@mail.com';<br/>email // 'hermione.granger@mail.com'</span></pre><p id="1321" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在想象你有一个数字列表。你想用一个函数对所有的数字求和。该函数如下所示:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="30c7" class="nl ln it ms b gy nm nn l no np">function sumNumbers(numbers: number[]) {<br/>  let sum = 0;<br/>  let num = numbers.pop();</span><span id="eedb" class="nl ln it ms b gy nq nn l no np">while (num !== undefined) {<br/>    sum += num;<br/>    num = numbers.pop();<br/>  }</span><span id="c633" class="nl ln it ms b gy nq nn l no np">return sum;<br/>}</span></pre><p id="4385" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您调用传递您的列表的函数并获得结果。它工作得很好。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="f7ec" class="nl ln it ms b gy nm nn l no np">const list = [1, 2, 3, 4];<br/>sumNumbers(list); // 10</span></pre><p id="c41d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是你的单子怎么了？是函数让它完全变异了吗？</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="3df0" class="nl ln it ms b gy nm nn l no np">list; // []</span></pre><p id="d944" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用列表，它现在是空的。<code class="fe mp mq mr ms b">sumNumbers</code>函数中的<code class="fe mp mq mr ms b">pop</code>是一个“变异”函数。它获取引用并从引用中移除该项。不是抄袭，是真实参考。</p><p id="778e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在运行时，我们可以使用其他函数或方法来做同样的事情:使用reduce，做一个for循环而不需要从数组中<code class="fe mp mq mr ms b">pop</code>项。</p><p id="d0b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是使用Typescript，我们可以在编译时提供不变性。如果不使用类型，可以使用类型断言<code class="fe mp mq mr ms b">as const</code>。想象一下:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="8068" class="nl ln it ms b gy nm nn l no np">const author = {<br/>  name: 'Walter Isaacson',<br/>  email: 'walter.isaacson@mail.com',<br/>  books: [<br/>    {<br/>      title: 'Leonardo Da Vinci',<br/>      price: 50.00,<br/>    }<br/>  ]<br/>};</span><span id="1b06" class="nl ln it ms b gy nq nn l no np">author.books.push({<br/>  title: 'Steve Jobs',<br/>  price: 10.00<br/>});</span></pre><p id="188a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只是一个作者对象，然后我们给这个作者添加一本新书。<code class="fe mp mq mr ms b">push</code>方法更新书的数组引用。这是一种“变异”方法。让我们看看你是否使用了const断言<code class="fe mp mq mr ms b">as const</code>:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="7f38" class="nl ln it ms b gy nm nn l no np">const author = {<br/>  name: 'Walter Isaacson',<br/>  email: 'walter.isaacson@mail.com',<br/>  books: [<br/>    {<br/>      title: 'Leonardo Da Vinci',<br/>      price: 50.00,<br/>    }<br/>  ]<br/>} as const;</span><span id="a958" class="nl ln it ms b gy nq nn l no np">author.books.push({<br/>  title: 'Steve Jobs',<br/>  price: 10.00<br/>});<br/>// Property 'push' does not exist on type<br/>// 'readonly [{ readonly title: "Leonardo Da Vinci"; readonly price: 50; }]'</span></pre><p id="551f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译器不会编译。它在作者的对象上得到一个错误。它现在是readonly，作为一个readonly对象，它没有名为<code class="fe mp mq mr ms b">push</code>的方法(或任何“mutate”方法)。我们给作者的对象添加了一个约束。之前它是一个特定的类型(带有所有的“mutate”方法)，现在我们将类型缩小到几乎相同，但是没有“mutate”方法。缩小类型。</p><p id="37ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了继续，让我们给这个对象添加类型。<code class="fe mp mq mr ms b">book</code>和<code class="fe mp mq mr ms b">author</code>:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="005c" class="nl ln it ms b gy nm nn l no np">type Book = {<br/>  title: string;<br/>  price: number;<br/>};</span><span id="57ad" class="nl ln it ms b gy nq nn l no np">type Author = {<br/>  name: string;<br/>  email: string;<br/>  books: Book[];<br/>};</span></pre><p id="806f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将类型添加到作者对象:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="3ef2" class="nl ln it ms b gy nm nn l no np">const author: Author = {<br/>  name: 'Walter Isaacson',<br/>  email: 'walter.isaacson@mail.com',<br/>  books: [<br/>    {<br/>      title: 'Leonardo Da Vinci',<br/>      price: 50.00,<br/>    }<br/>  ]<br/>};</span></pre><p id="5a38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将类型添加到新的图书对象:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="c932" class="nl ln it ms b gy nm nn l no np">const book: Book = {<br/>  title: 'Steve Jobs',<br/>  price: 30<br/>};</span></pre><p id="efaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以将新书添加到作者:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="2095" class="nl ln it ms b gy nm nn l no np">author.name = 'TK';<br/>author.books.push(book);</span></pre><p id="45fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它工作得很好！</p><p id="413a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想展示另一种在编译时增加不变性的方法。Typescript有一个名为<code class="fe mp mq mr ms b">Readonly</code>的实用程序类型。</p><p id="eac2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以为对象中的每个属性添加<code class="fe mp mq mr ms b">readonly</code>。大概是这样的:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="91e4" class="nl ln it ms b gy nm nn l no np">type Book = {<br/>  readonly title: string;<br/>  readonly price: number;<br/>};</span></pre><p id="aa63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是它可能非常重复。因此，我们可以使用<code class="fe mp mq mr ms b">Readonly</code>实用程序将<code class="fe mp mq mr ms b">readonly</code>添加到对象的所有属性中:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="f518" class="nl ln it ms b gy nm nn l no np">type Book = Readonly&lt;{<br/>  title: string;<br/>  price: number;<br/>}&gt;;</span></pre><p id="3a14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要记住的一点是，它没有为嵌套属性添加readonly。例如，如果我们将<code class="fe mp mq mr ms b">Readonly</code>添加到<code class="fe mp mq mr ms b">Author</code>类型，它不会将<code class="fe mp mq mr ms b">readonly</code>也添加到<code class="fe mp mq mr ms b">Book</code>类型。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="5b69" class="nl ln it ms b gy nm nn l no np">type Author = Readonly&lt;{<br/>  name: string;<br/>  email: string;<br/>  books: Book[];<br/>}&gt;;</span></pre><p id="5f65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作者的所有属性都不能被重新分配，但是你可以在这里改变<code class="fe mp mq mr ms b">books</code>列表(<code class="fe mp mq mr ms b">push</code>，<code class="fe mp mq mr ms b">pop</code>，...)因为<code class="fe mp mq mr ms b">Book[]</code>不是只读的。让我们看看。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="c2cc" class="nl ln it ms b gy nm nn l no np">const author: Author = {<br/>  name: 'Walter Isaacson',<br/>  email: 'walter.isaacson@mail.com',<br/>  books: [<br/>    {<br/>      title: 'Leonardo Da Vinci',<br/>      price: 50.00,<br/>    }<br/>  ]<br/>};</span><span id="6982" class="nl ln it ms b gy nq nn l no np">const book: Book = {<br/>  title: 'Steve Jobs',<br/>  price: 30<br/>};</span><span id="bd8c" class="nl ln it ms b gy nq nn l no np">author.books.push(book);<br/>author.books;<br/>/* =&gt;<br/> * <br/> * [<br/> *   {<br/> *     title: 'Leonardo Da Vinci',<br/> *     price: 50.00,<br/> *   },<br/> *   {<br/> *    title: 'Steve Jobs',<br/> *    price: 30<br/> *   }<br/> * ]<br/> * <br/> */</span></pre><p id="e85c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr ms b">push</code>将会工作得很好。</p><p id="3e35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，我们如何对<code class="fe mp mq mr ms b">books</code>执行只读操作呢？我们需要确保数组是只读类型。我们可以使用<code class="fe mp mq mr ms b">Readonly</code>，或者使用Typescript中另一个名为<code class="fe mp mq mr ms b">ReadonlyArray</code>的实用程序。让我们来看两种方法。</p><p id="6e07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">带<code class="fe mp mq mr ms b">Readonly</code>:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="67d4" class="nl ln it ms b gy nm nn l no np">type Author = Readonly&lt;{<br/>  name: string;<br/>  email: string;<br/>  books: Readonly&lt;Book[]&gt;;<br/>}&gt;;</span></pre><p id="e832" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用<code class="fe mp mq mr ms b">ReadonlyArray</code>:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="b649" class="nl ln it ms b gy nm nn l no np">type Author = Readonly&lt;{<br/>  name: string;<br/>  email: string;<br/>  books: ReadonlyArray&lt;Book&gt;;<br/>}&gt;;</span></pre><p id="3e5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对我来说，两者都很棒！但是在我看来，<code class="fe mp mq mr ms b">ReadonlyArray</code>更有语义，我也觉得它不那么罗嗦(不是说带数组的<code class="fe mp mq mr ms b">Readonly</code>是)。</p><p id="06b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们现在尝试改变author对象会发生什么？</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="385d" class="nl ln it ms b gy nm nn l no np">author.name = 'TK'; // Cannot assign to 'name' because it is a read-only property.<br/>author.books.push(book); // Property 'push' does not exist on type 'readonly [{ readonly title: "Leonardo Da Vinci"; readonly price: 50; }]'.</span></pre><p id="84e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！现在我们可以在编译时捕捉可变操作。这是一种使用向我们的类型添加约束的概念来确保它们只做真正需要的事情的方法。</p><h1 id="1b6b" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">语义和可读性</h1><p id="3453" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">起初，我觉得由于类型的原因，Typescript可能会非常冗长，并使代码比它应该的要复杂得多。它确实可以。力求简单是目标，同时也很难。</p><p id="cdb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个想法与干净的代码以及我们如何编写人类可读和可维护的代码非常相关。Typescript也不例外。大多数情况下，我们不需要超级复杂的类型。让简单的类型来完成这项工作。</p><p id="8120" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现另一件非常有用的事情是类型的语义。</p><p id="f07a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您需要向<code class="fe mp mq mr ms b">sessionStorage</code>添加一个字符串，以将其保存在浏览器中。您的函数如下所示:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="0962" class="nl ln it ms b gy nm nn l no np">function saveMyString(value: string): any {<br/>  sessionStorage.myString = value;<br/>}</span></pre><p id="a5e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您向字符串输入添加了一个类型注释，由于您不知道返回的类型，您可能会添加一个<code class="fe mp mq mr ms b">any</code>类型。</p><p id="87ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是这种回归类型背后的真正含义是什么呢？它会返回任何东西吗？</p><p id="55a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它只是将字符串保存到<code class="fe mp mq mr ms b">sessionStorage</code>。它不返回任何东西。<code class="fe mp mq mr ms b">void</code>型正是你要找的。正如Typescript docs所说:<code class="fe mp mq mr ms b">the absence of having any type at all</code>。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="bcb3" class="nl ln it ms b gy nm nn l no np">function saveMyString(value: string): void {<br/>  sessionStorage.myString = value;<br/>}</span></pre><p id="bb02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了，现在类型的含义是正确的。正确性在一个类型系统中是非常重要的。这是对我们的数据建模的一种方式，但也有助于为未来的开发人员维护系统。哪怕开发者是……你！</p><p id="700f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们讨论冗长代码之前。我们可以通过使用Typescript类型推断来改进很多代码。</p><p id="ec15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于某些代码，我们不需要显式添加类型注释。Typescript编译器将理解并隐式推断它。例如:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="347f" class="nl ln it ms b gy nm nn l no np">const num: number = 1;</span></pre><p id="eb74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这段代码是多余的。我们可以让编译器这样推断:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="d2ed" class="nl ln it ms b gy nm nn l no np">const num = 1;</span></pre><p id="2f24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前面的例子中，我们将注释<code class="fe mp mq mr ms b">void</code>添加到了<code class="fe mp mq mr ms b">saveMyString</code>函数中。但是由于函数不返回值，编译器会推断返回的类型是隐式的<code class="fe mp mq mr ms b">void</code>。</p><p id="1f62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我得知这一点时，我自己也在想。但是使用Typescript(或任何其他类型系统/静态类型语言)的最大优势之一是将类型作为文档。如果我们让编译器推断大部分类型，我们就不会有我们想要的文档。</p><p id="572d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果您将鼠标悬停在编辑器中的Typescript代码上(至少VS代码是这样工作的)，您可以看到类型信息和相关文档。</p><p id="cab3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看其他冗余代码的例子，让代码不那么冗长，让编译器为我们工作。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="cbcb" class="nl ln it ms b gy nm nn l no np">function sum(a: number, b: number): number {<br/>  return a + b;<br/>};</span></pre><p id="fdfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不需要返回类型<code class="fe mp mq mr ms b">number</code>，因为编译器知道一个<code class="fe mp mq mr ms b">number</code> +另一个<code class="fe mp mq mr ms b">number</code>等于一个<code class="fe mp mq mr ms b">number</code>类型，而且是返回类型。它可以是:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="8e59" class="nl ln it ms b gy nm nn l no np">function sum(a: number, b: number) {<br/>  return a + b;<br/>};</span></pre><p id="2eea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">隐式代码，但是有文档，由编译器完成工作。</p><p id="d40c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型推理也适用于方法:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="13cc" class="nl ln it ms b gy nm nn l no np">function squareAll(numbers: number[]): number[] {<br/>  return numbers.map(number =&gt; number * number);<br/>};</span></pre><p id="3d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个函数获取一个数字列表，并使每个数字都是平方值。返回的类型是<code class="fe mp mq mr ms b">number[]</code>，尽管地图的结果总是一个列表，并且因为我们有一个数字列表，它将总是一个数字列表。所以我们让编译器也推断出这一点:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="d57d" class="nl ln it ms b gy nm nn l no np">function squareAll(numbers: number[]) {<br/>  return numbers.map(number =&gt; number * number);<br/>};</span></pre><p id="6ed4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这同样适用于对象。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="a26c" class="nl ln it ms b gy nm nn l no np">const person: { name: string, age: number } = {<br/>  name: 'TK',<br/>  age: 24<br/>};</span></pre><p id="effb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">具有字符串名称和数字年龄的person对象。但是当我们给这些值赋值时，编译器可以推断出这些类型。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="fb9b" class="nl ln it ms b gy nm nn l no np">const person = {<br/>  name: 'TK',<br/>  age: 24<br/>};</span></pre><p id="549f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你悬停在<code class="fe mp mq mr ms b">person</code>上，你会得到这个:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="ac40" class="nl ln it ms b gy nm nn l no np">const person: {<br/>  name: string;<br/>  age: number;<br/>}</span></pre><p id="c634" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里记录了这些类型。</p><p id="cd64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类型推断的另一个好处是我们可以很容易地重构我们的代码。这是一个简单的例子，但是很好地说明了重构过程。再来拿<code class="fe mp mq mr ms b">sum</code>函数。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="a6e1" class="nl ln it ms b gy nm nn l no np">function sum(a: number, b: number): number {<br/>  return a + b;<br/>};</span></pre><p id="f76c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想返回<code class="fe mp mq mr ms b">"Sum: {a + b}"</code>，而不是返回总数。所以对于<code class="fe mp mq mr ms b">a = 1</code>和<code class="fe mp mq mr ms b">b = 2</code>，我们得到的字符串是<code class="fe mp mq mr ms b">"Sum: 3"</code>。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="f33d" class="nl ln it ms b gy nm nn l no np">function sum(a: number, b: number): string {<br/>  return `Sum: ${a + b}`;<br/>};</span><span id="4bc1" class="nl ln it ms b gy nq nn l no np">sum(1, 2); // Sum: 3</span></pre><p id="d37c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！但是现在让编译器推断这个。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="0060" class="nl ln it ms b gy nm nn l no np">// function sum(a: number, b: number): number<br/>function sum(a: number, b: number) {<br/>  return a + b;<br/>};</span><span id="666f" class="nl ln it ms b gy nq nn l no np">// function sum(a: number, b: number): string<br/>function sum(a: number, b: number) {<br/>  return `Sum: ${a + b}`;<br/>};</span></pre><p id="8a07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只需要修改返回值，类型推断就会起作用。不需要考虑返回类型。这是一个小例子，但是对于更复杂的函数，它也可以工作。</p><p id="adc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到可读性部分，我们可以使用<code class="fe mp mq mr ms b">Enum</code>。定义一组命名常量的实用程序。这是赋予应用程序中的数据更多意义的一种方式。</p><p id="3cc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您的节点应用程序或前端应用程序中，您可能会做一些获取来请求数据。您通常使用fetch对象来执行请求，有时您需要传递accept头。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="58bb" class="nl ln it ms b gy nm nn l no np">fetch('/pokemons', {<br/>  headers: {<br/>    Accept: 'application/json'<br/>  }<br/>});</span><span id="86f0" class="nl ln it ms b gy nq nn l no np">fetch('/harry-potter/spells', {<br/>  headers: {<br/>    Accept: 'application/json'<br/>  }<br/>});</span></pre><p id="b148" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很好，但是我们也可以使用enum将这个accept字符串分隔在一个常量中并重用。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="8563" class="nl ln it ms b gy nm nn l no np">enum MediaTypes {<br/>  JSON = 'application/json'<br/>}</span><span id="c005" class="nl ln it ms b gy nq nn l no np">fetch('/pokemons', {<br/>  headers: {<br/>    Accept: MediaTypes.JSON<br/>  }<br/>});</span><span id="e734" class="nl ln it ms b gy nq nn l no np">fetch('/harry-potter/spells', {<br/>  headers: {<br/>    Accept: MediaTypes.JSON<br/>  }<br/>});</span></pre><p id="6db5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们能够添加更多与<code class="fe mp mq mr ms b">MediaTypes</code>相关的数据，如<code class="fe mp mq mr ms b">PDF</code>:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="995f" class="nl ln it ms b gy nm nn l no np">enum MediaTypes {<br/>  JSON = 'application/json',<br/>  PDF = 'application/pdf'<br/>}</span></pre><p id="466c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了<code class="fe mp mq mr ms b">Enum</code>，我们可以将数据封装成有意义的代码块。</p><p id="474d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近，我正在实现一个“state”React组件。它基本上是一个基于请求响应呈现空状态或错误状态的组件。</p><p id="c24b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">空状态和错误状态的用户界面非常相似。只有标题、描述文本和图像图标不同。所以我想:“我有两种方法来实现这一点:在组件外部执行逻辑并传递所有需要的信息，或者传递一个‘状态类型’并让组件呈现正确的图标和消息。”</p><p id="b31d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我建立了一个枚举:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="188f" class="nl ln it ms b gy nm nn l no np">export enum StateTypes {<br/>  Empty = 'Empty',<br/>  Error = 'Error'<br/>};</span></pre><p id="4e8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我可以将这些数据作为<code class="fe mp mq mr ms b">type</code>传递给组件:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="4933" class="nl ln it ms b gy nm nn l no np">import ComponentState, { StateTypes } from './ComponentState';</span><span id="7353" class="nl ln it ms b gy nq nn l no np">&lt;ComponentState type={StateTypes.Empty} /&gt;<br/>&lt;ComponentState type={StateTypes.Error} /&gt;</span></pre><p id="41cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在组件中，它有一个状态对象，其中包含与<code class="fe mp mq mr ms b">title</code>、<code class="fe mp mq mr ms b">description</code>和<code class="fe mp mq mr ms b">icon</code>相关的所有信息。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="64c5" class="nl ln it ms b gy nm nn l no np">const stateInfo = {<br/>  Empty: {<br/>    title: messages.emptyTitle,<br/>    description: messages.emptyDescription,<br/>    icon: EmptyIcon,<br/>  },<br/>  Error: {<br/>    title: messages.errorTitle,<br/>    description: messages.errorDescription,<br/>    icon: ErrorIcon,<br/>  },<br/>};</span></pre><p id="43e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我可以只接收基于枚举的类型，并将这个<code class="fe mp mq mr ms b">stateInfo</code>对象与来自我们设计系统的<code class="fe mp mq mr ms b">State</code>组件一起使用:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="6239" class="nl ln it ms b gy nm nn l no np">export const ComponentState = ({ type }) =&gt; (<br/>  &lt;State<br/>    title={stateInfo[type].title}<br/>    subtitle={stateInfo[type].subtitle}<br/>    icon={stateInfo[type].icon}<br/>  /&gt;<br/>);</span></pre><p id="daa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一种使用枚举将重要数据封装到应用程序中有意义的代码块中的方法。</p><p id="e515" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Typescript的另一个很酷的特性是可选属性。当一个对象的属性可以是一个实值或者未定义的值时，我们使用一个可选的属性来明确地表示该属性可以存在或者不存在。其语法是object属性中的一个简单的<code class="fe mp mq mr ms b">?</code>操作符。想象一下这个函数:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="ec67" class="nl ln it ms b gy nm nn l no np">function sumAll(a: number, b: number, c: number) {<br/>  return a + b + c;<br/>}</span></pre><p id="b047" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是现在<code class="fe mp mq mr ms b">c</code>值是可选的:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="f5b2" class="nl ln it ms b gy nm nn l no np">function sumAll(a: number, b: number, c?: number) {<br/>  return a + b + c;<br/>}</span></pre><p id="3e9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在<code class="fe mp mq mr ms b">c</code>后面加上<code class="fe mp mq mr ms b">?</code>。但是现在我们有一个编译器错误:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="e4c0" class="nl ln it ms b gy nm nn l no np">(parameter) c: number | undefined<br/>Object is possibly 'undefined'.</span></pre><p id="83ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们不能对一个<code class="fe mp mq mr ms b">undefined</code>值求和(实际上在Javascript中我们可以，但是我们接收的是一个<code class="fe mp mq mr ms b">NaN</code>值)。</p><p id="aa9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要确保<code class="fe mp mq mr ms b">c</code>存在。缩小类型！</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="ed3e" class="nl ln it ms b gy nm nn l no np">function sumAll(a: number, b: number, c?: number) {<br/>  if (c) {<br/>    return a + b + c;<br/>  }</span><span id="4bc3" class="nl ln it ms b gy nq nn l no np">return a + b;<br/>}</span></pre><p id="7079" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe mp mq mr ms b">c</code>存在，它将是一个<code class="fe mp mq mr ms b">number</code>，我们可以对所有的求和。如果不是，只对<code class="fe mp mq mr ms b">a</code>和<code class="fe mp mq mr ms b">b</code>值求和。</p><p id="55b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个可选属性的有趣之处在于，它是一个<code class="fe mp mq mr ms b">undefined</code>而不是<code class="fe mp mq mr ms b">null</code>。这就是为什么我们这样做，我们得到一个编译错误:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="8de3" class="nl ln it ms b gy nm nn l no np">let number = null;<br/>sumAll(1, 2, number);<br/>// Argument of type 'null' is not assignable to parameter of type 'number | undefined'.</span></pre><p id="02c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于<code class="fe mp mq mr ms b">?</code>操作符不处理<code class="fe mp mq mr ms b">null</code>值，所以选择在应用程序中使用<code class="fe mp mq mr ms b">undefined</code>类型，这样您仍然可以使用可选属性并使类型保持一致。我们可以这样使用它:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="6a39" class="nl ln it ms b gy nm nn l no np">let value: number | undefined;<br/>sumAll(1, 2, value); // 3</span></pre><p id="42bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果给参数添加一个默认值，就不需要<code class="fe mp mq mr ms b">?</code>操作符了。实际上，编译器会说<code class="fe mp mq mr ms b">Parameter cannot have question mark and initializer</code>。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="79d2" class="nl ln it ms b gy nm nn l no np">function sumAll(a: number, b: number, c: number = 3) {<br/>  return a + b + c;<br/>}</span></pre><p id="3c7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可选属性不仅作用于变量和参数，也作用于对象。</p><p id="b0bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">API响应是类型定义和可选属性结合的一个很好的例子。在API响应中，数据可以是可选的。有时候API发送，有时候没有值。</p><p id="afea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们如何对我们的类型建模对于一个应用程序来说非常重要。如果一个可选的属性被定义为一个必需的类型，我们可以让我们的应用程序在运行时中断。但是如果我们正确地设计了类型，我们就有可能在编译时出错。</p><p id="e341" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们正在获取一个用户数据，这是我们对响应类型建模的方式:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="0c4a" class="nl ln it ms b gy nm nn l no np">type UserResponse = {<br/>  name: string;<br/>  email: string;<br/>  username: string;<br/>  age: number;<br/>  isActive: boolean;<br/>};</span></pre><p id="b86f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但实际上，电子邮件对用户来说是可选的。API端点可以返回，也可以不返回。但是我们构建的<code class="fe mp mq mr ms b">UserResponse</code>类型将它视为必需属性。</p><p id="46a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在获取用户数据之后，我们希望查看用户电子邮件是否与特定的域匹配。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="03fa" class="nl ln it ms b gy nm nn l no np">function matchDomain(email: string) {<br/>  return email.endsWith(domain);<br/>}</span></pre><p id="6053" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于在<code class="fe mp mq mr ms b">UserResponse</code>类型中需要<code class="fe mp mq mr ms b">email</code>属性，因此在<code class="fe mp mq mr ms b">matchDomain</code>函数中也需要<code class="fe mp mq mr ms b">email</code>参数。</p><p id="85ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe mp mq mr ms b">email</code>是<code class="fe mp mq mr ms b">undefined</code>，这是我们可以得到的运行时间:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="5d27" class="nl ln it ms b gy nm nn l no np">// Uncaught TypeError: Cannot read property 'endsWith' of undefined</span></pre><p id="add4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们正确地对<code class="fe mp mq mr ms b">UserResponse</code>建模会发生什么呢？</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="d99f" class="nl ln it ms b gy nm nn l no np">type UserResponse = {<br/>  name: string;<br/>  email?: string;<br/>  username: string;<br/>  age: number;<br/>  isActive: boolean;<br/>};</span></pre><p id="6668" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在<code class="fe mp mq mr ms b">email</code>可能是<code class="fe mp mq mr ms b">undefined</code>并且是显式的。</p><p id="9ce9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们仍然保持函数<code class="fe mp mq mr ms b">matchDomain</code>不变，我们会得到一个编译错误:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="4464" class="nl ln it ms b gy nm nn l no np">// Argument of type 'undefined' is not assignable to parameter of type 'string'.</span></pre><p id="eff0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这太棒了！现在我们可以使用<code class="fe mp mq mr ms b">?</code>操作符来修改该函数中的<code class="fe mp mq mr ms b">email</code>参数:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="f0b2" class="nl ln it ms b gy nm nn l no np">function matchDomain(email?: string) {<br/>  return email.endsWith('email.com');<br/>}</span></pre><p id="adbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是现在我们在运行<code class="fe mp mq mr ms b">email.endsWith</code>时得到一个编译错误，因为它也可能是<code class="fe mp mq mr ms b">undefined</code>:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="d634" class="nl ln it ms b gy nm nn l no np">// (parameter) email: string | undefined<br/>// Object is possibly 'undefined'.</span></pre><p id="efb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缩小类型！当<code class="fe mp mq mr ms b">email</code>为<code class="fe mp mq mr ms b">undefined</code>时，我们使用if块返回一个<code class="fe mp mq mr ms b">false</code>。并且只有当<code class="fe mp mq mr ms b">email</code>确实是一个字符串时才运行<code class="fe mp mq mr ms b">endsWith</code>方法:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="9c7b" class="nl ln it ms b gy nm nn l no np">function matchDomain(email?: string) {<br/>  if (!email) return false;<br/>  return email.endsWith('email.com');<br/>}</span></pre><p id="4043" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们可以在编译时得到运行时错误时，这是非常好的。在我们投入生产后，编码比调试更好，不是吗？</p><h1 id="f044" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">铅字排版</h1><p id="5129" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">当试图为代码库的新位置重用现有类型时，类型组合非常有用。我们不需要重写新的类型，我们可以通过组合现有的类型来创建新的类型。</p><p id="83eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我必须使用Redux或React中的<code class="fe mp mq mr ms b">useReducer</code>钩子来处理的一个例子就是“reducers”的概念。减压器总是可以接收许多不同的动作。</p><p id="7706" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个上下文中，动作是至少具有一个<code class="fe mp mq mr ms b">type</code>属性的对象。看起来是这样的:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="9acd" class="nl ln it ms b gy nm nn l no np">enum ActionTypes {<br/>  FETCH = 'FETCH'<br/>}</span><span id="efe6" class="nl ln it ms b gy nq nn l no np">type FetchAction = {<br/>  type: typeof ActionTypes.FETCH;<br/>};</span><span id="b716" class="nl ln it ms b gy nq nn l no np">const fetchAction: FetchAction = {<br/>  type: ActionTypes.FETCH<br/>};</span></pre><p id="00e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个<code class="fe mp mq mr ms b">fetchAction</code>的类型<code class="fe mp mq mr ms b">FetchAction</code>的属性类型是<code class="fe mp mq mr ms b">FETCH</code>的类型。</p><p id="00ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是减速器也可以接收其他动作。例如，提交操作:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="651b" class="nl ln it ms b gy nm nn l no np">enum ActionTypes {<br/>  FETCH = 'FETCH',<br/>  SUBMIT = 'SUBMIT'<br/>}</span><span id="8e60" class="nl ln it ms b gy nq nn l no np">type SubmitAction = {<br/>  type: typeof ActionTypes.SUBMIT;<br/>};</span><span id="f55f" class="nl ln it ms b gy nq nn l no np">const submitAction: SubmitAction = {<br/>  type: ActionTypes.SUBMIT<br/>};</span></pre><p id="c572" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于一个特定的容器，我们可以将所有这些动作组合成一个类型，并将其用于reducer参数类型。</p><p id="ddcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它看起来像这样:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="59a6" class="nl ln it ms b gy nm nn l no np">type Actions = FetchAction | SubmitAction;</span><span id="9bc1" class="nl ln it ms b gy nq nn l no np">function reducer(state, action: Actions) {<br/>  switch (action.type) {<br/>    case ActionTypes.FETCH:<br/>    // fetching action<br/>    case ActionTypes.SUBMIT:<br/>    // submiting action<br/>  }<br/>}</span></pre><p id="123d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有可能的动作都是<code class="fe mp mq mr ms b">Actions</code>类型。我们使用一个联合类型来“连接”所有的动作类型。减速器中的动作可以有<code class="fe mp mq mr ms b">FetchAction</code>或<code class="fe mp mq mr ms b">SubmitAction</code>。</p><p id="0565" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一个波特迷，我不能错过一个哈利波特的例子。我想建立一个简单的函数来根据人物特征选择霍格沃茨的房子。让我们先从房子开始。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="175e" class="nl ln it ms b gy nm nn l no np">type House = {<br/>  name: string;<br/>  traits: string[];<br/>}</span><span id="a3ab" class="nl ln it ms b gy nq nn l no np">const gryffindor: House = {<br/>  name: 'Gryffindor',<br/>  traits: ['courage', 'bravery']<br/>};</span><span id="a4a9" class="nl ln it ms b gy nq nn l no np">const slytherin: House = {<br/>  name: 'Slytherin',<br/>  traits: ['ambition', 'leadership']<br/>};</span><span id="9f0f" class="nl ln it ms b gy nq nn l no np">const ravenclaw: House = {<br/>  name: 'Ravenclaw',<br/>  traits: ['intelligence', 'learning']<br/>};</span><span id="9b68" class="nl ln it ms b gy nq nn l no np">const hufflepuff: House = {<br/>  name: 'Hufflepuff',<br/>  traits: ['hard work', 'patience']<br/>};</span><span id="34e6" class="nl ln it ms b gy nq nn l no np">const houses: House[] = [<br/>  gryffindor,<br/>  slytherin,<br/>  ravenclaw,<br/>  hufflepuff<br/>];</span></pre><p id="8497" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想保持简单，所以<code class="fe mp mq mr ms b">House</code>类型只有<code class="fe mp mq mr ms b">name</code>和<code class="fe mp mq mr ms b">traits</code>，这是与房子相关的人的可能特征列表。</p><p id="65b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我创建了每个房子，并将它们全部添加到<code class="fe mp mq mr ms b">houses</code>列表中。</p><p id="b3d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">太好了！现在我将构建<code class="fe mp mq mr ms b">Person</code>类型。一个人可以是女巫，也可以是麻瓜。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="0417" class="nl ln it ms b gy nm nn l no np">type Witch = {<br/>  name: string;<br/>  trait: string;<br/>	magicFamily: string;<br/>}</span><span id="9252" class="nl ln it ms b gy nq nn l no np">type Muggle = {<br/>  name: string;<br/>	trait: string;<br/>  email: string;<br/>}</span></pre><p id="057a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们使用联合类型将这两种不同类型结合起来的部分:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="212c" class="nl ln it ms b gy nm nn l no np">type Person = Muggle | Witch;</span></pre><p id="130e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用交集类型，<code class="fe mp mq mr ms b">Person</code>类型具有来自<code class="fe mp mq mr ms b">Muggle</code>或<code class="fe mp mq mr ms b">Witch</code>的所有属性。</p><p id="d3d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在，如果我创建一个<code class="fe mp mq mr ms b">Muggle</code>，我只需要名字、特征和电子邮件:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="c0a7" class="nl ln it ms b gy nm nn l no np">const hermione: Muggle = {<br/>  name: 'Hermione Granger',<br/>	trait: 'bravery',<br/>  email: 'hermione@mail.com'<br/>};</span></pre><p id="7c5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我创建一个<code class="fe mp mq mr ms b">Witch</code>，我需要它的名字、特征和神奇的姓氏:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="1092" class="nl ln it ms b gy nm nn l no np">const harry: Witch = {<br/>  name: 'Harry Potter',<br/>  trait: 'courage',<br/>  magicFamily: 'Potter'<br/>};</span></pre><p id="5cca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我创建一个<code class="fe mp mq mr ms b">Person</code>，我至少需要来自<code class="fe mp mq mr ms b">Muggle</code>和<code class="fe mp mq mr ms b">Witch</code>的<code class="fe mp mq mr ms b">name</code>和<code class="fe mp mq mr ms b">trait</code>属性:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="3222" class="nl ln it ms b gy nm nn l no np">const tk: Person = {<br/>  name: 'TK',<br/>  email: 'tk@mail.com',<br/>  trait: 'learning',<br/>  magicFamily: 'Kinoshita'<br/>};</span></pre><p id="0a03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mp mq mr ms b">chooseHouse</code>很简单。我们只是路过房子和人。基于person特征，该函数将返回所选的房子:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="b1c3" class="nl ln it ms b gy nm nn l no np">function chooseHouse(houses: House[], person: Person) {<br/>  return houses.find((house) =&gt; house.traits.includes(person.trait))<br/>}</span></pre><p id="1487" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应用我们创造的所有人:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="dade" class="nl ln it ms b gy nm nn l no np">chooseHouse(houses, harry); // { name: 'Gryffindor', traits: ['courage', 'bravery'] }<br/>chooseHouse(houses, hermione); // { name: 'Gryffindor', traits: ['courage', 'bravery'] }<br/>chooseHouse(houses, tk); // { name: 'Ravenclaw', traits: ['intelligence', 'learning'] }</span></pre><p id="703f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不错！</p><p id="995a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">交集类型稍有不同，但也可以用于组合现有类型。</p><p id="e916" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我实现一个web应用程序来应用我对UX的研究时，我需要为图像组件创建一个prop类型。</p><p id="3351" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从产品类型中得到类型<code class="fe mp mq mr ms b">ImageUrl</code>:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="2738" class="nl ln it ms b gy nm nn l no np">type ImageUrl = {<br/>  imageUrl: string;<br/>};</span></pre><p id="2bf9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和代表图像所有属性的<code class="fe mp mq mr ms b">ImageAttr</code>:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="3f1b" class="nl ln it ms b gy nm nn l no np">type ImageAttr = {<br/>  imageAlt: string;<br/>  width?: string<br/>};</span></pre><p id="1133" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是道具需要组件中的所有这些信息。十字路口式救援！</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="7648" class="nl ln it ms b gy nm nn l no np">type ImageProps = ImageUrl &amp; ImageAttr;</span></pre><p id="c147" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这么简单。所以现在，组件需要所有这些属性。该类型如下所示:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="8f18" class="nl ln it ms b gy nm nn l no np">type ImageProps = {<br/>  imageUrl: string;<br/>  imageAlt: string;<br/>  width?: string<br/>};</span></pre><p id="24ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以这样使用这个类型:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="57aa" class="nl ln it ms b gy nm nn l no np">const imageProps: ImageProps = {<br/>  imageUrl: 'www.image.com',<br/>  imageAlt: 'an image',<br/>};</span><span id="2eef" class="nl ln it ms b gy nq nn l no np">const imagePropsWithWidth: ImageProps = {<br/>  imageUrl: 'www.image.com',<br/>  imageAlt: 'an image',<br/>  width: '100%'<br/>};</span></pre><p id="4fe3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不错！重用和组合类型的另一个概念。</p><p id="45b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我也发现<code class="fe mp mq mr ms b">Pick</code>型非常有趣和有用。我们还有其他有趣的类型<a class="ae ko" href="https://leandrotk.github.io/tk/2020/05/typescript-learnings-interesting-types/index.html" rel="noopener ugc nofollow" target="_blank">可以在这里编写，但是这里的想法是理解我们可以组合类型，并且没有重用类型的限制。如果你对研究其他类型感兴趣，看看我写的这篇文章:</a><a class="ae ko" href="https://leandrotk.github.io/tk/2020/05/typescript-learnings-interesting-types/index.html" rel="noopener ugc nofollow" target="_blank">Typescript learning:interest Types</a>。</p><h1 id="9a46" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">工具作业</h1><p id="b729" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">当你<code class="fe mp mq mr ms b">npm install typescript</code>时，你不仅仅得到编译器，你还得到语言服务API，一个叫做tsserver的独立服务器，编辑可以运行它来提供自动补全、跳转和其他很酷的特性。</p><p id="d4c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Typescript团队中的一些人将这些功能称为开发人员生产力工具，如类型检查时的智能错误和智能感知(代码完成、悬停信息、签名信息)。我们将在整篇文章中讨论这些特性，但我想专门讨论一下。</p><p id="84ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Typescript类型检查器功能强大，因为它可以推断类型并为一些可能的问题提供信息。例如:它推断城市是一个字符串。而且<code class="fe mp mq mr ms b">uppercase</code>用错了。由于它知道这是一个字符串，它也试图找到一个工程师正在寻找的可能的方法。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="5135" class="nl ln it ms b gy nm nn l no np">const city = 'Tokyo';<br/>city.toUppercase();<br/>// Property 'toUppercase' does not exist on type<br/>// 'string'. Did you mean 'toUpperCase'?</span></pre><p id="f9ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，编译器非常聪明，因为它准确地找到了我们想要的东西。</p><p id="42d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它也适用于对象:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="b112" class="nl ln it ms b gy nm nn l no np">const people = [<br/>  { name: 'TK', age: 24 },<br/>  { name: 'Kaio', age: 12 },<br/>  { name: 'Kazumi', age: 31 },<br/>];</span><span id="316e" class="nl ln it ms b gy nq nn l no np">for (const person of people) {<br/>  console.log(person.agi);<br/>  // Property 'agi' does not exist on type '{ name: string; age: number; }'<br/>}</span></pre><p id="0113" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了静态类型，该工具可以在代码完成、显示已定义类型的悬停信息以及方法和其他数据的签名信息方面为开发人员提供出色的体验。</p><p id="8656" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果键入:<code class="fe mp mq mr ms b">'TK'.</code>，编辑器将显示string对象所有可能的方法。编译器知道它是一个字符串。它知道来自<code class="fe mp mq mr ms b">String</code>原型的方法。但是它也提供了方法签名。这非常有趣，因为我们不一定需要去看医生。“文档”已经在我们的代码编辑器中了。</p><p id="1dbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个很棒的编码体验。</p><p id="4987" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“悬停”类型定义是我们在本文前面看到的另一件事。让编译器隐式地推断类型，这样你就不会丢失类型文档。将鼠标悬停在对象上，IDE或编辑器将始终能够显示类型定义。</p><p id="21d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一件有趣的事情是，Typescript不仅会标记出运行时可能出错的地方，而且还有助于找到不符合您预期的代码。</p><p id="d630" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有一个函数可以打开一个仍然关闭的零食条。它将验证snackbar的状态。如果它是关闭的，只需调用另一个函数来打开它。</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="632f" class="nl ln it ms b gy nm nn l no np">const buildSnackbar = (status: SnackbarStatus) =&gt; {<br/>  if (status.isClosed) {<br/>    openSnackbar();<br/>  }<br/>};</span></pre><p id="5f32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个snackbar的类型信息是:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="39e7" class="nl ln it ms b gy nm nn l no np">type SnackbarStatus = {<br/>  isClosed: boolean;<br/>};</span></pre><p id="8e61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我像这样调用这个函数会发生什么:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="b2ae" class="nl ln it ms b gy nm nn l no np">buildSnackbar({ isclosed: true });</span></pre><p id="9e9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在运行时不会中断，因为<code class="fe mp mq mr ms b">status</code>对象没有<code class="fe mp mq mr ms b">isClosed</code>属性，<code class="fe mp mq mr ms b">undefined</code>对象是一个<code class="fe mp mq mr ms b">falsy</code>值，所以会跳过if条件，不调用<code class="fe mp mq mr ms b">openSnackbar</code>函数。没有运行时错误。但很可能它的行为会与预期的不同。</p><p id="3343" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Typescript中，编译器会给出一些提示，使其正常工作。首先，它会显示以下错误:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="6469" class="nl ln it ms b gy nm nn l no np">// Argument of type '{ isclosed: boolean; }' is not assignable to<br/>// parameter of type 'SnackbarStatus'.</span></pre><p id="60f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向下转换的<code class="fe mp mq mr ms b">isclosed</code>不能赋给该类型。那里没有定义。这是让你改正代码的第一个提示。</p><p id="3093" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个更好:</p><pre class="kq kr ks kt gt nh ms ni nj aw nk bi"><span id="20fb" class="nl ln it ms b gy nm nn l no np">// Object literal may only specify known properties,<br/>// but 'isclosed' does not exist in type 'SnackbarStatus'.<br/>// Did you mean to write 'isClosed'?</span></pre><p id="a884" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它确切地告诉了您可能需要做的事情:将<code class="fe mp mq mr ms b">isclosed</code>重命名为<code class="fe mp mq mr ms b">isClosed</code>。</p><p id="b956" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以谈论很多关于工具的事情，我认为这是主要部分。</p><p id="9f3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我建议学习更多这方面的知识，只是用Typescript编码，并与编译器“对话”。阅读错误。玩悬停。请参阅自动完成功能。理解方法签名。这确实是一种高效的编码方式。</p><h1 id="bc89" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">提示和学习</h1><p id="7ea0" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">随着文章接近尾声，我想添加最后的想法、学习和技巧，以帮助您学习Typescript或在项目中应用它。</p><ul class=""><li id="894f" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">真正阅读类型错误:这将帮助您更好地理解问题和类型。</li><li id="2b9d" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><code class="fe mp mq mr ms b">strictNullChecks</code>和<code class="fe mp mq mr ms b">noImplicitAny</code>对于发现bug非常有帮助。请尽快在您的项目中启用此功能。使用<code class="fe mp mq mr ms b">strictNullChecks</code>来防止“未定义不是对象”式的运行时错误。使用<code class="fe mp mq mr ms b">noImplicitAny</code>键入源代码，为编译器提供更多类型信息。</li><li id="5230" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">连同这些编译器的配置，我总是建议对你的类型非常精确。主要是像API响应那样只在运行时出现的值。正确性对于在编译时捕捉尽可能多的bug非常重要。</li><li id="3377" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">理解运行时和编译时的区别:类型只影响编译类型。它运行类型检查器，然后编译成Javascript。Javascript源代码不使用任何类型的引用或类型操作。</li><li id="51a5" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">了解实用程序类型。我们更具体地讨论了编译时不变性中的<code class="fe mp mq mr ms b">Readonly</code>，但是Typescript有一个类似<code class="fe mp mq mr ms b">Required</code>、<code class="fe mp mq mr ms b">Pick</code>以及更多的助手。</li><li id="8d1c" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">如果可能，最好让编译器为您推断类型。大多数类型和返回类型都是多余的。Typescript编译器在这个主题中非常聪明。如果不可能，您总是可以添加类型注释。让最后一个选项的类型断言。</li><li id="4fdc" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">在编写代码时，看一下工具。IDE中提供的工具设计令人惊叹。智能感知和类型检查提供了非常好的体验。</li></ul><h1 id="990b" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">资源</h1><p id="0de3" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我编的(双关非常有意！)帮助您学习更多关于编程语言、类型系统和类型心智模型的资源。</p><p id="501e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，如果你觉得这篇文章中的例子有用，我把它们都添加到了这个库中:<a class="ae ko" href="https://github.com/leandrotk/thinking-in-types" rel="noopener ugc nofollow" target="_blank">在类型中思考</a>。这样你就可以叉着玩了。</p><h1 id="7b1a" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">类型系统</h1><ul class=""><li id="8b2b" class="mt mu it js b jt mk jx ml kb nr kf ns kj nt kn my mz na nb bi translated"><a class="ae ko" href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html" rel="noopener ugc nofollow" target="_blank">类型兼容性</a></li><li id="00d6" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://medium.com/@thejameskyle/type-systems-structural-vs-nominal-typing-explained-56511dd969f4" rel="noopener">类型系统:结构与名义类型解释</a></li><li id="64ec" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://yakovfain.com/2018/07/11/learning-typescript-structural-vs-nominal-typing-system/" rel="noopener ugc nofollow" target="_blank">学习打字稿:结构与名义打字系统</a></li><li id="0311" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=GqmsQeSzMdw&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">约束解放，自由约束——鲁纳·比雅纳松</a></li><li id="1585" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://www.no.lol/2019-12-27-type-narrowing/" rel="noopener ugc nofollow" target="_blank">在TypeScript中键入缩小</a></li><li id="2c6b" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://2ality.com/2020/06/type-guards-assertion-functions-typescript.html" rel="noopener ugc nofollow" target="_blank">类型脚本:通过类型守卫和断言函数缩小类型</a></li><li id="4331" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://www.goodreads.com/book/show/48920810-programming-with-types" rel="noopener ugc nofollow" target="_blank">编程用类型书</a></li><li id="4ed5" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">有效的打字稿:62种改善你的打字本的具体方法</li><li id="e58a" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://leandrotk.github.io/tk/2020/05/typescript-learnings-interesting-types/index.html" rel="noopener ugc nofollow" target="_blank">打字稿学习:有趣的类型</a></li></ul><h1 id="0588" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">工具和开发人员体验</h1><ul class=""><li id="7884" class="mt mu it js b jt mk jx ml kb nr kf ns kj nt kn my mz na nb bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=fnTEZk-oECM" rel="noopener ugc nofollow" target="_blank">先进的规模化打字工具</a></li><li id="91f5" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=4C4wCGcsiT0" rel="noopener ugc nofollow" target="_blank">类型系统&amp;道具设计</a></li><li id="e8ee" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=wSdV1M7n4gQ" rel="noopener ugc nofollow" target="_blank">安德斯·海尔斯伯格论现代编译器建设</a></li><li id="d474" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://www.youtube.com/watch?v=f6TCB61fDwY" rel="noopener ugc nofollow" target="_blank">作者安德斯·海尔斯伯格讲解的Typescript编译器</a></li></ul><h1 id="82fd" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">编译时间与运行时间</h1><ul class=""><li id="aa4e" class="mt mu it js b jt mk jx ml kb nr kf ns kj nt kn my mz na nb bi translated"><a class="ae ko" href="https://stackoverflow.com/questions/846103/runtime-vs-compile-time" rel="noopener ugc nofollow" target="_blank">编译时间与运行时间</a></li><li id="15b6" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://stackoverflow.com/questions/9471837/what-is-the-difference-between-run-time-error-and-compiler-error" rel="noopener ugc nofollow" target="_blank">编译错误vs运行时错误</a></li><li id="af93" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://stackoverflow.com/a/51132333/3159162" rel="noopener ugc nofollow" target="_blank">值空间和类型空间</a></li><li id="9ffb" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://www.typescriptlang.org/play" rel="noopener ugc nofollow" target="_blank">一个游乐场工具，用来玩Typescript并查看Javascript输出</a></li></ul><h1 id="4fff" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">最佳实践</h1><ul class=""><li id="3e93" class="mt mu it js b jt mk jx ml kb nr kf ns kj nt kn my mz na nb bi translated"><a class="ae ko" href="https://engineering.zalando.com/posts/2019/02/typescript-best-practices.html" rel="noopener ugc nofollow" target="_blank">打字稿最佳实践</a></li><li id="e09f" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><a class="ae ko" href="https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html" rel="noopener ugc nofollow" target="_blank">一般类型的注意事项</a></li></ul></div></div>    
</body>
</html>