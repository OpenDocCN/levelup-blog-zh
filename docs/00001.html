<html>
<head>
<title>Implementing Your Own Transactions with MVCC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实施您自己与MVCC的交易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-your-own-transactions-with-mvcc-bba11cab8e70?source=collection_archive---------0-----------------------#2015-12-20">https://levelup.gitconnected.com/implementing-your-own-transactions-with-mvcc-bba11cab8e70?source=collection_archive---------0-----------------------#2015-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/be3f086e55107e9a29ebb785f5ba989e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8K9BuK4fzIWUARjWb1C6rw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@killerfvith?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alex wong </a>在<a class="ae kc" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="948b" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><ol class=""><li id="6e29" class="lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><em class="lt">什么是MVCC？</em>提供总体概述。</li><li id="fc41" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">什么是隔离？</em>更详细地介绍了我们提到交易时的真正含义。</li><li id="fc8f" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">术语</em>设置一些常用词和基本概念。</li><li id="32f8" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">事务id</em>解释了我们可以生成唯一事务id的不同方式。</li><li id="b9f8" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">是时候深入研究了</em>直接跳到代码示例。</li><li id="e19e" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">记录可见性和锁定</em>解释了MVCC的核心概念，它允许记录具有条件可见性。</li><li id="af64" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">添加记录。</em></li><li id="6617" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">删除记录。</em></li><li id="6e68" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated">更新记录。</li><li id="7df2" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">提交更改</em>将所有累积的更改作为原子操作应用。</li><li id="d600" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">回滚更改</em>将所有累积的更改恢复为原子操作。</li><li id="eb40" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><em class="lt">清空或回收空间</em>讨论了如何清理所有那些僵尸记录。</li></ol><h1 id="c687" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是MVCC？</h1><p id="c7f4" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">MVCC ( <a class="ae kc" href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" rel="noopener ugc nofollow" target="_blank">多版本并发控制</a>)是一种简单而有效的方法来实现管理一组事物的任何应用程序的事务隔离。我们通常认为这些东西是数据库记录，因为它们实际上可以是任何东西。</p><p id="bc7d" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">MVCC是实现最广泛的并发控制算法之一，因为读取不会阻塞其他读取，写入也不会阻塞其他读取或写入。这意味着我们可以安全并发地让许多客户端同时读写，而不会互相阻塞。我将在后面解释一些值得注意的具体案例。</p><h1 id="a6e6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">什么是隔离？</strong></h1><p id="23a5" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">隔离(I from <a class="ae kc" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID </a>)确保当客户端开始一个事务时，它看到的数据总是相同的。如果其他事务正在修改数据，则引发。</p><p id="554e" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">如果另一笔交易…</p><ul class=""><li id="56da" class="lb lc iq ld b le mo lg mp li mt lk mu lm mv lo mw lq lr ls bi translated"><strong class="ld ir">增加一条记录</strong>:它将<em class="lt">而不是</em>对你可见。</li><li id="1d93" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo mw lq lr ls bi translated"><strong class="ld ir">删除一条记录</strong>:它将<em class="lt">保持</em>可见。</li><li id="ff2f" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo mw lq lr ls bi translated"><strong class="ld ir">修改一条记录</strong>:您将看到交易开始时的版本。</li></ul><p id="6768" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">这些规则受制于一些边缘情况，称为<a class="ae kc" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Read_phenomena" rel="noopener ugc nofollow" target="_blank">异常</a>。我现在不讨论这些。然而，他们在<a class="ae kc" href="https://medium.com/@elliotchance/sql-transaction-isolation-levels-explained-50d1a2f90d8f" rel="noopener">另一篇博客文章</a>中有更详细的解释。</p><p id="cb58" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">通常被忽视的是，应用于正确应用程序的事务可以；</p><ul class=""><li id="1382" class="lb lc iq ld b le mo lg mp li mt lk mu lm mv lo mw lq lr ls bi translated"><strong class="ld ir">减轻阻塞</strong>如果您以前依赖于简单地锁定整个数据库/集合，直到每个修改完成后再继续。</li><li id="bce2" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo mw lq lr ls bi translated"><strong class="ld ir">防止出现读取问题</strong>如果您的应用程序因两次读取相同的数据而意外获得两个不同的答案而受到影响。</li><li id="4668" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo mw lq lr ls bi translated"><strong class="ld ir">提供耐用性</strong>。任何时候，如果你改变了主意，你都可以放弃这些改变，而不需要你自己明确地撤销所有的改变。</li></ul><h1 id="d099" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">术语</strong></h1><p id="f42e" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">一个<em class="lt">记录</em>是一个单一的实体。这最好解释为数据库记录。它也可以是一个文件，一个JSON对象，任何封装了数据原子单元的东西。这里最重要的是，记录不能被两个独立的客户/事务同时修改。如果你有一个复杂的数据结构，你需要确保你定义的记录没有封装太多。</p><p id="305f" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">一个<em class="lt">集合</em>是记录的集合。这就像数据库中的一个表。这里重要的是，只要每个记录共享相同的事务id，事务就不会孤立于单个集合。</p><p id="b032" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">一个<em class="lt">交易ID </em>(也称为<em class="lt"> XID </em>)是交易的唯一编号。在同一事务下修改的所有记录都可以作为一个原子操作保存或回滚，这是我们最终想要的。</p><h1 id="8c0c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">交易id</strong></h1><p id="320a" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">我们可以使用三种交易ID编号系统:</p><ol class=""><li id="402f" class="lb lc iq ld b le mo lg mp li mt lk mu lm mv lo lp lq lr ls bi translated">一个递增的数字。在交易开始之前(在任何变化发生之前是重要的，即使没有变化)。这是所有记录更改的事务ID。保存或丢弃更改并不重要，相同的事务ID永远不会被再次使用，因此它必须是原子的。同样重要的是，当应用程序重新启动时，必须保留该值，以防止事务id被重用。</li><li id="c835" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated">一个时间戳。我们不需要维护一个原子计数器。这有一个额外的好处，允许我们将集合恢复到某个时间点。有一个警告:如果时间戳没有足够高的分辨率(假设您使用了整秒),开始时彼此非常接近的事务可能会共享相同的事务ID，可怕的事情将会发生…</li><li id="d664" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><strong class="ld ir">自定义交易ID实现</strong>。在特殊情况下，您使用分布式数据库，或者有上述两种类型无法满足的其他需求。这可能包括基于UUID的算法，甚至可能不是一个严格的数字。</li></ol><p id="1c9b" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">第2项和第3项都应该有自己的博客帖子，所以我不会在这里谈论它们。我将只讨论使用递增计数器的最简单实现的机制。</p><h1 id="d6fb" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">是时候潜水了</strong></h1><p id="6c9d" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">我将提供Python中的代码示例。完整的示例程序可在本要点中<a class="ae kc" href="https://gist.github.com/elliotchance/d169e39f5d4d056a9138" rel="noopener ugc nofollow" target="_blank">获得。但是我会在下面解释每一块。</a></p><p id="f695" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">简而言之，我们需要的是下一个事务ID和当前活动事务的数组(或<a class="ae kc" href="https://en.wikipedia.org/wiki/Set_(mathematics)" rel="noopener ugc nofollow" target="_blank">集合</a>)来产生新的事务:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="247d" class="ng ke iq nc b gy nh ni l nj nk">next_xid = 1<br/>active_xids = set()<br/>records = []</span><span id="8184" class="ng ke iq nc b gy nl ni l nj nk">def new_transaction():<br/>    global next_xid<br/>    next_xid += 1<br/>    active_xids.add(next_xid)<br/>    return Transaction(next_xid)</span><span id="4f5a" class="ng ke iq nc b gy nl ni l nj nk">class Transaction:<br/>    def __init__(self, xid):<br/>        self.xid = xid<br/>        self.rollback_actions = []</span></pre></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="2289" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">接下来，我们需要向每个记录添加两条独立的信息。叫做<em class="lt">创造了XID </em>和<em class="lt">过期了XID </em>。两者都代表一个事务ID，但并不总是需要有值。每个场景都有更详细的解释。</p><p id="bc17" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">最好将这些直接与唱片本身存储在一起。然而，这并不总是可能的，所以只要您是唯一一个修改数据以保持一致性的人，您就可以在外部的某个地方维护它们。</p><h1 id="07a0" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">记录可见性和锁定</strong></h1><p id="126c" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">最终，这就是MVCC的总结:</p><blockquote class="nt nu nv"><p id="f86c" class="lz ma lt ld b le mo mb mc lg mp md me nw mq mg mh nx mr mj mk ny ms mm mn lo ij bi translated">行的可见性取决于谁在看它。</p></blockquote><p id="782c" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">如果从事务的角度来看每一行<em class="lt">可见</em>，则必须对其进行测试:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="a6d6" class="ng ke iq nc b gy nh ni l nj nk">#class Transaction:<br/>    def record_is_visible(self, record):<br/>        # The record was created in active transaction that is not<br/>        # our own.<br/>        if record['created_xid'] in active_xids and \<br/>            record['created_xid'] != self.xid:<br/>            return False</span><span id="5688" class="ng ke iq nc b gy nl ni l nj nk">        # The record is expired or and no transaction holds it that<br/>        # is our own.<br/>        if record['expired_xid'] != 0 and \<br/>            (record['expired_xid'] not in active_xids or \<br/>            record['expired_xid'] == self.xid):<br/>            return False</span><span id="1a95" class="ng ke iq nc b gy nl ni l nj nk">        return True</span></pre><p id="7346" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">此外，我们之前讨论过，并发事务不能对同一记录进行修改。如果发生这种情况，有两种方法可以处理:</p><ol class=""><li id="b41c" class="lb lc iq ld b le mo lg mp li mt lk mu lm mv lo lp lq lr ls bi translated"><strong class="ld ir">中止并回滚</strong>试图进行最近更改的事务。您可能还希望将错误传播回原始客户端。</li><li id="54e9" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><strong class="ld ir">【阻塞】</strong>等待第二个事务，直到该记录可用。这对于性能和潜在的重新读取错误有一些特殊的挑战。</li></ol><p id="b5d6" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">最安全和最容易的是第一选择——所以这就是我在本教程中要使用的。当我们需要修改记录时，我们需要检查它是否被另一个事务锁定，如下所示:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="8c83" class="ng ke iq nc b gy nh ni l nj nk">#class Transaction:<br/>    def row_is_locked(self, record):<br/>        return record['expired_xid'] != 0 and \<br/>            row['expired_xid'] in active_xids</span></pre><h1 id="5a1c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">添加记录</strong></h1><p id="4d1a" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">这是一个简单的问题。我们将<code class="fe nz oa ob nc b">created_xid</code>设置为当前事务ID，将<code class="fe nz oa ob nc b">expired_xid</code>设置为<code class="fe nz oa ob nc b">0</code>:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="6eda" class="ng ke iq nc b gy nh ni l nj nk">#class Transaction:<br/>    def add_record(self, record):<br/>        record['created_xid'] = self.xid<br/>        record['expired_xid'] = 0<br/>        self.rollback_actions.append(["delete", len(records)])<br/>        records.append(record)</span></pre><p id="b25a" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">稍后将解释<code class="fe nz oa ob nc b">rollback_actions</code>。</p><h1 id="8e5d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">删除记录</strong></h1><p id="cfec" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">有两种可能性:</p><ol class=""><li id="9060" class="lb lc iq ld b le mo lg mp li mt lk mu lm mv lo lp lq lr ls bi translated"><code class="fe nz oa ob nc b">expired_xid</code>是<code class="fe nz oa ob nc b">0</code>，表示该记录从未被任何人删除过。因此，通过将<code class="fe nz oa ob nc b">expired_xid</code>设置为当前事务ID，我们将其标记为已删除。</li><li id="e44a" class="lb lc iq ld b le lu lg lv li lw lk lx lm ly lo lp lq lr ls bi translated"><code class="fe nz oa ob nc b">expired_xid</code>不是<code class="fe nz oa ob nc b">0</code> <em class="lt">和</em> <code class="fe nz oa ob nc b">expired_xid</code>是主动事务。该记录已被另一个活动事务删除，因此我们无法触及它。</li></ol><p id="ee47" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">由于正常的可见性约束，<code class="fe nz oa ob nc b">expired_xid</code>不是活动事务的第三种情况是不可能的。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="36d2" class="ng ke iq nc b gy nh ni l nj nk">#class Transaction:<br/>    def delete_record(self, id):<br/>        for i, record in enumerate(records):<br/>            if self.record_is_visible(record) and \<br/>                record['id'] == id:<br/>                if self.row_is_locked(record):<br/>                    raise Error("Row locked by another transaction.")<br/>                else:<br/>                    record['expired_xid'] = self.xid<br/>                    self.rollback_actions.append(["add", i])</span></pre><p id="78ba" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">稍后将解释<code class="fe nz oa ob nc b">rollback_actions</code>。</p><h1 id="855f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">更新记录</strong></h1><p id="39d1" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">更新是删除旧记录和添加新记录的简单组合。这允许其他事务仍然可以查看现有记录。如果<code class="fe nz oa ob nc b">delete_record</code>失败，那么引发的异常将导致随后的<code class="fe nz oa ob nc b">add_record</code>不发生，这正是我们想要的。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="f119" class="ng ke iq nc b gy nh ni l nj nk">#class Transaction:<br/>    def update_record(self, id, name):<br/>        self.delete_record(id)<br/>        self.add_record({"id": id, "name": name})</span></pre><h1 id="6891" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">提交更改</strong></h1><p id="1a4d" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">一旦所有的修改完成，我们需要<em class="lt">提交</em>所有的修改，这样未来的客户/交易就可以看到这些新的变化。非常简单，我们只需从活动交易列表中删除我们的交易ID:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="cd57" class="ng ke iq nc b gy nh ni l nj nk">#class Transaction:<br/>    def commit(self):<br/>        active_xids.discard(self.xid)</span></pre><p id="bd0b" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">请注意，此操作具有一致的时间复杂性，它不是基于我们提交的更改数量。这使得有大量变化的长时间运行的事务成为可能，有时甚至更可取。</p><h1 id="bdc8" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">回滚更改</strong></h1><p id="13a0" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">回滚可以通过几种方式完成，一种方式是反向重放更改:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="3792" class="ng ke iq nc b gy nh ni l nj nk">#class Transaction:<br/>    def rollback(self):<br/>        for action in reversed(self.rollback_actions):<br/>            if action[0] == 'add':<br/>                records[action[1]]['expired_xid'] = 0<br/>            elif action[0] == 'delete':<br/>                records[action[1]]['expired_xid'] = self.xid</span><span id="ddc4" class="ng ke iq nc b gy nl ni l nj nk">        active_xids.discard(self.xid)</span></pre><p id="5cea" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">这对于一个应用程序来说很好，它可以保证所有的回滚操作都将被重放，并且当应用程序被强制关闭时，所有的活动事务都将被调用<code class="fe nz oa ob nc b">rollback()</code>。</p><p id="1448" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">如果您想要更高的持久性，可以从应用程序随机崩溃中恢复，您将需要将事务id存储在更持久的地方。然后，当应用程序启动时，您可以有额外的代码来检查它是否被安全关闭，并在需要时手动修复记录。因为这篇文章已经够长了，所以我不会深入讨论这个问题，但它可能会在以后的文章中解释。</p><h1 id="c022" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">吸尘或回收空间</strong></h1><p id="d2a1" class="pw-post-body-paragraph lz ma iq ld b le lf mb mc lg lh md me li mf mg mh lk mi mj mk lm ml mm mn lo ij bi translated">你可能已经注意到，这个算法实际上并没有删除数据，只是将它标记为已删除。这使得它非常适合在磁盘上保存大量记录，只需对文件进行追加/就地更新以进行修改。</p><p id="4b68" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">随着时间的推移，你可能会想要收回所有的死角。如果它在内存数据库中，您可以简单地遍历记录，并永久删除现在完全失效的记录。</p><p id="cf7b" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">如果你使用像磁盘这样的媒介，这就不那么容易了。如果您的应用程序不太复杂，您可以将所有非死行重写到一个新文件中，并在您的应用程序下切换它。有大量的解决方案并不特定于MVCC的工作方式，所以我将把它留给你。</p><p id="b3c7" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated">在任何情况下，我们也需要对行的可见性保持敏感。具有不是<code class="fe nz oa ob nc b">0</code> <em class="lt">的<code class="fe nz oa ob nc b">expired_xid</code>和不出现在活动事务中的</em>的记录是完全死行。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="a30c" class="pw-post-body-paragraph lz ma iq ld b le mo mb mc lg mp md me li mq mg mh lk mr mj mk lm ms mm mn lo ij bi translated"><em class="lt">原载于2015年12月20日</em><a class="ae kc" href="http://elliot.land/post/implementing-your-own-transactions-with-mvcc" rel="noopener ugc nofollow" target="_blank"><em class="lt">http://Elliot . land</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>