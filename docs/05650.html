<html>
<head>
<title>Unit-testing in Python: If You Do Not Test Your Code, No One Will</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的单元测试:如果你不测试你的代码，没人会测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-in-python-if-you-do-not-test-your-code-no-one-will-6504c7cda7d1?source=collection_archive---------14-----------------------#2020-09-17">https://levelup.gitconnected.com/unit-testing-in-python-if-you-do-not-test-your-code-no-one-will-6504c7cda7d1?source=collection_archive---------14-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fe95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">甚至在你写程序之前就发现错误</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a370b603fc4961d1c1eff57459968e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_ixTH5IzVRwZ2pEs.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=152459" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="ecdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python是一种多用途语言，用于一切后端。在本文中，我将教你用Python执行基本的单元测试，如何模拟模块，并确保你的代码是干净的。</p><h1 id="29d9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是单元测试？</h1><p id="3285" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">单元测试是测试代码的方法之一。其他方式包括功能测试、集成测试、回归测试等等。测试对于任何更大的代码库来说都是至关重要的，因为它让您可以快速迭代和执行更改，而不用太担心会出现什么问题。</p><p id="85cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单元测试是抽象层次上最低的测试方法。单元测试关注的是独立测试各个模块和功能<em class="mi"/>。也就是说，通过确保系统的所有部分都正常工作，你可以假设整个系统工作正常。</p><p id="f926" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然是在理想世界里。虽然单元测试非常有价值，但是整个系统不仅仅是其各个部分的总和:即使每个功能都如预期的那样工作，您仍然需要测试它们配合得有多好(这超出了本文的范围)。</p><h1 id="7cd9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">单元测试与TDD有什么关系？</h1><p id="8bbb" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">单元测试是TDD的基础之一。TDD代表测试驱动开发，是一种生产高质量软件的方法。本质上，这一切都归结为这些:</p><ol class=""><li id="cedf" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated">先写测试。考虑系统的不同部分如何独立工作，并编写测试来验证它们的预期行为。您的测试<strong class="js iu">肯定</strong>会失败，因为您还没有编写任何实际的代码。</li><li id="8899" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">编写足够通过测试的代码。</li><li id="aae7" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">重构你刚刚写的东西。</li><li id="4c4d" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">转到步骤1。</li></ol><p id="f726" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！整个周期需要几分钟，但是这个简单的技术将确保你的系统(1)按照规范工作,( 2)是可测试的。但是要开始使用TDD，您需要首先掌握基本的单元测试。</p><h1 id="1188" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe mx my mz na b">unittest</code>模块</h1><p id="16ea" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">Python中的单元测试可以通过<code class="fe mx my mz na b">unittest</code>模块开箱即用。我们将通过开发我们自己的<em class="mi">阶乘</em>函数来学习单元测试。首先，打开一个新的Python文件，然后编写以下代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="396c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第1行，您可以注意到导入的<code class="fe mx my mz na b">unittest</code>模块。在第4-6行，我们通过扩展<code class="fe mx my mz na b">TestCase</code>类定义了一个<em class="mi">测试用例</em>。在它里面，我们目前只有一个测试，<code class="fe mx my mz na b">test_something</code>。测试以<code class="fe mx my mz na b">test_</code>为前缀是很重要的，这样测试运行人员就可以找到它们。最后，在第9-10行，我们执行测试。如果您现在尝试运行此文件，测试将会失败:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5f67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为在第6行我们断言<code class="fe mx my mz na b">True</code>和<code class="fe mx my mz na b">False</code>相等，这显然是错误的。让我们改变它来测试我们的(不成文！)功能:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="037e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你现在运行这个，它仍然会失败，因为我们还没有写<code class="fe mx my mz na b">factorial</code>函数。让我们通过这个测试:</p><pre class="kp kq kr ks gt nd na ne nf aw ng bi"><span id="8507" class="nh lg it na b gy ni nj l nk nl">def factorial(num): <br/>    return 6</span></pre><p id="c2bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这在数学上不合理，但这使我们的测试通过了。让我们再写一些测试:</p><pre class="kp kq kr ks gt nd na ne nf aw ng bi"><span id="e06c" class="nh lg it na b gy ni nj l nk nl">def test_factorial(self): <br/>    self.assertEqual(factorial(1), 1) <br/>    self.assertEqual(factorial(2), 2) <br/>    self.assertEqual(factorial(3), 6) <br/>    self.assertEqual(factorial(10), 3628800)</span></pre><p id="6e8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查测试现在是否失败(因为<code class="fe mx my mz na b">factorial</code>总是返回6 ),并对阶乘函数进行修改:</p><pre class="kp kq kr ks gt nd na ne nf aw ng bi"><span id="b68f" class="nh lg it na b gy ni nj l nk nl">def factorial(num): <br/>    if num == 1: <br/>        return 1 <br/>    return num * factorial(num - 1)</span></pre><p id="9743" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你运行这个，测试通过:</p><pre class="kp kq kr ks gt nd na ne nf aw ng bi"><span id="49e7" class="nh lg it na b gy ni nj l nk nl">Ran 1 test in 0.002s OK</span></pre><p id="ac8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们后退一步，理解我们刚刚做了什么。</p><h1 id="262a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">断言</h1><p id="0f8a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当我们编写测试时，我们想要测试一些东西。如果某个东西相等或不相等，如果一个函数抛出异常，如果一个方法用某些参数调用，等等。这种检查被称为<em class="mi">断言</em>。断言是为了代码正常工作而总是被认为是正确的事情。</p><p id="2f64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你刚才看到的一个断言是不是<code class="fe mx my mz na b">assertEqual</code>。它检查传入的两个变量是否相等。<code class="fe mx my mz na b">assertEqual</code>通过<code class="fe mx my mz na b">self</code>可用，由<code class="fe mx my mz na b">TestCase</code>父类提供。以下是一些您会发现有用的常见断言:</p><ul class=""><li id="e014" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assertEqual(x, y)/assertNotEqual(x, y)</code></li><li id="3aaa" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assertTrue(x)/assertFalse(x)</code></li><li id="e6ee" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assertIs(x, y)</code></li><li id="896f" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assertIsNone(x)</code></li><li id="6753" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assertIn(x, y)</code></li><li id="0e4a" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assertIsInstance(x, y)/assertNotIsInstance(x, y)</code></li><li id="61e9" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assertRaises(exc, fun, *args, **kwargs)</code></li><li id="4807" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assertGreater(x, y)/assertLess(x, y)/assertGreaterEqual(x, y)/assertLessEqual(x, y)</code></li></ul><p id="0ee9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中一些可以使用上下文管理器，比如<code class="fe mx my mz na b">assertRaises</code>。这使得代码更容易阅读:</p><pre class="kp kq kr ks gt nd na ne nf aw ng bi"><span id="186a" class="nh lg it na b gy ni nj l nk nl">with self.assertRaises(Exception):<br/>    do_something_that_throws("please")</span></pre><p id="7cd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这些断言，您几乎可以测试任何东西！</p><h1 id="8219" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">嘲弄的</h1><p id="830d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">回想一下，单元测试是在<em class="mi">隔离</em>中测试系统的各个部分。但是，我们设计的系统从来不会出现这种情况。不同的部分依赖于其他部分，为了使测试成为可能，有时您需要模拟它们。例如，如果您正在测试一个HTTP响应解析器的行为，那么没有必要执行一个实际的HTTP响应:您所需要做的只是模拟它。</p><p id="e38d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，模仿是一种抽象软件模块实现的方法，这些模块与你测试的行为无关。此外，您可以断言是否调用了mock，调用了多少次，以及向它提供了什么参数。毫无疑问，这些额外的断言将使您的测试更加健壮。</p><p id="b0d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python中的模仿也可以通过<code class="fe mx my mz na b">unittest</code>模块获得。让我们从一个简单的例子开始。假设您编写了一个调用所提供回调的函数:</p><pre class="kp kq kr ks gt nd na ne nf aw ng bi"><span id="e22f" class="nh lg it na b gy ni nj l nk nl">def call_this_function(func): <br/>    func()</span></pre><p id="42ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要测试它，你只需要通过一个<code class="fe mx my mz na b">MagicMock</code>(可通过<code class="fe mx my mz na b">unittest.mock</code>):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1dd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mx my mz na b">MagicMock</code>是一种特殊类型的物体。你可以调用它本身，调用你能想到的任何方法它都不会抛出。相反，它会记住所有的调用，并通过断言提供给你。注意，在这种情况下，断言是在<code class="fe mx my mz na b">mock</code>对象上调用的，而不是在<code class="fe mx my mz na b">self</code>上。下面是一些可用于模拟对象的断言:</p><ul class=""><li id="1349" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assert_called</code></li><li id="c116" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assert_called_once</code></li><li id="13b8" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assert_called_with</code></li><li id="1de2" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assert_called_once_with</code></li><li id="acac" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn nm mp mq mr bi translated"><code class="fe mx my mz na b">assert_not_called</code></li></ul><h1 id="d097" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">嘲弄进口</h1><p id="3d49" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有时候，当你在测试一个类的时候，你需要模拟一个导入其中的函数或者类。考虑这个例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，为了测试这段代码，您想要模拟<code class="fe mx my mz na b">api_action</code>函数。这实际上很容易用<code class="fe mx my mz na b">patch</code>装饰器(可从<code class="fe mx my mz na b">unittest.mock</code>获得)来完成:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="44a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mx my mz na b">patch</code>装饰器被应用到我们正在使用的测试函数中。它接受模拟模块的路径作为参数。这里有一个非常重要的注意事项:您指定相对于测试代码的路径。例如，<code class="fe mx my mz na b">main.py</code>文件从<code class="fe mx my mz na b">some_library</code>导入了<code class="fe mx my mz na b">api_action</code>函数。然后，我们将<code class="fe mx my mz na b">main</code>模块导入到测试文件中。这意味着我们模仿了在<code class="fe mx my mz na b">main</code>内部导入的<code class="fe mx my mz na b">api_action</code>函数，因此有了<code class="fe mx my mz na b">'main.api_action'</code>路径。如果我们要写<code class="fe mx my mz na b">'some_library.api_action'</code>，这就不行了。我们还指定了<code class="fe mx my mz na b">side_effect</code>参数，它本质上是mock将返回的返回值。然后，模拟对象作为参数传递给测试函数，这样我们就可以断言它。我们断言(1)返回值被转发,( 2)在正确的端点上调用了<code class="fe mx my mz na b">api_action</code>。</p><h1 id="a510" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结束语</h1><p id="155f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">感谢你阅读这篇文章，我希望你喜欢它。请在评论中告诉我你用Python测试的经历！</p></div></div>    
</body>
</html>