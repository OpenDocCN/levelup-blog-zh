<html>
<head>
<title>Use these 3 proven techniques to improve your unit tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这三种成熟的技术来改进你的单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/better-unit-testing-practices-for-error-free-code-be7bdb56b86f?source=collection_archive---------4-----------------------#2020-01-25">https://levelup.gitconnected.com/better-unit-testing-practices-for-error-free-code-be7bdb56b86f?source=collection_archive---------4-----------------------#2020-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/01dfdf536d897b185ef0540d84ea87fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DM9mqU10Y0y2O92K"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">当送货人踩下踏板时，披萨就送到了。[图片由<a class="ae kf" href="https://unsplash.com/@kaip?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯皮尔格</a><a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">】</a></figcaption></figure><p id="3c2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们开发一个新的软件特性或故事时，错误处理往往是事后才想到的——或者更糟，当碰巧发现一个bug时。这会导致许多边缘情况和错误条件被忽略。结果？一款比奶酪刨丝器还多孔的发布产品。</p><blockquote class="le"><p id="0c7a" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">但是，如果有一种方法可以从一开始就测试错误处理，并确保几乎所有的错误条件都被覆盖，那会怎么样呢？</p></blockquote><p id="ca69" class="pw-post-body-paragraph kg kh it ki b kj lo kl km kn lp kp kq kr lq kt ku kv lr kx ky kz ls lb lc ld im bi translated">在本文中，我将介绍三种实践，它们将使您的总体测试策略更加有效。</p><p id="8eab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特别是，你会发现你的测试开始<a class="ae kf" href="https://codeburst.io/code-coverage-vs-test-coverage-c9afb261e902" rel="noopener" target="_blank">强调需求覆盖</a>和错误处理，这将使你的代码变得更加严格——甚至防弹。</p><p id="50b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近在总部位于伦敦的FinTech先锋公司<a class="ae kf" href="https://11fs.com/" rel="noopener ugc nofollow" target="_blank"> 11:FS </a>尝试了这些和其他自动化测试技术，目前已经看到了很好的结果。我参与了他们核心银行服务的架构和开发，其中代码质量显然是最重要的。</p><p id="ea0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，在我们开始之前，程序员联盟规定我们必须有一个基于比萨饼的例子，所以开始吧:</p><p id="637c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🍕您正在为一家披萨外卖初创公司创建订购系统，该公司由屡获殊荣的企业家Pete创立。为了简单起见，Pete只提供一种三种尺寸的披萨(坏消息是，披萨里有凤尾鱼——这是我们可以改进的地方)。</p><p id="e423" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子也简单地使用了awesome <a class="ae kf" href="http://www.scalatest.org/" rel="noopener ugc nofollow" target="_blank"> ScalaTest </a>，但是同样的原则也适用，不管你喜欢的语言和测试框架是什么。</p><p id="f250" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，第一次练习…</p><h1 id="cf85" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">1.将您的测试面向业务领域，而不是代码</h1><p id="74d6" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">这是一个很容易立即开始做的事情，它将对你的测试产生深远的影响。当我们编写单元测试时，我们倾向于完全沉浸在代码中；因此，测试应该在代码的上下文中编写，而不是在业务需求的上下文中。请这样想:</p><ul class=""><li id="985a" class="mw mx it ki b kj kk kn ko kr my kv mz kz na ld nb nc nd ne bi translated"><strong class="ki iu">需求</strong> =你正在解决的问题</li><li id="96d5" class="mw mx it ki b kj nf kn ng kr nh kv ni kz nj ld nb nc nd ne bi translated"><strong class="ki iu">代码</strong> =解决方案</li></ul><p id="8ca2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你的测试集中在代码上，很容易忽略真正的目标。所以…</p><blockquote class="nk nl nm"><p id="94e1" class="kg kh nn ki b kj kk kl km kn ko kp kq no ks kt ku np kw kx ky nq la lb lc ld im bi translated">相反，把你的测试集中在用户故事和业务领域上</p></blockquote><p id="8002" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，对于比萨饼交付功能的第一口，测试中的系统(或SUT)最初看起来像这样:</p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f718" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是第一个测试:</p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a2eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试给<code class="fe nx ny nz oa b">amounts</code>分配一系列<code class="fe nx ny nz oa b">BigDecimal</code>值，将它们传递给<code class="fe nx ny nz oa b">calculateTotal</code>，然后断言结果。在进行过程中，您还需要为每个额外的函数编写一个类似的测试。</p><p id="746a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">乍一看，该测试似乎…好吧…当然，它是在测试<code class="fe nx ny nz oa b">calculateTotal</code>函数，并断言给定一个累加的金额列表，它会返回正确的结果。我们还能从单元测试中得到什么呢？</p><p id="0400" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事实证明，相当多！</p><p id="5cf8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题是测试是从被测试的函数中诞生的；因此，它只能证明该功能在技术上是正确的，而不能证明它满足了特定的要求。如果您想要确保您的所有用户故事都在一系列场景中得到完全实现和测试——顺便说一下，这是一个好主意——需要几个跳跃才能将上面的测试追溯到它的原始故事。</p><p id="2867" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">😕所以(采用教师的口吻)如果你不知道哪些测试是针对哪个故事的——反过来说，哪些故事和场景是经过充分测试的——你怎么知道你已经写了足够多的测试呢？</p><p id="0daf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，让我们从头开始，从一个<a class="ae kf" href="https://medium.com/parallel-agile-blog/user-stories-are-requirements-described-from-the-business-perspective-feebe6d4d5c5" rel="noopener">用户故事</a>开始:</p><pre class="nr ns nt nu gt ob oa oc od aw oe bi"><span id="de08" class="of lu it oa b gy og oh l oi oj">As a hungry customer, I want to know the total price given the pizza items in my order.</span></pre><p id="530e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您已经可以从这一个需求中挑选出一些域对象:</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/8fd4f6f8ba6b0ee3186437b5aff7bc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmSgngIN_MYao8XKU6ttCg.jpeg"/></div></div></figure><p id="97df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以进一步完善这些域对象名称，使它们更清晰，例如用<code class="fe nx ny nz oa b">OrderItem</code>代替<code class="fe nx ny nz oa b">item</code>，但是现在让我们用它们来运行。</p><p id="977a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在测试中直接使用这些名称，因此在应用程序代码中也是如此。</p><p id="0eed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为故事是在客户/BA/SME在场的情况下形成的，所以它们将用业务语言编写；所以开发人员使用完全相同的术语是值得的。这有助于确保每个人都说同一种语言。</p><p id="4129" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，询问鲍勃这位获奖的企业家，你会发现他不仅仅计划销售披萨，他很快会将热狗、薯条和碳酸饮料加入他受人尊敬的产品线。所以一个<code class="fe nx ny nz oa b">Pizza</code>域对象是不够的——你需要一些更通用的东西，比如一个<code class="fe nx ny nz oa b">LineItem</code>。</p><p id="350c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在编写测试时，您将开始将故事分解成场景，特别是考虑可能出错的地方。</p><p id="8eaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试现在看起来像这样:</p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="707e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您已经可以看到这是如何产生一个更有意义的测试的，并且我们已经确定了一个额外的场景。</p><p id="1ee6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，主要的变化是测试标题不再指特定的代码功能，而是指用户故事和场景。</p><p id="415e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">遵循这个领域驱动的过程对代码也有积极的影响:</p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="93ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，<code class="fe nx ny nz oa b">PizzaService</code>已经消失了，至少目前是这样。当您开始实现下订单等功能时，新的服务可能会出现，但是现在，新的<code class="fe nx ny nz oa b">Order</code>类拥有计算总价所需的一切。</p><p id="2f10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，遵循<a class="ae kf" href="https://medium.com/modern-software-architecture/modern-software-architecture-1-domain-driven-design-f06fad8695f9" rel="noopener">领域驱动的</a>方法，同时<a class="ae kf" href="https://www.domainorientedtesting.com/" rel="noopener ugc nofollow" target="_blank">将您的测试面向业务领域</a>具有改善SUT设计的良好效果，同时使测试本身更加关注正在解决的实际问题。</p><p id="ecd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果您认为示例测试开始看起来有点不像单元测试，那么您是对的。这就把我们带到了第二个练习…</p><h1 id="ff3f" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">2.比起单元测试，更喜欢组件测试</h1><p id="88f6" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">组件测试类似于单元测试，但是它们覆盖了更多的代码。一个<em class="nn">组件</em>是一组紧密相关的类(在<a class="ae kf" href="http://domainorientedtesting.com/" rel="noopener ugc nofollow" target="_blank"> DOT </a>世界中，它可以包含一个“实现被测试特性的封闭系统”，例如一个完整的微服务)。</p><p id="71ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组件测试比单元测试更容易操作，也更有效。他们是测试范围的<a class="ae kf" href="https://medium.com/swlh/write-tests-at-three-levels-909561a9544b" rel="noopener">“金发女孩”级别。</a></p><p id="5c91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组件测试相对于单元测试的优势有很多，但这里有一个非常好的…</p><p id="c6ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我读过很多文章，建议开发人员保持他们的测试尽可能的小和集中，这样程序执行就不会“泄漏”到每个测试的范围之外。考虑一下这个:</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/d810f9496db939d7819ab5cc5ba35902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Ec8HOWwdKp5d_IMggaYJw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">checkOrder调用checkItem…啊哦？</figcaption></figure><p id="de0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，这个针对<code class="fe nx ny nz oa b">checkOrder()</code>的特定单元测试可以验证订单地址是否被检查，与检查项目无关。然而，指南是这样的，如果在测试过程中允许<code class="fe nx ny nz oa b">checkOrder()</code>调用<code class="fe nx ny nz oa b">checkItem()</code>，那么这就是一个不纯的单元测试，因为它执行的代码比预期的多。</p><p id="e896" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了防止这种情况，测试初始化一个<a class="ae kf" href="https://medium.com/swlh/test-automation-creating-mock-objects-using-mockito-simple-guide-d6c0e558472a" rel="noopener">模拟对象</a>并将其注入到被测试的类中。那么函数调用将命中模拟而不是“真实的”<code class="fe nx ny nz oa b">checkItem()</code>。</p><p id="1829" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建这些模拟可能很耗时，而且它们也使测试变得相当脆弱，因为测试必须了解SUT的内部工作方式。</p><blockquote class="le"><p id="184a" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">但是——讽刺的是——所有这些额外的努力<em class="om">使得测试</em><strong class="ak"><em class="om"/></strong><em class="om">效果不佳</em>。</p></blockquote><p id="ecfa" class="pw-post-body-paragraph kg kh it ki b kj lo kl km kn lp kp kq kr lq kt ku kv lr kx ky kz ls lb lc ld im bi translated">如果在代码的某个部分引入了一个bug(比方说，<code class="fe nx ny nz oa b">checkItem()</code>在被<code class="fe nx ny nz oa b">checkOrder()</code>调用时抛出一个异常)，您可能会想知道它——不管它是如何被发现的。如果它碰巧被“错误的”单元测试发现，不要担心…只要庆幸你发现了这个bug。</p><p id="bebe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(但是一定要重温一下测试，即<em class="nn">应该</em>已经发现了bug)…</p><p id="af0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">👍<strong class="ki iu">我们在这里谈论的是实用主义，而不是意识形态。</strong></p><p id="0786" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，组件测试在这里有什么帮助呢？</p><p id="b1d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为每个组件测试比一个单元测试覆盖更多的代码，你会发现你编写模拟的需求要少得多。所以你的测试变得不那么脆弱了——它们不会因为你改变了函数内部的某些东西而虚假地崩溃。</p><p id="fc70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为你没有花时间嘲笑SUT的内部结构，你的注意力并不主要在代码上；取而代之的是商业领域和故事。</p><p id="5fdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还需要编写更少的组件测试(尽管您会发现自己为每个测试编写了更多的场景——参见下一个指南)。</p><p id="d550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我写了更多关于组件测试的文章，因为它们确实是蜜蜂的膝盖:</p><div class="on oo gp gr op oq"><a href="https://codeburst.io/component-tests-vs-unit-tests-tdd-71b921d48907" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">为什么你应该写组件测试而不是单元测试</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">你的测试将不再脆弱，你的代码将变得刀枪不入🔫</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">codeburst.io</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe jz oq"/></div></div></a></div><p id="e760" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三个练习用一把整齐的防弹弓将前两个练习联系在一起:</p><h1 id="6fed" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">3.先测试，但也要先识别</h1><p id="6290" class="pw-post-body-paragraph kg kh it ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">这个想法不仅仅是“测试第一”，而且——对于每一个故事——在你开始编写测试之前就确定测试场景:</p><figure class="nr ns nt nu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pf"><img src="../Images/a3ad6c53f33da53b7d3c0a1566aad6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*smeP5petRVt4x2N724JzKg.jpeg"/></div></div></figure><p id="9a1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将场景分为快乐的和不快乐的路径，真正关注“不快乐的”。你真的想深入了解SUT是如何处理意外事件的，特别是错误、消息到达顺序错误等等。当你想到每一个的时候，把它作为一个新的“待定”场景添加到你的测试套件中；然后在实现每个测试时实现代码。</p><p id="5e3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，根据每个故事的多个场景来考虑您的测试。由于涵盖了所有的边缘情况和错误条件，您的代码将从一开始就具有内置的错误处理功能。</p><blockquote class="le"><p id="a66c" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">并且您将能够更有信心地部署到生产环境中，相信代码会如预期的那样运行。</p></blockquote><p id="c2d6" class="pw-post-body-paragraph kg kh it ki b kj lo kl km kn lp kp kq kr lq kt ku kv lr kx ky kz ls lb lc ld im bi translated">本质上，这就是你如何编写更严谨、更集中和更有目的的单元测试！</p></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><p id="8ba1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nn">如果你想更深入地探索这些单元测试技术，请查看面向领域的测试:</em></p><div class="on oo gp gr op oq"><a href="https://www.domainorientedtesting.com/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">一种简洁高效的自动化软件测试方法</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">将您的测试导向业务领域面向领域的测试(DOT)是“面向领域的”,因为一切…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">www.domainorientedtesting.com</p></div></div><div class="oz l"><div class="pn l pb pc pd oz pe jz oq"/></div></div></a></div><p id="e6e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nn">并且一定要加入LinkedIn </em>  <em class="nn">上的</em> <a class="ae kf" href="https://www.linkedin.com/groups/13804489/" rel="noopener ugc nofollow" target="_blank"> <em class="nn">讨论组。</em></a></p></div></div>    
</body>
</html>