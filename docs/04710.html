<html>
<head>
<title>Designing API’s with gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用gRPC设计API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/designing-apis-with-grpc-dd5e39df0333?source=collection_archive---------14-----------------------#2020-07-10">https://levelup.gitconnected.com/designing-apis-with-grpc-dd5e39df0333?source=collection_archive---------14-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gRPC远程过程调用是一个高性能、开源、功能丰富的RPC框架。gRPC的理想用途是用于微服务中的服务间通信，以及移动应用程序和服务器之间的通信。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/087fddb5439defaa121ec5934a8f9f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5wkgiKszKKQfNLmJnbw5g.png"/></div></div></figure><h2 id="d9f2" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">面向移动应用的gRPC】</strong></h2><p id="9fec" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">移动应用程序可以依靠gRPC来提高性能，因为它是基于HTTP/2构建的，HTTP/2具有更低的延迟，同时为CPU速度较慢的移动设备提供更高的性能。移动客户端可以利用gRPC中的流选项来节省带宽并减少与服务器的TCP连接数量，从而有助于减少CPU的使用并优化移动设备的电池。</p><h2 id="8e96" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">微服务gRPC】</strong></h2><p id="f439" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在微服务架构中，服务间的通信应该更快。gRPC使用的协议缓冲区比JSON更小、更快，并且可以有效地连接服务。默认情况下，gRPC服务器是异步的，这意味着它们不会根据请求阻塞线程，而是可以并行处理多个请求。gRPC提倡使用SSL，在SSL中，通过网络传输的所有数据都被加密，并且集成了身份验证。</p><h2 id="d3e8" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">使用Protobuf的gRPC APIs】</strong></h2><p id="dc6e" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">● gRPC使用协议缓冲区，这是一种序列化强类型结构化数据的方法</p><p id="0291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">●解析二进制格式的协议缓冲区比解析文本格式的JSON消耗更少的CPU</p><p id="da45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">●协议缓冲区有助于向后兼容，而不会影响客户端代码</p><p id="2376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">●一个简单的原型文件可以用任何语言生成大量代码</p><p id="d694" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Proto文件用于定义消息(请求和响应)、服务(RPC端点)。</p><p id="64a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的原型文件(cart.proto)是一个简单的cart操作的服务契约。</p><pre class="km kn ko kp gt lv lw lx ly aw lz bi"><span id="a30c" class="kx ky iq lw b gy ma mb l mc md"><em class="me">// The cart service definition</em></span><span id="e949" class="kx ky iq lw b gy mf mb l mc md"><em class="me">service CartService {</em></span><span id="610f" class="kx ky iq lw b gy mf mb l mc md"><em class="me">rpc createCart(CreateCartRequest) returns (CreateCartResponse);</em></span><span id="88fd" class="kx ky iq lw b gy mf mb l mc md"><em class="me">}</em></span><span id="d8b2" class="kx ky iq lw b gy mf mb l mc md"><em class="me">// The item message</em></span><span id="3cbe" class="kx ky iq lw b gy mf mb l mc md"><em class="me">message Item {</em></span><span id="410c" class="kx ky iq lw b gy mf mb l mc md"><em class="me">string id = 1;</em></span><span id="fa4a" class="kx ky iq lw b gy mf mb l mc md"><em class="me">string name = 2;</em></span><span id="e93f" class="kx ky iq lw b gy mf mb l mc md"><em class="me">}</em></span><span id="4bb1" class="kx ky iq lw b gy mf mb l mc md"><em class="me">// The request message containing Items</em></span><span id="2756" class="kx ky iq lw b gy mf mb l mc md"><em class="me">message CreateCartRequest {</em></span><span id="d6c7" class="kx ky iq lw b gy mf mb l mc md"><em class="me">repeated Item item = 1;</em></span><span id="7bac" class="kx ky iq lw b gy mf mb l mc md"><em class="me">}</em></span><span id="3cc3" class="kx ky iq lw b gy mf mb l mc md"><em class="me">// The response message containing cart id</em></span><span id="72d6" class="kx ky iq lw b gy mf mb l mc md"><em class="me">message CreateCartResponse {</em></span><span id="4c83" class="kx ky iq lw b gy mf mb l mc md"><em class="me">string cart_id = 1;</em></span><span id="174e" class="kx ky iq lw b gy mf mb l mc md"><em class="me">}</em></span></pre><p id="6fa2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的cart.proto，它包含需要在客户机和服务器之间共享的服务和消息。API服务是创建一个购物车。这些消息可以用于服务中定义的相应请求和响应。</p><h2 id="a101" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">gRPC中API的类型</strong></h2><p id="c545" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在gRPC中，API不是基于CRUD(创建/检索/更新/删除)的，每个API的设计都没有任何限制。因此gRPC不是面向资源的，而是特定于API的。我们可以将gRPC中的API大致分为一元API和流式API</p><h2 id="aef3" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">一元API</strong></h2><p id="7003" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">一元RPC调用是简单的请求-响应模型，其中客户端发送请求消息，服务器用响应消息进行响应。一旦客户端收到响应，呼叫就完成了。大多数API使用一元RPC模型。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/aa9de45c3c89373434879dfa82e8fcad.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*ktcbWaJOeb0Rvn3i4n3upA.png"/></div></div></figure><h2 id="06ab" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">流式API</strong></h2><p id="7e17" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">由于g RPC中HTTP/2的底层实现，流RPC调用是可用的。</p><p id="e2ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于HTTP/2支持多路复用，客户端和服务器可以通过单一TCP连接并行推送消息，这有助于减少数据传输的延迟。</p><p id="93aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">gRPC中有三种可用的流式API</p><p id="ef54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">●客户端流API</p><p id="6ac7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">●服务器流API</p><p id="ff20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">●双向流API</p><h2 id="a068" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">客户端流API </strong></h2><p id="98a8" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在客户端流RPC调用中，客户端向服务器发送多条消息，作为回报，服务器向客户端发送单个响应。当客户端需要向服务器发送大量数据而不期望从服务器得到响应时，可以使用客户端流API。例如，发送数据进行分析。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/ff9fe241dfb45fa8df13aee6043e1eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*Q38WJT3eSTgKj2V_L7eVnA.png"/></div></div></figure><h2 id="6d53" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">服务器流API </strong></h2><p id="526d" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在服务器流RPC调用中，客户端向服务器发送单个消息，作为回报，服务器向客户端发送多个响应。当服务器需要通过单个请求向客户端发送大量数据时，可以使用服务器流API。例如，在比赛期间发送实况比分。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/7d3090d6c7991b5657a89def30c44e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*JaydMdSsx4A0m8NEU7hSkg.png"/></div></div></figure><h2 id="73a0" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">双向流API </strong></h2><p id="8d49" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">在双向流RPC调用中，客户端和服务器彼此异步发送消息。当客户端和服务器不等待彼此发送和接收数据时，可以使用双向API。例如聊天应用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/f7e9923fb527d6d7c178229b28e46392.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*uf70VYFjhte7P8K7-9QrqA.png"/></div></div></figure><p id="63ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="me">作者:Ashwinbalaji Purusothaman <br/>流:Java </em> </strong></p></div></div>    
</body>
</html>