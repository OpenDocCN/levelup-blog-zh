<html>
<head>
<title>Tagging Jenkins Builds with Git Commit Hashes &amp; Messages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Git提交散列和消息标记Jenkins构建</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tagging-jenkins-builds-with-git-commit-hashes-messages-f11703effa5b?source=collection_archive---------2-----------------------#2021-04-22">https://levelup.gitconnected.com/tagging-jenkins-builds-with-git-commit-hashes-messages-f11703effa5b?source=collection_archive---------2-----------------------#2021-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d981a3d0270647ba30878eb8204c93ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIIV_PC6sABTueJ2Ho_Ylw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">吉特-&gt;詹金斯-&gt;码头工人</figcaption></figure><p id="2bf5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我写的是对Jenkinsfile的一个小的补充，它可以检索提交散列和消息，所以你可以用它来标记你的构建。在我的情况下，我在Octopus Deploy上标记发布，以提升生活质量。</p><p id="8457" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了提供一点背景知识，我的团队使用上面描述的CI/CD管道的设置，由Git、<a class="ae la" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>和<a class="ae la" href="https://octopus.com/" rel="noopener ugc nofollow" target="_blank"> Octopus Deploy </a>组成。Git是我们的源代码管理工具。Jenkins扮演一个中间人的角色，每当一个新的提交被推送到存储库时，它使用存储库中的Docker文件为存储库构建一个<a class="ae la" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>映像，将映像上传到注册中心，然后在Octopus Deploy中为它创建一个相应的发布。Octopus Deploy用于发布管理，可以方便地将不同版本的代码部署到不同的环境中，比如开发、试运行和生产。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/6f9a33ffc88e489d225640d0113003ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aepBkTRWsYY7aprkjvN3dg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">章鱼释放</figcaption></figure><p id="da83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种设置很好地满足了我们的需求，但是我们实现它的方式有一个问题，那就是我们的Octopus版本只标记了一个版本号，这使得很难区分它们对应于存储库中的哪些提交。例如，如果我试图将生产代码回滚到一个特定的提交，那么我必须通过尝试将提交的时间戳与发布创建时的时间戳相匹配来找出对应的v.0.0.XX发布，这也相差一分钟左右，因为它必须通过CI/CD管道。另一个同事顺便表达了对此的一些烦恼，通过在我们的Octopus版本中添加提交散列和消息，不到一个小时就解决了这个问题。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/d58eab236fb0539dc0742f228afa7a44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*qikoey3H9Gc-nbjepy1eMA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">发布现在用相应的提交来标记，所以不用再猜了！</figcaption></figure><p id="7922" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">幸运的是，Octopus有一个<a class="ae la" href="https://octopus.com/docs/octopus-rest-api/octopus-cli/create-release" rel="noopener ugc nofollow" target="_blank">选项，用于在通过CLI创建发布时指定发布说明</a>。我们在Jenkinsfile中这样做，所以现在我们只需要获取提交散列和消息。事实证明，使用我们已经安装并用于从存储库中获取新代码的<a class="ae la" href="http://plugins.jenkins.io/git/" rel="noopener ugc nofollow" target="_blank"> Git插件，我们可以将提交散列作为环境变量来获取:</a></p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="f300" class="lm ln iq li b gy lo lp l lq lr">RELEASE_NOTES = "$GIT_COMMIT"</span></pre><p id="96b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">获取额外的细节，如消息、作者、时间戳等。我们可以做到:</p><pre class="lc ld le lf gt lh li lj lk aw ll bi"><span id="89fa" class="lm ln iq li b gy lo lp l lq lr">RELEASE_NOTES = sh (script: """git log — format="medium" -1 ${GIT_COMMIT}""", returnStdout:true)</span></pre><p id="9181" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它使用提交散列作为shell脚本运行git log，并使用Jenkins的<a class="ae la" href="https://www.jenkins.io/doc/pipeline/steps/workflow-durable-task-step/#sh-shell-script" rel="noopener ugc nofollow" target="_blank"> returnStdout选项</a>将其作为字符串返回。</p><p id="2ed4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以唯一需要的改变是一个额外的变量声明，并把它作为发布说明附加到<em class="ls"> octo create-release </em>命令的末尾。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">以前</figcaption></figure><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在...之后</figcaption></figure></div></div>    
</body>
</html>