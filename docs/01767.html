<html>
<head>
<title>Where’s the Sleep Function in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的睡眠功能在哪里？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/wheres-the-sleep-function-in-javascript-69dc15d54ac8?source=collection_archive---------7-----------------------#2020-01-28">https://levelup.gitconnected.com/wheres-the-sleep-function-in-javascript-69dc15d54ac8?source=collection_archive---------7-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f62b8ed430eb66622881f8ce7b44af5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*amqh8qj6L3S9bAno"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@alexagorn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexandra Gorn </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="feb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们试图在JavaScript中搜索<code class="fe le lf lg lh b">sleep</code>函数，我们不会找到它。但是，我们可以很容易地用现有的功能制作一个。</p><h1 id="1371" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">setTimeout函数</h1><p id="6190" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">有一个<code class="fe le lf lg lh b">setTimeout</code>函数让我们在指定的毫秒数后运行代码。我们可以用它来创建我们自己的<code class="fe le lf lg lh b">sleep</code>函数。</p><p id="9d5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像大多数对时间敏感的JavaScript代码一样，它将是异步的，因为这不会阻塞运行我们程序的主线程。</p><p id="c1f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写以下代码来创建一个在指定时间后运行代码的函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c74a" class="mt lj it lh b gy mu mv l mw mx">const runLater = (delay) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    console.log('bar');<br/>  }, delay)<br/>}</span></pre><p id="1cce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们以毫秒为单位传递延迟时，<code class="fe le lf lg lh b">runLater</code>函数将显示字符串<code class="fe le lf lg lh b">'bar'</code>。</p><p id="ff70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们跑:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8caf" class="mt lj it lh b gy mu mv l mw mx">console.log('foo')<br/>runLater(100);<br/>console.log('baz')</span></pre><p id="d979" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会看到我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="dc9a" class="mt lj it lh b gy mu mv l mw mx">foo<br/>baz<br/>bar</span></pre><p id="12a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为第一行和最后一行同步代码首先运行。<code class="fe le lf lg lh b">runLater(100)</code>排队等待在第一行和最后一行运行之间的事件循环的下一次迭代中运行。</p><p id="3058" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在事件循环的下一次迭代中，<code class="fe le lf lg lh b">setTimeout</code>回调中的代码运行，这将记录<code class="fe le lf lg lh b">'baz'</code>。</p><p id="fc38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着如果我们想在回调中连续运行代码，我们必须嵌套回调。过多的回调会造成回调地狱。</p><h1 id="10c5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">承诺</h1><p id="f842" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">因此，顺序运行异步JavaScript代码的最佳方式是使用承诺。我们可以通过使用<code class="fe le lf lg lh b">Promise</code>构造函数用<code class="fe le lf lg lh b">setTimeout</code>函数创建一个承诺。</p><p id="cb51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下编写<code class="fe le lf lg lh b">sleep</code>函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="06f4" class="mt lj it lh b gy mu mv l mw mx">const sleep = (delay) =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(resolve, delay)<br/>  });<br/>}</span></pre><p id="2451" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">sleep</code>函数返回一个在<code class="fe le lf lg lh b">setTimeout</code>回调后解决的承诺，也就是在<code class="fe le lf lg lh b">delay</code>毫秒后<code class="fe le lf lg lh b">resolve</code>函数被调用。</p><p id="a5f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">承诺和<code class="fe le lf lg lh b">setTimeout</code>回调一样是异步的。它的好处是，我们可以在实现它们时按顺序运行它们。</p><p id="8bcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Fulfilled意味着调用了上面回调中的<code class="fe le lf lg lh b">resolve</code>方法。当出现错误时，也可以使用<code class="fe le lf lg lh b">reject</code>功能拒绝承诺。</p><p id="4f73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用承诺让我们链接异步代码并顺序运行它们。</p><p id="e1be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe le lf lg lh b">async</code>函数干净利落地做到这一点。为了定义一个<code class="fe le lf lg lh b">async</code>函数，我们使用如下的<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>关键字:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="70ad" class="mt lj it lh b gy mu mv l mw mx">(async ()=&gt;{<br/>  console.log('foo');<br/>  await sleep(2000);<br/>  console.log('bar');<br/>})();</span></pre><p id="bd74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们应该看到<code class="fe le lf lg lh b">'foo'</code>被记录，然后2秒后<code class="fe le lf lg lh b">'bar'</code>被记录。</p><p id="842d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将让我们在不挂起应用程序的情况下完成延时代码。</p><p id="cf6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参数中的数字2000是以毫秒为单位的，所以它将在运行下一行之前等待2秒钟。</p><p id="7aa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">await</code>告诉浏览器暂停执行下一行，直到<code class="fe le lf lg lh b">await</code>行被解析。我们可以把<code class="fe le lf lg lh b">await</code>放在任何承诺的前面，表示要等承诺解决了再继续。</p><p id="668a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以不断重复这个:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f8b9" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  console.log('foo');<br/>  await sleep(2000);<br/>  console.log('bar');<br/>  await sleep(2000);<br/>  console.log('a');<br/>  await sleep(2000);<br/>  console.log('b');<br/>})();</span></pre><p id="29b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是它变得重复。幸运的是，我们可以使用循环来消除这种重复。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/eead374ff2cf09feeffd5eeed8062a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KTlSDQUsUBdp42Bo"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁斯·马斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="40b4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">For-Await-Of循环</h1><p id="53e8" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们有一个<code class="fe le lf lg lh b">for-await-of</code>循环，它遍历可迭代对象，比如数组和类数组对象，不管它们是同步的还是异步的。</p><p id="7cf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="57dd" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const arr = ['foo', 'bar', 'a', 'b'];<br/>  for await (let a of arr) {<br/>    console.log(a);<br/>    await sleep(2000);<br/>  }<br/>})();</span></pre><p id="59a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码要干净得多，我们想循环多少次都没关系。</p><p id="8cd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管我们是否想使用循环，在我们的<code class="fe le lf lg lh b">async</code>函数中有promise代码是很重要的。</p><p id="5aee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以从一个<code class="fe le lf lg lh b">async</code>函数返回一个承诺，所以我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5a12" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const arr = ['foo', 'bar', 'a', 'b'];<br/>  for await (let a of arr) {<br/>    console.log(a);<br/>    await sleep(2000);<br/>  }<br/>  return sleep(2000);<br/>})();</span></pre><p id="2980" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了回报<code class="fe le lf lg lh b">sleep(2000)</code>的承诺。</p><p id="ef4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以给它命名，并在其他<code class="fe le lf lg lh b">async</code>功能中使用，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f249" class="mt lj it lh b gy mu mv l mw mx">const foo = async () =&gt; {<br/>  const arr = ['foo', 'bar', 'a', 'b'];<br/>  for await (let a of arr) {<br/>    console.log(a);<br/>    await sleep(2000);<br/>  }<br/>  return sleep(2000);<br/>};</span><span id="b2fe" class="mt lj it lh b gy mz mv l mw mx">(async () =&gt; {<br/>  await foo();<br/>  console.log('c');<br/>})();</span></pre><p id="fea4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这说明<code class="fe le lf lg lh b">async</code>功能是承诺。</p><h1 id="c6a7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="714e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，不像其他语言那样有<code class="fe le lf lg lh b">sleep</code>函数。然而，我们可以很容易地做出自己的选择。</p><p id="aa85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了承诺，我们可以轻松解决时间问题。它使得延时代码的执行变得清晰易读。我们可以通过使用<code class="fe le lf lg lh b">setTimeout</code>函数来编写延时的JavaScript代码。</p><p id="6962" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>语法使得读写代码变得轻而易举。</p><p id="7af9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以在其他<code class="fe le lf lg lh b">async</code>函数中调用<code class="fe le lf lg lh b">async</code>函数，因为这些类型的函数只返回承诺。</p></div></div>    
</body>
</html>