<html>
<head>
<title>3 principles to manage your objects elegantly in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java优雅地管理对象的3个原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-principles-to-manage-your-objects-elegantly-in-java-bbb56aa51401?source=collection_archive---------3-----------------------#2022-03-29">https://levelup.gitconnected.com/3-principles-to-manage-your-objects-elegantly-in-java-bbb56aa51401?source=collection_archive---------3-----------------------#2022-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3d0c5c24fefd0b1331b3c767d971c9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nFpZg8SYw_JcozxfJk5iSg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由Lisa Fotios提供</figcaption></figure><p id="4f89" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">学习使用设计模式更有效地管理您的对象</p><p id="2bb1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Java是一种面向对象的编程语言。就像它的定义一样，对象在其中扮演着巨大的角色。因此，学会正确管理对象对于Java项目的性能和成功至关重要。在本文中，我总结了3个原则和实现方法，以帮助您实现更有效的对象管理。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h2 id="2758" class="lk ll it bd lm ln lo dn lp lq lr dp ls kq lt lu lv ku lw lx ly ky lz ma mb mc bi translated">原则1:控制实例的数量</h2><p id="afd6" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">对象分配可能会消耗大量资源，如果管理不当，很快就会成为瓶颈。最重要的事情之一是确保不要在某些对象上创建过多的实例。不必要的实例会给你的程序带来巨大的时间和空间开销。在这里，我列出了一些避免创建不必要的实例的方法。</p><ol class=""><li id="37ed" class="mi mj it kh b ki kj km kn kq mk ku ml ky mm lc mn mo mp mq bi translated"><strong class="kh iu">尝试使用静态工厂方法</strong></li></ol><p id="a80e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我想澄清一下，静态工厂方法与设计模式中的工厂方法无关。什么是静态工厂方法？好吧，假设你的手机快没电了，你需要一个<code class="fe mr ms mt mu b">charger</code>。通常，我们会写<code class="fe mr ms mt mu b">Charger getMeACharger = new Charger().</code>然而，你真的想每次给手机充电都换一个新的充电器吗？大概不会。一个更好的主意是从你桌子的抽屉里拿一个充电器，并在那里挑选一个可用的充电器。在Java中，你桌子的抽屉就是工厂，挑选可用充电器的动作就是你想要的方法。为了实现这一点，我们必须使方法成为静态的，这样我们就不需要为了得到我们的<code class="fe mr ms mt mu b">charger</code>而拥有我们工厂的一个实例。在Java中，它看起来像这样:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1396" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面是一个静态工厂方法的例子。在这种情况下，我们的<code class="fe mr ms mt mu b">DeskDrawerChargerFactory</code>是工厂，我们可以从我们的工厂拿实例，而不是做传统的<code class="fe mr ms mt mu b">new</code>方法。</p><p id="7b23" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过这种方式，我们可以控制对象的总数，如果需要，我们可以调用静态工厂方法来返回一个实例，并基于该实例执行操作。许多现实世界中的应用程序，如JDBC，强制执行这样的良好实践来限制您的程序可以拥有的数据库连接数。如果允许我们根据需要创建任意数量的数据库连接，那么很有可能数据库会被请求淹没，无法正常响应。当然，还有许多其他的原因让您想使用静态工厂方法。使用这种做法允许您将所需的instance子类返回给user，这是普通构造函数无法做到的；它允许您使用更有意义的名称以获得更好的可读性。例如，假设你想要一个复数类，像<code class="fe mr ms mt mu b">ComplexNumbers.createFromXYCoordinate(double x, double u)</code>或<code class="fe mr ms mt mu b">ComplexNumbers.createFromPolarCoordinate(double distance, double angle)</code>这样的方法名似乎比<code class="fe mr ms mt mu b">ComplexNumbers c = new ComplexNumbers(x,y)</code>更好。</p><p id="2eef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">2.<strong class="kh iu">强制非实质性</strong></p><p id="812e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个想法乍听起来很疯狂:如果不允许我们实例化对象，Java是干什么用的？嗯，有些情况下你确实想要不可实现性。例如，有时您会编写util类。这些util类不包含状态/属性，因此您可以直接调用它们的静态方法来实现您想要的。有时，如果其他人不小心实例化了这样的util类，这可能是一种资源浪费，尤其是对于那些具有大量方法的巨型util类。因此，您希望确保人们无法实例化这些类。一种有效的方法是将构造函数设置为私有的。请注意，如果您没有显式实现构造函数，Java将提供一个默认的构造函数，有时人们可能会偶然调用默认的构造函数。因此，检查您的util类，并确保有一个私有构造函数。</p><p id="ff22" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">3.<strong class="kh iu">注意库中的方法</strong></p><p id="29c3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是一个棘手的问题，它严重依赖于您对代码库的了解。然而，这是相当重要的。举个简单的例子:字符串串联<code class="fe mr ms mt mu b">+</code>。在幕后，<code class="fe mr ms mt mu b">+</code>操作将创建一个StringBuilder操作符，并使用它将我们的字符串连接在一起。考虑以下程序:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="24ae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在每个循环中，将构造一个StringBuilder对象，<code class="fe mr ms mt mu b">str = str + i</code>将被大致翻译成<code class="fe mr ms mt mu b">StringBuilder builder = new StringBuilder(str); builder.append(i); str = builder.toString();</code>你看，这样，我们将有1000个内部构造的StringBuilder对象，这可能不是我们所希望的。相反，请尝试执行以下操作:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="01ee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">创建的StringBuilder的数量从1000减少到1，这个数字可能会对您的程序有所帮助。</p><p id="b5c6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">其他的例子包括<code class="fe mr ms mt mu b">String.matches</code>法。它会在你每次调用它的时候创建内部对象。假设您的服务器每秒钟运行10000次这种方法，如果您能找到替代方法，您的性能会好得多。一种方法是创建一个内部对象的静态等价对象，这样你只需要创建一次这个对象。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h2 id="9dc6" class="lk ll it bd lm ln lo dn lp lq lr dp ls kq lt lu lv ku lw lx ly ky lz ma mb mc bi translated">原则2:使实例化具有可读性和可伸缩性</h2><p id="080e" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">我这么说是什么意思？嗯，我的意思是有两件事我们需要注意。</p><ol class=""><li id="3183" class="mi mj it kh b ki kj km kn kq mk ku ml ky mm lc mn mo mp mq bi translated"><strong class="kh iu">参数过多的构造器</strong></li></ol><p id="6e1a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一个是我们应该为那些有许多构造函数参数对象使用构建器模式。</p><p id="36ee" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">考虑一下，我们正在编写一个汉堡类，它需要一个名为<code class="fe mr ms mt mu b">bun</code>的组件、一个名为<code class="fe mr ms mt mu b">meat</code>的组件和一个名为<code class="fe mr ms mt mu b">in-between </code>的组件(奶酪、生菜)。此外，我们可以允许我们的客户添加两个额外的<code class="fe mr ms mt mu b">in-between</code>，这样总共剩下5个参数。因为三个是必需的，两个是可选的，传统上我们需要提供三个构造函数:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="16f1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如你所见，随着参数数量的增长，我们必须编写越来越多的构造函数。设定者有出路。然而，设置器仍然不是那么有效。为了找到更好的解决方案，我们考虑如下的构建器模式:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6cc5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">2.<strong class="kh iu">使用依赖注入</strong></p><p id="e1be" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第二件值得一提的事情是尽可能使用依赖注入。有时，我们会有一个依赖于许多其他对象的类<code class="fe mr ms mt mu b">A</code>，比如说<code class="fe mr ms mt mu b">B, C, D, E</code>。虽然我们可以一个接一个地创造它们(<code class="fe mr ms mt mu b">B, C, D, E</code>)，但事情会很快变得不可收拾。如果<code class="fe mr ms mt mu b">B</code>也有几个依赖关系，并且它的依赖关系还有进一步的依赖关系呢？在这种情况下，为了实例化一个<code class="fe mr ms mt mu b">A</code>，我们必须实例化数百个类，我们甚至很难找出依赖路径。当我们试图模仿一些依赖类时，这在测试中尤其困难。</p><p id="05b0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">幸运的是，依赖来拯救！在这里，我不会进一步解释依赖，但要提到的是，它是一种机制，允许计算机自动注入你需要的依赖类到适当的地方。有大量的依赖注入库，我会让你通过搜索关键词来发现你最喜欢的。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><h2 id="669a" class="lk ll it bd lm ln lo dn lp lq lr dp ls kq lt lu lv ku lw lx ly ky lz ma mb mc bi translated">原则3:检查可能的参考泄漏</h2><p id="ae89" class="pw-post-body-paragraph kf kg it kh b ki md kk kl km me ko kp kq mf ks kt ku mg kw kx ky mh la lb lc im bi translated">是的，你没听错！Java中确实存在引用泄漏或内存泄漏。虽然Java为我们处理了内存管理，但是它不能处理所有的情况。如今，JVM仍然依赖引用计数作为垃圾收集或内存管理的主要机制。因此，如果我们不小心留下了一个我们不会使用的对象的引用，这将影响我们的程序，甚至会把我们带到熟悉的<code class="fe mr ms mt mu b">stackoverflow</code>！！！</p><p id="711f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设你自己正在实现一个<code class="fe mr ms mt mu b">Queue</code>类，你像这样写<code class="fe mr ms mt mu b">pop()</code>方法:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1b1d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这种情况下，我们直接返回数组中某个元素的引用，没有像<code class="fe mr ms mt mu b">data_array[index] = null;</code>那样写一些语句。然后，该数组仍将引用附加到该对象。假设您在一个非常大的数组中执行这个有问题的代码，JVM将跳过成百上千个应该被垃圾收集的对象！如果我们不能及时发现这一点，记忆很可能很快就会被填满。因此，要时刻注意潜在的引用泄漏，因为它们会对您的程序造成真正的损害。缓存是引用泄漏的一个常见位置。假设您在缓存中存储了1个对象，但它从未被命中，并且它可以在缓存中停留很长一段时间，具体取决于您的缓存驱逐算法。由于缓存仍将保留对该对象的引用，因此无法正确清理它。有时候，侦听器、回调甚至操作系统页面交换都会导致引用泄漏！</p><p id="c6f4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对抗引用/内存泄漏的一些潜在有用的实践是分析程序的内存以查看是否有任何异常，或者您可以直接进入JVM，寻找内存信息并进行堆转储(清除内存堆)。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="e2c0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是我为您总结的三个原则，可以让您更好地控制Java程序的性能和资源。没有适合所有情况的完美解决方案，但是请记住这些实践，它们可能会在一些常见的情况下帮助你。快乐学习，快乐编码！</p></div></div>    
</body>
</html>