<html>
<head>
<title>Tracking Multiple Cryptocurrency Exchanges Using a Timeseries Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用时间序列数据库跟踪多个加密货币交易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tracking-multiple-cryptocurrency-exchanges-using-a-timeseries-database-6b13cc7e8490?source=collection_archive---------8-----------------------#2021-05-25">https://levelup.gitconnected.com/tracking-multiple-cryptocurrency-exchanges-using-a-timeseries-database-6b13cc7e8490?source=collection_archive---------8-----------------------#2021-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd56" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用QuestDB通过InfluxDB线路协议接收的数据，构建一个高吞吐量的加密货币价格跟踪器，能够即时处理无序记录。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/93f7a20d07d5d0bf756af1ab4e97f8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gW0mEmx67FCEpmbO"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">尼克·崇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="afd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着比特币和其他加密货币的价格暴跌至2021年的最低水平，加密投资者在5月份目睹了1万亿美元的市值蒸发。鉴于这一资产类别的波动性，寻求在市场中导航的交易者需要来自多个交易所的快速可靠的价格数据。今年早些时候，我分享了一种通过Kafka和QuestDB实时分析加密货币价格趋势的方法。该项目调查了比特币基地API的最新价格，并计算了移动平均值，然后将其发送到timeseries数据库进行进一步分析。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/swlh/realtime-crypto-tracker-with-kafka-and-questdb-b33b19048fc2" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用Kafka和QuestDB的实时加密跟踪器</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">通过Kafka实时分析加密货币的价格趋势，并存储在timeseries数据库中以供进一步调查。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="e793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用Kafka，我能够在接受QuestDB之前利用它的可伸缩性和订购保证。然而，由于我使用的是Postgres wire协议接口，它并没有针对快速接收进行优化。此外，价格反馈仅限于一个交易所(即比特币基地专业版)，降低了我们对波动性做出快速反应的能力(例如，根据另一个交易所的最佳价格买入/卖出比特币)。幸运的是，<a class="ae ky" href="https://github.com/questdb/questdb/releases" rel="noopener ugc nofollow" target="_blank"> QuestDB团队发布了一个更新</a>，对他们的InfluxDB内联协议进行了重大重写，以实现快速接收并支持乱序数据。所以我决定修改我以前的项目来测试这些功能。</p><h1 id="2351" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">无序摄入</h1><p id="6e18" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">随着v6.0.0的发布，QuestDB不再强制时间序列数据按照严格的时间顺序发送。这意味着QuestDB可以处理由网络延迟、硬件抖动或不同的交付机制导致的乱序数据，使用时间戳字段而不是依赖于接收时间。如下例所示，如果QuestDB在采样时间(分别延迟9s、1s、2s)后收到消息，QuestDB可以识别这种延迟，并在将消息提交到数据库之前对其进行重新排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b1a50636f65771ef65b7e39ac89578d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j3VIMhUGZLLC1Vxr.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://questdb.io/docs/guides/out-of-order-commit-lag/" rel="noopener ugc nofollow" target="_blank"> QuestDB </a></figcaption></figure><p id="5ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这减轻了程序员设计摄取机制来处理延迟或网络偏斜的负担。尽管Kafka保证在一个分区内排序，但我仍然有责任发送消息，以便让代理按时间顺序使用它们。因为我是在轮询单个端点，所以记录被乱序发送的可能性很小。但是通过添加新的交换来轮询来自(例如币安、双子)的信息，API响应时间和网络延迟成为考虑因素。</p><h1 id="7d4a" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">InfluxDB线路协议</h1><p id="290b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">QuestDB还建议使用InfluxDB线路协议作为获得最高性能的主要接收方法。事实上，QuestDB团队在运行<a class="ae ky" href="https://github.com/timescale/tsbs" rel="noopener ugc nofollow" target="_blank">时间序列基准测试套件</a>时，使用AMD Ryzen5处理器实现了1.43M行/秒的<a class="ae ky" href="https://questdb.io/blog/2021/05/10/questdb-release-6-0-tsbs-benchmark/#comparing-ingestion-with-clickhouse-influxdb-and-timescaledb" rel="noopener ugc nofollow" target="_blank">写入速度。</a></p><p id="5b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与使用Postgres客户端(如通过Kafka Connect在Kafka项目中使用的)相比，InfluxDB线路协议还提供了以下优势:</p><ul class=""><li id="cee7" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">更高的吞吐量</li><li id="9e7b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">从多个来源大量摄入到表中</li><li id="0e1b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">无序数据的可配置提交延迟</li><li id="57bb" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">无模式/不可知的接收(即添加新字段将动态创建新列)</li></ul><p id="678d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">InfluxDB的消息格式如下:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="7ce6" class="oe mo it oa b gy of og l oh oi">table_name,tag &lt;label&gt;=&lt;value&gt;,&lt;label&gt;=&lt;value&gt; timestamp \n</span></pre><p id="b8d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">InfluxDB记录的每一行都作为QuestDB中的一个新行被接收。对于这个项目，<code class="fe oj ok ol oa b">table_name</code>是<code class="fe oj ok ol oa b">crypto</code>，<code class="fe oj ok ol oa b">tag</code>将是加密货币的符号(例如<code class="fe oj ok ol oa b">BTC</code>)，其他标签包括交易所名称和价格列。</p><h1 id="db32" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">履行</h1><p id="010b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">首先，获取最新版本的QuestDB (v6.0.1或更高版本):</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="d342" class="oe mo it oa b gy of og l oh oi">$ docker pull questdb/questdb:latest</span></pre><p id="dbfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在InfluxDB端口(9009)打开的情况下运行映像:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="3173" class="oe mo it oa b gy of og l oh oi">$ docker run -p 9000:9000 -p 8812:8812 -p 9009:9009 questdb/questdb</span></pre><p id="a165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开控制台UI并创建我们的简单表格:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="2d19" class="oe mo it oa b gy of og l oh oi">CREATE TABLE crypto(currency STRING, exchange STRING, price DOUBLE, timestamp TIMESTAMP) timestamp(timestamp) PARTITION BY DAY;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/9be31c0c9017d0ba7c87747b34faab63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePDdK4sc_uH9pq263gVmRQ.png"/></div></div></figure><p id="2c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于演示的目的，我决定每秒从币安和双子座获取比特币的价格。为了更明显地测试无序摄取，我特意在Gemini发送价格数据之前引入了1-5秒的随机延迟。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="c4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查数据是否按时间顺序提交，我只需查询crypto表:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="3515" class="oe mo it oa b gy of og l oh oi">select * from crypto;</span></pre><p id="5871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我在Gemini price feed上引入了随机网络延迟，但您可以看到两个交易所的比特币价格是按顺序提交的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/3df94cd94ca5b9cc5369b4c0a1f28235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrDzTli0EELqfKrQvGKLDw.png"/></div></div></figure><h1 id="1f53" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">包扎</h1><p id="7e73" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在一个更现实的场景中，我们将在云上运行不同的服务，从各种交换中提取数据，而没有故意的网络延迟。一旦我们找到了API响应时间或延迟的模式，我们可以通过调整QuestDB上的提交延迟变量来进一步优化这个过程。指定这个已知的滞后间隔可以减少QuestDB用于排序无序数据的计算资源，然后与持久数据合并以实现更高的吞吐量:</p><pre class="kj kk kl km gt nz oa ob oc aw od bi"><span id="f8b9" class="oe mo it oa b gy of og l oh oi"># via env variables<br/>docker run -p 8812:8812 -p 9000:9000 -p 9009:9009 -e QDB_CAIRO_MAX_UNCOMMITTED_ROWS=1000 -e QDB_CAIRO_COMMIT_LAG=20000 questdb/questdb</span><span id="7ff4" class="oe mo it oa b gy oq og l oh oi"># via SQL statements<br/>ALTER TABLE crypto SET PARAM maxUncommittedRows = 10000</span></pre><p id="a991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个需要高吞吐量和高性能的项目，QuestDB提供了很好的特性，可以两全其美:通过InfluxDB线路协议快速接收数据，而不用担心数据丢失或排序，并提供完整的SQL支持来分析和处理数据。与Kafka项目一样，您可以随意将它与您的帐户连接，使用价格数据执行交易或构建更复杂的统计模型。</p></div></div>    
</body>
</html>