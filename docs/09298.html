<html>
<head>
<title>WebSockets Demystified, Part 1: Understanding the Protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSockets揭秘，第1部分:理解协议</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/websockets-demystified-part-1-understanding-the-protocol-fccca2ca75eb?source=collection_archive---------5-----------------------#2021-07-25">https://levelup.gitconnected.com/websockets-demystified-part-1-understanding-the-protocol-fccca2ca75eb?source=collection_archive---------5-----------------------#2021-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a7f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解WebSocket连接的生命周期</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e867fa7455183a8f4f7b941f2da6893a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IftSO5IaP6w9DozP_jmBdQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@tvick?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰勒维克</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="7c1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发出请求，得到响应:大多数HTTP连接都是这样开始和结束的。但有时，这还不够:当你需要在应用程序和服务器之间实现实时双向通信时(例如，如果你正在构建一个聊天应用程序或基于网络的协作编辑器)，这就是WebSockets的用武之地。在本文中，我们将了解WebSocket协议是如何工作的；在第2部分中，我们将使用React构建一个聊天室应用程序——最重要的是，我们不会屈服于套接字的抽象。IO提供。</p><p id="f32b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:为了简单起见，本文将只广泛讨论HTTP/1.1上的WebSockets。尽管这不是最前沿的技术(Chrome和Firefox最近通过HTTP/2提供了对WebSockets的支持)，但它是迄今为止最成熟和最健壮的技术，对它的支持可以追溯到2011年。</em></p><h1 id="1ebd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">WebSocket连接的生命周期</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/9b3dee1a74f641d7e67190ff41c13237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0eclkZzDbxaHNDqQyn3pA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">显示WebSocket连接生命周期的简化图。</figcaption></figure><p id="aa13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从广义上讲，WebSocket连接可以分为三个部分，总共有四种状态:开始握手(对应于<code class="fe mm mn mo mp b">CONNECTING</code>状态)、数据传输(可能发生在<code class="fe mm mn mo mp b">OPEN</code>状态期间)和结束握手(将连接从<code class="fe mm mn mo mp b">CLOSING</code>状态带到<code class="fe mm mn mo mp b">CLOSED</code>状态)。这一切都从一个简单的HTTP请求开始…</p><h2 id="80e7" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">开场握手</h2><p id="ca4b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">首先，什么是握手？你可能已经听说过这个词在HTTPS的上下文中使用，因为那确实是这个概念适用的另一个地方。简单地说，正如你可能想象的那样，握手由网络上的两方之间的协议组成，在大多数情况下，这两方是客户端(应用程序或浏览器)和服务器。既然是协议，那么双方都有发言权是合理的——相当不奇怪，事实上，客户端和服务器都积极参与握手。</p><p id="62fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，第一次握手以来自客户端的HTTP请求开始，看起来像这样:</p><pre class="kg kh ki kj gt nh mp ni nj aw nk bi"><span id="9faa" class="mq lu iq mp b gy nl nm l nn no">GET /chat HTTP/1.1<br/>Host: server.example.com<br/>Connection: upgrade<br/>Upgrade: websocket<br/>Origin: &lt;http://example.com&gt;<br/>Sec-WebSocket-Key: NnRlZW4gYnl0ZXMgbG9uZw==<br/>Sec-WebSocket-Protocol: html-chat, text-chat<br/>Sec-WebSocket-Version: 13</span></pre><p id="d951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感觉不知所措？让我们来分解一下:</p><ul class=""><li id="7242" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">前两行是对几乎所有HTTP请求的介绍:它们告诉网络客户机想要连接到什么服务器(在本例中是<code class="fe mm mn mo mp b">server.example.com</code>)以及它想要如何连接到服务器(握手是一个<code class="fe mm mn mo mp b">GET</code>请求，它使用HTTP/1.1连接到WebSocket端点，在本例中是<code class="fe mm mn mo mp b">/chat</code>)。</li><li id="0721" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">第二两行通知服务器，如果握手成功，客户端希望<em class="ls">将连接升级</em>到WebSocket协议(即，将其协议从HTTP更改为WebSocket)。</li><li id="a83b" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">浏览器会自动包含<code class="fe mm mn mo mp b">Origin</code>标头，并告知服务器请求来自哪个网站。</li></ul><p id="2e90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后三个头包含一些特定于WebSocket的信息，这些信息允许服务器建立连接。</p><ul class=""><li id="2050" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">Sec-Websocket-Key</code>是一个随机的16字节base64编码的字符串，稍后将使用它来确保服务器支持WebSocket协议。</li><li id="ef78" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">Sec-Websocket-Protocol</code>是客户想要使用的内部<em class="ls">子协议</em>的列表。你会问，什么是子协议？仅仅是一个内部约定，规定了什么数据将被交换——你可以把它看作类似于“API版本”字段的东西。在上面的例子中，客户机实际上是在告诉服务器，“我想使用<code class="fe mm mn mo mp b">html-chat</code>协议与您交谈，但是如果那不可用，我也可以使用<code class="fe mm mn mo mp b">text-chat</code>”。</li><li id="266b" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">最后，<code class="fe mm mn mo mp b">Sec-WebSocket-Version</code>告诉服务器应该使用哪个版本的WebSocket协议:2011年12月发布的版本13是最新的官方标准。</li></ul><p id="7876" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了这三个之外，客户端还可以指定一个<code class="fe mm mn mo mp b">Sec-WebSocket-Extensions</code>头，请求服务器启用WebSocket协议的一个或多个扩展——但是这本身就是一个完整的世界，远远超出了本文的范围。</p><p id="447f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是客户端握手的一部分WebSocket连接现在处于<code class="fe mm mn mo mp b">CONNECTING</code>状态。但是服务器在这个协议中也有发言权—让我们看看它是如何回应的:</p><pre class="kg kh ki kj gt nh mp ni nj aw nk bi"><span id="5ebd" class="mq lu iq mp b gy nl nm l nn no">HTTP/1.1 101 Switching Protocols<br/>Connection: upgrade<br/>Upgrade: websocket<br/>Sec-WebSocket-Accept: 5TJpHv9RoAl7w8ytsXcWxTOZ9Q==<br/>Sec-WebSocket-Protocol: new-chat</span></pre><p id="7bb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个应该更简单一点。正如我们阅读的前三行，握手是成功的:<strong class="ky ir">连接已经被转换成WebSocket，并将保持活动状态</strong>(这与HTTP/1.1连接不同，后者往往在服务器响应时就被关闭)。此外，<code class="fe mm mn mo mp b">Sec-WebSocket-Protocol</code>头用于向客户机传达服务器支持<code class="fe mm mn mo mp b">html-chat</code>子协议，因此，根据请求，这将在整个通信中使用。但是<code class="fe mm mn mo mp b">Sec-WebSocket-Accept</code>呢？这是服务器向客户机证明它支持WebSockets的方式，事实上，它是使用<code class="fe mm mn mo mp b">Sec-WebSocket-Key</code>计算的(还记得吗？)作为起点。这个过程并不简单，但应该很容易理解——它只是一系列操作字符串的步骤:</p><ol class=""><li id="802d" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr od nv nw nx bi translated">首先，服务器从请求头中读取<code class="fe mm mn mo mp b">Sec-WebSocket-Key</code>，并将其与“神奇字符串”<code class="fe mm mn mo mp b">258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>(一个任意的常量)连接起来。使用我们例子中的密钥，我们得到<code class="fe mm mn mo mp b">NnRlZW4gYnl0ZXMgbG9uZw==</code> + <code class="fe mm mn mo mp b">258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> = <code class="fe mm mn mo mp b">NnRlZW4gYnl0ZXMgbG9uZw==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>。</li><li id="f2ff" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">然后，服务器计算这个新字符串的SHA-1散列，在我们的例子中是<code class="fe mm mn mo mp b">SHA1(NnRlZW4gYnl0ZXMgbG9uZw==258EAFA5-E914-47DA-95CA-C5AB0DC85B11)</code> = <code class="fe mm mn mo mp b">e53269001eff51a0097bc3ccadb17716c53399f5</code>。</li><li id="fe5b" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">最后，服务器将这个散列编码为Base64(请记住，它将散列视为一个字节列表，因此是<code class="fe mm mn mo mp b">0xe5</code>、<code class="fe mm mn mo mp b">0x32</code>、<code class="fe mm mn mo mp b">0x29</code>等，而不是实际的字符串)，这是计算<code class="fe mm mn mo mp b">Sec-WebSocket-Accept</code>、<code class="fe mm mn mo mp b">5TJpHv9RoAl7w8ytsXcWxTOZ9Q==</code>的最后一步。</li></ol><p id="e3e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">响应被发送到客户端，连接保持打开:握手完成！连接现在处于<code class="fe mm mn mo mp b">OPEN</code>状态。是时候交换一些数据了…</p><h2 id="46f1" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">数据传输</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/bd8290474aecd51c910a4d8783367e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPd0v0HfC-tbAh1N_hhELQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">显示WebSocket消息框架结构的简化图。</figcaption></figure><p id="30ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然已经执行了开始握手，客户端和服务器可以自由地以<em class="ls">消息帧</em>的形式互相发送数据，即具有特定结构和含义的一系列位。消息帧不是WebSockets特有的概念，因为它们适用于TCP协议上的所有连接(TCP协议是HTTP/1.1和HTTP/2的基础)，但出于我们的目的，我们将只考虑WebSocket帧的结构。让我们按顺序进行:</p><ul class=""><li id="6039" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">WebSocket消息帧的第一位是<code class="fe mm mn mo mp b">FIN</code>位，表示该帧是否是消息的最后一帧。在绝大多数用例中，这个位总是<code class="fe mm mn mo mp b">1</code>(即<code class="fe mm mn mo mp b">true</code>)，因为每个消息都将在自己的帧中发送。然而，如果，比如说，数据的初始大小未知，或者它非常大并且分割它很方便，那么<code class="fe mm mn mo mp b">FIN</code>位可以被设置为<code class="fe mm mn mo mp b">0</code>，表示更多的数据将出现在随后的帧中。</li><li id="b83f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">FIN</code>位之后是另外三个位，分别称为<code class="fe mm mn mo mp b">RSV1</code>、<code class="fe mm mn mo mp b">RSV2</code>和<code class="fe mm mn mo mp b">RSV3</code>，它们可能包含一些用于已启用的任何扩展的额外数据。如果没有启用扩展，则三者都必须为零。</li><li id="3889" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">另外四位组成了<code class="fe mm mn mo mp b">opcode</code>，它回答了“应该如何解释这些数据”的问题在本文的后面，我们将深入探讨这四个位的含义以及它们可能取的值。</li><li id="7f8f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">在<code class="fe mm mn mo mp b">opcode</code>之后，单个<code class="fe mm mn mo mp b">Mask</code>位指示数据是否已经被<em class="ls">屏蔽</em>。在WebSockets中，屏蔽是指出于安全目的对消息数据进行简单的对称加密——从客户端发送到服务器的所有数据都必须屏蔽，而服务器可以决定不屏蔽它发送的数据。</li><li id="43c8" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">接下来的几个位(数量为7、7+16或7+64，取决于它们的值)以字节为单位指定有效载荷数据的长度。</li><li id="6986" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">如果<code class="fe mm mn mo mp b">Mask</code>位被设置为<code class="fe mm mn mo mp b">1</code>，则代表有效载荷长度的位后面将跟随<code class="fe mm mn mo mp b">Masking key</code>，即用于加密数据的4字节随机密钥。否则，如果消息没有被屏蔽，这32位将被省略。</li><li id="f8c0" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">最后，可变数量的字节组成了<code class="fe mm mn mo mp b">Payload data</code>，正如您所想象的，这是消息的实际内容。</li></ul><p id="13dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">帧类型和</strong> <code class="fe mm mn mo mp b"><strong class="ky ir">opcode</strong></code> <strong class="ky ir">帧类型</strong></p><p id="4d51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们之前忽略了它，所以现在让我们更详细地了解一下<code class="fe mm mn mo mp b">opcode</code>位的含义。但是我们应该首先后退一步，定义WebSocket连接的两种抽象框架类型:</p><ul class=""><li id="de6d" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><strong class="ky ir">数据帧</strong>用于传输应用数据(咄！)并且有三种类型:包含文本数据的帧、包含二进制数据的帧、以及为通过前一帧传输的部分数据提供延续的帧(这些帧必须跟随将<code class="fe mm mn mo mp b">FIN</code>位设置为<code class="fe mm mn mo mp b">0</code>的帧，即携带不完整数据的帧)。</li><li id="8e8c" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><strong class="ky ir">控制帧</strong>传输关于连接本身的元数据，包括“关闭”帧、“ping”帧和“pong”帧。“Ping”和“pong”帧可用于验证连接的状态，而“close”帧启动结束握手——稍后将详细介绍！</li></ul><p id="716e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这一点，<code class="fe mm mn mo mp b">opcode</code>很容易理解:每个<code class="fe mm mn mo mp b">opcode</code>值对应一个帧类型。具体来说，</p><ul class=""><li id="f6ed" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">0000</code>(十六进制<code class="fe mm mn mo mp b">0x0</code> ) →“连续帧”(用于跨多个帧拆分的消息)，</li><li id="4649" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">0001</code> ( <code class="fe mm mn mo mp b">0x1</code> ) →文字框架，</li><li id="f51e" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">0010</code> ( <code class="fe mm mn mo mp b">0x2</code> ) →二进制帧，</li><li id="62bc" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">1000</code> ( <code class="fe mm mn mo mp b">0x8</code> ) →关闭框架，</li><li id="662f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">1001</code> ( <code class="fe mm mn mo mp b">0x9</code> ) → ping帧，</li><li id="562f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe mm mn mo mp b">1010</code> ( <code class="fe mm mn mo mp b">0xA</code> ) →乓帧，以及</li><li id="da7f" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">所有其他可能的值(<code class="fe mm mn mo mp b">0x3</code>至<code class="fe mm mn mo mp b">0x7</code>和<code class="fe mm mn mo mp b">0xB</code>至<code class="fe mm mn mo mp b">0xF</code>)保留供将来使用。</li></ul><p id="f35d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一点需要注意:对于数据帧，前导(第一)位总是<code class="fe mm mn mo mp b">0</code>，对于控制帧总是<code class="fe mm mn mo mp b">1</code>。</p><h2 id="1990" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">闭幕握手</h2><p id="e3aa" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">天下没有不散的宴席，每个WebSocket连接也是如此。不过谢天谢地，结束握手比开始握手简单多了！它只包括几个步骤:</p><ol class=""><li id="6fdf" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr od nv nw nx bi translated">两个对等体中的一个——无论是客户端还是服务器——发送“关闭”控制帧，可选地指定状态代码和/或关闭连接的原因。WebSocket连接进入<code class="fe mm mn mo mp b">CLOSING</code>状态。</li><li id="8581" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">另一个对等体用另一个“关闭”帧来响应。</li></ol><p id="fc3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，WebSocket连接处于其<code class="fe mm mn mo mp b">CLOSED</code>状态，底层TCP连接可以安全地终止。然而，如果两个对等体中的一个突然关闭了TCP连接，该怎么办呢？这也很好:用技术术语来说，我们会说WebSocket连接被关闭了，但不是“干净地”(也就是说，它跳过了<code class="fe mm mn mo mp b">CLOSING</code>状态)。</p><h1 id="2ade" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我必须自己编码这些东西吗？</h1><p id="b535" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这样做将是一个奇妙的编程练习！但是，幸运的是，许多现有的解决方案处理了庞大的底层逻辑(最著名的是自2011年以来内置于所有浏览器中的JavaScript <code class="fe mm mn mo mp b">WebSocket</code> API)，使我们能够专注于最重要的事情:<strong class="ky ir">我们的应用程序和服务器之间简单、实时、双向的消息交换</strong>。</p><p id="a838" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第2部分中，我们将利用内置的<code class="fe mm mn mo mp b">WebSocket</code>浏览器API和Node.js <code class="fe mm mn mo mp b">ws</code>库来构建一个简单的聊天室应用程序，它还将提供一些额外的特性来充分利用WebSockets的能力。</p><h1 id="7d8c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">附录:出于好奇…</h1><p id="08c3" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我试图在整篇文章中尽可能地详细，但是至少有一点我必须承认我故意忽略了，那就是为什么屏蔽对于客户端到服务器的消息帧是必要的解释。如果你想了解更多，我推荐你参考StackOverflow 上的<a class="ae kv" href="https://stackoverflow.com/questions/33250207/why-are-websockets-masked" rel="noopener ugc nofollow" target="_blank">这个问题以及它的答案和评论链接到的许多有用的资源。</a></p><p id="4965" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，为了更深入、更全面地解释WebSocket协议，这里的<a class="ae kv" href="https://www.rfc-editor.org/rfc/rfc6455.html" rel="noopener ugc nofollow" target="_blank"/>是该标准的链接——它相当长，但我认为值得一看！</p></div></div>    
</body>
</html>