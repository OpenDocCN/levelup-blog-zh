<html>
<head>
<title>Writing unit test is not just for testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写单元测试不仅仅是为了测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-unit-test-is-not-just-for-testing-e49ed5fe09cd?source=collection_archive---------18-----------------------#2020-05-26">https://levelup.gitconnected.com/writing-unit-test-is-not-just-for-testing-e49ed5fe09cd?source=collection_archive---------18-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5969" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">软件工程实践</h2><div class=""/><div class=""><h2 id="db50" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我在大学里没有学到的单元测试</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f59a351f404422e4707d9f81c670bc3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ApREFeZboVSv98DS"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@hush52?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的</a></figcaption></figure><p id="ce13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">当我第一次了解编写单元测试的概念时，我觉得它们很无聊，不知道有什么好处。我真的不能理解这样做的好处，尤其是编写代码的开发人员也要编写测试。考试一定会通过的！</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="d7e5" class="ms mt it mo b gy mu mv l mw mx">fun plus(valueA: Int, valueB: Int) Int {<br/>    return valueA + valueB<br/>}</span><span id="a981" class="ms mt it mo b gy my mv l mw mx">@Test<br/>fun `test plus`() {<br/>    val x = plus(1, 2)<br/>    assertEqual(3, x)<br/>}</span></pre><p id="a96b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">后来，我了解到单元测试可以保证我们未来的代码更改不会破坏逻辑。这就是我们在大学里学到的。</p><p id="14b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">经过多年的开发，现在我发现它比测试有更多的价值。让我与你分享一些(也许过于简单的)例子，并希望我得到它有助于弄清楚。</p><h1 id="98f0" class="mz mt it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">识别不在规格范围内的极限情况</h1><p id="0abb" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">我说的角落案例是什么意思？当我们被给定规格时，我们在编码时难道不考虑它吗？</p><p id="5c8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看规格</p><blockquote class="nv nw nx"><p id="f24e" class="li lj ny lk b ll lm kd ln lo lp kg lq nz ls lt lu oa lw lx ly ob ma mb mc md im bi translated">编写一个生成阶乘数的函数。给定一个X值，<code class="fe oc od oe mo b">Factorial(A)</code>就是<code class="fe oc od oe mo b">Ax(A-1)x(A-2)x … 3x2x1</code>，例如给定5！，该值应为5x4x3x2x1 = 120。</p></blockquote><p id="dabf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，让我们编写完全覆盖阶乘规范的代码:</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="2742" class="ms mt it mo b gy mu mv l mw mx">fun factorial(value: Int) : Int {<br/>    var temp = value<br/>    var result = 1<br/>    while (temp &gt; 0) {<br/>        result *= temp--<br/>    }<br/>    return result<br/>}</span></pre><p id="0808" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在没有为它编写单元测试的情况下，上面的代码看起来都不错。</p><p id="b912" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们试着为它编写单元测试</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="6244" class="ms mt it mo b gy mu mv l mw mx">@Test<br/>fun `test factorial`() {<br/>    assertEqual(factorial(5), 120)<br/>    assertEqual(factorial(4), 24)<br/>    assertEqual(factorial(3), 6)<br/>    assertEqual(factorial(2), 2)<br/>    assertEqual(factorial(1), 1)<br/>    assertEqual(factorial(0), 1)</span><span id="5b63" class="ms mt it mo b gy my mv l mw mx">    // Ops, whataboout when it is -1?<br/>}</span></pre><p id="fb4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我们发现一些范围之外的情况，例如值&lt; 0。如果它不在规范中(也就是验收标准)，我们就需要讨论它应该如何执行。</p><p id="9c85" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以上是一个过于简化的例子。如果你以前练习过编写单元测试，这肯定是你经历过的事情。</p><h1 id="3107" class="mz mt it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">发现一个做太多事情的函数</h1><p id="29ac" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">每个单元测试都用来测试一个特定的功能场景。然而，如果一个场景需要太多的断言，就需要对代码进行一些更新。</p><p id="fcb1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如返回一对中的最小值和最大值的函数。</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="26f7" class="ms mt it mo b gy mu mv l mw mx">fun minMax(list: List&lt;Int&gt;): Pair&lt;Int, Int&gt; {<br/>    list.<em class="ny">ifEmpty </em><strong class="mo jd">{ <br/>        </strong>throw Throwable("list should not be empty") <br/>    <strong class="mo jd">}<br/>    </strong>var min = list[0]<br/>    var max = list[0]<br/><br/>    list.<em class="ny">forEach </em><strong class="mo jd">{<br/>        </strong>if (min &gt; <strong class="mo jd">it</strong>) min = <strong class="mo jd">it<br/>        </strong>if (max &lt; <strong class="mo jd">it</strong>) max = <strong class="mo jd">it<br/>    }<br/><br/>    </strong>return Pair(min, max)<br/>}</span></pre><p id="f843" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们做一些测试时，我们注意到对于每个场景，我们需要不止一个断言。</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="04e6" class="ms mt it mo b gy mu mv l mw mx">@Test<br/>fun `test minMax`() {<br/>    val (min, max) = minMax(<em class="ny">listOf</em>(1, 2, 3, 4))<br/>    Assert.assertEquals(min, 1)<br/>    Assert.assertEquals(min, 4)<br/>}</span></pre><p id="600e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可能会让人吃惊。也许我们应该对该职能承担较小的责任，并将责任移交给其他职能</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="d8a0" class="ms mt it mo b gy mu mv l mw mx">fun minMax(list: List&lt;Int&gt;): Pair&lt;Int, Int&gt; {<br/>    list.<em class="ny">ifEmpty </em><strong class="mo jd">{ <br/>        </strong>throw Throwable("list should not be empty") <br/>    <strong class="mo jd">}<br/>    </strong>return Pair(min(list),max(list))<br/>}<br/><br/>fun min(list: List&lt;Int&gt;): Int {<br/>    var min = list[0]<br/>    list.<em class="ny">forEach </em><strong class="mo jd">{<br/>        </strong>if (min &gt; <strong class="mo jd">it</strong>) min = <strong class="mo jd">it<br/>    }<br/>    </strong>return min<br/>}<br/><br/>fun max(list: List&lt;Int&gt;): Int {<br/>    var max = list[0]<br/>    list.<em class="ny">forEach </em><strong class="mo jd">{<br/>        </strong>if (max &lt; <strong class="mo jd">it</strong>) max = <strong class="mo jd">it<br/>    }<br/>    </strong>return max<br/>}</span></pre><p id="1be6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">编写单元测试过程暴露了对单一责任功能的需求。</p><h1 id="36ca" class="mz mt it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">通过适当的注入改进代码架构</h1><p id="addc" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">假设我们有一个代码，如果提供的id存在，它将通过调用<code class="fe oc od oe mo b">getData</code>来执行网络获取</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="7718" class="ms mt it mo b gy mu mv l mw mx">class NetworkRequest() {<br/>    fun fetch(id: Int) {}<br/>}<br/><br/>fun getData(id: Int?) {<br/>    id?.<em class="ny">let</em><strong class="mo jd">{<br/>        </strong>NetworkRequest().fetch(it)<br/>    <strong class="mo jd">}<br/></strong>}</span></pre><p id="6b0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一切都很好。但是有一个问题，我们如何测试<code class="fe oc od oe mo b">getData</code>？</p><p id="5c2a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们没有办法编写一个测试来验证当<code class="fe oc od oe mo b">id</code>不是<code class="fe oc od oe mo b">null</code>时<code class="fe oc od oe mo b">NetworkRequest</code>的<code class="fe oc od oe mo b">fetch(id)</code>被调用。</p><p id="9d2a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是不可能的，因为<code class="fe oc od oe mo b">NetworkRequest</code>是在<code class="fe oc od oe mo b">getData</code>函数中实例化的。它暴露了一些糟糕的架构。</p><ul class=""><li id="de1b" class="of og it lk b ll lm lo lp lr oh lv oi lz oj md ok ol om on bi translated"><code class="fe oc od oe mo b">NetworkRequest</code>每次提取都被反复实例化</li><li id="1c8d" class="of og it lk b ll oo lo op lr oq lv or lz os md ok ol om on bi translated">如果我们想将<code class="fe oc od oe mo b">NetworkRequest</code>改为其他代码，我们必须修改<code class="fe oc od oe mo b">getData</code>代码。</li></ul><p id="bd2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要解决这个问题，我们必须将<code class="fe oc od oe mo b">NetworkRequest</code>从<code class="fe oc od oe mo b">getData</code>中分离出来，注入进去。</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="86f5" class="ms mt it mo b gy mu mv l mw mx">class NetworkRequest() {<br/>    fun fetch(id: Int) {}<br/>}<br/><br/>fun getData(id: Int?, networkRequest: NetworkRequest) {<br/>    id?.<em class="ny">let</em><strong class="mo jd">{<br/>        </strong>networkRequest.fetch(id)<br/>    <strong class="mo jd">}<br/></strong>}</span></pre><p id="5e94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了测试，我们现在可以很容易地模仿<code class="fe oc od oe mo b">networkRequeest</code>并编写一个测试来验证<code class="fe oc od oe mo b">fetch(id)</code>是否被调用</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="18b7" class="ms mt it mo b gy mu mv l mw mx">@Test<br/>fun `test getData`() {<br/>    val networkRequest: NetworkRequest = <em class="ny">mock</em>()<br/>    val id = 100<br/>    <br/>    getData(id, networkRequest)<br/>    <br/>    <em class="ny">verify</em>(networkRequest).fetch(id)<br/>}</span></pre><blockquote class="nv nw nx"><p id="76eb" class="li lj ny lk b ll lm kd ln lo lp kg lq nz ls lt lu oa lw lx ly ob ma mb mc md im bi translated">注意:理想情况下<code class="fe oc od oe mo b">NetworkRequest</code>应该是一个<code class="fe oc od oe mo b">interface</code>，但是为了简单起见，我把它作为一个类。</p></blockquote><h1 id="c68f" class="mz mt it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">可能会暴露一些代码气味</h1><p id="f104" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">这是我遇到的一个真实案例。为了简单起见，我对它做了一个微妙的改变。</p><p id="760c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是一个类似上面的示例代码。它在大多数情况下工作正常。</p><pre class="ks kt ku kv gt mn mo mp mq aw mr bi"><span id="0e63" class="ms mt it mo b gy mu mv l mw mx">class NetworkRequest() {<br/>    fun fetch(id: Int) {}<br/>}<br/><br/>fun getData(id: Int?, networkRequest: NetworkRequest) {<br/>    id?.<em class="ny">let</em><strong class="mo jd">{<br/>        </strong>Thread <strong class="mo jd">{<br/>            </strong>networkRequest.fetch(id)<br/>        <strong class="mo jd">}</strong>.start()<br/>    <strong class="mo jd">}<br/></strong>}<br/><br/>@Test<br/>fun `test getData`() {<br/>    val networkRequest: NetworkRequest = <em class="ny">mock</em>()<br/>    val id = 100<br/>    getData(id, networkRequest)<br/>    <em class="ny">verify</em>(networkRequest).fetch(id)<br/>}</span></pre><p id="95ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过运行测试本身，我们在大多数情况下都会得到一个通过的结果。然而，它偶尔会失败。</p><p id="dfb5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码很简单，我们可以快速识别代码中<code class="fe oc od oe mo b">Thread</code>的使用，它在执行<code class="fe oc od oe mo b">fetch(id)</code>时启动一个不同的线程。</p><p id="7604" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据机器计算强度，在执行<code class="fe oc od oe mo b">verify</code>之前<code class="fe oc od oe mo b">fetch(id)</code>可能会也可能不会及时运行。因此，它可能会不时地失败，这导致了一个奇怪的混乱，在哪里出了问题。</p><p id="4721" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是幸运的是我们有一个测试，虽然感觉测试很脆弱，但是有味道的是代码。</p><p id="649e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码不好是因为</p><ul class=""><li id="d1f9" class="of og it lk b ll lm lo lp lr oh lv oi lz oj md ok ol om on bi translated">在测试中使用<code class="fe oc od oe mo b">Thread</code>并产生不确定的结果。</li><li id="6d25" class="of og it lk b ll oo lo op lr oq lv or lz os md ok ol om on bi translated">如果程序退出，没有代码处理线程活动的取消。</li></ul><p id="cc00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了解决这个问题，在Kotlin的世界里，也许应该考虑使用协程或者RxJava线程机制。</p><p id="5be3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">幸运的是，我们已经编写了单元测试来帮助暴露一些代码味道。</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h1 id="10ea" class="mz mt it bd na nb pa nd ne nf pb nh ni ki pc kj nk kl pd km nm ko pe kp no np bi translated">TL；DR；</h1><p id="58ea" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">编写单元测试不仅仅是为了确保现有的代码得到测试，以避免由于未来的变化而导致的退化，它还有助于提高代码的健壮性和质量。编写单元测试可以被认为是开发人员自己执行代码评审的另一种方式。这是值得花在未来的时间-证明代码。</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="4fda" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读。你可以在这里查看我的其他话题。</p><p id="d94a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以在此订阅<a class="ae lh" href="https://buttondown.email/Elye." rel="noopener ugc nofollow" target="_blank"/>或关注我的<a class="ae lh" href="https://medium.com/@elye.project" rel="noopener"> <em class="ny">中的</em> </a> <em class="ny">，</em><a class="ae lh" href="https://twitter.com/elye_project" rel="noopener ugc nofollow" target="_blank"><em class="ny">Twitter</em></a><em class="ny">，</em> <a class="ae lh" href="https://www.facebook.com/elye.project/" rel="noopener ugc nofollow" target="_blank"> <em class="ny">脸书</em> </a> <em class="ny">，以及</em> <a class="ae lh" href="https://www.reddit.com/user/elyeproj/" rel="noopener ugc nofollow" target="_blank"> <em class="ny"> Reddit </em> </a>获取关于移动开发、中写等相关话题的小技巧和学习。~Elye~</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pf pg l"/></div></figure></div></div>    
</body>
</html>