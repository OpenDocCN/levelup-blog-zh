<html>
<head>
<title>Challenge of Serverless: Database Connections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器的挑战:数据库连接</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/challenge-of-serverless-database-connections-97fde014b75d?source=collection_archive---------11-----------------------#2021-04-01">https://levelup.gitconnected.com/challenge-of-serverless-database-connections-97fde014b75d?source=collection_archive---------11-----------------------#2021-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1878e3d9045796d531a1a214ab8611e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pqyOy_NOsofz2fzLzzDtcg.jpeg"/></div></div></figure><p id="255d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为无服务器设计数据库，我们认为最大的挑战是建立一个基础设施，以盈利的方式支持按请求定价。我们相信<a class="ae kw" href="https://upstash.com" rel="noopener ugc nofollow" target="_blank"> Upstash </a>已经做到了这一点。在我们发布产品之后，我们看到了另一个主要挑战:数据库连接！</p><p id="42e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">众所周知，无服务器功能的范围从0到无穷大。这意味着当你的函数获得大量流量时，云提供商会并行创建新的容器(lambda函数)并扩展你的后端。如果您在函数中创建新的数据库连接，那么您可以很快达到数据库的连接限制。</p><p id="fb41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你试图在lambda函数之外缓存连接，就会出现另一个问题。当AWS冻结你的Lambda函数时，它不会关闭连接。因此，你可能会以许多闲置/僵尸连接而告终，这些连接仍然会造成威胁。</p><p id="eeea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题不是Redis特有的，它适用于所有依赖TCP连接的数据库(Mysql、Postgre、MongoDB等)。你可以看到无服务器社区正在创建像<a class="ae kw" href="https://github.com/jeremydaly/serverless-mysql" rel="noopener ugc nofollow" target="_blank">无服务器-mysql </a>这样的解决方案。这些是客户端解决方案。作为Upstash，我们有实现和维护服务器端的优势。所以我们决定通过监控连接和驱逐空闲的连接来缓解这个问题。算法如下:作为最大并发连接数，我们对数据库有两个限制，软限制和硬限制。当数据库达到软限制时，我们开始终止空闲连接。我们继续接受新的连接请求，直到达到硬限制。如果数据库达到硬限制，那么我们开始拒绝新的连接。</p><h1 id="8be0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">连接驱逐算法</h1><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="bd01" class="me ky iq ma b gy mf mg l mh mi">if( current_connection_count &lt; SOFT_LIMIT ) {<br/>    ACCEPT_NEW_CONNECTIONS<br/>}</span><span id="b206" class="me ky iq ma b gy mj mg l mh mi">if( current_connection_count &gt; SOFT_LIMIT &amp;&amp; current_connection_count &lt; HARD_LIMIT ) {<br/>    ACCEPT_NEW_CONNECTIONS<br/>    START_EVICTING_IDLE_CONNECTIONS<br/>}</span><span id="e04a" class="me ky iq ma b gy mj mg l mh mi">if( current_connection_count &gt; HARD_LIMIT ) {<br/>    REJECT_NEW_CONNECTIONS<br/>}</span></pre><p id="6f06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，<a class="ae kw" href="https://docs.upstash.com/overall/databasetypes" rel="noopener ugc nofollow" target="_blank">上传文件</a>中列出的最大并发连接限制是软限制。</p><h1 id="dfc8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">短暂的联系</h1><p id="0926" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">部署上述算法后，我们发现所有地区被拒绝的连接数量都大大减少了。但是如果你想安全起见，你也可以在你这边解决问题。您可以在函数内部打开Redis连接，但也可以在使用Redis时关闭它们，而不是重用连接，如下所示:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5471" class="me ky iq ma b gy mf mg l mh mi">exports.handler = async (event) =&gt; {<br/>    const client = new Redis(process.env.REDIS_URL);<br/>    /*<br/>    do stuff with redis<br/>    */<br/>    await client.quit();<br/>    /*<br/>    do other stuff<br/>    */<br/>    return {<br/>        response: "response"<br/>    };<br/>};</span></pre><p id="9bcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码帮助您最小化并发连接数。人们询问新连接的延迟开销。众所周知，Redis连接非常轻量级。</p><h1 id="7386" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Redis连接真的是轻量级的吗？</h1><p id="c216" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们运行了一个基准测试，看看Redis连接有多轻量级。在本测试中，我们比较了两种方法的延迟时间:</p><p id="3248" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1-短暂的连接:我们不重用连接。相反，我们为每个命令创建一个新的连接，并立即关闭该连接。我们一起记录客户机创建、ping()和client.quit()的延迟。参见下面代码部分的<code class="fe mp mq mr ma b">benchEphemeral()</code>方法。</p><p id="a2a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2-重用连接:我们创建一个连接，然后为所有命令重用同一个连接。在这里，我们记录下<code class="fe mp mq mr ma b">ping()</code>操作的延迟。参见下面的<code class="fe mp mq mr ma b">benchReuse()</code>方法。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="10f8" class="me ky iq ma b gy mf mg l mh mi">async function benchReuse() {<br/>    const client = new Redis(options);<br/>    const hist = hdr.build();<br/>    for (let index = 0; index &lt; total; index++) {<br/>        let start = performance.now() * 1000 // to μs<br/>        client.ping()<br/>        let end = performance.now() * 1000 // to μs<br/>        hist.recordValue(end-start)<br/>        await delay(10)<br/>    }<br/>    client.quit()<br/>    console.log(hist.outputPercentileDistribution(1, 1));<br/>}<br/>    <br/>async function benchEphemeral() {<br/>    const hist = hdr.build();<br/>    for (let index = 0; index &lt; total; index++) {<br/>        let start = performance.now() * 1000 // to μs<br/>        const client = new Redis(options);<br/>        client.ping()<br/>        client.quit()<br/>        let end = performance.now() * 1000 // to μs<br/>        hist.recordValue(end-start)<br/>        await delay(10)<br/>    }<br/>    console.log(hist.outputPercentileDistribution(1, 1));<br/>}</span></pre><p id="7a38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参见<a class="ae kw" href="https://github.com/upstash/redis-connection-benchmark" rel="noopener ugc nofollow" target="_blank">回购</a>，如果你想自己运行基准。</p><p id="73b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在AWS EU-WEST-1地区以两种不同的设置运行了这个基准代码。第一种设置是相同的区域，其中客户端和数据库位于相同的可用性区域。第二种设置是INTER ZONE，其中客户端运行在与数据库不同的可用性区域中。我们使用标准字体作为数据库服务器。</p><p id="fb9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经看到创建和关闭一个新连接的开销(短暂方法)只有75微秒(99%)。在区间设置中，开销非常相似(80微秒)。</p><p id="f46a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们决定在AWS Lambda函数中重复同样的测试。结果是不同的。尤其是当我们把Lambda函数的内存设置的很低(128Mb)的时候，我们看到了Redis连接更大的开销。我们已经看到在AWS Lambda函数中延迟开销高达6–7毫秒。</p><ul class=""><li id="94e4" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">Redis连接在具有合理CPU能力的系统上确实是轻量级的。甚至在t2.micro上。</li><li id="f894" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">默认AWS Lambda配置的CPU能力非常差，这显著增加了TCP连接相对于Lambda函数总执行时间的成本。</li><li id="1672" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">如果您使用Lambda函数和缺省/最小内存，那么您最好在函数外部缓存Redis连接。</li></ul><p id="5322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们关于Redis连接的结论是:</p><h1 id="e727" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">冻结容器= &gt;僵尸连接</h1><p id="af4d" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在意识到连接在一些AWS Lambda设置中会有显著的开销后，我们决定在AWS Lambda中对<code class="fe mp mq mr ma b">reusing connection</code>做进一步的测试。我们发现了另一个问题。这是一个边缘病例，还没有人报道过。</p><p id="bde5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是事情发生的时间线:</p><p id="2ac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> STEP1 — timer-0sec: </strong>我们发送一个请求，在lambda函数之外缓存连接。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="313f" class="me ky iq ma b gy mf mg l mh mi">if (typeof client === 'undefined') {<br/>    var client = new Redis("REDIS_URL");<br/>}</span><span id="1962" class="me ky iq ma b gy mj mg l mh mi">module.exports.hello = async(event) =&gt; {<br/>    let response = await client.get("foo");<br/>    return {response : response + "-" + time}<br/>};</span></pre><p id="1146" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤2 —定时器-5秒:</strong> AWS在短时间后冻结集装箱。</p><p id="0a34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">step 3—time-60 sec:</strong>upash对于空闲连接有60秒的超时。所以它终止了连接，但是由于它被冻结了，所以不能从客户端获得ACK。因此服务器连接进入状态<a class="ae kw" href="https://kb.iu.edu/d/ajmi" rel="noopener ugc nofollow" target="_blank"> FIN_WAIT_2 </a>。</p><p id="75f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">step 4—time-90 sec:</strong>upsh服务器完全断开连接，退出FIN_WAIT_2状态。</p><p id="c02d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> STEP5 — time-95sec: </strong>客户端发送同样的请求，得到ETIMEDOUT异常。因为客户端假设连接是打开的，但事实并非如此。🤦🏻 🤦🏻 🤦🏻</p><p id="fdd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> STEP6 — time-396sec: </strong>最后一次请求后5分钟，AWS完全杀死容器。</p><p id="97ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> STEP7 — time-400sec: </strong>客户端发送相同的请求，这次它运行良好，因为容器是从头开始创建的，所以初始化步骤没有被跳过。将创建一个新连接。</p><p id="2887" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上面看到的，AWS解冻了一个容器并重用了连接。但是服务器端的连接已经关闭，由于功能被冻结，无法进行通信。所以在Upstash驱逐一个空闲连接和AWS处理一个空闲函数之间存在同步问题。因此，如果我们只在AWS终止一个函数后终止一个空闲连接，那么就不会有任何问题。</p><p id="96be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设AWS在300秒内终止一个空闲函数，我们将Upstash连接超时更改为310秒。经过这一改，问题消失了。这里的问题是AWS在终止空闲函数时是不透明的。因此，我们需要继续测试，并尝试检测问题是否再次发生。</p><p id="a701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题与在无服务器mysql库上看到的问题非常相似。在注释中，建议在ETIMEDOUT异常时重试请求。但是重试有两个缺点。首先，您可以重试一个写请求，该请求可能已被处理并因实际网络问题而超时。第二个问题是失败请求的额外延迟。</p><h1 id="90dd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">GraphQL也有帮助</h1><p id="1687" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">一种解决连接问题的方法是使用无连接API。除了Redis协议，Upstash还支持<a class="ae kw" href="https://docs.upstash.com/graphql/aboutgraphqlapi" rel="noopener ugc nofollow" target="_blank"> GraphQL API </a>。GraphQL是基于HTTP的，所以它没有连接限制的问题。查看文档以了解支持的命令。注意GraphQL API在Redis协议上有一个延迟开销(大约5毫秒)。</p><h1 id="e2a5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="6d73" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们定制Upstash数据库，为无服务器应用提供流畅的体验。我们新的服务器端算法删除了AWS Lambda大量创建的非活动连接。您可以通过在Lambda函数中打开/关闭Redis客户端来最小化连接的数量，但是如果您的函数内存小于1GB，这可能会产生延迟开销。</p><ul class=""><li id="21ee" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated">如果您的用例对延迟敏感(例如，6毫秒对您来说很大)，那么重用Redis客户端。</li><li id="999c" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">如果您遇到非常多的并发客户端(超过1000个)，那么可以重用Redis客户端。</li><li id="c738" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">如果您的用例对延迟不敏感，那么在函数中打开/关闭Redis客户端。</li><li id="74c8" class="ms mt iq ka b kb nb kf nc kj nd kn ne kr nf kv mx my mz na bi translated">如果您的函数至少有1GB内存，那么打开/关闭函数中的Redis客户端。</li></ul><p id="c238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，我们对无服务器用例的建议是:</p><p id="23fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请在<a class="ae kw" href="https://twitter.com/upstash" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae kw" href="https://discord.com/invite/w9SenAtbme" rel="noopener ugc nofollow" target="_blank"> Discord </a>上告诉我们您的反馈。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="a408" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nn">原载于2021年4月1日https://blog.upstash.com</em><a class="ae kw" href="https://blog.upstash.com/serverless-database-connections" rel="noopener ugc nofollow" target="_blank"><em class="nn"/></a><em class="nn">。</em></p></div></div>    
</body>
</html>