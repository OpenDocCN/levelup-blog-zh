<html>
<head>
<title>Top 10 PHP 8.1 Features You Should Start Using Now</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你现在应该开始使用的10大PHP 8.1特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/top-10-php-8-1-features-you-should-start-using-now-7161b91275fd?source=collection_archive---------0-----------------------#2021-12-06">https://levelup.gitconnected.com/top-10-php-8-1-features-you-should-start-using-now-7161b91275fd?source=collection_archive---------0-----------------------#2021-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e819" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解PHP 8.1更新提供的最惊人的特性。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6c901c65b2d4234ae6d351344fc7628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ky2c6CrwZl1Ga3AsEwqZvg.png"/></div></div></figure><p id="1262" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">PHP 8.1现已推出，它提供了新的特性和性能改进——最令人兴奋的是新的JIT编译器。最近已于2021年11月25日上映。</p><p id="f761" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将详细演示PHP 8.1提供的10大特性，以便您可以开始在项目中使用它们，并改善您的PHP体验。初学者和有经验的开发人员可以从这篇文章中受益。</p><h1 id="b1b6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">PHP 8.1提供的十大特性</h1><ol class=""><li id="e648" class="mf mg iq kt b ku mh kx mi la mj le mk li ml lm mm mn mo mp bi translated">列举</li><li id="5b00" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">纤维</li><li id="8ac9" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">“永不”返回类型</li><li id="d7ee" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">“只读”属性</li><li id="0653" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">最终类别常数</li><li id="3911" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">新的“array_is_list()”函数</li><li id="a2b3" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">新的“fsync()”和“fdatasync()”函数</li><li id="6c6e" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">字符串键数组的数组解包支持</li><li id="2851" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">用于目录上传的“$_FILES”中的新“full_path”键</li><li id="232d" class="mf mg iq kt b ku mq kx mr la ms le mt li mu lm mm mn mo mp bi translated">新的“IntlDatePatternGenerator”类</li></ol></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="76d1" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">1.列举</h1><p id="5da6" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对枚举的支持，也称为enum。它是一种逐项列出的类型，包含固定数量的可能值。请参考下面的代码片段，了解如何使用枚举。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="abdb" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">2.纤维</h1><p id="9887" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对纤程的支持，纤程是一个底层组件，它允许在PHP中执行并发代码。纤程是一个代码块，它包含自己的变量和状态堆栈。这些纤程可以被认为是应用程序线程，可以从主程序启动。一旦启动，主程序将不能暂停或终止纤程。它只能从光纤代码块内部暂停或端接。在纤程被挂起之后，控制权再次回到主程序，它可以从它被挂起的地方继续执行纤程。</p><blockquote class="nm nn no"><p id="9378" class="kr ks np kt b ku kv jr kw kx ky ju kz nq lb lc ld nr lf lg lh ns lj lk ll lm ij bi translated">纤程本身不允许同时执行多个纤程或主线程和一个纤程。然而，对于PHP框架来说，有效地管理执行堆栈并允许异步执行是一个巨大的优势。</p></blockquote><p id="0fd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">参考下面的代码片段来理解如何使用纤程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="3c63" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">3.“永不”返回类型</h1><p id="b659" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对名为<code class="fe nt nu nv nw b">never</code>的新返回类型的支持。<code class="fe nt nu nv nw b">never</code>类型可以用来表示一个函数将在执行一组指定的任务后终止程序执行。这可以通过抛出异常、调用<code class="fe nt nu nv nw b">exit()</code>或<code class="fe nt nu nv nw b">die() </code>函数来实现。</p><blockquote class="nm nn no"><p id="b27d" class="kr ks np kt b ku kv jr kw kx ky ju kz nq lb lc ld nr lf lg lh ns lj lk ll lm ij bi translated">永不返回类型类似于<code class="fe nt nu nv nw b">void</code>返回类型。然而，<code class="fe nt nu nv nw b">void</code>返回类型在函数完成一组指定的任务后继续执行。</p></blockquote><p id="a078" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请参考下面的代码片段，了解如何使用永不返回类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="f59f" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">4.“只读”属性</h1><p id="1e09" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对名为<code class="fe nt nu nv nw b">readonly</code>的新类属性的支持。声明为只读的类属性只能初始化一次。里面设置的值不能更改。如果您尝试强制更新该值，应用程序将会抛出一个错误。请参考下面的代码片段，了解如何使用只读属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="47d1" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">5.最终类别常数</h1><p id="ba23" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对名为<code class="fe nt nu nv nw b">final</code>的类常量的新标志的支持。最终的类常量不能被修改，即使通过执行继承，这意味着这些不能被子类扩展或覆盖。</p><blockquote class="nm nn no"><p id="6e2b" class="kr ks np kt b ku kv jr kw kx ky ju kz nq lb lc ld nr lf lg lh ns lj lk ll lm ij bi translated">此标志不能用于私有常量，因为它不能在类外部访问。同时声明final和private常量将导致致命错误。</p></blockquote><p id="6fc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请参考下面的代码片段，了解如何使用final标志。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="ea8e" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">6.新的“array_is_list()”函数</h1><p id="64af" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对名为<code class="fe nt nu nv nw b">array_is_list()</code>的新数组函数的支持。它标识指定数组是否包含从0开始的所有连续整数。如果数组是值的语义列表(数组的键从0开始，都是整数，中间没有间隔)，则该函数返回true。对于空数组，它也返回true。参考下面的代码片段来理解如何使用array_is_list()函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bfc1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果数组的键不是从零开始，或者键不是整数，或者键是整数，但是没有按顺序出现，则该数组的值为false。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="99cd" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">7.新的“fsync()”和“fdatasync()”函数</h1><p id="110d" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对<code class="fe nt nu nv nw b">fsync()</code>和<code class="fe nt nu nv nw b">fdatasync()</code>函数的支持。两者都与现有的<code class="fe nt nu nv nw b">fflush()</code>函数相似，后者目前用于将缓冲区刷新到操作系统中。然而，<code class="fe nt nu nv nw b">fsync()</code>和<code class="fe nt nu nv nw b">fdatasync()</code>将缓冲区刷新到物理存储器。它们之间唯一的区别是<code class="fe nt nu nv nw b">fsync()</code>函数在同步文件更改时包含元数据，而<code class="fe nt nu nv nw b">fdatasync()</code>函数不包含。</p><blockquote class="nm nn no"><p id="2bfd" class="kr ks np kt b ku kv jr kw kx ky ju kz nq lb lc ld nr lf lg lh ns lj lk ll lm ij bi translated"><code class="fe nt nu nv nw b">fsync()</code>函数将获取一个文件指针，并尝试将更改提交到磁盘。如果成功，它将返回true如果失败，它将返回false如果资源不是文件，它将发出警告。<code class="fe nt nu nv nw b">fdatasync()</code>函数以同样的方式工作，但是更快一些，因为fsync()将尝试完全同步文件的数据变化和关于文件的元数据(最后修改时间等)。)，技术上是两次磁盘写入。</p></blockquote><p id="3188" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">参考下面的代码片段来理解如何使用fsync()和fdatasync()函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="659c" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">8.字符串键数组的数组解包支持</h1><p id="0c21" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对解包字符串数组的支持。为了解开一个数组，PHP使用了一个spread <code class="fe nt nu nv nw b">(…)</code>操作符。PHP 7.4引入了这个操作符来合并两个或多个数组，但是语法更加简洁。但是在PHP 8.1之前，spread操作符只支持带数字键的数组。请参考下面的代码片段，了解如何对字符串键数组使用spread运算符。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="ed04" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">9.用于目录上传的“$_FILES”中的新“full_path”键</h1><p id="b798" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1在<code class="fe nt nu nv nw b">$_FILES</code>全局变量中增加了对新的<code class="fe nt nu nv nw b">full_path</code>键的支持。在PHP 8.1之前，<code class="fe nt nu nv nw b">$_FILES</code>没有存储相对路径或服务器的确切目录。因此，您无法使用HTML文件上传表单上传整个目录。新的<code class="fe nt nu nv nw b">full_path</code>钥匙解决了这个问题。它存储相对路径，并在服务器上重建精确的目录结构，使目录上传成为可能。参考下面的代码片段来理解如何将<code class="fe nt nu nv nw b">full_path</code>键与<code class="fe nt nu nv nw b">$_FILES</code>全局变量一起使用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="9738" class="ln lo iq bd lp lq nc ls lt lu nd lw lx jw ne jx lz jz nf ka mb kc ng kd md me bi translated">10.新的“IntlDatePatternGenerator”类</h1><p id="0606" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">PHP 8.1增加了对新的<code class="fe nt nu nv nw b">IntlDatePatternGenerator</code>类的支持。在PHP 8.1之前，只能用<code class="fe nt nu nv nw b">IntlDateFormatter</code>创建本地化的日期和时间。它支持使用昨天、今天和明天的八种预定义格式。但是这些格式不像<code class="fe nt nu nv nw b">IntlDatePatternGenerator</code>提供的那样可以定制。这个类允许指定日期、月份和时间的格式，顺序将由该类自动处理。请参考下面的代码片段，了解如何使用IntlDatePatternGenerator类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="1f0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太棒了。您已经学习完了PHP 8.1提供的特性。现在，您可以开始在当前或即将到来的项目中实现上述特性。</p><blockquote class="nm nn no"><p id="e106" class="kr ks np kt b ku kv jr kw kx ky ju kz nq lb lc ld nr lf lg lh ns lj lk ll lm ij bi translated">如果你喜欢读这篇文章，并且学到了一些新的东西，那么请鼓掌，与你的朋友分享，并关注我以获得我即将发布的文章的更新。你可以在<a class="ae nx" href="https://www.linkedin.com/in/tara-prasad-routray-b83027145/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我。</p></blockquote></div></div>    
</body>
</html>