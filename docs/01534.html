<html>
<head>
<title>Deriving, Signing, and Verifying a JWT (JSON Web Token) with Node JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用节点JS派生、签名和验证JWT (JSON Web令牌)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deriving-signing-and-verifying-a-jwt-json-web-token-with-node-js-f3d0d12b1fc9?source=collection_archive---------1-----------------------#2020-01-11">https://levelup.gitconnected.com/deriving-signing-and-verifying-a-jwt-json-web-token-with-node-js-f3d0d12b1fc9?source=collection_archive---------1-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1dd3971ba606c105218a79626df6c39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rL6xRp15BCJRHqpv4DVGyw.png"/></div></div></figure><h1 id="e730" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">JSON Web令牌的组件(JWT)</h1><p id="962b" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在最基本的层面上，JSON Web令牌(JWT)只是包含用户信息的一小段数据。它包含三个部分:</p><ol class=""><li id="9afd" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">页眉</li><li id="63be" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">有效载荷</li><li id="6b53" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">签名</li></ol><p id="7356" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">每个部分都以Base64url格式编码(比JSON对象更容易通过HTTP协议传输)。</p><p id="2814" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">这里有一个JWT的例子:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="96d1" class="mz kc it mv b gy na nb l nc nd">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.POstGetfAytaZS82wHcjoTyoqhMyxXiWdR7Nn7A29DNSl0EiXLdwJ6xC6AfgZWF1bOsS_TuYI3OG85AmiExREkrS6tDfTQ2B3WXlrr-wp5AokiRbz3_oB4OxG-W9KcEEbDRcZc0nH3L7LzYptiy1PtAylQGxHTWZXtGz4ht0bAecBgmpdgXMguEIcoqPJ1n3pIWk_dUZegpqx0Lka21H6XxUTxiy8OcaarA8zdnPUnV6AmNP3ecFawIFYdvJB_cm-GvpCSbr8G8y_Mllj8f4x9nBH8pQux89_6gUY618iYv7tuPWBFfEbLxtF2pZS6YC1aSfLQxeNe8djT9YjpvRZA</span></pre><p id="02f3" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">请注意这段文字中的句号<code class="fe ne nf ng mv b">.</code>。这些句点将报头、有效载荷和签名分开。让我们分离出头部:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ac05" class="mz kc it mv b gy na nb l nc nd">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9</span></pre><p id="feea" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">现在，让我们安装NodeJS <code class="fe ne nf ng mv b">base64url</code>库并对此进行解码。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="6e9b" class="mz kc it mv b gy na nb l nc nd">npm install --save base64url</span><span id="1fde" class="mz kc it mv b gy nh nb l nc nd"># I am running this from Node console</span><span id="6265" class="mz kc it mv b gy nh nb l nc nd">const base64 = require('base64url');</span><span id="b6a3" class="mz kc it mv b gy nh nb l nc nd">const headerInBase64UrlFormat = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9';</span><span id="4938" class="mz kc it mv b gy nh nb l nc nd">const decoded = base64.decode(headerInBase64UrlFormat);</span><span id="bfc5" class="mz kc it mv b gy nh nb l nc nd">console.log(decoded);</span></pre><p id="0e8a" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">如果我们如上所示解码这个头，它将给出下面的<strong class="lb iu"> JSON </strong>对象(因此得名“JSON”Web令牌):</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="7e5e" class="mz kc it mv b gy na nb l nc nd">{<br/>    "alg":"RS256",<br/>    "typ":"JWT"<br/>}</span></pre><p id="7c55" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">我们稍后将了解这意味着什么，但是现在，让我们使用相同的方法解码有效载荷和签名。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="afc8" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">上述代码的结果将是:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="a2ee" class="mz kc it mv b gy na nb l nc nd"># Header<br/>{<br/>    "alg":"RS256",<br/>    "typ":"JWT"<br/>}</span><span id="3d22" class="mz kc it mv b gy nh nb l nc nd"># Payload<br/>{<br/>    "sub":"1234567890",<br/>    "name":"John Doe",<br/>    "admin":true,<br/>    "iat":1516239022<br/>}</span><span id="578d" class="mz kc it mv b gy nh nb l nc nd"># Signature<br/>Lots of gibberish like - ��e宿���(�$[����4\e�'</span></pre><p id="3be7" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">现在，忽略JWT的签名部分。它不能被解码成有意义的JSON对象的原因是因为它比头部和有效载荷稍微复杂一些。我们将很快对此进行进一步的探索。</p><p id="fc09" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">让我们看一下报头和有效载荷。</p><p id="0b96" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">标题同时具有一个<code class="fe ne nf ng mv b">alg</code>和<code class="fe ne nf ng mv b">typ</code>属性。这两个都在JWT，因为它们代表了解释那个乱糟糟的签名的“指令”。</p><p id="d064" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">有效负载是最简单的部分，它只是我们正在验证的用户的信息。</p><ul class=""><li id="4dd7" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw nk mf mg mh bi translated"><code class="fe ne nf ng mv b">sub</code>——“主题”的缩写，通常代表数据库中的用户ID</li><li id="663d" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw nk mf mg mh bi translated"><code class="fe ne nf ng mv b">name</code> -只是一些关于用户的任意元数据</li><li id="4a4b" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw nk mf mg mh bi translated"><code class="fe ne nf ng mv b">admin</code> -更多关于用户的任意元数据</li><li id="622d" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw nk mf mg mh bi translated"><code class="fe ne nf ng mv b">iat</code>—“发行时间”的缩写，代表本JWT的发行时间</li></ul><p id="0acb" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">使用jwt，您可能还会在有效负载中看到以下信息:</p><ul class=""><li id="c6a8" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw nk mf mg mh bi translated"><code class="fe ne nf ng mv b">exp</code>—“到期时间”的缩写，表示该JWT到期的时间</li><li id="42a4" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw nk mf mg mh bi translated"><code class="fe ne nf ng mv b">iss</code> -“发行者”的缩写，通常在中央登录服务器发行许多JWT令牌时使用(在OAuth协议中也大量使用)</li></ul><p id="f888" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">你可以在这个链接看到JWT规范<a class="ae nl" href="https://tools.ietf.org/html/rfc7519#section-4.1" rel="noopener ugc nofollow" target="_blank">的所有“标准声明”。</a></p><h1 id="4dd4" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">逐步创建签名</h1><p id="3c3a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">虽然我告诉过你不要担心我们在试图解码JWT的<code class="fe ne nf ng mv b">signature</code>部分时收到的乱码，但我确信它仍然很烦人。在本节中，我们将学习它是如何工作的，但是首先<strong class="lb iu"/>，你需要阅读<a class="ae nl" href="https://medium.com/@zach.gollwitzer/whats-the-point-of-public-key-cryptography-and-how-does-it-work-bd1ab46550ed" rel="noopener">我写的这篇文章，这篇文章解释了公钥加密是如何工作的</a>(根据你对这个主题的熟悉程度，应该需要10-20分钟)。</p><p id="4ad2" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">即使你对题目很熟悉，你也应该略读文章。如果您对公钥密码学没有扎实的理解，这一节将毫无意义。</p><p id="422a" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">不管怎样…</p><p id="f86e" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">JWT的签名实际上是“T1”和“T2”的组合。它是这样创建的(下面是伪代码):</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="85d2" class="mz kc it mv b gy na nb l nc nd">// NOTE: This is pseudocode!!</span><span id="1e3d" class="mz kc it mv b gy nh nb l nc nd">// Copied from the original JWT we are using as an example above</span><span id="150f" class="mz kc it mv b gy nh nb l nc nd">const base64UrlHeader = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9';</span><span id="07a4" class="mz kc it mv b gy nh nb l nc nd">const base64UrlPayload = 'eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0';</span><span id="254a" class="mz kc it mv b gy nh nb l nc nd">// We take a one-way hash of the header and payload using the SHA256 hashing algorithm.  We know to use this algorithm because it was specified in the JWT header</span><span id="9b9e" class="mz kc it mv b gy nh nb l nc nd">const hashedData = sha256hashFunction(base64UrlHeader + '.' + base64UrlPayload);</span><span id="40c6" class="mz kc it mv b gy nh nb l nc nd">// The issuer (in our case, it will be the Express server) will sign the hashed data with its private key</span><span id="7e14" class="mz kc it mv b gy nh nb l nc nd">const encryptedData = encryptFunction(issuer_priv_key, hashedData);</span><span id="538e" class="mz kc it mv b gy nh nb l nc nd">const finalSignature = convertToBase64UrlFunction(encryptedData);</span></pre><p id="c5e5" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">尽管<code class="fe ne nf ng mv b">sha256hashFunction</code>、<code class="fe ne nf ng mv b">encryptFunction</code>和<code class="fe ne nf ng mv b">convertToBase64UrlFunction</code>是由伪代码组成的，上面的例子解释了创建签名的过程。</p><p id="3031" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">现在，让我们使用NodeJS <code class="fe ne nf ng mv b">crypto</code>库来实际实现上面的伪代码。下面是我用来生成这个示例JWT的公钥和私钥(我们将需要它们来创建和解码JWT的签名)。请注意，在正常情况下，您永远不会像这样共享私钥。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="43b2" class="mz kc it mv b gy na nb l nc nd">-----BEGIN PUBLIC KEY-----<br/>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnzyis1ZjfNB0bBgKFMSv<br/>vkTtwlvBsaJq7S5wA+kzeVOVpVWwkWdVha4s38XM/pa/yr47av7+z3VTmvDRyAHc<br/>aT92whREFpLv9cj5lTeJSibyr/Mrm/YtjCZVWgaOYIhwrXwKLqPr/11inWsAkfIy<br/>tvHWTxZYEcXLgAXFuUuaS3uF9gEiNQwzGTU1v0FqkqTBr4B8nW3HCN47XUu0t8Y0<br/>e+lf4s4OxQawWD79J9/5d3Ry0vbV3Am1FtGJiJvOwRsIfVChDpYStTcHTCMqtvWb<br/>V6L11BWkpzGXSW4Hv43qa+GSYOD2QU68Mb59oSk2OB+BtOLpJofmbGEGgvmwyCI9<br/>MwIDAQAB<br/>-----END PUBLIC KEY-----</span><span id="d48a" class="mz kc it mv b gy nh nb l nc nd">-----BEGIN RSA PRIVATE KEY-----<br/>MIIEogIBAAKCAQEAnzyis1ZjfNB0bBgKFMSvvkTtwlvBsaJq7S5wA+kzeVOVpVWw<br/>kWdVha4s38XM/pa/yr47av7+z3VTmvDRyAHcaT92whREFpLv9cj5lTeJSibyr/Mr<br/>m/YtjCZVWgaOYIhwrXwKLqPr/11inWsAkfIytvHWTxZYEcXLgAXFuUuaS3uF9gEi<br/>NQwzGTU1v0FqkqTBr4B8nW3HCN47XUu0t8Y0e+lf4s4OxQawWD79J9/5d3Ry0vbV<br/>3Am1FtGJiJvOwRsIfVChDpYStTcHTCMqtvWbV6L11BWkpzGXSW4Hv43qa+GSYOD2<br/>QU68Mb59oSk2OB+BtOLpJofmbGEGgvmwyCI9MwIDAQABAoIBACiARq2wkltjtcjs<br/>kFvZ7w1JAORHbEufEO1Eu27zOIlqbgyAcAl7q+/1bip4Z/x1IVES84/yTaM8p0go<br/>amMhvgry/mS8vNi1BN2SAZEnb/7xSxbflb70bX9RHLJqKnp5GZe2jexw+wyXlwaM<br/>+bclUCrh9e1ltH7IvUrRrQnFJfh+is1fRon9Co9Li0GwoN0x0byrrngU8Ak3Y6D9<br/>D8GjQA4Elm94ST3izJv8iCOLSDBmzsPsXfcCUZfmTfZ5DbUDMbMxRnSo3nQeoKGC<br/>0Lj9FkWcfmLcpGlSXTO+Ww1L7EGq+PT3NtRae1FZPwjddQ1/4V905kyQFLamAA5Y<br/>lSpE2wkCgYEAy1OPLQcZt4NQnQzPz2SBJqQN2P5u3vXl+zNVKP8w4eBv0vWuJJF+<br/>hkGNnSxXQrTkvDOIUddSKOzHHgSg4nY6K02ecyT0PPm/UZvtRpWrnBjcEVtHEJNp<br/>bU9pLD5iZ0J9sbzPU/LxPmuAP2Bs8JmTn6aFRspFrP7W0s1Nmk2jsm0CgYEAyH0X<br/>+jpoqxj4efZfkUrg5GbSEhf+dZglf0tTOA5bVg8IYwtmNk/pniLG/zI7c+GlTc9B<br/>BwfMr59EzBq/eFMI7+LgXaVUsM/sS4Ry+yeK6SJx/otIMWtDfqxsLD8CPMCRvecC<br/>2Pip4uSgrl0MOebl9XKp57GoaUWRWRHqwV4Y6h8CgYAZhI4mh4qZtnhKjY4TKDjx<br/>QYufXSdLAi9v3FxmvchDwOgn4L+PRVdMwDNms2bsL0m5uPn104EzM6w1vzz1zwKz<br/>5pTpPI0OjgWN13Tq8+PKvm/4Ga2MjgOgPWQkslulO/oMcXbPwWC3hcRdr9tcQtn9<br/>Imf9n2spL/6EDFId+Hp/7QKBgAqlWdiXsWckdE1Fn91/NGHsc8syKvjjk1onDcw0<br/>NvVi5vcba9oGdElJX3e9mxqUKMrw7msJJv1MX8LWyMQC5L6YNYHDfbPF1q5L4i8j<br/>8mRex97UVokJQRRA452V2vCO6S5ETgpnad36de3MUxHgCOX3qL382Qx9/THVmbma<br/>3YfRAoGAUxL/Eu5yvMK8SAt/dJK6FedngcM3JEFNplmtLYVLWhkIlNRGDwkg3I5K<br/>y18Ae9n7dHVueyslrb6weq7dTkYDi3iOYRW8HRkIQh06wEdbxt0shTzAJvvCQfrB<br/>jg/3747WSsf/zBTcHihTRBdAv6OmdhV4/dD5YBfLAkLrd+mX7iE=<br/>-----END RSA PRIVATE KEY-----</span></pre><p id="c5bd" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">首先，让我们创建头部和有效载荷。为此我将使用<code class="fe ne nf ng mv b">base64url</code>库，所以请确保您已经安装了它。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">createJWT.js</figcaption></figure><p id="6413" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">嘣！您刚刚创建了JWT的前两个部分。现在，让我们将签名的创建添加到这个脚本中。为此，我们将需要内置的NodeJS <code class="fe ne nf ng mv b">crypto</code>库和私钥。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">createJWT.js</figcaption></figure><p id="1a79" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">在上面的代码中，我重复了之前运行的脚本，并添加了创建签名的逻辑。在这段代码中，我们首先通过一个<code class="fe ne nf ng mv b">.</code>字符将头和有效负载(base64url编码)附加在一起。然后，我们将这些内容写入我们的签名函数，这是内置的NodeJS加密库的<code class="fe ne nf ng mv b">RSA-SHA256</code>签名类。虽然听起来很复杂，但这一切告诉我们的是:</p><ol class=""><li id="76c1" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">使用RSA标准4096位公共/私有密钥对</li><li id="553d" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">对于<code class="fe ne nf ng mv b">base64Url(header) + '.' + base64Url(payload)</code>的散列，使用<code class="fe ne nf ng mv b">SHA256</code>散列算法。</li></ol><p id="99de" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">在JWT标题中，您会注意到这是由<code class="fe ne nf ng mv b">RS256</code>表示的，这只是<code class="fe ne nf ng mv b">RSA-SHA256</code>的一种缩写方式。</p><p id="fde5" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">一旦我们将内容写入这个函数，我们需要从一个文件中读取将要签名的私钥。我已经将本文前面显示的私钥存储在一个名为<code class="fe ne nf ng mv b">id_rsa_priv.pem</code>的文件中，该文件位于当前工作目录中，以<code class="fe ne nf ng mv b">.pem</code>格式存储(相当标准)。</p><p id="3cde" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">接下来，我将对数据进行“签名”,首先用<code class="fe ne nf ng mv b">SHA256</code>散列函数对数据进行散列，然后用私钥对结果进行加密。</p><p id="c6d1" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">最后，由于NodeJS加密库以<code class="fe ne nf ng mv b">Base64</code>格式返回我们的值，我们需要使用<code class="fe ne nf ng mv b">base64Url</code>库将其从Base64转换为Base64Url。</p><p id="fdc3" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">一旦完成，你将有一个JWT标题，有效载荷和签名，匹配我们原来的JWT完美！</p><h1 id="06e0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">逐步验证签名</h1><p id="34ab" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在上一节中，我们看了如何创建JWT签名。在用户身份验证中，流程如下所示:</p><ol class=""><li id="2724" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">服务器接收登录凭证(用户名、密码)</li><li id="c80b" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">服务器执行一些逻辑来验证这些凭证是有效的</li><li id="4d77" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">如果凭证是有效的，服务器发布并<em class="nq">签署</em>一个JWT并将其返回给用户</li><li id="b904" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">用户使用颁发的JWT在浏览器中验证未来的请求</li></ol><p id="ae7f" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">但是，当用户向应用程序的受保护路由或受保护API端点发出另一个请求时，会发生什么呢？</p><p id="24ce" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">您的用户向服务器提供了一个JWT令牌，但是您的服务器如何解释这个令牌并决定用户是否有效呢？以下是基本步骤。</p><ol class=""><li id="f947" class="lx ly it lb b lc lz lg ma lk mb lo mc ls md lw me mf mg mh bi translated">服务器收到一个JWT令牌</li><li id="dc67" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">服务器首先检查JWT令牌是否过期，以及过期日期是否已过。如果是，服务器拒绝访问。</li><li id="6723" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">如果JWT没有过期，服务器将首先把<code class="fe ne nf ng mv b">header</code>和<code class="fe ne nf ng mv b">payload</code>从Base64Url转换成JSON格式。</li><li id="d461" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">服务器在JWT的<code class="fe ne nf ng mv b">header</code>中寻找解密签名所需的散列函数和加密算法(我们假设在这个例子中，JWT使用<code class="fe ne nf ng mv b">RSA-SHA256</code>作为算法。</li><li id="0c11" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">服务器使用一个<code class="fe ne nf ng mv b">SHA256</code>散列函数来散列<code class="fe ne nf ng mv b">base64Url(header) + '.' + base64Url(payload)</code>，这给服务器留下一个散列值。</li><li id="3e12" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">服务器使用存储在其文件系统中的<code class="fe ne nf ng mv b">Public Key</code>来解密<code class="fe ne nf ng mv b">base64Url(signature)</code>(记住，私钥加密，公钥解密)。因为服务器既创建签名又验证签名，所以它应该在文件系统中存储公钥和私钥。对于较大的用例，通常会将这些任务分离到完全独立的机器上。</li><li id="48fd" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">服务器比较步骤5和步骤6的值。如果它们匹配，这个JWT就是有效的。</li><li id="4aa8" class="lx ly it lb b lc mi lg mj lk mk lo ml ls mm lw me mf mg mh bi translated">如果JWT有效，服务器将使用<code class="fe ne nf ng mv b">payload</code>数据来获取用户的更多信息，并对该用户进行身份验证。</li></ol><p id="c3a0" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">使用我们在这篇文章中一直使用的<strong class="lb iu">相同的JWT </strong>，下面是这个过程在代码中的样子:</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">verifyJWT.js</figcaption></figure><p id="d8a6" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">这段代码中有几项值得注意。首先，我们把Base64Url编码的JWT分成3部分。然后我们使用内置的NodeJS <code class="fe ne nf ng mv b">createVerify</code>函数创建一个新的<code class="fe ne nf ng mv b">Verify</code>类。就像创建签名的过程一样，我们需要将<code class="fe ne nf ng mv b">base64url(header) + '.' + base64url(payload)</code>传递给<code class="fe ne nf ng mv b">Verify</code>加密类使用的流。</p><p id="216e" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">下一步很关键——您需要将<code class="fe ne nf ng mv b">jwtSignature</code>从其默认编码Base64Url转换为&gt; Base64。然后，您需要传递公钥，即签名的Base64版本，并向NodeJS表明您正在使用Base64。如果你不指定编码，它将默认为一个缓冲区，你将总是得到一个错误的返回值。</p><p id="72ae" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">如果一切顺利，你应该得到一个真的返回值，这意味着这个签名是有效的！</p><h1 id="5fe9" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">缩小:JWT签名的真正价值</h1><p id="f69a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果你阅读了上面的两节，你就知道如何使用<code class="fe ne nf ng mv b">RSA-SHA256</code> JWT算法来签署和验证JWT签名(其他算法的工作非常相似，但是这个算法被认为是更安全和“生产就绪”的算法之一)。</p><p id="e466" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">但这一切意味着什么呢？</p><p id="b9f6" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">如果您考虑其他身份验证方法(例如，使用Cookies和会话对用户进行身份验证)，您会知道为了这样做，您的应用程序服务器必须有一个跟踪会话的数据库，并且每当用户想要访问服务器上受保护的资源时，都必须调用该数据库。</p><p id="3d07" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">使用JWT认证，唯一需要验证用户是否通过认证的是一个公钥！！</p><p id="f03e" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">一旦颁发了JWT令牌(由您的应用程序服务器、身份验证服务器甚至第三方身份验证服务器颁发)，该JWT就可以安全地存储在浏览器中，并可用于验证任何请求，而无需使用任何数据库。应用服务器只需要发行者的公钥！</p><p id="5b72" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">如果你推断这个概念，并思考JWT的更广泛的含义，就会清楚它是多么强大。您不再需要本地数据库。您可以在整个web上传输身份验证！</p><p id="1a8b" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">比方说，我登录到一个流行的服务，如谷歌，我从谷歌的认证服务器收到一个JWT令牌。唯一需要验证我正在浏览的JWT的是与Google签名的私钥相匹配的公钥。通常，这个公钥是<em class="nq">公开</em>可用的，这意味着互联网上的任何人都可以验证我的JWT！如果他们信任谷歌，并且他们相信谷歌正在提供正确的公钥，那么我没有理由不使用谷歌发布的JWT来认证进入我的应用程序的用户。</p><p id="779c" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">我知道我说过我们不会在这篇文章中涉及所有OAuth的东西，但这是委托认证的本质(即OAuth2.0协议、OpenIDConnect、访问令牌、授权令牌等。)!</p><h1 id="ae59" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">更简单的解决方案</h1><p id="cca1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">到目前为止，我们已经了解了解构一个JWT，用NodeJS <code class="fe ne nf ng mv b">crypto</code>库签名它，并用NodeJS <code class="fe ne nf ng mv b">crypto</code>库验证它的完整过程。</p><p id="0abd" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">但是，如果你可能已经注意到，我们必须写很多代码来做到这一点！此外，我们还必须在各种格式(JSON、base64、base64urlencoded)之间进行转换。</p><p id="8ee5" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">难道在应用程序中没有更简单的方法来做到这一点吗？</p><p id="c2dd" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">要理解jwt，使用NodeJS <code class="fe ne nf ng mv b">crypto</code>库是一个很好的工具。在实践中，我们想要抽象出很多细节的东西。这就是为什么在大多数情况下，您将使用<code class="fe ne nf ng mv b">jsonwebtoken</code> NPM库来签署和验证jwt。此外，如果您使用Passport JS框架中的<code class="fe ne nf ng mv b">passport-jwt</code>策略(参见本文)，您需要编写的代码将会更少！</p><p id="07e7" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">下面，我写了和上面我们用NodeJS <code class="fe ne nf ng mv b">crypto</code>库做的完全一样的东西，但是使用了<code class="fe ne nf ng mv b">jsonwebtoken</code>库。看一看，我们将审查它。</p><figure class="mq mr ms mt gt ju"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">signandverifywithjsonwebtoken . js</figcaption></figure><p id="2986" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">有了<a class="ae nl" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> jsonwebtoken库</a>，您不需要对base64/base64urlencoded编码或向NodeJS流传递数据来签署数据感到着迷。你所要做的就是传递带有几个参数的<code class="fe ne nf ng mv b">jsonwebtoken.sign()</code>和<code class="fe ne nf ng mv b">jsonwebtoken.verify()</code>方法，你就完成了！</p><p id="a40f" class="pw-post-body-paragraph kz la it lb b lc lz le lf lg ma li lj lk mn lm ln lo mo lq lr ls mp lu lv lw im bi translated">通常，一个教程从<code class="fe ne nf ng mv b">jsonwebtoken</code>库开始，并试图解释其内部。希望从内部开始，您可以更清晰地理解这个通用语法。如果你有任何问题，请在下面的评论中提出！</p></div></div>    
</body>
</html>