# 主 RxJS:使用 BehaviorSubject 在服务中存储前端数据

> 原文：<https://levelup.gitconnected.com/master-rxjs-data-stores-in-services-c1f553e5d48b>

## 如何使用 BehaviorSubject 而不触发不必要的重新渲染、内存问题和不必要的突变

![](img/f81704111c8cde2b183cb07e4e6734c1.png)

[丘特尔斯纳普](https://unsplash.com/@chuttersnap?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

随着在向 UI 组件交付数据的服务中使用 RxJS 的流行，越来越多的人只使用 RxJS **而不是更专用的应用程序状态管理包，如 NgRx、Redux、NGXS 等。，尤其是有棱角的。**

一种常用的模式是让一个 BehaviorSubject 保存数据，并作为 Http 响应处理过程的一部分使用`.next()`插入数据。让我们以此为起点，逐步改进，讨论每个步骤的问题和解决方案。

> 重要！开始之前，请阅读以下内容！

*请注意，下面描述的许多方法，如深度冻结和简单对象比较* ***，对于某些数据类型*** *将无法正常工作，例如不仅* `*Map*` *、* `*Set*` *、* `*WeakMap*` *和* `*WeakSet*` *，还有* `*function*` *。希望你没有在服务中的 base* `*BehaviorSubject*` *中存储任何这些类型，但是如果你存储了，请注意你将不得不手动规避与这些相关的任何问题。*

# 第一步:商店开门迎客

假设我们有一个为用户获取`userData`的服务。我们忽略了如何识别用户，而只是简单地看一个没有返回用户的参数的 get 调用。

消费者很容易改变其状态的商店

这里，变量`USER_DATA_INIT`是一个匹配类型`UserData`的初始化对象。除此之外，它非常简单。首先，让我们讨论并解决这个实现的两个突出问题。

## **公共用户数据$**

第一个大问题是，`userData$`是`public`，因此暴露在服务之外。这意味着任何使用`UserService`的组件或其他服务都可以调用`.next()`方法来覆盖存储服务中的任何内容。换句话说，什么数据可以存储在`userData$`中的定义并不局限于这个类，可以在代码库中的任何地方任意修改。

解决这个问题最简单的方法是将`userData$`声明为私有的，并公开消费者可以利用的公共选择器函数。这些选择器函数是可观察的，要么返回整个对象，要么只返回特定的字段。一个例子是`public userName$`，它只从`userData$`中暴露`userName`属性。

*(如果你想暴露整个* `*BehaviorSubject*` *你也可以把* `*userData$.asObservable()*` *暴露为一个公共变量。)*

## 可变用户数据

尽管这取决于类型`UserData`的结构，但是存储在`dataStore$`中的对象在这一点上是完全可变的。虽然选择器将确保第一级道具不再是可变的，但是嵌套对象仍然可以被任何消费者改变。

例如，假设我们有一个名为`messages`的道具，它包含一个类型为`Message`的数组。如果任何消费者订阅该服务并访问该属性，该消费者可以使用`push`或`pop`或任何其他改变数组的数组函数，存储在`UserDataService`中的数据当然会改变，这意味着该服务的所有其他消费者将在各自的过程中使用改变后的数组。

对于大多数 Javascript 开发人员来说，这个问题应该再熟悉不过了。虽然有无数的文章讨论如何处理可变性和冻结，但我倾向于使用一个递归的`deepFreeze`函数来处理这个问题。我使用的实现如下所示:

deepFreeze 的一个可能实现

# 第二步:嘈杂的商店

实施上面讨论的更改，我们最终会得到以下结果:

一家噪音很大的商店，比正常情况下排放的气体要多得多！

看起来好多了！对于大多数应用程序来说，这可能就足够了。但是在这一步，让我们看看如何减少由于对重复数据输入处理不当而导致的不必要的排放。关于这一点，我们可以解决两个具体问题:

## **重复门店排放**

让我们假设用户浏览你的站点，并访问两个独立的页面，这两个页面都触发了对`userData`的获取。这是有意义的:毕竟，当用户访问时，API 上存储的数据很可能已经改变。但是，让我们假设用户收到的数据与前一次获取的数据完全相同。接下来会发生什么？

从 API 获取数据，订阅函数使用重复数据调用`userData$.next()`。`userData$`然后发出这个数据，所有的订阅和选择器将再次触发。

在这个简单的例子中，这不是一个很大的问题，但最近我在一个项目中使用提取的数据作为一些非常广泛的计算和处理前端的基础，用于计算各种变量和呈现给用户的图形。

有人可能认为这可以在 API 中完成，但是由于计算完全与 UI 相关，并且只与我们的特定堆栈相关(API 有许多消费者)，我们在前端执行这些操作。我们观察到，每隔一段时间，页面就会获取重复的值，这些重复的值会多次触发这些操作，从而降低页面的速度。

那么我们如何解决这个问题呢？那些熟悉 RxJs 的人可能会期待一个`distinctUntilChanged`的引入，虽然我们稍后会这样做，但我们现在要做一些稍微不同的事情。但在此之前，我们需要一种方法来查看以前的数据和当前的数据是否相同。

根据对象的简单或复杂程度，编写一个定制的验证器可能是明智的。我喜欢使用一个我称之为`naiveObjectComparison`的通用方法，但当然这不是我自己想出来的，因为大多数 Javascript 开发人员对此应该很熟悉。看起来是这样的:

简单对象比较

注意，对于某些数据类型，例如`Set`和`Map`，这种方法不能正常工作。

我们开始工作吧。我们将创建一个名为`Store`的新数据类型，它扩展了`BehaviorSubject`。在很大程度上，它将像`BehaviorSubject`一样工作，但是我们将覆盖下一个函数，以确保我们不会转发重复的函数。我们还将把传入数据的`deepFreeze`直接合并到类型中。我们以下面的定义结束:

解决冻结和过滤重复数据输入的自定义存储数据类型

然后我们用`userDataService`中的`Store`替换`BehaviorSubject`，并删除 Http 订阅中的`deepFreeze`调用。因此，作为我们的第一步，我们现在已经修复了重复的商店排放。

## 重复选择器发射

即使我们的存储不再发出重复数据，我们的选择器可能仍然会这样做。你可能会想，*嘿，Lars，我们刚刚在基础级别解决了这个问题！这已经不是问题了，对吧？* **错了。**

如果 Http 获取再次被触发，假设用户的年龄已经改变(在她生日前的午夜浏览！)，那么显然我们的`Store.next()`函数会认为数据被改变并插入新的数据。这将依次向**所有**订户发送值，这意味着**所有**我们的选择器现在都将被触发，即使只有一个字段被更新。

这一次我们将使用前面提到的`distinctUntilChanged`操作符。`distinctUntilChanged`通过比较先前的排放和当前的排放，过滤掉与上一次相同的排放。

对于`userName$`和`age$`，我们只需在`map`操作符后添加`distinctUntilChanged()`。

**注意，这个顺序很重要**；如果将`distinctUntilChanged()`放在`map`之前，它将比较**输入**而不是**输出**。我们想要停止相同的**输出**，意思是`name`或`age`，而不是相同的**输入**，意思是`userData`对象本身。过滤重复的`userData`输入在上一步已经解决。

**遵循关注点分离原则，我们应始终假设选择器的输入已经过重复发射过滤程序。**

因为这并不容易。注意`messages$`不是一个原语，而是一个数组，因此是一个对象。默认情况下，`distinctUntilChanged()`使用`===`进行比较，这意味着它只比较引用，而不比较任何属性的实际值。

然而，`distinctUntilChanged`采用比较函数作为参数，允许用户手动比较以前和当前的排放量。在这种情况下，为已知结构的道具编写一个自定义函数通常是明智的，但是在这种情况下使用`naiveObjectComparison`也是可以的。

# 步骤 3:选择器繁忙的内存泄漏存储

实现上述更改后，我们的服务现在看起来像这样:

一家不断发展壮大的商店，选择器的工作太多了

好多了！但是我们还可以做一个优化，它可能会产生相当大的影响。

**向管道添加订阅时，RxJs 的默认行为是为每个订阅创建该管道的新实例及其所有操作符。虽然这种行为在很多情况下是件好事，但对于数据存储的值选择器来说，这是不必要的，而且可能会占用大量资源。**

例如，假设您有一个服务，它将数据映射为图形 UI 的现成数据。在 UI 中，有两个组件显示的图形略有不同，但它们都订阅了相同的选择器函数来进行数据映射。

**在这种情况下，数据映射过程将运行*两次——每次订阅运行*一次——每次发出新数据。**

此外，随着订阅数量的增加，还存在内存泄漏的问题。您可能认为这不是问题，因为单个可观察对象的内存占用非常小。

然而，随着应用程序变得越来越复杂，我们经常创建使用选择器的**选择器，以及使用这些选择器的选择器，等等**。至少在我工作过的堆栈中，有一些服务组合起来达到了 **20(！)**选择器从应用程序的各个部分创建一个新的选择器，然后这个选择器在被 UI 访问之前被另一个级别订阅，在 UI 组件中，同一个选择器上可能有四个或五个订阅，它们做不同的事情。

您的应用程序可能有**千个**重复的可观察对象，它们**执行完全相同的任务并发出完全相同的值。**你可能认为解决这个问题的方法是限制嵌套订阅的级别，**但是我们希望开发者能够像鸟儿一样筑巢！**嵌套选择器是最强大的工具之一，用于将数据从它们的基础逐渐转换成每个 UI 组件需要的数据。

幸运的是，RxJs 提供了一些操作符来帮助解决这些问题。第一个被称为`share`，它的工作原理是**确保只有一个管道实例存在并被所有订阅者使用。**换句话说，它是一个无比强大的运营商。

虽然这本身是好的，但在使用任何`BehaviorSubject`管道时有一个警告。默认情况下，当在`BehaviorSubject`上创建订阅时，首先通过立即发出当前值来同步订阅，然后在发出任何后续发出时异步订阅。

`share`将改变这种行为，因为从`BehaviorSubject`的角度来看，每个选择器只有一个订阅。因此，`share`将仅在第一次订阅时获得存储在`BehaviorSubject`中的值，任何后续订阅者将仅从`BehaviorSubject`获得异步发射。

幸运的是，RxJs 有另一个类似的操作符来解决这个问题。`shareReplay`操作符基本上类似于`share`，但是增加了同步返回最新值给任何新订户的行为。`shareReplay`接受一个参数，即存储和转发多少排放，但是在我们的例子中，我们想要模拟`BehaviorSubject`的默认行为，所以我们使用 1。

# 步骤 4:详细存储

我们当前的实现如下所示:

一家需要花很长时间才能打印出来的商店。说真的，所有商店都应该这么啰嗦吗！？

从功能上来说，我们的设置是可靠的，可以投入生产。我们出色的管道和工程解决了以下幼稚实现的问题:

*   **消费者改写存储的数据**
*   **消费者对存储的数据进行变异**
*   **重复的 Http 响应强制反应**
*   **重复数据值强制反应**
*   **内存泄漏和冗余处理**

然而，我们的解决方案开始变得有点冗长。每个选择器在其管道中至少需要一个`map`、一个`distinctUntilChanged`和一个`shareReplay`操作符。因为我们希望所有的选择器至少有这三个操作符，我们可以做得比一遍又一遍地定义它们更好。

还有一个问题是，如果类型是一个对象或数组，那么`distinctUntilChanged`应该将`naiveObjectComparison`作为一个参数，如果类型是一个原语，那么就没有参数，这种区别应该从开发人员那里抽象出来。除此之外，自定义的比较功能也应该被允许，由开发者在任何必要的时候决定。

**换句话说，虽然当前的实现在功能上是正确的，并且大大提高了用户体验，但是开发人员的体验却受到了影响。让我们解决这个问题。**

**选择$**

我们引入一个叫做`select$`的新函数。这个函数将返回一个可观察对象，包括我们当前在选择器管道中使用的所有操作符。它将一个源流和一个映射函数作为强制参数，并将一个`memoizationFunction`作为可选参数。

`source$`是源流，通常会是我们的存储对象；在这种特殊情况下`userData$`。

`mapping`功能将成为`map`操作器的参数。换句话说，它是一个描述我们如何从源发射中提取我们想要发射的道具的函数。`age$`的一个例子是`userData => userData.age`。

最后，`memoizationFunction`是用于确定我们之前和当前的排放量是否相等的函数。这是可选的，如果没有给出，我们使用默认的记忆功能，对对象运行`naiveObjectComparison`，否则运行`===`比较。

考虑到我们已经在前面的章节中完成了实现，大部分代码应该是简单明了的。这里要考虑的重要事情是，我们希望基于是否返回一个对象的不同行为。

在这种情况下，我们通过检查先前和当前值的类型来解决这个问题，如果它们是对象，我们使用`naiveObjectComparison`，否则我们使用`===`比较。

可以说，检查每次排放的类型并不太有效，但这优于替代解决方案:

*   使用 Typescript 和对`R`的限制来解决这个问题。这将意味着创建两个函数(`selectPrimitive$`和`selectObject$`)，因为我们无法利用类型限制运行时，实现会有所不同。如果忽略类型警告，这会给开发人员带来复杂性和运行时错误。
*   通过只检查一次类型来解决它。如果没有设置数据对象的属性，我们允许映射返回`null`或`undefined`，仅从这个事实我们不能确定映射函数在运行时通常是返回一个对象还是一个原语。换句话说，我们必须每次都检查类型。

也就是说，对每次排放的先前和当前值进行类型检查是一个非常快速的操作，尤其是考虑到我们已经消除了来自任何输入源的重复排放，因此这应该不是什么大问题。

如果任何读者对这个具体问题有更好的解决方案，请在下面留下评论，我很想知道！

# 最终解决方案:一个完美的商店

随着`select$`功能的完成，我们将`dataUserService`实现更改如下:

使用 select$ for 选择函数的完整存储

当然，`select$`也允许嵌套，没有任何问题。只要确保当你使用嵌套的`select$`时，声明顺序遵循树的深度。换句话说，如果你在`this.messages$`上使用`select$`来获得`dataUser.messages`的一个道具，确保`this.messages$`被首先声明。

除此之外，我们现在已经完成了漂亮的基本商店服务。这样，您就可以在服务中存储数据，并将其分发给组件和其他服务了！不错！

唷！精通 RxJs 不仅需要理解相当多的操作符，有时还需要理解 RxJs 在基本层面上的行为。当我第一次尝试在`BehaviorSubjects`上使用`share()` 时，我挣扎了很长时间才明白为什么它不能正确工作，因为我没有掌握一些关于`BehaviorSubject`和管道如何工作的基本概念。

坚持下去，它最终会到来的，一如既往…继续为你的成功铺平道路！

更多我关于专业 RxJs 和 Angular 的文章:

[](https://medium.com/swlh/master-rxjs-handling-auth-related-events-frontend-with-rxjs-a10c396c6493) [## 主 RxJs:用 RxJs 处理授权相关事件前端

### RxJs 擅长处理异步操作。今天，我们将探讨如何解决一个更具挑战性的问题…

medium.com](https://medium.com/swlh/master-rxjs-handling-auth-related-events-frontend-with-rxjs-a10c396c6493) [](https://larsholdaas.medium.com/master-rxjs-debounce-all-but-first-223eb90089dd) [## 主机 RxJs:除第一个之外的所有去抖

### 随着反应式表单和其他输入设置接受用户输入作为一个可观察的流，它已经变得相当…

larsholdaas.medium.com](https://larsholdaas.medium.com/master-rxjs-debounce-all-but-first-223eb90089dd)