<html>
<head>
<title>Improve Postgresql Performance by Reducing Dead Tuple without Auto-vacuum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过减少无自动清空的死元组来提高Postgresql性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improve-postgresql-performance-by-reducing-dead-tuple-without-auto-vacuum-f7538fdb7bb0?source=collection_archive---------9-----------------------#2022-06-06">https://levelup.gitconnected.com/improve-postgresql-performance-by-reducing-dead-tuple-without-auto-vacuum-f7538fdb7bb0?source=collection_archive---------9-----------------------#2022-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="5e2f" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/7f3229d77468c65aa0f19777a30a8755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iKeSz3LibpWnhjyx"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kl" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>拍照</figcaption></figure><p id="993f" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这个故事是关于我们在使用Postgres数据库时遇到的关键性能问题，以及我们的团队是如何解决的。</p><h1 id="3fc8" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">我们系统的高级概述</h1><figure class="mj mk ml mm gt ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi mi"><img src="../Images/f08dc360f93f8e849669b1d2588d4382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PD3hyp2fUnlfwx9fPMW_w.png"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk translated">导入数据，处理数据，然后导出数据</figcaption></figure><p id="8a3a" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如今，一切都与数据有关。我们的解决方案不断同步客户的业务数据，对其进行处理，并最终提供更多的业务见解，用有价值的信息丰富数据，以方便客户。</p><h1 id="cd73" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">问题是怎么出现的？</h1><p id="64ba" class="pw-post-body-paragraph km kn iq ko b kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf mr lh li lj ij bi translated">在工作中，我们有观察器，当我们的系统出现问题时，它会通知我们。突然，所有的观察者开始为一个特定的应用程序开火。</p><p id="f30e" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在做了一些调查后，我们注意到我们的Postgres严重超载。深入研究AWS性能洞察[1]后，我发现自动清空正在对特定的表积极执行。结果，我们的系统耗尽了CPU信用，这导致了显著的性能下降。最后，它降低了我们整个应用程序的速度。</p><p id="97ba" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">一个显而易见的问题是，为什么自动吸尘会突然变得如此活跃？这个问题的答案是，由于数据同步，死亡元组的<strong class="ko ja">数量不断增加。</strong></p><h1 id="b65f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">我的错误</h1><p id="8763" class="pw-post-body-paragraph km kn iq ko b kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf mr lh li lj ij bi translated">对于数据同步，我使用了<em class="ms"> UPSERT </em>(没有记录时插入，如果有记录则更新)。我不知道Postgres中的<em class="ms"> UPDATE </em>命令有什么不同的实现方式。它添加一个新的元组(或行)并将旧的元组标记为<strong class="ko ja"> dead </strong>。之后，自动真空基于自动真空设置移除这些<strong class="ko ja">死元组</strong>。</p><p id="7c91" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">看看这篇关于这个主题的优秀文章[2]——多版本并发控制(MVCC)。</p><h1 id="9d89" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">解决办法</h1><p id="35e9" class="pw-post-body-paragraph km kn iq ko b kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf mr lh li lj ij bi translated">根据我的发现，我想到了一个解决方案，当且仅当数据库中的现有记录有任何变化时才进行upsert。</p><pre class="mj mk ml mm gt mt mu mv mw aw mx bi"><span id="74a5" class="my ll iq mu b gy mz na l nb nc">PSUEDO CODE</span><span id="6d79" class="my ll iq mu b gy nd na l nb nc">1. FETCH EXISTING DATA<br/>2. SEPARATE DATA AS UNCHANGED AND DATA-TO-BE-UPSERTED<br/>3. UPSERT DATA-TO-BE-UPSERTED</span></pre><p id="8e6b" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">它大大减少了<strong class="ko ja">死元组</strong>和自动吸尘。它还有助于解决性能问题。</p><p id="dba2" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">此外，我的用例是定期进行数据同步，所以我很少经常观察到数据的变化。</p><h1 id="4ef1" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">资源</h1><p id="a70d" class="pw-post-body-paragraph km kn iq ko b kp mn kr ks kt mo kv kw kx mp kz la lb mq ld le lf mr lh li lj ij bi translated">[1]<a class="ae kl" href="https://aws.amazon.com/rds/performance-insights/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/rds/performance-insights/</a></p><p id="b704" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">[2]<a class="ae kl" href="https://www.percona.com/blog/2018/08/06/basic-understanding-bloat-vacuum-postgresql-mvcc/" rel="noopener ugc nofollow" target="_blank">https://www . per ConA . com/blog/2018/08/06/basic-understanding-float-vacuum-PostgreSQL-mvcc/</a></p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="8c12" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">喜欢我的作品吗？你愿意跟随我来支持我的工作吗？谢谢:)</p></div></div>    
</body>
</html>