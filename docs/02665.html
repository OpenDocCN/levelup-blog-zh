<html>
<head>
<title>Simple State Management with Mobx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Mobx进行简单的状态管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-state-management-with-mobx-ce8c1ad6fea9?source=collection_archive---------13-----------------------#2020-03-28">https://levelup.gitconnected.com/simple-state-management-with-mobx-ce8c1ad6fea9?source=collection_archive---------13-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5102b62156f7e47991d955d23a3ac7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VBG5A0hRl9RO4tw_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelly Sikkema </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3f8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Mobx是React应用程序状态管理的一个更简单的替代方案。它的工作原理是创建一个存储，然后观察它的变化，我们通过直接改变值来更新存储。</p><p id="8395" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解如何使用Mobx和React。</p><h1 id="8bbf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">装置</h1><p id="5eb1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们安装<code class="fe mh mi mj mk b">mobx</code>和<code class="fe mh mi mj mk b">mobx-react</code>库来创建我们的Mobx存储，然后将它连接到我们的React组件。</p><p id="b7e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ddeb" class="mt lf it mk b gy mu mv l mw mx">npm install mobx mobx-react</span></pre><p id="38fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Mobx 4 . x或更早版本支持所有现代浏览器。从版本5开始，Mobx使用代理进行状态更新，因此不支持Internet Explorer。它还可以与React Native和Node.js一起使用</p><h1 id="5435" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基本用法</h1><p id="3d88" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了开始使用它，我们创建一个存储来保存状态。然后，我们可以将存储传递到组件中。</p><p id="38e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用Mobx创建一个商店，然后将该商店注入React组件，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3586" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { observable } from "mobx";<br/>import { observer } from "mobx-react";</span><span id="073c" class="mt lf it mk b gy my mv l mw mx">class Count {<br/>  @observable count = 0;<br/>}</span><span id="bcd9" class="mt lf it mk b gy my mv l mw mx">const App = observer(({ store }) =&gt; {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;button<br/>        onClick={() =&gt; {<br/>          store.count++;<br/>        }}<br/>      &gt;<br/>        Increment<br/>      &lt;/button&gt;<br/>      &lt;button<br/>        onClick={() =&gt; {<br/>          store.count--;<br/>        }}<br/>      &gt;<br/>        Decrement<br/>      &lt;/button&gt;<br/>      &lt;p&gt;{store.count}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>});</span><span id="d0bc" class="mt lf it mk b gy my mv l mw mx">const store = new Count();<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App store={store} /&gt;, rootElement);</span></pre><p id="a8c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过定义<code class="fe mh mi mj mk b">Count</code>类创建了一个商店:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2921" class="mt lf it mk b gy mu mv l mw mx">class Count {<br/>  @observable count = 0;<br/>}</span></pre><p id="ae3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们创建一个<code class="fe mh mi mj mk b">Count</code>类的新实例，这样我们就可以通过编写以下代码将它作为一个道具传递给我们的组件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0cce" class="mt lf it mk b gy mu mv l mw mx">const store = new Count();</span></pre><p id="3ea6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f3a6" class="mt lf it mk b gy mu mv l mw mx">ReactDOM.render(&lt;App store={store} /&gt;, rootElement);</span></pre><p id="9283" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，为了定义我们的<code class="fe mh mi mj mk b">App</code>函数组件，我们在<code class="fe mh mi mj mk b">observer</code>函数周围包装了一个函数，以便观察来自商店的最新值。</p><p id="1789" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着一旦我们传入了<code class="fe mh mi mj mk b">store</code>，我们将自动获得最新的值，并且当我们更改之前有<code class="fe mh mi mj mk b">@observable</code>装饰的商店属性时，该值将被传播到商店。</p><p id="b96c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在我们的<code class="fe mh mi mj mk b">onClick</code>道具中，我们可以传入一个直接改变<code class="fe mh mi mj mk b">store.count</code>的函数来更新值，这些值将立即反映在我们添加到<code class="fe mh mi mj mk b">p</code>元素中的<code class="fe mh mi mj mk b">store.count</code>中。</p><p id="e8f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用带有React类组件的<code class="fe mh mi mj mk b">observer</code>装饰器，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="88c9" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { observable, computed, autorun } from "mobx";<br/>import { observer } from "mobx-react";</span><span id="4b25" class="mt lf it mk b gy my mv l mw mx">class Person {<br/>  @observable firstName = "Jane";<br/>  @observable lastName = "Smith";<br/>  @computed<br/>  get fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</span><span id="c70f" class="mt lf it mk b gy my mv l mw mx">@observer<br/>class App extends React.Component {<br/>  render() {<br/>    const { store } = this.props;<br/>    return (<br/>      &lt;div className="App"&gt;<br/>        &lt;p&gt;{store.fullName}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="9080" class="mt lf it mk b gy my mv l mw mx">const store = new Person();<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App store={store} /&gt;, rootElement);</span></pre><p id="5296" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的功能与带有反应功能组件的<code class="fe mh mi mj mk b">observer</code>功能相同。</p><h1 id="1ee4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">计算值和Getters</h1><p id="be5b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在store类中创建一个函数，返回一个从其他可观察值计算出来的值。</p><p id="1e31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以在我们的方法之前使用<code class="fe mh mi mj mk b">@computed</code>装饰器。我们可以定义一个并如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7f70" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { observable, computed } from "mobx";<br/>import { observer } from "mobx-react";</span><span id="fcd9" class="mt lf it mk b gy my mv l mw mx">class Person {<br/>  @observable firstName = "Jane";<br/>  @observable lastName = "Smith";<br/>  @computed<br/>  get fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</span><span id="c9f5" class="mt lf it mk b gy my mv l mw mx">const App = observer(({ store }) =&gt; {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;p&gt;{store.fullName}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>});</span><span id="66e4" class="mt lf it mk b gy my mv l mw mx">const store = new Person();<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App store={store} /&gt;, rootElement);</span></pre><p id="b35c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe mh mi mj mk b">Person</code>类中有一个方法<code class="fe mh mi mj mk b">fullName</code>，它是一个getter并返回<code class="fe mh mi mj mk b">`${this.firstName} ${this.lastName}`</code>，这是我们定义的两个可观察属性的组合。</p><p id="b3f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以像在<code class="fe mh mi mj mk b">App</code>组件中一样，在<code class="fe mh mi mj mk b">store</code>道具中获得<code class="fe mh mi mj mk b">fullname</code>属性。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/0b1cf15628b09423c96a0bb44d88c7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*txYr02k-PjMsX9V2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@teddyosterblom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Teddy sterblom</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="35f0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">自定义反应</h1><p id="f548" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">自定义反应是通过使用<code class="fe mh mi mj mk b">autorun</code>、<code class="fe mh mi mj mk b">reaction</code>或<code class="fe mh mi mj mk b">when</code>函数创建的，方法是向它们传递一个回调。反应是用来产生副作用的。</p><p id="7b28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以按如下方式创建它们:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="062d" class="mt lf it mk b gy mu mv l mw mx">autorun(() =&gt; {<br/>  console.log(store.fullName);<br/>});</span></pre><p id="f750" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个在运行代码时自动运行的反应。</p><p id="7841" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从上面记录了<code class="fe mh mi mj mk b">store.fullName</code>的值，我们可以在我们的组件中使用它，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5e6c" class="mt lf it mk b gy mu mv l mw mx">const App = observer(({ store }) =&gt; {<br/>  autorun(() =&gt; {<br/>    console.log(store.fullName);<br/>  });</span><span id="0a48" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;p&gt;{store.fullName}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>});</span></pre><h1 id="45f1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9ee3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用Mobx创建一个简单的存储来存储我们的值。它附带了decorators和函数，让我们可以观察React组件的值，并直接操作存储值。</p><p id="5968" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">observable</code>装饰器，我们可以观察来自商店的值，然后直接保存更改的值。</p><p id="c814" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">computed</code>装饰器让我们从组件的store类中的getters获取函数。</p><p id="9419" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了提交副作用，我们可以添加自定义反应。</p></div></div>    
</body>
</html>