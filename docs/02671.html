<html>
<head>
<title>Learning Go: Object-Oriented Programming Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Go:面向对象编程第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-object-oriented-programming-part-2-a95bac44a1aa?source=collection_archive---------19-----------------------#2020-03-28">https://levelup.gitconnected.com/learning-go-object-oriented-programming-part-2-a95bac44a1aa?source=collection_archive---------19-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3eb5c4a3e95b70fe28bfb173dc68e35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D2WrhC85zhbt1sot"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@ggiqueaux?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Geronimo Giqueaux </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4404" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在之前的<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/learning-go-object-oriented-programming-part-1-e8da5c91488e">文章</a>中，我讨论了如何用Go完成面向对象编程，即使Go没有类。在本文中，我将通过演示如何封装Go结构的数据和方法来继续讨论Go中的OOP。在文章的第二部分，我将讨论OOP的另一个方面，通过创建Go接口来创建抽象类型。</p><h1 id="6b84" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是封装？</h1><p id="341b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">OOP的主要目标之一是封装或数据隐藏。为什么这很重要？如果没有数据隐藏，可以直接访问结构的字段，并且可以将该字段的数据类型合法的任何值赋给该字段。例如，给定这个结构定义:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="20ff" class="mq lf it mm b gy mr ms l mt mu">type Person struct {<br/>  name string<br/>  age int<br/>}</span></pre><p id="0c1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据这个定义，我们可以将任何有效的整数分配给一个人的年龄:</p><p id="d40a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">p1 := Person{“Jane Doe”, 823}</code></p><p id="29da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哇哦。除非我们生活在圣经时代，否则人们不可能活到823岁。但是一个整型变量最有可能容纳823。显然，我们需要一些过程来控制如何访问结构的字段。</p><p id="02ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数OOP编程语言都提供了访问机制，通过使字段具有私有访问权限来隐藏类的字段，这意味着该字段只能在类定义中被访问。Go没有这个，所以我们需要找到另一种方法。</p><p id="6bdb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种方法是通过包名导出。</p><h1 id="6492" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何将软件包导出名称</h1><p id="c5f6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">创建包时，您可以控制在导入包时公开哪些函数和其他实体。要做到这一点，可以将想要导出到导入程序的实体的名称大写。我在这篇文章中没有足够的篇幅来讨论如何创建包，但是这篇文章做得很好。</p><p id="7ed7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进行演示，下面是导出用于处理几何点的功能的包的定义:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dd83" class="mq lf it mm b gy mr ms l mt mu">package point</span><span id="1fff" class="mq lf it mm b gy my ms l mt mu">type Point struct {<br/>  x, y float64<br/>}</span><span id="54fc" class="mq lf it mm b gy my ms l mt mu">func (p *Point) Create(newx, newy float64) {<br/>  p.x = newx<br/>  p.y = newy<br/>}</span><span id="1697" class="mq lf it mm b gy my ms l mt mu">func (p *Point) X() float64 {<br/>  return p.x<br/>}</span><span id="345b" class="mq lf it mm b gy my ms l mt mu">func (p *Point) Y() float64 {<br/>  return p.y<br/>}</span><span id="37d9" class="mq lf it mm b gy my ms l mt mu">func (p *Point) MoveTo(newx, newy float64) {<br/>  p.x = newx<br/>  p.y = newy<br/>}</span></pre><p id="f7d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来看看这个定义。这些字段在结构定义中声明。像构造函数一样使用方法<code class="fe mv mw mx mm b">Create</code>来初始化一个新的<code class="fe mv mw mx mm b">Point</code>结构。方法<code class="fe mv mw mx mm b">X()</code>和<code class="fe mv mw mx mm b">Y()</code>类似于Java等语言中的getters，用于返回存储在<code class="fe mv mw mx mm b">x</code>和<code class="fe mv mw mx mm b">y</code>字段中的值。</p><p id="60d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个定义中，您应该注意到所有的方法名都是大写的，这意味着它们被导出到一个导入程序中，但是字段名不是大写的。因此，您不能直接访问这些字段，尝试这样做会导致死机。</p><p id="20c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您熟悉其他OOP语言，这可能看起来是实现封装的一种激进方式，但是使用包也提供了另一个理由，通过拆分大多数结构定义使您的程序更加模块化。</p><h1 id="d2b8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Go接口</h1><p id="7b53" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">传统上，接口是由一组方法组成的类，这些方法必须由实现接口的任何子类(或派生类)来实现。围棋界面与传统界面相似，但有一些不同，在这一节中，我将讨论如何在我们的围棋程序中使用它们。</p><p id="b805" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示接口在Go中是如何工作的，我将开发一组实现几何形状的结构(尽管没有实际的图形)。这些形状将基于一个接口<code class="fe mv mw mx mm b">shape</code>，它命名了一个形状应该具有的行为类型，但没有明确定义这些行为。</p><p id="03ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将首先定义接口<code class="fe mv mw mx mm b">shape</code>。作为接口，它是抽象的，不能直接实现。但是它可以用作定义特定类型形状的基础。定义如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="43c4" class="mq lf it mm b gy mr ms l mt mu">type shape interface {<br/>  X() float64<br/>  Y() float64<br/>  Draw()<br/>  MoveTo(newx, newy float64)<br/>  Radius() float64<br/>}</span></pre><p id="c118" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go接口不能指定字段，但是它可以并且必须指定实现该接口的任何结构都必须实现的方法。</p><p id="bd09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以将特定的形状定义为一个结构:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d011" class="mq lf it mm b gy mr ms l mt mu">type circle struct {<br/>  x, y float64<br/>  radius float64<br/>}</span></pre><p id="f1cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该结构定义存储该类型数据的字段。现在，我们可以通过创建一个实现接口的实体来将两者结合起来:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c428" class="mq lf it mm b gy mr ms l mt mu">var circ shape<br/>circ = Circle(1,2,5)</span></pre><p id="dc77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在你可以看到一个接口是如何实现的。首先声明一个接口类型的变量。然后，通过调用struct文本为该变量赋值，以完成实现。</p><p id="1645" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码是乱序的，因为我仍然需要定义接口中指定的所有方法。这些定义如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="25ca" class="mq lf it mm b gy mr ms l mt mu">func (c circle) X() float64 {<br/>  return c.x<br/>}</span><span id="7330" class="mq lf it mm b gy my ms l mt mu">func (c circle) Y() float64 {<br/>  return c.y<br/>}</span><span id="e9f4" class="mq lf it mm b gy my ms l mt mu">func (c circle) Radius() float64 {<br/>  return c.radius<br/>}</span><span id="c8e3" class="mq lf it mm b gy my ms l mt mu">func (c circle) MoveTo(newx, newy float64) {<br/>  c.x = newx<br/>  c.y = newy<br/>}</span><span id="b7b3" class="mq lf it mm b gy my ms l mt mu">func (c circle) Draw() {<br/>  fmt.Printf("Drawing a circle at %.0f,<br/>             %.0f with radius of %.0f.",<br/>             c.X(), c.Y(), c.Radius())<br/>}</span></pre><p id="bed7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些方法定义看起来就像是从一个结构定义构建代码一样，但是如果没有定义接口中指定的所有方法，就会有一些问题。</p><p id="e4c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个例子，说明如果我们注释掉<code class="fe mv mw mx mm b">Radius</code>函数定义会发生什么:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9060" class="mq lf it mm b gy mr ms l mt mu">c:\Go\bin\shapes&gt;go run shapeprog.go<br/># command-line-arguments<br/>.\shapeprog.go:37:29: c.Radius undefined (type circle has no field or method Radius, but does have radius)<br/>.\shapeprog.go:42:8: cannot use circle literal (type circle) as type shape in assignment:<br/>circle does not implement shape (missing Radius method)</span></pre><p id="ae39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恐慌的最后一行是最有教育意义的。它告诉我，我的<code class="fe mv mw mx mm b">circle </code>结构没有实现接口，因为没有定义<code class="fe mv mw mx mm b">Radius</code>方法。这强化了接口是一个契约的观点，即任何选择实现接口的结构都必须定义接口中指定的所有方法。</p><p id="5108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我将把所有这些代码合并到一个程序中，以便更容易地看到发生了什么:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0318" class="mq lf it mm b gy mr ms l mt mu">package main</span><span id="d393" class="mq lf it mm b gy my ms l mt mu">import "fmt"</span><span id="4bf4" class="mq lf it mm b gy my ms l mt mu">type shape interface {<br/>  X() float64<br/>  Y() float64<br/>  Draw()<br/>  MoveTo(newx, newy float64)<br/>  Radius() float64<br/>}</span><span id="d08e" class="mq lf it mm b gy my ms l mt mu">type circle struct {<br/>  x, y float64<br/>  radius float64<br/>}</span><span id="95e6" class="mq lf it mm b gy my ms l mt mu">func (c circle) X() float64 {<br/>  return c.x<br/>}</span><span id="f741" class="mq lf it mm b gy my ms l mt mu">func (c circle) Y() float64 {<br/>  return c.y<br/>}</span><span id="0299" class="mq lf it mm b gy my ms l mt mu">func (c circle) Radius() float64 {<br/>  return c.radius<br/>}</span><span id="94bc" class="mq lf it mm b gy my ms l mt mu">func (c circle) MoveTo(newx, newy float64) {<br/>  c.x = newx<br/>  c.y = newy<br/>}</span><span id="a560" class="mq lf it mm b gy my ms l mt mu">func (c circle) Draw() {<br/>  fmt.Printf("Drawing a circle at %.0f,<br/>             %.0f with radius of %.0f.",<br/>             c.X(), c.Y(), c.Radius())<br/>}</span><span id="5efa" class="mq lf it mm b gy my ms l mt mu">func main() {<br/>  var circ shape<br/>  circ = circle{1,2,5}<br/>  fmt.Println("circle radius: ",circ.Radius())<br/>  circ.Draw()<br/>}</span></pre><p id="5bac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我强烈建议您将我的例子扩展到其他形状，以便更好地理解界面在Go中是如何工作的。</p><h1 id="342a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">去吧</h1><p id="a9e8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在本文中，我展示了两个重要的OOP技术，数据封装和接口实现，以及如何在Go中执行这些技术。虽然Go不是一种严格的面向对象编程语言，但它至少提供了编写基于对象的代码的机制，而且在我看来，这种语言正在引领未来编程语言的设计方式以及未来计算机程序的编写方式。</p><p id="7810" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>