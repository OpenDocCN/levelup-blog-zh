# 如何避免软件中令人头痛的非确定性错误

> 原文：<https://levelup.gitconnected.com/how-to-avoid-the-headache-with-non-deterministic-bugs-in-software-e24457f05c9b>

## 再现性:有时

![](img/acd4395be3239d907b63005b70293c6a.png)

照片由[潘卡杰·帕特尔](https://unsplash.com/@pankajpatel?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

QA 工程师测试软件应用程序，发现问题，并将它们报告给像吉拉这样的错误跟踪系统。标签必须包含尽可能多的细节，以便软件工程师可以用来重现 bug。理想情况下，描述 bug 的标签应该指定问题出现的环境、先决条件和重现步骤。

有时程序员无法重现 bug，即使有全面的信息。我不是在说试图在不同的环境中重现这个 bug。这是一种常见的情况，即错误出现在 UAT 环境中，而不是 QA 环境中。这可能是由于数据库不一致或其他外部因素。真正的问题是，每 10 或 20 次试图重现它时，这个 bug 就会随机出现在相同的环境中。它只表明应用程序代码本身导致了不确定性。

对于尝试 10 次、50 次或 100 次重现一个 bug 的程序员来说，这不是最佳选择。不能保证工程师会重现这一点。另一种耗时较少的方法如下所示:

*   **分析代码的哪些部分可能与 bug 有关。**
*   **检查代码中导致不确定行为的反模式。**

通常，不确定性行为是由三种情况引起的:缺乏线程同步、误用系统日期和时间，以及暂停线程一段时间。

# 缺少线程同步

根据我的经验，缺乏线程同步是应用程序中不确定性行为的最常见原因。如果并行运行的多个线程在没有适当同步的情况下同时修改共享数据，它们通常会给出不同的(不确定的)结果。

让我们看一个例子:

这段代码克隆了订单集合。在某种程度上，工程师可能会决定通过将`foreach`循环分成块并在单独的处理器上执行每个块来加速这段代码。英寸 NET 中，这可以简单地通过使用`Parallel`类来完成。

然而，工程师得到的不是快速代码，而是具有不确定性行为的代码，因为根本没有线程同步。方法`CloneOrders`将总是为相同的输入返回不同数量的订单。

在我们的特殊例子中，可以通过简单地将第 7 行包含在`Lock`语句中来改善这种情况。然而，并发和线程同步是一个庞大而复杂的话题。如果软件工程师发现多个线程同时修改共享数据，他们必须根据自己的情况仔细选择解决方案。

# 逻辑取决于当前时间

处理当前日期和时间的逻辑可以不确定地工作。

让我们举个例子:

如果代码执行得非常快，方法`GetCount`将返回预期的计数 3。如果执行缓慢，那么所有的`DateTime.Now`属性将返回不同的值，所以方法`GetCount`将返回 0。此外，该方法可以返回 1 或 2。订单的数量取决于代码执行的速度，由于许多外部因素，代码执行的速度总是不同的。

在我们的特例中，`DateTime.Now`属性只需要在方法中被访问一次。我们可以将当前的时间值存储在某个变量中并重用它，这样行为就变得确定了。

# 挂起线程执行

有时候，线程 A 需要等待线程 B 完成。否则，线程 A 将无法正确完成其工作。最简单也是最不正确的方法是使用`Thread.Sleep(ms)`或`Task.Delay(ms)`语句，因为永远不可能预测线程 A 是否会在指定的毫秒数内完成。

访问`Length`属性的线程需要另一个线程来初始化文本。如果 text 属性初始化得足够快，长度将被正确地计算出来。如果文本没有初始化，将抛出`NullReferenceException`。行`Thread.Sleep(1)`试图阻止对文本的访问，直到初始化完成。但是，如果文本是通过 HTTP 调用接收的，就不可能预先知道初始化需要多长时间。

在我们的特殊情况下，文本处理逻辑应该放在一个单独的回调函数中。一旦文本被加载，加载文本的线程应该通过事件触发回调函数。

# 最后的想法

一旦带有非确定性反模式的代码被合并到主分支中，很可能在测试过程中没有人会注意到这个 bug。您的客户可能是第一个发现生产环境中问题的人。

软件工程师在进行代码评审时，应该注意非确定性的反模式。否则，客户或 QA 工程师可能会变得有点疯狂，无法确定他们是否看到了真正的 bug，或者他们是否有幻觉。

# 更多关于软件质量的文章

[](/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a) [## 如何在不破坏应用程序的情况下修复 Bug

### 更改源代码时更自信的步骤。

levelup.gitconnected.com](/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a) [](/how-to-design-reusable-software-components-213e05119796) [## 开发人员编写可重用代码的两个简单技巧

### 加快发展应遵循的两个基本原则

levelup.gitconnected.com](/how-to-design-reusable-software-components-213e05119796)