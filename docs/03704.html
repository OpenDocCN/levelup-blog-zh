<html>
<head>
<title>JavaScript Best Practices — Arrows, Const, and Duplicate Members</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—箭头、常量和重复成员</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-arrows-const-and-duplicate-members-7825c857b99c?source=collection_archive---------9-----------------------#2020-05-23">https://levelup.gitconnected.com/javascript-best-practices-arrows-const-and-duplicate-members-7825c857b99c?source=collection_archive---------9-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6ccdc462f29308eb3af55e822e533dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GLVD7wmOXegYqLqb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@oowgnuj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jungwoo Hong </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3c89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="5f72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看令人困惑的箭头，分配给<code class="fe le lf lg lh b">const</code>常量，以及重复成员。</p><h1 id="068d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">可能与比较混淆的箭头函数</h1><p id="9479" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">箭头函数有一个<code class="fe le lf lg lh b">=&gt;</code>粗箭头，对于不完全熟悉JavaScript的人来说，这个箭头可能会与不等式比较运算符<code class="fe le lf lg lh b">&lt;=</code>或<code class="fe le lf lg lh b">=&gt;</code>相混淆。</p><p id="7441" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可能希望通过不使用看起来像比较表达式的箭头函数来使我们的代码对他们来说更容易理解。</p><p id="d21a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下函数可能会让一些人感到困惑:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fc63" class="mt lj it lh b gy mu mv l mw mx">const foo = a =&gt; 1;</span></pre><p id="f7a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个<code class="fe le lf lg lh b">foo</code>函数，它有一个参数<code class="fe le lf lg lh b">a</code>并返回1。</p><p id="76f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，有些人可能会将此与:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fede" class="mt lj it lh b gy mu mv l mw mx">const foo = a &gt;= 1;</span></pre><p id="bb9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6b79" class="mt lj it lh b gy mu mv l mw mx">const foo = a &lt;= 1;</span></pre><p id="1b5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其分别比较<code class="fe le lf lg lh b">a</code>是否大于或等于1或者<code class="fe le lf lg lh b">a</code>是否小于或等于1。</p><p id="75e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可能希望用花括号将函数体括起来，或者用括号将函数签名括起来，从而使我们的箭头函数不那么容易混淆。</p><p id="eb97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用下面的方式重写<code class="fe le lf lg lh b">foo</code>函数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cf30" class="mt lj it lh b gy mu mv l mw mx">const foo = a =&gt; {<br/>  return 1<br/>};</span></pre><p id="8807" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码通过表明我们想要返回值1，使我们的函数变得清晰。</p><p id="0720" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以改写如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="284d" class="mt lj it lh b gy mu mv l mw mx">const foo = (a) =&gt; 1;</span></pre><p id="4904" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">括号让我们的代码读者清楚地知道<code class="fe le lf lg lh b">a</code>是一个参数，而不是一个我们想与1比较的变量。</p><h1 id="87e9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">没有使用<code class="fe le lf lg lh b">const</code>声明的修改变量</h1><p id="3bf2" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，用<code class="fe le lf lg lh b">const</code>声明的常量不能被重新赋值。</p><p id="0eb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们编写类似下面的代码，那么我们会得到一个错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="86d1" class="mt lj it lh b gy mu mv l mw mx">const a = 1;<br/>a = 2;</span></pre><p id="0080" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行上面的代码时，我们会得到错误“未捕获的类型错误:常量变量赋值”并且代码将停止运行。</p><p id="8928" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该注意不要这样做。如果我们希望<code class="fe le lf lg lh b">a</code>能够被重新赋值给一个不同的值，那么我们应该用<code class="fe le lf lg lh b">let</code>来声明它。</p><p id="be57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们改为编写以下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="79d3" class="mt lj it lh b gy mu mv l mw mx">let a = 1;<br/>a = 2;</span></pre><p id="8a85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，<code class="fe le lf lg lh b">a</code>被声明为一个变量而不是常量，因此它可以被重新赋值。</p><p id="f3aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他做赋值运算的运算符如<code class="fe le lf lg lh b">+=</code>、<code class="fe le lf lg lh b">-=</code>、<code class="fe le lf lg lh b">*=</code>、<code class="fe le lf lg lh b">/=</code>、<code class="fe le lf lg lh b">%=</code>也不能用<code class="fe le lf lg lh b">const</code>常量。</p><p id="467a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们编写以下代码，我们会得到相同的错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1ecc" class="mt lj it lh b gy mu mv l mw mx">const a = 1;<br/>a += 2;</span></pre><p id="d0cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe le lf lg lh b">const</code>声明的循环变量也不能被重新赋值。例如，我们会得到一个错误，如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9ee3" class="mt lj it lh b gy mu mv l mw mx">for (const a in [1, 2, 3]) {<br/>  a = 1;<br/>}</span></pre><p id="fe11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们试图将<code class="fe le lf lg lh b">a</code>重新赋值为1，但同样无效。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/0fc78baee9dc90bda9b578e51ad57456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OPY38tc6SMSU2Q9n"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@jg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔·格林</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="d4a2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">类中有重复的成员名</h1><p id="258d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们不希望类中有重复的成员名。这是因为很难确定哪一个才是真正被保留下来的。</p><p id="25bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该写这样的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="870e" class="mt lj it lh b gy mu mv l mw mx">class Foo {<br/>  bar() {<br/>    console.log("foo");<br/>  }</span><span id="92fe" class="mt lj it lh b gy mz mv l mw mx">  bar() {<br/>    console.log("bar");<br/>  }<br/>}</span></pre><p id="7b7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有2个<code class="fe le lf lg lh b">bar</code>实例方法。第二个会被保留，所以第一个是无用的。</p><p id="a072" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当我们调用<code class="fe le lf lg lh b">bar</code>方法时如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6172" class="mt lj it lh b gy mu mv l mw mx">const foo = new Foo();<br/>foo.bar();</span></pre><p id="217e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将看到控制台日志输出中记录了<code class="fe le lf lg lh b">'bar'</code>。</p><p id="5a78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该只保留我们想要保留的一个，或者在两个都需要时重命名其中一个。</p><p id="8c0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="404f" class="mt lj it lh b gy mu mv l mw mx">class Foo {<br/>  foo() {<br/>    console.log("foo");<br/>  }</span><span id="0894" class="mt lj it lh b gy mz mv l mw mx">  bar() {<br/>    console.log("bar");<br/>  }<br/>}</span></pre><p id="a009" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以调用两个实例方法，并在控制台中查看两者的记录值。</p><h1 id="9dd1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="d9ee" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可能想要重写可能与比较表达式混淆的箭头函数。</p><p id="feac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以将函数签名放在括号中，或者在函数体中添加花括号。</p><p id="2e2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该将<code class="fe le lf lg lh b">const</code>常量重新赋值给另一个值。所以它是一个常数。</p><p id="e373" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不应该在一个类中有多个同名的成员。这是无用和混乱的，因为后面定义的那个会覆盖上面的那个。</p></div></div>    
</body>
</html>