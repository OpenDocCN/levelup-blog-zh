<html>
<head>
<title>Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/methods-f31edbc52963?source=collection_archive---------13-----------------------#2021-11-04">https://levelup.gitconnected.com/methods-f31edbc52963?source=collection_archive---------13-----------------------#2021-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fdf87859d0dcd6315f71a44b6e826320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArLmdQ47-ikTBUl_tjzBhA.png"/></div></div></figure><div class=""/><p id="bfe6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">什么是方法？<em class="kz">方法</em>和<em class="kz">函数</em>可以互换使用，只有方法是C#特有的。方法就像是指令的子集，可以被注入到脚本中以增加整洁性和功能性。像脚本一样，方法从上到下运行。当您从脚本中调用一个方法时，该方法将在从它被调用的地方继续之前完整地运行。</p><p id="85d4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">方法也可以带<em class="kz">参数</em>。当调用带有所需参数的方法时，调用必须包含一个与要传递的数据类型相匹配的<em class="kz">值</em>。一个方法可以要求尽可能多的参数来完成手头的任务。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="f260" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一个挑战，我的任务是通过由<em class="kz">空格键</em>触发的一些方法<em class="kz">参数</em>来传递一个<em class="kz">对象</em>和一个<em class="kz">颜色</em>。</p><p id="6359" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个普通的3D立方体，并通过<em class="kz">检查器</em>将其分配给主摄像机的<em class="kz"> ChangeColor </em>类组件中的<em class="kz"> cubePrimitive3D </em>变量。一个<em class="kz">新的</em> <em class="kz">颜色</em>变量被声明并分配给<em class="kz">蓝色</em>。</p><p id="aac1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在void <em class="kz">更新</em>中，检查<em class="kz">空格</em>键。按下时，调用<em class="kz"> ChangeObjectColor </em>方法，使用<em class="kz"> cubePrimitive3D </em>和<em class="kz"> newColor </em>变量满足两个必需的<em class="kz">参数</em>。</p><p id="2c80" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> ChangeObjectColor </em>方法接受两个<em class="kz">参数</em>然后开始工作。被质疑的对象是<em class="kz"> null </em>检查终身。如果对象是活动的，使用<em class="kz"> GetComponent </em>抓取<em class="kz"> MeshRenderer </em>，然后颜色被赋予<em class="kz"> newColor </em>值<em class="kz">(蓝色)</em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lh"><img src="../Images/be2673dbe2d6faad4c3442f7b504230e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXjd-Ms7oufnWcVaZVhV-A.png"/></div></div></figure><p id="0623" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个当空格键被按下时立方体变成蓝色的片段。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/81c46c214f4149a274507a6a0f231f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/1*6eIE9j5JG8m9ZjJgTQe1yQ.gif"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="8fc4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于另一个挑战，玩家必须受到<em class="kz">随机</em>数量的伤害，玩家<em class="kz">生命值</em>不能低于<em class="kz">零，</em>并且在玩家生命值达到零后不能再次调用该方法。我从两个<em class="kz"> int </em>值开始。第一个保存<em class="kz"> maxHealth </em>值<em class="kz"> 100 </em>，第二个保存<em class="kz"> currentHealth </em>的未赋值。引入一个数据类型为<em class="kz"> bool </em>的变量来检查玩家<em class="kz">是否死了</em>。</p><p id="90bf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在void <em class="kz"> Start </em>中，我将<em class="kz"> currentHealth </em>赋值为<em class="kz"> maxHealth </em>值。</p><p id="7db3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在void <em class="kz"> Update </em>中，检查空格键并添加<em class="kz">is dead</em>bool is<em class="kz">false</em>作为通过条件。引入了一个名为<em class="kz"> damageAmount </em>的局部<em class="kz"> int </em>变量，并赋予了一个在10到20之间的<em class="kz">随机</em>范围。然后调用<em class="kz">player image</em>方法，这需要传递一个强制的<em class="kz"> int </em>值。在10到20之间随机产生的<em class="kz">伤害量</em>是玩家每次按空格键时通过的。</p><p id="f2b4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> DamagePlayer </em>方法获取damageAmount，并立即从<em class="kz">当前生命值</em>中减去该值。一个名为<em class="kz"> healthClamp </em>的本地<em class="kz"> int </em>变量被声明，并被赋予<em class="kz"> Mathf的值。夹具</em>，用于将<em class="kz">当前健康</em>值保持在规定的最小<em class="kz">值</em>和最大<em class="kz">值</em>之间。</p><p id="b6cd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在将<em class="kz">当前健康</em>值指定为新的箝位值后，我会检查<em class="kz">当前健康</em>是否小于1。如果玩家的生命值小于1，控制台会收到一条消息，表明<em class="kz">玩家已经死亡</em>，并且<em class="kz">是死亡</em>布尔翻转到<em class="kz">真</em>以防止空格键再次触发方法。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ln"><img src="../Images/34fc3769cb66f36eff45f7fd451dda60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DWzS-5K2GCwzOyUP4uVlcA.png"/></div></div></figure><p id="9691" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里你可以看到<em class="kz">当前健康</em>值在<em class="kz">检查器</em>中减少。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/a27049e4ce1f1c58a37aaf1eeacaf3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/1*6peV0dkgYpTH918Bh0Vbhw.gif"/></div></figure><p id="093f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">控制台告诉我<em class="kz">玩家</em>已经死亡！</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/3566ffb84309906a792f6ac54faadb69.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*MmtDYWse5YRbPgXfgm1OAQ.png"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="d823" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于一个额外的挑战，我的任务是存储一个包含<em class="kz"> 5个位置</em>的<em class="kz">数组</em>。然后我必须使用一种方法<em class="kz">随机化</em>返回位置，另一种方法<em class="kz">将位置分配给</em>游戏对象。与其在void <em class="kz"> Start </em>中做这一次，我决定在void <em class="kz"> update </em>中添加我的空格键检查。</p><p id="ebc1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我从一个名为<em class="kz">rand composition</em>的<em class="kz"> int </em>变量开始，它将简单地存储一个随机的<em class="kz">索引值</em>供数组返回。声明一个名为<em class="kz">位置</em>的<em class="kz">向量3 </em>数组，分配<em class="kz"> 5 </em>个不同的位置。</p><p id="25a5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> randomPosition </em>变量被赋予<em class="kz"> RandomPositionIndex </em>方法的值，该方法返回一个介于零和数组中任意多个位置之间的公共<em class="kz"> int </em>值。既然已经通过Index方法运行了randomPosition变量以获得适当的存储值，那么就可以通过<em class="kz"> NewRandomPosition </em>方法使用它来分配最终的位置值。该方法从<em class="kz">位置索引</em>、<em class="kz"> </em>中获取一个<em class="kz"> int </em>值，该数字将引用哪个位置被分配给对象的变换！</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/a6b29f2433765c6db1ecb902664df31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MP25g0cCWRedML2W9rjxVA.png"/></div></div></figure><p id="2fd9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是按下空格键时立方体改变位置的剪辑。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lr"><img src="../Images/d555af32c4d68a91967faefc331d47de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fPEy6JwE1Da-VAnTwRjtbQ.gif"/></div></div></figure><p id="cc92" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当谈到编写清晰和功能性的代码时，方法和方法参数确实打开了强大的大门。感谢您的阅读！</p></div></div>    
</body>
</html>