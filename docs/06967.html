<html>
<head>
<title>Nginx Event Driven Architecture — Demonstrated in Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nginx事件驱动架构——代码演示</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nginx-event-driven-architecture-demonstrated-in-code-51bf0061cad9?source=collection_archive---------1-----------------------#2021-01-15">https://levelup.gitconnected.com/nginx-event-driven-architecture-demonstrated-in-code-51bf0061cad9?source=collection_archive---------1-----------------------#2021-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/191ca4a5e5a789257da44795d45a10bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rw5UtkN4fSKRnGll6pNqoA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">资料来源:nginx.com</figcaption></figure><h2 id="abb1" class="kf kg it bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">背景</strong></h2><p id="9619" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">Nginx是一个开源的web服务器，可以用作备用代理、负载平衡器、HTTP缓存和邮件代理。它能够支持大量的并发连接，这是它的旗舰特性之一。Nginx网站上有一篇博文[1]解释了其出色的可扩展性背后的事件驱动架构。虽然这是一个很好的深入探索，但核心工程师可能仍然感到不满意，因为我们总是在寻找涉及实际代码的理解水平。</p><p id="6afb" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">Nginx的源代码虽然可以公开获得，但阅读起来很有挑战性，因为它巨大的尺寸和单薄的注释。所以为了演示核心架构，我用C写了一个简单的服务器，复制了Nginx的事件驱动设计。我的代码在Github [2]上。请随意检查回购和服务器周围玩。在这篇博文中，我将从实现的角度带你了解事件驱动架构。</p><h2 id="801b" class="kf kg it bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">准备好插座</strong></h2><p id="02c1" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">首先，我们需要创建一个套接字，将它绑定到一个网络地址和端口，并开始监听套接字。一系列的<code class="fe mb mc md me b">socket</code>、<code class="fe mb mc md me b">bind</code>和<code class="fe mb mc md me b">listen</code>系统调用是如此的标准，以至于几乎所有的web服务器都从它们开始。Nginx也不例外。有一点需要注意的是，我们希望将监听套接字设置为非阻塞的——原因很快就会清楚。</p><h2 id="e1e5" class="kf kg it bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">事件循环</strong></h2><p id="5e76" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">下一步是Nginx与其他web服务器(如Apache)的区别。当客户端连接进来时，在调用<code class="fe mb mc md me b">accept</code>之后，可以产生一个新的线程来处理请求。这使得教科书中的并发请求处理成为可能。我记得我在学校也是这样被教导的。然而，在真实的生产环境中，这并不是最具可伸缩性的方式。线程虽然比进程轻，但在大多数现代操作系统中却太重了。当我们有成百上千个线程，每个线程代表一个客户端连接时，开销是巨大的。相反，规范的方法是使用事件循环。</p><p id="ff98" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">不同的操作系统有不同的事件循环接口(例如，<code class="fe mb mc md me b">select</code>、<code class="fe mb mc md me b">epoll</code>、<code class="fe mb mc md me b">epoll_wait</code>、<code class="fe mb mc md me b">evpoll</code>、<code class="fe mb mc md me b">kqueue</code>)。但它们都是一样的。实际上，应用程序要求操作系统监控一组文件描述符，并在一个或多个文件描述符发生IO事件时进行报告。因此，我们的服务器将监听套接字放入事件结构，并在循环中调用<code class="fe mb mc md me b">epoll_wait</code>(我使用的是linux ),而不是阻塞<code class="fe mb mc md me b">accept</code>直到有客户端连接。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="8f9a" class="kf kg it me b gy mn mo l mp mq">int efd = epoll_create1 (0);<br/>// Call register_fd() to register the<br/>// listening socket to the event<br/>// struct represented by efd.<br/>// See the snippet below.<br/>for ;; {<br/>  int n = epoll_wait(<br/>    efd,<br/>    events /* Empty events that will be filled on return */,<br/>    EVENTS_LEN,<br/>    1000 /* timeout in ms */<br/>  );<br/>  // Error check.<br/>  for (int i = 0 ; i &lt; n; i ++) {<br/>    // Process events[i]. It has IO updates.<br/>  }<br/>}</span></pre><p id="d639" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">当监听套接字的IO事件触发时，一个新的客户端连接可用于<code class="fe mb mc md me b">accept</code>。然后我们<code class="fe mb mc md me b">accept</code>连接，并将从<code class="fe mb mc md me b">accept</code>获得的客户端套接字描述符放回事件循环。当客户端发送数据时，客户端套接字描述符的事件将被触发，我们将在下一轮<code class="fe mb mc md me b">epoll_wait</code>中捕捉到这个事件。随着我们<code class="fe mb mc md me b">accept</code>新的连接，我们将在事件观察列表中不断积累客户端套接字描述符，直到我们完成它们，在这种情况下，我们关闭客户端套接字描述符并停止轮询它们的IO事件。</p><p id="f874" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">对于一个<code class="fe mb mc md me b">epoll_wait</code>调用，可能会返回来自多个套接字(监听套接字和客户端套接字)的IO事件。这很好，也在意料之中。我们只是一个接一个地回应。这是最关键的部分。我们不会仅仅为了处理IO事件而产生新的线程。我们以单线程的方式依次浏览它们。显然，我们需要将所有的套接字描述符设置为非阻塞的，这样单个线程就不会被特定的IO通道阻塞。这样，我们避免了创建数千个线程，然后只让它们阻塞等待IO。这种模式在现代web架构中被广泛采用，因为单线程现在通常足够强大，可以进行多路复用。事实证明，这通常比拥有多个线程要高效得多。Redis也在利用完全相同的模式[3]。</p><p id="ee3c" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">注意一个细节:在监听插座上设置电平触发(<code class="fe mb mc md me b">EPOLLIN</code>)而不是边沿触发(<code class="fe mb mc md me b">EPOLLET</code>)很重要。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="6bde" class="kf kg it me b gy mn mo l mp mq">void register_fd(int efd, int fd) {<br/>  struct epoll_event event;<br/>  event.data.fd = fd;<br/>  event.events = EPOLLIN;<br/>  epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;event);<br/>  // Error check.<br/>}</span></pre><p id="3951" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">Edge-trigger只为更改触发事件。当<code class="fe mb mc md me b">epoll_wait</code>返回时，可能会有多个客户端连接在监听队列中。如果没有新的客户端连接，即使队列中有旧的客户端连接，<code class="fe mb mc md me b">epoll_wait</code>也不会为edge-trigger返回事件。人们可以将<code class="fe mb mc md me b">accept</code>包装在一个嵌套的循环中，试图耗尽现有的客户端连接，但是这会导致更加复杂和微妙的竞争情况(例如，太多连续的客户端连接；客户端连接在<code class="fe mb mc md me b">accept</code>完成之后、下一个<code class="fe mb mc md me b">epoll_wait</code>之前进入。同样的原理也适用于客户端套接字。</p><h2 id="98a5" class="kf kg it bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">多流程</strong></h2><p id="c045" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">到目前为止，所有的逻辑都在一个线程上运行。我们还没有利用大多数现代机器中的多核。为此，我们可以(Nginx也这样做)<code class="fe mb mc md me b">fork</code>在初始服务器套接字上调用<code class="fe mb mc md me b">listen</code>之后。</p><p id="dccb" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">监听套接字可以在多个进程之间共享。当连接事件在监听套接字上触发时，所有调用<code class="fe mb mc md me b">epoll_wait</code>的进程都会知道。他们都会冲向<code class="fe mb mc md me b">accept</code>。它们中只有一个能够从监听队列中获取连接——操作系统保证了这一点。<code class="fe mb mc md me b">accept</code>将向其他进程返回<code class="fe mb mc md me b">AGAIN</code>或<code class="fe mb mc md me b">EWOULDBLOCK</code>错误。这些进程将知道所有的客户端连接在这一轮都被接受了。通过一些特殊的标志控制，一些操作系统足够聪明，可以只通知一个进程。某些操作系统支持跨进程分割监听套接字，并且只唤醒那些分配了新连接事件的进程。从操作系统的角度来看，这样效率更高。但是不利的一面是，如果一个特定的进程很慢，所有分配给它的连接事件都必须等待，并且不能被其他进程获得。</p><h2 id="4a02" class="kf kg it bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">不要阻塞事件循环</strong></h2><p id="03a6" class="pw-post-body-paragraph lb lc it ld b le lf lg lh li lj lk ll ko lm ln lo ks lp lq lr kw ls lt lu lv im bi translated">我们的服务器处理事件循环中的所有业务逻辑。这很好，因为我们的演示客户机只是向服务器发送“hello world”消息，服务器读取并打印出这些消息。许多现实世界的系统具有复杂的逻辑，当在单线程框架中处理时，可能会停止事件循环。例如，Node.js在接受连接后将繁重的工作卸载到一个单独的线程池[4]。Golang对轻量级线程——Go例程(我们可以创建任意多的线程)提供了本机支持，它将由几个核心底层操作系统线程执行。</p><blockquote class="mr ms mt"><p id="ce48" class="lb lc mu ld b le lw lg lh li lx lk ll mv ly ln lo mw lz lq lr mx ma lt lu lv im bi translated"><strong class="ld iu">参考文献</strong></p></blockquote><p id="2bea" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">[1]<a class="ae my" href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" rel="noopener ugc nofollow" target="_blank">https://www . nginx . com/blog/inside-nginx-how-we-designed-for-performance-scale/</a></p><p id="a75b" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">[2]https://github.com/eileen-code4fun/NginxEventLoop<a class="ae my" href="https://github.com/eileen-code4fun/NginxEventLoop" rel="noopener ugc nofollow" target="_blank"/></p><p id="7771" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">[3]<a class="ae my" href="https://medium.com/swlh/use-the-source-redis-internal-tricks-5a8b735b9ef0" rel="noopener">https://medium . com/swlh/use-the-source-redis-internal-tricks-5a 8b 735 B9 ef 0</a></p><p id="8cc7" class="pw-post-body-paragraph lb lc it ld b le lw lg lh li lx lk ll ko ly ln lo ks lz lq lr kw ma lt lu lv im bi translated">[4]<a class="ae my" href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/en/docs/guides/don-block-the-event-loop/</a></p></div></div>    
</body>
</html>