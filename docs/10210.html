<html>
<head>
<title>5 Surprising Angular Features You Might Not Have Known About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能不知道的5个令人惊讶的棱角特征</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-angular-features-you-might-not-have-known-about-d809babb51a4?source=collection_archive---------2-----------------------#2021-11-07">https://levelup.gitconnected.com/5-angular-features-you-might-not-have-known-about-d809babb51a4?source=collection_archive---------2-----------------------#2021-11-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="43cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些鲜为人知但很方便的技巧，让你的角度代码库更安全、更整洁</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d619901852d8107745a9ddb84e7eb6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUb5fOrTApsZ3lc72jXPWA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/cs-cz/foto/podnikatel-ruce-pracovni-stul-vladce-5582597/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae ky" href="https://www.pexels.com/cs-cz/@thirdman?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">第三人</a>的照片</figcaption></figure><p id="7871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Angular非常适合企业软件开发，所以Angular代码库可以变得很大。每一个大的代码库都会随着时间的推移而退化，通常是因为它的一些编程模式和实践已经被证明是不合适的，或者是由于代码库维护者的波动。本文将介绍五个简单而简洁的技巧来重构您的代码库，以获得更好的质量，或者如果您正在开始一个新项目，它们将帮助您明确您关于编码实践的想法。</p><h1 id="7170" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">💉管道实际上是可注射的</h1><p id="5f82" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有时可能会出现这样的情况，当您需要使用没有导出配套格式化函数的管道来格式化控制器方法中的一些值时(内置的角度管道有这些函数:<code class="fe ms mt mu mv b">PercentPipe</code> → <code class="fe ms mt mu mv b">formatPercent</code>、<code class="fe ms mt mu mv b">CurrencyPipe</code> → <code class="fe ms mt mu mv b">formatCurrency</code>、…)。</p><p id="3e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用没有这种相关格式化功能的管道的一个简单方法是将它的依赖项注入到您的控制器中，然后使用这些依赖项实例化管道本身，并在最后一步调用它的<code class="fe ms mt mu mv b">transform</code>方法——类似这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/c2417a9e731b9fdad75da96916fbca8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtMeOqNeQpsU12NlrInl-A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">之前-手动管道实例化</figcaption></figure><p id="7b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题解决了。或许足够了。但是构造函数中的这些依赖项实际上是不需要的代码，仅仅是为了实例化管道的需要而存在的。然而，有一个简洁的解决方案。因为管道是Angular管理的对象，所以它们应该是可注入的。通过在<code class="fe ms mt mu mv b">@Component.providers</code>中列出这些管道，然后将它们像服务一样注入到控制器的构造函数中，您将获得由角度依赖注入自动创建的管道实例及其所有依赖项，而无需不必要的技术管道:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/90895f38ff41c9c5e190303f0e4e1ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQa50jxVlso-CgR_9BX3lQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">后-通过角度DI进行管道实例化</figcaption></figure><h1 id="cd90" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">👀ViewChild也可用于服务</h1><p id="b56c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">很少有好的理由将<code class="fe ms mt mu mv b">@ViewChild</code>与子组件结合使用。对子组件这样做的通常用例是在假设父组件和子组件总是一起使用的情况下使用子组件的方法。在非常微妙的情况下，还需要使用子组件的组件提供的服务的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/fc99e269f204075f6cfb37f47d1a0a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gd4CPTkxuAy_NlGGBOZ68g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有组件提供的服务的父组件和子组件</figcaption></figure><p id="5ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的一个常见的简单方法是将一个<code class="fe ms mt mu mv b">@ViewChild</code>与一个组件一起使用，并在您的子组件中打破该服务的封装，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/a1b32237beec3d6d73bae59b80ff075c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5l7QXiKZ6HyDMAVUUF6oA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用对子组件的引用来访问子组件的服务</figcaption></figure><p id="3aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有一个更好的解决方案，允许您直接获得子组件的组件提供的服务，而无需访问子组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/6cd8dc40598687103143baea9790ed0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZL2j8GcKdukaHwvquTMFA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">直接访问子组件的服务</figcaption></figure><p id="c146" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只是不要忘记这个技巧只需要用于<em class="mx">组件提供的服务</em>，也就是那些在<code class="fe ms mt mu mv b">@Component.providers</code>中列出的服务。在装饰元数据中有<code class="fe ms mt mu mv b">providedIn: root</code>的服务或者在<code class="fe ms mt mu mv b">@NgModule.providers</code>中列出的服务在这种情况下会被简单地注入到你的父组件的构造函数中，这样就可以了。</p><h1 id="9c3e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">🧨角服务可以有NgOnDestroy</h1><p id="0377" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">许多Angular开发者不知道的一个非常令人惊讶的事实。它确实得到了官方的支持！一个片段说了1000多个字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/48ea677c1efe2b49da3cef38f16bda95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pT3iLNh33iYlR9Hi87fdw.png"/></div></div></figure><p id="9769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe ms mt mu mv b">ngOnDestroy</code>在服务中可用，您也可以使用与在组件中相同的技术在服务中自动取消订阅。</p><p id="9b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面列出的文章对自动退订的技巧做了一个很好的总结，值得一读，大约只需要5分钟:</p><div class="my mz gp gr na nb"><a rel="noopener  ugc nofollow" target="_blank" href="/auto-unsubscribing-in-angular-components-like-a-pro-742220b01d0c"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">像专业人士一样自动退订角度组件</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">快速处理unsubscribe()调用的5个技巧</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ks nb"/></div></div></a></div><p id="698a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">不过需要注意的是，我会忽略在服务中创建订阅，因为大多数时候，来自服务的数据消费者通常是组件、指令和管道。</em></p><h1 id="37b3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">📐推断通用组件的类型</h1><p id="ca48" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是Angular编译器的一个很大的特性，尤其是如果你正在使用自Angular 12以来强烈推荐的AOT和严格模式。它非常优雅地克服了组件中的各种类型转换怪癖和奇怪的模板编译错误。</p><p id="92cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设您有一个实现选项列表的组件<code class="fe ms mt mu mv b">OptionsListComponent</code>，它使用一个带有通用值的数组<code class="fe ms mt mu mv b">Options</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/67d87b8031e4b47521dfff1d8954ec3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-eS_AbPJz2jEFLst32r1Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实现具有泛型值类型的选项列表的组件</figcaption></figure><p id="a169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种带有泛型参数的组件的真正威力在于它在许多不同值类型上下文中的无限广泛的用途:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/6ddab426b0ef681401ae0b294a9795ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yqi6nM-xxxf8nOmmEGOzBA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">动作中的一般角度分量类型推断</figcaption></figure><p id="1325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请参阅—不需要对不同的值类型进行类型转换或重新实现。严格模式下的艾薇·AOT做得很好！</p><p id="4955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我的实践和经验来看，通用组件类型推断在巨大的代码库中是一个真正的救命稻草，在那里有防止代码重复的巨大需求，并且代码重用率是代码质量的主要度量之一。</p><p id="fda0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，它也适用于指令和管道！</p><h1 id="d822" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">🪙应用程序初始值设定项是多标记的，可以这样使用</h1><p id="5709" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可能已经多次使用或见过应用程序初始化器，最常见的用法如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/7e09e4377e3f803fb626d8cb8c20d472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxViktJXLfJc0l1q4lRIKg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">之前—所有初始化代码都在一个工厂中</figcaption></figure><p id="0781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意小小的<code class="fe ms mt mu mv b">multi: true</code>静态提供者元数据。这意味着可以在你的引导模块提供者中声明多个<code class="fe ms mt mu mv b">APP_INITIALIZER</code>——出于某种原因，没有多少教程和文档提到这一点。这就打开了将大的应用程序初始化器按照职责分成多个更小的初始化器的大门，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/af57a147d3fc3e77a8d0d61413c88a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6zKxlGf3tCXj6WBZTBrqw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">after——初始化代码按照职责划分到多个工厂中</figcaption></figure><p id="1bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它适用于以下初始化器标记:</p><ul class=""><li id="cde9" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><code class="fe ms mt mu mv b">PLATFORM_INITIALIZER</code> —角平台初始化后运行的初始化器，</li><li id="9535" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe ms mt mu mv b">APP_BOOTSTRAP_LISTENER</code> —初始化每个引导组件后运行的初始化器，</li><li id="2655" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><code class="fe ms mt mu mv b">APP_INITIALIZER</code> —在应用程序初始化过程中运行的初始化器。</li></ul><p id="2c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，各个初始化器是并行执行的。</p><p id="bc6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的特性，因为从软件工程的角度来看，使用多个初始化器的方法符合单一责任原则——与初始化器相关的代码将更容易测试，也更简单。</p><h1 id="2880" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">📦结论</h1><p id="5c25" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，您已经看到了提高Angular代码库质量和安全性的五个技巧。当我第一次听说这五个技巧时，我很惊讶。和Angular一起工作的时候有什么让你惊讶的？不要犹豫，在下面的评论中告诉其他读者吧！</p><h1 id="b979" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">👓值得一看的文章</h1><div class="my mz gp gr na nb"><a rel="noopener  ugc nofollow" target="_blank" href="/this-angular-technique-will-significantly-lower-code-duplication-in-big-projects-28fd62c3eadd"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">这种角度技术将显著降低大型项目中的代码重复</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">告别大型项目中ng模板的代码重复和性能问题</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nk l"><div class="oe l nm nn no nk np ks nb"/></div></div></a></div><div class="my mz gp gr na nb"><a rel="noopener  ugc nofollow" target="_blank" href="/handling-loading-indicators-in-angular-applications-the-right-way-11ff8b8896ba"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">正确处理角度应用中的负载指示器</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">一个优雅的，没有麻烦的方式来摆脱无意义的技术管道在您的业务角组件。</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nk l"><div class="of l nm nn no nk np ks nb"/></div></div></a></div></div></div>    
</body>
</html>