<html>
<head>
<title>More Useful RxJS Transformation Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更有用的RxJS转换运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-useful-rxjs-transformation-operators-1ab617f28814?source=collection_archive---------14-----------------------#2020-02-16">https://levelup.gitconnected.com/more-useful-rxjs-transformation-operators-1ab617f28814?source=collection_archive---------14-----------------------#2020-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d8d00d9eef449ece6f5979978b335133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A2ffRzp9u0oqEEqd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sweetmangostudios?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ricky Kharawala </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="8aeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS是一个反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="5b0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将查看一些RxJS转换操作符，如<code class="fe le lf lg lh b">concatMapTo</code>、<code class="fe le lf lg lh b">expand</code>、<code class="fe le lf lg lh b">exhaust</code>和<code class="fe le lf lg lh b">exhaustMap</code>操作符。</p><h1 id="1abd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">concatMapTo</h1><p id="9a6d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">concatMapTo</code>操作符获取可观察对象的源值，并将每个值映射到同一个内部可观察对象。</p><p id="f172" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它最多需要两个参数。第一个是<code class="fe le lf lg lh b">innerObservable</code>，它是将每个值从原始可观察值映射到的可观察值。</p><p id="9f62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是一个<code class="fe le lf lg lh b">resultSelector</code>函数，让我们选择结果。</p><p id="160d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管源值如何，每个原始可观察值的发射值都被映射到给定的<code class="fe le lf lg lh b">innerObservable</code>。然后将这些结果的可观察值合并成一个可观察值。这是返回的可观测值。</p><p id="3980" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发出的每个新的<code class="fe le lf lg lh b">innerObservable</code>与其他的值连接在一起。</p><p id="c1e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果源值没完没了地到达，并且比相应的内部观察值完成的速度快，那么就会导致内存问题，因为会有大量的数据聚集在一起等待订阅。</p><p id="7400" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="181e" class="mt lj it lh b gy mu mv l mw mx">import { fromEvent, interval } from "rxjs";<br/>import { take, concatMapTo } from "rxjs/operators";</span><span id="b4e6" class="mt lj it lh b gy my mv l mw mx">const clicks = fromEvent(document, "click");<br/>const result = clicks.pipe(concatMapTo(interval(1000).pipe(take(5))));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="c57d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将从文档中获取click事件，然后在1秒钟后发出0，再等一秒钟后发出4。</p><h1 id="7560" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">废气</h1><p id="1cc5" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">exhaust</code>算子将一个较高层次的可观测值，即发射可观测值的可观测值，转化为发射内部可观测值的一阶可观测值，而之前的内部可观测值尚未完成。</p><p id="08fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果将是来自所有可观察值的值被展平并由一个可观察值发出，该可观察值是该运算符返回的值。</p><p id="0187" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ffe3" class="mt lj it lh b gy mu mv l mw mx">import { interval, of } from "rxjs";<br/>import { exhaust, map, take } from "rxjs/operators";</span><span id="d812" class="mt lj it lh b gy my mv l mw mx">const observable = of(1, 2, 3);<br/>const higherOrder = observable.pipe(map(ev =&gt; interval(1000).pipe(take(5))));<br/>const result = higherOrder.pipe(exhaust());<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="d383" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个发出1、2和3的<code class="fe le lf lg lh b">observable</code>可观察对象。使用进入<code class="fe le lf lg lh b">interval(1000).pipe(take(5)</code>的<code class="fe le lf lg lh b">map</code>操作符将<code class="fe le lf lg lh b">observable</code>发出的值映射到内部可观察值。</p><p id="f5da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于没有完成的内部观察值被<code class="fe le lf lg lh b">exhaust</code>操作符丢弃，我们将得到<code class="fe le lf lg lh b">interval(1000).pipe(take(5)</code>只被发出一次，因为只有它的第一个实例被启动。然后我们得到每秒发射一个数，从0开始，到4停止。</p><h1 id="152e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">耗尽图</h1><p id="83c9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">像<code class="fe le lf lg lh b">exhaust</code>操作符一样，<code class="fe le lf lg lh b">exhaustMap</code>操作符也采用从原始可观察值映射而来的第一个内部可观察值。不同之处在于，它采用了一个函数，让我们将原始可观测值的发射值映射到另一个可观测值，但只采用该操作符的第一个发射可观测值。</p><p id="2c82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ef0a" class="mt lj it lh b gy mu mv l mw mx">import { interval, of } from "rxjs";<br/>import { take, exhaustMap } from "rxjs/operators";</span><span id="b0bd" class="mt lj it lh b gy my mv l mw mx">const observable = of(1, 2, 3);<br/>const result = observable.pipe(exhaustMap(ev =&gt; interval(1000).pipe(take(5))));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="8e58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到与<code class="fe le lf lg lh b">exhaust</code>相同的结果，但我们不必将<code class="fe le lf lg lh b">observable</code>的发射值<code class="fe le lf lg lh b">pipe</code>和<code class="fe le lf lg lh b">map</code>转换成新的可观测值。相反，我们用<code class="fe le lf lg lh b">exhaustMap</code>操作符将所有东西组合在一起。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/7c96c43650e60e96343a8b8591e13fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1d46z_fVN4jk0nNw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安妮·斯普拉特在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="098d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">发展</h1><p id="298d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">expand</code>操作符递归地将每个源值投影到一个可观察值，然后将其合并到输出可观察值中。</p><p id="238b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有3个参数，即<code class="fe le lf lg lh b">project</code>函数，应用于源可观察对象或输出可观察对象发出的项目，并返回一个新的可观察对象。</p><p id="2e85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是<code class="fe le lf lg lh b">concurrency</code>，这是一个可选参数，表示同时订阅的输入观察值的最大数量。默认为<code class="fe le lf lg lh b">Number.POSITIVE_INFINITY</code>。</p><p id="4973" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个参数是可选的<code class="fe le lf lg lh b">scheduler</code>对象，这是一个调度器，我们可以用它来为值的发出计时。</p><p id="4d9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该运算符的一个简单用法如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4ac3" class="mt lj it lh b gy mu mv l mw mx">import { of } from "rxjs";<br/>import { expand, delay, take } from "rxjs/operators";</span><span id="1e81" class="mt lj it lh b gy my mv l mw mx">const powersOfTwo = of(1, 2, 3).pipe(<br/>  expand(x =&gt; of(x).pipe(delay(1000))),<br/>  take(10)<br/>);<br/>powersOfTwo.subscribe(x =&gt; console.log(x));</span></pre><p id="1f3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe le lf lg lh b">of(1, 2, 3)</code>个可观察对象，它们有从<code class="fe le lf lg lh b">pipe</code> d到<code class="fe le lf lg lh b">expand(x =&gt; of(x).pipe(delay(1000)))</code>可观察对象的发射值。然后前10个值取自<code class="fe le lf lg lh b">expand</code>返回的可观测值，后者取<code class="fe le lf lg lh b">of(1, 2, 3)</code>可观测值的发射值，重复发射，直到我们发射了10个值，每组在等待1秒后发射。</p><p id="733c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为我们指定了<code class="fe le lf lg lh b">of(x)</code>，它获取<code class="fe le lf lg lh b">of(1, 2, 3)</code>值，然后不做任何修改就发出它们。<code class="fe le lf lg lh b">pipe(delay(1000))</code>将每组数值1、2和3的发射延迟一秒钟。</p><p id="e524" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这应该会产生以下输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f3af" class="mt lj it lh b gy mu mv l mw mx">1<br/>2<br/>3<br/>1<br/>2<br/>3<br/>1<br/>2<br/>3<br/>1</span></pre><h1 id="af03" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="9726" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">concatMapTo</code>运算符获取可观察值的源值，并将每个值映射到相同的内部可观察值。</p><p id="345d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">exhaust</code>算子转换一个发出可观测值的可观测值，然后发出第一个内部可观测值的值，并丢弃没有发出的值。</p><p id="91f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">exhaustMap</code>操作符也获取第一个内部可观察值，然后将它们映射到内部可观察值中，然后发出值。</p><p id="b93b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<code class="fe le lf lg lh b">expand</code>操作符递归地将每个源值投影到一个可观察值上，然后将其合并到输出可观察值中并发出。</p></div></div>    
</body>
</html>