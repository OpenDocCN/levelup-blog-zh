<html>
<head>
<title>The Single Responsibility Principle made simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一责任原则变得简单</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-single-responsibility-principle-made-simple-4e1597a44d7d?source=collection_archive---------12-----------------------#2021-04-06">https://levelup.gitconnected.com/the-single-responsibility-principle-made-simple-4e1597a44d7d?source=collection_archive---------12-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3309" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么这个原则经常被误解，以及应该如何在现实世界的代码中应用它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff0f58c7325c3e45498d537d8e1c0c11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPWLpdpYemtLxaNH5MvT_A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">米海三都</figcaption></figure><p id="8d72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上图中，你更愿意拥有什么，瑞士军刀还是右边所有的工具？旅行的时候，便携性是最重要的。瑞士军刀是合适的工具。</p><p id="eebc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在日常生活中，你会切面包、修理汽车或者用瑞士军刀开罐头吗？大概不会。你可以做，但用面包刀、一套螺丝刀或开罐器更容易。</p><p id="cc3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现实生活中的代码应该被同样对待。一个万能类(上帝对象)没关系，它可以让你在旅途中完成工作(比如原型或脚本)，但不适合日常使用。</p><p id="10cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">神器第一次写起来很容易，以后每次修改都很恐怖。每一项新功能或更新都会成倍增加复杂性。这反过来使得新程序员很难理解和理解其中的逻辑。</p><p id="bb64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是上帝物品最大的问题是它们产生的错误数量。因为所有东西都紧密耦合在同一个类中，所以每次更新都会影响几乎所有东西。这使得保持代码无bug变得困难。对于客户来说，没有什么比要求一些东西并破坏代码的其他部分更令人恼火的了。</p><h1 id="f8a6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">SRP前来救援</h1><blockquote class="mm mn mo"><p id="d488" class="ky kz mp la b lb lc ju ld le lf jx lg mq li lj lk mr lm ln lo ms lq lr ls lt im bi translated">单一责任原则(SRP)规定每个软件模块应该有且只有一个变更的理由。</p><p id="b8fb" class="ky kz mp la b lb lc ju ld le lf jx lg mq li lj lk mr lm ln lo ms lq lr ls lt im bi translated">罗伯特·马丁</p></blockquote><p id="10c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">换句话说，当应用这个原则时，我们应该确定变化的可能原因，并把它们分成不同的对象。</p><p id="e521" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遵循这个原则应该给我们:</p><ul class=""><li id="8cea" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">可维护的代码→因为当新的需求进来时，代码是细粒度的，我们应该能够只更新负责设计变更的类</li><li id="5d42" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">易于测试的代码→因为我们没有破坏一个大的对象，而是一个小的对象，所以大多数的测试应该还是可以通过的</li><li id="1846" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">可读代码→较小的对象比“上帝”对象更容易理解</li><li id="0e9d" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">可重用代码→重用粒度级的类比重用大型类的机会更大</li></ul><p id="157a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看这个原理的实际应用。</p><h1 id="d2d3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">真实世界的例子</h1><p id="50fb" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">快速看一下下面的代码(不用担心编程语言，里面没什么具体的):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2c2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果代码太长，请长时间阅读方法签名:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="cdd7" class="nt lv it np b gy nu nv l nw nx">public double GetPriceOf(string ticker)</span><span id="13a5" class="nt lv it np b gy ny nv l nw nx">public void Buy(string ticker)</span><span id="152f" class="nt lv it np b gy ny nv l nw nx">public void Sell(string ticker)</span><span id="7ca8" class="nt lv it np b gy ny nv l nw nx">public void PrintProfitableTransactions()</span><span id="3a86" class="nt lv it np b gy ny nv l nw nx">public void SaveReportToFile()</span></pre><p id="8bc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你能识别SRP违规吗？</p><p id="88d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乍一看，这段代码似乎还不错。但有一个问题，我们想保存到文件，也打印一些数据都来自一个单一的类。</p><p id="dbbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在生产代码中，这意味着我们需要依赖于文件管理器、打印管理器、web API管理器、日志管理器等对象。由于所提供的功能相当简单，像复杂报告、新类型的股票订单这样的新特性可能会使该类变得臃肿。事情很快失去控制。</p><h2 id="528a" class="nt lv it bd lw nz oa dn ma ob oc dp me lh od oe mg ll of og mi lp oh oi mk oj bi translated">解决方案</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/1deca93b87610bef6b2f7b15bab14b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80O6xdspetCnPefqEGVV3A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</figcaption></figure><p id="c455" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者如果你喜欢代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="a403" class="nt lv it bd lw nz oa dn ma ob oc dp me lh od oe mg ll of og mi lp oh oi mk oj bi translated">发生了什么事？</h2><p id="baf8" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">神级被分成了三个等级。架构代码被提取为两个类:FileManager和PrintManager。这样，如果需要“股票组合”的新功能，我们可以在不影响打印或文件逻辑的情况下进行更新。另外，打印和文件类可以在其他组件中重用。</p><p id="4073" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从StockPortfolio类中，我们删除了两个方法(print和save ),但是添加了一个新的getter方法来提取必要的数据。</p><p id="76a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码的整体大小增加了，但是我们获得了关注点的分离。划分逻辑还允许多个开发人员在同一个项目上工作。</p><h1 id="990a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">当心</h1><p id="bfc0" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">SRP很容易被过度使用。该原则背后的思想是使您的代码易于维护。不多不少。</p><p id="e3b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae ol" href="https://softwareengineering.stackexchange.com/questions/150760/single-responsibility-principle-how-can-i-avoid-code-fragmentation" rel="noopener ugc nofollow" target="_blank"> StackExchange </a>上有一个很好的例子，它详细描述了当程序员将这个原则发挥到极致时会发生什么。简而言之，它使得代码如此原子化，以至于理解和调试代码是一场噩梦。</p><p id="dc40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到瑞士军队的例子，你可以很容易地把“瑞士军刀”分解成剪刀、螺丝刀、小刀之类的东西。如果你做得太过分，你可能会用面包刀、黄油刀、鱼刀、猎刀来代替刀子。对于厨师来说，所有这些刀都是有意义的，但在几乎所有其他情况下，一把通用刀就可以完成这项工作。</p><p id="0a90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将SRP与KISS原则结合使用。保持简单和愚蠢。如果你觉得代码过于分散，那么你可能是对的。</p><blockquote class="om"><p id="3d0c" class="on oo it bd op oq or os ot ou ov lt dk translated">把因为同样的原因而改变的东西聚集在一起。把那些因为不同原因而改变的东西分开。罗伯特·马丁</p></blockquote><p id="504e" class="pw-post-body-paragraph ky kz it la b lb ow ju ld le ox jx lg lh oy lj lk ll oz ln lo lp pa lr ls lt im bi translated">类原子性使得原理很容易被讨厌。项目中的类太多，理解逻辑、调试和维护它们变得越来越困难。</p><p id="bc34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遵循您在构造函数中注入的参数数量。如果超过五个，停下来分析你的代码。你可能过度应用了这个原则。</p><p id="da7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到StockPortfolioManager代码示例，看看代码，我们很容易想到将所有日志提取到不同的类中。这就说得通了。例如，如果我们想要改变日志行为，那么只有一个负责日志管理的类会对我们有所帮助。</p><p id="1671" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在实践中，在95%的情况下，您可能不会对日志工具进行太多的修改。也许永远不会。所以不要在这上面浪费时间。大多数程序员使用一个库来记录日志，所以在它上面做一个包装器对我来说是一种浪费。</p><h1 id="3818" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">如何确定变革的原因</h1><p id="b794" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">理论上，SRP原则是所有坚实原则中最容易理解的。实际上，这是最难应用的方法之一。</p><p id="2ad0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们应该基于“改变的原因”来分离代码，程序员必须预测那些原因可能是什么。</p><p id="6cdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">初级程序员得靠想象力。有经验的程序员可以依靠他们过去的经验。高级程序员了解客户的业务，并据此编写代码。它们价值连城。</p><p id="a4ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这里有一些让你开始的建议:</p><ul class=""><li id="4993" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">保持业务逻辑与基础设施分离1→通常业务规则比基础设施更容易改变。在StockPortfolio示例中，StockPortfolioManager类中的逻辑可能会比我们打印或保存信息的方式更频繁地变化</li><li id="6e93" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">与客户交谈，了解他们对未来应用的设想。特别注意他们可能会问的潜在特征。</li><li id="b66f" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">看看他们过去的要求。在请求之前知道系统的状态，你会预见到吗？</li></ul><p id="bffe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时我们会把事情做好，但有时不会。尽管我很想预测未来，但这是不可能的。我们只能分析和发挥概率。</p><h1 id="6fb9" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">外卖食品</h1><ul class=""><li id="9427" class="mt mu it la b lb nh le ni lh pb ll pc lp pd lt my mz na nb bi translated">找出变化的可能原因，并根据这些原因打破你的代码</li><li id="1765" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">如果你了解商业领域，你就能更好地应用这个原则。花一些时间，了解客户的需求是什么。</li><li id="5074" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">不要过度→需要它而没有它比其他方式更好</li></ul></div><div class="ab cl pe pf hx pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="im in io ip iq"><p id="bc13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">坚实的原理制作简单的系列:</strong></p><ul class=""><li id="088d" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">单一责任原则</li><li id="a392" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ol" rel="noopener ugc nofollow" target="_blank" href="/the-open-closed-principle-made-simple-cc3d0ed70553">开合原理</a></li><li id="72e0" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ol" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-made-simple-5e69165e7ab5">里斯科夫替代原理</a></li><li id="2803" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ol" rel="noopener ugc nofollow" target="_blank" href="/interface-segregation-principle-made-simple-990da495441c">界面偏析原理</a></li><li id="5991" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ol" rel="noopener ugc nofollow" target="_blank" href="/the-dependency-inversion-principle-made-simple-70108b88dc76">依存倒置原则</a></li></ul></div><div class="ab cl pe pf hx pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="im in io ip iq"><h1 id="7574" class="lu lv it bd lw lx pl lz ma mb pm md me jz pn ka mg kc po kd mi kf pp kg mk ml bi translated">进一步阅读</h1><div class="pq pr gp gr ps pt"><a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="noopener  ugc nofollow" target="_blank"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd iu gy z fp py fr fs pz fu fw is bi translated">清洁编码器博客</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">1972年，戴维·l·帕纳斯发表了一篇经典论文，题为《关于将系统分解为……</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">blog.cleancoder.com</p></div></div></div></a></div><div class="pq pr gp gr ps pt"><a href="https://hackernoon.com/you-dont-understand-the-single-responsibility-principle-abfdd005b137" rel="noopener  ugc nofollow" target="_blank"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd iu gy z fp py fr fs pz fu fw is bi translated">你明白单一责任原则吗？</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">单一责任原则是关键的软件工程原则，它决定了我们应该如何模块化…</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">hackernoon.com</p></div></div><div class="qc l"><div class="qd l qe qf qg qc qh ks pt"/></div></div></a></div><div class="pq pr gp gr ps pt"><a href="https://www.toptal.com/software/single-responsibility-principle" rel="noopener  ugc nofollow" target="_blank"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd iu gy z fp py fr fs pz fu fw is bi translated">单一责任原则:伟大代码的秘诀</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">阅读这篇文章的西班牙语版本，由玛丽塞拉·奥尔达斯翻译，不管我们认为什么是伟大的代码…</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">www.toptal.com</p></div></div></div></a></div></div></div>    
</body>
</html>