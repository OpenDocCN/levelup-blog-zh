<html>
<head>
<title>Using CMAKE for your C++ projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为您的C++项目使用CMAKE</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-cmake-for-your-c-projects-e548302abe5f?source=collection_archive---------8-----------------------#2021-07-23">https://levelup.gitconnected.com/using-cmake-for-your-c-projects-e548302abe5f?source=collection_archive---------8-----------------------#2021-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d4bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你和我一样，当我听说我需要学习一门全新的语言来编译你的代码时，我觉得太费力了。所以，就像当时的弱者一样，我爬回了visual studio，那里一切都是解决方案。当我从事一个在visual studio之外编写的项目时，这一切都改变了，所以它使用了CMAKE，所以我认为学习CMAKE可能是一个好主意，这样我就可以了解正在发生的事情。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/93f82dda341526d053df4fd53cee0bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6wyHN6uUV_pvYdGb"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">沙哈达特·拉赫曼在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5bcd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">一个起点</h1><p id="3f31" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">首先，我们需要创建一个CMakeLists.txt文件。我们还需要指定一个CMAKE版本来使用，我们的项目名称是什么，并添加我们试图运行什么。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="fcff" class="mk ld iq mg b gy ml mm l mn mo">CMakeLists.txt</span><span id="fa96" class="mk ld iq mg b gy mp mm l mn mo">cmake_minimum_required(VERSION 3.10)</span><span id="8b43" class="mk ld iq mg b gy mp mm l mn mo">project(Application)</span><span id="dc20" class="mk ld iq mg b gy mp mm l mn mo">add_executable(Application application.cpp)</span></pre><p id="137c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以更进一步，我们可能想要指定需要什么版本的C++并且我们可能想要指定我们的项目是什么版本。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="6cea" class="mk ld iq mg b gy ml mm l mn mo">cmake_minimum_required(VERSION 3.10)<br/>set(CMAKE_CXX_STANDARD_17)<br/>set(CMAKE_CXX_REQUIRED ON)</span><span id="ebc7" class="mk ld iq mg b gy mp mm l mn mo">project(Application VERSION 1.0)</span><span id="5b0d" class="mk ld iq mg b gy mp mm l mn mo">add_executable(Application application.cpp)</span></pre><p id="d2af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于小型的单个文件项目来说很好，但是如果您想在项目中添加类呢？我们不能让CMakeLists文件保持原样，假设CMakeLists文件可以编译，但项目不会构建，因为它不知道头文件在哪里。要向CMAKE文件添加头文件，我们必须指定该文件的位置。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="5d01" class="mk ld iq mg b gy ml mm l mn mo">cmake_minimum_required(VERSION 3.10)<br/>set(CMAKE_CXX_STANDARD_17)<br/>set(CMAKE_CXX_REQUIRED ON)</span><span id="9997" class="mk ld iq mg b gy mp mm l mn mo">project(Application VERSION 1.0)<br/>add_executable(Application application.cpp)<br/>target_include_directories(Application PUBLIC "${PROJECT_BINARY_DIR}")</span></pre><p id="f063" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，上述实现假设您的函数都是内联函数，因此没有必要添加源文件。如果您的类有一个头文件和cpp文件，您需要将它包含在CMakeLists文件中。有两种方法可以做到这一点，第一种方法是CMake认可的方法，第二种方法不是。</p><h2 id="3a79" class="mk ld iq bd le mq mr dn li ms mt dp lm jy mu mv lq kc mw mx lu kg my mz ly na bi translated">准许的方法</h2><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="bb10" class="mk ld iq mg b gy ml mm l mn mo">cmake_minimum_required(VERSION 3.10)<br/>set(CMAKE_CXX_STANDARD_17)<br/>set(CMAKE_CXX_REQUIRED ON)</span><span id="6d5e" class="mk ld iq mg b gy mp mm l mn mo">project(Application VERSION 1.0)<br/>add_executable(Application application.cpp class_1.cpp)<br/>target_include_directories(Application PUBLIC "${PROJECT_BINARY_DIR}")</span></pre><h2 id="c47e" class="mk ld iq bd le mq mr dn li ms mt dp lm jy mu mv lq kc mw mx lu kg my mz ly na bi translated">第二种方法</h2><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="1d09" class="mk ld iq mg b gy ml mm l mn mo">cmake_minimum_required(VERSION 3.10)<br/>set(CMAKE_CXX_STANDARD_17)<br/>set(CMAKE_CXX_REQUIRED ON)</span><span id="b2e6" class="mk ld iq mg b gy mp mm l mn mo">project(Application VERSION 1.0)</span><span id="2c3d" class="mk ld iq mg b gy mp mm l mn mo">file(GLOB_RECURSE SRC FILES src/*.cpp)<br/>add_executable(Application application.cpp ${SRC FILES})<br/>target_include_directories(Application PUBLIC "${PROJECT_BINARY_DIR}")</span></pre><p id="14bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当处理较大的项目时，比如一个渲染引擎，你将需要使用一些库，比如你的图形API。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="c5cc" class="mk ld iq mg b gy ml mm l mn mo">add_library(glew STATIC IMPORTED GLOBAL)</span><span id="4b3d" class="mk ld iq mg b gy mp mm l mn mo">set_target_properties(glew PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/dependencies/glew/lib/windows/glew32s.lib)<br/>set_target_properites(glew PROPERTIES INCLUDE_DIRECTORIES ${CMAKE_SOURCE_DIR}/dependencies/glew/include)</span><span id="0b2f" class="mk ld iq mg b gy mp mm l mn mo">target_link_libraries(${PROJECT_NAME} PUBLIC glew)</span></pre><p id="1326" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些外部库，如上图所示，对于不同的操作系统有不同的文件。您可以为您的项目所在的每个操作系统编写不同的CMakeLists文件，或者您可以将一些逻辑放入CMakeLists文件中，以便根据您所在的操作系统导入库的不同部分。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="b77b" class="mk ld iq mg b gy ml mm l mn mo">if(CMAKE_SYTEM_NAME MATCHES WIN32)<br/>    #Import windows stuff<br/>elseif(CMAKE_SYSTEM_NAME MATCHES Linux)<br/>    #Import linux stuff<br/>elseif(CMAKE_SYSTEM_NAME MATHCES UNIX) #UNIX is MacOS<br/>    #Import UNIX stuff</span></pre><p id="c455" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样重要的是要知道，使用CMAKE我们可以从自己的源文件创建自己的库，如果您打算在其他地方使用代码片段，或者创建一个非常大的项目，例如一个游戏引擎，您需要将多个软件片段组合在一起，这将非常有用。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="7efd" class="mk ld iq mg b gy ml mm l mn mo">cmake_minimum_required(VERSION 3.10)<br/>set(CMAKE_CXX_STANDARD_17)<br/>set(CMAKE_CXX_REQUIRED ON)</span><span id="826a" class="mk ld iq mg b gy mp mm l mn mo">project(Application VERSION 1.0)<br/>add_library(Library_1 STATIC class1/class_1.cpp)<br/>target_include_directories(Library_1 PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/class1/include)</span><span id="3a8b" class="mk ld iq mg b gy mp mm l mn mo">add_executable(Application application.cpp ${SRC FILES}<br/>target_link_libraries(Application PUBLIC Library_1)</span></pre><p id="7790" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以为我们创建的每个库这样做，并且总是在顶部的CMakeLists文件中这样做，或者(这将使我们管理CMAKE文件更容易)我们可以在子目录中创建一个CMAKE文件。</p><h2 id="d6ac" class="mk ld iq bd le mq mr dn li ms mt dp lm jy mu mv lq kc mw mx lu kg my mz ly na bi translated">class1/CMakeLists.txt</h2><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="0387" class="mk ld iq mg b gy ml mm l mn mo">add_library(Library_1 STATIC class_1.cpp)<br/>target_include_directories(Library_1 PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)</span></pre><h2 id="22c7" class="mk ld iq bd le mq mr dn li ms mt dp lm jy mu mv lq kc mw mx lu kg my mz ly na bi translated">CMakeLists.txt</h2><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="91cd" class="mk ld iq mg b gy ml mm l mn mo">cmake_minimum_required(VERSION 3.10)<br/>set(CMAKE_CXX_STANDARD_17)<br/>set(CMAKE_CXX_REQUIRED ON)</span><span id="c0ae" class="mk ld iq mg b gy mp mm l mn mo">add_subdirectory(Library_1)</span><span id="75c7" class="mk ld iq mg b gy mp mm l mn mo">add_executable(Application application.cpp ${SRC FILES}<br/>target_link_libraries(Application PUBLIC Library_1)</span></pre><p id="7421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，这是一种更干净的做事方式。</p><p id="a438" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果你想把你的程序分发给其他人，在你的项目中包含一个安装程序是有意义的，为此我们只需要使用CPACK。要使用CPACK，我们需要在主CMakeLists文件的底部添加几行代码，并在我们的项目中添加一个许可证，关于许可证代码的更多信息可以在这里找到。</p><pre class="km kn ko kp gt mf mg mh mi aw mj bi"><span id="476d" class="mk ld iq mg b gy ml mm l mn mo">cmake_minimum_required(VERSION 3.10)<br/>set(CMAKE_CXX_STANDARD_17)<br/>set(CMAKE_CXX_REQUIRED ON)</span><span id="dd65" class="mk ld iq mg b gy mp mm l mn mo">add_subdirectory(Library_1)</span><span id="66c2" class="mk ld iq mg b gy mp mm l mn mo">add_executable(Application application.cpp ${SRC FILES}<br/>target_link_libraries(Application PUBLIC Library_1)</span><span id="1a41" class="mk ld iq mg b gy mp mm l mn mo">include(InstallRequiredSystemLibraries)<br/>set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/License.txt")<br/>set(CPACK_PACKAGE_VERSION_MAJOR "${APPLICATION_VERSION_MAJOR}")<br/>set(CPACK_PACKAGE_VERSION_MINOR "${APPLICATION_VERSION_MINOR}")<br/>include(CPack)</span></pre><p id="2bc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望本文已经向您展示了CMAKE并不是什么可怕的东西，而是应该包含在您的C++项目中的东西。就CMAKE能做什么而言，本文实际上只看到了冰山一角，如果正确使用，它会非常有用。要更详细地了解CMAKE，网上有大量的视频和文章，我也建议您查看CMAKE文档，可在<a class="ae lb" href="https://cmake.org/cmake/help/latest/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>