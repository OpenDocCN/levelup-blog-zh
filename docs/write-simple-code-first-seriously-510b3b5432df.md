# 首先编写简单的代码将有助于以后的优化

> 原文：<https://levelup.gitconnected.com/write-simple-code-first-seriously-510b3b5432df>

为什么首先构建简单的应用程序比试图猜测在哪里进行优化更好。

![](img/f032ca012131e2b844bcf16d4ac637ec.png)

乔恩·泰森在 [Unsplash](https://unsplash.com/s/photos/start?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

我在 Bandwidth 的团队专注于编写高吞吐量、低延迟的 REST 应用程序。对于微服务和极端水平可伸缩性的驱动来说，这并不是什么新鲜事。许多公司和团体都在做同样的事情。

在讨论对这类应用程序的需求时，我首先想到的是这样一件事:

“为了满足我们的 SLA，我们需要从一开始就实施非常积极的缓存。”

“我们将无法使用传统的数据库，甚至无法使用 NoSQL。它必须在内存中。

“如果我们一开始就不关注性能，我们的应用将永远无法满足我们的服务级别协议。”

我相信这听起来对你们有些人来说很熟悉。许多这些顾虑**都是有根据的——当设计这类应用程序时，你必须首先考虑性能；你应该考虑缓存；您应该评估和考虑使用多种工具来存储数据；等等等等。**

然而，我恳求你从简单开始。

我上面列出的所有项目可以让您很快进入一个尽最大努力猜测访问模式和性能瓶颈的地方。你会花很多时间在白板上写下如何解决你猜测的问题，很可能会想出一些复杂的东西来提高你的表现。然后到了实施的时候，你必须一直保持你的设计。再加入 3-4 名开发人员(一个典型的团队规模)，突然之间，你们所有人都不得不互相提醒，定期“达成共识”，因为你的设计太复杂了。

## 复杂性会杀人

看起来复杂的系统只是意味着它们在做更“重要”的工作，或者是由“真正聪明的人”制造的。在我(短暂的)软件工程生涯和学术课程中，我从我的软件工程师生涯和学术课程中学到，最聪明的人尽可能避免复杂性。

为什么？因为复杂性通常会降低可读性和可维护性。测试必须变得更加复杂。故障排除变得困难和令人沮丧。

复杂的系统也很难开始实施。如果你在一开始就设计了一个系统来缓解每一个边缘情况，那么开始会很困难。当你必须记住所有其他的边缘用例时，很难把注意力集中在核心用例上并让一些东西工作。您确实需要支持您发现的边缘用例，但是一旦您为核心用例确定了一条清晰的路径，支持它们将会变得更加容易。

## 从简单开始

简单的代码通常是可读的、可维护的和可测试的。这些正是你作为软件工程师想要的特征。当你阅读来自另一个开发者的极其简单的代码时，它读起来更像一本扣人心弦的小说，而不是计算机指令。

尽早拥有这些核心特征将加快您的交付时间——即使是复杂的边缘情况或严格的性能需求。

为什么？

因为当软件可读、可维护、可测试时，它也是可变的。当您得到更多的需求或者遇到可以针对性能需求进行的额外优化时，很容易进行更改。每个更改(通常)都可以很小很简洁，而不是 1000 行代码，这些代码实际上只是在未来进行数据库调用，或者还试图实现缓存，还试图优化 5 个元素的循环的每次迭代。你明白了。

## 测量，测量，测量

简单代码优先的另一个好处是简单代码更容易被**度量**。度量标准应该尽可能早地出现在你的开发周期中！！测量执行树遍历的时间。测量您正在处理的数据的大小。使用跟踪工具可以直观地看到事件是如何流过应用程序代码并找到瓶颈的。开发自动化测试来一遍又一遍地执行相同的场景，以了解每个变化如何影响您的性能。

有了这样的指标，您可以首先解决最大的瓶颈，而不是猜测它们可能是什么。

举个例子，假设你有一个进程 A，平均花费 1 毫秒，另一个进程 B，平均花费 4 毫秒。两者都需要在服务返回响应之前完成，并且一个需要在另一个之前发生(您需要来自 A 的数据用于 B)。

您可能很容易发现，通过专注于 A 可以节省 70%的时间并节省 7 ms，或者您可以将另一个瓶颈的速度提高 50%并节省 2 ms。您还可以估计每个瓶颈所需的开发时间，并发现您可以在 B 上花费两倍的时间，甚至可以节省 75%或 3 ms。

如果你只关注 B 的**和**，你的总处理时间会有很大的不同！

## 故事时间

At Bandwidth(顺便说一下，我们正在[招聘](https://grnh.se/rvdtbj8b1)！)，我们正在开发一个类似我上面描述的服务。它有一个激进的 SLA，需要像大多数服务一样执行一些数据查找。自然而然，话题开始转向“我们如何高效地存储数据？我们应该使用缓存吗？那么<在这里插入流行的内存数据存储>呢

我们的开发团队确信，从一个简单的设计开始会更有效，它只是在请求处理时直接对数据库进行所需的查找，而没有任何缓存或复杂性。我们的架构师不太确定，并强调他们认为缓存是必要的，所以我们应该尽早开始。

我们的团队和我们的架构师在这个问题上争论了一段时间。最终，我们能够说服他们让我们从更简单的开始，并在实现缓存之前测量我们的瓶颈。

快进几周，我们就有了一个简单的方法，用适当大小的数据库和数据集直接进行数据库查找。我们创建了一个 skunkworks 性能测试场景，并针对该数据运行测试，以测量我们的应用程序瓶颈。我们发现从数据库中获取数据相当快，但是我们最大的瓶颈在别的地方。

对于一些快速的上下文，让我描述一下我们的数据结构。我们的数据库查询为每个惟一的 ID 返回了一个 JSON 字符串(没什么特别的)。这个 JSON 非常复杂，我们决定为它编写一个定制的反序列化器。注意，我们的团队对这些数据没有所有权，因为我们是从一个集成合作伙伴的 API 中获取这些数据的

我们的解串器花了很长时间！

反序列化对象需要几毫秒的时间，这太长了。我们看到了一些可以轻松优化它的方法。我们尝试了一下，节省了大约 60%的时间。我们还意识到被反序列化的对象总数相当少(大约 300，000 个项目)。这已经足够小了，因此我们可以使用内存中的数据存储来缓存整个集合。我们还没有实现它，但是我相信我们可以通过有针对性的改变来实现。

我还没有告诉你的是，我们最初的假设是，我们的数据库查找将会太慢，我们将需要缓存一个大得多的数据集。相反，我们看到检索要反序列化的数据根本不是最大的瓶颈(< 1 ms)。如果我们继续下去，并决定缓存整个数据集(数百万行)，我们会发现自己有一个更复杂的(和更多的资源密集型！)应用。

我不是说你应该写慢代码或者忽略编码的基础！了解你的数据结构！了解您的一般算法运行时间！知道它们之间的取舍。

不要试图变得“太聪明”,猜测你不知道的事情。编写代码，这样**简单**和**可以理解**当你找到可以优化的地方时，你可以很容易地改变。测量你的应用程序，这样你就可以识别你的瓶颈，知道哪些是值得改进的。你未来的自己会感谢你。

编码快乐！