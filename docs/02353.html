<html>
<head>
<title>Understand RxJS Subjects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解RxJS主题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understand-rxjs-subjects-97b43f9d32ba?source=collection_archive---------5-----------------------#2020-03-08">https://levelup.gitconnected.com/understand-rxjs-subjects-97b43f9d32ba?source=collection_archive---------5-----------------------#2020-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="30b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">凭借每周1700万npm的下载量，RxJS在JavaScript世界相当受欢迎。如果你是一个角度开发者，你不可能错过RxJS可观的东西，但是你可能不太熟悉这些主题。尽管它们没有简单的可观察到的频率高，但是它们非常有用。理解它们将有助于您编写更好、更清晰的反应式代码。</p><h1 id="583e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">看得见的</h1><p id="4fc6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">直观地说，您可以将可观测量视为发出价值流的对象，或者如RxJS文档所述:</p><blockquote class="lr ls lt"><p id="b2c6" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated">可观察值是多个值的惰性推送集合。</p></blockquote><p id="e8db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们可以用肉眼观察到的数字每秒钟发出0到59的数字:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1852" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">订阅该可观察值的观察者将每秒接收一个值:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/5240db0d5a84de121ca681634b11d301.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*tCF1COPzatyjh0qk9NHAtg.png"/></div></figure><p id="48d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你需要订阅可观测值来开始计数，就像你需要调用一个函数来计算它一样。同样类似于函数，第二次“调用”将触发新的独立执行。如果你在两秒钟后再次订阅这个观察，你会在你的控制台上看到两个“计数器”，第二个有两秒钟的延迟。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/f86ae636d60848718fbc8cb2c9994272.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*s0fK46v0zgAgMyev1CXIZQ.png"/></div></figure><p id="fd1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着你不能同时向两个观察者发出相同的值，至少不能使用简单的观察值。为此，你需要主题。</p><h1 id="60a8" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">学科</h1><blockquote class="lr ls lt"><p id="7a50" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated">一个主题就像一个可观察对象，但是可以多播给许多观察者。</p></blockquote><p id="2bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主体是可观察的。我们可以使用一个主题创建相同的计数器，每秒钟发出0到59的数字:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="9cb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能会发现与我们之前的示例的主要区别。当声明一个可观察对象时，我们给了一个函数作为参数，告诉可观察对象向订阅者发出什么。这是可以的，因为每个新的订阅者将开始一个新的执行。另一方面，在这种情况下，我们只有一次执行，新订户只是开始“听”它。我们简单地用<em class="lu"> new Subject()创建一个新对象。</em></p><p id="fae5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以订阅我们的主题，因为<strong class="js iu">主题是可观察的</strong>。然后我们在我们的主题上直接调用<em class="lu">的下一个</em>，因为<strong class="js iu">主题是观察者。</strong></p><p id="8320" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何新的订户都将被添加到Subject内部保存的订户列表中，并且将同时接收与其他订户相同的值。如果我们在第一次订阅后两秒钟订阅主题，新的订阅者将会错过前两个值:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/b3980e50064b9ad889e9cc8cebdf180a.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*VCrdQ0JZLw3xNgJADb1OwA.png"/></div></figure><p id="01f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用主题一次向许多观察者发送值。你正在<em class="lu">多播</em>给许多观察者。</p><h1 id="ebc9" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">行为主体</h1><p id="5146" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">您可能遇到的主题问题是，观察器将只接收订阅主题后发出的值。在前面的例子中，第二个发射器没有接收到值0、1和2。在订阅之前，您有时需要知道主题最后发出了哪个值。例如，如果您发出日期，就会出现这种情况。任何在3月1日订阅的观察者应该在订阅时收到01-03-20，不管他们是在什么时候订阅的。午夜时，每个订阅者都会收到日期已更改的通知。</p><p id="b831" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这种情况，你可以使用行为主语。BehaviorSubject保存它发出的最后一个值的记忆。订阅时，观察者会立即收到最后发出的值。如果我们修改前面的示例，这将意味着第二个观察者在订阅时收到值2，然后像第一个观察者一样收到所有其他值。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/62afdb5129ae4366f9fb6ccc1524af92.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*00_fjgDIcK2fDTaxE-85ww.png"/></div></figure><p id="5953" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能已经注意到，在这个例子中，我们需要给一个行为主体一个初始值，而主体却不是这样。这是行为主体总是需要当前值的结果。</p><h1 id="85b0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">重播主题</h1><p id="f159" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">重播主题和行为主题非常相似。不同的是，它们不会只记住最后一个值，而是你想要多少就有多少。在订阅时，它们将自己记住的所有值发送给新的观察者。</p><p id="1415" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你不需要在创建时给它们任何初始值，但是你可以定义它们应该在内存中保存多少值。在本例中，我们保留了两个值:</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/335cce099cd1360ca1427f7f49d61371.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*ffEGStWRzrVogWbKz98-lQ.png"/></div></figure><p id="dc24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当第二个观察者订阅ReplaySubject时，已经发出了0、1和2。由于ReplaySubject保存了最后两个值，第二个观察者立即收到1和2。</p><h1 id="f145" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">异步主题</h1><p id="917d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">对于AsyncSubjects，在主题完成之前，您的观察者实际上什么也得不到。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="75b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中使用一个AsyncSubject，在观察者收到任何东西之前，我们必须等待整整一分钟。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/5ea4ec4a116ca9aa717745ee02b16d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*CFLjnLOKY0VO8G-NU4hfRQ.png"/></div></figure><p id="db05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你也可以看到我们要把题目做完整，这是我们之前没有做到的。如果我们不这样做，我们的观察者将根本收不到任何东西。</p><p id="bece" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在AsyncSubject完成后，任何订阅它的观察者都会收到相同的值。</p><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="c3dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，第三个观察者在AsyncSubject完成五秒钟后订阅了它。在订阅时，它接收最后一个值:59。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/3518c260284212cd6ccb41754dc480a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*VA5yZCCyZ_A9s61eUKUZPQ.png"/></div></figure><p id="4583" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这使得AsyncSubjects对于获取和缓存一个值非常有用，就像一个HTTP响应，您只需要获取一次，然后从不同的地方访问。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="0047" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自己尝试这些例子，并修改它们，以了解它如何影响结果。当谈到反应式编程时，对RxJS主题的良好理解将有助于您编写更具可读性和更高效的代码。</p></div></div>    
</body>
</html>