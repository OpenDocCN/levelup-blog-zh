<html>
<head>
<title>Interesting points from Abramov’s “A Complete Guide to useEffect”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿布拉莫夫《使用效果完全指南》中的有趣观点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/interesting-points-from-abramovs-a-complete-guide-to-useeffect-99ef9e136a19?source=collection_archive---------2-----------------------#2019-05-29">https://levelup.gitconnected.com/interesting-points-from-abramovs-a-complete-guide-to-useeffect-99ef9e136a19?source=collection_archive---------2-----------------------#2019-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/db936d8916b8acad39244c17252b1465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmtyI-Udi3v0FRRNlujchg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">酸橙不错:3 ( <a class="ae kf" href="https://unsplash.com/photos/c8TWWQ5ZnUw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Hoach Le Dinh </a>)</figcaption></figure><p id="df2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今年，在个人和生产项目中，我一直在使用钩子和redux钩子。这个API有点粗糙——但是他们通常不负众望。我已经能够相对无缝地重构应用程序，让所有组件都发挥作用真的非常困难。</p><p id="4d11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="le lf ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----99ef9e136a19--------------------------------" rel="noopener" target="_blank">几个月前，丹·阿布拉莫夫</a>以<code class="fe lg lh li lj b">useEffect</code>为主题写了一篇非常长且<a class="ae kf" href="https://overreacted.io/a-complete-guide-to-useeffect/" rel="noopener ugc nofollow" target="_blank">有用的博文</a>(我参加派对迟到了)。我在这里的重点不是TL；DR(他有自己的总结)，甚至是我自己从文章中获得的，但我在文档或我读过的教程中没有获得的一些有趣的hooks API行为。在丹的文章中，它们有点像旁注，但鉴于这些想法对我来说是多么陌生，我认为它们至少值得发表在这样一篇小文章中。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="dd7a" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">cleanupCallback！= componentDidUnmount</h1><p id="43bf" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">第一个是可选的清理函数，您可以从传递给<code class="fe lg lh li lj b">useEffect</code>的回调中返回。来自react官方文档:</p><blockquote class="mu mv mw"><p id="2825" class="kg kh mx ki b kj kk kl km kn ko kp kq my ks kt ku mz kw kx ky na la lb lc ld im bi translated">【React到底什么时候清理效果？当组件卸载时，React执行清理<strong class="ki iu">。然而，正如我们之前了解到的，效果会在每次渲染时运行，而不是只运行一次。<strong class="ki iu">这也是为什么React <em class="it">和</em>会在下次运行效果之前清除之前渲染的效果</strong>。</strong></p></blockquote><p id="6f78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想当我读到当组件被卸载时，我的大脑忽略了这句话的其余部分。我已经被锁定在生命周期思维模式中，并且classes == hooks，我没有承认<code class="fe lg lh li lj b">useEffect</code>的新特性，即在再次运行useEffect回调时运行它的清理<em class="mx">。每当<code class="fe lg lh li lj b">useEffect</code>回调运行时，在它可以再次运行之前，清理回调将被运行。它有一些有趣的含义，尽管老实说，目前还没有想到这种行为的实际应用😅。</em></p><p id="fd0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个效果回调将在每次渲染后运行，除非我们指定一个dep数组。如果我们指定dep，它将只在dep在渲染之间变化时运行。如果发生这种情况，清理回调也必须运行。这不仅仅发生在组件卸载的时候。但事实上，我们可能真的不应该认为我们的组件是用钩子组件“卸载”的，而是另一个渲染的结束，尽管是最终的。</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c4c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以通过玩这个<a class="ae kf" href="https://codesandbox.io/embed/distracted-bardeen-k5qz1" rel="noopener ugc nofollow" target="_blank">例子</a>来看这个irl。检查控制台，你会看到每按一次按钮，回调函数中的日志就被打印出来，清理函数中的日志也是如此。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="ecc1" class="lr ls it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><code class="fe lg lh li lj b">dispatch</code>是个酷hax</h1><p id="9516" class="pw-post-body-paragraph kg kh it ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">丹创造了一个利用两个状态变量的效果的例子。其中一个变量的计算值依赖于另一个，因此其他变量必须作为dep列出。你可以在他的例子<a class="ae kf" href="https://codesandbox.io/s/zxn70rnkx" rel="noopener ugc nofollow" target="_blank">这里</a>中看到这一细节，或者只看下面的片段</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1793" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们使用回调来改变<code class="fe lg lh li lj b">count</code>的值，这允许我们避免将它传递给我们的数组deps。但是由于它的计算值依赖于<code class="fe lg lh li lj b">step</code>，我们必须将<code class="fe lg lh li lj b">step</code>传递到数组中。当<code class="fe lg lh li lj b">step</code>改变时，效果回调和清理函数都被调用。如果出于某种原因，你不希望效果和它的清理功能被调用，你可以随时召唤<code class="fe lg lh li lj b">dispatch</code>。</p><p id="aff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">效果有点像远程访问和修改你的状态。<code class="fe lg lh li lj b">dispatch</code>从效果内部发送一个动作到相应的<code class="fe lg lh li lj b">reducer</code>，将效果从状态中分离出来，并允许您更好地控制效果何时运行。这里的可以找到一个例子<a class="ae kf" href="https://codesandbox.io/s/xzr480k0np" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="febf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这实际上是阿布拉莫夫试图传达的一个主要观点，但我把它包括在这里，因为从官方文件来看<code class="fe lg lh li lj b">dispatch</code>的这种行为并不明显。我也想包括它，因为它展示了<code class="fe lg lh li lj b">useReducer</code>的效用。在第一次查看关于这种方法的文档时，我有点不以为然。我认为它只是一个redux风格的全局reducer移动到一个组件状态。现在我可以看到它更有能力了。</p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><p id="36ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这些观点让我震惊，但在Dan的文章中还有很多其他非常有用的观点，尽管它很长，我还是鼓励所有人阅读它，至少是TL；这篇文章的大部分内容鼓励为渲染阶段采用一种新的心智模型，尽管我不能说我100%理解它，但我会说它对我帮助很大。</p><p id="a0bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个更辣的收获是hooks API在进入黄金时段之前，尤其是在大约<code class="fe lg lh li lj b">useEffect</code>的时候，可能还需要一点点的润色和抽象。记忆功能，将静态功能提升到组件主体之外，创建冗长的异径管，增加了一些进入imo的障碍。或者也许我只是思想狭隘，看事情不正确。大家在评论里聊聊吧！</p><p id="8e5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi">🐈</p></div></div>    
</body>
</html>