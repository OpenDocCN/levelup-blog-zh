<html>
<head>
<title>Managing Terraform At Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大规模管理地形</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-terraform-at-scale-d71d6b7a0357?source=collection_archive---------14-----------------------#2021-11-30">https://levelup.gitconnected.com/managing-terraform-at-scale-d71d6b7a0357?source=collection_archive---------14-----------------------#2021-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="29d9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">管理地形状态和模块的技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4319f4e6f267bd572658ffaaf0fb1e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w74z2PsEc5CotJsaae65Sg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.terraform.io" rel="noopener ugc nofollow" target="_blank"> HashiCorp Terraform </a>标志</figcaption></figure><p id="e3b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> T </span> erraform是开发基础设施代码(IaC)的一个很好的工具。但是也有一些问题，特别是Terraform状态的管理和可重用的Terraform模块。幸运的是，只要稍加思考和努力，这些挑战是可以克服的。</p><h1 id="8bbc" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">管理地形状态</h1><p id="03f8" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">默认情况下，Terraform状态存储在Terraform模块目录中的本地文件系统上。如果你只是玩玩，那就太好了。但是，如果你想确保你的状态是持久的，或者如果你想让其他任何人都可以使用你的状态，你需要使用一个不同的后端，比如Terraform Cloud或S3(如果你在AWS中)。</p><p id="ddb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您正在使用一个S3桶作为您的后端。那个桶必须以某种方式被创造出来。如果你用Terraform创建这个桶，并且你想用它作为你的后端，那么你就有一个先有鸡还是先有蛋的问题。这不是一个无法解决的问题。您可以使用Terraform和本地状态创建bucket，然后更改后端状态配置以指向bucket。但是，现在有了一个不同的问题，如果您将状态存储在Terraform state管理的对象中，您需要注意对该对象所做的任何更改，以免导致不可恢复的状态情况。</p><h2 id="6ca2" class="my mc iq bd md mz na dn mh nb nc dp ml lf nd ne mn lj nf ng mp ln nh ni mr nj bi translated">不同环境的状态</h2><p id="3348" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">撇开[相对次要的]状态存储问题不谈，如何为不同的环境设置Terraform呢？您的第一个倾向可能是使用Terraform工作空间。然而，如果安全是一个问题，这不是一个很好的选择。</p><blockquote class="nk nl nm"><p id="96db" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">组织通常希望在服务于不同开发阶段(例如，试运行与生产)或不同内部团队的同一基础架构的多个部署之间建立强有力的隔离。在这种情况下，用于每个部署的后端通常属于该部署，具有不同的凭证和访问控制。对于这种情况，命名工作区不是合适的隔离机制。</p><p id="e66f" class="kw kx nn ky b kz la jr lb lc ld ju le no lg lh li np lk ll lm nq lo lp lq lr ij bi translated">- <a class="ae kv" href="https://www.terraform.io/docs/language/state/workspaces.html#when-to-use-multiple-workspaces" rel="noopener ugc nofollow" target="_blank">哈希公司</a></p></blockquote><p id="1f56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Terraform将其状态文件存储为纯文本。您的基础架构组件的名称、Terraform使用的任何密码以及Terraform管理的基础架构的所有配置详细信息都存储在纯文本状态文件中。工作区只是存储在同一后端位置的不同状态文件。因此，如果您不希望有权访问开发环境状态的人也有权访问生产环境状态，那么您就不希望使用Terraform工作区来跨环境管理状态。</p><p id="ebc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更好的方法是使用部分后端配置。部分后端配置要求您只将后端的类型存储在根Terraform模块的本地文件中。剩下的后端配置可以在命令行上通过<em class="nn"> terraform init </em>提供。这允许您在不编辑文件的情况下更改后端存储位置。而且，如果您不想一致地输入那些剩余的参数，您可以将它们存储在某种类型的参数存储中(例如AWS参数存储),并在需要时获取它们。</p><p id="5aaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您可能想象的那样，如果使用部分后端配置，那么通过构建自动化工具自动提供基础设施将变得非常简单，因为许多这样的工具支持不同的可配置概要文件。后端配置文件配置可以与环境保持一致，与后端配置相关联，并在命令行上用<em class="nn"> terraform init </em>命令注入。</p><h2 id="c23f" class="my mc iq bd md mz na dn mh nb nc dp ml lf nd ne mn lj nf ng mp ln nh ni mr nj bi translated">分割状态</h2><p id="ea77" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">状态管理是Terraform的一个经常考虑的问题。然而，拥有易于管理的基础设施和弹性状态的愿望有时是相互矛盾的。</p><p id="7aca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以具有复制功能的S3桶为例。源存储区在区域A中调配，目标存储区在区域b中。目标存储区的存在只是为了确保源存储区的数据可恢复性。如果某个区域发生了中断事件，导致源存储桶关闭，您可能希望管理从源存储桶分离的目标存储桶的状态。这意味着两个不同的根模块具有两种不同的状态:一个用于源桶，一个用于目的桶。然而，一个地区的停电事件不会是一个常见的情况。此外，由于有两个独立的Terraform配置，复制的S3存储桶的管理复杂性加倍，以应对这种可能性。在两个区域都可用的常见情况下，更希望将源存储桶和目标存储桶作为单个配置来管理(即，一个<em class="nn"> terraform apply </em>命令来供应两者)。</p><p id="c775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不是有两个不同的根模块和两个不同的状态，而是只有一个根模块和一个状态，会怎么样？这个模块将把源桶和目的桶耦合在一起。这两个存储桶将被一起提供，它们的生命周期也将被一起管理(更新、删除等)。)但是，现在有一个问题，如果一个地区确实发生了断电事件。没有简单的方法来恢复目标存储桶的状态，并将其从聚合状态中分离出来进行管理…除非状态也被复制到区域B，并且每个存储桶都是使用单独的模块定义的。</p><p id="590d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了阐明这种方法，有一个模块用于目标存储桶，有一个模块用于源存储桶，还有一个根模块将源存储桶和目标存储桶合并成一个模块。当区域断电事件发生时，从根模块的状态中提取与幸存区域相关联的模块状态。然后，定义bucket的子模块可以用作根模块。更深入的细节可以在下面参考资料部分链接的post<em class="nn">terra form State</em>的灾难恢复中找到。</p><h1 id="4bf0" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">管理Terraform模块</h1><p id="67b9" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">Terraform模块已在上文中提及。但是，什么是地形模块呢？简单地说，Terraform模块是一个可重用的Terraform配置。根模块是一种特殊类型的地形模块，可以直接初始化、应用、规划和删除。</p><p id="300a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几条规则将Terraform根模块与其他Terraform模块区分开来。但是，一般来说，没有理由为什么Terraform模块不能是Terraform根模块。下面将主要根据来源于Terraform根模块或其他Terraform模块的Terraform模块来讨论Terraform模块。</p><h2 id="af31" class="my mc iq bd md mz na dn mh nb nc dp ml lf nd ne mn lj nf ng mp ln nh ni mr nj bi translated">发布和使用Terraform模块</h2><p id="101e" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">Terraform模块可以发布到Terraform注册表、网络驱动器、S3桶、Git回购、GCS桶和HTTP URLs。模块源在使用模块的地形配置中指定。该模块作为<em class="nn"> terraform init </em>命令的一部分被验证和获取(或直接通过<em class="nn"> terraform get </em>)。</p><p id="4a1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Terraform强加的配置中指定模块源的要求有一些非常重要的含义，包括:</p><ul class=""><li id="fb1c" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated">更新版本需要更改代码</li><li id="2f3e" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">更改模块版本可能需要在Terraform配置中的多个位置进行更新</li><li id="dec8" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">同一模块的不同版本可以出现在同一配置中</li></ul><p id="07a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">* *注:术语“模块”、“地形模块”、“配置”和“地形配置”可互换使用。</em></p><p id="7f2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用说，这些都是相当大的问题。Terraform开发人员通过将Terraform模块依赖关系的已发布源代码外部化来解决这些问题。实现这一点的一种机制是通过使用Terrafile，它通过将发布的源代码翻译成单个本地模块源代码，将模块的发布源代码外部化。这里的优点是本地模块源没有版本，Terrafile(在Terraform配置的外部)处理指定版本的获取。这与其他语言中的依赖管理没有太大的不同(例如Python中的资源或Java中的Maven/Gradle)。事实上，甚至有一个Terraform Maven插件，允许使用Maven和Maven存储库来发布、版本化和获取Terraform模块。</p><p id="4eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Terrafile的缺点是没有发现功能。因此，它可能仍然是一个寻宝游戏来寻找Terraform模块的依赖关系。这是使用Terraform注册表或Terraform和Maven的一个好处。Maven确实有内置发现，可以使用。此外，Maven还支持原型，这对于生成项目框架来说非常方便。而且，如果您已经在使用Maven，那么添加带有自动化[Java/Groovy/Kotlin/JVM]测试支持的Terraform项目可能会很有吸引力。</p><h1 id="54ad" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="66b6" class="nr ns iq ky b kz mt lc mu lf of lj og ln oh lr nw nx ny nz bi translated">不同环境的地形状态应该存储在不同的后端位置。</li><li id="5ed8" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">使用一致的后台类型，允许部分后端配置。</li><li id="2337" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">使用部分后端配置允许后端位置是动态的。</li><li id="e6de" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">Terraform模块和状态应根据其管理方式进行划分。</li><li id="142f" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">为了简单起见，通常一起使用的模块可以聚合在一起，然后在不常见的情况下可以分解。</li><li id="4786" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">Terraform为模块重用设置了相当大的障碍；最值得注意的是，发布的模块源及其版本包含在Terraform配置中。</li><li id="1ea8" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">Terraform外部的依赖管理解决方案是可用的，包括Terrafile和Terraform Maven插件。</li></ul></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="bbc2" class="mb mc iq bd md me op mg mh mi oq mk ml jw or jx mn jz os ka mp kc ot kd mr ms bi translated">资源</h1><ul class=""><li id="94a4" class="nr ns iq ky b kz mt lc mu lf of lj og ln oh lr nw nx ny nz bi translated"><a class="ae kv" href="https://www.terraform.io/docs/language/state/index.html" rel="noopener ugc nofollow" target="_blank">地形状态</a></li><li id="3e9b" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://www.terraform.io/docs/language/settings/backends/index.html" rel="noopener ugc nofollow" target="_blank">地形后端</a></li><li id="cee9" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://www.terraform.io/docs/language/state/workspaces.html" rel="noopener ugc nofollow" target="_blank">地形工作区</a></li><li id="afe1" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://www.terraform.io/docs/language/settings/backends/configuration.html#partial-configuration" rel="noopener ugc nofollow" target="_blank">地形部分后端配置</a></li><li id="74a2" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://www.terraform.io/docs/cli/commands/init.html" rel="noopener ugc nofollow" target="_blank">地形命令:初始化</a></li><li id="89f4" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html" rel="noopener ugc nofollow" target="_blank"> AWS系统管理器参数存储</a></li><li id="69d9" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://www.bluflametech.com/blog/recover-tf-state/" rel="noopener ugc nofollow" target="_blank">地形状态下的灾难恢复</a></li><li id="afce" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://www.terraform.io/docs/language/modules/index.html" rel="noopener ugc nofollow" target="_blank">地形模块</a></li><li id="de4a" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://www.terraform.io/docs/cli/commands/get.html" rel="noopener ugc nofollow" target="_blank">地形命令:获取</a></li><li id="b416" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://bensnape.com/2016/01/14/terraform-design-patterns-the-terrafile/" rel="noopener ugc nofollow" target="_blank"> Terraform设计模式:Terrafile </a></li><li id="3fe4" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://github.com/deliveredtechnologies/terraform-maven" rel="noopener ugc nofollow" target="_blank"> Terraform Maven插件</a></li><li id="797c" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><a class="ae kv" href="https://maven.apache.org/guides/introduction/introduction-to-archetypes.html" rel="noopener ugc nofollow" target="_blank">美芬原型</a></li></ul></div></div>    
</body>
</html>