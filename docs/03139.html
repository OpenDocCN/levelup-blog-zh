<html>
<head>
<title>Writing C++ Modules For Feral</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Feral编写C++模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-c-modules-for-feral-391c30ac7739?source=collection_archive---------13-----------------------#2020-04-21">https://levelup.gitconnected.com/writing-c-modules-for-feral-391c30ac7739?source=collection_archive---------13-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c006" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用C++扩展野生编程语言</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3311b2bbd3d0798e7c9299577745a214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7rwtzF9ijge-f6OQH89ag.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">为本文中创建的模块构建脚本</figcaption></figure><p id="33a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的<a class="ae le" href="https://medium.com/@ElectruxR/the-feral-programming-language-81f87deb58cc" rel="noopener">上一篇文章</a>中，我介绍了<a class="ae le" href="https://github.com/Feral-Lang" rel="noopener ugc nofollow" target="_blank">野生</a>编程语言。这一次，我们将为它创建C++扩展！这些扩展是为该语言添加功能和库支持的构建块。通常，一个通用任务可以用Feral本身实现，但是当任务需要本机性能时，用C++编写它特别有用。</p><p id="458a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出于本文的目的，我们将实现一个C++模块，包含一个野生变量和函数，来演示如何正确地利用可用的特性来为我们服务。</p><p id="06ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何疑问、问题等。可以在GitHub或Feral的discord服务器上询问(链接在底部)。🙂</p><h1 id="3d54" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">概念</h1><p id="9fd3" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在Feral中，C++扩展的工作方式如下:</p><ol class=""><li id="aca6" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">使用我们的脚本中的<code class="fe mr ms mt mu b">mload()</code>函数在运行时加载扩展。在内部，这将打开给定的动态库(模块)并调用其中一个名为<code class="fe mr ms mt mu b">init_&lt;module_name&gt;()</code>的特殊函数(使用<code class="fe mr ms mt mu b">INIT_MODULE(module_name)</code>宏在模块中创建)。</li><li id="29ff" class="mi mj it js b jt mv jx mw kb mx kf my kj mz kn mn mo mp mq bi translated">通过<code class="fe mr ms mt mu b">init_&lt;module_name&gt;()</code>函数将所需的变量和函数注入/插入到Feral运行时。</li><li id="5e8c" class="mi mj it js b jt mv jx mw kb mx kf my kj mz kn mn mo mp mq bi translated">变量和函数现在可以从Feral源访问。</li><li id="9390" class="mi mj it js b jt mv jx mw kb mx kf my kj mz kn mn mo mp mq bi translated">如果有动态分配的变量，可以使用可选的<code class="fe mr ms mt mu b">deinit_&lt;module_name&gt;()</code>函数(使用<code class="fe mr ms mt mu b">DEINIT_MODULE(module_name)</code>宏创建)取消分配。这方面的一个例子是<a class="ae le" href="https://github.com/Feral-Lang/Feral-Curl" rel="noopener ugc nofollow" target="_blank">野性语言/野性卷曲</a>模块。</li></ol><p id="b59f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根本就是这样！很简单，我想…我希望至少？😁 🙈</p><h1 id="11c0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">编写我们的模块——创建变量</h1><p id="09aa" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">对于一个带有解释和完整源代码的简单模块，请查看<strong class="js iu"> ImMaax </strong>的存储库:<a class="ae le" href="https://github.com/ImMaax/Feral-HelloWorld" rel="noopener ugc nofollow" target="_blank">ImMaax/Feral-hello world</a>。</p><p id="8593" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，我们去找些有趣的东西吧！首先，我们需要为模块创建一个目录结构。Feral附带了一个构建系统，当提供了一个特定的目录结构和一个构建脚本(<code class="fe mr ms mt mu b">build.fer</code>)时，它会为你构建并安装你的Feral C++模块。就这么简单。</p><p id="e8ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目录结构如下:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="c612" class="ne lg it mu b gy nf ng l nh ni">&lt;a_module_directory&gt;/<br/>    ├─ include/<br/>    ├─ src/<br/>    └─ build.fer</span></pre><p id="b992" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mr ms mt mu b">src/</code>目录将包含C++源文件，而<code class="fe mr ms mt mu b">include/</code>目录将包含<code class="fe mr ms mt mu b">.fer</code>导入脚本。注意，两者都不是必须的。我们将在<code class="fe mr ms mt mu b">src/</code>目录下创建我们的<code class="fe mr ms mt mu b">.cpp</code>模块源文件。现在，让我们把它命名为<code class="fe mr ms mt mu b">learn.cpp</code>(是的，我知道——太有创意了！).</p><p id="f5c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们的目录结构如下所示:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="e2e4" class="ne lg it mu b gy nf ng l nh ni">&lt;a_module_directory&gt;/<br/>    ├─ include/<br/>    ├─ src/<br/>    │   └─ learn.cpp<br/>    └─ build.fer</span></pre><p id="d456" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经准备好深入(华丽的)C++源代码了。</p><p id="8558" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为所有需要的声明都存在于你的野生安装的<code class="fe mr ms mt mu b">PREFIX_DIR</code>中的<code class="fe mr ms mt mu b">feral/VM/VM.hpp</code>头文件中(更多关于那个<a class="ae le" href="https://feral-lang.github.io/Book/01-install.html#compiler-and-virtual-machine" rel="noopener ugc nofollow" target="_blank">这里是</a>)，我们将不得不把那个文件包含在我们的源代码中。</p><p id="efa2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还使用了<code class="fe mr ms mt mu b">INIT_MODULE</code>宏，它为我们的模块提供了一个入口点。我们的源文件将如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我们的准系统C++扩展源文件</figcaption></figure><p id="f808" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意</strong>模块名<strong class="js iu">必须</strong>与源文件名相同(减去<code class="fe mr ms mt mu b">.cpp</code>部分)，包括字母大写。</p><p id="c8e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们创建一个源局部变量——比如说<code class="fe mr ms mt mu b">pi</code> (3.14157)。</p><p id="0b5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于变量是源本地的(仅在调用<code class="fe mr ms mt mu b">mload()</code>加载该模块的野生源文件中可用)，我们需要获取当前打开的野生源文件，然后我们可以将变量添加到其中。</p><p id="bc3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获取当前源，我们基本上获取了野生虚拟机的源文件堆栈中的顶部元素，并将该元素存储在一个<code class="fe mr ms mt mu b">var_src_t*</code>类型变量中。</p><p id="5c81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这总结起来就是:<code class="fe mr ms mt mu b">var_src_t * src = vm.current_source();</code>。</p><p id="526e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在源代码中实际插入变量，我们必须在<code class="fe mr ms mt mu b">src</code>指针上调用<code class="fe mr ms mt mu b">add_native_var</code>函数。在源代码中插入<code class="fe mr ms mt mu b">pi</code>的完整语句是:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="90de" class="ne lg it mu b gy nf ng l nh ni">src-&gt;add_native_var("pi", make_all&lt;<em class="nl">var_flt_t</em>&gt;(3.14157, src_id, idx));</span></pre><p id="74b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来分析一下。</p><p id="dd13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从最里面，我们看到了<code class="fe mr ms mt mu b">make_all&lt;var_flt_t&gt;</code>。本质上，<code class="fe mr ms mt mu b">var_flt_t</code>是一个用于存储浮点值的野生类型。<code class="fe mr ms mt mu b">make_all</code>是一个允许我们用所需值初始化类型(此处为<code class="fe mr ms mt mu b">var_flt_t</code>)的函数。</p><p id="b247" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mr ms mt mu b">var_flt_t</code>的论据是:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="5196" class="ne lg it mu b gy nf ng l nh ni">1. float: the floating point value to be created<br/>2. size_t: the current source ID<br/>3. size_t: the current source location index</span><span id="6427" class="ne lg it mu b gy nm ng l nh ni">For the first argument, we enter the pi's value - 3.14157.<br/>src_id and idx are provided to us through the INIT_MODULE macro itself.</span></pre><p id="2f71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mr ms mt mu b">src_id</code>和<code class="fe mr ms mt mu b">idx</code>变量是至关重要的，因为在错误发生时，它们被用来显示源文件、发生错误的行和列。</p><p id="2032" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mr ms mt mu b">src-&gt;add_native_var()</code>的第一个参数是我们的变量在野性中的名字(这里是<code class="fe mr ms mt mu b">pi</code>)。</p><p id="730f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，就这样吧！我们在扩展中创建了第一个野性变量！整个源代码应该看起来像这样:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我们的带有pi变量的C++扩展源文件</figcaption></figure><p id="2ca1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，剩下要做的就是创建我们的构建脚本(<code class="fe mr ms mt mu b">build.fer</code>)并安装这个模块供我们测试。构建脚本如下所示:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="c8e9" class="ne lg it mu b gy nf ng l nh ni">let <em class="nl">sys</em> = import('std/sys');<br/>let <em class="nl">builder</em> = import('std/builder');</span><span id="61ab" class="ne lg it mu b gy nm ng l nh ni">let <em class="nl">build</em> = builder.new().make_dll();<br/>build.add_src('src/learn.cpp');</span><span id="c9fa" class="ne lg it mu b gy nm ng l nh ni">sys.exit(build.perform('learn'));</span></pre><p id="fda8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们在这个脚本中只需要注意两件事:<code class="fe mr ms mt mu b">build.add_src('src/learn.cpp');</code>和<code class="fe mr ms mt mu b">sys.exit(build.perform('learn'));</code>。</p><p id="080e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这分别是我们的源文件位置和构建名称。记住根据你的文件位置和模块名来命名它们。</p><p id="7bc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，我们将使用<code class="fe mr ms mt mu b">feral install</code>命令安装我们的模块。但是首先，确保Feral的模块目录是使用<code class="fe mr ms mt mu b">feral init</code>命令初始化的。对我来说，<code class="fe mr ms mt mu b">feral install</code>的输出是:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ea2aebea3304577b6e727af7297142af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*Zow6PAvCl1d7rbXoa8Wi3Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">恶意安装</figcaption></figure><p id="112f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">耶！是时候测试一下了！</p><p id="23c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只需创建一个脚本——比如说<code class="fe mr ms mt mu b">test.fer</code>,在该文件中导入<code class="fe mr ms mt mu b">io</code>模块和<code class="fe mr ms mt mu b">mload()</code>我们的自定义模块，并使用<code class="fe mr ms mt mu b">io.println()</code>函数看看我们是否可以打印pi值。其代码如下:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="a16b" class="ne lg it mu b gy nf ng l nh ni">let io = import('std/io');<br/>mload('learn');</span><span id="44b1" class="ne lg it mu b gy nm ng l nh ni">io.println('Value of pi is: ', pi);</span></pre><p id="ea01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将获得以下输出:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="9887" class="ne lg it mu b gy nf ng l nh ni">Value of pi is: 3.14157000000000019568</span></pre><p id="1523" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">耶！！我们做了第一个C++扩展！！</p><p id="899e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，它还没有完成。注意到<code class="fe mr ms mt mu b">mload()</code>而不是<code class="fe mr ms mt mu b">import()</code>了吗？是的，我们不想那样。原因是其中的符号不能存储在变量中(如<code class="fe mr ms mt mu b">io</code>)，这意味着它在这个脚本之外是不可用的。</p><p id="fc87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们希望将这个<code class="fe mr ms mt mu b">mload()</code>调用封装在一个我们将根据需要导入的野生脚本中，而不是一次又一次地使用<code class="fe mr ms mt mu b">mload()</code>。</p><p id="5d5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，创建一个野生脚本——比如说在<code class="fe mr ms mt mu b">include/</code>目录中的<code class="fe mr ms mt mu b">learn.fer</code>,并在该脚本中编写<code class="fe mr ms mt mu b">mload()</code>函数调用:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="70c7" class="ne lg it mu b gy nf ng l nh ni">mload('learn');</span></pre><p id="7863" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，再做一个<code class="fe mr ms mt mu b">feral install</code>轰！我们已经完成了简单模块的创建！！</p><p id="1f80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使用它，我们将调用<code class="fe mr ms mt mu b">import()</code>，而不是调用<code class="fe mr ms mt mu b">mload()</code>，并将它存储在一个包含我们的<code class="fe mr ms mt mu b">pi</code>变量的变量中。我们最终的测试脚本将如下所示:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="85d6" class="ne lg it mu b gy nf ng l nh ni">let io = import('std/io');<br/>let learn = import('learn');</span><span id="c59e" class="ne lg it mu b gy nm ng l nh ni">io.println(learn.pi);</span></pre><p id="20c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">呜呜呜。我们的第一个C++野生扩展！是不是很牛逼？！🤩😍</p><p id="a75f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是时候为Feral创建一个C++函数了！</p><h1 id="736b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">编写我们的模块—创建一个函数</h1><p id="8c58" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">野生函数的C++签名是特定的。我们必须使用这个签名来创建一个野生函数。签名是:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="5516" class="ne lg it mu b gy nf ng l nh ni"><em class="nl">var_base_t</em> * func(<em class="nl">vm_state_t</em> &amp;, const <em class="nl">fn_data_t</em> &amp;);</span></pre><p id="9592" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数名(这里是<code class="fe mr ms mt mu b">func</code>)可以是你想要的任何名字。该函数必须有两个参数:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="e7b5" class="ne lg it mu b gy nf ng l nh ni">1. vm_state_t&amp;: virtual machine state - provides access to the VM<br/>2. const fn_data_t&amp;: the function call information - mainly arguments, keyword arguments, src_id, and idx</span></pre><p id="864b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且，该函数必须返回一个野生变量对象指针(<code class="fe mr ms mt mu b">var_base_t*</code>)。</p><p id="f7ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，让我们创建一个返回字符串长度的函数！</p><p id="57bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们知道，在C++中，字符串的长度是由<code class="fe mr ms mt mu b">std::string::size()</code>成员函数返回的。我们可以利用这一点。当然，Feral有一个C++的<code class="fe mr ms mt mu b">string</code>类型的包装器。你猜对了——<code class="fe mr ms mt mu b">var_str_t</code>。</p><p id="b3fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将创建一个函数<code class="fe mr ms mt mu b">len()</code>，它将字符串作为参数，并返回该字符串的长度。这方面的代码是:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">绳子的长度(第一部分)</figcaption></figure><p id="83f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…是的，我们应该分解它。</p><p id="4aec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一行当然是我们讨论过的函数签名——这里的函数名是<code class="fe mr ms mt mu b">len</code>。在函数体内，我们获取当前正在执行的源文件的<code class="fe mr ms mt mu b">src_file</code>对象——这样做是为了正确地产生错误。然后，我们检查第一个参数(<code class="fe mr ms mt mu b">fd.args[1]</code>)的类型是否是string ( <code class="fe mr ms mt mu b">VT_STR</code>)。如果不是字符串，我们使用<code class="fe mr ms mt mu b">vm.fail()</code>函数显示第一个参数(<code class="fe mr ms mt mu b">fd.args[1]-&gt;idx()</code>)的位置错误，并返回<code class="fe mr ms mt mu b">nullptr</code>。</p><p id="5177" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，第一个参数不是<code class="fe mr ms mt mu b">fd.args[0]</code>，因为它是保留的。我们稍后会谈到这一点。此外，当我们返回<code class="fe mr ms mt mu b">nullptr</code>时，实际上意味着函数已经失败，Feral将在此之后停止执行。</p><p id="984e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们使用<code class="fe mr ms mt mu b">STR()</code>宏将我们的基类对象<code class="fe mr ms mt mu b">fd.args[1]</code>类型转换为<code class="fe mr ms mt mu b">var_str_t</code>类型，然后我们<code class="fe mr ms mt mu b">get()</code>包装的<code class="fe mr ms mt mu b">std::string</code>对象并使用<code class="fe mr ms mt mu b">size()</code>成员函数获取它的长度，之后，我们将该值包装到<code class="fe mr ms mt mu b">var_int_t</code>并返回它。就是这样！</p><p id="2a49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你一定注意到了，这次我们用的是<code class="fe mr ms mt mu b">make&lt;&gt;()</code>函数，而不是之前我们用的<code class="fe mr ms mt mu b">make_all&lt;&gt;()</code>。它们之间的区别在于，我们在使用<code class="fe mr ms mt mu b">make</code>函数时不设置<code class="fe mr ms mt mu b">src_id</code>和<code class="fe mr ms mt mu b">idx</code>，这正是我们想要的，因为在函数调用之后，Feral会自己设置那个值。</p><p id="3882" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们做到了！我们自己的野性功能！但是，我们也需要让Feral本身知道这个函数的存在。为此，我们将把它添加到Feral当前执行的源文件中(类似于我们之前添加变量的方式)。</p><p id="9b3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们将在<code class="fe mr ms mt mu b">INIT_MODULE</code>块中使用<code class="fe mr ms mt mu b">src</code>变量的<code class="fe mr ms mt mu b">add_native_fn()</code>成员函数。</p><p id="e4d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该函数的参数如下:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="ee40" class="ne lg it mu b gy nf ng l nh ni">1. string: the name for function which will be visible in Feral<br/>2. nativefnptr_t: the function we created in the C++ source<br/>3. int (optional): number of arguments required by the function<br/>4. bool: does the function use variadic arguments</span></pre><p id="f0e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们希望我们的<code class="fe mr ms mt mu b">len</code>函数在Feral中被调用<code class="fe mr ms mt mu b">len</code>，它采用<code class="fe mr ms mt mu b">1</code>参数并且不是可变的，函数调用如下:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="66ea" class="ne lg it mu b gy nf ng l nh ni">src-&gt;add_native_fn("len", len, 1);</span></pre><p id="42c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没错。我们完了！！我们现在可以试试我们的功能了！😁</p><p id="a27a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们再次使用<code class="fe mr ms mt mu b">feral install</code>来更新我们的模块，并在<code class="fe mr ms mt mu b">test.fer</code>中写入以下内容:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="c543" class="ne lg it mu b gy nf ng l nh ni">let <em class="nl">io</em> = import('std/io');<br/>let <em class="nl">learn</em> = import('learn');</span><span id="0b00" class="ne lg it mu b gy nm ng l nh ni">io.println(learn.len("some string"));</span></pre><p id="8f73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们运行它时，我们将看到输出<code class="fe mr ms mt mu b">11</code>，它是<code class="fe mr ms mt mu b">some string</code>的长度。耶！成功了！！🤩</p><p id="b279" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然，如果我们能做些类似… <code class="fe mr ms mt mu b">"some string".len()</code>的事情不是更好吗？就这么办吧！</p><p id="9fe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了创建一个成员函数(或者正确地说，类型绑定函数),我们需要将函数绑定到一个特定的类型(这里是<code class="fe mr ms mt mu b">VT_STR</code>)并稍微改变一下我们的函数体。</p><p id="7c54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于函数体，还记得我们保留了<code class="fe mr ms mt mu b">fd.args[0]</code>吗？实际上，这个变量包含了调用这个函数的对象。换句话说，如果我们做了<code class="fe mr ms mt mu b">"some string".len()</code>，<code class="fe mr ms mt mu b">fd.args[0]</code>就会包含<code class="fe mr ms mt mu b">"some string"</code>(同样，当我们做了<code class="fe mr ms mt mu b">learn.len()</code>，<code class="fe mr ms mt mu b">learn</code>的时候物体就被它包含了)。</p><p id="6f05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，由于这个函数将被绑定到字符串类型，我们将不必像以前那样检查参数是否是字符串！</p><p id="4f20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行这些更改后，我们的新职能变成了:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">字符串长度第2部分</figcaption></figure><p id="8aac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们还删除了<code class="fe mr ms mt mu b">src_file</code>,因为不再需要它。</p><p id="5528" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个看起来很小很可爱吧！😍</p><p id="53b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，更新<code class="fe mr ms mt mu b">INIT_MODULE</code>中的函数声明，我们用<code class="fe mr ms mt mu b">vm.add_native_typefn()</code>替换<code class="fe mr ms mt mu b">src-&gt;add_native_fn()</code>调用。该函数的参数如下:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="d921" class="ne lg it mu b gy nf ng l nh ni">1. int: type to bind the function to<br/>2. string: the name for function which will be visible in Feral<br/>3. nativefnptr_t: the function we created in the C++ source<br/>4. int: number of arguments required by the function<br/>5. size_t: the current source ID<br/>6. size_t: the current source location index</span></pre><p id="c8b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这将是一个<code class="fe mr ms mt mu b">string</code>类型的成员函数，我们不再需要为它提供任何参数。因此，参数计数现在将是<code class="fe mr ms mt mu b">0</code>，而不是之前的<code class="fe mr ms mt mu b">1</code>。因此，最后一个函数调用变成了:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="aff8" class="ne lg it mu b gy nf ng l nh ni">vm.add_native_typefn(VT_STR, "len", len, 0, src_id, idx);</span></pre><p id="15f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，使用<code class="fe mr ms mt mu b">feral install</code>安装更新的模块，并将<code class="fe mr ms mt mu b">test.fer</code>改为使用<code class="fe mr ms mt mu b">"some string".len()</code>而不是<code class="fe mr ms mt mu b">learn.len("some string")</code>。</p><p id="103c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码变为:</p><pre class="kp kq kr ks gt na mu nb nc aw nd bi"><span id="6848" class="ne lg it mu b gy nf ng l nh ni">let <em class="nl">io</em> = import('std/io');<br/>let <em class="nl">learn</em> = import('learn');</span><span id="fe44" class="ne lg it mu b gy nm ng l nh ni">io.println("some string".len());</span></pre><p id="515f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意不再需要前缀<code class="fe mr ms mt mu b">learn.</code>。</p><p id="c852" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行代码，我们将看到输出<code class="fe mr ms mt mu b">11</code>，它是<code class="fe mr ms mt mu b">some string</code>的长度。完美！！</p><p id="b866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的C++模块的完整源代码是:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">全模块源</figcaption></figure><h1 id="9863" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="3f1c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这是一篇关于如何为Feral创建C++扩展的基础文章/教程。我希望它能增长见识，引人入胜。😁</p><p id="2730" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想要更多的例子，可以查看<a class="ae le" href="https://github.com/Feral-Lang/Feral-Std" rel="noopener ugc nofollow" target="_blank"> Feral-Lang/Feral-Std </a>库(Feral的标准库)。相关链接见下一节。</p><p id="fdd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一如既往，所有的问题，想法，建议和想法都是愉快的欢迎和非常感谢。</p><p id="a666" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非常感谢你的阅读，祝你有美好的一天。下次见！❤️</p><h1 id="b16a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">链接</h1><p id="1c14" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">野性不和服务器:<a class="ae le" href="https://discord.gg/zMAjSXn" rel="noopener ugc nofollow" target="_blank">https://discord.gg/zMAjSXn</a></p><p id="1850" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">野狼(组织网址):<a class="ae le" href="https://github.com/Feral-Lang" rel="noopener ugc nofollow" target="_blank">https://github.com/Feral-Lang</a></p><p id="e244" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">野生编译器/虚拟机:<a class="ae le" href="https://github.com/Feral-Lang/Feral" rel="noopener ugc nofollow" target="_blank">https://github.com/Feral-Lang/Feral</a></p><p id="3de7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">野生Std(标准库):https://github.com/Feral-Lang/Feral-Std<a class="ae le" href="https://github.com/Feral-Lang/Feral-Std" rel="noopener ugc nofollow" target="_blank"/></p><p id="09d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">野性之书(WIP):<a class="ae le" href="https://feral-lang.github.io/Book" rel="noopener ugc nofollow" target="_blank">https://feral-lang.github.io/Book</a>(来源:<a class="ae le" href="https://github.com/Feral-Lang/Book" rel="noopener ugc nofollow" target="_blank">https://github.com/Feral-Lang/Book</a>)</p><p id="e877" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">野生HelloWorld(作者ImMaax):<a class="ae le" href="https://github.com/ImMaax/Feral-HelloWorld" rel="noopener ugc nofollow" target="_blank">https://github.com/ImMaax/Feral-HelloWorld</a></p><p id="6a20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上一篇:<a class="ae le" href="https://medium.com/@ElectruxR/the-feral-programming-language-81f87deb58cc" rel="noopener">https://medium . com/@ electr uxr/the-feral-programming-language-81 f 87 deb 58 cc</a></p></div></div>    
</body>
</html>