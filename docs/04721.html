<html>
<head>
<title>How to Manually Trigger a GitHub Actions Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何手动触发GitHub操作工作流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-manually-trigger-a-github-actions-workflow-4712542f1960?source=collection_archive---------0-----------------------#2020-07-11">https://levelup.gitconnected.com/how-to-manually-trigger-a-github-actions-workflow-4712542f1960?source=collection_archive---------0-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本周早些时候，GitHub <a class="ae kl" href="https://github.blog/changelog/2020-07-06-github-actions-manual-triggers-with-workflow_dispatch/" rel="noopener ugc nofollow" target="_blank">宣布了一个新功能</a>，它允许开发者在“动作”标签中手动触发工作流。</p><p id="a0e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一段时间以来请求最多的功能之一，随着<a class="ae kl" href="https://github.community/t/github-actions-manual-trigger-approvals/16233" rel="noopener ugc nofollow" target="_blank">官方支持线程</a>在过去的12个月里吸引了数百次投票——那么它是否实现了所有承诺？</p><p id="78b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简短的回答是肯定的，但也有一些陷阱。让我们开始吧。</p><h1 id="c9d4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">选项1:基本设置</h1><p id="d30f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">要创建您的第一个手动工作流，您需要使用新的<code class="fe lp lq lr ls b">workflow_dispatch</code>触发器:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">一个非常简单的手动工作流触发器。</figcaption></figure><p id="aa03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦您将该文件添加到您的存储库中，您将能够从GitHub上的“Actions”选项卡中查看并手动运行该工作流:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/90afafd918993fad3da9935741692c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMLrGuzK3UoR03RvyX7qiw.png"/></div></div></figure><p id="9090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还会注意到，您可以定制分支来运行您的手动工作流，但是请注意，至少<em class="ml">工作流文件的某些</em>变体必须在您的默认分支(例如<code class="fe lp lq lr ls b">master</code>)上，它才会出现在“Actions”选项卡中。</p><p id="eb51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择自定义分支将:</p><ul class=""><li id="ddff" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">签出该分支的最新提交。</li><li id="be29" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">使用分支机构自己的工作流文件变体(如果已修改)。</li></ul><h1 id="f36d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">选项2:带参数的中间设置</h1><p id="0b07" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为了更进一步，您还可以配置您的手动工作流在运行时接受变量。该功能的工作方式与<a class="ae kl" href="https://support.atlassian.com/bitbucket-cloud/docs/run-pipelines-manually/" rel="noopener ugc nofollow" target="_blank">手动位桶管道</a>非常相似。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">为您的手动工作流程设置自定义输入。</figcaption></figure><p id="78d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当单击“运行工作流”下拉菜单时，您会看到参数显示为输入文本字段:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi na"><img src="../Images/4b80c433b526a6203b806c0fd90547dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDGcBIIyCUotLPpn9Otz7g.png"/></div></div></figure><p id="90f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些输入的验证目前仅限于简单的存在检查，唯一可用的输入类型是自由文本字段(仅限字符串)。</p><h1 id="8774" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">选项3:使用Git参考的高级设置</h1><p id="17aa" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们在Ynomia使用“手动”触发器的一个用例是，当我们准备好从阶段升级特性时，开始生产部署。虽然99%的时间我们都是针对主分支上的最新代码运行的，但有时如果出现关键问题，我们需要回滚到以前版本的能力。</p><p id="6df3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一点，我们设置了一个可选字段来指定一个自定义的SHA-1提交哈希，以根据该哈希运行工作流:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">以编程方式选择要对其运行操作的提交。</figcaption></figure><p id="f8d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你会看到一个类似下图的下拉列表，你可以粘贴一个通过<code class="fe lp lq lr ls b">git log</code>等获得的完整提交散列:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi na"><img src="../Images/ef272594b293167dc0fcc6003e31ea72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uUiKeyPGjmurTrfBkLosZg.png"/></div></div></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="9683" class="km kn iq bd ko kp ni kr ks kt nj kv kw kx nk kz la lb nl ld le lf nm lh li lj bi translated">结束语</h1><p id="fe31" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">很高兴终于看到一个可行的、非黑客的选项，可以从存储库内部手动触发GitHub动作工作流。</p><p id="224f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们过去使用“打开拉式请求”作为运行昂贵的移动测试工作流的触发器，这样它们就不会在每次提交时运行。这意味着我们必须频繁地关闭和打开拉请求，以便在合并之前重新运行测试——而现在<em class="ml">和</em>我们至少可以从一个专用的用户界面启动它们。</p><p id="4625" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是它也有缺点。</p><p id="b946" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无法在标准推送工作流(像许多其他CI服务提供的那样)上定义“暂停步骤”仍然是一个令人沮丧的原因。在新的<code class="fe lp lq lr ls b">workflow_dispatch</code>触发器中，没有从其他工作流下载工件的能力，这使得情况变得更糟。以我们的生产部署为例，我们已经从以前的工作中归档了完整的构建，但是这个限制意味着我们需要再次运行我们的构建任务。哭丧着脸。你似乎也不能从手动工作流程中上传工件🤷‍♀️.</p><p id="578d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，虽然这个特性可能还没有其他CI平台强大，但是核心功能应该已经到位，可以满足大多数开发人员的需求。</p><p id="6fbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎在下面的评论中分享你自己的使用例子或经验！</p><p id="909f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐手动触发:)</p></div></div>    
</body>
</html>