<html>
<head>
<title>Lambda, Go and Local development — State of 2020 🌖</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lambda、Go和地方发展——2020年状况🌖</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lambda-go-and-local-development-state-of-2020-7e14862eeccc?source=collection_archive---------4-----------------------#2020-03-02">https://levelup.gitconnected.com/lambda-go-and-local-development-state-of-2020-7e14862eeccc?source=collection_archive---------4-----------------------#2020-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b7f7e24cea36bbdab909f71aa2e20b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQ9afXMR41T0IoZq_qPOnQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">当地开发人员的感受——照片由<a class="ae kc" href="https://unsplash.com/@davidkovalenkoo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> David Kovalenko </a>拍摄</figcaption></figure><p id="71cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎光临！我最近一直在重新评估我的AWS Lambda和Go local开发。我学到了很多，也尝试了一些不同的方法，所以我想与更广泛的社区分享。这个故事实际上是从想在本地运行我的Go Lambda函数以及AWS Cognito等集成开始的。</p><p id="6e6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的本地开发需求是:</p><ul class=""><li id="24d2" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">它需要<code class="fe lk ll lm ln b">hot reloading</code>又名<strong class="kf ir">它需要快</strong>。理想情况下，如此之快，你会认为这是常规的本地围棋开发</li><li id="12c1" class="lb lc iq kf b kg lo kk lp ko lq ks lr kw ls la lg lh li lj bi translated">来自<code class="fe lk ll lm ln b"><a class="ae kc" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank">cognito</a></code>的JWT代币需要工作。这是因为应用程序本身并不解析JWT令牌，但是APIGateway将一个<code class="fe lk ll lm ln b"><a class="ae kc" href="https://godoc.org/github.com/aws/aws-lambda-go/events#APIGatewayProxyRequest" rel="noopener ugc nofollow" target="_blank">APIGatewayProxyRequest</a></code>对象附加到请求的上下文中。这个<code class="fe lk ll lm ln b">APIGatewayProxyRequest</code>充满了重要的东西，比如<code class="fe lk ll lm ln b">claims</code>地图，它告诉我们哪个用户正在请求资源等等。</li></ul><p id="1941" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这从一开始看起来并不太难，但它具有欺骗性。</p><h2 id="ac11" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">挑战1</h2><p id="3d93" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">首先，也是最重要的，我们需要可靠地在本地运行我们的Lambda代码。我尝试和考虑的主要选项是:</p><ul class=""><li id="7659" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/dherault/serverless-offline" rel="noopener ugc nofollow" target="_blank">无服务器离线</a></li><li id="9f9b" class="lb lc iq kf b kg lo kk lp ko lq ks lr kw ls la lg lh li lj bi translated"><a class="ae kc" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank"> AWS Sam本地</a></li><li id="1e88" class="lb lc iq kf b kg lo kk lp ko lq ks lr kw ls la lg lh li lj bi translated">本地运行二进制/ <a class="ae kc" href="https://github.com/lambci/docker-lambda" rel="noopener ugc nofollow" target="_blank"> Lambda Docker包装器</a></li></ul><h1 id="266a" class="mr lu iq bd lv ms mt mu ly mv mw mx mb my mz na me nb nc nd mh ne nf ng mk nh bi translated">无服务器框架和离线插件</h1><p id="13b2" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><a class="ae kc" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>是一个非常可靠的部署工具，我在项目中使用它将我的Lambda代码部署到AWS。我对部署的过程非常满意。但是对本地开发的支持来自于一个插件<code class="fe lk ll lm ln b"><a class="ae kc" href="https://github.com/dherault/serverless-offline" rel="noopener ugc nofollow" target="_blank">serverless offline</a></code>。</p><p id="2bd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">速度</strong>💩💩:插件本身很棒，工作正常，但是它太慢了。我的简单网络服务器需要20-50秒来完成一个请求(在一台像样的2017年3.1ghz 16gb macbook pro上)。似乎每个请求都需要重建一个docker容器。不幸的是，我无法找到一种方法来安装卷，如果有一种方法，请让我知道！</p><figure class="nj nk nl nm gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/936174a96b8940ceb55de766b2229ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*fx1YkQfFJ0cBvneV3US5xw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无服务器框架，一个长请求</figcaption></figure><p id="7a74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">环境</strong>🔥:它按照预期处理<code class="fe lk ll lm ln b">cognito</code>标记👍就像真实的Lambda环境一样。</p><p id="41f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">额外工作</strong>🔥:我已经用它来部署我的lambdas，所以没有额外的yaml文件需要设置。</p><h1 id="8663" class="mr lu iq bd lv ms mt mu ly mv mw mx mb my mz na me nb nc nd mh ne nf ng mk nh bi translated">AWS Sam</h1><p id="4739" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><a class="ae kc" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank">官方AWS解决方案</a>。大约一年前，当我刚开始我的项目时，我访问过这个网站，想看看它是否符合我所有的条件。我想使用官方的解决方案，但是它没有很好地与<code class="fe lk ll lm ln b">cognito</code>集成，而且它看起来仍然过于复杂，并且仍然不支持本地的<code class="fe lk ll lm ln b">cognito</code>👎。</p><p id="be54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">速度</strong>👍山姆跑得很快。一个请求通常需要大约3秒钟。它挂载卷，从而热重装<code class="fe lk ll lm ln b">go</code>二进制文件。所以我们只需要确保构建我们的二进制文件也一样快。</p><p id="1609" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">环境</strong>👍:作为官方解决方案，我希望它能处理<code class="fe lk ll lm ln b">cognito</code>令牌。但可惜不是，所以有点屎。</p><p id="d147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">额外工作</strong>💩:首先我们需要一个额外的<code class="fe lk ll lm ln b">yaml</code>文件来声明路线。但是当您想要解析那个<code class="fe lk ll lm ln b">cognito</code>标记时，真正令人头痛的事情就开始了。这意味着需要一些应用程序代码来处理基于下面的<code class="fe lk ll lm ln b">cognito</code>标记创建正确的上下文。</p><h1 id="998a" class="mr lu iq bd lv ms mt mu ly mv mw mx mb my mz na me nb nc nd mh ne nf ng mk nh bi translated">滚动你自己的</h1><p id="23fd" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">海上人的方法，这里有几个选择。您可以使用从<a class="ae kc" href="https://github.com/lambci/docker-lambda" rel="noopener ugc nofollow" target="_blank"> docker-lambda </a>提供的docker环境。这很棒，但也是引擎盖下使用的相同图像。我看不出这有什么好处。<br/>你也可以尝试完全独立于任何框架/docker映像来运行你的<code class="fe lk ll lm ln b">go</code>函数，并省去中间人。这意味着您必须在代码中替换<code class="fe lk ll lm ln b">lambda.Start</code>，并且在本地运行时还要处理<code class="fe lk ll lm ln b">cognito</code>令牌。</p><p id="527f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/apex/gateway" rel="noopener ugc nofollow" target="_blank"> Apex网关</a>和<a class="ae kc" href="https://github.com/akrylysov/algnhsa" rel="noopener ugc nofollow" target="_blank"> algnhsa </a>都处理替换<code class="fe lk ll lm ln b">lambda.Start</code>并且你得到使用<code class="fe lk ll lm ln b">net/http</code>处理程序签名的好处，该签名与<a class="ae kc" href="https://godoc.org/github.com/aws/aws-lambda-go/lambda#Start" rel="noopener ugc nofollow" target="_blank">列表</a>中的某些内容相对应。</p><p id="baa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是您需要处理解析那个<code class="fe lk ll lm ln b">cognito</code>标记。唉，和<code class="fe lk ll lm ln b">AWS Sam</code>的情况一样，您必须编写一个中间件函数，用令牌中正确的<code class="fe lk ll lm ln b">claims</code>手动填充<code class="fe lk ll lm ln b">APIGatewayRequestProxy</code>。然后将<code class="fe lk ll lm ln b">APIGatewayRequestProxy</code>重新附加到请求上，并沿着中间件链传递。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">快速了解我如何在本地处理访问令牌</figcaption></figure><p id="e32d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管处理了问题，但它是裸的，所以速度很快。但是额外的代码和Lambda环境的缺乏并不是我们要寻找的信心助推器。<br/> <strong class="kf ir">速度🔥，环境💩，额外工作💩。</strong></p><h1 id="3591" class="mr lu iq bd lv ms mt mu ly mv mw mx mb my mz na me nb nc nd mh ne nf ng mk nh bi translated">重新编译/监视工具</h1><p id="51ea" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我还没有提到的是我们实际上是如何处理实时重载的。是一种编译语言，所以每次我们做改变时，我们都需要重新编译代码，确保我们运行的是二进制代码。我一直在寻找的工具有:</p><ul class=""><li id="236b" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/oxequa/realize" rel="noopener ugc nofollow" target="_blank">实现</a>。非常受欢迎的go task runner，可能是因为它有一个(巧妙的)网络用户界面。我发现配置过于复杂，尽管围绕做了<a class="ae kc" href="https://github.com/oxequa/realize/issues/217#issuecomment-459198990" rel="noopener ugc nofollow" target="_blank">的工作，但最后<code class="fe lk ll lm ln b">go mod</code>还是有很多问题。它在windows环境下也有</a><a class="ae kc" href="https://github.com/oxequa/realize/issues/19" rel="noopener ugc nofollow" target="_blank">问题</a>。</li><li id="e073" class="lb lc iq kf b kg lo kk lp ko lq ks lr kw ls la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/cortesi/modd" rel="noopener ugc nofollow" target="_blank"> Modd </a>。一个非常容易使用和灵活的工具。跨平台。</li><li id="de3d" class="lb lc iq kf b kg lo kk lp ko lq ks lr kw ls la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/cespare/reflex" rel="noopener ugc nofollow" target="_blank">反射</a>。另一个简单易用的工具。可能只适用于linux和mac*</li></ul><p id="88d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些工具重新编译每一个go二进制文件是一个有点棘手的过程。您会遇到大规模的问题，因为不仅需要在处理程序改变时重新编译它们，还需要像utils /数据库模型这样的支持包。</p><p id="9e06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个使用reflex的例子，它可以在任何Go文件改变时重建一切。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用reflex的makefile在github中打开以查看完整的要点和改进的buildP！</figcaption></figure><p id="308a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大约需要30秒，来建立我的20个函数。</p><p id="1f3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">改进后的<code class="fe lk ll lm ln b">make buildP</code>需要大约5秒，来构建大约20个相同的函数，但是有明显的CPU负载。</p><p id="cfe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个使用<code class="fe lk ll lm ln b">modd</code>的例子，它不太动态，但你可以在速度上弥补。它仅在处理程序发生变化时才重新构建单独的处理程序。或者当任何util/helper代码改变时，它重新构建一切。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">modd.conf最终示例—在github中打开以查看完整的要点！</figcaption></figure><p id="ebb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为这是一个很好的交易。我很乐意看到人们提出的任何其他解决方案，所以请在下面留下评论！</p><h1 id="d9fd" class="mr lu iq bd lv ms mt mu ly mv mw mx mb my mz na me nb nc nd mh ne nf ng mk nh bi translated">TLDR；服务摘要</h1><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">结果出来了</figcaption></figure><blockquote class="np nq nr"><p id="68b0" class="kd ke ns kf b kg kh ki kj kk kl km kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">看起来在2020年，它仍然会是一个工具的混搭。</p></blockquote><p id="e73a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会为了部署而放弃无服务器。他们的插件和对授权者的一流支持意味着我不能离开。但是我将使用AWS Sam在本地运行API，使用一些hackney应用程序代码，用一些重新编译脚本进行修补，以不断地根据更改进行重建！</p><p id="6a27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读，如果您有更好的解决方案，请务必告诉我！</p></div></div>    
</body>
</html>