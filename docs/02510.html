<html>
<head>
<title>JavaScript Clean Code — More Heuristics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码—更多启发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-more-heuristics-f2e490cc95ae?source=collection_archive---------7-----------------------#2020-03-18">https://levelup.gitconnected.com/javascript-clean-code-more-heuristics-f2e490cc95ae?source=collection_archive---------7-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/de2db174dd1132b1b25a09948fd3687c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xOmJ7vAZXQ95y6i9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@kylejglenn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯尔·格伦</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e1f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">糟糕的代码有很多独特的特征。在这篇文章中，我们将看看每一个和他们是什么。我们看更一般的代码味道。</p><h1 id="a56a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要武断</h1><p id="4f5e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该按照清晰的代码约定来构建我们的代码。不属于这个地方的代码不应该在那里。</p><p id="a9cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一个团队对代码库有约定，那么每个人都应该遵守。否则，很快就会变得一团糟。</p><h1 id="0bba" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">封装边界条件</h1><p id="0efc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">边界条件应该放在函数或变量中，以便于访问和理解。</p><p id="ab98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想让变量<code class="fe mh mi mj mk b">arr.length — 1</code>成为循环的结束索引变量，我们应该将它设置为如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3b1e" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3];<br/>const lastIndexOfArray = arr.length - 1;<br/>for (let i = 0; i &lt;= lastIndexOfArray; i++) {<br/>  console.log(arr[i]);<br/>}</span></pre><p id="c5e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，一旦我们把常数<code class="fe mh mi mj mk b">lastIndexOfArray</code>赋值给<code class="fe mh mi mj mk b">arr.length — 1</code>，那么我们就知道它是数组的最后一个索引。</p><p id="0d39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不再需要考虑这意味着什么。从常量名，我们知道它的意思。</p><p id="9551" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，对于其他边界情况，我们也应该这样做，这样我们就不必猜测为什么我们在不同的地方有<code class="fe mh mi mj mk b">+1</code>或<code class="fe mh mi mj mk b">-1</code>。</p><h1 id="1ca2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数应该只下降一个抽象层次</h1><p id="94a5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这意味着函数应该只做一件事。如果我们要求它在不同的抽象层次上做另一件事，那么我们应该写一个新的函数并调用它。</p><p id="e82f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为函数应该很小，应该只做一件事，所以它们不应该在不同的层次上接触不同的东西。</p><h1 id="b38c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">保持高水平的可配置数据</h1><p id="df1d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">将配置数据保持在一个较高的水平，让它们在我们的视线之内。因为我们在许多地方使用它们，所以它们处于高水平是有意义的。</p><p id="c7e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们把它们放在一个高层次上，那么它们也很容易改变。</p><h1 id="50bc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免传递导航</h1><p id="606a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该避免<code class="fe mh mi mj mk b">A</code>引用<code class="fe mh mi mj mk b">B</code>而<code class="fe mh mi mj mk b">B</code>引用<code class="fe mh mi mj mk b">C</code>的代码结构。</p><p id="9ff1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的大脑更难理解这种导航。此外，它向我们展示了更多耦合在一起的代码。</p><p id="fb69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该公开我们不想公开的代码。</p><p id="33f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，类似于:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6aff" class="mt lf it mk b gy mu mv l mw mx">foo.getBar().getBaz().doSomething();</span></pre><p id="cc5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码不好，因为我们必须用<code class="fe mh mi mj mk b">getBar</code>获得<code class="fe mh mi mj mk b">Bar</code>实例，然后用<code class="fe mh mi mj mk b">Bar</code>实例，我们必须用<code class="fe mh mi mj mk b">getBaz</code>获得<code class="fe mh mi mj mk b">Baz</code>实例。然后我们最终在<code class="fe mh mi mj mk b">Baz</code>实例上调用<code class="fe mh mi mj mk b">doSomething</code>。</p><p id="c614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是脆弱的代码，因为如果链条中的任何一点断裂，整个链条都会断裂。</p><p id="0755" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们中的任何一个改变都会成为一个问题。我们应该通过改变实现来去掉这个可传递的导航代码，这样我们就没有这种结构了。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/98a7517c307f79a6c5c018fdfd719f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_ErLmcMp4ZdRIFHb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@daniimarr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dani Marroquin </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d97d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">选择描述性名称</h1><p id="bdba" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">描述性地给事物命名很重要。名字告诉我们很多关于一段代码在做什么。因此，我们应该选择能说明它在存储什么或做什么的名字。</p><p id="e02d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像<code class="fe mh mi mj mk b">x</code>和<code class="fe mh mi mj mk b">y</code>这样的名字并不是变量的好名字，因为它们没有告诉我们关于它们存储了什么。</p><p id="29f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，<code class="fe mh mi mj mk b">numApples</code>和<code class="fe mh mi mj mk b">numOranges</code>是更好的名字，因为它们告诉我们它们在做什么。</p><h1 id="d4c2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在适当的抽象层次上选择名称</h1><p id="827e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们用名字给事物命名时，我们应该考虑代码的抽象层次。</p><p id="4fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的<code class="fe mh mi mj mk b">Phone</code>类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5f72" class="mt lf it mk b gy mu mv l mw mx">class Phone {<br/>  dial() {}<br/>}</span></pre><p id="fca7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们实际上想要表达我们正在使用它来调用另一个人时，我们对<code class="fe mh mi mj mk b">dial</code>方法的命名过于具体。</p><p id="1940" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数手机已经没有拨号功能了，所以给它们起这样的名字没有任何意义。一些手机有键盘，智能手机有屏幕。</p><p id="32a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该将其重命名为更通用的名称，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d9ef" class="mt lf it mk b gy mu mv l mw mx">class Phone {<br/>  call() {}<br/>}</span></pre><h1 id="3886" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">明确的名称</h1><p id="f3ae" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">名字不应该模棱两可。它们不应该有双重含义，让人不得不去猜测这个名字的真实含义。</p><p id="831a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">猜测是不好的，因为人们可能会得出错误的结论，并在更改代码时出错。</p><p id="c02a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想创建一个函数来重命名一个文件，我们不应该叫它<code class="fe mh mi mj mk b">rename</code>，因为它没有告诉我们我们要重命名什么。取而代之的是<code class="fe mh mi mj mk b">renameFile</code>更合适，因为我们知道这个函数是用来重命名文件的。</p><h1 id="44af" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9713" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们给事物命名时，我们应该清楚。名称应该是描述性的和明确的。</p><p id="c68f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该在正确的抽象层次上命名事物，因此应该通用的名称应该通用，反之亦然。</p><p id="173b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可传递导航也不好，因为它会创建脆弱的代码。我们不应该为了做某件事而有一系列获取不同类型对象的函数调用。</p><p id="5957" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们应该封装边界条件，以便我们清楚它是什么以及为什么我们有它。</p></div></div>    
</body>
</html>