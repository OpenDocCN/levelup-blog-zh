<html>
<head>
<title>Serverless API to API authentication🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器API到API认证🚀</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/serverless-api-to-api-authentication-d4cb4472721e?source=collection_archive---------3-----------------------#2021-08-10">https://levelup.gitconnected.com/serverless-api-to-api-authentication-d4cb4472721e?source=collection_archive---------3-----------------------#2021-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/602f27be6c23134545c8670ace3c2858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aBOkXJxJbNyiDqypjIsIHw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">肯里克·米尔斯在<a class="ae jd" href="https://unsplash.com/s/photos/stop-hand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="a8e4" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">使用OAuth2客户端凭证授权流，使用Amazon Cognito验证API到API集成的实用指南，包括代码示例和视觉效果。</h2></div><h1 id="eccc" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">介绍</h1><p id="e0bc" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在无服务器的世界中，在开发解决方案时，总会有两个或多个API需要同步地相互通信的情况。</p><p id="05ec" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">黄金标准是使用事件的完全解耦的域服务，但是在现实中，经常有一些原因需要使用REST的机器对机器风格的通信。</p><p id="add6" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这篇博文介绍了如何使用<a class="ae jd" href="https://aws.amazon.com/blogs/mobile/understanding-amazon-cognito-user-pool-oauth-2-0-grants/" rel="noopener ugc nofollow" target="_blank"> OAuth2客户端凭证授权流</a>来认证API(<em class="mo">机器</em>)而不是用户，使用<a class="ae jd" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank"> AWS Cognito </a>、<a class="ae jd" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> API网关</a>、<a class="ae jd" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>和<a class="ae jd" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>，为了便于演示，这些都托管在<a class="ae jd" href="https://lerna.js.org/" rel="noopener ugc nofollow" target="_blank"> Lerna monorepo </a>中。您可以在 这里<a class="ae jd" href="https://github.com/leegilmorecode/serverless-api-to-api-auth" rel="noopener ugc nofollow" target="_blank">查看代码回购。</a></p><p id="8dad" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们将构建以下无服务器体系结构:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mp"><img src="../Images/b56a426d239a333cd5dd87756fd867e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkGq_O0oJwXZPoYuh5aoeg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">我们正在构建的解决方案的示例架构</figcaption></figure><p id="cb9c" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jh">建筑工程如下:</strong></p><ol class=""><li id="8c0a" class="mu mv jg lp b lq mj lt mk lw mw ma mx me my mi mz na nb nc bi translated">用户调用<code class="fe nd ne nf ng b">create orders</code> POST API端点。(<em class="mo">为了便于演示，此端点没有任何身份验证</em>)</li><li id="0191" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">后端lambda然后为具有所需范围的交付API生成一个访问令牌(在这个场景中是<code class="fe nd ne nf ng b">create.delivery</code>)。</li><li id="f046" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">从AWS Cognito返回的访问令牌随后在请求的<code class="fe nd ne nf ng b">Authorization</code>报头中发送给deliveries API，即创建交付端点。</li><li id="1921" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">我们针对交付API的API网关配置将自动为我们验证令牌，即令牌是否有效、未过期、是否由正确的提供商发布、令牌上是否有针对该特定端点的正确范围等</li><li id="d56d" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">如果是一个<code class="fe nd ne nf ng b">valid</code>令牌，我们允许API Gateway调用正确的lambda。如果是<code class="fe nd ne nf ng b">invalid</code>，那么请求将被拒绝。</li></ol><blockquote class="nm nn no"><p id="2e1c" class="ln lo mo lp b lq mj kh ls lt mk kk lv np ml ly lz nq mm mc md nr mn mg mh mi ij bi translated"><em class="jg">💡</em> <strong class="lp jh"> <em class="jg">注意</em> </strong>:通常lambda会与DynamoDB之类的后端数据存储进行交互，但是我们只是将控制台输出记录到CloudWatch中以查看发生了什么，因为这个演示只是使用Cognito来显示M2M流。</p></blockquote><h2 id="28de" class="ns kw jg bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">有哪些替代方案？</h2><p id="72f7" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">根据我的经验，一些团队通常会单独使用<strong class="lp jh"> API密匙</strong>进行认证和授权，这不是一个好主意，也不是最佳实践:</p><blockquote class="nm nn no"><p id="9694" class="ln lo mo lp b lq mj kh ls lt mk kk lv np ml ly lz nq mm mc md nr mn mg mh mi ij bi translated">“不要依赖API密钥作为API认证和授权的唯一手段。首先，如果在一个使用计划中有多个API，拥有该使用计划中一个API的有效API键的用户可以访问该使用计划中的所有API。相反，使用IAM角色、<a class="ae jd" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html" rel="noopener ugc nofollow" target="_blank">Lambda授权者</a>或<a class="ae jd" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html" rel="noopener ugc nofollow" target="_blank"> Amazon Cognito用户池</a>。—<a class="ae jd" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/API gateway/latest/developer guide/API-gateway-API-usage-plans . html</a></p></blockquote><p id="bcce" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">控制对API Gateway的访问的一些其他替代方法在这里<a class="ae jd" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-to-api.html" rel="noopener ugc nofollow" target="_blank">详细介绍</a>，但是使用本文中的方法的好处是它也可以用于其他服务，如AWS AppSync，因为它是一个行业标准，也可以与Lambda Authorisers结合使用。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="f38f" class="kv kw jg bd kx ky ol la lb lc om le lf km on kn lh kp oo kq lj ks op kt ll lm bi translated">让我们开始行动吧！🚀</h1><blockquote class="nm nn no"><p id="ef51" class="ln lo mo lp b lq mj kh ls lt mk kk lv np ml ly lz nq mm mc md nr mn mg mh mi ij bi translated"><em class="jg"> 🛑 </em></p><p id="f9dd" class="ln lo mo lp b lq mj kh ls lt mk kk lv np ml ly lz nq mm mc md nr mn mg mh mi ij bi translated"><em class="jg">💡</em> <strong class="lp jh"> <em class="jg">注</em> </strong>:示例代码尚未准备好投入生产，有详细的注释来突出整体概念和架构。</p></blockquote><p id="65fe" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jh">该解决方案在一个Lerna monorepo内分为三个无服务器应用</strong>:</p><ol class=""><li id="7672" class="mu mv jg lp b lq mj lt mk lw mw ma mx me my mi mz na nb nc bi translated">🔐授权服务(<em class="mo"> AWS认知客户端、资源服务器等</em>)</li><li id="ddfc" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">🛍️订单服务API ( <em class="mo">面向公众的客户，即消费者</em>)</li><li id="5b99" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">📦交付服务API ( <em class="mo">内部资源服务器</em>)</li></ol><p id="b1e9" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们可以通过下面的步骤来部署它们。</p><h2 id="3832" class="ns kw jg bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">部署授权资源🔐</h2><p id="a27c" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在回购运行的基础上<code class="fe nd ne nf ng b">npm i</code>然后<code class="fe nd ne nf ng b">npm run bootstrap</code> ( <em class="mo">这将安装依赖项，然后引导Lerna </em></p><p id="6de6" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">完成上述步骤后，运行以下命令从<code class="fe nd ne nf ng b">./apps/auth-service</code>文件夹部署认证服务:<code class="fe nd ne nf ng b">npm run deploy:develop</code></p><p id="3fbb" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">部署完成后，为了测试如何取回访问令牌，您可以使用终端运行以下CURL命令(<em class="mo">替换占位符</em>)</p><pre class="mq mr ms mt gt oq ng or os aw ot bi"><span id="a46b" class="ns kw jg ng b gy ou ov l ow ox">curl -X POST --user &lt;client_id_here&gt;:&lt;client_secret_here&gt; 'https://serverless-auth-service-develop.auth.eu-west-1.amazoncognito.com/oauth2/token?grant_type=client_credentials&amp;scope=serverless-auth-service-develop/cancel.delivery' -H 'Content-Type: application/x-www-form-urlencoded'</span></pre><p id="9627" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">或者，您可以通过创建一个新资源来使用<a class="ae jd" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>，单击<code class="fe nd ne nf ng b">Authorization</code>选项卡，将类型更改为“<code class="fe nd ne nf ng b">OAuth 2.0</code>”，并在单击“<code class="fe nd ne nf ng b">Get New Access Token</code>”之前填写详细信息:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oy"><img src="../Images/14a59fef071085ceaf70368d0c22f2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFHvc4WPH6fKxxcGGyuHpg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">需要添加客户端ID和客户端密码的Postman屏幕示例</figcaption></figure><p id="eaf1" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果您获取返回的结果<code class="fe nd ne nf ng b">access_token</code>，您可以使用<a class="ae jd" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">https://jwt.io/</a>(<em class="mo">如下图</em>所示)查看JWT的内容</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/e5d6ab9002b73940fb27f20497c85da6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*rkRYq1whhvYghTi07_dpmA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来自AWS Cognito的解码访问令牌示例</figcaption></figure><p id="7c3b" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">正如您可以从生成的访问令牌中看到的，它具有以下内容:</p><ol class=""><li id="6d03" class="mu mv jg lp b lq mj lt mk lw mw ma mx me my mi mz na nb nc bi translated">它只有<code class="fe nd ne nf ng b">cancel.delivery</code>作用域，因为这是令牌所请求的全部内容(<em class="mo">如果您将此留空，您将获得客户端拥有的所有可用作用域</em></li><li id="6c90" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">它有一个<code class="fe nd ne nf ng b">exp</code>属性，即到期的纪元日期/时间。</li><li id="0796" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">它有一个唯一的<code class="fe nd ne nf ng b">sub</code>和<code class="fe nd ne nf ng b">client_id</code>属性，即应用程序客户端ID ( <em class="mo">即订单API </em>)</li><li id="b39a" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">在纪元日期/时间发布的<code class="fe nd ne nf ng b">iat</code>属性。</li><li id="1ae8" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">它有一个<code class="fe nd ne nf ng b">jti</code>属性，这是这个特定令牌的唯一标识符。</li><li id="d2c6" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">它有一个<code class="fe nd ne nf ng b">iss</code>属性，是颁发令牌的身份提供者，在我们的场景中是我们的AWS Cognito用户池。</li></ol><h2 id="438b" class="ns kw jg bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">部署交付API📦</h2><p id="498c" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">完成上述步骤后，从<code class="fe nd ne nf ng b">./apps/deliveries</code>目录运行以下命令来部署交付服务:<code class="fe nd ne nf ng b">npm run deploy:develop</code></p><blockquote class="nm nn no"><p id="8e84" class="ln lo mo lp b lq mj kh ls lt mk kk lv np ml ly lz nq mm mc md nr mn mg mh mi ij bi translated"><em class="jg">💡</em> <strong class="lp jh"> <em class="jg">注意</em> </strong>:在Auth Service <code class="fe nd ne nf ng b"><em class="jg">serverless.yml</em></code>中我们将用户池的arn推送到<a class="ae jd" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html" rel="noopener ugc nofollow" target="_blank">参数存储</a>这里:</p></blockquote><pre class="mq mr ms mt gt oq ng or os aw ot bi"><span id="bf03" class="ns kw jg ng b gy ou ov l ow ox"># push the value to parameter store<br/>UserPoolArnSSMParameter:<br/>   Type: AWS::SSM::Parameter<br/>   Properties:<br/>      Name: <strong class="ng jh">'/serverless-auth/${self:provider.stage}/userpool-arn'</strong><br/>      Type: String<br/>      Value:<br/>         Fn::GetAtt:<br/>            - UserPoolResource<br/>            - Arn<br/>   Description: SSM Parameter for cognito userpool arn.</span></pre><blockquote class="nm nn no"><p id="87c2" class="ln lo mo lp b lq mj kh ls lt mk kk lv np ml ly lz nq mm mc md nr mn mg mh mi ij bi translated">要在此处的交货<code class="fe nd ne nf ng b"><em class="jg">serverless.yml</em></code>堆栈中消费:</p></blockquote><pre class="mq mr ms mt gt oq ng or os aw ot bi"><span id="eef3" class="ns kw jg ng b gy ou ov l ow ox">authorizer:<br/>   # import the arn via ssm<br/>   <strong class="ng jh">arn: ${ssm:/serverless-auth/${self:provider.stage}/userpool-arn}</strong><br/>   scopes:<br/>      - serverless-auth-service-develop/create.delivery</span></pre><blockquote class="nm nn no"><p id="2d06" class="ln lo mo lp b lq mj kh ls lt mk kk lv np ml ly lz nq mm mc md nr mn mg mh mi ij bi translated">我们需要使用SSM而不是CloudFormation <a class="ae jd" href="https://aws.amazon.com/premiumsupport/knowledge-center/cloudformation-reference-resource/" rel="noopener ugc nofollow" target="_blank">跨堆栈</a>的输出和输入来实现这一点的原因是，由于API网关的底层CloudFormation，目前该<code class="fe nd ne nf ng b"><em class="jg">Authorizer</em></code>属性的无服务器框架存在一个<a class="ae jd" href="https://github.com/serverless/serverless/issues/3212#issuecomment-307341924" rel="noopener ugc nofollow" target="_blank">问题。</a></p></blockquote><h2 id="6f81" class="ns kw jg bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">获取订单API部署🛍️</h2><p id="d190" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">最后，完成上述步骤后，从<code class="fe nd ne nf ng b">./apps/orders</code>目录运行以下命令来部署订单服务:<code class="fe nd ne nf ng b">npm run deploy:develop</code></p><p id="d5df" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这是现在部署的所有相关服务！🥳</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="2a58" class="kv kw jg bd kx ky ol la lb lc om le lf km on kn lh kp oo kq lj ks op kt ll lm bi translated">端到端测试✔️</h1><p id="65fc" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在让我们对其进行端到端的测试，看看它的运行情况，并在CloudWatch中查看生成的日志。</p><p id="f616" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您可以从<code class="fe nd ne nf ng b">./postman</code>文件夹中导入Postman文件<code class="fe nd ne nf ng b">serverless-auth-service.postman_collection.json </code>，这将允许您点击创建订单端点，返回如下所示的类似响应:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pa"><img src="../Images/68a796b074e2004073c86e44bcce58dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wa7KihTIVoTsazjO-KuyQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来自创建订单端点的响应示例</figcaption></figure><p id="76fc" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在，您可以使用下面的查询，通过上面响应中的<code class="fe nd ne nf ng b">CorrelationID</code>属性，使用<a class="ae jd" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch Log Insights </a>来整理您跨两个域服务的日志(下面显示了我们的示例关联ID 的<em class="mo">结果)</em></p><pre class="mq mr ms mt gt oq ng or os aw ot bi"><span id="2c96" class="ns kw jg ng b gy ou ov l ow ox">fields <em class="mo">@timestamp</em>, <em class="mo">@message<br/></em>| filter <em class="mo">@message</em> like /a9b0f153-8cd7-4257-8ff9-34ce33678738/<br/>| sort <em class="mo">@timestamp</em> asc<br/>| limit 50</span></pre><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pb"><img src="../Images/719a7ecd70d81c2e2aa538e0a3c42f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iUVsWWmRH_eFJJGmd-e0Q.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用CloudWatch Log Insights跨多个日志组按CorrelationId查看所有呼叫</figcaption></figure><p id="d8c7" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">从上面经过整理的日志中可以看到，Orders服务生成了一个访问令牌，该令牌具有正确的作用域，允许它成功地调用内部交付服务。</p><h1 id="3332" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">缓存令牌</h1><p id="9ab0" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对于生产服务，您可能希望缓存访问令牌，而不是在每次lambda调用中一遍又一遍地生成它们(<em class="mo">特别是如果您出于安全原因将它们设置为一小时后过期</em>)。</p><p id="702d" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jh">更新</strong>:正如神奇的<a class="pc pd ep" href="https://medium.com/u/33d1209889d5?source=post_page-----d4cb4472721e--------------------------------" rel="noopener" target="_blank">辛·布里萨尔斯</a>向我指出的，访问令牌和刷新令牌的到期时间如下:</p><p id="0c29" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">"<em class="mo">访问令牌可以配置为在最短5分钟或最长24小时内过期。刷新令牌可以配置为在短至一小时内到期，长至十年后到期。</em></p><p id="3b52" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">下图显示了在没有缓存的情况下，lambdas如何不断地生成相同的访问令牌，每次只使用一次。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pe"><img src="../Images/a84e2bf8dd0c405d2e52f71daf37636c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ttT1U4HByA3fi63uafOng.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图中显示了lambdas向外扩展，每个生成一个新令牌</figcaption></figure><h2 id="84a0" class="ns kw jg bd kx nt nu dn lb nv nw dp lf lw nx ny lh ma nz oa lj me ob oc ll od bi translated">我们如何用缓存来解决这个问题？</h2><p id="1c4a" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在现实中，你可能会在一个服务中缓存令牌，例如<a class="ae jd" href="https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html" rel="noopener ugc nofollow" target="_blank">参数存储</a>，并使用<a class="ae jd" href="https://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html" rel="noopener ugc nofollow" target="_blank">应用配置Lambda层</a>将令牌自动拉入各种Lambda并缓存；如果令牌即将到期，则Lambda可以重新生成一次访问令牌，并将其推回到参数存储区，以供后续的扩展Lambda获取。(<strong class="lp jh">我将在后续文章</strong>中展示这一点)</p><p id="267d" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">其架构如下所示:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pf"><img src="../Images/44f4c96c3f3ba1d8d1a4682e5845dac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOukZtzTFTWm6yE91HGaog.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">显示使用应用配置和Lambda层存储访问令牌的图表</figcaption></figure><p id="6db4" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我在下面的博文中介绍了如何使用<a class="ae jd" href="https://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html" rel="noopener ugc nofollow" target="_blank">应用配置Lambda层</a>:</p><div class="ip iq gp gr ir pg"><a rel="noopener  ugc nofollow" target="_blank" href="/serverless-feature-flags-6e49d534e79f"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd jh gy z fp pl fr fs pm fu fw jf bi translated">无服务器功能标志🚀</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">带有lambda扩展和AppConfig的无服务器功能标志</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ix pg"/></div></div></a></div></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="fc83" class="kv kw jg bd kx ky ol la lb lc om le lf km on kn lh kp oo kq lj ks op kt ll lm bi translated">包扎</h1><p id="d5cc" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是一个超级基础的例子，展示了如何认证API到API通信的前提，但是我希望你发现它是有用的，并且是一个工作的基础！在后续文章(<em class="mo"> V2 </em>)中，我将进一步举这个例子并展示:</p><ol class=""><li id="e048" class="mu mv jg lp b lq mj lt mk lw mw ma mx me my mi mz na nb nc bi translated">用不同的方法缓存访问令牌。</li><li id="e38d" class="mu mv jg lp b lq nh lt ni lw nj ma nk me nl mi mz na nb nc bi translated">将这种方法与其他AWS服务一起使用，作为在您的解决方案中认证API的单一方式(<em class="mo">例如与AWS AppSync一起使用，使用Lambda授权器等</em></li></ol><p id="73fe" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我很乐意就以下任何一个问题与您联系:</p><p id="66ce" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/lee-james-gilmore/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/lee-james-gilmore/</a>T20】https://twitter.com/LeeJamesGilmore<a class="ae jd" href="https://twitter.com/LeeJamesGilmore" rel="noopener ugc nofollow" target="_blank">T22】</a></p><p id="6949" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你觉得这些文章鼓舞人心或有用，请随时用虚拟咖啡<a class="ae jd" href="https://www.buymeacoffee.com/leegilmore" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/leegilmore</a>来支持我，不管怎样，让我们联系和聊天吧！☕️</p><p id="5694" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你喜欢这些帖子，请关注我的简介<a class="ae jd" href="https://medium.com/u/2906c6def240?source=post_page-----39c4f4ae5aff----------------------" rel="noopener">李·詹姆斯·吉尔摩</a>以获取更多的帖子/系列，不要忘了联系并问好👋</p><p id="60e3" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果你喜欢，也请使用帖子底部的“鼓掌”功能！(<strong class="lp jh"> <em class="mo">你可以鼓掌不止一次！！</em> </strong>)</p><p id="9bcd" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jh">本文由</strong> <a class="ae jd" href="https://www.sedai.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh"> Sedai.io </strong> </a>赞助</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pv"><img src="../Images/4c77bc2d275bd557dda90aa2fe842d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJqkQYFI-KAGHOI3cHWxJQ.png"/></div></div></figure></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="6762" class="kv kw jg bd kx ky ol la lb lc om le lf km on kn lh kp oo kq lj ks op kt ll lm bi translated">关于我</h1><p id="af95" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">"<em class="mo">大家好，我是Lee，英国的AWS认证技术架构师和首席软件工程师，目前担任技术云架构师和首席无服务器开发人员，过去5年主要从事AWS上的全栈JavaScript工作。</em></p><p id="9688" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><em class="mo">我认为自己是一个热爱AWS、创新、软件架构和技术的无服务器布道者。</em></p><p id="a6ef" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jh"> **所提供的信息是我个人的观点，我对这些信息的使用不承担任何责任。*** </strong></p></div></div>    
</body>
</html>