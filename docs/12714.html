<html>
<head>
<title>Test-Driven Development in C++ With Catch2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Catch2在C++中进行测试驱动开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/test-driven-development-in-c-with-catch2-96a0bc592c9d?source=collection_archive---------18-----------------------#2022-07-03">https://levelup.gitconnected.com/test-driven-development-in-c-with-catch2-96a0bc592c9d?source=collection_archive---------18-----------------------#2022-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f196bb9ed9a648bd0ea8fb1af0b58cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dpfh8ufcrEMbgtzf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">塔尔哈·哈桑在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c3b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试驱动开发(TDD)是一个软件开发过程，其中软件需求首先被分解成一系列单元测试，然后编写软件来满足这些单元测试。例如，如果您正在创建一个API或一个返回股票市场数据(基本面和技术面数据)的API包装器，那么可以为每个测试预期API输出的端点编写测试。在编写完测试之后，API端点将被实现，直到所有的测试用例都通过。</p><blockquote class="le lf lg"><p id="ee13" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">通过<a class="ae kf" href="https://anthony-a-morast.medium.com/membership" rel="noopener">成为推荐媒介会员</a>或通过了解更多关于<a class="ae kf" href="https://amzn.to/3nBYkhC" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>或<a class="ae kf" href="https://amzn.to/3umjaoZ" rel="noopener ugc nofollow" target="_blank">有效C++编程</a>(亚马逊会员链接)来支持我的内容。</p></blockquote><p id="d8fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何软件开发的方法一样，TDD有它的优点和缺点。TDD的一些好处是</p><ul class=""><li id="8242" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated"><strong class="ki iu">软件更容易维护</strong></li></ul><p id="dc76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过编写单元测试来验证程序的正确性，可以更容易地引入对软件的修改。</p><ul class=""><li id="6361" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated"><strong class="ki iu">同样，代码重构会更加顺利</strong></li></ul><p id="5a0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，通过测试来验证正确性使得大规模生产变得不那么令人头疼了</p><ul class=""><li id="8944" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated"><strong class="ki iu">调试少</strong></li></ul><p id="ba76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当单元测试或多或少地告诉你去哪里找时，错误更容易被发现。事实上，最近在工作中，我的任务是围绕一些功能编写单元测试，只是为了清除潜在的bug。</p><ul class=""><li id="a73f" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated"><strong class="ki iu">单元测试通过描述代码应该如何工作来提供一些自我文档</strong></li></ul><p id="d065" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像所有的事情一样，好事也会带来坏事。下面列出了TDD的一些缺点。</p><ul class=""><li id="3048" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated"><strong class="ki iu"> TDD慢</strong></li></ul><p id="3f16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在能够输出任何代码之前，必须创建单元测试，这大大减慢了开发过程。如果你需要一个产品快，只需写代码。</p><ul class=""><li id="c5b9" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated"><strong class="ki iu">类似地，TDD的维护也很昂贵且充满挑战</strong></li></ul><p id="a601" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">敏捷项目管理方法告诉我们对产品所有者和客户反馈提供的产品进行迭代变更。使用TDD，这变得具有挑战性并且昂贵，因为新的单元测试可能需要随着每次迭代占用开发时间而编写。</p><ul class=""><li id="c441" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated"><strong class="ki iu">很难引入TDD </strong></li></ul><p id="cf7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有一个由一组工程师维护和开发的现有产品，那么需要一点培训和一种新的思维方式才能转移到TDD方法。这可能值得，也可能不值得。</p><p id="abca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，TDD的好处超过了坏处。当开发新软件或者在现有软件中创建可以作为一个模块进行测试的新特性时，尤其如此。这再加上C++在2022年越来越受欢迎，是这篇文章的灵感来源。在这篇文章中，我们将使用TDD在C++中构建一个简单的应用程序。单元测试框架Catch2用于测试财务API包装中的一些基本端点，并编写C++代码来满足这些测试。</p><h1 id="e77b" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">单元测试</h1><p id="db68" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">Catch2是最流行的C++单元测试框架之一。在v2.x中，Catch2是一个仅包含头文件的库，使得它很容易集成到任何C++应用程序中并在其中使用。在最近的版本中，CMake工具集是获取和使用Catch2的首选方式。为了简单起见，我将对版本2.x 使用仅包含<a class="ae kf" href="https://github.com/catchorg/Catch2/tree/v2.x" rel="noopener ugc nofollow" target="_blank">头的实现。另一个项目依赖是</a><a class="ae kf" href="https://rapidjson.org/" rel="noopener ugc nofollow" target="_blank"> RapiJSON库</a>，它允许我们在C++中使用JSON对象。你可以在我之前的文章中读到更多关于<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/parsing-json-in-c-with-rapidjson-6d6d3e505e12?source=your_stories_page-------------------------------------">使用这个库的内容。</a></p><p id="ca6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，创建一个名为Quotes.cpp的文件，用于存放从<a class="ae kf" href="https://fmpcloud.io/documentation" rel="noopener ugc nofollow" target="_blank"> FMP云API </a>获取股票、加密、外汇报价和其他数据的单元测试。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e35b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的逻辑中，Catch2和FMPCloud.hpp头包含在项目中，FMP cloud . HPP头包含未来API包装器的声明和定义。到目前为止，API类只保存返回空的<a class="ae kf" href="https://rapidjson.org/" rel="noopener ugc nofollow" target="_blank"> RapidJson </a>文档对象的虚拟函数。首先，Catch2被指示通过以下方式提供主要功能</p><blockquote class="le lf lg"><p id="dc57" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><em class="it"> #define CATCH_CONFIG_MAIN //这告诉CATCH提供一个main() —只在一个cpp文件中这样做</em></p></blockquote><p id="abd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，创建三个测试用例来测试获取股票代码的报价、一组代码、所有可用外汇汇率的报价以及所有可用加密货币的报价。类似地，还测试了确定哪些加密货币和外汇汇率可用的方法。</p><p id="0bdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在运行这些测试显示它们都失败了:</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e19f77fc20ba58d7b09448543c5d5780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/0*tZvs4lq91yYnC8kH.png"/></div></figure><p id="6dd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，下一步是开发C++类，直到这些测试用例通过。</p><h1 id="f704" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">C++类</h1><p id="8319" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">下面的代码片段显示了类声明</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2e86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个类的细节对于这篇文章来说并不重要。重要的是我们获取可用的公共函数，实现它们，并确保它们满足上面的单元测试。为此，我们需要实现<em class="lh">_ to command delimited</em>、<em class="lh"> _downloadAndGetJsonFile </em>、<em class="lh"> _generateFilename </em>、<em class="lh"> _return </em>和<em class="lh"> get* </em>方法。在实现这些方法之后，可以表明测试用例是令人满意的。</p><h1 id="2100" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">助手功能</h1><p id="6eec" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">前面提到的前缀为' _ '的函数是帮助函数，负责所有API端点使用的公共操作。为了简洁起见，因为类的实现不是本文的重点，所以我不会实现这些函数，但会提供简短的描述(实现将在以后的文章中介绍)。</p><ul class=""><li id="ea15" class="ll lm it ki b kj kk kn ko kr ln kv lo kz lp ld lq lr ls lt bi translated">_<em class="lh">to commame delimited</em>:这个函数获取一个字符串向量，并返回一个包含所有向量元素的字符串，所有向量元素用逗号分隔。</li><li id="f27a" class="ll lm it ki b kj ne kn nf kr ng kv nh kz ni ld lq lr ls lt bi translated"><em class="lh">_ downloadanddgetjsonfile</em>:解析来自FMP云API的，通过cURL下载，保存为JSON文件，读入字符串，然后文件被删除，这个helper函数执行这些操作。</li><li id="5f03" class="ll lm it ki b kj ne kn nf kr ng kv nh kz ni ld lq lr ls lt bi translated"><em class="lh"> _generateFilename </em>:生成带时间戳的文件名。</li><li id="6ff7" class="ll lm it ki b kj ne kn nf kr ng kv nh kz ni ld lq lr ls lt bi translated"><em class="lh"> _return </em>:返回一个RapidJSON文档对象，提供一个包含JSON数据的字符串。</li></ul><p id="bf93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这些助手函数，API包装器可以轻松实现。</p><figure class="mx my mz na gt ju"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="7345" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">满足单元测试</h1><p id="8234" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">给定单元测试套件、类声明和成员函数定义，下一步是通过单元测试套件验证API包装的功能。</p><p id="1203" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重新构建并重新运行单元测试表明所有条件都得到了满足。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/1b3f3dc24b4126d614761ffccd1ed04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/0*PNAbBChA7lMRpu5v.png"/></div></figure><h1 id="92b0" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">向前移动</h1><p id="44ac" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">从这里开始，遵循TDD实践，开发人员将确定应用程序中还需要什么功能(在这种情况下是API包装),并创建更多的Catch2测试用例。最初，这些测试会失败，直到将功能添加到应用程序实现中。单元测试将在实现就绪后运行，直到软件的正确性得到验证。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="3c43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">原载于2022年7月3日https://www.anthonymorast.com</em><em class="lh">T21</em><a class="ae kf" href="https://www.anthonymorast.com/blog/2022/07/03/test-driven-development-in-c-with-catch2/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>