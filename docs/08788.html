<html>
<head>
<title>Concurrency Control For Dummies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">虚拟对象的并发控制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/concurrency-control-for-dummies-49c15305827b?source=collection_archive---------4-----------------------#2021-06-05">https://levelup.gitconnected.com/concurrency-control-for-dummies-49c15305827b?source=collection_archive---------4-----------------------#2021-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="6c79" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">一件可能出错的事情和一件不可能出错的事情之间的主要区别在于，当一件不可能出错的事情出错时，它通常是不可能得到和修复的。</p><p id="634b" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae kp" href="https://www.brainyquote.com/authors/douglas-adams-quotes" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">——道格拉斯·亚当斯</strong> </a></p></blockquote><p id="7647" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">还记得和你经理的那次谈话吗？当他要求你提高服务质量时，你回答说“嘿！我们可以在其中添加并行性”？</p><p id="d03b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">所以，你开始朝它努力，你将性能提高了5倍，测试用例通过了，你发布了你的变更。您觉得自己已经掌握了提高系统性能的艺术。几天后，你所谓的改进服务产生了一个错误的输出，你只是忽略了它，说这是一个暂时的问题，不会再发生了。但它确实会一次又一次周期性地发生，现在你只是在代码中上下徘徊寻找bug，抓耳挠腮。你想知道这一切是从哪里开始的。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><blockquote class="jn jo jp"><p id="e1d8" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><strong class="jt ir">“我们可以加上排比。”</strong></p></blockquote><p id="812a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">不管这一行看起来多么无关痛痒，都不要掉入陷阱。作为开发人员，我们的首要责任是让代码按预期工作。我们不能不惜任何代价来换取工作的正确性，即使是以业绩为代价。那么，我们是否应该永远不使用并行。如果操作正确，系统中的并行性可以创造奇迹，将资源利用率提高到极致，并明显带来更好的性能。但请记住，只有做得正确。在这篇文章中，我的目标是提供一些启发，可以帮助您理解与并发性相关的常见问题以及它为什么如此重要。</p><p id="00ac" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这篇文章主要是关于Java中的并发控制。但是，如果您想从总体上了解并发性，这是一本很好的读物。如果你想知道为什么JavaScript是单线程语言，为什么你只能在Android的主线程中更新UI组件，我们将会深入探讨。</p><h1 id="b98c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">常见陷阱</h1><p id="19d8" class="pw-post-body-paragraph jq jr iq jt b ju ly jw jx jy lz ka kb kq ma ke kf kr mb ki kj ks mc km kn ko ij bi translated">并发控制是一个宽泛的概念，不可能在一篇文章中涵盖。我将尝试列出一些最常见的模式，如果不小心的话，它们会导致系统中的主要并发错误。这将帮助你培养一种意识，在任何代码库中找出问题。</p><ul class=""><li id="f909" class="md me iq jt b ju jv jy jz kq mf kr mg ks mh ko mi mj mk ml bi translated"><strong class="jt ir">比较和设置</strong></li></ul><p id="dd91" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">你会发现在你的代码中有很多例子，你只是简单地比较一些变量，如果某些条件成立，就改变相同的或其他的变量值。就像如果购物车没有满，然后添加一个项目，如果用户名是唯一的，然后分配用户名，如果座位没有预订，然后分配给请求用户。让我们看一个创建单例类的简单例子，这是在整个系统中创建共享服务的一个非常常见的设计模式。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8d09" class="mv lb iq mr b gy mw mx l my mz">public class SharedService {<br/>    <br/>    private SharedService instance;</span><span id="0196" class="mv lb iq mr b gy na mx l my mz">    public SharedService createInstance() {</span><span id="712d" class="mv lb iq mr b gy na mx l my mz">        if (instance == null) {<br/>            instance = new SharedService();<br/>        }<br/>        return instance;<br/>    }<br/>}</span></pre><p id="b35e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">比较:如果实例为空，则不创建SharedService实例</p><p id="b91c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">Set: Instance为新创建的SharedService</p><p id="9f7a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你的系统是单线程的，上面的代码会很好的工作，但事实可能不是这样，所以会发生很多错误。</p><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nb"><img src="../Images/3545550365fd857694a7f638e31e9bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OC6lVfap2hCFLcu_TuUkYw.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated"><strong class="bd lc">不幸的时间线</strong></figcaption></figure><p id="8049" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">线程1和线程2的操作交错进行，由于“不走运的时间安排”,它们都为SharedService创建了不同的实例，这违反了我们的单例模式。Singleton示例可能看起来很无聊，但是用一个用户的购物车列表(一个用户有两个购物车列表)替换SharedService，一个用户名分配给两个用户。上面的操作时间线只是交错线程操作的简化版本，如果我们考虑寄存器级别或机器代码级别的操作，它将更加复杂和危险。</p><ul class=""><li id="5122" class="md me iq jt b ju jv jy jz kq mf kr mg ks mh ko mi mj mk ml bi translated"><strong class="jt ir">读-修改-写</strong></li></ul><p id="d4be" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">另一种常见的模式是读取-修改-写入循环，您从传感器读取数据，转换它以生成危险级别值，并存储它(因此一些安全系统可以读取它并采取行动)或简单的计数器。</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="5873" class="mv lb iq mr b gy mw mx l my mz">public class SimpleCounter {</span><span id="9954" class="mv lb iq mr b gy na mx l my mz">    private int counter = 0;</span><span id="03c8" class="mv lb iq mr b gy na mx l my mz">    public void incrementCounter() {<br/>        counter++;<br/>    }<br/>}</span></pre><p id="3e4b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">如果你争论的话，count++不可能在这里产生“不幸的时机”问题，对吗？</p><p id="075f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">++操作不是原子操作，它的机器级代码如下所示:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="40ec" class="mv lb iq mr b gy mw mx l my mz">LD R0, COUNTER             // R0 = COUNTER  -&gt; Read<br/>ADD R0, R0, 1              // R0 = R0 + 1   -&gt; Modify<br/>ST COUNTER, R0             // COUNTER = R0  -&gt; Write</span></pre><figure class="mm mn mo mp gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nn"><img src="../Images/e84ffb6acf0520d977a9f299abdaff5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-QzcvdGNu4KX-CPc6-Kmg.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">不幸的时机</figcaption></figure><p id="aace" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">假设COUNTER的初始值为27(当时)，两个线程1和2进行增量运算。从程序员的意图来看，两次运算后的最终结果应该是29，但由于一些“不走运的时机”，最终结果是28。</p><p id="0609" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">当对象被多线程并行读/写时，有许多这样的模式是系统中并发错误的根本原因。这种访问/修改模式中真正问题可以列举如下:</p><ol class=""><li id="3a0d" class="md me iq jt b ju jv jy jz kq mf kr mg ks mh ko no mj mk ml bi translated">对象的状态发布</li><li id="a312" class="md me iq jt b ju np jy nq kq nr kr ns ks nt ko no mj mk ml bi translated">状态不变量</li><li id="f703" class="md me iq jt b ju np jy nq kq nr kr ns ks nt ko no mj mk ml bi translated">非原子操作</li></ol><h2 id="7d9e" class="mv lb iq bd lc nu nv dn lg nw nx dp lk kq ny nz lo kr oa ob ls ks oc od lw oe bi translated">国家出版物</h2><p id="ae77" class="pw-post-body-paragraph jq jr iq jt b ju ly jw jx jy lz ka kb kq ma ke kf kr mb ki kj ks mc km kn ko ij bi translated">对象的状态由其变量或其变量的状态来定义。举个例子，</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="12d2" class="mv lb iq mr b gy mw mx l my mz">public ShoppingCart{</span><span id="82a1" class="mv lb iq mr b gy na mx l my mz">   Long totalItems;<br/>   Long totalCartPrice;<br/>   List&lt;Item&gt; cartItemList;</span><span id="9823" class="mv lb iq mr b gy na mx l my mz">}</span></pre><p id="6856" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在这里，我们可以说ShoppingCart状态是由totalItems、totalCartPrice的值以及cartitem list(cartitem list的状态)中的每一项定义的。</p><p id="b398" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">状态发布只是允许其他对象访问/修改对象的状态。像在SimpleCounter示例中一样，允许多个线程改变SimpleCounter(即计数器)的状态。</p><h2 id="36a2" class="mv lb iq bd lc nu nv dn lg nw nx dp lk kq ny nz lo kr oa ob ls ks oc od lw oe bi translated"><strong class="ak">状态不变量</strong></h2><p id="0eb1" class="pw-post-body-paragraph jq jr iq jt b ju ly jw jx jy lz ka kb kq ma ke kf kr mb ki kj ks mc km kn ko ij bi translated">随着程序的进行，对象的状态会发生变化，更多的商品会被添加到购物车列表中。但是它们是物体禁止的状态。例如，计数器不可能是负的。下面是状态不变量的几个例子:</p><ol class=""><li id="7931" class="md me iq jt b ju jv jy jz kq mf kr mg ks mh ko no mj mk ml bi translated">totalItems必须等于cartItemList中的项目数</li><li id="22b8" class="md me iq jt b ju np jy nq kq nr kr ns ks nt ko no mj mk ml bi translated">每个用户的用户名必须是唯一的</li><li id="5936" class="md me iq jt b ju np jy nq kq nr kr ns ks nt ko no mj mk ml bi translated">计数器值不能为负</li><li id="e5a5" class="md me iq jt b ju np jy nq kq nr kr ns ks nt ko no mj mk ml bi translated">交易后，发送方和接收方账户余额之和应相同</li></ol><p id="04b5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">作为开发人员，我们必须确保如果对象的状态发生转变，它必须保持这些不变量。大多数并发错误都源于违反这种状态不变量，两个线程同时试图在cartItemList中添加项目，并且由于不幸的计时totalItems不等于cartItemList中的实际项目数。</p><h2 id="8620" class="mv lb iq bd lc nu nv dn lg nw nx dp lk kq ny nz lo kr oa ob ls ks oc od lw oe bi translated">非原子操作</h2><p id="bccf" class="pw-post-body-paragraph jq jr iq jt b ju ly jw jx jy lz ka kb kq ma ke kf kr mb ki kj ks mc km kn ko ij bi translated">我们的incrementCounter函数之所以不起作用，是因为count++操作不是原子的。对于一个原子操作，只有转换前或转换后的状态对外界存在，中间没有挂起状态。这意味着在SimpleCounter中，线程2不应该在线程1执行操作时读取值27。</p><h1 id="abaa" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如何控制并发</h1><h2 id="b61e" class="mv lb iq bd lc nu nv dn lg nw nx dp lk kq ny nz lo kr oa ob ls ks oc od lw oe bi translated">封装，封装，封装</h2><p id="4483" class="pw-post-body-paragraph jq jr iq jt b ju ly jw jx jy lz ka kb kq ma ke kf kr mb ki kj ks mc km kn ko ij bi translated">知道对象状态被完美地封装，限制对象状态可以被改变的范围(理想的是从类的公共函数开始)。但是对象封装并不是将变量声明为私有的，而是提供公共的Getter-Setter。这不是封装的含义，例如:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="312c" class="mv lb iq mr b gy mw mx l my mz">public List&lt;Item&gt; getShoppingCartList(){<br/>    <br/>     return this.cartItemList;</span><span id="46b3" class="mv lb iq mr b gy na mx l my mz">}</span></pre><p id="351e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">初看起来，getShoppingCartList函数似乎完美地封装了cartItemList变量，但客户端在获得对List的引用后，可能会尝试更改它或添加更多的项，或者List中的Item对象本身是可变的。</p><p id="0123" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">不完美，更好的选择是返回列表的克隆</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="03da" class="mv lb iq mr b gy mw mx l my mz">public List&lt;ImmutableItem&gt; getShoppingCartList(){<br/>    <br/>      List&lt;ImmutableItem&gt; cartListClone = new ArrayList();<br/>      for( Item i : this.cartItemList ){<br/>            cartListClone.add( createImmutableItem( i ) );<br/>      }<br/>      return cartListClone;<br/>}</span></pre><h2 id="354e" class="mv lb iq bd lc nu nv dn lg nw nx dp lk kq ny nz lo kr oa ob ls ks oc od lw oe bi translated">不可变对象</h2><p id="36d7" class="pw-post-body-paragraph jq jr iq jt b ju ly jw jx jy lz ka kb kq ma ke kf kr mb ki kj ks mc km kn ko ij bi translated">不可变对象是那些状态不能改变的对象。示例:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="59ec" class="mv lb iq mr b gy mw mx l my mz">public class Point{</span><span id="692a" class="mv lb iq mr b gy na mx l my mz">     private int x, y;<br/>     public point( int x, int y ){<br/>         this.x = x;<br/>         this.y = y;<br/>     }<br/>     public getX(){ return this.x; }<br/>     public getY(){ return this.y; }<br/>}</span></pre><p id="7dce" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">点是不可变的，因为在创建点对象之后，我们不能改变它的状态，如果对象的状态没有改变，那么它怎么会导致并发错误。</p><h2 id="cbd9" class="mv lb iq bd lc nu nv dn lg nw nx dp lk kq ny nz lo kr oa ob ls ks oc od lw oe bi translated">线程限制</h2><p id="33a4" class="pw-post-body-paragraph jq jr iq jt b ju ly jw jx jy lz ka kb kq ma ke kf kr mb ki kj ks mc km kn ko ij bi translated">当多个线程试图修改一个对象的状态时，许多并发错误就会出现。但是如果我们只允许一个线程改变对象的状态呢？这并不意味着创建一个单线程系统，而是只允许单线程改变对象的状态，而其他操作仍然可以并行工作。您会在许多地方发现线程限制的概念，</p><ol class=""><li id="df09" class="md me iq jt b ju jv jy jz kq mf kr mg ks mh ko no mj mk ml bi translated">演员模型</li><li id="ae2a" class="md me iq jt b ju np jy nq kq nr kr ns ks nt ko no mj mk ml bi translated">用于与UI组件交互的Android主线程</li><li id="b75e" class="md me iq jt b ju np jy nq kq nr kr ns ks nt ko no mj mk ml bi translated">Java Swing</li><li id="d561" class="md me iq jt b ju np jy nq kq nr kr ns ks nt ko no mj mk ml bi translated">JavaScript单线程执行</li></ol><h2 id="ac07" class="mv lb iq bd lc nu nv dn lg nw nx dp lk kq ny nz lo kr oa ob ls ks oc od lw oe bi translated">锁</h2><p id="950c" class="pw-post-body-paragraph jq jr iq jt b ju ly jw jx jy lz ka kb kq ma ke kf kr mb ki kj ks mc km kn ko ij bi translated">像Java这样的语言为构建健壮的并发程序提供了对象锁定机制。这些锁可以充当看门人的角色，只允许一个线程进入一个代码块，并帮助创建原子操作。为了使incrementCounter操作原子化，我们可以使用锁定，例如:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="2787" class="mv lb iq mr b gy mw mx l my mz">public class SimpleCounter {</span><span id="0a57" class="mv lb iq mr b gy na mx l my mz">     private int counter = 0;</span><span id="8540" class="mv lb iq mr b gy na mx l my mz">     synchronized public void incrementCounter() {<br/>        counter++;<br/>    }<br/>}</span></pre><p id="1a84" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">仅仅通过添加一个关键字synchronized，我们就使我们的函数原子化了。</p><p id="232b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">关于并发性，肯定还有很多内容需要介绍，但我想这是一个很好的起点。</p><p id="c675" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">谢了。</p></div></div>    
</body>
</html>