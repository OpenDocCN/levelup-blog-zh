<html>
<head>
<title>Pushing Typescript to the Extremes: The Most Advanced Typescript I’ve Ever Had to Write</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将打字稿推向极端:我写过的最高级的打字稿</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pushing-typescript-to-the-extremes-the-most-advanced-typescript-ive-ever-had-to-write-7e47bc070697?source=collection_archive---------1-----------------------#2021-06-14">https://levelup.gitconnected.com/pushing-typescript-to-the-extremes-the-most-advanced-typescript-ive-ever-had-to-write-7e47bc070697?source=collection_archive---------1-----------------------#2021-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb4dad25923542a545ceddc391180eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsUddAAv-4RByqDyt0lwYg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">打字稿。一只美丽的野兽</figcaption></figure><p id="4cab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我写代码时，我不是为了完成工作而写，也不是为了自己<em class="ld"/>而写。我是为下一个读或写它的人写的。</p><p id="6810" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于大多数专业编写代码的人来说，编写可编译的代码并不难，同样，编写<em class="ld">bug</em>也不难。前者是应该的，但是要努力限制未来开发者写bug的能力<em class="ld"> </em>。</p><p id="f3e8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这就是为什么当我写代码时，我努力争取编译时安全:我希望你的IDE在你的测试之前告诉你“这不行”——或者更糟，在你的生产环境之前。这就是为什么我像许多开发人员一样，更喜欢Typescript而不是Javascript——我们希望我们的IDE尽可能地验证我们的代码是正确的。</p><p id="8a65" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">备注:</strong></p><ul class=""><li id="f12e" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">为了清楚起见，这里的大部分代码都被剥离/编辑了。我实际上没有一个接受字段<code class="fe ln lo lp lq b">otherField</code>的API。</li><li id="5ee6" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">如果你已经知道这一切，恭喜你！你比我做这个之前聪明多了。</li><li id="b516" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">如果你发现我在某个地方打错了，不要犹豫，留下评论！我会尽快修理它。</li><li id="6739" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">如果你想跳过整个旅程，在最后的“关键外卖部分”。</li><li id="8845" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">虽然我在亚马逊工作，但这些都不是亚马逊说的，不是关于我在亚马逊的工作，也不是代表亚马逊说的。</li></ul><h1 id="acb3" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">打字稿</h1><p id="54a1" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">我们已经确定，我在寻找“不可能破解”的代码(只要我们真诚地行动):这就是为什么当我看到<em class="ld">这个，</em>我知道必须做出改变。</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="13ca" class="nh lx it lq b gy ni nj l nk nl">interface IReqBody {<br/>    username: string<br/>    otherField: string<br/>}</span><span id="4223" class="nh lx it lq b gy nm nj l nk nl">const myApiRouteHandler = (req: Request): Response =&gt; {<br/>    const myReqBody = req.body as IReqBody</span><span id="d352" class="nh lx it lq b gy nm nj l nk nl">    ...<br/>}</span></pre><p id="09a8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里最大的问题是我们没有对<code class="fe ln lo lp lq b">req.body</code>进行验证。我们只是…相信客户发送的数据是正确的。如果我们的信任被破坏，客户端不会得到“400:错误请求”，他们会得到“500:试图在未定义上调用fn”或类似的东西。</p><p id="523d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这对客户端没有帮助——他们会认为服务器做错了什么(从技术上来说，服务器<em class="ld">做错了什么——它没有验证输入，但我的意思是“做错了什么”,比如“代码中有逻辑错误”,但事实并非如此)。</em></p><p id="30d5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么我们能做些什么来修复它呢？我们希望验证主体，如果格式不正确，就抛出400。我们想写一个这样的函数:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="99e1" class="nh lx it lq b gy ni nj l nk nl">const validateBody&lt;T&gt; = (body: T): body is T =&gt; {<br/>   ...<br/>}</span></pre><p id="8818" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我在这条路上的第一次旅程引导我找到了这样一个函数，它有一些问题:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="b3ae" class="nh lx it lq b gy ni nj l nk nl">interface IReqBody {<br/>    username: string<br/>    otherField: string<br/>}</span><span id="187b" class="nh lx it lq b gy nm nj l nk nl">const validateBody = (body: unknown): body is IReqBody =&gt; {<br/>  const bodyAsReq = body as IReqBody<br/>    if (<br/>      bodyAsReq.username === undefined || <br/>      bodyAsReq.otherField === undefined<br/>    ) {<br/>      throw HttpError(500)<br/>    }<br/>  return true<br/>}</span></pre><p id="47d5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里有两个问题:</p><ol class=""><li id="a02d" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc nn lk ll lm bi translated">还记得我们讨论过写代码时人们不能破解代码吗？如果一周后，我们决定需要在<code class="fe ln lo lp lq b">IReqBody</code>中添加另一个字段，会发生什么呢？添加字段的人必须记得检查它是否在验证器中未定义。这是一个容易被忽略的错误。我们希望我们的编译器说“嘿！您忘记验证该字段了！”</li><li id="23bc" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc nn lk ll lm bi translated">我们必须为每一条路线重复这个代码。有很多重复的功能。</li></ol><p id="05ca" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">要解决问题2，您可能会想“让它通用一点！”。如果那是你，你就说对了一半。TypeScript有类型擦除的概念，这意味着在运行时，所有的接口都消失了——它们只是在编译时存在，所以你不能迭代通过接口的字段(但那不是很好吗！).</p><p id="32d1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不过，我们能做的是遍历对象的字段。</p><p id="d99b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以让我们试试这样的东西:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="43ae" class="nh lx it lq b gy ni nj l nk nl">const validateBody&lt;T&gt; = (body: unknown, verifier: T): body is T =&gt; {<br/>   const validKeys = Object.keys(verifier)<br/>   const inputKeys = new Set(Object.keys(body))</span><span id="e0d4" class="nh lx it lq b gy nm nj l nk nl">   for (const validKeys of validKey) {</span><span id="8809" class="nh lx it lq b gy nm nj l nk nl">       // if we're missing the key, return false<br/>       if (inputKeys.has(validKey)) {<br/>           return false<br/>       } else {<br/>           inputKeys.delete(validKey)<br/>       }</span><span id="3261" class="nh lx it lq b gy nm nj l nk nl">       // if the types are different, return false<br/>       if (typeof verifier[validKey] !== typeof body[validKey]) {<br/>          return false <br/>       }<br/>      <br/>       //if it's an object, recurse and if it's false return false<br/>       if (typeof verifier[validKey] === 'object' &amp;&amp; !validateBody(body[validKey], verifier[validKey]) {<br/>          return false<br/>       }<br/>  }<br/>  <br/>  //for strictness, if there's extra fields return false (optional)<br/>   if (inputKeys.length() &gt; 0) { <br/>    return false<br/>   }<br/>  <br/>  return true<br/>  }</span></pre><p id="5b1a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对此进行分解，我们遍历所有的键并比较类型。如果它们都是对象，我们可以在子类型上递归，该子类型的所有键都将被验证。</p><p id="7f88" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">其中<code class="fe ln lo lp lq b">verifier</code>是我们<em class="ld">知道</em>是正确的<code class="fe ln lo lp lq b">T</code>的版本。呼叫看起来像这样:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="dfaf" class="nh lx it lq b gy ni nj l nk nl">const myApiRouteHandler = (req: Request): Response =&gt; {<br/>    const body = req.body<br/>    <br/>    if (!validateBody(body, {<br/>       username: "mockstr",<br/>       otherField: "mockstr",<br/>      }) {<br/>         throw HttpError(500)<br/>     }</span><span id="0761" class="nh lx it lq b gy nm nj l nk nl">    ...<br/>  }</span></pre><p id="91db" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">厉害！我们都受到了约束！我们是编译时安全的:向req添加一个字段，这里会出现一个错误，说validateBody的第二个参数不正确。</p><p id="7fc6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">唉，我们还没完，我还不开心。</p><p id="7534" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这适用于基本类型:字符串、布尔、对象、数字…如果我们想要验证一个枚举值，会发生什么？例如，一个字符串只能有<code class="fe ln lo lp lq b">['hi', 'bye']</code>中的值？或者，更有可能的是，如果字段可以不定义会发生什么？或者我们想在空字符串上失败？</p><h2 id="5d89" class="nh lx it bd ly no np dn mc nq nr dp mg kq ns nt mk ku nu nv mo ky nw nx ms ny bi translated">二:高级部分</h2><p id="0c51" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated">到目前为止，我们做了一些简单的东西:类型保护、泛型和基本的TS。</p><p id="e3dc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们想变得疯狂一点。</p><p id="221b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设我们有一个抽象类，<code class="fe ln lo lp lq b">BaseValidator</code>:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="c170" class="nh lx it lq b gy ni nj l nk nl">abstract class BaseValidator&lt;T&gt; {<br/>    validate(input: unknown): boolean<br/>}</span></pre><p id="93f8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这太棒了！我们现在可以扩展它，并在必要时进行验证。例如，具有可空性的字符串验证器:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="faa9" class="nh lx it lq b gy ni nj l nk nl">abstract class StringValidator extends BaseValidator&lt;string&gt; {<br/>  nullable: boolean</span><span id="8ea7" class="nh lx it lq b gy nm nj l nk nl">  constructor(nullable: boolean) {<br/>     this.nullable = nullable</span><span id="1d14" class="nh lx it lq b gy nm nj l nk nl">   validate(input: unknown): boolean {<br/>      if (input === undefined) {<br/>         return nullable<br/>      } <br/>      return typeof input === "string"<br/>   }<br/>}</span></pre><p id="9efa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以尽情发挥，验证许多东西。我们可以有<code class="fe ln lo lp lq b">EmailValidator</code>、<code class="fe ln lo lp lq b">AgeValidator</code>、<code class="fe ln lo lp lq b">integerValidator</code>、<code class="fe ln lo lp lq b">EnumValidator</code>等。(你可以为所有的原语做泛型<code class="fe ln lo lp lq b">TypeValidator</code>，但是记住类型擦除，但是这可以通过传递给构造函数的一个空值很容易地解决)我承认这也可能是一大堆样板文件(你多久在你的API中接收一次电子邮件？)但这总比不验证或者在你记得验证的地方漫不经心地做好。</p><p id="b699" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是什么会成为我们<code class="fe ln lo lp lq b">validateBody</code>的验证者呢？我们不能再拿<code class="fe ln lo lp lq b">T</code>，因为下面不再是<code class="fe ln lo lp lq b">T</code>:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="6498" class="nh lx it lq b gy ni nj l nk nl">const notT = {<br/>   username: new UsernameValidator(),<br/>   otherField: new StringValidator()<br/>}</span></pre><p id="b72b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以我们需要编写一个通用类型，它接受任何其他类型，并返回用<code class="fe ln lo lp lq b">BaseValidator&lt;TypeOfTheFieldOfTheOriginalValue&gt;</code>包装的每个字段。更详细地说，如果原始接口需要一个<code class="fe ln lo lp lq b">string</code>，我们不想给它一个<code class="fe ln lo lp lq b">BaseValidator&lt;number&gt;</code>类型的验证器。</p><p id="c4f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，让我们定义一个有效的文章主体<em class="ld">甚至</em> <em class="ld">是什么样子的:</em></p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="c262" class="nh lx it lq b gy ni nj l nk nl">type IJsonArray = Array&lt;<br/> string         | <br/> number         | <br/> boolean        | <br/> Date           | <br/> IValidPostBody | <br/> IJsonArray<br/> &gt;</span><span id="8725" class="nh lx it lq b gy nm nj l nk nl">export interface IValidPostBody {<br/> [x: string]: <br/>  string         | <br/>  number         | <br/>  boolean        | <br/>  Date           | <br/>  IValidPostBody | <br/>  IJsonArray<br/>}</span></pre><p id="5ea5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个有效的JSON是一个由字符串索引的对象，可以是:一个原语、另一个JSON或者原语或JSON的数组。</p><p id="c27f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么我们将如何定义包装类型呢？第一次拍摄可能是这样的:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="7101" class="nh lx it lq b gy ni nj l nk nl">export type IOptionsForFields&lt;T&gt; = {<br/>   [key in keyof T]: FieldOption&lt;T[key]&gt;<br/>}</span></pre><p id="65d4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">简而言之，这意味着对于<code class="fe ln lo lp lq b">T</code>中的每个键，我们需要给出一个fieldOption，它采用的类型是<code class="fe ln lo lp lq b">T[key]</code>。</p><p id="1cb5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第一个问题是子jsons！</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="e103" class="nh lx it lq b gy ni nj l nk nl">//an interface like this...<br/>interface MyInterface {<br/>   foo: string<br/>   bar: {<br/>      baz: boolean<br/>   }<br/> }</span><span id="82ba" class="nh lx it lq b gy nm nj l nk nl"><br/>//would turn into this! No good!<br/>const t: IOptionsForFields&lt;MyInterface&gt;  = {<br/> foo: new FieldValidator&lt;string&gt;,<br/> bar: new FieldValidator&lt;{ baz: boolean }&gt;<br/>}</span></pre><p id="28f6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不知何故，我们需要让<code class="fe ln lo lp lq b">IOptionsForFields</code>也是递归的。</p><p id="8e3f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">进入条件类型的魔力！我们可以说，如果一个类型扩展了IValidPostBody(也就是说，是一个有效的post主体)，那么我们希望递归该类型。否则，我们要合适的<code class="fe ln lo lp lq b">fieldValidator</code>。</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="8e52" class="nh lx it lq b gy ni nj l nk nl">export type IOptionsForFields&lt;T&gt; = {<br/>  [key in keyof T]: <br/>    T[key] extends IValidPostBody ? <br/>        IOptionsForFields&lt;T[key]&gt; : <br/>        FieldOption&lt;T[key]&gt;<br/>}</span></pre><p id="0cd2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就这样，我们的包装工作了！</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="a19c" class="nh lx it lq b gy ni nj l nk nl">const t: IOptionsForFields&lt;MyInterface&gt;  = {<br/> foo: new FieldValidator&lt;string&gt;(),<br/> bar: {<br/>    baz: new FieldValidator&lt;boolean&gt;(),<br/> }</span></pre><p id="cdab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不过，还有最后一个问题需要解决。如果我们创建一个这样的新界面:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="778a" class="nh lx it lq b gy ni nj l nk nl">interface IOmittable {<br/>   omittable?: string<br/>}</span></pre><p id="e133" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后这个飞起来:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="0bce" class="nh lx it lq b gy ni nj l nk nl">const t: IOptionsForFields&lt;IOmittable&gt; {}</span></pre><p id="ffe8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这可不好。我们希望它作为一个可省略的字符串进行验证，但是您希望实现这个验证器。所以我们需要给<code class="fe ln lo lp lq b">IOptionsForFields</code>界面增加一些魔力:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="ecd8" class="nh lx it lq b gy ni nj l nk nl">export type IOptionsForFields&lt;T&gt; = {<br/>  [key in keyof T]-?: <br/>    T[key] extends IValidPostBody ? <br/>        IOptionsForFields&lt;T[key]&gt; : <br/>        FieldOption&lt;T[key]&gt;<br/>}</span></pre><p id="b881" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我不会让你在这里指出不同之处:在<code class="fe ln lo lp lq b">[key in key T]</code>之后，还有一个<code class="fe ln lo lp lq b">-?</code>。这就意味着:现在，所有可省略的字段都是必需的！</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="9751" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最终的函数如下所示:</p><pre class="mz na nb nc gt nd lq ne nf aw ng bi"><span id="b5fd" class="nh lx it lq b gy ni nj l nk nl">export const baseValidator = &lt;T extends IValidPostBody&gt;(<br/>   options: IOptionsForFields&lt;T&gt;, input: Record&lt;string, unknown&gt;<br/>): boolean =&gt; {<br/>  const validKeys = Object.keys(options)<br/>  const inputKeys = new Set(Object.keys(input))<br/>   <br/>  for (const validKey of validKeys) {<br/>     const optionsOfKey = options[validKey]<br/>     if (!inputKeys.delete(validKey)) {<br/>       return false<br/>     }</span><span id="22d3" class="nh lx it lq b gy nm nj l nk nl">    if (optionsOfKey instanceof FieldOption) {<br/>       if (optionsOfKey.validate(input[validKey])) {<br/>          continue<br/>       } else {<br/>         return false<br/>       }<br/>    }</span><span id="9ae9" class="nh lx it lq b gy nm nj l nk nl">    if (!baseValidator(</span><span id="2eae" class="nh lx it lq b gy nm nj l nk nl">     // whatever typescript cast is required here, I am not smart  enough to figure it out. I know that this type is a IOptionsForFields, because it can either be that or a fieldOption, which was already caught in the previous block. This means that this is verifably correct. I can't seem to tell the typechecker that though. </span><span id="d76f" class="nh lx it lq b gy nm nj l nk nl">         options[validKey] as any,<br/>         input[validKey] as Record&lt;string, unknown&gt;<br/>     )) {<br/>       return false<br/>     }<br/>   }<br/>  return true<br/> }</span></pre></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h2 id="4a91" class="nh lx it bd ly no np dn mc nq nr dp mg kq ns nt mk ku nu nv mo ky nw nx ms ny bi translated">关键要点</h2><p id="6b96" class="pw-post-body-paragraph kf kg it kh b ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky my la lb lc im bi translated"><strong class="kh iu">打字稿要点:</strong></p><ul class=""><li id="bdcb" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated"><code class="fe ln lo lp lq b">-?</code>是<code class="fe ln lo lp lq b">?</code>的反义词——它只是一般的暗示，因此较少被看到。</li><li id="28ed" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">您可以编写一个类型，它接受另一个类型，并使用<code class="fe ln lo lp lq b">key in keyof T</code>为它的所有键做一些事情。</li><li id="bd46" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">三元运算符也适用于类型！</li><li id="3215" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">类型可以是递归的。</li><li id="bb8f" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated"><code class="fe ln lo lp lq b">T[key]</code>表示该键将在<code class="fe ln lo lp lq b">T</code>中获得的值的类型。</li><li id="ca4d" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">包装器类型很有用！</li></ul><p id="1b0c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">其他外卖:</strong></p><ul class=""><li id="15a6" class="le lf it kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">你很可能迟早会发现问题:我建议你早点发现它们。编译时安全。</li><li id="6711" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">为下一个需要它的人写程序，为下一个阅读它的人写代码。</li><li id="0c02" class="le lf it kh b ki lr km ls kq lt ku lu ky lv lc lj lk ll lm bi translated">编写代码并不困难。编写bug也不难。让写bug变得困难。</li></ul><p id="c155" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">感谢阅读！</p></div></div>    
</body>
</html>