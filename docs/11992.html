<html>
<head>
<title>Basic Guide to Semantic Release</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">语义发布基本指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/basic-guide-to-semantic-release-9e2aa7834e4b?source=collection_archive---------1-----------------------#2022-05-06">https://levelup.gitconnected.com/basic-guide-to-semantic-release-9e2aa7834e4b?source=collection_archive---------1-----------------------#2022-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/530c22dff1ddc7d683ad160f07c6f4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8OsJ7yDy3GRxh0JV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹金</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当涉及到将软件项目发布到产品中时，版本控制是一个很容易被忽视的话题，因为它太琐碎了，并且是手工完成的。我们如何确定下一个版本号？应该是主版本(v1到v2)还是次版本(1.1到1.2)？<a class="ae kc" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>是软件开发人员用来自动管理我们代码版本的软件模式。</p><p id="64b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语义发布遵循<strong class="kf ir"> v{Major}{Minor}{Patch} </strong>的标准<a class="ae kc" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>格式，例如<em class="lb"> v1.2.3 </em>。因此，当您在项目上运行语义发布时，语义发布将有助于确保创建的所有版本都将严格遵守语义版本化，这样您就不能跳跃版本(v1到v3)或向后移动(v2.1到v2.0)。语义版本化的一些基本准则如下:</p><p id="bde2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。版本发布后不做任何修改</p><p id="dcd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。任何改变都必须是新的版本</p><p id="2e36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。版本号只能上升</p><p id="65f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。{补丁} →向后兼容的错误修复</p><p id="994c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。{Minor} →新的向后兼容特性，公共api的弃用</p><p id="51f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。{Major} →新的向后不兼容api</p><p id="a3a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。{Major} = 0 →任何事情都可能改变时的初始开发</p><p id="448f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。{Major} &gt;= 1 →第一个公共稳定版本</p><p id="2e54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。预发布版本→例如1.0.0-alpha，1.0.0之前的1.0.0-beta</p><h1 id="109d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">语义发布是如何工作的？</h1><p id="0c88" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">语义发布是在NodeJS中开发的，但它可以在任何代码基础上使用，例如java、kotlin、c#、golang等。为什么？因为它并不完全是我们代码的一部分(除了配置之外)，但是语义发布是在我们的持续集成(CI)环境中使用和安装的(例如GitHub、GitLab等)。当我们的代码库中有任何代码更改(推送、合并等)时，语义发布会运行以确定是否需要新版本，如果需要，它将为其创建一个<a class="ae kc" href="https://www.atlassian.com/git/tutorials/inspecting-a-repository/git-tag" rel="noopener ugc nofollow" target="_blank"> git标签</a>，并在我们的git中发布一个发布版本。</p><p id="e0ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么它如何知道是否需要新版本呢？这是由我们提交代码时的提交消息决定的。因此，为了正确使用语义发布，开发人员在提交时需要遵循某些常规的提交消息格式。默认情况下，语义发布遵循<a class="ae kc" href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-format" rel="noopener ugc nofollow" target="_blank">角度提交消息约定</a>。一些基本准则如下:</p><p id="c0a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。提交标头格式:(范围):</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6066" class="mo ld iq mk b gy mp mq l mr ms">. Type and Short summary are mandatory</span><span id="5524" class="mo ld iq mk b gy mt mq l mr ms">. Type: **fix**, **feat**, perf, ci, build, docs, refactor</span><span id="f231" class="mo ld iq mk b gy mt mq l mr ms">. Scope: affected package</span></pre><p id="5f65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。使用命令式现在时。例如“修复”而不是“修复”或“已修复”</p><p id="f94c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。第一个字母不要大写</p><p id="126b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。没有”在句子的结尾</p><p id="9cc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">。提交页脚格式(如有必要)</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8fd3" class="mo ld iq mk b gy mp mq l mr ms">. **BREAKING CHANGE**: &lt;Summary of breaking change&gt; &lt;blank line&gt; &lt;description if any&gt;</span><span id="22b2" class="mo ld iq mk b gy mt mq l mr ms">. DEPRECATED: &lt;What is deprecated&gt; &lt;blank line&gt; &lt;description if any&gt;</span></pre><p id="cab4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确定版本号最常见的方法是使用<code class="fe mu mv mw mk b">fix</code>和<code class="fe mu mv mw mk b">feat</code>提交头类型。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/bd8a5933334981a6c8ee62b305d4495f.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*4FDhMj8NGPTSS5rAKEtGgA.png"/></div></figure><p id="3a68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上表中可以看出，如果您的提交消息中有一个<code class="fe mu mv mw mk b">fix: xxx</code>或<code class="fe mu mv mw mk b">fix(scope): xxx</code>，当语义发布运行时，它将创建一个补丁版本。所以如果当前版本是2.1.0，那么发布版本将是2.1.1。同样，如果你有一个<code class="fe mu mv mw mk b">feat: xxx</code>消息，下一个发布版本将是2.2.0。</p><p id="d77f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在内部，当执行语义发布时，有9个步骤要依次执行，如下所示:</p><ol class=""><li id="3383" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">验证条件</li><li id="3854" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">分析提交</li><li id="a495" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">验证发布</li><li id="0484" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">生成注释</li><li id="45ed" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">准备</li><li id="a85e" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">出版</li><li id="ef4e" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">添加通道</li><li id="5ade" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">成功</li><li id="e697" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">失败</li></ol><p id="fcfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些步骤由插件执行，插件是可以实现上述一个或多个步骤的其他npm模块。默认情况下，只有4个插件与语义发布一起提供。这4个插件和它们实现的步骤如下:</p><ol class=""><li id="9902" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">@ semantic-release/commit-analyzer—分析提交</li><li id="9850" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">@ semantic-release/release-notes-generator-generate notes</li><li id="d15b" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">@semantic-release/npm —验证条件、准备、发布</li><li id="2ef7" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">@semantic-release/github —验证条件、发布、成功、失败</li></ol><p id="26b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，并不是所有的9个步骤都实现了。如果没有实现，则跳过该步骤。只有analyzeCommits步骤是必需的，其余步骤都是可选的。在每个步骤中，语义发布将运行每个定义的插件，只要插件实现了该步骤。我们可以在配置文件中定义运行什么插件来进行语义发布。这个配置文件通常是主项目文件夹中以json或yaml格式编写的<code class="fe mu mv mw mk b">.releaserc</code>文件。官方和社区插件列表可在<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/extending/plugins-list" rel="noopener ugc nofollow" target="_blank">https://semantic-release . git book . io/semantic-release/extending/plugins-list</a>上获得。有关格式和其他可用配置的更多信息，请访问<a class="ae kc" href="https://semantic-release.gitbook.io/semantic-release/usage/configuration" rel="noopener ugc nofollow" target="_blank">https://semantic-release . git book . io/semantic-release/usage/configuration</a>。需要注意的一点是，为了运行非默认插件，您将需要<code class="fe mu mv mw mk b">npm install</code>CI文件中的插件，以及在这个配置文件中指定插件。下一节中的例子将演示通过在GitHub动作中安装<code class="fe mu mv mw mk b">@semantic-release/git</code>和<code class="fe mu mv mw mk b">@semantic-release/changelog</code>插件。</p><h1 id="6fc5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">用GitHub动作演示Java项目的语义发布</h1><p id="f157" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">要开始在GitHub上托管的java项目上进行语义发布，第一步是启用GitHub操作。点击github项目页面中的<code class="fe mu mv mw mk b">Actions</code>标签，会出现各种模板供你选择。语义发布文档在<a class="ae kc" href="https://github.com/semantic-release/semantic-release/blob/master/docs/recipes/github-actions.md" rel="noopener ugc nofollow" target="_blank">https://github . com/semantic-Release/semantic-Release/blob/master/docs/recipes/github-actions . MD</a>上也有一个可用的模板，但它更适用于nodejs项目，因为它使用默认的npm插件，该插件会将项目发布到npm。对于一个java项目，典型的工作流如下:</p><ol class=""><li id="de0c" class="my mz iq kf b kg kh kk kl ko na ks nb kw nc la nd ne nf ng bi translated">签出源代码—操作/签出@v2</li><li id="c8c2" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">设置Java-操作/设置-java@v2</li><li id="2f11" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">设置节点—操作/设置节点@v2</li><li id="50b9" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">构建/测试java代码</li><li id="b19d" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">运行npm install来安装语义发布和您需要的任何插件</li><li id="9d5c" class="my mz iq kf b kg nh kk ni ko nj ks nk kw nl la nd ne nf ng bi translated">运行语义发布</li></ol><p id="b9e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们仍然需要在VM中安装nodejs，因为语义发布将从npx命令中运行。一个非常基本的github动作工作流脚本是这样的</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8cfb" class="mo ld iq mk b gy mp mq l mr ms">name: Release</span><span id="8f40" class="mo ld iq mk b gy mt mq l mr ms">on:<br/>  push:<br/>    branches: [ master ]<br/>  pull_request:<br/>    branches: [ master ]</span><span id="4f1b" class="mo ld iq mk b gy mt mq l mr ms">env:<br/>  GH_TOKEN: ${{ secrets.GH_TOKEN }}</span><span id="839f" class="mo ld iq mk b gy mt mq l mr ms">jobs:<br/>  release:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>    - uses: actions/checkout@v2<br/>    - name: Set up JDK 11<br/>      uses: actions/setup-java@v2<br/>      with:<br/>        java-version: '11'<br/>        distribution: 'adopt'<br/>        cache: maven<br/>    - name: Setup Node.js<br/>      uses: actions/setup-node@v2<br/>      with:<br/>        node-version: 'lts/*'<br/>    - name: Build with Maven<br/>      run: mvn -B package --file pom.xml<br/>    - name: setup semantic-release<br/>      run: npm install -g semantic-release @semantic-release/git @semantic-release/changelog -D<br/>    - name: release<br/>      run: npx semantic-release</span></pre><p id="4fda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查代码并安装java和node，我们只是使用<a class="ae kc" href="https://github.com/marketplace?category=&amp;query=&amp;type=actions&amp;verification=" rel="noopener ugc nofollow" target="_blank"> github marketplace </a>上可用的模板，然后我们只是使用shell脚本运行<code class="fe mu mv mw mk b">mvn package</code>来打包我们的代码。如果这是成功的，意味着项目中的所有测试都通过了，那么它将进入下一步，安装语义发布和带有<code class="fe mu mv mw mk b">npm install</code>的插件。注意，除了semantic-release，我们还在这里安装了另外两个插件。最后，我们用<code class="fe mu mv mw mk b">npx semantic-release</code>运行语义发布。</p><p id="949a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们已经将此工作流配置为只在主分支中运行，只要有推送或拉取请求。我们还设置了名为<code class="fe mu mv mw mk b">GH_TOKEN</code>的环境变量，该值链接到当前github项目中定义的一个秘密。这个<code class="fe mu mv mw mk b">GH_TOKEN</code>是<a class="ae kc" href="https://github.com/semantic-release/github" rel="noopener ugc nofollow" target="_blank"> github语义发布插件</a>需要的一个变量，我们将用它在github中发布发布。基本上，为了执行所需的git动作，插件需要被认证。所以在这种情况下，我们需要在github项目的<code class="fe mu mv mw mk b">Settings -&gt; Secrets</code>中创建一个名为<code class="fe mu mv mw mk b">GH_TOKEN</code>的变量，这样它是安全的，当任何人克隆项目时都不会被下载。</p><p id="e673" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GitHub Action会在你在master分支提交这个文件后自动运行这个工作流，它会失败。错误信息可能是<code class="fe mu mv mw mk b">ENOPKG Missing package.json file</code>。这是默认<code class="fe mu mv mw mk b">@semantic-release/npm</code>插件中<code class="fe mu mv mw mk b">verifyConditions</code>步骤的失败。因为我们没有运行nodejs项目，所以我们没有package.json，我们也不打算使用npm插件将包发布到npm。所以我们需要创建一个<code class="fe mu mv mw mk b">.releaserc</code>文件来覆盖默认插件。下面是一个例子:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="b425" class="mo ld iq mk b gy mp mq l mr ms">{<br/>  "branches": "master",<br/>  "repositoryUrl": "https://github.com/thecodinganalyst/semantic-java",<br/>  "debug": "false",<br/>  "plugins": [<br/>    "@semantic-release/commit-analyzer",<br/>    "@semantic-release/release-notes-generator",<br/>    [<br/>      "@semantic-release/changelog",<br/>      {<br/>        "changelogFile": "CHANGELOG.md",<br/>        "changelogTitle": "# Semantic Versioning Changelog"<br/>      }<br/>    ],<br/>    [<br/>      "@semantic-release/git",<br/>      {<br/>        "assets": ["CHANGELOG.md"]<br/>      }<br/>    ],<br/>    [<br/>      "@semantic-release/github",<br/>      {<br/>        "assets": [<br/>          {<br/>            "path": "release/**"<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  ]<br/>}</span></pre><p id="12db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们移除了npm插件，并引入了另外两个插件— <code class="fe mu mv mw mk b">changelog</code>和<code class="fe mu mv mw mk b">git</code>。<code class="fe mu mv mw mk b">changelog</code>将有助于在每次发布时在我们的项目文件夹中创建和维护一个<code class="fe mu mv mw mk b">CHANGELOG.md</code>。<code class="fe mu mv mw mk b">git</code>然后会在发布中包含CHANGELOG.md。提交该文件后，工作流将再次运行，这一次它将成功。</p><p id="e291" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://github.com/thecodinganalyst/semantic-java." rel="noopener ugc nofollow" target="_blank">https://github.com/thecodinganalyst/semantic-java.</a>有一个运行在github action上的带有语义发布的工作java项目的示例报告</p><p id="9da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">本文原载于</em><a class="ae kc" href="https://thecodinganalyst.github.io/knowledgebase/Basic-guide-to-Semantic-Release/" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://the coding analyst . github . io/knowledge base/Basic-guide-to-Semantic-Release/</em></a><em class="lb">。</em></p></div></div>    
</body>
</html>