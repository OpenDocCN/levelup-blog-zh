<html>
<head>
<title>REST and the future of APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST和API的未来</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rest-and-the-future-of-apis-ef9cf4e1706b?source=collection_archive---------0-----------------------#2021-12-26">https://levelup.gitconnected.com/rest-and-the-future-of-apis-ef9cf4e1706b?source=collection_archive---------0-----------------------#2021-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d1f796b135f746befd942e5f63a652de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYbDW7MkY3caVSfUmus6kg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">gRPC徽标(<a class="ae kc" href="https://grpc.io" rel="noopener ugc nofollow" target="_blank"> https://grpc.io </a> ) —只是众多消息协议中的一种</figcaption></figure><p id="7fab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当有人开始谈论web服务和API时，您最终会讨论是使用REST还是一些新技术。让我先声明一下，我并不认为使用REST有什么本质上的不好。这是一个很好的规范，充分利用了现有的HTTP技术，实现符合该规范的客户机和服务器非常简单，并且允许很大的灵活性。</p><p id="6581" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，同样的“现有HTTP技术”非常陈旧，不一定能很好地适应现代用例。此外，该规范并没有真正定义如何实现REST服务的规则，所以你可以有三个不同的API，它们都使用REST，但不遵循相同的“标准”。</p><p id="451b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道我在这篇文章的顶部有一个gRPC标志的图像，但我不是gRPC的死忠粉。我觉得很管用，我觉得有它的用武之地，很扎实的推荐。它也是CNCF的一部分，在我看来这是一个伟大的里程碑，在许多基于容器的框架中有很多对gRPC的内置支持，比如那些运行在Kubernetes上的框架。但不一定是API的未来。</p><p id="9c36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时你可能会想，“如果不是REST或gRPC，那是什么？”我认为这取决于你们互动的目标是什么。对我来说，除非有充分的理由，否则我总是会考虑四种解决方案:REST、JSON-RPC、gRPC和GraphQL。</p><h1 id="abf6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们快点休息吧</h1><p id="fa7b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不管别人说什么，休息仍然是坚实的。但它肯定是面向基于浏览器的客户端的。如果您使用几乎任何非REST解决方案，您要么会丢失一些内置于web浏览器中的有价值的功能，要么需要编写大量的JavaScript代码来适应变通方法。</p><p id="3d7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，为特定页面添加书签。例如，如果你建立了一个电子商务网站，你试图用JSON-RPC使它成为一个PWA或别的什么东西，你需要考虑到人们可能想要给一个特定的产品加书签。他们可以做到这一点的唯一方法是产品页面可以用一个唯一的URL(包括查询参数)来表示。</p><p id="3c5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">REST从一开始就将这一切构建到系统中，因为它脱离了浏览网页的标准方式。你<em class="me">可以</em>用JSON-RPC解决方案做到这一点，但是这需要更多的代码，潜在的更多错误，最终不值得付出额外的努力(在我看来)。</p><p id="6112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，如果web浏览器是web应用程序的主要或者唯一的客户端目标，那么应该首先考虑REST。关于REST替代方案的大讨论应该留给不使用web浏览器作为主要客户端的API或其他系统。</p><p id="ed0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意</strong>:在有意义的地方混合搭配解决方案是完全可以接受的。在同一个应用程序中使用REST和GraphQL。或者对web服务器使用REST，对单独的后端服务使用gRPC。您不必认为您构建的每个服务都应该使用单一的协议/规范。挑选两三个可能有利于确保每种<em class="me">类型的服务使用最适合它的解决方案。</em></p><h1 id="3199" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据与功能</h1><p id="c73d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我不构建网站并且需要REST之外的东西时，我喜欢回答的一个大问题是:我将主要呈现复杂的数据负载还是我将需要与我的后端系统进行大量的交互？</p><p id="8c06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再次以电子商务网站为例。假设您使用REST作为基础来服务网站的大部分内容。但是，您还需要查询相关产品、评论或其他附加数据，这些数据没有产品描述、价格等重要。由于您主要需要的是<em class="me">数据</em>，除了添加评论或者将产品添加到购物车之外，不太可能有太多的交互，您可能希望使用GraphQL来异步加载所有这些额外的数据。</p><p id="0937" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL肯定是一个普遍流行的选择，如果您主要处理数据的呈现，尤其是复杂的数据关系，那么它很有意义。客户可以很容易地请求<em class="me">精确地</em>他们想要的每个查询的属性和相关数据。</p><p id="bf3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您试图使用REST甚至任何RPC选项来实现这一点，您需要添加头或函数参数来包含/排除哪些属性、相关模型等。客户想要的每一个电话。或者，每次想要显著改变响应负载时，都需要创建一个新函数。</p><p id="7344" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果你有类似客户支持聊天服务的东西，那么交互将是你的主要目标，GraphQL在这些情况下就没那么有用了。现在，实际上一个聊天服务会使用一个定制的二进制协议，并使用web sockets或其他东西，但gRPC和JSON-RPC和那些都可以很好地工作，仍然可以通过web sockets完成。</p><p id="dd8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在这些频繁执行操作的情况下，并且您正在调用需要到达后端服务器的状态更改，RPC选项是可行的方法。在这种情况下，您的问题就变成了是否需要这些RPC消息的模式。</p><p id="d337" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">gRPC使用协议缓冲区，所以您创建一个protobuf模式，其中包含您的客户端可以使用的所有请求和响应消息，然后gRPC处理这些消息的打包，适当地路由它，并将其转换为后端的函数调用。gRPC也是Kubernetes工具和框架的流行选择，如Istio，所以如果您在Kubernetes集群中运行，那么您绝对应该将gRPC放在考虑列表的首位。</p><p id="3234" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JSON-RPC是无模式的，所以您遵循约定而不是配置来进行调用。这样做的好处是允许函数签名以较低的开销进行更改，或者允许松散类型的参数，而无需任何特别的努力。但是这样您就错过了诸如客户端和服务器消息验证之类的事情，确保被调用的函数是服务器允许的，并且参数的正确数量及其类型与签名匹配。</p><h1 id="0ded" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">流程图</h1><p id="2df3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">REST、gRPC、GraphQL和JSON-RPC之外还有很多解决方案。就我个人而言，这些只是目前流行的。我通常会问几个核心问题，以了解我应该调查通信协议/规范的哪一类,然后我会查看这些类别中最多的类别，并寻找它们的直接替代方案。如果我找不到任何既能充分满足我们的技术需求，又能适应我们的业务需求和现有工作流的替代方案，那么我会选择该类别中最丰富的方案。</p><p id="7ed1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我制作了这个简单的图表来帮助你根据你的需求和我在这篇文章中讨论的内容来确定你应该关注的网络交流的<em class="me">类别</em>。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/d0bb007e7e762b1d78ec408f83b9c031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2jzcXJfo1AC6XbTbLFiZw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">便捷的网络通信流程图</figcaption></figure><p id="9977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从本质上来说，交付可以轻松加入书签、使用web链接导航等的网页。，您的客户端主要——或者唯一——web浏览器应该继续使用REST。</p><p id="d620" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以数据为中心的客户端，即大多数客户端专注于显示数据关系的客户端，应该使用GraphQL。GraphQL肯定有竞争对手，但老实说，我认为在这一点上，它是以数据为中心的客户端事实上的选择。大量的支持，很多人知道它，大量的集成选项…它实际上是这个类别的黄金标准。</p><p id="cf0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以API为中心的服务，即那些调用函数和修改状态的服务，以及更有可能异步或通过非浏览器客户端(如移动应用程序、其他后端服务)进行通信的服务，应该考虑使用RPC选项，如gRPC或JSON-RPC。如果需要一个模式，看看gRPC和它的直接替代方案。如果schema是可选的，那么包括JSON-RPC及其直接替代方案。</p><p id="23f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你专门在Kubernetes上运行多种服务，我强烈建议考虑gRPC。它是CNCF的一部分，许多Kubernetes工具和框架都支持gRPC。看起来gRPC将成为更复杂的Kubernetes部署中服务间通信的实际手段。</p><h1 id="87b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="24f8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">就我个人而言，我会坚持使用REST来开发网站——也就是说，一种将网络浏览器作为其主要或唯一客户目标的服务——并可能在适当的时候混合使用GraphQL。重复前面的例子，您可能有一个产品页面，当页面第一次加载时，它会填充所有主要内容，但是您也可以使用GraphQL加载相关的产品、评论或任何数量的其他非即时必要的信息。</p><p id="8681" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的服务主要有非浏览器客户端，尤其是如果您正在进行服务对服务的通信，REST肯定没什么用处。最好使用通过TCP连接处理的二进制协议，或者有一个单一的端点向其发出RPC请求。在这些情况下，我会考虑gRPC或类似的产品。</p><p id="f7b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有一个高度交互的基于web的应用程序，你应该看看web sockets，考虑一个与后端服务通信的非REST方法。使用web sockets肯定可以使用gRPC、JSON-RPC，甚至GraphQL，所以不要认为web sockets需要一套完全不同的解决方案。</p><p id="cfae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您最终在后端服务器和客户端之间实现了高度的双向通信，那么考虑定制二进制协议也是一个好主意。例如，如果您要使用Erlang或Elixir，有一个名为<em class="me"> BERT </em>的二进制消息格式，它有一个足够简单的规范，可以在现有库不可用的情况下在您的客户机中实现。使用BERT编码的二进制负载可以使用内置函数解码成后端代码中的本机对象，反之亦然:本机对象可以使用内置函数编码成BERT。然后，您只需将有效负载推过web socket连接，就大功告成了。</p><p id="bc58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你没有一个好的理由，我不会推荐一个定制的二进制协议。但是这样做也没有错。例如，您可以在不使用gRPC的情况下使用protobuf消息，这对于特定的用例可能更有意义。请随意追求能够为您的特定问题提供最佳解决方案的技术。</p></div></div>    
</body>
</html>