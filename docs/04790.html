<html>
<head>
<title>Setting up mTLS and Kestrel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设置mTLS和Kestrel</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/setting-up-mtls-and-kestrel-a4f8b146a32e?source=collection_archive---------10-----------------------#2020-07-15">https://levelup.gitconnected.com/setting-up-mtls-and-kestrel-a4f8b146a32e?source=collection_archive---------10-----------------------#2020-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e27a8d7cfc5ee8657f3d4dd844abf584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TTZRK7xh0ptgUOU9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@mmayyer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马科斯·迈尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1a18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数人都知道TLS是什么，但是mTLS呢？和TLS有什么不同，是用来做什么的？</p><h1 id="b3cb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">坦克激光瞄准镜（Tank Laser-Sight的缩写）</h1><p id="d012" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TLS，即传输层安全性，是SSL的后继者；这两者都是安全通信的手段。TLS有几个版本，每个后续版本都更安全、更易于使用，或者两者兼而有之。我们已经升级到TLS v1.3版了。</p><p id="1dd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里阅读更多关于TLS <a class="ae kf" href="https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="c955" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TLS的基本思想是保护多方之间的通信，当你访问像这样的网站时，你可能非常习惯于“看到”它。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/ec56a5f5a6803b36aee2d974f84828ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6hM99VIhbhlVe2qS.PNG"/></div></div></figure><p id="f4ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当连接到一个网站时，有很多“魔法”在进行，以客户端和服务器之间来回的形式。我发布的链接对此进行了更详细的描述，但是我们也可以很容易地使用cURL命令看到其中的一些内容。</p><p id="88df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将使用一个测试web api项目，我将从以下内容开始:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d0f7" class="mr lf it mn b gy ms mt l mu mv">mkdir Kritner.Mtls<br/>cd Kritner.Mtls<br/>dotnet new webapi</span></pre><p id="c623" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在用<code class="fe mw mx my mn b">dotnet run</code>运行项目，并向默认的WeatherForecast控制器提交cURL命令:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f8a6" class="mr lf it mn b gy ms mt l mu mv">curl --insecure -v https://localhost:5001/weatherForecast</span></pre><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5d7f81b04810b2a24e3a6322eb77d6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q-3-zhMQIhgm_ykG.PNG"/></div></div></figure><p id="a56e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会注意到，在上面的内容中，我们在cURL命令中使用了<code class="fe mw mx my mn b">--insecure</code>标志，因为我们通过web api使用“开发”证书来建立安全连接。</p><h1 id="e0a2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">mTLS</h1><p id="f4d1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">既然我们已经对TLS及其外观有了很高的认识，那么什么是mTLS呢？</p><p id="9a30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自维基百科:</p><blockquote class="na nb nc"><p id="0d38" class="kg kh nd ki b kj kk kl km kn ko kp kq ne ks kt ku nf kw kx ky ng la lb lc ld im bi translated"><em class="it">相互认证或双向认证是指双方同时对彼此进行认证，在一些协议(IKE、SSH)中是默认的认证方式，在另一些协议(TLS)中是可选的。<br/>默认情况下，TLS协议仅使用X.509证书向客户端证明服务器的身份，客户端向服务器的认证由应用层负责。TLS还使用客户端X.509身份验证提供客户端到服务器的身份验证。[1]由于它需要向客户端提供证书，并且用户体验不太友好，因此很少在最终用户应用程序中使用。<br/>双向TLS认证(mTLS)在企业对企业(B2B)应用中更为普遍，在这种应用中，有限数量的编程式同构客户端连接到特定的web服务，运营负担有限，并且与消费者环境相比，安全性要求通常更高。</em></p></blockquote><p id="d891" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面有相当多的信息，但我认为tdlr是:</p><ul class=""><li id="6b7c" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">双方通过某种方式提供他们的身份</li><li id="7d08" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">通常用于企业对企业的应用</li></ul><p id="b1a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着可以通过我们的系统生成供用户使用的“密码”来控制应用程序对我们系统的访问，该密码以我们的CA签名的证书的形式提供给用户。</p><p id="ad15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意(我将在整个帖子中多次提到),代码的设置并不是为了验证客户端提供的证书是由我们的CA<em class="nd">签名的，它只是被签名了。这不是<em class="nd">想要的行为，但是我会在另一篇文章中尝试处理额外的认证。此外，除了证书、由一次性密码提供的某种双重身份验证或类似的东西之外，您通常还想设置另一层安全措施。这将<em class="nd">有助于</em>在客户证书/私钥泄露的情况下保护您的系统；没有这“第二个因素”，用户将无法进入(也不包括在本文中)。</em></em></p><h1 id="5787" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">mTLS设置</h1><p id="62af" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">mTLS，至少以我们在这篇文章中将要设置的方式，有几个步骤，其中许多步骤超出了“编码”的范围。步骤的高级列表包括:</p><ul class=""><li id="0040" class="nh ni it ki b kj kk kn ko kr nj kv nk kz nl ld nm nn no np bi translated">创建本地CA</li><li id="2ce0" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">导入CA作为我们的“服务器”(在本例中是我们的本地机器)的受信任根CA</li><li id="6cfa" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">创建由CA签名的“客户端”使用的证书</li><li id="ad3a" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">在我们的中启用/强制客户端证书。网络核心应用</li><li id="c144" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">再次对我们的代码运行cURL命令，不提供证书，看到我们的请求被拒绝</li><li id="cfa7" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">对我们的代码运行cURL命令，这次提供我们的客户端证书，看看我们的请求是否通过</li></ul><h1 id="38ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建本地CA</h1><p id="5b70" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我按照这个教程:<a class="ae kf" href="https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/" rel="noopener ugc nofollow" target="_blank">https://delicious brains . com/SSL-certificate-authority-for-local-https-development/</a></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="94b6" class="mr lf it mn b gy ms mt l mu mv"># Generate a key<br/>openssl genrsa -aes256 -out myCA.key 2048</span><span id="c763" class="mr lf it mn b gy nv mt l mu mv"># Generate root certificate<br/>openssl req -x509 -new -nodes -key myCA.key -sha256 -days 10240 -out myCA.pem</span><span id="fe79" class="mr lf it mn b gy nv mt l mu mv"># Create a .crt file so it can be installed on yucky windows (can *probably* just out in this format from the step above, but i don't know much about openssl)<br/>openssl x509 -outform der -in myCa.pem -out myCa.crt</span></pre><h1 id="d272" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将CA证书作为受信任的根CA导入</h1><p id="0a1c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在，双击crt并选择“安装证书”，将其安装为受信任的根颁发机构:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/271a04049f954d10b8acb165fb6940e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kxlw4hwPyiBvlAA0.png"/></div></div></figure><h1 id="6cc6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建一个由CA签名的证书供客户端使用</h1><p id="cbbc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用以下信息创建文件client.ext:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="21d9" class="mr lf it mn b gy ms mt l mu mv">authorityKeyIdentifier=keyid,issuer<br/>basicConstraints=CA:FALSE<br/>keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span></pre><p id="18f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在生成客户端密钥/证书:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="eb67" class="mr lf it mn b gy ms mt l mu mv"># Generate a key for the "client" to use<br/>openssl genrsa -out client.key 2048</span><span id="513d" class="mr lf it mn b gy nv mt l mu mv"># Generate a Certificate Signing Request (csr)<br/>openssl req -new -key client.key -out client.csr</span><span id="d9c6" class="mr lf it mn b gy nv mt l mu mv"># Using the CA, create client cert based on the CSR<br/>openssl x509 -req -in client.csr -CA myCA.pem -CAkey myCA.key -CAcreateserial -out client.crt -days 1024 -sha256 -extfile client.ext</span></pre><p id="0c8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您应该有一个可用的client.crt，在查看时，您应该能够看到“完整的证书链”,因为证书是由myCa签名的(在我的例子中是kritnerCa):</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/60a7b11acbc012ea8c64261953423c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/0*4lcf4_AwokpXRcZ1.png"/></div></figure><h1 id="0407" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从Kestrel/启用mTLS。网络核心代码</h1><p id="fb74" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让mTLS与Kestrel一起工作是非常简单的，更多地涉及IIS(我可能会在另一篇文章中讨论…？)</p><p id="7d7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">向项目文件添加一个NuGet包，该包允许客户端证书身份验证:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3723" class="mr lf it mn b gy ms mt l mu mv">&lt;ItemGroup&gt;<br/>    &lt;PackageReference Include="Microsoft.AspNetCore.Authentication.Certificate" Version="3.1.0" /&gt;<br/>&lt;/ItemGroup&gt;</span></pre><p id="4287" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在<code class="fe mw mx my mn b">Program.cs</code>中添加“要求客户端证书”到我们的应用程序引导中:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a855" class="mr lf it mn b gy ms mt l mu mv">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;<br/>    Host.CreateDefaultBuilder(args)<br/>        .ConfigureWebHostDefaults(webBuilder =&gt;<br/>        {<br/>            webBuilder.UseStartup&lt;Startup&gt;();<br/>            // vvv requires client certificate when connecting vvv <br/>            webBuilder.ConfigureKestrel(options =&gt;<br/>            {<br/>                options.ConfigureHttpsDefaults(configureOptions =&gt;<br/>                {<br/>                    configureOptions.ClientCertificateMode = ClientCertificateMode.RequireCertificate;<br/>                });<br/>            });<br/>            // ^^^ requires client certificate when connecting ^^^<br/>        });</span></pre><p id="5cb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mw mx my mn b">Startup.cs</code>中，我们需要更新<code class="fe mw mx my mn b">ConfigureServices</code>和<code class="fe mw mx my mn b">Configure</code>来设置认证并注册认证中间件。</p><p id="f386" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mn b">ConfigureServices</code>:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4639" class="mr lf it mn b gy ms mt l mu mv">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services<br/>        .AddAuthentication(CertificateAuthenticationDefaults.AuthenticationScheme)<br/>        .AddCertificate(options =&gt;<br/>        {<br/>            // Only allow chained certs, no self signed<br/>            options.AllowedCertificateTypes = CertificateTypes.Chained;<br/>            // Don't perform the check if a certificate has been revoked - requires an "online CA", which was not set up in our case.<br/>            options.RevocationMode = X509RevocationMode.NoCheck;<br/>            options.Events = new CertificateAuthenticationEvents()<br/>            {<br/>                OnAuthenticationFailed = context =&gt;<br/>                {<br/>                    var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;Startup&gt;&gt;();</span><span id="484f" class="mr lf it mn b gy nv mt l mu mv">logger.LogError(context.Exception, "Failed auth.");</span><span id="a844" class="mr lf it mn b gy nv mt l mu mv">return Task.CompletedTask;<br/>                },<br/>                OnCertificateValidated = context =&gt;<br/>                {<br/>                    var logger = context.HttpContext.RequestServices.GetService&lt;ILogger&lt;Startup&gt;&gt;();</span><span id="9502" class="mr lf it mn b gy nv mt l mu mv">// You should implement a service that confirms the certificate passed in<br/>                    // was signed by the root CA.<br/>                    <br/>                    // Otherwise, a certificate that is valid to one of the other trusted CAs on the webserver,<br/>                    // would be valid in this case as well.<br/>                    <br/>                    logger.LogInformation("You did it my dudes!");</span><span id="0517" class="mr lf it mn b gy nv mt l mu mv">return Task.CompletedTask;<br/>                } <br/>            };<br/>        });<br/>    <br/>    services.AddControllers();<br/>}</span></pre><p id="628f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="nd">请注意上面代码块中的注释。</em> </strong>如果您没有在普通证书验证的基础上实现您自己的验证，那么<em class="nd">任何从客户端传入的</em>有效证书都将被允许，不管它是否由我们在本文前面创建的CA签名。我不打算在这篇文章中介绍如何编写这样的验证器，但是我会在另一篇文章中尽量记住这样做；这篇文章花费了我比预期更多的时间！</p><p id="7ee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mn b">Configure</code>:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e124" class="mr lf it mn b gy ms mt l mu mv">app.UseAuthentication();</span></pre><p id="6537" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意上述<code class="fe mw mx my mn b">app.UseAuthentication</code>应该在<code class="fe mw mx my mn b">app.UseRouting();</code>之后<code class="fe mw mx my mn b">app.UseAuthorization();</code>之前完成。整个<code class="fe mw mx my mn b">Configure</code>方法现在看起来像这样:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ee65" class="mr lf it mn b gy ms mt l mu mv">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br/>{<br/>    if (env.IsDevelopment())<br/>    {<br/>        app.UseDeveloperExceptionPage();<br/>    }</span><span id="14e1" class="mr lf it mn b gy nv mt l mu mv">app.UseHttpsRedirection();</span><span id="5727" class="mr lf it mn b gy nv mt l mu mv">app.UseRouting();</span><span id="4c46" class="mr lf it mn b gy nv mt l mu mv">// vvv Order is important vvv<br/>    app.UseAuthentication();<br/>    // ^^^ Order is important ^^^<br/>    app.UseAuthorization();</span><span id="71d8" class="mr lf it mn b gy nv mt l mu mv">app.UseEndpoints(endpoints =&gt;<br/>    {<br/>        endpoints.MapControllers();<br/>    });<br/>}</span></pre><h1 id="ca48" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试它</h1><p id="993d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在，我们已经针对我们的系统和代码设置了MTL。让我们试一试吧！</p><p id="e7a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，启动web应用程序。</p><p id="6af5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们尝试我们在本文开始时使用的curl命令:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b4af" class="mr lf it mn b gy ms mt l mu mv">curl --insecure -v https://localhost:5001/weatherForecast</span></pre><p id="6d27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来像是:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/867b46395a0a8e44fd75460100b4ea7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eCr5wk6Pvag61Dn3.JPG"/></div></div></figure><p id="536b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上是有道理的，我们还没有给web应用提供证书，所以被拒绝了。</p><p id="e815" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们使用下面的命令来确保我们实际上可以使用我们的签名证书进入:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="eb5d" class="mr lf it mn b gy ms mt l mu mv">curl --insecure -v --key client.key --cert client.crt https://localhost:5001/weatherForecast</span></pre><p id="5d3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来像是:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/f953b3c46a41583fab9d83b074075e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I2P_FM5C7Qos7WzU.JPG"/></div></div></figure><p id="c72d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有用！</p><h1 id="b58c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">自我注释/未来帖子</h1><ul class=""><li id="4c6e" class="nh ni it ki b kj mc kn md kr oa kv ob kz oc ld nm nn no np bi translated">涵盖在IIS上设置mTLS在某些情况下需要更新注册表设置(讨厌！)</li><li id="9c57" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">设置一个自定义证书验证器，现在我们只是放入任何非自签名的证书，而不是检查签名的证书是否由我们的 CA签名。</li><li id="f5e7" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated">多因素认证</li></ul><h1 id="f6b1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参考</h1><ul class=""><li id="1aa8" class="nh ni it ki b kj mc kn md kr oa kv ob kz oc ld nm nn no np bi translated"><a class="ae kf" href="https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/" rel="noopener ugc nofollow" target="_blank">如何为本地HTTPS开发创建自己的SSL证书颁发机构</a></li><li id="b447" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><a class="ae kf" href="https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/" rel="noopener ugc nofollow" target="_blank">什么是传输层安全性(TLS) </a></li><li id="2433" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><a class="ae kf" href="https://en.wikipedia.org/wiki/Mutual_authentication" rel="noopener ugc nofollow" target="_blank">相互认证—维基百科</a></li><li id="6a2e" class="nh ni it ki b kj nq kn nr kr ns kv nt kz nu ld nm nn no np bi translated"><a class="ae kf" href="https://github.com/Kritner-Blogs/Kritner.Mtls/releases/tag/v0.9" rel="noopener ugc nofollow" target="_blank">发布后的代码</a></li></ul></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><p id="011a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nd">原载于2020年7月15日</em><a class="ae kf" href="https://blog.kritner.com/2020/07/15/setting-up-mtls-and-kestrel/" rel="noopener ugc nofollow" target="_blank"><em class="nd">https://blog.kritner.com</em></a><em class="nd">。</em></p></div></div>    
</body>
</html>