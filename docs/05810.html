<html>
<head>
<title>How to Deploy a Cython Package to PyPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将Cython包部署到PyPI</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-deploy-a-cython-package-to-pypi-8217a6581f09?source=collection_archive---------0-----------------------#2020-10-04">https://levelup.gitconnected.com/how-to-deploy-a-cython-package-to-pypi-8217a6581f09?source=collection_archive---------0-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9f429e605ba8438e9b1a0814803c60bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AlobDzu3hnFXtcaI"/></div></div></figure><p id="3a80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现这实际上很难，所以我想会有其他人也会发现这一点。</p><h1 id="3066" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">项目结构</h1><p id="7504" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这是我们将在这个项目中使用的文件结构:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4152" class="mi kx iq me b gy mj mk l ml mm">.<br/>├── classification_library<br/>│   ├── data<br/>│   ├── __init__.pxd<br/>│   ├── __init__.pyx<br/>│   └── test_classification_library.py<br/>├── MANIFEST.in<br/>├── pyproject.toml<br/>├── README.md<br/>└── setup.py</span></pre><h1 id="c6cc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">安装脚本</h1><p id="a88b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Python包的设置脚本是<code class="fe mn mo mp me b">setup.py,</code>，打包工具使用它来知道如何处理代码。</p><p id="8cec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，从setuptools导入所需的函数。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f290" class="mi kx iq me b gy mj mk l ml mm">from setuptools import find_packages, setup</span></pre><p id="a371" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然你正在制作一个Cython包，我假设你知道<code class="fe mn mo mp me b">setup</code>是做什么的。如果你以前没有使用过<code class="fe mn mo mp me b">find_packages</code>，它确实如你所料，当你看到对<code class="fe mn mo mp me b">setup</code>函数的调用时，我们为什么需要它就变得非常明显了。</p><p id="d600" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，在我们调用<code class="fe mn mo mp me b">setup</code>之前，我们必须再导入一些东西。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e3f3" class="mi kx iq me b gy mj mk l ml mm">from Cython.Build import cythonize<br/>import numpy as np</span></pre><p id="fbb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要<code class="fe mn mo mp me b">cythonize</code>，因为它将Cython代码转换成C，我需要numpy，因为我的Cython生成的C代码依赖于它。</p><p id="5eac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要加载自述文件，以便它可以显示在您的软件包的PyPI页面上。你可以用这段代码或者类似的代码来实现:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f693" class="mi kx iq me b gy mj mk l ml mm">with open("README.md", 'r') as f:<br/>    long_description = f.read()</span></pre><p id="68d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您添加<code class="fe mn mo mp me b">setup</code>调用时，文件看起来是这样的:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a2fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mn mo mp me b">setup</code>调用的重要部分是最后三个参数。<code class="fe mn mo mp me b">ext_modules</code>指定包的C扩展，<code class="fe mn mo mp me b">include_dirs</code>需要被指定以便依赖于numpy的C扩展可以被编译，<code class="fe mn mo mp me b">install_requires</code>指定<code class="fe mn mo mp me b">classification_library</code>依赖的包。</p><p id="28ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以使用<code class="fe mn mo mp me b">setuptools.Extension</code>代替<code class="fe mn mo mp me b">Cython.Build.cythonize</code>来生成和编译C扩展，但是仍然需要安装Cython。</p><h1 id="9304" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">指定生成依赖项</h1><p id="ac1f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">你可能一直在担心在<code class="fe mn mo mp me b">setup.py</code>导入numpy和Cython。如果你没有，这里是为什么它是一个问题:</p><p id="01d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你使用pip安装某个东西时，它会临时下载<code class="fe mn mo mp me b">setup.py</code>并在上面运行某些命令(比如<code class="fe mn mo mp me b">python3 setup.py &lt;command&gt;</code>)，这样正确的文件就会出现在你的<code class="fe mn mo mp me b">sys.path</code>中的某个地方，这样你就可以导入它们了。除非pip安装您的软件包的人碰巧已经安装了Cython和numpy，否则这些导入语句将会抛出错误。因此，您必须在<code class="fe mn mo mp me b">pyproject.toml</code>中指定它们。这使得pip将临时安装安装您的软件包所需的软件包。下面是我的<code class="fe mn mo mp me b">pyproject.toml</code>的样子:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="66be" class="mi kx iq me b gy mj mk l ml mm">[build-system]<br/>requires = ["setuptools", "wheel", "numpy&gt;=1.19.0", "Cython&gt;=0.29.21"]<br/>build-backend = "setuptools.build_meta"</span></pre><p id="61ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一行基本上是告诉包管理器使用<code class="fe mn mo mp me b">setuptools.build_meta</code>，以便知道如何处理该部分中指定的其他信息。</p><p id="bf6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了指定构建依赖关系之外，还可以做更多的事情，但这是另一篇博客文章要讨论的问题。</p><h1 id="2a41" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">包括非Python文件</h1><p id="38e9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">拥有一个<code class="fe mn mo mp me b">MANIFEST.in</code>文件很重要，因为它指定了包含哪些非python文件，否则打包工具会忽略这些文件。您不必包含<code class="fe mn mo mp me b">.pyx</code>文件，因为这些文件会被编译成<code class="fe mn mo mp me b">.so</code>文件，后者会被检测为python文件。但是，<code class="fe mn mo mp me b">.pxd</code>文件如果不包含将被忽略。所以，我的<code class="fe mn mo mp me b">MANIFEST.in</code>长这样:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c09c" class="mi kx iq me b gy mj mk l ml mm">include classification_library/__init__.pxd<br/>include classification_library/data</span></pre><h1 id="6d12" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">生成源档案和Wheel文件</h1><p id="8017" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果您尚未安装wheel，请安装:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="91e9" class="mi kx iq me b gy mj mk l ml mm">pip install wheel</span></pre><p id="b4ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在您可以运行该命令:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="a30b" class="mi kx iq me b gy mj mk l ml mm">python3 setup.py sdist bdist_wheel</span></pre><p id="5b85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该看到一个名为<code class="fe mn mo mp me b">dist</code>的目录，其中包含以<code class="fe mn mo mp me b">.tar.gz</code>和<code class="fe mn mo mp me b">.whl</code>结尾的文件。如果你在Linux上，你的wheel文件以<code class="fe mn mo mp me b">cp38-linux_x86_64.whl</code>结尾，那么你必须做一些额外的工作。</p><p id="863e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于技术原因，PyPI不支持上传这种车轮文件。要将其更改为正确的格式，您必须安装auditwheel:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9d41" class="mi kx iq me b gy mj mk l ml mm">pip install auditwheel</span></pre><p id="c125" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，您可以运行命令:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4865" class="mi kx iq me b gy mj mk l ml mm">auditwheel repair dist/&lt;your_package_name&gt;-cp38-cp38-linux_86_64.whl</span></pre><p id="6dae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将auditwheel生成的文件移动到<code class="fe mn mo mp me b">dist</code>目录中，并删除旧的wheels。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="dc23" class="mi kx iq me b gy mj mk l ml mm">mv wheelhouse/* dist<br/>rm dist/*-cp38-cp38-linux_x86_64.whl</span></pre><h1 id="f4dc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">上传到PyPI</h1><p id="28e3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">将文件上传到PyPI是由一个名为twine的包处理的。</p><p id="55e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我相信你已经明白了这一点，但如果你还没有，这里有如何安装twine:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="faa5" class="mi kx iq me b gy mj mk l ml mm">pip install twine</span></pre><p id="5123" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还必须<a class="ae ms" href="https://pypi.org/account/register/" rel="noopener ugc nofollow" target="_blank">创建一个PyPI帐户</a>。</p><p id="829b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你<em class="mt">可以在每次上传包的时候</em>指定你的用户名和密码，或者你可以把它们放在一个<code class="fe mn mo mp me b">~/.pypirc</code>文件里，就像这样:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7a18" class="mi kx iq me b gy mj mk l ml mm">[pypi]<br/>username = &lt;your_username&gt;<br/>password = &lt;your_password&gt;</span></pre><p id="9f3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想更安全，你可以从你的帐户设置中获得一个API令牌。你的账户设置页面上有相关说明。</p><p id="1d9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，您可以使用以下命令上传到PyPI:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="212e" class="mi kx iq me b gy mj mk l ml mm">python3 -m twine upload --repository pypi dist/*</span></pre><p id="e5b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切顺利，你应该可以在终端上输入这个，你的包就会被安装。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="4605" class="mi kx iq me b gy mj mk l ml mm">pip install &lt;your_cython_package&gt;</span></pre><p id="c301" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您必须增加您的<code class="fe mn mo mp me b">setup.py</code>中的版本号，重新生成源发行版和wheel文件，并在每次更新您的包时使用twine重新上传。</p><p id="845e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我有这个问题，我部署的一些软件包必须安装<code class="fe mn mo mp me b">pip install git+https://github.com/lol-cubes/&lt;package-name&gt;</code>。如果您知道为什么会出现这种情况和/或如何解决，请告诉我。非常感谢。</p><p id="f8e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常感谢您的阅读！祝你在Cython冒险中好运！</p></div></div>    
</body>
</html>