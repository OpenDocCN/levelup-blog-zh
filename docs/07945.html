<html>
<head>
<title>You are Simply Injecting a Dependency, Thinking that You are Following the Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您只是简单地注入了一个依赖，认为您遵循了依赖倒置原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/you-are-simply-injecting-a-dependency-thinking-that-you-are-following-the-dependency-inversion-32632954c208?source=collection_archive---------11-----------------------#2021-03-23">https://levelup.gitconnected.com/you-are-simply-injecting-a-dependency-thinking-that-you-are-following-the-dependency-inversion-32632954c208?source=collection_archive---------11-----------------------#2021-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d6fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">澄清差异。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b42c8e797e812ecefc994af17d5ab1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*01NZ_BEORamVlHj4"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁斯·马斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="16f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖倒置原则和依赖注入是完全不同的东西，尽管术语的名称相似。理解这些差异对于从事面向对象编程的软件工程师来说非常重要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c29b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有非常简单或少数底层对象才能独立实现所需的全部功能。通常，对象需要重用其他对象的逻辑。要做到这一点，对象可以简单地使用<code class="fe mc md me mf b">new</code>关键字自己实例化所有需要的依赖关系:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="0de0" class="mk ml it mf b gy mm mn l mo mp">public class OrderService<br/>{<br/>   private OrderRepository _orderRepository = new OrderRepository();</span><span id="1d6d" class="mk ml it mf b gy mq mn l mo mp">   public Order PrepareOrder(long orderId)<br/>   {<br/>      var order = _orderRepository.GetOrder(orderId);<br/>      //...<br/>   }<br/>}</span></pre><p id="dc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象可以重用对象T2的逻辑。现在好像一切都好。每个组件负责自己的工作，组件之间相互作用。</p><p id="a3a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用<code class="fe mc md me mf b">new</code>关键字会在对象及其依赖项之间产生紧密耦合。紧密耦合使得类<code class="fe mc md me mf b">OrderService</code>对于不需要存储库的新上下文中的代码重用是不可用的。同样，单元测试不能为<code class="fe mc md me mf b">OrderService</code>类编写。缺乏依赖注入会严重影响应用程序的可维护性。这就是为什么依赖注入是软件工程中常见的最佳实践。</p><p id="7cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入是一种允许一个对象接收它所依赖的其他对象的技术。最常见的方法是将依赖项的接口注入到类的构造函数中，如下所示:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="7dcc" class="mk ml it mf b gy mm mn l mo mp">public class OrderService<br/>{<br/>   private IOrderRepository _orderRepository;</span><span id="96be" class="mk ml it mf b gy mq mn l mo mp">   public OrderService(IOrderRepository orderRepository)<br/>   {<br/>      _orderRepository = orderRepository;<br/>   }</span><span id="18e8" class="mk ml it mf b gy mq mn l mo mp">   public Order PrepareOrder(long orderId)<br/>   {<br/>      var order = _orderRepository.GetOrder(orderId);<br/>      //...<br/>   }<br/>}</span></pre><p id="cf0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了构造函数注入，还有两种技术:方法注入和属性注入。当一个类的单个方法需要某种依赖时，可以使用方法依赖注入。属性依赖注入通常用于设置在类的生命周期中可以多次更改的依赖关系。</p><p id="5f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将构造函数注入与接口结合使用有助于我们反转<code class="fe mc md me mf b">OrderRepository</code>依赖性——类<code class="fe mc md me mf b">OrderService</code>不应该再实例化<code class="fe mc md me mf b">OrderRepository</code>。依赖关系需要由其他人实例化，并传递给<code class="fe mc md me mf b">OrderService</code>构造函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/9ab5a506348e20d833afc8e750870220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*INYjyPlS4yLS9NQpQHw6AA.png"/></div></figure><p id="a5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个特殊的例子中，在构造函数中注入一个接口使得代码遵循依赖倒置原则。但整个故事的关键点如下:</p><blockquote class="ms"><p id="d94e" class="mt mu it bd mv mw mx my mz na nb lu dk translated">并不是每个在构造函数中需要接口的对象都遵循依赖反转原则。</p></blockquote><p id="383a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">依赖倒置原则不仅仅是将一个接口注入到构造函数中。原则声明一个对象必须依赖于相同或更高抽象层次的对象。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="c255" class="mk ml it mf b gy mm mn l mo mp">public class OrderService<br/>{<br/>   private ISqlConnection _sqlConnection;<br/>   <br/>   public OrderService(ISqlConnection sqlConnection)<br/>   {<br/>       _sqlConnection = sqlConnection;<br/>   }<br/>}</span></pre><p id="03f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe mc md me mf b">OrderService</code>类仍然在构造函数中接收一个接口，但是尽管如此，<code class="fe mc md me mf b">OrderService</code>还是违反了依赖倒置原则。类<code class="fe mc md me mf b">ISqlConnection</code>存在于<code class="fe mc md me mf b">OrderService</code>类的几个层次之下，它应该只处理存储库(在下一个层次)或其他域对象(在同一层次上)。处理连接、套接字或其他底层细节违反了依赖倒置，这会使<code class="fe mc md me mf b">OrderService</code>类的实现变得非常复杂。</p><p id="b8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖倒置原则帮助开发人员将应用程序组件(类和模块)组织成一个清晰的层次结构，而依赖注入只是一种避免类之间紧密耦合的简单技术。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6bf3" class="nh ml it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">摘要</h1><ul class=""><li id="5665" class="ny nz it lb b lc oa lf ob li oc lm od lq oe lu of og oh oi bi translated">依赖注入是一种允许对象通过构造函数、方法或属性获得它所依赖的其他对象的技术。</li><li id="9d9f" class="ny nz it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">依赖注入没有说依赖应该属于哪个抽象层次。</li><li id="cac6" class="ny nz it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">依赖倒置原则声明依赖必须存在于相同或更高的抽象层次。</li><li id="b665" class="ny nz it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">依赖倒置原则是使用依赖注入技术实现的。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="03c6" class="nh ml it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">更多关于设计的文章</h1><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">在C#中实现单例设计反模式的5种方法</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">各有利弊</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/3-main-use-cases-of-the-facade-design-pattern-in-enterprise-applications-aa9b290adac6"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">企业应用程序中外观设计模式的3个主要用例</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">优雅地处理代码复杂性</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener  ugc nofollow" target="_blank" href="/the-simplest-explanation-of-adapter-design-pattern-cd37f02bfecd"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">适配器设计模式的最简单解释</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">C#中的真实世界示例</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="ph l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>