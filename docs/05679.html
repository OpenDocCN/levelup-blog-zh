<html>
<head>
<title>Await Array.Prototype.Map with ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">等待数组。原型。带ES6的地图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/await-array-prototype-map-with-es6-ae5d6e4d1d66?source=collection_archive---------7-----------------------#2020-09-21">https://levelup.gitconnected.com/await-array-prototype-map-with-es6-ae5d6e4d1d66?source=collection_archive---------7-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b19b88b5b9f0e6e885c7ee829fcc27c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zmd0RSHU7MxLepJABKnn9w.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="https://www.pexels.com/photo/computer-with-code-4218883/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kf" href="https://www.pexels.com/@paras?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Paras Katwal </a>摄影</figcaption></figure><p id="eea4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Javascript中的承诺很难理解。我们应该使用承诺还是组合异步/等待？这可能是一个艰难的选择。</p><p id="283a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当它开始做函数式编程时，它可能开始变得令人困惑。如果您的回调正在处理异步函数，而您想等待它们，该怎么办？那么如何处理地图回调的返回值呢？(这将是一个承诺，因为回调是异步的)</p><p id="c0ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，即使有意义，在地图上直接使用await也是不可能的。让我们来看看下面的场景:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e3cf" class="ln lo it lj b gy lp lq l lr ls">const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];</span><span id="6198" class="ln lo it lj b gy lt lq l lr ls">async function test() {<br/>  const results = await array.map(async(item) =&gt; {</span><span id="55e7" class="ln lo it lj b gy lt lq l lr ls">   // The setTimeout with await simulate a "heavy async function"<br/>   await setTimeout(() =&gt; {}, 1000);<br/>    return item;<br/>  })<br/>  <br/>  console.log(results);<br/>}</span><span id="1a79" class="ln lo it lj b gy lt lq l lr ls">test()</span></pre><p id="463f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">console.log将打印一组仍然需要解决的承诺。这是因为Map本身无法解析这些承诺，所以它只会返回这些承诺，并期望开发人员手动处理它们。</p><p id="ceb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们想等待所有的承诺都被解析并打印出来，我们可以使用全局对象Promise: <code class="fe lu lv lw lj b">Promise.all</code>中的这个非常有用的函数，并在后面添加关键字await来等待所有的承诺都被解析。</p><p id="0113" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们编辑我们的代码:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7515" class="ln lo it lj b gy lp lq l lr ls">const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];</span><span id="6d07" class="ln lo it lj b gy lt lq l lr ls">async function test() {<br/>  // No more await here<br/>  const promises = array.map(async(item) =&gt; {<br/>   await setTimeout(() =&gt; {}, 1000);<br/>    return item;<br/>  })<br/>  <br/>  // Await + Promise.all to wait for all promises to resolve<br/>  const results = await Promise.all(promises)<br/>  <br/>  console.log(results);<br/>}</span><span id="be25" class="ln lo it lj b gy lt lq l lr ls">test()</span></pre><p id="93a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这个新版本的代码，我们正在等待所有的承诺解决，然后我们可以正确地打印它们的结果！</p></div></div>    
</body>
</html>