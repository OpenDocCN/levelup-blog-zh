<html>
<head>
<title>Using Mockito for Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Mockito进行单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-mockito-for-unit-testing-96a74f3ed2a5?source=collection_archive---------2-----------------------#2020-06-01">https://levelup.gitconnected.com/using-mockito-for-unit-testing-96a74f3ed2a5?source=collection_archive---------2-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d23e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">新手用例子解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d63461b9fdf1a86236f0b8171ff18e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dg-CEFVxCtizENgbVoLbBA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">蒂姆·高在<a class="ae ky" href="https://unsplash.com/s/photos/nerds?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ae5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试是每个在公司工作或编写自己代码的开发人员工作的一部分。在大多数情况下，新的Java程序员开始学习编写JUnit测试，这是Java开发人员的另一个基础知识。但是，仅仅了解JUnit是不够的。<em class="lv">模拟</em>是单元测试的重要组成部分，被许多开发人员广泛使用。</p><blockquote class="lw"><p id="dbb6" class="lx ly it bd lz ma mb mc md me mf lu dk translated">最流行的使用mocks的Java库之一是Mockito。</p></blockquote><p id="6390" class="pw-post-body-paragraph kz la it lb b lc mg ju le lf mh jx lh li mi lk ll lm mj lo lp lq mk ls lt lu im bi translated">我意识到对于初级开发人员来说，理解如何用Mockito编码可能有点困难。它是需要额外学习的Java库之一。我可以把它与学习一种新的方言相比较——例如，荷兰人有非常多样的方言，其中一些甚至在荷兰的不同地区都很难理解。Mockito也是一样——它是Java的一部分，但是需要额外的努力来学习它。</p><blockquote class="lw"><p id="0dc0" class="lx ly it bd lz ma mb mc md me mf lu dk translated">在本文中，我将解释开发人员应该使用Mockito的情况。此外，我将提供一些代码示例。</p></blockquote></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="1c4f" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">为什么模拟是必要的？</h2><p id="8da9" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated"><strong class="lb iu">单元</strong>测试的概念是在一个测试类中只测试一个类/单元。然而，在大多数情况下，这个类有一些其他的依赖项。例如，服务类可能依赖于其他类:存储库、助手等。服务类从其他类调用代码，但是我们只想测试<strong class="lb iu"> this-service </strong>类，而不是所有其他相关的类。在编写单元测试时，我们不应该对其他类中的侧面实现感兴趣。为了避免侧面测试，我们必须使用模拟。如果模拟不能用于类依赖，我们将不得不创建真实的对象，这样的测试将发展成为集成测试，而集成测试不是单元测试的一部分。</p><p id="19fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖性的替换和这种依赖性的虚拟实现被称为模仿。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="4178" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">实际例子</h2><p id="9f53" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">对于代码示例，我将Spring Boot与Maven结合使用。首先要做的是在pom文件中添加所需的依赖关系:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="1315" class="ms mt it nr b gy nv nw l nx ny">&lt;<strong class="nr iu">dependency</strong>&gt;<br/>   &lt;<strong class="nr iu">groupId</strong>&gt;org.mockito&lt;/<strong class="nr iu">groupId</strong>&gt;<br/>   &lt;<strong class="nr iu">artifactId</strong>&gt;mockito-junit-jupiter&lt;/<strong class="nr iu">artifactId</strong>&gt;<br/>   &lt;<strong class="nr iu">version</strong>&gt;3.3.3&lt;/<strong class="nr iu">version</strong>&gt;<br/>   &lt;<strong class="nr iu">scope</strong>&gt;test&lt;/<strong class="nr iu">scope</strong>&gt;<br/>&lt;/<strong class="nr iu">dependency</strong>&gt;</span></pre><p id="8d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将测试一个<em class="lv"> BookService </em>类，它只有一个带有一些依赖项的方法:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="11de" class="ms mt it nr b gy nv nw l nx ny">@Component<br/><strong class="nr iu">public class </strong>BookService {<br/><br/>    <strong class="nr iu">private static final </strong>Logger <strong class="nr iu"><em class="lv">LOGGER </em></strong>= Logger.<em class="lv">getLogger</em>(<strong class="nr iu">"InfoLoggin"</strong>);</span><span id="a410" class="ms mt it nr b gy nz nw l nx ny">@Autowired<br/>    <strong class="nr iu">private </strong>BookRepo <strong class="nr iu">bookRepo</strong>;</span><span id="cc17" class="ms mt it nr b gy nz nw l nx ny">@Autowired<br/>    <strong class="nr iu">private </strong>VoiceOverAgencyRepository <strong class="nr iu">agencyRepo</strong>;<br/><br/>    <strong class="nr iu">public </strong>Book saveBook(Book book) <strong class="nr iu">throws </strong>CustomException {<br/><br/>        <em class="lv">//1. Checking if this book already exists in database.<br/>        </em><strong class="nr iu">if </strong>(<strong class="nr iu">bookRepo</strong>.existsByIbanId(book.getIbanId())) {<br/>            <strong class="nr iu">throw new </strong>CustomException();<br/>        }<br/><br/>        <em class="lv">//2. Setting registration date of a new book.<br/>        </em>book.setRegistrationDateTime(LocalDateTime.<em class="lv">now</em>());<br/><br/>        <em class="lv">//3. Checking if this book has an audio version.<br/>        //If not, we register it in agency's DB too.<br/>        </em><strong class="nr iu">if </strong>(book.isAudioVersion()) {<br/>            <strong class="nr iu"><em class="lv">LOGGER</em></strong>.info(book.getBookName() + <strong class="nr iu">": audio version       exists."</strong>);<br/>        } <strong class="nr iu">else </strong>{<br/>            <strong class="nr iu">agencyRepo</strong>.registerBookForAudio(book.getIbanId());<br/>        }<br/>        <em class="lv">//4. Saving into the database.<br/>        </em><strong class="nr iu">return bookRepo</strong>.save(book);<br/>    }<br/>}</span></pre><p id="30ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法接收一个book对象并检查:</p><p id="aa0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">a)如果这样的书已经存在于数据库中。如果这本书存在，它会抛出一个自定义异常。</p><p id="a407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">b)如果数据库中不存在该书，则它设置注册日期和时间。</p><p id="d4f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">c)它检查该书是否有音频版本。如果没有音频版本，它会将这本书注册到一个语音代理的存储库中。</p><p id="a518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">d)最后，它将这本书注册到图书库中。</p><p id="b3a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这个类有两个自动连接的对象:<em class="lv">语音代理库</em>和<em class="lv">图书库</em>。我们在这个类中调用两个存储库，但是它们将在自己的类中完成它们的工作。我们不想测试其他类的功能，这意味着这两个对象将被嘲笑。</p><h2 id="c8ec" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">让我们一步一步来</h2><ol class=""><li id="58ad" class="oa ob it lb b lc nl lf nm li oc lm od lq oe lu of og oh oi bi translated">我需要创建一个测试类，并添加所有的依赖项。<br/> a)我的测试类得到一个注释<em class="lv">@ extend with(mockitoextensionc . class)。这个注释初始化了测试类中的所有模拟。<br/> b)我用注释<em class="lv"> @Mock </em>模拟所有的依赖关系，并使用注释<em class="lv"> @InjectMocks </em>将这些模拟注入到我想要测试的服务类中:</em></li></ol><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="8f3f" class="ms mt it nr b gy nv nw l nx ny">@ExtendWith(MockitoExtension.<strong class="nr iu">class</strong>)<br/><strong class="nr iu">public class </strong>TestBookService {<br/><br/>    @Mock<br/>    <strong class="nr iu">private </strong>Book <strong class="nr iu">book</strong>;<br/><br/>    @Mock<br/>    <strong class="nr iu">private </strong>BookRepo <strong class="nr iu">bookRepo</strong>;<br/><br/>    @Mock<br/>    <strong class="nr iu">private </strong>VoiceOverAgencyRepository <strong class="nr iu">agencyRepo</strong>;<br/><br/>    @InjectMocks<br/>    <strong class="nr iu">private </strong>BookService <strong class="nr iu">bookService</strong>;<br/>...</span></pre><p id="b23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我已经模拟了在<em class="lv"> BookService </em>类中与<em class="lv"> @Autowired </em>注释一起使用的所有依赖项。我还模仿了一本我在<em class="lv"> BookService </em>类中用作方法参数的书。我将能够随心所欲地操纵这些对象，并且我不需要创建真实的对象。</p><p id="64c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.让我们回到<em class="lv"> BookService </em>类。</p><p id="0618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里只有一种方法，我将一步一步地测试它。这意味着我想创建一些不同的测试方法来检查我的方法的不同行为。</p><p id="471b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的方法的前几行验证图书是否已经在图书存储库中。如果确实存在，它会抛出一个自定义异常:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="9691" class="ms mt it nr b gy nv nw l nx ny"><strong class="nr iu">public </strong>Book saveBook(Book book) <strong class="nr iu">throws </strong>CustomException {<br/><br/>        <em class="lv">//1. Checking if this book already exists in database.<br/>        </em><strong class="nr iu">if </strong>(<strong class="nr iu">bookRepo</strong>.existsByIbanId(book.getIbanId())) {<br/>            <strong class="nr iu">throw new </strong>CustomException();<br/>        }</span></pre><p id="9fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我如何能检查它？我必须对我的测试类说，这本书已经存在于存储库中，所以它将调用异常。我可以用模仿的方法<em class="lv">来做，当…然后Return… </em>我传递一个Mockito变量<em class="lv"> any() </em>因为它不必是一个真实的对象——我唯一关心的是调用我的异常。因此，我告诉Mockito: <em class="lv">当</em>到达一个代码行，上面写着<em class="lv">book repo . existsbyibanid(any())</em>，<em class="lv">然后返回</em> <em class="lv"> true </em>。现在我可以测试我的程序是否真的抛出了异常。看看这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/67fdcc1825c808cc151d345114327631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*DJIaFz600OYKpmDVBWEAbQ.jpeg"/></div></figure><p id="3c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.下面是服务类的第二部分:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="633f" class="ms mt it nr b gy nv nw l nx ny"><em class="lv">//2. Setting registration date of a new book.<br/>        </em>book.setRegistrationDateTime(LocalDateTime.<em class="lv">now</em>());</span></pre><p id="ec4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的测试应该检查服务类是否真的执行了这一行。我想确保我的代码不会在没有到达的地方结束。</p><p id="c8df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做到这一点，我可以使用Mockito方法<em class="lv">验证</em>(发生了一些事情)。</p><p id="d46c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在调用这个方法之前，我必须向测试类给出指令:</p><p id="2fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">a)当我的代码到达第一行时，检查这本书是否已经存在，我必须告诉我的代码这本(被模仿的)书还不存在(否则我的代码将抛出异常)。</p><p id="393d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">b)之后，我的代码将到达我想要测试的行。然而，这还不够。我必须为我的测试方法编写指令，以及当它到达方法的以下行时应该做什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/afe3099e73faaa2a7d653496347d8914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xH15rSGlshYSzIMrMlmahw.jpeg"/></div></div></figure><p id="3e38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.让我们进入该方法的下一部分:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="c5a8" class="ms mt it nr b gy nv nw l nx ny"><em class="lv">//3. Checking if this book has an audio version.<br/>// If not, we register it in agency's DB too.<br/>        </em><strong class="nr iu">if </strong>(book.isAudioVersion()) {<br/>            <strong class="nr iu"><em class="lv">LOGGER</em></strong>.info(book.getBookName() + <strong class="nr iu">": audio version exists."</strong>);<br/>        } <strong class="nr iu">else </strong>{<br/>            <strong class="nr iu">agencyRepo</strong>.registerBookForAudio(book.getIbanId());<br/>        }</span></pre><p id="983d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有音频版本，我想确保我的代码确实在机构的存储库中注册了一本书。在这种情况下，我会告诉我的嘲笑，这本书没有音频版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/b066599869e0a99360913963f6c184f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kCpZ-ACisOHt6k3dxT_2w.jpeg"/></div></div></figure><p id="8f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.反之亦然:如果音频版本已经存在，我想确保我的代码永远不会为代理注册这本书。我可以告诉我的<em class="lv"> verify </em>函数，这一行不应该被调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/f9d30adfd0151f95c0aa2874ca2a48c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e77GOIwUg9Fn-u2VM31j4w.jpeg"/></div></div></figure><p id="0762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6.最后，最后一部分<em class="lv">图书服务</em>类:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="aa46" class="ms mt it nr b gy nv nw l nx ny"><em class="lv">//4. Saving into the database.<br/>        </em><strong class="nr iu">return bookRepo</strong>.save(book);<br/>    }<br/>}</span></pre><p id="8299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想确保它会将正确的对象保存到数据库中。</p><p id="4e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我将创建一个真正的book对象，并捕获我保存在book存储库中的数据。</p><p id="57fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">参数捕获器</em>允许访问方法调用的参数并检查它们。它与<em class="lv">验证(..)</em>方法。我可以很容易地启动它:</p><p id="815b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">ArgumentCaptor&lt;</em><strong class="lb iu"><em class="lv">objectthawanttocapture</em></strong><em class="lv">&gt;captor = ArgumentCaptor . for class(</em><strong class="lb iu"><em class="lv">objectthawanttocapture . class</em></strong><em class="lv">)；</em></p><p id="314c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/9f18a03f82b2204a01d58a6f27e54c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*GpxOuBqXiDcbkEwb0m4U6w.jpeg"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="e958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在已经学习了如何使用Mockito编写单元测试。我的例子包括您可以在代码中使用的最常用的Mockito方法:</p><ul class=""><li id="89b1" class="oa ob it lb b lc ld lf lg li oo lm op lq oq lu or og oh oi bi translated"><em class="lv">何时(某个方法将被调用)。thenReturn(某物)；</em></li><li id="8970" class="oa ob it lb b lc os lf ot li ou lm ov lq ow lu or og oh oi bi translated"><em class="lv">验证(该方法将被调用x次)；</em></li><li id="7f68" class="oa ob it lb b lc os lf ot li ou lm ov lq ow lu or og oh oi bi translated"><em class="lv">验证(该方法将被调用，永不调用)；</em></li><li id="8165" class="oa ob it lb b lc os lf ot li ou lm ov lq ow lu or og oh oi bi translated">验证(当这个方法被调用时)……(捕获者捕获我想要验证的参数)。</li></ul><p id="c352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">掌握了这些基本的Mockito函数后，您将能够更深入地研究它，并确保您的代码质量更好。</p><p id="4ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Mockito的更多信息可以在官方文档网站中找到<a class="ae ky" href="https://site.mockito.org/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>