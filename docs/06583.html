<html>
<head>
<title>Handle Registration in FastAPI and Tortoise ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在FastAPI和Tortoise ORM中处理注册</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handle-registration-in-fastapi-and-tortoise-orm-a661162d27f1?source=collection_archive---------7-----------------------#2020-12-09">https://levelup.gitconnected.com/handle-registration-in-fastapi-and-tortoise-orm-a661162d27f1?source=collection_archive---------7-----------------------#2020-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="dfb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个过程中掉一两滴眼泪——第二部分</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/bf28fd8a01e6374b3b184263a87ae7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hceLACM7RXXdEEe2"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@zenking?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗布·金</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="69da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程的前一部分中，您已经设置好了Uvicorn服务器。您还不能很好地使用它，但是您仍然应该编写一些代码。在本部分中，您将添加两个服务:</p><ul class=""><li id="0a24" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe ll lm ln lo b">auth</code> —用于生成注册令牌</li><li id="d61e" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated"><code class="fe ll lm ln lo b">mailer</code> —用于发送注册确认电子邮件</li></ul><p id="f123" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们开始吧。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="98fd" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">认证服务</h1><p id="6f1f" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">打开<code class="fe ll lm ln lo b">/app/services/auth.py</code>，从这个方法(和一个类)的存根开始:</p><pre class="km kn ko kp gt ne lo nf ng aw nh bi"><span id="2e6a" class="ni mc iq lo b gy nj nk l nl nm">class Auth:<br/>    @staticmethod<br/>    def create_token(data: dict, expires_delta: int):<br/>        pass</span></pre><p id="a5bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法应该这样工作:您提供要编码的数据和令牌过期后的时间(以秒为单位)。我们用一个<code class="fe ll lm ln lo b">staticmethod</code>装饰器包装它，因为它既不依赖于对象也不依赖于类属性。这是我对这个方法的想法:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="ea81" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">用<code class="fe ll lm ln lo b">exp</code>(到期时间)<a class="ae lb" href="https://tools.ietf.org/html/rfc7519#section-4.1.4" rel="noopener ugc nofollow" target="_blank">索赔</a>更新提供的<code class="fe ll lm ln lo b">data</code>。这很重要，因为你不希望确认链接永远存在。我们使用UTC时间。这是一个共同点。用户时区可以不同，但UTC时间将始终相同。</li><li id="17f6" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated">指定令牌的颁发者(<code class="fe ll lm ln lo b">iss</code> claim)。</li><li id="e167" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated">用本教程前面部分指定的密钥和算法对<code class="fe ll lm ln lo b">data</code>进行编码。</li></ul><p id="f646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了方便起见，您将创建另一个方法，仅用于生成确认令牌。它将用户ID作为唯一的参数。它也将是静态的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="e07f" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><code class="fe ll lm ln lo b">sub</code>声明是令牌的订阅者——用户。你通过他的身份证认出他。</li><li id="1251" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated"><code class="fe ll lm ln lo b">scope</code> — JWT令牌可以有多种作用域。我在本教程中只涉及<code class="fe ll lm ln lo b">registration</code>。</li><li id="38bc" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated"><code class="fe ll lm ln lo b">jti</code> —令牌的唯一标识符。没有它，如果生成了多个令牌，我们就无法使其无效。</li></ul><p id="c344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一需要添加的是生成散列密码的选项:</p><pre class="km kn ko kp gt ne lo nf ng aw nh bi"><span id="8da1" class="ni mc iq lo b gy nj nk l nl nm">class Auth:<br/>    password_context = CryptContext(schemes=["bcrypt"], deprecated="auto")<br/><br/>    @classmethod<br/>    def get_password_hash(cls, password: str):<br/>        return cls.password_context.hash(password)</span></pre><ul class=""><li id="244b" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">使用<code class="fe ll lm ln lo b">bcrypt</code>。很方便，省去了你自己管理密码盐。</li><li id="ccdf" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated">定义<code class="fe ll lm ln lo b">classmethod</code>，这次不定义<code class="fe ll lm ln lo b">staticmethod</code>。那是因为已经添加了类别字段<code class="fe ll lm ln lo b">password_context</code>。</li></ul><p id="5c27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你可以参加考试了。在Python REPL中，包含服务:</p><pre class="km kn ko kp gt ne lo nf ng aw nh bi"><span id="6499" class="ni mc iq lo b gy nj nk l nl nm">from services.auth import Auth</span></pre><p id="11eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你需要一个UUID。<code class="fe ll lm ln lo b">00000000-0000-0000-0000-000000000000</code>会做:</p><pre class="km kn ko kp gt ne lo nf ng aw nh bi"><span id="0f7b" class="ni mc iq lo b gy nj nk l nl nm">uuid = '00000000-0000-0000-0000-000000000000'<br/>Auth.create_confirmation_token(uuid)</span></pre><p id="8eab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据您提供的密钥，您将获得一个令牌。贴在<a class="ae lb" href="https://jwt.io:" rel="noopener ugc nofollow" target="_blank"> https://jwt.io </a>上。一切都应该是健全的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi np"><img src="../Images/399d537c3c5702dd6955208d6153c61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8yLNX4XbkLX0YWQ3hSgxA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">解码的JWT令牌</figcaption></figure></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="47c5" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">邮件服务</h1><p id="66aa" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">打开<code class="fe ll lm ln lo b">/app/services/mailer.py</code>。您将添加一个发送电子邮件的方法。这很简单:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="ac2f" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">创建一个新的空的<code class="fe ll lm ln lo b">EmailMessage</code>分配给一个<code class="fe ll lm ln lo b">message</code>变量。然后，使用提供的方法参数设置消息<code class="fe ll lm ln lo b">content</code>。</li><li id="cf18" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated">设置割台— <code class="fe ll lm ln lo b">Subject</code>、<code class="fe ll lm ln lo b">From</code>和<code class="fe ll lm ln lo b">To</code>。</li><li id="64be" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated">使用您的SMTP服务器发送邮件。</li></ul><p id="835b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以添加另一种方法来处理确认电子邮件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div></figure><ul class=""><li id="f01f" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">从<code class="fe ll lm ln lo b">localhost/api/auth/verify.</code>开始生成<code class="fe ll lm ln lo b">confirmation_url</code></li><li id="9089" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated"><code class="fe ll lm ln lo b">'''</code>表示一个<a class="ae lb" href="https://docs.python.org/3/library/stdtypes.html?highlight=str#text-sequence-type-str" rel="noopener ugc nofollow" target="_blank">多线串</a>。</li></ul><p id="dcd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。<code class="fe ll lm ln lo b">mailer</code>模块完成。现在你必须测试它。出于我们的目的，您将使用内置于Python中的SMTP调试服务器。要运行它，调用:</p><pre class="km kn ko kp gt ne lo nf ng aw nh bi"><span id="64c4" class="ni mc iq lo b gy nj nk l nl nm">python -m smtpd -c DebuggingServer -n localhost:25</span></pre><p id="3bdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它将在主机<code class="fe ll lm ln lo b">localhost</code>和端口<code class="fe ll lm ln lo b">25</code>运行服务器。在REPL，输入以下内容:</p><pre class="km kn ko kp gt ne lo nf ng aw nh bi"><span id="c09c" class="ni mc iq lo b gy nj nk l nl nm">from services.mailer import Mailer<br/>Mailer.send_confirmation_message('test-token', '<a class="ae lb" href="mailto:test@example.com" rel="noopener ugc nofollow" target="_blank">test@example.com</a>')</span></pre><p id="5e7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在运行SMTP服务器的窗口中，您应该会看到以下输出:</p><pre class="km kn ko kp gt ne lo nf ng aw nh bi"><span id="f28e" class="ni mc iq lo b gy nj nk l nl nm">---------- MESSAGE FOLLOWS ----------<br/>b'Content-Type: text/plain; charset="utf-8"'<br/>b'Content-Transfer-Encoding: 7bit'<br/>b'MIME-Version: 1.0'<br/>b'<strong class="lo ir">Subject: Please confirm your registration</strong>'<br/>b'<strong class="lo ir">From: </strong><a class="ae lb" href="mailto:noreply@example.com" rel="noopener ugc nofollow" target="_blank"><strong class="lo ir">noreply@example.com</strong></a>'<br/>b'<strong class="lo ir">To: </strong><a class="ae lb" href="mailto:test@example.com" rel="noopener ugc nofollow" target="_blank"><strong class="lo ir">test@example.com</strong></a>'<br/>b'X-Peer: ::1'<br/>b'<strong class="lo ir">Hi!</strong>'<br/>b''<br/>b'<strong class="lo ir">Please confirm your registration: localhost:8000/verify/test-token.</strong>'<br/>------------ END MESSAGE ------------</span></pre><p id="467a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您的输出匹配，那么您就完成了教程的这一部分。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="e92f" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">最后的话</h1><p id="a6bb" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">感谢阅读！</p><p id="e88d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/handle-registration-in-fastapi-and-tortoise-orm-a673263bdba3">最后一部分</a>中，您将:</p><ul class=""><li id="6918" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">将<code class="fe ll lm ln lo b">users</code>表映射到ORM模型</li><li id="c8bf" class="lc ld iq jp b jq lp ju lq jy lr kc ls kg lt kk lh li lj lk bi translated">编写用于注册和确认的端点</li></ul><p id="05b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有代码都可以在我的GitHub上找到。</p></div></div>    
</body>
</html>