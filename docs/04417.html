<html>
<head>
<title>Dynamic Storage Provisioning for Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes的动态存储供应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamic-storage-provisioning-for-kubernetes-d43891fd1a51?source=collection_archive---------9-----------------------#2020-06-25">https://levelup.gitconnected.com/dynamic-storage-provisioning-for-kubernetes-d43891fd1a51?source=collection_archive---------9-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c0f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让Rook/EdgeFS驱动您的MongoDB集群</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a4a70b596580d3297d1f2f9016b379e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Y_pHYcAvZwBJlXCt4vKegA.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://commons.wikimedia.org/wiki/Lawrence_Livermore_National_Laboratory" rel="noopener ugc nofollow" target="_blank">劳伦斯利弗莫尔国家实验室</a>提供</figcaption></figure><p id="1db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇文章<a class="ae ky" href="https://medium.com/better-programming/build-your-own-in-home-cloud-storage-part-2-8fe86e9bd5bf" rel="noopener">构建你自己的家庭云存储(第二部分)</a>中，我们使用<a class="ae ky" href="https://rook.io/" rel="noopener ugc nofollow" target="_blank"> Rook </a>创建了一个<a class="ae ky" href="http://edgefs.io/" rel="noopener ugc nofollow" target="_blank"> EdgeFS </a>存储集群，但是没有真正使用它。在本文中，我将展示如何创建一个存储类类型，允许您对它进行持久的卷声明。</p><p id="3fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到最近，声称在Kubernetes存储是一个偶然的事情。这是因为它被视为GKE或AWS等Kubernetes提供商的领域，每个人都有自己的解决方案。Kubernetes 1.13增加了容器存储接口(CSI ),它为第三方存储提供商提供了一条通向Kubernetes集群的桥梁。通过CSI，提供商可以实现<code class="fe lv lw lx ly b">StorageClass</code>和<code class="fe lv lw lx ly b">PersistentVolume</code>类型的基本方面，使管理员能够静态或动态地定义存储，并使pod用户能够申请存储。我们将通过Rook/EdgeFS使用这个接口为一个<a class="ae ky" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>副本集提供存储。</p><p id="f42b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应该描述一下我们将在本文中用到的一些部分。EdgeFS是一个集群存储解决方案，可以独立使用。Rook是一个Kubernetes操作符，它将在Kubernetes中自动建立一个EdgeFS集群。Rook有一个CSI驱动程序，允许我们在EdgeFS中动态地创建和使用存储桶。在我的上一篇文章<a class="ae ky" href="https://medium.com/better-programming/build-your-own-in-home-cloud-storage-part-2-8fe86e9bd5bf" rel="noopener">构建您自己的家庭云存储(第2部分)</a>中，我用Rook创建了EdgeFS集群，我们将在此基础上添加CSI实现。如果您不理解我的前一篇文章，我们有一个Kubernetes集群，它有七个节点，kube1-kube4作为我们的控制面板和三个工作节点，node 1–3作为处理EdgeFS集群的节点。我的GitHub存储库中的<a class="ae ky" href="https://github.com/rkamradt/storage-deploy/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> README.md </a>有设置集群的基本说明。</p><p id="392d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们对Kubernetes做一个小小的设置。我在我的文章<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-4691283e3995" rel="noopener"> Kubernetes from Scratch </a>中创建的集群没有正确的CSI驱动程序定义，所以我需要添加它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="beda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您需要ssh到Kubernetes集群中的每个节点，并安装NFS支持:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="7465" class="mf mg it ly b gy mh mi l mj mk">sudo apt install -y nfs-common rpcbind open-iscsi watchdog</span></pre><p id="5cfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我添加了<code class="fe lv lw lx ly b">open-iscsi</code>包，以防我们以后想玩CSI <code class="fe lv lw lx ly b">iscsi</code>驱动。</p><p id="d8d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让事情更有条理，我将为CSI驱动程序组件创建一个单独的名称空间，名为<code class="fe lv lw lx ly b">edgefs-nfs-csi</code>。</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="73c9" class="mf mg it ly b gy mh mi l mj mk">kubectl create namespace edgefs-nfs-csi</span></pre><p id="c784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以配置和部署EdgeFS CSI NFS驱动程序。在我的上一篇文章<a class="ae ky" href="https://medium.com/better-programming/build-your-own-in-home-cloud-storage-part-2-8fe86e9bd5bf" rel="noopener">构建你自己的家庭云存储(第2部分)</a>中，我们从Rook GitHub资源库下载了示例。如果您没有，可以下载:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="fc2a" class="mf mg it ly b gy mh mi l mj mk">git clone --single-branch --branch release-1.3 \<br/>       <a class="ae ky" href="https://github.com/rook/rook.git" rel="noopener ugc nofollow" target="_blank">https://github.com/rook/rook.git</a></span></pre><p id="9890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经创建了自己的GitHub存储库，<a class="ae ky" href="https://github.com/rkamradt/storage-deploy/tree/v1.2" rel="noopener ugc nofollow" target="_blank"> storage-deploy </a>，用于存储我的部署文件，因此我将把必要的文件复制到我的本地克隆中:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="a33c" class="mf mg it ly b gy mh mi l mj mk">cp rook/cluster/examples/kubernetes/edgefs/csi/nfs/*.yaml \<br/>     storage-deploy</span></pre><p id="a225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将给我们两个文件，<code class="fe lv lw lx ly b">edgefs-nfs-csi-driver-config.yaml</code>和<code class="fe lv lw lx ly b">edgefs-nfs-csi-driver.yaml</code>，它们都需要一点编辑。以下是<code class="fe lv lw lx ly b">edgefs-nfs-csi-driver-config.yaml</code>的值</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="c510" class="mf mg it ly b gy mh mi l mj mk">k8sEdgefsNamespaces: ["rook-edgefs"] <br/>k8sEdgefsMgmtPrefix: rook-edgefs-mgr <br/>cluster: cltest <br/>tenant: test    <br/>username: admin <br/>password: admin</span></pre><p id="49c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然里面有密码，那就需要是Kubernetes的秘密。它可能也不应该出现在GitHub repo中，但是因为它只是一个例子，所以我将把它留在我的例子中。有点遗憾的是，配置都在同一个地方，而不是有一个单独的方式来指示用户名/密码。也许有一种方法，我会让你去发现。在更安全的环境中，我希望将集群的配置与凭证分开，因为我们不应该将凭证存储在版本控制中，但是我们可能希望将其余的定义存储在那里。</p><p id="5d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">edgefs-nfs-csi-driver.yaml</code>需要引用我们创建的名称空间。事实上，它使用<code class="fe lv lw lx ly b">default</code>作为名称空间，但是我不想破坏<code class="fe lv lw lx ly b">default</code>名称空间。编辑文件并用<code class="fe lv lw lx ly b">namespace: edgefs-nfs-csi</code>替换<code class="fe lv lw lx ly b">namespace: default</code>的所有实例。</p><p id="b047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，我们需要在EdgeFS客户机中设置一些东西。CSI适配器通过创建附加到集群/租户/服务三元组的存储桶来工作。但是这些工件需要提前创建，只有桶是动态创建的。在上面的配置中，集群是<code class="fe lv lw lx ly b">cltest</code>，租户是<code class="fe lv lw lx ly b">test</code>。稍后我们将使用一个服务<code class="fe lv lw lx ly b">nfs01</code>。所以我们需要首先创建它们。您可以使用我们在上一篇文章末尾提到的GUI来创建这些工件，也可以使用命令行界面。我将在这里展示命令行界面版本。在<code class="fe lv lw lx ly b">rook-edgefs</code>名称空间中找到<code class="fe lv lw lx ly b">rook-edgefs-mgr</code>的pod，在交互终端中执行<code class="fe lv lw lx ly b">toolbox</code>命令</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="53d2" class="mf mg it ly b gy mh mi l mj mk">rkamradt@beast:~/storage-deploy$ kubectl exec -it rook-edgefs-mgr-648457b454-j2tcl -n rook-edgefs -- toolbox<br/>Defaulting container name to rook-edgefs-mgr.<br/>Use 'kubectl describe pod/rook-edgefs-mgr-648457b454-j2tcl -n rook-edgefs' to see all of the containers in this pod.</span><span id="cb69" class="mf mg it ly b gy ml mi l mj mk">Welcome to EdgeFS Mgmt Toolbox.<br/>Hint: type neadm or efscli to begin</span><span id="a37c" class="mf mg it ly b gy ml mi l mj mk">root@rook-edgefs-mgr-648457b454-j2tcl:/opt/nedge# efscli system status</span><span id="3dfa" class="mf mg it ly b gy ml mi l mj mk">SID                | HOST  |          POD           | USED,% | STATE   <br/>+----------------------------------+-------+------------------------+--------+--------+<br/>  3131644475DD1E38274C22A6E7D14DA8 | node1 | rook-edgefs-target-1-0 |  0.00  | ONLINE  <br/>  40AD4245F79D8924F686E560C2256383 | node2 | rook-edgefs-target-0-0 |  0.00  | ONLINE  <br/>  7A4ED7164285247D68236351AB7CD770 | node3 | rook-edgefs-target-2-0 |  0.00  | ONLINE</span><span id="4ac6" class="mf mg it ly b gy ml mi l mj mk">root@rook-edgefs-mgr-648457b454-j2tcl:/opt/nedge# efscli cluster create cltest<br/>root@rook-edgefs-mgr-648457b454-j2tcl:/opt/nedge# efscli tenant create cltest/test<br/>root@rook-edgefs-mgr-648457b454-j2tcl:/opt/nedge# efscli service create nfs nfs01<br/>root@rook-edgefs-mgr-648457b454-j2tcl:/opt/nedge# exit<br/>exit</span></pre><p id="0e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会创造出我们需要的三件艺术品。我们还没有将服务附加到集群/租户，因为CSI供应器会这样做。如果您愿意，您可以在之前设置的GUI中查看这些服务。单击集群名称空间，然后单击<code class="fe lv lw lx ly b">cltest</code>框，您应该会看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/422feb82c975e2734b601e1b9ca33129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-FmfmWnUTEfAvx8IuKtrA.png"/></div></div></figure><p id="6ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建密码并应用驱动程序:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="8ae6" class="mf mg it ly b gy mh mi l mj mk">kubectl create secret generic edgefs-nfs-csi-driver-config \<br/>   -n edgefs-nfs-csi --from-file=./edgefs-nfs-csi-driver-config.yaml<br/>kubectl apply -n edgefs-nfs-csi -f edgefs-nfs-csi-driver.yaml</span></pre><p id="6891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查以确保它都在运行:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="ff51" class="mf mg it ly b gy mh mi l mj mk">rkamradt@beast:~/storage-deploy$ kubectl get all -n edgefs-nfs-csi<br/>NAME                              READY   STATUS    RESTARTS   AGE<br/>pod/edgefs-nfs-csi-controller-0   3/3     Running   0          88s<br/>pod/edgefs-nfs-csi-node-lcdxx     2/2     Running   0          88s<br/>pod/edgefs-nfs-csi-node-tvc6m     2/2     Running   0          88s<br/>pod/edgefs-nfs-csi-node-x97cp     2/2     Running   0          88s</span><span id="c1ea" class="mf mg it ly b gy ml mi l mj mk">NAME                                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)     AGE<br/>service/edgefs-nfs-csi-controller   ClusterIP   10.110.6.49   &lt;none&gt;        12345/TCP   88s<br/>service/kubernetes                  ClusterIP   10.96.0.1     &lt;none&gt;        443/TCP     48d</span><span id="021b" class="mf mg it ly b gy ml mi l mj mk">NAME                                 DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE<br/>daemonset.apps/edgefs-nfs-csi-node   3         3         3       3            3           &lt;none&gt;          88s</span><span id="1516" class="mf mg it ly b gy ml mi l mj mk">NAME                                         READY   AGE<br/>statefulset.apps/edgefs-nfs-csi-controller   1/1     88s</span></pre><p id="517f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能需要一段时间才能让所有的pod显示为就绪，所以请休息一下。</p><p id="4096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们有一个名为<code class="fe lv lw lx ly b">edgefs-nfs-csi-controller</code>的有状态集和一个名为<code class="fe lv lw lx ly b">edgefs-nfs-csi-node</code>的守护进程集，一切都很好！</p><p id="8650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从我们的集群中进行动态配置，我们需要设置一个存储类。用以下内容创建一个文件<code class="fe lv lw lx ly b">nfs-storage-class.yaml</code>:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="294f" class="mf mg it ly b gy mh mi l mj mk">apiVersion: storage.k8s.io/v1<br/>kind: StorageClass<br/>metadata:<br/>  name: edgefs-nfs-csi-storageclass<br/>provisioner: io.edgefs.csi.nfs<br/>parameters:<br/>  segment: rook-edgefs<br/>  service: nfs01</span></pre><p id="fdb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后应用:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="86d8" class="mf mg it ly b gy mh mi l mj mk">kubectl apply -f nfs-storage-class.yaml</span></pre><p id="8f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，存储类没有名称空间。现在，您应该能够使用存储类<code class="fe lv lw lx ly b">edgefs-nfs-csi-storageclass</code>进行持久的卷声明</p><p id="40fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过使用新的存储类设置一个MongoDB副本集来尝试一下。创建一个文件<code class="fe lv lw lx ly b">mongodb-stateful.yaml</code>并添加以下内容:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="3ebd" class="mf mg it ly b gy mh mi l mj mk">apiVersion: rbac.authorization.k8s.io/v1beta1<br/>kind: ClusterRoleBinding<br/>metadata:<br/>  name: mongo-sidecar-rbac<br/>subjects:<br/>  - kind: ServiceAccount<br/>    name: default<br/>    namespace: default<br/>roleRef:<br/>  kind: ClusterRole<br/>  name: cluster-admin<br/>  apiGroup: rbac.authorization.k8s.io<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mongo<br/>  labels:<br/>    name: mongo<br/>spec:<br/>  ports:<br/>  - port: 27017<br/>    targetPort: 27017<br/>  clusterIP: None<br/>  selector:<br/>    role: mongo<br/>---<br/>apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>  name: mongo<br/>spec:<br/>  serviceName: "mongo"<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: mongodb<br/>  template:<br/>    metadata:<br/>      labels:<br/>        role: mongo<br/>        app: mongodb<br/>        environment: test<br/>    spec:<br/>      terminationGracePeriodSeconds: 10<br/>      containers:<br/>        - name: mongo<br/>          image: mongo:3.4<br/>          command:<br/>            - mongod<br/>            - "--replSet"<br/>            - rs0<br/>            - "--bind_ip"<br/>            - 0.0.0.0<br/>            - "--smallfiles"<br/>            - "--noprealloc"<br/>          ports:<br/>            - containerPort: 27017<br/>          volumeMounts:<br/>            - name: mongo-persistent-storage<br/>              mountPath: /data/db<br/>        - name: mongo-sidecar<br/>          image: cvallance/mongo-k8s-sidecar<br/>          env:<br/>            - name: MONGO_SIDECAR_POD_LABELS<br/>              value: "role=mongo,environment=test"<br/>  volumeClaimTemplates:<br/>  - metadata:<br/>      name: mongo-persistent-storage<br/>      annotations:<br/>        volume.beta.kubernetes.io/storage-class: "edgefs-nfs-csi-storageclass"<br/>    spec:<br/>      accessModes: [ "ReadWriteOnce" ]<br/>      resources:<br/>        requests:<br/>          storage: 100Gi</span></pre><p id="df86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将建立一个服务和一个有状态集。您将会注意到，除了MongoDB图像之外，它还使用了sidecar中的<a class="ae ky" href="https://github.com/cvallance/mongo-k8s-sidecar" rel="noopener ugc nofollow" target="_blank">cvallance/mongo-k8s-sidecar</a>助手。在一个pod中，您可以有多个容器，如果有一个主容器和一个辅助容器，则使用“sidecar”这个术语。它们仍然是独立的容器，但是因为它们存在于同一个pod中，所以它们共享所有相同的资源。sidecar容器帮助MongoDB找到其他副本并在它们之间进行协调。用<code class="fe lv lw lx ly b">kubectl apply -f mongodb-stateful.yaml</code>涂抹。</p><p id="b625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意的是，上述yaml的第一部分将默认的pod用户绑定到cluster-admin，这意味着您的任何pod都可以在集群上执行任何Kubernetes命令。这在生产中不是一个好主意。这里需要它，因为sidecar需要列出所有的pod，以便能够找到对等的mongo服务。可能有一个更好的解决方案，但是现在，我要给所有的pod<code class="fe lv lw lx ly b">cluster-admin</code>权限。</p><p id="450e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还使用了卷声明模板，因此每个pod都可以从我们之前创建的<code class="fe lv lw lx ly b">edgefs-nfs-csi-storageclass</code>类中分配自己的存储。一旦所有副本都出现，我们就可以返回到EdgeFS GUI并检查供应情况。单击Services选项卡，单击<code class="fe lv lw lx ly b">nfs01</code>框，然后向下滚动查看系统创建的存储桶:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/a89aa99f7631dd33e0eba09f655c5b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrVZS6qCbhjlaAOtuuunjA.png"/></div></div></figure><p id="cab9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">nfs01</code>服务中，每个mongo副本集都有自己的存储桶。</p><p id="6d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们测试一下我们的新MongoDB集群。我将安装Mongo Express，这是一个基于网络的管理员。它可以从<a class="ae ky" href="https://www.cowboysysop.com/en/" rel="noopener ugc nofollow" target="_blank"> cowboysysop </a>获得。要安装，需要两个命令:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="f92a" class="mf mg it ly b gy mh mi l mj mk">helm repo add cowboysysop <a class="ae ky" href="https://cowboysysop.github.io/charts/" rel="noopener ugc nofollow" target="_blank">https://cowboysysop.github.io/charts/</a><br/>helm install mongo-express -n rook-edgefs \<br/>    --set mongodbServer=mongo.default cowboysysop/mongo-express</span></pre><p id="eb7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将它添加到了<code class="fe lv lw lx ly b">rook-edgefs</code>名称空间，这样我就可以重用用于EdgeFS GUI的虚拟主机入口。由于<code class="fe lv lw lx ly b">mongo</code>服务在<code class="fe lv lw lx ly b">default</code>名称空间中，我必须将<code class="fe lv lw lx ly b">.default</code>附加到<code class="fe lv lw lx ly b">mongodbServer</code>值上。现在我可以更新我已经拥有的<code class="fe lv lw lx ly b">vhost-ingress.yaml</code>:</p><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="e778" class="mf mg it ly b gy mh mi l mj mk">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: rook-ingress<br/>  annotations:<br/>    cert-manager.io/issuer: ca-issuer <br/>spec:<br/>  rules:<br/>  - host: rook.local<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: rook-edgefs-ui<br/>          servicePort: 3000<br/>        path: /<br/>  - host: mongo-express.local<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: mongo-express<br/>          servicePort: 8081<br/>        path: /<br/>  tls:<br/>  - hosts:<br/>    - mongo-express.local<br/>    secretName: mongo-express-cert<br/>  - hosts:<br/>    - rook.local<br/>    secretName: rook-cert</span></pre><p id="bb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lv lw lx ly b">kubectl apply -n rook-edgefs vhost-ingress.yaml</code>涂抹。然后在您的笔记本电脑上添加<code class="fe lv lw lx ly b">mongo-express.local</code>作为入口IP的别名，并浏览到<code class="fe lv lw lx ly b">https://mongo-express.local</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/4145ce2d55d65f0c85a3a303a341810e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHBlYIKtlptJhKo0xNGxXg.png"/></div></div></figure><p id="ae97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，唯一的数据库是由MongoDB默认创建的本地数据库。单击“查看”按钮查看详细信息</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/84a24d0364418e7d2b5b3f19f2f4e839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ImpdtdZvIACD5l-21GmXg.png"/></div></div></figure><p id="3ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经有了EdgeFS GUI和MongoDB Express GUI可以使用了。就像您为MongoDB做持久存储声明一样容易，您也可以为其他Kubernetes应用程序获取存储。或者将您的微服务附加到新的MongoDB集群。玩得开心！感谢您阅读我的另一篇文章，这篇文章试图给软件开发增添一点乐趣。</p><p id="d6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是GitHub存储库，包含所有使用的脚本:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/rkamradt/storage-deploy/tree/v1.2" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">rkamradt/存储-部署</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">将Rook/EdgeFS系统部署到Kubernetes，参见文章“构建您自己的家庭云存储第二部分”</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ks ms"/></div></div></a></div><p id="007b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是提到的其他文章:</p><div class="mp mq gp gr mr ms"><a href="https://medium.com/better-programming/build-your-own-in-home-cloud-storage-part-2-8fe86e9bd5bf" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">构建您自己的家庭云存储(第2部分)</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">使用Rook/EdgeFS向Kubernetes集群添加存储</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng ks ms"/></div></div></a></div><div class="mp mq gp gr mr ms"><a href="https://medium.com/better-programming/kubernetes-from-scratch-4691283e3995" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd iu gy z fp mx fr fs my fu fw is bi translated">从零开始</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">不含Minikube或Microk8s的Kubernetes</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="ni l nd ne nf nb ng ks ms"/></div></div></a></div></div></div>    
</body>
</html>