<html>
<head>
<title>All about Javascript Promises for Interviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于面试的Javascript承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vimp-javascript-promise-implementation-challenges-5a4f120d8606?source=collection_archive---------7-----------------------#2022-07-24">https://levelup.gitconnected.com/vimp-javascript-promise-implementation-challenges-5a4f120d8606?source=collection_archive---------7-----------------------#2022-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fae1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript |承诺聚合填充|输出驱动问题|所有关于承诺的内容</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/2b4de5348a17f4010cca8d0a200a3ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/0*I8vzE0EZlY-_TUvb.png"/></div></figure><p id="3f31" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">承诺返回一个值，这个值可以是一个已解决的值，也可以是拒绝的原因。</p><h1 id="dbc9" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">承诺有四种状态</h1><p id="ad1e" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated"><strong class="kp ir">待定</strong>:在事件发生之前，承诺处于待定状态。</p><p id="86de" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">已解决</strong>:一旦事件发生，它就处于已解决状态。</p><p id="42c3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">完成</strong>:与承诺相关的动作成功。</p><p id="f677" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">拒绝</strong>:与承诺相关的动作失败。</p><h1 id="6535" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">对照表</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/d2d24252186593a492b8cdf242416f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*miuj_qxA-Uvk6zvN"/></div></div></figure><h1 id="cd50" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">` Promise.all()'</h1><p id="d4c5" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated"><strong class="kp ir"> Promise.all() </strong>方法并行执行许多承诺。它接受一组承诺并返回一个承诺。</p><ul class=""><li id="f9ae" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">只有所有通过的承诺都解决了，才会解决。</li><li id="376e" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">如果一系列承诺中的任何一个失败了，它就会拒绝。</li></ul><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="2ebf" class="ne lk iq na b gy nf ng l nh ni">const promiseArr = [<br/>  new Promise(resolve =&gt; setTimeout(resolve, 100, 'apple')),<br/>  new Promise(resolve =&gt; setTimeout(resolve, 100, 'banana')),<br/>  new Promise(resolve =&gt; setTimeout(resolve, 3000, 'orange'))<br/>]<br/><strong class="na ir">Promise.all</strong>(promiseArr)<br/>  .then(fruits =&gt; console.log(fruits))<br/>  .catch(err =&gt; console.log('Error:', err))<br/><br/>// After 3 seconds, logs out the following<br/>// ["apple", "banana", "orange"]</span></pre><h1 id="aab8" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">机具或聚合填料</h1><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="63dd" class="ne lk iq na b gy nf ng l nh ni"><em class="nj">/**<br/> * </em><strong class="na ir"><em class="nj">@param </em></strong><em class="nj">{Array&lt;any&gt;} </em><strong class="na ir"><em class="nj">promises </em></strong><em class="nj">- notice input might have non-Promises<br/> * </em><strong class="na ir"><em class="nj">@return </em></strong><em class="nj">{Promise&lt;any[]&gt;}<br/> */</em></span><span id="b43b" class="ne lk iq na b gy nk ng l nh ni"><em class="nj">function </em>all(promises) {<br/>  <em class="nj">return new Promise</em>((resolve, reject) =&gt; {<br/>    <em class="nj">if </em>(!promises.length) {<br/>      resolve([])<br/>    }<br/><br/>    <em class="nj">const </em>poolResponses = []<br/>    <em class="nj">let </em>count = 0<br/><br/>    promises.forEach((p, idx) =&gt; {<br/>      Promise.resolve(p).then(res =&gt; {<br/>        poolResponses[idx] = res<br/>        count++<br/>        <em class="nj">if </em>(count === promises.length) {<br/>          resolve(poolResponses)<br/>        }<br/>      }).<em class="nj">catch</em>(err =&gt; {<br/>        reject(err)<br/>      })<br/>    })<br/>  })<br/>}</span></pre><h1 id="b365" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">` Promise.allSettled()'</h1><p id="6883" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated"><strong class="kp ir"> Promise.allSettled() </strong>接受承诺数组的方法。它返回一个新的承诺，如果数组中的所有承诺都被解决，则该承诺将被解决，而不管这些承诺是被解决还是被拒绝。</p><p id="8971" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="nj">一例</em><strong class="kp ir"><em class="nj">promise . all settled()</em></strong><em class="nj">一口答应拒绝:</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1013" class="ne lk iq na b gy nf ng l nh ni">const promiseArr = [<br/>  new Promise(resolve =&gt; setTimeout(resolve, 100, 'apple')),<br/>  new Promise((resolve, reject) =&gt; setTimeout(reject, 10, 'banana')),<br/>  new Promise(resolve =&gt; setTimeout(resolve, 3000, 'orange'))<br/>]</span><span id="d416" class="ne lk iq na b gy nk ng l nh ni"><strong class="na ir">Promise.allSettled(promiseArr)</strong><br/>  .then(fruits =&gt; console.log(fruits))<br/>  .catch(err =&gt; console.log('Error:', err))<br/><br/>// After 10 ms, logs out the following<br/>// [<br/>//  {status: 'fulfilled', value: 'apple'},<br/>//  {status: 'rejected', value: 'banana'},<br/>//  {status: 'fulfilled', value: 'orange'}<br/>// ]</span></pre><h1 id="1345" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">机具或聚合填料</h1><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="2b14" class="ne lk iq na b gy nf ng l nh ni"><em class="nj">/**<br/> * </em><strong class="na ir"><em class="nj">@param </em></strong><em class="nj">{Array&lt;any&gt;} </em><strong class="na ir"><em class="nj">promises </em></strong><em class="nj">- notice that input might contains non-promises</em></span><span id="417f" class="ne lk iq na b gy nk ng l nh ni"><em class="nj"> * </em><strong class="na ir"><em class="nj">@return </em></strong><em class="nj">{Promise&lt;Array &lt;{status: 'fulfilled', value: any} | {status: 'rejected', reason: any}&gt;&gt;}</em></span><span id="fd9c" class="ne lk iq na b gy nk ng l nh ni"><em class="nj"> */</em></span><span id="c6fd" class="ne lk iq na b gy nk ng l nh ni"><em class="nj">const </em><strong class="na ir">allSettled</strong> = <em class="nj">async </em>(promises) =&gt; {<br/>  <em class="nj">if </em>(!promises.length) {<br/>    <em class="nj">return </em>[]<br/>  }<br/><br/>  <em class="nj">const </em>poolResponses = []<br/>  <em class="nj">let </em>counter = 0<br/><br/>  <em class="nj">for </em>(<em class="nj">let </em>i = 0; i &lt; promises.length; i++) {<br/>    <em class="nj">try </em>{<br/>      <em class="nj">const </em>res = <em class="nj">await </em>promises[i];<br/>      poolResponses[i] = {<br/>        status: 'fulfilled',<br/>        value: res<br/>      }<br/>    } <em class="nj">catch </em>(err) {<br/>      poolResponses[i] = {<br/>        status: 'rejected',<br/>        reason: err<br/>      }<br/>    } <em class="nj">finally </em>{<br/>      counter++<br/>      <em class="nj">if </em>(counter === promises.length) {<br/>        <em class="nj">return </em>poolResponses<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="c93f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">实现` Promise.race()'</h1><p id="b01b" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated"><em class="nj">promise . race()方法返回一个承诺，该承诺在iterable中的一个承诺履行或拒绝时立即履行或拒绝，其值或原因来自该承诺</em></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="922a" class="ne lk iq na b gy nf ng l nh ni"><em class="nj">/**<br/> * </em><strong class="na ir"><em class="nj">@param </em></strong><em class="nj">{Array&lt;Promise&gt;} </em><strong class="na ir"><em class="nj">promises<br/> </em></strong><em class="nj">* </em><strong class="na ir"><em class="nj">@return </em></strong><em class="nj">{Promise}<br/> */<br/>const </em>race = (promises) =&gt; {<br/>  <em class="nj">return new Promise</em>((resolve, reject) =&gt; {<br/>    promises.forEach(p =&gt; p.then(resolve, reject))<br/>  })<br/>}</span></pre><h1 id="b8f1" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">拒绝时自动重试承诺</h1><ul class=""><li id="3aa4" class="ml mm iq kp b kq mb kt mc kw nl la nm le nn li mq mr ms mt bi translated">在web应用程序中获取数据是很常见的。然而，如果我们遇到网络问题，我们可能需要<strong class="kp ir">重试</strong>机制。</li><li id="fdc9" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">如何实现接受一个<strong class="kp ir">承诺</strong>和一个<strong class="kp ir"> maximumRetryCount </strong>的<code class="fe no np nq na b">fetchWithAutoRetry</code>。util将继续重试<strong class="kp ir">承诺</strong>，直到计数器计数完毕，那时，我们将拒绝最后一个错误。</li></ul><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="13c8" class="ne lk iq na b gy nf ng l nh ni"><em class="nj">/**<br/> * </em><strong class="na ir"><em class="nj">@param </em></strong><em class="nj">{() =&gt; Promise&lt;any&gt;} </em><strong class="na ir">promise<em class="nj"><br/> </em></strong><em class="nj">* </em><strong class="na ir"><em class="nj">@param </em></strong><em class="nj">{number} </em><strong class="na ir"><em class="nj">maximumRetryCount<br/> </em></strong><em class="nj">* </em><strong class="na ir"><em class="nj">@return </em></strong><em class="nj">{Promise&lt;any&gt;}<br/> */<br/>const </em>fetchWithAutoRetry = <em class="nj">async </em>(promise, maximumRetryCount) =&gt; {<br/>  <em class="nj">try </em>{<br/>    <em class="nj">return await </em>promise()<br/>  } <em class="nj">catch </em>(err) {<br/>    <em class="nj">if </em>(maximumRetryCount === 0) {<br/>      <em class="nj">return </em>Promise.reject(err)<br/>    }<br/>    <em class="nj">return </em>fetchWithAutoRetry(promise, maximumRetryCount - 1)<br/>  }<br/>}</span></pre><h1 id="a6d4" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">节流承诺</h1><ul class=""><li id="d18e" class="ml mm iq kp b kq mb kt mc kw nl la nm le nn li mq mr ms mt bi translated">如何实现接受返回承诺的函数数组和表示最大并发调用的变量的<code class="fe no np nq na b">throttlePromises()</code>?</li><li id="61b1" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">一般我们用<code class="fe no np nq na b">Promise.all</code>或<code class="fe no np nq na b">Promise.allSettled</code>来依次计算承诺。然而，有时候我们需要动态地限制一系列承诺。</li><li id="7a3e" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">由于网络或硬件的限制，或者缺少分页，我们不得不限制同时可以处理的并发请求的数量。</li></ul><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="c17c" class="ne lk iq na b gy nf ng l nh ni">throttleAsync(callApis, 10).then((data) =&gt; {<br/>  // the data is the same as `Promise.all` <br/>}).catch((err) =&gt; {<br/>  // any error occurs in the callApis would be relayed here<br/>})</span></pre><p id="cc4c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通过运行上面的代码，在任何时候，请求的API都不会超过10个，因此节省了低规格的服务器。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1101" class="ne lk iq na b gy nf ng l nh ni"><em class="nj">/**<br/> * </em><strong class="na ir"><em class="nj">@param </em></strong><em class="nj">{() =&gt; Promise&lt;any&gt;} </em><strong class="na ir"><em class="nj">func<br/> </em></strong><em class="nj">* </em><strong class="na ir"><em class="nj">@param </em></strong><em class="nj">{number} </em><strong class="na ir"><em class="nj">max<br/> </em></strong><em class="nj">* </em><strong class="na ir"><em class="nj">@return </em></strong><em class="nj">{Promise}<br/> */<br/>const </em>throttlePromises = <em class="nj">async </em>(promises, max) =&gt; {<br/>  <em class="nj">try </em>{<br/>    <em class="nj">let </em>counter = 0<br/>    <em class="nj">const </em>poolResponses = []</span><span id="4b5a" class="ne lk iq na b gy nk ng l nh ni"><em class="nj">while </em>(counter &lt;= promises.length) {<br/>      <em class="nj">const </em>chunkPromises = promises.slice(counter, counter + max)<br/>      counter += max</span><span id="5289" class="ne lk iq na b gy nk ng l nh ni"><em class="nj">const </em>results = <em class="nj">await </em>Promise.all(chunkPromises.map(p =&gt; p()))<br/>      poolResponses.push(...results)<br/>    }</span><span id="72e0" class="ne lk iq na b gy nk ng l nh ni"><em class="nj">return </em>poolResponses<br/>  } <em class="nj">catch </em>(err) {<br/>    <em class="nj">throw </em>err<br/>  }<br/>}<br/></span></pre></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/2b3c5e7b9ab410065e9e29e1bccd604c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5AxAchDnang_p7eo.png"/></div></div></figure><h1 id="d22a" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战1:承诺建造者</h1><p id="f3b8" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这段代码的输出是什么？</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8c8f" class="ne lk iq na b gy nf ng l nh ni">console.log('start'); </span><span id="1233" class="ne lk iq na b gy nk ng l nh ni">const promise1 = new Promise((resolve, reject) =&gt; {  <br/>   console.log(1)<br/>}) ;</span><span id="6933" class="ne lk iq na b gy nk ng l nh ni">console.log('end');</span></pre><p id="d046" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">同步代码块总是从上到下顺序执行。</p><ul class=""><li id="81c3" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">当我们调用<code class="fe no np nq na b">new Promise(callback)</code>时，回调函数会立即执行。</li></ul><blockquote class="nz oa ob"><p id="98ac" class="kn ko nj kp b kq kr jr ks kt ku ju kv oc kx ky kz od lb lc ld oe lf lg lh li ij bi translated"><strong class="kp ir">输出</strong>，所以这段代码是依次输出<code class="fe no np nq na b">start</code>、<code class="fe no np nq na b">1</code>、<code class="fe no np nq na b">end</code>。</p></blockquote><h1 id="5458" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战2:。然后()</h1><p id="78b5" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这段代码的输出是什么？</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="def2" class="ne lk iq na b gy nf ng l nh ni">console.log('start'); </span><span id="4bd7" class="ne lk iq na b gy nk ng l nh ni">const promise1 = new Promise((resolve, reject) =&gt; {  <br/>  console.log(1)  <br/>  resolve(2)<br/>}) </span><span id="70fb" class="ne lk iq na b gy nk ng l nh ni">promise1.then(res =&gt; {  <br/>  console.log(res)<br/>}) </span><span id="8698" class="ne lk iq na b gy nk ng l nh ni">console.log('end');</span></pre><p id="aff5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">记住，JavaScript引擎总是先执行同步代码，然后执行异步代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/ef8fac7301bf9e04098beff6e3687ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fosnXIMFv1pLpv2_.png"/></div></div></figure><blockquote class="nz oa ob"><p id="0d61" class="kn ko nj kp b kq kr jr ks kt ku ju kv oc kx ky kz od lb lc ld oe lf lg lh li ij bi translated"><strong class="kp ir">输出</strong>，所以输出为<code class="fe no np nq na b">start</code>、<code class="fe no np nq na b">1</code>、<code class="fe no np nq na b">end</code>和<code class="fe no np nq na b">2</code>。</p></blockquote><h1 id="9ec5" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战3:解决()</h1><p id="29bc" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这段代码的输出是什么？</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="07c2" class="ne lk iq na b gy nf ng l nh ni">console.log('start'); </span><span id="2017" class="ne lk iq na b gy nk ng l nh ni">const promise1 = new Promise((resolve, reject) =&gt; {  <br/>  console.log(1)  <br/>  resolve(2)  <br/>  console.log(3)<br/>})</span><span id="99c6" class="ne lk iq na b gy nk ng l nh ni">promise1.then(res =&gt; {  <br/>  console.log(res)<br/>}) </span><span id="8109" class="ne lk iq na b gy nk ng l nh ni">console.log('end');</span></pre><p id="b906" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">请记住，resolve方法不会中断函数的执行。其背后的代码仍将继续执行。</p><blockquote class="nz oa ob"><p id="b49b" class="kn ko nj kp b kq kr jr ks kt ku ju kv oc kx ky kz od lb lc ld oe lf lg lh li ij bi translated"><strong class="kp ir">输出</strong>，所以输出结果为<code class="fe no np nq na b">start</code>、<code class="fe no np nq na b">1</code>、<code class="fe no np nq na b">3</code>、<code class="fe no np nq na b">end</code>和<code class="fe no np nq na b">2</code>。</p></blockquote><h1 id="e62f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战4:未调用resolve()</h1><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b1a5" class="ne lk iq na b gy nf ng l nh ni">console.log('start'); </span><span id="c249" class="ne lk iq na b gy nk ng l nh ni">const promise1 = new Promise((resolve, reject) =&gt; {  <br/>  console.log(1)<br/>}) </span><span id="1cdb" class="ne lk iq na b gy nk ng l nh ni">promise1.then(res =&gt; {  <br/>  console.log(2)<br/>})</span><span id="4d5b" class="ne lk iq na b gy nk ng l nh ni">console.log('end');</span></pre><p id="5195" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">resolve方法从未被调用过，所以<code class="fe no np nq na b">promise1</code>总是处于挂起状态。所以<code class="fe no np nq na b">promise1.then(…)</code>从来没有执行过。<code class="fe no np nq na b">2</code>不在控制台中打印出来。</p><blockquote class="nz oa ob"><p id="d061" class="kn ko nj kp b kq kr jr ks kt ku ju kv oc kx ky kz od lb lc ld oe lf lg lh li ij bi translated"><strong class="kp ir">，</strong>输出，所以结果是<code class="fe no np nq na b">start</code>，<code class="fe no np nq na b">1</code>，<code class="fe no np nq na b">end</code></p></blockquote><h1 id="b26e" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战5:让你困惑的那个</h1><p id="4bcc" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这段代码的输出是什么？</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="d443" class="ne lk iq na b gy nf ng l nh ni">console.log('start') </span><span id="d213" class="ne lk iq na b gy nk ng l nh ni">const fn = () =&gt; (new Promise((resolve, reject) =&gt; {   <br/>    console.log(1);  <br/>    resolve('success')<br/>})) </span><span id="f818" class="ne lk iq na b gy nk ng l nh ni">console.log('middle') </span><span id="bdbe" class="ne lk iq na b gy nk ng l nh ni">fn().then(res =&gt; {  <br/>   console.log(res)<br/>})<br/> <br/>console.log('end')</span></pre><p id="bc95" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这段代码故意加了一个函数来迷惑挑战者，那就是<code class="fe no np nq na b">fn</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/52f70eec0d528bf17d58113ceea56a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-9EHG-wcMhfO8mJF.png"/></div></div></figure><blockquote class="nz oa ob"><p id="9ef8" class="kn ko nj kp b kq kr jr ks kt ku ju kv oc kx ky kz od lb lc ld oe lf lg lh li ij bi translated"><strong class="kp ir">输出</strong>，所以结果是<code class="fe no np nq na b">start</code>、<code class="fe no np nq na b">middle</code>、<code class="fe no np nq na b">1</code>、<code class="fe no np nq na b">end</code>和<code class="fe no np nq na b">success</code>。</p></blockquote><h1 id="f198" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战7:超时与承诺</h1><p id="4c26" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这段代码的输出是什么？</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="3468" class="ne lk iq na b gy nf ng l nh ni">console.log('start') </span><span id="5ba9" class="ne lk iq na b gy nk ng l nh ni">setTimeout(() =&gt; {  <br/>  console.log('setTimeout')<br/>}) </span><span id="64a9" class="ne lk iq na b gy nk ng l nh ni">Promise.resolve().then(() =&gt; {  <br/>  console.log('resolve')<br/>}) </span><span id="0174" class="ne lk iq na b gy nk ng l nh ni">console.log('end')</span></pre><p id="a956" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是一个很难的问题。如果你能正确回答这个问题并解释原因，那么你对JavaScript异步编程的理解已经达到了中级水平。</p><p id="9a19" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在JavaScript EventLoop中，还有优先级的概念。</p><ul class=""><li id="92a9" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">优先级较高的任务称为微任务。包括:<code class="fe no np nq na b">Promise</code>、<code class="fe no np nq na b">ObjectObserver</code>、<code class="fe no np nq na b">MutationObserver</code>、<code class="fe no np nq na b">process.nextTick</code>、<code class="fe no np nq na b">async/await</code>。</li><li id="85ca" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">优先级较低的任务称为宏任务。包括:<code class="fe no np nq na b">setTimeout</code>、<code class="fe no np nq na b">setInterval</code>和<code class="fe no np nq na b">XHR</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/bd6940ddf5dfdee0debf6bea177079e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QQP0zjC_CGKrHgnm.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/c0ded8cc8b93b18fd12aa545d7324325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6yG9dzMaTvF2Jm0v.png"/></div></div></figure><blockquote class="nz oa ob"><p id="69ee" class="kn ko nj kp b kq kr jr ks kt ku ju kv oc kx ky kz od lb lc ld oe lf lg lh li ij bi translated"><strong class="kp ir">输出</strong>，所以结果是<code class="fe no np nq na b">start</code>、<code class="fe no np nq na b">end</code>、<code class="fe no np nq na b">resolve</code>和<code class="fe no np nq na b">setTimeout</code>。</p></blockquote><h1 id="6fec" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战8:微任务混合宏任务</h1><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="ec55" class="ne lk iq na b gy nf ng l nh ni">const promise = new Promise((resolve, reject) =&gt; {  <br/>  console.log(1);  <br/>  setTimeout(() =&gt; {    <br/>    console.log("timerStart");    <br/>    resolve("success");    <br/>    console.log("timerEnd");  <br/>  }, 0);  <br/>  console.log(2);<br/>}); </span><span id="9218" class="ne lk iq na b gy nk ng l nh ni">promise.then((res) =&gt; {  <br/>   console.log(res);<br/>}); </span><span id="dede" class="ne lk iq na b gy nk ng l nh ni">console.log(4);</span></pre><p id="98ca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们只需要做三步:</p><ol class=""><li id="e6a3" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li of mr ms mt bi translated">找到同步代码。</li><li id="3362" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">找到微任务代码</li><li id="0065" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">找到宏任务代码</li></ol><p id="e1d7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，执行同步代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/59bbf3640260ea2d6712aa8726e6e617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uAHKe0q_BahTWxd6.png"/></div></div></figure><p id="2804" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">输出<code class="fe no np nq na b">1</code>、<code class="fe no np nq na b">2</code>和<code class="fe no np nq na b">4</code>。</p><p id="bd4e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后执行微任务:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/79084445468ff2229344bf1f64c59ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y1Y5fw3QzgHx2MPc.png"/></div></div></figure><p id="f8be" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是这里有一个陷阱:由于当前的承诺仍然处于<strong class="kp ir">待定</strong>状态，这里的代码目前不会被执行。</p><p id="c101" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后执行宏任务:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/23d060ddf632bee514dba80b49bc3259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kgW8VDYuMcT3W9J5.png"/></div></div></figure><p id="c839" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后，通过事件循环，再次执行微任务:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/969ea99a8485e29251bb51913cbc5e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VK6THMtQ6LmEe_uu.png"/></div></div></figure><h1 id="1bf7" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战9:区分微任务和宏任务的优先级</h1><p id="ccec" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这段代码的输出是什么？</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="bc6a" class="ne lk iq na b gy nf ng l nh ni">const timer1 = setTimeout(() =&gt; {  <br/>  console.log('timer1');    </span><span id="7590" class="ne lk iq na b gy nk ng l nh ni">  promise1 = Promise.resolve().then(() =&gt; {   <br/>    console.log('promise1')  <br/>  })<br/>}, 0) </span><span id="a734" class="ne lk iq na b gy nk ng l nh ni">const timer2 = setTimeout(() =&gt; {  console.log('timer2')}, 0)</span></pre><p id="6907" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有些朋友可能认为微任务和宏任务是这样执行的:</p><ol class=""><li id="1d69" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li of mr ms mt bi translated">首先执行所有微任务</li><li id="76b1" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">执行所有宏任务</li><li id="30e6" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">再次执行所有微任务</li><li id="0678" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">循环通过</li></ol><p id="08da" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是上面的说法是<strong class="kp ir">错</strong>。</p><p id="bad9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正确的理解是:</p><ol class=""><li id="63bf" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li of mr ms mt bi translated">首先执行所有微任务</li><li id="b9ba" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">执行一个宏任务</li><li id="56d1" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">再次执行所有(新添加的)微任务</li><li id="789d" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">执行下一个宏任务</li><li id="f97e" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">循环通过</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d083ec841cd13a139ed9100e535e5eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*n4Cq7G8DOXV6yG2a.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/105ee911dd5a9ca12e0bbb5345314935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xxYTZybzX0mOgXLX.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/c5d62e904edcebaf0bde6563c2c4838d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AjCovdAMP7o6elQ4.png"/></div></div></figure><h1 id="f56d" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">挑战10:典型的面试问题</h1><p id="ed87" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">这是我们最后的挑战。如果你能正确说出这段代码的输出，那么你对Promise的理解已经很强了。而且同类型的面试问题不会对你有任何困扰。</p><p id="e6ec" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">记住我们之前学到的内容:</p><ol class=""><li id="e72e" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li of mr ms mt bi translated">同步代码</li><li id="638e" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">所有微任务</li><li id="3f28" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">第一个宏任务</li><li id="5aa4" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">所有新添加的微任务</li><li id="3fd4" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">下一个宏任务</li><li id="52f8" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi">…</li></ol><p id="1937" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以:</p><ol class=""><li id="e3cf" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li of mr ms mt bi translated">执行所有同步代码:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/a0f1f147ae0394f754f5c20d08d8b70c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JPM_TiD5lubgPWYG.png"/></div></div></figure><p id="aca1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">2.执行所有微任务</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/aaa84ce84c856cc9f1cabc702df27219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ugaUcOxlaMo4o1x.png"/></div></div></figure><p id="bebc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">3.执行第一个宏任务</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/cdac6f376211047f065352ca9c6dda27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lo_NnjRLLZvBYLus.png"/></div></div></figure><p id="7022" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">4.执行所有新添加的微任务</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/213c92ab5cca3d50271c9019bb54d9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Va4jNluhgf-UKcv_.png"/></div></div></figure><p id="c79a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">5.执行下一个宏任务</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ny"><img src="../Images/041c417299e27c21a455fe17fc47bbd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V6rf9XdWL92iT9jc.png"/></div></div></figure><h1 id="1f1a" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">结论</h1><p id="ef3c" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">对于所有类似的问题，你只需要记住三条规则:</p><ol class=""><li id="eac9" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li of mr ms mt bi translated">JavaScript引擎总是先执行同步代码，然后执行异步代码。</li><li id="ee1e" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">微任务比宏任务具有更高的优先级。</li><li id="a7f2" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li of mr ms mt bi translated">微任务可以在事件循环中插入行。</li></ol></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="3255" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">参考</strong>，</p><p id="fba7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我发现了一篇关于承诺的很棒的文章，把这些文章整理成一篇…这是一篇非常重要的文章，有助于理解在面试中被问到的承诺、填充和挑战。</p><p id="38ca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">-<a class="ae oh" href="https://towardsdev.com/6-promise-problems-that-front-end-engineers-should-master-for-interviews-8281848d7721" rel="noopener ugc nofollow" target="_blank">https://towardsdev . com/6-promise-problems-that-front-end-engineers-should-master-for-interview-8281848d 7721</a><br/>-<a class="ae oh" href="https://betterprogramming.pub/10-javascript-promise-challenges-before-you-start-an-interview-c9af8d4144ec" rel="noopener ugc nofollow" target="_blank">https://better programming . pub/10-JavaScript-promise-challenges-before-you-start-a-an-interview-c 9 af8d 4144 EC</a></p></div></div>    
</body>
</html>