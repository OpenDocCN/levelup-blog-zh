<html>
<head>
<title>An In-Depth Guide To AES Encryption With Angular Service Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AES加密与角度服务实现的深入指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-in-depth-guide-to-aes-encryption-with-angular-service-implementation-ebfeec3d6c63?source=collection_archive---------2-----------------------#2020-10-31">https://levelup.gitconnected.com/an-in-depth-guide-to-aes-encryption-with-angular-service-implementation-ebfeec3d6c63?source=collection_archive---------2-----------------------#2020-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ee4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">包括一些历史、机械理论和工作代码示例。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7429261e95c34e8392aa79bf5928aacb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ic-xWuMGiXsrDaCf.jpeg"/></div></div></figure><p id="3f79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi la translated">本文将介绍JavaScript中的高级加密标准(AES)。这篇文章是全面的，包括基本的历史，力学和工作代码的例子。</p><p id="13da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以自由地向下滚动到代码，而不需要阅读文章的其余部分，尽管我要说研究涉及的步骤将极大地提高您的理解！</p><p id="0201" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a117" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">关于AES的快速历史课</h1><p id="5eb6" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">你听说过Rijndael吗？嗯，它不是一个人——它是一套加密算法(但你当然知道)。在国家标准与技术研究所(NIST)的领导下，顶尖的科学家和数学家承担了提供确保数据传输完整性的数据传输方法的任务。</p><p id="fc8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Rijndael </strong> <strong class="js iu">算法</strong>是由比利时密码学家Vincent Rijman和Joan Daemon开发的——不知何故，Rijman+Daemon=Rijndael。</p><p id="cdad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">加密算法的主要目标是:</p><ol class=""><li id="9297" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated">保持对所有已知攻击的抵抗力</li><li id="ae1b" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated">各种计算平台上的速度和性能</li><li id="c3f9" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">设计简单</strong></li></ol><p id="437f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2001年11月，美国商务部长批准Rijndael算法在<em class="nh">联邦信息处理标准出版物</em>中合法化。虽然多年来许多加密算法已被弃用，但AES一直保持着强大的标准，通常用于工业和政府安全领域。</p><p id="3296" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到世界已经随着大数据和机器学习发生了多大的变化，AES仍然是高级加密标准，这是一个令人印象深刻的壮举。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="66f0" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">了解AES的基本步骤</h1><p id="34c8" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated"><strong class="js iu">免责声明:</strong>这些步骤大部分都是缩写的，意在传达重要的想法。如果你想要一个数学上严谨的解释，维基百科在这个话题上有很棒的解释。</p><p id="ec5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AES是一种对称算法，这意味着您可以加密和解密信息。AES由用作分组密码的128位数据块组成。回想一下，比特是信息的单一单位，通常是0或1。然后，这128位被分组为16个字节(每个字节8位)。然后，这16个字节被表示为一个二维数组，也称为矩阵表示。对于AES，这被称为当前“状态”。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/bc8c7d0bf9203a1debdd26c11d026c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*47hAFAyl2lvHR11RbbneGw.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">代表16字节信息的4x4矩阵</figcaption></figure><p id="4480" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AES允许密钥长度为128、192或256位。密钥只是一个随机生成的值。你可以用一整本书来讲述密钥是如何随机生成的，所以我们将跳过这里的细节。</p><p id="4368" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第一步是获取我们的消息并将其转换成字节表示。</strong></p><p id="d9d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">明文“这是一条秘密消息。”将由下面的标准UTF 8字节编码来表示。那就是用25个字节代表25个字符。</p><p id="8998" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">54 68 69 73 20 69 73 20 61 20 73 65 63 72 65 74 20 6d 65 73 73 73 61 67 65 2e</p><p id="b33a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">加密密钥也将以字节格式表示。</p><p id="e7b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面列出了AES加密算法的五个主要步骤。</p><ol class=""><li id="89d5" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated"><strong class="js iu">密钥扩展</strong> —我们的秘密密钥的一种派生，称为循环密钥，是使用AES密钥表从密码密钥中派生出来的。</li><li id="c2df" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">添加轮密钥</strong> —矩阵的每个字节与轮密钥的一个字节使用按位异或进行组合。</li><li id="ffb6" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">替换字节</strong> —一个替换步骤，根据查找表用另一个字节替换每个字节。</li><li id="7c4e" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">移位行</strong> —转置步骤，状态的最后三行循环移位一定的步数。</li><li id="7ad2" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">混合列</strong> —对矩阵的列进行混合操作，组合每列中的四个字节。</li></ol><p id="bfd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一步在算法开始时只发生一次。AES要求每轮加一个单独的128位轮密钥块。</p><p id="90e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据密钥的长度，步骤二到步骤五会重复多次。128位密钥有10轮，192位密钥有12轮，256位密钥有14轮。在最后一轮中，无论密钥大小如何，步骤5都被跳过，因为它不会给计算增加任何进一步的随机性(不要问我为什么)。</p><p id="4c50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在很高的层面上描述了AES是如何工作的。接下来描述每个步骤的进一步细节。</p><p id="6a2b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果你不熟悉XOR: </strong>两组字节之间的“异或”是一种逐位运算。如果在两次比较之间只有一位是值1，那么结果位也是值1。否则，它的值为0。例如:</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="25db" class="ns lr it no b gy nt nu l nv nw">An example XOR operation<br/>1 0 1 1 0 0 1 0<br/>0 1 0 1 0 0 1 1 XOR<br/>---------------<br/>1 1 1 0 0 0 0 1 Result</span></pre><h2 id="7b43" class="ns lr it bd ls nx ny dn lw nz oa dp ma kb ob oc me kf od oe mi kj of og mm oh bi translated">密钥扩展</h2><p id="71d4" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">从最复杂的一步开始。在这里，我们实际上是将我们的秘密密钥进行扩展，这样密钥的一部分可以在每一轮中使用。这种情况只发生一次，然后根据密钥大小重复以下步骤若干轮。</p><p id="3d3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给定我们的秘密密钥，我们以矩阵形式K得到它，元素k(0，0)到k(3，3)。下图中的上标代表我们处于哪一轮。对于第一轮，我们采用具有元素k(0，3)到k(3，3)的密钥矩阵的第四列，并将元素k(0，3)翻转到列(RotWord)的底部。所以我们得到的列是k(1，3)，k(2，3)，k(3，3)，k(0，3)。</p><p id="591e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们从表中替换该列的字节(子字，参见替换字节)。我们还有一个被称为Round Constants表(Rcon)的表，我们将把它与key列进行XOR运算。最后，我们与左边的第三列进行XOR运算，在本例中包含k(0，0)到k(3，0)。</p><p id="da8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在我们有一列的加扰字节。我们的密钥矩阵K有四列，所以接下来的三列通过XOR与它左边的第三列进行加扰。</p><p id="9829" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个过程重复所需的回合数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/f77439d30d745814ad2aa092cc6f38fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oeUc6XpdWcqH147m.png"/></div></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">来自<a class="ae oj" href="https://en.wikipedia.org/wiki/AES_key_schedule#/media/File:AES-Key_Schedule_128-bit_key.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><h2 id="1338" class="ns lr it bd ls nx ny dn lw nz oa dp ma kb ob oc me kf od oe mi kj of og mm oh bi translated">添加圆形密钥</h2><p id="b383" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">深呼吸，因为这一步很容易！在这里，我们使用上一步计算出的循环密钥，并将其与当前的分组密码进行异或运算。仅此而已！</p><h2 id="8810" class="ns lr it bd ls nx ny dn lw nz oa dp ma kb ob oc me kf od oe mi kj of og mm oh bi translated">替代字节</h2><p id="67e6" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">唷，简单的一步！我们在这里所做的就是从状态矩阵中取出每个单独的块，并从表中进行替换。给定128位分组密码，</p><p id="caa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">54 68 69 73 20 69 73 20 61 20 73 65 63 72 65 74 20 6d 65 73 73 73 61 67 65 2e</p><p id="7174" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们要替换的第一个字节是54。根据这个表，我们将简单地转到第5行和第4列来得到替换4C。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/65a9adf9b1666cb61dc58b5924f5bbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9d37HLI3J9JtEz_V.png"/></div></div></figure><p id="9a36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个表的方向的推理是由于一些概率魔术，我们将跳过。我们将用状态矩阵的所有16个字节来代替这一步。</p><h2 id="9977" class="ns lr it bd ls nx ny dn lw nz oa dp ma kb ob oc me kf od oe mi kj of og mm oh bi translated">移动行</h2><p id="2194" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这一步也很简单。我们只需根据每行的位置来移动它。第一行没有移位。第二行将每个元素向左移动一个块。第三行将每个元素向左移动两个块，第四行将每个元素向左移动三行。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/83017f695a4c71603ae0bcef80dd7862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*EF7s7O3HK8bvb0d8"/></div></figure><h2 id="6f42" class="ns lr it bd ls nx ny dn lw nz oa dp ma kb ob oc me kf od oe mi kj of og mm oh bi translated">混合列</h2><p id="4735" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">在这一步，我们使用一点矩阵数学和模运算。我们有一个状态矩阵A，它包含元素a(0，0)到a(3，3 ),将它乘以我们给定的矩阵，矩阵中充满了数字，意在将所有东西混在一起。得到的矩阵B将是混合列步骤的最终结果。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/fa2440f5c60541bbef0c307b7487529e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*se1thU219sahCxYZ"/></div></figure><p id="ec50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哇，你成功了！如果你更喜欢视觉学习，我发现下面的视频对理解AES加密算法非常有帮助。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="6fdd" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用TypeScript和Crypto-JS实现AES</h1><p id="b5a0" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">好吧，这就是你一直在等待的。没有更多的历史和理论，让我们得到一些代码！</p><p id="4f03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">开始一个新的角度项目。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="9f72" class="ns lr it no b gy nt nu l nv nw">$ ng new aes-app</span></pre><p id="9636" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继续操作，删除src/app/app.component.html下的所有模板代码。您可以在那里放置一个占位符，因为我们将重点关注服务实现。我们将把流程输出到控制台。我知道，有点脏——但我们只是要专注于AES。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/4c77bf145fc35e96227cb9b5ecc6c49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvh9fWxmjOI5bzaujhqT7Q.png"/></div></div></figure><p id="576f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个新的Angular服务并安装crypto-js。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="af25" class="ns lr it no b gy nt nu l nv nw">$ ng generate service encryption<br/>$ npm install crypto-js</span></pre><p id="3ec9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的加密服务将具有以下代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op on l"/></div></figure><p id="6a1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在以字节格式执行AES后，我们必须在第17行用标准的UTF-8编码转换回字符串。</p><p id="cbc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们可以进行一个简单的测试来输出我们的结果。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="op on l"/></div></figure><p id="3b5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行我们的测试，并在控制台日志中查看AES加密。</p><pre class="kp kq kr ks gt nn no np nq aw nr bi"><span id="edf5" class="ns lr it no b gy nt nu l nv nw">$ ng test --include='**/encryption.service.spec.ts'</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/42642dac3b798bb296f877beee93147b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d10iGPJbsiARncIU99QfKA.png"/></div></div></figure><p id="630c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该注意到，代码很简单！这就是为什么我认为至少了解通用加密库的基本机制是值得的。crypto-js库还包括一个可能的参数来包含一个初始化向量(IV ),尽管它在这里是自动包含的。如果你想看一个IV使用crypto-js的例子，请在下面留下评论，我很乐意发表一篇文章详细介绍如何做。感谢阅读！</p></div></div>    
</body>
</html>